<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ip: Linux ipv4 protocol implementation</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Linux ipv4 protocol implementation">
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">ip<small> (7)</small></h1>
        <p class="lead">Linux ipv4 protocol implementation</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/">
      <span itemprop="name">Miscellaneous</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/ip.7.html">
      <span itemprop="name">ip: Linux ipv4 protocol implementation</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/man-pages/">
      <span itemprop="name">man-pages</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man7/ip.7.html">
      <span itemprop="name">ip: Linux ipv4 protocol implementation</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<p><strong>#include &lt;sys/socket.h&gt;</strong></p>
<p class='spacer'>

<p><strong>#include &lt;netinet/in.h&gt;</strong></p>
<p class='spacer'>

<p><strong>#include &lt;netinet/ip.h&gt; /* superset of previous */</strong></p>
<p class='spacer'>

<p><em>tcp_socket</em><strong> = socket(AF_INET, SOCK_STREAM, 0);</strong></p>
<p class='spacer'>

<p><em>udp_socket</em><strong> = socket(AF_INET, SOCK_DGRAM, 0);</strong></p>
<p class='spacer'>

<p><em>raw_socket</em><strong> = socket(AF_INET, SOCK_RAW, </strong><em>protocol</em><strong>);</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">

<p>Linux implements the Internet Protocol, version 4, described in RFC&nbsp;791 and RFC&nbsp;1122. <strong>ip</strong> contains a level 2 multicasting implementation conforming to RFC&nbsp;1112. It also contains an IP router including a packet filter.</p>
<p class='spacer'>

<p>The programming interface is BSD-sockets compatible. For more information on sockets, see <a href="../man7/socket.7.html"><strong>socket</strong>(7)</a>.</p>
<p class='spacer'>

<p>An IP socket is created using <a href="../man2/socket.2.html"><strong>socket</strong>(2)</a>:</p>
<p class='spacer'>

<pre>    socket(AF_INET, socket_type, protocol);</pre>

<p class='spacer'>

<p>Valid socket types are <strong>SOCK_STREAM</strong> to open a <a href="../man7/tcp.7.html"><strong>tcp</strong>(7)</a> socket, <strong>SOCK_DGRAM</strong> to open a <a href="../man7/udp.7.html"><strong>udp</strong>(7)</a> socket, or <strong>SOCK_RAW</strong> to open a <a href="../man7/raw.7.html"><strong>raw</strong>(7)</a> socket to access the IP protocol directly. <em>protocol</em> is the IP protocol in the IP header to be received or sent. The only valid values for <em>protocol</em> are 0 and <strong>IPPROTO_TCP</strong> for TCP sockets, and 0 and <strong>IPPROTO_UDP</strong> for UDP sockets. For <strong>SOCK_RAW</strong> you may specify a valid IANA IP protocol defined in RFC&nbsp;1700 assigned numbers.</p>
<p class='spacer'>

<p>When a process wants to receive new incoming packets or connections, it should bind a socket to a local interface address using <a href="../man2/bind.2.html"><strong>bind</strong>(2)</a>. In this case, only one IP socket may be bound to any given local (address, port) pair. When <strong>INADDR_ANY</strong> is specified in the bind call, the socket will be bound to <em>all</em> local interfaces. When <a href="../man2/listen.2.html"><strong>listen</strong>(2)</a> is called on an unbound socket, the socket is automatically bound to a random free port with the local address set to <strong>INADDR_ANY</strong>. When <a href="../man2/connect.2.html"><strong>connect</strong>(2)</a> is called on an unbound socket, the socket is automatically bound to a random free port or to a usable shared port with the local address set to <strong>INADDR_ANY</strong>.</p>
<p class='spacer'>

<p>A TCP local socket address that has been bound is unavailable for some time after closing, unless the <strong>SO_REUSEADDR</strong> flag has been set. Care should be taken when using this flag as it makes TCP less reliable.</p>
  <h3>Address format</h3>
<p>An IP socket address is defined as a combination of an IP interface address and a 16-bit port number. The basic IP protocol does not supply port numbers, they are implemented by higher level protocols like <a href="../man7/udp.7.html"><strong>udp</strong>(7)</a> and <a href="../man7/tcp.7.html"><strong>tcp</strong>(7)</a>. On raw sockets <em>sin_port</em> is set to the IP protocol.</p>
<p class='spacer'>

<pre>struct sockaddr_in {
    sa_family_t    sin_family; /* address family: AF_INET */
    in_port_t      sin_port;   /* port in network byte order */
    struct in_addr sin_addr;   /* internet address */
};

/* Internet address. */
struct in_addr {
    uint32_t       s_addr;     /* address in network byte order */
};</pre>

<p class='spacer'>

<p><em>sin_family</em> is always set to <strong>AF_INET</strong>. This is required; in Linux 2.2 most networking functions return <strong>EINVAL</strong> when this setting is missing. <em>sin_port</em> contains the port in network byte order. The port numbers below 1024 are called <em>privileged ports</em> (or sometimes: <em>reserved ports</em>). Only privileged processes (i.e., those having the <strong>CAP_NET_BIND_SERVICE</strong> capability) may <a href="../man2/bind.2.html"><strong>bind</strong>(2)</a> to these sockets. Note that the raw IPv4 protocol as such has no concept of a port, they are implemented only by higher protocols like <a href="../man7/tcp.7.html"><strong>tcp</strong>(7)</a> and <a href="../man7/udp.7.html"><strong>udp</strong>(7)</a>.</p>
<p class='spacer'>

<p><em>sin_addr</em> is the IP host address. The <em>s_addr</em> member of <em>struct in_addr</em> contains the host interface address in network byte order. <em>in_addr</em> should be assigned one of the <strong>INADDR_*</strong> values (e.g., <strong>INADDR_ANY</strong>) or set using the <a href="../man3/inet_aton.3.html"><strong>inet_aton</strong>(3)</a>, <a href="../man3/inet_addr.3.html"><strong>inet_addr</strong>(3)</a>, <a href="../man3/inet_makeaddr.3.html"><strong>inet_makeaddr</strong>(3)</a> library functions or directly with the name resolver (see <a href="../man3/gethostbyname.3.html"><strong>gethostbyname</strong>(3)</a>).</p>
<p class='spacer'>

<p>IPv4 addresses are divided into unicast, broadcast and multicast addresses. Unicast addresses specify a single interface of a host, broadcast addresses specify all hosts on a network and multicast addresses address all hosts in a multicast group. Datagrams to broadcast addresses can be sent or received only when the <strong>SO_BROADCAST</strong> socket flag is set. In the current implementation, connection-oriented sockets are allowed to use only unicast addresses.</p>
<p class='spacer'>

<p>Note that the address and the port are always stored in network byte order. In particular, this means that you need to call <a href="../man3/htons.3.html"><strong>htons</strong>(3)</a> on the number that is assigned to a port. All address/port manipulation functions in the standard library work in network byte order.</p>
<p class='spacer'>

<p>There are several special addresses: <strong>INADDR_LOOPBACK</strong> (127.0.0.1) always refers to the local host via the loopback device; <strong>INADDR_ANY</strong> (0.0.0.0) means any address for binding; <strong>INADDR_BROADCAST</strong> (255.255.255.255) means any host and has the same effect on bind as <strong>INADDR_ANY</strong> for historical reasons.</p>
  <h3>Socket options</h3>
<p>IP supports some protocol-specific socket options that can be set with <a href="../man2/setsockopt.2.html"><strong>setsockopt</strong>(2)</a> and read with <a href="../man2/getsockopt.2.html"><strong>getsockopt</strong>(2)</a>. The socket option level for IP is <strong>IPPROTO_IP</strong>. A boolean integer flag is zero when it is false, otherwise true.</p>
<p class='spacer'>

  <p>When an invalid socket option is specified, <a href="../man2/getsockopt.2.html"><strong>getsockopt</strong>(2)</a> and <a href="../man2/setsockopt.2.html"><strong>setsockopt</strong>(2)</a> fail with the error <strong>ENOPROTOOPT</strong>.</p>
  <dl class='dl-vertical'>
    <dt><strong>IP_ADD_MEMBERSHIP</strong> (since Linux 1.2)</dt>
    <dd>
  <p>Join a multicast group. Argument is an <em>ip_mreqn</em> structure.</p>
<p class='spacer'>

<pre>struct ip_mreqn {
    struct in_addr imr_multiaddr; /* IP multicast group
                                     address */
    struct in_addr imr_address;   /* IP address of local
                                     interface */
    int            imr_ifindex;   /* interface index */
};</pre>

<p class='spacer'>

  <p><em>imr_multiaddr</em> contains the address of the multicast group the application wants to join or leave. It must be a valid multicast address (or <a href="../man2/setsockopt.2.html"><strong>setsockopt</strong>(2)</a> fails with the error <strong>EINVAL</strong>). <em>imr_address</em> is the address of the local interface with which the system should join the multicast group; if it is equal to <strong>INADDR_ANY</strong>, an appropriate interface is chosen by the system. <em>imr_ifindex</em> is the interface index of the interface that should join/leave the <em>imr_multiaddr</em> group, or 0 to indicate any interface.</p>
<p class='spacer'>

  <p>The <em>ip_mreqn</em> structure is available only since Linux 2.2. For compatibility, the old <em>ip_mreq</em> structure (present since Linux 1.2) is still supported; it differs from <em>ip_mreqn</em> only by not including the <em>imr_ifindex</em> field. (The kernel determines which structure is being passed based on the size passed in <em>optlen</em>.)</p>
<p class='spacer'>

  <p><strong>IP_ADD_MEMBERSHIP</strong> is valid only for <a href="../man2/setsockopt.2.html"><strong>setsockopt</strong>(2)</a>.</p>
    </dd>
    <dt><strong>IP_ADD_SOURCE_MEMBERSHIP</strong> (since Linux 2.4.22 / 2.5.68)</dt>
    <dd>
  <p>Join a multicast group and allow receiving data only from a specified source. Argument is an <em>ip_mreq_source</em> structure.</p>
<p class='spacer'>

<pre>struct ip_mreq_source {
    struct in_addr imr_multiaddr;  /* IP multicast group
                                      address */
    struct in_addr imr_interface;  /* IP address of local
                                      interface */
    struct in_addr imr_sourceaddr; /* IP address of
                                      multicast source */
};</pre>

<p class='spacer'>

  <p>The <em>ip_mreq_source</em> structure is similar to <em>ip_mreqn</em> described under <strong>IP_ADD_MEMBERSIP</strong>. The <em>imr_multiaddr</em> field contains the address of the multicast group the application wants to join or leave. The <em>imr_interface</em> field is the address of the local interface with which the system should join the multicast group. Finally, the <em>imr_sourceaddr</em> field contains the address of the source the application wants to receive data from.</p>
<p class='spacer'>

  <p>This option can be used multiple times to allow receiving data from more than one source.</p>
    </dd>
    <dt><strong>IP_BIND_ADDRESS_NO_PORT</strong> (since Linux 4.2)</dt>
    <dd>
  <p>Inform the kernel to not reserve an ephemeral port when using <a href="../man2/bind.2.html"><strong>bind</strong>(2)</a> with a port number of 0. The port will later be automatically chosen at <a href="../man2/connect.2.html"><strong>connect</strong>(2)</a> time, in a way that allows sharing a source port as long as the 4-tuple is unique.</p>
    </dd>
    <dt><strong>IP_BLOCK_SOURCE</strong> (since Linux 2.4.22 / 2.5.68)</dt>
    <dd>
  <p>Stop receiving multicast data from a specific source in a given group. This is valid only after the application has subscribed to the multicast group using either <strong>IP_ADD_MEMBERSHIP</strong> or <strong>IP_ADD_SOURCE_MEMBERSHIP</strong>.</p>
<p class='spacer'>

  <p>Argument is an <em>ip_mreq_source</em> structure as described under <strong>IP_ADD_SOURCE_MEMBERSHIP</strong>.</p>
    </dd>
    <dt><strong>IP_DROP_MEMBERSHIP</strong> (since Linux 1.2)</dt>
    <dd>
  <p>Leave a multicast group. Argument is an <em>ip_mreqn</em> or <em>ip_mreq</em> structure similar to <strong>IP_ADD_MEMBERSHIP</strong>.</p>
    </dd>
    <dt><strong>IP_DROP_SOURCE_MEMBERSHIP</strong> (since Linux 2.4.22 / 2.5.68)</dt>
    <dd>
  <p>Leave a source-specific group&ndash;that is, stop receiving data from a given multicast group that come from a given source. If the application has subscribed to multiple sources within the same group, data from the remaining sources will still be delivered. To stop receiving data from all sources at once, use <strong>IP_DROP_MEMBERSHIP</strong>.</p>
<p class='spacer'>

  <p>Argument is an <em>ip_mreq_source</em> structure as described under <strong>IP_ADD_SOURCE_MEMBERSHIP</strong>.</p>
    </dd>
    <dt><strong>IP_FREEBIND</strong> (since Linux 2.4)</dt>
    <dd>
  <p>If enabled, this boolean option allows binding to an IP address that is nonlocal or does not (yet) exist. This permits listening on a socket, without requiring the underlying network interface or the specified dynamic IP address to be up at the time that the application is trying to bind to it. This option is the per-socket equivalent of the <em>ip_nonlocal_bind</em> <em>/proc</em> interface described below.</p>
    </dd>
    <dt><strong>IP_HDRINCL</strong> (since Linux 2.0)</dt>
    <dd>
  <p>If enabled, the user supplies an IP header in front of the user data. Valid only for <strong>SOCK_RAW</strong> sockets; see <a href="../man7/raw.7.html"><strong>raw</strong>(7)</a> for more information. When this flag is enabled, the values set by <strong>IP_OPTIONS</strong>, <strong>IP_TTL</strong>, and <strong>IP_TOS</strong> are ignored.</p>
    </dd>
    <dt><strong>IP_MSFILTER</strong> (since Linux 2.4.22 / 2.5.68)</dt>
    <dd>
  <p>This option provides access to the advanced full-state filtering API. Argument is an <em>ip_msfilter</em> structure.</p>
<p class='spacer'>

<pre>struct ip_msfilter {
    struct in_addr imsf_multiaddr; /* IP multicast group
                                      address */
    struct in_addr imsf_interface; /* IP address of local
                                      interface */
    uint32_t       imsf_fmode;     /* Filter-mode */

    uint32_t       imsf_numsrc;    /* Number of sources in
                                      the following array */
    struct in_addr imsf_slist[1];  /* Array of source
                                      addresses */
};</pre>

<p class='spacer'>

  <p>There are two macros, <strong>MCAST_INCLUDE</strong> and <strong>MCAST_EXCLUDE</strong>, which can be used to specify the filtering mode. Additionally, the <strong>IP_MSFILTER_SIZE</strong>(n) macro exists to determine how much memory is needed to store <em>ip_msfilter</em> structure with <em>n</em> sources in the source list.</p>
<p class='spacer'>

  <p>For the full description of multicast source filtering refer to RFC 3376.</p>
    </dd>
    <dt><strong>IP_MTU</strong> (since Linux 2.2)</dt>
    <dd>
  <p>Retrieve the current known path MTU of the current socket. Returns an integer.</p>
<p class='spacer'>

  <p><strong>IP_MTU</strong> is valid only for <a href="../man2/getsockopt.2.html"><strong>getsockopt</strong>(2)</a> and can be employed only when the socket has been connected.</p>
    </dd>
    <dt><strong>IP_MTU_DISCOVER</strong> (since Linux 2.2)</dt>
    <dd>
  <p>Set or receive the Path MTU Discovery setting for a socket. When enabled, Linux will perform Path MTU Discovery as defined in RFC&nbsp;1191 on <strong>SOCK_STREAM</strong> sockets. For non-<strong>SOCK_STREAM</strong> sockets, <strong>IP_PMTUDISC_DO</strong> forces the don't-fragment flag to be set on all outgoing packets. It is the user's responsibility to packetize the data in MTU-sized chunks and to do the retransmits if necessary. The kernel will reject (with <strong>EMSGSIZE</strong>) datagrams that are bigger than the known path MTU. <strong>IP_PMTUDISC_WANT</strong> will fragment a datagram if needed according to the path MTU, or will set the don't-fragment flag otherwise.</p>
<p class='spacer'>

  <p>The system-wide default can be toggled between <strong>IP_PMTUDISC_WANT</strong> and <strong>IP_PMTUDISC_DONT</strong> by writing (respectively, zero and nonzero values) to the <em>/proc/sys/net/ipv4/ip_no_pmtu_disc</em> file.</p>
<table class="table table-striped">
<tr>
<th>Path MTU discovery value</th>
<th>Meaning</th></tr>

<tr>
<td>IP_PMTUDISC_WANT</td>
<td>Use per-route settings.</td></tr>

<tr>
<td>IP_PMTUDISC_DONT</td>
<td>Never do Path MTU Discovery.</td></tr>

<tr>
<td>IP_PMTUDISC_DO</td>
<td>Always do Path MTU Discovery.</td></tr>

<tr>
<td>IP_PMTUDISC_PROBE</td>
<td>Set DF but ignore Path MTU.</td></tr>
</table>

<p class='spacer'>

  <p>When PMTU discovery is enabled, the kernel automatically keeps track of the path MTU per destination host. When it is connected to a specific peer with <a href="../man2/connect.2.html"><strong>connect</strong>(2)</a>, the currently known path MTU can be retrieved conveniently using the <strong>IP_MTU</strong> socket option (e.g., after an <strong>EMSGSIZE</strong> error occurred). The path MTU may change over time. For connectionless sockets with many destinations, the new MTU for a given destination can also be accessed using the error queue (see <strong>IP_RECVERR</strong>). A new error will be queued for every incoming MTU update.</p>
<p class='spacer'>

  <p>While MTU discovery is in progress, initial packets from datagram sockets may be dropped. Applications using UDP should be aware of this and not take it into account for their packet retransmit strategy.</p>
<p class='spacer'>

  <p>To bootstrap the path MTU discovery process on unconnected sockets, it is possible to start with a big datagram size (up to 64K-headers bytes long) and let it shrink by updates of the path MTU.</p>
<p class='spacer'>

  <p>To get an initial estimate of the path MTU, connect a datagram socket to the destination address using <a href="../man2/connect.2.html"><strong>connect</strong>(2)</a> and retrieve the MTU by calling <a href="../man2/getsockopt.2.html"><strong>getsockopt</strong>(2)</a> with the <strong>IP_MTU</strong> option.</p>
<p class='spacer'>

  <p>It is possible to implement RFC 4821 MTU probing with <strong>SOCK_DGRAM</strong> or <strong>SOCK_RAW</strong> sockets by setting a value of <strong>IP_PMTUDISC_PROBE</strong> (available since Linux 2.6.22). This is also particularly useful for diagnostic tools such as <strong>tracepath</strong>(8) that wish to deliberately send probe packets larger than the observed Path MTU.</p>
    </dd>
    <dt><strong>IP_MULTICAST_ALL</strong> (since Linux 2.6.31)</dt>
    <dd>
  <p>This option can be used to modify the delivery policy of multicast messages to sockets bound to the wildcard <strong>INADDR_ANY</strong> address. The argument is a boolean integer (defaults to 1). If set to 1, the socket will receive messages from all the groups that have been joined globally on the whole system. Otherwise, it will deliver messages only from the groups that have been explicitly joined (for example via the <strong>IP_ADD_MEMBERSHIP</strong> option) on this particular socket.</p>
    </dd>
    <dt><strong>IP_MULTICAST_IF</strong> (since Linux 1.2)</dt>
    <dd>
  <p>Set the local device for a multicast socket. The argument for <a href="../man2/setsockopt.2.html"><strong>setsockopt</strong>(2)</a> is an <em>ip_mreqn</em> or (since Linux 3.5) <em>ip_mreq</em> structure similar to <strong>IP_ADD_MEMBERSHIP</strong>, or an <em>in_addr</em> structure. (The kernel determines which structure is being passed based on the size passed in <em>optlen</em>.) For <a href="../man2/getsockopt.2.html"><strong>getsockopt</strong>(2)</a>, the argument is an <em>in_addr</em> structure.</p>
    </dd>
    <dt><strong>IP_MULTICAST_LOOP</strong> (since Linux 1.2)</dt>
    <dd>
  <p>Set or read a boolean integer argument that determines whether sent multicast packets should be looped back to the local sockets.</p>
    </dd>
    <dt><strong>IP_MULTICAST_TTL</strong> (since Linux 1.2)</dt>
    <dd>
  <p>Set or read the time-to-live value of outgoing multicast packets for this socket. It is very important for multicast packets to set the smallest TTL possible. The default is 1 which means that multicast packets don't leave the local network unless the user program explicitly requests it. Argument is an integer.</p>
    </dd>
    <dt><strong>IP_NODEFRAG</strong> (since Linux 2.6.36)</dt>
    <dd>
  <p>If enabled (argument is nonzero), the reassembly of outgoing packets is disabled in the netfilter layer. The argument is an integer.</p>
<p class='spacer'>

  <p>This option is valid only for <strong>SOCK_RAW</strong> sockets.</p>
    </dd>
    <dt><strong>IP_OPTIONS</strong> (since Linux 2.0)</dt>
    <dd>
  <p>Set or get the IP options to be sent with every packet from this socket. The arguments are a pointer to a memory buffer containing the options and the option length. The <a href="../man2/setsockopt.2.html"><strong>setsockopt</strong>(2)</a> call sets the IP options associated with a socket. The maximum option size for IPv4 is 40 bytes. See RFC&nbsp;791 for the allowed options. When the initial connection request packet for a <strong>SOCK_STREAM</strong> socket contains IP options, the IP options will be set automatically to the options from the initial packet with routing headers reversed. Incoming packets are not allowed to change options after the connection is established. The processing of all incoming source routing options is disabled by default and can be enabled by using the <em>accept_source_route</em> <em>/proc</em> interface. Other options like timestamps are still handled. For datagram sockets, IP options can be only set by the local user. Calling <a href="../man2/getsockopt.2.html"><strong>getsockopt</strong>(2)</a> with <strong>IP_OPTIONS</strong> puts the current IP options used for sending into the supplied buffer.</p>
    </dd>
    <dt><strong>IP_PKTINFO</strong> (since Linux 2.2)</dt>
    <dd>
  <p>Pass an <strong>IP_PKTINFO</strong> ancillary message that contains a <em>pktinfo</em> structure that supplies some information about the incoming packet. This only works for datagram oriented sockets. The argument is a flag that tells the socket whether the <strong>IP_PKTINFO</strong> message should be passed or not. The message itself can only be sent/retrieved as control message with a packet using <a href="../man2/recvmsg.2.html"><strong>recvmsg</strong>(2)</a> or <a href="../man2/sendmsg.2.html"><strong>sendmsg</strong>(2)</a>.</p>
<p class='spacer'>

<pre>struct in_pktinfo {
    unsigned int   ipi_ifindex;  /* Interface index */
    struct in_addr ipi_spec_dst; /* Local address */
    struct in_addr ipi_addr;     /* Header Destination
                                    address */
};</pre>

<p class='spacer'>

  <p><em>ipi_ifindex</em> is the unique index of the interface the packet was received on. <em>ipi_spec_dst</em> is the local address of the packet and <em>ipi_addr</em> is the destination address in the packet header. If <strong>IP_PKTINFO</strong> is passed to <a href="../man2/sendmsg.2.html"><strong>sendmsg</strong>(2)</a> and <em>ipi_spec_dst</em> is not zero, then it is used as the local source address for the routing table lookup and for setting up IP source route options. When <em>ipi_ifindex</em> is not zero, the primary local address of the interface specified by the index overwrites <em>ipi_spec_dst</em> for the routing table lookup.</p>
    </dd>
    <dt><strong>IP_RECVERR</strong> (since Linux 2.2)</dt>
    <dd>
  <p>Enable extended reliable error message passing. When enabled on a datagram socket, all generated errors will be queued in a per-socket error queue. When the user receives an error from a socket operation, the errors can be received by calling <a href="../man2/recvmsg.2.html"><strong>recvmsg</strong>(2)</a> with the <strong>MSG_ERRQUEUE</strong> flag set. The <em>sock_extended_err</em> structure describing the error will be passed in an ancillary message with the type <strong>IP_RECVERR</strong> and the level <strong>IPPROTO_IP</strong>. This is useful for reliable error handling on unconnected sockets. The received data portion of the error queue contains the error packet.</p>
<p class='spacer'>

  <p>The <strong>IP_RECVERR</strong> control message contains a <em>sock_extended_err</em> structure:</p>
<p class='spacer'>

<pre>#define SO_EE_ORIGIN_NONE    0
#define SO_EE_ORIGIN_LOCAL   1
#define SO_EE_ORIGIN_ICMP    2
#define SO_EE_ORIGIN_ICMP6   3

struct sock_extended_err {
    uint32_t ee_errno;   /* error number */
    uint8_t  ee_origin;  /* where the error originated */
    uint8_t  ee_type;    /* type */
    uint8_t  ee_code;    /* code */
    uint8_t  ee_pad;
    uint32_t ee_info;    /* additional information */
    uint32_t ee_data;    /* other data */
    /* More data may follow */
};

struct sockaddr *SO_EE_OFFENDER(struct sock_extended_err *);</pre>

<p class='spacer'>

  <p><em>ee_errno</em> contains the <em>errno</em> number of the queued error. <em>ee_origin</em> is the origin code of where the error originated. The other fields are protocol-specific. The macro <strong>SO_EE_OFFENDER</strong> returns a pointer to the address of the network object where the error originated from given a pointer to the ancillary message. If this address is not known, the <em>sa_family</em> member of the <em>sockaddr</em> contains <strong>AF_UNSPEC</strong> and the other fields of the <em>sockaddr</em> are undefined.</p>
<p class='spacer'>

  <p>IP uses the <em>sock_extended_err</em> structure as follows: <em>ee_origin</em> is set to <strong>SO_EE_ORIGIN_ICMP</strong> for errors received as an ICMP packet, or <strong>SO_EE_ORIGIN_LOCAL</strong> for locally generated errors. Unknown values should be ignored. <em>ee_type</em> and <em>ee_code</em> are set from the type and code fields of the ICMP header. <em>ee_info</em> contains the discovered MTU for <strong>EMSGSIZE</strong> errors. The message also contains the <em>sockaddr_in of the node</em> caused the error, which can be accessed with the <strong>SO_EE_OFFENDER</strong> macro. The <em>sin_family</em> field of the <strong>SO_EE_OFFENDER</strong> address is <strong>AF_UNSPEC</strong> when the source was unknown. When the error originated from the network, all IP options (<strong>IP_OPTIONS</strong>, <strong>IP_TTL</strong>,  etc.) enabled on the socket and contained in the error packet are passed as control messages. The payload of the packet causing the error is returned as normal payload. Note that TCP has no error queue; <strong>MSG_ERRQUEUE</strong> is not permitted on <strong>SOCK_STREAM</strong> sockets. <strong>IP_RECVERR</strong> is valid for TCP, but all errors are returned by socket function return or <strong>SO_ERROR</strong> only.</p>
<p class='spacer'>

  <p>For raw sockets, <strong>IP_RECVERR</strong> enables passing of all received ICMP errors to the application, otherwise errors are only reported on connected sockets</p>
<p class='spacer'>

  <p>It sets or retrieves an integer boolean flag. <strong>IP_RECVERR</strong> defaults to off.</p>
    </dd>
    <dt><strong>IP_RECVOPTS</strong> (since Linux 2.2)</dt>
    <dd>
  <p>Pass all incoming IP options to the user in a <strong>IP_OPTIONS</strong> control message. The routing header and other options are already filled in for the local host. Not supported for <strong>SOCK_STREAM</strong> sockets.</p>
    </dd>
    <dt><strong>IP_RECVORIGDSTADDR</strong> (since Linux 2.6.29)</dt>
    <dd>
  <p>This boolean option enables the <strong>IP_ORIGDSTADDR</strong> ancillary message in <a href="../man2/recvmsg.2.html"><strong>recvmsg</strong>(2)</a>, in which the kernel returns the original destination address of the datagram being received. The ancillary message contains a <em>struct sockaddr_in</em>.</p>
    </dd>
    <dt><strong>IP_RECVTOS</strong> (since Linux 2.2)</dt>
    <dd>
  <p>If enabled, the <strong>IP_TOS</strong> ancillary message is passed with incoming packets. It contains a byte which specifies the Type of Service/Precedence field of the packet header. Expects a boolean integer flag.</p>
    </dd>
    <dt><strong>IP_RECVTTL</strong> (since Linux 2.2)</dt>
    <dd>
  <p>When this flag is set, pass a <strong>IP_TTL</strong> control message with the time-to-live field of the received packet as a byte. Not supported for <strong>SOCK_STREAM</strong> sockets.</p>
    </dd>
    <dt><strong>IP_RETOPTS</strong> (since Linux 2.2)</dt>
    <dd>
  <p>Identical to <strong>IP_RECVOPTS</strong>, but returns raw unprocessed options with timestamp and route record options not filled in for this hop.</p>
    </dd>
    <dt><strong>IP_ROUTER_ALERT</strong> (since Linux 2.2)</dt>
    <dd>
  <p>Pass all to-be forwarded packets with the IP Router Alert option set to this socket. Valid only for raw sockets. This is useful, for instance, for user-space RSVP daemons. The tapped packets are not forwarded by the kernel; it is the user's responsibility to send them out again. Socket binding is ignored, such packets are only filtered by protocol. Expects an integer flag.</p>
    </dd>
    <dt><strong>IP_TOS</strong> (since Linux 1.0)</dt>
    <dd>
  <p>Set or receive the Type-Of-Service (TOS) field that is sent with every IP packet originating from this socket. It is used to prioritize packets on the network. TOS is a byte. There are some standard TOS flags defined: <strong>IPTOS_LOWDELAY</strong> to minimize delays for interactive traffic, <strong>IPTOS_THROUGHPUT</strong> to optimize throughput, <strong>IPTOS_RELIABILITY</strong> to optimize for reliability, <strong>IPTOS_MINCOST</strong> should be used for "filler data" where slow transmission doesn't matter. At most one of these TOS values can be specified. Other bits are invalid and shall be cleared. Linux sends <strong>IPTOS_LOWDELAY</strong> datagrams first by default, but the exact behavior depends on the configured queueing discipline. Some high-priority levels may require superuser privileges (the <strong>CAP_NET_ADMIN</strong> capability).</p>
    </dd>
    <dt><strong>IP_TRANSPARENT</strong> (since Linux 2.6.24)</dt>
    <dd>
  <p>Setting this boolean option enables transparent proxying on this socket. This socket option allows the calling application to bind to a nonlocal IP address and operate both as a client and a server with the foreign address as the local endpoint. NOTE: this requires that routing be set up in a way that packets going to the foreign address are routed through the TProxy box (i.e., the system hosting the application that employs the <strong>IP_TRANSPARENT</strong> socket option). Enabling this socket option requires superuser privileges (the <strong>CAP_NET_ADMIN</strong> capability).</p>
<p class='spacer'>

  <p>TProxy redirection with the iptables TPROXY target also requires that this option be set on the redirected socket.</p>
    </dd>
    <dt><strong>IP_TTL</strong> (since Linux 1.0)</dt>
    <dd>
  <p>Set or retrieve the current time-to-live field that is used in every packet sent from this socket.</p>
    </dd>
    <dt><strong>IP_UNBLOCK_SOURCE</strong> (since Linux 2.4.22 / 2.5.68)</dt>
    <dd>
  <p>Unblock previously blocked multicast source. Returns <strong>EADDRNOTAVAIL</strong> when given source is not being blocked.</p>
<p class='spacer'>

  <p>Argument is an <em>ip_mreq_source</em> structure as described under <strong>IP_ADD_SOURCE_MEMBERSHIP</strong>.</p>
    </dd>
  </dl>
  <h3>/proc interfaces</h3>
  <p>The IP protocol supports a set of <em>/proc</em> interfaces to configure some global parameters. The parameters can be accessed by reading or writing files in the directory <em>/proc/sys/net/ipv4/</em>. Interfaces described as <em>Boolean</em> take an integer value, with a nonzero value ("true") meaning that the corresponding option is enabled, and a zero value ("false") meaning that the option is disabled.</p>
  <dl class='dl-vertical'>
    <dt><em>ip_always_defrag</em> (Boolean; since Linux 2.2.13)</dt>
    <dd>
  <p>[New with kernel 2.2.13; in earlier kernel versions this feature was controlled at compile time by the <strong>CONFIG_IP_ALWAYS_DEFRAG</strong> option; this option is not present in 2.4.x and later]</p>
<p class='spacer'>

  <p>When this boolean flag is enabled (not equal 0), incoming fragments (parts of IP packets that arose when some host between origin and destination decided that the packets were too large and cut them into pieces) will be reassembled (defragmented) before being processed, even if they are about to be forwarded.</p>
<p class='spacer'>

  <p>Only enable if running either a firewall that is the sole link to your network or a transparent proxy; never ever use it for a normal router or host. Otherwise, fragmented communication can be disturbed if the fragments travel over different links. Defragmentation also has a large memory and CPU time cost.</p>
<p class='spacer'>

  <p>This is automagically turned on when masquerading or transparent proxying are configured.</p>
    </dd>
    <dt><em>ip_autoconfig</em> (since Linux 2.2 to 2.6.17)</dt>
    <dd>
  <p>Not documented.</p>
    </dd>
    <dt><em>ip_default_ttl</em> (integer; default: 64; since Linux 2.2)</dt>
    <dd>
  <p>Set the default time-to-live value of outgoing packets. This can be changed per socket with the <strong>IP_TTL</strong> option.</p>
    </dd>
    <dt><em>ip_dynaddr</em> (Boolean; default: disabled; since Linux 2.0.31)</dt>
    <dd>
  <p>Enable dynamic socket address and masquerading entry rewriting on interface address change. This is useful for dialup interface with changing IP addresses. 0 means no rewriting, 1 turns it on and 2 enables verbose mode.</p>
    </dd>
    <dt><em>ip_forward</em> (Boolean; default: disabled; since Linux 1.2)</dt>
    <dd>
  <p>Enable IP forwarding with a boolean flag. IP forwarding can be also set on a per-interface basis.</p>
    </dd>
    <dt><em>ip_local_port_range</em> (since Linux 2.2)</dt>
    <dd>
      <p>This file contains two integers that define the default local port range allocated to sockets that are not explicitly bound to a port number&ndash;that is, the range used for <em>ephemeral ports</em>. An ephemeral port is allocated to a socket in the following circumstances:</p>
      <dl class='dl-horizontal'>
        <dt>*</dt>
        <dd>
      <p>the port number in a socket address is specified as 0 when calling <a href="../man2/bind.2.html"><strong>bind</strong>(2)</a>;</p>
        </dd>
        <dt>*</dt>
        <dd>
      <p><a href="../man2/listen.2.html"><strong>listen</strong>(2)</a> is called on a stream socket that was not previously bound;</p>
        </dd>
        <dt>*</dt>
        <dd>
      <p><a href="../man2/connect.2.html"><strong>connect</strong>(2)</a> was called on a socket that was not previously bound;</p>
        </dd>
        <dt>*</dt>
        <dd>
      <p><a href="../man2/sendto.2.html"><strong>sendto</strong>(2)</a> is called on a datagram socket that was not previously bound.</p>
        </dd>
      </dl>
<p class='spacer'>

  <p>Allocation of ephemeral ports starts with the first number in <em>ip_local_port_range</em> and ends with the second number. If the range of ephemeral ports is exhausted, then the relevant system call returns an error (but see BUGS).</p>
<p class='spacer'>

  <p>Note that the port range in <em>ip_local_port_range</em> should not conflict with the ports used by masquerading (although the case is handled). Also, arbitrary choices may cause problems with some firewall packet filters that make assumptions about the local ports in use. The first number should be at least greater than 1024, or better, greater than 4096, to avoid clashes with well known ports and to minimize firewall problems.</p>
    </dd>
    <dt><em>ip_no_pmtu_disc</em> (Boolean; default: disabled; since Linux 2.2)</dt>
    <dd>
  <p>If enabled, don't do Path MTU Discovery for TCP sockets by default. Path MTU discovery may fail if misconfigured firewalls (that drop all ICMP packets) or misconfigured interfaces (e.g., a point-to-point link where the both ends don't agree on the MTU) are on the path. It is better to fix the broken routers on the path than to turn off Path MTU Discovery globally, because not doing it incurs a high cost to the network.</p>
    </dd>
    <dt><em>ip_nonlocal_bind</em> (Boolean; default: disabled; since Linux 2.4)</dt>
    <dd>
  <p>If set, allows processes to <a href="../man2/bind.2.html"><strong>bind</strong>(2)</a> to nonlocal IP addresses, which can be quite useful, but may break some applications.</p>
    </dd>
    <dt><em>ip6frag_time</em> (integer; default: 30)</dt>
    <dd>
  <p>Time in seconds to keep an IPv6 fragment in memory.</p>
    </dd>
    <dt><em>ip6frag_secret_interval</em> (integer; default: 600)</dt>
    <dd>
  <p>Regeneration interval (in seconds) of the hash secret (or lifetime for the hash secret) for IPv6 fragments.</p>
    </dd>
    <dt><em>ipfrag_high_thresh</em> (integer), <em>ipfrag_low_thresh</em> (integer)</dt>
    <dd>
  <p>If the amount of queued IP fragments reaches <em>ipfrag_high_thresh</em>, the queue is pruned down to <em>ipfrag_low_thresh</em>. Contains an integer with the number of bytes.</p>
    </dd>
    <dt><em>neigh/*</em></dt>
    <dd>
  <p>See <a href="../man7/arp.7.html"><strong>arp</strong>(7)</a>.</p>
    </dd>
  </dl>
  <h3>Ioctls</h3>
<p>All ioctls described in <a href="../man7/socket.7.html"><strong>socket</strong>(7)</a> apply to <strong>ip</strong>.</p>
<p class='spacer'>

<p>Ioctls to configure generic device parameters are described in <a href="../man7/netdevice.7.html"><strong>netdevice</strong>(7)</a>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ERRORS</h2>
        <div class="sectioncontent">

  <dl class='dl-vertical'>
    <dt><strong>EACCES</strong></dt>
    <dd>
  <p>The user tried to execute an operation without the necessary permissions. These include: sending a packet to a broadcast address without having the <strong>SO_BROADCAST</strong> flag set; sending a packet via a <em>prohibit</em> route; modifying firewall settings without superuser privileges (the <strong>CAP_NET_ADMIN</strong> capability); binding to a privileged port without superuser privileges (the <strong>CAP_NET_BIND_SERVICE</strong> capability).</p>
    </dd>
    <dt><strong>EADDRINUSE</strong></dt>
    <dd>
  <p>Tried to bind to an address already in use.</p>
    </dd>
    <dt><strong>EADDRNOTAVAIL</strong></dt>
    <dd>
  <p>A nonexistent interface was requested or the requested source address was not local.</p>
    </dd>
    <dt><strong>EAGAIN</strong></dt>
    <dd>
  <p>Operation on a nonblocking socket would block.</p>
    </dd>
    <dt><strong>EALREADY</strong></dt>
    <dd>
  <p>A connection operation on a nonblocking socket is already in progress.</p>
    </dd>
    <dt><strong>ECONNABORTED</strong></dt>
    <dd>
  <p>A connection was closed during an <a href="../man2/accept.2.html"><strong>accept</strong>(2)</a>.</p>
    </dd>
    <dt><strong>EHOSTUNREACH</strong></dt>
    <dd>
  <p>No valid routing table entry matches the destination address. This error can be caused by a ICMP message from a remote router or for the local routing table.</p>
    </dd>
    <dt><strong>EINVAL</strong></dt>
    <dd>
  <p>Invalid argument passed. For send operations this can be caused by sending to a <em>blackhole</em> route.</p>
    </dd>
    <dt><strong>EISCONN</strong></dt>
    <dd>
  <p><a href="../man2/connect.2.html"><strong>connect</strong>(2)</a> was called on an already connected socket.</p>
    </dd>
    <dt><strong>EMSGSIZE</strong></dt>
    <dd>
  <p>Datagram is bigger than an MTU on the path and it cannot be fragmented.</p>
    </dd>
    <dt><strong>ENOBUFS</strong>, <strong>ENOMEM</strong></dt>
    <dd>
  <p>Not enough free memory. This often means that the memory allocation is limited by the socket buffer limits, not by the system memory, but this is not 100% consistent.</p>
    </dd>
    <dt><strong>ENOENT</strong></dt>
    <dd>
  <p><strong>SIOCGSTAMP</strong> was called on a socket where no packet arrived.</p>
    </dd>
    <dt><strong>ENOPKG</strong></dt>
    <dd>
  <p>A kernel subsystem was not configured.</p>
    </dd>
    <dt><strong>ENOPROTOOPT</strong> and <strong>EOPNOTSUPP</strong></dt>
    <dd>
  <p>Invalid socket option passed.</p>
    </dd>
    <dt><strong>ENOTCONN</strong></dt>
    <dd>
  <p>The operation is defined only on a connected socket, but the socket wasn't connected.</p>
    </dd>
    <dt><strong>EPERM</strong></dt>
    <dd>
  <p>User doesn't have permission to set high priority, change configuration, or send signals to the requested process or group.</p>
    </dd>
    <dt><strong>EPIPE</strong></dt>
    <dd>
  <p>The connection was unexpectedly closed or shut down by the other end.</p>
    </dd>
    <dt><strong>ESOCKTNOSUPPORT</strong></dt>
    <dd>
  <p>The socket is not configured or an unknown socket type was requested.</p>
    </dd>
  </dl>
<p class='spacer'>

<p>Other errors may be generated by the overlaying protocols; see <a href="../man7/tcp.7.html"><strong>tcp</strong>(7)</a>, <a href="../man7/raw.7.html"><strong>raw</strong>(7)</a>, <a href="../man7/udp.7.html"><strong>udp</strong>(7)</a>, and <a href="../man7/socket.7.html"><strong>socket</strong>(7)</a>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTES</h2>
        <div class="sectioncontent">

<p><strong>IP_FREEBIND</strong>, <strong>IP_MSFILTER</strong>, <strong>IP_MTU</strong>, <strong>IP_MTU_DISCOVER</strong>, <strong>IP_RECVORIGDSTADDR</strong>, <strong>IP_PKTINFO</strong>, <strong>IP_RECVERR</strong>, <strong>IP_ROUTER_ALERT</strong>, and <strong>IP_TRANSPARENT</strong> are Linux-specific.</p>
<p class='spacer'>

<p>Be very careful with the <strong>SO_BROADCAST</strong> option - it is not privileged in Linux. It is easy to overload the network with careless broadcasts. For new application protocols it is better to use a multicast group instead of broadcasting. Broadcasting is discouraged.</p>
<p class='spacer'>

<p>Some other BSD sockets implementations provide <strong>IP_RCVDSTADDR</strong> and <strong>IP_RECVIF</strong> socket options to get the destination address and the interface of received datagrams. Linux has the more general <strong>IP_PKTINFO</strong> for the same task.</p>
<p class='spacer'>

<p>Some BSD sockets implementations also provide an <strong>IP_RECVTTL</strong> option, but an ancillary message with type <strong>IP_RECVTTL</strong> is passed with the incoming packet. This is different from the <strong>IP_TTL</strong> option used in Linux.</p>
<p class='spacer'>

<p>Using <strong>SOL_IP</strong> socket options level isn't portable, BSD-based stacks use <strong>IPPROTO_IP</strong> level.</p>
  <h3>Compatibility</h3>
<p>For compatibility with Linux 2.0, the obsolete <strong>socket(AF_INET, SOCK_PACKET, </strong><em>protocol</em><strong>)</strong> syntax is still supported to open a <a href="../man7/packet.7.html"><strong>packet</strong>(7)</a> socket. This is deprecated and should be replaced by <strong>socket(AF_PACKET, SOCK_RAW, </strong><em>protocol</em><strong>)</strong> instead. The main difference is the new <em>sockaddr_ll</em> address structure for generic link layer information instead of the old <strong>sockaddr_pkt</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">

<p>There are too many inconsistent error values.</p>
<p class='spacer'>

<p>The error used to diagnose exhaustion of the ephemeral port range differs across the various system calls (<a href="../man2/connect.2.html"><strong>connect</strong>(2)</a>, <a href="../man2/bind.2.html"><strong>bind</strong>(2)</a>, <a href="../man2/listen.2.html"><strong>listen</strong>(2)</a>, <a href="../man2/sendto.2.html"><strong>sendto</strong>(2)</a>) that can assign ephemeral ports.</p>
<p class='spacer'>

<p>The ioctls to configure IP-specific interface options and ARP tables are not described.</p>
<p class='spacer'>

<p>Receiving the original destination address with <strong>MSG_ERRQUEUE</strong> in <em>msg_name</em> by <a href="../man2/recvmsg.2.html"><strong>recvmsg</strong>(2)</a> does not work in some 2.2 kernels.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO ip&hellip;</h2>
        <div class="sectioncontent">

<p><a href="../man2/recvmsg.2.html"><strong>recvmsg</strong>(2)</a>, <a href="../man2/sendmsg.2.html"><strong>sendmsg</strong>(2)</a>, <a href="../man3/byteorder.3.html"><strong>byteorder</strong>(3)</a>, <strong>ipfw</strong>(4), <a href="../man7/capabilities.7.html"><strong>capabilities</strong>(7)</a>, <a href="../man7/icmp.7.html"><strong>icmp</strong>(7)</a>, <a href="../man7/ipv6.7.html"><strong>ipv6</strong>(7)</a>, <a href="../man7/netlink.7.html"><strong>netlink</strong>(7)</a>, <a href="../man7/raw.7.html"><strong>raw</strong>(7)</a>, <a href="../man7/socket.7.html"><strong>socket</strong>(7)</a>, <a href="../man7/tcp.7.html"><strong>tcp</strong>(7)</a>, <a href="../man7/udp.7.html"><strong>udp</strong>(7)</a></p>
<p class='spacer'>

<p>RFC&nbsp;791 for the original IP specification. RFC&nbsp;1122 for the IPv4 host requirements. RFC&nbsp;1812 for the IPv4 router requirements.</p>
        </div>
      </section>

<nav>
  <ul class="pager">
   <li class="previous"><a href="intro.7.html"><span aria-hidden="true">&larr;</span> intro.7: Introduction to overview, conventions, and miscellany section</a></li>
   <li class="next"><a href="ipv6.7.html">ipv6.7: Linux ipv6 protocol implementation <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

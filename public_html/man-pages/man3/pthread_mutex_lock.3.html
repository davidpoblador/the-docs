<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>pthread_mutex_lock - operations on mutexes</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Operations on mutexes">
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">pthread_mutex_lock<small> (3)</small></h1>
        <p class="lead">Operations on mutexes</p>
      </div>

    <ol class="breadcrumb">
	<li itemscope itemtype="http://data-vocabulary.org/Breadcrumb" itemref="breadcrumb_section">
		<a itemprop="url" href="/"><span itemprop="title">Carta.tech</span></a>
	</li>
	<li itemscope itemtype="http://data-vocabulary.org/Breadcrumb" itemref="breadcrumb_section">
		<a itemprop="url" href="https://www.carta.tech/man-pages/"><span itemprop="title">Man Pages</span></a>
	</li>
	<li id="breadcrumb_section" itemscope itemtype="http://data-vocabulary.org/Breadcrumb" itemref="breadcrumb_page" itemprop="child">
		<a itemprop="url" href="https://www.carta.tech/man-pages/man3/"><span itemprop="title">Library calls</span></a>
	</li>
	<li id="breadcrumb_page" itemscope itemtype="http://data-vocabulary.org/Breadcrumb" itemprop="child" class="active">
		<a itemprop="url" href="https://www.carta.tech/man-pages/man3/pthread_mutex_lock.3.html"><span itemprop="title">pthread_mutex_lock</span></a>
	</li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<p><strong>#include &lt;pthread.h&gt;</strong></p>
<p class='spacer'>

<p><strong>pthread_mutex_t </strong><em>fastmutex</em><strong> = PTHREAD_MUTEX_INITIALIZER;</strong></p>
<p class='spacer'>

<p><strong>pthread_mutex_t </strong><em>recmutex</em><strong> = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;</strong></p>
<p class='spacer'>

<p><strong>pthread_mutex_t </strong><em>errchkmutex</em><strong> = PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP;</strong></p>
<p class='spacer'>

<p><strong>int pthread_mutex_init(pthread_mutex_t *</strong><em>mutex</em><strong>, const pthread_mutexattr_t *</strong><em>mutexattr</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>int pthread_mutex_lock(pthread_mutex_t *</strong><em>mutex</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>int pthread_mutex_trylock(pthread_mutex_t *</strong><em>mutex</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>int pthread_mutex_unlock(pthread_mutex_t *</strong><em>mutex</em><strong>);</strong></p>
<p class='spacer'>

<p><strong>int pthread_mutex_destroy(pthread_mutex_t *</strong><em>mutex</em><strong>);</strong></p>
<p class='spacer'>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">

<p>A mutex is a MUTual EXclusion device, and is useful for protecting shared data structures from concurrent modifications, and implementing critical sections and monitors.</p>
<p class='spacer'>

<p>A mutex has two possible states: unlocked (not owned by any thread), and locked (owned by one thread). A mutex can never be owned by two different threads simultaneously. A thread attempting to lock a mutex that is already locked by another thread is suspended until the owning thread unlocks the mutex first.</p>
<p class='spacer'>

<p><strong>pthread_mutex_init</strong> initializes the mutex object pointed to by <em>mutex</em> according to the mutex attributes specified in <em>mutexattr</em>. If <em>mutexattr</em> is <strong>NULL</strong>, default attributes are used instead.</p>
<p class='spacer'>

<p>The LinuxThreads implementation supports only one mutex attributes, the <em>mutex kind</em>, which is either ``fast'', ``recursive'', or ``error checking''. The kind of a mutex determines whether it can be locked again by a thread that already owns it. The default kind is ``fast''. See <a href="../man3/pthread_mutexattr_init.3.html"><strong>pthread_mutexattr_init</strong>(3)</a> for more information on mutex attributes.</p>
<p class='spacer'>

<p>Variables of type <strong>pthread_mutex_t</strong> can also be initialized statically, using the constants <strong>PTHREAD_MUTEX_INITIALIZER</strong> (for fast mutexes), <strong>PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP</strong> (for recursive mutexes), and <strong>PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP</strong> (for error checking mutexes).</p>
<p class='spacer'>

<p><strong>pthread_mutex_lock</strong> locks the given mutex. If the mutex is currently unlocked, it becomes locked and owned by the calling thread, and <strong>pthread_mutex_lock</strong> returns immediately. If the mutex is already locked by another thread, <strong>pthread_mutex_lock</strong> suspends the calling thread until the mutex is unlocked.</p>
<p class='spacer'>

<p>If the mutex is already locked by the calling thread, the behavior of <strong>pthread_mutex_lock</strong> depends on the kind of the mutex. If the mutex is of the ``fast'' kind, the calling thread is suspended until the mutex is unlocked, thus effectively causing the calling thread to deadlock. If the mutex is of the ``error checking'' kind, <strong>pthread_mutex_lock</strong> returns immediately with the error code <strong>EDEADLK</strong>. If the mutex is of the ``recursive'' kind, <strong>pthread_mutex_lock</strong> succeeds and returns immediately, recording the number of times the calling thread has locked the mutex. An equal number of <strong>pthread_mutex_unlock</strong> operations must be performed before the mutex returns to the unlocked state.</p>
<p class='spacer'>

<p><strong>pthread_mutex_trylock</strong> behaves identically to <strong>pthread_mutex_lock</strong>, except that it does not block the calling thread if the mutex is already locked by another thread (or by the calling thread in the case of a ``fast'' mutex). Instead, <strong>pthread_mutex_trylock</strong> returns immediately with the error code <strong>EBUSY</strong>.</p>
<p class='spacer'>

<p><strong>pthread_mutex_unlock</strong> unlocks the given mutex. The mutex is assumed to be locked and owned by the calling thread on entrance to <strong>pthread_mutex_unlock</strong>. If the mutex is of the ``fast'' kind, <strong>pthread_mutex_unlock</strong> always returns it to the unlocked state. If it is of the ``recursive'' kind, it decrements the locking count of the mutex (number of <strong>pthread_mutex_lock</strong> operations performed on it by the calling thread), and only when this count reaches zero is the mutex actually unlocked.</p>
<p class='spacer'>

<p>On ``error checking'' and ``recursive'' mutexes, <strong>pthread_mutex_unlock</strong> actually checks at run-time that the mutex is locked on entrance, and that it was locked by the same thread that is now calling <strong>pthread_mutex_unlock</strong>.  If these conditions are not met, an error code is returned and the mutex remains unchanged.  ``Fast'' mutexes perform no such checks, thus allowing a locked mutex to be unlocked by a thread other than its owner. This is non-portable behavior and must not be relied upon.</p>
<p class='spacer'>

<p><strong>pthread_mutex_destroy</strong> destroys a mutex object, freeing the resources it might hold. The mutex must be unlocked on entrance. In the LinuxThreads implementation, no resources are associated with mutex objects, thus <strong>pthread_mutex_destroy</strong> actually does nothing except checking that the mutex is unlocked.</p>
<p class='spacer'>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CANCELLATION</h2>
        <div class="sectioncontent">

<p class='spacer'>

<p>None of the mutex functions is a cancellation point, not even <strong>pthread_mutex_lock</strong>, in spite of the fact that it can suspend a thread for arbitrary durations. This way, the status of mutexes at cancellation points is predictable, allowing cancellation handlers to unlock precisely those mutexes that need to be unlocked before the thread stops executing. Consequently, threads using deferred cancellation should never hold a mutex for extended periods of time.</p>
<p class='spacer'>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ASYNC-SIGNAL SAFETY</h2>
        <div class="sectioncontent">

<p class='spacer'>

<p>The mutex functions are not async-signal safe. What this means is that they should not be called from a signal handler. In particular, calling <strong>pthread_mutex_lock</strong> or <strong>pthread_mutex_unlock</strong> from a signal handler may deadlock the calling thread.</p>
<p class='spacer'>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">

<p class='spacer'>

<p><strong>pthread_mutex_init</strong> always returns 0. The other mutex functions return 0 on success and a non-zero error code on error.</p>
<p class='spacer'>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ERRORS</h2>
        <div class="sectioncontent">

<p class='spacer'>

    <p>The <strong>pthread_mutex_lock</strong> function returns the following error code on error:</p>
    <dl class='dl-vertical'>
      <dt><strong>EINVAL</strong></dt>
      <dd>
    <p>the mutex has not been properly initialized.</p>
<p class='spacer'>

      </dd>
      <dt><strong>EDEADLK</strong></dt>
      <dd>
    <p>the mutex is already locked by the calling thread (``error checking'' mutexes only).</p>
      </dd>
    </dl>
<p class='spacer'>

    <p>The <strong>pthread_mutex_trylock</strong> function returns the following error codes on error:</p>
    <dl class='dl-vertical'>
      <dt><strong>EBUSY</strong></dt>
      <dd>
    <p>the mutex could not be acquired because it was currently locked.</p>
<p class='spacer'>

      </dd>
      <dt><strong>EINVAL</strong></dt>
      <dd>
    <p>the mutex has not been properly initialized.</p>
      </dd>
    </dl>
<p class='spacer'>

    <p>The <strong>pthread_mutex_unlock</strong> function returns the following error code on error:</p>
    <dl class='dl-vertical'>
      <dt><strong>EINVAL</strong></dt>
      <dd>
    <p>the mutex has not been properly initialized.</p>
<p class='spacer'>

      </dd>
      <dt><strong>EPERM</strong></dt>
      <dd>
    <p>the calling thread does not own the mutex (``error checking'' mutexes only).</p>
      </dd>
    </dl>
<p class='spacer'>

    <p>The <strong>pthread_mutex_destroy</strong> function returns the following error code on error:</p>
    <dl class='dl-vertical'>
      <dt><strong>EBUSY</strong></dt>
      <dd>
    <p>the mutex is currently locked.</p>
      </dd>
    </dl>
<p class='spacer'>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">

<p>Xavier Leroy &lt;Xavier.Leroy@inria.fr&gt;</p>
<p class='spacer'>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SEE ALSO</h2>
        <div class="sectioncontent">

<p><a href="../man3/pthread_mutexattr_init.3.html"><strong>pthread_mutexattr_init</strong>(3)</a>, <a href="../man3/pthread_mutexattr_setkind_np.3.html"><strong>pthread_mutexattr_setkind_np</strong>(3)</a>, <a href="../man3/pthread_cancel.3.html"><strong>pthread_cancel</strong>(3)</a>.</p>
<p class='spacer'>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLE</h2>
        <div class="sectioncontent">

<p class='spacer'>

<p>A shared global variable <em>x</em> can be protected by a mutex as follows:</p>
<p class='spacer'>

<pre>
int x;
pthread_mutex_t mut = PTHREAD_MUTEX_INITIALIZER;
</pre>

<p class='spacer'>

<p>All accesses and modifications to <em>x</em> should be bracketed by calls to <strong>pthread_mutex_lock</strong> and <strong>pthread_mutex_unlock</strong> as follows:</p>
<p class='spacer'>

<pre>
pthread_mutex_lock(&mut);
/* operate on x */
pthread_mutex_unlock(&mut);
</pre>

<p class='spacer'>

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="pthread_mutex_init.3.html"><span aria-hidden="true">&larr;</span> pthread_mutex_init.3: operations on mutexes</a></li>
   <li class="next"><a href="pthread_mutex_trylock.3.html">pthread_mutex_trylock.3: operations on mutexes <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>pcrejit: Perl-compatible regular expressions</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Perl-compatible regular expressions">
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">pcrejit<small> (3)</small></h1>
        <p class="lead">Perl-compatible regular expressions</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/pcrejit.3.html">
      <span itemprop="name">pcrejit: Perl-compatible regular expressions</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/mariadb/">
      <span itemprop="name">mariadb</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/pcrejit.3.html">
      <span itemprop="name">pcrejit: Perl-compatible regular expressions</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">PCRE JUST-IN-TIME COMPILER SUPPORT</h2>
        <div class="sectioncontent">
<p>Just-in-time compiling is a heavyweight optimization that can greatly speed up pattern matching. However, it comes at the cost of extra processing before the match is performed. Therefore, it is of most benefit when the same pattern is going to be matched many times. This does not necessarily mean many calls of a matching function; if the pattern is not anchored, matching attempts may take place many times at various positions in the subject, even for a single call. Therefore, if the subject string is very long, it may still pay to use JIT for one-off matches.</p><p>JIT support applies only to the traditional Perl-compatible matching function. It does not apply when the DFA matching function is being used. The code for this support was written by Zoltan Herczeg.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">8-BIT, 16-BIT AND 32-BIT SUPPORT</h2>
        <div class="sectioncontent">
<p>JIT support is available for all of the 8-bit, 16-bit and 32-bit PCRE libraries. To keep this documentation simple, only the 8-bit interface is described in what follows. If you are using the 16-bit library, substitute the 16-bit functions and 16-bit structures (for example, <em>pcre16_jit_stack</em> instead of <em>pcre_jit_stack</em>). If you are using the 32-bit library, substitute the 32-bit functions and 32-bit structures (for example, <em>pcre32_jit_stack</em> instead of <em>pcre_jit_stack</em>).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AVAILABILITY OF JIT SUPPORT</h2>
        <div class="sectioncontent">
<p>JIT support is an optional feature of PCRE. The "configure" option --enable-jit (or equivalent CMake option) must be set when PCRE is built if you want to use JIT. The support is limited to the following hardware platforms:</p>
<pre>
  ARM v5, v7, and Thumb2
  Intel x86 32-bit and 64-bit
  MIPS 32-bit
  Power PC 32-bit and 64-bit
  SPARC 32-bit (experimental)
</pre>
<p>If --enable-jit is set on an unsupported platform, compilation fails.</p><p>A program that is linked with PCRE 8.20 or later can tell if JIT support is available by calling <strong>pcre_config()</strong> with the PCRE_CONFIG_JIT option. The result is 1 when JIT is available, and 0 otherwise. However, a simple program does not need to check this in order to use JIT. The normal API is implemented in a way that falls back to the interpretive code if JIT is not available. For programs that need the best possible performance, there is also a "fast path" API that is JIT-specific.</p><p>If your program may sometimes be linked with versions of PCRE that are older than 8.20, but you want to use JIT when it is available, you can test the values of PCRE_MAJOR and PCRE_MINOR, or the existence of a JIT macro such as PCRE_CONFIG_JIT, for compile-time control of your code.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SIMPLE USE OF JIT</h2>
        <div class="sectioncontent">
<p>You have to do two things to make use of the JIT support in the simplest way:</p>
<pre>
  (1) Call <strong>pcre_study()</strong> with the PCRE_STUDY_JIT_COMPILE option for
      each compiled pattern, and pass the resulting <strong>pcre_extra</strong> block to
      <strong>pcre_exec()</strong>.
</pre>

<pre>
  (2) Use <strong>pcre_free_study()</strong> to free the <strong>pcre_extra</strong> block when it is
      no longer needed, instead of just freeing it yourself. This ensures that
      any JIT data is also freed.
</pre>
<p>For a program that may be linked with pre-8.20 versions of PCRE, you can insert</p>
<pre>
  #ifndef PCRE_STUDY_JIT_COMPILE
  #define PCRE_STUDY_JIT_COMPILE 0
  #endif
</pre>
<p>so that no option is passed to <strong>pcre_study()</strong>, and then use something like this to free the study data:</p>
<pre>
  #ifdef PCRE_CONFIG_JIT
      pcre_free_study(study_ptr);
  #else
      pcre_free(study_ptr);
  #endif
</pre>
<p>PCRE_STUDY_JIT_COMPILE requests the JIT compiler to generate code for complete matches. If you want to run partial matches using the PCRE_PARTIAL_HARD or PCRE_PARTIAL_SOFT options of <strong>pcre_exec()</strong>, you should set one or both of the following options in addition to, or instead of, PCRE_STUDY_JIT_COMPILE when you call <strong>pcre_study()</strong>:</p>
<pre>
  PCRE_STUDY_JIT_PARTIAL_HARD_COMPILE
  PCRE_STUDY_JIT_PARTIAL_SOFT_COMPILE
</pre>
<p>The JIT compiler generates different optimized code for each of the three modes (normal, soft partial, hard partial). When <strong>pcre_exec()</strong> is called, the appropriate code is run if it is available. Otherwise, the pattern is matched using interpretive code.</p><p>In some circumstances you may need to call additional functions. These are described in the section entitled "Controlling the JIT stack" below.</p><p>If JIT support is not available, PCRE_STUDY_JIT_COMPILE etc. are ignored, and no JIT data is created. Otherwise, the compiled pattern is passed to the JIT compiler, which turns it into machine code that executes much faster than the normal interpretive code. When <strong>pcre_exec()</strong> is passed a <strong>pcre_extra</strong> block containing a pointer to JIT code of the appropriate mode (normal or hard/soft partial), it obeys that code instead of running the interpreter. The result is identical, but the compiled JIT code runs much faster.</p><p>There are some <strong>pcre_exec()</strong> options that are not supported for JIT execution. There are also some pattern items that JIT cannot handle. Details are given below. In both cases, execution automatically falls back to the interpretive code. If you want to know whether JIT was actually used for a particular match, you should arrange for a JIT callback function to be set up as described in the section entitled "Controlling the JIT stack" below, even if you do not need to supply a non-default JIT stack. Such a callback function is called whenever JIT code is about to be obeyed. If the execution options are not right for JIT execution, the callback function is not obeyed.</p><p>If the JIT compiler finds an unsupported item, no JIT data is generated. You can find out if JIT execution is available after studying a pattern by calling <strong>pcre_fullinfo()</strong> with the PCRE_INFO_JIT option. A result of 1 means that JIT compilation was successful. A result of 0 means that JIT support is not available, or the pattern was not studied with PCRE_STUDY_JIT_COMPILE etc., or the JIT compiler was not able to handle the pattern.</p><p>Once a pattern has been studied, with or without JIT, it can be used as many times as you like for matching different subject strings.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">UNSUPPORTED OPTIONS AND PATTERN ITEMS</h2>
        <div class="sectioncontent">
<p>The only <strong>pcre_exec()</strong> options that are supported for JIT execution are PCRE_NO_UTF8_CHECK, PCRE_NO_UTF16_CHECK, PCRE_NO_UTF32_CHECK, PCRE_NOTBOL, PCRE_NOTEOL, PCRE_NOTEMPTY, PCRE_NOTEMPTY_ATSTART, PCRE_PARTIAL_HARD, and PCRE_PARTIAL_SOFT.</p><p>The only unsupported pattern items are &#92;C (match a single data unit) when running in a UTF mode, and a callout immediately before an assertion condition in a conditional group.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUES FROM JIT EXECUTION</h2>
        <div class="sectioncontent">
<p>When a pattern is matched using JIT execution, the return values are the same as those given by the interpretive <strong>pcre_exec()</strong> code, with the addition of one new error code: PCRE_ERROR_JIT_STACKLIMIT. This means that the memory used for the JIT stack was insufficient. See "Controlling the JIT stack" below for a discussion of JIT stack usage. For compatibility with the interpretive <strong>pcre_exec()</strong> code, no more than two-thirds of the <em>ovector</em> argument is used for passing back captured substrings.</p><p>The error code PCRE_ERROR_MATCHLIMIT is returned by the JIT code if searching a very large pattern tree goes on for too long, as it is in the same circumstance when JIT is not used, but the details of exactly what is counted are not the same. The PCRE_ERROR_RECURSIONLIMIT error code is never returned by JIT execution.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SAVING AND RESTORING COMPILED PATTERNS</h2>
        <div class="sectioncontent">
<p>The code that is generated by the JIT compiler is architecture-specific, and is also position dependent. For those reasons it cannot be saved (in a file or database) and restored later like the bytecode and other data of a compiled pattern. Saving and restoring compiled patterns is not something many people do. More detail about this facility is given in the <strong>pcreprecompile</strong> documentation. It should be possible to run <strong>pcre_study()</strong> on a saved and restored pattern, and thereby recreate the JIT data, but because JIT compilation uses significant resources, it is probably not worth doing this; you might as well recompile the original pattern.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONTROLLING THE JIT STACK</h2>
        <div class="sectioncontent">
<p>When the compiled JIT code runs, it needs a block of memory to use as a stack. By default, it uses 32K on the machine stack. However, some large or complicated patterns need more than this. The error PCRE_ERROR_JIT_STACKLIMIT is given when there is not enough stack. Three functions are provided for managing blocks of memory for use as JIT stacks. There is further discussion about the use of JIT stacks in the section entitled "JIT stack FAQ" below.</p><p>The <strong>pcre_jit_stack_alloc()</strong> function creates a JIT stack. Its arguments are a starting size and a maximum size, and it returns a pointer to an opaque structure of type <strong>pcre_jit_stack</strong>, or NULL if there is an error. The <strong>pcre_jit_stack_free()</strong> function can be used to free a stack that is no longer needed. (For the technically minded: the address space is allocated by mmap or VirtualAlloc.)</p><p>JIT uses far less memory for recursion than the interpretive code, and a maximum stack size of 512K to 1M should be more than enough for any pattern.</p><p>The <strong>pcre_assign_jit_stack()</strong> function specifies which stack JIT code should use. Its arguments are as follows:</p>
<pre>
  pcre_extra         *extra
  pcre_jit_callback  callback
  void               *data
</pre>
<p>The <em>extra</em> argument must be the result of studying a pattern with PCRE_STUDY_JIT_COMPILE etc. There are three cases for the values of the other two options:</p>
<pre>
  (1) If <em>callback</em> is NULL and <em>data</em> is NULL, an internal 32K block
      on the machine stack is used.
</pre>

<pre>
  (2) If <em>callback</em> is NULL and <em>data</em> is not NULL, <em>data</em> must be
      a valid JIT stack, the result of calling <strong>pcre_jit_stack_alloc()</strong>.
</pre>

<pre>
  (3) If <em>callback</em> is not NULL, it must point to a function that is
      called with <em>data</em> as an argument at the start of matching, in
      order to set up a JIT stack. If the return from the callback
      function is NULL, the internal 32K stack is used; otherwise the
      return value must be a valid JIT stack, the result of calling
      <strong>pcre_jit_stack_alloc()</strong>.
</pre>
<p>A callback function is obeyed whenever JIT code is about to be run; it is not obeyed when <strong>pcre_exec()</strong> is called with options that are incompatible for JIT execution. A callback function can therefore be used to determine whether a match operation was executed by JIT or by the interpreter.</p><p>You may safely use the same JIT stack for more than one pattern (either by assigning directly or by callback), as long as the patterns are all matched sequentially in the same thread. In a multithread application, if you do not specify a JIT stack, or if you assign or pass back NULL from a callback, that is thread-safe, because each thread has its own machine stack. However, if you assign or pass back a non-NULL JIT stack, this must be a different stack for each thread so that the application is thread-safe.</p><p>Strictly speaking, even more is allowed. You can assign the same non-NULL stack to any number of patterns as long as they are not used for matching by multiple threads at the same time. For example, you can assign the same stack to all compiled patterns, and use a global mutex in the callback to wait until the stack is available for use. However, this is an inefficient solution, and not recommended.</p><p>This is a suggestion for how a multithreaded program that needs to set up non-default JIT stacks might operate:</p>
<pre>
  During thread initalization
    thread_local_var = pcre_jit_stack_alloc(...)
</pre>

<pre>
  During thread exit
    pcre_jit_stack_free(thread_local_var)
</pre>

<pre>
  Use a one-line callback function
    return thread_local_var
</pre>
<p>All the functions described in this section do nothing if JIT is not available, and <strong>pcre_assign_jit_stack()</strong> does nothing unless the <strong>extra</strong> argument is non-NULL and points to a <strong>pcre_extra</strong> block that is the result of a successful study with PCRE_STUDY_JIT_COMPILE etc.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">JIT STACK FAQ</h2>
        <div class="sectioncontent">
<p>(1) Why do we need JIT stacks?</p><p>PCRE (and JIT) is a recursive, depth-first engine, so it needs a stack where the local data of the current node is pushed before checking its child nodes. Allocating real machine stack on some platforms is difficult. For example, the stack chain needs to be updated every time if we extend the stack on PowerPC. Although it is possible, its updating time overhead decreases performance. So we do the recursion in memory.</p><p>(2) Why don't we simply allocate blocks of memory with <strong>malloc()</strong>?</p><p>Modern operating systems have a nice feature: they can reserve an address space instead of allocating memory. We can safely allocate memory pages inside this address space, so the stack could grow without moving memory data (this is important because of pointers). Thus we can allocate 1M address space, and use only a single memory page (usually 4K) if that is enough. However, we can still grow up to 1M anytime if needed.</p><p>(3) Who "owns" a JIT stack?</p><p>The owner of the stack is the user program, not the JIT studied pattern or anything else. The user program must ensure that if a stack is used by <strong>pcre_exec()</strong>, (that is, it is assigned to the pattern currently running), that stack must not be used by any other threads (to avoid overwriting the same memory area). The best practice for multithreaded programs is to allocate a stack for each thread, and return this stack through the JIT callback function.</p><p>(4) When should a JIT stack be freed?</p><p>You can free a JIT stack at any time, as long as it will not be used by <strong>pcre_exec()</strong> again. When you assign the stack to a pattern, only a pointer is set. There is no reference counting or any other magic. You can free the patterns and stacks in any order, anytime. Just <em>do not</em> call <strong>pcre_exec()</strong> with a pattern pointing to an already freed stack, as that will cause SEGFAULT. (Also, do not free a stack currently used by <strong>pcre_exec()</strong> in another thread). You can also replace the stack for a pattern at any time. You can even free the previous stack before assigning a replacement.</p><p>(5) Should I allocate/free a stack every time before/after calling <strong>pcre_exec()</strong>?</p><p>No, because this is too costly in terms of resources. However, you could implement some clever idea which release the stack if it is not used in let's say two minutes. The JIT callback can help to achieve this without keeping a list of the currently JIT studied patterns.</p><p>(6) OK, the stack is for long term memory allocation. But what happens if a pattern causes stack overflow with a stack of 1M? Is that 1M kept until the stack is freed?</p><p>Especially on embedded sytems, it might be a good idea to release memory sometimes without freeing the stack. There is no API for this at the moment. Probably a function call which returns with the currently allocated memory for any stack and another which allows releasing memory (shrinking the stack) would be a good idea if someone needs this.</p><p>(7) This is too much of a headache. Isn't there any better solution for JIT stack handling?</p><p>No, thanks to Windows. If POSIX threads were used everywhere, we could throw out this complicated API.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLE CODE</h2>
        <div class="sectioncontent">
<p>This is a single-threaded example that specifies a JIT stack without using a callback.</p>
<pre>
  int rc;
  int ovector[30];
  pcre *re;
  pcre_extra *extra;
  pcre_jit_stack *jit_stack;
</pre>

<pre>
  re = pcre_compile(pattern, 0, &error, &erroffset, NULL);
  /* Check for errors */
  extra = pcre_study(re, PCRE_STUDY_JIT_COMPILE, &error);
  jit_stack = pcre_jit_stack_alloc(32*1024, 512*1024);
  /* Check for error (NULL) */
  pcre_assign_jit_stack(extra, NULL, jit_stack);
  rc = pcre_exec(re, extra, subject, length, 0, 0, ovector, 30);
  /* Check results */
  pcre_free(re);
  pcre_free_study(extra);
  pcre_jit_stack_free(jit_stack);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">JIT FAST PATH API</h2>
        <div class="sectioncontent">
<p>Because the API described above falls back to interpreted execution when JIT is not available, it is convenient for programs that are written for general use in many environments. However, calling JIT via <strong>pcre_exec()</strong> does have a performance impact. Programs that are written for use where JIT is known to be available, and which need the best possible performance, can instead use a "fast path" API to call JIT execution directly instead of calling <strong>pcre_exec()</strong> (obviously only for patterns that have been successfully studied by JIT).</p><p>The fast path function is called <strong>pcre_jit_exec()</strong>, and it takes exactly the same arguments as <strong>pcre_exec()</strong>, plus one additional argument that must point to a JIT stack. The JIT stack arrangements described above do not apply. The return values are the same as for <strong>pcre_exec()</strong>.</p><p>When you call <strong>pcre_exec()</strong>, as well as testing for invalid options, a number of other sanity checks are performed on the arguments. For example, if the subject pointer is NULL, or its length is negative, an immediate error is given. Also, unless PCRE_NO_UTF[8|16|32] is set, a UTF subject string is tested for validity. In the interests of speed, these checks do not happen on the JIT fast path, and if invalid data is passed, the result is undefined.</p><p>Bypassing the sanity checks and the <strong>pcre_exec()</strong> wrapping can give speedups of more than 10%.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO pcrejit&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man3/pcreapi.3.html"><strong>pcreapi</strong>(3)</a></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">

<pre>
Philip Hazel (FAQ by Zoltan Herczeg)
University Computing Service
Cambridge CB2 3QH, England.
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REVISION</h2>
        <div class="sectioncontent">

<pre>
Last updated: 17 March 2013
Copyright (c) 1997-2013 University of Cambridge.
</pre>

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="pcrecpp.3.html"><span aria-hidden="true">&larr;</span> pcrecpp.3: Perl-compatible regular expressions.</a></li>
   <li class="next"><a href="pcrelimits.3.html">pcrelimits.3: Perl-compatible regular expressions <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>pmapi: Introduction to the performance metrics application programming interface</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Introduction to the performance metrics application programming interface">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="pmapi (3) manual">
  <meta name="twitter:description" content="Introduction to the performance metrics application programming interface">
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">pmapi<small> (3)</small></h1>
        <p class="lead">Introduction to the performance metrics application programming interface</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/pmapi.3.html">
      <span itemprop="name">pmapi: Introduction to the performance metrics application programming interface</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/pcp/">
      <span itemprop="name">pcp</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/pmapi.3.html">
      <span itemprop="name">pmapi: Introduction to the performance metrics application programming interface</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">C SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;pcp/pmapi.h&gt;</p><p> ... assorted routines ...</p><p>cc ... -lpcp</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Within the framework of the Performance Co-Pilot (PCP), client applications are developed using the Performance Metrics Application Programming Interface (PMAPI) that defines a procedural interface with services suited to the development of applications with a particular interest in performance metrics.</p><p>This description presents an overview of the PMAPI and the context in which PMAPI applications are run. The PMAPI is more fully described in the <em>Performance Co-Pilot Programmer's Guide</em>, and the manual pages for the individual PMAPI routines.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PERFORMANCE METRICS - NAMES AND IDENTIFIERS</h2>
        <div class="sectioncontent">
<p>For a description of the Performance Metrics Name Space (PMNS) and associated terms and concepts, see <a href="../man1/pcpintro.1.html"><strong>PCPIntro</strong>(1)</a>.</p><p>Not all PMIDs need be represented in the PMNS of every application. For example, an application which monitors disk traffic will likely use a name space which references only the PMIDs for I/O statistics.</p><p>Applications which use the PMAPI may have independent versions of a PMNS, constructed from an initialization file when the application starts; see <a href="../man3/pmloadasciinamespace.3.html"><strong>pmLoadASCIINameSpace</strong>(3)</a>, <a href="../man3/pmloadnamespace.3.html"><strong>pmLoadNameSpace</strong>(3)</a>, and <a href="../man5/pmns.5.html"><strong>pmns</strong>(5)</a>.</p><p>Internally (below the PMAPI) the implementation of the Performance Metrics Collection System (PMCS) uses only the PMIDs, and a PMNS provides an external mapping from a hierarchic taxonomy of names to PMIDs that is convenient in the context of a particular system or particular use of the PMAPI. For the applications programmer, the routines <a href="../man3/pmlookupname.3.html"><strong>pmLookupName</strong>(3)</a> and <a href="../man3/pmnameid.3.html"><strong>pmNameID</strong>(3)</a> translate between names in a PMNS and PMIDs, and vice versa. The PMNS may be traversed using <a href="../man3/pmgetchildren.3.html"><strong>pmGetChildren</strong>(3)</a> and<strong>pmTraversePMNS</strong>. The <a href="../man3/pmfetchgroup.3.html"><strong>pmFetchGroup</strong>(3)</a> functions combine metric name lookup, fetch, and conversion operations.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PMAPI CONTEXT</h2>
        <div class="sectioncontent">
<p>An application using the PMAPI may manipulate several concurrent contexts, each associated with a source of performance metrics, e.g.  .BR pmcd (1) on some host, or a set of archive logs of performance metrics as created by <a href="../man1/pmlogger.1.html"><strong>pmlogger</strong>(1)</a>.</p><p>Contexts are identified by a ``handle'', a small integer value that is returned when the context is created; see <a href="../man3/pmnewcontext.3.html"><strong>pmNewContext</strong>(3)</a> and <a href="../man3/pmdupcontext.3.html"><strong>pmDupContext</strong>(3)</a>. Some PMAPI functions require an explicit ``handle'' to identify the correct context, but more commonly the PMAPI function is executed in the ``current'' context. The current context may be discovered using <a href="../man3/pmwhichcontext.3.html"><strong>pmWhichContext</strong>(3)</a> and changed using <a href="../man3/pmusecontext.3.html"><strong>pmUseContext</strong>(3)</a>.</p><p>If a PMAPI context has not been explicitly established (or the previous current context has been closed using <a href="../man3/pmdestroycontext.3.html"><strong>pmDestroyContext</strong>(3)</a>) then the current PMAPI context is undefined.</p><p>In addition to the source of the performance metrics, the context also includes the instance profile and collection time (both described below) which controls how much information is returned, and when the information was collected.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INSTANCE DOMAINS</h2>
        <div class="sectioncontent">
<p>When performance metric values are returned across the PMAPI to a requesting application, there may be more than one value for a particular metric. Multiple values, or <strong>instances</strong>, for a single metric are typically the result of instrumentation being implemented for each instance of a set of similar components or services in a system, e.g. independent counts for each CPU, or each process, or each disk, or each system call type, etc. This multiplicity of values is not enumerated in the name space but rather, when performance metrics are delivered across the PMAPI by <a href="../man3/pmfetch.3.html"><strong>pmFetch</strong>(3)</a>, the format of the result accommodates values for one or more instances, with an instance-value pair encoding the metric value for a particular instance.</p><p>The instances are identified by an internal identifier assigned by the agent responsible for instantiating the values for the associated performance metric. Each instance identifier has a corresponding external instance identifier name (an ASCII string). The routines <a href="../man3/pmgetindom.3.html"><strong>pmGetInDom</strong>(3)</a>, <a href="../man3/pmlookupindom.3.html"><strong>pmLookupInDom</strong>(3)</a> and <a href="../man3/pmnameindom.3.html"><strong>pmNameInDom</strong>(3)</a> may be used to enumerate all instance identifiers, and to translate between internal and external instance identifiers.</p><p>All of the instance identifiers for a particular performance metric are collectively known as an instance domain. Multiple performance metrics may share the same instance domain.</p><p>If only one instance is ever available for a particular performance metric, the instance identifier in the result from <a href="../man3/pmfetch.3.html"><strong>pmFetch</strong>(3)</a> assumes the special value <strong>PM_IN_NULL</strong> and may be ignored by the application, and only one instance-value pair appears in the result for that metric. Under these circumstances, the associated instance domain (as returned via <a href="../man3/pmlookupdesc.3.html"><strong>pmLookupDesc</strong>(3)</a>) is set to <strong>PM_INDOM_NULL</strong> to indicate that values for this metric are singular.</p><p>The difficult issue of transient performance metrics (e.g. per-filesystem information, hot-plug replaceable hardware modules, etc.) means that repeated requests for the same PMID may return different numbers of values, and/or some changes in the particular instance identifiers returned. This means applications need to be aware that metric instantiation is guaranteed to be valid at the time of collection only. Similar rules apply to the transient semantics of the associated metric values. In general however, it is expected that the bulk of the performance metrics will have instantiation semantics that are fixed over the execution life-time of any PMAPI client.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THE TYPE OF METRIC VALUES</h2>
        <div class="sectioncontent">
<p>The PMAPI supports a wide range of format and type encodings for the values of performance metrics, namely signed and unsigned integers, floating point numbers, 32-bit and 64-bit encodings of all of the above, ASCII strings (C-style, NULL byte terminated), and arbitrary aggregates of binary data.</p><p>The field in the structure returned by <a href="../man3/pmlookupdesc.3.html"><strong>pmLookupDesc</strong>(3)</a> identifies the format and type of the values for a particular performance metric within a particular PMAPI context.</p><p>Note that the encoding of values for a particular performance metric may be different for different PMAPI contexts, due to differences in the underlying implementation for different contexts. However it is expected that the vast majority of performance metrics will have consistent value encoding across all versions of all implementations, and hence across all PMAPI contexts.</p><p>The PMAPI supports routines to automate the handling of the various value formats and types, particularly for the common case where conversion to a canonical format is desired, see <a href="../man3/pmextractvalue.3.html"><strong>pmExtractValue</strong>(3)</a> and <a href="../man3/pmprintvalue.3.html"><strong>pmPrintValue</strong>(3)</a>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THE DIMENSIONALITY AND SCALE OF METRIC VALUES</h2>
        <div class="sectioncontent">
<p>Independent of how the value is encoded, the value for a performance metric is assumed to be drawn from a set of values that can be described in terms of their dimensionality and scale by a compact encoding as follows. The dimensionality is defined by a power, or index, in each of 3 orthogonal dimensions, namely Space, Time and Count (or Events, which are dimensionless). For example I/O throughput might be represented as Space/Time, while the running total of system calls is Count, memory allocation is Space and average service time is Time/Count. In each dimension there are a number of common scale values that may be used to better encode ranges that might otherwise exhaust the precision of a 32-bit value. This information is encoded in the structure which is embedded in the structure returned from <a href="../man3/pmlookupdesc.3.html"><strong>pmLookupDesc</strong>(3)</a>.</p><p>The routine <a href="../man3/pmconvscale.3.html"><strong>pmConvScale</strong>(3)</a> is provided to convert values in conjunction with the structures that defines the dimensionality and scale of the values for a particular performance metric as returned from <a href="../man3/pmfetch.3.html"><strong>pmFetch</strong>(3)</a>, and the desired dimensionality and scale of the value the PMAPI client wishes to manipulate. Alternatively, the <a href="../man3/pmfetchgroup.3.html"><strong>pmFetchGroup</strong>(3)</a> functions can perform data format and unit conversion operations, specified by textual descriptions of desired unit / scales.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INSTANCE PROFILE</h2>
        <div class="sectioncontent">
<p>The set of instances for performance metrics returned from a <a href="../man3/pmfetch.3.html"><strong>pmFetch</strong>(3)</a> call may be filtered or restricted using an instance profile. There is one instance profile for each PMAPI context the application creates, and each instance profile may include instances from one or more instance domains.</p><p>The routines <a href="../man3/pmaddprofile.3.html"><strong>pmAddProfile</strong>(3)</a> and <a href="../man3/pmdelprofile.3.html"><strong>pmDelProfile</strong>(3)</a> may be used to dynamically adjust the instance profile.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COLLECTION TIME</h2>
        <div class="sectioncontent">
<p>For each set of values for performance metrics returned via <a href="../man3/pmfetch.3.html"><strong>pmFetch</strong>(3)</a> there is an associated ``timestamp'' that serves to identify when the performance metric values were collected; for metrics being delivered from a real-time source (i.e.  .BR pmcd (1) on some host) this would typically be not long before they were exported across the PMAPI, and for metrics being delivered from a set of archive logs, this would be the time when the metrics were written into the archive log.</p><p>There is an issue here of exactly when individual metrics may have been collected, especially given their origin in potentially different Performance Metric Domains, and variability in the metric updating frequency at the lowest level of the Performance Metric Domain. The PMCS opts for the pragmatic approach, in which the PMAPI implementation undertakes to return all of the metrics with values accurate as of the timestamp, to the best of our ability. The belief is that the inaccuracy this introduces is small, and the additional burden of accurate individual timestamping for each returned metric value is neither warranted nor practical (from an implementation viewpoint).</p><p>Of course, in the case of collection of metrics from multiple hosts the PMAPI client must assume the sanity of the timestamps is constrained by the extent to which clock synchronization protocols are implemented across the network.</p><p>A PMAPI application may call <a href="../man3/pmsetmode.3.html"><strong>pmSetMode</strong>(3)</a> to vary the requested collection time, e.g. to rescan performance metrics values from the recent past, or to ``fast-forward'' through a set of archive logs.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">GENERAL ISSUES OF PMAPI PROGRAMMING STYLE</h2>
        <div class="sectioncontent">
<p>Across the PMAPI, all arguments and results involving a ``list of something'' are declared to be arrays with an associated argument or function value to identify the number of elements in the list. This has been done to avoid both the <strong>varargs</strong>(3) approach and sentinel-terminated lists.</p><p>Where the size of a result is known at the time of a call, it is the caller's responsibility to allocate (and possibly free) the storage, and the called function will assume the result argument is of an appropriate size. Where a result is of variable size and that size cannot be known in advance (e.g. for <a href="../man3/pmgetchildren.3.html"><strong>pmGetChildren</strong>(3)</a>, <a href="../man3/pmgetindom.3.html"><strong>pmGetInDom</strong>(3)</a>, <a href="../man3/pmnameindom.3.html"><strong>pmNameInDom</strong>(3)</a>, <a href="../man3/pmnameid.3.html"><strong>pmNameID</strong>(3)</a>, <a href="../man3/pmlookuptext.3.html"><strong>pmLookupText</strong>(3)</a> and <a href="../man3/pmfetch.3.html"><strong>pmFetch</strong>(3)</a>) the PMAPI implementation uses a range of dynamic allocation schemes in the called routine, with the caller responsible for subsequently releasing the storage when no longer required. In some cases this simply involves calls to <a href="../man3/free.3.html"><strong>free</strong>(3)</a>, but in others (most notably for the result from <a href="../man3/pmfetch.3.html"><strong>pmFetch</strong>(3)</a>), special routines (e.g.  .BR pmFreeResult (3)) should be used to release the storage.</p><p>As a general rule, if the called routine returns an error status then no allocation will have been done, and any pointer to a variable sized result is undefined.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DIAGNOSTICS</h2>
        <div class="sectioncontent">
<p>Where error conditions may arise, the functions that comprise the PMAPI conform to a single, simple error notification scheme, as follows;</p><ul>
<li><p>the function returns an integer</p></li><li><p>values &gt;= 0 indicate no error, and perhaps some positive status, e.g. the number of things really processed</p></li><li><p>values &lt; 0 indicate an error, with a global table of error conditions and error messages</p></li>
</ul><p>The PMAPI routine <a href="../man3/pmerrstr.3.html"><strong>pmErrStr</strong>(3)</a> translates error conditions into error messages. By convention, the small negative values are assumed to be negated versions of the Unix error codes as defined in <strong>&lt;errno.h&gt;</strong> and the strings returned are as per <a href="../man3/strerror.3.html"><strong>strerror</strong>(3)</a>. The larger, negative error codes are PMAPI error conditions.</p><p>One error, common to all PMAPI routines that interact with <a href="../man1/pmcd.1.html"><strong>pmcd</strong>(1)</a> on some host is <strong>PM_ERR_IPC</strong>, which indicates the communication link to <a href="../man1/pmcd.1.html"><strong>pmcd</strong>(1)</a> has been lost.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MULTI-THREADED APPLICATIONS</h2>
        <div class="sectioncontent">
<p>The original design for PCP was based around single-threaded applications, or more strictly applications in which only one thread was ever expected to call the PCP libraries. This restriction has been relaxed for <strong>libpcp</strong> to allow the most common PMAPI routines to be safely called from any thread in a multi-threaded application.</p><p>However the following groups of functions and services in <strong>libpcp</strong> are still restricted to being called from a single-thread, and this is enforced by returning <strong>PM_ERR_THREAD</strong> when an attempt to call the routines in each group from more than one thread is detected.</p>
<dl class='dl-vertical'>
  <dt>
    <p>1.</p>
  </dt>
  <dd>
    <p>Any use of a <strong>PM_CONTEXT_LOCAL</strong> context, as the DSO PMDAs that are called directly from <strong>libpcp</strong> may not be thread-safe.</p>
  </dd>
  <dt>
    <p>2.</p>
  </dt>
  <dd>
    <p>The interval timer services use global state with semantics that demand it is only used in the context of a single thread, so <strong>__pmAFregister</strong>(3), <strong>__pmAFunregister</strong>(3), <strong>__pmAFblock</strong>(3), <strong>__pmAFunblock (3)</strong> and <strong>__pmAFisempty</strong>(3).</p>
  </dd>
  <dt>
    <p>3.</p>
  </dt>
  <dd>
    <p>The following (undocumented) access control manipulation routines that are principally intended for single-threaded applications: <strong>__pmAccAddOp</strong>, <strong>__pmAccSaveHosts</strong>, <strong>__pmAccRestoreHosts</strong>, <strong>__pmAccFreeSavedHosts</strong>, <strong>__pmAccAddHost</strong>, <strong>__pmAccAddClient</strong>, <strong>__pmAccDelClient</strong> and <strong>__pmAccDumpHosts</strong>.</p>
  </dd>
  <dt>
    <p>4.</p>
  </dt>
  <dd>
    <p>The following (undocumented) routines that identify <em>pmlogger</em> control ports and are principally intended for single-threaded applications: <strong>__pmLogFindPort</strong> and <strong>__pmLogFindLocalPorts</strong>.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PCP ENVIRONMENT</h2>
        <div class="sectioncontent">
<p>Most environment variables are described in <a href="../man1/pcpintro.1.html"><strong>PCPIntro</strong>(1)</a>. In addition, environment variables with the prefix <strong>PCP_</strong> are used to parameterize the file and directory names used by PCP. On each installation, the file <em>/etc/pcp.conf</em> contains the local values for these variables. The <strong>$PCP_CONF</strong> variable may be used to specify an alternative configuration file, as described in <a href="../man5/pcp.conf.5.html"><strong>pcp.conf</strong>(5)</a>. Values for these variables may be obtained programmatically using the <a href="../man3/pmgetconfig.3.html"><strong>pmGetConfig</strong>(3)</a> function.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO pmapi&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man1/pcpintro.1.html"><strong>PCPIntro</strong>(1)</a>, <a href="../man3/pcpintro.3.html"><strong>PCPIntro</strong>(3)</a>, <a href="../man3/pmda.3.html"><strong>pmda</strong>(3)</a>, <a href="../man3/pmgetconfig.3.html"><strong>pmGetConfig</strong>(3)</a>, <a href="../man5/pcp.conf.5.html"><strong>pcp.conf</strong>(5)</a> and <a href="../man5/pcp.env.5.html"><strong>pcp.env</strong>(5)</a>.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="pmap_unset.3.html"><span aria-hidden="true">&larr;</span> pmap_unset.3: Library routines for remote procedure calls</a></li>
   <li class="next"><a href="pmatomstr.3.html">pmatomstr.3: Convert a performance metric value into a string <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

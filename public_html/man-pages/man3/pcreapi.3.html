<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>pcreapi: Perl-compatible regular expressions  #include pcre.h</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Perl-compatible regular expressions  #include pcre.h">
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">pcreapi<small> (3)</small></h1>
        <p class="lead">Perl-compatible regular expressions  #include pcre.h</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/pcreapi.3.html">
      <span itemprop="name">pcreapi: Perl-compatible regular expressions  #include pcre.h</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/mariadb/">
      <span itemprop="name">mariadb</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/pcreapi.3.html">
      <span itemprop="name">pcreapi: Perl-compatible regular expressions  #include pcre.h</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">PCRE NATIVE API BASIC FUNCTIONS</h2>
        <div class="sectioncontent">

<pre>
<strong>pcre *pcre_compile(const char *</strong><em>pattern</em><strong>, int </strong><em>options</em><strong>,</strong>
<strong>     const char **</strong><em>errptr</em><strong>, int *</strong><em>erroffset</em><strong>,</strong>
<strong>     const unsigned char *</strong><em>tableptr</em><strong>);</strong>

<strong>pcre *pcre_compile2(const char *</strong><em>pattern</em><strong>, int </strong><em>options</em><strong>,</strong>
<strong>     int *</strong><em>errorcodeptr</em><strong>,</strong>
<strong>     const char **</strong><em>errptr</em><strong>, int *</strong><em>erroffset</em><strong>,</strong>
<strong>     const unsigned char *</strong><em>tableptr</em><strong>);</strong>

<strong>pcre_extra *pcre_study(const pcre *</strong><em>code</em><strong>, int </strong><em>options</em><strong>,</strong>
<strong>     const char **</strong><em>errptr</em><strong>);</strong>

<strong>void pcre_free_study(pcre_extra *</strong><em>extra</em><strong>);</strong>

<strong>int pcre_exec(const pcre *</strong><em>code</em><strong>, const pcre_extra *</strong><em>extra</em><strong>,</strong>
<strong>     const char *</strong><em>subject</em><strong>, int </strong><em>length</em><strong>, int </strong><em>startoffset</em><strong>,</strong>
<strong>     int </strong><em>options</em><strong>, int *</strong><em>ovector</em><strong>, int </strong><em>ovecsize</em><strong>);</strong>

<strong>int pcre_dfa_exec(const pcre *</strong><em>code</em><strong>, const pcre_extra *</strong><em>extra</em><strong>,</strong>
<strong>     const char *</strong><em>subject</em><strong>, int </strong><em>length</em><strong>, int </strong><em>startoffset</em><strong>,</strong>
<strong>     int </strong><em>options</em><strong>, int *</strong><em>ovector</em><strong>, int </strong><em>ovecsize</em><strong>,</strong>
<strong>     int *</strong><em>workspace</em><strong>, int </strong><em>wscount</em><strong>);</strong>
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PCRE NATIVE API STRING EXTRACTION FUNCTIONS</h2>
        <div class="sectioncontent">

<pre>
<strong>int pcre_copy_named_substring(const pcre *</strong><em>code</em><strong>,</strong>
<strong>     const char *</strong><em>subject</em><strong>, int *</strong><em>ovector</em><strong>,</strong>
<strong>     int </strong><em>stringcount</em><strong>, const char *</strong><em>stringname</em><strong>,</strong>
<strong>     char *</strong><em>buffer</em><strong>, int </strong><em>buffersize</em><strong>);</strong>

<strong>int pcre_copy_substring(const char *</strong><em>subject</em><strong>, int *</strong><em>ovector</em><strong>,</strong>
<strong>     int </strong><em>stringcount</em><strong>, int </strong><em>stringnumber</em><strong>, char *</strong><em>buffer</em><strong>,</strong>
<strong>     int </strong><em>buffersize</em><strong>);</strong>

<strong>int pcre_get_named_substring(const pcre *</strong><em>code</em><strong>,</strong>
<strong>     const char *</strong><em>subject</em><strong>, int *</strong><em>ovector</em><strong>,</strong>
<strong>     int </strong><em>stringcount</em><strong>, const char *</strong><em>stringname</em><strong>,</strong>
<strong>     const char **</strong><em>stringptr</em><strong>);</strong>

<strong>int pcre_get_stringnumber(const pcre *</strong><em>code</em><strong>,</strong>
<strong>     const char *</strong><em>name</em><strong>);</strong>

<strong>int pcre_get_stringtable_entries(const pcre *</strong><em>code</em><strong>,</strong>
<strong>     const char *</strong><em>name</em><strong>, char **</strong><em>first</em><strong>, char **</strong><em>last</em><strong>);</strong>

<strong>int pcre_get_substring(const char *</strong><em>subject</em><strong>, int *</strong><em>ovector</em><strong>,</strong>
<strong>     int </strong><em>stringcount</em><strong>, int </strong><em>stringnumber</em><strong>,</strong>
<strong>     const char **</strong><em>stringptr</em><strong>);</strong>

<strong>int pcre_get_substring_list(const char *</strong><em>subject</em><strong>,</strong>
<strong>     int *</strong><em>ovector</em><strong>, int </strong><em>stringcount</em><strong>, const char ***</strong><em>listptr</em><strong>);</strong>

<strong>void pcre_free_substring(const char *</strong><em>stringptr</em><strong>);</strong>

<strong>void pcre_free_substring_list(const char **</strong><em>stringptr</em><strong>);</strong>
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PCRE NATIVE API AUXILIARY FUNCTIONS</h2>
        <div class="sectioncontent">

<pre>
<strong>int pcre_jit_exec(const pcre *</strong><em>code</em><strong>, const pcre_extra *</strong><em>extra</em><strong>,</strong>
<strong>     const char *</strong><em>subject</em><strong>, int </strong><em>length</em><strong>, int </strong><em>startoffset</em><strong>,</strong>
<strong>     int </strong><em>options</em><strong>, int *</strong><em>ovector</em><strong>, int </strong><em>ovecsize</em><strong>,</strong>
<strong>     pcre_jit_stack *</strong><em>jstack</em><strong>);</strong>

<strong>pcre_jit_stack *pcre_jit_stack_alloc(int </strong><em>startsize</em><strong>, int </strong><em>maxsize</em><strong>);</strong>

<strong>void pcre_jit_stack_free(pcre_jit_stack *</strong><em>stack</em><strong>);</strong>

<strong>void pcre_assign_jit_stack(pcre_extra *</strong><em>extra</em><strong>,</strong>
<strong>     pcre_jit_callback </strong><em>callback</em><strong>, void *</strong><em>data</em><strong>);</strong>

<strong>const unsigned char *pcre_maketables(void);</strong>

<strong>int pcre_fullinfo(const pcre *</strong><em>code</em><strong>, const pcre_extra *</strong><em>extra</em><strong>,</strong>
<strong>     int </strong><em>what</em><strong>, void *</strong><em>where</em><strong>);</strong>

<strong>int pcre_refcount(pcre *</strong><em>code</em><strong>, int </strong><em>adjust</em><strong>);</strong>

<strong>int pcre_config(int </strong><em>what</em><strong>, void *</strong><em>where</em><strong>);</strong>

<strong>const char *pcre_version(void);</strong>

<strong>int pcre_pattern_to_host_byte_order(pcre *</strong><em>code</em><strong>,</strong>
<strong>     pcre_extra *</strong><em>extra</em><strong>, const unsigned char *</strong><em>tables</em><strong>);</strong>
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PCRE NATIVE API INDIRECTED FUNCTIONS</h2>
        <div class="sectioncontent">

<pre>
<strong>void *(*pcre_malloc)(size_t);</strong>

<strong>void (*pcre_free)(void *);</strong>

<strong>void *(*pcre_stack_malloc)(size_t);</strong>

<strong>void (*pcre_stack_free)(void *);</strong>

<strong>int (*pcre_callout)(pcre_callout_block *);</strong>

<strong>int (*pcre_stack_guard)(void);</strong>
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PCRE 8-BIT, 16-BIT, AND 32-BIT LIBRARIES</h2>
        <div class="sectioncontent">
<p>As well as support for 8-bit character strings, PCRE also supports 16-bit strings (from release 8.30) and 32-bit strings (from release 8.32), by means of two additional libraries. They can be built as well as, or instead of, the 8-bit library. To avoid too much complication, this document describes the 8-bit versions of the functions, with only occasional references to the 16-bit and 32-bit libraries.</p><p>The 16-bit and 32-bit functions operate in the same way as their 8-bit counterparts; they just use different data types for their arguments and results, and their names start with <strong>pcre16_</strong> or <strong>pcre32_</strong> instead of <strong>pcre_</strong>. For every option that has UTF8 in its name (for example, PCRE_UTF8), there are corresponding 16-bit and 32-bit names with UTF8 replaced by UTF16 or UTF32, respectively. This facility is in fact just cosmetic; the 16-bit and 32-bit option names define the same bit values.</p><p>References to bytes and UTF-8 in this document should be read as references to 16-bit data units and UTF-16 when using the 16-bit library, or 32-bit data units and UTF-32 when using the 32-bit library, unless specified otherwise. More details of the specific differences for the 16-bit and 32-bit libraries are given in the <strong>pcre16</strong> and <strong>pcre32</strong> pages.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PCRE API OVERVIEW</h2>
        <div class="sectioncontent">
<p>PCRE has its own native API, which is described in this document. There are also some wrapper functions (for the 8-bit library only) that correspond to the POSIX regular expression API, but they do not give access to all the functionality. They are described in the <strong>pcreposix</strong> documentation. Both of these APIs define a set of C function calls. A C++ wrapper (again for the 8-bit library only) is also distributed with PCRE. It is documented in the <strong>pcrecpp</strong> page.</p><p>The native API C function prototypes are defined in the header file <strong>pcre.h</strong>, and on Unix-like systems the (8-bit) library itself is called <strong>libpcre</strong>. It can normally be accessed by adding <strong>-lpcre</strong> to the command for linking an application that uses PCRE. The header file defines the macros PCRE_MAJOR and PCRE_MINOR to contain the major and minor release numbers for the library. Applications can use these to include support for different releases of PCRE.</p><p>In a Windows environment, if you want to statically link an application program against a non-dll <strong>pcre.a</strong> file, you must define PCRE_STATIC before including <strong>pcre.h</strong> or <strong>pcrecpp.h</strong>, because otherwise the <strong>pcre_malloc()</strong> and <strong>pcre_free()</strong> exported functions will be declared <strong>__declspec(dllimport)</strong>, with unwanted results.</p><p>The functions <strong>pcre_compile()</strong>, <strong>pcre_compile2()</strong>, <strong>pcre_study()</strong>, and <strong>pcre_exec()</strong> are used for compiling and matching regular expressions in a Perl-compatible manner. A sample program that demonstrates the simplest way of using them is provided in the file called <em>pcredemo.c</em> in the PCRE source distribution. A listing of this program is given in the <strong>pcredemo</strong> documentation, and the <strong>pcresample</strong> documentation describes how to compile and run it.</p><p>Just-in-time compiler support is an optional feature of PCRE that can be built in appropriate hardware environments. It greatly speeds up the matching performance of many patterns. Simple programs can easily request that it be used if available, by setting an option that is ignored when it is not relevant. More complicated programs might need to make use of the functions <strong>pcre_jit_stack_alloc()</strong>, <strong>pcre_jit_stack_free()</strong>, and <strong>pcre_assign_jit_stack()</strong> in order to control the JIT code's memory usage.</p><p>From release 8.32 there is also a direct interface for JIT execution, which gives improved performance. The JIT-specific functions are discussed in the <strong>pcrejit</strong> documentation.</p><p>A second matching function, <strong>pcre_dfa_exec()</strong>, which is not Perl-compatible, is also provided. This uses a different algorithm for the matching. The alternative algorithm finds all possible matches (at a given point in the subject), and scans the subject just once (unless there are lookbehind assertions). However, this algorithm does not return captured substrings. A description of the two matching algorithms and their advantages and disadvantages is given in the <strong>pcrematching</strong> documentation.</p><p>In addition to the main compiling and matching functions, there are convenience functions for extracting captured substrings from a subject string that is matched by <strong>pcre_exec()</strong>. They are:</p>
<pre>
  <strong>pcre_copy_substring()</strong>
  <strong>pcre_copy_named_substring()</strong>
  <strong>pcre_get_substring()</strong>
  <strong>pcre_get_named_substring()</strong>
  <strong>pcre_get_substring_list()</strong>
  <strong>pcre_get_stringnumber()</strong>
  <strong>pcre_get_stringtable_entries()</strong>
</pre>
<p><strong>pcre_free_substring()</strong> and <strong>pcre_free_substring_list()</strong> are also provided, to free the memory used for extracted strings.</p><p>The function <strong>pcre_maketables()</strong> is used to build a set of character tables in the current locale for passing to <strong>pcre_compile()</strong>, <strong>pcre_exec()</strong>, or <strong>pcre_dfa_exec()</strong>. This is an optional facility that is provided for specialist use. Most commonly, no special tables are passed, in which case internal tables that are generated when PCRE is built are used.</p><p>The function <strong>pcre_fullinfo()</strong> is used to find out information about a compiled pattern. The function <strong>pcre_version()</strong> returns a pointer to a string containing the version of PCRE and its date of release.</p><p>The function <strong>pcre_refcount()</strong> maintains a reference count in a data block containing a compiled pattern. This is provided for the benefit of object-oriented applications.</p><p>The global variables <strong>pcre_malloc</strong> and <strong>pcre_free</strong> initially contain the entry points of the standard <strong>malloc()</strong> and <strong>free()</strong> functions, respectively. PCRE calls the memory management functions via these variables, so a calling program can replace them if it wishes to intercept the calls. This should be done before calling any PCRE functions.</p><p>The global variables <strong>pcre_stack_malloc</strong> and <strong>pcre_stack_free</strong> are also indirections to memory management functions. These special functions are used only when PCRE is compiled to use the heap for remembering data, instead of recursive function calls, when running the <strong>pcre_exec()</strong> function. See the <strong>pcrebuild</strong> documentation for details of how to do this. It is a non-standard way of building PCRE, for use in environments that have limited stacks. Because of the greater use of memory management, it runs more slowly. Separate functions are provided so that special-purpose external code can be used for this case. When used, these functions always allocate memory blocks of the same size. There is a discussion about PCRE's stack usage in the <strong>pcrestack</strong> documentation.</p><p>The global variable <strong>pcre_callout</strong> initially contains NULL. It can be set by the caller to a "callout" function, which PCRE will then call at specified points during a matching operation. Details are given in the <strong>pcrecallout</strong> documentation.</p><p>The global variable <strong>pcre_stack_guard</strong> initially contains NULL. It can be set by the caller to a function that is called by PCRE whenever it starts to compile a parenthesized part of a pattern. When parentheses are nested, PCRE uses recursive function calls, which use up the system stack. This function is provided so that applications with restricted stacks can force a compilation error if the stack runs out. The function should return zero if all is well, or non-zero to force an error.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NEWLINES</h2>
        <div class="sectioncontent">
<p>PCRE supports five different conventions for indicating line breaks in strings: a single CR (carriage return) character, a single LF (linefeed) character, the two-character sequence CRLF, any of the three preceding, or any Unicode newline sequence. The Unicode newline sequences are the three just mentioned, plus the single characters VT (vertical tab, U+000B), FF (form feed, U+000C), NEL (next line, U+0085), LS (line separator, U+2028), and PS (paragraph separator, U+2029).</p><p>Each of the first three conventions is used by at least one operating system as its standard newline sequence. When PCRE is built, a default can be specified. The default default is LF, which is the Unix standard. When PCRE is run, the default can be overridden, either when a pattern is compiled, or when it is matched.</p><p>At compile time, the newline convention can be specified by the <em>options</em> argument of <strong>pcre_compile()</strong>, or it can be specified by special text at the start of the pattern itself; this overrides any other settings. See the <strong>pcrepattern</strong> page for details of the special character sequences.</p><p>In the PCRE documentation the word "newline" is used to mean "the character or pair of characters that indicate a line break". The choice of newline convention affects the handling of the dot, circumflex, and dollar metacharacters, the handling of #-comments in /x mode, and, when CRLF is a recognized line ending sequence, the match position advancement for a non-anchored pattern. There is more detail about this in the section on <strong>pcre_exec()</strong> options below.</p><p>The choice of newline convention does not affect the interpretation of the &#92;n or &#92;r escape sequences, nor does it affect what &#92;R matches, which is controlled in a similar way, but by separate options.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MULTITHREADING</h2>
        <div class="sectioncontent">
<p>The PCRE functions can be used in multi-threading applications, with the proviso that the memory management functions pointed to by <strong>pcre_malloc</strong>, <strong>pcre_free</strong>, <strong>pcre_stack_malloc</strong>, and <strong>pcre_stack_free</strong>, and the callout and stack-checking functions pointed to by <strong>pcre_callout</strong> and <strong>pcre_stack_guard</strong>, are shared by all threads.</p><p>The compiled form of a regular expression is not altered during matching, so the same compiled pattern can safely be used by several threads at once.</p><p>If the just-in-time optimization feature is being used, it needs separate memory stack areas for each thread. See the <strong>pcrejit</strong> documentation for more details.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SAVING PRECOMPILED PATTERNS FOR LATER USE</h2>
        <div class="sectioncontent">
<p>The compiled form of a regular expression can be saved and re-used at a later time, possibly by a different program, and even on a host other than the one on which it was compiled. Details are given in the <strong>pcreprecompile</strong> documentation, which includes a description of the <strong>pcre_pattern_to_host_byte_order()</strong> function. However, compiling a regular expression with one version of PCRE for use with a different version is not guaranteed to work and may cause crashes.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CHECKING BUILD-TIME OPTIONS</h2>
        <div class="sectioncontent">
<p><strong>int pcre_config(int </strong><em>what</em><strong>, void *</strong><em>where</em><strong>);</strong></p><p>The function <strong>pcre_config()</strong> makes it possible for a PCRE client to discover which optional features have been compiled into the PCRE library. The <strong>pcrebuild</strong> documentation has more details about these optional features.</p><p>The first argument for <strong>pcre_config()</strong> is an integer, specifying which information is required; the second argument is a pointer to a variable into which the information is placed. The returned value is zero on success, or the negative error code PCRE_ERROR_BADOPTION if the value in the first argument is not recognized. The following information is available:</p>
<pre>
  PCRE_CONFIG_UTF8
</pre>
<p>The output is an integer that is set to one if UTF-8 support is available; otherwise it is set to zero. This value should normally be given to the 8-bit version of this function, <strong>pcre_config()</strong>. If it is given to the 16-bit or 32-bit version of this function, the result is PCRE_ERROR_BADOPTION.</p>
<pre>
  PCRE_CONFIG_UTF16
</pre>
<p>The output is an integer that is set to one if UTF-16 support is available; otherwise it is set to zero. This value should normally be given to the 16-bit version of this function, <strong>pcre16_config()</strong>. If it is given to the 8-bit or 32-bit version of this function, the result is PCRE_ERROR_BADOPTION.</p>
<pre>
  PCRE_CONFIG_UTF32
</pre>
<p>The output is an integer that is set to one if UTF-32 support is available; otherwise it is set to zero. This value should normally be given to the 32-bit version of this function, <strong>pcre32_config()</strong>. If it is given to the 8-bit or 16-bit version of this function, the result is PCRE_ERROR_BADOPTION.</p>
<pre>
  PCRE_CONFIG_UNICODE_PROPERTIES
</pre>
<p>The output is an integer that is set to one if support for Unicode character properties is available; otherwise it is set to zero.</p>
<pre>
  PCRE_CONFIG_JIT
</pre>
<p>The output is an integer that is set to one if support for just-in-time compiling is available; otherwise it is set to zero.</p>
<pre>
  PCRE_CONFIG_JITTARGET
</pre>
<p>The output is a pointer to a zero-terminated "const char *" string. If JIT support is available, the string contains the name of the architecture for which the JIT compiler is configured, for example "x86 32bit (little endian + unaligned)". If JIT support is not available, the result is NULL.</p>
<pre>
  PCRE_CONFIG_NEWLINE
</pre>
<p>The output is an integer whose value specifies the default character sequence that is recognized as meaning "newline". The values that are supported in ASCII/Unicode environments are: 10 for LF, 13 for CR, 3338 for CRLF, -2 for ANYCRLF, and -1 for ANY. In EBCDIC environments, CR, ANYCRLF, and ANY yield the same values. However, the value for LF is normally 21, though some EBCDIC environments use 37. The corresponding values for CRLF are 3349 and 3365. The default should normally correspond to the standard sequence for your operating system.</p>
<pre>
  PCRE_CONFIG_BSR
</pre>
<p>The output is an integer whose value indicates what character sequences the &#92;R escape sequence matches by default. A value of 0 means that &#92;R matches any Unicode line ending sequence; a value of 1 means that &#92;R matches only CR, LF, or CRLF. The default can be overridden when a pattern is compiled or matched.</p>
<pre>
  PCRE_CONFIG_LINK_SIZE
</pre>
<p>The output is an integer that contains the number of bytes used for internal linkage in compiled regular expressions. For the 8-bit library, the value can be 2, 3, or 4. For the 16-bit library, the value is either 2 or 4 and is still a number of bytes. For the 32-bit library, the value is either 2 or 4 and is still a number of bytes. The default value of 2 is sufficient for all but the most massive patterns, since it allows the compiled pattern to be up to 64K in size. Larger values allow larger regular expressions to be compiled, at the expense of slower matching.</p>
<pre>
  PCRE_CONFIG_POSIX_MALLOC_THRESHOLD
</pre>
<p>The output is an integer that contains the threshold above which the POSIX interface uses <strong>malloc()</strong> for output vectors. Further details are given in the <strong>pcreposix</strong> documentation.</p>
<pre>
  PCRE_CONFIG_PARENS_LIMIT
</pre>
<p>The output is a long integer that gives the maximum depth of nesting of parentheses (of any kind) in a pattern. This limit is imposed to cap the amount of system stack used when a pattern is compiled. It is specified when PCRE is built; the default is 250. This limit does not take into account the stack that may already be used by the calling application. For finer control over compilation stack usage, you can set a pointer to an external checking function in <strong>pcre_stack_guard</strong>.</p>
<pre>
  PCRE_CONFIG_MATCH_LIMIT
</pre>
<p>The output is a long integer that gives the default limit for the number of internal matching function calls in a <strong>pcre_exec()</strong> execution. Further details are given with <strong>pcre_exec()</strong> below.</p>
<pre>
  PCRE_CONFIG_MATCH_LIMIT_RECURSION
</pre>
<p>The output is a long integer that gives the default limit for the depth of recursion when calling the internal matching function in a <strong>pcre_exec()</strong> execution. Further details are given with <strong>pcre_exec()</strong> below.</p>
<pre>
  PCRE_CONFIG_STACKRECURSE
</pre>
<p>The output is an integer that is set to one if internal recursion when running <strong>pcre_exec()</strong> is implemented by recursive function calls that use the stack to remember their state. This is the usual way that PCRE is compiled. The output is zero if PCRE was compiled to use blocks of data on the heap instead of recursive function calls. In this case, <strong>pcre_stack_malloc</strong> and <strong>pcre_stack_free</strong> are called to manage memory blocks on the heap, thus avoiding the use of the stack.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COMPILING A PATTERN</h2>
        <div class="sectioncontent">

<pre>
<strong>pcre *pcre_compile(const char *</strong><em>pattern</em><strong>, int </strong><em>options</em><strong>,</strong>
<strong>     const char **</strong><em>errptr</em><strong>, int *</strong><em>erroffset</em><strong>,</strong>
<strong>     const unsigned char *</strong><em>tableptr</em><strong>);</strong>

<strong>pcre *pcre_compile2(const char *</strong><em>pattern</em><strong>, int </strong><em>options</em><strong>,</strong>
<strong>     int *</strong><em>errorcodeptr</em><strong>,</strong>
<strong>     const char **</strong><em>errptr</em><strong>, int *</strong><em>erroffset</em><strong>,</strong>
<strong>     const unsigned char *</strong><em>tableptr</em><strong>);</strong>
</pre>
<p>Either of the functions <strong>pcre_compile()</strong> or <strong>pcre_compile2()</strong> can be called to compile a pattern into an internal form. The only difference between the two interfaces is that <strong>pcre_compile2()</strong> has an additional argument, <em>errorcodeptr</em>, via which a numerical error code can be returned. To avoid too much repetition, we refer just to <strong>pcre_compile()</strong> below, but the information applies equally to <strong>pcre_compile2()</strong>.</p><p>The pattern is a C string terminated by a binary zero, and is passed in the <em>pattern</em> argument. A pointer to a single block of memory that is obtained via <strong>pcre_malloc</strong> is returned. This contains the compiled code and related data. The <strong>pcre</strong> type is defined for the returned block; this is a typedef for a structure whose contents are not externally defined. It is up to the caller to free the memory (via <strong>pcre_free</strong>) when it is no longer required.</p><p>Although the compiled code of a PCRE regex is relocatable, that is, it does not depend on memory location, the complete <strong>pcre</strong> data block is not fully relocatable, because it may contain a copy of the <em>tableptr</em> argument, which is an address (see below).</p><p>The <em>options</em> argument contains various bit settings that affect the compilation. It should be zero if no options are required. The available options are described below. Some of them (in particular, those that are compatible with Perl, but some others as well) can also be set and unset from within the pattern (see the detailed description in the <strong>pcrepattern</strong> documentation). For those options that can be different in different parts of the pattern, the contents of the <em>options</em> argument specifies their settings at the start of compilation and execution. The PCRE_ANCHORED, PCRE_BSR_<em>xxx</em>, PCRE_NEWLINE_<em>xxx</em>, PCRE_NO_UTF8_CHECK, and PCRE_NO_START_OPTIMIZE options can be set at the time of matching as well as at compile time.</p><p>If <em>errptr</em> is NULL, <strong>pcre_compile()</strong> returns NULL immediately. Otherwise, if compilation of a pattern fails, <strong>pcre_compile()</strong> returns NULL, and sets the variable pointed to by <em>errptr</em> to point to a textual error message. This is a static string that is part of the library. You must not try to free it. Normally, the offset from the start of the pattern to the data unit that was being processed when the error was discovered is placed in the variable pointed to by <em>erroffset</em>, which must not be NULL (if it is, an immediate error is given). However, for an invalid UTF-8 or UTF-16 string, the offset is that of the first data unit of the failing character.</p><p>Some errors are not detected until the whole pattern has been scanned; in these cases, the offset passed back is the length of the pattern. Note that the offset is in data units, not characters, even in a UTF mode. It may sometimes point into the middle of a UTF-8 or UTF-16 character.</p><p>If <strong>pcre_compile2()</strong> is used instead of <strong>pcre_compile()</strong>, and the <em>errorcodeptr</em> argument is not NULL, a non-zero error code number is returned via this argument in the event of an error. This is in addition to the textual error message. Error codes and messages are listed below.</p><p>If the final argument, <em>tableptr</em>, is NULL, PCRE uses a default set of character tables that are built when PCRE is compiled, using the default C locale. Otherwise, <em>tableptr</em> must be an address that is the result of a call to <strong>pcre_maketables()</strong>. This value is stored with the compiled pattern, and used again by <strong>pcre_exec()</strong> and <strong>pcre_dfa_exec()</strong> when the pattern is matched. For more discussion, see the section on locale support below.</p><p>This code fragment shows a typical straightforward call to <strong>pcre_compile()</strong>:</p>
<pre>
  pcre *re;
  const char *error;
  int erroffset;
  re = pcre_compile(
    "^A.*Z",          /* the pattern */
    0,                /* default options */
    &error,           /* for error message */
    &erroffset,       /* for error offset */
    NULL);            /* use default character tables */
</pre>
<p>The following names for option bits are defined in the <strong>pcre.h</strong> header file:</p>
<pre>
  PCRE_ANCHORED
</pre>
<p>If this bit is set, the pattern is forced to be "anchored", that is, it is constrained to match only at the first matching point in the string that is being searched (the "subject string"). This effect can also be achieved by appropriate constructs in the pattern itself, which is the only way to do it in Perl.</p>
<pre>
  PCRE_AUTO_CALLOUT
</pre>
<p>If this bit is set, <strong>pcre_compile()</strong> automatically inserts callout items, all with number 255, before each pattern item. For discussion of the callout facility, see the <strong>pcrecallout</strong> documentation.</p>
<pre>
  PCRE_BSR_ANYCRLF
  PCRE_BSR_UNICODE
</pre>
<p>These options (which are mutually exclusive) control what the &#92;R escape sequence matches. The choice is either to match only CR, LF, or CRLF, or to match any Unicode newline sequence. The default is specified when PCRE is built. It can be overridden from within the pattern, or by setting an option when a compiled pattern is matched.</p>
<pre>
  PCRE_CASELESS
</pre>
<p>If this bit is set, letters in the pattern match both upper and lower case letters. It is equivalent to Perl's /i option, and it can be changed within a pattern by a (?i) option setting. In UTF-8 mode, PCRE always understands the concept of case for characters whose values are less than 128, so caseless matching is always possible. For characters with higher values, the concept of case is supported if PCRE is compiled with Unicode property support, but not otherwise. If you want to use caseless matching for characters 128 and above, you must ensure that PCRE is compiled with Unicode property support as well as with UTF-8 support.</p>
<pre>
  PCRE_DOLLAR_ENDONLY
</pre>
<p>If this bit is set, a dollar metacharacter in the pattern matches only at the end of the subject string. Without this option, a dollar also matches immediately before a newline at the end of the string (but not before any other newlines). The PCRE_DOLLAR_ENDONLY option is ignored if PCRE_MULTILINE is set. There is no equivalent to this option in Perl, and no way to set it within a pattern.</p>
<pre>
  PCRE_DOTALL
</pre>
<p>If this bit is set, a dot metacharacter in the pattern matches a character of any value, including one that indicates a newline. However, it only ever matches one character, even if newlines are coded as CRLF. Without this option, a dot does not match when the current position is at a newline. This option is equivalent to Perl's /s option, and it can be changed within a pattern by a (?s) option setting. A negative class such as [^a] always matches newline characters, independent of the setting of this option.</p>
<pre>
  PCRE_DUPNAMES
</pre>
<p>If this bit is set, names used to identify capturing subpatterns need not be unique. This can be helpful for certain types of pattern when it is known that only one instance of the named subpattern can ever be matched. There are more details of named subpatterns below; see also the <strong>pcrepattern</strong> documentation.</p>
<pre>
  PCRE_EXTENDED
</pre>
<p>If this bit is set, most white space characters in the pattern are totally ignored except when escaped or inside a character class. However, white space is not allowed within sequences such as (?&gt; that introduce various parenthesized subpatterns, nor within a numerical quantifier such as {1,3}. However, ignorable white space is permitted between an item and a following quantifier and between a quantifier and a following + that indicates possessiveness.</p><p>White space did not used to include the VT character (code 11), because Perl did not treat this character as white space. However, Perl changed at release 5.18, so PCRE followed at release 8.34, and VT is now treated as white space.</p><p>PCRE_EXTENDED also causes characters between an unescaped # outside a character class and the next newline, inclusive, to be ignored. PCRE_EXTENDED is equivalent to Perl's /x option, and it can be changed within a pattern by a (?x) option setting.</p><p>Which characters are interpreted as newlines is controlled by the options passed to <strong>pcre_compile()</strong> or by a special sequence at the start of the pattern, as described in the section entitled "Newline conventions" in the <strong>pcrepattern</strong> documentation. Note that the end of this type of comment is a literal newline sequence in the pattern; escape sequences that happen to represent a newline do not count.</p><p>This option makes it possible to include comments inside complicated patterns. Note, however, that this applies only to data characters. White space characters may never appear within special character sequences in a pattern, for example within the sequence (?( that introduces a conditional subpattern.</p>
<pre>
  PCRE_EXTRA
</pre>
<p>This option was invented in order to turn on additional functionality of PCRE that is incompatible with Perl, but it is currently of very little use. When set, any backslash in a pattern that is followed by a letter that has no special meaning causes an error, thus reserving these combinations for future expansion. By default, as in Perl, a backslash followed by a letter with no special meaning is treated as a literal. (Perl can, however, be persuaded to give an error for this, by running it with the -w option.) There are at present no other features controlled by this option. It can also be set by a (?X) option setting within a pattern.</p>
<pre>
  PCRE_FIRSTLINE
</pre>
<p>If this option is set, an unanchored pattern is required to match before or at the first newline in the subject string, though the matched text may continue over the newline.</p>
<pre>
  PCRE_JAVASCRIPT_COMPAT
</pre>
<p>If this option is set, PCRE's behaviour is changed in some ways so that it is compatible with JavaScript rather than Perl. The changes are as follows:</p><p>(1) A lone closing square bracket in a pattern causes a compile-time error, because this is illegal in JavaScript (by default it is treated as a data character). Thus, the pattern AB]CD becomes illegal when this option is set.</p><p>(2) At run time, a back reference to an unset subpattern group matches an empty string (by default this causes the current matching alternative to fail). A pattern such as (&#92;1)(a) succeeds when this option is set (assuming it can find an "a" in the subject), whereas it fails by default, for Perl compatibility.</p><p>(3) &#92;U matches an upper case "U" character; by default &#92;U causes a compile time error (Perl uses &#92;U to upper case subsequent characters).</p><p>(4) &#92;u matches a lower case "u" character unless it is followed by four hexadecimal digits, in which case the hexadecimal number defines the code point to match. By default, &#92;u causes a compile time error (Perl uses it to upper case the following character).</p><p>(5) &#92;x matches a lower case "x" character unless it is followed by two hexadecimal digits, in which case the hexadecimal number defines the code point to match. By default, as in Perl, a hexadecimal number is always expected after &#92;x, but it may have zero, one, or two digits (so, for example, &#92;xz matches a binary zero character followed by z).</p>
<pre>
  PCRE_MULTILINE
</pre>
<p>By default, for the purposes of matching "start of line" and "end of line", PCRE treats the subject string as consisting of a single line of characters, even if it actually contains newlines. The "start of line" metacharacter (^) matches only at the start of the string, and the "end of line" metacharacter ($) matches only at the end of the string, or before a terminating newline (except when PCRE_DOLLAR_ENDONLY is set). Note, however, that unless PCRE_DOTALL is set, the "any character" metacharacter (.) does not match at a newline. This behaviour (for ^, $, and dot) is the same as Perl.</p><p>When PCRE_MULTILINE it is set, the "start of line" and "end of line" constructs match immediately following or immediately before internal newlines in the subject string, respectively, as well as at the very start and end. This is equivalent to Perl's /m option, and it can be changed within a pattern by a (?m) option setting. If there are no newlines in a subject string, or no occurrences of ^ or $ in a pattern, setting PCRE_MULTILINE has no effect.</p>
<pre>
  PCRE_NEVER_UTF
</pre>
<p>This option locks out interpretation of the pattern as UTF-8 (or UTF-16 or UTF-32 in the 16-bit and 32-bit libraries). In particular, it prevents the creator of the pattern from switching to UTF interpretation by starting the pattern with (*UTF). This may be useful in applications that process patterns from external sources. The combination of PCRE_UTF8 and PCRE_NEVER_UTF also causes an error.</p>
<pre>
  PCRE_NEWLINE_CR
  PCRE_NEWLINE_LF
  PCRE_NEWLINE_CRLF
  PCRE_NEWLINE_ANYCRLF
  PCRE_NEWLINE_ANY
</pre>
<p>These options override the default newline definition that was chosen when PCRE was built. Setting the first or the second specifies that a newline is indicated by a single character (CR or LF, respectively). Setting PCRE_NEWLINE_CRLF specifies that a newline is indicated by the two-character CRLF sequence. Setting PCRE_NEWLINE_ANYCRLF specifies that any of the three preceding sequences should be recognized. Setting PCRE_NEWLINE_ANY specifies that any Unicode newline sequence should be recognized.</p><p>In an ASCII/Unicode environment, the Unicode newline sequences are the three just mentioned, plus the single characters VT (vertical tab, U+000B), FF (form feed, U+000C), NEL (next line, U+0085), LS (line separator, U+2028), and PS (paragraph separator, U+2029). For the 8-bit library, the last two are recognized only in UTF-8 mode.</p><p>When PCRE is compiled to run in an EBCDIC (mainframe) environment, the code for CR is 0x0d, the same as ASCII. However, the character code for LF is normally 0x15, though in some EBCDIC environments 0x25 is used. Whichever of these is not LF is made to correspond to Unicode's NEL character. EBCDIC codes are all less than 256. For more details, see the <strong>pcrebuild</strong> documentation.</p><p>The newline setting in the options word uses three bits that are treated as a number, giving eight possibilities. Currently only six are used (default plus the five values above). This means that if you set more than one newline option, the combination may or may not be sensible. For example, PCRE_NEWLINE_CR with PCRE_NEWLINE_LF is equivalent to PCRE_NEWLINE_CRLF, but other combinations may yield unused numbers and cause an error.</p><p>The only time that a line break in a pattern is specially recognized when compiling is when PCRE_EXTENDED is set. CR and LF are white space characters, and so are ignored in this mode. Also, an unescaped # outside a character class indicates a comment that lasts until after the next line break sequence. In other circumstances, line break sequences in patterns are treated as literal data.</p><p>The newline option that is set at compile time becomes the default that is used for <strong>pcre_exec()</strong> and <strong>pcre_dfa_exec()</strong>, but it can be overridden.</p>
<pre>
  PCRE_NO_AUTO_CAPTURE
</pre>
<p>If this option is set, it disables the use of numbered capturing parentheses in the pattern. Any opening parenthesis that is not followed by ? behaves as if it were followed by ?: but named parentheses can still be used for capturing (and they acquire numbers in the usual way). There is no equivalent of this option in Perl.</p>
<pre>
  PCRE_NO_AUTO_POSSESS
</pre>
<p>If this option is set, it disables "auto-possessification". This is an optimization that, for example, turns a+b into a++b in order to avoid backtracks into a+ that can never be successful. However, if callouts are in use, auto-possessification means that some of them are never taken. You can set this option if you want the matching functions to do a full unoptimized search and run all the callouts, but it is mainly provided for testing purposes.</p>
<pre>
  PCRE_NO_START_OPTIMIZE
</pre>
<p>This is an option that acts at matching time; that is, it is really an option for <strong>pcre_exec()</strong> or <strong>pcre_dfa_exec()</strong>. If it is set at compile time, it is remembered with the compiled pattern and assumed at matching time. This is necessary if you want to use JIT execution, because the JIT compiler needs to know whether or not this option is set. For details see the discussion of PCRE_NO_START_OPTIMIZE below.</p>
<pre>
  PCRE_UCP
</pre>
<p>This option changes the way PCRE processes &#92;B, &#92;b, &#92;D, &#92;d, &#92;S, &#92;s, &#92;W, &#92;w, and some of the POSIX character classes. By default, only ASCII characters are recognized, but if PCRE_UCP is set, Unicode properties are used instead to classify characters. More details are given in the section on generic character types in the <strong>pcrepattern</strong> page. If you set PCRE_UCP, matching one of the items it affects takes much longer. The option is available only if PCRE has been compiled with Unicode property support.</p>
<pre>
  PCRE_UNGREEDY
</pre>
<p>This option inverts the "greediness" of the quantifiers so that they are not greedy by default, but become greedy if followed by "?". It is not compatible with Perl. It can also be set by a (?U) option setting within the pattern.</p>
<pre>
  PCRE_UTF8
</pre>
<p>This option causes PCRE to regard both the pattern and the subject as strings of UTF-8 characters instead of single-byte strings. However, it is available only when PCRE is built to include UTF support. If not, the use of this option provokes an error. Details of how this option changes the behaviour of PCRE are given in the <strong>pcreunicode</strong> page.</p>
<pre>
  PCRE_NO_UTF8_CHECK
</pre>
<p>When PCRE_UTF8 is set, the validity of the pattern as a UTF-8 string is automatically checked. There is a discussion about the validity of UTF-8 strings in the <strong>pcreunicode</strong> page. If an invalid UTF-8 sequence is found, <strong>pcre_compile()</strong> returns an error. If you already know that your pattern is valid, and you want to skip this check for performance reasons, you can set the PCRE_NO_UTF8_CHECK option. When it is set, the effect of passing an invalid UTF-8 string as a pattern is undefined. It may cause your program to crash or loop. Note that this option can also be passed to <strong>pcre_exec()</strong> and <strong>pcre_dfa_exec()</strong>, to suppress the validity checking of subject strings only. If the same string is being matched many times, the option can be safely set for the second and subsequent matchings to improve performance.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COMPILATION ERROR CODES</h2>
        <div class="sectioncontent">
<p>The following table lists the error codes than may be returned by <strong>pcre_compile2()</strong>, along with the error messages that may be returned by both compiling functions. Note that error messages are always 8-bit ASCII strings, even in 16-bit or 32-bit mode. As PCRE has developed, some error codes have fallen out of use. To avoid confusion, they have not been re-used.</p>
<pre>
   0  no error
   1  &#92; at end of pattern
   2  &#92;c at end of pattern
   3  unrecognized character follows &#92;
   4  numbers out of order in {} quantifier
   5  number too big in {} quantifier
   6  missing terminating ] for character class
   7  invalid escape sequence in character class
   8  range out of order in character class
   9  nothing to repeat
  10  [this code is not in use]
  11  internal error: unexpected repeat
  12  unrecognized character after (? or (?-
  13  POSIX named classes are supported only within a class
  14  missing )
  15  reference to non-existent subpattern
  16  erroffset passed as NULL
  17  unknown option bit(s) set
  18  missing ) after comment
  19  [this code is not in use]
  20  regular expression is too large
  21  failed to get memory
  22  unmatched parentheses
  23  internal error: code overflow
  24  unrecognized character after (?&lt;
  25  lookbehind assertion is not fixed length
  26  malformed number or name after (?(
  27  conditional group contains more than two branches
  28  assertion expected after (?(
  29  (?R or (?[+-]digits must be followed by )
  30  unknown POSIX class name
  31  POSIX collating elements are not supported
  32  this version of PCRE is compiled without UTF support
  33  [this code is not in use]
  34  character value in &#92;x{} or &#92;o{} is too large
  35  invalid condition (?(0)
  36  &#92;C not allowed in lookbehind assertion
  37  PCRE does not support &#92;L, &#92;l, &#92;N{name}, &#92;U, or &#92;u
  38  number after (?C is &gt; 255
  39  closing ) for (?C expected
  40  recursive call could loop indefinitely
  41  unrecognized character after (?P
  42  syntax error in subpattern name (missing terminator)
  43  two named subpatterns have the same name
  44  invalid UTF-8 string (specifically UTF-8)
  45  support for &#92;P, &#92;p, and &#92;X has not been compiled
  46  malformed &#92;P or &#92;p sequence
  47  unknown property name after &#92;P or &#92;p
  48  subpattern name is too long (maximum 32 characters)
  49  too many named subpatterns (maximum 10000)
  50  [this code is not in use]
  51  octal value is greater than &#92;377 in 8-bit non-UTF-8 mode
  52  internal error: overran compiling workspace
  53  internal error: previously-checked referenced subpattern
        not found
  54  DEFINE group contains more than one branch
  55  repeating a DEFINE group is not allowed
  56  inconsistent NEWLINE options
  57  &#92;g is not followed by a braced, angle-bracketed, or quoted
        name/number or by a plain number
  58  a numbered reference must not be zero
  59  an argument is not allowed for (*ACCEPT), (*FAIL), or (*COMMIT)
  60  (*VERB) not recognized or malformed
  61  number is too big
  62  subpattern name expected
  63  digit expected after (?+
  64  ] is an invalid data character in JavaScript compatibility mode
  65  different names for subpatterns of the same number are
        not allowed
  66  (*MARK) must have an argument
  67  this version of PCRE is not compiled with Unicode property
        support
  68  &#92;c must be followed by an ASCII character
  69  &#92;k is not followed by a braced, angle-bracketed, or quoted name
  70  internal error: unknown opcode in find_fixedlength()
  71  &#92;N is not supported in a class
  72  too many forward references
  73  disallowed Unicode code point (&gt;= 0xd800 && &lt;= 0xdfff)
  74  invalid UTF-16 string (specifically UTF-16)
  75  name is too long in (*MARK), (*PRUNE), (*SKIP), or (*THEN)
  76  character value in &#92;u.... sequence is too large
  77  invalid UTF-32 string (specifically UTF-32)
  78  setting UTF is disabled by the application
  79  non-hex character in &#92;x{} (closing brace missing?)
  80  non-octal character in &#92;o{} (closing brace missing?)
  81  missing opening brace after &#92;o
  82  parentheses are too deeply nested
  83  invalid range in character class
  84  group name must start with a non-digit
  85  parentheses are too deeply nested (stack check)
</pre>
<p>The numbers 32 and 10000 in errors 48 and 49 are defaults; different values may be used if the limits were changed when PCRE was built.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">STUDYING A PATTERN</h2>
        <div class="sectioncontent">

<pre>
<strong>pcre_extra *pcre_study(const pcre *</strong><em>code</em><strong>, int </strong><em>options</em><strong>,</strong>
<strong>     const char **</strong><em>errptr</em><strong>);</strong>
</pre>
<p>If a compiled pattern is going to be used several times, it is worth spending more time analyzing it in order to speed up the time taken for matching. The function <strong>pcre_study()</strong> takes a pointer to a compiled pattern as its first argument. If studying the pattern produces additional information that will help speed up matching, <strong>pcre_study()</strong> returns a pointer to a <strong>pcre_extra</strong> block, in which the <em>study_data</em> field points to the results of the study.</p><p>The returned value from <strong>pcre_study()</strong> can be passed directly to <strong>pcre_exec()</strong> or <strong>pcre_dfa_exec()</strong>. However, a <strong>pcre_extra</strong> block also contains other fields that can be set by the caller before the block is passed; these are described below in the section on matching a pattern.</p><p>If studying the pattern does not produce any useful information, <strong>pcre_study()</strong> returns NULL by default. In that circumstance, if the calling program wants to pass any of the other fields to <strong>pcre_exec()</strong> or <strong>pcre_dfa_exec()</strong>, it must set up its own <strong>pcre_extra</strong> block. However, if <strong>pcre_study()</strong> is called with the PCRE_STUDY_EXTRA_NEEDED option, it returns a <strong>pcre_extra</strong> block even if studying did not find any additional information. It may still return NULL, however, if an error occurs in <strong>pcre_study()</strong>.</p><p>The second argument of <strong>pcre_study()</strong> contains option bits. There are three further options in addition to PCRE_STUDY_EXTRA_NEEDED:</p>
<pre>
  PCRE_STUDY_JIT_COMPILE
  PCRE_STUDY_JIT_PARTIAL_HARD_COMPILE
  PCRE_STUDY_JIT_PARTIAL_SOFT_COMPILE
</pre>
<p>If any of these are set, and the just-in-time compiler is available, the pattern is further compiled into machine code that executes much faster than the <strong>pcre_exec()</strong> interpretive matching function. If the just-in-time compiler is not available, these options are ignored. All undefined bits in the <em>options</em> argument must be zero.</p><p>JIT compilation is a heavyweight optimization. It can take some time for patterns to be analyzed, and for one-off matches and simple patterns the benefit of faster execution might be offset by a much slower study time. Not all patterns can be optimized by the JIT compiler. For those that cannot be handled, matching automatically falls back to the <strong>pcre_exec()</strong> interpreter. For more details, see the <strong>pcrejit</strong> documentation.</p><p>The third argument for <strong>pcre_study()</strong> is a pointer for an error message. If studying succeeds (even if no data is returned), the variable it points to is set to NULL. Otherwise it is set to point to a textual error message. This is a static string that is part of the library. You must not try to free it. You should test the error pointer for NULL after calling <strong>pcre_study()</strong>, to be sure that it has run successfully.</p><p>When you are finished with a pattern, you can free the memory used for the study data by calling <strong>pcre_free_study()</strong>. This function was added to the API for release 8.20. For earlier versions, the memory could be freed with <strong>pcre_free()</strong>, just like the pattern itself. This will still work in cases where JIT optimization is not used, but it is advisable to change to the new function when convenient.</p><p>This is a typical way in which <strong>pcre_study</strong>() is used (except that in a real application there should be tests for errors):</p>
<pre>
  int rc;
  pcre *re;
  pcre_extra *sd;
  re = pcre_compile("pattern", 0, &error, &erroroffset, NULL);
  sd = pcre_study(
    re,             /* result of pcre_compile() */
    0,              /* no options */
    &error);        /* set to NULL or points to a message */
  rc = pcre_exec(   /* see below for details of pcre_exec() options */
    re, sd, "subject", 7, 0, 0, ovector, 30);
  ...
  pcre_free_study(sd);
  pcre_free(re);
</pre>
<p>Studying a pattern does two things: first, a lower bound for the length of subject string that is needed to match the pattern is computed. This does not mean that there are any strings of that length that match, but it does guarantee that no shorter strings match. The value is used to avoid wasting time by trying to match strings that are shorter than the lower bound. You can find out the value in a calling program via the <strong>pcre_fullinfo()</strong> function.</p><p>Studying a pattern is also useful for non-anchored patterns that do not have a single fixed starting character. A bitmap of possible starting bytes is created. This speeds up finding a position in the subject at which to start matching. (In 16-bit mode, the bitmap is used for 16-bit values less than 256. In 32-bit mode, the bitmap is used for 32-bit values less than 256.)</p><p>These two optimizations apply to both <strong>pcre_exec()</strong> and <strong>pcre_dfa_exec()</strong>, and the information is also used by the JIT compiler. The optimizations can be disabled by setting the PCRE_NO_START_OPTIMIZE option. You might want to do this if your pattern contains callouts or (*MARK) and you want to make use of these facilities in cases where matching fails.</p><p>PCRE_NO_START_OPTIMIZE can be specified at either compile time or execution time. However, if PCRE_NO_START_OPTIMIZE is passed to <strong>pcre_exec()</strong>, (that is, after any JIT compilation has happened) JIT execution is disabled. For JIT execution to work with PCRE_NO_START_OPTIMIZE, the option must be set at compile time.</p><p>There is a longer discussion of PCRE_NO_START_OPTIMIZE below.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LOCALE SUPPORT</h2>
        <div class="sectioncontent">
<p>PCRE handles caseless matching, and determines whether characters are letters, digits, or whatever, by reference to a set of tables, indexed by character code point. When running in UTF-8 mode, or in the 16- or 32-bit libraries, this applies only to characters with code points less than 256. By default, higher-valued code points never match escapes such as &#92;w or &#92;d. However, if PCRE is built with Unicode property support, all characters can be tested with &#92;p and &#92;P, or, alternatively, the PCRE_UCP option can be set when a pattern is compiled; this causes &#92;w and friends to use Unicode property support instead of the built-in tables.</p><p>The use of locales with Unicode is discouraged. If you are handling characters with code points greater than 128, you should either use Unicode support, or use locales, but not try to mix the two.</p><p>PCRE contains an internal set of tables that are used when the final argument of <strong>pcre_compile()</strong> is NULL. These are sufficient for many applications. Normally, the internal tables recognize only ASCII characters. However, when PCRE is built, it is possible to cause the internal tables to be rebuilt in the default "C" locale of the local system, which may cause them to be different.</p><p>The internal tables can always be overridden by tables supplied by the application that calls PCRE. These may be created in a different locale from the default. As more and more applications change to using Unicode, the need for this locale support is expected to die away.</p><p>External tables are built by calling the <strong>pcre_maketables()</strong> function, which has no arguments, in the relevant locale. The result can then be passed to <strong>pcre_compile()</strong> as often as necessary. For example, to build and use tables that are appropriate for the French locale (where accented characters with values greater than 128 are treated as letters), the following code could be used:</p>
<pre>
  setlocale(LC_CTYPE, "fr_FR");
  tables = pcre_maketables();
  re = pcre_compile(..., tables);
</pre>
<p>The locale name "fr_FR" is used on Linux and other Unix-like systems; if you are using Windows, the name for the French locale is "french".</p><p>When <strong>pcre_maketables()</strong> runs, the tables are built in memory that is obtained via <strong>pcre_malloc</strong>. It is the caller's responsibility to ensure that the memory containing the tables remains available for as long as it is needed.</p><p>The pointer that is passed to <strong>pcre_compile()</strong> is saved with the compiled pattern, and the same tables are used via this pointer by <strong>pcre_study()</strong> and also by <strong>pcre_exec()</strong> and <strong>pcre_dfa_exec()</strong>. Thus, for any single pattern, compilation, studying and matching all happen in the same locale, but different patterns can be processed in different locales.</p><p>It is possible to pass a table pointer or NULL (indicating the use of the internal tables) to <strong>pcre_exec()</strong> or <strong>pcre_dfa_exec()</strong> (see the discussion below in the section on matching a pattern). This facility is provided for use with pre-compiled patterns that have been saved and reloaded. Character tables are not saved with patterns, so if a non-standard table was used at compile time, it must be provided again when the reloaded pattern is matched. Attempting to use this facility to match a pattern in a different locale from the one in which it was compiled is likely to lead to anomalous (usually incorrect) results.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INFORMATION ABOUT A PATTERN</h2>
        <div class="sectioncontent">

<pre>
<strong>int pcre_fullinfo(const pcre *</strong><em>code</em><strong>, const pcre_extra *</strong><em>extra</em><strong>,</strong>
<strong>     int </strong><em>what</em><strong>, void *</strong><em>where</em><strong>);</strong>
</pre>
<p>The <strong>pcre_fullinfo()</strong> function returns information about a compiled pattern. It replaces the <strong>pcre_info()</strong> function, which was removed from the library at version 8.30, after more than 10 years of obsolescence.</p><p>The first argument for <strong>pcre_fullinfo()</strong> is a pointer to the compiled pattern. The second argument is the result of <strong>pcre_study()</strong>, or NULL if the pattern was not studied. The third argument specifies which piece of information is required, and the fourth argument is a pointer to a variable to receive the data. The yield of the function is zero for success, or one of the following negative numbers:</p>
<pre>
  PCRE_ERROR_NULL           the argument <em>code</em> was NULL
                            the argument <em>where</em> was NULL
  PCRE_ERROR_BADMAGIC       the "magic number" was not found
  PCRE_ERROR_BADENDIANNESS  the pattern was compiled with different
                            endianness
  PCRE_ERROR_BADOPTION      the value of <em>what</em> was invalid
  PCRE_ERROR_UNSET          the requested field is not set
</pre>
<p>The "magic number" is placed at the start of each compiled pattern as an simple check against passing an arbitrary memory pointer. The endianness error can occur if a compiled pattern is saved and reloaded on a different host. Here is a typical call of <strong>pcre_fullinfo()</strong>, to obtain the length of the compiled pattern:</p>
<pre>
  int rc;
  size_t length;
  rc = pcre_fullinfo(
    re,               /* result of pcre_compile() */
    sd,               /* result of pcre_study(), or NULL */
    PCRE_INFO_SIZE,   /* what is required */
    &length);         /* where to put the data */
</pre>
<p>The possible values for the third argument are defined in <strong>pcre.h</strong>, and are as follows:</p>
<pre>
  PCRE_INFO_BACKREFMAX
</pre>
<p>Return the number of the highest back reference in the pattern. The fourth argument should point to an <strong>int</strong> variable. Zero is returned if there are no back references.</p>
<pre>
  PCRE_INFO_CAPTURECOUNT
</pre>
<p>Return the number of capturing subpatterns in the pattern. The fourth argument should point to an <strong>int</strong> variable.</p>
<pre>
  PCRE_INFO_DEFAULT_TABLES
</pre>
<p>Return a pointer to the internal default character tables within PCRE. The fourth argument should point to an <strong>unsigned char *</strong> variable. This information call is provided for internal use by the <strong>pcre_study()</strong> function. External callers can cause PCRE to use its internal tables by passing a NULL table pointer.</p>
<pre>
  PCRE_INFO_FIRSTBYTE (deprecated)
</pre>
<p>Return information about the first data unit of any matched string, for a non-anchored pattern. The name of this option refers to the 8-bit library, where data units are bytes. The fourth argument should point to an <strong>int</strong> variable. Negative values are used for special cases. However, this means that when the 32-bit library is in non-UTF-32 mode, the full 32-bit range of characters cannot be returned. For this reason, this value is deprecated; use PCRE_INFO_FIRSTCHARACTERFLAGS and PCRE_INFO_FIRSTCHARACTER instead.</p><p>If there is a fixed first value, for example, the letter "c" from a pattern such as (cat|cow|coyote), its value is returned. In the 8-bit library, the value is always less than 256. In the 16-bit library the value can be up to 0xffff. In the 32-bit library the value can be up to 0x10ffff.</p><p>If there is no fixed first value, and if either</p><p>(a) the pattern was compiled with the PCRE_MULTILINE option, and every branch starts with "^", or</p><p>(b) every branch of the pattern starts with ".*" and PCRE_DOTALL is not set (if it were set, the pattern would be anchored),</p><p>-1 is returned, indicating that the pattern matches only at the start of a subject string or after any newline within the string. Otherwise -2 is returned. For anchored patterns, -2 is returned.</p>
<pre>
  PCRE_INFO_FIRSTCHARACTER
</pre>
<p>Return the value of the first data unit (non-UTF character) of any matched string in the situation where PCRE_INFO_FIRSTCHARACTERFLAGS returns 1; otherwise return 0. The fourth argument should point to an <strong>uint_t</strong> variable.</p><p>In the 8-bit library, the value is always less than 256. In the 16-bit library the value can be up to 0xffff. In the 32-bit library in UTF-32 mode the value can be up to 0x10ffff, and up to 0xffffffff when not using UTF-32 mode.</p>
<pre>
  PCRE_INFO_FIRSTCHARACTERFLAGS
</pre>
<p>Return information about the first data unit of any matched string, for a non-anchored pattern. The fourth argument should point to an <strong>int</strong> variable.</p><p>If there is a fixed first value, for example, the letter "c" from a pattern such as (cat|cow|coyote), 1 is returned, and the character value can be retrieved using PCRE_INFO_FIRSTCHARACTER. If there is no fixed first value, and if either</p><p>(a) the pattern was compiled with the PCRE_MULTILINE option, and every branch starts with "^", or</p><p>(b) every branch of the pattern starts with ".*" and PCRE_DOTALL is not set (if it were set, the pattern would be anchored),</p><p>2 is returned, indicating that the pattern matches only at the start of a subject string or after any newline within the string. Otherwise 0 is returned. For anchored patterns, 0 is returned.</p>
<pre>
  PCRE_INFO_FIRSTTABLE
</pre>
<p>If the pattern was studied, and this resulted in the construction of a 256-bit table indicating a fixed set of values for the first data unit in any matching string, a pointer to the table is returned. Otherwise NULL is returned. The fourth argument should point to an <strong>unsigned char *</strong> variable.</p>
<pre>
  PCRE_INFO_HASCRORLF
</pre>
<p>Return 1 if the pattern contains any explicit matches for CR or LF characters, otherwise 0. The fourth argument should point to an <strong>int</strong> variable. An explicit match is either a literal CR or LF character, or &#92;r or &#92;n.</p>
<pre>
  PCRE_INFO_JCHANGED
</pre>
<p>Return 1 if the (?J) or (?-J) option setting is used in the pattern, otherwise 0. The fourth argument should point to an <strong>int</strong> variable. (?J) and (?-J) set and unset the local PCRE_DUPNAMES option, respectively.</p>
<pre>
  PCRE_INFO_JIT
</pre>
<p>Return 1 if the pattern was studied with one of the JIT options, and just-in-time compiling was successful. The fourth argument should point to an <strong>int</strong> variable. A return value of 0 means that JIT support is not available in this version of PCRE, or that the pattern was not studied with a JIT option, or that the JIT compiler could not handle this particular pattern. See the <strong>pcrejit</strong> documentation for details of what can and cannot be handled.</p>
<pre>
  PCRE_INFO_JITSIZE
</pre>
<p>If the pattern was successfully studied with a JIT option, return the size of the JIT compiled code, otherwise return zero. The fourth argument should point to a <strong>size_t</strong> variable.</p>
<pre>
  PCRE_INFO_LASTLITERAL
</pre>
<p>Return the value of the rightmost literal data unit that must exist in any matched string, other than at its start, if such a value has been recorded. The fourth argument should point to an <strong>int</strong> variable. If there is no such value, -1 is returned. For anchored patterns, a last literal value is recorded only if it follows something of variable length. For example, for the pattern /^a&#92;d+z&#92;d+/ the returned value is "z", but for /^a&#92;dz&#92;d/ the returned value is -1.</p><p>Since for the 32-bit library using the non-UTF-32 mode, this function is unable to return the full 32-bit range of characters, this value is deprecated; instead the PCRE_INFO_REQUIREDCHARFLAGS and PCRE_INFO_REQUIREDCHAR values should be used.</p>
<pre>
  PCRE_INFO_MATCH_EMPTY
</pre>
<p>Return 1 if the pattern can match an empty string, otherwise 0. The fourth argument should point to an <strong>int</strong> variable.</p>
<pre>
  PCRE_INFO_MATCHLIMIT
</pre>
<p>If the pattern set a match limit by including an item of the form (*LIMIT_MATCH=nnnn) at the start, the value is returned. The fourth argument should point to an unsigned 32-bit integer. If no such value has been set, the call to <strong>pcre_fullinfo()</strong> returns the error PCRE_ERROR_UNSET.</p>
<pre>
  PCRE_INFO_MAXLOOKBEHIND
</pre>
<p>Return the number of characters (NB not data units) in the longest lookbehind assertion in the pattern. This information is useful when doing multi-segment matching using the partial matching facilities. Note that the simple assertions &#92;b and &#92;B require a one-character lookbehind. &#92;A also registers a one-character lookbehind, though it does not actually inspect the previous character. This is to ensure that at least one character from the old segment is retained when a new segment is processed. Otherwise, if there are no lookbehinds in the pattern, &#92;A might match incorrectly at the start of a new segment.</p>
<pre>
  PCRE_INFO_MINLENGTH
</pre>
<p>If the pattern was studied and a minimum length for matching subject strings was computed, its value is returned. Otherwise the returned value is -1. The value is a number of characters, which in UTF mode may be different from the number of data units. The fourth argument should point to an <strong>int</strong> variable. A non-negative value is a lower bound to the length of any matching string. There may not be any strings of that length that do actually match, but every string that does match is at least that long.</p>
<pre>
  PCRE_INFO_NAMECOUNT
  PCRE_INFO_NAMEENTRYSIZE
  PCRE_INFO_NAMETABLE
</pre>
<p>PCRE supports the use of named as well as numbered capturing parentheses. The names are just an additional way of identifying the parentheses, which still acquire numbers. Several convenience functions such as <strong>pcre_get_named_substring()</strong> are provided for extracting captured substrings by name. It is also possible to extract the data directly, by first converting the name to a number in order to access the correct pointers in the output vector (described with <strong>pcre_exec()</strong> below). To do the conversion, you need to use the name-to-number map, which is described by these three values.</p><p>The map consists of a number of fixed-size entries. PCRE_INFO_NAMECOUNT gives the number of entries, and PCRE_INFO_NAMEENTRYSIZE gives the size of each entry; both of these return an <strong>int</strong> value. The entry size depends on the length of the longest name. PCRE_INFO_NAMETABLE returns a pointer to the first entry of the table. This is a pointer to <strong>char</strong> in the 8-bit library, where the first two bytes of each entry are the number of the capturing parenthesis, most significant byte first. In the 16-bit library, the pointer points to 16-bit data units, the first of which contains the parenthesis number. In the 32-bit library, the pointer points to 32-bit data units, the first of which contains the parenthesis number. The rest of the entry is the corresponding name, zero terminated.</p><p>The names are in alphabetical order. If (?| is used to create multiple groups with the same number, as described in the section on duplicate subpattern numbers in the <strong>pcrepattern</strong> page, the groups may be given the same name, but there is only one entry in the table. Different names for groups of the same number are not permitted. Duplicate names for subpatterns with different numbers are permitted, but only if PCRE_DUPNAMES is set. They appear in the table in the order in which they were found in the pattern. In the absence of (?| this is the order of increasing number; when (?| is used this is not necessarily the case because later subpatterns may have lower numbers.</p><p>As a simple example of the name/number table, consider the following pattern after compilation by the 8-bit library (assume PCRE_EXTENDED is set, so white space - including newlines - is ignored):</p>
<pre>
  (?&lt;date&gt; (?&lt;year&gt;(&#92;d&#92;d)?&#92;d&#92;d) -
  (?&lt;month&gt;&#92;d&#92;d) - (?&lt;day&gt;&#92;d&#92;d) )
</pre>
<p>There are four named subpatterns, so the table has four entries, and each entry in the table is eight bytes long. The table is as follows, with non-printing bytes shows in hexadecimal, and undefined bytes shown as ??:</p>
<pre>
  00 01 d  a  t  e  00 ??
  00 05 d  a  y  00 ?? ??
  00 04 m  o  n  t  h  00
  00 02 y  e  a  r  00 ??
</pre>
<p>When writing code to extract data from named subpatterns using the name-to-number map, remember that the length of the entries is likely to be different for each compiled pattern.</p>
<pre>
  PCRE_INFO_OKPARTIAL
</pre>
<p>Return 1 if the pattern can be used for partial matching with <strong>pcre_exec()</strong>, otherwise 0. The fourth argument should point to an <strong>int</strong> variable. From release 8.00, this always returns 1, because the restrictions that previously applied to partial matching have been lifted. The <strong>pcrepartial</strong> documentation gives details of partial matching.</p>
<pre>
  PCRE_INFO_OPTIONS
</pre>
<p>Return a copy of the options with which the pattern was compiled. The fourth argument should point to an <strong>unsigned long int</strong> variable. These option bits are those specified in the call to <strong>pcre_compile()</strong>, modified by any top-level option settings at the start of the pattern itself. In other words, they are the options that will be in force when matching starts. For example, if the pattern /(?im)abc(?-i)d/ is compiled with the PCRE_EXTENDED option, the result is PCRE_CASELESS, PCRE_MULTILINE, and PCRE_EXTENDED.</p><p>A pattern is automatically anchored by PCRE if all of its top-level alternatives begin with one of the following:</p>
<pre>
  ^     unless PCRE_MULTILINE is set
  &#92;A    always
  &#92;G    always
  .*    if PCRE_DOTALL is set and there are no back
          references to the subpattern in which .* appears
</pre>
<p>For such patterns, the PCRE_ANCHORED bit is set in the options returned by <strong>pcre_fullinfo()</strong>.</p>
<pre>
  PCRE_INFO_RECURSIONLIMIT
</pre>
<p>If the pattern set a recursion limit by including an item of the form (*LIMIT_RECURSION=nnnn) at the start, the value is returned. The fourth argument should point to an unsigned 32-bit integer. If no such value has been set, the call to <strong>pcre_fullinfo()</strong> returns the error PCRE_ERROR_UNSET.</p>
<pre>
  PCRE_INFO_SIZE
</pre>
<p>Return the size of the compiled pattern in bytes (for all three libraries). The fourth argument should point to a <strong>size_t</strong> variable. This value does not include the size of the <strong>pcre</strong> structure that is returned by <strong>pcre_compile()</strong>. The value that is passed as the argument to <strong>pcre_malloc()</strong> when <strong>pcre_compile()</strong> is getting memory in which to place the compiled data is the value returned by this option plus the size of the <strong>pcre</strong> structure. Studying a compiled pattern, with or without JIT, does not alter the value returned by this option.</p>
<pre>
  PCRE_INFO_STUDYSIZE
</pre>
<p>Return the size in bytes (for all three libraries) of the data block pointed to by the <em>study_data</em> field in a <strong>pcre_extra</strong> block. If <strong>pcre_extra</strong> is NULL, or there is no study data, zero is returned. The fourth argument should point to a <strong>size_t</strong> variable. The <em>study_data</em> field is set by <strong>pcre_study()</strong> to record information that will speed up matching (see the section entitled "Studying a pattern" above). The format of the <em>study_data</em> block is private, but its length is made available via this option so that it can be saved and restored (see the <strong>pcreprecompile</strong> documentation for details).</p>
<pre>
  PCRE_INFO_REQUIREDCHARFLAGS
</pre>
<p>Returns 1 if there is a rightmost literal data unit that must exist in any matched string, other than at its start. The fourth argument should  point to an <strong>int</strong> variable. If there is no such value, 0 is returned. If returning 1, the character value itself can be retrieved using PCRE_INFO_REQUIREDCHAR.</p><p>For anchored patterns, a last literal value is recorded only if it follows something of variable length. For example, for the pattern /^a&#92;d+z&#92;d+/ the returned value 1 (with "z" returned from PCRE_INFO_REQUIREDCHAR), but for /^a&#92;dz&#92;d/ the returned value is 0.</p>
<pre>
  PCRE_INFO_REQUIREDCHAR
</pre>
<p>Return the value of the rightmost literal data unit that must exist in any matched string, other than at its start, if such a value has been recorded. The fourth argument should point to an <strong>uint32_t</strong> variable. If there is no such value, 0 is returned.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REFERENCE COUNTS</h2>
        <div class="sectioncontent">
<p><strong>int pcre_refcount(pcre *</strong><em>code</em><strong>, int </strong><em>adjust</em><strong>);</strong></p><p>The <strong>pcre_refcount()</strong> function is used to maintain a reference count in the data block that contains a compiled pattern. It is provided for the benefit of applications that operate in an object-oriented manner, where different parts of the application may be using the same compiled pattern, but you want to free the block when they are all done.</p><p>When a pattern is compiled, the reference count field is initialized to zero. It is changed only by calling this function, whose action is to add the <em>adjust</em> value (which may be positive or negative) to it. The yield of the function is the new value. However, the value of the count is constrained to lie between 0 and 65535, inclusive. If the new value is outside these limits, it is forced to the appropriate limit value.</p><p>Except when it is zero, the reference count is not correctly preserved if a pattern is compiled on one host and then transferred to a host whose byte-order is different. (This seems a highly unlikely scenario.)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MATCHING A PATTERN: THE TRADITIONAL FUNCTION</h2>
        <div class="sectioncontent">

<pre>
<strong>int pcre_exec(const pcre *</strong><em>code</em><strong>, const pcre_extra *</strong><em>extra</em><strong>,</strong>
<strong>     const char *</strong><em>subject</em><strong>, int </strong><em>length</em><strong>, int </strong><em>startoffset</em><strong>,</strong>
<strong>     int </strong><em>options</em><strong>, int *</strong><em>ovector</em><strong>, int </strong><em>ovecsize</em><strong>);</strong>
</pre>
<p>The function <strong>pcre_exec()</strong> is called to match a subject string against a compiled pattern, which is passed in the <em>code</em> argument. If the pattern was studied, the result of the study should be passed in the <em>extra</em> argument. You can call <strong>pcre_exec()</strong> with the same <em>code</em> and <em>extra</em> arguments as many times as you like, in order to match different subject strings with the same pattern.</p><p>This function is the main matching facility of the library, and it operates in a Perl-like manner. For specialist use there is also an alternative matching function, which is described below in the section about the <strong>pcre_dfa_exec()</strong> function.</p><p>In most applications, the pattern will have been compiled (and optionally studied) in the same process that calls <strong>pcre_exec()</strong>. However, it is possible to save compiled patterns and study data, and then use them later in different processes, possibly even on different hosts. For a discussion about this, see the <strong>pcreprecompile</strong> documentation.</p><p>Here is an example of a simple call to <strong>pcre_exec()</strong>:</p>
<pre>
  int rc;
  int ovector[30];
  rc = pcre_exec(
    re,             /* result of pcre_compile() */
    NULL,           /* we didn't study the pattern */
    "some string",  /* the subject string */
    11,             /* the length of the subject string */
    0,              /* start at offset 0 in the subject */
    0,              /* default options */
    ovector,        /* vector of integers for substring information */
    30);            /* number of elements (NOT size in bytes) */
</pre>
<h3>Extra data for \fBpcre_exec()\fR</h3>
<p>If the <em>extra</em> argument is not NULL, it must point to a <strong>pcre_extra</strong> data block. The <strong>pcre_study()</strong> function returns such a block (when it doesn't return NULL), but you can also create one for yourself, and pass additional information in it. The <strong>pcre_extra</strong> block contains the following fields (not necessarily in this order):</p>
<pre>
  unsigned long int <em>flags</em>;
  void *<em>study_data</em>;
  void *<em>executable_jit</em>;
  unsigned long int <em>match_limit</em>;
  unsigned long int <em>match_limit_recursion</em>;
  void *<em>callout_data</em>;
  const unsigned char *<em>tables</em>;
  unsigned char **<em>mark</em>;
</pre>
<p>In the 16-bit version of this structure, the <em>mark</em> field has type "PCRE_UCHAR16 **".</p><p>In the 32-bit version of this structure, the <em>mark</em> field has type "PCRE_UCHAR32 **".</p><p>The <em>flags</em> field is used to specify which of the other fields are set. The flag bits are:</p>
<pre>
  PCRE_EXTRA_CALLOUT_DATA
  PCRE_EXTRA_EXECUTABLE_JIT
  PCRE_EXTRA_MARK
  PCRE_EXTRA_MATCH_LIMIT
  PCRE_EXTRA_MATCH_LIMIT_RECURSION
  PCRE_EXTRA_STUDY_DATA
  PCRE_EXTRA_TABLES
</pre>
<p>Other flag bits should be set to zero. The <em>study_data</em> field and sometimes the <em>executable_jit</em> field are set in the <strong>pcre_extra</strong> block that is returned by <strong>pcre_study()</strong>, together with the appropriate flag bits. You should not set these yourself, but you may add to the block by setting other fields and their corresponding flag bits.</p><p>The <em>match_limit</em> field provides a means of preventing PCRE from using up a vast amount of resources when running patterns that are not going to match, but which have a very large number of possibilities in their search trees. The classic example is a pattern that uses nested unlimited repeats.</p><p>Internally, <strong>pcre_exec()</strong> uses a function called <strong>match()</strong>, which it calls repeatedly (sometimes recursively). The limit set by <em>match_limit</em> is imposed on the number of times this function is called during a match, which has the effect of limiting the amount of backtracking that can take place. For patterns that are not anchored, the count restarts from zero for each position in the subject string.</p><p>When <strong>pcre_exec()</strong> is called with a pattern that was successfully studied with a JIT option, the way that the matching is executed is entirely different. However, there is still the possibility of runaway matching that goes on for a very long time, and so the <em>match_limit</em> value is also used in this case (but in a different way) to limit how long the matching can continue.</p><p>The default value for the limit can be set when PCRE is built; the default default is 10 million, which handles all but the most extreme cases. You can override the default by suppling <strong>pcre_exec()</strong> with a <strong>pcre_extra</strong> block in which <em>match_limit</em> is set, and PCRE_EXTRA_MATCH_LIMIT is set in the <em>flags</em> field. If the limit is exceeded, <strong>pcre_exec()</strong> returns PCRE_ERROR_MATCHLIMIT.</p><p>A value for the match limit may also be supplied by an item at the start of a pattern of the form</p>
<pre>
  (*LIMIT_MATCH=d)
</pre>
<p>where d is a decimal number. However, such a setting is ignored unless d is less than the limit set by the caller of <strong>pcre_exec()</strong> or, if no such limit is set, less than the default.</p><p>The <em>match_limit_recursion</em> field is similar to <em>match_limit</em>, but instead of limiting the total number of times that <strong>match()</strong> is called, it limits the depth of recursion. The recursion depth is a smaller number than the total number of calls, because not all calls to <strong>match()</strong> are recursive. This limit is of use only if it is set smaller than <em>match_limit</em>.</p><p>Limiting the recursion depth limits the amount of machine stack that can be used, or, when PCRE has been compiled to use memory on the heap instead of the stack, the amount of heap memory that can be used. This limit is not relevant, and is ignored, when matching is done using JIT compiled code.</p><p>The default value for <em>match_limit_recursion</em> can be set when PCRE is built; the default default is the same value as the default for <em>match_limit</em>. You can override the default by suppling <strong>pcre_exec()</strong> with a <strong>pcre_extra</strong> block in which <em>match_limit_recursion</em> is set, and PCRE_EXTRA_MATCH_LIMIT_RECURSION is set in the <em>flags</em> field. If the limit is exceeded, <strong>pcre_exec()</strong> returns PCRE_ERROR_RECURSIONLIMIT.</p><p>A value for the recursion limit may also be supplied by an item at the start of a pattern of the form</p>
<pre>
  (*LIMIT_RECURSION=d)
</pre>
<p>where d is a decimal number. However, such a setting is ignored unless d is less than the limit set by the caller of <strong>pcre_exec()</strong> or, if no such limit is set, less than the default.</p><p>The <em>callout_data</em> field is used in conjunction with the "callout" feature, and is described in the <strong>pcrecallout</strong> documentation.</p><p>The <em>tables</em> field is provided for use with patterns that have been pre-compiled using custom character tables, saved to disc or elsewhere, and then reloaded, because the tables that were used to compile a pattern are not saved with it. See the <strong>pcreprecompile</strong> documentation for a discussion of saving compiled patterns for later use. If NULL is passed using this mechanism, it forces PCRE's internal tables to be used.</p><p><strong>Warning:</strong> The tables that <strong>pcre_exec()</strong> uses must be the same as those that were used when the pattern was compiled. If this is not the case, the behaviour of <strong>pcre_exec()</strong> is undefined. Therefore, when a pattern is compiled and matched in the same process, this field should never be set. In this (the most common) case, the correct table pointer is automatically passed with the compiled pattern from <strong>pcre_compile()</strong> to <strong>pcre_exec()</strong>.</p><p>If PCRE_EXTRA_MARK is set in the <em>flags</em> field, the <em>mark</em> field must be set to point to a suitable variable. If the pattern contains any backtracking control verbs such as (*MARK:NAME), and the execution ends up with a name to pass back, a pointer to the name string (zero terminated) is placed in the variable pointed to by the <em>mark</em> field. The names are within the compiled pattern; if you wish to retain such a name you must copy it before freeing the memory of a compiled pattern. If there is no name to pass back, the variable pointed to by the <em>mark</em> field is set to NULL. For details of the backtracking control verbs, see the section entitled "Backtracking control" in the <strong>pcrepattern</strong> documentation.</p>
<h3>Option bits for \fBpcre_exec()\fP</h3>
<p>The unused bits of the <em>options</em> argument for <strong>pcre_exec()</strong> must be zero. The only bits that may be set are PCRE_ANCHORED, PCRE_NEWLINE_<em>xxx</em>, PCRE_NOTBOL, PCRE_NOTEOL, PCRE_NOTEMPTY, PCRE_NOTEMPTY_ATSTART, PCRE_NO_START_OPTIMIZE, PCRE_NO_UTF8_CHECK, PCRE_PARTIAL_HARD, and PCRE_PARTIAL_SOFT.</p><p>If the pattern was successfully studied with one of the just-in-time (JIT) compile options, the only supported options for JIT execution are PCRE_NO_UTF8_CHECK, PCRE_NOTBOL, PCRE_NOTEOL, PCRE_NOTEMPTY, PCRE_NOTEMPTY_ATSTART, PCRE_PARTIAL_HARD, and PCRE_PARTIAL_SOFT. If an unsupported option is used, JIT execution is disabled and the normal interpretive code in <strong>pcre_exec()</strong> is run.</p>
<pre>
  PCRE_ANCHORED
</pre>
<p>The PCRE_ANCHORED option limits <strong>pcre_exec()</strong> to matching at the first matching position. If a pattern was compiled with PCRE_ANCHORED, or turned out to be anchored by virtue of its contents, it cannot be made unachored at matching time.</p>
<pre>
  PCRE_BSR_ANYCRLF
  PCRE_BSR_UNICODE
</pre>
<p>These options (which are mutually exclusive) control what the &#92;R escape sequence matches. The choice is either to match only CR, LF, or CRLF, or to match any Unicode newline sequence. These options override the choice that was made or defaulted when the pattern was compiled.</p>
<pre>
  PCRE_NEWLINE_CR
  PCRE_NEWLINE_LF
  PCRE_NEWLINE_CRLF
  PCRE_NEWLINE_ANYCRLF
  PCRE_NEWLINE_ANY
</pre>
<p>These options override the newline definition that was chosen or defaulted when the pattern was compiled. For details, see the description of <strong>pcre_compile()</strong> above. During matching, the newline choice affects the behaviour of the dot, circumflex, and dollar metacharacters. It may also alter the way the match position is advanced after a match failure for an unanchored pattern.</p><p>When PCRE_NEWLINE_CRLF, PCRE_NEWLINE_ANYCRLF, or PCRE_NEWLINE_ANY is set, and a match attempt for an unanchored pattern fails when the current position is at a CRLF sequence, and the pattern contains no explicit matches for CR or LF characters, the match position is advanced by two characters instead of one, in other words, to after the CRLF.</p><p>The above rule is a compromise that makes the most common cases work as expected. For example, if the pattern is .+A (and the PCRE_DOTALL option is not set), it does not match the string "&#92;r&#92;nA" because, after failing at the start, it skips both the CR and the LF before retrying. However, the pattern [&#92;r&#92;n]A does match that string, because it contains an explicit CR or LF reference, and so advances only by one character after the first failure.</p><p>An explicit match for CR of LF is either a literal appearance of one of those characters, or one of the &#92;r or &#92;n escape sequences. Implicit matches such as [^X] do not count, nor does &#92;s (which includes CR and LF in the characters that it matches).</p><p>Notwithstanding the above, anomalous effects may still occur when CRLF is a valid newline sequence and explicit &#92;r or &#92;n escapes appear in the pattern.</p>
<pre>
  PCRE_NOTBOL
</pre>
<p>This option specifies that first character of the subject string is not the beginning of a line, so the circumflex metacharacter should not match before it. Setting this without PCRE_MULTILINE (at compile time) causes circumflex never to match. This option affects only the behaviour of the circumflex metacharacter. It does not affect &#92;A.</p>
<pre>
  PCRE_NOTEOL
</pre>
<p>This option specifies that the end of the subject string is not the end of a line, so the dollar metacharacter should not match it nor (except in multiline mode) a newline immediately before it. Setting this without PCRE_MULTILINE (at compile time) causes dollar never to match. This option affects only the behaviour of the dollar metacharacter. It does not affect &#92;Z or &#92;z.</p>
<pre>
  PCRE_NOTEMPTY
</pre>
<p>An empty string is not considered to be a valid match if this option is set. If there are alternatives in the pattern, they are tried. If all the alternatives match the empty string, the entire match fails. For example, if the pattern</p>
<pre>
  a?b?
</pre>
<p>is applied to a string not beginning with "a" or "b", it matches an empty string at the start of the subject. With PCRE_NOTEMPTY set, this match is not valid, so PCRE searches further into the string for occurrences of "a" or "b".</p>
<pre>
  PCRE_NOTEMPTY_ATSTART
</pre>
<p>This is like PCRE_NOTEMPTY, except that an empty string match that is not at the start of the subject is permitted. If the pattern is anchored, such a match can occur only if the pattern contains &#92;K.</p><p>Perl has no direct equivalent of PCRE_NOTEMPTY or PCRE_NOTEMPTY_ATSTART, but it does make a special case of a pattern match of the empty string within its <strong>split()</strong> function, and when using the /g modifier. It is possible to emulate Perl's behaviour after matching a null string by first trying the match again at the same offset with PCRE_NOTEMPTY_ATSTART and PCRE_ANCHORED, and then if that fails, by advancing the starting offset (see below) and trying an ordinary match again. There is some code that demonstrates how to do this in the <strong>pcredemo</strong> sample program. In the most general case, you have to check to see if the newline convention recognizes CRLF as a newline, and if so, and the current character is CR followed by LF, advance the starting offset by two characters instead of one.</p>
<pre>
  PCRE_NO_START_OPTIMIZE
</pre>
<p>There are a number of optimizations that <strong>pcre_exec()</strong> uses at the start of a match, in order to speed up the process. For example, if it is known that an unanchored match must start with a specific character, it searches the subject for that character, and fails immediately if it cannot find it, without actually running the main matching function. This means that a special item such as (*COMMIT) at the start of a pattern is not considered until after a suitable starting point for the match has been found. Also, when callouts or (*MARK) items are in use, these "start-up" optimizations can cause them to be skipped if the pattern is never actually used. The start-up optimizations are in effect a pre-scan of the subject that takes place before the pattern is run.</p><p>The PCRE_NO_START_OPTIMIZE option disables the start-up optimizations, possibly causing performance to suffer, but ensuring that in cases where the result is "no match", the callouts do occur, and that items such as (*COMMIT) and (*MARK) are considered at every possible starting position in the subject string. If PCRE_NO_START_OPTIMIZE is set at compile time, it cannot be unset at matching time. The use of PCRE_NO_START_OPTIMIZE at matching time (that is, passing it to <strong>pcre_exec()</strong>) disables JIT execution; in this situation, matching is always done using interpretively.</p><p>Setting PCRE_NO_START_OPTIMIZE can change the outcome of a matching operation. Consider the pattern</p>
<pre>
  (*COMMIT)ABC
</pre>
<p>When this is compiled, PCRE records the fact that a match must start with the character "A". Suppose the subject string is "DEFABC". The start-up optimization scans along the subject, finds "A" and runs the first match attempt from there. The (*COMMIT) item means that the pattern must match the current starting position, which in this case, it does. However, if the same match is run with PCRE_NO_START_OPTIMIZE set, the initial scan along the subject string does not happen. The first match attempt is run starting from "D" and when this fails, (*COMMIT) prevents any further matches being tried, so the overall result is "no match". If the pattern is studied, more start-up optimizations may be used. For example, a minimum length for the subject may be recorded. Consider the pattern</p>
<pre>
  (*MARK:A)(X|Y)
</pre>
<p>The minimum length for a match is one character. If the subject is "ABC", there will be attempts to match "ABC", "BC", "C", and then finally an empty string. If the pattern is studied, the final attempt does not take place, because PCRE knows that the subject is too short, and so the (*MARK) is never encountered. In this case, studying the pattern does not affect the overall match result, which is still "no match", but it does affect the auxiliary information that is returned.</p>
<pre>
  PCRE_NO_UTF8_CHECK
</pre>
<p>When PCRE_UTF8 is set at compile time, the validity of the subject as a UTF-8 string is automatically checked when <strong>pcre_exec()</strong> is subsequently called. The entire string is checked before any other processing takes place. The value of <em>startoffset</em> is also checked to ensure that it points to the start of a UTF-8 character. There is a discussion about the validity of UTF-8 strings in the <strong>pcreunicode</strong> page. If an invalid sequence of bytes is found, <strong>pcre_exec()</strong> returns the error PCRE_ERROR_BADUTF8 or, if PCRE_PARTIAL_HARD is set and the problem is a truncated character at the end of the subject, PCRE_ERROR_SHORTUTF8. In both cases, information about the precise nature of the error may also be returned (see the descriptions of these errors in the section entitled <em>Error return</em> values from <strong>pcre_exec()</strong> below). If <em>startoffset</em> contains a value that does not point to the start of a UTF-8 character (or to the end of the subject), PCRE_ERROR_BADUTF8_OFFSET is returned.</p><p>If you already know that your subject is valid, and you want to skip these checks for performance reasons, you can set the PCRE_NO_UTF8_CHECK option when calling <strong>pcre_exec()</strong>. You might want to do this for the second and subsequent calls to <strong>pcre_exec()</strong> if you are making repeated calls to find all the matches in a single subject string. However, you should be sure that the value of <em>startoffset</em> points to the start of a character (or the end of the subject). When PCRE_NO_UTF8_CHECK is set, the effect of passing an invalid string as a subject or an invalid value of <em>startoffset</em> is undefined. Your program may crash or loop.</p>
<pre>
  PCRE_PARTIAL_HARD
  PCRE_PARTIAL_SOFT
</pre>
<p>These options turn on the partial matching feature. For backwards compatibility, PCRE_PARTIAL is a synonym for PCRE_PARTIAL_SOFT. A partial match occurs if the end of the subject string is reached successfully, but there are not enough subject characters to complete the match. If this happens when PCRE_PARTIAL_SOFT (but not PCRE_PARTIAL_HARD) is set, matching continues by testing any remaining alternatives. Only if no complete match can be found is PCRE_ERROR_PARTIAL returned instead of PCRE_ERROR_NOMATCH. In other words, PCRE_PARTIAL_SOFT says that the caller is prepared to handle a partial match, but only if no complete match can be found.</p><p>If PCRE_PARTIAL_HARD is set, it overrides PCRE_PARTIAL_SOFT. In this case, if a partial match is found, <strong>pcre_exec()</strong> immediately returns PCRE_ERROR_PARTIAL, without considering any other alternatives. In other words, when PCRE_PARTIAL_HARD is set, a partial match is considered to be more important that an alternative complete match.</p><p>In both cases, the portion of the string that was inspected when the partial match was found is set as the first matching string. There is a more detailed discussion of partial and multi-segment matching, with examples, in the <strong>pcrepartial</strong> documentation.</p>
<h3>The string to be matched by \fBpcre_exec()\fP</h3>
<p>The subject string is passed to <strong>pcre_exec()</strong> as a pointer in <em>subject</em>, a length in <em>length</em>, and a starting offset in <em>startoffset</em>. The units for <em>length</em> and <em>startoffset</em> are bytes for the 8-bit library, 16-bit data items for the 16-bit library, and 32-bit data items for the 32-bit library.</p><p>If <em>startoffset</em> is negative or greater than the length of the subject, <strong>pcre_exec()</strong> returns PCRE_ERROR_BADOFFSET. When the starting offset is zero, the search for a match starts at the beginning of the subject, and this is by far the most common case. In UTF-8 or UTF-16 mode, the offset must point to the start of a character, or the end of the subject (in UTF-32 mode, one data unit equals one character, so all offsets are valid). Unlike the pattern string, the subject may contain binary zeroes.</p><p>A non-zero starting offset is useful when searching for another match in the same subject by calling <strong>pcre_exec()</strong> again after a previous success. Setting <em>startoffset</em> differs from just passing over a shortened string and setting PCRE_NOTBOL in the case of a pattern that begins with any kind of lookbehind. For example, consider the pattern</p>
<pre>
  &#92;Biss&#92;B
</pre>
<p>which finds occurrences of "iss" in the middle of words. (&#92;B matches only if the current position in the subject is not a word boundary.) When applied to the string "Mississipi" the first call to <strong>pcre_exec()</strong> finds the first occurrence. If <strong>pcre_exec()</strong> is called again with just the remainder of the subject, namely "issipi", it does not match, because &#92;B is always false at the start of the subject, which is deemed to be a word boundary. However, if <strong>pcre_exec()</strong> is passed the entire string again, but with <em>startoffset</em> set to 4, it finds the second occurrence of "iss" because it is able to look behind the starting point to discover that it is preceded by a letter.</p><p>Finding all the matches in a subject is tricky when the pattern can match an empty string. It is possible to emulate Perl's /g behaviour by first trying the match again at the same offset, with the PCRE_NOTEMPTY_ATSTART and PCRE_ANCHORED options, and then if that fails, advancing the starting offset and trying an ordinary match again. There is some code that demonstrates how to do this in the <strong>pcredemo</strong> sample program. In the most general case, you have to check to see if the newline convention recognizes CRLF as a newline, and if so, and the current character is CR followed by LF, advance the starting offset by two characters instead of one.</p><p>If a non-zero starting offset is passed when the pattern is anchored, one attempt to match at the given offset is made. This can only succeed if the pattern does not require the match to be at the start of the subject.</p>
<h3>How \fBpcre_exec()\fP returns captured substrings</h3>
<p>In general, a pattern matches a certain portion of the subject, and in addition, further substrings from the subject may be picked out by parts of the pattern. Following the usage in Jeffrey Friedl's book, this is called "capturing" in what follows, and the phrase "capturing subpattern" is used for a fragment of a pattern that picks out a substring. PCRE supports several other kinds of parenthesized subpattern that do not cause substrings to be captured.</p><p>Captured substrings are returned to the caller via a vector of integers whose address is passed in <em>ovector</em>. The number of elements in the vector is passed in <em>ovecsize</em>, which must be a non-negative number. <strong>Note</strong>: this argument is NOT the size of <em>ovector</em> in bytes.</p><p>The first two-thirds of the vector is used to pass back captured substrings, each substring using a pair of integers. The remaining third of the vector is used as workspace by <strong>pcre_exec()</strong> while matching capturing subpatterns, and is not available for passing back information. The number passed in <em>ovecsize</em> should always be a multiple of three. If it is not, it is rounded down.</p><p>When a match is successful, information about captured substrings is returned in pairs of integers, starting at the beginning of <em>ovector</em>, and continuing up to two-thirds of its length at the most. The first element of each pair is set to the offset of the first character in a substring, and the second is set to the offset of the first character after the end of a substring. These values are always data unit offsets, even in UTF mode. They are byte offsets in the 8-bit library, 16-bit data item offsets in the 16-bit library, and 32-bit data item offsets in the 32-bit library. <strong>Note</strong>: they are not character counts.</p><p>The first pair of integers, <em>ovector[0]</em> and <em>ovector[1]</em>, identify the portion of the subject string matched by the entire pattern. The next pair is used for the first capturing subpattern, and so on. The value returned by <strong>pcre_exec()</strong> is one more than the highest numbered pair that has been set. For example, if two substrings have been captured, the returned value is 3. If there are no capturing subpatterns, the return value from a successful match is 1, indicating that just the first pair of offsets has been set.</p><p>If a capturing subpattern is matched repeatedly, it is the last portion of the string that it matched that is returned.</p><p>If the vector is too small to hold all the captured substring offsets, it is used as far as possible (up to two-thirds of its length), and the function returns a value of zero. If neither the actual string matched nor any captured substrings are of interest, <strong>pcre_exec()</strong> may be called with <em>ovector</em> passed as NULL and <em>ovecsize</em> as zero. However, if the pattern contains back references and the <em>ovector</em> is not big enough to remember the related substrings, PCRE has to get additional memory for use during matching. Thus it is usually advisable to supply an <em>ovector</em> of reasonable size.</p><p>There are some cases where zero is returned (indicating vector overflow) when in fact the vector is exactly the right size for the final match. For example, consider the pattern</p>
<pre>
  (a)(?:(b)c|bd)
</pre>
<p>If a vector of 6 elements (allowing for only 1 captured substring) is given with subject string "abd", <strong>pcre_exec()</strong> will try to set the second captured string, thereby recording a vector overflow, before failing to match "c" and backing up to try the second alternative. The zero return, however, does correctly indicate that the maximum number of slots (namely 2) have been filled. In similar cases where there is temporary overflow, but the final number of used slots is actually less than the maximum, a non-zero value is returned.</p><p>The <strong>pcre_fullinfo()</strong> function can be used to find out how many capturing subpatterns there are in a compiled pattern. The smallest size for <em>ovector</em> that will allow for <em>n</em> captured substrings, in addition to the offsets of the substring matched by the whole pattern, is (<em>n</em>+1)*3.</p><p>It is possible for capturing subpattern number <em>n+1</em> to match some part of the subject when subpattern <em>n</em> has not been used at all. For example, if the string "abc" is matched against the pattern (a|(z))(bc) the return from the function is 4, and subpatterns 1 and 3 are matched, but 2 is not. When this happens, both values in the offset pairs corresponding to unused subpatterns are set to -1.</p><p>Offset values that correspond to unused subpatterns at the end of the expression are also set to -1. For example, if the string "abc" is matched against the pattern (abc)(x(yz)?)? subpatterns 2 and 3 are not matched. The return from the function is 2, because the highest used capturing subpattern number is 1, and the offsets for for the second and third capturing subpatterns (assuming the vector is large enough, of course) are set to -1.</p><p><strong>Note</strong>: Elements in the first two-thirds of <em>ovector</em> that do not correspond to capturing parentheses in the pattern are never changed. That is, if a pattern contains <em>n</em> capturing parentheses, no more than <em>ovector[0]</em> to <em>ovector[2n+1]</em> are set by <strong>pcre_exec()</strong>. The other elements (in the first two-thirds) retain whatever values they previously had.</p><p>Some convenience functions are provided for extracting the captured substrings as separate strings. These are described below.</p>
<h3>Error return values from \fBpcre_exec()\fP</h3>
<p>If <strong>pcre_exec()</strong> fails, it returns a negative number. The following are defined in the header file:</p>
<pre>
  PCRE_ERROR_NOMATCH        (-1)
</pre>
<p>The subject string did not match the pattern.</p>
<pre>
  PCRE_ERROR_NULL           (-2)
</pre>
<p>Either <em>code</em> or <em>subject</em> was passed as NULL, or <em>ovector</em> was NULL and <em>ovecsize</em> was not zero.</p>
<pre>
  PCRE_ERROR_BADOPTION      (-3)
</pre>
<p>An unrecognized bit was set in the <em>options</em> argument.</p>
<pre>
  PCRE_ERROR_BADMAGIC       (-4)
</pre>
<p>PCRE stores a 4-byte "magic number" at the start of the compiled code, to catch the case when it is passed a junk pointer and to detect when a pattern that was compiled in an environment of one endianness is run in an environment with the other endianness. This is the error that PCRE gives when the magic number is not present.</p>
<pre>
  PCRE_ERROR_UNKNOWN_OPCODE (-5)
</pre>
<p>While running the pattern match, an unknown item was encountered in the compiled pattern. This error could be caused by a bug in PCRE or by overwriting of the compiled pattern.</p>
<pre>
  PCRE_ERROR_NOMEMORY       (-6)
</pre>
<p>If a pattern contains back references, but the <em>ovector</em> that is passed to <strong>pcre_exec()</strong> is not big enough to remember the referenced substrings, PCRE gets a block of memory at the start of matching to use for this purpose. If the call via <strong>pcre_malloc()</strong> fails, this error is given. The memory is automatically freed at the end of matching.</p><p>This error is also given if <strong>pcre_stack_malloc()</strong> fails in <strong>pcre_exec()</strong>. This can happen only when PCRE has been compiled with <strong>--disable-stack-for-recursion</strong>.</p>
<pre>
  PCRE_ERROR_NOSUBSTRING    (-7)
</pre>
<p>This error is used by the <strong>pcre_copy_substring()</strong>, <strong>pcre_get_substring()</strong>, and <strong>pcre_get_substring_list()</strong> functions (see below). It is never returned by <strong>pcre_exec()</strong>.</p>
<pre>
  PCRE_ERROR_MATCHLIMIT     (-8)
</pre>
<p>The backtracking limit, as specified by the <em>match_limit</em> field in a <strong>pcre_extra</strong> structure (or defaulted) was reached. See the description above.</p>
<pre>
  PCRE_ERROR_CALLOUT        (-9)
</pre>
<p>This error is never generated by <strong>pcre_exec()</strong> itself. It is provided for use by callout functions that want to yield a distinctive error code. See the <strong>pcrecallout</strong> documentation for details.</p>
<pre>
  PCRE_ERROR_BADUTF8        (-10)
</pre>
<p>A string that contains an invalid UTF-8 byte sequence was passed as a subject, and the PCRE_NO_UTF8_CHECK option was not set. If the size of the output vector (<em>ovecsize</em>) is at least 2, the byte offset to the start of the the invalid UTF-8 character is placed in the first element, and a reason code is placed in the second element. The reason codes are listed in the following section. For backward compatibility, if PCRE_PARTIAL_HARD is set and the problem is a truncated UTF-8 character at the end of the subject (reason codes 1 to 5), PCRE_ERROR_SHORTUTF8 is returned instead of PCRE_ERROR_BADUTF8.</p>
<pre>
  PCRE_ERROR_BADUTF8_OFFSET (-11)
</pre>
<p>The UTF-8 byte sequence that was passed as a subject was checked and found to be valid (the PCRE_NO_UTF8_CHECK option was not set), but the value of <em>startoffset</em> did not point to the beginning of a UTF-8 character or the end of the subject.</p>
<pre>
  PCRE_ERROR_PARTIAL        (-12)
</pre>
<p>The subject string did not match, but it did match partially. See the <strong>pcrepartial</strong> documentation for details of partial matching.</p>
<pre>
  PCRE_ERROR_BADPARTIAL     (-13)
</pre>
<p>This code is no longer in use. It was formerly returned when the PCRE_PARTIAL option was used with a compiled pattern containing items that were not supported for partial matching. From release 8.00 onwards, there are no restrictions on partial matching.</p>
<pre>
  PCRE_ERROR_INTERNAL       (-14)
</pre>
<p>An unexpected internal error has occurred. This error could be caused by a bug in PCRE or by overwriting of the compiled pattern.</p>
<pre>
  PCRE_ERROR_BADCOUNT       (-15)
</pre>
<p>This error is given if the value of the <em>ovecsize</em> argument is negative.</p>
<pre>
  PCRE_ERROR_RECURSIONLIMIT (-21)
</pre>
<p>The internal recursion limit, as specified by the <em>match_limit_recursion</em> field in a <strong>pcre_extra</strong> structure (or defaulted) was reached. See the description above.</p>
<pre>
  PCRE_ERROR_BADNEWLINE     (-23)
</pre>
<p>An invalid combination of PCRE_NEWLINE_<em>xxx</em> options was given.</p>
<pre>
  PCRE_ERROR_BADOFFSET      (-24)
</pre>
<p>The value of <em>startoffset</em> was negative or greater than the length of the subject, that is, the value in <em>length</em>.</p>
<pre>
  PCRE_ERROR_SHORTUTF8      (-25)
</pre>
<p>This error is returned instead of PCRE_ERROR_BADUTF8 when the subject string ends with a truncated UTF-8 character and the PCRE_PARTIAL_HARD option is set. Information about the failure is returned as for PCRE_ERROR_BADUTF8. It is in fact sufficient to detect this case, but this special error code for PCRE_PARTIAL_HARD precedes the implementation of returned information; it is retained for backwards compatibility.</p>
<pre>
  PCRE_ERROR_RECURSELOOP    (-26)
</pre>
<p>This error is returned when <strong>pcre_exec()</strong> detects a recursion loop within the pattern. Specifically, it means that either the whole pattern or a subpattern has been called recursively for the second time at the same position in the subject string. Some simple patterns that might do this are detected and faulted at compile time, but more complicated cases, in particular mutual recursions between two different subpatterns, cannot be detected until run time.</p>
<pre>
  PCRE_ERROR_JIT_STACKLIMIT (-27)
</pre>
<p>This error is returned when a pattern that was successfully studied using a JIT compile option is being matched, but the memory available for the just-in-time processing stack is not large enough. See the <strong>pcrejit</strong> documentation for more details.</p>
<pre>
  PCRE_ERROR_BADMODE        (-28)
</pre>
<p>This error is given if a pattern that was compiled by the 8-bit library is passed to a 16-bit or 32-bit library function, or vice versa.</p>
<pre>
  PCRE_ERROR_BADENDIANNESS  (-29)
</pre>
<p>This error is given if a pattern that was compiled and saved is reloaded on a host with different endianness. The utility function <strong>pcre_pattern_to_host_byte_order()</strong> can be used to convert such a pattern so that it runs on the new host.</p>
<pre>
  PCRE_ERROR_JIT_BADOPTION
</pre>
<p>This error is returned when a pattern that was successfully studied using a JIT compile option is being matched, but the matching mode (partial or complete match) does not correspond to any JIT compilation mode. When the JIT fast path function is used, this error may be also given for invalid options. See the <strong>pcrejit</strong> documentation for more details.</p>
<pre>
  PCRE_ERROR_BADLENGTH      (-32)
</pre>
<p>This error is given if <strong>pcre_exec()</strong> is called with a negative value for the <em>length</em> argument.</p><p>Error numbers -16 to -20, -22, and 30 are not used by <strong>pcre_exec()</strong>.</p>
<h3>Reason codes for invalid UTF-8 strings</h3>
<p>This section applies only to the 8-bit library. The corresponding information for the 16-bit and 32-bit libraries is given in the <strong>pcre16</strong> and <strong>pcre32</strong> pages.</p><p>When <strong>pcre_exec()</strong> returns either PCRE_ERROR_BADUTF8 or PCRE_ERROR_SHORTUTF8, and the size of the output vector (<em>ovecsize</em>) is at least 2, the offset of the start of the invalid UTF-8 character is placed in the first output vector element (<em>ovector[0]</em>) and a reason code is placed in the second element (<em>ovector[1]</em>). The reason codes are given names in the <strong>pcre.h</strong> header file:</p>
<pre>
  PCRE_UTF8_ERR1
  PCRE_UTF8_ERR2
  PCRE_UTF8_ERR3
  PCRE_UTF8_ERR4
  PCRE_UTF8_ERR5
</pre>
<p>The string ends with a truncated UTF-8 character; the code specifies how many bytes are missing (1 to 5). Although RFC 3629 restricts UTF-8 characters to be no longer than 4 bytes, the encoding scheme (originally defined by RFC 2279) allows for up to 6 bytes, and this is checked first; hence the possibility of 4 or 5 missing bytes.</p>
<pre>
  PCRE_UTF8_ERR6
  PCRE_UTF8_ERR7
  PCRE_UTF8_ERR8
  PCRE_UTF8_ERR9
  PCRE_UTF8_ERR10
</pre>
<p>The two most significant bits of the 2nd, 3rd, 4th, 5th, or 6th byte of the character do not have the binary value 0b10 (that is, either the most significant bit is 0, or the next bit is 1).</p>
<pre>
  PCRE_UTF8_ERR11
  PCRE_UTF8_ERR12
</pre>
<p>A character that is valid by the RFC 2279 rules is either 5 or 6 bytes long; these code points are excluded by RFC 3629.</p>
<pre>
  PCRE_UTF8_ERR13
</pre>
<p>A 4-byte character has a value greater than 0x10fff; these code points are excluded by RFC 3629.</p>
<pre>
  PCRE_UTF8_ERR14
</pre>
<p>A 3-byte character has a value in the range 0xd800 to 0xdfff; this range of code points are reserved by RFC 3629 for use with UTF-16, and so are excluded from UTF-8.</p>
<pre>
  PCRE_UTF8_ERR15
  PCRE_UTF8_ERR16
  PCRE_UTF8_ERR17
  PCRE_UTF8_ERR18
  PCRE_UTF8_ERR19
</pre>
<p>A 2-, 3-, 4-, 5-, or 6-byte character is "overlong", that is, it codes for a value that can be represented by fewer bytes, which is invalid. For example, the two bytes 0xc0, 0xae give the value 0x2e, whose correct coding uses just one byte.</p>
<pre>
  PCRE_UTF8_ERR20
</pre>
<p>The two most significant bits of the first byte of a character have the binary value 0b10 (that is, the most significant bit is 1 and the second is 0). Such a byte can only validly occur as the second or subsequent byte of a multi-byte character.</p>
<pre>
  PCRE_UTF8_ERR21
</pre>
<p>The first byte of a character has the value 0xfe or 0xff. These values can never occur in a valid UTF-8 string.</p>
<pre>
  PCRE_UTF8_ERR22
</pre>
<p>This error code was formerly used when the presence of a so-called "non-character" caused an error. Unicode corrigendum #9 makes it clear that such characters should not cause a string to be rejected, and so this code is no longer in use and is never returned.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXTRACTING CAPTURED SUBSTRINGS BY NUMBER</h2>
        <div class="sectioncontent">

<pre>
<strong>int pcre_copy_substring(const char *</strong><em>subject</em><strong>, int *</strong><em>ovector</em><strong>,</strong>
<strong>     int </strong><em>stringcount</em><strong>, int </strong><em>stringnumber</em><strong>, char *</strong><em>buffer</em><strong>,</strong>
<strong>     int </strong><em>buffersize</em><strong>);</strong>

<strong>int pcre_get_substring(const char *</strong><em>subject</em><strong>, int *</strong><em>ovector</em><strong>,</strong>
<strong>     int </strong><em>stringcount</em><strong>, int </strong><em>stringnumber</em><strong>,</strong>
<strong>     const char **</strong><em>stringptr</em><strong>);</strong>

<strong>int pcre_get_substring_list(const char *</strong><em>subject</em><strong>,</strong>
<strong>     int *</strong><em>ovector</em><strong>, int </strong><em>stringcount</em><strong>, const char ***</strong><em>listptr</em><strong>);</strong>
</pre>
<p>Captured substrings can be accessed directly by using the offsets returned by <strong>pcre_exec()</strong> in <em>ovector</em>. For convenience, the functions <strong>pcre_copy_substring()</strong>, <strong>pcre_get_substring()</strong>, and <strong>pcre_get_substring_list()</strong> are provided for extracting captured substrings as new, separate, zero-terminated strings. These functions identify substrings by number. The next section describes functions for extracting named substrings.</p><p>A substring that contains a binary zero is correctly extracted and has a further zero added on the end, but the result is not, of course, a C string. However, you can process such a string by referring to the length that is returned by <strong>pcre_copy_substring()</strong> and <strong>pcre_get_substring()</strong>. Unfortunately, the interface to <strong>pcre_get_substring_list()</strong> is not adequate for handling strings containing binary zeros, because the end of the final string is not independently indicated.</p><p>The first three arguments are the same for all three of these functions: <em>subject</em> is the subject string that has just been successfully matched, <em>ovector</em> is a pointer to the vector of integer offsets that was passed to <strong>pcre_exec()</strong>, and <em>stringcount</em> is the number of substrings that were captured by the match, including the substring that matched the entire regular expression. This is the value returned by <strong>pcre_exec()</strong> if it is greater than zero. If <strong>pcre_exec()</strong> returned zero, indicating that it ran out of space in <em>ovector</em>, the value passed as <em>stringcount</em> should be the number of elements in the vector divided by three.</p><p>The functions <strong>pcre_copy_substring()</strong> and <strong>pcre_get_substring()</strong> extract a single substring, whose number is given as <em>stringnumber</em>. A value of zero extracts the substring that matched the entire pattern, whereas higher values extract the captured substrings. For <strong>pcre_copy_substring()</strong>, the string is placed in <em>buffer</em>, whose length is given by <em>buffersize</em>, while for <strong>pcre_get_substring()</strong> a new block of memory is obtained via <strong>pcre_malloc</strong>, and its address is returned via <em>stringptr</em>. The yield of the function is the length of the string, not including the terminating zero, or one of these error codes:</p>
<pre>
  PCRE_ERROR_NOMEMORY       (-6)
</pre>
<p>The buffer was too small for <strong>pcre_copy_substring()</strong>, or the attempt to get memory failed for <strong>pcre_get_substring()</strong>.</p>
<pre>
  PCRE_ERROR_NOSUBSTRING    (-7)
</pre>
<p>There is no substring whose number is <em>stringnumber</em>.</p><p>The <strong>pcre_get_substring_list()</strong> function extracts all available substrings and builds a list of pointers to them. All this is done in a single block of memory that is obtained via <strong>pcre_malloc</strong>. The address of the memory block is returned via <em>listptr</em>, which is also the start of the list of string pointers. The end of the list is marked by a NULL pointer. The yield of the function is zero if all went well, or the error code</p>
<pre>
  PCRE_ERROR_NOMEMORY       (-6)
</pre>
<p>if the attempt to get the memory block failed.</p><p>When any of these functions encounter a substring that is unset, which can happen when capturing subpattern number <em>n+1</em> matches some part of the subject, but subpattern <em>n</em> has not been used at all, they return an empty string. This can be distinguished from a genuine zero-length substring by inspecting the appropriate offset in <em>ovector</em>, which is negative for unset substrings.</p><p>The two convenience functions <strong>pcre_free_substring()</strong> and <strong>pcre_free_substring_list()</strong> can be used to free the memory returned by a previous call of <strong>pcre_get_substring()</strong> or <strong>pcre_get_substring_list()</strong>, respectively. They do nothing more than call the function pointed to by <strong>pcre_free</strong>, which of course could be called directly from a C program. However, PCRE is used in some situations where it is linked via a special interface to another programming language that cannot use <strong>pcre_free</strong> directly; it is for these cases that the functions are provided.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXTRACTING CAPTURED SUBSTRINGS BY NAME</h2>
        <div class="sectioncontent">

<pre>
<strong>int pcre_get_stringnumber(const pcre *</strong><em>code</em><strong>,</strong>
<strong>     const char *</strong><em>name</em><strong>);</strong>

<strong>int pcre_copy_named_substring(const pcre *</strong><em>code</em><strong>,</strong>
<strong>     const char *</strong><em>subject</em><strong>, int *</strong><em>ovector</em><strong>,</strong>
<strong>     int </strong><em>stringcount</em><strong>, const char *</strong><em>stringname</em><strong>,</strong>
<strong>     char *</strong><em>buffer</em><strong>, int </strong><em>buffersize</em><strong>);</strong>

<strong>int pcre_get_named_substring(const pcre *</strong><em>code</em><strong>,</strong>
<strong>     const char *</strong><em>subject</em><strong>, int *</strong><em>ovector</em><strong>,</strong>
<strong>     int </strong><em>stringcount</em><strong>, const char *</strong><em>stringname</em><strong>,</strong>
<strong>     const char **</strong><em>stringptr</em><strong>);</strong>
</pre>
<p>To extract a substring by name, you first have to find associated number. For example, for this pattern</p>
<pre>
  (a+)b(?&lt;xxx&gt;&#92;d+)...
</pre>
<p>the number of the subpattern called "xxx" is 2. If the name is known to be unique (PCRE_DUPNAMES was not set), you can find the number from the name by calling <strong>pcre_get_stringnumber()</strong>. The first argument is the compiled pattern, and the second is the name. The yield of the function is the subpattern number, or PCRE_ERROR_NOSUBSTRING (-7) if there is no subpattern of that name.</p><p>Given the number, you can extract the substring directly, or use one of the functions described in the previous section. For convenience, there are also two functions that do the whole job.</p><p>Most of the arguments of <strong>pcre_copy_named_substring()</strong> and <strong>pcre_get_named_substring()</strong> are the same as those for the similarly named functions that extract by number. As these are described in the previous section, they are not re-described here. There are just two differences:</p><p>First, instead of a substring number, a substring name is given. Second, there is an extra argument, given at the start, which is a pointer to the compiled pattern. This is needed in order to gain access to the name-to-number translation table.</p><p>These functions call <strong>pcre_get_stringnumber()</strong>, and if it succeeds, they then call <strong>pcre_copy_substring()</strong> or <strong>pcre_get_substring()</strong>, as appropriate. <strong>NOTE:</strong> If PCRE_DUPNAMES is set and there are duplicate names, the behaviour may not be what you want (see the next section).</p><p><strong>Warning:</strong> If the pattern uses the (?| feature to set up multiple subpatterns with the same number, as described in the section on duplicate subpattern numbers in the <strong>pcrepattern</strong> page, you cannot use names to distinguish the different subpatterns, because names are not included in the compiled code. The matching process uses only numbers. For this reason, the use of different names for subpatterns of the same number causes an error at compile time.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DUPLICATE SUBPATTERN NAMES</h2>
        <div class="sectioncontent">

<pre>
<strong>int pcre_get_stringtable_entries(const pcre *</strong><em>code</em><strong>,</strong>
<strong>     const char *</strong><em>name</em><strong>, char **</strong><em>first</em><strong>, char **</strong><em>last</em><strong>);</strong>
</pre>
<p>When a pattern is compiled with the PCRE_DUPNAMES option, names for subpatterns are not required to be unique. (Duplicate names are always allowed for subpatterns with the same number, created by using the (?| feature. Indeed, if such subpatterns are named, they are required to use the same names.)</p><p>Normally, patterns with duplicate names are such that in any one match, only one of the named subpatterns participates. An example is shown in the <strong>pcrepattern</strong> documentation.</p><p>When duplicates are present, <strong>pcre_copy_named_substring()</strong> and <strong>pcre_get_named_substring()</strong> return the first substring corresponding to the given name that is set. If none are set, PCRE_ERROR_NOSUBSTRING (-7) is returned; no data is returned. The <strong>pcre_get_stringnumber()</strong> function returns one of the numbers that are associated with the name, but it is not defined which it is.</p><p>If you want to get full details of all captured substrings for a given name, you must use the <strong>pcre_get_stringtable_entries()</strong> function. The first argument is the compiled pattern, and the second is the name. The third and fourth are pointers to variables which are updated by the function. After it has run, they point to the first and last entries in the name-to-number table for the given name. The function itself returns the length of each entry, or PCRE_ERROR_NOSUBSTRING (-7) if there are none. The format of the table is described above in the section entitled <em>Information about a pattern</em> above. Given all the relevant entries for the name, you can extract each of their numbers, and hence the captured data, if any.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FINDING ALL POSSIBLE MATCHES</h2>
        <div class="sectioncontent">
<p>The traditional matching function uses a similar algorithm to Perl, which stops when it finds the first match, starting at a given point in the subject. If you want to find all possible matches, or the longest possible match, consider using the alternative matching function (see below) instead. If you cannot use the alternative function, but still need to find all possible matches, you can kludge it up by making use of the callout facility, which is described in the <strong>pcrecallout</strong> documentation.</p><p>What you have to do is to insert a callout right at the end of the pattern. When your callout function is called, extract and save the current matched substring. Then return 1, which forces <strong>pcre_exec()</strong> to backtrack and try other alternatives. Ultimately, when it runs out of matches, <strong>pcre_exec()</strong> will yield PCRE_ERROR_NOMATCH.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OBTAINING AN ESTIMATE OF STACK USAGE</h2>
        <div class="sectioncontent">
<p>Matching certain patterns using <strong>pcre_exec()</strong> can use a lot of process stack, which in certain environments can be rather limited in size. Some users find it helpful to have an estimate of the amount of stack that is used by <strong>pcre_exec()</strong>, to help them set recursion limits, as described in the <strong>pcrestack</strong> documentation. The estimate that is output by <strong>pcretest</strong> when called with the <strong>-m</strong> and <strong>-C</strong> options is obtained by calling <strong>pcre_exec</strong> with the values NULL, NULL, NULL, -999, and -999 for its first five arguments.</p><p>Normally, if its first argument is NULL, <strong>pcre_exec()</strong> immediately returns the negative error code PCRE_ERROR_NULL, but with this special combination of arguments, it returns instead a negative number whose absolute value is the approximate stack frame size in bytes. (A negative number is used so that it is clear that no match has happened.) The value is approximate because in some cases, recursive calls to <strong>pcre_exec()</strong> occur when there are one or two additional variables on the stack.</p><p>If PCRE has been compiled to use the heap instead of the stack for recursion, the value returned is the size of each block that is obtained from the heap.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MATCHING A PATTERN: THE ALTERNATIVE FUNCTION</h2>
        <div class="sectioncontent">

<pre>
<strong>int pcre_dfa_exec(const pcre *</strong><em>code</em><strong>, const pcre_extra *</strong><em>extra</em><strong>,</strong>
<strong>     const char *</strong><em>subject</em><strong>, int </strong><em>length</em><strong>, int </strong><em>startoffset</em><strong>,</strong>
<strong>     int </strong><em>options</em><strong>, int *</strong><em>ovector</em><strong>, int </strong><em>ovecsize</em><strong>,</strong>
<strong>     int *</strong><em>workspace</em><strong>, int </strong><em>wscount</em><strong>);</strong>
</pre>
<p>The function <strong>pcre_dfa_exec()</strong> is called to match a subject string against a compiled pattern, using a matching algorithm that scans the subject string just once, and does not backtrack. This has different characteristics to the normal algorithm, and is not compatible with Perl. Some of the features of PCRE patterns are not supported. Nevertheless, there are times when this kind of matching can be useful. For a discussion of the two matching algorithms, and a list of features that <strong>pcre_dfa_exec()</strong> does not support, see the <strong>pcrematching</strong> documentation.</p><p>The arguments for the <strong>pcre_dfa_exec()</strong> function are the same as for <strong>pcre_exec()</strong>, plus two extras. The <em>ovector</em> argument is used in a different way, and this is described below. The other common arguments are used in the same way as for <strong>pcre_exec()</strong>, so their description is not repeated here.</p><p>The two additional arguments provide workspace for the function. The workspace vector should contain at least 20 elements. It is used for keeping track of multiple paths through the pattern tree. More workspace will be needed for patterns and subjects where there are a lot of potential matches.</p><p>Here is an example of a simple call to <strong>pcre_dfa_exec()</strong>:</p>
<pre>
  int rc;
  int ovector[10];
  int wspace[20];
  rc = pcre_dfa_exec(
    re,             /* result of pcre_compile() */
    NULL,           /* we didn't study the pattern */
    "some string",  /* the subject string */
    11,             /* the length of the subject string */
    0,              /* start at offset 0 in the subject */
    0,              /* default options */
    ovector,        /* vector of integers for substring information */
    10,             /* number of elements (NOT size in bytes) */
    wspace,         /* working space vector */
    20);            /* number of elements (NOT size in bytes) */
</pre>
<h3>Option bits for \fBpcre_dfa_exec()\fP</h3>
<p>The unused bits of the <em>options</em> argument for <strong>pcre_dfa_exec()</strong> must be zero. The only bits that may be set are PCRE_ANCHORED, PCRE_NEWLINE_<em>xxx</em>, PCRE_NOTBOL, PCRE_NOTEOL, PCRE_NOTEMPTY, PCRE_NOTEMPTY_ATSTART, PCRE_NO_UTF8_CHECK, PCRE_BSR_ANYCRLF, PCRE_BSR_UNICODE, PCRE_NO_START_OPTIMIZE, PCRE_PARTIAL_HARD, PCRE_PARTIAL_SOFT, PCRE_DFA_SHORTEST, and PCRE_DFA_RESTART. All but the last four of these are exactly the same as for <strong>pcre_exec()</strong>, so their description is not repeated here.</p>
<pre>
  PCRE_PARTIAL_HARD
  PCRE_PARTIAL_SOFT
</pre>
<p>These have the same general effect as they do for <strong>pcre_exec()</strong>, but the details are slightly different. When PCRE_PARTIAL_HARD is set for <strong>pcre_dfa_exec()</strong>, it returns PCRE_ERROR_PARTIAL if the end of the subject is reached and there is still at least one matching possibility that requires additional characters. This happens even if some complete matches have also been found. When PCRE_PARTIAL_SOFT is set, the return code PCRE_ERROR_NOMATCH is converted into PCRE_ERROR_PARTIAL if the end of the subject is reached, there have been no complete matches, but there is still at least one matching possibility. The portion of the string that was inspected when the longest partial match was found is set as the first matching string in both cases. There is a more detailed discussion of partial and multi-segment matching, with examples, in the <strong>pcrepartial</strong> documentation.</p>
<pre>
  PCRE_DFA_SHORTEST
</pre>
<p>Setting the PCRE_DFA_SHORTEST option causes the matching algorithm to stop as soon as it has found one match. Because of the way the alternative algorithm works, this is necessarily the shortest possible match at the first possible matching point in the subject string.</p>
<pre>
  PCRE_DFA_RESTART
</pre>
<p>When <strong>pcre_dfa_exec()</strong> returns a partial match, it is possible to call it again, with additional subject characters, and have it continue with the same match. The PCRE_DFA_RESTART option requests this action; when it is set, the <em>workspace</em> and <em>wscount</em> options must reference the same vector as before because data about the match so far is left in them after a partial match. There is more discussion of this facility in the <strong>pcrepartial</strong> documentation.</p>
<h3>Successful returns from \fBpcre_dfa_exec()\fP</h3>
<p>When <strong>pcre_dfa_exec()</strong> succeeds, it may have matched more than one substring in the subject. Note, however, that all the matches from one run of the function start at the same point in the subject. The shorter matches are all initial substrings of the longer matches. For example, if the pattern</p>
<pre>
  &lt;.*&gt;
</pre>
<p>is matched against the string</p>
<pre>
  This is &lt;something&gt; &lt;something else&gt; &lt;something further&gt; no more
</pre>
<p>the three matched strings are</p>
<pre>
  &lt;something&gt;
  &lt;something&gt; &lt;something else&gt;
  &lt;something&gt; &lt;something else&gt; &lt;something further&gt;
</pre>
<p>On success, the yield of the function is a number greater than zero, which is the number of matched substrings. The substrings themselves are returned in <em>ovector</em>. Each string uses two elements; the first is the offset to the start, and the second is the offset to the end. In fact, all the strings have the same start offset. (Space could have been saved by giving this only once, but it was decided to retain some compatibility with the way <strong>pcre_exec()</strong> returns data, even though the meaning of the strings is different.)</p><p>The strings are returned in reverse order of length; that is, the longest matching string is given first. If there were too many matches to fit into <em>ovector</em>, the yield of the function is zero, and the vector is filled with the longest matches. Unlike <strong>pcre_exec()</strong>, <strong>pcre_dfa_exec()</strong> can use the entire <em>ovector</em> for returning matched strings.</p><p>NOTE: PCRE's "auto-possessification" optimization usually applies to character repeats at the end of a pattern (as well as internally). For example, the pattern "a&#92;d+" is compiled as if it were "a&#92;d++" because there is no point even considering the possibility of backtracking into the repeated digits. For DFA matching, this means that only one possible match is found. If you really do want multiple matches in such cases, either use an ungreedy repeat ("a&#92;d+?") or set the PCRE_NO_AUTO_POSSESS option when compiling.</p>
<h3>Error returns from \fBpcre_dfa_exec()\fP</h3>
<p>The <strong>pcre_dfa_exec()</strong> function returns a negative number when it fails. Many of the errors are the same as for <strong>pcre_exec()</strong>, and these are described above. There are in addition the following errors that are specific to <strong>pcre_dfa_exec()</strong>:</p>
<pre>
  PCRE_ERROR_DFA_UITEM      (-16)
</pre>
<p>This return is given if <strong>pcre_dfa_exec()</strong> encounters an item in the pattern that it does not support, for instance, the use of &#92;C or a back reference.</p>
<pre>
  PCRE_ERROR_DFA_UCOND      (-17)
</pre>
<p>This return is given if <strong>pcre_dfa_exec()</strong> encounters a condition item that uses a back reference for the condition, or a test for recursion in a specific group. These are not supported.</p>
<pre>
  PCRE_ERROR_DFA_UMLIMIT    (-18)
</pre>
<p>This return is given if <strong>pcre_dfa_exec()</strong> is called with an <em>extra</em> block that contains a setting of the <em>match_limit</em> or <em>match_limit_recursion</em> fields. This is not supported (these fields are meaningless for DFA matching).</p>
<pre>
  PCRE_ERROR_DFA_WSSIZE     (-19)
</pre>
<p>This return is given if <strong>pcre_dfa_exec()</strong> runs out of space in the <em>workspace</em> vector.</p>
<pre>
  PCRE_ERROR_DFA_RECURSE    (-20)
</pre>
<p>When a recursive subpattern is processed, the matching function calls itself recursively, using private vectors for <em>ovector</em> and <em>workspace</em>. This error is given if the output vector is not large enough. This should be extremely rare, as a vector of size 1000 is used.</p>
<pre>
  PCRE_ERROR_DFA_BADRESTART (-30)
</pre>
<p>When <strong>pcre_dfa_exec()</strong> is called with the <strong>PCRE_DFA_RESTART</strong> option, some plausibility checks are made on the contents of the workspace, which should contain data about the previous partial match. If any of these checks fail, this error is given.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO pcreapi&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man3/pcre16.3.html"><strong>pcre16</strong>(3)</a>, <a href="../man3/pcre32.3.html"><strong>pcre32</strong>(3)</a>, <a href="../man3/pcrebuild.3.html"><strong>pcrebuild</strong>(3)</a>, <a href="../man3/pcrecallout.3.html"><strong>pcrecallout</strong>(3)</a>, <a href="../man3/pcrecpp.3.html"><strong>pcrecpp</strong>(3)</a></strong>(3), <a href="../man3/pcrematching.3.html"><strong>pcrematching</strong>(3)</a>, <a href="../man3/pcrepartial.3.html"><strong>pcrepartial</strong>(3)</a>, <a href="../man3/pcreposix.3.html"><strong>pcreposix</strong>(3)</a>, <a href="../man3/pcreprecompile.3.html"><strong>pcreprecompile</strong>(3)</a>, <a href="../man3/pcresample.3.html"><strong>pcresample</strong>(3)</a>, <a href="../man3/pcrestack.3.html"><strong>pcrestack</strong>(3)</a>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">

<pre>
Philip Hazel
University Computing Service
Cambridge CB2 3QH, England.
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REVISION</h2>
        <div class="sectioncontent">

<pre>
Last updated: 18 December 2015
Copyright (c) 1997-2015 University of Cambridge.
</pre>

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="pcre_version.3.html"><span aria-hidden="true">&larr;</span> pcre_version.3: Perl-compatible regular expressions</a></li>
   <li class="next"><a href="pcrebuild.3.html">pcrebuild.3: Perl-compatible regular expressions <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>lxc.container.conf: Lxc container configuration file</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Lxc container configuration file">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="lxc.container.conf (5) manual">
  <meta name="twitter:description" content="Lxc container configuration file">
  <meta name="twitter:image" content="https://www.carta.tech/images/lxc-lxc.container.conf-5.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man5/lxc.container.conf.5.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="lxc.container.conf (5) manual" />
  <meta property="og:description" content="Lxc container configuration file" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/lxc-lxc.container.conf-5.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">lxc.container.conf<small> (5)</small></h1>
        <p class="lead">Lxc container configuration file</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/">
      <span itemprop="name">File formats and conventions</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/lxc.container.conf.5.html">
      <span itemprop="name">lxc.container.conf: Lxc container configuration file</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/lxc/">
      <span itemprop="name">lxc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/lxc.container.conf.5.html">
      <span itemprop="name">lxc.container.conf: Lxc container configuration file</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The linux containers (<strong>lxc</strong>) are always created before being used. This creation defines a set of system resources to be virtualized / isolated when a process is using the container. By default, the pids, sysv ipc and mount points are virtualized and isolated. The other system resources are shared across containers, until they are explicitly defined in the configuration file. For example, if there is no network configuration, the network will be shared between the creator of the container and the container itself, but if the network is specified, a new network stack is created for the container and the container can no longer use the network of its ancestor.</p><p>The configuration file defines the different system resources to be assigned for the container. At present, the utsname, the network, the mount points, the root file system, the user namespace, and the control groups are supported.</p><p>Each option in the configuration file has the form <strong>key</strong> = value fitting in one line. The '#' character means the line is a comment.</p><h3>CONFIGURATION</h3>
<p>In order to ease administration of multiple related containers, it is possible to have a container configuration file cause another file to be loaded. For instance, network configuration can be defined in one common file which is included by multiple containers. Then, if the containers are moved to another host, only one file may need to be updated.</p>
<dl class='dl-vertical'>
  <dt>
    <p>\*(T&lt;<strong>lxc.include</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>Specify the file to be included. The included file must be in the same valid lxc configuration file format.</p>
  </dd>

</dl>

<h3>ARCHITECTURE</h3>
<p>Allows one to set the architecture for the container. For example, set a 32bits architecture for a container running 32bits binaries on a 64bits host. This fixes the container scripts which rely on the architecture to do some work like downloading the packages.</p>
<dl class='dl-vertical'>
  <dt>
    <p>\*(T&lt;<strong>lxc.arch</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>Specify the architecture for the container.</p><p>Valid options are \*(T&lt;<strong>x86</strong>\*(T&gt;, \*(T&lt;<strong>i686</strong>\*(T&gt;, \*(T&lt;<strong>x86_64</strong>\*(T&gt;, \*(T&lt;<strong>amd64</strong>\*(T&gt;</p>
  </dd>

</dl>

<h3>HOSTNAME</h3>
<p>The utsname section defines the hostname to be set for the container. That means the container can set its own hostname without changing the one from the system. That makes the hostname private for the container.</p>
<dl class='dl-vertical'>
  <dt>
    <p>\*(T&lt;<strong>lxc.utsname</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>specify the hostname for the container</p>
  </dd>

</dl>

<h3>HALT SIGNAL</h3>
<p>Allows one to specify signal name or number, sent by lxc-stop to the container's init process to cleanly shutdown the container. Different init systems could use different signals to perform clean shutdown sequence. This option allows the signal to be specified in <a href="../man1/kill.1.html"><strong>kill</strong>(1)</a> fashion, e.g. SIGPWR, SIGRTMIN+14, SIGRTMAX-10 or plain number. The default signal is SIGPWR.</p>
<dl class='dl-vertical'>
  <dt>
    <p>\*(T&lt;<strong>lxc.haltsignal</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>specify the signal used to halt the container</p>
  </dd>

</dl>

<h3>STOP SIGNAL</h3>
<p>Allows one to specify signal name or number, sent by lxc-stop to forcibly shutdown the container. This option allows signal to be specified in <a href="../man1/kill.1.html"><strong>kill</strong>(1)</a> fashion, e.g. SIGKILL, SIGRTMIN+14, SIGRTMAX-10 or plain number. The default signal is SIGKILL.</p>
<dl class='dl-vertical'>
  <dt>
    <p>\*(T&lt;<strong>lxc.stopsignal</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>specify the signal used to stop the container</p>
  </dd>

</dl>

<h3>NETWORK</h3>
<p>The network section defines how the network is virtualized in the container. The network virtualization acts at layer two. In order to use the network virtualization, parameters must be specified to define the network interfaces of the container. Several virtual interfaces can be assigned and used in a container even if the system has only one physical network interface.</p>
<dl class='dl-vertical'>
  <dt>
    <p>\*(T&lt;<strong>lxc.network.type</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>specify what kind of network virtualization to be used for the container. Each time a \*(T&lt;<strong>lxc.network.type</strong>\*(T&gt; field is found a new round of network configuration begins. In this way, several network virtualization types can be specified for the same container, as well as assigning several network interfaces for one container. The different virtualization types can be:</p><p>\*(T&lt;<strong>none:</strong>\*(T&gt; will cause the container to share the host's network namespace. This means the host network devices are usable in the container. It also means that if both the container and host have upstart as init, 'halt' in a container (for instance) will shut down the host.</p><p>\*(T&lt;<strong>empty:</strong>\*(T&gt; will create only the loopback interface.</p><p>\*(T&lt;<strong>veth:</strong>\*(T&gt; a peer network device is created with one side assigned to the container and the other side is attached to a bridge specified by the \*(T&lt;<strong>lxc.network.link</strong>\*(T&gt;. If the bridge is not specified, then the veth pair device will be created but not attached to any bridge. Otherwise, the bridge has to be setup before on the system, <strong>lxc</strong> won't handle any configuration outside of the container. By default <strong>lxc</strong> choose a name for the network device belonging to the outside of the container, this name is handled by <strong>lxc</strong>, but if you wish to handle this name yourself, you can tell <strong>lxc</strong> to set a specific name with the \*(T&lt;<strong>lxc.network.veth.pair</strong>\*(T&gt; option (except for unprivileged containers where this option is ignored for security reasons).</p><p>\*(T&lt;<strong>vlan:</strong>\*(T&gt; a vlan interface is linked with the interface specified by the \*(T&lt;<strong>lxc.network.link</strong>\*(T&gt; and assigned to the container. The vlan identifier is specified with the option \*(T&lt;<strong>lxc.network.vlan.id</strong>\*(T&gt;.</p><p>\*(T&lt;<strong>macvlan:</strong>\*(T&gt; a macvlan interface is linked with the interface specified by the \*(T&lt;<strong>lxc.network.link</strong>\*(T&gt; and assigned to the container. \*(T&lt;<strong>lxc.network.macvlan.mode</strong>\*(T&gt; specifies the mode the macvlan will use to communicate between different macvlan on the same upper device. The accepted modes are \*(T&lt;<strong>private</strong>\*(T&gt;, the device never communicates with any other device on the same upper_dev (default), \*(T&lt;<strong>vepa</strong>\*(T&gt;, the new Virtual Ethernet Port Aggregator (VEPA) mode, it assumes that the adjacent bridge returns all frames where both source and destination are local to the macvlan port, i.e. the bridge is set up as a reflective relay. Broadcast frames coming in from the upper_dev get flooded to all macvlan interfaces in VEPA mode, local frames are not delivered locally, or \*(T&lt;<strong>bridge</strong>\*(T&gt;, it provides the behavior of a simple bridge between different macvlan interfaces on the same port. Frames from one interface to another one get delivered directly and are not sent out externally. Broadcast frames get flooded to all other bridge ports and to the external interface, but when they come back from a reflective relay, we don't deliver them again. Since we know all the MAC addresses, the macvlan bridge mode does not require learning or STP like the bridge module does.</p><p>\*(T&lt;<strong>phys:</strong>\*(T&gt; an already existing interface specified by the \*(T&lt;<strong>lxc.network.link</strong>\*(T&gt; is assigned to the container.</p>
  </dd>
  <dt>
    <p>\*(T&lt;<strong>lxc.network.flags</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>specify an action to do for the network.</p><p>\*(T&lt;<strong>up:</strong>\*(T&gt; activates the interface.</p>
  </dd>
  <dt>
    <p>\*(T&lt;<strong>lxc.network.link</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>specify the interface to be used for real network traffic.</p>
  </dd>
  <dt>
    <p>\*(T&lt;<strong>lxc.network.mtu</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>specify the maximum transfer unit for this interface.</p>
  </dd>
  <dt>
    <p>\*(T&lt;<strong>lxc.network.name</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>the interface name is dynamically allocated, but if another name is needed because the configuration files being used by the container use a generic name, eg. eth0, this option will rename the interface in the container.</p>
  </dd>
  <dt>
    <p>\*(T&lt;<strong>lxc.network.hwaddr</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>the interface mac address is dynamically allocated by default to the virtual interface, but in some cases, this is needed to resolve a mac address conflict or to always have the same link-local ipv6 address. Any "x" in address will be replaced by random value, this allows setting hwaddr templates.</p>
  </dd>
  <dt>
    <p>\*(T&lt;<strong>lxc.network.ipv4</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>specify the ipv4 address to assign to the virtualized interface. Several lines specify several ipv4 addresses. The address is in format x.y.z.t/m, eg. 192.168.1.123/24. The broadcast address should be specified on the same line, right after the ipv4 address.</p>
  </dd>
  <dt>
    <p>\*(T&lt;<strong>lxc.network.ipv4.gateway</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>specify the ipv4 address to use as the gateway inside the container. The address is in format x.y.z.t, eg. 192.168.1.123. Can also have the special value \*(T&lt;<strong>auto</strong>\*(T&gt;, which means to take the primary address from the bridge interface (as specified by the \*(T&lt;<strong>lxc.network.link</strong>\*(T&gt; option) and use that as the gateway. \*(T&lt;<strong>auto</strong>\*(T&gt; is only available when using the \*(T&lt;<strong>veth</strong>\*(T&gt; and \*(T&lt;<strong>macvlan</strong>\*(T&gt; network types.</p>
  </dd>
  <dt>
    <p>\*(T&lt;<strong>lxc.network.ipv6</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>specify the ipv6 address to assign to the virtualized interface. Several lines specify several ipv6 addresses. The address is in format x::y/m, eg. 2003:db8:1:0:214:1234:fe0b:3596/64</p>
  </dd>
  <dt>
    <p>\*(T&lt;<strong>lxc.network.ipv6.gateway</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>specify the ipv6 address to use as the gateway inside the container. The address is in format x::y, eg. 2003:db8:1:0::1 Can also have the special value \*(T&lt;<strong>auto</strong>\*(T&gt;, which means to take the primary address from the bridge interface (as specified by the \*(T&lt;<strong>lxc.network.link</strong>\*(T&gt; option) and use that as the gateway. \*(T&lt;<strong>auto</strong>\*(T&gt; is only available when using the \*(T&lt;<strong>veth</strong>\*(T&gt; and \*(T&lt;<strong>macvlan</strong>\*(T&gt; network types.</p>
  </dd>
  <dt>
    <p>\*(T&lt;<strong>lxc.network.script.up</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>add a configuration option to specify a script to be executed after creating and configuring the network used from the host side. The following arguments are passed to the script: container name and config section name (net) Additional arguments depend on the config section employing a script hook; the following are used by the network system: execution context (up), network type (empty/veth/macvlan/phys), Depending on the network type, other arguments may be passed: veth/macvlan/phys. And finally (host-sided) device name.</p><p>Standard output from the script is logged at debug level. Standard error is not logged, but can be captured by the hook redirecting its standard error to standard output.</p>
  </dd>
  <dt>
    <p>\*(T&lt;<strong>lxc.network.script.down</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>add a configuration option to specify a script to be executed before destroying the network used from the host side. The following arguments are passed to the script: container name and config section name (net) Additional arguments depend on the config section employing a script hook; the following are used by the network system: execution context (down), network type (empty/veth/macvlan/phys), Depending on the network type, other arguments may be passed: veth/macvlan/phys. And finally (host-sided) device name.</p><p>Standard output from the script is logged at debug level. Standard error is not logged, but can be captured by the hook redirecting its standard error to standard output.</p>
  </dd>

</dl>

<h3>NEW PSEUDO TTY INSTANCE (DEVPTS)</h3>
<p>For stricter isolation the container can have its own private instance of the pseudo tty.</p>
<dl class='dl-vertical'>
  <dt>
    <p>\*(T&lt;<strong>lxc.pts</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>If set, the container will have a new pseudo tty instance, making this private to it. The value specifies the maximum number of pseudo ttys allowed for a pts instance (this limitation is not implemented yet).</p>
  </dd>

</dl>

<h3>CONTAINER SYSTEM CONSOLE</h3>
<p>If the container is configured with a root filesystem and the inittab file is setup to use the console, you may want to specify where the output of this console goes.</p>
<dl class='dl-vertical'>
  <dt>
    <p>\*(T&lt;<strong>lxc.console.logfile</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>Specify a path to a file where the console output will be written.</p>
  </dd>
  <dt>
    <p>\*(T&lt;<strong>lxc.console</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>Specify a path to a device to which the console will be attached. The keyword 'none' will simply disable the console. This is dangerous once if have a rootfs with a console device file where the application can write, the messages will fall in the host.</p>
  </dd>

</dl>

<h3>CONSOLE THROUGH THE TTYS</h3>
<p>This option is useful if the container is configured with a root filesystem and the inittab file is setup to launch a getty on the ttys. The option specifies the number of ttys to be available for the container. The number of gettys in the inittab file of the container should not be greater than the number of ttys specified in this option, otherwise the excess getty sessions will die and respawn indefinitely giving annoying messages on the console or in \*(T&lt;<em>/var/log/messages</em>\*(T&gt;.</p>
<dl class='dl-vertical'>
  <dt>
    <p>\*(T&lt;<strong>lxc.tty</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>Specify the number of tty to make available to the container.</p>
  </dd>

</dl>

<h3>CONSOLE DEVICES LOCATION</h3>
<p>LXC consoles are provided through Unix98 PTYs created on the host and bind-mounted over the expected devices in the container. By default, they are bind-mounted over \*(T&lt;<em>/dev/console</em>\*(T&gt; and \*(T&lt;<em>/dev/ttyN</em>\*(T&gt;. This can prevent package upgrades in the guest. Therefore you can specify a directory location (under \*(T&lt;<em>/dev</em>\*(T&gt; under which LXC will create the files and bind-mount over them. These will then be symbolically linked to \*(T&lt;<em>/dev/console</em>\*(T&gt; and \*(T&lt;<em>/dev/ttyN</em>\*(T&gt;. A package upgrade can then succeed as it is able to remove and replace the symbolic links.</p>
<dl class='dl-vertical'>
  <dt>
    <p>\*(T&lt;<strong>lxc.devttydir</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>Specify a directory under \*(T&lt;<em>/dev</em>\*(T&gt; under which to create the container console devices.</p>
  </dd>

</dl>

<h3>/DEV DIRECTORY</h3>
<p>By default, lxc creates a few symbolic links (fd,stdin,stdout,stderr) in the container's \*(T&lt;<em>/dev</em>\*(T&gt; directory but does not automatically create device node entries. This allows the container's \*(T&lt;<em>/dev</em>\*(T&gt; to be set up as needed in the container rootfs. If lxc.autodev is set to 1, then after mounting the container's rootfs LXC will mount a fresh tmpfs under \*(T&lt;<em>/dev</em>\*(T&gt; (limited to 100k) and fill in a minimal set of initial devices. This is generally required when starting a container containing a "systemd" based "init" but may be optional at other times. Additional devices in the containers /dev directory may be created through the use of the \*(T&lt;<strong>lxc.hook.autodev</strong>\*(T&gt; hook.</p>
<dl class='dl-vertical'>
  <dt>
    <p>\*(T&lt;<strong>lxc.autodev</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>Set this to 1 to have LXC mount and populate a minimal \*(T&lt;<em>/dev</em>\*(T&gt; when starting the container.</p>
  </dd>

</dl>

<h3>ENABLE KMSG SYMLINK</h3>
<p>Enable creating /dev/kmsg as symlink to /dev/console. This defaults to 1.</p>
<dl class='dl-vertical'>
  <dt>
    <p>\*(T&lt;<strong>lxc.kmsg</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>Set this to 0 to disable /dev/kmsg symlinking.</p>
  </dd>

</dl>

<h3>MOUNT POINTS</h3>
<p>The mount points section specifies the different places to be mounted. These mount points will be private to the container and won't be visible by the processes running outside of the container. This is useful to mount /etc, /var or /home for examples.</p><p>NOTE - LXC will generally ensure that mount targets and relative bind-mount sources are properly confined under the container root, to avoid attacks involving over-mounting host directories and files. (Symbolic links in absolute mount sources are ignored) However, if the container configuration first mounts a directory which is under the control of the container user, such as /home/joe, into the container at some \*(T&lt;<em>path</em>\*(T&gt;, and then mounts under \*(T&lt;<em>path</em>\*(T&gt;, then a TOCTTOU attack would be possible where the container user modifies a symbolic link under his home directory at just the right time.</p>
<dl class='dl-vertical'>
  <dt>
    <p>\*(T&lt;<strong>lxc.mount</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>specify a file location in the \*(T&lt;<em>fstab</em>\*(T&gt; format, containing the mount information. The mount target location can and in most cases should be a relative path, which will become relative to the mounted container root. For instance,</p>
<pre>
\*(T&lt;
proc proc proc nodev,noexec,nosuid 0 0
\*(T&gt;.fi

Will mount a proc filesystem under the container's /proc,
regardless of where the root filesystem comes from. This
is resilient to block device backed filesystems as well as
container cloning.

Note that when mounting a filesystem from an
image file or block device the third field (fs_vfstype)
cannot be auto as with
<a href="../man8/mount.8.html"><strong>mount</strong>(8)</a>
but must be explicitly specified.
\*(T&lt;<strong>lxc.mount.entry</strong>\*(T&gt;
specify a mount point corresponding to a line in the
fstab format.
\*(T&lt;<strong>lxc.mount.auto</strong>\*(T&gt;
specify which standard kernel file systems should be
automatically mounted. This may dramatically simplify
the configuration. The file systems are:
&bull;
\*(T&lt;<strong>proc:mixed</strong>\*(T&gt; (or \*(T&lt;<strong>proc</strong>\*(T&gt;):
mount \*(T&lt;<em>/proc</em>\*(T&gt; as read-write, but
remount \*(T&lt;<em>/proc/sys</em>\*(T&gt; and
\*(T&lt;<em>/proc/sysrq-trigger</em>\*(T&gt; read-only
for security / container isolation purposes.
&bull;
\*(T&lt;<strong>proc:rw</strong>\*(T&gt;: mount
\*(T&lt;<em>/proc</em>\*(T&gt; as read-write
&bull;
\*(T&lt;<strong>sys:ro</strong>\*(T&gt; (or \*(T&lt;<strong>sys</strong>\*(T&gt;):
mount \*(T&lt;<em>/sys</em>\*(T&gt; as read-only
for security / container isolation purposes.
&bull;
\*(T&lt;<strong>sys:rw</strong>\*(T&gt;: mount
\*(T&lt;<em>/sys</em>\*(T&gt; as read-write
&bull;
\*(T&lt;<strong>cgroup:mixed</strong>\*(T&gt;:
mount a tmpfs to \*(T&lt;<em>/sys/fs/cgroup</em>\*(T&gt;,
create directories for all hierarchies to which
the container is added, create subdirectories
there with the name of the cgroup, and bind-mount
the container's own cgroup into that directory.
The container will be able to write to its own
cgroup directory, but not the parents, since they
will be remounted read-only
&bull;
\*(T&lt;<strong>cgroup:ro</strong>\*(T&gt;: similar to
\*(T&lt;<strong>cgroup:mixed</strong>\*(T&gt;, but everything will
be mounted read-only.
&bull;
\*(T&lt;<strong>cgroup:rw</strong>\*(T&gt;: similar to
\*(T&lt;<strong>cgroup:mixed</strong>\*(T&gt;, but everything will
be mounted read-write. Note that the paths leading
up to the container's own cgroup will be writable,
but will not be a cgroup filesystem but just part
of the tmpfs of \*(T&lt;<em>/sys/fs/cgroup</em>\*(T&gt;
&bull;
\*(T&lt;<strong>cgroup</strong>\*(T&gt; (without specifier):
defaults to \*(T&lt;<strong>cgroup:rw</strong>\*(T&gt; if the
container retains the CAP_SYS_ADMIN capability,
\*(T&lt;<strong>cgroup:mixed</strong>\*(T&gt; otherwise.
&bull;
\*(T&lt;<strong>cgroup-full:mixed</strong>\*(T&gt;:
mount a tmpfs to \*(T&lt;<em>/sys/fs/cgroup</em>\*(T&gt;,
create directories for all hierarchies to which
the container is added, bind-mount the hierarchies
from the host to the container and make everything
read-only except the container's own cgroup. Note
that compared to \*(T&lt;<strong>cgroup</strong>\*(T&gt;, where
all paths leading up to the container's own cgroup
are just simple directories in the underlying
tmpfs, here
\*(T&lt;<em>/sys/fs/cgroup/$hierarchy</em>\*(T&gt;
will contain the host's full cgroup hierarchy,
albeit read-only outside the container's own cgroup.
This may leak quite a bit of information into the
container.
&bull;
\*(T&lt;<strong>cgroup-full:ro</strong>\*(T&gt;: similar to
\*(T&lt;<strong>cgroup-full:mixed</strong>\*(T&gt;, but everything
will be mounted read-only.
&bull;
\*(T&lt;<strong>cgroup-full:rw</strong>\*(T&gt;: similar to
\*(T&lt;<strong>cgroup-full:mixed</strong>\*(T&gt;, but everything
will be mounted read-write. Note that in this case,
the container may escape its own cgroup. (Note also
that if the container has CAP_SYS_ADMIN support
and can mount the cgroup filesystem itself, it may
do so anyway.)
&bull;
\*(T&lt;<strong>cgroup-full</strong>\*(T&gt; (without specifier):
defaults to \*(T&lt;<strong>cgroup-full:rw</strong>\*(T&gt; if the
container retains the CAP_SYS_ADMIN capability,
\*(T&lt;<strong>cgroup-full:mixed</strong>\*(T&gt; otherwise.
</pre>

  </dd>

</dl>
<p>Note that if automatic mounting of the cgroup filesystem is enabled, the tmpfs under \*(T&lt;<em>/sys/fs/cgroup</em>\*(T&gt; will always be mounted read-write (but for the \*(T&lt;<strong>:mixed</strong>\*(T&gt; and \*(T&lt;<strong>:ro</strong>\*(T&gt; cases, the individual hierarchies, \*(T&lt;<em>/sys/fs/cgroup/$hierarchy</em>\*(T&gt;, will be read-only). This is in order to work around a quirk in Ubuntu's <a href="../man8/mountall.8.html"><strong>mountall</strong>(8)</a> command that will cause containers to wait for user input at boot if \*(T&lt;<em>/sys/fs/cgroup</em>\*(T&gt; is mounted read-only and the container can't remount it read-write due to a lack of CAP_SYS_ADMIN.</p><p>Examples:</p>
<pre>
\*(T&lt;
	      lxc.mount.auto = proc sys cgroup
	      lxc.mount.auto = proc:rw sys:rw cgroup-full:rw
	    \*(T&gt;
</pre>

<h3>ROOT FILE SYSTEM</h3>
<p>The root file system of the container can be different than that of the host system.</p>
<dl class='dl-vertical'>
  <dt>
    <p>\*(T&lt;<strong>lxc.rootfs</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>specify the root file system for the container. It can be an image file, a directory or a block device. If not specified, the container shares its root file system with the host.</p>
  </dd>
  <dt>
    <p>\*(T&lt;<strong>lxc.rootfs.mount</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>where to recursively bind \*(T&lt;<strong>lxc.rootfs</strong>\*(T&gt; before pivoting. This is to ensure success of the <a href="../man8/pivot_root.8.html"><strong>pivot_root</strong>(8)</a> syscall. Any directory suffices, the default should generally work.</p>
  </dd>
  <dt>
    <p>\*(T&lt;<strong>lxc.rootfs.options</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>extra mount options to use when mounting the rootfs.</p>
  </dd>
  <dt>
    <p>\*(T&lt;<strong>lxc.pivotdir</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>where to pivot the original root file system under \*(T&lt;<strong>lxc.rootfs</strong>\*(T&gt;, specified relatively to that. The default is \*(T&lt;<em>mnt</em>\*(T&gt;. It is created if necessary, and also removed after unmounting everything from it during container setup.</p>
  </dd>

</dl>

<h3>CONTROL GROUP</h3>
<p>The control group section contains the configuration for the different subsystem. <strong>lxc</strong> does not check the correctness of the subsystem name. This has the disadvantage of not detecting configuration errors until the container is started, but has the advantage of permitting any future subsystem.</p>
<dl class='dl-vertical'>
  <dt>
    <p>\*(T&lt;<strong>lxc.cgroup.[subsystem name]</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>specify the control group value to be set. The subsystem name is the literal name of the control group subsystem. The permitted names and the syntax of their values is not dictated by LXC, instead it depends on the features of the Linux kernel running at the time the container is started, eg. \*(T&lt;<strong>lxc.cgroup.cpuset.cpus</strong>\*(T&gt;</p>
  </dd>

</dl>

<h3>CAPABILITIES</h3>
<p>The capabilities can be dropped in the container if this one is run as root.</p>
<dl class='dl-vertical'>
  <dt>
    <p>\*(T&lt;<strong>lxc.cap.drop</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>Specify the capability to be dropped in the container. A single line defining several capabilities with a space separation is allowed. The format is the lower case of the capability definition without the "CAP_" prefix, eg. CAP_SYS_MODULE should be specified as sys_module. See <a href="../man7/capabilities.7.html"><strong>capabilities</strong>(7)</a>,</p>
  </dd>
  <dt>
    <p>\*(T&lt;<strong>lxc.cap.keep</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>Specify the capability to be kept in the container. All other capabilities will be dropped.</p>
  </dd>

</dl>

<h3>APPARMOR PROFILE</h3>
<p>If lxc was compiled and installed with apparmor support, and the host system has apparmor enabled, then the apparmor profile under which the container should be run can be specified in the container configuration. The default is <strong>lxc-container-default</strong>.</p>
<dl class='dl-vertical'>
  <dt>
    <p>\*(T&lt;<strong>lxc.aa_profile</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>Specify the apparmor profile under which the container should be run. To specify that the container should be unconfined, use</p>
<pre>
\*(T&lt;lxc.aa_profile = unconfined\*(T&gt;
</pre>

  </dd>

</dl>

<h3>SELINUX CONTEXT</h3>
<p>If lxc was compiled and installed with SELinux support, and the host system has SELinux enabled, then the SELinux context under which the container should be run can be specified in the container configuration. The default is <strong>unconfined_t</strong>, which means that lxc will not attempt to change contexts. See /usr/share/lxc/selinux/lxc.te for an example policy and more information.</p>
<dl class='dl-vertical'>
  <dt>
    <p>\*(T&lt;<strong>lxc.se_context</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>Specify the SELinux context under which the container should be run or <strong>unconfined_t</strong>. For example</p>
<pre>
\*(T&lt;lxc.se_context = system_u:system_r:lxc_t:s0:c22\*(T&gt;
</pre>

  </dd>

</dl>

<h3>SECCOMP CONFIGURATION</h3>
<p>A container can be started with a reduced set of available system calls by loading a seccomp profile at startup. The seccomp configuration file must begin with a version number on the first line, a policy type on the second line, followed by the configuration.</p><p>Versions 1 and 2 are currently supported. In version 1, the policy is a simple whitelist. The second line therefore must read "whitelist", with the rest of the file containing one (numeric) sycall number per line. Each syscall number is whitelisted, while every unlisted number is blacklisted for use in the container</p><p>In version 2, the policy may be blacklist or whitelist, supports per-rule and per-policy default actions, and supports per-architecture system call resolution from textual names.</p><p>An example blacklist policy, in which all system calls are allowed except for mknod, which will simply do nothing and return 0 (success), looks like:</p>
<pre>
\*(T&lt;
2
blacklist
mknod errno 0
\*(T&gt;.fi
\*(T&lt;<strong>lxc.seccomp</strong>\*(T&gt;
Specify a file containing the seccomp configuration to
load before the container starts.
</pre>

<h3>UID MAPPINGS</h3>
<p>A container can be started in a private user namespace with user and group id mappings. For instance, you can map userid 0 in the container to userid 200000 on the host. The root user in the container will be privileged in the container, but unprivileged on the host. Normally a system container will want a range of ids, so you would map, for instance, user and group ids 0 through 20,000 in the container to the ids 200,000 through 220,000.</p>
<dl class='dl-vertical'>
  <dt>
    <p>\*(T&lt;<strong>lxc.id_map</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>Four values must be provided. First a character, either 'u', or 'g', to specify whether user or group ids are being mapped. Next is the first userid as seen in the user namespace of the container. Next is the userid as seen on the host. Finally, a range indicating the number of consecutive ids to map.</p>
  </dd>

</dl>

<h3>CONTAINER HOOKS</h3>
<p>Container hooks are programs or scripts which can be executed at various times in a container's lifetime.</p><p>When a container hook is executed, information is passed both as command line arguments and through environment variables. The arguments are:</p>
<dl class='dl-vertical'>
  <dt>
    <p>&bull;</p>
  </dt>
  <dd>
    <p>Container name.</p>
  </dd>
  <dt>
    <p>&bull;</p>
  </dt>
  <dd>
    <p>Section (always 'lxc').</p>
  </dd>
  <dt>
    <p>&bull;</p>
  </dt>
  <dd>
    <p>The hook type (i.e. 'clone' or 'pre-mount').</p>
  </dd>
  <dt>
    <p>&bull;</p>
  </dt>
  <dd>
    <p>Additional arguments In the case of the clone hook, any extra arguments passed to lxc-clone will appear as further arguments to the hook.</p>
  </dd>

</dl>
<p>The following environment variables are set:</p>
<dl class='dl-vertical'>
  <dt>
    <p>&bull;</p>
  </dt>
  <dd>
    <p>LXC_NAME: is the container's name.</p>
  </dd>
  <dt>
    <p>&bull;</p>
  </dt>
  <dd>
    <p>LXC_ROOTFS_MOUNT: the path to the mounted root filesystem.</p>
  </dd>
  <dt>
    <p>&bull;</p>
  </dt>
  <dd>
    <p>LXC_CONFIG_FILE: the path to the container configuration file.</p>
  </dd>
  <dt>
    <p>&bull;</p>
  </dt>
  <dd>
    <p>LXC_SRC_NAME: in the case of the clone hook, this is the original container's name.</p>
  </dd>
  <dt>
    <p>&bull;</p>
  </dt>
  <dd>
    <p>LXC_ROOTFS_PATH: this is the lxc.rootfs entry for the container. Note this is likely not where the mounted rootfs is to be found, use LXC_ROOTFS_MOUNT for that.</p>
  </dd>

</dl>
<p>Standard output from the hooks is logged at debug level. Standard error is not logged, but can be captured by the hook redirecting its standard error to standard output.</p>
<dl class='dl-vertical'>
  <dt>
    <p>\*(T&lt;<strong>lxc.hook.pre-start</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>A hook to be run in the host's namespace before the container ttys, consoles, or mounts are up.</p>
  </dd>
  <dt>
    <p>\*(T&lt;<strong>lxc.hook.pre-mount</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>A hook to be run in the container's fs namespace but before the rootfs has been set up. This allows for manipulation of the rootfs, i.e. to mount an encrypted filesystem. Mounts done in this hook will not be reflected on the host (apart from mounts propagation), so they will be automatically cleaned up when the container shuts down.</p>
  </dd>
  <dt>
    <p>\*(T&lt;<strong>lxc.hook.mount</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>A hook to be run in the container's namespace after mounting has been done, but before the pivot_root.</p>
  </dd>
  <dt>
    <p>\*(T&lt;<strong>lxc.hook.autodev</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>A hook to be run in the container's namespace after mounting has been done and after any mount hooks have run, but before the pivot_root, if \*(T&lt;<strong>lxc.autodev</strong>\*(T&gt; == 1. The purpose of this hook is to assist in populating the /dev directory of the container when using the autodev option for systemd based containers. The container's /dev directory is relative to the ${\*(T&lt;<strong>LXC_ROOTFS_MOUNT</strong>\*(T&gt;} environment variable available when the hook is run.</p>
  </dd>
  <dt>
    <p>\*(T&lt;<strong>lxc.hook.start</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>A hook to be run in the container's namespace immediately before executing the container's init. This requires the program to be available in the container.</p>
  </dd>
  <dt>
    <p>\*(T&lt;<strong>lxc.hook.post-stop</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>A hook to be run in the host's namespace after the container has been shut down.</p>
  </dd>
  <dt>
    <p>\*(T&lt;<strong>lxc.hook.clone</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>A hook to be run when the container is cloned to a new one. See <a href="../man1/lxc-clone.1.html"><strong>lxc-clone</strong>(1)</a> for more information.</p>
  </dd>

</dl>

<h3>CONTAINER HOOKS ENVIRONMENT VARIABLES</h3>
<p>A number of environment variables are made available to the startup hooks to provide configuration information and assist in the functioning of the hooks. Not all variables are valid in all contexts. In particular, all paths are relative to the host system and, as such, not valid during the \*(T&lt;<strong>lxc.hook.start</strong>\*(T&gt; hook.</p>
<dl class='dl-vertical'>
  <dt>
    <p>\*(T&lt;<strong>LXC_NAME</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>The LXC name of the container. Useful for logging messages in common log environments. [\*(T&lt;<strong>-n</strong>\*(T&gt;]</p>
  </dd>
  <dt>
    <p>\*(T&lt;<strong>LXC_CONFIG_FILE</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>Host relative path to the container configuration file. This gives the container to reference the original, top level, configuration file for the container in order to locate any additional configuration information not otherwise made available. [\*(T&lt;<strong>-f</strong>\*(T&gt;]</p>
  </dd>
  <dt>
    <p>\*(T&lt;<strong>LXC_CONSOLE</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>The path to the console output of the container if not NULL. [\*(T&lt;<strong>-c</strong>\*(T&gt;] [\*(T&lt;<strong>lxc.console</strong>\*(T&gt;]</p>
  </dd>
  <dt>
    <p>\*(T&lt;<strong>LXC_CONSOLE_LOGPATH</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>The path to the console log output of the container if not NULL. [\*(T&lt;<strong>-L</strong>\*(T&gt;]</p>
  </dd>
  <dt>
    <p>\*(T&lt;<strong>LXC_ROOTFS_MOUNT</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>The mount location to which the container is initially bound. This will be the host relative path to the container rootfs for the container instance being started and is where changes should be made for that instance. [\*(T&lt;<strong>lxc.rootfs.mount</strong>\*(T&gt;]</p>
  </dd>
  <dt>
    <p>\*(T&lt;<strong>LXC_ROOTFS_PATH</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>The host relative path to the container root which has been mounted to the rootfs.mount location. [\*(T&lt;<strong>lxc.rootfs</strong>\*(T&gt;]</p>
  </dd>

</dl>

<h3>LOGGING</h3>
<p>Logging can be configured on a per-container basis. By default, depending upon how the lxc package was compiled, container startup is logged only at the ERROR level, and logged to a file named after the container (with '.log' appended) either under the container path, or under /var/lib/lxc.</p><p>Both the default log level and the log file can be specified in the container configuration file, overriding the default behavior. Note that the configuration file entries can in turn be overridden by the command line options to <strong>lxc-start</strong>.</p>
<dl class='dl-vertical'>
  <dt>
    <p>\*(T&lt;<strong>lxc.loglevel</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>The level at which to log. The log level is an integer in the range of 0..8 inclusive, where a lower number means more verbose debugging. In particular 0 = trace, 1 = debug, 2 = info, 3 = notice, 4 = warn, 5 = error, 6 = critical, 7 = alert, and 8 = fatal. If unspecified, the level defaults to 5 (error), so that only errors and above are logged.</p><p>Note that when a script (such as either a hook script or a network interface up or down script) is called, the script's standard output is logged at level 1, debug.</p>
  </dd>
  <dt>
    <p>\*(T&lt;<strong>lxc.logfile</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>The file to which logging info should be written.</p>
  </dd>

</dl>

<h3>AUTOSTART</h3>
<p>The autostart options support marking which containers should be auto-started and in what order. These options may be used by LXC tools directly or by external tooling provided by the distributions.</p>
<dl class='dl-vertical'>
  <dt>
    <p>\*(T&lt;<strong>lxc.start.auto</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>Whether the container should be auto-started. Valid values are 0 (off) and 1 (on).</p>
  </dd>
  <dt>
    <p>\*(T&lt;<strong>lxc.start.delay</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>How long to wait (in seconds) after the container is started before starting the next one.</p>
  </dd>
  <dt>
    <p>\*(T&lt;<strong>lxc.start.order</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>An integer used to sort the containers when auto-starting a series of containers at once.</p>
  </dd>
  <dt>
    <p>\*(T&lt;<strong>lxc.group</strong>\*(T&gt;</p>
  </dt>
  <dd>
    <p>A multi-value key (can be used multiple times) to put the container in a container group. Those groups can then be used (amongst other things) to start a series of related containers.</p>
  </dd>

</dl>

<h3>AUTOSTART AND SYSTEM BOOT</h3>
<p>Each container can be part of any number of groups or no group at all. Two groups are special. One is the NULL group, i.e. the container does not belong to any group. The other group is the "onboot" group.</p><p>When the system boots with the LXC service enabled, it will first attempt to boot any containers with lxc.start.auto == 1 that is a member of the "onboot" group. The startup will be in order of lxc.start.order. If an lxc.start.delay has been specified, that delay will be honored before attempting to start the next container to give the current container time to begin initialization and reduce overloading the host system. After starting the members of the "onboot" group, the LXC system will proceed to boot containers with lxc.start.auto == 1 which are not members of any group (the NULL group) and proceed as with the onboot group.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>In addition to the few examples given below, you will find some other examples of configuration file in /usr/share/doc/lxc/examples</p><h3>NETWORK</h3>
<p>This configuration sets up a container to use a veth pair device with one side plugged to a bridge br0 (which has been configured before on the system by the administrator). The virtual network device visible in the container is renamed to eth0.</p>
<pre>
\*(T&lt;
	lxc.utsname = myhostname
	lxc.network.type = veth
	lxc.network.flags = up
	lxc.network.link = br0
	lxc.network.name = eth0
	lxc.network.hwaddr = 4a:49:43:49:79:bf
	lxc.network.ipv4 = 10.2.3.5/24 10.2.3.255
	lxc.network.ipv6 = 2003:db8:1:0:214:1234:fe0b:3597
      \*(T&gt;
</pre>

<h3>UID/GID MAPPING</h3>
<p>This configuration will map both user and group ids in the range 0-9999 in the container to the ids 100000-109999 on the host.</p>
<pre>
\*(T&lt;
	lxc.id_map = u 0 100000 10000
	lxc.id_map = g 0 100000 10000
      \*(T&gt;
</pre>

<h3>CONTROL GROUP</h3>
<p>This configuration will setup several control groups for the application, cpuset.cpus restricts usage of the defined cpu, cpus.share prioritize the control group, devices.allow makes usable the specified devices.</p>
<pre>
\*(T&lt;
	lxc.cgroup.cpuset.cpus = 0,1
	lxc.cgroup.cpu.shares = 1234
	lxc.cgroup.devices.deny = a
	lxc.cgroup.devices.allow = c 1:3 rw
	lxc.cgroup.devices.allow = b 8:0 rw
      \*(T&gt;
</pre>

<h3>COMPLEX CONFIGURATION</h3>
<p>This example show a complex configuration making a complex network stack, using the control groups, setting a new hostname, mounting some locations and a changing root file system.</p>
<pre>
\*(T&lt;
	lxc.utsname = complex
	lxc.network.type = veth
	lxc.network.flags = up
	lxc.network.link = br0
	lxc.network.hwaddr = 4a:49:43:49:79:bf
	lxc.network.ipv4 = 10.2.3.5/24 10.2.3.255
	lxc.network.ipv6 = 2003:db8:1:0:214:1234:fe0b:3597
	lxc.network.ipv6 = 2003:db8:1:0:214:5432:feab:3588
	lxc.network.type = macvlan
	lxc.network.flags = up
	lxc.network.link = eth0
	lxc.network.hwaddr = 4a:49:43:49:79:bd
	lxc.network.ipv4 = 10.2.3.4/24
	lxc.network.ipv4 = 192.168.10.125/24
	lxc.network.ipv6 = 2003:db8:1:0:214:1234:fe0b:3596
	lxc.network.type = phys
	lxc.network.flags = up
	lxc.network.link = dummy0
	lxc.network.hwaddr = 4a:49:43:49:79:ff
	lxc.network.ipv4 = 10.2.3.6/24
	lxc.network.ipv6 = 2003:db8:1:0:214:1234:fe0b:3297
	lxc.cgroup.cpuset.cpus = 0,1
	lxc.cgroup.cpu.shares = 1234
	lxc.cgroup.devices.deny = a
	lxc.cgroup.devices.allow = c 1:3 rw
	lxc.cgroup.devices.allow = b 8:0 rw
	lxc.mount = /etc/fstab.complex
	lxc.mount.entry = /lib /root/myrootfs/lib none ro,bind 0 0
	lxc.rootfs = /mnt/rootfs.complex
	lxc.cap.drop = sys_module mknod setuid net_raw
	lxc.cap.drop = mac_override
      \*(T&gt;
</pre>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO lxc.container.conf&hellip;</h2>
        <div class="sectioncontent">
<p><strong>chroot</strong>(1), <a href="../man8/pivot_root.8.html"><strong>pivot_root</strong>(8)</a>, <strong>\*(T&lt;</strong><em>fstab</em>\*(T&gt;(5), <strong>\*(T&lt;</strong><em>capabilities</em>\*(T&gt;(7)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO lxc.container.conf&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man7/lxc.7.html"><strong>lxc</strong>(7)</a>, <a href="../man1/lxc-create.1.html"><strong>lxc-create</strong>(1)</a>, <a href="../man1/lxc-destroy.1.html"><strong>lxc-destroy</strong>(1)</a>, <a href="../man1/lxc-start.1.html"><strong>lxc-start</strong>(1)</a>, <a href="../man1/lxc-stop.1.html"><strong>lxc-stop</strong>(1)</a>, <a href="../man1/lxc-execute.1.html"><strong>lxc-execute</strong>(1)</a>, <a href="../man1/lxc-console.1.html"><strong>lxc-console</strong>(1)</a>, <a href="../man1/lxc-monitor.1.html"><strong>lxc-monitor</strong>(1)</a>, <a href="../man1/lxc-wait.1.html"><strong>lxc-wait</strong>(1)</a>, <a href="../man1/lxc-cgroup.1.html"><strong>lxc-cgroup</strong>(1)</a>, <a href="../man1/lxc-ls.1.html"><strong>lxc-ls</strong>(1)</a>, <a href="../man1/lxc-info.1.html"><strong>lxc-info</strong>(1)</a>, <a href="../man1/lxc-freeze.1.html"><strong>lxc-freeze</strong>(1)</a>, <a href="../man1/lxc-unfreeze.1.html"><strong>lxc-unfreeze</strong>(1)</a>, <a href="../man1/lxc-attach.1.html"><strong>lxc-attach</strong>(1)</a>, <a href="../man5/lxc.conf.5.html"><strong>lxc.conf</strong>(5)</a></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Daniel Lezcano &lt;\*(T&lt;daniel.lezcano@free.fr\*(T&gt;&gt;</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="lxc.conf.5.html"><span aria-hidden="true">&larr;</span> lxc.conf.5: Configuration files for lxc.</a></li>
   <li class="next"><a href="lxc.system.conf.5.html">lxc.system.conf.5: Lxc system configuration file <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ltrace.conf: Configuration file for ltrace(1).</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Configuration file for ltrace(1).">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="ltrace.conf (5) manual">
  <meta name="twitter:description" content="Configuration file for ltrace(1).">
  <meta name="twitter:image" content="https://www.carta.tech/images/ltrace-ltrace.conf-5.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man5/ltrace.conf.5.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="ltrace.conf (5) manual" />
  <meta property="og:description" content="Configuration file for ltrace(1)." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/ltrace-ltrace.conf-5.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">ltrace.conf<small> (5)</small></h1>
        <p class="lead">Configuration file for ltrace(1).</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/">
      <span itemprop="name">File formats and conventions</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/ltrace.conf.5.html">
      <span itemprop="name">ltrace.conf: Configuration file for ltrace(1).</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/ltrace/">
      <span itemprop="name">ltrace</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/ltrace.conf.5.html">
      <span itemprop="name">ltrace.conf: Configuration file for ltrace(1).</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This manual page describes <strong>ltrace.conf</strong>, a file that describes prototypes of functions in binaries for <a href="../man1/ltrace.1.html"><strong>ltrace</strong>(1)</a></strong> to use. Ltrace needs this information to display function call arguments.</p><p>Each line of a configuration file describes at most a single item. Lines composed entirely of white space are ignored, as are lines starting with semicolon character (comment lines).  Described items can be either function prototypes, or definitions of type aliases.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PROTOTYPES</h2>
        <div class="sectioncontent">
<p>A prototype describes return type and parameter types of a single function.  The syntax is as follows:</p><p><em>LENS</em> <em>NAME</em> <strong>(</strong>[<em>LENS</em>{,<em>LENS</em>}]<strong>);</strong></p><p><em>NAME</em> is the (mangled) name of a symbol.  In the elementary case, <em>LENS</em> is simply a type.  Both lenses and types are described below.  For example, a simple function prototype might look like this:</p><p><strong>int</strong> kill<strong>(int,int);</strong></p><p>Despite the apparent similarity with C, <strong>ltrace.conf</strong> is really its own language that's only somewhat inspired by C.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TYPES</h2>
        <div class="sectioncontent">
<p>Ltrace understands a range of primitive types.  Those are interpreted according to C convention native on a given architecture. E.g. <strong>ulong</strong> is interpreted as 4-byte unsigned integer on 32-bit GNU/Linux machine, but 8-byte unsigned integer on 64-bit GNU/Linux machine.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>void</strong></p>
  </dt>
  <dd>
    <p>Denotes that a function does not return anything.  Can be also used to construct a generic pointer, i.e. pointer-sized number formatted in hexadecimal format.</p>
  </dd>
  <dt>
    <p><strong>char</strong></p>
  </dt>
  <dd>
    <p>8-bit quantity rendered as a character</p>
  </dd>
  <dt>
    <p><strong>ushort,short</strong></p>
  </dt>
  <dd>
    <p>Denotes unsigned or signed short integer.</p>
  </dd>
  <dt>
    <p><strong>uint,int</strong></p>
  </dt>
  <dd>
    <p>Denotes unsigned or signed integer.</p>
  </dd>
  <dt>
    <p><strong>ulong,long</strong></p>
  </dt>
  <dd>
    <p>Denotes unsigned or signed long integer.</p>
  </dd>
  <dt>
    <p><strong>float</strong></p>
  </dt>
  <dd>
    <p>Denotes floating point number with single precision.</p>
  </dd>
  <dt>
    <p><strong>double</strong></p>
  </dt>
  <dd>
    <p>Denotes floating point number with double precision.</p>
  </dd>

</dl>
<p>Besides primitive types, the following composed types are possible:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>struct(</strong>[<em>LENS</em>{,<em>LENS</em>}]<strong>)</strong></p>
  </dt>
  <dd>
    <p>Describes a structure with given types as fields, e.g. <strong>struct(int,int,float)</strong>.</p><p>Alignment is computed as customary on the architecture.  Custom alignment (e.g. packed structs) and bit-fields are not supported. It's also not possible to differentiate between structs and non-POD C++ classes, for arches where it makes a difference.</p>
  </dd>
  <dt>
    <p><strong>array(</strong><em>LENS</em><strong>,</strong><em>EXPR</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>Describes array of length <em>EXPR</em>, which is composed of types described by <em>LENS</em>, e.g. <strong>array(int, </strong>6<strong>)</strong>.</p><p>Note that in C, arrays in role of function argument decay into pointers.  Ltrace currently handles this automatically, but for full formal correctness, any such arguments should be described as pointers to arrays.</p>
  </dd>
  <dt>
    <p><em>LENS</em><strong>*</strong></p>
  </dt>
  <dd>
    <p>Describes a pointer to a given type, e.g. <strong>char*</strong> or <strong>int***</strong>. Note that the former example actually describes a pointer to a character, not a string.  See below for <strong>string</strong> lens, which is applicable to these cases.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LENSES</h2>
        <div class="sectioncontent">
<p>Lenses change the way that types are described.  In the simplest case, a lens is directly a type.  Otherwise a type is decorated by the lens. Ltrace understands the following lenses:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>oct(</strong><em>TYPE</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>The argument, which should be an integer type, is formatted in base-8.</p>
  </dd>
  <dt>
    <p><strong>hex(</strong><em>TYPE</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>The argument, which should be an integer or floating point type, is formatted in base-16.  Floating point arguments are converted to double and then displayed using the <strong>%a</strong> fprintf modifier.</p>
  </dd>
  <dt>
    <p><strong>hide(</strong><em>TYPE</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>The argument is not shown in argument list.</p>
  </dd>
  <dt>
    <p><strong>bool(</strong><em>TYPE</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>Arguments with zero value are shown as "false", others are shown as "true".</p>
  </dd>
  <dt>
    <p><strong>bitvec(</strong><em>TYPE</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>Underlying argument is interpreted as a bit vector and a summary of bits set in the vector is displayed.  For example if bits 3,4,5 and 7 of the bit vector are set, ltrace shows &lt;3-5,7&gt;.  Empty bit vector is displayed as &lt;&gt;.  If there are more bits set than unset, inverse is shown instead: e.g. ~&lt;0&gt; when a number 0xfffffffe is displayed.  Full set is thus displayed ~&lt;&gt;.</p><p>If the underlying type is integral, then bits are shown in their natural big-endian order, with LSB being bit 0. E.g. <strong>bitvec(ushort)</strong> with value 0x0102 would be displayed as &lt;1,8&gt;, irrespective of underlying byte order.</p><p>For other data types (notably structures and arrays), the underlying data is interpreted byte after byte.  Bit 0 of first byte has number 0, bit 0 of second byte number 8, and so on.  Thus <strong>bitvec(struct(int))</strong> is endian sensitive, and will show bytes comprising the integer in their memory order.  Pointers are first dereferenced, thus <strong>bitvec(array(char, </strong>32<strong>)*)</strong> is actually a pointer to 256-bit bit vector.</p>
  </dd>

</dl>
<p><strong>string(</strong><em>TYPE</em><strong>)</strong></p><p><strong>string[</strong><em>EXPR</em><strong>]</strong></p><p><strong>string</strong></p><p>The first form of the argument is canonical, the latter two are syntactic sugar.  In the canonical form, the function argument is formatted as string.  The <em>TYPE</em> shall be either a <strong>char*</strong>, or <strong>array(char,</strong><em>EXPR</em><strong>)</strong>, or <strong>array(char,</strong><em>EXPR</em><strong>)*</strong>.  If an array is given, the length will typically be a <strong>zero</strong> expression (but doesn't have to be).  Using argument that is plain array (i.e. not a pointer to array) makes sense e.g. in C structs, in cases like <strong>struct(string(array(char, </strong>6<strong>)))</strong>, which describes the C type <strong>struct {char </strong>s<strong>[</strong>6<strong>];}</strong>.</p><p>Because simple C-like strings are pretty common, there are two shorthand forms.  The first shorthand form (with brackets) means the same as <strong>string(array(char, </strong><em>EXPR</em><strong>)*)</strong>.  Plain <strong>string</strong> without an argument is then taken to mean the same as <strong>string[zero]</strong>.</p><p>Note that <strong>char*</strong> by itself describes a pointer to a char.  Ltrace will dereference the pointer, and read and display the single character that it points to.</p><p><strong>enum(</strong><em>NAME</em>[<strong>=</strong><em>VALUE</em>]{,<em>NAME</em>[<strong>=</strong><em>VALUE</em>]}<strong>)</strong></p><p><strong>enum[</strong><em>TYPE</em><strong>]</strong><strong>(</strong><em>NAME</em>[<strong>=</strong><em>VALUE</em>]{,<em>NAME</em>[<strong>=</strong><em>VALUE</em>]}<strong>)</strong></p><p>This describes an enumeration lens.  If an argument has any of the given values, it is instead shown as the corresponding <em>NAME</em>.  If a <em>VALUE</em> is omitted, the next consecutive value following after the previous <em>VALUE</em> is taken instead.  If the first <em>VALUE</em> is omitted, it's <strong>0</strong> by default.</p><p><em>TYPE</em>, if given, is the underlying type.  It is thus possible to create enums over shorts or longs&ndash;arguments that are themselves plain, non-enum types in C, but whose values can be meaningfully described as enumerations.  If omitted, <em>TYPE</em> is taken to be <strong>int</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TYPE ALIASES</h2>
        <div class="sectioncontent">
<p>A line in config file can, instead of describing a prototype, create a type alias.  Instead of writing the same enum or struct on many places (and possibly updating when it changes), one can introduce a name for such type, and later just use that name:</p><p><strong>typedef </strong><em>NAME</em><strong> = </strong><em>LENS</em><strong>;</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RECURSIVE STRUCTURES</h2>
        <div class="sectioncontent">
<p>Ltrace allows you to express recursive structures.  Such structures are expanded to the depth described by the parameter -A.  To declare a recursive type, you first have to introduce the type to ltrace by using forward declaration.  Then you can use the type in other type definitions in the usual way:</p><p><strong>typedef </strong><em>NAME</em><strong> = struct;</strong></p><p><strong>typedef </strong><em>NAME</em><strong> = struct(</strong><em>NAME</em> can be used here<strong>)</strong></p><p>For example, consider the following singy-linked structure and a function that takes such list as an argument:</p><p><strong>typedef</strong> int_list <strong>= struct;</strong></p><p><strong>typedef</strong> int_list <strong>= struct(int,</strong> int_list<strong>*);</strong></p><p><strong>void</strong> ll<strong>(</strong>int_list<strong>*);</strong></p><p>Such declarations might lead to an output like the following:</p><p>ll({ 9, { 8, { 7, { 6, ... } } } }) = &lt;void&gt;</p><p>Ltrace detects recursion and will not expand already-expanded structures.  Thus a doubly-linked list would look like the following:</p><p><strong>typedef</strong> int_list <strong>= struct;</strong></p><p><strong>typedef</strong> int_list <strong>= struct(int,</strong> int_list<strong>*,</strong> int_list<strong>*);</strong></p><p>With output e.g. like:</p><p>ll({ 9, { 8, { 7, { 6, ..., ... }, recurse^ }, recurse^ }, nil })</p><p>The "recurse^" tokens mean that given pointer points to a structure that was expanded in the previous layer.  Simple "recurse" would mean that it points back to this object.  E.g. "recurse^^^" means it points to a structure three layers up.  For doubly-linked list, the pointer to the previous element is of course the one that has been just expanded in the previous round, and therefore all of them are either recurse^, or nil.  If the next and previous pointers are swapped, the output adjusts correspondingly:</p><p>ll({ 9, nil, { 8, recurse^, { 7, recurse^, { 6, ..., ... } } } })</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPRESSIONS</h2>
        <div class="sectioncontent">
<p>Ltrace has support for some elementary expressions.  Each expression can be either of the following:</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>NUM</em></p>
  </dt>
  <dd>
    <p>An integer number.</p>
  </dd>
  <dt>
    <p><strong>arg</strong><em>NUM</em></p>
  </dt>
  <dd>
    <p>Value of <em>NUM</em>-th argument.  The expression has the same value as the corresponding argument.  <strong>arg1</strong> refers to the first argument, <strong>arg0</strong> to the return value of the given function.</p>
  </dd>
  <dt>
    <p><strong>retval</strong></p>
  </dt>
  <dd>
    <p>Return value of function, same as <strong>arg0</strong>.</p>
  </dd>
  <dt>
    <p><strong>elt</strong><em>NUM</em></p>
  </dt>
  <dd>
    <p>Value of <em>NUM</em>-th element of the surrounding structure type.  E.g. <strong>struct(ulong,array(int,elt1))</strong> describes a structure whose first element is a length, and second element an array of ints of that length.</p>
  </dd>

</dl>
<p><strong>zero</strong></p><p><strong>zero(</strong><em>EXPR</em><strong>)</strong></p><p>Describes array which extends until the first element, whose each byte is 0.  If an expression is given, that is the maximum length of the array.  If NUL terminator is not found earlier, that's where the array ends.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PARAMETER PACKS</h2>
        <div class="sectioncontent">
<p>Sometimes the actual function prototype varies slightly depending on the exact parameters given.  For example, the number and types of printf parameters are not known in advance, but ltrace might be able to determine them in runtime.  This feature has wider applicability, but currently the only parameter pack that ltrace supports is printf-style format string itself:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>format</strong></p>
  </dt>
  <dd>
    <p>When <strong>format</strong> is seen in the parameter list, the underlying string argument is parsed, and GNU-style format specifiers are used to determine what the following actual arguments are.  E.g. if the format string is "%s %d&#92;n", it's as if the <strong>format</strong> was replaced by <strong>string, string, int</strong>.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN ARGUMENTS</h2>
        <div class="sectioncontent">
<p>C functions often use one or more arguments for returning values back to the caller.  The caller provides a pointer to storage, which the called function initializes.  Ltrace has some support for this idiom.</p><p>When a traced binary hits a function call, ltrace first fetches all arguments.  It then displays <em>left</em> portion of the argument list. Only when the function returns does ltrace display <em>right</em> portion as well.  Typically, left portion takes up all the arguments, and right portion only contains return value.  But ltrace allows you to configure where exactly to put the dividing line by means of a <strong>+</strong> operator placed in front of an argument:</p><p><strong>int</strong> asprintf<strong>(+string*, format);</strong></p><p>Here, the first argument to asprintf is denoted as return argument, which means that displaying the whole argument list is delayed until the function returns:</p><p>a.out-&gt;asprintf( &lt;unfinished ...&gt;</p><p>libc.so.6-&gt;malloc(100)                   = 0x245b010</p><p>[... more calls here ...]</p><p>&lt;... asprintf resumed&gt; "X=1", "X=%d", 1) = 5</p><p>It is currently not possible to have an "inout" argument that passes information in both directions.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>In the following, the first is the C prototype, and following that is ltrace configuration line.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>void</strong> func_charp_string<strong>(char</strong> str<strong>[]);</strong></p>
  </dt>
  <dd>
    <p><strong>void</strong> func_charp_string<strong>(string);</strong></p>
  </dd>

</dl>
<p><strong>enum</strong> e_foo <strong>{</strong>RED<strong>, </strong>GREEN<strong>, </strong>BLUE<strong>};</strong></p><p><strong>void</strong> func_enum<strong>(enum</strong> e_foo bar<strong>);</strong></p><p><strong>void</strong> func_enum<strong>(enum(</strong>RED<strong>,</strong>GREEN<strong>,</strong>BLUE<strong>));</strong></p><p>- or -</p><p><strong>typedef</strong> e_foo <strong>= enum(</strong>RED<strong>,</strong>GREEN<strong>,</strong>BLUE<strong>);</strong></p><p><strong>void</strong> func_enum<strong>(</strong>e_foo<strong>);</strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>void</strong> func_arrayi<strong>(int</strong> arr<strong>[],</strong> int len<strong>);</strong></p>
  </dt>
  <dd>
    <p><strong>void</strong> func_arrayi<strong>(array(int,arg2)*,int);</strong></p>
  </dd>

</dl>
<p><strong>struct</strong> S1 <strong>{float</strong> f<strong>; char</strong> a<strong>; char </strong>b<strong>;};</strong></p><p><strong>struct</strong> S2 <strong>{char</strong> str<strong>[</strong>6<strong>]; float</strong> f<strong>;};</strong></p><p><strong>struct</strong> S1 func_struct<strong>(int </strong>a<strong>, struct </strong>S2<strong>, double </strong>d<strong>);</strong></p><p><strong>struct(float,char,char)</strong> func_struct_2<strong>(int, struct(string(array(char, </strong>6<strong>)),float), double);</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Petr Machata &lt;pmachata@redhat.com&gt;</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="lsmboxrc.5.html"><span aria-hidden="true">&larr;</span> lsmboxrc.5: Configuration file for lsmbox</a></li>
   <li class="next"><a href="lts.conf.5.html">lts.conf.5: Main configuration file for ltsp <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

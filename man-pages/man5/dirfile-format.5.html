<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>dirfile-format: Dirfile-format  the dirfile database format specification file</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Dirfile-format  the dirfile database format specification file">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="dirfile-format (5) manual">
  <meta name="twitter:description" content="Dirfile-format  the dirfile database format specification file">
  <meta name="twitter:image" content="https://www.carta.tech/images/libgetdata-tools-dirfile-format-5.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man5/dirfile-format.5.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="dirfile-format (5) manual" />
  <meta property="og:description" content="Dirfile-format  the dirfile database format specification file" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libgetdata-tools-dirfile-format-5.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">dirfile-format<small> (5)</small></h1>
        <p class="lead">Dirfile-format  the dirfile database format specification file</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/">
      <span itemprop="name">File formats and conventions</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/dirfile-format.5.html">
      <span itemprop="name">dirfile-format: Dirfile-format  the dirfile database format specification file</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libgetdata-tools/">
      <span itemprop="name">libgetdata-tools</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/dirfile-format.5.html">
      <span itemprop="name">dirfile-format: Dirfile-format  the dirfile database format specification file</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The <em>dirfile format specification</em> fully specifies the raw and derived time streams and auxiliary information for a <a href="../man5/dirfile.5.html"><strong>dirfile</strong>(5)</a> database.</p><p>The format specification is contained in one or more case-sensitive text files located in the dirfile tree.  Each file is known as a <em>fragment</em>. The primary fragment is the file called <strong>format</strong> located in the base dirfile directory.  This file may contain only part of the format specification, and may reference other fragments (using the <strong>/INCLUDE</strong> directive) containing further format specification.  This inclusion mechanism may be nested arbitrarily deep.</p><p>The explicit text encoding of these files is not specified by these standards, but must be 7-bit ASCII compatible. Examples of acceptable character encodings include all the ISO\~8859 character sets (<em>i.e.</em> Latin-1 through Latin-10, among others), as well as the UTF-8 encoding of Unicode and UCS.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNTAX</h2>
        <div class="sectioncontent">
<p>The format specification is composed of field specification lines and directive lines, optionally separated by blank lines or lines containing only whitespace. Lines are separated by the line-feed character (0x0A).  Unless escaped (see below), the hash mark (<strong>#</strong>) is the comment delimiter; the comment delimiter, and any text following it to the end of the line, is ignored.</p><h3>Tokens</h3>
<p>Both field specification lines and directive lines consist of several tokens separated by whitespace.  Whitespace consists of one or more whitespace characters.  These are: space (0x20), horizontal tab (0x09), vertical tab (0x0B), form-feed (0x0C), and carriage return (0x0D).  The first token of a directive line is always a <em>reserved word</em>. The first token of a field specification line is never a reserved word.  Any amount of whitespace may precede the first token on a line.</p><p>Since tokens are separated by whitespace, to include a whitespace character in a token, it must either escaped by preceding it by a backslash character (<strong>&#92;</strong>), or be replaced by a <em>character escape sequence</em> (see below), or else the token must be enclosed in quotation marks (<strong></strong><strong>).</strong> The quotation marks themselves will be stripped from the token. The <em>null-token</em> (that is, the token consisting of zero characters) may be specified by a pair of quotation marks with nothing between them (<strong></strong><strong></strong>). To include a literal quotation mark in a token, it must be escaped (<strong>&#92;"</strong>). Similarly, a hash mark may be included in a token by including it in a quoted token or else by escaping it (<strong>&#92;#</strong>), otherwise the hash mark will be understood as the comment delimiter.</p><p>It is a syntax error to have a line which contains unmatched quotation marks, or in which the last character is the backslash character.</p><p>Several characters when escaped by a preceding backslash character are interpreted as special characters in tokens.  The character escape sequences are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>&#92;a</strong></p>
  </dt>
  <dd>
    <p>an alert (bell) character (ASCII 0x07 / U+0007)</p>
  </dd>
  <dt>
    <p><strong>&#92;b</strong></p>
  </dt>
  <dd>
    <p>a backspace character (ASCII 0x08 / U+0008)</p>
  </dd>
  <dt>
    <p><strong>&#92;e</strong></p>
  </dt>
  <dd>
    <p>an escape character (ASCII 0x1B / U+001B)</p>
  </dd>
  <dt>
    <p><strong>&#92;f</strong></p>
  </dt>
  <dd>
    <p>a form-feed character (ASCII 0x0C / U+000C)</p>
  </dd>
  <dt>
    <p><strong>&#92;n</strong></p>
  </dt>
  <dd>
    <p>a line-feed character (ASCII 0x0A / U+000A)</p>
  </dd>
  <dt>
    <p><strong>&#92;r</strong></p>
  </dt>
  <dd>
    <p>a carriage return character (ASCII 0x0D / U+000D)</p>
  </dd>
  <dt>
    <p><strong>&#92;t</strong></p>
  </dt>
  <dd>
    <p>a horizontal tab character (ASCII 0x09 / U+0009)</p>
  </dd>
  <dt>
    <p><strong>&#92;v</strong></p>
  </dt>
  <dd>
    <p>a vertical tab character (ASCII 0x0B / U+000B)</p>
  </dd>
  <dt>
    <p><strong>&#92;&#92;</strong></p>
  </dt>
  <dd>
    <p>a backslash character (ASCII 0x5C / U+005C)</p>
  </dd>
  <dt>
    <p><strong>&#92;</strong><em>ooo</em></p>
  </dt>
  <dd>
    <p>the single byte given by the octal number <em>ooo</em>.</p>
  </dd>
  <dt>
    <p><strong>&#92;x</strong><em>hh</em></p>
  </dt>
  <dd>
    <p>the single byte given by the hexadecimal number <em>hh</em>.</p>
  </dd>
  <dt>
    <p><strong>&#92;u</strong><em>hhhhhhh</em></p>
  </dt>
  <dd>
    <p>the UTF-8 byte sequence encoding the Unicode code point given by the hexadecimal number <em>hhhhhhh</em>.</p>
  </dd>

</dl>
<p>Any other character which is escaped is interpreted as the character itself. (<em>i.e.</em> <strong>&#92;c</strong> is interpreted as <strong>c</strong>; also, as pointed out above, <strong>&#92;"</strong> and <strong>&#92;#</strong> are interpreted as simply <strong> </strong> and <strong>#</strong>, without their special meanings).</p><p>No token may contain the NULL character (ASCII 0x00 / U+0000).  Furthermore, although support is present to create UTF-8 byte sequences, tokens are not required to be valid UTF-8 sequences.  Any byte sequence not containing the NULL character forms a valid token.  However, there may be further restrictions on allowed characters for a token in a particular situation, (for example, when used as a field name).</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DIRECTIVES</h2>
        <div class="sectioncontent">
<p>There are eight <em>reserved words</em>, which cannot be used as field names in the dirfile.  Instead, these specify directives.  All reserved words start with an initial forward slash (<strong>/</strong>), to distinguish them from field names.  Previous versions of the Standards permitted the omission of the slash.  Like the rest of the format specification, directives are case sensitive.</p><p>A number of the directives have <em>fragment scope</em>. A directive with fragment scope only applies to the fragment in which it is present, plus any sub-fragments indicated by the <strong>/INCLUDE</strong> directive, but only if those sub-fragments don't have their own corresponding directive.  Directives which have fragment scope are: <strong>/ENCODING</strong>,\~<strong>/ENDIAN</strong>,\~<strong>/FRAMEOFFSET</strong>, and <strong>/PROTECT</strong>. Because of these scoping rules, different portions of the dirfile may have different encodings, endiannesses, frame offsets, or protection levels.</p><p>If a directive with fragment scope appears more than once in a fragment, only the last such directive will be honoured, with the exception that the effect of a directive will not be propagated to sub-fragments if the directive line appears after the sub-fragment is included.  The scoping rules of the remaining directives are discussed below.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>/ENCODING</strong></p>
  </dt>
  <dd>
    <p>The /ENCODING directive specifies the encoding scheme used to encode binary files in the dirfile.  The encoding scheme may be one of the predefined names listed below, which are described in more detail in <a href="../man5/dirfile-encoding.5.html"><strong>dirfile-encoding</strong>(5)</a>, or any other site-specific encoding scheme.  The predefined scheme names are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>none</em></p>
  </dt>
  <dd>
    <p>The dirfile is unencoded.</p>
  </dd>
  <dt>
    <p><em>bzip2</em></p>
  </dt>
  <dd>
    <p>The dirfile is compressed using the bzip2 compression scheme.</p>
  </dd>
  <dt>
    <p><em>gzip</em></p>
  </dt>
  <dd>
    <p>The dirfile is compressed using the gzip compression scheme.</p>
  </dd>
  <dt>
    <p><em>lzma</em></p>
  </dt>
  <dd>
    <p>The dirfile is compressed using the LZMA compression scheme.</p>
  </dd>
  <dt>
    <p><em>slim</em></p>
  </dt>
  <dd>
    <p>The dirfile is compressed using the slim compression scheme.</p>
  </dd>
  <dt>
    <p><em>text</em></p>
  </dt>
  <dd>
    <p>The dirfile is text encoded.</p>
  </dd>

</dl>
<p>Implementations should fail gracefully when encountering an unknown encoding scheme.  If no encoding scheme is specified, behaviour is implementation dependent.  Syntax is:</p><ul>
<li><p><strong>/ENCODING\~</strong><em>&lt;scheme&gt;</em></p></li>
</ul><p>The /ENCODING directive has <em>fragment scope</em>.</p>
  </dd>
  <dt>
    <p><strong>/ENDIAN</strong></p>
  </dt>
  <dd>
    <p>The /ENDIAN directive specifies the endianness of the raw data in the database. The assumed endianness of raw data in dirfiles which omit this directive is implementation dependent.  Syntax is:</p><ul>
<li><p><strong>/ENDIAN</strong> <em>( </em>big<em> | </em>little<em> ) [ </em>arm<em> ]</em></p></li>
</ul><p>where the "arm" token should be included if double precision floating point data are stored in the ARM middle-endian format.  The /ENDIAN directive has <em>fragment scope</em>.</p>
  </dd>
  <dt>
    <p><strong>/FRAMEOFFSET</strong></p>
  </dt>
  <dd>
    <p>The /FRAMEOFFSET directive specifies the frame number of the first frame for which data exists in binary files associated with <strong>RAW</strong> fields.  Syntax is:</p><ul>
<li><p><strong>/FRAMEOFFSET\~</strong><em>&lt;integer&gt;</em></p></li>
</ul><p>The /FRAMEOFFSET directive has <em>fragment scope</em>.</p>
  </dd>
  <dt>
    <p><strong>/INCLUDE</strong></p>
  </dt>
  <dd>
    <p>The /INCLUDE directive specifies another file (called a <em>fragment</em>) to parse for additional format specification for the dirfile.  The inclusion is treated as if the lines of the fragment were pasted verbatim in place of the INCLUDE directive line.  The exception to this is that RAW fields specified in the fragment are located in the directory containing the fragment and not in the directory containing the parent fragment, and the binary file encoding may be different for each fragment.  The fragment may be specified either with an absolute path, or else a relative path from the current file.  Syntax is:</p><ul>
<li><p><strong>/INCLUDE\~</strong><em>&lt;file&gt;</em></p></li>
</ul><p>The /INCLUDE directive has no scope: it is processed immediately and has no long-term effect.</p>
  </dd>
  <dt>
    <p><strong>/META</strong></p>
  </dt>
  <dd>
    <p>The /META directive specifies a metafield attached to a particular parent field.  The field metadata may be of any allowed type except <strong>RAW</strong>. Metafields are retrieved in exactly the same way as regular field data, but the <em>field code</em> specified consists of the parent and metafield names joined with a forward slash:</p><ul>
<li><p><em>&lt;parent-field&gt;</em><strong>/</strong><em>&lt;meta-field&gt;</em></p></li>
</ul><p>META fields may not be specified before their parent field has been.  Syntax is:</p><ul>
<li><p><strong>/META</strong> <em>&lt;parent-field&gt;</em> {field specification line}</p></li>
</ul><p>As an illustration of this concept,</p><ul>
<li><p><strong>/META</strong> pfield meta <strong>CONST FLOAT64</strong> 3.291882</p></li>
</ul><p>provides a scalar metadatum called <em>meta</em> with value 3.291882 attached to the field <em>pfield</em>. This particular metafield may be referred to by the <em>field code</em> "pfield/meta".  Note that different parent fields may have metafields with the same name, since all references to metafields must include the parent field name.  Metafields may not themselves have further sub-metafields.</p><p>As an alternative to the /META directive, a metafield may be specified by a standard field specification line, using</p><ul>
<li><p><em>&lt;parent-field&gt;</em><strong>/</strong><em>&lt;meta-field&gt;</em></p></li>
</ul><p>as the field name.  That is, the above example metafield could have also been specified as:</p><ul>
<li><p>pfield/meta <strong>CONST FLOAT64</strong> 3.291882</p></li>
</ul><p>The /META directive has no scope: it is processed immediately and has no long-term effect.</p>
  </dd>
  <dt>
    <p><strong>/PROTECT</strong></p>
  </dt>
  <dd>
    <p>The /PROTECT directive specifies the advisory protection level of the current fragment and of the <strong>RAW</strong> fields defined therein.  The protection level indicates whether writing to the fragment, or the binary data on disk is permitted.  Syntax is:</p><ul>
<li><p><strong>/PROTECT\~</strong><em>&lt;level&gt;</em></p></li>
</ul><p>Four advisory protection levels are defined:</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>none</em></p>
  </dt>
  <dd>
    <p>No protection at all: data and metadata may be freely changed.  This is the default, if no /PROTECT directive is present.</p>
  </dd>
  <dt>
    <p><em>format</em></p>
  </dt>
  <dd>
    <p>The dirfile metadata is protected from change, but <strong>RAW</strong> data on disk may be modified.</p>
  </dd>
  <dt>
    <p><em>data</em></p>
  </dt>
  <dd>
    <p>The <strong>RAW</strong> data on disk is protected from change, but metadata may be modified.</p>
  </dd>
  <dt>
    <p><em>all</em></p>
  </dt>
  <dd>
    <p>Both metadata and data on disk are protected from change.</p>
  </dd>

</dl>
<p>The /PROTECT directive has <em>fragment scope</em>.</p>
  </dd>
  <dt>
    <p><strong>/REFERENCE</strong></p>
  </dt>
  <dd>
    <p>The /REFERENCE directive specifies the name of the field to use as the dirfile's reference field (see <a href="../man5/dirfile.5.html"><strong>dirfile</strong>(5)</a>). If no /REFERENCE directive is specified, the first <strong>RAW</strong> field encountered is used as the reference field.  The /REFERENCE directive must specify a <strong>RAW</strong> field.  Syntax is:</p><ul>
<li><p><strong>/REFERENCE\~</strong><em>&lt;field-code&gt;</em></p></li>
</ul><p>The /REFERENCE directive has <em>global scope</em>: if multiple /REFERENCE directives appear in the dirfile metadata, only the last such will be honoured.</p>
  </dd>
  <dt>
    <p><strong>/VERSION</strong></p>
  </dt>
  <dd>
    <p>The /VERSION directive specifies the particular version of the Dirfile Standards to which the dirfile format specification conforms.  This directive should occur before any version dependent syntax is encountered.  As of Standards Version 6, no such syntax exists, and this directive is provided primarily to ease forward compatibility.  Syntax is:</p><ul>
<li><p><strong>/VERSION\~</strong><em>&lt;integer&gt;</em></p></li>
</ul><p>The /VERSION directive has <em>immediate scope</em>: its effect is immediate, and it applies only to metadata below it, including and propagating downwards to sub-fragments after the directive.  Its effect will also propagate upwards back to the parent fragment, and affect subsequent metadata.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FIELD SPECIFICATION LINES</h2>
        <div class="sectioncontent">
<p>Any line which does not start with a <em>reserved word</em> is assumed to be a field specification line.  A field specification line consists of at least two tokens.  The first token is the <em>field name</em>. The second token is the <em>field type</em>. Subsequent tokens are field parameters.  The meaning and number these parameters depends on the field type specified.</p><h3>Field Names</h3>
<p>The first token in a field specification line is the field name.  The field name consists of one or more characters, excluding both ASCII control characters (the bytes 0x01 through 0x1F), and the characters</p><ul>
<li><p><strong>&\t/\t;\t&lt;\t&gt;\t|\t.</strong></p></li>
</ul><p>which are reserved (but see below for the use of <strong>/</strong> to specify metafields).  The field name may not be <em>INDEX</em>, which is a special, implicit field which contains the integer frame index. Field names are case sensitive.</p><p>If the field name beginning a field specification line does contain a <strong>/</strong> character, the line is assumed to specify a metafield.  See the <strong>/META</strong> directive above for further details.</p>
<h3>Field Types</h3>
<p>There are thirteen field types.  Of these, ten are of vector type (<strong>BIT</strong>, <strong>DIVIDE</strong>, <strong>LINCOM</strong>, <strong>LINTERP</strong>, <strong>MULTIPLY</strong>, <strong>PHASE</strong>, <strong>POLYNOM</strong>, <strong>RAW</strong>, <strong>RECIP</strong>, and <strong>SBIT</strong>) and three are of scalar type (<strong>CONST</strong>, <strong>CARRAY</strong>, and <strong>STRING</strong>). The possible fields types are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>BIT</strong></p>
  </dt>
  <dd>
    <p>The BIT vector field type extracts one or more bits out of an input vector field as an unsigned number.  Syntax is:</p><ul>
<li><p><em>&lt;field-name&gt;</em> <strong>BIT</strong> <em>&lt;input&gt; &lt;first-bit&gt; [&lt;bits&gt;]</em></p></li>
</ul><p>which specifies <em>field-name</em> to be the value of bits <em>first-bit</em> through <em>first-bit</em>+<em>bits</em>-1 of the input vector field <em>input</em>, when <em>input</em> is converted from its native type to an (endianness corrected) unsigned 64-bit integer.  If <em>bits</em> is omitted, it is assumed to be 1.  Both <em>first-bit</em> and <em>bits</em> may be either literal numbers, or else the field code of a <strong>CONST</strong> or <strong>CARRAY</strong> field type containing their values.  The <strong>SBIT</strong> field type is a signed version of this field type.</p>
  </dd>
  <dt>
    <p><strong>CARRAY</strong></p>
  </dt>
  <dd>
    <p>The CARRAY scalar field type is a list of constants fully specified in the format specification metadata.  Syntax is:</p><ul>
<li><p><em>&lt;field-name&gt;</em> <strong>CARRAY</strong> <em>&lt;type&gt; &lt;value0&gt; &lt;value1&gt; &lt;value2&gt; ...</em></p></li>
</ul><p>where <em>type</em> may be any supported native data type (see the description of the <strong>RAW</strong> field type below), and <em>value0</em>, <em>value1</em>, &c. are the values of successive elements in the scalar list interpreted as indicated by <em>type</em>. No limit is placed on the number of elements in a <strong>CARRAY</strong>. (Note: despite being multivalued, this is not considered a vector field since the elements of the <strong>CARRAY</strong> are not indexed by frames.)</p>
  </dd>
  <dt>
    <p><strong>CONST</strong></p>
  </dt>
  <dd>
    <p>The CONST scalar field type is a constant fully specified in the format specification metadata.  Syntax is:</p><ul>
<li><p><em>&lt;field-name&gt;</em> <strong>CONST</strong> <em>&lt;type&gt; &lt;value&gt;</em></p></li>
</ul><p>where <em>type</em> may be any supported native data type (see the description of the <strong>RAW</strong> field type below), and <em>value</em> is the numerical value of the constant interpreted as indicated by <em>type</em>.</p>
  </dd>
  <dt>
    <p><strong>DIVIDE</strong></p>
  </dt>
  <dd>
    <p>The DIVIDE vector field type is the quotient of two vector fields.  Syntax is:</p><ul>
<li><p><em>&lt;field-name&gt;</em> <strong>DIVIDE</strong> <em>&lt;field1&gt; &lt;field1&gt;</em></p></li>
</ul><p>The derived field will be computed as:</p><ul>
<li><p>field-name[n] = field1[n] / field2[n2]</p></li>
</ul><p>with the index <em>n2</em> computed appropriately for the (potentially differing) sample rates of the input fields.  The resultant field will have the same sample rate as <em>field1</em>.</p>
  </dd>
  <dt>
    <p><strong>LINCOM</strong></p>
  </dt>
  <dd>
    <p>The LINCOM vector field type is the linear combination of one, two or three input vector fields.  Syntax is:</p><ul>
<li><p><em>&lt;field-name&gt;</em> <strong>LINCOM</strong> [<em>&lt;n&gt;</em>] <em>&lt;field1&gt; &lt;a1&gt; &lt;b1&gt;</em>\~<em>[</em>&lt;field2&gt; &lt;a2&gt; &lt;b2&gt;<em>\~</em>[<em>&lt;field3&gt; &lt;a3&gt;</em> <em>&lt;b3&gt;</em>]]</p></li>
</ul><p>where <em>n</em>, if present, indicates the number of input vector fields (1, 2, or 3).  The derived field will be computed as:</p><ul>
<li><p>field-name[n] = (a1 * field1[n] + b1) + (a2 * field2[n2] + b2) + (a3 * field3[n3] + b3)</p></li>
</ul><p>with the <em>field2</em> and <em>field3</em> terms included only if specified and the indices <em>n2</em> and <em>n3</em> computed appropriately for the (potentially differing) sample rates of the input fields.  The resultant field will have the same sample rate as <em>field1</em>. Each supplied co-efficient (<em>a1</em>,\~<em>b1</em>,\~<em>a2</em>, &c.) may be either a literal number, or else the field code of a <strong>CONST</strong> or <strong>CARRAY</strong> field type containing its value.</p><p>If <em>n</em> is not specified, the number of fields is determined by looking at the supplied parameters.  Since it is possible to create a field code which is identical to a literal number, the third token on the line is assumed to be <em>n</em> if it the entire token can be parsed as a literal number using the rules outlined in <a href="../man3/strtod.3.html"><strong>strtod</strong>(3)</a>. That is, if the field code specifying <em>field1</em> could be mistaken for a literal number, <em>n</em> must be specified to prevent ambiguity.</p>
  </dd>
  <dt>
    <p><strong>LINTERP</strong></p>
  </dt>
  <dd>
    <p>The LINTERP vector field type specifies a table look up based on another vector field.  Syntax is:</p><ul>
<li><p><em>&lt;field-name&gt;</em> <strong>LINTERP</strong> <em>&lt;input&gt; &lt;table&gt;</em></p></li>
</ul><p>where <em>input</em> is the input vector field for the table lookup, and <em>table</em> is the path to the lookup table file for the field.  If this path is relative, it is assumed to be relative to the directory containing the fragment defining this field.  The lookup table file is an ASCII text file with two whitespace separated columns of <em>x</em> and <em>y</em> values.  Values are linearly interpolated between the points specified in the lookup table.</p>
  </dd>
  <dt>
    <p><strong>MULTIPLY</strong></p>
  </dt>
  <dd>
    <p>The MULTIPLY vector field type is the product of two vector fields.  Syntax is:</p><ul>
<li><p><em>&lt;field-name&gt;</em> <strong>MULTIPLY</strong> <em>&lt;field1&gt; &lt;field2&gt;</em></p></li>
</ul><p>The derived field will be computed as:</p><ul>
<li><p>field-name[n] = field1[n] * field2[n2]</p></li>
</ul><p>with the index <em>n2</em> computed appropriately for the (potentially differing) sample rates of the input fields.  The resultant field will have the same sample rate as <em>field1</em>.</p>
  </dd>
  <dt>
    <p><strong>PHASE</strong></p>
  </dt>
  <dd>
    <p>The PHASE vector field type shifts an input vector field by the specified number of samples.  Syntax is:</p><ul>
<li><p><em>&lt;field-name&gt;</em> <strong>PHASE</strong> <em>&lt;input&gt; &lt;shift&gt;</em></p></li>
</ul><p>which specifies <em>field-name</em> to be the input vector field, <em>input</em>, shifted by <em>shift</em> samples.  A positive <em>shift</em> indicates a forward shift, towards the end-of-field.  Results of shifting past the beginning- or end-of-field is implementation dependent.  The <em>shift</em> parameter may be either a literal number, or else the field code of a <strong>CONST</strong> or <strong>CARRAY</strong> field type containing its values.</p>
  </dd>
  <dt>
    <p><strong>POLYNOM</strong></p>
  </dt>
  <dd>
    <p>The POLYNOM vector field type specifies a polynomial function of a single input vector field.  Syntax is:</p><ul>
<li><p><em>&lt;field_name&gt;</em> <strong>POLYNOM</strong> <em>&lt;input&gt; &lt;a0&gt; &lt;a1&gt;</em> [<em>&lt;a2&gt;</em>\~[<em>&lt;a3&gt;</em>\~[<em>&lt;a4&gt;</em>\~[<em>&lt;a5&gt;</em>]]]]</p></li>
</ul><p>where <em>&lt;input&gt;</em> is the input field code, and the order of the computed polynomial is determined by how many co-efficients are present in the specification.  The derived field is computed as:</p><ul>
<li><p>field-name[n] = a0 + a1 * input[n] + a2 * input[n]**2 + a3 * input[n]**3 + a4 * input[n]**4 + a5 * input[n]**5</p></li>
</ul><p>where <em>**</em> is the exponentiation operator, and the higher order terms are computed only if the corresponding co-efficients a<em>i</em> are specified.  The coefficients, if specified, may be either literal numbers, or else the field code of a <strong>CONST</strong> or <strong>CARRAY</strong> field type containing the value.</p>
  </dd>
  <dt>
    <p><strong>RECIP</strong></p>
  </dt>
  <dd>
    <p>The RECIP vector field type computes the reciprocal of a single input vector field.  Syntax is:</p><ul>
<li><p><em>&lt;field_name&gt;</em> <strong>RECIP</strong> <em>&lt;input&gt; &lt;dividend&gt;</em></p></li>
</ul><p>where <em>&lt;input&gt;</em> is the input field code and <em>&lt;dividend&gt;</em> is a scalar quantity.  The derived field is computed as:</p><ul>
<li><p>field-name[n] = dividend / input[n].</p></li>
</ul><p>The dividend, if specified, may be either literal numbers, or else the field code of a <strong>CONST</strong> or <strong>CARRAY</strong> field type containing the value.</p>
  </dd>
  <dt>
    <p><strong>RAW</strong></p>
  </dt>
  <dd>
    <p>The RAW vector field type specifies raw time streams on disk.  In this case, the field name should correspond to the name of the file containing the time stream. Syntax is:</p><ul>
<li><p><em>&lt;field-name&gt;</em> <strong>RAW</strong> <em>&lt;type&gt; &lt;sample-rate&gt;</em></p></li>
</ul><p>where <em>sample-rate</em> is the number of samples per dirfile frame for the time stream and <em>type</em> is a token specifying the native data format type:</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>UINT8</em></p>
  </dt>
  <dd>
    <p>unsigned 8-bit integer</p>
  </dd>
  <dt>
    <p><em>INT8</em></p>
  </dt>
  <dd>
    <p>signed (two's complement) 8-bit integer</p>
  </dd>
  <dt>
    <p><em>UINT16</em></p>
  </dt>
  <dd>
    <p>unsigned 16-bit integer</p>
  </dd>
  <dt>
    <p><em>INT16</em></p>
  </dt>
  <dd>
    <p>signed (two's complement) 16-bit integer</p>
  </dd>
  <dt>
    <p><em>UINT32</em></p>
  </dt>
  <dd>
    <p>unsigned 32-bit integer</p>
  </dd>
  <dt>
    <p><em>INT32</em></p>
  </dt>
  <dd>
    <p>signed (two's complement) 32-bit integer</p>
  </dd>
  <dt>
    <p><em>UINT64</em></p>
  </dt>
  <dd>
    <p>unsigned 64-bit integer</p>
  </dd>
  <dt>
    <p><em>INT64</em></p>
  </dt>
  <dd>
    <p>signed (two's complement) 64-bit integer</p>
  </dd>
  <dt>
    <p><em>FLOAT32</em>\~or\~<em>FLOAT</em></p>
  </dt>
  <dd>
    <p>IEEE-754 standard 32-bit single precision floating point number</p>
  </dd>
  <dt>
    <p><em>FLOAT64</em>\~or\~<em>DOUBLE</em></p>
  </dt>
  <dd>
    <p>IEEE-754 standard 64-bit double precision floating point number</p>
  </dd>
  <dt>
    <p><em>COMPLEX64</em></p>
  </dt>
  <dd>
    <p>a 64-bit complex number consisting of two IEEE-754 standard 32-bit single precision floating point numbers representing the real and imaginary parts of the complex number.</p>
  </dd>
  <dt>
    <p><em>COMPLEX128</em></p>
  </dt>
  <dd>
    <p>a 128-bit complex number consisting of two IEEE-754 standard 64-bit double precision floating point numbers representing the real and imaginary parts of the complex number.</p>
  </dd>

</dl>
<p>For more information on the storage of complex valued data, see <a href="../man5/dirfile.5.html"><strong>dirfile</strong>(5)</a>.</p><p>For backwards compatibility, implementations should also recognise the following single character type aliases in use prior to Standards Version 5:</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>c</em></p>
  </dt>
  <dd>
    <p>UINT8</p>
  </dd>
  <dt>
    <p><em>u</em></p>
  </dt>
  <dd>
    <p>UINT16</p>
  </dd>
  <dt>
    <p><em>s</em></p>
  </dt>
  <dd>
    <p>INT16</p>
  </dd>
  <dt>
    <p><em>U</em></p>
  </dt>
  <dd>
    <p>UINT32</p>
  </dd>
  <dt>
    <p><em>i</em>,\~<em>S</em></p>
  </dt>
  <dd>
    <p>INT32</p>
  </dd>
  <dt>
    <p><em>f</em></p>
  </dt>
  <dd>
    <p>FLOAT32</p>
  </dd>
  <dt>
    <p><em>d</em></p>
  </dt>
  <dd>
    <p>FLOAT64</p>
  </dd>

</dl>
<p>Types <em>INT8</em>,\~<em>UINT64</em>,\~<em>INT64</em>,\~<em>COMPLEX64</em>, and <em>COMPLEX128</em> are not supported before Standards Version 5, so no single character type aliases exist for these types.  Standards Version 8 removed support for these single character type codes.</p><p>The <em>sample-rate</em> parameter may be either a literal number, or else the name of a <strong>CONST</strong> or <strong>CARRAY</strong> field type containing its values.</p>
  </dd>
  <dt>
    <p><strong>SBIT</strong></p>
  </dt>
  <dd>
    <p>The SBIT vector field type extracts one or more bits out of an input vector field as a signed number.  Syntax is:</p><ul>
<li><p><em>&lt;field-name&gt;</em> <strong>SBIT</strong> <em>&lt;input&gt; &lt;first-bit&gt; [&lt;bits&gt;]</em></p></li>
</ul><p>which specifies <em>field-name</em> to be the value of bits <em>first-bit</em> through <em>first-bit</em>+<em>bits</em>-1 of the input vector field <em>input</em>, when <em>input</em> is converted from its native type to a (endianness corrected) signed 64-bit integer.  If <em>bits</em> is omitted, it is assumed to be 1.  Both <em>first-bit</em> and <em>bits</em> may be either literal numbers, or else the field code of a <strong>CONST</strong> or <strong>CARRAY</strong> field type containing their values.  The <strong>BIT</strong> field type is an unsigned version of this field type.</p>
  </dd>
  <dt>
    <p><strong>STRING</strong></p>
  </dt>
  <dd>
    <p>The STRING scalar field type is a character string fully specified in the format file metadata.  Syntax is:</p><ul>
<li><p><em>&lt;field-name&gt;</em> <strong>STRING</strong> <em>&lt;value&gt;</em></p></li>
</ul><p>where <em>value</em> is the string value of the field.  Note that <em>value</em> is a single token.  To include whitespace in the string, enclose <em>value</em> in quotation marks (<strong></strong><strong>),</strong> or else escape the whitespace with the backslash character (<strong>&#92;</strong>).</p>
  </dd>

</dl>

<h3>Field Parameters</h3>
<p>All input vector field parameters should be <em>field codes</em> (see below).  Additionally, some of the numerical field parameters may be either literal numbers or else the <em>field code</em> of a <strong>CONST</strong> field containing the value, or the <em>field code</em> of a <strong>CARRAY</strong> followed by a left angle bracket (<em>&lt;</em>), then an non-negative integer used as the <strong>CARRAY</strong> element index, then a right angle bracket (<em>&gt;</em>), that is:</p><ul>
<li><p><em>field_code</em><strong>&lt;</strong><em>n</em><strong>&gt;</strong></p></li>
</ul><p>Parameters which allow non-literal values are indicated above.  If the angle brackets and element index are omitted from a <strong>CARRAY</strong> field code used as a parameter, the first element in the field (index zero) is assumed.</p><p>Since it is possible to create a field code which is identical to a literal number, a parameter is assumed to be the field code of a scalar field only if the entire token cannot be parsed as a literal number using the rules outlined in <a href="../man3/strtod.3.html"><strong>strtod</strong>(3)</a>. For example, a <strong>CONST</strong> field whose field code consists solely of digits can never be used as a parameter in a field specification line.</p><p>A literal complex number is specified as two real (floating point) numbers separated by a semicolon (<strong>;</strong>) with no intervening whitespace.  So, for example, the tokens</p><ul>
<li><p>1;0 0;1 4;0 0;5 9.313e2;74.1</p></li>
</ul><p>represent, respectively, the real unit, the imaginary unit, the real number four, the imaginary number 5<em>i</em>, and the complex number 931.3 + 74.1<em>i</em>. Because the semicolon character cannot be used in field names, a complex valued literal can never be mistaken for a field code.  This allows, among other things, the composition of complex valued fields from purely real input fields. For example, a complex valued field, <em>z</em>, may be created from a real valued field <em>re</em>, representing the real part of the complex number, and the real valued field <em>im</em>, representing the imaginary part of the complex number, with the following <strong>LINCOM</strong> specification:</p><ul>
<li><p><em>z</em> <strong>LINCOM</strong> <em>re</em> 1 0 <em>im</em> 0;1 0</p></li>
</ul>
<h3>Field Codes</h3>
<p>When specifying the input to a field, either as a scalar parameter, or as an input vector field to a non-<strong>RAW</strong> vector field, <em>field codes</em> are used.  A <em>field code</em> is one of:</p><ul>
<li><p>a simple field name, indicating a vector or scalar field</p></li><li><p>a parent field name, followed by a forward slash, followed by a metafield name, indicating a metafield.  See the description of the <strong>/META</strong> directive above for further details.</p></li><li><p>either of the above, followed by a period, followed by a <em>representation suffix</em>, but only if the field or metafield specified is not a <strong>STRING</strong> type field.</p></li>
</ul><p>A <em>representation suffix</em> may be used used to extract a real number from a complex value.  The available suffixes and their meanings are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>.a</strong></p>
  </dt>
  <dd>
    <p>This representation indicates the angle (in radians) between the positive real axis and the value (ie. the complex argument).  The argument is in the range [-pi, pi], and a branch cut exists along the negative real axis.  At the branch cut, -pi is returned if the imaginary part is -0, and pi is returned if the imaginary part is +0.  If z=0, zero is returned.</p>
  </dd>
  <dt>
    <p><strong>.i</strong></p>
  </dt>
  <dd>
    <p>This representation indicates the projection of the value onto the imaginary axis (ie. the imaginary part of the number).</p>
  </dd>
  <dt>
    <p><strong>.m</strong></p>
  </dt>
  <dd>
    <p>This representation indicates the modulus of the value (ie. its absolute value).</p>
  </dd>
  <dt>
    <p><strong>.r</strong></p>
  </dt>
  <dd>
    <p>This representation indicates the projection of the value onto the real axis (ie.  the real part of the number).</p>
  </dd>

</dl>
<p>If the specified field is purely real, the representations are calculated as if the imaginary part was equal to +0.  For example, given a complex valued vector, <em>z</em>, a vector containing the real part of <em>z</em>,\~<em>re_z</em>, could be produced with:</p><ul>
<li><p><em>re_z</em> <strong>PHASE</strong> <em>z.r</em> 0</p></li>
</ul><p>and similarly for the complex field's imaginary part, argument, and absolute value.  (Although it should be pointed out this simplistic an example isn't strictly necessary, since <em>z.r</em> could be used wherever <em>re_z</em> would be.)</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">STANDARDS VERSIONS</h2>
        <div class="sectioncontent">
<p>This document describes Version 8 of the Dirfile Standards.</p><p>Version 8 of the Standards (November 2010) added the <strong>DIVIDE</strong>, <strong>RECIP</strong>, and <strong>CARRAY</strong> field types, made the forward slash on reserved words mandatory, and prohibited using the single character data type aliases in the specification of <strong>RAW</strong> fields.  It also introduced the optional second (<em>arm</em>) token to the <strong>/ENDIAN</strong> directive.</p><p>Version 7 of the Standards (October 2009) added the <strong>SBIT</strong> and <strong>POLYNOM</strong> field types, and the directive-less method of specifying metafields.  It also introduced the data types <em>COMPLEX128</em> and <em>COMPLEX64</em>, along with the notion of <em>representations</em>. Finally, it made the number of fields parameter for <em>LINCOM</em> optional.</p><p>Version 6 of the Standards (October 2008) added the <strong>/ENCODING</strong>,\~<strong>/META</strong>,\~<strong>/PROTECT</strong>, and <strong>/REFERENCE</strong> directives, and the <strong>CONST</strong> and <strong>STRING</strong> field types.  It permitted whitespace in tokens and introduced the character escape sequences. It allowed <strong>CONST</strong> fields to be used as parameters in field specification lines.  It also removed <em>FILEFRAM</em> as an alias for <em>INDEX</em>, and prohibited <strong>.</strong> but allowed <strong>#</strong> and <strong>&#92;</strong> in field names.</p><p>Version 5 of the Standards (August 2008) added <strong>VERSION</strong> and <strong>ENDIAN</strong>, slash demarcation of reserved words, and removed the restriction on field name length.  It introduced the data types <em>INT8</em>,\~<em>INT64</em>, and <em>UINT64</em>, the new-style type specifiers, and increased the range of the <strong>BIT</strong> field type from 32 to 64 bits.  It also prohibited the characters <strong>&;&lt;&gt;&#92;|</strong> in field names.</p><p>Version 4 of the Standards (October 2006) added the <strong>PHASE</strong> field type.</p><p>Version 3 of the Standards (January 2006) added <strong>INCLUDE</strong> and increased the allowed length of a field name from 16 to 50 characters.</p><p>Version 2 of the Standards (September 2005) added the <strong>MULTIPLY</strong> field type.</p><p>Version 1 of the Standards (November 2004) added <strong>FRAMEOFFSET</strong> and the optional fourth argument to the <strong>BIT</strong> field type.</p><p>Version 0 of the Standards (before March 2003) refers to the dirfile standards supported by the <strong>getdata</strong>(3) library originally introduced into the <strong>kst</strong>(1) sources, which contained support for all other features covered by this document.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p>The dirfile specification was developed by C. B. Netterfield &lt;netterfield@astro.utoronto.ca&gt;.</p><p>Since Standards Version 3, the dirfile specification has been maintained by D. V. Wiebe &lt;getdata@ketiltrout.net&gt;.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO dirfile-format&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man5/dirfile.5.html"><strong>dirfile</strong>(5)</a>, <a href="../man5/dirfile-encoding.5.html"><strong>dirfile-encoding</strong>(5)</a></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="dirfile-encoding.5.html"><span aria-hidden="true">&larr;</span> dirfile-encoding.5: Dirfile-encoding  dirfile database encoding schemes</a></li>
   <li class="next"><a href="discover-modprobe.conf.5.html">discover-modprobe.conf.5: Discover-modprobe.conf  configuration file for discover-modprobe(5) <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>mdbTutorialIM: Tutorial of input method</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Tutorial of input method">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="mdbTutorialIM (5) manual">
  <meta name="twitter:description" content="Tutorial of input method">
  <meta name="twitter:image" content="https://www.carta.tech/images/m17n-docs-mdbTutorialIM-5.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man5/mdbTutorialIM.5.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="mdbTutorialIM (5) manual" />
  <meta property="og:description" content="Tutorial of input method" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/m17n-docs-mdbTutorialIM-5.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">mdbTutorialIM<small> (5)</small></h1>
        <p class="lead">Tutorial of input method</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/">
      <span itemprop="name">File formats and conventions</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/mdbTutorialIM.5.html">
      <span itemprop="name">mdbTutorialIM: Tutorial of input method</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/m17n-docs/">
      <span itemprop="name">m17n-docs</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/mdbTutorialIM.5.html">
      <span itemprop="name">mdbTutorialIM: Tutorial of input method</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">Structure of an input method file</h2>
        <div class="sectioncontent">
<p>An input method is defined in a *.mim file with this format.</p>
<pre>
(input-method LANG NAME)

(description (_ "DESCRIPTION"))

(title "TITLE-STRING")

(map
  (MAP-NAME
    (KEYSEQ MAP-ACTION MAP-ACTION ...)        &lt;- rule
    (KEYSEQ MAP-ACTION MAP-ACTION ...)        &lt;- rule
    ...)
  (MAP-NAME
    (KEYSEQ MAP-ACTION MAP-ACTION ...)        &lt;- rule
    (KEYSEQ MAP-ACTION MAP-ACTION ...)        &lt;- rule
    ...)
  ...)

(state
  (STATE-NAME
    (MAP-NAME BRANCH-ACTION BRANCH-ACTION ...)   &lt;- branch
    ...)
  (STATE-NAME
    (MAP-NAME BRANCH-ACTION BRANCH-ACTION ...)   &lt;- branch
    ...)
  ...)
</pre>
<p>Lowercase letters and parentheses are literals, so they must be written as they are. Uppercase letters represent arbitrary strings.</p><p>KEYSEQ specifies a sequence of keys in this format:</p>
<pre>
  (SYMBOLIC-KEY SYMBOLIC-KEY ...)

</pre>
<p>where SYMBOLIC-KEY is the keysym value returned by the xev command. For instance</p>
<pre>
  (n i)

</pre>
<p>represents a key sequence of &lt;n&gt; and &lt;i&gt;. If all SYMBOLIC-KEYs are ASCII characters, you can use the short form</p>
<pre>
  "ni"

</pre>
<p>instead. Consult <strong>Input Method</strong> for Non-ASCII characters.</p><p>Both MAP-ACTION and BRANCH-ACTION are a sequence of actions of this format:</p>
<pre>
  (ACTION ARG ARG ...)

</pre>
<p>The most common action is insert, which is written as this:</p>
<pre>
  (insert "TEXT")

</pre>
<p>But as it is very frequently used, you can use the short form</p>
<pre>
  "TEXT"

</pre>
<p>If 'TEXT' contains only one character 'C', you can write it as</p>
<pre>
  (insert ?C)

</pre>
<p>or even shorter as</p>
<pre>
  ?C

</pre>
<p>So the shortest notation for an action of inserting 'a' is</p>
<pre>
  ?a

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Simple example of capslock</h2>
        <div class="sectioncontent">
<p>Here is a simple example of an input method that works as CapsLock.</p>
<pre>
(input-method en capslock)
(description (_ "Upcase all lowercase letters"))
(title "a-&gt;A")
(map
  (toupper ("a" "A") ("b" "B") ("c" "C") ("d" "D") ("e" "E")
           ("f" "F") ("g" "G") ("h" "H") ("i" "I") ("j" "J")
           ("k" "K") ("l" "L") ("m" "M") ("n" "N") ("o" "O")
           ("p" "P") ("q" "Q") ("r" "R") ("s" "S") ("t" "T")
           ("u" "U") ("v" "V") ("w" "W") ("x" "X") ("y" "Y")
           ("z" "Z")))
(state
  (init (toupper)))
</pre>
<p>When this input method is activated, it is in the initial condition of the first state (in this case, the only state init). In the initial condition, no key is being processed and no action is suspended. When the input method receives a key event &lt;a&gt;, it searches branches in the current state for a rule that matches &lt;a&gt; and finds one in the map toupper. Then it executes MAP-ACTIONs (in this case, just inserting 'A' in the preedit buffer). After all MAP-ACTIONs have been executed, the input method shifts to the initial condition of the current state.</p><p>The shift to <em>the initial condition of the first state</em> has a special meaning; it commits all characters in the preedit buffer then clears the preedit buffer.</p><p>As a result, 'A' is given to the application program.</p><p>When a key event does not match with any rule in the current state, that event is unhandled and given back to the application program.</p><p>Turkish users may want to extend the above example for 'İ' (U+0130: LATIN CAPITAL LETTER I WITH DOT ABOVE). It seems that assigning the key sequence &lt;i&gt; &lt;i&gt; for that character is convenient. So, he will add this rule in toupper.</p>
<pre>
    ("ii" "İ")
</pre>
<p>However, we already have the following rule:</p>
<pre>
    ("i" "I")
</pre>
<p>What will happen when a key event &lt;i&gt; is sent to the input method?</p><p>No problem. When the input method receives &lt;i&gt;, it inserts 'I' in the preedit buffer. It knows that there is another rule that may match the additional key event &lt;i&gt;. So, after inserting 'I', it suspends the normal behavior of shifting to the initial condition, and waits for another key. Thus, the user sees 'I' with underline, which indicates it is not yet committed.</p><p>When the input method receives the next &lt;i&gt;, it cancels the effects done by the rule for the previous 'i' (in this case, the preedit buffer is cleared), and executes MAP-ACTIONs of the rule for 'ii'. So, 'İ' is inserted in the preedit buffer. This time, as there are no other rules that match with an additional key, it shifts to the initial condition of the current state, which leads to commit 'İ'.</p><p>Then, what will happen when the next key event is &lt;a&gt; instead of &lt;i&gt;?</p><p>No problem, either.</p><p>The input method knows that there are no rules that match the &lt;i&gt; &lt;a&gt; key sequence. So, when it receives the next &lt;a&gt;, it executes the suspended behavior (i.e. shifting to the initial condition), which leads to commit 'I'. Then the input method tries to handle &lt;a&gt; in the current state, which leads to commit 'A'.</p><p>So far, we have explained MAP-ACTION, but not BRANCH-ACTION. The format of BRANCH-ACTION is the same as that of MAP-ACTION. It is executed only after a matching rule has been determined and the corresponding MAP-ACTIONs have been executed. A typical use of BRANCH-ACTION is to shift to a different state.</p><p>To see this effect, let us modify the current input method to upcase only word-initial letters (i.e. to capitalize). For that purpose, we modify the 'init' state as this:</p>
<pre>
  (init
    (toupper (shift non-upcase)))
</pre>
<p>Here (shift non-upcase) is an action to shift to the new state non-upcase, which has two branches as below:</p>
<pre>
  (non-upcase
    (lower)
    (nil (shift init)))
</pre>
<p>The first branch is simple. We can define the new map lower as the following to insert lowercase letters as they are.</p>
<pre>
(map
  ...
  (lower ("a" "a") ("b" "b") ("c" "c") ("d" "d") ("e" "e")
         ("f" "f") ("g" "g") ("h" "h") ("i" "i") ("j" "j")
         ("k" "k") ("l" "l") ("m" "m") ("n" "n") ("o" "o")
         ("p" "p") ("q" "q") ("r" "r") ("s" "s") ("t" "t")
         ("u" "u") ("v" "v") ("w" "w") ("x" "x") ("y" "y")
         ("z" "z")))
</pre>
<p>The second branch has a special meaning. The map name nil means that it matches with any key event that does not match any rules in the other maps in the current state. In addition, it does not consume any key event. We will show the full code of the new input method before explaining how it works.</p>
<pre>
(input-method en titlecase)
(description (_ "Titlecase letters"))
(title "abc-&gt;Abc")
(map
  (toupper ("a" "A") ("b" "B") ("c" "C") ("d" "D") ("e" "E")
           ("f" "F") ("g" "G") ("h" "H") ("i" "I") ("j" "J")
           ("k" "K") ("l" "L") ("m" "M") ("n" "N") ("o" "O")
           ("p" "P") ("q" "Q") ("r" "R") ("s" "S") ("t" "T")
           ("u" "U") ("v" "V") ("w" "W") ("x" "X") ("y" "Y")
           ("z" "Z") ("ii" "İ"))
  (lower ("a" "a") ("b" "b") ("c" "c") ("d" "d") ("e" "e")
         ("f" "f") ("g" "g") ("h" "h") ("i" "i") ("j" "j")
         ("k" "k") ("l" "l") ("m" "m") ("n" "n") ("o" "o")
         ("p" "p") ("q" "q") ("r" "r") ("s" "s") ("t" "t")
         ("u" "u") ("v" "v") ("w" "w") ("x" "x") ("y" "y")
         ("z" "z")))
(state
  (init
    (toupper (shift non-upcase)))
  (non-upcase
    (lower (commit))
    (nil (shift init))))
</pre>
<p>Let's see what happens when the user types the key sequence &lt;a&gt; &lt;b&gt; &lt; &gt;. Upon &lt;a&gt;, 'A' is inserted into the buffer and the state shifts to non-upcase. So, the next &lt;b&gt; is handled in the non-upcase state. As it matches a rule in the map lower, 'b' is inserted in the preedit buffer and characters in the buffer ('Ab') are committed explicitly by the 'commit' command in BRANCH-ACTION. After that, the input method is still in the non-upcase state. So the next &lt; &gt; is also handled in non-upcase. For this time, no rule in this state matches it. Thus the branch (nil (shift init)) is selected and the state is shifted to init. Please note that &lt; &gt; is not yet handled because the map nil does not consume any key event. So, the input method tries to handle it in the init state. Again no rule matches it. Therefore, that event is given back to the application program, which usually inserts a space for that.</p><p>When you type 'a quick blown fox' with this input method, you get 'A Quick Blown Fox'. OK, you find a typo in 'blown', which should be 'brown'. To correct it, you probably move the cursor after 'l' and type &lt;Backspace&gt; and &lt;r&gt;. However, if the current input method is still active, a capital 'R' is inserted. It is not a sophisticated behavior.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Example of utilizing surrounding text support</h2>
        <div class="sectioncontent">
<p>To make the input method work well also in such a case, we must use 'surrounding text support'. It is a way to check characters around the inputting spot and delete them if necessary. Note that this facility is available only with Gtk+ applications and Qt applications. You cannot use it with applications that use XIM to communicate with an input method.</p><p>Before explaining how to utilize 'surrounding text support', you must understand how to use variables, arithmetic comparisons, and conditional actions.</p><p>At first, any symbol (except for several preserved ones) used as ARG of an action is treated as a variable. For instance, the commands</p>
<pre>
  (set X 32) (insert X)
</pre>
<p>set the variable X to integer value 32, then insert a character whose Unicode character code is 32 (i.e. SPACE).</p><p>The second argument of the set action can be an expression of this form:</p>
<pre>
  (OPERATOR ARG1 [ARG2])
</pre>
<p>Both ARG1 and ARG2 can be an expression. So,</p>
<pre>
  (set X (+ (* Y 32) Z))
</pre>
<p>sets X to the value of Y * 32 + Z.</p><p>We have the following arithmetic/bitwise OPERATORs (require two arguments):</p>
<pre>
  + - * / & |
</pre>
<p>these relational OPERATORs (require two arguments):</p>
<pre>
  == &lt;= &gt;= &lt; &gt;
</pre>
<p>and this logical OPERATOR (requires one argument):</p>
<pre>
  !
</pre>
<p>For surrounding text support, we have these preserved variables:</p>
<pre>
  @-0, @-N, @+N (N is a positive integer)
</pre>
<p>The values of them are predefined as below and can not be altered.</p><ul>
<li><p>@-0</p></li>
</ul><p>-1 if surrounding text is supported, -2 if not.</p><ul>
<li><p>@-N</p></li>
</ul><p>The Nth previous character in the preedit buffer. If there are only M (M&lt;N) previous characters in it, the value is the (N-M)th previous character from the inputting spot.</p><ul>
<li><p>@+N</p></li>
</ul><p>The Nth following character in the preedit buffer. If there are only M (M&lt;N) following characters in it, the value is the (N-M)th following character from the inputting spot.</p><p>So, provided that you have this context:</p>
<pre>
  ABC|def|GHI
</pre>
<p>('def' is in the preedit buffer, two '|'s indicate borders between the preedit buffer and the surrounding text) and your current position in the preedit buffer is between 'd' and 'e', you get these values:</p>
<pre>
  @-3 -- ?B
  @-2 -- ?C
  @-1 -- ?d
  @+1 -- ?e
  @+2 -- ?f
  @+3 -- ?G
</pre>
<p>Next, you have to understand the conditional action of this form:</p>
<pre>
  (cond
    (EXPR1 ACTION ACTION ...)
    (EXPR2 ACTION ACTION ...)
    ...)
</pre>
<p>where EXPRn are expressions. When an input method executes this action, it resolves the values of EXPRn one by one from the first branch. If the value of EXPRn is resolved into nonzero, the corresponding actions are executed.</p><p>Now you are ready to write a new version of the input method 'Titlecase'.</p>
<pre>
(input-method en titlecase2)
(description (_ "Titlecase letters"))
(title "abc-&gt;Abc")
(map
  (toupper ("a" "A") ("b" "B") ("c" "C") ("d" "D") ("e" "E")
           ("f" "F") ("g" "G") ("h" "H") ("i" "I") ("j" "J")
           ("k" "K") ("l" "L") ("m" "M") ("n" "N") ("o" "O")
           ("p" "P") ("q" "Q") ("r" "R") ("s" "S") ("t" "T")
           ("u" "U") ("v" "V") ("w" "W") ("x" "X") ("y" "Y")
           ("z" "Z") ("ii" "İ")))
(state
  (init
    (toupper

     ;; Now we have exactly one uppercase character in the preedit
     ;; buffer.  So, "@-2" is the character just before the inputting
     ;; spot.

     (cond ((| (& (&gt;= @-2 ?A) (&lt;= @-2 ?Z))
               (& (&gt;= @-2 ?a) (&lt;= @-2 ?z))
               (= @-2 ?İ))

	    ;; If the character before the inputting spot is A..Z,
	    ;; a..z, or İ, remember the only character in the preedit
	    ;; buffer in the variable X and delete it.

	    (set X @-1) (delete @-)

	    ;; Then insert the lowercase version of X.

	    (cond ((= X ?İ) "i")
                  (1 (set X (+ X 32)) (insert X))))))))
</pre>
<p>The above example contains the new action delete. So, it is time to explain more about the preedit buffer. The preedit buffer is a temporary place to store a sequence of characters. In this buffer, the input method keeps a position called the 'current position'. The current position exists between two characters, at the beginning of the buffer, or at the end of the buffer. The insert action inserts characters before the current position. For instance, when your preedit buffer contains 'ab.c' ('.' indicates the current position),</p>
<pre>
  (insert "xyz")
</pre>
<p>changes the buffer to 'abxyz.c'.</p><p>There are several predefined variables that represent a specific position in the preedit buffer. They are:</p><ul>
<li><p>@&lt;, @=, @&gt;</p></li>
</ul><p>The first, current, and last positions.</p><ul>
<li><p>@-, @+</p></li>
</ul><p>The previous and the next positions.</p><p>The format of the delete action is this:</p>
<pre>
  (delete POS)
</pre>
<p>where POS is a predefined positional variable. The above action deletes the characters between POS and the current position. So, (delete @-) deletes one character before the current position. The other examples of delete include the followings:</p>
<pre>
  (delete @+)  ; delete the next character
  (delete @&lt;)  ; delete all the preceding characters in the buffer
  (delete @&gt;)  ; delete all the following characters in the buffer
</pre>
<p>You can change the current position using the move action as below:</p>
<pre>
  (move @-)  ; move the current position to the position before the
               previous character
  (move @&lt;)  ; move to the first position
</pre>
<p>Other positional variables work similarly.</p><p>Let's see how our new example works. Whatever a key event is, the input method is in its only state, init. Since an event of a lower letter key is firstly handled by MAP-ACTIONs, every key is changed into the corresponding uppercase and put into the preedit buffer. Now this character can be accessed with @-1.</p><p>How can we tell whether the new character should be a lowercase or an uppercase? We can do so by checking the character before it, i.e. @-2. BRANCH-ACTIONs in the init state do the job.</p><p>It first checks if the character @-2 is between A to Z, between a to z, or İ by the conditional below.</p>
<pre>
     (cond ((| (& (&gt;= @-2 ?A) (&lt;= @-2 ?Z))
               (& (&gt;= @-2 ?a) (&lt;= @-2 ?z))
               (= @-2 ?İ))
</pre>
<p>If not, there is nothing to do specially. If so, our new key should be changed back into lowercase. Since the uppercase character is already in the preedit buffer, we retrieve and remember it in the variable X by</p>
<pre>
    (set X @-1)
</pre>
<p>and then delete that character by</p>
<pre>
    (delete @-)
</pre>
<p>Lastly we re-insert the character in its lowercase form. The problem here is that 'İ' must be changed into 'i', so we need another conditional. The first branch</p>
<pre>
    ((= X ?İ) "i")
</pre>
<p>means that 'if the character remembered in X is 'İ', 'i' is inserted'.</p><p>The second branch</p>
<pre>
    (1 (set X (+ X 32)) (insert X))
</pre>
<p>starts with '1', which is always resolved into nonzero, so this branch is a catchall. Actions in this branch increase X by 32, then insert X. In other words, they change A...Z into a...z respectively and insert the resulting lowercase character into the preedit buffer. As the input method reaches the end of the BRANCH-ACTIONs, the character is committed.</p><p>This new input method always checks the character before the current position, so 'A Quick Blown Fox' will be successfully fixed to 'A Quick Brown Fox' by the key sequence &lt;BackSpace&gt; &lt;r&gt;.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright (C) 2001 Information-technology Promotion Agency (IPA)</p><p>Copyright (C) 2001-2011 National Institute of Advanced Industrial Science and Technology (AIST)</p><p>Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License &lt;http://www.gnu.org/licenses/fdl.html&gt;.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="mdbIM.5.html"><span aria-hidden="true">&larr;</span> mdbIM.5: Input method</a></li>
   <li class="next"><a href="mdoc.5.html">mdoc.5: Mono documentation xml format <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

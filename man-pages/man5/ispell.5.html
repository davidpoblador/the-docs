<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ispell: Format of ispell dictionaries and affix files</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Format of ispell dictionaries and affix files">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="ispell (5) manual">
  <meta name="twitter:description" content="Format of ispell dictionaries and affix files">
  <meta name="twitter:image" content="https://www.carta.tech/images/ispell-ispell-5.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man5/ispell.5.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="ispell (5) manual" />
  <meta property="og:description" content="Format of ispell dictionaries and affix files" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/ispell-ispell-5.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">ispell<small> (5)</small></h1>
        <p class="lead">Format of ispell dictionaries and affix files</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/">
      <span itemprop="name">File formats and conventions</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/ispell.5.html">
      <span itemprop="name">ispell: Format of ispell dictionaries and affix files</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/ispell/">
      <span itemprop="name">ispell</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/ispell.5.html">
      <span itemprop="name">ispell: Format of ispell dictionaries and affix files</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><strong>Ispell</strong>(1) requires two files to define the language that it is spell-checking. The first file is a dictionary containing words for the language, and the second is an "affix" file that defines the meaning of special flags in the dictionary. The two files are combined by <em>buildhash</em> (see <strong>ispell</strong>(1)) and written to a hash file which is not described here.</p><p>A raw <em>ispell</em> dictionary (either the main dictionary or your own personal dictionary) contains a list of words, one per line. Each word may optionally be followed by a slash ("/") and one or more flags, which modify the root word as explained below. Depending on the options with which <em>ispell</em> was built, case may or may not be significant in either the root word or the flags, independently. Specifically, if the compile-time option CAPITALIZATION is defined, case is significant in the root word; if not, case is ignored in the root word. If the compile-time option MASKBITS is set to a value of 32, case is ignored in the flags; otherwise case is significant in the flags. Contact your system administrator or <em>ispell</em> maintainer for more information (or use the <strong>-vv</strong> flag to find out). The dictionary should be sorted with the <strong>-f</strong> flag of <a href="../man1/sort.1.html"><strong>sort</strong>(1)</a> before the hash file is built; this is done automatically by <strong>munchlist</strong>(1), which is the normal way of building dictionaries.</p><p>If the dictionary contains words that have string characters (see the affix-file documentation below), they must be written in the format given by the <strong>defstringtype</strong> statement in the affix file. This will be the case for most non-English languages. Be careful to use this format, rather than that of your favorite formatter, when adding words to a dictionary.  (If you add words to your personal dictionary during an <em>ispell</em> session, they will automatically be converted to the correct format. This feature can be used to convert an entire dictionary if necessary:)</p>
<pre>
	echo qqqqq &gt; dummy.dict
	buildhash dummy.dict <em>affix-file</em> dummy.hash
	awk '{print "*"}END{print "#"}' <em>old-dict-file</em> &#92;
	| ispell -a -T <em>old-dict-string-type</em> &#92;
	  -d ./dummy.hash -p ./<em>new-dict-file</em> &#92;
	  &gt; /dev/null
	rm dummy.*
</pre>
<p>The case of the root word controls the case of words accepted by <em>ispell</em>, as follows:</p>
<dl class='dl-vertical'>
  <dt>
    (1)
  </dt>
  <dd>
    <p>If the root word appears only in lower case (e.g., <em>bob</em>), it will be accepted in lower case, capitalized, or all capitals.</p>
  </dd>
  <dt>
    (2)
  </dt>
  <dd>
    <p>If the root word appears capitalized (e.g., <em>Robert</em>), it will not be accepted in all-lower case, but will be accepted capitalized or all in capitals.</p>
  </dd>
  <dt>
    (3)
  </dt>
  <dd>
    <p>If the root word appears all in capitals (e.g., <em>UNIX</em>), it will only be accepted all in capitals.</p>
  </dd>
  <dt>
    (4)
  </dt>
  <dd>
    <p>If the root word appears with a "funny" capitalization (e.g., <em>ITCorp</em>), a word will be accepted only if it follows that capitalization, or if it appears all in capitals.</p>
  </dd>
  <dt>
    (5)
  </dt>
  <dd>
    <p>More than one capitalization of a root word may appear in the dictionary. Flags from different capitalizations are combined by OR-ing them together.</p>
  </dd>

</dl>
<p>Redundant capitalizations (e.g., <em>bob</em> and <em>Bob</em>) will be combined by <em>buildhash</em> and by <em>ispell</em> (for personal dictionaries), and can be removed from a raw dictionary by <em>munchlist</em>.</p><p>For example, the dictionary:</p>
<pre>
bob
Robert
UNIX
ITcorp
ITCorp
</pre>
<p>will accept <em>bob</em>, <em>Bob</em>, <em>BOB</em>, <em>Robert</em>, <em>ROBERT</em>, <em>UNIX</em>, <em>ITcorp</em>, <em>ITCorp</em>, and <em>ITCORP</em>, and will reject all others. Some of the unacceptable forms are <em>bOb</em>, <em>robert</em>, <em>Unix</em>, and <em>ItCorp</em>.</p><p>As mentioned above, root words in any dictionary may be extended by flags. Each flag is a single alphabetic character, which represents a prefix or suffix that may be added to the root to form a new word. For example, in an English dictionary the <strong>D</strong> flag can be added to <em>bathe</em> to make <em>bathed</em>. Since flags are represented as a single bit in the hashed dictionary, this results in significant space savings. The <em>munchlist</em> script will reduce an existing raw dictionary by adding flags when possible.</p><p>When a word is extended with an affix, the affix will be accepted only if it appears in the same case as the initial (prefix) or final (suffix) letter of the word. Thus, for example, the entry <em>UNIX/M</em> in the main dictionary (<strong>M</strong> means add an apostrophe and an "s" to make a possessive) would accept <em>UNIX'S</em> but would reject <em>UNIX's</em>. If <em>UNIX's</em> is legal, it must appear as a separate dictionary entry, and it will not be combined by <em>munchlist</em>. (In general, you don't need to worry about these things; <em>munchlist</em> guarantees that its output dictionary will accept the same set of words as its input, so all you have to do is add words to the dictionary and occasionally run munchlist to reduce its size).</p><p>As mentioned, the affix definition file describes the affixes associated with particular flags. It also describes the character set used by the language.</p><p>Although the affix-definition grammar is designed for a line-oriented layout, it is actually a free-format yacc grammar and can be laid out weirdly if you want. Comments are started by a pound (sharp) sign (#), and continue to the end of the line. Backslashes are supported in the usual fashion (<strong>&#92;</strong><em>nnn</em>, plus specials <strong>&#92;n</strong>, <strong>&#92;r</strong>, <strong>&#92;t</strong>, <strong>&#92;v</strong>, <strong>&#92;f</strong>, <strong>&#92;b</strong>, and the new hex format <strong>&#92;x</strong><em>nn</em>). Any character with special meaning to the parser can be changed to an uninterpreted token by backslashing it; for example, you can declare a flag named 'asterisk' or 'colon' with <em>flag &#92;*:</em> or <em>flag &#92;::</em>.</p><p>The grammar will be presented in a top-down fashion, with discussion of each element. An affix-definition file must contain exactly one table:</p>
<pre>
<em>table</em>	:	[<em>headers</em>] [<em>prefixes</em>] [<em>suffixes</em>]
</pre>
<p>At least one of <em>prefixes</em> and <em>suffixes</em> is required. They can appear in either order.</p>
<pre>
<em>headers</em>	:	[ <em>options</em> ] <em>char-sets</em>
</pre>
<p>The headers describe options global to this dictionary and language. These include the character sets to be used and the formatter, and the defaults for certain <em>ispell</em> flags.</p>
<pre>
<em>options</em> :	{ <em>fmtr-stmt</em> | <em>opt-stmt</em> | <em>flag-stmt</em> | <em>num-stmt</em> }
</pre>
<p>The options statements define the defaults for certain ispell flags and for the character sets used by the formatters.</p>
<pre>
<em>fmtr-stmt</em>	:	{ <em>nroff-stmt</em> | <em>tex-stmt</em> }
</pre>
<p>A <em>fmtr-stmt</em> describes characters that have special meaning to a formatter. Normally, this statement is not necessary, but some languages may have preempted the usual defaults for use as language-specific characters. In this case, these statements may be used to redefine the special characters expected by the formatter.</p>
<pre>
<em>nroff-stmt</em>	:	{ <strong>nroffchars</strong> | <strong>troffchars</strong> } <em>string</em>
</pre>
<p>The <strong>nroffchars</strong> statement allows redefinition of certain <em>nroff</em> control characters. The string given must be exactly five characters long, and must list substitutions for the left and right parentheses ("()") , the period ("."), the backslash ("&#92;"), and the asterisk ("*"). (The right parenthesis is not currently used, but is included for completeness.) For example, the statement:</p>
<pre>
<strong>nroffchars</strong> {}.&#92;&#92;*
</pre>
<p>would replace the left and right parentheses with left and right curly braces for purposes of parsing <em>nroff</em>/<em>troff</em> strings, with no effect on the others (admittedly a contrived example). Note that the backslash is escaped with a backslash.</p>
<pre>
<em>tex-stmt</em>	:	{ <strong>TeXchars</strong> | <strong>texchars</strong> } <em>string</em>
</pre>
<p>The <strong>TeXchars</strong> statement allows redefinition of certain TeX/LaTeX control characters. The string given must be exactly thirteen characters long, and must list substitutions for the left and right parentheses ("()") , the left and right square brackets ("[]"), the left and right curly braces ("{}"), the left and right angle brackets ("&lt;&gt;"), the backslash ("&#92;"), the dollar sign ("$"), the asterisk ("*"), the period or dot ("."), and the percent sign ("%"). For example, the statement:</p>
<pre>
<strong>texchars</strong> ()&#92;[\|]&lt;&#92;&gt;&lt;&#92;&gt;&#92;&#92;$*.%
</pre>
<p>would replace the functions of the left and right curly braces with the left and right angle brackets for purposes of parsing TeX/LaTeX constructs, while retaining their functions for the <em>tib</em> bibliographic preprocessor. Note that the backslash, the left square bracket, and the right angle bracket must be escaped with a backslash.</p>
<pre>
<em>opt-stmt</em>	:	{ <em>cmpnd-stmt</em> | <em>aff-stmt</em> }

<em>cmpnd-stmt</em>	:	<strong>compoundwords</strong> <em>compound-opt</em>

<em>aff-stmt</em>		:	<strong>allaffixes</strong> <em>on-or-off</em>

<em>on-or-off</em>	:	{ <strong>on</strong> | <strong>off</strong> }

<em>compound-opt</em> :	{ <em>on-or-off</em> | <strong>controlled</strong> <em>character</em> }
</pre>
<p>An <em>opt-stmt</em> controls certain ispell defaults that are best made language-specific. The <strong>allaffixes</strong> statement controls the default for the <strong>-P</strong> and <strong>-m</strong> options to <em>ispell.</em> If <strong>allaffixes</strong> is turned <strong>off</strong> (the default), <em>ispell</em> will default to the behavior of the <em>-P</em> flag: root/affix suggestions will only be made if there are no "near misses". If <strong>allaffixes</strong> is turned <strong>on</strong>, <em>ispell</em> will default to the behavior of the <em>-m</em> flag: root/affix suggestions will always be made. The <strong>compoundwords</strong> statement controls the default for the <strong>-B</strong> and <strong>-C</strong> options to <em>ispell.</em> If <strong>compoundwords</strong> is turned <strong>off</strong> (the default), <em>ispell</em> will default to the behavior of the <em>-B</em> flag: run-together words will be reported as errors. If <strong>compoundwords</strong> is turned <strong>on</strong>, <em>ispell</em> will default to the behavior of the <em>-C</em> flag: run-together words will be considered as compounds if both are in the dictionary. This is useful for languages such as German and Norwegian, which form large numbers of compound words. Finally, if <strong>compoundwords</strong> is set to <em>controlled</em>, only words marked with the flag indicated by <em>character</em> (which should not be otherwise used) will be allowed to participate in compound formation. Because this option requires the flags to be specified in the dictionary, it is not available from the command line.</p>
<pre>
<em>flag-stmt</em>	:	<strong>flagmarker</strong> <em>character</em>
</pre>
<p>The <strong>flagmarker</strong> statement describes the character which is used to separate affix flags from the root word in a raw dictionary file. This must be a character which is not found in any word (including in string characters; see below). The default is "/" because this character is not normally used to represent special characters in any language.</p>
<pre>
<em>num-stmt</em>	:	<strong>compoundmin</strong> <em>digit</em>
</pre>
<p>The <strong>compoundmin</strong> statement controls the length of the two components of a compound word. This only has an effect if <strong>compoundwords</strong> is turned <strong>on</strong> or if the <strong>-C</strong> flag is given to <em>ispell</em>. In that case, only words at least as long as the given minimum will be accepted as components of a compound. The default is 3 characters.</p>
<pre>
<em>char-sets</em>	:	<em>norm-sets</em> [ <em>alt-sets</em> ]
</pre>
<p>The character-set section describes the characters that can be part of a word, and defines their collating order. There must always be a definition of "normal" character sets;  in addition, there may be one or more partial definitions of "alternate" sets which are used with various text formatters.</p>
<pre>
<em>norm-sets</em> :	[ <em>deftype</em> ] charset-group
</pre>
<p>A "normal" character set may optionally begin with a definition of the file suffixes that make use of this set. Following this are one or more character-set declarations.</p>
<pre>
<em>deftype</em> :	<strong>defstringtype</strong> <em>name</em> <em>deformatter</em> <em>suffix</em>*
</pre>
<p>The <strong>defstringtype</strong> declaration gives a list of file suffixes which should make use of the default string characters defined as part of the base character set; it is only necessary if string characters are being defined. The <em>name</em> parameter is a string giving the unique name associated with these suffixes; often it is a formatter name. If the formatter is a member of the troff family, "nroff" should be used for the name associated with the most popular macro package; members of the TeX family should use "tex". Other names may be chosen freely, but they should be kept simple, as they are used in <em>ispell 's</em> <strong>-T</strong> switch to specify a formatter type. The <em>deformatter</em> parameter specifies the deformatting style to use when processing files with the given suffixes. Currently, this must be either <strong>tex</strong> or <strong>nroff</strong>. The <em>suffix</em> parameters are a whitespace-separated list of strings which, if present at the end of a filename, indicate that the associated set of string characters should be used by default for this file.  For example, the suffix list for the troff family typically includes suffixes such as ".ms", ".me", ".mm", etc.</p>
<pre>
<em>charset-group</em> :	{ <em>char-stmt</em> | <em>string-stmt</em> | <em>dup-stmt</em>}*
</pre>
<p>A <em>char-stmt</em> describes single characters; a <em>string-stmt</em> describes characters that must appear together as a string, and which usually represent a single character in the target language. Either may also describe conversion between upper and lower case. A <em>dup-stmt</em> is used to describe alternate forms of string characters, so that a single dictionary may be used with several formatting programs that use different conventions for representing non-ASCII characters.</p>
<pre>
<em>char-stmt</em>	:	<strong>wordchars</strong> <em>character-range</em>
		|	<strong>wordchars</strong> <em>lowercase-range</em> <em>uppercase-range</em>
		|	<strong>boundarychars</strong> <em>character-range</em>
		|	<strong>boundarychars</strong> <em>lowercase-range</em> <em>uppercase-range</em>
<em>string-stmt</em>	:	<strong>stringchar</strong> <em>string</em>
		|	<strong>stringchar</strong> <em>lowercase-string</em> <em>uppercase-string</em>
</pre>
<p>Characters described with the <strong>boundarychars</strong> statement are considered part of a word only if they appear singly, embedded between characters declared with the <strong>wordchars</strong> or <strong>stringchar</strong> statements. For example, if the hyphen is a boundary character (useful in French), the string "foo-bar" would be a single word, but "-foo" would be the same as "foo", and "foo--bar" would be two words separated by non-word characters.</p><p>If two ranges or strings are given in a <em>char-stmt</em> or <em>string-stmt</em>, the first describes characters that are interpreted as lowercase and the second describes uppercase. In the case of a <strong>stringchar</strong> statement, the two strings must be of the same length. Also, in a <strong>stringchar</strong> statement, the actual strings may contain both uppercase and characters themselves without difficulty; for instance, the statement</p>
<pre>
stringchar	"&#92;&#92;*(sS"	"&#92;&#92;*(Ss"
</pre>
<p>is legal and will not interfere with (or be interfered with by) other declarations of of "s" and "S" as lower and upper case, respectively.</p><p>A final note on string characters: some languages collate certain special characters as if they were strings. For example, the German "a-umlaut" is traditionally sorted as if it were "ae". Ispell is not capable of this; each character must be treated as an individual entity. So in certain cases, ispell will sort a list of words into a different order than the standard "dictionary" order for the target language.</p>
<pre>
<em>alt-sets</em>	:	<em>alttype</em> [ <em>alt-stmt</em>* ]
</pre>
<p>Because different formatters use different notations to represent non-ASCII characters, <em>ispell</em> must be aware of the representations used by these formatters. These are declared as alternate sets of string characters.</p>
<pre>
<em>alttype</em>	:	<strong>altstringtype</strong> <em>name</em> <em>suffix</em>*
</pre>
<p>The <strong>altstringtype</strong> statement introduces each set by declaring the associated formatter name and filename suffix list. This name and list are interpreted exactly as in the <strong>defstringtype</strong> statement above. Following this header are one or more <em>alt-stmt</em>s which declare the alternate string characters used by this formatter.</p>
<pre>
<em>alt-stmt</em>		:	<strong>altstringchar</strong> <em>alt-string</em> <em>std-string</em>
</pre>
<p>The <em>altstringchar</em> statement describes alternate representations for string characters. For example, the -mm macro package of <em>troff</em> represents the German "a-umlaut" as <em>a&#92;*:</em>, while <em>TeX</em> uses the sequence <em>&#92;"a</em>. If the <em>troff</em> versions are declared as the standard versions using <strong>stringchar</strong>, the <em>TeX</em> versions may be declared as alternates by using the statement</p>
<pre>
altstringchar	&#92;&#92;&#92;"a	a&#92;&#92;*
</pre>
<p>When the <strong>altstringchar</strong> statement is used to specify alternate forms, all forms for a particular formatter must be declared together as a group. Also, each formatter or macro package must provide a complete set of characters, both upper- and lower-case, and the character sequences used for each formatter must be completely distinct. Character sequences which describe upper- and lower-case versions of the same printable character must also be the same length. It may be necessary to define some new macros for a given formatter to satisfy these restrictions. (The current version of <em>buildhash</em> does not enforce these restrictions, but failure to obey them may result in errors being introduced into files that are processed with <em>ispell</em>.)</p><p>An important minor point is that <em>ispell</em> assumes that all characters declared as <strong>wordchars</strong> or <strong>boundarychars</strong> will occupy exactly one position on the terminal screen.</p><p>A single character-set statement can declare either a single character or a contiguous range of characters. A range is given as in egrep and the shell: [a-z] means lowercase alphabetics; [^a-z] means all but lowercase, etc. All character-set statements are combined (unioned) to produce the final list of characters that may be part of a word. The collating order of the characters is defined by the order of their declaration; if a range is used, the characters are considered to have been declared in ASCII order. Characters that have case are collated next to each other, with the uppercase character first.</p><p>The character-declaration statements have a rather strange behavior caused by its need to match each lowercase character with its uppercase equivalent. In any given <strong>wordchars</strong> or <strong>boundarychars</strong> statement, the characters in each range are first sorted into ASCII collating sequence, then matched one-for-one with the other range. (The two ranges must have the same number of characters). Thus, for example, the two statements:</p>
<pre>
<strong>wordchars</strong> [aeiou] [AEIOU]
<strong>wordchars</strong> [aeiou] [UOIEA]
</pre>
<p>would produce exactly the same effect. To get the vowels to match up "wrong", you would have to use separate statements:</p>
<pre>
<strong>wordchars</strong> a U
<strong>wordchars</strong> e O
<strong>wordchars</strong> i I
<strong>wordchars</strong> o E
<strong>wordchars</strong> u A
</pre>
<p>which would cause uppercase 'e' to be 'O', and lowercase 'O' to be 'e'. This should normally be a problem only with languages which have been forced to use a strange ASCII collating sequence. If your uppercase and lowercase letters both collate in the same order, you shouldn't have to worry about this "feature".</p><p>The prefixes and suffixes sections have exactly the same syntax, except for the introductory keyword.</p>
<pre>
<em>prefixes</em>	:	<strong>prefixes</strong><em> flagdef</em>*
<em>suffixes</em>	:	<strong>suffixes</strong><em> flagdef</em>*
<em>flagdef</em>	:	<strong>flag</strong> [<strong>*</strong>|<strong>~</strong>] <em>char</em><strong> : </strong><em>repl</em>*
</pre>
<p>A prefix or suffix table consists of an introductory keyword and a list of flag definitions. Flags can be defined more than once, in which case the definitions are combined. Each flag controls one or more <em>repl</em>s (replacements) which are conditionally applied to the beginnings or endings of various words.</p><p>Flags are named by a single character <em>char</em>. Depending on a configuration option, this character can be either any uppercase letter (the default configuration) or any 7-bit ASCII character. Most languages should be able to get along with just 26 flags.</p><p>A flag character may be prefixed with one or more option characters. (If you wish to use one of the option characters as a flag character, simply enclose it in double quotes.)</p><p>The asterisk (<strong>*</strong>) option means that this flag participates in <em>cross-product</em> formation. This only matters if the file contains both prefix and suffix tables. If so, all prefixes and suffixes marked with an asterisk will be applied in all cross-combinations to the root word. For example, consider the root <em>fix</em> with prefixes <em>pre</em> and <em>in</em>, and suffixes <em>es</em> and <em>ed</em>. If all flags controlling these prefixes and suffixes are marked with an asterisk, then the single root <em>fix</em> would also generate <em>prefix</em>, <em>prefixes</em>, <em>prefixed</em>, <em>infix</em>, <em>infixes</em>, <em>infixed</em>, <em>fix</em>, <em>fixes</em>, and <em>fixed</em>. Cross-product formation can produce a large number of words quickly, some of which may be illegal, so watch out. If cross-products produce illegal words, <em>munchlist</em> will not produce those flag combinations, and the flag will not be useful.</p>
<pre>
<em>repl</em>	:	<em>condition</em>* <strong>&gt;</strong> [ <strong>- </strong><em>strip-string </em><strong>,</strong> ] <em>append-string</em>
</pre>
<p>The <strong>~</strong> option specifies that the associated flag is only active when a compound word is being formed. This is useful in a language like German, where the form of a word sometimes changes inside a compound.</p><p>A <em>repl</em> is a conditional rule for modifying a root word. Up to 8 <em>conditions</em> may be specified. If the <em>conditions</em> are satisfied, the rules on the right-hand side of the <em>repl</em> are applied, as follows:</p>
<dl class='dl-vertical'>
  <dt>
    (1)
  </dt>
  <dd>
    <p>If a strip-string is given, it is first stripped from the beginning or ending (as appropriate) of the root word.</p>
  </dd>
  <dt>
    (2)
  </dt>
  <dd>
    <p>Then the append-string is added at that point.</p>
  </dd>

</dl>
<p>For example, the <em>condition</em> <strong>.</strong> means "any word", and the <em>condition</em> <strong>Y</strong> means "any word ending in Y". The following (suffix) replacements:</p>
<pre>
.	&gt;	MENT
Y	&gt;	-Y,IES
</pre>
<p>would change <em>induce</em> to <em>inducement</em> and <em>fly</em> to <em>flies</em>. (If they were controlled by the same flag, they would also change <em>fly</em> to <em>flyment</em>, which might not be what was wanted. <em>Munchlist</em> can be used to protect against this sort of problem; see the command sequence given below.)</p><p>No matter how much you might wish it, the strings on the right must be strings of specific characters, not ranges. The reasons are rooted deeply in the way <em>ispell</em> works, and it would be difficult or impossible to provide for more flexibility. For example, you might wish to write:</p>
<pre>
[EY]	&gt;	-[EY],IES
</pre>
<p>This will not work. Instead, you must use two separate rules:</p>
<pre>
E	&gt;	-E,IES
Y	&gt;	-Y,IES
</pre>
<p>The application of <em>repl</em>s can be restricted to certain words with <em>conditions</em>:</p>
<pre>
<em>condition</em>	:	{ <strong>.</strong> | <em>character</em> | <em>range</em> }
</pre>
<p>A <em>condition</em> is a restriction on the characters that adjoin, and/or are replaced by, the right-hand side of the <em>repl</em>. Up to 8 <em>conditions</em> may be given, which should be enough context for anyone. The right-hand side will be applied only if the <em>conditions</em> in the <em>repl</em> are satisfied. The <em>conditions</em> also implicitly define a length; roots shorter than the number of <em>conditions</em> will not pass the test. (As a special case, a <em>condition</em> of a single dot "." defines a length of zero, so that the rule applies to all words indiscriminately). This length is independent of the separate test that insists that all flags produce an output word length of at least four.</p><p><em></em> Conditions that are single characters should be separated by white space. For example, to specify words ending in "ED", write:</p>
<pre>
E D	&gt;	-ED,ING		# As in covered &gt; covering
</pre>
<p>If you write:</p>
<pre>
ED	&gt;	-ED,ING
</pre>
<p>the effect will be the same as:</p>
<pre>
[ED]	&gt;	-ED,ING
</pre>
<p>As a final minor, but important point, it is sometimes useful to rebuild a dictionary file using an incompatible suffix file. For example, suppose you expanded the "R" flag to generate "er" and "ers" (thus making the Z flag somewhat obsolete). To build a new dictionary <em>newdict</em> that, using <em>newaffixes</em>, will accept exactly the same list of words as the old list <em>olddict</em> did using <em>oldaffixes</em>, the <strong>-c</strong> switch of <em>munchlist</em> is useful, as in the following example:</p>
<pre>
$ munchlist -c oldaffixes -l newaffixes olddict &gt; newdict
</pre>
<p>If you use this procedure, your new dictionary will always accept the same list the original did, even if you badly screwed up the affix file. This is because <em>munchlist</em> compares the words generated by a flag with the original word list, and refuses to use any flags that generate illegal words. (But don't forget that the <em>munchlist</em> step takes a long time and eats up temporary file space).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>As an example of conditional suffixes, here is the specification of the <strong>S</strong> flag from the English affix file:</p>
<pre>
flag *S:
    [^AEIOU]Y	&gt;	-Y,IES	# As in imply &gt; implies
    [AEIOU]Y	&gt;	S		# As in convey &gt; conveys
    [SXZH]	&gt;	ES		# As in fix &gt; fixes
    [^SXZHY]	&gt;	S		# As in bat &gt; bats
</pre>
<p>The first line applies to words ending in Y, but not in vowel-Y. The second takes care of the vowel-Y words. The third then handles those words that end in a sibilant or near-sibilant, and the last picks up everything else.</p><p>Note that the <em>conditions</em> are written very carefully so that they apply to disjoint sets of words. In particular, note that the fourth line excludes words ending in Y as well as the obvious SXZH. Otherwise, it would convert "imply" into "implys".</p><p>Although the English affix file does not do so, you can also have a flag generate more than one variation on a root word. For example, we could extend the English "R" flag as follows:</p>
<pre>
flag *R:
   E			&gt;	R		# As in skate &gt; skater
   E			&gt;	RS		# As in skate &gt; skaters
   [^AEIOU]Y	&gt;	-Y,IER	# As in multiply &gt; multiplier
   [^AEIOU]Y	&gt;	-Y,IERS	# As in multiply &gt; multipliers
   [AEIOU]Y	&gt;	ER		# As in convey &gt; conveyer
   [AEIOU]Y	&gt;	ERS		# As in convey &gt; conveyers
   [^EY]		&gt;	ER		# As in build &gt; builder
   [^EY]		&gt;	ERS		# As in build &gt; builders
</pre>
<p>This flag would generate both "skater" and "skaters" from "skate". This capability can be very useful in languages that make use of noun, verb, and adjective endings. For instance, one could define a single flag that generated all of the German "weak" verb endings.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO ispell&hellip;</h2>
        <div class="sectioncontent">
<p><strong>ispell</strong>(1)</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="isodump.5.html"><span aria-hidden="true">&larr;</span> isodump.5: Format of ieee 1394 isochronous packets dump file</a></li>
   <li class="next"><a href="issue.5.html">issue.5: Prelogin message and identification file <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

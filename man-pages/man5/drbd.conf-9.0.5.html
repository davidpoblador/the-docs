<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>drbd.conf-9.0: Drbd configuration files.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Drbd configuration files.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="drbd.conf-9.0 (5) manual">
  <meta name="twitter:description" content="Drbd configuration files.">
  <meta name="twitter:image" content="https://www.carta.tech/images/drbd-utils-drbd.conf-9.0-5.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man5/drbd.conf-9.0.5.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="drbd.conf-9.0 (5) manual" />
  <meta property="og:description" content="Drbd configuration files." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/drbd-utils-drbd.conf-9.0-5.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">drbd.conf-9.0<small> (5)</small></h1>
        <p class="lead">Drbd configuration files.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/">
      <span itemprop="name">File formats and conventions</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/drbd.conf-9.0.5.html">
      <span itemprop="name">drbd.conf-9.0: Drbd configuration files.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/drbd-utils/">
      <span itemprop="name">drbd-utils</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/drbd.conf-9.0.5.html">
      <span itemprop="name">drbd.conf-9.0: Drbd configuration files.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">INTRODUCTION</h2>
        <div class="sectioncontent">
<p>DRBD implements block devices which replicate their data to all nodes of a cluster. The actual data and associated metadata are usually stored redundantly on "ordinary" block devices on each cluster node.</p><p>Replicated block devices are called <strong>/dev/drbd</strong><strong></strong><em>minor</em> by default. They are grouped into resources, with one or more devices per resource. Replication among the devices in a resource takes place in chronological order. With DRBD, we refer to the devices inside a resource as <em>volumes</em>.</p><p>In DRBD 9, a resource can be replicated between two or more cluster nodes. The connections between cluster nodes are point-to-point links, and use TCP or a TCP-like protocol. All nodes must be directly connected.</p><p>DRBD consists of low-level user-space components which interact with the kernel and perform basic operations (<strong>drbdsetup</strong>, <strong>drbdmeta</strong>), a high-level user-space component which understands and processes the DRBD configuration and translates it into basic operations of the low-level components (<strong>drbdadm</strong>), and a kernel component.</p><p>The default DRBD configuration consists of <strong>/etc/drbd.conf</strong> and of additional files included from there, usually <strong>global_common.conf</strong> and all <strong></strong><em>*</em><strong>.res</strong> files inside <strong>/etc/drbd.d/</strong>. It has turned out to be useful to define each resource in a separate <strong></strong><em>*</em><strong>.res</strong> file.</p><p>The configuration files are designed so that each cluster node can contain an identical copy of the entire cluster configuration. The host name of each node determines which parts of the configuration apply (<strong>uname -n</strong>). It is highly recommended to keep the cluster configuration on all nodes in sync by manually copying it to all nodes, or by automating the process with <strong>csync2</strong> or a similar tool.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLE CONFIGURATION FILE</h2>
        <div class="sectioncontent">

<pre>
resource r0 {
      net {
	      cram-hmac-alg sha1;
	      shared-secret "FooFunFactory";
      }
      volume 0 {
	      device    /dev/drbd1;
	      disk      /dev/sda7;
	      meta-disk internal;
      }
      on alice {
	      node-id   0;
	      address   10.1.1.31:7000;
      }
      on bob {
	      node-id   1;
	      address   10.1.1.32:7000;
      }
      connection {
	      host      alice  port 7000;
	      host      bob    port 7000;
	      net {
			protocol C;
	      }
      }
}
</pre>
<p>This example defines a resource <strong>r0</strong> which contains a single replicated device with volume number 0. The resource is replicated among hosts <strong>alice</strong> and <strong>bob</strong>, which have the IPv4 addresses <strong>10.1.1.31</strong> and <strong>10.1.1.32</strong> and the node identifiers 0 and 1, respectively. On both hosts, the replicated device is called <strong>/dev/drbd1</strong>, and the actual data and metadata are stored on the lower-level device <strong>/dev/sda7</strong>. The connection between the hosts uses protocol C.</p><p>Please refer to the \m[blue]<strong>DRBD User&apos;s Guide</strong>\m[]\s-2\u[1]\d\s+2 for more examples.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILE FORMAT</h2>
        <div class="sectioncontent">
<p>DRBD configuration files consist of sections, which contain other sections and parameters depending on the section types. Each section consists of one or more keywords, sometimes a section name, an opening brace (&ldquo;{&rdquo;), the section&apos;s contents, and a closing brace (&ldquo;}&rdquo;). Parameters inside a section consist of a keyword, followed by one or more keywords or values, and a semicolon (&ldquo;;&rdquo;).</p><p>Some parameter values have a default scale which applies when a plain number is specified (for example Kilo, or 1024 times the numeric value). Such default scales can be overridden by using a suffix (for example, <strong>M</strong> for Mega). The common suffixes <strong>K</strong> = 2^10 = 1024, <strong>M</strong> = 1024 K, and <strong>G</strong> = 1024 M are supported.</p><p>Comments start with a hash sign (&ldquo;#&rdquo;) and extend to the end of the line. In addition, any section can be prefixed with the keyword <strong>skip</strong>, which causes the section and any sub-sections to be ignored.</p><p>Additional files can be included with the <strong>include </strong><strong></strong><em>file-pattern</em> statement (see <a href="../man7/glob.7.html"><strong>glob</strong>(7)</a> for the expressions supported in <em>file-pattern</em>). Include statements are only allowed outside of sections.</p><p>The following sections are defined (indentation indicates in which context):</p>
<pre>
common
   [disk]
   [handlers]
   [net]
   [options]
   [startup]
global
resource
   connection
      net
   connection-mesh
      net
   [disk]
   floating
   handlers
   [net]
   on
      [disk]
      volume
         disk
   options
   stacked-on-top-of
   startup
</pre>
<p>Sections in brackets affect other parts of the configuration: inside the <strong>common</strong> section, they apply to all resources. A <strong>disk</strong> section inside a <strong>resource</strong> or <strong>on</strong> section applies to all volumes of that resource, and a <strong>net</strong> section inside a <strong>resource</strong> section applies to all connections of that resource. This allows to avoid repeating identical options for each resource, connection, or volume. Options can be overridden in a more specific <strong>resource</strong>, <strong>connection</strong>, <strong>on</strong>, or <strong>volume</strong> section.</p><h3>Sections</h3>
<p><strong>common</strong></p><p>This section can contain each a <strong>disk</strong>, <strong>handlers</strong>, <strong>net</strong>, <strong>options</strong>, and <strong>startup</strong> section. All resources inherit the parameters in these sections as their default values.</p><p><strong>connection </strong><strong></strong><em>[name]</em></p><p>Define a connection between two hosts. This section must contain two <strong>host</strong> parameters. The optional <em>name</em> is used to refer to the connection in the system log and in other messages. If no name is specified, the peer&apos;s host name is used instead.</p><p><strong>connection-mesh</strong></p><p>Define a connection mesh between multiple hosts. This section must contain a <strong>hosts</strong> parameter, which has the host names as arguments. This section is a shortcut to define many connections which share the same network options.</p><p><strong>disk</strong></p><p>Define parameters for a volume. All parameters in this section are optional.</p><p><strong>floating </strong><strong></strong><em>[address-family]</em><strong> </strong><strong></strong><em>addr</em><strong>:</strong><strong></strong><em>port</em></p><p>Like the <strong>on</strong> section, except that instead of the host name a network address is used to determine if it matches a <strong>floating</strong> section.</p><p>The <strong>node-id</strong> parameter in this section is required. If the <strong>address</strong> parameter is not provided, no connections to peers will be created by default. The <strong>device</strong>, <strong>disk</strong>, and <strong>meta-disk</strong> parameters must be defined in, or inherited by, this section.</p><p><strong>global</strong></p><p>Define some global parameters. All parameters in this section are optional. Only one <strong>global</strong> section is allowed in the configuration.</p><p><strong>handlers</strong></p><p>Define handlers to be invoked when certain events occur. The kernel passes the resource name in the first command-line argument and sets the following environment variables depending on the event&apos;s context:</p><p>For events related to a particular device: the device&apos;s minor number in <strong>DRBD_MINOR</strong>, the device&apos;s volume number in <strong>DRBD_VOLUME</strong>.</p><p>For events related to a particular device on a particular peer: the connection endpoints in <strong>DRBD_MY_ADDRESS</strong>, <strong>DRBD_MY_AF</strong>, <strong>DRBD_PEER_ADDRESS</strong>, and <strong>DRBD_PEER_AF</strong>; the device&apos;s local minor number in <strong>DRBD_MINOR</strong>, and the device&apos;s volume number in <strong>DRBD_VOLUME</strong>.</p><p>For events related to a particular connection: the connection endpoints in <strong>DRBD_MY_ADDRESS</strong>, <strong>DRBD_MY_AF</strong>, <strong>DRBD_PEER_ADDRESS</strong>, and <strong>DRBD_PEER_AF</strong>; and, for each device defined for that connection: the device&apos;s minor number in <strong>DRBD_MINOR_</strong><strong></strong><em>volume-number</em>.</p><p>For events that identify a device, if a lower-level device is attached, the lower-level device&apos;s device name is passed in <strong>DRBD_BACKING_DEV</strong> (or <strong>DRBD_BACKING_DEV_</strong><strong></strong><em>volume-number</em>).</p><p>All parameters in this section are optional. Only a single handler can be defined for each event; if no handler is defined, nothing will happen.</p><p><strong>net</strong></p><p>Define parameters for a connection. All parameters in this section are optional.</p><p><strong>on</strong> <strong></strong><em>host-name</em> <em>[...]</em></p><p>Define the properties of a resource on a particular host or set of hosts. Specifying more than one host name can make sense in a setup with IP address failover, for example. The <em>host-name</em> argument must match the Linux host name (<strong>uname -n</strong>).</p><p>Usually contains or inherits at least one <strong>volume</strong> section. The <strong>node-id</strong> and <strong>address</strong> parameters must be defined in this section. The <strong>device</strong>, <strong>disk</strong>, and <strong>meta-disk</strong> parameters must be defined in, or inherited by, this section.</p><p>A normal configuration file contains two or more <strong>on</strong> sections for each resource. Also see the <strong>floating</strong> section.</p><p><strong>options</strong></p><p>Define parameters for a resource. All parameters in this section are optional.</p><p><strong>resource</strong> <strong></strong><em>name</em></p><p>Define a resource. Usually contains at least two <strong>on</strong> sections and at least one <strong>connection</strong> section.</p><p><strong>stacked-on-top-of </strong><strong></strong><em>resource</em></p><p>Used instead of an <strong>on</strong> section for configuring a stacked resource with three to four nodes.</p><p>Starting with DRBD 9, stacking is deprecated. It is advised to use resources which are replicated among more than two nodes instead.</p><p><strong>startup</strong></p><p>The parameters in this section determine the behavior of a resource at startup time.</p><p><strong>volume</strong> <strong></strong><em>volume-number</em></p><p>Define a volume within a resource. The volume numbers in the various <strong>volume</strong> sections of a resource define which devices on which hosts form a replicated device.</p>
<h3>Section connection Parameters</h3>
<p><strong>host </strong><strong></strong><em>name</em> [<strong>address </strong><strong>[address-family]</strong><strong> </strong><strong></strong><em>address</em>] [<strong>port </strong><strong></strong><em>port-number</em>]</p><p>Defines an endpoint for a connection. Each <strong>host</strong> statement refers to an <strong>on</strong> section in a resource. If a port number is defined, this endpoint will use the specified port instead of the port defined in the <strong>on</strong> section. Each <strong>connection</strong> section must contain exactly two <strong>host</strong> parameters.</p>
<h3>Section connection-mesh Parameters</h3>
<p><strong>hosts </strong><strong></strong><em>name</em>...</p><p>Defines all nodes of a mesh. Each <strong></strong><em>name</em> refers to an <strong>on</strong> section in a resource. The port that is defined in the <strong>on</strong> section will be used.</p>
<h3>Section disk Parameters</h3>
<p><strong>al-extents </strong><strong></strong><em>extents</em></p><p>DRBD automatically maintains a "hot" or "active" disk area likely to be written to again soon based on the recent write activity. The "active" disk area can be written to immediately, while "inactive" disk areas must be "activated" first, which requires a meta-data write. We also refer to this active disk area as the "activity log".</p><p>The activity log saves meta-data writes, but the whole log must be resynced upon recovery of a failed node. The size of the activity log is a major factor of how long a resync will take and how fast a replicated disk will become consistent after a crash.</p><p>The activity log consists of a number of 4-Megabyte segments; the <em>al-extents</em> parameter determines how many of those segments can be active at the same time. The default value for <em>al-extents</em> is 1237, with a minimum of 7 and a maximum of 65536.</p><p>Note that the effective maximum may be smaller, depending on how you created the device meta data, see also <a href="../man8/drbdmeta.8.html"><strong>drbdmeta</strong>(8)</a> The effective maximum is 919 * (available on-disk activity-log ring-buffer area/4kB -1), the default 32kB ring-buffer effects a maximum of 6433 (covers more than 25 GiB of data) We recommend to keep this well within the amount your backend storage and replication link are able to resync inside of about 5 minutes.</p><p><strong>al-updates </strong><strong>{yes | no}</strong><strong> </strong></p><p>With this parameter, the activity log can be turned off entirely (see the <strong>al-extents</strong> parameter). This will speed up writes because fewer meta-data writes will be necessary, but the entire device needs to be resynchronized opon recovery of a failed primary node. The default value for <strong>al-updates</strong> is <strong>yes</strong>.</p><p><strong>c-delay-target </strong><strong></strong><em>delay_target</em>,</p><p><strong>c-fill-target </strong><strong></strong><em>fill_target</em>,</p><p><strong>c-max-rate </strong><strong></strong><em>max_rate</em>,</p><p><strong>c-plan-ahead </strong><strong></strong><em>plan_time</em></p><p>Dynamically control the resync speed. This mechanism is enabled by setting the <strong>c-plan-ahead</strong> parameter to a positive value. The goal is to either fill the buffers along the data path with a defined amount of data if <strong>c-fill-target</strong> is defined, or to have a defined delay along the path if <strong>c-delay-target</strong> is defined. The maximum bandwidth is limited by the <strong>c-max-rate</strong> parameter.</p><p>The <strong>c-plan-ahead</strong> parameter defines how fast drbd adapts to changes in the resync speed. It should be set to five times the network round-trip time or more. Common values for <strong>c-fill-target</strong> for "normal" data paths range from 4K to 100K. If drbd-proxy is used, it is advised to use <strong>c-delay-target</strong> instead of <strong>c-fill-target</strong>. The <strong>c-delay-target</strong> parameter is used if the <strong>c-fill-target</strong> parameter is undefined or set to 0. The <strong>c-delay-target</strong> parameter should be set to five times the network round-trip time or more. The <strong>c-max-rate</strong> option should be set to either the bandwidth available between the DRBD-hosts and the machines hosting DRBD-proxy, or to the available disk bandwidth.</p><p>The default values of these parameters are: <strong>c-plan-ahead</strong> = 20 (in units of 0.1 seconds), <strong>c-fill-target</strong> = 0 (in units of sectors), <strong>c-delay-target</strong> = 1 (in units of 0.1 seconds), and <strong>c-max-rate</strong> = 102400 (in units of KiB/s).</p><p>Dynamic resync speed control is available since DRBD 8.3.9.</p><p><strong>c-min-rate </strong><strong></strong><em>min_rate</em></p><p>A node which is primary and sync-source has to schedule application I/O requests and resync I/O requests. The <strong>c-min-rate</strong> parameter limits how much bandwidth is available for resync I/O; the remaining bandwidth is used for application I/O.</p><p>A <strong>c-min-rate</strong> value of 0 means that there is no limit on the resync I/O bandwidth. This can slow down application I/O significantly. Use a value of 1 (1 KiB/s) for the lowest possible resync rate.</p><p>The default value of <strong>c-min-rate</strong> is 4096, in units of KiB/s.</p><p><strong>disk-barrier</strong>,</p><p><strong>disk-flushes</strong>,</p><p><strong>disk-drain</strong></p><p>DRBD has three methods of handling the ordering of dependent write requests:</p><p><strong>disk-barrier</strong></p><p>Use disk barriers to make sure that requests are written to disk in the right order. Barriers ensure that all requests submitted before a barrier make it to the disk before any requests submitted after the barrier. This is implemented using &apos;tagged command queuing&apos; on SCSI devices and &apos;native command queuing&apos; on SATA devices. Only some devices and device stacks support this method. The device mapper (LVM) only supports barriers in some configurations.</p><p>Note that on systems which do not support disk barriers, enabling this option can lead to data loss or corruption. Until DRBD 8.4.1, <strong>disk-barrier</strong> was turned on if the I/O stack below DRBD did support barriers. Kernels since linux-2.6.36 (or 2.6.32 RHEL6) no longer allow to detect if barriers are supported. Since drbd-8.4.2, this option is off by default and needs to be enabled explicitly.</p><p><strong>disk-flushes</strong></p><p>Use disk flushes between dependent write requests, also referred to as &apos;force unit access&apos; by drive vendors. This forces all data to disk. This option is enabled by default.</p><p><strong>disk-drain</strong></p><p>Wait for the request queue to "drain" (that is, wait for the requests to finish) before submitting a dependent write request. This method requires that requests are stable on disk when they finish. Before DRBD 8.0.9, this was the only method implemented. This option is enabled by default. Do not disable in production environments.</p><p>From these three methods, drbd will use the first that is enabled and supported by the backing storage device. If all three of these options are turned off, DRBD will submit write requests without bothering about dependencies. Depending on the I/O stack, write requests can be reordered, and they can be submitted in a different order on different cluster nodes. This can result in data loss or corruption. Therefore, turning off all three methods of controlling write ordering is strongly discouraged.</p><p>A general guideline for configuring write ordering is to use disk barriers or disk flushes when using ordinary disks (or an ordinary disk array) with a volatile write cache. On storage without cache or with a battery backed write cache, disk draining can be a reasonable choice.</p><p><strong>disk-timeout</strong></p><p>If the lower-level device on which a DRBD device stores its data does not finish an I/O request within the defined <strong>disk-timeout</strong>, DRBD treats this as a failure. The lower-level device is detached, and the device&apos;s disk state advances to Diskless. If DRBD is connected to one or more peers, the failed request is passed on to one of them.</p><p>This option is <em>dangerous and may lead to kernel panic!</em></p><p>"Aborting" requests, or force-detaching the disk, is intended for completely blocked/hung local backing devices which do no longer complete requests at all, not even do error completions. In this situation, usually a hard-reset and failover is the only way out.</p><p>By "aborting", basically faking a local error-completion, we allow for a more graceful swichover by cleanly migrating services. Still the affected node has to be rebooted "soon".</p><p>By completing these requests, we allow the upper layers to re-use the associated data pages.</p><p>If later the local backing device "recovers", and now DMAs some data from disk into the original request pages, in the best case it will just put random data into unused pages; but typically it will corrupt meanwhile completely unrelated data, causing all sorts of damage.</p><p>Which means delayed successful completion, especially for READ requests, is a reason to panic(). We assume that a delayed *error* completion is OK, though we still will complain noisily about it.</p><p>The default value of <strong>disk-timeout</strong> is 0, which stands for an infinite timeout. Timeouts are specified in units of 0.1 seconds. This option is available since DRBD 8.3.12.</p><p><strong>fencing </strong><strong></strong><em>fencing_policy</em></p><p>is a preventive measure to avoid situations where both nodes are primary and disconnected. This is also known as a split-brain situation. DRBD supports the following fencing policies:</p><p><strong>dont-care</strong></p><p>No fencing actions are taken. This is the default policy.</p><p><strong>resource-only</strong></p><p>If a node becomes a disconnected primary, it tries to fence the peer. This is done by calling the <strong>fence-peer</strong> handler. The handler is supposed to reach the peer over an alternative communication path and call &apos;<strong>drbdadm outdate minor</strong>&apos; there.</p><p><strong>resource-and-stonith</strong></p><p>If a node becomes a disconnected primary, it freezes all its IO operations and calls its fence-peer handler. The fence-peer handler is supposed to reach the peer over an alternative communication path and call &apos;<strong>drbdadm outdate minor</strong>&apos; there. In case it cannot do that, it should stonith the peer. IO is resumed as soon as the situation is resolved. In case the fence-peer handler fails, I/O can be resumed manually with &apos;<strong>drbdadm resume-io</strong>&apos;.</p><p><strong>md-flushes</strong></p><p>Enable disk flushes and disk barriers on the meta-data device. This option is enabled by default. See the <strong>disk-flushes</strong> parameter.</p><p><strong>on-io-error </strong><strong></strong><em>handler</em></p><p>Configure how DRBD reacts to I/O errors on a lower-level device. The following policies are defined:</p><p><strong>pass_on</strong></p><p>Change the disk status to Inconsistent, mark the failed block as inconsistent in the bitmap, and retry the I/O operation on a remote cluster node.</p><p><strong>call-local-io-error</strong></p><p>Call the <strong>local-io-error</strong> handler (see the <strong>handlers</strong> section).</p><p><strong>detach</strong></p><p>Detach the lower-level device and continue in diskless mode.</p><p><strong>read-balancing </strong><strong></strong><em>policy</em></p><p>Distribute read requests among cluster nodes as defined by <em>policy</em>. The supported policies are <strong>prefer-local</strong> (the default), <strong>prefer-remote</strong>, <strong>round-robin</strong>, <strong>least-pending</strong>, <strong>when-congested-remote</strong>, <strong>32K-striping</strong>, <strong>64K-striping</strong>, <strong>128K-striping</strong>, <strong>256K-striping</strong>, <strong>512K-striping</strong> and <strong>1M-striping</strong>.</p><p>This option is available since DRBD 8.4.1.</p><p><strong>resync-after </strong><strong></strong><em>res-name</em><strong>/</strong><strong></strong><em>volume</em></p><p>Define that a device should only resynchronize after the specified other device. By default, no order between devices is defined, and all devices will resynchronize in parallel. Depending on the configuration of the lower-level devices, and the available network and disk bandwidth, this can slow down the overall resync process. This option can be used to form a chain or tree of dependencies among devices.</p><p><strong>resync-rate </strong><strong></strong><em>rate</em></p><p>Define how much bandwidth DRBD may use for resynchronizing. DRBD allows "normal" application I/O even during a resync. If the resync takes up too much bandwidth, application I/O can become very slow. This parameter allows to avoid that. Please note this is option only works when the dynamic resync controller is disabled.</p>
<h3>Section global Parameters</h3>
<p><strong>dialog-refresh </strong><strong></strong><em>time</em></p><p>The DRBD init script can be used to configure and start DRBD devices, which can involve waiting for other cluster nodes. While waiting, the init script shows the remaining waiting time. The <strong>dialog-refresh</strong> defines the number of seconds between updates of that countdown. The default value is 1; a value of 0 turns off the countdown.</p><p><strong>disable-ip-verification</strong></p><p>Normally, DRBD verifies that the IP addresses in the configuration match the host names. Use the <strong>disable-ip-verification</strong> parameter to disable these checks.</p><p><strong>usage-count </strong><strong>{yes | no | ask}</strong><strong> </strong></p><p>A explained on DRBD&apos;s \m[blue]<strong>Online Usage Counter</strong>\m[]\s-2\u[2]\d\s+2 web page, DRBD includes a mechanism for anonymously counting how many installations are using which versions of DRBD. The results are available on the web page for anyone to see.</p><p>This parameter defines if a cluster node participates in the usage counter; the supported values are <strong>yes</strong>, <strong>no</strong>, and <strong>ask</strong> (ask the user, the default).</p><p>We would like to ask users to participate in the online usage counter as this provides us valuable feedback for steering the development of DRBD.</p>
<h3>Section handlers Parameters</h3>
<p><strong>after-resync-target </strong><strong></strong><em>cmd</em></p><p>Called on a resync target when a node state changes from <strong>Inconsistent</strong> to <strong>Consistent</strong> when a resync finishes. This handler can be used for removing the snapshot created in the <strong>before-resync-target</strong> handler.</p><p><strong>before-resync-target </strong><strong></strong><em>cmd</em></p><p>Called on a resync target before a resync begins. This handler can be used for creating a snapshot of the lower-level device for the duration of the resync: if the resync source becomes unavailable during a resync, reverting to the snapshot can restore a consistent state.</p><p><strong>fence-peer </strong><strong></strong><em>cmd</em></p><p>Called when a node should fence a resource on a particular peer. The handler should not use the same communication path that DRBD uses for talking to the peer.</p><p><strong>initial-split-brain </strong><strong></strong><em>cmd</em></p><p>Called when DRBD connects to a peer and detects that the peer is in a split-brain state with the local node. This handler is also called for split-brain scenarios which will be resolved automatically.</p><p><strong>local-io-error </strong><strong></strong><em>cmd</em></p><p>Called when an I/O error occurs on a lower-level device.</p><p><strong>pri-lost </strong><strong></strong><em>cmd</em></p><p>The local node is currently primary, but DRBD believes that it should become a sync target. The node should give up its primary role.</p><p><strong>pri-lost-after-sb </strong><strong></strong><em>cmd</em></p><p>The local node is currently primary, but it has lost the after-split-brain auto recovery procedure. The node should be abandoned.</p><p><strong>pri-on-incon-degr </strong><strong></strong><em>cmd</em></p><p>The local node is primary, and neither the local lower-level device nor a lower-level device on a peer is up to date. (The primary has no device to read from or to write to.)</p><p><strong>split-brain </strong><strong></strong><em>cmd</em></p><p>DRBD has detected a split-brain situation which could not be resolved automatically. Manual recovery is necessary. This handler can be used to call for administrator attention.</p>
<h3>Section net Parameters</h3>
<p><strong>after-sb-0pri </strong><strong></strong><em>policy</em></p><p>Define how to react if a split-brain scenario is detected and none of the two nodes is in primary role. (We detect split-brain scenarios when two nodes connect; split-brain decisions are always between two nodes.) The defined policies are:</p><p><strong>disconnect</strong></p><p>No automatic resynchronization; simply disconnect.</p><p><strong>discard-younger-primary</strong>,</p><p><strong>discard-older-primary</strong></p><p>Resynchronize from the node which became primary first (<strong>discard-younger-primary</strong>) or last (<strong>discard-older-primary</strong>). If both nodes became primary independently, the <strong>discard-least-changes</strong> policy is used.</p><p><strong>discard-zero-changes</strong></p><p>If only one of the nodes wrote data since the split brain situation was detected, resynchronize from this node to the other. If both nodes wrote data, disconnect.</p><p><strong>discard-least-changes</strong></p><p>Resynchronize from the node with more modified blocks.</p><p><strong>discard-node-</strong><strong></strong><em>nodename</em></p><p>Always resynchronize to the named node.</p><p><strong>after-sb-1pri </strong><strong></strong><em>policy</em></p><p>Define how to react if a split-brain scenario is detected, with one node in primary role and one node in secondary role. (We detect split-brain scenarios when two nodes connect, so split-brain decisions are always among two nodes.) The defined policies are:</p><p><strong>disconnect</strong></p><p>No automatic resynchronization, simply disconnect.</p><p><strong>consensus</strong></p><p>Discard the data on the secondary node if the <strong>after-sb-0pri</strong> algorithm would also discard the data on the secondary node. Otherwise, disconnect.</p><p><strong>violently-as0p</strong></p><p>Always take the decision of the <strong>after-sb-0pri</strong> algorithm, even if it causes an erratic change of the primary&apos;s view of the data. This is only useful if a single-node file system (i.e., not OCFS2 or GFS) with the <strong>allow-two-primaries</strong> flag is used. This option can cause the primary node to crash, and should not be used.</p><p><strong>discard-secondary</strong></p><p>Discard the data on the secondary node.</p><p><strong>call-pri-lost-after-sb</strong></p><p>Always take the decision of the <strong>after-sb-0pri</strong> algorithm. If the decision is to discard the data on the primary node, call the <strong>pri-lost-after-sb</strong> handler on the primary node.</p><p><strong>after-sb-2pri </strong><strong></strong><em>policy</em></p><p>Define how to react if a split-brain scenario is detected and both nodes are in primary role. (We detect split-brain scenarios when two nodes connect, so split-brain decisions are always among two nodes.) The defined policies are:</p><p><strong>disconnect</strong></p><p>No automatic resynchronization, simply disconnect.</p><p><strong>violently-as0p</strong></p><p>See the <strong>violently-as0p</strong> policy for <strong>after-sb-1pri</strong>.</p><p><strong>call-pri-lost-after-sb</strong></p><p>Call the <strong>pri-lost-after-sb</strong> handler on one of the machines. The handler is expected to reboot the machine, which brings the node into secondary role.</p><p><strong>allow-two-primaries</strong></p><p>The most common way to configure DRBD devices is to allow only one node to be primary (and thus writable) at a time.</p><p>In some scenarios it is preferable to allow two nodes to be primary at once; a mechanism outside of DRBD then must make sure that writes to the shared, replicated device happen in a coordinated way. This can be done with a shared-storage cluster file system like OCFS2 and GFS, or with virtual machine images and a virtual machine manager that can migrate virtual machines between physical machines.</p><p>The <strong>allow-two-primaries</strong> parameter tells DRBD to allow two nodes to be primary at the same time. Never enable this option when using a non-distributed file system; otherwise, data corruption and node crashes will result!</p><p><strong>always-asbp</strong></p><p>Normally the automatic after-split-brain policies are only used if current states of the UUIDs do not indicate the presence of a third node.</p><p>With this option you request that the automatic after-split-brain policies are used as long as the data sets of the nodes are somehow related. This might cause a full sync, if the UUIDs indicate the presence of a third node. (Or double faults led to strange UUID sets.)</p><p><strong>connect-int </strong><strong></strong><em>time</em></p><p>As soon as a connection between two nodes is configured with <strong>drbdsetup connect</strong>, DRBD immediately tries to establish the connection. If this fails, DRBD waits for <strong>connect-int</strong> seconds and then repeats. The default value of <strong>connect-int</strong> is 10 seconds.</p><p><strong>cram-hmac-alg </strong><strong></strong><em>hash-algorithm</em></p><p>Configure the hash-based message authentication code (HMAC) or secure hash algorithm to use for peer authentication. The kernel supports a number of different algorithms, some of which may be loadable as kernel modules. See the shash algorithms listed in /proc/crypto. By default, <strong>cram-hmac-alg</strong> is unset. Peer authentication also requires a <strong>shared-secret</strong> to be configured.</p><p><strong>csums-alg </strong><strong></strong><em>hash-algorithm</em></p><p>Normally, when two nodes resynchronize, the sync target requests a piece of out-of-sync data from the sync source, and the sync source sends the data. With many usage patterns, a significant number of those blocks will actually be identical.</p><p>When a <strong>csums-alg</strong> algorithm is specified, when requesting a piece of out-of-sync data, the sync target also sends along a hash of the data it currently has. The sync source compares this hash with its own version of the data. It sends the sync target the new data if the hashes differ, and tells it that the data are the same otherwise. This reduces the network bandwidth required, at the cost of higher cpu utilization and possibly increased I/O on the sync target.</p><p>The <strong>csums-alg</strong> can be set to one of the secure hash algorithms supported by the kernel; see the shash algorithms listed in /proc/crypto. By default, <strong>csums-alg</strong> is unset.</p><p><strong>csums-after-crash-only</strong></p><p>Enabling this option (and csums-alg, above) makes it possible to use the checksum based resync only for the first resync after primary crash, but not for later "network hickups".</p><p>In most cases, block that are marked as need-to-be-resynced are in fact changed, so calculating checksums, and both reading and writing the blocks on the resync target is all effective overhead.</p><p>The advantage of checksum based resync is mostly after primary crash recovery, where the recovery marked larger areas (those covered by the activity log) as need-to-be-resynced, just in case. Introduced in 8.4.5.</p><p><strong>data-integrity-alg </strong> <em>alg</em></p><p>DRBD normally relies on the data integrity checks built into the TCP/IP protocol, but if a data integrity algorithm is configured, it will additionally use this algorithm to make sure that the data received over the network match what the sender has sent. If a data integrity error is detected, DRBD will close the network connection and reconnect, which will trigger a resync.</p><p>The <strong>data-integrity-alg</strong> can be set to one of the secure hash algorithms supported by the kernel; see the shash algorithms listed in /proc/crypto. By default, this mechanism is turned off.</p><p>Because of the CPU overhead involved, we recommend not to use this option in production environments. Also see the notes on data integrity below.</p><p><strong>ko-count </strong><strong></strong><em>number</em></p><p>If a secondary node fails to complete a write request in <strong>ko-count</strong> times the <strong>timeout</strong> parameter, it is excluded from the cluster. The primary node then sets the connection to this secondary node to Standalone. The default value of <strong>ko-count</strong> is 0, which disables this feature.</p><p><strong>max-buffers </strong><strong></strong><em>number</em></p><p>Limits the memory usage per DRBD minor device on the receiving side, or for internal buffers during resync or online-verify. Unit is PAGE_SIZE, which is 4 KiB on most systems. The minimum possible setting is hard coded to 32 (=128 KiB). These buffers are used to hold data blocks while they are written to/read from disk. To avoid possible distributed deadlocks on congestion, this setting is used as a throttle threshold rather than a hard limit. Once more than max-buffers pages are in use, further allocation from this pool is throttled. You want to increase max-buffers if you cannot saturate the IO backend on the receiving side.</p><p><strong>max-epoch-size </strong><strong></strong><em>number</em></p><p>Define the maximum number of write requests DRBD may issue before issuing a write barrier. The default value is 2048, with a minimum of 1 and a maximum of 20000. Setting this parameter to a value below 10 is likely to decrease performance.</p><p><strong>on-congestion </strong><strong></strong><em>policy</em>,</p><p><strong>congestion-fill </strong><strong></strong><em>threshold</em>,</p><p><strong>congestion-extents </strong><strong></strong><em>threshold</em></p><p>By default, DRBD blocks when the TCP send queue is full. This prevents applications from generating further write requests until more buffer space becomes available again.</p><p>When DRBD is used together with DRBD-proxy, it can be better to use the <strong>pull-ahead</strong><strong>on-congestion</strong> policy, which can switch DRBD into ahead/behind mode before the send queue is full. DRBD then records the differences between itself and the peer in its bitmap, but it no longer replicates them to the peer. When enough buffer space becomes available again, the node resynchronizes with the peer and switches back to normal replication.</p><p>This has the advantage of not blocking application I/O even when the queues fill up, and the disadvantage that peer nodes can fall behind much further. Also, while resynchronizing, peer nodes will become inconsistent.</p><p>The available congestion policies are <strong>block</strong> (the default) and <strong>pull-ahead</strong>. The <strong>congestion-fill</strong> parameter defines how much data is allowed to be "in flight" in this connection. The default value is 0, which disables this mechanism of congestion control, with a maximum of 10 GiBytes. The <strong>congestion-extents</strong> parameter defines how many bitmap extents may be active before switching into ahead/behind mode, with the same default and limits as the <strong>al-extents</strong> parameter. The <strong>congestion-extents</strong> parameter is effective only when set to a value smaller than <strong>al-extents</strong>.</p><p>Ahead/behind mode is available since DRBD 8.3.10.</p><p><strong>ping-int </strong><strong></strong><em>interval</em></p><p>When the TCP/IP connection to a peer is idle for more than <strong>ping-int</strong> seconds, DRBD will send a keep-alive packet to make sure that a failed peer or network connection is detected reasonably soon. The default value is 10 seconds, with a minimum of 1 and a maximum of 120 seconds. The unit is seconds.</p><p><strong>ping-timeout </strong><strong></strong><em>timeout</em></p><p>Define the timeout for replies to keep-alive packets. If the peer does not reply within <strong>ping-timeout</strong>, DRBD will close and try to reestablish the connection. The default value is 0.5 seconds, with a minimum of 0.1 seconds and a maximum of 3 seconds. The unit is tenths of a second.</p><p><strong>socket-check-timeout </strong><strong></strong><em>timeout</em></p><p><strong>ping-timeout</strong> to an unusual high value. By default DRBD uses the same value to wait if a newly established TCP-connection is stable. Since the DRBD-proxy is usually located in the same data center such a long wait time may hinder DRBD&apos;s connect process.</p><p>In such setups <strong>socket-check-timeout</strong> should be set to at least to the round trip time between DRBD and DRBD-proxy. I.e. in most cases to 1.</p><p>The default unit is tenths of a second, the default value is 0 (which causes DRBD to use the value of <strong>ping-timeout</strong> instead). Introduced in 8.4.5.</p><p><strong>protocol </strong><strong></strong><em>name</em></p><p>Use the specified protocol on this connection. The supported protocols are:</p><p><strong>A</strong></p><p>Writes to the DRBD device complete as soon as they have reached the local disk and the TCP/IP send buffer.</p><p><strong>B</strong></p><p>Writes to the DRBD device complete as soon as they have reached the local disk, and all peers have acknowledged the receipt of the write requests.</p><p><strong>C</strong></p><p>Writes to the DRBD device complete as soon as they have reached the local and all remote disks.</p><p><strong>rcvbuf-size </strong><strong></strong><em>size</em></p><p>Configure the size of the TCP/IP receive buffer. A value of 0 (the default) causes the buffer size to adjust dynamically. This parameter usually does not need to be set, but it can be set to a value up to 10 MiB. The default unit is bytes.</p><p><strong>rr-conflict</strong> <em>policy</em></p><p>This option helps to solve the cases when the outcome of the resync decision is incompatible with the current role assignment in the cluster. The defined policies are:</p><p><strong>disconnect</strong></p><p>No automatic resynchronization, simply disconnect.</p><p><strong>violently</strong></p><p>Resync to the primary node is allowed, violating the assumption that data on a block device are stable for one of the nodes. <em>Do not use this option, it is dangerous.</em></p><p><strong>call-pri-lost</strong></p><p>Call the <strong>pri-lost</strong> handler on one of the machines. The handler is expected to reboot the machine, which puts it into secondary role.</p><p><strong>shared-secret </strong><strong></strong><em>secret</em></p><p>Configure the shared secret used for peer authentication. The secret is a string of up to 64 characters. Peer authentication also requires the <strong>cram-hmac-alg</strong> parameter to be set.</p><p><strong>sndbuf-size </strong><strong></strong><em>size</em></p><p>Configure the size of the TCP/IP send buffer. Since DRBD 8.0.13 / 8.2.7, a value of 0 (the default) causes the buffer size to adjust dynamically. Values below 32 KiB are harmful to the throughput on this connection. Large buffer sizes can be useful especially when protocol A is used over high-latency networks; the maximum value supported is 10 MiB.</p><p><strong>tcp-cork</strong></p><p>By default, DRBD uses the TCP_CORK socket option to prevent the kernel from sending partial messages; this results in fewer and bigger packets on the network. Some network stacks can perform worse with this optimization. On these, the <strong>tcp-cork</strong> parameter can be used to turn this optimization off.</p><p><strong>timeout </strong><strong></strong><em>time</em></p><p>Define the timeout for replies over the network: if a peer node does not send an expected reply within the specified <strong>timeout</strong>, it is considered dead and the TCP/IP connection is closed. The timeout value must be lower than <strong>connect-int</strong> and lower than <strong>ping-int</strong>. The default is 6 seconds; the value is specified in tenths of a second.</p><p><strong>unplug-watermark </strong><strong></strong><em>number</em></p><p>Mainline kernels before version 2.6.39-rc1 use an explicit plug / unplug mechanism to control when a block device starts processing queued requests. On those kernels, the <strong>unplug-watermark</strong> parameter defines how many requests must be queued until a secondary node starts processing them. Some storage controllers perform best when <strong>unplug-watermark</strong> is set to the same value as <strong>max-buffers</strong>; others are more efficient with smaller values. The default value for <strong>unplug-watermark</strong> is 128, with a minimum of 16 and a maximum of 131072.</p><p>More recent kernels handle plugging and unplugging implicitly; on those kernels, this parameter has no effect. Note that some distributions have backported this feature to older kernel versions.</p><p><strong>use-rle</strong></p><p>Each replicated device on a cluster node has a separate bitmap for each of its peer devices. The bitmaps are used for tracking the differences between the local and peer device: depending on the cluster state, a disk range can be marked as different from the peer in the device&apos;s bitmap, in the peer device&apos;s bitmap, or in both bitmaps. When two cluster nodes connect, they exchange each other&apos;s bitmaps, and they each compute the union of the local and peer bitmap to determine the overall differences.</p><p>Bitmaps of very large devices are also relatively large, but they usually compress very well using run-length encoding. This can save time and bandwidth for the bitmap transfers.</p><p>The <strong>use-rle</strong> parameter determines if run-length encoding should be used. It is on by default since DRBD 8.4.0.</p><p><strong>verify-alg </strong><strong></strong><em>hash-algorithm</em></p><p>Online verification (<strong>drbdadm verify</strong>) computes and compares checksums of disk blocks (i.e., hash values) in order to detect if they differ. The <strong>verify-alg</strong> parameter determines which algorithm to use for these checksums. It must be set to one of the secure hash algorithms supported by the kernel before online verify can be used; see the shash algorithms listed in /proc/crypto.</p><p>We recommend to schedule online verifications regularly during low-load periods, for example once a month. Also see the notes on data integrity below.</p>
<h3>Section on Parameters</h3>
<p><strong>address </strong><strong></strong><em>[address-family]</em><strong> </strong><strong></strong><em>address</em><strong>:</strong><strong></strong><em>port</em></p><p>Defines the address family, address, and port of a connection endpoint.</p><p>The address families <strong>ipv4</strong>, <strong>ipv6</strong>, <strong>ssocks</strong> (Dolphin Interconnect Solutions&apos; "super sockets"), <strong>sdp</strong> (Infiniband Sockets Direct Protocol), and <strong>sci</strong> are supported (<strong>sci</strong> is an alias for <strong>ssocks</strong>). If no address family is specified, <strong>ipv4</strong> is assumed. For all address families except <strong>ipv6</strong>, the address is specified in IPV4 address notation (for example, 1.2.3.4). For <strong>ipv6</strong>, the address is enclosed in brackets and uses IPv6 address notation (for example, [fd01:2345:6789:abcd::1]). The port is always specified as a decimal number from 1 to 65535.</p><p>On each host, the port numbers must be unique for each address; ports cannot be shared.</p><p><strong>node-id </strong><strong></strong><em>value</em></p><p>Defines the unique node identifier for a node in the cluster. Node identifiers are used to identify individual nodes in the network protocol, and to assign bitmap slots to nodes in the metadata.</p><p>Node identifiers can only be reasssigned in a cluster when the cluster is down. It is essential that the node identifiers in the configuration and in the device metadata are changed consistently on all hosts. To change the metadata, dump the current state with <strong>drbdmeta dump-md</strong>, adjust the bitmap slot assignment, and update the metadata with <strong>drbdmeta restore-md</strong>.</p><p>The <strong>node-id</strong> parameter exists since DRBD 9. Its value ranges from 0 to 16; there is no default.</p>
<h3>Section options Parameters (Resource Options)</h3>
<p><strong>auto-promote </strong><strong></strong><em>bool-value</em></p><p>A resource must be promoted to primary role before any of its devices can be mounted or opened for writing.</p><p>Before DRBD 9, this could only be done explicitly ("drbdadm primary"). Since DRBD 9, the <strong>auto-promote</strong> parameter allows to automatically promote a resource to primary role when one of its devices is mounted or opened for writing. As soon as all devices are unmounted or closed with no more remaining users, the role of the resource changes back to secondary.</p><p>Automatic promotion only succeeds if the cluster state allows it (that is, if an explicit <strong>drbdadm primary</strong> command would succeed). Otherwise, mounting or opening the device fails as it already did before DRBD 9: the <a href="../man2/mount.2.html"><strong>mount</strong>(2)</a> system call fails with errno set to EROFS (Read-only file system); the <a href="../man2/open.2.html"><strong>open</strong>(2)</a> system call fails with errno set to EMEDIUMTYPE (wrong medium type).</p><p>Irrespective of the <strong>auto-promote</strong> parameter, if a device is promoted explicitly (<strong>drbdadm primary</strong>), it also needs to be demoted explicitly (<strong>drbdadm secondary</strong>).</p><p>The <strong>auto-promote</strong> parameter is available since DRBD 9.0.0, and defaults to <strong>yes</strong>.</p><p><strong>cpu-mask </strong><strong></strong><em>cpu-mask</em></p><p>Set the cpu affinity mask for DRBD kernel threads. The cpu mask is specified as a hexadecimal number. The default value is 0, which lets the scheduler decide which kernel threads run on which CPUs. CPU numbers in <strong>cpu-mask</strong> which do not exist in the system are ignored.</p><p><strong>on-no-data-accessible </strong><strong></strong><em>policy</em></p><p>Determine how to deal with I/O requests when the requested data is not available locally or remotely (for example, when all disks have failed). The defined policies are:</p><p><strong>io-error</strong></p><p>System calls fail with errno set to EIO.</p><p><strong>suspend-io</strong></p><p>The resource suspends I/O. I/O can be resumed by (re)attaching the lower-level device, by connecting to a peer which has access to the data, or by forcing DRBD to resume I/O with <strong>drbdadm resume-io </strong><strong></strong><em>res</em>. When no data is available, forcing I/O to resume will result in the same behavior as the <strong>io-error</strong> policy.</p><p>This setting is available since DRBD 8.3.9; the default policy is <strong>io-error</strong>.</p><p><strong>peer-ack-window </strong><strong></strong><em>value</em></p><p>On each node and for each device, DRBD maintains a bitmap of the differences between the local and remote data for each peer device. For example, in a three-node setup (nodes A, B, C) each with a single device, every node maintains one bitmap for each of its peers.</p><p>When nodes receive write requests, they know how to update the bitmaps for the writing node, but not how to update the bitmaps between themselves. In this example, when a write request propagates from node A to B and C, nodes B and C know that they have the same data as node A, but not whether or not they both have the same data.</p><p>As a remedy, the writing node occasionally sends peer-ack packets to its peers which tell them which state they are in relative to each other.</p><p>The <strong>peer-ack-window</strong> parameter specifies how much data a primary node may send before sending a peer-ack packet. A low value causes increased network traffic; a high value causes less network traffic but higher memory consumption on secondary nodes and higher resync times between the secondary nodes after primary node failures. (Note: peer-ack packets may be sent due to other reasons as well, e.g. membership changes or expiry of the <strong>peer-ack-delay</strong> timer.)</p><p>The default value for <strong>peer-ack-window</strong> is 2 MiB, the default unit is sectors. This option is available since 9.0.0.</p><p><strong>peer-ack-delay </strong><strong></strong><em>expiry-time</em></p><p>If after the last finished write request no new write request gets issued for <em>expiry-time</em>, then a peer-ack packet is sent. If a new write request is issued before the timer expires, the timer gets reset to <em>expiry-time</em>. (Note: peer-ack packets may be sent due to other reasons as well, e.g. membership changes or the <strong>peer-ack-window</strong> option.)</p><p>This parameter may influence resync behavior on remote nodes. Peer nodes need to wait until they receive an peer-ack for releasing a lock on an AL-extent. Resync operations between peers may need to wait for for these locks.</p><p>The default value for <strong>peer-ack-delay</strong> is 100 milliseconds, the default unit is milliseconds. This option is available since 9.0.0.</p>
<h3>Section startup Parameters</h3>
<p>The parameters in this section define the behavior of DRBD at system startup time, in the DRBD init script. They have no effect once the system is up and running.</p><p><strong>degr-wfc-timeout </strong><strong></strong><em>timeout</em></p><p>Define how long to wait until all peers are connected in case the cluster consisted of a single node only when the system went down. This parameter is usually set to a value smaller than <strong>wfc-timeout</strong>. The assumption here is that peers which were unreachable before a reboot are less likely to be be reachable after the reboot, so waiting is less likely to help.</p><p>The timeout is specified in seconds. The default value is 0, which stands for an infinite timeout. Also see the <strong>wfc-timeout</strong> parameter.</p><p><strong>outdated-wfc-timeout </strong><strong></strong><em>timeout</em></p><p>Define how long to wait until all peers are connected if all peers were outdated when the system went down. This parameter is usually set to a value smaller than <strong>wfc-timeout</strong>. The assumption here is that an outdated peer cannot have become primary in the meantime, so we don&apos;t need to wait for it as long as for a node which was alive before.</p><p>The timeout is specified in seconds. The default value is 0, which stands for an infinite timeout. Also see the <strong>wfc-timeout</strong> parameter.</p><p><strong>stacked-timeouts</strong></p><p>On stacked devices, the <strong>wfc-timeout</strong> and <strong>degr-wfc-timeout</strong> parameters in the configuration are usually ignored, and both timeouts are set to twice the <strong>connect-int</strong> timeout. The <strong>stacked-timeouts</strong> parameter tells DRBD to use the <strong>wfc-timeout</strong> and <strong>degr-wfc-timeout</strong> parameters as defined in the configuration, even on stacked devices. Only use this parameter if the peer of the stacked resource is usually not available, or will not become primary. Incorrect use of this parameter can lead to unexpected split-brain scenarios.</p><p><strong>wait-after-sb</strong></p><p>This parameter causes DRBD to continue waiting in the init script even when a split-brain situation has been detected, and the nodes therefore refuse to connect to each other.</p><p><strong>wfc-timeout </strong><strong></strong><em>timeout</em></p><p>Define how long the init script waits until all peers are connected. This can be useful in combination with a cluster manager which cannot manage DRBD resources: when the cluster manager starts, the DRBD resources will already be up and running. With a more capable cluster manager such as Pacemaker, it makes more sense to let the cluster manager control DRBD resources. The timeout is specified in seconds. The default value is 0, which stands for an infinite timeout. Also see the <strong>degr-wfc-timeout</strong> parameter.</p>
<h3>Section volume Parameters</h3>
<p><strong>device /dev/drbd</strong><strong></strong><em>minor-number</em></p><p>Define the device name and minor number of a replicated block device. This is the device that applications are supposed to access; in most cases, the device is not used directly, but as a file system. This parameter is required and the standard device naming convention is assumed.</p><p>In addition to this device, udev will create <strong>/dev/drbd/by-res/</strong><strong></strong><em>resource</em><strong>/</strong><strong></strong><em>volume</em> and <strong>/dev/drbd/by-disk/</strong><strong></strong><em>lower-level-device</em> symlinks to the device.</p><p><strong>disk</strong> {[disk] | <strong>none</strong>}</p><p>Define the lower-level block device that DRBD will use for storing the actual data. While the replicated drbd device is configured, the lower-level device must not be used directly. Even read-only access with tools like <a href="../man8/dumpe2fs.8.html"><strong>dumpe2fs</strong>(8)</a> and similar is not allowed. The keyword <strong>none</strong> specifies that no lower-level block device is configured; this also overrides inheritance of the lower-level device.</p><p><strong>meta-disk internal</strong>,</p><p><strong>meta-disk </strong><strong></strong><em>device</em>,</p><p><strong>meta-disk </strong><strong></strong><em>device</em><strong> [</strong><strong></strong><em>index</em><strong>]</strong></p><p>Define where the metadata of a replicated block device resides: it can be <strong>internal</strong>, meaning that the lower-level device contains both the data and the metadata, or on a separate device.</p><p>When the <em>index</em> form of this parameter is used, multiple replicated devices can share the same metadata device, each using a separate index. Each index occupies 128 MiB of data, which corresponds to a replicated device size of at most 4 TiB with two cluster nodes. We recommend not to share metadata devices anymore, and to instead use the lvm volume manager for creating metadata devices as needed.</p><p>When the <em>index</em> form of this parameter is not used, the size of the lower-level device determines the size of the metadata. The size needed is 36 KiB + (size of lower-level device) / 32K * (number of nodes - 1). If the metadata device is bigger than that, the extra space is not used.</p><p>This parameter is required if a <strong>disk</strong> other than <strong>none</strong> is specified, and ignored if <strong>disk</strong> is set to <strong>none</strong>. A <strong>meta-disk</strong> parameter without a <strong>disk</strong> parameter is not allowed.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTES ON DATA INTEGRITY</h2>
        <div class="sectioncontent">
<p>DRBD supports two different mechanisms for data integrity checking: first, the <strong>data-integrity-alg</strong> network parameter allows to add a checksum to the data sent over the network. Second, the online verification mechanism (<strong>drbdadm verify</strong> and the <strong>verify-alg</strong> parameter) allows to check for differences in the on-disk data.</p><p>Both mechanisms can produce false positives if the data is modified during I/O (i.e., while it is being sent over the network or written to disk). This does not always indicate a problem: for example, some file systems and applications do modify data under I/O for certain operations. Swap space can also undergo changes while under I/O.</p><p>Network data integrity checking tries to identify data modification during I/O by verifying the checksums on the sender side after sending the data. If it detects a mismatch, it logs an error. The receiver also logs an error when it detects a mismatch. Thus, an error logged only on the receiver side indicates an error on the network, and an error logged on both sides indicates data modification under I/O.</p><p>The most recent example of systematic data corruption was identified as a bug in the TCP offloading engine and driver of a certain type of GBit NIC in 2007: the data corruption happened on the DMA transfer from core memory to the card. Because the TCP checksum were calculated on the card, the TCP/IP protocol checksums did not reveal this problem.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">VERSION</h2>
        <div class="sectioncontent">
<p>This document was revised for version 9.0.0 of the DRBD distribution.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Written by Philipp Reisner &lt;philipp.reisner@linbit.com&gt; and Lars Ellenberg &lt;lars.ellenberg@linbit.com&gt;.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REPORTING BUGS</h2>
        <div class="sectioncontent">
<p>Report bugs to &lt;drbd-user@lists.linbit.com&gt;.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright 2001-2012 LINBIT Information Technologies, Philipp Reisner, Lars Ellenberg. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO drbd.conf-9.0&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man8/drbd.8.html"><strong>drbd</strong>(8)</a>, <a href="../man8/drbddisk.8.html"><strong>drbddisk</strong>(8)</a>, <a href="../man8/drbdsetup.8.html"><strong>drbdsetup</strong>(8)</a>, <a href="../man8/drbdadm.8.html"><strong>drbdadm</strong>(8)</a>, \m[blue]<strong>DRBD User&apos;s Guide</strong>\m[]\s-2\u[1]\d\s+2, \m[blue]<strong>DRBD Web Site</strong>\m[]\s-2\u[3]\d\s+2</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTES</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
     1.
  </dt>
  <dd>
    <p>DRBD User's Guide</p><p>http://www.drbd.org/users-guide/</p>
  </dd>
  <dt>
     2.
  </dt>
  <dd>
    
<pre>
      Online Usage Counter
</pre>
<p>http://usage.drbd.org</p>
  </dd>
  <dt>
     3.
  </dt>
  <dd>
    <p>DRBD Web Site</p><p>http://www.drbd.org/</p>
  </dd>

</dl>

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="drbd.conf-8.4.5.html"><span aria-hidden="true">&larr;</span> drbd.conf-8.4.5: Configuration file for drbds devices .</a></li>
   <li class="next"><a href="dsbl.conf.5.html">dsbl.conf.5: Configuration file for all dsbl testers <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

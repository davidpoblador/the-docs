<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>dacs.exprs: Dacs expression language</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Dacs expression language">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="dacs.exprs (5) manual">
  <meta name="twitter:description" content="Dacs expression language">
  <meta name="twitter:image" content="https://www.carta.tech/images/dacs-dacs.exprs-5.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man5/dacs.exprs.5.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="dacs.exprs (5) manual" />
  <meta property="og:description" content="Dacs expression language" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/dacs-dacs.exprs-5.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">dacs.exprs<small> (5)</small></h1>
        <p class="lead">Dacs expression language</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/">
      <span itemprop="name">File formats and conventions</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/dacs.exprs.5.html">
      <span itemprop="name">dacs.exprs: Dacs expression language</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/dacs/">
      <span itemprop="name">dacs</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/dacs.exprs.5.html">
      <span itemprop="name">dacs.exprs: Dacs expression language</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>These files are part of the <strong>DACS</strong> suite.</p><p><strong>DPL</strong> (the <strong>DACS</strong> programming language) is used in access control rules, its revocation list, and in configuration files. This programmability gives <strong>DACS</strong> maximum run-time configurability and flexibility. A <strong>DPL</strong> expression - or even a small program - may appear within predicate, allow, and deny elements of an access control rule, for example. <strong>DPL</strong> is also accessible using the \m[blue]<a href="../man1/dacsexpr.1.html"><strong>dacsexpr</strong>(1)</a></strong>\m[]\s-2\u[1]\d\s+2 command, which can be used for writing scripts even for non-<strong>DACS</strong> applications.</p><p><strong>DPL</strong>, which is gradually evolving in mostly backward-compatible ways, is similar in many ways to \m[blue]<strong>Perl</strong>\m[]\s-2\u[2]\d\s+2, \m[blue]<strong>PHP</strong>\m[]\s-2\u[3]\d\s+2, \m[blue]<strong>Tcl</strong>\m[]\s-2\u[4]\d\s+2 and its expressions look and behave much like C/C++ expressions. The calling signatures for functions are reminiscent of those of <strong>Tcl</strong>, with literal or string arguments used to select a particular mode of operation or specify options. The syntaxes used for strings and variables have been influenced by various Unix shells. Our intent is for the language to feel familiar and be easy to use for the typical tasks at hand. We have tried not to be gratuitously different.</p><p><strong>Note</strong></p><p>The philosophy guiding the design of the <strong>DACS</strong> expression language is that its power should be limited to basic operations on elementary data types that can be expressed simply and evaluated efficiently, along with a collection of utility and higher-level functions, targeted for the tasks at hand, that hide complexity. This is why the language does not include much in the way of control flow statements - our feeling is that complicated expressions are more likely to introduce mistakes, which can easily result in access control rules not working as intended.</p><p>While fleshing out the language is not a priority, expression syntax and the set of functions are being extended as necessary. An extensibility mechanism is planned that would let user-defined functions be loaded at run-time.</p><p>While there are no immediate plans to do so, replacing the <strong>DACS</strong> expression language with a general-purpose extension language may eventually make sense. <strong>Tcl</strong> and <strong>Perl</strong> would be leading contenders.</p><p><strong>Tip</strong></p><p>The \m[blue]<a href="../man1/dacsexpr.1.html"><strong>dacsexpr</strong>(1)</a></strong>\m[]\s-2\u[1]\d\s+2 utility can be useful for learning, testing, and debugging <strong>DPL</strong>.</p><h3>Expression Syntax</h3>
<p>Expression evaluation consists of a lexical analysis stage, in which the expression is broken into a sequence of tokens, followed by evaluation of the tokens.</p><p>Expression syntax is checked before an expression is evaluated. Any syntactic or run-time evaluation error immediately terminates evaluation of the top-level expression and returns a <strong>False</strong> result.</p><p><strong>Note</strong></p><p>Because files containing expressions are local to the <strong>DACS</strong> site on which they appear (i.e., <strong>DACS</strong> does not copy them), they need not be portable across sites. This means that any <strong>DACS</strong> jurisdiction is free to customize or extend these expressions at will since they do not have to be understood or executed by any other jurisdiction.</p><p><strong>Comments</strong></p><p>Three comment styles are recognized:</p><p>The /* ... */ C style comment syntax, which does not nest;</p><p>The // syntax of C++, where the remainder of the line following the token is ignored; and</p><p>The # syntax of shells and many scripting languages, provided the # is either at the beginning of a line or appears after whitespace, where the remainder of the line following the token is ignored. Note that escaping the # by preceding it with a backslash prevents the text that follows from being interpreted as a comment. For example, this will result in a syntax error if the backslash is omitted:</p>
<pre>
&gt; ${foo:? &#92;#xxx}
" #xxx"
</pre>
<p>Here are examples of all three styles:</p>
<pre>
/*
 * This is a comment
 */

// This is another comment

${x} = 17;  # And one last comment
</pre>
<p>Additionally, when expressions are parsed in the context of an XML document (such as in an access control rule), the XML comment syntax can be used (&lt;!-- A comment --&gt;). Such comments can span multiple lines.</p>
<pre>
&lt;!--
Comment out this clause for now...
&lt;Auth id="authx"&gt;
STYLE "expr"
CONTROL "sufficient"
&lt;/Auth&gt;
--&gt;
</pre>

<h3>Basic Data Types</h3>
<p>The following basic data types are supported:</p><p>integer</p><p>int</p><p>, Integers are represented internally as a C/C++ <strong>long int</strong>. Maximum and minimum values are platform dependent. Integers are written in the C-style syntax; for example, -1958, 0377 (octal), and 0xABC (hexadecimal, upper or lower case).</p><p>real</p><p>double</p><p>, Reals are represented internally as a C/C++ <strong>double</strong>. Maximum and minimum values are platform dependent. A real constant is an optional sequence of decimal digits (possibly signed) followed by a period and 1) at least one digit or 2) an &apos;e&apos; or &apos;E&apos; followed by at least one digit.</p><p>string</p><p>A string is a sequence of characters enclosed between matching single or double quotes (e.g., &apos;Hello world&apos;). Interpolation of variables occurs within double quotes but not single quotes. C-style character escape codes and octal numeric escape codes are understood (e.g., "&#92;t", "&#92;010") and either quote character (e.g., &apos;It&#92;&apos;s here&apos;) and the backslash character (e.g., "&#92;&#92;") can be quoted. An unrecognized quoted character is mapped to that character (e.g., "&#92;x" is "x"). Character strings are limited in length by available memory and are represented internally as a null-terminated vector.</p><p><strong>Note</strong></p><p>Because a string is null-terminated, it cannot contain a NUL character. Also, functions that deal with strings usually do not expect (most) ASCII control characters to appear in a string. Therefore a string that contains an unprintable character (a character that is not a tab, newline, carriage return, and that does not satisfy \m[blue]<a href="../man3/isprint.3.html"><strong>isprint</strong>(3)</a></strong>\m[]\s-2\u[5]\d\s+2) automatically becomes a bstring (see below).</p><p>Because <strong>DACS</strong> configuration files are XML documents, characters special to XML must be properly escaped within them. In particular, an ampersand character must always be written as &amp; and a &lt; character must be written as &lt;. For example, the query string a=1&b=2 might be used as</p>
<pre>
${Foo::QUERY_STRING} = "a=1&amp;b=2"
</pre>
<p>Variable references may occur within a (double-quoted) string; the value of the variable reference is interpolated at that point. If <em>${Foo::bar}</em> is "hello", then the value of "${Foo::bar}, world" is "hello, world".</p><p><strong>Note</strong></p><p>The first expression is invalid and must be written as the second:</p>
<pre>
foo"baz"
foo."baz"
</pre>
<p>binary</p><p>bstring</p><p>, A binary string is a sequence of bytes, limited in length by available memory. Most language operators cannot be applied to data of this type without converting it to another type (e.g., two bstring values cannot be added using the + operator). A binary string is not necessarily portable across systems.</p>
<pre>
&gt; "&#92;0&#92;1&#92;2"
"000102"
</pre>
<p>bareword</p><p>This type is a "literal word" much like Perl&apos;s <em>barewords</em>. A bareword consists of an initial alphabetic character, followed by any number of alphanumerics and underscores. The resulting lexical token must have no other interpretation in the language and is treated as if it were a quoted string. This syntactic convenience makes these two function calls equivalent:</p>
<pre>
file(test, "-e", foo)
file("test", "-e", "foo")
</pre>
<p>These two expressions are equivalent and yield "foobaz":</p>
<pre>
foo."baz"
foo.baz
</pre>
<p>bool</p><p>The boolean values <strong>True</strong> and <strong>False</strong> are either the result of evaluating certain expressions or are implicit argument values. This is really a pseudo-type because it is represented internally as an integer. In the former case, the integer <strong>1</strong> is the canonical "true" value and <strong>0</strong> is considered "false". In the latter case, there are several possibilities. If the argument is an integer or real, any non-zero value is considered <strong>True</strong> and <strong>0</strong> is considered <strong>False</strong>. For the string data type, both the empty string (i.e., "") and the string "0" are considered <strong>False</strong> and anything else is considered <strong>True</strong>. A binary string is equivalent to <strong>False</strong> if and only if its length is zero. An empty list of either variety ("[]" or "{}") is <strong>False</strong>, while any non-empty list or alist is <strong>True</strong>.</p><p>Automatic type conversion is performed when necessary and possible. In general, a "lower" type is promoted to a "higher" type (e.g., an integer is converted to a real when it is added to a real) and the result is of the higher type. Arguments to function calls are automatically coerced to the required types. A printable binary string (one not containing any "troublesome" control characters) can be converted into a string without loss; other binary strings are converted into a hexadecimal string representation for assignment or display.</p><p>The C/C++ unary cast operation is available for explicit type conversion. Not all conversions are supported (e.g., integer to binary and binary to string). These type names are case sensitive.</p><p>The language includes the concept of the void type, which cannot be stored in a variable, used as an operand, or printed. Some functions are void, \m[blue]<strong>print()</strong>\m[]\s-2\u[6]\d\s+2 for example. A value can be \m[blue]<strong>cast</strong>\m[]\s-2\u[7]\d\s+2 to void.</p><p><strong>Note</strong></p><p>Support for binary data is only partially implemented.</p>
<h3>Variables and Namespaces</h3>
<p>Every variable exists within a namespace. Namespaces exist so that the same variable name can exist safely and without ambiguity in different contexts. They also serve to group together and name a set of closely related variables, and they make it easy for all variables in the set to be assigned a characteristic (such as being read-only). For example, CGI parameter values are automatically put in the <em>Args</em> namespace and variables automatically created by <strong>DACS</strong> are put in the <em>DACS</em> namespace. Namespaces address the problem of a parameter name that happens to have the same name as a variable created by <strong>DACS</strong>, for example. They also allow intermediate results to be stored in their own namespace, also avoiding the problem of clashing variable names.</p><p>Variables are not declared in advance. The value of an uninitialized variable is the empty string, which is invalid in a numerical context, but variables should always be initialized before being used. Some variables are created automatically by <strong>DACS</strong> from the execution context (e.g., the value of a CGI parameter value, the identity of the client, an environment variable), as a side-effect of function evaluation, or by an assignment operator.</p><p>The interpreter tries to maintain the natural type of a variable when possible, to avoid conversions to and from the string type.</p><p><strong>Variable Syntax</strong></p><p>A variable reference may have either of the following syntaxes:</p>
<pre>
${[<em>namespace</em>::]<em>variable-name</em>[:<em>flags</em>]}
$[<em>namespace</em>::]<em>variable-name</em>
</pre>
<p>For instance, the following refers to the value of a variable called <em>JURISDICTION_NAME</em> within the namespace called <em>Conf</em>:</p>
<pre>
${Conf::JURISDICTION_NAME}
</pre>
<p>A variable called <em>JURISDICTION_NAME</em> within a different namespace could exist and would be completely distinct.</p><p>A namespace must begin with an alphabetic character and can be followed by any number of alphabetics, digits, dashes, and underscores. By convention, predefined namespaces begin with an upper case letter.</p><p>If the namespace is omitted from a variable reference, a default namespace is implied (see below).</p><p>A variable name consists of any number of alphanumeric characters (upper and lower case), and characters from this set:</p>
<pre>
-_.!~*&apos;()
</pre>
<p>Additionally, a "%" character that is followed by two hexadecimal characters (upper and lower case) is acceptable.</p><p>If instead of a variable name the character "#" appears, the number of variables in the namespace is returned. If the namespace does not exist, 0 is returned. For example, the value of this variable reference is the number of variables in the <em>Conf</em> namespace:</p>
<pre>
${Conf::#}
</pre>
<p>When the syntax with braces is used, a variable name may be followed by a colon and then one or more modifier flags that affect the processing of the variable. Referencing an invalid variable name or unknown namespace, or using an undefined \m[blue]<strong>modifier flag</strong>\m[]\s-2\u[8]\d\s+2 is an error. Referencing an undefined variable yields the empty string.</p><p>Variable names are case sensitive by default; namespaces are always case sensitive.</p><p>User-defined variables and namespaces are not persistent. They disappear when their execution context terminates.</p><p><strong>Tip</strong></p><p>A variable reference may not contain any whitespace except when it appears after a ? or +\m[blue]<strong>modifier flag</strong>\m[]\s-2\u[8]\d\s+2.</p><p><strong>Tip</strong></p><p>Because many variable references do not include flags or use punctuation characters in the variable name, as a convenience the braces that surround a variable reference may be omitted in certain cases. This is only possible if the variable name begins with an alphabetic or an underscore, which can be followed by alphanumerics and underscores. A namespace may be specified, but flags are not permitted, although the special "#" construct is also allowed. The variable name ends with the first invalid character. For example, these pairs of variable references are equivalent:</p>
<pre>
${myvar}
$myvar

${foo::baz}
$foo::baz
</pre>
<p>Note that the variable reference ${foo-17} has a valid but different interpretation if the braces are omitted.</p><p><strong>Variable Modifier Flags</strong></p><p>A variable reference may include one or more modifier flags that control how the reference is to be interpreted.</p><p>The following modifier flags are recognized:</p><p>e</p><p><em>Exists</em>: The "e" modifier flag is used to test whether the variable exists (has been defined). Instead of returning the value of the variable or causing an error, the value of the variable reference is the string "1" if the variable is defined, the empty string otherwise (equivalent to <strong>False</strong>).</p><p>i</p><p><em>Insensitive</em>: When looking up the name of a variable, the default is to use a case-sensitive comparison for the variable name. To use a case-insensitive comparison instead, an "i" flag is used (e.g., <em>${FOO::i}</em>). The namespace lookup is always case sensitive.</p><p>n</p><p><em>Non-empty</em>: The "n" modifier flag tests whether the variable exists (has been defined) <em>and</em> is not the empty string (i.e., has zero length). Instead of returning the value of the variable or causing an error, the value of the variable reference is the string "1" if the variable is defined and is not the empty string, otherwise it is the empty string (equivalent to <strong>False</strong>).</p><p>z</p><p><em>Zero</em>: The opposite of the "n" flag, instead of returning the value of the variable or causing an error, the value of the variable reference is the string "1" if the variable is undefined or the empty string, otherwise it is the empty string (equivalent to <strong>False</strong>).</p><p>?</p><p><em>Default</em>: The "?" modifier flag must appear last if it is used. The flag is immediately followed by zero or more characters. Its purpose is to associate a default value with the variable reference. If the variable is defined and is not empty, then the result of the variable reference is the value of the variable; otherwise, the result is the evaluation of the characters that follow the "?" flag. If no character follows the "?" flag, the empty string is indicated. The default may itself contain variable references, embedded spaces, etc., and is evaluated left to right. Any "}" characters appearing in the string before the last closing brace must be escaped by being preceded by a backslash.</p><p>+</p><p><em>Substitute</em>: The "+" modifier flag must appear last if it is used. The flag is immediately followed by zero or more characters. Its purpose is to associate a substitute value with a variable reference. If the variable is defined and is not the empty string, then the result of the variable reference is the evaluation of the characters that follow the "+" flag; if the variable is undefined or is the empty string, the value of the variable reference is the empty string. If no character follows the "+" flag, the empty string is indicated. The substitute may itself contain variable references, embedded spaces, etc., and is evaluated left to right. Any "}" characters appearing in the string before the last closing brace must be escaped by being preceded by a backslash.</p><p>The i can be combined with any other flag, but it must appear first. All other flags are mutually exclusive. Repetitions of a flag are ignored. An unrecognized flag raises an error condition.</p><p>Consider these examples:</p>
<pre>
${Args::SCALE:?17}
${Foo::bar:i?${Bar::baz&#92;}baz}
"${DACS::QUERY:+?}${DACS::QUERY:?}"
</pre>
<p>In the first example, if <em>${Args::SCALE}</em> is undefined or empty, the value of the variable reference is "17" instead of the value of <em>${Args::SCALE}</em>. In the second example, if <em>${Foo::bar}</em> (case insensitive) is defined, the result is its value, otherwise the result is the value of the string "${Bar::baz}baz". In the third example, if <em>${DACS::QUERY}</em> is defined and not empty, the value of the expression will be a question mark followed by the value of <em>${DACS::QUERY}</em>. If <em>${DACS::QUERY}</em> is undefined or empty, the value will be the empty string.</p><p><strong>Reserved Namespaces</strong></p><p>The following namespaces are predefined by <strong>DACS</strong> and reserved for particular uses. Some are read-only, which means that only <strong>DACS</strong> can create a variable or change the value of a variable in the namespace, except in certain contexts.</p><p><em>Args</em></p><p>Instantiated from query string arguments and the POST data stream (if the content type is application/x-www-form-urlencoded or multipart/form-data). This namespace is read-only.</p><p><em>Argv</em></p><p>Instantiated by <strong>dacsexpr</strong> from the command line flags passed to the script. The value of <em>${Argv::0}</em> is the name of the file being processed, with - signifying the standard input. The next argument, if any, will be <em>${Argv::1}</em>, and so on. This namespace is read-only.</p><p><em>Auth</em></p><p>Used by \m[blue]<a href="../man8/dacs_authenticate.8.html"><strong>dacs_authenticate</strong>(8)</a></strong>\m[]\s-2\u[9]\d\s+2 during authentication processing.</p><p><em>Conf</em></p><p>Instantiated with configuration directive variables, this namespace is made read-only after configuration processing. See \m[blue]<strong>dacs.conf</strong>(5)</strong>\m[]\s-2\u[10]\d\s+2.</p><p><em>Cookies</em></p><p>This namespace is instantiated with HTTP cookies that were submitted with a request. For security reasons, those associated with <strong>DACS</strong> credentials are excluded. This is a read-only namespace. If a cookie named foo is sent by a user agent, an access control rule can access the cookie value as <em>${Cookies::foo}</em>.</p><p><em>DACS</em></p><p>Instantiated with <strong>DACS</strong>-specific variables. It is read-only. See \m[blue]<a href="../man8/dacs_acs.8.html"><strong>dacs_acs</strong>(8)</a></strong>\m[]\s-2\u[11]\d\s+2.</p><p><em>Env</em></p><p>For web services, instantiated with the standard <strong>Apache</strong> environment variables; for other programs, instantiated from the execution environment (\m[blue]<a href="../man7/environ.7.html"><strong>environ</strong>(7)</a></strong>\m[]\s-2\u[12]\d\s+2). It is read-only.</p><p><em>ExecEnv</em></p><p>Used by \m[blue]<strong>exec()</strong>\m[]\s-2\u[13]\d\s+2.</p><p><em>LDAP</em></p><p>Used by <strong>local_ldap_authenticate</strong>.</p><p><em>Temp</em></p><p>Unless disabled or redefined at build-time, variable references that do not include a namespace are associated with this namespace as a convenience. The following three expressions are therefore equivalent:</p>
<pre>
${foo} = 17
${Temp::foo} = 17
$foo = 17
</pre>
<p>In a future release, this mechanism may be generalized to provide a run-time means of selecting the default namespace.</p>
<h3>Lists, Alists, and Arrays</h3>
<p><strong>DPL</strong> supports more complicated data structures based on lists and associative lists. These types may also be combined and composed so that programmers can create lists of lists, and so on.</p><p><strong>Lists</strong></p><p>A list is composed of zero or more basic data types or sub-lists. A list is created using the following syntax:</p>
<pre>
<em>LIST</em>     -&gt; "[" "]" | "[" <em>LIST-ELS</em> "]"
<em>LIST-ELS</em> -&gt; <em>EL</em> | <em>EL</em> "," <em>LIST-ELS</em>
<em>EL</em>       -&gt; <em>BASIC-DATA-TYPE</em> | <em>LIST</em>
</pre>
<p>A list can also be created through the \m[blue]<strong>list()</strong>\m[]\s-2\u[14]\d\s+2 function.</p><p>Here is a list consisting of four elements:</p>
<pre>
[1, "one", 1.000, ["one sublist"]]
</pre>
<p>The \m[blue]<strong>length()</strong>\m[]\s-2\u[15]\d\s+2 function returns the number of elements in a list.</p><p>A list can be assigned to a variable:</p>
<pre>
$mylist = [1, 2, 3, 4, 5, 6]
$mylist_copy = $mylist
</pre>
<p><strong>Note</strong></p><p>These two statements are equivalent:</p>
<pre>
$mylist = ["one", "two"]
${mylist} = ["one", "two"]
</pre>
<p>And so are these two:</p>
<pre>
$mylist[0]
${mylist}[0]
</pre>
<p>Modifier flags therefore do not apply to list elements, only the list variable.</p><p>A list or element can be appended to another list using the "." ("dot") concatenation operator. List elements can be rotated using the "&gt;&gt;" ("shift left") or "&lt;&lt;" ("shift right") operators. The compound assignment operator versions of these operators may also be used.</p>
<pre>
&gt; $mylist=[orange, apple, grape]
[orange,apple,grape]
&gt; $mylist . banana
[orange,apple,grape,banana]
&gt; $mylist .= [prune,plum]
[orange,apple,grape,prune,plum]
&gt; $mylist .= [[lime]]
[orange,apple,grape,prune,plum,[lime]]
&gt;$mylist &lt;&lt; 1
[apple,grape,banana,prune,plum,[lime],orange]
</pre>
<p>A list element can be referenced using a subscript between zero and one less than the number of elements in the list:</p>
<pre>
&gt; $mylist = [1, 2, 3, 4, 5, 6]; length($mylist)
6
&gt; $mylist[0]
1
</pre>
<p>It is an error to reference a non-existent list element using a subscript. (Note: additional syntax may be introduced to provide a way to declare lists and arrays.)</p><p>The values of one or more list elements are selected by a list reference, which includes the simple subscript case just described. The value of a list reference is either a basic data type or a list.</p>
<pre>
<em>LIST-REFERENCE</em>       -&gt; "[" <em>LIST-REFERENCE-ELS</em> "]"
<em>LIST-REFERENCE-ELS</em>   -&gt; <em>EMPTY</em> | <em>LIST-REFERENCE-EL</em> | <em>LIST-REFERENCE-EL</em> "," <em>LIST-REFERENCE-ELS</em>
<em>LIST-REFERENCE-EL</em>    -&gt; <em>EXP</em> | <em>LIST-REFERENCE-SLICE</em>
<em>LIST-REFERENCE-SLICE</em> -&gt; <em>EXP</em> ".." <em>EXP</em>

<em>LIST-REFERENCE-SEQ</em>   -&gt; <em>LIST-REFERENCE</em> | <em>LIST-REFERENCE</em> <em>LIST-REFERENCE-SEQ</em>
</pre>
<p>An <em>EXP</em> must evaluate to a non-negative integer value. The ".." ("dotdot") range operator specifies a sequence of subscripts between the value to its left and the value to its right, inclusive. The left value must not be greater than the right value. If "#" appears to the right of the ".." operator, the number of elements in the list variable or the intermediate list computation is implied. A "#" may not appear to the left of ".." and may not be used in an expression (e.g., "#-2" is invalid). As in a function&apos;s argument list, a comma is not treated as the comma operator in this context. Note that it is not an error to specify non-existent elements in a slice; therefore it is possible for the value of a list reference to be the empty list.</p>
<pre>
&gt; $i=1, $mylist[$i]
2
&gt; $mylist[1,3,5]
[2,4,6]
&gt; $mylist[0..2,4]
[1,2,3,5]
&gt; $mylist[2..#]
[3,4,5,6]
&gt; $mylist[0..3]
[1,2,3,4]
</pre>
<p>The dotdot operator can also be used to construct an element of a list or alist:</p>
<pre>
&gt; $a = [1, 4..8, 10, 12, 13]
[1,4..8,10,12,13]
&gt; length($a)
5
&gt; $b = [0..2,4]; listref($a, $b)
[1,4..8,10,13]
</pre>
<p>Whether a "[" ... "]" sequence introduces a list constructor or list reference depends on the context; if it appears to the right of a list variable, list constructor, a function that returns a list, or another list reference, it is treated as a list reference.</p><p>List references can be composed as a right-associative operation. For example:</p>
<pre>
&gt; $a = [[1,2,3], [4,5,6], [7,8,9]]
[[1,2,3], [4,5,6], [7,8,9]]
&gt; $a[1][1]
5
&gt; $a[0..1][1..2]
[[4,5,6]]
&gt; $a[0..1][1..2][0][2]
6
</pre>
<p><strong>Tip</strong></p><p>Individual characters and sequences of characters of a string-valued expression can be selected using \m[blue]<strong>strchars()</strong>\m[]\s-2\u[16]\d\s+2, which uses a similar syntax.</p><p><strong>Note</strong></p><p>The list constructor and list reference syntax has not yet been integrated with the \m[blue]<strong>expression grammar</strong>\m[]\s-2\u[17]\d\s+2.</p><p>A list value can also be assigned to a subscripted variable; only a single subscript is allowed, however, and the referenced element must already exist:</p>
<pre>
&gt; $a = [1, 2, 3]
[1,2,3]
&gt; $a[2] = 17
17
&gt; $i = 1
1
&gt; $a[$i] = [10, 11]
[10,11]
&gt; $a
[1,[10,11],17]
</pre>
<p><strong>Alists</strong></p><p><strong>DPL&apos;s</strong> associative list, or "alist", is similar to Perl&apos;s hashes. An alist is composed of zero or more pairs. The first element of each pair is a case-sensitive key, unique within the alist, that is used to index the element. The second element of a pair is its value, which may be any data type. The key element of a pair, or all the keys in an alist, can be obtained using \m[blue]<strong>keysof()</strong>\m[]\s-2\u[18]\d\s+2. Similarly, \m[blue]<strong>valuesof()</strong>\m[]\s-2\u[19]\d\s+2 yields the value element or a list of value elements.</p><p>Unlike a regular list, elements within an alist are not ordered. Two alists can only be compared for equality (or inequality); they are equal if they contain exactly the same pairs.</p><p>An alist has the following syntax:</p>
<pre>
<em>ALIST</em>       -&gt; "{" "}" | "{" <em>ALIST-PAIRS</em> "}"
<em>ALIST-PAIRS</em> -&gt; <em>ALIST-PAIR</em> | <em>ALIST-PAIRS</em> "," <em>ALIST-PAIR</em>
<em>ALIST-PAIR</em>  -&gt; <em>KEY-EL</em> "," <em>VALUE-EL</em>
<em>KEY-EL</em>      -&gt; <em>STRING</em>
<em>VALUE-EL</em>    -&gt; <em>BASIC-DATA-TYPE</em> | <em>LIST</em> | <em>ALIST</em>
</pre>
<p>An alist can also be created through the \m[blue]<strong>alist()</strong>\m[]\s-2\u[20]\d\s+2 function.</p><p>Here is an alist consisting of four elements:</p>
<pre>
{"red", 0, "blue", 2, "green", 5, "black", 7}
</pre>
<p>The \m[blue]<strong>length()</strong>\m[]\s-2\u[15]\d\s+2 function returns the number of pairs of elements in an alist.</p><p>An alist can be assigned to a variable:</p>
<pre>
$myalist = {1, 2, 3, 4, 5, 6}
$myalist_copy = $myalist
</pre>
<p>An alist can be appended to another alist using the "." ("dot") concatenation operator. The compound assignment operator version of this operator may also be used.</p>
<pre>
&gt; $myalist={sunny, 3}
{"sunny", 3}
&gt; $myalist . {rainy, 11}
{"sunny", 3, "rainy", 11}
&gt; $myalist .= {"snowy", 13}
{"sunny", 3, "snowy", 13}
</pre>
<p>An alist element or pair is referenced using a string subscript. A sequence of string subscripts can be used to select multiple pairs. If the subscript (or subscripts) are within brackets, then a successful result will be a basic data type or a list. If the subscript (or subscripts) are within braces, then a successful result will always be an alist. Note that because an alist subscript is not automatically converted to the string type, a numeric subscript is illegal.</p>
<pre>
&gt; $myalist = {a, 2, b, 4, c, 6}; length($myalist)
3
&gt; $myalist["a"]
2
&gt; $myalist{"b"}
{"b", 4}
&gt; $myalist{"c", "a"}
{"c", 6, "a", 2}
</pre>
<p>It is an error to reference a non-existent alist element. (Note: additional syntax may be introduced to provide a way to declare lists and arrays.)</p><p>Like regular lists, alist references can be composed as a right-associative operation:</p>
<pre>
&gt; $myalist = {a, [1, 2], b, [3, 4], c, [5, 6]}; length($myalist)
3
&gt; $myalist["a"]
[1, 2]
&gt; $myalist{"b"}
{"b", [3, 4]}
&gt; $myalist{"b"}[1]
4
</pre>
<p>It is possible to convert an alist to a regular list, or vice versa; see the \m[blue]<strong>cast</strong>\m[]\s-2\u[7]\d\s+2 operator.</p><p><strong>Note</strong></p><p>There is currently no way to delete an alist pair.</p>
<h3>Expression Grammar</h3>
<p>The following grammar is used to construct an expression (EXP) or sequence (S) of expressions.</p><p><strong>Note</strong></p><p>The syntax is very similar to that of the C programming language. It differs with respect to data types, variables, compile-time operators, and on some minor aspects of grammar.</p><p>A sequence of statements (or simply a sequence) is two or more expressions, with a ";" character separating them. The ";" is unnecessary following the last statement in a sequence of statements (and is therefore unnecessary if there is only one expression). The statements are evaluated in the order in which they appear. The value of a sequence is that of the last expression, unless an <strong>exit</strong> or <strong>return</strong> function is invoked, in which case the value of the sequence is the value returned by the function call. An error condition will also terminate evaluation of the sequence and yield a result of <strong>False</strong>. A sequence within curly braces is called a block.</p><p><strong>Figure&nbsp;1.&nbsp;Expression Grammar</strong></p>
<pre>
<em>S</em>    -&gt; <em>E</em>    | <em>E</em> ";" | <em>E</em> ";" <em>S</em>
<em>E</em>    -&gt; <em>E2</em>   | <em>E2</em> "," <em>E</em>
<em>E2</em>   -&gt; <em>E3</em>   | <em>VAR ASSIGN_OP</em> <em>E2</em> | <em>IF_ELSEIF_ELSE</em>
<em>E3</em>   -&gt; <em>E4</em>   | <em>E4</em> "?" <em>E</em> ":" <em>E</em>
<em>E4</em>   -&gt; <em>E5</em>   | <em>E5</em> <em>OR</em> <em>E5</em>
<em>E5</em>   -&gt; <em>E6</em>   | <em>E6</em> <em>AND</em> <em>E5</em>
<em>E6</em>   -&gt; <em>E7</em>   | <em>E7</em> "|" <em>E7</em>
<em>E7</em>   -&gt; <em>E8</em>   | <em>E8</em> "^" <em>E8</em>
<em>E8</em>   -&gt; <em>E9</em>   | <em>E9</em> "&" <em>E9</em>
<em>E9</em>   -&gt; <em>E10</em>  | <em>E10</em> <em>EQ_OP</em> <em>E10</em>
<em>E10</em>  -&gt; <em>E11</em>  | <em>E11</em> <em>REL_OP</em> <em>E11</em>
<em>E11</em>  -&gt; <em>E12</em>  | <em>E12</em> "." <em>E12</em>
<em>E12</em>  -&gt; <em>E13</em>  | <em>E13</em> "&lt;&lt;" <em>E13</em> | <em>E13</em> "&gt;&gt;" <em>E13</em>
<em>E13</em>  -&gt; <em>E14</em>  | <em>E14</em> "+" <em>E14</em>  | <em>E14</em> "-" <em>E14</em>
<em>E14</em>  -&gt; <em>E15</em>  | <em>E15</em> "*" <em>E15</em>  | <em>E15</em> "/" <em>E15</em> | <em>E15</em> "%" <em>E15</em>
<em>E15</em>  -&gt; <em>E16</em>  | <em>E16</em> "^" <em>E14</em>  | <em>E16</em> "**" <em>E14</em>
<em>E16</em>  -&gt; <em>E17</em>  | <em>NOT</em> <em>E16</em> | "~" <em>E16</em> | "++" <em>VAR</em> | "--" <em>VAR</em>
             | "+" <em>E</em> | "-" <em>E</em> | "(" <em>type</em> ")"
<em>E17</em>  -&gt; "(" <em>E</em> ")" | <em>VAR</em> "++" | <em>VAR</em> "--" | <em>FUNCTION_CALL</em> | <em>PRIMARY</em>

<em>ASSIGN_OP</em> -&gt; "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&gt;&gt;="
                 | "&lt;&lt;=" | "&=" | "^=" | "|=" | ".="

<em>PRIMARY</em> -&gt; <em>a number</em> | <em>a string</em> | <em>VAR</em>
<em>OR</em>      -&gt; "||" | "or"
<em>AND</em>     -&gt; "&&" | "and"
<em>NOT</em>     -&gt; "!"  | "not"
<em>EQ_OP</em>   -&gt; "==" | "!=" | "eq" | "ne"
<em>REL_OP</em>  -&gt; "&lt;"  | "&lt;=" | "&gt;" | "&gt;=" | "lt" | "le" | "gt" | "ge"
<em>VAR</em>     -&gt; <em>a variable reference</em>
<em>FUNCTION_CALL</em> -&gt; <em>FUNCTION_NAME</em> "(" <em>ARG_LIST</em> ")"
<em>ARG_LIST</em> -&gt; <em>EMPTY</em> | <em>E2</em> | <em>ARG_LIST</em> "," <em>E2</em>
<em>EMPTY</em>    -&gt;
</pre>
<p>Keywords and function names are case sensitive.</p><p>The production <em>VAR</em><em>ASSIGN_OP</em><em>E</em> in the grammar refers to assignment of the evaluation of <em>E</em> to a variable using the given assignment operator (<em>ASSIGN_OP</em>). For example,</p>
<pre>
${a} += 17
</pre>
<p>Provided <em>${a}</em> has been initialized to an integer value, this expression increments it by 17.</p><p>The production <em>IF_ELSEIF_ELSE</em> represents a familiar if statement with zero or more elseif components and an optional else component:</p>
<pre>
if (<em>expression</em>) {
  <em>sequence</em>
}
[elseif (<em>expression</em>) {
  <em>sequence</em>
}] ...
[else {
  <em>sequence</em>
}]
</pre>
<p>Each <em>block</em> is an optional sequence of statements. Braces are mandatory.</p><p><strong>Tip</strong></p><p>An if_elseif_else statement has a value: it is either that of the last statement executed in the selected block, or the empty string if no statement is executed. In this example, <em>${a}</em> is set to either 33 or ${b} - 1, depending on whether <em>${b}</em> is greater than eight:</p>
<pre>
${a} = if (${b} &gt; 8) {${b}++; 33;} else {${b} - 1}
</pre>
<p>The value of this expression is the string "hello, world":</p>
<pre>
"hello, " . (if (0) {b . y . e} else {"world"})
</pre>
<p><strong>Note</strong></p><p>As in C, function calls, nested assignment operators, and increment and decrement operators cause side effects where the value of a variable is changed during expression evaluation. Because exactly when such side effects take place is left unspecified, programmers should avoid writing code with these kinds of dependencies on evaluation ordering.</p>
<h3>Operators</h3>
<p>The operators that appear in the grammar have the following semantics. They are listed in order of increasing precedence (which is very close to ISO C&apos;s), with operators in the same section having equal precedence. The result of applying an operator is one of the \m[blue]<strong>supported data types</strong>\m[]\s-2\u[21]\d\s+2, or an error. Parentheses can be applied to subexpressions in the usual way.</p><p>Whenever it makes sense, intermediate values are automatically converted to an appropriate type by an operator. So, for example, adding an integer and a real will cause the integer to automatically be converted to a real, yielding a real value. Adding a string and a number will work only if the string can be successfully converted to a number. In situations where an integer is required, a real value (including a string that represents a valid real number) will be truncated to an integer. For logical comparison operators, the operands will both be converted to integers, reals, or strings as necessary. A string value that is an illegal number will always be treated as a string.</p><p><strong>Note</strong></p><p> id="note11" xreflabel="dacsexpr prompts".PP In the examples that follow, the &apos;&gt;&apos; character at the beginning of an input line is a prompt from \m[blue]<a href="../man1/dacsexpr.1.html"><strong>dacsexpr</strong>(1)</a></strong>\m[]\s-2\u[1]\d\s+2.</p><p>,</p><p>This is the C/C++ comma operator. A pair of expressions separated by a comma is evaluated left to right, and the type and value of the result are the type and value of the right operand.</p><p>=, +=, -=, *=, /=, %=, &gt;&gt;=, &lt;&lt;=, &=, ^=, |=, .=</p><p>Assignment is done using a simple or compound assignment operator, each of which has right to left associativity. In the case of a compound assignment operator, the left hand side is evaluated only once. The type and value of an assignment is that of its right hand side. A variable reference is expected on the left side of the operator. Modifier flags are not permitted. The variable, which is created if it does not exist. The syntax of the variable reference includes the initial "${" and terminating "}" character (so it&apos;s similar to <strong>Perl</strong>&apos;s syntax).</p>
<pre>
&gt; ${foo::bar} = "hello"
"hello"
&gt; ${foo::bar} .= ", world"
"hello, world"
&gt; ${a} = [1, 2]
[1,2]
&gt; ${a} .= [3, 4]
[1,2,3,4]
</pre>
<p>?:</p><p>This is equivalent to the C/C++ conditional expression, which has right to left associativity. If the first expression is <strong>True</strong>, the result is the value of the second expression (the third is not evaluated). If the first expression is <strong>False</strong>, the result is the value of the third expression (the second is not evaluated).</p><p>or, ||</p><p>This is the C/C++ logical OR operator, which yields <strong>1</strong> (<strong>True</strong>) if either operand is <strong>True</strong>, otherwise it yields <strong>0</strong> (<strong>False</strong>). Evaluation is from left to right and and stops as soon as the truth or falsehood of the result is known. The two tokens are synonymous.</p><p>and, &&</p><p>This is the C/C++ logical AND operator, which yields <strong>1</strong> (<strong>True</strong>) if both operands are <strong>True</strong>, otherwise it yields <strong>0</strong> (<strong>False</strong>). Evaluation is from left to right and and stops as soon as the truth or falsehood of the result is known. The two tokens are synonymous.</p><p><strong>Note</strong></p><p>When expressions are parsed as XML attribute values, an &apos;&&apos; character must be encoded as the five characters &apos;&amp;&apos;.</p><p>|</p><p>This is the C/C++ bitwise inclusive OR operator. Both operands must be integers.</p><p>^</p><p>This is the C/C++ bitwise exclusive OR operator. Both operands must be integers.</p><p>&</p><p>This is the C/C++ bitwise AND operator. Both operands must be integers.</p><p><strong>Note</strong></p><p>When expressions are parsed as XML attribute values, an &apos;&&apos; character must be encoded as the five characters &apos;&amp;&apos;.</p><p>==, !=, eq, ne, eq:i, ne:i</p><p>These operators compare their arguments and return 1 if the relation is true, 0 otherwise. If both arguments are lists, corresponding elements of both lists are compared, recursively. If both arguments are alists, the number of pairs in both lists is compared and, if necessary, pairs in the first list are looked up in the second list for matching values (note that the case-insensitive variant applies only to the value component of a pair, not the key component). For other valid arguments an attempt is first made to coerce both arguments to numbers and do a numeric comparison. If that fails, a lexicographic comparison is performed. Operators having a :i modifier are like their counterparts without the modifier except they do case-insensitive string comparisons.</p><p>If either argument is of type bstring, however, the comparison is done differently than explained above. Two bstring arguments are equal if and only if they are byte-wise identical. If one argument is a bstring and the other is a string, the latter is treated as a bstring of length(<em>string</em>) bytes. The case flag is ignored if at least one argument is a bstring.</p><p>&lt;, &lt;=, &gt;, &gt;=, lt, le, lt:i, le:i, gt, ge, gt:i, ge:i</p><p>These operators compare their arguments and return 1 if the relation is true, 0 otherwise. An attempt is first made to coerce both arguments to numbers and do a numeric comparison. If that fails, a lexicographic comparison is performed. Operators having a :i modifier are like their counterparts without the modifier except they do a case-insensitive comparison.</p><p><strong>Note</strong></p><p>When expressions are parsed as XML attribute values, the &apos;&lt;&apos; character must be encoded as the four characters &apos;&lt;&apos;; the same applies to the "greater than" symbol.</p><p>If either argument is of type bstring, however, the comparison is done differently than explained above. If two bstring arguments are compared, the shorter bstring is "less than" the other argument and they are equal if and only if they are byte-wise identical. If one argument is a bstring and the other is a string, the latter is treated as a bstring of length(<em>string</em>) bytes. The case flag is ignored if at least one argument is a bstring.</p><p>.</p><p>The "dot" operator (not in ISO C) concatenates its right operand to its left operand. If both arguments are of type bstring, the result is also of type bstring. If the left operand is a list and the right operand is a basic data type, the right operand is appended to the list. If the left operand is a list and the right operand is also a list, the elements of the right operand are appended to the left operand. A list may not appear as the right operand if the left operand is not a list. In all other cases, both arguments are coerced to string (an error occurs if this cannot be done) before the left operand is appended to the right.</p>
<pre>
&gt; "hello" . ", world"
"hello, world"
&gt; "hello" . (16 + 1)
"hello17"
&gt; 17 . (16 + 1)
"1717"
&gt; [1, 2, 3] . 4
[1,2,3,4]
&gt; [1, 2, 3] . [4, 5, 6]
[1,2,3,4,5,6]
&gt; [1, 2, 3] . [[4]]
[1,2,3,[4]]
</pre>
<p><strong>Note</strong></p><p>A period will be recognized as a decimal point in a real number context rather than as the dot operator, so the input:</p>
<pre>
4.5
</pre>
<p>will be scanned as a number whereas, for example, the input:</p>
<pre>
"4".5
</pre>
<p>will evaluate to the string "45".</p><p>&lt;&lt;, &gt;&gt;</p><p>These are the C/C++ bitwise left shift and right shift operators, respectively. The first operand may be an integer or a list, the second operand must be an integer. When shifting an integer, these operators are implemented using the corresponding C/C++ operators. In the case of right shifting, the behaviour with respect to arithmetic vs. logical shifts will be platform dependent.</p><p>+, -</p><p>These are the (binary) addition and subtraction operators, respectively. Both arguments are coerced to numbers. An error occurs if this cannot be done. Also, unary + and - operators may precede an arithmetic-valued expression.</p><p>*, /, %</p><p>These are the multiplication, division, and remainder operators, respectively. Both arguments are coerced to numbers. An error occurs if this cannot be done, such as attempting to divide by zero. For the remainder operator, both operands must be integers.</p><p>**</p><p>This is the exponentiation operator (not in ISO C). Both arguments are coerced to numbers (either both integers or both reals). An error occurs if this cannot be done, such as attempting to raise to a negative power.</p>
<pre>
&gt; 2**10
1024
</pre>
<p>+, -, not, !, ~, ++<em>VAR</em>, --<em>VAR</em>, (<em>type</em>)</p><p>The + and - operators are the (unary) arithmetic plus and minus operators, respectively. These may precede an arithmetic-valued expression. Both arguments are coerced to numbers. An error occurs if this cannot be done.</p><p>The logical NOT operator (not, or equivalently, !) yields a result of zero when applied to a non-zero numeric value and non-zero when applied to an operand of zero. The result of applying this operator to a non-empty string is zero and it is non-zero when applied to an empty string string. These two tokens are synonymous.</p><p>The ~ operator is the one&apos;s complement (bitwise not) unary operator.</p><p>The ++<em>VAR</em> and --<em>VAR</em> operators are the prefix increment and decrement operators, respectively. These operators are followed by a variable reference. The variable must have an integer value.</p>
<pre>
&gt; ${foo} = 17, ++${foo}
18
</pre>
<p>An explicit type conversion can be forced by using a cast. The syntax for this type coercion is:</p>
<pre>
(<em>type</em>) <em>expression</em>
</pre>
<p>The <em>type</em> must be a recognized data type name: integer or int (for an integer), real or double (for a real), bool (for a boolean value as a long integer), string (for a character string), bstring or binary (for a binary string), list, alist, or void.</p><p>A list can be cast to an alist, provided it has no elements or an even number of elements and if no key would appear more than once in the alist. A namespace can be cast to an alist; the operand specifies the namespace, either as a literal or a string. An alist can be cast to an list; the ordering of the pairs in the resulting list is unspecified. A void type can only be cast to void, which is a no-op. Here are some examples:</p>
<pre>
&gt; (int) 3.4
3
&gt; (int) "3.6"
3
&gt; (bool) 17
1
&gt; (bool) ""
0
&gt; (string) (4 * 3)
"12"
&gt; ${x} = "17"; (int) ((real) ${x} + (bool) 1965)
18
&gt; (bstring) "abc"
"abc"
&gt; (bstring) 4.4
"4.400000"
&gt; (bstring) "&#92;0&#92;1&#92;2"
""
&gt; bstring("&#92;0&#92;1&#92;2",3) . bstring("&#92;3&#92;4", 3)
"0001020304"
&gt; (void) ($b=$x)
&gt;
&gt; (alist) [a, 1, "b", 2, 3, 3]
{"a", 1, "b", 2, "3", 3}
&gt; (list) { red, first, blue, second, white, third }
["blue", "second", "white", "third", "red", "first"]
&gt; $env = (alist) Env; $env["HOME"]
"/home/bobo"
&gt; $env{HOME}
{"HOME","/home/bobo"}
</pre>
<p><em>VAR</em>++, <em>VAR</em>--, primary</p><p>The <em>VAR</em>++ and <em>VAR</em>-- operators are the postfix increment and decrement operators, respectively. These operators are preceded by a variable reference. The variable must have an integer value.</p><p>A primary is a basic \m[blue]<strong>data type</strong>\m[]\s-2\u[21]\d\s+2 (i.e., an integer or real number, string, bareword, or binary string), or a \m[blue]<strong>variable reference</strong>\m[]\s-2\u[22]\d\s+2.</p>
<h3>Functions</h3>
<p>A function call is written as a function name, optionally followed by whitespace, a left parenthesis, zero or more comma-separated arguments, and a right parenthesis. A function name begins with either an alphabetic character or an underscore, followed by any number of alphanumerics and underscores. Additionally, a pair of colons may appear exactly once within the name (except at the beginning or end of the name). The number of arguments and their expected types depends on the particular function being called. The order in which the arguments to a function are evaluated is undefined. There is no mechanism for creating user-defined functions yet (they will eventually be available on some platforms through dynamically linked libraries).</p><p>The result of a function call is one of the \m[blue]<strong>supported data types</strong>\m[]\s-2\u[21]\d\s+2, or an error. An invalid function call, including those that fail during execution, yields a <strong>False</strong> result.</p><p><strong>Function Index:</strong></p><p><strong>ack</strong>: notice acknowledgement processing</p><p><strong>alist</strong>: create an alist</p><p><strong>alistref</strong>: create an alist reference</p><p><strong>bstring</strong>: convert a string to binary</p><p><strong>contains_any</strong>: count elements common to two lists</p><p><strong>counter</strong>: persistent integer counters</p><p><strong>dacs_admin</strong>: test if user is an administrator</p><p><strong>dacs_approval</strong>: create or test a signed authorization</p><p><strong>dacs_meta</strong>: get or update metadata</p><p><strong>dacsauth</strong>: perform authentication tests</p><p><strong>dacscheck</strong>: perform authorization tests</p><p><strong>debug</strong>: control debugging output</p><p><strong>decode</strong>: convert from a text representation</p><p><strong>digest</strong>: cryptographic hash functions</p><p><strong>encode</strong>: convert to a text representation</p><p><strong>eval</strong>: evaluate a string</p><p><strong>exec</strong>: execute a program</p><p><strong>exit</strong>: terminate current evaluation</p><p><strong>expand</strong>: variable interpolation</p><p><strong>file</strong>: perform an operation on a file</p><p><strong>file_group</strong>: test if user is associated with file's group</p><p><strong>file_owner</strong>: test if user is associated with file's owner</p><p><strong>from</strong>: test where the current request comes from</p><p><strong>get</strong>: read the contents of a file or VFS object</p><p><strong>hash</strong>: fast hashes</p><p><strong>hmac</strong>: secure keyed-hashes</p><p><strong>http</strong>: invoke an HTTP request</p><p><strong>index</strong>: search a string or list</p><p><strong>info</strong>: information about namespaces and variables</p><p><strong>keysof</strong>: extract keys from an alist</p><p><strong>ldap</strong>: extract a component from an LDAP name</p><p><strong>length</strong>: string length</p><p><strong>list</strong>: create a list</p><p><strong>listref</strong>: dereference a list</p><p><strong>on_success</strong>: evaluate an expression if authentication or authorization succeeds</p><p><strong>password</strong>: compute or check a password hash</p><p><strong>pathname</strong>: filename-based string interpolation</p><p><strong>pbkdf2</strong>: password-based key derivation</p><p><strong>print</strong>: display a string</p><p><strong>printf</strong>: display a formatted string</p><p><strong>random</strong>: generate random values</p><p><strong>redirect</strong>: redirect user after access is denied</p><p><strong>regmatch</strong>: string matching</p><p><strong>regsub</strong>: string substitution</p><p><strong>request_match</strong>: compare the current request to a URI</p><p><strong>return</strong>: terminate current evaluation</p><p><strong>rule</strong>: recursive authorization checking</p><p><strong>setvar</strong>: operations on namespaces</p><p><strong>sizeof</strong>: basic data type sizes</p><p><strong>sleep</strong>: suspend execution temporarily</p><p><strong>source</strong>: read and evaluate external expressions</p><p><strong>sprintf</strong>: format a string</p><p><strong>strchars</strong>: select characters from a string</p><p><strong>strchop</strong>: delete characters from the end of a string</p><p><strong>strftime</strong>: format the current date and time</p><p><strong>strptime</strong>: parse a date and time</p><p><strong>strrstr</strong>: locate the last instance of a substring</p><p><strong>strstr</strong>: locate the first instance of a substring</p><p><strong>strtolower</strong>: map uppercase to lowercase</p><p><strong>strtoupper</strong>: map lowercase to uppercase</p><p><strong>strtr</strong>: character transliteration</p><p><strong>subset</strong>: test if one set is a subset of another</p><p><strong>substr</strong>: extract a substring</p><p><strong>syntax</strong>: perform a syntax check on a string</p><p><strong>time</strong>: local time and date</p><p><strong>transform</strong>: filter text through rule-based transformations</p><p><strong>transform_config</strong>: set options for transform</p><p><strong>trim</strong>: delete trailing characters</p><p><strong>typeof</strong>: get or test data type</p><p><strong>undef</strong>: an undefined value</p><p><strong>user</strong>: test current user's identity</p><p><strong>ustamp</strong>: generate a unique stamp</p><p><strong>valuesof</strong>: extract values from an alist</p><p><strong>var</strong>: operations on individual variables</p><p><strong>vfs</strong>: perform a VFS operation</p><p><strong>ack</strong>(<em>notice-uri</em>[, <em>...</em>][, EXACT_MATCH | ALL_MATCH])</p><p>This function is associated with notice acknowledgement processing. The function indicates that the current service request has one or more notices associated with it (identified by a sequence of <em>notice-uri</em> arguments), each one represented by a URI that will return the text of a notice that must be acknowledged by the user. Following the last URI is an optional mode argument. The EXACT_MATCH mode is the default mode and requires a single acknowledgement to address all of the specified notices. The ALL_MATCH argument specifies a less stringent matching mode and requires any set of acknowledgements to collectively address all of the specified notices. See \m[blue]<a href="../man8/dacs_notices.8.html"><strong>dacs_notices</strong>(8)</a></strong>\m[]\s-2\u[23]\d\s+2.</p><p><strong>alist</strong>([<em>key</em>, <em>value</em> [, ...])</p><p>This function is equivalent to the \m[blue]<strong>alist construction operator</strong>\m[]\s-2\u[24]\d\s+2. There must be an even number of arguments, or no arguments. If the first argument of each pair (the key) is not a string or literal, it will be converted to a string, if possible.</p>
<pre>
alist(cars, 2, bikes, 5)
</pre>
<p>is equivalent to the expression:</p>
<pre>
{"cars", 2, "bikes", 5}
</pre>
<p>And the call:</p>
<pre>
alist(2, xx, [0, 1], yy)
</pre>
<p>yields:</p>
<pre>
{"2", xx, "[0,1]", yy}
</pre>
<p><strong>alistref</strong>(<em>list</em>)</p><p>This function creates a new list that is equivalent to that of the special "brace syntax" subscript used to dereference an alist. This is currently useful only in conjunction with \m[blue]<strong>listref()</strong>\m[]\s-2\u[25]\d\s+2.</p>
<pre>
listref({"a", 1, "b", 2, "c", 3}, alistref(["b"]))
</pre>
<p>is equivalent to the expression:</p>
<pre>
{"a", 1, "b", 2, "c", 3}{"b"}
</pre>
<p>the value of which is:</p>
<pre>
{"b", 2}
</pre>
<p><strong>bstring</strong>(<em>string</em>, <em>length</em>)</p><p>This function converts the first <em>length</em> characters of <em>string</em> (which may also be a bstring and which is converted to a string if necessary) into the binary type. The <em>length</em> argument may be less than the actual length of <em>string</em>; if it is zero, then actual length is computed, and if <em>length</em> is greater than the actual length, the actual length is used. The implicit null character on the end of <em>string</em> is not considered part of it.</p>
<pre>
&gt; bstring("&#92;0&#92;1&#92;2", 4)
"000102"
&gt; bstring("&#92;0&#92;1&#92;2", 2)
"0001"
</pre>
<p><strong>contains_any</strong>(<em>format</em>, <em>test-set</em>, <em>target-set</em>[, nocase])</p><p>This function returns a count of the number of elements of <em>test-set</em> that appear in <em>target-set</em> at least once. Duplicate elements may appear in <em>test-set</em> and are considered to be distinct. The <em>format</em> indicates how to parse the set arguments. It can be the space, tab, or newline character, or any punctuation character. For both sets, it is currently interpreted as the character that separates elements. If the optional nocase literal argument is given, then set elements are compared case-insensitively. The greatest possible return value is the number of distinct elements in the third parameter.</p>
<pre>
contains_any(",", ${Args::LAYERS:i}, "Nests,Secret_roads,Heritage")
contains_any(",", "a,a,b,z", "a,a,a,b,b,b,a,z,z")
</pre>
<p>The first expression returns <strong>3</strong> if every element in the third parameter appears at least once (case insensitive) in the second parameter, otherwise the value of the expression is <strong>0</strong>. The second expression returns <strong>4</strong>.</p><p><strong>counter</strong>(<em>op</em>, <em>vfs-ref</em>, <em>counter_name</em> [,<em>value</em>])</p><p>This function is used to manage persistent integer counters, which can be useful for a variety of purposes, such as counting the number of logins for a particular identity, limiting the number of logins, or restricting the number of times a resource can be accessed. Internally, counter values are \m[blue]<strong>integers</strong>\m[]\s-2\u[21]\d\s+2.</p><p>The first argument specifies an operation and is case-insensitive. The second argument identifies a filestore (typically a file or database). It must be an indexed filestore scheme, such as dacs-kwv-fs or dacs-db (see \m[blue]<strong>VFS</strong>\m[]\s-2\u[26]\d\s+2). The third argument is the name of the counter, which acts as a key. The meaning of the fourth argument depends on the operation, but if present it must be an integer.</p><p><strong>Note</strong></p><p>The current implementation has a limitation; a counter name (key) can be any printable string but cannot contain a space character. You can work around this limitation by encoding all keys every time they are used in a filestore operation.</p><p>counter(set, <em>vfs-ref</em>, <em>counter_name</em>, <em>new-value</em>)</p><p>This is used to create a new counter or reset an existing counter. The counter&apos;s value will be <em>new-value</em>, which must be an integer, and is the return value.</p><p>counter(create, <em>vfs-ref</em>, <em>counter_name</em>, <em>initial-value</em>)</p><p>This is used to create a new counter if it does not already exist. The new counter&apos;s value will be <em>initial-value</em>, which must be an integer. If the counter exists, its value will not be changed and is returned.</p><p>counter(del[ete], <em>vfs-ref</em>, <em>counter_name</em>)</p><p>This operation deletes an existing counter. The operation can be del or delete.</p><p>counter(exists, <em>vfs-ref</em>, <em>counter_name</em>)</p><p>This operation returns 1 if a counter exists, 0 otherwise.</p><p>counter(get, <em>vfs-ref</em>, <em>counter_name</em>)</p><p>This operation returns the current counter value.</p><p>counter(inc|dec, <em>vfs-ref</em>, <em>counter_name</em>[, <em>amount</em>])</p><p>This operation increments or decrements an existing counter by <em>amount</em>, which must be an integer. If <em>amount</em> is not given, 1 is used. The updated counter value is returned.</p><p>counter(decdel, <em>vfs-ref</em>, <em>counter_name</em>[, <em>amount</em>])</p><p>This operation decrements an existing counter by <em>amount</em>, which must be an integer. If <em>amount</em> is not given, 1 is used. If the resulting value is zero or negative, the counter is deleted and zero is returned. If the counter is not deleted, its updated value is returned.</p><p>counter(list, <em>vfs-ref</em>)</p><p>This operation returns a list of counters as a string, newline separated, each with its current value.</p><p>Operations that set or change the counter value return the new value.</p><p>For filestores that support locking, read-only operations obtain a shared lock while the other operations obtain an exclusive lock.</p><p>It is an error to reference a counter that does not exist unless the operation is set or exists.</p><p><strong>Note</strong></p><p>To some extent, this function is a poor substitute for a more general Perl-like <strong>tie()</strong> function. Such a function is being considered.</p><p>Modifications to counters are not atomic. Amongst other things, this means that a crash may cause counter updates to be lost.</p><p>A counter would typically be created by running \m[blue]<a href="../man1/dacsexpr.1.html"><strong>dacsexpr</strong>(1)</a></strong>\m[]\s-2\u[1]\d\s+2:</p>
<pre>
% dacsexpr -e &apos;counter(set, "dacs-kwv-fs:/usr/local/dacs/counters/logins", "EXAMPLE::EX:bob", 1)&apos;
</pre>
<p>The counter&apos;s value might then be tested in the \m[blue]<strong>revocation list</strong>\m[]\s-2\u[27]\d\s+2 or by an \m[blue]<strong>access control rule</strong>\m[]\s-2\u[28]\d\s+2, for instance:</p>
<pre>
counter(exists, "dacs-kwv-fs:/usr/local/dacs/counters/logins", ${DACS::IDENTITY})
</pre>
<p>The counter might be conditionally updated using the \m[blue]<strong>on_success()</strong>\m[]\s-2\u[29]\d\s+2 function, or the \m[blue]<strong>AUTH_SUCCESS</strong>\m[]\s-2\u[30]\d\s+2 or \m[blue]<strong>ACS_SUCCESS</strong>\m[]\s-2\u[31]\d\s+2 directives, using an expression like:</p>
<pre>
counter(decdel, "dacs-kwv-fs:/usr/local/dacs/counters/logins", ${DACS::IDENTITY})
</pre>
<p><strong>dacs_admin</strong>()</p><p>This predicate returns <strong>True</strong> if the user making a service request has any credentials that match any specified by the \m[blue]<strong>ADMIN_IDENTITY</strong>\m[]\s-2\u[32]\d\s+2 configuration directive.</p><p><strong>dacs_approval</strong>(<em>op</em>[, ...])</p><p>This function is used to create an \m[blue]<strong>approval stamp</strong>\m[]\s-2\u[33]\d\s+2 or inspect or validate one.</p><p>The following operations are available:</p><p><strong>dacs_approval</strong>(approval, <em>dacs64-approval-message</em>, <em>namespace</em>)</p><p>This operation parses the <em>dacs64-approval-message</em> (the value of <strong>DACS_APPROVAL</strong>), setting variables in <em>namespace</em>, after first \m[blue]<strong>dacs64 decoding</strong>\m[]\s-2\u[34]\d\s+2 the argument. If <em>namespace</em> exists, its contents are deleted. Variables set are: <em>j</em> (jurisdiction name), <em>h</em> (hash/digest name), <em>s</em> (stamp), <em>u</em> (URI), <em>m</em> (HTTP method), and <em>i</em> (user identity). See \m[blue]<a href="../man8/dacs_acs.8.html"><strong>dacs_acs</strong>(8)</a></strong>\m[]\s-2\u[33]\d\s+2. The signature is <em>not</em> checked. The function returns <strong>True</strong> (1) if the approval message is syntactically correct, otherwise <strong>False</strong> (0).</p><p><strong>dacs_approval</strong>(check, <em>dacs64-approval-message</em>)</p><p>The <em>dacs64-approval-message</em> is decoded and parsed, and the signature is validated. The function returns <strong>True</strong> (1) only if the signature is correct, otherwise <strong>False</strong> (0).</p><p>In the current implementation, the signature can only be validated by the jurisdiction that signed the message. This deficiency will be addressed in a future release and a web service will also supply this functionality. Ideally, for maximum convenience, availability, efficiency, and simplicity, the recipient of an approval message should be able to validate it directly if it has the appropriate public key, invoke a web service at any jurisdiction in the federation if public keys are distributed and kept current, or at the jurisdiction that signed the message.</p><p><strong>dacs_approval</strong>(create, <em>uri</em>, <em>method</em>, <em>ident</em>, <em>digest-name</em>)</p><p>Create and return a <em>dacs64-approval-message</em> (as described above and in \m[blue]<a href="../man8/dacs_acs.8.html"><strong>dacs_acs</strong>(8)</a></strong>\m[]\s-2\u[33]\d\s+2), formed from the given arguments and signed by the current jurisdiction.</p><p><strong>dacs_meta</strong>(<em>op</em>[, ...])</p><p>This function returns information associated with the current federation, current jurisdiction, or other jurisdictions in the current federation. See \m[blue]<a href="../man8/dacs_list_jurisdictions.8.html"><strong>dacs_list_jurisdictions</strong>(8)</a></strong>\m[]\s-2\u[35]\d\s+2 for additional information.</p><p>The following operations are available:</p><p><strong>dacs_meta</strong>(federation, <em>namespace</em>)</p><p>Return metadata for the current federation, setting variables in <em>namespace</em>. If <em>namespace</em> exists, its contents are deleted. Variables set are: <em>federation</em>, <em>domain</em>, <em>fed_id</em> (if available), and <em>fed_public_key</em> (if available, in PEM format).</p><p><strong>dacs_meta</strong>(jname, <em>jurisdiction-name</em>, <em>namespace</em>)</p><p>Return metadata for the jurisdiction named <em>jurisdiction-name</em> in the current federation. If <em>namespace</em> exists, its contents are deleted. Variables set are: <em>jname</em>, <em>name</em>, <em>alt_name</em>, <em>dacs_url</em>, <em>authenticates</em>, <em>prompts</em>, <em>auxiliary</em> (if available), and <em>public_key</em> (if available, in PEM format).</p><p><strong>dacs_meta</strong>(jurisdiction, <em>namespace</em>)</p><p>This is equivalent to the jname operation with <em>jurisdiction_name</em> set to the name of the current jurisdiction.</p><p><strong>dacs_meta</strong>(list_jurisdictions)</p><p>Return a newline-separated list of all jurisdiction names in the current federation. A local copy of the metadata is used.</p><p><strong>dacs_meta</strong>(update_jurisdiction, <em>jname</em> [,<em>url</em>])</p><p><em>Not implemented</em>. Intended to update the local metadata for the jurisdiction name <em>jname</em>. If <em>url</em> is absent, then the current jurisdiction must already have the correct dacs_url attribute in its entry for <em>jname</em>. If <em>url</em> is given, it is assumed to be the URL for <strong>dacs_list_jurisdictions</strong> and it is used instead of one formed from dacs_url for the jurisdiction.</p><p><strong>dacs_meta</strong>(update_jurisdictions, <em>jname</em>)</p><p><em>Not implemented</em>. Intended to update the local metadata for all of the jurisdictions. If <em>jname</em> looks like a URL (i.e., it begins with either "http" or "https", then it is assumed to be the URL for <strong>dacs_list_jurisdictions</strong> and it is used to obtain a fresh copy of the metadata; otherwise, <em>jname</em> is assumed to be a jurisdiction name for which the current jurisdiction already has a correct dacs_url attribute and metadata is retrieved from that jurisdiction.</p><p><strong>dacsauth</strong>(<em>dacsauth-flags</em>)</p><p><strong>dacsauth</strong>(<em>arg1</em>, <em>arg2</em>[, ...])</p><p>This function provides an interface to \m[blue]<a href="../man1/dacsauth.1.html"><strong>dacsauth</strong>(1)</a></strong>\m[]\s-2\u[36]\d\s+2. In the first usage, the single string argument is parsed into space or tab separated flags. Single or double quotes are allowed. In the second usage, each flag is a separate string or literal argument and is not parsed.</p><p>An alist is returned that has the following three elements:</p><p>result</p><p>An integer: 1 if authentication succeeded, 0 if it failed or was not requested, and -1 if an error occured.</p><p>identity</p><p>A string: if authentication was requested and succeeded, this is the corresponding identity, otherwise it is the empty string.</p><p>roles</p><p>A string: if roles were requested (and authentication succeeded, if requested), this is the role descriptor string, otherwise it is the empty string.</p><p><strong>Important</strong></p><p>This function should be considered experimental. Use it with caution. In version 1.4.25 and earlier, this function returned an integer value (the result).</p><p><strong>Security</strong></p><p>Like <strong>dacsauth</strong> and <strong>dacs_authenticate</strong>, if a built-in module is used to perform authentication, this function must be run by a setuid or setgid process to obtain sufficient privileges to access the required files; this is true for Unix password authentication, for example.</p><p>Examples: .sp .if n {&nbsp;.RS 4 .\} .nf &gt; dacsauth("-m unix suff -user bobo -p apassword") {"result",0,"identity","","roles",""} &gt; dacsauth("-m", "unix", "suff", "-user", "bobo", "-p", "bpassword") {"result",1,"identity","EXAMPLE::FEDROOT:bobo","roles",""} &gt; dacsauth("-r unix -DVFS=&apos;[federation_keys]dacs-fs:/usr/local/dacs/federations/federation_keys&apos; -u bobo") {"result",0,"identity","","roles","bobo,wheel,www,users"} .fi .if n {&nbsp;.RE .\} .sp</p><p><strong>dacscheck</strong>(<em>dacscheck-flags</em>)</p><p><strong>dacscheck</strong>(<em>arg1</em>, <em>arg2</em>[, ...])</p><p>This function provides an interface to \m[blue]<a href="../man1/dacscheck.1.html"><strong>dacscheck</strong>(1)</a></strong>\m[]\s-2\u[37]\d\s+2, returning 1 if access is granted, 0 if access is denied, and -1 if an error occurs. In the first usage, the single string argument is parsed into space or tab separated flags. Single or double quotes are allowed. In the second usage, each flag is a separate string or literal argument and is not parsed.</p><p><strong>Important</strong></p><p>This function should be considered experimental. Use it with caution.</p><p><strong>debug</strong>(<em>type</em>, <em>value</em>)</p><p>This function enables, disables, or adjusts the amount of debugging output produced by the interpreter. Output type <em>type</em> is set to <em>value</em>, which may be "on", "off", or a non-negative integer level (the meaning of which depends on <em>type</em>.</p><p>The following <em>type</em> names are recognized: TBD</p><p><strong>decode</strong>(<em>encoding-type</em>, <em>string</em>)</p><p>This function performs the inverse of \m[blue]<strong>encode()</strong>\m[]\s-2\u[38]\d\s+2 for the same <em>encoding-type</em>. The result is a bstring. The function will fail if its argument is not properly encoded.</p><p>For the hex encoding type, alphabetic characters may be upper case or lower case.</p><p><strong>digest</strong>(<em>msg</em>, <em>msg-len</em> [, <em>digest-name</em>])</p><p>This function computes a \m[blue]<strong>cryptographic hash</strong>\m[]\s-2\u[39]\d\s+2 of <em>msg</em> (a string or bstring). The <em>msg-len</em> is the length of <em>msg</em> in bytes; if it is 0, its length is implicitly the entire length of <em>msg</em>. The hash algorithm can be any function provided by <strong>OpenSSL</strong> and may be specified as <em>digest-name</em>, case insensitively, otherwise "sha1" is used. The list of available digest algorithms is subject to change, but is likely to include "md5" (the 128-bit \m[blue]<strong>MD5 Message-Digest Algorithm</strong>\m[]\s-2\u[40]\d\s+2), "sha" (the deprecated 160-bit SHA-0 algorithm), "sha1" (the 160-bit SHA-1 Secure Hash Algorithm), "sha224", "sha256", "sha384", and "sha512". Algorithms "sha224" (SHA-224), "sha256" (SHA-256), "sha384" (SHA-384), and "sha512" (SHA-512) (224, 256, 384, and 512 bit values, respectively) comprise SHA-2. The function value is a bstring. If cryptographic strength is not required, see \m[blue]<strong>hash()</strong>\m[]\s-2\u[41]\d\s+2.</p>
<pre>
&gt; digest("foo", 0, "md5")
"acbd18db4cc2f85cedef654fccc4a4d8"
&gt; digest("Hello, world", 0, "SHA256")
"4ae7c3b6ac0beff671efa8cf57386151c06e58ca53a78d83f36107316cec125f"
</pre>
<p><strong>encode</strong>(<em>encoding-type</em>, <em>arg</em>)</p><p>This function converts <em>arg</em>, a string or bstring, into a printable text representation that depends on <em>encoding-type</em>. Applying \m[blue]<strong>decode()</strong>\m[]\s-2\u[42]\d\s+2 with the same <em>encoding-type</em> to the output of this function will produce a value equivalent to the original <em>arg</em>. The result is a string.</p><p>Note that encoding is only a representational or formatting change. If secrecy, authentication, or verification of integrity are required, use a cryptographic method.</p><p>The following encoding types are recognized:</p><p><strong>encode</strong>(ascii85, <em>arg</em>)</p><p>This encoding, also known as \m[blue]<strong>radix-85</strong>\m[]\s-2\u[43]\d\s+2, uses nearly every printable character to obtain a compact encoding. But note that the resulting strings may be problematic in many contexts without additional encoding, which can largely defeat the reason for selecting this encoding in the first place. The start-of-data ("&lt;~") and end-of-data ("~&gt;") indicators that are sometimes used with this encoding are not included.</p>
<pre>
&gt; encode(ascii85, decode(hex, "123456789a"))
"&i&lt;X6RK"
</pre>
<p><strong>encode</strong>(cescape, <em>arg</em>)</p><p>This encoding converts its argument into a C-style escaped string. Character escape codes are used when possible, numeric escape codes are used for other non-printable characters, and all other characters map to themselves.</p>
<pre>
&gt; encode(cescape, bstring("hi&#92;0&#92;1&#92;2&#92;3&#92;012", 7))
"hi&#92;0&#92;001&#92;002&#92;003&#92;n"
</pre>
<p><strong>encode</strong>(dacs64, <em>arg</em>)</p><p>This encoding type produces a base-64 encoding of <em>arg</em> using upper- and lower-case alphabetics, digits, &apos;-&apos;, and &apos;_&apos;. It is similar to the mime encoding except that &apos;-&apos; and &apos;_&apos; are used in the encoding character set instead of &apos;+&apos; and &apos;/&apos;. This encoding is better suited for use in paths and URIs, for example, and is used extensively within <strong>DACS</strong>. It is sometimes referred to as "the dacs64 encoding" or just "dacs64" in the <strong>DACS</strong> documentation.</p>
<pre>
&gt; encode(dacs64, bstring("&#92;0&#92;0&#92;0&#92;1", 4))
"_____-"
</pre>
<p><strong>encode</strong>(hex, <em>arg</em>)</p><p>This encoding converts each byte in <em>arg</em> into a hexadecimal character pair.</p>
<pre>
&gt; encode(hex, "Hello")
"48656c6c6f"
</pre>
<p><strong>encode</strong>(mime, <em>arg</em>)</p><p>This encoding applies the MIME base-64 encoding function (\m[blue]<strong>RFC 2045</strong>\m[]\s-2\u[44]\d\s+2, Section 6.8) to its argument and returns the result.</p>
<pre>
&gt; encode(mime, bstring("&#92;0&#92;0&#92;0&#92;1", 4))
"AAAAAQ=="
</pre>
<p><strong>encode</strong>(url, <em>arg</em>)</p><p>This returns the URL-encoding of the argument (\m[blue]<strong>RFC 1738</strong>\m[]\s-2\u[45]\d\s+2, \m[blue]<strong>RFC 2396</strong>\m[]\s-2\u[46]\d\s+2 (Section 2.4), and \m[blue]<strong>RFC 3986</strong>\m[]\s-2\u[47]\d\s+2).</p>
<pre>
&gt; encode(url, bstring("a&#92;0b", 3))
"a%00b"
</pre>
<p><strong>eval</strong>(<em>expression</em>)</p><p>This function evaluates its string argument and returns the result.</p><p>The call:</p>
<pre>
&gt; eval("length(&#92;"abc&#92;")")
3
</pre>
<p><strong>exec</strong>(<em>prog</em>, <em>...</em>)</p><p>The <strong>exec</strong> function executes <em>prog</em>, waits (indefinitely) for it to terminate, and returns the program&apos;s standard output. A trailing newline in the output is deleted. Optionally, command line arguments to <em>prog</em> may be given; they are automatically converted to strings. By default, no environment variables are passed to the program; if the namespace <em>ExecEnv</em> exists, however, its contents are used as the executed program&apos;s environment variables. The exit status of <em>prog</em> is made available as the value of <em>${DACS::status}</em>. The program is executed using the \m[blue]<a href="../man3/execv.3.html"><strong>execv</strong>(3)</a></strong>\m[]\s-2\u[48]\d\s+2 function, not a command shell.</p><p>On POSIX systems, this call returns the string "1&#92;n" on Thursdays, "0&#92;n" on any other day:</p>
<pre>
&gt; exec("/bin/sh", "-c", "date | grep -c ^Thu")
"0"
</pre>

<pre>
&gt; ${ExecEnv::PATH} = "/usr/bin";
"/usr/bin"
&gt; exec("/bin/sh", "-c", "printenv");
"PATH=/usr/bin"
</pre>
<p><strong>Security</strong></p><p>The program is executed as the same user and group IDs as the <strong>DACS</strong> program that calls <strong>exec()</strong>. Take appropriate precautions to prevent unauthorized users from modifying or replacing <strong>DACS</strong> configuration files, access control rules, and so on.</p><p><strong>exit</strong>(<em>result</em>)</p><p>Equivalent to <strong>return</strong>, this function causes evaluation of the expression, block, or program being evaluated to terminate and returns <em>result</em> as the value of the expression or the program&apos;s exit status.</p><p><strong>expand</strong>(<em>string</em>)</p><p>The argument, a string, is returned with variable references expanded. An undefined variable expands to the empty string.</p>
<pre>
&gt; ${a} = 17
17
&gt; "${a}"
"17"
&gt; &apos;${a}&apos;
"${a}"
&gt; expand(&apos;${a}&apos;)
"17"
&gt; ${b} = 1999, ${c} = expand(&apos;${a}, &#92;${b}&apos;)
"17, ${b}"
&gt; expand(${c})
"17, 1999"
</pre>
<p><strong>file</strong>(<em>op</em> [,<em>arg-list</em>])</p><p>This function performs various operations on files and filenames according to <em>op</em>, which is one of the following operation names, followed by command-specific arguments. All arguments must either be strings or literal words.</p><p>file(basename, <em>string</em> [,<em>suffix</em>])</p><p>This is used to extract the last component of a pathname and is equivalent to the \m[blue]<a href="../man1/basename.1.html"><strong>basename</strong>(1)</a></strong>\m[]\s-2\u[49]\d\s+2 command. It deletes any prefix that ends with the last slash character in <em>string</em>, after first stripping trailing slashes, and a <em>suffix</em>, if present. The <em>suffix</em> is <em>not</em> stripped, however, if it is identical to the remaining characters in <em>string</em>. A non-existent suffix is ignored. The value is the resulting string.</p>
<pre>
&gt; file(basename,"/a/b/c")
"c"
&gt; file(basename,"/a/b/c.c")
"c.c"
&gt; file(basename,"/a/b/c.c", ".c")
"c"
&gt; file(basename,"/a/b/c.c", "c")
"c."
&gt; file(basename,"/a/b/c.c", "c.c")
"c.c"
&gt; file(basename,"/a/b/c.c//", "c.c")
"c.c"
</pre>
<p>file(chmod, <em>abs-mode</em>, <em>file</em>)</p><p>Change the mode of <em>file</em> to <em>abs-mode</em>, which is an absolute (octal) file mode (note, however, that <strong>DACS</strong> always set the process <strong>umask</strong> to 07).</p>
<pre>
file(chmod, "0755", "/usr/local/dacs/tmp/foofile")
</pre>
<p>file(dirname, <em>string</em>)</p><p>Equivalent to the \m[blue]<a href="../man1/dirname.1.html"><strong>dirname</strong>(1)</a></strong>\m[]\s-2\u[50]\d\s+2 command, its value is the string that remains after deleting the filename portion of <em>string</em> (a pathname), beginning with the last slash character to the end of <em>string</em>, after first stripping trailing slashes.</p>
<pre>
&gt; file(dirname,"/usr/local/dacs/bin/dacsexpr")
"/usr/local/dacs/bin"
&gt; file(dirname,"/usr/local/dacs///")
"/usr/local"
</pre>
<p>file(extension, <em>pathname</em>)</p><p>The returned value is all of the characters in <em>pathname</em> after and including the last dot in the last element. If there is no dot in the last element of <em>pathname</em>, the value is the empty string.</p>
<pre>
&gt; file(extension,"acl-myapp.0")
".0"
</pre>
<p>file(lstat, <em>fmt</em>, <em>file</em>)</p><p>This is like the \m[blue]<strong>stat</strong>\m[]\s-2\u[51]\d\s+2 operation, except in the case where the named file is a symbolic link, in which case <strong>lstat</strong> returns information about the link, while <strong>stat</strong> returns information about the file the link references.</p><p>file(mkdir, <em>directory</em> [,abs-mode])</p><p>Create <em>directory</em>. If an absolute (octal) mode is given, the new directory will have that mode (note, however, that <strong>DACS</strong> always set the process <strong>umask</strong> to 07).</p><p>file(readlink, <em>file</em>)</p><p>If <em>file</em> is a symbolic link, print its contents.</p><p>file(remove, <em>file</em>)</p><p>Remove (delete) <em>file</em>.</p><p>file(rename, <em>source-file</em>, <em>target-file</em>)</p><p>Rename (mv) <em>source-file</em> to <em>target-file</em>.</p><p>file(rmdir, <em>directory</em>)</p><p>Remove (delete) <em>directory</em>, which must be empty.</p><p>file(stat, <em>fmt</em>, <em>file</em>)</p><p>Similar to the \m[blue]<a href="../man1/stat.1.html"><strong>stat</strong>(1)</a></strong>\m[]\s-2\u[52]\d\s+2 command available on some systems, this makes the functionality of the \m[blue]<a href="../man2/stat.2.html"><strong>stat</strong>(2)</a></strong>\m[]\s-2\u[53]\d\s+2 system call available. The <em>fmt</em> argument is a \m[blue]<a href="../man3/printf.3.html"><strong>printf</strong>(3)</a></strong>\m[]\s-2\u[54]\d\s+2-type descriptor that indicates what file status information is wanted and how it is to be printed. Non-formatting characters, including &#92;n, &#92;t, and &#92;&#92;, are copied to the output verbatim.</p><p>The following format specifiers are understood:</p><p>%d</p><p>The value of <em>st_dev</em>.</p><p>%i</p><p>The value of <em>st_ino</em>.</p><p>%m</p><p>The value of <em>st_mode</em> in octal.</p><p>%M</p><p>The value of <em>st_mode</em> as text.</p><p>%l</p><p>The value of <em>st_nlink</em>.</p><p>%u</p><p>The value of <em>st_uid</em> in decimal.</p><p>%U</p><p>The value of <em>st_uid</em> as text.</p><p>%g</p><p>The value of <em>st_gid</em> in decimal.</p><p>%G</p><p>The value of <em>st_gid</em> as text.</p><p>%r</p><p>The value of <em>st_rdev</em>.</p><p>%s</p><p>The value of <em>st_size</em>.</p><p>%b</p><p>The value of <em>st_blksize</em>.</p><p>%n</p><p>The value of the <em>file</em> argument.</p><p>%N</p><p>If the argument is a symbolic link, print the contents of the link, otherwise print the <em>file</em> argument.</p><p>%ta</p><p>The value of <em>st_atime</em> in decimal.</p><p>%tA</p><p>The value of <em>st_atime</em> as text.</p><p>%tm</p><p>The value of <em>st_mtime</em> in decimal.</p><p>%tM</p><p>The value of <em>st_mtime</em> as text.</p><p>%tc</p><p>The value of <em>st_ctime</em> in decimal.</p><p>%tC</p><p>The value of <em>st_ctime</em> as text.</p><p>%f</p><p>The name of the host (fileserver) where the file is stored.</p><p>%%</p><p>A literal &apos;%&apos; character.</p><p>This excerpt from an access control rule limits access to authenticated users for every file greater than 999 bytes in length that it <strong>DACS</strong>-wraps:</p>
<pre>
&lt;allow&gt;
  user("auth")
&lt;/allow&gt;

&lt;allow&gt;
  user("any") and file(stat, "%s", ${DACS::FILENAME}) lt 1000
&lt;/allow&gt;
</pre>
<p>file(test, <em>op</em> [, <em>args</em>])</p><p>Most of the file-testing predicates of the \m[blue]<a href="../man1/test.1.html"><strong>test</strong>(1)</a></strong>\m[]\s-2\u[55]\d\s+2 command are available.</p><p><strong>-b</strong><em>file</em></p><p><strong>True</strong> if <em>file</em> exists and is a block special file.</p><p><strong>-c</strong><em>file</em></p><p><strong>True</strong> if <em>file</em> exists and is a character special file.</p><p><strong>-d</strong><em>file</em></p><p><strong>True</strong> if <em>file</em> exists and is a directory.</p><p><strong>-e</strong><em>file</em></p><p><strong>True</strong> if <em>file</em> exists, regardless of its type.</p><p><strong>-f</strong><em>file</em></p><p><strong>True</strong> if <em>file</em> exists and is a regular file.</p><p><strong>-g</strong><em>file</em></p><p><strong>True</strong> if <em>file</em> exists and its set group ID flag is set.</p><p><strong>-k</strong><em>file</em></p><p><strong>True</strong> if <em>file</em> exists and its sticky bit is set.</p><p><strong>-p</strong><em>file</em></p><p><strong>True</strong> if <em>file</em> exists and is a named pipe (FIFO).</p><p><strong>-r</strong><em>file</em></p><p><strong>True</strong> if <em>file</em> exists and is readable (access(file, R_OK) == 0).</p><p><strong>-s</strong><em>file</em></p><p><strong>True</strong> if <em>file</em> exists and has a size greater than zero bytes.</p><p><strong>-u</strong><em>file</em></p><p><strong>True</strong> if <em>file</em> exists and its set user ID flag is set.</p><p><strong>-w</strong><em>file</em></p><p><strong>True</strong> if <em>file</em> exists and is writable (access(file, W_OK) == 0).</p><p><strong>-x</strong><em>file</em></p><p><strong>True</strong> if <em>file</em> exists and is executable (access(file, X_OK) == 0).</p><p><strong>-L</strong><em>file</em></p><p><strong>True</strong> if <em>file</em> exists and is a symbolic link.</p><p><strong>-O</strong><em>file</em></p><p><strong>True</strong> if <em>file</em> exists and its owner matches the effective user id of this process.</p><p><strong>-G</strong><em>file</em></p><p><strong>True</strong> if <em>file</em> exists and its group matches the effective group id of this process.</p><p><strong>-S</strong><em>file</em></p><p><strong>True</strong> if <em>file</em> exists and is a socket.</p><p><strong>-nt</strong><em>file1</em><em>file2</em></p><p><strong>True</strong> if <em>file1</em> and <em>file2</em> exist and the former is newer than the latter.</p><p><strong>-ot</strong><em>file1</em><em>file2</em></p><p><strong>True</strong> if <em>file1</em> and <em>file2</em> exist and the former is older than the latter.</p><p><strong>-ef</strong><em>file1</em><em>file2</em></p><p><strong>True</strong> if <em>file1</em> and <em>file2</em> exist and refer to the same file.</p><p>file(touch, <em>file</em> [, <em>abs-mode</em>])</p><p>If <em>file</em> does not exist, it is created; if an absolute (octal) mode is given, the new file will have that mode (note, however, that <strong>DACS</strong> always set the process <strong>umask</strong> to 07). If the file exists, its modification time will be set to the current date and time.</p><p><strong>file_group</strong>([<em>path</em>])</p><p>Test if <em>path</em> (defaults to <em>${DACS::FILENAME}</em>, which is equivalent to Apache&apos;s <strong>SCRIPT_FILENAME</strong> or <em>REQUEST_FILENAME</em> variables) has a group ownership with which the user making the request is associated. This is effectively the same as:</p>
<pre>
file(test, "-e", ${DACS::FILENAME})
and
user("%" . ${Conf::JURISDICTION_NAME} . ":" &#92;
  . file(stat, "%G", ${DACS::FILENAME}))
</pre>
<p>This predicate provides a simple way of limiting access to a file to its group membership with respect to file system permissions:</p>
<pre>
&lt;allow&gt;
  file_group()
&lt;/allow&gt;
</pre>
<p>For example, if the user requesting access has been assigned the following roles by the current jurisdiction (e.g., through <strong>local_unix_roles</strong>):</p>
<pre>
wheel,www,users
</pre>
<p>and the resource being requested is the file:</p>
<pre>
-rw-r--r--  1 bobo     www  75 Apr 11 12:41 htdocs/foo.html
</pre>
<p>then this predicate would return <strong>True</strong> because the file has group ownership www and the user is associated with that role.</p><p>There is an implicit assumption that the file in question is associated with the current jurisdiction; this might be problematic if more than one jurisdiction can claim this association.</p><p><strong>file_owner</strong>([<em>path</em>])</p><p>Test if <em>path</em> (defaults to <em>${DACS::FILENAME}</em>, which is equivalent to Apache&apos;s <strong>SCRIPT_FILENAME</strong> or <em>REQUEST_FILENAME</em> variables) is owned by the user making the request. This is effectively the same as:</p>
<pre>
file(test, "-e", ${DACS::FILENAME})
and
user(${Conf::JURISDICTION_NAME} . ":" . file(stat, "%U", ${DACS::FILENAME}))
</pre>
<p>This predicate provides a simple way of limiting access to a file to its owner with respect to file system permissions:</p>
<pre>
&lt;allow&gt;
  file_owner()
&lt;/allow&gt;
</pre>
<p>There is an implicit assumption that the file in question is associated with the current jurisdiction; this might be problematic if more than one jurisdiction can claim this association.</p><p><strong>from</strong>(<em>string</em>)</p><p>This predicate is used to test where a request comes from, based on the values of <strong>REMOTE_ADDR</strong> and <strong>REMOTE_HOST</strong>. These environment variables are passed to <strong>DACS</strong> from <strong>Apache</strong>. The supported argument types are similar to those recognized by the <strong>Apache</strong>\m[blue]<strong>mod_access</strong>\m[]\s-2\u[56]\d\s+2 module&apos;s allow and deny directives. If either <strong>REMOTE_HOST</strong> or <strong>REMOTE_ADDR</strong> are needed to evaluate the argument but are not available, the result will be <strong>False</strong>.</p><p>The string argument may be:</p><p>a full or partially matching domain name:</p>
<pre>
from("metalogic.example.com")
</pre>
<p>Here, the function yields <strong>True</strong> if the given domain name matches <strong>REMOTE_HOST</strong> or is a subdomain of <strong>REMOTE_HOST</strong>. Case-insensitive matching is performed (\m[blue]<strong>RFC 1035</strong>\m[]\s-2\u[57]\d\s+2). Only complete components are matched, so the above example will match foo.metalogic.example.com but not foonmetalogic.example.com. If <strong>REMOTE_ADDR</strong> is available but not <strong>REMOTE_HOST</strong>, a reverse DNS lookup will be performed on the domain name and all IP addresses that result will be tested against <strong>REMOTE_ADDR</strong>; if this lookup results in an error (i.e., it fails), then the function raises an error condition.</p><p>a full IPv4 address in standard dot notation:</p>
<pre>
from("10.0.0.123")
</pre>
<p>a partial IPv4 address (the first one, two, or three bytes) in standard dot notation:</p>
<pre>
from("10.0")
</pre>
<p>a network/netmask pair:</p>
<pre>
from("10.0.0.0/255.255.0.0")
</pre>
<p>a network/nnn pair using \m[blue]<strong>CIDR notation</strong>\m[]\s-2\u[58]\d\s+2 (\m[blue]<strong>RFC 1338</strong>\m[]\s-2\u[59]\d\s+2):</p>
<pre>
from("10.0.0.0/8")
</pre>
<p>a full or partial IPv4 address in standard dot notation where any address element can be a decimal number (0 through 255) or a \m[blue]<strong>range specification</strong>\m[]\s-2\u[60]\d\s+2, similar to that used with \m[blue]<strong>strchars()</strong>\m[]\s-2\u[16]\d\s+2; note that the range separator in this context is ":" instead of "..": :</p>
<pre>
from("10.0.[0:100,255]")
</pre>
<p>In the example above, the two high-order octets of <em>${DACS::REMOTE_ADDR}</em> must be 10 and 0, the value of the next octet must be between 0 and 100 (inclusive) or be 255 (decimal), and the value of the fourth octet is unimportant. The following expressions are equivalent:</p>
<pre>
from("10")
from("10.")
from("[10]")
from("[10].")
from("10.0.0.0/8")
from("10.0.0.0/255.0.0.0")
</pre>
<p>"all" (always yields <strong>True</strong> and is included for compatibility with <strong>Apache</strong>):</p>
<pre>
from("all")
</pre>
<p>An alternative method is to perform a regular expression match against <em>${DACS::REMOTE_ADDR}</em> using \m[blue]<strong>regmatch()</strong>\m[]\s-2\u[61]\d\s+2.</p><p><strong>Tip</strong></p><p>To test where a client authenticated from, which is not necessarily the same as the place from which a request is sent, use the \m[blue]<strong>user()</strong>\m[]\s-2\u[62]\d\s+2 function.</p><p><strong>get</strong>(<em>vfs-ref</em> [,<em>key</em>])</p><p>The file or item specified by <em>vfs-ref</em>, which may be followed by a <em>key</em> if it is an indexed filestore, is read and returned. The <em>vfs-ref</em> may be an absolute pathname, an item type, or a \m[blue]<strong>vfs_uri</strong>\m[]\s-2\u[26]\d\s+2, except if called from a standalone application without a <em>key</em> argument, in which case <em>vfs-ref</em> may also be a relative pathname.</p><p><strong>Note</strong></p><p>A proper I/O subsystem does not exist yet, but until then you may use the special item type stdin to read the standard input until end of file. This function will probably not work if a special file is used (e.g., /dev/stdin).</p><p><strong>hash</strong>(<em>msg</em>, <em>msg-len</em> [,<em>hash-name</em>])</p><p>This function computes a fast hash of <em>msg</em>, a string or bstring. The <em>msg-len</em> is the length of <em>msg</em> in bytes; if it is 0, its length is computed. The <em>hash-name</em> can be the 32-bit hash "hash32" (the default) or the 64-bit hash "hash64". The result is a string. Although the algorithms have been used extensively with very good results, they should not be used for cryptographic purposes; see \m[blue]<strong>digest()</strong>\m[]\s-2\u[63]\d\s+2.</p>
<pre>
&gt; hash("Hello, world", 0)
"3696529580"
&gt; hash("Hello, world", 0, hash64)
"462009511995194717"
</pre>
<p><strong>hmac</strong>(<em>msg</em>, <em>msg-len</em>, <em>key</em>, <em>key-len</em> [, <em>digest-name</em>])</p><p>This function computes a cryptographic \m[blue]<strong>message authentication code</strong>\m[]\s-2\u[64]\d\s+2 - specifically, the \m[blue]<strong>Keyed-Hash Message Authentication Code (HMAC)</strong>\m[]\s-2\u[65]\d\s+2 - of <em>msg</em> (a string or bstring), using <em>key</em> (a string or bstring). The <em>msg-len</em> is the length of <em>msg</em> in bytes; if it is 0, its length is computed. Similarly, <em>key-len</em> is the length of <em>key</em> in bytes and if it is 0, its length is computed. Any of the available \m[blue]<strong>Secure Hash Standard functions</strong>\m[]\s-2\u[66]\d\s+2, as well as \m[blue]<strong>MD5 (RFC 2104)</strong>\m[]\s-2\u[67]\d\s+2, may be specified as <em>digest-name</em> (case insensitively), otherwise SHA1 is used. The list of available digest algorithms is subject to change, but is likely to include md5, sha1, sha224, sha256, sha384, and sha512. The function value is a bstring. Note that the function is not commutative; the key is the third argument, not the first. Although the MD5 hash function is deprecated for some purposes, it is still considered adequate in some applications and is required by many older protocols that are still in widespread use.</p>
<pre>
&gt; hmac("Sample #2", 0,
  decode(hex, "303132333435363738393a3b3c3d3e3f40414243"), 0)
"0922d3405faa3d194f82a45830737d5cc6c75d24"
</pre>
<p><strong>http</strong>(<em>url</em>, [<em>method</em> [,<em>arglist</em>]])</p><p>This function sends an HTTP request to <em>url</em>, using a given method (GET, POST, HEAD, PUT, DELETE, or OPTIONS, case insensitively), and optionally passing parameters. If no method is given (and no arguments), GET is assumed. The value of the function is the message returned by the request. The <em>url</em> is in the usual syntax and must use either the http or https scheme (case insensitive). The argument list, if present, consists of some number of pairs, the first being the name of the parameter and the second the value of the parameter.</p><p>The first statement sends an HTTP request to example.com and sets the variable to the message body (if any) that is returned. The second statement makes a GET request to port 8443 of example.com over SSL, passing it two parameters, FOO=17 and FOO=2:</p>
<pre>
&gt; ${x} = http("http://example.com")
&gt; http("https://example.com:8443/cgi-bin/dacs_prenv.cgi", "GET", "FOO", 17,
      "BAZ", 1+1)
</pre>
<p><strong>index</strong>(<em>string</em>, <em>character-class</em> [, nocase])</p><p><strong>index</strong>(<em>list</em>, <em>search_operand</em> [, nocase])</p><p>If the first argument is a string, this function returns the first position in <em>string</em> (counting from 1) where the first character in <em>character-class</em> was found, or 0. Case-sensitive character comparison is used unless the optional <em>nocase</em> literal argument is present.</p><p>If the first argument is a list, the position of element <em>search_operand</em> (counting from 1) in <em>list</em> is returned, or 0 if it is not found. During comparison, types are automatically converted as necessary. Case-sensitive character comparison is used unless the optional <em>nocase</em> literal argument is present.</p><p>Examples:</p>
<pre>
&gt; index("abcdef", "abc")
1
&gt; index("abcdef", "e")
5
&gt; index("zzz", "abc")
0
&gt; index([a, b, c, d, e], d)
4
&gt; index(["hello", world, 2009, qUAKe], "quake", nocase)
4
&gt; index([1.0, 2.2, 3.3, 4.4, 5.0, 6.6], "1")
1
&gt; index(["apple", ["orange", "banana"], ["peach", "mango"]], "orange")
0
&gt; index(["apple", ["orange", "banana"], ["peach", "mango"]], ["orange", "banana"])
2
</pre>
<p><strong>info</strong>(namespaces)</p><p><strong>info</strong>(namespace, <em>namespace-name</em>)</p><p>Return a string containing information about variables and namespaces. The first form returns a comma-separated list of known namespaces. The second form returns a list containing all variables in the given namespace and their values, one per line. This can be useful for debugging.</p><p>Examples:</p>
<pre>
info(namespaces)
info(namespace, "Conf")
</pre>
<p><strong>keysof</strong>(<em>alist</em>)</p><p>If its argument is a single pair, the pair&apos;s key is returned. If there is more than one pair in the argument, a list of keys is returned. To get the value component of a pair or set of pairs, use \m[blue]<strong>valuesof()</strong>\m[]\s-2\u[19]\d\s+2.</p><p>Examples:</p>
<pre>
&gt; keysof({red, 17})
"red"
&gt; keysof({red, 17, blue, 100})
["red", "blue"]
</pre>
<p><strong>ldap</strong>(dn_length, <em>dn-string</em>)</p><p><strong>ldap</strong>(dn_index, <em>dn-string</em>, <em>nth</em>)</p><p><strong>ldap</strong>(rdn_length, <em>rdn-string</em>)</p><p><strong>ldap</strong>(rdn_index, <em>rdn-string</em>, <em>nth</em>)</p><p><strong>ldap</strong>(rdn_attrtype, <em>rdn-string</em> [, <em>nth</em>])</p><p><strong>ldap</strong>(rdn_attrvalue, <em>rdn-string</em> [, <em>nth</em>])</p><p>The <strong>ldap</strong> function is used to extract components of LDAP names. Its first argument, a literal, determines the operation mode to be used and the semantics of the following arguments. Distinguished Name (DN) and Relative Distinguished Name (RDN) strings are as defined in \m[blue]<strong>RFC 2253</strong>\m[]\s-2\u[68]\d\s+2.</p><p>The dn_length mode returns the number of RDN components in its DN argument; -1 is returned if the argument is not a valid DN. The dn_index mode returns the <em>nth</em>RDN component of the DN, where <em>nth</em> is an integer greater than zero. If <em>nth</em> is greater than the number of components, the last component is returned.</p><p>The rdn_length mode returns the number of AttributeTypeAndValue elements in its RDN argument; -1 is returned if the argument is not a valid RDN. The rdn_index mode returns the <em>nth</em>AttributeTypeAndValue component of the RDN, where <em>nth</em> is an integer greater than zero. If <em>nth</em> is greater than the number of components, the last component is returned.</p><p>The rdn_attrtype mode returns the AttributeType of the <em>nth</em>AttributeTypeAndValue component of the RDN, where <em>nth</em> is an integer greater than zero. If <em>nth</em> is missing, it is taken to be 1. If <em>nth</em> is greater than the number of components, the last component is selected. The rdn_attrvalue mode is similar except that it returns the AttributeValue.</p><p>The first and second expressions below return 2, the third expression returns Administrator:</p>
<pre>
ldap(dn_length, "dc=example,dc=com")
ldap(rdn_length, "foo=bar+bar=baz")
ldap(rdn_attrvalue, ldap(dn_index, &#92;
    "CN=Administrator,CN=Users,DC=example,DC=com", 1))
</pre>
<p><strong>length</strong>(<em>string</em>)</p><p><strong>length</strong>(<em>bstring</em>)</p><p><strong>length</strong>(<em>list</em>)</p><p><strong>length</strong>(<em>alist</em>)</p><p>This function returns the length, in characters, of <em>string</em>, the number of bytes in binary string <em>bstring</em>, the number of elements in <em>list</em>, or the number of pairs in <em>alist</em>.</p><p><strong>list</strong>([<em>value</em> [, ...])</p><p>This function is equivalent to the \m[blue]<strong>list construction operator</strong>\m[]\s-2\u[69]\d\s+2.</p>
<pre>
list(1, 2, [hello, world], 5)
</pre>
<p>is equivalent to the expression:</p>
<pre>
[1, 2, [hello, world], 5]
</pre>
<p><strong>listref</strong>(<em>list</em>, <em>list-ref</em> [, ...])</p><p>This function provides an alternate syntax to the language&apos;s list/array notation. For example, the function call:</p>
<pre>
listref([1, 2, [3, 4], 5], 2, 1)
</pre>
<p>is equivalent to the expression:</p>
<pre>
[1, 2, [3, 4], 5][2][1]
</pre>
<p>Note that a list reference may follow a list-valued expression (e.g., a list constructor, a list-valued variable, a function that returns a list) this syntax is valid:</p>
<pre>
($a . $b)[0]
</pre>
<p>The parentheses are necessary here because the subscript binds more tightly than the concatenation operator. This expression can also be written as:</p>
<pre>
listref($a . $b, 0)
</pre>
<p><strong>on_success</strong>(<em>list-name</em> [, <em>expr</em>])</p><p>The <em>list-name</em> argument must be either acs or auth (case insensitive) to select the post-authorization list or the post-authentication list, respectively. For the former case, if authorization is successful, the <em>expr</em> argument (a string) will be evaluated by <strong>dacs_acs</strong> immediately after any \m[blue]<strong>ACS_SUCCESS</strong>\m[]\s-2\u[31]\d\s+2 directive, and just prior to program termination. These expressions are not evaluated if authorization is denied, an authorization processing error occurs, or a <em>DACS_ACS</em> argument prevents execution of the request. For the latter case, if authentication is successful, the <em>expr</em> argument (a string) will be evaluated by \m[blue]<a href="../man8/dacs_authenticate.8.html"><strong>dacs_authenticate</strong>(8)</a></strong>\m[]\s-2\u[9]\d\s+2 immediately after any \m[blue]<strong>AUTH_SUCCESS</strong>\m[]\s-2\u[30]\d\s+2 directive, and just prior to program termination. These expressions are not evaluated if authentication fails or an authentication processing error occurs.</p><p>Once added to either list, an entry cannot be removed. The expressions are evaluated in the order in which <strong>on_success()</strong> was called. The values returned by the expressions are discarded and errors are ignored.</p><p>If no <em>expr</em> is given, the current list of expressions is returned, one per line, in order of evaluation. With an expression argument, it returns the number of expressions in the list after any addition.</p><p><strong>password</strong>(<em>op</em> [, <em>op-args</em>])</p><p>This function performs a variety of read-only operations on <strong>DACS</strong> accounts and their passwords. See \m[blue]<a href="../man1/dacspasswd.1.html"><strong>dacspasswd</strong>(1)</a></strong>\m[]\s-2\u[70]\d\s+2 and directives \m[blue]<strong>PASSWORD_DIGEST</strong>\m[]\s-2\u[71]\d\s+2 and \m[blue]<strong>PASSWORD_SALT_PREFIX</strong>\m[]\s-2\u[72]\d\s+2 for additional information.</p><p>The following operations are available:</p><p><strong>password</strong>(check, <em>given-password</em>, <em>password-digest</em> [,<em>alg-name</em>])</p><p>With the check operation, the digest of <em>given-password</em> is computed (as computed by the hash operation) and compared to <em>password-digest</em>, which was previously generated by the hash operation of this function, retrieved by the getdigest operation, or obtained using <strong>dacspasswd</strong>. This algorithm is identical to the one used by \m[blue]<strong>local_passwd_authenticate</strong>\m[]\s-2\u[73]\d\s+2 to validate passwords. If <em>alg-name</em> is given, it names the digest algorithm to use instead of the one specified within <em>password-digest</em>. If <em>given-password</em> is correct (i.e., the same passwords were used to generate the two digest values), <strong>True</strong> (1) is returned, otherwise <strong>False</strong> (0) is returned.</p><p><strong>password</strong>(getdata, <em>username</em> [,<em>vfs-ref</em>])</p><p>The getdata operation returns the private data associated with the account for <em>username</em>. The result is a bstring. If there is no private data, the length of the result will be zero (the length of the empty string is one). If a <em>vfs-ref</em> is given, it identifies the virtual filestore to use, otherwise the item type passwds is used. It is an error if the account does not exist, so a test operation will often be performed first.</p><p><strong>password</strong>(getdigest, <em>username</em> [,<em>vfs-ref</em>])</p><p>The getdigest operation is similar to getdata except that the digest string for the account is returned; this digest string can be used with the check operation.</p><p><strong>password</strong>(hash, <em>plain-password</em> [,<em>alg-name</em>])</p><p>With the hash operation, a digest of the string <em>plain-password</em> is returned as a printable string. The password hashing algorithm is identical to the one used by \m[blue]<a href="../man1/dacspasswd.1.html"><strong>dacspasswd</strong>(1)</a></strong>\m[]\s-2\u[70]\d\s+2. If <em>alg-name</em> is given (see \m[blue]<strong>digest()</strong>\m[]\s-2\u[63]\d\s+2), it names the digest algorithm to use instead of the configured default.</p><p><strong>password</strong>(list [, <em>vfs-ref</em>])</p><p>The list operation returns a list of account names, one per line. An empty string is returned if there are no accounts. If a <em>vfs-ref</em> is given, it identifies the virtual filestore to use, otherwise the item type passwds is used. To test if a password file exists, use \m[blue]<strong>vfs()</strong>\m[]\s-2\u[74]\d\s+2.</p><p><strong>password</strong>(syntax, <em>password</em> [,<em>constraints</em>])</p><p>The syntax operation tests if <em>password</em> satisfies the <em>constraints</em> argument, if provided, otherwise the value of the \m[blue]<strong>PASSWORD_CONSTRAINTS</strong>\m[]\s-2\u[75]\d\s+2 directive. The <em>constraints</em> are specified in the same syntax as the PASSWORD_CONSTRAINTS directive. The function returns <strong>True</strong> (1) if the constraints are satisfied, otherwise <strong>False</strong> (0).</p><p><strong>password</strong>(test, <em>test-op</em>, <em>username</em> [,<em>vfs-ref</em>])</p><p>The test operation applies <em>test-op</em> to the account entry for <em>username</em> in the virtual filestore <em>vfs-ref</em> (or item type passwds). It is an error if the password file does not exist or is unreadable. It returns <strong>True</strong> if the test is successful, otherwise the result is <strong>False</strong>. The recognized values of <em>test-op</em> are (case insensitively): data (to test if the account exists and has private data), disabled (to test if the account exists and is disabled), enabled (to test if the account exists and is enabled), or exists (to test if the account exists).</p><p>Examples:</p>
<pre>
&gt; password(hash, "bobo")
"2|XYZZYxBhU/7VgJAt2lc.G|HL4RQ2vo0uNoXlXnv.GcY3Vlf9."
&gt; password(check, "bobo", "2|XYZZYxBhU/7VgJAt2lc.G|HL4RQ2vo0uNoXlXnv.GcY3Vlf9.")
1
</pre>
<p><strong>pathname</strong>(<em>path</em>, <em>hostname</em>, <em>port</em>)</p><p>Perform string interpolation on <em>path</em> based on the other arguments. For details, please see \m[blue]<strong>dacs.conf</strong>(5)</strong>\m[]\s-2\u[76]\d\s+2 (where <em>hostname</em> is <strong>SERVER_NAME</strong>).</p><p><strong>pbkdf2</strong>(<em>password</em>, <em>salt</em>, <em>count</em>, <em>dklen</em>)</p><p>Apply a pseudorandom function (HMAC-SHA-1) to <em>password</em> and <em>salt</em> (both binary strings, or converted as required), modified by <em>count</em> iterations, returning a binary string of length <em>dklen</em> bytes. For details, please see \m[blue]<strong>RFC 2898</strong>\m[]\s-2\u[77]\d\s+2 and \m[blue]<strong>RFC 3962</strong>\m[]\s-2\u[78]\d\s+2.</p>
<pre>
&gt; pbkdf2("password", "ATHENA.MIT.EDUraeburn", 1200, 32)
"5c08eb61fdf71e4e4ec3cf6ba1f5512ba7e52ddbc5e5142f708a31e2e62b1e13"
&gt; pbkdf2("password", decode(hex,"1234567878563412"), 5, 16)
"d1daa78615f287e6a1c8b120d7062a49"
</pre>
<p><strong>print</strong>(<em>...</em>)</p><p>Each argument is converted to a string, the strings are concatenated, a newline is appended, and the result is printed. The return type is void. If called from \m[blue]<a href="../man1/dacsexpr.1.html"><strong>dacsexpr</strong>(1)</a></strong>\m[]\s-2\u[1]\d\s+2, the string is printed to the standard output; otherwise, it is printed to the <strong>DACS</strong> log file (or stderr), which can be useful for debugging purposes. These log messages are associated with the user class (see the \m[blue]<strong>LOG_FILTER</strong>\m[]\s-2\u[79]\d\s+2 directive).</p><p><strong>printf</strong>(<em>fmt</em>, <em>...</em>)</p><p>This is a slightly scaled-down version of the \m[blue]<a href="../man3/printf.3.html"><strong>printf</strong>(3)</a></strong>\m[]\s-2\u[54]\d\s+2 library function. If called from \m[blue]<a href="../man1/dacsexpr.1.html"><strong>dacsexpr</strong>(1)</a></strong>\m[]\s-2\u[1]\d\s+2, the string is printed to the standard output; otherwise, it is printed to the <strong>DACS</strong> log file (or stderr), which can be useful for debugging purposes. These log messages are associated with the user class (see the \m[blue]<strong>LOG_FILTER</strong>\m[]\s-2\u[79]\d\s+2 directive). This can be useful for debugging purposes. If necessary and possible, arguments are converted to the type requested by a formatting specification. The return type is void.</p><p><strong>random</strong>(bytes, <em>nbytes</em>)</p><p><strong>random</strong>(uint, <em>lo</em>, <em>hi</em>)</p><p><strong>random</strong>(string, <em>nbytes</em> [, <em>spec</em>])</p><p><strong>random</strong>(stringc, <em>nbytes</em>, <em>spec</em>)</p><p>The various forms of this function, distinguished by the first argument, return \m[blue]<strong>cryptographically strong pseudo-random values</strong>\m[]\s-2\u[80]\d\s+2 in various formats. The starting point (seed value) for the pseudo-random sequence cannot be set, meaning that the sequence cannot be (intentionally) reproduced.</p><p>The bytes operation requests <em>nbytes</em> bytes of random material. The result is a bstring of that length.</p><p>The uint operation requests an unsigned random integer between <em>lo</em> and <em>hi</em> (both unsigned integers), inclusive. It is an error if <em>lo</em> is not greater than <em>hi</em>. The result is an (unsigned) integer.</p><p>The string operation requests <em>nbytes</em> of random material, returned as a hex-encoded string. If a <em>spec</em> argument is present, it uses the character specification syntax of \m[blue]<strong>strtr()</strong>\m[]\s-2\u[81]\d\s+2 to indicate the characters that can be used to encode the result. Only printable characters, excluding the space, are allowed in the result, regardless of the <em>spec</em> argument. Example:</p>
<pre>
&gt; random(string,12,"a-zA-Z0-9")
"LgROshy6SMMH"
&gt; random(string,12,"a-z")
"kehhvwydhhbk"
</pre>
<p>The functionality of the stringc operation is identical to that of the three-argument instance of the string operation except that the sense of the <em>spec</em> argument is complemented to indicate those characters that may <em>not</em> be used in the encoding of the result.</p><p><strong>redirect</strong>(<em>error-code</em>, <em>target</em>)</p><p><strong>redirect</strong>(<em>target</em>)</p><p>Permitted only within the context of an access control rule&apos;s deny clause, this function causes expression evaluation and rule processing to stop immediately, access to be denied, and the client to be redirected to <em>target</em>, a URL that may contain a query component. If the <em>error-code</em> is present, it must be an ACS error name or number (see the \m[blue]<strong>ACS_ERROR_HANDLER</strong>\m[]\s-2\u[82]\d\s+2 directive), otherwise "BY_REDIRECT" is used.</p><p><strong>Note</strong></p><p>The URL must be properly escaped if it appears within an XML document, such as an access control rule; for example, if an ampersand occurs in the query component in a context where it must be escaped, it must appear as the five characters "&amp;".</p><p>The <em>target</em> string is expected to have one of the syntaxes of the document component of <strong>Apache&apos;s</strong>\m[blue]<strong>ErrorDocument directive</strong>\m[]\s-2\u[83]\d\s+2. In essence, this function causes an ACS_ERROR_HANDLER directive to be created and triggered. The function returns the <em>target</em> string, although because of the function&apos;s run time behaviour the value cannot be used.</p><p><strong>Tip</strong></p><p>One application of this function is to create a short link, which is a relatively concise URL that acts as an "alias" for another, usually much longer URL (here, the <em>target</em>). The short link is made public. It must be <strong>DACS</strong>-wrapped; the <em>target</em> does not need to be. Any attempt to access the short link is denied by its rule, but the rule uses the <strong>redirect()</strong> function, probably with BY_SIMPLE_REDIRECT as the <em>error-code</em> (see \m[blue]<strong>dacs.conf</strong>(5)</strong>\m[]\s-2\u[82]\d\s+2), to redirect the user agent to the <em>target</em>.</p><p>The following rule demonstrates how this can be done:</p>
<pre>
&lt;acl_rule status="enabled"&gt;
 &lt;services&gt;
  &lt;service url_pattern="/id/*"/&gt;
 &lt;/services&gt;

 &lt;rule order="allow,deny"&gt;
  &lt;deny&gt;
    setvar(split, "X", ${Env::REQUEST_URI}, "/");
    ${x} = var(get, X, ${X::#} - 1);
    redirect(BY_SIMPLE_REDIRECT, "https://example.com/docs/${x}.html");
  &lt;/deny&gt;
 &lt;/rule&gt;
&lt;/acl_rule&gt;
</pre>
<p>With this rule in place, a request like:</p>
<pre>
https://example.com/id/17795821
</pre>
<p>would result in a redirect to this target:</p>
<pre>
https://example.com/docs/17795821.html
</pre>
<p>The target URL can depend on contextual elements, and it is straightforward to do things like make the target URL depend on the time of day, identity of the user, and so on. The technique can also be used with \m[blue]<strong>Rlinks</strong>\m[]\s-2\u[84]\d\s+2.</p><p>Because the rule associated with the short link can be changed at any time, this feature can be used to implement smart \m[blue]<strong>permalinks</strong>\m[]\s-2\u[85]\d\s+2.</p><p><strong>regmatch</strong>(<em>string</em>, <em>regex</em> [, <em>namespace</em>] [, nocase])</p><p>This is a pattern matching function. The first two arguments are coerced to strings, with the second one taken to be the regular expression, with a "^" (the start-of-string anchor) implicitly prepended. The <em>string</em> argument is then matched against the regular expression, which may contain subexpressions enclosed between &apos;(&apos; and &apos;)&apos; (or &apos;&#92;(&apos; and &apos;&#92;)&apos;). If the match fails, the result is 0. If the match succeeds there are several possibilities:</p><p>if there are no subexpressions in <em>regex</em>, the result is an integer that is the number of characters matched.</p><p>if there is at least one subexpression in <em>regex</em> but no <em>namespace</em> (a string argument) is given, the result is the substring of <em>string</em> that was matched by the entire regular expression.</p><p>if there is at least one subexpression in <em>regex</em> and a namespace argument is given, the result is an integer that is the number of characters matched by the entire regular expression. The value of the first matching subexpression is assigned to the variable named "<em>1</em>" in the namespace, the value of the second subexpression is assigned to a variable named "<em>2</em>" in the namespace, and so on up to the ninth subexpression. The variable named "<em>0</em>" in the namespace is assigned the substring of string that was matched by the entire regular expression. Following function evaluation in the context of ACL rule processing, <em>namespace</em> is accessible only within the predicate, allow, or deny element in which it appears.</p><p>If the optional <em>nocase</em> literal argument is given, then matching is done case-insensitively. Only one parenthesized pair can be used. IEEE Std 1003.2 ("POSIX.2") "extended" regular expressions are supported (\m[blue]<a href="../man3/regex.3.html"><strong>regex</strong>(3)</a></strong>\m[]\s-2\u[86]\d\s+2, \m[blue]<a href="../man7/re_format.7.html"><strong>re_format</strong>(7)</a></strong>\m[]\s-2\u[87]\d\s+2).</p><p>Examples:</p>
<pre>
&gt; ${X} = "abfoo"
"abfoo"
&gt; regmatch(${X}, ".*foo", nocase)
5
&gt; regmatch("abcdefgzz", "(.*)g")
"abcdefg"
&gt; regmatch("foo", "(bar)|(baz)|(foo)")
"foo"
&gt; regmatch("abcdefgzz", "ab(.*)efg(.*)", "x")
9
&gt; ${x::0}
"abcdefgzz"
&gt; ${x::1}
"cd"
&gt; ${x::2}
"zz"
&gt; $addr = "192.168.7.3"
"192.168.7.3"
&gt; regmatch($addr, "192&#92;&#92;.168&#92;&#92;.(.*)&#92;&#92;..*", "X")
11
&gt; ${X::1}
"7"
</pre>
<p><strong>regsub</strong>(<em>string</em>, <em>regex</em>, <em>replacement</em> [, nocase] [,repeat])</p><p>This function matches <em>regex</em> against <em>string</em>, like \m[blue]<strong>regmatch()</strong>\m[]\s-2\u[61]\d\s+2 does, and returns the string that results when the substitution specified by <em>replacement</em> is applied to the matched text. This is similar to the <strong>ed</strong>/<strong>vi</strong>/<strong>sed</strong> command "s/regex/replacement/" applied to <em>string</em>. If no match is found, the empty string is returned.</p><p>The optional <em>repeat</em> literal argument causes the replacement to be applied to all matches; i.e., like the <strong>ed</strong>/<strong>vi</strong>/<strong>sed</strong> command "s/regex/replacement/g".</p><p>Examples:</p>
<pre>
&gt; regsub("hello world", "world", "auggie")
"hello auggie"
&gt; regsub("hello world", "auggie", "world")
""
&gt; regsub("hello", ".*", "& &")
"hello hello"
&gt; regsub("one two three", "(.*) (.*) (.*)", "&#92;${3} &#92;${2} &#92;${1}")
"three two one"
&gt; regsub("one two three", "(.*) (.*) (.*)", &apos;${3} ${2} ${1}&apos;)
"three two one"
&gt; strtr(regsub("https://BOB.Example.com",
    "&#92;([^:]*&#92;)://&#92;([^.]*&#92;)&#92;&#92;.&#92;(.*&#92;)", &apos;${1}-${2}@${3}&apos;),
      "A-Z", "a-z")
"https-bob@example.com"
&gt; regsub("one, bone, cone, hone", "one", "two", repeat)
"two, btwo, ctwo, htwo"
</pre>
<p><strong>request_match</strong>(<em>uri-string</em>)</p><p>This function is used to inspect the current request. The argument is either a valid URI or a path component that begins with a slash. In the latter case, the scheme and authority components of the current request are effectively prepended to the given path. The path component is like the <em>url_pattern</em> attribute used in \m[blue]<strong>access control rules</strong>\m[]\s-2\u[88]\d\s+2 in that it can either specify an exact match or, by ending in "/*", a wildcard match. A query component is allowed but ignored. The function returns 0 if <em>uri-string</em> does not match the current request, otherwise it returns the number of path components of <em>uri-string</em> that match the current request. If the scheme and authority components are given in <em>uri-string</em>, they count as one naming component.</p><p>Assuming that the current request is http://example.com:18123/a/b/c, we get:</p>
<pre>
&gt; request_match("http://example.com:18123/a/b/c")
4
&gt; request_match("https://example.com:18123/a/b/c")
0
&gt; request_match("http://example.com:18123/a/b/c/d")
0
&gt; request_match("http://example.com:18123/a/b")
0
&gt; request_match("http://example.com:18123/a/b/*")
4
&gt; request_match("http://example.com:18123/*")
2
&gt; request_match("http://example.com:18123")
0
&gt; request_match("http://example.com")
0
&gt; request_match("http://example.com/*")
2
&gt; request_match("/*")
1
&gt; request_match("/a/b/c")
3
&gt; request_match("/a/b/*")
3
&gt; request_match("/")
0
</pre>
<p><strong>return</strong>(<em>result</em>)</p><p>Equivalent to <strong>exit</strong>, this function causes evaluation of the expression to terminate and returns <em>result</em> as the value of the expression.</p><p><strong>rule</strong>(<em>object</em>, <em>ruleset_vfs</em>)</p><p>The <strong>rule</strong> predicate is an interface to the <strong>DACS</strong> rule processing engine. It is used to test if the rule set <em>ruleset_vfs</em> authorizes <em>object</em>, much as \m[blue]<a href="../man1/dacscheck.1.html"><strong>dacscheck</strong>(1)</a></strong>\m[]\s-2\u[37]\d\s+2 does. The <em>object</em> argument is the name to match against the services specified in access control rules and can either be a URI or an absolute pathname (one that begins with a slash character). It can have an optional query string component attached. An absolute pathname <em>path</em> is mapped internally to a URI as file://<em>path</em>; e.g., /myapp is interpreted as file:///myapp (see \m[blue]<strong>RFC 1738</strong>\m[]\s-2\u[45]\d\s+2).</p><p>One application of this predicate is for a rule associated with a program to check that the user requesting access is entitled to use a data file needed by the program.</p><p><strong>Note</strong></p><p>Only the <em>path</em> component of the URI is considered when <strong>DACS</strong> matches an object&apos;s name against the url_pattern of an access control rule. At present, the object name is not automatically canonicalized or resolved (see \m[blue]<strong>RFC 3986</strong>\m[]\s-2\u[47]\d\s+2), as is usually done by a web server, so relative path components such as "." and ".." should be avoided.</p><p>The <em>ruleset_vfs</em> is a URI in the syntax of the \m[blue]<strong>VFS</strong>\m[]\s-2\u[26]\d\s+2 configuration directive.</p><p>The various components of the URI that names the object are available as <strong>DACS</strong> variables and environment variables (see below). If a query string is given, it is parsed and the individual arguments are made available to rules through the <em>Args</em> namespace, just as for <strong>DACS</strong>-wrapped web services.</p><p>Many variables normally set by a web server are instantiated based on the object name and the execution environment. These variables are available in the <em>DACS</em> namespace. For example, if the object name is https://example.com:8443/myapp/edit-menu?entry=item1, the following variables will be set as indicated:</p>
<pre>
${DACS::HTTPS}=on
${DACS::SERVER_NAME}=example.com
${DACS::SERVER_ADDR}=142.179.101.118
${DACS::HTTP_HOST}=example.com:8443
${DACS::SERVER_PORT}=8443
${DACS::REQUEST_URI}=/myapp/edit-menu
${DACS::DOCUMENT_ROOT}=/
${DACS::REQUEST_METHOD}=GET
${DACS::SERVER_SOFTWARE}=dacsexpr-1.4.14
${DACS::QUERY_STRING}=entry=item1
${DACS::ARG_COUNT}=1
${DACS::CURRENT_URI}=/myapp/edit-menu?entry=item1
${DACS::CURRENT_URI_NO_QUERY}=/myapp/edit-menu
</pre>
<p>The value of <em>${Args::entry}</em> will be item1. The request method is always GET. The variable <em>${DACS::REMOTE_USER}</em> will be set if credentials are available in the execution environment.</p><p>For example, assuming that the file /usr/local/exams/acls/acl-exams.17 contains:</p>
<pre>
&lt;acl_rule status="enabled"&gt;
  &lt;services&gt;
    &lt;service url_pattern="/exam1.html"/&gt;
  &lt;/services&gt;

  &lt;rule order="allow,deny"&gt;
    &lt;precondition&gt;&lt;predicate&gt;
      ${Args::user} eq "teacher"
    &lt;/predicate&gt;&lt;/precondition&gt;

    &lt;allow&gt;
      time(hour) eq 17
    &lt;/allow&gt;
  &lt;/rule&gt;
&lt;/acl_rule&gt;
</pre>
<p>The following call would only return <strong>True</strong> (<strong>1</strong>) any day between 5:00pm and 5:59pm:</p>
<pre>
rule("/exam1.html?user=teacher", "dacs-fs:/usr/local/exams/acls");
</pre>
<p><strong>Note</strong></p><p>Since any rule can call the <strong>rule</strong> function, take care to avoid infinite recursion.</p><p>Although this function is similar in concept to the \m[blue]<a href="../man1/dacscheck.1.html"><strong>dacscheck</strong>(1)</a></strong>\m[]\s-2\u[37]\d\s+2 command, there are some significant differences, particularly with respect to the context available during rule evaluation.</p><p>The <em>Env</em> namespace is not reinitialized or altered during evaluation of rules processed by <strong>rule</strong>. That is, the <em>Env</em> namespace is the same as the outer-most one.</p><p><strong>setvar</strong>(<em>op</em>, <em>dst-namespace</em> [, <em>args</em> ...])</p><p>This function, which performs various operations on namespaces, has several different syntaxes. The first argument always specifies the operation (case insensitively) and determines the meaning of the arguments that follow it. The second argument always specifies a namespace that is created or modified. If successful, the function returns the number of variables created (or replaced) in <em>dst-namespace</em>.</p><p>The <em>dst-namespace</em> cannot be a \m[blue]<strong>read-only namespace</strong>\m[]\s-2\u[89]\d\s+2. Unless otherwise specified, if <em>dst-namespace</em> exists, variables are added to it, with any existing variable assigned its new value.</p><p>The following operations are recognized:</p><p><strong>setvar</strong>(authorization, <em>dst-namespace</em>, <em>auth-str</em>)</p><p>The <em>auth-str</em> argument, which is the value of an Authorization HTTP request header, is parsed into its component fields and assigned to variables in the destination namespace <em>dst-namespace</em>. If <em>dst-namespace</em> exists, its contents are deleted first. Corresponding to the field names used in \m[blue]<strong>RFC 2617</strong>\m[]\s-2\u[90]\d\s+2 Section 3.2.2, the following variables are created: <em>AUTH_SCHEME</em>, <em>USERNAME</em>, <em>PASSWORD</em>, <em>REALM</em>, <em>NONCE</em>, <em>DIGEST_URI</em>, <em>RESPONSE</em>, <em>ALGORITHM</em>, <em>CNONCE</em>, <em>OPAQUE</em>, <em>MESSAGE_QOP</em>, <em>NONCE_COUNT</em>, and <em>AUTH_PARAM</em>. Any variable that corresponds to a non-existent field is assigned the empty string.</p><p>The following call sets <em>${Foo::AUTH_SCHEME}</em> to Basic, <em>${Foo::USERNAME}</em> to Bobo, and <em>${Foo::PASSWORD}</em> to myPassWord.</p>
<pre>
setvar(authorization, Foo, "Basic Qm9ibzpteVBhc3NXb3Jk")
</pre>
<p><strong>setvar</strong>(copy, <em>dst-namespace</em>, <em>src-namespace</em>)</p><p>With the copy operation, all variables in an existing namespace <em>src-namespace</em> are copied to <em>dst-namespace</em>. If the latter exists, its contents are deleted, otherwise the namespace is created.</p><p><strong>setvar</strong>(delete, <em>dst-namespace</em>)</p><p>The delete operation is used to delete <em>dst-namespace</em> and its contents.</p><p><strong>setvar</strong>(kwv, <em>dst-namespace</em>, <em>assign-char</em>, <em>sep-chars</em>, <em>string</em>)</p><p>For the kwv operation, <em>string</em> is parsed, creating (or replacing) variables in <em>dst-namespace</em>. The <em>string</em> consists of zero or more keyword/value pairs. The keyword, which is used as the variable name, is separated by the value by the character <em>assign-char</em>. A keyword/value pair is separated from the next by any character that appears in <em>sep-chars</em>. Here is an example:</p>
<pre>
setvar(kwv, "Foo", "=", ", ", "a=b, c=d, e=f")
</pre>
<p>The value of this call is 3 and it sets <em>${Foo::a}</em> to "b", <em>${Foo::c}</em> to "d", and <em>${Foo::e}</em> to "f".</p><p><strong>setvar</strong>(load, <em>dst-namespace</em>, <em>filename</em>)</p><p><strong>setvar</strong>(load, <em>dst-namespace</em>, <em>item_type</em>, <em>key</em>)</p><p><strong>setvar</strong>(load, <em>dst-namespace</em>, <em>vfs-ref</em>, <em>key</em>)</p><p>The contents of a text object, which can be specified using a filename, as an <em>item_type</em>, or using a <em>vfs-ref</em> (see \m[blue]<strong>vfs()</strong>\m[]\s-2\u[74]\d\s+2), is split into newline separated lines. The first line is assigned index 0 in <em>dst-namespace</em>, the second index 1, and so on.</p><p>Consider the following example:</p>
<pre>
&gt; setvar(load, PASSWD, "/etc/passwd")
25
&gt; ${PASSWD::2}
"root:*:0:0:Charlie &amp;:/root:/bin/csh"
</pre>
<p>Here, there are 25 lines in /etc/passwd and the third line is printed.</p><p><strong>setvar</strong>(loadi, <em>dst-namespace</em>, <em>vfs-ref</em>)</p><p>Each item in the indexed text object specified by <em>vfs-ref</em> (an absolute pathname, an item type, or a \m[blue]<strong>VFS URI</strong>\m[]\s-2\u[26]\d\s+2) is copied to <em>dst-namespace</em>, with the same index. The index must be a valid <em>variable-name</em>.</p>
<pre>
&gt; setvar(loadi, PASSWD, "dacs-kwv-fs:/etc/passwd")
23
&gt; ${PASSWD::root}
"*:0:0:Charlie &amp;:/root:/bin/csh"
&gt; ${PASSWD::bobo}
"bobo:*:1001:1001:Bobo &amp;:/home/bobo:/bin/tcsh"
</pre>
<p>Here, 23 items are copied into the <em>PASSWD</em> namespace (the first two lines in this particular /etc/passwd are ignored because they are comments that are not recognized as items). The lines indexed by the keys root and bobo are printed.</p><p><strong>setvar</strong>(merge, <em>dst-namespace</em>, <em>src-namespace</em>)</p><p>The merge operation is similar to \m[blue]<strong>copy</strong>\m[]\s-2\u[91]\d\s+2 except that if <em>dst-namespace</em> exists its contents are not deleted.</p><p><strong>setvar</strong>(post, <em>dst-namespace</em> [, <em>content-type</em>, <em>string</em>])</p><p>Like \m[blue]<strong>query</strong>\m[]\s-2\u[92]\d\s+2, this operation parses its input into arguments in <em>dst-namespace</em>. The function reads its standard input, unless a <em>string</em> argument is given. The input is expected to be a correctly formatted application/x-www-form-urlencoded or multipart/form-data content type. If the standard input is read, both the <em>CONTENT_TYPE</em> and <em>CONTENT_LENGTH</em> environment variables must be set (as they are when Apache runs a script that is passed an entity-body).</p><p>The form that takes <em>string</em> is not yet implemented.</p><p><strong>setvar</strong>(query, <em>dst-namespace</em>, <em>query-string</em>)</p><p>For the query operation, <em>query-string</em> is parsed, creating variables in <em>dst-namespace</em>. This uses the same parsing algorithm employed by \m[blue]<a href="../man8/cgiparse.8.html"><strong>cgiparse</strong>(8)</a></strong>\m[]\s-2\u[93]\d\s+2. In the case of a malformed query string, like "a&b", variables will be created but will have the empty string as their value. If successful, the function returns the number of variables created. The following call returns 3 and sets <em>${Foo::a}</em> to "b", <em>${Foo::c}</em> to "d", and <em>${Foo::e}</em> to "f":</p>
<pre>
setvar(query, "Foo", "a=b&c=d&e=f")
</pre>
<p>One application of this function it to distinguish query arguments (which are part of the requested resource&apos;s URI and made available through the environment variable <strong>QUERY_STRING</strong>) from arguments supplied in the body of a POST method (or other such method). For example:</p>
<pre>
setvar(query, "Qargs", "${Env::QUERY_STRING}")
if (${Qargs::foo:e}) {
    /* "foo" is a query argument */
}
else {
    /* "foo" is not a query argument */
}

if (${Args::foo:e} and not ${Qargs::foo:e}) {
    /* "foo" is a POST argument */
}
else {
    /* "foo" is not a POST argument */
}
</pre>
<p><strong>setvar</strong>(regsplit, <em>dst-namespace</em>, <em>string</em>, <em>delimiter-regex</em> [,<em>limit</em>])</p><p>The regsplit operation is similar to \m[blue]<strong>split</strong>\m[]\s-2\u[94]\d\s+2 except that substrings are separated by the regular expression <em>delimiter-regex</em>. IEEE Std 1003.2 ("POSIX.2") "extended" regular expressions are used (\m[blue]<a href="../man3/regex.3.html"><strong>regex</strong>(3)</a></strong>\m[]\s-2\u[86]\d\s+2).</p><p><strong>setvar</strong>(rename, <em>dst-namespace</em>, <em>src-namespace</em>)</p><p>The rename operation deletes <em>dst-namespace</em>, if it exists, and changes the name of <em>src-namespace</em> to <em>dst-namespace</em>. The two namespace arguments must be different.</p><p><strong>setvar</strong>(split, <em>dst-namespace</em>, <em>string</em>, <em>delimiter</em> [,<em>limit</em> [,<em>dflag</em>]])</p><p>The split operation extracts substrings from <em>string</em>. Substrings are separated by the string <em>delimiter</em>. For example, this call separates a composite role string into individual basic roles:</p>
<pre>
setvar(split, "ROLES", ${DACS::ROLES}, ",")
</pre>
<p>If the variable reference <em>${DACS::ROLES}</em> has the value "root,wheel,www,users", then the example would return 4 and set <em>${ROLES::0}</em> to "root", <em>${ROLES::1}</em> to "wheel", and so on.</p><p>If a <em>limit</em> is given, it is an integer that specifies the maximum number of substrings to extract. Once the maximum has been reached, the remainder of <em>string</em> that has not been split will be assigned to the last element. A <em>limit</em> of zero is equivalent to the default, which is for there to be no maximum. For instance, setvar(split, X, "a,b,c,d", ",", 2) will assign "a" to <em>${X::0}</em> and "b,c,d" to <em>${X::1}</em>.</p><p>Here is another example:</p>
<pre>
&gt; setvar(split, "X", "a&#92;nb&#92;nc&#92;n", "&#92;n")
"3"
&gt; ${X::0}
"a"
&gt; ${X::#}
"3"
</pre>
<p>This function can be used to break a pathname into its individual components. For instance, the following call results in <em>${X::0}</em> set to the empty string, <em>${X::1}</em> set to "a", <em>${X::2}</em> set to "long", and <em>${X::3}</em> set to "path":</p>
<pre>
&gt; setvar(split, "X", "/a/long/path", "/")
4
</pre>
<p>(You may need to first remove redundant slashes in <em>string</em> using \m[blue]<strong>strtr()</strong>\m[]\s-2\u[81]\d\s+2.)</p><p>A <em>dflag</em> argument may follow the <em>limit</em> argument to indicate whether <em>delimiter</em> should not be included in substrings (<em>dflag</em> == 0, which is the default behavior), whether it should be included at the start of substrings with the possible exception of the first one (<em>dflag</em> &gt; 0), or whether it should be included at the end of substrings with the possible exception of the last one (<em>dflag</em> &lt; 0).</p>
<pre>
&gt; setvar(split, P, "/a/long/path", "/", 0, 1)
3
&gt; ${P::0}
"/a"
&gt; ${P::1}
"/long"
&gt; ${P::2}
"/path"
&gt; setvar(split, P, "/a/long/path", "/", 0, -1)
4
&gt; ${P::0}
"/"
&gt; ${P::1}
"a/"
&gt; ${P::2}
"long/"
&gt; ${P::3}
"path"
</pre>
<p><strong>setvar</strong>(uri, <em>dst-namespace</em>, <em>uri</em>)</p><p>The given <em>uri</em>, a URI conforming to \m[blue]<strong>RFC 2396</strong>\m[]\s-2\u[46]\d\s+2 or \m[blue]<strong>RFC 3986</strong>\m[]\s-2\u[47]\d\s+2, is parsed into its components. Variables in <em>dst-namespace</em> are set accordingly: <em>SCHEME</em> (mapped to lower case), <em>HOST</em> (mapped to lower case), <em>AUTHORITY</em>, <em>PORT</em>, <em>SERVER</em>, <em>USERINFO</em>, <em>PATH</em>, <em>QUERY</em>, and <em>FRAGMENT</em>. If a component is absent from <em>uri</em>, the corresponding variable will not be defined.</p><p><strong>Security</strong></p><p>It is possible for <em>USERINFO</em> to include a plaintext password.</p><p>In addition, the URI&apos;s path component is split into its slash-delimited pieces. The variable <em>PATH_LENGTH</em> is set to the number of such pieces (it will be zero if there are none), and variables <em>PATH_0</em>, <em>PATH_1</em>, and so on are set to the first, second, and successive pieces. An "empty" path component is treated as a piece consisting of the empty string.</p>
<pre>
&gt; setvar(uri, "X", "https://bar@foo.example.com:8443/cgi-bin/prog?a=17")
11
&gt; info(namespace,X)
"SCHEME="https"
AUTHORITY="bar@foo.example.com:8443"
HOST="foo.example.com"
PORT="8443"
SERVER="foo.example.com:8443"
USERINFO="bar"
PATH="/cgi-bin/prog"
PATH_COUNT="2"
PATH_0="cgi-bin"
PATH_1="prog"
QUERY="a=17"
"
</pre>
<p><strong>sizeof</strong>(<em>typename</em>)</p><p>This function returns the amount of memory in bytes, as an integer, used by <em>typename</em>, the name of a \m[blue]<strong>basic data type</strong>\m[]\s-2\u[21]\d\s+2. For the string and binary types, the returned value is the number of bytes used by each element of that type (1, typically). To find the number of elements in string or binary data, use \m[blue]<strong>length()</strong>\m[]\s-2\u[15]\d\s+2.</p>
<pre>
&gt; sizeof(real)
8
</pre>
<p><strong>sleep</strong>(<em>seconds</em>)</p><p>The process is suspended for approximately <em>seconds</em> seconds, or until a signal is received and caught or the process terminated. It returns the "unslept" number of seconds, which will be zero if the process slept for the requested interval. This is an interface to \m[blue]<a href="../man3/sleep.3.html"><strong>sleep</strong>(3)</a></strong>\m[]\s-2\u[95]\d\s+2. It can be useful for inserting delays in conjunction with error handlers, for instance.</p><p><strong>source</strong>(<em>vfs-ref</em> [,<em>key</em>])</p><p>The expressions in the file or item specified by <em>vfs-ref</em>, which may be followed by a <em>key</em> if it is an indexed filestore, are read and evaluated as a block. The <em>vfs-ref</em> can be an absolute pathname, an item type, or a \m[blue]<strong>VFS URI</strong>\m[]\s-2\u[26]\d\s+2. The value returned is that of the evaluated block. The following two expressions are essentially equivalent:</p>
<pre>
source("/usr/local/dacs/scripts/script17")
eval(get("/usr/local/dacs/scripts/script17"))
</pre>
<p>This function is handy when a lengthy expression is needed but one does not want to clutter a configuration file or a rule.</p><p><strong>sprintf</strong>(<em>fmt</em>, <em>...</em>)</p><p>This is a slightly scaled-down version of the \m[blue]<a href="../man3/sprintf.3.html"><strong>sprintf</strong>(3)</a></strong>\m[]\s-2\u[96]\d\s+2 library function. If necessary and possible, arguments are converted to the type requested by a formatting specification. The formatted string is returned.</p>
<pre>
${a} = sprintf("Hello") . ", world."
"Hello, world."
length(sprintf("Hello") . ", world.")
13
</pre>
<p><strong>strchars</strong>(<em>str</em>, <em>range-spec</em> [,...])</p><p>This function returns a new string by selecting characters from <em>str</em> according to a sequence of one or more range specifications (each one a <em>range-spec</em>). A <em>range-spec</em> is a string argument that determines the indexes of characters to select within <em>str</em>. Indexes start at zero. The result of each successive range specification is appended to the previous result.</p><p>A <em>range-spec</em> is an unordered set of one or more comma-separated elements, each of which is either an <em>index</em> or a <em>range</em>. An <em>index</em> may either be a non-negative integer or "#", which means "all indexes". A <em>range</em> represents a sequence of indexes and has the syntax:</p>
<pre>
<em>range-start</em> ".." <em>range-end</em>
</pre>
<p>A <em>range-start</em> may be a non-negative integer, the character "#" (which means "from the beginning"), or may be elided (also meaning "from the beginning"). A <em>range-end</em> may be a non-negative integer (not less than <em>range-start</em>, if it is also a non-negative integer), the character "#" (which means "to the end"), or may be omitted (also meaning "to the end").</p>
<pre>
&gt; $a = "abcdef"
"abcdef"
&gt; strchars($a, 2)
"c"
&gt; strchars($a, "1..4", "0")
"bcdea"
&gt; strchars($a . $a, "5..#")
"fabcdef"
&gt; strchars($a, "#")
"abcdef"
&gt; strchars($a, "#..#")
"abcdef"
&gt; strchars($a, "#..3")
"abcd"
&gt; strchars($a, "..3")
"abcd"
&gt; strchars($a, "..3", "#")
"abcdabcdef"
</pre>
<p><strong>strchop</strong>(<em>str</em>, <em>del-spec</em>)</p><p>This function deletes from the end of <em>str</em> a continuous run of any characters in <em>del-spec</em>.</p>
<pre>
&gt; strchop("foo4.859", ".56789")
"foo4"
&gt; strchop("foo7.859", ".5679")
"foo7.8"
&gt; strchop("hello    ", " ")
"hello"
&gt; strchop("dogs rule&#92;n&#92;n", "&#92;n")
"dogs rule"
</pre>
<p><strong>strftime</strong>(<em>format</em>)</p><p>This function is an interface to the \m[blue]<a href="../man3/strftime.3.html"><strong>strftime</strong>(3)</a></strong>\m[]\s-2\u[97]\d\s+2 function. It is applied to the current date and time.</p><p><strong>strptime</strong>(<em>date-str</em>, <em>date-format</em>, <em>namespace</em>)</p><p><strong>strptime</strong>(<em>namespace</em>)</p><p>This function is an interface to the \m[blue]<a href="../man3/strptime.3.html"><strong>strptime</strong>(3)</a></strong>\m[]\s-2\u[98]\d\s+2 function. The <em>date-str</em> argument is a string representation of a date and/or time, with <em>date-format</em> describing its syntax. If the parse of <em>date-str</em> succeeds, the following elements of <em>namespace</em> are set from the corresponding fields of struct tm: <em>tm_sec</em>, <em>tm_min</em>, <em>tm_hour</em>, <em>tm_mday</em>, <em>tm_mon</em>, <em>tm_year</em>, <em>tm_wday</em>, <em>tm_yday</em>, <em>tm_isdst</em>, <em>tm_zone</em>, and <em>tm_gmtoff</em>. Additionally, a variable named <em>clock</em> is set to the Unix time that corresponds to the parsed date and time. Any existing elements of <em>namespace</em> are not modified. If <em>date-str</em> does not fully describe a date and time, it is taken to be relative to the current date and time (e.g., if only a time is given, "today&apos;s date" is used).</p><p>In the single-argument usage, the current date and time are parsed and <em>namespace</em> is assigned values as previously described.</p><p>The return value is the "Unix time" equivalent of the resulting time and date.</p>
<pre>
&gt; strptime("6 Dec 2001 12:33:45", "%d %b %Y %H:%M:%S", tm)
1007670825
&gt; "${tm::tm_mon} ${tm::tm_mday} ${tm::tm_hour} ${tm::tm_min}"
"11 6 12 33"
&gt; ${tm::clock}
1007670825
</pre>
<p><strong>strrstr</strong>(<em>string</em>, <em>substring</em> [, nocase])</p><p>Return the start of the last occurrence of <em>substring</em> within <em>string</em>. The empty string is returned if <em>string</em> is empty or if no occurrence of <em>substring</em> is found. If <em>substring</em> is empty, <em>string</em> is returned. The optional <em>nocase</em> literal argument requests case-insensitive comparison.</p>
<pre>
&gt; strrstr("afoofoofooz", "foo")
"fooz"
&gt; strrstr("afOOfoofooz", "FooF", nocase)
"foofooz"
&gt; strrstr("afOOfoofooz", "ofoo",nocase)
"ofooz"
</pre>
<p><strong>strstr</strong>(<em>string</em>, <em>substring</em> [, nocase])</p><p>Return the start of the first occurrence of <em>substring</em> within <em>string</em>. The empty string is returned if <em>string</em> is empty or if no occurrence of <em>substring</em> is found. If <em>substring</em> is empty, <em>string</em> is returned. The optional <em>nocase</em> literal argument requests case-insensitive comparison.</p>
<pre>
&gt; strstr("foobazbar", "baz")
"bazbar"
&gt; strstr("foobazbar", "")
"foobazbar"
&gt; strstr("foobazbar", "zzz")
""
&gt; strstr("", "zzz")
""
&gt; strstr("afoofoofooz", "foo")
"foofoofooz"
&gt; strstr("fooZbar", "Ozb", nocase)
"oZbar"
</pre>
<p><strong>strtolower</strong>(<em>string</em>)</p><p>A new string is returned where each uppercase character in <em>string</em> is mapped to lowercase and all other characters are mapped to themselves. These two expressions are equivalent and have the value "hello, world 2008":</p>
<pre>
strtolower("Hello, World 2008")
strtr("Hello, World 2008", "A-Z", "a-z")
</pre>
<p><strong>strtoupper</strong>(<em>string</em>)</p><p>A new string is returned where each lowercase character in <em>string</em> is mapped to uppercase and all other characters are mapped to themselves. These two expressions are equivalent and have the value "HELLO, WORLD 2008":</p>
<pre>
strtoupper("Hello, World 2008")
strtr("Hello, World 2008", "a-z", "A-Z")
</pre>
<p><strong>strtr</strong>(<em>input-string</em>, <em>string1</em>, [<em>string2</em> [,cds]])</p><p>This function performs string transliteration, like the \m[blue]<strong>tr(1)</strong>\m[]\s-2\u[99]\d\s+2 command and <strong>Perl</strong>&apos;s tr and y operators. The result is the transliterated string. The first argument is the input string to be transliterated (stdin in the <strong>tr</strong> command). The second argument is the search list ("string1" in the <strong>tr</strong> command). The third argument is the (possibly empty) replacement list ("string2" in the <strong>tr</strong> command); it may be omitted if no flag string argument follows.</p><p>The fourth, optional argument is a literal flag string made of the characters &apos;c&apos;, &apos;d&apos;, and &apos;s&apos; (in any order), which correspond to the flags of the same name in the <strong>tr</strong> command:</p><p><strong>c</strong></p><p>Complement the set of values in <em>string1</em>.</p><p><strong>d</strong></p><p>Delete characters in <em>string1</em> from the input string.</p><p><strong>s</strong></p><p>Squeeze multiple occurrences of the characters listed in the last operand (either <em>string1</em> or <em>string2</em>) in the input into a single instance of the character. This occurs after all deletion and translation is completed.</p>
<pre>
&gt; strtr("AbCdEf", "A-Z", "a-z")
"abcdef"
&gt; strtr("/a//b///c", "/", "", "s")
"/a/b/c"
</pre>
<p><strong>subset</strong>(<em>format</em>, <em>purported-subset</em>, <em>superset</em> [, nocase])</p><p>This function returns <strong>True</strong> if every element of the purported-subset appears in superset. The <em>format</em> indicates how to parse the set arguments. It can be the space, tab, or newline character, or any punctuation character. It is currently interpreted as the character that separates elements. If the optional nocase literal argument is given, then set elements are compared case-insensitively.</p><p>Example:</p>
<pre>
subset(",", ${Args::LAYERS:i}, "RELIEF:Foundation,GTOPO30:Foundation")
</pre>
<p>This call returns <strong>True</strong> if every element of the LAYERS parameter (case insensitive) appears in the given list, otherwise the expression is <strong>False</strong>.</p><p><strong>substr</strong>(<em>string</em>, <em>start-position</em>, <em>length</em>)</p><p>This function returns the substring of <em>string</em> beginning at <em>start-position</em> with length at most <em>length</em> characters. The first character is in position one. If <em>start-position</em> is negative, the position is relative to the end of <em>string</em> (-1 specifies the last character in <em>string</em>). If the effective starting position is outside of <em>string</em>, an empty string is returned. If <em>length</em> is negative, it means "the remainder of the string". It is an error if either numeric argument is zero. It is not an error if <em>length</em> exceeds the actual number of characters returned.</p>
<pre>
&gt; substr("foozle", 3, 4)
"ozle"
&gt; substr("foobar", -3, 2)
"ba"
&gt; substr("foobar", -5, -1)
"oobar"
&gt; substr("foobar", 10, -1)
""
&gt; substr("foobar", -10, 3)
""
</pre>
<p><strong>syntax</strong>(<em>type</em>, <em>name</em> [, <em>flag</em>])</p><p>This function performs a syntax test, specified by <em>type</em>, on <em>name</em>. It returns 0 if the test fails, 1 or a <em>type</em>-dependent, non-zero value if the test is successful. It can be useful for testing, catching errors, recognizing when a string must be mapped, and for learning about <strong>DACS</strong>. Note that these are purely syntactical checks. They do not test whether an object called <em>name</em> exists or is configured.</p><p>The following tests are recognized:</p><p><strong>syntax</strong>(charset, <em>name</em>, <em>charset_spec</em>)</p><p>Test if each of the characters in <em>name</em> is specified by <em>charset_spec</em>, which is a character set specification as used by \m[blue]<strong>strtr()</strong>\m[]\s-2\u[81]\d\s+2 ("the search list").</p><p><strong>syntax</strong>(dacsname, <em>name</em>)</p><p>Test if <em>name</em> is valid as a \m[blue]<strong></strong><strong>DACS</strong> name\m[]\s-2\u[100]\d\s+2. If the string is recognized, one of the following values is returned to classify it:</p><p>1 if it is a <strong>DACS</strong> identity</p><p>2 if it is a group name</p><p>3 if it is a jurisdiction name</p><p>4 if it is a federation name</p><p>5 if it is an IP address in numeric dot notation</p><p><strong>syntax</strong>(emailaddr, <em>name</em>)</p><p>Test if <em>name</em> is a syntactically valid \m[blue]<strong>RFC 822</strong>\m[]\s-2\u[101]\d\s+2 email address. A successful test does not imply that a message can be delivered to the address.</p><p><strong>Note</strong></p><p>The implementation does not currently recognize valid addresses where the local-part (the substring to the left of the &apos;@&apos; character) contains a quoted-string component.</p><p><strong>syntax</strong>(expr, <em>name</em>)</p><p>Test if <em>name</em> is a syntactically valid expression. The expression is not actually evaluated. A successful test does not imply that evaluation of the expression will necessarily be successful or error-free.</p><p><strong>syntax</strong>(domainname, <em>name</em>)</p><p>Test if <em>name</em> is a syntactically valid domain name (\m[blue]<strong>RFC 952</strong>\m[]\s-2\u[102]\d\s+2). A successful test does not imply that <em>name</em> exists or has a DNS entry.</p><p><strong>syntax</strong>(federation, <em>name</em>)</p><p>Test if <em>name</em> is valid as a federation name (e.g., as the value of \m[blue]<strong>FEDERATION_NAME</strong>\m[]\s-2\u[103]\d\s+2).</p><p><strong>syntax</strong>(group, <em>name</em>)</p><p>Test if <em>name</em> is valid as a group name.</p><p><strong>syntax</strong>(hostname, <em>name</em>)</p><p>Test if <em>name</em> is valid as a host name (an alphanumeric, followed by any number of alphanumerics and hyphens, but not ending with a hyphen; see \m[blue]<strong>RFC 952</strong>\m[]\s-2\u[102]\d\s+2 and \m[blue]<strong>RFC 1123</strong>\m[]\s-2\u[104]\d\s+2).</p><p><strong>syntax</strong>(ipaddr, <em>name</em>)</p><p>Test if <em>name</em> is a valid Class C IPv4 address (\m[blue]<strong>RFC 790</strong>\m[]\s-2\u[105]\d\s+2).</p><p><strong>syntax</strong>(jurisdiction, <em>name</em>)</p><p>Test if <em>name</em> is valid as a jurisdiction name (e.g., as the value of \m[blue]<strong>JURISDICTION_NAME</strong>\m[]\s-2\u[106]\d\s+2).</p><p><strong>syntax</strong>(namespace, <em>name</em>)</p><p>Test if <em>name</em> is valid as the name of a \m[blue]<strong>namespace</strong>\m[]\s-2\u[22]\d\s+2.</p><p><strong>syntax</strong>(role, <em>name</em>)</p><p>Test if <em>name</em> is valid as a \m[blue]<strong>role descriptor string</strong>\m[]\s-2\u[100]\d\s+2.</p><p><strong>syntax</strong>(uri, <em>name</em>)</p><p>Test if <em>name</em> is a valid URI (\m[blue]<strong>RFC 2396</strong>\m[]\s-2\u[46]\d\s+2, but partially \m[blue]<strong>RFC 3986</strong>\m[]\s-2\u[47]\d\s+2). It must consist of a scheme, authority component, path component, and optional query and fragment components.</p><p><strong>syntax</strong>(username, <em>name</em>)</p><p>Test if <em>name</em> is valid as a username (e.g., as the value of the <em>USERNAME</em> argument to many <strong>DACS</strong> web services).</p><p><strong>syntax</strong>(variable, <em>name</em>)</p><p>Test if <em>name</em> is valid as a \m[blue]<strong>variable reference</strong>\m[]\s-2\u[22]\d\s+2. This does not test if the named variable exists.</p><p><strong>syntax</strong>(varname, <em>name</em>)</p><p>Test if <em>name</em> is a syntactically correct \m[blue]<strong>variable name</strong>\m[]\s-2\u[22]\d\s+2, with or without a namespace. This does not test if the named variable exists.</p>
<pre>
&gt; syntax(federation, "FOO")
1
&gt; syntax(dacsname, "FOO::BAZ:bar")
1
&gt; syntax(dacsname, "FOO::")
4
&gt; syntax(charset, "bobo17+", "a-z0-9")
0
&gt; syntax(expr, &apos;1 + 1 + 1&apos;)
1
&gt; syntax(variable, &apos;${1$}&apos;)
0
&gt; syntax(variable, &apos;${Foo::baz:z}&apos;)
0
&gt; syntax(varname, &apos;Foo::baz&apos;)
1
&gt; syntax(varname, "17")
1
&gt; syntax(username, "/bobo/")
0
&gt; syntax(group, "blop")
1
&gt; syntax(group, "%blop")
0
&gt; syntax(dacsname, "%blop:flop")
1
&gt; syntax(uri,"https://foo.example.com:8443/cgi-bin/prog?a=17")
1
</pre>
<p><strong>time</strong>(<em>format</em> [, <em>timeval</em>])</p><p><strong>time</strong>(<em>format</em>, <em>namespace</em>)</p><p>This function returns time and date information, as specified by the first argument. The second argument, if present, either specifies the "Unix time" from which to obtain the time and date or a namespace that was returned by \m[blue]<strong>strptime()</strong>\m[]\s-2\u[107]\d\s+2. If the second argument is absent, the result is the same as if a second argument were given as time("now"). The \m[blue]<a href="../man3/localtime.3.html"><strong>localtime</strong>(3)</a></strong>\m[]\s-2\u[108]\d\s+2 library function is used internally to perform the date calculations.</p><p>The <em>format</em> argument, which is treated case-insensitively, can be any of the following:</p><p>If the argument is "now", the function&apos;s value is the current "Unix time" (the value of time in seconds since 0 hours, 0 minutes, 0 seconds, January 1, 1970, Coordinated Universal Time). If the second argument is present, however, it is the function&apos;s value.</p><p>If the argument is "sec" or "secs" or "seconds", the function&apos;s value is the system clock&apos;s seconds reading.</p><p>If the argument is "min" or "mins" or "minutes", the function&apos;s value is the system clock&apos;s minutes reading.</p><p>If the argument is "hour", the function&apos;s value is the system clock&apos;s hour reading (0 - 23).</p><p>If the argument is "mday", the function&apos;s value is the day of the month (1 - 31).</p><p>If the argument is "ismdaylast", the function&apos;s value is non-zero if this is the last day of the month.</p><p>If the argument is "mon" or "month", the function&apos;s value is the month of the year (0 - 11).</p><p>If the argument is "year", the function&apos;s value is the year (from 1900 onward).</p><p>If the argument is "isleapyear", the function&apos;s value is non-zero if this is a leap year.</p><p>If the argument is "wday", the function&apos;s value is the day of the week (Sunday is 0).</p><p>If the argument is "yday", the function&apos;s value is the day of the year (0 - 365).</p><p>If the argument is "isdst", the function&apos;s value is non-zero if daylight saving time is in effect.</p><p>If the argument is "zone", the function&apos;s value is system clock&apos;s time zone, abbreviated. If the time zone is not known, the value will be the empty string.</p><p>If the argument is "gmtoff", the function&apos;s value is the offset (in seconds) of the system clock&apos;s time represented from UTC, with positive values indicating east of the Prime Meridian.</p><p><strong>Note</strong></p><p>A more powerful function is planned to test whether the current time and date satisfy a predicate. It might, for example, understand arguments such as "Tuesday" (<strong>True</strong> on any Tuesday), "last day of the month", "between midnight and 8:30am", "January 30, 2004 at 1:23pm", "between March 2 and April 1", "the second Tuesday of the month", or "within 15 days of April 30".</p><p><strong>transform</strong>(<em>input</em>,<em>name</em>,<em>rules</em>,<em>docs</em> [,<em>idents</em>])</p><p><strong>transform</strong>(<em>input</em>,<em>config</em>,<em>name</em>,<em>rules</em>,<em>docs</em> [,<em>idents</em>])</p><p>This function provides a simplified API for \m[blue]<a href="../man1/dacstransform.1.html"><strong>dacstransform</strong>(1)</a></strong>\m[]\s-2\u[109]\d\s+2 - refer to its description for additional details. The first form of the function uses compile-time defaults, unless they are overridden by configuration variables (e.g., <em>${Conf::transform_prefix}</em>). The second form passes a configuration object returned by \m[blue]<strong>transform_config()</strong>\m[]\s-2\u[110]\d\s+2. The <em>input</em> argument is the text to be passed through the function. The <em>name</em> argument is equivalent to the value of the <strong>dacstransform</strong><strong>-name</strong> flag, <em>rules</em> is equivalent to the value of the <strong>-r</strong> flag, <em>docs</em> is equivalent to the value of the <strong>-docs</strong> flag, and the optional <em>idents</em> argument is a whitespace-separated list of identities in the \m[blue]<strong>concise user syntax</strong>\m[]\s-2\u[111]\d\s+2. The function returns the transformed <em>input</em>.</p><p><strong>transform_config</strong>(<em>flags</em>)</p><p>This function returns a configuration object that is passed to subsequent calls to \m[blue]<strong>transform()</strong>\m[]\s-2\u[112]\d\s+2 so that defaults can be overridden. The single string argument is parsed into whitespace-separated words. If a flag is repeated, the right-most occurrence is used.</p><p>The following flags are recognized:</p><p><strong>-prefix </strong><strong></strong><em>prefix-string</em>: The string used to introduce a directive, which must appear at the beginning of a line.</p><p><strong>-suffix </strong><strong></strong><em>suffix-string</em>: The string used to end a directive.</p><p><strong>-rprefix </strong><strong></strong><em>regex-prefix</em>: A line whose beginning matches the specified regular expression introduces a directive.</p><p><strong>-rsuffix </strong><strong></strong><em>regex-suffix</em>: The end of a directive is found by matching the specified regular expression.</p><p><strong>trim</strong>(<em>string</em>, <em>delete-set</em> [,<em>limit</em>])</p><p>Delete each character in <em>delete-set</em> that appears at the end of <em>string</em>, up to <em>limit</em> characters. The <em>delete-set</em> is a search list specification as used by \m[blue]<strong>strtr()</strong>\m[]\s-2\u[81]\d\s+2. If <em>limit</em> is missing or zero, all of the characters in <em>string</em> can potentially be deleted (leaving the empty string). The new string is returned.</p>
<pre>
&gt; trim("abceffff", "f")
"abce"
&gt; trim("abceffff", abf)
"abce"
&gt; trim("a&#92;n&#92;n&#92;n", "&#92;n")
"a"
&gt; trim("a", "a-z")
""
</pre>
<p><strong>typeof</strong>([<em>typename</em>,] <em>expression</em>)</p><p>If there are two arguments and the first is a recognized \m[blue]<strong>data type name</strong>\m[]\s-2\u[21]\d\s+2, the return value is 1 (<strong>True</strong>) if <em>expression</em> has that type and 0 (<strong>False</strong>) otherwise. If there is one argument, the function yields a string that is the data type name of the evaluated expression.</p>
<pre>
&gt; typeof(4.5)
"real"
&gt; typeof(integer, 4.5)
0
</pre>
<p><strong>undef</strong>()</p><p>This function returns a special value that represents the "undefined" value. It is used in certain circumstances to undefine a symbol. See \m[blue]<strong>dacs.conf</strong>(5)</strong>\m[]\s-2\u[10]\d\s+2.</p><p><strong>user</strong>(<em>string</em>)</p><p>This function compares its argument against each set of current credentials and returns the number of credentials that match. The argument is a user filter expression that must evaluate to <strong>True</strong> for a set of credentials for those credentials to match. See \m[blue]<a href="../man1/dacs.1.html"><strong>dacs</strong>(1)</a></strong>\m[]\s-2\u[100]\d\s+2 for information about naming.</p><p><strong>Note</strong></p><p>In typical usage, each user will have only one set of credentials or will be unauthenticated. One should keep in mind, however, that multiple concurrent identities are allowed, subject to \m[blue]<strong>ACS_CREDENTIALS_LIMIT</strong>\m[]\s-2\u[113]\d\s+2.</p><p>The <em>string</em> argument (<em>EXP</em>) has the following syntax:</p><p><strong>Figure&nbsp;2.&nbsp;User Filter Expression Grammar</strong></p>
<pre>
<em>EXP</em> -&gt; <em>E1</em>
<em>E1</em>  -&gt; <em>E2</em> | <em>E2</em> <em>OR</em> <em>E2</em>
<em>E2</em>  -&gt; <em>E3</em> | <em>E3</em> <em>AND</em> <em>E2</em>
<em>E3</em>  -&gt; <em>E4</em> | <em>NOT</em> <em>E3</em>
<em>E4</em>  -&gt; <em>primary</em> | "(" <em>E1</em> ")"

<em>OR</em>  -&gt; "or"  | "||"
<em>AND</em> -&gt; "and" | "&&"
<em>NOT</em> -&gt; "not" | "!"
</pre>
<p>Whitespace (spaces and tabs) is permitted before and after lexical elements. Keywords are case sensitive except when otherwise stated.</p><p>A <em>primary</em>, which evaluates to <strong>True</strong> or <strong>False</strong>, is one of the following:</p><p><em>username</em></p><p><strong>True</strong> if the <strong>DACS</strong> identity <em>username</em> matches.</p>
<pre>
user("METALOGIC:auggie")
user(":bobo")
</pre>
<p>If the jurisdiction name or federation name components are omitted, the \m[blue]<strong>current federation and jurisdiction</strong>\m[]\s-2\u[100]\d\s+2 are implied. The jurisdiction name component may be specified as "*" (e.g., *:<em>username</em>), in which case it will match <em>any</em> jurisdiction name in the current federation. In addition, both the federation name and the jurisdiction name components may be specified as "*" (e.g., *::*:<em>username</em>), in which case it will match <em>any</em> federation name and <em>any</em> jurisdiction name.</p><p><em>jurisdiction</em></p><p><strong>True</strong> if <em>jurisdiction</em> matches the name of the jurisdiction that created the credentials.</p>
<pre>
user("METALOGIC:")
user("DEMO::METALOGIC:")
</pre>
<p><em>federation</em></p><p><strong>True</strong> if <em>federation</em> matches the name of the federation that created the credentials.</p>
<pre>
user("DEMO::")
</pre>
<p><em>address</em></p><p>Given an argument acceptable to the \m[blue]<strong>from()</strong>\m[]\s-2\u[114]\d\s+2 predicate, the result is <strong>True</strong> if the credentials were generated by a user apparently located at <em>address</em>.</p>
<pre>
user("10.0.0.123")
user("10.0.0.0/24")
user("example.com")
</pre>
<p><em>group</em></p><p><strong>True</strong> if the identity is a member of <em>group</em>, which is a <strong>DACS</strong> group.</p>
<pre>
user("%METALOGIC:admin")
</pre>
<p>A group name may reference an explicit group membership list or a role-based group. Also, it is possible for an explicit group membership list to have the same name as a role-based group; if the name is referenced in a rule, the rule processing engine will first check if the user is associated with the role. If he&apos;s not, it will go on to check for an explicit group membership list with the same name. This allows an administrator to easily supplement the membership associated with a role-based group. Refer to \m[blue]<a href="../man5/dacs.groups.5.html"><strong>dacs.groups</strong>(5)</a></strong>\m[]\s-2\u[115]\d\s+2.</p><p>namespace <em>ns</em></p><p>The value of each element in <em>ns</em> (a namespace) is evaluated as a <em>primary</em>. The order in which the list is evaluated is unspecified. Processing of the list terminates with the first <em>primary</em> that evaluates to <strong>True</strong> or when the list is exhausted. This <em>primary</em> can appear in an element (so that one list can reference other lists) but beware of infinite recursion.</p><p>For example, if /usr/local/dacs/app_users consists of usernames, one per line, an access control rule can grant permission to any of the users by having an allow element containing the statements:</p>
<pre>
setvar(load, APP_USERS, "/usr/local/dacs/app_users");
user("namespace APP_USERS")
</pre>
<p>style <em>style-list</em></p><p>The keyword style is followed by a list of one or more comma-separated, case-insensitive style keywords, described below. Each style keyword may be abbreviated up to the indicated minimum number of initial characters. Every set of credentials has one or more \m[blue]<strong>styles</strong>\m[]\s-2\u[116]\d\s+2 associated with it that indicate which authentication method or methods were successfully applied and how (by what means) the credentials were generated within <strong>DACS</strong>. A primary is <strong>True</strong> if the tested credentials satisfy <em>all</em> of the keywords in the <em>style-list</em>.</p><p>For example, this expression tests if both the passwd and certificate styles are associated with it:</p>
<pre>
user("style passwd,cert")
</pre>
<p>This is equivalent to the following expression, which tests if the user was authenticated via a username/password style of authentication and a valid X.509 client certificate was presented:</p>
<pre>
user("style passwd") and user("style CERT")
</pre>
<p>The following style keywords are understood:</p><p>acs</p><p><strong>True</strong> if the credentials were created during an authorization check by <strong>dacs_acs</strong></p><p>admin</p><p><strong>True</strong> if the credentials were created for use internal to <strong>DACS</strong>.</p><p>alien</p><p><strong>True</strong> if the credentials were imported by \m[blue]<a href="../man8/dacs_auth_agent.8.html"><strong>dacs_auth_agent</strong>(8)</a></strong>\m[]\s-2\u[117]\d\s+2 in its "alien" mode, or by \m[blue]<a href="../man8/dacs_auth_transfer.8.html"><strong>dacs_auth_transfer</strong>(8)</a></strong>\m[]\s-2\u[118]\d\s+2.</p><p>cas</p><p><strong>True</strong> if the user was authenticated using CAS.</p><p>cert[ificate]</p><p><strong>True</strong> if the user authenticated using an X.509 certificate.</p><p>digest</p><p><strong>True</strong> if the user authenticated using \m[blue]<strong>RFC 2617</strong>\m[]\s-2\u[90]\d\s+2 Digest authentication.</p><p>expr</p><p><strong>True</strong> if the user was authenticated using an expression.</p><p>gen[erated]</p><p><strong>True</strong> if the credentials were generated by a <strong>DACS</strong> utility (e.g., \m[blue]<a href="../man1/dacscookie.1.html"><strong>dacscookie</strong>(1)</a></strong>\m[]\s-2\u[119]\d\s+2).</p><p>import[ed]</p><p><strong>True</strong> if the credentials were imported by \m[blue]<a href="../man8/dacs_auth_agent.8.html"><strong>dacs_auth_agent</strong>(8)</a></strong>\m[]\s-2\u[117]\d\s+2 or \m[blue]<a href="../man8/dacs_auth_transfer.8.html"><strong>dacs_auth_transfer</strong>(8)</a></strong>\m[]\s-2\u[118]\d\s+2.</p><p>infocard</p><p><strong>True</strong> if the user was authenticated using an InfoCard.</p><p>nat[ive]</p><p><strong>True</strong> if the user was authenticated using the native authentication style.</p><p>managed_infocard</p><p><strong>True</strong> if the user was authenticated using a managed InfoCard.</p><p>pass[word]</p><p>passwd</p><p><strong>True</strong> if the user authenticated using a password.</p><p>prompt[ed]</p><p><strong>True</strong> if the user was authenticated using the prompted authentication style.</p><p>rlink</p><p><strong>True</strong> if the user was authenticated using an \m[blue]<strong>Rlink</strong>\m[]\s-2\u[84]\d\s+2.</p><p>selfissued_infocard</p><p><strong>True</strong> if the user was authenticated using a self-issued InfoCard.</p><p>simple</p><p><strong>True</strong> if the user authenticated without using a password.</p><p>This test can be used as part of a risk-based authentication configuration; a user with credentials obtained through an authentication style deemed not to be sufficiently secure with respect to a resource could be forced to reauthenticate using a stronger authentication method. See \m[blue]<a href="../man8/dacs_authenticate.8.html"><strong>dacs_authenticate</strong>(8)</a></strong>\m[]\s-2\u[9]\d\s+2 for additional information.</p><p>importedby <em>jurisdiction</em></p><p>The keyword importedby is followed by the name of a jurisdiction within the current federation; the result is <strong>True</strong> if the credentials were imported using \m[blue]<a href="../man8/dacs_auth_transfer.8.html"><strong>dacs_auth_transfer</strong>(8)</a></strong>\m[]\s-2\u[118]\d\s+2 at that jurisdiction.</p>
<pre>
user("importedby METALOGIC")
</pre>
<p>version <em>protocol-version</em></p><p>The keyword version is followed by a <strong>DACS</strong> protocol version number (every release of <strong>DACS</strong> defines this as the value of the compile-time symbol DACS_VERSION_NUMBER); the result is <strong>True</strong> if the credentials match that protocol version number.</p>
<pre>
user("version 1.4")
</pre>
<p>authenticated, unauthenticated</p><p>Either of two keywords: authenticated (or simply auth) or unauthenticated (or simply unauth). The former is <strong>True</strong> if the user is authenticated, while the latter is <strong>True</strong> if the user is not authenticated. A case-insensitive string comparison is used to match these special names.</p>
<pre>
user("auth")
user("unauth")
</pre>
<p>mine</p><p>The keyword "mine" (case insensitive) is <strong>True</strong> if the user was authenticated by the current jurisdiction.</p>
<pre>
user("mine")
</pre>
<p>any</p><p>The keyword "any" (case insensitive) is always <strong>True</strong>.</p>
<pre>
user("any")
</pre>
<p>none</p><p>The keyword "none" (case insensitive) is always <strong>False</strong>.</p>
<pre>
user("none")
</pre>
<p>By default, an exact string comparison (case sensitive) is used to match name components other than the special names; this default behaviour can be overridden using the NAME_COMPARE configuration directive (\m[blue]<strong>dacs.conf</strong>(5)</strong>\m[]\s-2\u[10]\d\s+2). The method used to compare federation names, jurisdiction names, and usernames can also be specified by following the <em>primary</em> with a <em>mode</em>. If the value of <em>mode</em> (which is itself case insensitive) is case, then case-sensitive comparisons are used, if its value is nocase, then case-insensitive comparisons are used, and if its value is default, then the value of the NAME_COMPARE directive will be used if present, otherwise the application default is used (either case or the value selected by the application).</p><p><strong>Important</strong></p><p>Keep in mind that <strong>user()</strong> can return <strong>False</strong> because no credentials matched the user filter expression and because there are no credentials at all (i.e., the user is unauthenticated). For example,</p>
<pre>
user("not METALOGIC:rmorriso")
</pre>
<p>will return <strong>True</strong> if the user&apos;s identity is not METALOGIC:rmorriso, even if the user is not authenticated. It may therefore be necessary to explicitly test for an authenticated user:</p>
<pre>
user("not METALOGIC:rmorriso and auth")
</pre>
<p>Here are examples of the <strong>user()</strong> function. Note that any non-zero expression value implies <strong>True</strong>.</p>
<pre>
user("METALOGIC:")
</pre>
<p>Return <strong>True</strong> if the client was authenticated by the jurisdiction METALOGIC in this federation</p>
<pre>
user("METALOGIC:rmorriso")
</pre>
<p>Return <strong>True</strong> if the client was authenticated as the user METALOGIC:rmorriso</p>
<pre>
user("DEMO::METALOGIC:rmorriso")
</pre>
<p>Return <strong>True</strong> if the client was authenticated by the given federation and jurisdiction as rmorriso</p>
<pre>
user("%METALOGIC:admin")
</pre>
<p>Return <strong>True</strong> if the client is a member of the group METALOGIC:admin</p>
<pre>
user("*:rmorriso")
</pre>
<p>Return <strong>True</strong> if the client was authenticated as the username rmorriso by any jurisdiction in this federation</p>
<pre>
user("auth")
</pre>
<p>Return <strong>True</strong> if the client was authenticated anywhere</p>
<pre>
user("UnAuthenticated")
</pre>
<p>Return <strong>True</strong> if the client is not authenticated</p>
<pre>
user("10.0.0.123")
</pre>
<p>Return <strong>True</strong> if the client was authenticated through a request from a host having the IP address 10.0.0.123</p>
<pre>
user("not 10.0.0.123")
</pre>
<p>Return <strong>True</strong> if the client is unauthenticated or was not authenticated through a request from a host having the IP address 10.0.0.123 (use user("auth and not 10.0.0.123") to remove the unauthenticated case)</p>
<pre>
user("ANY")
</pre>
<p>Always return <strong>True</strong></p>
<pre>
user("any") gt 1
</pre>
<p>Return <strong>True</strong> if the client has more than one set of current credentials (i.e., has authenticated as two or more identities)</p>
<pre>
user(":rmorriso")
</pre>
<p>Return <strong>True</strong> if the client was authenticated as rmorriso by this jurisdiction</p>
<pre>
user(":rmorriso nocase")
</pre>
<p>Return <strong>True</strong> if the client was authenticated as rmorriso, case-insensitively, by this jurisdiction</p>
<pre>
user("metalogic:RMORRISO nocase")
</pre>
<p>Return <strong>True</strong> if the client was authenticated as the user metalogic:RMORRISO, but comparing the jurisdiction name, username, and implied federation name case-insensitively</p>
<pre>
user("METALOGIC:rmorriso default")
</pre>
<p>Equivalent to user("METALOGIC:rmorriso"), return <strong>True</strong> if the client was authenticated as the user METALOGIC:rmorriso, but comparing the jurisdiction name, username, and implied federation name according to the NAME_COMPARE directive, otherwise using the application&apos;s default</p><p><strong>Tip</strong></p><p>The following two tests are not equivalent:</p>
<pre>
user("auth")
user("DSS:auth")
</pre>
<p>The first is <strong>True</strong> if the user making the request has been authenticated; it does matter which jurisdiction authenticated the user or what the username is. The second test requires the user making the request to have a specific identity; she must have been authenticated by the jurisdiction DSS as the username auth.</p><p><strong>ustamp</strong>(<em>op</em>, <em>vfs-ref</em> [,<em>args</em> ...])</p><p>This function generates a string called a <em>stamp</em> that is globally unique and sequenced, with high probability. It has the following syntax:</p>
<pre>
h=<em>hostid</em>, s=<em>seqno</em>
</pre>
<p>A <em>hostid</em> consists of one or more characters from the same set used for a \m[blue]<strong>DACS username</strong>\m[]\s-2\u[120]\d\s+2. A <em>seqno</em> consists of two elements, separated by a colon, each of which is an unsigned decimal value.</p><p>The first component of a stamp, the <em>hostid</em>, is intended to be uniquely associated with the host that generates the stamp. By default, it is a 128-bit, cryptographically strong pseudo-random value. This value is stored in <em>vfs-ref</em>, which may be an absolute pathname, an item type, or a \m[blue]<strong>VFS URI</strong>\m[]\s-2\u[26]\d\s+2. If <em>vfs-ref</em> does not exist, it is created and a new value is stored in it.</p><p>Note that by default, <em>hostid</em> identifies a host, not a jurisdiction. If required, it is possible to configure unique stamps for each jurisdiction on a host.</p><p>The second component (<em>seqno</em>) is a sequence number string relative to <em>hostid</em>. Sequence numbers should never repeat with respect to a host and always increase in value so that any two sequence numbers created by the same host must be different. Successive sequence numbers need not increase by uniform steps. If <em>stamp1</em> compares less than <em>stamp2</em>, then <em>stamp1</em> was created before <em>stamp2</em>. Comparison of sequence numbers is performed on matching elements numerically, left to right. Two <em>hostid</em> components are compared case insensitively. No ordering is necessarily implied by stamps created by different hosts.</p><p>Sequence number state information is stored in a file that must be specified using the configuration variable <em>${Conf::ustamp_seqno}</em>; e.g.,</p>
<pre>
EVAL ${Conf::ustamp_seqno} = "${Conf::DACS_HOME}/seqno"
</pre>
<p>The variable must be set to the absolute pathname of a file that is readable and writable by any process that needs to generate a stamp. If this file is deleted, the sequence will be reinitialized. Note that updates to the state information are unlikely to be atomic, which means that in the event of a system crash the state information should be deleted so that a new stream of sequence numbers is generated.</p><p>One application of these stamps is to provide an efficient way to detect replayed messages. A recipient may only need to keep track of the stamp sent with the last message received from a jurisdiction to detect an invalid stamp in any subsequent message. Cryptographic techniques can be employed to prevent a stamp from being altered or forged.</p><p>The following operations are recognized:</p><p><strong>ustamp</strong>(clock, <em>vfs-uri</em>)</p><p>The host&apos;s system clock is used for the stamp&apos;s sequence number. Its first element is the number of seconds since the start of the epoch and the second is a counter value. Note that if the system clock is reset to an earlier time, sequence numbers may repeat with unpredictable consequences; a future version of this function may detect a reset clock.</p><p><strong>ustamp</strong>(ntpclock, <em>vfs-uri</em>, <em>ntp_host</em>)</p><p><em>This operation is not implemented</em>. Rather than using the system clock, this operation obtains the current time from <em>ntp_host</em>, which is assumed to be more reliable than the system clock in that it will never be reset to an earlier time. The <em>ntp_host</em> argument is a hostname or IP address. The default port number (123) may be overridden by appending a colon and the port number to use.</p><p><strong>ustamp</strong>(user, <em>vfs-uri</em>, <em>seqno</em>)</p><p>Instead of incorporating the current time into the stamp&apos;s sequence number, this operation uses a user-supplied string that is assumed to have the necessary syntax and characteristics.</p><p>Examples:</p>
<pre>
&gt; ustamp(clock, "${Conf::DACS_HOME}/hostid")
"h=2fbae312ddc1d2ae388cea1b57a47c66, s=1185565675:9"
</pre>
<p><strong>valuesof</strong>(<em>alist</em>)</p><p>If its argument is a single pair, the pair&apos;s value is returned. If there is more than one pair in the argument, a list of values is returned. To get the key component of a pair or set of pairs, use \m[blue]<strong>keysof()</strong>\m[]\s-2\u[18]\d\s+2.</p><p>Examples:</p>
<pre>
&gt; valuesof({red, 17})
17
&gt; valuesof({red, 17, blue, 100})
[17, 100]
</pre>
<p><strong>var</strong>(<em>op</em>, <em>namespace</em>, <em>variable-name</em> [, <em>args</em> ...])</p><p>This function performs various operations on a variable, some of which are awkward or impossible to do using the more concise variable reference syntax. For example, the namespace or variable name argument to <strong>var()</strong> can be specified by an expression.</p><p>The following operations are available:</p><p><strong>var</strong>(delete, <em>namespace</em>, <em>variable-name</em>)</p><p>Delete (undefine) the variable named <em>variable-name</em> within <em>namespace</em>. If the variable is deleted, 1 is returned, and if it does not exist, 0 is returned.</p><p><strong>var</strong>(exists, <em>namespace</em>, <em>variable-name</em>)</p><p>Test if the variable named <em>variable-name</em> within <em>namespace</em> exists, returning 1 if so and 0 if not.</p><p><strong>var</strong>(get, <em>namespace</em>, <em>variable-name</em> [, <em>altval</em>])</p><p>Return the value of the variable named <em>variable-name</em> within <em>namespace</em>. If the variable does not exist, <em>altval</em> is returned if given, otherwise the empty string is returned (which could potentially be confused with a legitimate value).</p><p><strong>var</strong>(set, <em>namespace</em>, <em>variable-name</em>, <em>value</em>)</p><p>Set the value of the variable named <em>variable-name</em> within <em>namespace</em> to <em>value</em>. If <em>namespace</em> or <em>variable-name</em> do not exist they are created. If the variable already exists, its value is replaced. The function returns <em>value</em>.</p><p>Examples:</p>
<pre>
&gt; ${Y::foo} = 17
17
&gt; setvar(split, X, "/a/b/c/Y", "/")
5
&gt; var(get, X, 4)
"Y"
&gt; var(get, X, ${X::#} - 1)
"Y"
&gt; var(get, var(get, X, "4"), "foo")
"17"
&gt; var(set, Y, "f" . "o" . "o", 2007)
2007
&gt; ${Y::foo}
2007
</pre>
<p><strong>vfs</strong>(<em>op</em>, <em>vfs-ref</em> [, <em>argument</em> ...])</p><p>This function is an interface to the <strong>DACS</strong> virtual filestore subsystem, described in \m[blue]<a href="../man5/dacs.vfs.5.html"><strong>dacs.vfs</strong>(5)</a></strong>\m[]\s-2\u[121]\d\s+2. Please refer to \m[blue]<strong>dacs.conf</strong>(5)</strong>\m[]\s-2\u[26]\d\s+2 and \m[blue]<a href="../man1/dacsvfs.1.html"><strong>dacsvfs</strong>(1)</a></strong>\m[]\s-2\u[122]\d\s+2 for details and examples.</p><p>The first argument specifies the operation to be performed. The second argument identifies a filestore (typically a file or database); it can be an absolute pathname, an item_type that has been configured through a \m[blue]<strong>VFS</strong>\m[]\s-2\u[26]\d\s+2 directive, or a \m[blue]<strong>VFS URI</strong>\m[]\s-2\u[123]\d\s+2. Zero or more arguments may follow, depending on <em>op</em>. For most operations, the third argument will be the key that identifies the object of interest. The underlying filestore is implicitly opened and closed.</p><p>An operation that fails abnormally triggers a fatal error.</p><p>The following operations (<em>op</em>) are available:</p><p>vfs(control, <em>vfs-ref</em>, <em>c_op</em> [, <em>argument</em> ...]</p><p>Perform a configuration operation, specified by <em>c_op</em>, on the filestore. Zero or more arguments may follow <em>c_op</em>, depending on the semantics of <em>c_op</em>. Not all <em>c_op</em> requests are valid for a given storage scheme or have an effect. <strong>True</strong> is returned if successful, <strong>False</strong> otherwise. Recognized <em>c_op</em> specifiers are:</p><p>flush</p><p>For dacs-kwv type schemes, if modified data has been buffered, write it to the underlying storage layer.</p><p>get_container</p><p>For most schemes, return a URI for the underlying object that stores the instance&apos;s data (e.g., the URI for a filename).</p><p>set_cookies</p><p>For an http or https scheme, each argument is an HTTP cookie to submit with each request. (NOT IMPLEMENTED).</p><p>set_field_sep <em>field_sep</em></p><p>For dacs-kwv type schemes, set the field separator string to <em>field_sep</em>.</p><p>set_lock <em>mode</em></p><p>For a native filesystem object (the fs scheme), set or unset a lock on the underlying storage object according to <em>mode</em>. (NOT IMPLEMENTED.)</p><p>vfs(defined, <em>item-type</em>)</p><p>Test if the specified <em>item-type</em> has been defined by a \m[blue]<strong>VFS</strong>\m[]\s-2\u[26]\d\s+2 directive.</p>
<pre>
vfs(defined, "passwds")
</pre>
<p>vfs(delete, <em>vfs-ref</em> [, <em>key</em>])</p><p>Delete the referenced object.</p><p>vfs(enabled [, <em>store-name</em>])</p><p>With an argument, test if the specified <em>store-name</em> can be used. With no argument, return a \m[blue]<strong>list</strong>\m[]\s-2\u[69]\d\s+2 of enabled store names.</p>
<pre>
vfs(enabled, "db") ? print("yes") : print("no");
</pre>
<p>vfs(exists, <em>vfs-ref</em> [, <em>key</em>])</p><p>Test whether the referenced object exists, returning <strong>True</strong> or <strong>False</strong>.</p>
<pre>
vfs(exists, "/usr/local/dacs/conf/passwd")
vfs(exists, "file:///usr/local/dacs/conf/passwd")
</pre>
<p>vfs(get, <em>vfs-ref</em> [, <em>key</em>])</p><p>Retrieve the referenced object.</p><p>vfs(getsize, <em>vfs-ref</em> [, <em>key</em>])</p><p>Return the length, in bytes, of the referenced object.</p><p>vfs(list, <em>vfs-ref</em>)</p><p>List the keys of all objects in the store.</p><p>vfs(put, <em>vfs-ref</em>, <em>value</em>)</p><p>vfs(put, <em>vfs-ref</em>, <em>key</em>, <em>value</em>)</p><p>Store an item under the given key, replacing any existing instance. The value is null-terminated.</p><p>vfs(rename, <em>vfs-ref</em>, <em>oldkey</em>, <em>newkey</em>)</p><p>Change the key associated with an existing item from <em>oldkey</em> to <em>newkey</em>.</p><p>vfs(uri, <em>item-type</em>)</p><p>If <em>item-type</em> has been defined by a \m[blue]<strong>VFS</strong>\m[]\s-2\u[26]\d\s+2 directive, return its URI, otherwise the empty string.</p>
<pre>
&gt; vfs(uri, "passwds")
"[passwds]dacs-kwv-fs:/usr/local/dacs/conf/passwd?field_sep=:"
</pre>
<p>This statement sets a variable to the contents of the file /tmp/somefile:</p>
<pre>
${somefile} = vfs(get, "file:///tmp/somefile")
</pre>
<p>As do this equivalent statements:</p>
<pre>
${somefile} = vfs(get, "/tmp/somefile")
${somefile} = get("/tmp/somefile")
</pre>
<p>This expression lists the files in the /tmp directory:</p>
<pre>
vfs(list,"dacs-fs:/tmp")
</pre>
<p>These expressions 1) add a key/value pair to a Berkeley DB database (/tmp/mydb.db), creating the database file if necessary, 2) retrieve the value, 3) rename the key, and 4) list the keys in the database:</p>
<pre>
vfs(put, "dacs-db:/tmp/mydb.db", "foo", "baz");
vfs(get, "dacs-db:/tmp/mydb.db", "foo");
vfs(rename, "dacs-db:/tmp/mydb.db", "foo", "bar");
vfs(list, "dacs-db:/tmp/mydb.db");
</pre>
<p>This rule fragment denies access if the user has already been granted access five times:</p>
<pre>
&lt;deny&gt;
  if (user("auth")) {
    if (vfs(exists, counter_db, ${DACS::IDENTITY})) {
      ${count} = vfs(get, counter_db, ${DACS::IDENTITY});
    }
    else {
      ${count} = 0;
    }
    if (${count} gt 5) {
      <strong>return</strong>(1);
    }
    vfs(put, counter_db, ${DACS::IDENTITY}, ++${count});
    <strong>return</strong>(0);
  }
&lt;/deny&gt;
</pre>
<p>The item type counter_db would be configured in dacs.conf; e.g.,</p>
<pre>
VFS "[counter_db]dacs-db:/usr/local/dacs/federations/counters.db"
</pre>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO dacs.exprs&hellip;</h2>
        <div class="sectioncontent">
<p>\m[blue]<a href="../man1/dacsexpr.1.html"><strong>dacsexpr</strong>(1)</a></strong>\m[]\s-2\u[1]\d\s+2</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>Assorted clunky aspects of the language are likely to be replaced by simplified or more general approaches once requirements are clearer. The list and alist data types have not been fully developed and integrated. Assignment to a namespace would be a useful extension.</p><p>A way to handle errors and exceptions (such as with try/catch/throw statements) would be nice. A switch statement and dynamically loaded functions are planned. A foreach statement might be useful, although the language has so far successfully avoided loop constructs as a way to limit its complexity.</p><p>Various aspects of variables and namespaces are not implemented. A namespace cannot be copied by assignment; use <strong>setvar()</strong>.</p><p>Input and output processing is still rather limited.</p><p>Having to use ":" instead of ".." when matching octet ranges with \m[blue]<strong>from()</strong>\m[]\s-2\u[114]\d\s+2 is unfortunate but avoids pesky period proliferation.</p><p>Some of the more esoteric functions and modes of operation exist primarily to expose <strong>DACS</strong> core code for testing purposes.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Distributed Systems Software (\m[blue]<strong>www.dss.ca</strong>\m[]\s-2\u[124]\d\s+2)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYING</h2>
        <div class="sectioncontent">
<p>Copyright2003-2013 Distributed Systems Software. See the \m[blue]<strong>LICENSE</strong>\m[]\s-2\u[125]\d\s+2 file that accompanies the distribution for licensing information.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTES</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
     1.
  </dt>
  <dd>
    <p><a href="../man1/dacsexpr.1.html"><strong>dacsexpr</strong>(1)</a></p><p>http://dacs.dss.ca/man/dacsexpr.1.html</p>
  </dd>
  <dt>
     2.
  </dt>
  <dd>
    <p>Perl</p><p>http://www.perl.org/</p>
  </dd>
  <dt>
     3.
  </dt>
  <dd>
    <p>PHP</p><p>http://www.php.net</p>
  </dd>
  <dt>
     4.
  </dt>
  <dd>
    <p>Tcl</p><p>http://www.tcl.tk/about</p>
  </dd>
  <dt>
     5.
  </dt>
  <dd>
    <p><a href="../man3/isprint.3.html"><strong>isprint</strong>(3)</a></p><p>http://www.freebsd.org/cgi/man.cgi?query=isprint&apropos=0&sektion=3&manpath=FreeBSD+9.1-RELEASE&format=html</p>
  </dd>
  <dt>
     6.
  </dt>
  <dd>
    <p>print()</p><p>http://dacs.dss.ca/man/#print</p>
  </dd>
  <dt>
     7.
  </dt>
  <dd>
    <p>cast</p><p>http://dacs.dss.ca/man/#cast</p>
  </dd>
  <dt>
     8.
  </dt>
  <dd>
    <p>modifier flag</p><p>http://dacs.dss.ca/man/#variable_modifiers</p>
  </dd>
  <dt>
     9.
  </dt>
  <dd>
    <p><a href="../man8/dacs_authenticate.8.html"><strong>dacs_authenticate</strong>(8)</a></p><p>http://dacs.dss.ca/man/dacs_authenticate.8.html</p>
  </dd>
  <dt>
    10.
  </dt>
  <dd>
    <p><strong>dacs.conf</strong>(5)</p><p>http://dacs.dss.ca/man/dacs.conf.5.html</p>
  </dd>
  <dt>
    11.
  </dt>
  <dd>
    <p><a href="../man8/dacs_acs.8.html"><strong>dacs_acs</strong>(8)</a></p><p>http://dacs.dss.ca/man/dacs_acs.8.html</p>
  </dd>
  <dt>
    12.
  </dt>
  <dd>
    <p><a href="../man7/environ.7.html"><strong>environ</strong>(7)</a></p><p>http://www.freebsd.org/cgi/man.cgi?query=environ&apropos=0&sektion=7&manpath=FreeBSD+9.1-RELEASE&format=html</p>
  </dd>
  <dt>
    13.
  </dt>
  <dd>
    <p>exec()</p><p>http://dacs.dss.ca/man/#exec</p>
  </dd>
  <dt>
    14.
  </dt>
  <dd>
    <p>list()</p><p>http://dacs.dss.ca/man/#list</p>
  </dd>
  <dt>
    15.
  </dt>
  <dd>
    <p>length()</p><p>http://dacs.dss.ca/man/#length</p>
  </dd>
  <dt>
    16.
  </dt>
  <dd>
    <p>strchars()</p><p>http://dacs.dss.ca/man/#strchars</p>
  </dd>
  <dt>
    17.
  </dt>
  <dd>
    <p>expression grammar</p><p>http://dacs.dss.ca/man/#expression_grammar</p>
  </dd>
  <dt>
    18.
  </dt>
  <dd>
    <p>keysof()</p><p>http://dacs.dss.ca/man/#keysof</p>
  </dd>
  <dt>
    19.
  </dt>
  <dd>
    <p>valuesof()</p><p>http://dacs.dss.ca/man/#valuesof</p>
  </dd>
  <dt>
    20.
  </dt>
  <dd>
    <p>alist()</p><p>http://dacs.dss.ca/man/#alist</p>
  </dd>
  <dt>
    21.
  </dt>
  <dd>
    <p>supported data types</p><p>http://dacs.dss.ca/man/#data_types</p>
  </dd>
  <dt>
    22.
  </dt>
  <dd>
    <p>variable reference</p><p>http://dacs.dss.ca/man/#variables</p>
  </dd>
  <dt>
    23.
  </dt>
  <dd>
    <p><a href="../man8/dacs_notices.8.html"><strong>dacs_notices</strong>(8)</a></p><p>http://dacs.dss.ca/man/dacs_notices.8.html</p>
  </dd>
  <dt>
    24.
  </dt>
  <dd>
    <p>alist construction operator</p><p>http://dacs.dss.ca/man/#alists</p>
  </dd>
  <dt>
    25.
  </dt>
  <dd>
    <p>listref()</p><p>http://dacs.dss.ca/man/#listref</p>
  </dd>
  <dt>
    26.
  </dt>
  <dd>
    <p>VFS</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#VFS</p>
  </dd>
  <dt>
    27.
  </dt>
  <dd>
    <p>revocation list</p><p>http://dacs.dss.ca/man/dacs.acls.5.html#revocation_list</p>
  </dd>
  <dt>
    28.
  </dt>
  <dd>
    <p>access control rule</p><p>http://dacs.dss.ca/man/dacs.acls.5.html</p>
  </dd>
  <dt>
    29.
  </dt>
  <dd>
    <p>on_success()</p><p>http://dacs.dss.ca/man/#on_success</p>
  </dd>
  <dt>
    30.
  </dt>
  <dd>
    <p>AUTH_SUCCESS</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#AUTH_SUCCESS</p>
  </dd>
  <dt>
    31.
  </dt>
  <dd>
    <p>ACS_SUCCESS</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#ACS_SUCCESS</p>
  </dd>
  <dt>
    32.
  </dt>
  <dd>
    <p>ADMIN_IDENTITY</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#ADMIN_IDENTITY</p>
  </dd>
  <dt>
    33.
  </dt>
  <dd>
    <p>approval stamp</p><p>http://dacs.dss.ca/man/dacs_acs.8.html#dacs_approval</p>
  </dd>
  <dt>
    34.
  </dt>
  <dd>
    <p>dacs64 decoding</p><p>http://dacs.dss.ca/man/dacs.exprs.5.html#encode</p>
  </dd>
  <dt>
    35.
  </dt>
  <dd>
    <p><a href="../man8/dacs_list_jurisdictions.8.html"><strong>dacs_list_jurisdictions</strong>(8)</a></p><p>http://dacs.dss.ca/man/dacs_list_jurisdictions.8.html</p>
  </dd>
  <dt>
    36.
  </dt>
  <dd>
    <p><a href="../man1/dacsauth.1.html"><strong>dacsauth</strong>(1)</a></p><p>http://dacs.dss.ca/man/dacsauth.1.html</p>
  </dd>
  <dt>
    37.
  </dt>
  <dd>
    <p><a href="../man1/dacscheck.1.html"><strong>dacscheck</strong>(1)</a></p><p>http://dacs.dss.ca/man/dacscheck.1.html</p>
  </dd>
  <dt>
    38.
  </dt>
  <dd>
    <p>encode()</p><p>http://dacs.dss.ca/man/#encode</p>
  </dd>
  <dt>
    39.
  </dt>
  <dd>
    <p>cryptographic hash</p><p>http://en.wikipedia.org/wiki/Message_digest</p>
  </dd>
  <dt>
    40.
  </dt>
  <dd>
    <p>MD5 Message-Digest Algorithm</p><p>http://en.wikipedia.org/wiki/MD5</p>
  </dd>
  <dt>
    41.
  </dt>
  <dd>
    <p>hash()</p><p>http://dacs.dss.ca/man/#hash</p>
  </dd>
  <dt>
    42.
  </dt>
  <dd>
    <p>decode()</p><p>http://dacs.dss.ca/man/#decode</p>
  </dd>
  <dt>
    43.
  </dt>
  <dd>
    <p>radix-85</p><p>http://en.wikipedia.org/wiki/Ascii85</p>
  </dd>
  <dt>
    44.
  </dt>
  <dd>
    <p>RFC 2045</p><p>http://www.rfc-editor.org/rfc/rfc2045.txt</p>
  </dd>
  <dt>
    45.
  </dt>
  <dd>
    <p>RFC 1738</p><p>http://www.rfc-editor.org/rfc/rfc1738.txt</p>
  </dd>
  <dt>
    46.
  </dt>
  <dd>
    <p>RFC 2396</p><p>http://www.rfc-editor.org/rfc/rfc2396.txt</p>
  </dd>
  <dt>
    47.
  </dt>
  <dd>
    <p>RFC 3986</p><p>http://www.rfc-editor.org/rfc/rfc3986.txt</p>
  </dd>
  <dt>
    48.
  </dt>
  <dd>
    <p><a href="../man3/execv.3.html"><strong>execv</strong>(3)</a></p><p>http://www.freebsd.org/cgi/man.cgi?query=execv&apropos=0&sektion=3&manpath=FreeBSD+9.1-RELEASE&format=html</p>
  </dd>
  <dt>
    49.
  </dt>
  <dd>
    <p><a href="../man1/basename.1.html"><strong>basename</strong>(1)</a></p><p>http://www.freebsd.org/cgi/man.cgi?query=basename&apropos=0&sektion=1&manpath=FreeBSD+9.1-RELEASE&format=html</p>
  </dd>
  <dt>
    50.
  </dt>
  <dd>
    <p><a href="../man1/dirname.1.html"><strong>dirname</strong>(1)</a></p><p>http://www.freebsd.org/cgi/man.cgi?query=dirname&apropos=0&sektion=1&manpath=FreeBSD+9.1-RELEASE&format=html</p>
  </dd>
  <dt>
    51.
  </dt>
  <dd>
    <p>stat</p><p>http://dacs.dss.ca/man/#stat</p>
  </dd>
  <dt>
    52.
  </dt>
  <dd>
    <p><a href="../man1/stat.1.html"><strong>stat</strong>(1)</a></p><p>http://www.freebsd.org/cgi/man.cgi?query=stat&apropos=0&sektion=1&manpath=FreeBSD+9.1-RELEASE&format=html</p>
  </dd>
  <dt>
    53.
  </dt>
  <dd>
    <p><a href="../man2/stat.2.html"><strong>stat</strong>(2)</a></p><p>http://www.freebsd.org/cgi/man.cgi?query=stat&apropos=0&sektion=2&manpath=FreeBSD+9.1-RELEASE&format=html</p>
  </dd>
  <dt>
    54.
  </dt>
  <dd>
    <p><a href="../man3/printf.3.html"><strong>printf</strong>(3)</a></p><p>http://www.freebsd.org/cgi/man.cgi?query=printf&apropos=0&sektion=3&manpath=FreeBSD+9.1-RELEASE&format=html</p>
  </dd>
  <dt>
    55.
  </dt>
  <dd>
    <p><a href="../man1/test.1.html"><strong>test</strong>(1)</a></p><p>http://www.freebsd.org/cgi/man.cgi?query=test&apropos=0&sektion=1&manpath=FreeBSD+9.1-RELEASE&format=html</p>
  </dd>
  <dt>
    56.
  </dt>
  <dd>
    <p>mod_access</p><p>http://httpd.apache.org/docs-2.2/mod/mod_access.html</p>
  </dd>
  <dt>
    57.
  </dt>
  <dd>
    <p>RFC 1035</p><p>http://www.rfc-editor.org/rfc/rfc1035.txt</p>
  </dd>
  <dt>
    58.
  </dt>
  <dd>
    <p>CIDR notation</p><p>http://en.wikipedia.org/wiki/CIDR_notation</p>
  </dd>
  <dt>
    59.
  </dt>
  <dd>
    <p>RFC 1338</p><p>http://www.rfc-editor.org/rfc/rfc1338.txt</p>
  </dd>
  <dt>
    60.
  </dt>
  <dd>
    <p>range specification</p><p>http://dacs.dss.ca/man/#range-spec</p>
  </dd>
  <dt>
    61.
  </dt>
  <dd>
    <p>regmatch()</p><p>http://dacs.dss.ca/man/#regmatch</p>
  </dd>
  <dt>
    62.
  </dt>
  <dd>
    <p>user()</p><p>http://dacs.dss.ca/man/#user</p>
  </dd>
  <dt>
    63.
  </dt>
  <dd>
    <p>digest()</p><p>http://dacs.dss.ca/man/#digest</p>
  </dd>
  <dt>
    64.
  </dt>
  <dd>
    <p>message authentication code</p><p>http://en.wikipedia.org/wiki/Message_Authentication_Code</p>
  </dd>
  <dt>
    65.
  </dt>
  <dd>
    <p>Keyed-Hash Message Authentication Code (HMAC)</p><p>http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf</p>
  </dd>
  <dt>
    66.
  </dt>
  <dd>
    <p>Secure Hash Standard functions</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#SHA_functions</p>
  </dd>
  <dt>
    67.
  </dt>
  <dd>
    <p>MD5 (RFC 2104)</p><p>http://www.rfc-editor.org/rfc/rfc2104.txt</p>
  </dd>
  <dt>
    68.
  </dt>
  <dd>
    <p>RFC 2253</p><p>http://www.rfc-editor.org/rfc/rfc2253.txt</p>
  </dd>
  <dt>
    69.
  </dt>
  <dd>
    <p>list construction operator</p><p>http://dacs.dss.ca/man/#lists</p>
  </dd>
  <dt>
    70.
  </dt>
  <dd>
    <p><a href="../man1/dacspasswd.1.html"><strong>dacspasswd</strong>(1)</a></p><p>http://dacs.dss.ca/man/dacspasswd.1.html</p>
  </dd>
  <dt>
    71.
  </dt>
  <dd>
    <p>PASSWORD_DIGEST</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#PASSWORD_DIGEST</p>
  </dd>
  <dt>
    72.
  </dt>
  <dd>
    <p>PASSWORD_SALT_PREFIX</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#PASSWORD_SALT_PREFIX</p>
  </dd>
  <dt>
    73.
  </dt>
  <dd>
    <p>local_passwd_authenticate</p><p>http://dacs.dss.ca/man/dacs_authenticate.8.html#local_passwd_authenticate</p>
  </dd>
  <dt>
    74.
  </dt>
  <dd>
    <p>vfs()</p><p>http://dacs.dss.ca/man/#vfs</p>
  </dd>
  <dt>
    75.
  </dt>
  <dd>
    <p>PASSWORD_CONSTRAINTS</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#PASSWORD_CONSTRAINTS</p>
  </dd>
  <dt>
    76.
  </dt>
  <dd>
    <p><strong>dacs.conf</strong>(5)</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#interpolation</p>
  </dd>
  <dt>
    77.
  </dt>
  <dd>
    <p>RFC 2898</p><p>http://www.rfc-editor.org/rfc/rfc2898.txt</p>
  </dd>
  <dt>
    78.
  </dt>
  <dd>
    <p>RFC 3962</p><p>http://www.rfc-editor.org/rfc/rfc3962.txt</p>
  </dd>
  <dt>
    79.
  </dt>
  <dd>
    <p>LOG_FILTER</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#LOG_FILTER</p>
  </dd>
  <dt>
    80.
  </dt>
  <dd>
    <p>cryptographically strong pseudo-random values</p><p>http://www.openssl.org/docs/crypto/RAND_bytes.html</p>
  </dd>
  <dt>
    81.
  </dt>
  <dd>
    <p>strtr()</p><p>http://dacs.dss.ca/man/#strtr</p>
  </dd>
  <dt>
    82.
  </dt>
  <dd>
    <p>ACS_ERROR_HANDLER</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#ACS_ERROR_HANDLER</p>
  </dd>
  <dt>
    83.
  </dt>
  <dd>
    <p>ErrorDocument directive</p><p>http://httpd.apache.org/docs-2.2/mod/core.html#errordocument</p>
  </dd>
  <dt>
    84.
  </dt>
  <dd>
    <p>Rlinks</p><p>http://dacs.dss.ca/man/dacs_acs.8.html#rlinks</p>
  </dd>
  <dt>
    85.
  </dt>
  <dd>
    <p>permalinks</p><p>http://en.wikipedia.org/wiki/Permalink</p>
  </dd>
  <dt>
    86.
  </dt>
  <dd>
    <p><a href="../man3/regex.3.html"><strong>regex</strong>(3)</a></p><p>http://www.freebsd.org/cgi/man.cgi?query=regex&apropos=0&esektion=3&emanpath=FreeBSD+9.1-RELEASE&format=html</p>
  </dd>
  <dt>
    87.
  </dt>
  <dd>
    <p><a href="../man7/re_format.7.html"><strong>re_format</strong>(7)</a></p><p>http://www.freebsd.org/cgi/man.cgi?query=re_format&sektion=7&apropos=0&manpath=FreeBSD+9.1-RELEASE&format=html</p>
  </dd>
  <dt>
    88.
  </dt>
  <dd>
    <p>access control rules</p><p>http://dacs.dss.ca/man/dacs.acls.5.html#elements</p>
  </dd>
  <dt>
    89.
  </dt>
  <dd>
    <p>read-only namespace</p><p>http://dacs.dss.ca/man/#reserved_namespaces</p>
  </dd>
  <dt>
    90.
  </dt>
  <dd>
    <p>RFC 2617</p><p>http://www.rfc-editor.org/rfc/rfc2617.txt</p>
  </dd>
  <dt>
    91.
  </dt>
  <dd>
    <p>copy</p><p>http://dacs.dss.ca/man/#setvar-copy</p>
  </dd>
  <dt>
    92.
  </dt>
  <dd>
    <p>query</p><p>http://dacs.dss.ca/man/#setvar-query</p>
  </dd>
  <dt>
    93.
  </dt>
  <dd>
    <p><a href="../man8/cgiparse.8.html"><strong>cgiparse</strong>(8)</a></p><p>http://dacs.dss.ca/man/cgiparse.8.html</p>
  </dd>
  <dt>
    94.
  </dt>
  <dd>
    <p>split</p><p>http://dacs.dss.ca/man/#setvar-split</p>
  </dd>
  <dt>
    95.
  </dt>
  <dd>
    <p><a href="../man3/sleep.3.html"><strong>sleep</strong>(3)</a></p><p>http://www.freebsd.org/cgi/man.cgi?query=sleep&apropos=0&sektion=3&manpath=FreeBSD+9.1-RELEASE&format=html</p>
  </dd>
  <dt>
    96.
  </dt>
  <dd>
    <p><a href="../man3/sprintf.3.html"><strong>sprintf</strong>(3)</a></p><p>http://www.freebsd.org/cgi/man.cgi?query=sprintf&apropos=0&sektion=3&manpath=FreeBSD+9.1-RELEASE&format=html</p>
  </dd>
  <dt>
    97.
  </dt>
  <dd>
    <p><a href="../man3/strftime.3.html"><strong>strftime</strong>(3)</a></p><p>http://www.freebsd.org/cgi/man.cgi?query=strftime&apropos=0&sektion=3&manpath=FreeBSD+9.1-RELEASE&format=html</p>
  </dd>
  <dt>
    98.
  </dt>
  <dd>
    <p><a href="../man3/strptime.3.html"><strong>strptime</strong>(3)</a></p><p>http://www.freebsd.org/cgi/man.cgi?query=strptime&apropos=0&sektion=3&manpath=FreeBSD+9.1-RELEASE&format=html</p>
  </dd>
  <dt>
    99.
  </dt>
  <dd>
    <p>tr(1)</p><p>http://www.freebsd.org/cgi/man.cgi?query=tr&apropos=0&sektion=1&manpath=FreeBSD+9.1-RELEASE&format=html</p>
  </dd>
  <dt>
    00.
  </dt>
  <dd>
    <p><strong>DACS</strong> name</p><p>http://dacs.dss.ca/man/dacs.1.html#naming</p>
  </dd>
  <dt>
    01.
  </dt>
  <dd>
    <p>RFC 822</p><p>http://www.rfc-editor.org/rfc/rfc822.txt</p>
  </dd>
  <dt>
    02.
  </dt>
  <dd>
    <p>RFC 952</p><p>http://www.rfc-editor.org/rfc/rfc952.txt</p>
  </dd>
  <dt>
    03.
  </dt>
  <dd>
    <p>FEDERATION_NAME</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#FEDERATION_NAME</p>
  </dd>
  <dt>
    04.
  </dt>
  <dd>
    <p>RFC 1123</p><p>http://www.rfc-editor.org/rfc/rfc1123.txt</p>
  </dd>
  <dt>
    05.
  </dt>
  <dd>
    <p>RFC 790</p><p>http://www.rfc-editor.org/rfc/rfc790.txt</p>
  </dd>
  <dt>
    06.
  </dt>
  <dd>
    <p>JURISDICTION_NAME</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#JURISDICTION_NAME</p>
  </dd>
  <dt>
    07.
  </dt>
  <dd>
    <p>strptime()</p><p>http://dacs.dss.ca/man/#strptime</p>
  </dd>
  <dt>
    08.
  </dt>
  <dd>
    <p><a href="../man3/localtime.3.html"><strong>localtime</strong>(3)</a></p><p>http://www.freebsd.org/cgi/man.cgi?query=localtime&apropos=0&sektion=3&manpath=FreeBSD+9.1-RELEASE&format=html</p>
  </dd>
  <dt>
    09.
  </dt>
  <dd>
    <p><a href="../man1/dacstransform.1.html"><strong>dacstransform</strong>(1)</a></p><p>http://dacs.dss.ca/man/dacstransform.1.html</p>
  </dd>
  <dt>
    10.
  </dt>
  <dd>
    <p>transform_config()</p><p>http://dacs.dss.ca/man/#transform_config</p>
  </dd>
  <dt>
    11.
  </dt>
  <dd>
    <p>concise user syntax</p><p>http://dacs.dss.ca/man/dacs.1.html#concise_user_syntax</p>
  </dd>
  <dt>
    12.
  </dt>
  <dd>
    <p>transform()</p><p>http://dacs.dss.ca/man/#transform</p>
  </dd>
  <dt>
    13.
  </dt>
  <dd>
    <p>ACS_CREDENTIALS_LIMIT</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#ACS_CREDENTIALS_LIMIT</p>
  </dd>
  <dt>
    14.
  </dt>
  <dd>
    <p>from()</p><p>http://dacs.dss.ca/man/#from</p>
  </dd>
  <dt>
    15.
  </dt>
  <dd>
    <p><a href="../man5/dacs.groups.5.html"><strong>dacs.groups</strong>(5)</a></p><p>http://dacs.dss.ca/man/dacs.groups.5.html</p>
  </dd>
  <dt>
    16.
  </dt>
  <dd>
    <p>styles</p><p>http://dacs.dss.ca/man/dacs_authenticate.8.html#STYLE</p>
  </dd>
  <dt>
    17.
  </dt>
  <dd>
    <p><a href="../man8/dacs_auth_agent.8.html"><strong>dacs_auth_agent</strong>(8)</a></p><p>http://dacs.dss.ca/man/dacs_auth_agent.8.html</p>
  </dd>
  <dt>
    18.
  </dt>
  <dd>
    <p><a href="../man8/dacs_auth_transfer.8.html"><strong>dacs_auth_transfer</strong>(8)</a></p><p>http://dacs.dss.ca/man/dacs_auth_transfer.8.html</p>
  </dd>
  <dt>
    19.
  </dt>
  <dd>
    <p><a href="../man1/dacscookie.1.html"><strong>dacscookie</strong>(1)</a></p><p>http://dacs.dss.ca/man/dacscookie.1.html</p>
  </dd>
  <dt>
    20.
  </dt>
  <dd>
    <p>DACS username</p><p>http://dacs.dss.ca/man/dacs.1.html#dacs_identity</p>
  </dd>
  <dt>
    21.
  </dt>
  <dd>
    <p><a href="../man5/dacs.vfs.5.html"><strong>dacs.vfs</strong>(5)</a></p><p>http://dacs.dss.ca/man/dacs.vfs.5.html</p>
  </dd>
  <dt>
    22.
  </dt>
  <dd>
    <p><a href="../man1/dacsvfs.1.html"><strong>dacsvfs</strong>(1)</a></p><p>http://dacs.dss.ca/man/dacsvfs.1.html</p>
  </dd>
  <dt>
    23.
  </dt>
  <dd>
    <p>VFS URI</p><p>http://dacs.dss.ca/man/man/dacs.conf.5.html#VFS</p>
  </dd>
  <dt>
    24.
  </dt>
  <dd>
    <p>www.dss.ca</p><p>http://www.dss.ca</p>
  </dd>
  <dt>
    25.
  </dt>
  <dd>
    <p>LICENSE</p><p>http://dacs.dss.ca/man/../misc/LICENSE</p>
  </dd>

</dl>

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="dacs.acls.5.html"><span aria-hidden="true">&larr;</span> dacs.acls.5: Dacs access control rules</a></li>
   <li class="next"><a href="dacs.groups.5.html">dacs.groups.5: Dacs groups <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

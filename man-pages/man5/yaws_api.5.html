<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>yaws_api: Api available to yaws web server programmers</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Api available to yaws web server programmers">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="yaws_api (5) manual">
  <meta name="twitter:description" content="Api available to yaws web server programmers">
  <meta name="twitter:image" content="https://www.carta.tech/images/erlang-yaws-yaws_api-5.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man5/yaws_api.5.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="yaws_api (5) manual" />
  <meta property="og:description" content="Api available to yaws web server programmers" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/erlang-yaws-yaws_api-5.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">yaws_api<small> (5)</small></h1>
        <p class="lead">Api available to yaws web server programmers</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/">
      <span itemprop="name">File formats and conventions</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/yaws_api.5.html">
      <span itemprop="name">yaws_api: Api available to yaws web server programmers</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/erlang-yaws/">
      <span itemprop="name">erlang-yaws</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/yaws_api.5.html">
      <span itemprop="name">yaws_api: Api available to yaws web server programmers</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>yaws_api:Function(...)</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This is the api available to yaws web server programmers. The Erlang module yaws_api contains a wide variety of functions that can be used inside yaws pages.</p><p>Each chunk of yaws code is executed while the yaws page is being delivered from the server. We give a very simple example here to show the basic idea. Imagine the following HTML code:</p><p><em></em></p>
<pre>
&lt;html&gt;
&lt;body&gt;

&lt;h1&gt; Header 1&lt;/h1&gt;

&lt;erl&gt;
out(Arg) -&gt;
    {html, "&lt;p&gt; Insert this text into the document"}.
&lt;/erl&gt;

&lt;/body&gt;
&lt;/html&gt;

</pre>
<p>The <strong>out(Arg)</strong> function is supplied one argument, an #arg{} structure. We have the following relevant record definitions:</p><p><em></em></p>
<pre>
-record(arg, {
          clisock,        % the socket leading to the peer client
          client_ip_port, % {ClientIp, ClientPort} tuple
          headers,        % headers
          req,            % request
          orig_req,       % original request
          clidata,        % The client data (as a binary in POST requests)
          server_path,    % The normalized server path
                          % (pre-querystring part of URI)
          querydata,      % For URIs of the form ...?querydata
                          %  equiv of cgi QUERY_STRING
          appmoddata,     % (deprecated - use pathinfo instead) the remainder
                          % of the path leading up to the query
          docroot,        % Physical base location of data for this request
          docroot_mount,  % virtual directory e.g /myapp/ that the docroot
                          %  refers to.
          fullpath,       % full deep path to yaws file
          cont,           % Continuation for chunked multipart uploads
          state,          % State for use by users of the out/1 callback
          pid,            % pid of the yaws worker process
          opaque,         % useful to pass static data
          appmod_prepath, % (deprecated - use prepath instead) path in front
                          %  of: &lt;appmod&gt;&lt;appmoddata&gt;
          prepath,        % Path prior to 'dynamic' segment of URI.
                          %  ie http://some.host/&lt;prepath&gt;/&lt;script-point&gt;/d/e
                          % where &lt;script-point&gt; is an appmod mount point,
                          % or .yaws,.php,.cgi,.fcgi etc script file.
          pathinfo        % Set to '/d/e' when calling c.yaws for the request
                          % http://some.host/a/b/c.yaws/d/e
                          %  equiv of cgi PATH_INFO
         }).
</pre>
<p>The headers argument is also a record: <em></em></p>
<pre>
-record(headers, {
          connection,
          accept,
          host,
          if_modified_since,
          if_match,
          if_none_match,
          if_range,
          if_unmodified_since,
          range,
          referer,
          user_agent,
          accept_ranges,
          cookie = [],
          keep_alive,
          location,
          content_length,
          content_type,
          content_encoding,
          authorization,
          transfer_encoding,
          x_forwarded_for,
          other = []   % misc other headers
         }).
</pre>
<p>The <strong>out/1</strong> function can use the Arg to generate any content it likes. We have the following functions to aid that generation.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">API</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>ssi(DocRoot, ListOfFiles)</strong></p>
  </dt>
  <dd>
    <p>Server side include. Just include the files as is in the document. The files will <strong>not</strong> be parsed and searched for &lt;erl&gt; tags.</p>
  </dd>
  <dt>
    <p><strong>pre_ssi_files(DocRoot, ListOfFiles) -&gt;</strong></p>
  </dt>
  <dd>
    <p>Server side include of pre-indented code.  The data in Files will be included but contained in a &lt;pre&gt; tag. The data will be htmlized.</p>
  </dd>
  <dt>
    <p><strong>pre_ssi_string(String)</strong></p>
  </dt>
  <dd>
    <p>Include htmlized content from String.</p>
  </dd>
  <dt>
    <p><strong>f(Fmt, Args)</strong></p>
  </dt>
  <dd>
    <p>The equivalent of io_lib:format/2. This function is automatically -included in all erlang code which is a part of a yaws page.</p>
  </dd>
  <dt>
    <p><strong>htmlize(Binary | List | Char)</strong></p>
  </dt>
  <dd>
    <p>Htmlize an IO list object.</p>
  </dd>
  <dt>
    <p><strong>set_cookie(Name, Value, Options])</strong></p>
  </dt>
  <dd>
    <p>Sets a cookie to the browser. Options are: <em></em></p>
<pre>
{expires, UtcTime}  - Cookie expiration time, where UtcTime is
                      a tuple returned by calendar:universal_time/0.
{max_age, Age}      - Defines the lifetime of the cookie, in seconds,
                      where age is an integer &gt;= 0.
{path, Path}        - Path is a string that specifies the subset of URLs to
                      which this cookie applies.
{domain, Domain}    - Domain is a string that specifies the domain for which
                      the cookie is valid.
{comment, Comment}  - Comment is a string that doccuments the server's
                      intended use of the cookie.
secure              - Directs the user agent to use only secure means to
                      contact the origin server whenever it sends back this
                      cookie.
http_only           - Restricts cookie access from other non-HTTP APIs.
</pre>

  </dd>
  <dt>
    <p><strong>setcookie(Name, Value, [Path, [ Expire, [Domain , [Secure]]]])</strong></p>
  </dt>
  <dd>
    <p>Sets a cookie to the browser. This function is deprecated by set_cookie/3.</p>
  </dd>
  <dt>
    <p><strong>find_cookie_val(Cookie, Header)</strong></p>
  </dt>
  <dd>
    <p>This function can be used to search for a cookie that was previously set by <strong>setcookie/2-6</strong>. For example if we set a cookie as <strong>yaws_api:setcookie("sid",SomeRandomSid)</strong>, then on subsequent requests from the browser we can call: <strong>find_cookie("sid",(Arg#arg.headers)#headers.cookie)</strong></p><p>The function returns [] if no cookie was found, otherwise the actual cookie is returned as a string.</p>
  </dd>
  <dt>
    <p><strong>parse_set_cookie(Str)</strong></p>
  </dt>
  <dd>
    <p>This function parses the value of a <strong>Set-Cookie</strong> header, following the RFC6265. Because old RFCs (2109 and 2965) are still used, it is backward compatible. So this function returns a <em>#setcookie{}</em> record when only one cookie is found. If multiple cookies are set in a single <strong>Set-Cookie</strong> header, it returns a list of <em>#setcookie{}</em> records. If no cookie was found or if an error occurred, it returns [].</p><p><em>#setcookie{}</em> record is defined in <em>yaws_api.hrl</em>: <em></em></p>
<pre>
-record(setcookie, {key,
                    value,
                    quoted = false,
                    domain,
                    max_age,
                    expires,
                    path,
                    secure = false,
                    http_only = false,
                    extensions = []}).
</pre>

  </dd>
  <dt>
    <p><strong>parse_cookie(Str)</strong></p>
  </dt>
  <dd>
    <p>This function parses the value of <strong>Cookie</strong> header, following the RFC6265. It returns a list of <em>#cookie{}</em> records. If no cookie was found or if an error occurred, it returns [].</p><p><em>#cookie{}</em> record is defined in <em>yaws_api.hrl</em>: <em></em></p>
<pre>
-record(cookie, {key,
                 value,
                 quoted = false}).
</pre>

  </dd>
  <dt>
    <p><strong>format_set_cookie(SetCookie)</strong></p>
  </dt>
  <dd>
    <p>Build a cookie string from a <em>#setcookie{}</em> record like returned by <strong>parse_set_cookie/1</strong>.</p>
  </dd>
  <dt>
    <p><strong>format_cookie(Cookie | [Cookie])</strong></p>
  </dt>
  <dd>
    <p>Build a cookie string from a <em>#cookie{}</em> record (or a list or records) like returned by <strong>parse_cookie/1</strong>.</p>
  </dd>
  <dt>
    <p><strong>redirect(Url)</strong></p>
  </dt>
  <dd>
    <p>This function generates a redirect to the browser. It will clear any previously set headers. So to generate a redirect <strong>and</strong> set a cookie, we need to set the cookie after the redirect as in: <em></em></p>
<pre>
out(Arg) -&gt;
  ... do some stuff

  Ret = [{redirect, "http://www.somewhere.com"},
          setcookie("sid", Random)
        ].

</pre>

  </dd>
  <dt>
    <p><strong>redirect_self(Arg)</strong></p>
  </dt>
  <dd>
    <p>If we want to issue a redirect to ourselves, this function is useful. It returns a record <em>#redir_self{}</em> defined in <em>yaws_api.hrl</em>. The record contains fields to construct a URL to ourselves. <em></em></p>
<pre>
-record(redir_self, {
          host,        % string() - our own host
          scheme,      % http | https
          scheme_str,  % "https://"  | "http://"
          port,        % integer()  - our own port
          port_str     % "" | ":&lt;int&gt;" - the optional port part
                       %                 to append to the url
         }).
</pre>

  </dd>
  <dt>
    <p><strong>get_line(String)</strong></p>
  </dt>
  <dd>
    <p>This function is convenient when getting &#92;r&#92;n terminated lines from a stream of data. It returns:</p><p><strong>{line, Line, Tail}</strong> or <strong>{lastline, Line, Tail}</strong></p><p>The function handles multilines as defined in e.g. SMTP or HTTP</p>
  </dd>
  <dt>
    <p><strong>mime_type(Scope, FileName)</strong></p>
  </dt>
  <dd>
    <p>Returns the MIME type as defined by the extension of <em>FileName</em>. <em>Scope</em> can have following values:</p><p><strong>global</strong> - returns the result obtained from the global context.</p><p><strong>#sconf{} | {ServerName, Port}</strong> - returns the result obtained from the virtual server's context. If no MIME type is found in this scope, it falls back on the global one.</p>
  </dd>
  <dt>
    <p><strong>mime_type(FileName)</strong></p>
  </dt>
  <dd>
    <p>Tries to determine the right <em>Scope</em> before calling mime_type/2.</p>
  </dd>
  <dt>
    <p><strong>stream_chunk_deliver(YawsPid, Data)</strong></p>
  </dt>
  <dd>
    <p>When a yaws function needs to deliver chunks of data which it gets from a process. The other process can call this function to deliver these chunks. It requires the <strong>out/1</strong> function to return the value <strong>{streamcontent, MimeType, FirstChunk}</strong> to work. YawsPid is the process identifier of the yaws process delivering the original .yaws file. That is self() in the yaws code. The Pid must typically be passed (somehow) to the producer of the stream.</p>
  </dd>
  <dt>
    <p><strong>stream_chunk_deliver_blocking(YawsPid, Data)</strong></p>
  </dt>
  <dd>
    <p>A synchronous version of the above function. This synchronous version must always be used when the producer of the stream is faster than the consumer. This is usually the case since the client is the WWW browser.</p>
  </dd>
  <dt>
    <p><strong>stream_chunk_end(YawsPid)</strong></p>
  </dt>
  <dd>
    <p>When the process discussed above is done delivering data, it must call this function to let the yaws content delivering process finish up the HTTP transaction.</p>
  </dd>
  <dt>
    <p><strong>stream_process_deliver(Socket, IoList)</strong></p>
  </dt>
  <dd>
    <p>Yaws allows application processes to deliver data directly to the client. The application tells yaws about such a process by returning <strong>{streamcontent_from_pid, MimeType, Pid}</strong> from its <strong>out/1</strong> function. In this case, <em>Pid</em> uses the <strong>stream_process_deliver/2</strong> function to deliver data to the client. The application gets <em>Socket</em> from <em>Arg#arg.clisock</em>, and <em>IoList</em> is the data to be sent to the client.</p>
  </dd>
  <dt>
    <p><strong>stream_process_deliver_chunk(Socket, IoList)</strong></p>
  </dt>
  <dd>
    <p>Same as above but delivers <em>IoList</em> using HTTP chunked transfer format. <em>IoList</em> must have a size greater than zero. The application process delivering the data will have had to have make sure that the HTTP headers of the response indicate chunked transfer mode, either by ensuring no Content-Length header is set or by specifically setting the Transfer-Encoding header to chunked.</p>
  </dd>
  <dt>
    <p><strong>stream_process_deliver_final_chunk(Socket, IoList)</strong></p>
  </dt>
  <dd>
    <p>If the application process delivering data to the client uses chunked transfer mode, it must call this to deliver the final chunk of the transfer. This tells yaws to create a special final chunk in the format required by the HTTP specification (RFC 2616). <em>IoList</em> may be empty, but if its size is greater than zero, that data will be sent as a separate chunk before the final chunk.</p>
  </dd>
  <dt>
    <p><strong>stream_process_end(Socket, YawsPid)</strong></p>
  </dt>
  <dd>
    <p>Application processes delivering data directly to clients must call this function to inform yaws that they've finished using <em>Socket</em>. The <em>YawsPid</em> argument will have been passed to the process earlier when yaws sent it a message telling it to proceed with data delivery. Yaws expects <em>Socket</em> to be open.</p>
  </dd>
  <dt>
    <p><strong>stream_process_end(closed, YawsPid)</strong></p>
  </dt>
  <dd>
    <p>Same as the previous function but the application calls this if it closes the client socket as part of its data delivery process. This allows yaws to continue without assuming the socket is still open and encountering errors due to that assumption. The <em>YawsPid</em> argument will have been passed to the application process earlier when yaws sent it a message telling it to proceed with data delivery.</p>
  </dd>
  <dt>
    <p><strong>parse_query(Arg)</strong></p>
  </dt>
  <dd>
    <p>This function will parse the query part of the URL. It will return a {Key, Value} list of the items supplied in the query part of the URL.</p>
  </dd>
  <dt>
    <p><strong>queryvar(Arg, VarName)</strong></p>
  </dt>
  <dd>
    <p>This function is automatically included from yaws_api in all  .yaws pages. It is used to search for a variable in the querypart of the url. Returns {ok, Val} or undefined. If a variable is defined multiple times, the function may also return <em>{Val1, ....}</em>.</p>
  </dd>
  <dt>
    <p><strong>parse_post(Arg)</strong></p>
  </dt>
  <dd>
    <p>This function will parse the POST data as supplied from the browser. It will return a {Key, Value} list of the items set by the browser.</p>
  </dd>
  <dt>
    <p><strong>postvar(Arg, VarName)</strong></p>
  </dt>
  <dd>
    <p>This function is automatically included from yaws_api in all  .yaws pages. It is used to search for a variable in the POSTed data from the client. Returns {ok, Val} or undefined. If a variable is defined multiple times, the function may also return <em>{Val1, ....}</em>.</p>
  </dd>
  <dt>
    <p><strong>getvar(Arg, VarName)</strong></p>
  </dt>
  <dd>
    <p>This function  looks at the HTTP request method from the client and invokes postvar/2 if it is a POST from the client and queryvar/2 if it is a GET request from the client.</p>
  </dd>
  <dt>
    <p><strong>parse_multipart_post(Arg)</strong></p>
  </dt>
  <dd>
    <p>If the browser has set the Content-Type header to the value "multipart/form-data", which is the case when the browser wants to upload a file to the server the following happens:</p><p>If the function returns <strong>{result, Res}</strong> no more data will come from the browser.</p><p>If the function returns <strong>{cont, Cont, Res}</strong> the browser will supply more data. (The file was to big to come in one read)</p><p>This indicates that there is more data to come and the out/1 function should return {get_more, Cont, User_state} where User_state might usefully be a File Descriptor. The Res value is a list of either: <strong>{head, {Name, Headers}}</strong> | <strong>{part_body, Binary}</strong> | <strong>{body, Binary}</strong></p><p>The function returns <strong>{error, Reason}</strong> when an error occurred during the parsing.</p><p>Example usage could be: <em></em></p>
<pre>
 &lt;erl&gt;

 out(A) -&gt;
        case yaws_api:parse_multipart_post(A) of
             {cont, Cont, Res} -&gt;
                    St = handle_res(A, Res),
                    {get_more, Cont, St};
             {result, Res} -&gt;
                    handle_res(A, Res),
                    {html, f("&lt;pre&gt;Done &lt;/pre&gt;",[])};
             {error, Reason} -&gt;
                    {html, f("An error occured: ~p", [Reason])}
        end.

 handle_res(A, [{head, {Name, _Hdrs}}|T]) -&gt;
      io:format("head:~p~n",[Name]),
      handle_res(A, T);
 handle_res(A, [{part_body, Data}|T]) -&gt;
      io:format("part_body:~p~n",[Data]),
      handle_res(A, T);
 handle_res(A, [{body, Data}|T]) -&gt;
      io:format("body:~p~n",[Data]),
      handle_res(A, T);
 handle_res(A, []) -&gt;
      io:format("End_res~n").

 &lt;/erl&gt;
</pre>

  </dd>
  <dt>
    <p><strong>new_cookie_session(Opaque)</strong></p>
  </dt>
  <dd>
    <p>Create a new cookie based session, the yaws system will set the cookie. The new random generated cookie is returned from this function. The Opaque argument will typically contain user data such as user name and password</p>
  </dd>
  <dt>
    <p><strong>new_cookie_session(Opaque, TTL)</strong></p>
  </dt>
  <dd>
    <p>As above, but allows to set a session specific time-out value, overriding the system specified time-out value.</p>
  </dd>
  <dt>
    <p><strong>new_cookie_session(Opaque, TTL, CleanupPid)</strong></p>
  </dt>
  <dd>
    <p>As above, but also sends a message <em>{yaws_session_end, Reason, Cookie, Opaque}</em> to the provided CleanuPid where Reason can be either of <em>timeout</em> or <em>normal</em>. The <em>Cookie</em> is the HTTP cookie as returned by <em>new_session()</em> and the Opaque is the user provided Opaque parameter to <em>new_session()</em>. The purpose of the feature is to cleanup resources assigned to the session.</p>
  </dd>
  <dt>
    <p><strong>cookieval_to_opaque(CookieVal)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>print_cookie_sessions() </strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>replace_cookie_session(Cookie, NewOpaque)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>delete_cookie_session(Cookie)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>setconf(Gconf, Groups)</strong></p>
  </dt>
  <dd>
    <p>This function is intended for embedded mode in yaws. It makes it possible to load a yaws configuration from another data source than /etc/yaws.conf, such as a database. If yaws is started with the environment <em>{embedded, true}</em>, yaws will start with an empty default configuration, and wait for some other program to execute a <em>setconf/2</em> The Gconf is a <em>#gconf{}</em> record and the Group variable is a list of lists of <em>#sconf{}</em> records. Each sublist must contain <em>#sconf{}</em> records with the same IP/Port listen address. To create a suitable initial #gconf{} record see the code in yaws_config:make_default_gconf/2. Especially the <em>yaws_dir</em> parameter is important to get right.</p>
  </dd>
  <dt>
    <p><strong>url_decode(Str)</strong></p>
  </dt>
  <dd>
    <p>Decode url-encoded string. A URL encoded string is a string where all alfa numeric characters and the the character _ are preserved and all other characters are encode as "%XY" where X and Y are the hex values of the least respective most significant 4 bits in the 8 bit character.</p>
  </dd>
  <dt>
    <p><strong>url_encode(Str)</strong></p>
  </dt>
  <dd>
    <p>Url-encodes a string. All URLs in HTML documents must be URL encoded.</p>
  </dd>
  <dt>
    <p><strong>get_sslsocket(Socket)</strong></p>
  </dt>
  <dd>
    <p>Returns a socket for SSL sockets or the atom <em>undefined</em> for non-SSL sockets. Useful for applications that have to deal with both SSL and non-SSL sockets.</p>
  </dd>
  <dt>
    <p><strong>get_listen_port(Sconf)</strong></p>
  </dt>
  <dd>
    <p>Return the actual port number used by the listen socket of the virtual server indicated by the function argument, an <em>#sconf{}</em> record instance. If successful, returns the requested port number, or returns <em>{error, not_found}</em> if the function argument does not match any known virtual server. This function is useful for retrieving the actual port number when, e.g. for testing purposes, a virtual server is configured to use port 0, which will cause it to have an ephemeral port assigned by the operating system.</p>
  </dd>
  <dt>
    <p><strong>reformat_header(H)</strong></p>
  </dt>
  <dd>
    <p>Returns a list of reformatted header values from a #headers{} record. The return list is suitable for retransmit.</p>
  </dd>
  <dt>
    <p><strong>reformat_header(H, FormatFun)</strong></p>
  </dt>
  <dd>
    <p>Returns a list of reformatted header values from a #headers{} record, with each element of the list formatted via a call to <em>FormatFun</em>. This enables converting #headers{} records into various lists of headers and their values. Note that sometimes the <em>Set-Cookie</em> header will contain a tuple value of the form <em>{multi, ValueList}</em> \[em] see <em>merge_header/2</em> below for details \[em] so formatting functions should be prepared to handle such a tuple. They should handle it by formatting each member of <em>ValueList</em> as a separate <em>Set-Cookie</em> header, then returning all such header-value pairs in a list. Note that this implies that sometimes the return values of <em>reformat_header/1</em> and <em>reformat_header/2</em> can be a multi-level list. The <em>{multi,</em> ValueList} construct results only from calls to <em>merge_header/2</em> or <em>merge_header/3</em>, where multiple values are set in separate calls for the same header.</p>
  </dd>
  <dt>
    <p><strong>set_header(Headers, {Header, Value})</strong></p>
  </dt>
  <dd>
    <p>Sets header <em>Header</em> with value <em>Value</em> in the #headers{} record <em>Headers</em>, and returns a new #headers{} record. Using the atom <em>undefined</em> for <em>Value</em> effectively deletes the header, same as <em>delete_header/2</em>.</p>
  </dd>
  <dt>
    <p><strong>set_header(Headers, Header, Value)</strong></p>
  </dt>
  <dd>
    <p>Same as <em>set_header/2</em> above, except <em>Header</em> and <em>Value</em> are not passed in a tuple.</p>
  </dd>
  <dt>
    <p><strong>merge_header(Headers, {Header, Value})</strong></p>
  </dt>
  <dd>
    <p>Merges value <em>Value</em> for header <em>Header</em> with any existing value for that header in the #headers{} record <em>Headers</em>, and returns a new #headers{} record. Using the atom <em>undefined</em> for <em>Value</em> simply returns <em>Headers</em>. Otherwise, <em>Value</em> is merged with any existing value already present in the <em>Headers</em> record for header <em>Header</em>, comma-separated from that existing value. If no such value exists in the <em>Headers</em> record, the effect is the same as <em>set_header/2</em>. Note that for the <em>Set-Cookie</em> header, values are not comma-separated but are instead collected into a tuple <em>{multi, ValueList}</em> where <em>ValueList</em> is the collection of <em>Set-Cookie</em> values. This implies that any formatting fun passed to <em>reformat_header/2</em> must be prepared to handle such tuples.</p>
  </dd>
  <dt>
    <p><strong>merge_header(Headers, Header, Value)</strong></p>
  </dt>
  <dd>
    <p>Same as <em>merge_header/2</em> above, except <em>Header</em> and <em>Value</em> are not passed in a tuple.</p>
  </dd>
  <dt>
    <p><strong>get_header(Headers, Header)</strong></p>
  </dt>
  <dd>
    <p>Gets the value of header <em>Header</em> from the #headers{} record <em>Headers</em> and returns it. If the header isn't set, the atom <em>undefined</em> is returned.</p>
  </dd>
  <dt>
    <p><strong>delete_header(Headers, Header)</strong></p>
  </dt>
  <dd>
    <p>Deletes any value set for header <em>Header</em> in the #headers{} record <em>Headers</em>, and returns a new #headers{} record.</p>
  </dd>
  <dt>
    <p><strong>request_url(ARG)</strong></p>
  </dt>
  <dd>
    <p>Return the url as requested by the client. Return value is a #url{} record as defined in yaws_api.hrl</p>
  </dd>
  <dt>
    <p><strong>parse_url(Str)</strong></p>
  </dt>
  <dd>
    <p>Parse URL in a string, returns a #url record</p>
  </dd>
  <dt>
    <p><strong>format_url(UrlRecord)</strong></p>
  </dt>
  <dd>
    <p>Takes a #url record a formats the Url as a string</p>
  </dd>
  <dt>
    <p><strong>call_cgi(Arg, Scriptfilename)</strong></p>
  </dt>
  <dd>
    <p>Calls an executable CGI script, given by its full path.  Used to make `.yaws' wrappers for CGI programs.  This function usually returns <em>streamcontent</em>.</p>
  </dd>
  <dt>
    <p><strong>call_cgi(Arg, Exefilename, Scriptfilename)</strong></p>
  </dt>
  <dd>
    <p>Like before, but calls <em>Exefilename</em> to handle the script.  The file name of the script is handed to the executable via a CGI meta variable.</p>
  </dd>
  <dt>
    <p><strong>call_fcgi_responder(Arg)</strong></p>
  </dt>
  <dd>
    <p>Calls a FastCGI responder. The address and port of the FastCGI application server are taken from the server configuration (see yaws.conf). Used to make `.yaws' wrappers for FastCGI responders. Returns the same return values as out/1 (see below).</p>
  </dd>
  <dt>
    <p><strong>call_fcgi_responder(Arg, Options)</strong></p>
  </dt>
  <dd>
    <p>Same as above, but Options overrides the defaults from the server configuration:</p><p><em></em></p>
<pre>
Options = [Option]
Option -- one of the following:
</pre>
<p><strong>{app_server_host, string() | ip_address()}</strong> The hostname or the IP address of the FastCGI application server.</p><p><strong>{app_server_port, 0..65535}</strong> The TCP port number of the FastCGI application server.</p><p><strong>{path_info, string()}</strong> Override default pathinfo in Arg#arg.pathinfo.</p><p><strong>{extra_env, ExtraEnv}</strong> Override default pathinfo in Arg#arg.pathinfo.</p><p><em></em></p>
<pre>
ExtraEnv = [Var]
Var = {Name, Value}
Name = string()
Value = string()
</pre>
<p><strong>{trace_protocol, boolean()}</strong> Enable or disable tracing of FastCGI protocol messages as info log messages.</p><p><strong>{log_app_error, boolean()}</strong> Enable or disable logging of application error messages: output to stderr and non-zero exit value.</p>
  </dd>
  <dt>
    <p><strong>call_fcgi_authorizer(Arg) -&gt; {allowed, Out} | {denied, Out}</strong></p>
  </dt>
  <dd>
    <p>Calls a FastCGI authorizer. The address and port of the FastCGI application server are taken from the server configuration (see yaws.conf). Used to make `.yaws' wrappers for FastCGI authorizers. Variables contains the values of the variables returned by the FastCGI application server in the "Variable-XXX: YYY" headers.</p><p>If access is denied, Out contains the complete response returned by the FastCGI application server. This response is typically returned as-is to the HTTP client.</p><p>If access is allowed, Out contains the response returned by the FastCGI application server minus the body (i.e. minus the content) which should be ignored per the FastCGI specification. This response is typically not returned to the HTTP client. The calling application module may wish to inspect the response, for example by extracting variables (see fcgi_extract_variables below) or by inspecting the headers returned by the FastCGI application server.</p><p><em></em></p>
<pre>
Out -- See return values for out/1 below
</pre>

  </dd>
  <dt>
    <p><strong>call_fcgi_authorizer(Arg, Options) -&gt; {allowed, Out} | {denied, Out}</strong></p>
  </dt>
  <dd>
    <p>Same as above, but Options overrides the defaults from the server configuration. See call_fcgi_responder/2 above for a description of Options.</p>
  </dd>
  <dt>
    <p><strong>fcgi_extract_variables(Out) -&gt; [{Name, Value}]</strong></p>
  </dt>
  <dd>
    <p>Extracts the environment variables from a FastCGI authorizer response by looking for headers of the form "Variable-Name: Value".</p><p><em></em></p>
<pre>
Name = string() -- The name of the variable (the "Variable-" prefix
has already been removed).
Value = string() -- The value of the variable.
</pre>

  </dd>
  <dt>
    <p><strong>dir_listing(Arg)</strong></p>
  </dt>
  <dd>
    <p>Perform a directory listing. Can be used in special directories when we don't want to turn on dir listings for the entire server. Always returns ok.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUES from out/1</h2>
        <div class="sectioncontent">
<p>The out/1 function can return different values to control the behavior of the server.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>{html, DeepList}</strong><strong></strong></p>
  </dt>
  <dd>
    <p>This assumes that DeepList is formatted HTML code. The code will be inserted in the page.</p>
  </dd>
  <dt>
    <p><strong>{ehtml|exhtml, Term}</strong></p>
  </dt>
  <dd>
    <p>This will transform the erlang term Term into a stream of HTML content. The exhtml variant transforms into strict XHTML code. The basic syntax of Term is</p><p><em></em></p>
<pre>
EHTML = [EHTML] | {Tag, Attrs, Body} | {Tag, Attrs} | {Tag} |
        binary() | character()
Tag      = atom()
Attrs = [{Key, Value}]  or {EventTag, {jscall, FunName, [Args]}}
Key      = atom()
Value = string()
Body  = EHTML
</pre>
<p>For example, <em>{p, [], "Howdy"}</em> expands into "&lt;p&gt;Howdy&lt;/p&gt;" and</p><p><em></em></p>
<pre>
{form, [{action, "a.yaws"}],
   {input, [{type,text}]}}

</pre>
<p>expands into</p><p><em></em></p>
<pre>
&lt;form action="a.yaws"
  &lt;input type="text"&gt;
&lt;/form&gt;
</pre>
<p>It may be more convenient to generate erlang tuples than plain html code.</p>
  </dd>
  <dt>
    <p><strong>{content, MimeType, Content}</strong></p>
  </dt>
  <dd>
    <p>This function will make the web server generate different content than HTML. This return value is only allowed in a yaws file which has only one &lt;erl&gt; &lt;/erl&gt; part and no html parts at all.</p>
  </dd>
  <dt>
    <p><strong>{streamcontent, MimeType, FirstChunk}</strong></p>
  </dt>
  <dd>
    <p>This return value plays the same role as the <em>content</em> return value above.</p><p>However it makes it possible to stream data to the client if the yaws code doesn't have access to all the data in one go. (Typically if a file is very large or if data arrives from back end servers on the network.</p>
  </dd>
  <dt>
    <p><strong>{streamcontent_with_timeout, MimeType, FirstChunk, Timeout}</strong></p>
  </dt>
  <dd>
    <p>Similar to above, but with an explicit timeout. The default timeout is 30 secs. I.e if the application fails to deliver data to the Yaws process, the streaming will stop. This is often not the desired behaviour in Comet/Ajax applications.  It's possible to provide 'infinity' as timeout.</p>
  </dd>
  <dt>
    <p><strong>{streamcontent_from_pid, MimeType, Pid}</strong></p>
  </dt>
  <dd>
    <p>This return value is similar to the <em>streamcontent</em> return value above.</p><p>However it makes it possible to stream data to the client directly from an application process to the socket. This approach can be useful for applications that employ long-polling (Comet) techniques, for example, and for applications wanting to avoid buffering data or avoid HTTP chunked mode transfer for streamed data.</p>
  </dd>
  <dt>
    <p><strong>{streamcontent_with_size, Sz, MimeType, FirstChunk}</strong></p>
  </dt>
  <dd>
    <p>This return value is similar to the <em>streamcontent</em> return value above.</p><p>However it makes it possible to stream data to the client by setting the content length of the response. As the opposite of other ways to stream data, in this case, the response is not chunked encoded.</p>
  </dd>
  <dt>
    <p><strong>{header, H}</strong></p>
  </dt>
  <dd>
    <p>Accumulates a HTTP header. The trailing CRNL which is supposed to end all HTTP headers must NOT be added. It is added by the server. The following list of headers are given special treatment.</p><p><em>{connection, What}</em></p><p>This sets the Connection: header. If <em>What</em> is the special value <em>"close"</em>, the connection will be closed once the yaws page is delivered to the client.</p><p><em>{server, What}</em></p><p>Sets the Server: header. By setting this header, the server's signature will be dynamically overloaded.</p><p><em>{location, Url}</em></p><p>Sets the Location: header. This header is typically combined with the <em>{status, 302}</em> return value.</p><p><em>{cache_control, What}</em></p><p>Sets the Cache-Control: header.</p><p><em>{expires, What}</em></p><p>Sets the Expires: header.</p><p><em>{date, What}</em></p><p>Sets the Date: header.</p><p><em>{allow, What}</em></p><p>Sets the Allow: header.</p><p><em>{last_modified, What}</em></p><p>Sets the Last-Modified: header.</p><p><em>{etag, What}</em></p><p>Sets the Etag: header.</p><p><em>{set_cookie, Cookie}</em></p><p>Prepends a Set-Cookie: header to the list of previously set Set-Cookie: headers.</p><p><em>{content_range, What}</em></p><p>Sets the Content-Range: header.</p><p><em>{content_type, MimeType}</em></p><p>Sets the Content-Type: header.</p><p><em>{content_encoding, What}</em></p><p>Sets the Content-Encoding: header. If this header is defined, no deflate is performed by Yaws. So you can compress data by yourself.</p><p><em>{content_length, Len}</em></p><p>Normally yaws will ship Yaws pages using Transfer-Encoding: chunked. This is because we generally can't know how long a yaws page will be. If we for some reason want to force a Content-Length: header (and we actually do know the length of the content, we can force yaws to not ship the page chunked.</p><p><em>{transfer_encoding, What}</em></p><p>Sets the Transfer-Encoding: header.</p><p><em>{www_authenticate, What}</em></p><p>Sets the WWW-Authenticate: header.</p><p><em>{vary, What}</em></p><p>Sets the Vary: header.</p><p>All other headers must be added using the normal HTTP syntax. Example:</p><p><em>{header, {"My-X-Header", "gadong"}}</em> or <em>{header, "My-X-Header: gadong"}</em></p>
  </dd>
  <dt>
    <p><strong>{header, {HeaderName, erase}}</strong></p>
  </dt>
  <dd>
    <p>Clears the header named <em>HeaderName</em> from the accumulated headers.</p>
  </dd>
  <dt>
    <p><strong>{allheaders, HeaderList}</strong></p>
  </dt>
  <dd>
    <p>Will clear all previously accumulated headers and replace them.</p>
  </dd>
  <dt>
    <p><strong>{status, Code}</strong></p>
  </dt>
  <dd>
    <p>Will set another HTTP status code than 200.</p>
  </dd>
  <dt>
    <p><strong>break</strong></p>
  </dt>
  <dd>
    <p>Will stop processing of any consecutive chunks of erl or html code in the yaws file.</p>
  </dd>
  <dt>
    <p><strong>ok</strong></p>
  </dt>
  <dd>
    <p>Do nothing.</p>
  </dd>
  <dt>
    <p><strong>flush</strong></p>
  </dt>
  <dd>
    <p>Flush remaining data sent by the client.</p>
  </dd>
  <dt>
    <p><strong>{redirect, Url}</strong></p>
  </dt>
  <dd>
    <p>Erase all previous headers and accumulate a single Location header. Set the status code.</p>
  </dd>
  <dt>
    <p><strong>{redirect_local, Path}</strong></p>
  </dt>
  <dd>
    <p>Does a redirect to the same Scheme://Host:Port/Path as we currently are executing in.</p>
  </dd>
  <dt>
    <p><strong>{get_more, Cont, State}</strong></p>
  </dt>
  <dd>
    <p>When we are receiving large POSTs we can return this value and be invoked again when more Data arrives.</p>
  </dd>
  <dt>
    <p><strong>{page, Page}</strong></p>
  </dt>
  <dd>
    <p>Make Yaws returns a different page than the one being requested. <em>Page</em> is a Request-URI, so it must be url-encoded and can contain a query-string.</p>
  </dd>
  <dt>
    <p><strong>{page, {Options, Page}}</strong></p>
  </dt>
  <dd>
    <p>Like the above, but supplying an additional deep list of options. Supported option types are:</p><p><em>{status, C}</em> - Set the HTTP response status code <em>C</em> for page <em>Page</em>.</p><p><em>{header, H}</em> - Accumulate the HTTP header <em>H</em> for page <em>Page</em>.</p><p><em>{disable_cache, Bool}</em> - if set to <em>true</em>, disable the cache of <em>Page</em> for this call.</p>
  </dd>
  <dt>
    <p><strong>{ssi, File, Delimiter, Bindings}</strong></p>
  </dt>
  <dd>
    <p>Server side include File and  macro expansion in File. Each occurrence of a string, say "xyz", inside File which is inside Delimiters is replaced with the corresponding value in Bindings.</p><p>Example: Delimiter = %%</p><p>File contains the string .... %%xyz%%  .....</p><p>Bindings contain the tuple {"xyz", "Dingbat"}</p><p>The occurrence of %%xyz%% in File will be replaced with "Dingbat" in the Server side included output.</p><p>The {ssi, File, Delimiter, Bindings} statement can also occur inside a deep ehtml structure.</p>
  </dd>
  <dt>
    <p><strong>{bindings, [{Key1, Value2}, {Key2, Value2} .....]}</strong></p>
  </dt>
  <dd>
    <p>Establish variable bindings that can be used in the page.</p><p>All bindings can then be used in the rest of yaws code (in HTML source and within erl tags). In HTML source %%Key%% is expanded to Value and within erl tags <em>yaws_api:binding(Key)</em> can be used to extract Value and <em>yaws_api:binding_exists(Key)</em> can be used to check for the existence of a binding.</p>
  </dd>
  <dt>
    <p><strong>{yssi, YawsFile}</strong></p>
  </dt>
  <dd>
    <p>Include a yaws file. Compile it and expand as if it had occured inline.</p>
  </dd>
  <dt>
    <p><strong>[ListOfValues]</strong></p>
  </dt>
  <dd>
    <p>It is possible to return a deep list of the above defined return values. Any occurrence of <em>streamcontent</em>, <em>streamcontent_with_timeout</em>, <em>streamcontent_with_size</em>, <em>streamcontent_from_pid</em>, <em>get_more</em>, <em>page</em> or <em>break</em> in this list is legal only if it is the last position of the list. If not, remaining values in the list are ignored.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Written by Claes Wikstrom</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO yaws_api&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man5/yaws.conf.5.html"><strong>yaws.conf</strong>(5)</a> <a href="../man1/erl.1.html"><strong>erl</strong>(1)</a></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="yaws.conf.5.html"><span aria-hidden="true">&larr;</span> yaws.conf.5: Configuration file for the yaws web server</a></li>
   <li class="next"><a href="yaws_soap_lib.5.html">yaws_soap_lib.5: Api for the yaws soap-functionality <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

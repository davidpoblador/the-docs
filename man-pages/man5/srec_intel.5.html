<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>srec_intel: Intel hexadecimal object file format specification</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Intel hexadecimal object file format specification">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="srec_intel (5) manual">
  <meta name="twitter:description" content="Intel hexadecimal object file format specification">
  <meta name="twitter:image" content="https://www.carta.tech/images/srecord-srec_intel-5.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man5/srec_intel.5.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="srec_intel (5) manual" />
  <meta property="og:description" content="Intel hexadecimal object file format specification" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/srecord-srec_intel-5.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">srec_intel<small> (5)</small></h1>
        <p class="lead">Intel hexadecimal object file format specification</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/">
      <span itemprop="name">File formats and conventions</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/srec_intel.5.html">
      <span itemprop="name">srec_intel: Intel hexadecimal object file format specification</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/srecord/">
      <span itemprop="name">srecord</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/srec_intel.5.html">
      <span itemprop="name">srec_intel: Intel hexadecimal object file format specification</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This format is also known as the <em>Intel MCS\[hy]86 Object</em> format.</p><p>This document describes the hexadecimal object file format for the Intel 8\[hy]bit, 16\[hy]bit, and 32\[hy]bit microprocessors.  The hexadecimal format is suitable as input to PROM programmers or hardware emulators.</p><p>Hexadecimal object file format is a way of representing an absolute binary object file in ASCII.  Because the file is in ASCII instead of binary, it is possible to store the file is non\[hy]binary medium such as paper\[hy]tape, punch cards, etc.; and the file can also be displayed on CRT terminals, line printers, etc..  The 8\[hy]bit hexadecimal object file format allows for the placement of code and data within the 16\[hy]bit linear address space of the Intel 8\[hy]bit processors. The 16\[hy]bit hexadecimal format allows for the 20\[hy]bit segmented address space of the Intel 16\[hy]bit processors.  And the 32\[hy]bit format allows for the 32\[hy]bit linear address space of the Intel 32\[hy]bit processors.</p><table class="table table-striped">
<tr>
<th>--address-length=2</th>
<th>\[lq]i8hex\[rq]</th>
<th>16\[hy]bit</th>
<th></th></tr>

<tr>
<td>--address-length=3</td>
<td>\[lq]i16hex\[rq]</td>
<td>20\[hy]bit</td>
<td>segmented</td></tr>

<tr>
<td>--address-length=4</td>
<td>\[lq]i32hex\[rq]</td>
<td>32\[hy]bit</td>
<td>linear</td></tr>
</table><p>The hexadecimal representation of binary is coded in ASCII alphanumeric characters.  For example, the 8\[hy]bit binary value 0011\[hy]1111 is 3F in hexadecimal.  To code this in ASCII, one 8\[hy]bit byte containing the ASCII code for the character '3' (0011\[hy]0011 or 0x33) and one 8\[hy]bit byte containing the) ASCII code for the character 'F' (0100\[hy]0110 or 0x46) are required.  For each byte value, the high\[hy]order hexadecimal digit is always the first digit of the pair of hexadecimal digits. This representation (ASCII hexadecimal) requires twice as many bytes as the binary representation.</p><p>A hexadecimal object file is blocked into records, each of which contains the record type, length, memory load address and checksum in addition to the data.  There are currently six (6) different types of records that are defined, not all combinations of these records are meaningful, however.  The record are:</p>
<dl class='dl-vertical'>
  <dt>
    <p>&bull;</p>
  </dt>
  <dd>
    <p>Data Record (8\[hy], 16\[hy], or 32\[hy]bit formats)</p>
  </dd>
  <dt>
    <p>&bull;</p>
  </dt>
  <dd>
    <p>End of File Record (8\[hy], 16\[hy], or 32\[hy]bit formats)</p>
  </dd>
  <dt>
    <p>&bull;</p>
  </dt>
  <dd>
    <p>Extended Segment Address Record (16\[hy] or 32\[hy]bit formats)</p>
  </dd>
  <dt>
    <p>&bull;</p>
  </dt>
  <dd>
    <p>Start Segment Address Record (16\[hy] or 32\[hy]bit formats)</p>
  </dd>
  <dt>
    <p>&bull;</p>
  </dt>
  <dd>
    <p>Extended Linear Address Record (32\[hy]bit format only)</p>
  </dd>
  <dt>
    <p>&bull;</p>
  </dt>
  <dd>
    <p>Start Linear Address Record (32\[hy]bit format only)</p>
  </dd>

</dl>
<h3>General Record Format</h3>
<table class="table table-striped">
<tr>
<th>Record            Mark     </th>
<th>Record            Length     </th>
<th>Load            Offset     </th>
<th>Record            Type     </th>
<th>Data</th>
<th>Check            sum     </th></tr>
</table>
<dl class='dl-vertical'>
  <dt>
    <p>Record Mark.</p>
  </dt>
  <dd>
    <p>Each record begins with a Record Mark field containing 0x3A, the ASCII code for the colon (\[lq]:\[rq]) character.</p>
  </dd>
  <dt>
    <p>Record Length</p>
  </dt>
  <dd>
    <p>Each record has a Record Length field which specifies the number of bytes of information or data which follows the Record Type field of the record. This field is one byte, represented as two hexadecimal characters. The maximum value of the Record Length field is hexadecimal 'FF' or 255.</p>
  </dd>
  <dt>
    <p>Load Offset</p>
  </dt>
  <dd>
    <p>Each record has a Load Offset field which specifies the 16\[hy]bit starting load offset of the data bytes, therefore this field is only used for Data Records.  In other records where this field is not used, it should be coded as four ASCII zero characters (\[lq]0000\[rq] or 0x30303030). This field is two byte, represented as four hexadecimal characters.</p>
  </dd>
  <dt>
    <p>Record Type</p>
  </dt>
  <dd>
    <p>Each record has a Record Type field which specifies the record type of this record.  The Record Type field is used to interpret the remaining information within the record.  This field is one byte, represented as two hexadecimal characters.  The encoding for all the current record types are:</p>
<dl class='dl-vertical'>
  <dt>
    <p>0</p>
  </dt>
  <dd>
    <p>Data Record</p>
  </dd>
  <dt>
    <p>1</p>
  </dt>
  <dd>
    <p>End of File Record</p>
  </dd>
  <dt>
    <p>2</p>
  </dt>
  <dd>
    <p>Extended Segment Address Record</p>
  </dd>
  <dt>
    <p>3</p>
  </dt>
  <dd>
    <p>Start Segment Address Record</p>
  </dd>
  <dt>
    <p>4</p>
  </dt>
  <dd>
    <p>Extended Linear Address Record</p>
  </dd>
  <dt>
    <p>5</p>
  </dt>
  <dd>
    <p>Start Linear Address Record</p>
  </dd>

</dl>

  </dd>
  <dt>
    <p>Data</p>
  </dt>
  <dd>
    <p>Each record has a variable length Data field, it consists of zero or more bytes encoded as pairs of hexadecimal digits.  The interpretation of this field depends on the Record Type field.</p>
  </dd>
  <dt>
    <p>Checksum</p>
  </dt>
  <dd>
    <p>Each record ends with a Checksum field that contains the ASCII hexadecimal representation of the two's complement of  the 8\[hy]bit bytes that result from converting each pair of ASCII hexadecimal digits to one byte of binary, from and including the Record Length field to and including the last byte of the Data field.  Therefore, the sum of all the ASCII pairs in a record after converting to binary, from the Record Length field to and including the Checksum field, is zero.</p>
  </dd>

</dl>

<h3>Extended Linear Address Record</h3>
<p>(32\[hy]bit format only)</p><table class="table table-striped">
<tr>
<th>Record            Mark            (\[lq]:\[rq])     </th>
<th>Record            Length            (2)     </th>
<th>Load            Offset            (0)     </th>
<th>Record            Type            (4)     </th>
<th>ULBA (2            bytes)     </th>
<th>Check            sum     </th></tr>
</table><p>The 32\[hy]bit Extended Linear Address Record is used to specify bits 16\[hy]31 of the Linear Base Address (LBA), where bits 0\[hy]15 of the LBA are zero. Bits 16\[hy]31 of the LBA are referred to as the Upper Linear Base Address (ULBA).  The absolute memory address of a content byte in a subsequent Data Record is) obtained by adding the LBA to an offset calculated by adding the Load Offset field of the containing Data Record to the index of the byte in the Data Record (0, 1, 2, ... <em>n</em>).  This offset addition is done) modulo 4G (<em>i.e.</em> 32\[hy]bits from 0xFFFFFFFF to 0x00000000) results in wrapping around from the end to the beginning of the 4G linear address defined by the LBA.  The linear address at which a particular byte is loaded is calculated as:</p><p>(LBA + DRLO + DRI) MOD 4G</p><p>where:</p>
<dl class='dl-vertical'>
  <dt>
    <p>DRLO</p>
  </dt>
  <dd>
    <p>is the Load Offset field of a Data Record.</p>
  </dd>
  <dt>
    <p>DRI</p>
  </dt>
  <dd>
    <p>is the data byte index within the Data Record.</p>
  </dd>

</dl>
<p>When an Extended Linear Address Record defines the value of LBA, it may appear anywhere within a 32\[hy]bit hexadecimal object file. This value remains in effect until another Extended Linear Address Record is encountered.  The LBA defaults to zero until an Extended Linear Address Record is encountered.  The contents of the individual fields within the record are:</p>
<dl class='dl-vertical'>
  <dt>
    <p>Record Mark</p>
  </dt>
  <dd>
    <p>This field contains 0x3A, the hexadecimal encoding of the ASCII colon (\[lq]:\[rq]) character.</p>
  </dd>
  <dt>
    <p>Record Length</p>
  </dt>
  <dd>
    <p>The field contains 0x3032, the hexadecimal encoding of the ASCII characters \[lq]02\[rq], which is the length, in bytes, of the ULBA data information within this record.</p>
  </dd>
  <dt>
    <p>Load Offset</p>
  </dt>
  <dd>
    <p>This field contains 0x30303030, the hexadecimal encoding of the ASCII characters \[lq]0000\[rq], since this field is not used for this record.</p>
  </dd>
  <dt>
    <p>Record Type</p>
  </dt>
  <dd>
    <p>This field contains 0x3034, the hexadecimal encoding of the ASCII character \[lq]04\[rq], which specifies the record type to be an Extended Linear Address Record.</p>
  </dd>
  <dt>
    <p>ULBA</p>
  </dt>
  <dd>
    <p>This field contains four ASCII hexadecimal digits that specify the 16\[hy]bit Upper Linear Base Address value.  The value is encoded big\[hy]endian (most significant digit first).</p>
  </dd>
  <dt>
    <p>Checksum</p>
  </dt>
  <dd>
    <p>This field contains the check sum on the Record Length, Load Offset, Record Type, and ULBA fields.</p>
  </dd>

</dl>

<h3>Extended Segment Address Record</h3>
<p>(16\[hy] or 32\[hy]bit formats)</p><table class="table table-striped">
<tr>
<th>Record            Mark            (\[lq]:\[rq])     </th>
<th>Record            Length            (2)     </th>
<th>Load            Offset            (0)     </th>
<th>Record            Type            (2)     </th>
<th>USBA (2            bytes)     </th>
<th>Check            sum     </th></tr>
</table><p>The 16\[hy]bit Extended Segment Address Record is used to specify bits 4\[hy]19 of the Segment Base Address (SBA), where bits 0\[hy]3 of the SBA are zero. Bits 4\[hy]19 of the SBA are referred to as the Upper Segment Base Address (USBA).  The absolute memory address of a content byte in a subsequent Data Record is) obtained by adding the SBA to an offset calculated by adding the Load Offset field of the containing Data Record to the index of the byte in the Data Record (0, 1, 2, ... <em>n</em>).  This offset addition is done modulo 64K (<em>i.e.</em> 16\[hy]bits from 0xFFFF to 0x0000 results in wrapping around from the end to the beginning of the 64K segment defined by the SBA.  The address at which a particular byte is loaded is calculated as:</p><p>SBA + ((DRLO + DRI) MOD 64K)</p><p>where:</p>
<dl class='dl-vertical'>
  <dt>
    <p>DRLO</p>
  </dt>
  <dd>
    <p>is the LOAD OFFSET field of a Data Record.</p>
  </dd>
  <dt>
    <p>DRI</p>
  </dt>
  <dd>
    <p>is the data byte index within the Data Record.</p>
  </dd>

</dl>
<p>When an Extended Segment Address Record defines the value of SBA, it may appear anywhere within a 16\[hy]bit hexadecimal object file. This value remains in effect until another Extended Segment Address Record is encountered.  The SBA defaults to zero until an Extended Segment Address Record is encountered.</p><p>The contents of the individual fields within the record are:</p>
<dl class='dl-vertical'>
  <dt>
    <p>Record Mark</p>
  </dt>
  <dd>
    <p>This field contains 0x3A, the hexadecimal encoding of the ASCII colon (\[lq]:\[rq]) character.</p>
  </dd>
  <dt>
    <p>Record Length</p>
  </dt>
  <dd>
    <p>The field contains 0x3032, the hexadecimal encoding of the ASCII characters '02', which is the length, in bytes, of the USBA data information within this record.</p>
  </dd>
  <dt>
    <p>Load Offset</p>
  </dt>
  <dd>
    <p>This field contains 0x30303030, the hexadecimal encoding of the ASCII characters '0000', since this field is not used for this record.</p>
  </dd>
  <dt>
    <p>Record Type</p>
  </dt>
  <dd>
    <p>This field contains 0x3032, the hexadecimal encoding of the ASCII character \[lq]02\[rq], which specifies the record type to be an Extended Segment Address Record.</p>
  </dd>
  <dt>
    <p>USBA</p>
  </dt>
  <dd>
    <p>This field contains four ASCII hexadecimal digits that specify the 16\[hy]bit Upper Segment Base Address value.  The field is encoded big\[hy]endian (most significant digit first).</p>
  </dd>
  <dt>
    <p>Checksum</p>
  </dt>
  <dd>
    <p>This field contains the check sum on the Record length, Load Offset, Record Type, and USBA fields.</p>
  </dd>

</dl>

<h3>Data Record</h3>
<p>(8\[hy], 16\[hy] or 32\[hy]bit formats)</p><table class="table table-striped">
<tr>
<th>Record            Mark            (\[lq]:\[rq])     </th>
<th>Record            Length     </th>
<th>Load            Offset     </th>
<th>Record            Type     </th>
<th>Data</th>
<th>Check            sum     </th></tr>
</table><p>The Data Record provides a set of hexadecimal digits that represent the ASCII code for data bytes that make up a portion of a memory image. The method for calculating the absolute address (linear in the 8\[hy]bit and 32\[hy]bit case and segmented in the 16\[hy]bit case) for each byte of data is described in the discussions of the Extended Linear Address Record and the Extended Segment Address Record.</p><p>The contents of the individual fields within the record are:</p>
<dl class='dl-vertical'>
  <dt>
    <p>Record Mark</p>
  </dt>
  <dd>
    <p>This field contains 0x3A, the hexadecimal encoding of the ASCII colon (\[lq]:\[rq]) character.</p>
  </dd>
  <dt>
    <p>Record Length</p>
  </dt>
  <dd>
    <p>The field contains two ASCII hexadecimal digits that specify the number of data bytes in the record.  The maximum value is 255 decimal.</p>
  </dd>
  <dt>
    <p>Load Offset</p>
  </dt>
  <dd>
    <p>This field contains four ASCII hexadecimal digits representing the offset from the LBA (see Extended Linear Address Record see Extended Segment Address Record) defining the address which the first byte of the data is to be placed.</p>
  </dd>
  <dt>
    <p>Record Type</p>
  </dt>
  <dd>
    <p>This field contains 0x3030, the hexadecimal encoding of the ASCII character \[lq]00\[rq], which specifies the record type to be a Data Record.</p>
  </dd>
  <dt>
    <p>Data</p>
  </dt>
  <dd>
    <p>This field contains pairs of ASCII hexadecimal digits, one pair for each data byte.</p>
  </dd>
  <dt>
    <p>Checksum</p>
  </dt>
  <dd>
    <p>This field contains the check sum on the Record Length, Load Offset, Record Type, and Data fields.</p>
  </dd>

</dl>
<p><strong>Note:</strong> Care must be taken when the addresses with an record span the end of addressing.  The behaviour is different for linear and segmented addressing modes.</p>
<dl class='dl-vertical'>
  <dt>
    <p>linear</p>
  </dt>
  <dd>
    <p>If a record starts just short of 2**32, and would finish after 2**32, the later part of the record wraps around to address 0. TP 8n segment If a record starts just for of a 2**16 boundary, and would finish after that 2**16 boundary, the later part of the record wraps around to address 0 within the same segment (<strong>not</strong> the next segment).</p>
  </dd>

</dl>
<p>The <a href="../man1/srec_cat.1.html"><strong>srec_cat</strong>(1)</a> program will never output records such as these, it will always produce separate records on output.</p>
<h3>Start Linear Address Record</h3>
<p>(32\[hy]bit format only)</p><table class="table table-striped">
<tr>
<th>Record            Mark            (\[lq]:\[rq])     </th>
<th>Record            Length            (4)     </th>
<th>Load.            Offset            (0)     </th>
<th>Record            Type            (5)     </th>
<th>EIP (4            bytes)     </th>
<th>Check            sum     </th></tr>
</table><p>The Start Linear Address Record is used to specify the execution start address for the object file.  The value given is the 32\[hy]bit linear address for the EIP register.  Note that this record only specifies the code address within the 32\[hy]bit linear address space of the 80386. If the code is to start execution in the real mode of the 80386, then the Start Segment Address Record should be used instead, since that record specifies both the CS and IP register contents necessary for real mode.</p><p>The Start Linear Address Record can appear anywhere in a 32\[hy]bit hexadecimal object file.  If such a record is not present in a hexadecimal object file, a loader is free to assign a default execution start address.</p><p>The contents of the individual fields within the record are:</p>
<dl class='dl-vertical'>
  <dt>
    <p>Record mark</p>
  </dt>
  <dd>
    <p>This field contains 0x3A, the hexadecimal encoding of the ASCII colon (\[lq]:\[rq]) character.</p>
  </dd>
  <dt>
    <p>Record length</p>
  </dt>
  <dd>
    <p>The field contains 0x3034, the hexadecimal encoding of the ASCII characters \[lq]04\[rq], which is the length, in bytes, of the EIP register content within this record.</p>
  </dd>
  <dt>
    <p>Load Offset</p>
  </dt>
  <dd>
    <p>This field contains 0x30303030, the hexadecimal encoding of the ASCII characters \[lq]0000\[rq], since this field is not used for this record.</p>
  </dd>
  <dt>
    <p>Record Type</p>
  </dt>
  <dd>
    <p>This field contains 0x3035, the hexadecimal encoding of the ASCII character \[lq]05\[rq], which specifies the record type to be a Start Linear Address Record.</p>
  </dd>
  <dt>
    <p>EIP</p>
  </dt>
  <dd>
    <p>This field contains eight ASCII hexadecimal digits that specify the 32\[hy]bit EIP register contents.  The field is encoded big\[hy]endian (most significant digit first).</p>
  </dd>
  <dt>
    <p>Checksum</p>
  </dt>
  <dd>
    <p>This field contains the check sum on the Record length, Load Offset, Record Type, and EIP fields.</p>
  </dd>

</dl>

<h3>Start Segment Address Record</h3>
<p>(16\[hy] or 32\[hy]bit formats)</p><table class="table table-striped">
<tr>
<th>Record              Mark              (\[lq]:\[rq])      </th>
<th>Record              Length              (4)      </th>
<th>Load.              Offset              (0)      </th>
<th>Record              Type              (3)      </th>
<th>CS (2              bytes)      </th>
<th>IP (2              bytes)      </th>
<th>Check              sum      </th></tr>
</table><p>The Start Segment Address Record is used to specify the execution start address for the object file.  The value given is the 20\[hy]bit segment address for the CS and IP registers.  Note that this record only specifies the code address within the 20\[hy]bit segmented address space of the 8086/80186.  The Start Segment Address Record can appear anywhere in a 16\[hy]bit hexadecimal object file.   If such a record is not present in a hexadecimal object file, a loader is free to assign a default start address.</p><p>The contents of the individual fields within the record are:</p>
<dl class='dl-vertical'>
  <dt>
    <p>Record Mark</p>
  </dt>
  <dd>
    <p>This field contains 0x3A, the hexadecimal encoding of the ASCII colon (\[lq]:\[rq]) character.</p>
  </dd>
  <dt>
    <p>Record Length</p>
  </dt>
  <dd>
    <p>The field contains 0x3034, the hexadecimal encoding of the ASCII characters \[lq]04\[rq], which is the length, in bytes, of the CS and IP register contents within this record.</p>
  </dd>
  <dt>
    <p>Load Offset</p>
  </dt>
  <dd>
    <p>This field contains 0x30303030, the hexadecimal encoding of the ASCII characters \[lq]0000\[rq], since this field is not used for this record.</p>
  </dd>
  <dt>
    <p>Record Type</p>
  </dt>
  <dd>
    <p>This field contains 0x3033, the hexadecimal encoding of the ASCII character '03', which specifies the record type to be a Start Segment Address Record.</p>
  </dd>
  <dt>
    <p>CS</p>
  </dt>
  <dd>
    <p>This field contains four ASCII hexadecimal digits that specify the 16\[hy]bit CS register contents.  The field is encoded big\[hy]endian (most significant digit first).</p>
  </dd>
  <dt>
    <p>IP</p>
  </dt>
  <dd>
    <p>This field contains four ASCII hexadecimal digits that specify the 16\[hy]bit IP register contents.  The field is encoded big\[hy]endian (most significant digit first).</p>
  </dd>
  <dt>
    <p>Checksum</p>
  </dt>
  <dd>
    <p>This field contains the check sum on the Record length, Load Offset, Record Type, CS, and IP fields.</p>
  </dd>

</dl>

<h3>End of File Record</h3>
<p>(8\[hy], 16\[hy], or 32\[hy]bit formats)</p><table class="table table-striped">
<tr>
<th>Record          Mark          (\[lq]:\[rq])    </th>
<th>Record          Length          (0)    </th>
<th>Load          Offset          (0)    </th>
<th>Record          Type          (1)    </th>
<th>Check          sum          (0xFF)    </th></tr>
</table><p>The End of File Record specifies the end of the hexadecimal object file.</p><p>The contents of the individual fields within the record are:</p>
<dl class='dl-vertical'>
  <dt>
    <p>Record mark</p>
  </dt>
  <dd>
    <p>This field contains 0x3A, the hexadecimal encoding of the ASCII colon (\[lq]:\[rq]) character.</p>
  </dd>
  <dt>
    <p>Record Length</p>
  </dt>
  <dd>
    <p>The field contains 0x3030, the hexadecimal encoding of the ASCII characters \[lq]00\[rq].  Since this record does not contain any Data bytes, the length is zero.</p>
  </dd>
  <dt>
    <p>Load Offset</p>
  </dt>
  <dd>
    <p>This field contains 0x30303030, the hexadecimal encoding of the ASCII characters \[lq]0000\[rq], since this field is not used for this record. In ancient times, i8hex used this for the start address record.</p>
  </dd>
  <dt>
    <p>Record Type</p>
  </dt>
  <dd>
    <p>This field contains 0x3031, the hexadecimal encoding of the ASCII character \[lq]01\[rq], which specifies the record type to be an End of File Record.</p>
  </dd>
  <dt>
    <p>Checksum</p>
  </dt>
  <dd>
    <p>This field contains the check sum an the Record Length, Load Offset, and Record Type fields.  Since all the fields are static, the check sum can also be calculated statically, and the value is 0x4646, the hexadecimal encoding of the ASCII characters \[lq]FF\[rq].</p>
  </dd>

</dl>

<h3>Size Multiplier</h3>
<p>In general, binary data will expand in sized by approximately 2.3 times when represented with this format.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLE</h2>
        <div class="sectioncontent">
<p>Here is an example Intel hex file. It contains the data \[lq]Hello, World\[rq] to be loaded at address 0.</p>
<pre>
:0D00000048656C6C6F2C20576F726C640AA1
:00000001FF
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REFERENCE</h2>
        <div class="sectioncontent">
<p>This information comes (very indirectly) from <em>Microprocessors and Programmed Logic,</em> Second Edition, Kenneth L. Short, 1987, Prentice\[hy]Hall, ISBN 0\[hy]13\[hy]580606\[hy]2.</p><p>http://en.wikipedia.org/wiki/Intel_HEX</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p><em>\*(n)</em> version \*(v)</p><p>Copyright \*(Y) Peter Miller</p><p>The <em>\*(n)</em> program comes with ABSOLUTELY NO WARRANTY; for details use the '<em>\*(n) -VERSion License</em>' command. This is free software and you are welcome to redistribute it under certain conditions; for details use the '<em>\*(n) -VERSion License</em>' command.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<table class="table table-striped">
<tr>
<th>Peter Miller</th>
<th>E\[hy]Mail:</th>
<th>pmiller@opensource.org.au</th></tr>

<tr>
<td>/&#92</td>
<td>/&#92</td>
<td>*</td></tr>

<tr>
<td>WWW:</td>
<td>http://miller.emu.id.au/pmiller/</td></tr>
</table><h3>Derivation</h3>
<p>This manual page is derived from a file marked as follows:</p><p>Intel Hexadecimal Object File Format Specification; Revision A, 1/6/88</p><p>Disclaimer: Intel makes no representation or warranties with respect to the contents hereof and specifically disclaims any implied warranties of merchantability or fitness for any particular purpose.  Further, Intel reserves the right to revise this publication from time to time in the content hereof without obligation of Intel to notify any person of such revision or changes.  The publication of this specification should not be construed as a commitment on Intel's part to implement any product.</p>

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="srec_fpc.5.html"><span aria-hidden="true">&larr;</span> srec_fpc.5: Four packed code file format</a></li>
   <li class="next"><a href="srec_intel16.5.html">srec_intel16.5: Intel hexadecimal 16\[hy]bit file format specification <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

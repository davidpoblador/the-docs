<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>nfs: Fstab format and options for the nfs file systems</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Fstab format and options for the nfs file systems">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="nfs (5) manual">
  <meta name="twitter:description" content="Fstab format and options for the nfs file systems">
  <meta name="twitter:image" content="https://www.carta.tech/images/nfs-common-nfs-5.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man5/nfs.5.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="nfs (5) manual" />
  <meta property="og:description" content="Fstab format and options for the nfs file systems" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/nfs-common-nfs-5.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">nfs<small> (5)</small></h1>
        <p class="lead">Fstab format and options for the nfs file systems</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/">
      <span itemprop="name">File formats and conventions</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/nfs.5.html">
      <span itemprop="name">nfs: Fstab format and options for the nfs file systems</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/nfs-common/">
      <span itemprop="name">nfs-common</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/nfs.5.html">
      <span itemprop="name">nfs: Fstab format and options for the nfs file systems</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><em>/etc/fstab</em></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>NFS is an Internet Standard protocol created by Sun Microsystems in 1984. NFS was developed to allow file sharing between systems residing on a local area network. The Linux NFS client supports three versions of the NFS protocol: NFS version 2 [RFC1094], NFS version 3 [RFC1813], and NFS version 4 [RFC3530].</p><p>The <a href="../man8/mount.8.html"><strong>mount</strong>(8)</a> command attaches a file system to the system's name space hierarchy at a given mount point. The <em>/etc/fstab</em> file describes how <a href="../man8/mount.8.html"><strong>mount</strong>(8)</a> should assemble a system's file name hierarchy from various independent file systems (including file systems exported by NFS servers). Each line in the <em>/etc/fstab</em> file describes a single file system, its mount point, and a set of default mount options for that mount point.</p><p>For NFS file system mounts, a line in the <em>/etc/fstab</em> file specifies the server name, the path name of the exported server directory to mount, the local directory that is the mount point, the type of file system that is being mounted, and a list of mount options that control the way the filesystem is mounted and how the NFS client behaves when accessing files on this mount point. The fifth and sixth fields on each line are not used by NFS, thus conventionally each contain the digit zero. For example:</p>
<pre>
	server:path	/mountpoint	fstype	option,option,...	0 0
</pre>
<p>The server's hostname and export pathname are separated by a colon, while the mount options are separated by commas. The remaining fields are separated by blanks or tabs.</p><p>The server's hostname can be an unqualified hostname, a fully qualified domain name, a dotted quad IPv4 address, or an IPv6 address enclosed in square brackets. Link-local and site-local IPv6 addresses must be accompanied by an interface identifier. See <a href="../man7/ipv6.7.html"><strong>ipv6</strong>(7)</a> for details on specifying raw IPv6 addresses.</p><p>The <em>fstype</em> field contains "nfs".  Use of the "nfs4" fstype in <em>/etc/fstab</em> is deprecated.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MOUNT OPTIONS</h2>
        <div class="sectioncontent">
<p>Refer to <a href="../man8/mount.8.html"><strong>mount</strong>(8)</a> for a description of generic mount options available for all file systems. If you do not need to specify any mount options, use the generic option <strong>defaults</strong> in <em>/etc/fstab</em>.</p><h3>Options supported by all versions</h3>
<p>These options are valid to use with any NFS version.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>soft</strong> / <strong>hard</strong></p>
  </dt>
  <dd>
    <p>Determines the recovery behavior of the NFS client after an NFS request times out. If neither option is specified (or if the <strong>hard</strong> option is specified), NFS requests are retried indefinitely. If the <strong>soft</strong> option is specified, then the NFS client fails an NFS request after <strong>retrans</strong> retransmissions have been sent, causing the NFS client to return an error to the calling application.</p><ul>
<li><p><em>NB:</em> A so-called "soft" timeout can cause silent data corruption in certain cases. As such, use the <strong>soft</strong> option only when client responsiveness is more important than data integrity. Using NFS over TCP or increasing the value of the <strong>retrans</strong> option may mitigate some of the risks of using the <strong>soft</strong> option.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>timeo=</strong><em>n</em></p>
  </dt>
  <dd>
    <p>The time in deciseconds (tenths of a second) the NFS client waits for a response before it retries an NFS request.</p><ul>
<li><p>For NFS over TCP the default <strong>timeo</strong> value is 600 (60 seconds). The NFS client performs linear backoff: After each retransmission the timeout is increased by <strong>timeo</strong> up to the maximum of 600 seconds.</p></li><li><p>However, for NFS over UDP, the client uses an adaptive algorithm to estimate an appropriate timeout value for frequently used request types (such as READ and WRITE requests), but uses the <strong>timeo</strong> setting for infrequently used request types (such as FSINFO requests). If the <strong>timeo</strong> option is not specified, infrequently used request types are retried after 1.1 seconds. After each retransmission, the NFS client doubles the timeout for that request, up to a maximum timeout length of 60 seconds.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>retrans=</strong><em>n</em></p>
  </dt>
  <dd>
    <p>The number of times the NFS client retries a request before it attempts further recovery action. If the <strong>retrans</strong> option is not specified, the NFS client tries each request three times.</p><ul>
<li><p>The NFS client generates a "server not responding" message after <strong>retrans</strong> retries, then attempts further recovery (depending on whether the <strong>hard</strong> mount option is in effect).</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>rsize=</strong><em>n</em></p>
  </dt>
  <dd>
    <p>The maximum number of bytes in each network READ request that the NFS client can receive when reading data from a file on an NFS server. The actual data payload size of each NFS READ request is equal to or smaller than the <strong>rsize</strong> setting. The largest read payload supported by the Linux NFS client is 1,048,576 bytes (one megabyte).</p><ul>
<li><p>The <strong>rsize</strong> value is a positive integral multiple of 1024. Specified <strong>rsize</strong> values lower than 1024 are replaced with 4096; values larger than 1048576 are replaced with 1048576. If a specified value is within the supported range but not a multiple of 1024, it is rounded down to the nearest multiple of 1024.</p></li><li><p>If an <strong>rsize</strong> value is not specified, or if the specified <strong>rsize</strong> value is larger than the maximum that either client or server can support, the client and server negotiate the largest <strong>rsize</strong> value that they can both support.</p></li><li><p>The <strong>rsize</strong> mount option as specified on the <a href="../man8/mount.8.html"><strong>mount</strong>(8)</a> command line appears in the <em>/etc/mtab</em> file. However, the effective <strong>rsize</strong> value negotiated by the client and server is reported in the <em>/proc/mounts</em> file.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>wsize=</strong><em>n</em></p>
  </dt>
  <dd>
    <p>The maximum number of bytes per network WRITE request that the NFS client can send when writing data to a file on an NFS server. The actual data payload size of each NFS WRITE request is equal to or smaller than the <strong>wsize</strong> setting. The largest write payload supported by the Linux NFS client is 1,048,576 bytes (one megabyte).</p><ul>
<li><p>Similar to <strong>rsize</strong> , the <strong>wsize</strong> value is a positive integral multiple of 1024. Specified <strong>wsize</strong> values lower than 1024 are replaced with 4096; values larger than 1048576 are replaced with 1048576. If a specified value is within the supported range but not a multiple of 1024, it is rounded down to the nearest multiple of 1024.</p></li><li><p>If a <strong>wsize</strong> value is not specified, or if the specified <strong>wsize</strong> value is larger than the maximum that either client or server can support, the client and server negotiate the largest <strong>wsize</strong> value that they can both support.</p></li><li><p>The <strong>wsize</strong> mount option as specified on the <a href="../man8/mount.8.html"><strong>mount</strong>(8)</a> command line appears in the <em>/etc/mtab</em> file. However, the effective <strong>wsize</strong> value negotiated by the client and server is reported in the <em>/proc/mounts</em> file.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>ac</strong> / <strong>noac</strong></p>
  </dt>
  <dd>
    <p>Selects whether the client may cache file attributes. If neither option is specified (or if <strong>ac</strong> is specified), the client caches file attributes.</p><ul>
<li><p>To improve performance, NFS clients cache file attributes. Every few seconds, an NFS client checks the server's version of each file's attributes for updates.  Changes that occur on the server in those small intervals remain undetected until the client checks the server again. The <strong>noac</strong> option prevents clients from caching file attributes so that applications can more quickly detect file changes on the server.</p></li><li><p>In addition to preventing the client from caching file attributes, the <strong>noac</strong> option forces application writes to become synchronous so that local changes to a file become visible on the server immediately.  That way, other clients can quickly detect recent writes when they check the file's attributes.</p></li><li><p>Using the <strong>noac</strong> option provides greater cache coherence among NFS clients accessing the same files, but it extracts a significant performance penalty. As such, judicious use of file locking is encouraged instead. The DATA AND METADATA COHERENCE section contains a detailed discussion of these trade-offs.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>acregmin=</strong><em>n</em></p>
  </dt>
  <dd>
    <p>The minimum time (in seconds) that the NFS client caches attributes of a regular file before it requests fresh attribute information from a server. If this option is not specified, the NFS client uses a 3-second minimum.</p>
  </dd>
  <dt>
    <p><strong>acregmax=</strong><em>n</em></p>
  </dt>
  <dd>
    <p>The maximum time (in seconds) that the NFS client caches attributes of a regular file before it requests fresh attribute information from a server. If this option is not specified, the NFS client uses a 60-second maximum.</p>
  </dd>
  <dt>
    <p><strong>acdirmin=</strong><em>n</em></p>
  </dt>
  <dd>
    <p>The minimum time (in seconds) that the NFS client caches attributes of a directory before it requests fresh attribute information from a server. If this option is not specified, the NFS client uses a 30-second minimum.</p>
  </dd>
  <dt>
    <p><strong>acdirmax=</strong><em>n</em></p>
  </dt>
  <dd>
    <p>The maximum time (in seconds) that the NFS client caches attributes of a directory before it requests fresh attribute information from a server. If this option is not specified, the NFS client uses a 60-second maximum.</p>
  </dd>
  <dt>
    <p><strong>actimeo=</strong><em>n</em></p>
  </dt>
  <dd>
    <p>Using <strong>actimeo</strong> sets all of <strong>acregmin</strong>, <strong>acregmax</strong>, <strong>acdirmin</strong>, and <strong>acdirmax</strong> to the same value. If this option is not specified, the NFS client uses the defaults for each of these options listed above.</p>
  </dd>
  <dt>
    <p><strong>bg</strong> / <strong>fg</strong></p>
  </dt>
  <dd>
    <p>Determines how the <a href="../man8/mount.8.html"><strong>mount</strong>(8)</a> command behaves if an attempt to mount an export fails. The <strong>fg</strong> option causes <a href="../man8/mount.8.html"><strong>mount</strong>(8)</a> to exit with an error status if any part of the mount request times out or fails outright. This is called a "foreground" mount, and is the default behavior if neither the <strong>fg</strong> nor <strong>bg</strong> mount option is specified.</p><ul>
<li><p>If the <strong>bg</strong> option is specified, a timeout or failure causes the <a href="../man8/mount.8.html"><strong>mount</strong>(8)</a> command to fork a child which continues to attempt to mount the export. The parent immediately returns with a zero exit code. This is known as a "background" mount.</p></li><li><p>If the local mount point directory is missing, the <a href="../man8/mount.8.html"><strong>mount</strong>(8)</a> command acts as if the mount request timed out. This permits nested NFS mounts specified in <em>/etc/fstab</em> to proceed in any order during system initialization, even if some NFS servers are not yet available. Alternatively these issues can be addressed using an automounter (refer to <a href="../man8/automount.8.html"><strong>automount</strong>(8)</a> for details).</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>rdirplus</strong> / <strong>nordirplus</strong></p>
  </dt>
  <dd>
    <p>Selects whether to use NFS v3 or v4 READDIRPLUS requests. If this option is not specified, the NFS client uses READDIRPLUS requests on NFS v3 or v4 mounts to read small directories. Some applications perform better if the client uses only READDIR requests for all directories.</p>
  </dd>
  <dt>
    <p><strong>retry=</strong><em>n</em></p>
  </dt>
  <dd>
    <p>The number of minutes that the <a href="../man8/mount.8.html"><strong>mount</strong>(8)</a> command retries an NFS mount operation in the foreground or background before giving up. If this option is not specified, the default value for foreground mounts is 2 minutes, and the default value for background mounts is 10000 minutes (80 minutes shy of one week). If a value of zero is specified, the <a href="../man8/mount.8.html"><strong>mount</strong>(8)</a> command exits immediately after the first failure.</p>
  </dd>
  <dt>
    <p><strong>sec=</strong><em>flavor</em></p>
  </dt>
  <dd>
    <p>The security flavor to use for accessing files on this mount point. If the server does not support this flavor, the mount operation fails. If <strong>sec=</strong> is not specified, the client attempts to find a security flavor that both the client and the server supports. Valid <em>flavors</em> are <strong>none</strong>, <strong>sys</strong>, <strong>krb5</strong>, <strong>krb5i</strong>, and <strong>krb5p</strong>. Refer to the SECURITY CONSIDERATIONS section for details.</p>
  </dd>
  <dt>
    <p><strong>sharecache</strong> / <strong>nosharecache</strong></p>
  </dt>
  <dd>
    <p>Determines how the client's data cache and attribute cache are shared when mounting the same export more than once concurrently.  Using the same cache reduces memory requirements on the client and presents identical file contents to applications when the same remote file is accessed via different mount points.</p><ul>
<li><p>If neither option is specified, or if the <strong>sharecache</strong> option is specified, then a single cache is used for all mount points that access the same export.  If the <strong>nosharecache</strong> option is specified, then that mount point gets a unique cache.  Note that when data and attribute caches are shared, the mount options from the first mount point take effect for subsequent concurrent mounts of the same export.</p></li><li><p>As of kernel 2.6.18, the behavior specified by <strong>nosharecache</strong> is legacy caching behavior. This is considered a data risk since multiple cached copies of the same file on the same client can become out of sync following a local update of one of the copies.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>resvport</strong> / <strong>noresvport</strong></p>
  </dt>
  <dd>
    <p>Specifies whether the NFS client should use a privileged source port when communicating with an NFS server for this mount point. If this option is not specified, or the <strong>resvport</strong> option is specified, the NFS client uses a privileged source port. If the <strong>noresvport</strong> option is specified, the NFS client uses a non-privileged source port. This option is supported in kernels 2.6.28 and later.</p><ul>
<li><p>Using non-privileged source ports helps increase the maximum number of NFS mount points allowed on a client, but NFS servers must be configured to allow clients to connect via non-privileged source ports.</p></li><li><p>Refer to the SECURITY CONSIDERATIONS section for important details.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>lookupcache=</strong><em>mode</em></p>
  </dt>
  <dd>
    <p>Specifies how the kernel manages its cache of directory entries for a given mount point. <em>mode</em> can be one of <strong>all</strong>, <strong>none</strong>, <strong>pos</strong>, or <strong>positive</strong>. This option is supported in kernels 2.6.28 and later.</p><ul>
<li><p>The Linux NFS client caches the result of all NFS LOOKUP requests. If the requested directory entry exists on the server, the result is referred to as <em>positive</em>. If the requested directory entry does not exist on the server, the result is referred to as <em>negative</em>.</p></li><li><p>If this option is not specified, or if <strong>all</strong> is specified, the client assumes both types of directory cache entries are valid until their parent directory's cached attributes expire.</p></li><li><p>If <strong>pos</strong> or <strong>positive</strong> is specified, the client assumes positive entries are valid until their parent directory's cached attributes expire, but always revalidates negative entires before an application can use them.</p></li><li><p>If <strong>none</strong> is specified, the client revalidates both types of directory cache entries before an application can use them. This permits quick detection of files that were created or removed by other clients, but can impact application and server performance.</p></li><li><p>The DATA AND METADATA COHERENCE section contains a detailed discussion of these trade-offs.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>fsc</strong> / <strong>nofsc</strong></p>
  </dt>
  <dd>
    <p>Enable/Disables the cache of (read-only) data pages to the local disk using the FS-Cache facility. See <a href="../man8/cachefilesd.8.html"><strong>cachefilesd</strong>(8)</a> and &lt;kernel_soruce&gt;/Documentation/filesystems/caching for detail on how to configure the FS-Cache facility. Default value is nofsc.</p>
  </dd>

</dl>

<h3>Options for NFS versions 2 and 3 only</h3>
<p>Use these options, along with the options in the above subsection, for NFS versions 2 and 3 only.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>proto=</strong><em>netid</em></p>
  </dt>
  <dd>
    <p>The <em>netid</em> determines the transport that is used to communicate with the NFS server.  Available options are <strong>udp</strong>, <strong>udp6</strong>, <strong>tcp</strong>, <strong>tcp6</strong>, and <strong>rdma</strong>. Those which end in <strong>6</strong> use IPv6 addresses and are only available if support for TI-RPC is built in. Others use IPv4 addresses.</p><ul>
<li><p>Each transport protocol uses different default <strong>retrans</strong> and <strong>timeo</strong> settings. Refer to the description of these two mount options for details.</p></li><li><p>In addition to controlling how the NFS client transmits requests to the server, this mount option also controls how the <a href="../man8/mount.8.html"><strong>mount</strong>(8)</a> command communicates with the server's rpcbind and mountd services. Specifying a netid that uses TCP forces all traffic from the <a href="../man8/mount.8.html"><strong>mount</strong>(8)</a> command and the NFS client to use TCP. Specifying a netid that uses UDP forces all traffic types to use UDP.</p></li><li><p><strong>Before using NFS over UDP, refer to the TRANSPORT METHODS section.</strong></p></li><li><p>If the <strong>proto</strong> mount option is not specified, the <a href="../man8/mount.8.html"><strong>mount</strong>(8)</a> command discovers which protocols the server supports and chooses an appropriate transport for each service. Refer to the TRANSPORT METHODS section for more details.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>udp</strong></p>
  </dt>
  <dd>
    <p>The <strong>udp</strong> option is an alternative to specifying <strong>proto=udp.</strong> It is included for compatibility with other operating systems.</p><ul>
<li><p><strong>Before using NFS over UDP, refer to the TRANSPORT METHODS section.</strong></p></li>
</ul>
  </dd>
  <dt>
    <p><strong>tcp</strong></p>
  </dt>
  <dd>
    <p>The <strong>tcp</strong> option is an alternative to specifying <strong>proto=tcp.</strong> It is included for compatibility with other operating systems.</p>
  </dd>
  <dt>
    <p><strong>rdma</strong></p>
  </dt>
  <dd>
    <p>The <strong>rdma</strong> option is an alternative to specifying <strong>proto=rdma.</strong></p>
  </dd>
  <dt>
    <p><strong>port=</strong><em>n</em></p>
  </dt>
  <dd>
    <p>The numeric value of the server's NFS service port. If the server's NFS service is not available on the specified port, the mount request fails.</p><ul>
<li><p>If this option is not specified, or if the specified port value is 0, then the NFS client uses the NFS service port number advertised by the server's rpcbind service. The mount request fails if the server's rpcbind service is not available, the server's NFS service is not registered with its rpcbind service, or the server's NFS service is not available on the advertised port.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>mountport=</strong><em>n</em></p>
  </dt>
  <dd>
    <p>The numeric value of the server's mountd port. If the server's mountd service is not available on the specified port, the mount request fails.</p><ul>
<li><p>If this option is not specified, or if the specified port value is 0, then the <a href="../man8/mount.8.html"><strong>mount</strong>(8)</a> command uses the mountd service port number advertised by the server's rpcbind service. The mount request fails if the server's rpcbind service is not available, the server's mountd service is not registered with its rpcbind service, or the server's mountd service is not available on the advertised port.</p></li><li><p>This option can be used when mounting an NFS server through a firewall that blocks the rpcbind protocol.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>mountproto=</strong><em>netid</em></p>
  </dt>
  <dd>
    <p>The transport the NFS client uses to transmit requests to the NFS server's mountd service when performing this mount request, and when later unmounting this mount point.</p><ul>
<li><p><em>netid</em> may be one of <strong>udp</strong>, and <strong>tcp</strong> which use IPv4 address or, if TI-RPC is built into the <strong>mount.nfs</strong> command, <strong>udp6</strong>, and <strong>tcp6</strong> which use IPv6 addresses.</p></li><li><p>This option can be used when mounting an NFS server through a firewall that blocks a particular transport. When used in combination with the <strong>proto</strong> option, different transports for mountd requests and NFS requests can be specified. If the server's mountd service is not available via the specified transport, the mount request fails.</p></li><li><p>Refer to the TRANSPORT METHODS section for more on how the <strong>mountproto</strong> mount option interacts with the <strong>proto</strong> mount option.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>mounthost=</strong><em>name</em></p>
  </dt>
  <dd>
    <p>The hostname of the host running mountd. If this option is not specified, the <a href="../man8/mount.8.html"><strong>mount</strong>(8)</a> command assumes that the mountd service runs on the same host as the NFS service.</p>
  </dd>
  <dt>
    <p><strong>mountvers=</strong><em>n</em></p>
  </dt>
  <dd>
    <p>The RPC version number used to contact the server's mountd. If this option is not specified, the client uses a version number appropriate to the requested NFS version. This option is useful when multiple NFS services are running on the same remote server host.</p>
  </dd>
  <dt>
    <p><strong>namlen=</strong><em>n</em></p>
  </dt>
  <dd>
    <p>The maximum length of a pathname component on this mount. If this option is not specified, the maximum length is negotiated with the server. In most cases, this maximum length is 255 characters.</p><ul>
<li><p>Some early versions of NFS did not support this negotiation. Using this option ensures that <a href="../man3/pathconf.3.html"><strong>pathconf</strong>(3)</a> reports the proper maximum component length to applications in such cases.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>nfsvers=</strong><em>n</em></p>
  </dt>
  <dd>
    <p>The NFS protocol version number used to contact the server's NFS service. If the server does not support the requested version, the mount request fails. If this option is not specified, the client negotiates a suitable version with the server, trying version 4 first, version 3 second, and version 2 last.</p>
  </dd>
  <dt>
    <p><strong>vers=</strong><em>n</em></p>
  </dt>
  <dd>
    <p>This option is an alternative to the <strong>nfsvers</strong> option. It is included for compatibility with other operating systems.</p>
  </dd>
  <dt>
    <p><strong>lock</strong> / <strong>nolock</strong></p>
  </dt>
  <dd>
    <p>Selects whether to use the NLM sideband protocol to lock files on the server. If neither option is specified (or if <strong>lock</strong> is specified), NLM locking is used for this mount point. When using the <strong>nolock</strong> option, applications can lock files, but such locks provide exclusion only against other applications running on the same client. Remote applications are not affected by these locks.</p><ul>
<li><p>NLM locking must be disabled with the <strong>nolock</strong> option when using NFS to mount <em>/var</em> because <em>/var</em> contains files used by the NLM implementation on Linux. Using the <strong>nolock</strong> option is also required when mounting exports on NFS servers that do not support the NLM protocol.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>intr</strong> / <strong>nointr</strong></p>
  </dt>
  <dd>
    <p>Selects whether to allow signals to interrupt file operations on this mount point. If neither option is specified (or if <strong>nointr</strong> is specified), signals do not interrupt NFS file operations. If <strong>intr</strong> is specified, system calls return EINTR if an in-progress NFS operation is interrupted by a signal.</p><ul>
<li><p>Using the <strong>intr</strong> option is preferred to using the <strong>soft</strong> option because it is significantly less likely to result in data corruption.</p></li><li><p>The <strong>intr</strong> / <strong>nointr</strong> mount option is deprecated after kernel 2.6.25. Only SIGKILL can interrupt a pending NFS operation on these kernels, and if specified, this mount option is ignored to provide backwards compatibility with older kernels.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>cto</strong> / <strong>nocto</strong></p>
  </dt>
  <dd>
    <p>Selects whether to use close-to-open cache coherence semantics. If neither option is specified (or if <strong>cto</strong> is specified), the client uses close-to-open cache coherence semantics. If the <strong>nocto</strong> option is specified, the client uses a non-standard heuristic to determine when files on the server have changed.</p><ul>
<li><p>Using the <strong>nocto</strong> option may improve performance for read-only mounts, but should be used only if the data on the server changes only occasionally. The DATA AND METADATA COHERENCE section discusses the behavior of this option in more detail.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>acl</strong> / <strong>noacl</strong></p>
  </dt>
  <dd>
    <p>Selects whether to use the NFSACL sideband protocol on this mount point. The NFSACL sideband protocol is a proprietary protocol implemented in Solaris that manages Access Control Lists. NFSACL was never made a standard part of the NFS protocol specification.</p><ul>
<li><p>If neither <strong>acl</strong> nor <strong>noacl</strong> option is specified, the NFS client negotiates with the server to see if the NFSACL protocol is supported, and uses it if the server supports it. Disabling the NFSACL sideband protocol may be necessary if the negotiation causes problems on the client or server. Refer to the SECURITY CONSIDERATIONS section for more details.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>local_lock=</strong>mechanism</p>
  </dt>
  <dd>
    <p>Specifies whether to use local locking for any or both of the flock and the POSIX locking mechanisms. <em>mechanism</em> can be one of <strong>all</strong>, <strong>flock</strong>, <strong>posix</strong>, or <strong>none</strong>. This option is supported in kernels 2.6.37 and later.</p><ul>
<li><p>The Linux NFS client provides a way to make locks local. This means, the applications can lock files, but such locks provide exclusion only against other applications running on the same client. Remote applications are not affected by these locks.</p></li><li><p>If this option is not specified, or if <strong>none</strong> is specified, the client assumes that the locks are not local.</p></li><li><p>If <strong>all</strong> is specified, the client assumes that both flock and POSIX locks are local.</p></li><li><p>If <strong>flock</strong> is specified, the client assumes that only flock locks are local and uses NLM sideband protocol to lock files when POSIX locks are used.</p></li><li><p>If <strong>posix</strong> is specified, the client assumes that POSIX locks are local and uses NLM sideband protocol to lock files when flock locks are used.</p></li><li><p>To support legacy flock behavior similar to that of NFS clients &lt; 2.6.12, use 'local_lock=flock'. This option is required when exporting NFS mounts via Samba as Samba maps Windows share mode locks as flock. Since NFS clients &gt; 2.6.12 implement flock by emulating POSIX locks, this will result in conflicting locks.</p></li><li><p>NOTE: When used together, the 'local_lock' mount option will be overridden by 'nolock'/'lock' mount option.</p></li>
</ul>
  </dd>

</dl>

<h3>Options for NFS version 4 only</h3>
<p>Use these options, along with the options in the first subsection above, for NFS version 4 and newer.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>proto=</strong><em>netid</em></p>
  </dt>
  <dd>
    <p>The <em>netid</em> determines the transport that is used to communicate with the NFS server.  Supported options are <strong>tcp</strong>, <strong>tcp6</strong>, and <strong>rdma</strong>. <strong>tcp6</strong> use IPv6 addresses and is only available if support for TI-RPC is built in. Both others use IPv4 addresses.</p><ul>
<li><p>All NFS version 4 servers are required to support TCP, so if this mount option is not specified, the NFS version 4 client uses the TCP protocol. Refer to the TRANSPORT METHODS section for more details.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>port=</strong><em>n</em></p>
  </dt>
  <dd>
    <p>The numeric value of the server's NFS service port. If the server's NFS service is not available on the specified port, the mount request fails.</p><ul>
<li><p>If this mount option is not specified, the NFS client uses the standard NFS port number of 2049 without first checking the server's rpcbind service. This allows an NFS version 4 client to contact an NFS version 4 server through a firewall that may block rpcbind requests.</p></li><li><p>If the specified port value is 0, then the NFS client uses the NFS service port number advertised by the server's rpcbind service. The mount request fails if the server's rpcbind service is not available, the server's NFS service is not registered with its rpcbind service, or the server's NFS service is not available on the advertised port.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>intr</strong> / <strong>nointr</strong></p>
  </dt>
  <dd>
    <p>Selects whether to allow signals to interrupt file operations on this mount point. If neither option is specified (or if <strong>intr</strong> is specified), system calls return EINTR if an in-progress NFS operation is interrupted by a signal.  If <strong>nointr</strong> is specified, signals do not interrupt NFS operations.</p><ul>
<li><p>Using the <strong>intr</strong> option is preferred to using the <strong>soft</strong> option because it is significantly less likely to result in data corruption.</p></li><li><p>The <strong>intr</strong> / <strong>nointr</strong> mount option is deprecated after kernel 2.6.25. Only SIGKILL can interrupt a pending NFS operation on these kernels, and if specified, this mount option is ignored to provide backwards compatibility with older kernels.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>cto</strong> / <strong>nocto</strong></p>
  </dt>
  <dd>
    <p>Selects whether to use close-to-open cache coherence semantics for NFS directories on this mount point. If neither <strong>cto</strong> nor <strong>nocto</strong> is specified, the default is to use close-to-open cache coherence semantics for directories.</p><ul>
<li><p>File data caching behavior is not affected by this option. The DATA AND METADATA COHERENCE section discusses the behavior of this option in more detail.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>clientaddr=</strong><em>n.n.n.n</em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>clientaddr=</strong><em>n:n:</em><strong>...</strong><em>:n</em></p>
  </dt>
  <dd>
    <p>Specifies a single IPv4 address (in dotted-quad form), or a non-link-local IPv6 address, that the NFS client advertises to allow servers to perform NFS version 4 callback requests against files on this mount point. If  the  server is unable to establish callback connections to clients, performance may degrade, or accesses to files may temporarily hang.</p><ul>
<li><p>If this option is not specified, the <a href="../man8/mount.8.html"><strong>mount</strong>(8)</a> command attempts to discover an appropriate callback address automatically. The automatic discovery process is not perfect, however. In the presence of multiple client network interfaces, special routing policies, or atypical network topologies, the exact address to use for callbacks may be nontrivial to determine.</p></li>
</ul>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">nfs4 FILE SYSTEM TYPE</h2>
        <div class="sectioncontent">
<p>The <strong>nfs4</strong> file system type is an old syntax for specifying NFSv4 usage. It can still be used with all NFSv4-specific and common options, excepted the <strong>nfsvers</strong> mount option.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MOUNT CONFIGURATION FILE</h2>
        <div class="sectioncontent">
<p>If the mount command is configured to do so, all of the mount options described in the previous section can also be configured in the <em>/etc/nfsmount.conf</em> file. See <a href="../man5/nfsmount.conf.5.html"><strong>nfsmount.conf</strong>(5)</a></strong> for details.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>To mount an export using NFS version 2, use the <strong>nfs</strong> file system type and specify the <strong>nfsvers=2</strong> mount option. To mount using NFS version 3, use the <strong>nfs</strong> file system type and specify the <strong>nfsvers=3</strong> mount option. To mount using NFS version 4, use either the <strong>nfs</strong> file system type, with the <strong>nfsvers=4</strong> mount option, or the <strong>nfs4</strong> file system type.</p><p>The following example from an <em>/etc/fstab</em> file causes the mount command to negotiate reasonable defaults for NFS behavior.</p>
<pre>
	server:/export	/mnt	nfs	defaults	0 0
</pre>
<p>Here is an example from an /etc/fstab file for an NFS version 2 mount over UDP.</p>
<pre>
	server:/export	/mnt	nfs	nfsvers=2,proto=udp	0 0
</pre>
<p>Try this example to mount using NFS version 4 over TCP with Kerberos 5 mutual authentication.</p>
<pre>
	server:/export	/mnt	nfs4	sec=krb5	0 0
</pre>
<p>This example can be used to mount /usr over NFS.</p>
<pre>
	server:/export	/usr	nfs	ro,nolock,nocto,actimeo=3600	0 0
</pre>
<p>This example shows how to mount an NFS server using a raw IPv6 link-local address.</p>
<pre>
	[fe80::215:c5ff:fb3e:e2b1%eth0]:/export	/mnt	nfs	defaults	0 0
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TRANSPORT METHODS</h2>
        <div class="sectioncontent">
<p>NFS clients send requests to NFS servers via Remote Procedure Calls, or <em>RPCs</em>. The RPC client discovers remote service endpoints automatically, handles per-request authentication, adjusts request parameters for different byte endianness on client and server, and retransmits requests that may have been lost by the network or server. RPC requests and replies flow over a network transport.</p><p>In most cases, the <a href="../man8/mount.8.html"><strong>mount</strong>(8)</a> command, NFS client, and NFS server can automatically negotiate proper transport and data transfer size settings for a mount point. In some cases, however, it pays to specify these settings explicitly using mount options.</p><p>Traditionally, NFS clients used the UDP transport exclusively for transmitting requests to servers.  Though its implementation is simple, NFS over UDP has many limitations that prevent smooth operation and good performance in some common deployment environments.  Even an insignificant packet loss rate results in the loss of whole NFS requests; as such, retransmit timeouts are usually in the subsecond range to allow clients to recover quickly from dropped requests, but this can result in extraneous network traffic and server load.</p><p>However, UDP can be quite effective in specialized settings where the networks MTU is large relative to NFSs data transfer size (such as network environments that enable jumbo Ethernet frames).  In such environments, trimming the <strong>rsize</strong> and <strong>wsize</strong> settings so that each NFS read or write request fits in just a few network frames (or even in  a single  frame) is advised.  This reduces the probability that the loss of a single MTU-sized network frame results in the loss of an entire large read or write request.</p><p>TCP is the default transport protocol used for all modern NFS implementations.  It performs well in almost every conceivable network environment and provides excellent guarantees against data corruption caused by network unreliability.  TCP is often a requirement for mounting a server through a network firewall.</p><p>Under normal circumstances, networks drop packets much more frequently than NFS servers drop requests.  As such, an aggressive retransmit timeout  setting for NFS over TCP is unnecessary. Typical timeout settings for NFS over TCP are between one and ten minutes. After  the client exhausts its retransmits (the value of the <strong>retrans</strong> mount option), it assumes a network partition has occurred, and attempts to reconnect to the server on a fresh socket. Since TCP itself makes network data transfer reliable, <strong>rsize</strong> and <strong>wsize</strong> can safely be allowed to default to the largest values supported by both client and server, independent of the network's MTU size.</p><h3>Using the mountproto mount option</h3>
<p>This section applies only to NFS version 2 and version 3 mounts since NFS version 4 does not use a separate protocol for mount requests.</p><p>The Linux NFS client can use a different transport for contacting an NFS server's rpcbind service, its mountd service, its Network Lock Manager (NLM) service, and its NFS service. The exact transports employed by the Linux NFS client for each mount point depends on the settings of the transport mount options, which include <strong>proto</strong>, <strong>mountproto</strong>, <strong>udp</strong>, and <strong>tcp</strong>.</p><p>The client sends Network Status Manager (NSM) notifications via UDP no matter what transport options are specified, but listens for server NSM notifications on both UDP and TCP. The NFS Access Control List (NFSACL) protocol shares the same transport as the main NFS service.</p><p>If no transport options are specified, the Linux NFS client uses UDP to contact the server's mountd service, and TCP to contact its NLM and NFS services by default.</p><p>If the server does not support these transports for these services, the <a href="../man8/mount.8.html"><strong>mount</strong>(8)</a> command attempts to discover what the server supports, and then retries the mount request once using the discovered transports. If the server does not advertise any transport supported by the client or is misconfigured, the mount request fails. If the <strong>bg</strong> option is in effect, the mount command backgrounds itself and continues to attempt the specified mount request.</p><p>When the <strong>proto</strong> option, the <strong>udp</strong> option, or the <strong>tcp</strong> option is specified but the <strong>mountproto</strong> option is not, the specified transport is used to contact both the server's mountd service and for the NLM and NFS services.</p><p>If the <strong>mountproto</strong> option is specified but none of the <strong>proto</strong>, <strong>udp</strong> or <strong>tcp</strong> options are specified, then the specified transport is used for the initial mountd request, but the mount command attempts to discover what the server supports for the NFS protocol, preferring TCP if both transports are supported.</p><p>If both the <strong>mountproto</strong> and <strong>proto</strong> (or <strong>udp</strong> or <strong>tcp</strong>) options are specified, then the transport specified by the <strong>mountproto</strong> option is used for the initial mountd request, and the transport specified by the <strong>proto</strong> option (or the <strong>udp</strong> or <strong>tcp</strong> options) is used for NFS, no matter what order these options appear. No automatic service discovery is performed if these options are specified.</p><p>If any of the <strong>proto</strong>, <strong>udp</strong>, <strong>tcp</strong>,  or <strong>mountproto</strong> options are specified more than once on the same mount command line, then the value of the rightmost instance of each of these options takes effect.</p>
<h3>Using NFS over UDP on high-speed links</h3>
<p>Using NFS over UDP on high-speed links such as Gigabit <strong>can cause silent data corruption</strong>.</p><p>The problem can be triggered at high loads, and is caused by problems in IP fragment reassembly. NFS read and writes typically transmit UDP packets of 4 Kilobytes or more, which have to be broken up into several fragments in order to be sent over the Ethernet link, which limits packets to 1500 bytes by default. This process happens at the IP network layer and is called fragmentation.</p><p>In order to identify fragments that belong together, IP assigns a 16bit <em>IP ID</em> value to each packet; fragments generated from the same UDP packet will have the same IP ID. The receiving system will collect these fragments and combine them to form the original UDP packet. This process is called reassembly. The default timeout for packet reassembly is 30 seconds; if the network stack does not receive all fragments of a given packet within this interval, it assumes the missing fragment(s) got lost and discards those it already received.</p><p>The problem this creates over high-speed links is that it is possible to send more than 65536 packets within 30 seconds. In fact, with heavy NFS traffic one can observe that the IP IDs repeat after about 5 seconds.</p><p>This has serious effects on reassembly: if one fragment gets lost, another fragment <em>from a different packet</em> but with the <em>same IP ID</em> will arrive within the 30 second timeout, and the network stack will combine these fragments to form a new packet. Most of the time, network layers above IP will detect this mismatched reassembly - in the case of UDP, the UDP checksum, which is a 16 bit checksum over the entire packet payload, will usually not match, and UDP will discard the bad packet.</p><p>However, the UDP checksum is 16 bit only, so there is a chance of 1 in 65536 that it will match even if the packet payload is completely random (which very often isn't the case). If that is the case, silent data corruption will occur.</p><p>This potential should be taken seriously, at least on Gigabit Ethernet. Network speeds of 100Mbit/s should be considered less problematic, because with most traffic patterns IP ID wrap around will take much longer than 30 seconds.</p><p>It is therefore strongly recommended to use <strong>NFS over TCP where possible</strong>, since TCP does not perform fragmentation.</p><p>If you absolutely have to use NFS over UDP over Gigabit Ethernet, some steps can be taken to mitigate the problem and reduce the probability of corruption:</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>Jumbo frames:</em></p>
  </dt>
  <dd>
    <p>Many Gigabit network cards are capable of transmitting frames bigger than the 1500 byte limit of traditional Ethernet, typically 9000 bytes. Using jumbo frames of 9000 bytes will allow you to run NFS over UDP at a page size of 8K without fragmentation. Of course, this is only feasible if all involved stations support jumbo frames.</p><ul>
<li><p>To enable a machine to send jumbo frames on cards that support it, it is sufficient to configure the interface for a MTU value of 9000.</p></li>
</ul>
  </dd>
  <dt>
    <p><em>Lower reassembly timeout:</em></p>
  </dt>
  <dd>
    <p>By lowering this timeout below the time it takes the IP ID counter to wrap around, incorrect reassembly of fragments can be prevented as well. To do so, simply write the new timeout value (in seconds) to the file <strong>/proc/sys/net/ipv4/ipfrag_time</strong>.</p><ul>
<li><p>A value of 2 seconds will greatly reduce the probability of IPID clashes on a single Gigabit link, while still allowing for a reasonable timeout when receiving fragmented traffic from distant peers.</p></li>
</ul>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DATA AND METADATA COHERENCE</h2>
        <div class="sectioncontent">
<p>Some modern cluster file systems provide perfect cache coherence among their clients. Perfect cache coherence among disparate NFS clients is expensive to achieve, especially on wide area networks. As such, NFS settles for weaker cache coherence that satisfies the requirements of most file sharing types. Normally, file sharing is completely sequential: first client A opens a file, writes something to it, then closes it; then client B opens the same file, and reads the changes.</p><h3>Close-to-open cache consistency</h3>
<p>When an application opens a file stored on an NFS server, the NFS client checks that it still exists on the server and is permitted to the opener by sending a GETATTR or ACCESS request. When the application closes the file, the NFS client writes back any pending changes to the file so that the next opener can view the changes. This also gives the NFS client an opportunity to report any server write errors to the application via the return code from <a href="../man2/close.2.html"><strong>close</strong>(2)</a>. The behavior of checking at open time and flushing at close time is referred to as close-to-open cache consistency.</p>
<h3>Weak cache consistency</h3>
<p>There are still opportunities for a client's data cache to contain stale data. The NFS version 3 protocol introduced "weak cache consistency" (also known as WCC) which provides a way of efficiently checking a file's attributes before and after a single request. This allows a client to help identify changes that could have been made by other clients.</p><p>When a client is using many concurrent operations that update the same file at the same time (for example, during asynchronous write behind), it is still difficult to tell whether it was that client's updates or some other client's updates that altered the file.</p>
<h3>Attribute caching</h3>
<p>Use the <strong>noac</strong> mount option to achieve attribute cache coherence among multiple clients. Almost every file system operation checks file attribute information. The client keeps this information cached for a period of time to reduce network and server load. When <strong>noac</strong> is in effect, a client's file attribute cache is disabled, so each operation that needs to check a file's attributes is forced to go back to the server. This permits a client to see changes to a file very quickly, at the cost of many extra network operations.</p><p>Be careful not to confuse the <strong>noac</strong> option with "no data caching." The <strong>noac</strong> mount option prevents the client from caching file metadata, but there are still races that may result in data cache incoherence between client and server.</p><p>The NFS protocol is not designed to support true cluster file system cache coherence without some type of application serialization. If absolute cache coherence among clients is required, applications should use file locking. Alternatively, applications can also open their files with the O_DIRECT flag to disable data caching entirely.</p>
<h3>Directory entry caching</h3>
<p>The Linux NFS client caches the result of all NFS LOOKUP requests. If the requested directory entry exists on the server, the result is referred to as a <em>positive</em> lookup result. If the requested directory entry does not exist on the server (that is, the server returned ENOENT), the result is referred to as <em>negative</em> lookup result.</p><p>To detect when directory entries have been added or removed on the server, the Linux NFS client watches a directory's mtime. If the client detects a change in a directory's mtime, the client drops all cached LOOKUP results for that directory. Since the directory's mtime is a cached attribute, it may take some time before a client notices it has changed. See the descriptions of the <strong>acdirmin</strong>, <strong>acdirmax</strong>, and <strong>noac</strong> mount options for more information about how long a directory's mtime is cached.</p><p>Caching directory entries improves the performance of applications that do not share files with applications on other clients. Using cached information about directories can interfere with applications that run concurrently on multiple clients and need to detect the creation or removal of files quickly, however. The <strong>lookupcache</strong> mount option allows some tuning of directory entry caching behavior.</p><p>Before kernel release 2.6.28, the Linux NFS client tracked only positive lookup results. This permitted applications to detect new directory entries created by other clients quickly while still providing some of the performance benefits of caching. If an application depends on the previous lookup caching behavior of the Linux NFS client, you can use <strong>lookupcache=positive</strong>.</p><p>If the client ignores its cache and validates every application lookup request with the server, that client can immediately detect when a new directory entry has been either created or removed by another client. You can specify this behavior using <strong>lookupcache=none</strong>. The extra NFS requests needed if the client does not cache directory entries can exact a performance penalty. Disabling lookup caching should result in less of a performance penalty than using <strong>noac</strong>, and has no effect on how the NFS client caches the attributes of files.</p>
<h3>The sync mount option</h3>
<p>The NFS client treats the <strong>sync</strong> mount option differently than some other file systems (refer to <a href="../man8/mount.8.html"><strong>mount</strong>(8)</a> for a description of the generic <strong>sync</strong> and <strong>async</strong> mount options). If neither <strong>sync</strong> nor <strong>async</strong> is specified (or if the <strong>async</strong> option is specified), the NFS client delays sending application writes to the server until any of these events occur:</p><ul>
<li><p>Memory pressure forces reclamation of system memory resources.</p></li><li><p>An application flushes file data explicitly with <a href="../man2/sync.2.html"><strong>sync</strong>(2)</a>, <a href="../man2/msync.2.html"><strong>msync</strong>(2)</a>, or <strong>fsync</strong>(3).</p></li><li><p>An application closes a file with <a href="../man2/close.2.html"><strong>close</strong>(2)</a>.</p></li><li><p>The file is locked/unlocked via <a href="../man2/fcntl.2.html"><strong>fcntl</strong>(2)</a>.</p></li>
</ul><p>In other words, under normal circumstances, data written by an application may not immediately appear on the server that hosts the file.</p><p>If the <strong>sync</strong> option is specified on a mount point, any system call that writes data to files on that mount point causes that data to be flushed to the server before the system call returns control to user space. This provides greater data cache coherence among clients, but at a significant performance cost.</p><p>Applications can use the O_SYNC open flag to force application writes to individual files to go to the server immediately without the use of the <strong>sync</strong> mount option.</p>
<h3>Using file locks with NFS</h3>
<p>The Network Lock Manager protocol is a separate sideband protocol used to manage file locks in NFS version 2 and version 3. To support lock recovery after a client or server reboot, a second sideband protocol -- known as the Network Status Manager protocol -- is also required. In NFS version 4, file locking is supported directly in the main NFS protocol, and the NLM and NSM sideband protocols are not used.</p><p>In most cases, NLM and NSM services are started automatically, and no extra configuration is required. Configure all NFS clients with fully-qualified domain names to ensure that NFS servers can find clients to notify them of server reboots.</p><p>NLM supports advisory file locks only. To lock NFS files, use <a href="../man2/fcntl.2.html"><strong>fcntl</strong>(2)</a> with the F_GETLK and F_SETLK commands. The NFS client converts file locks obtained via <a href="../man2/flock.2.html"><strong>flock</strong>(2)</a> to advisory locks.</p><p>When mounting servers that do not support the NLM protocol, or when mounting an NFS server through a firewall that blocks the NLM service port, specify the <strong>nolock</strong> mount option. NLM locking must be disabled with the <strong>nolock</strong> option when using NFS to mount <em>/var</em> because <em>/var</em> contains files used by the NLM implementation on Linux.</p><p>Specifying the <strong>nolock</strong> option may also be advised to improve the performance of a proprietary application which runs on a single client and uses file locks extensively.</p>
<h3>NFS version 4 caching features</h3>
<p>The data and metadata caching behavior of NFS version 4 clients is similar to that of earlier versions. However, NFS version 4 adds two features that improve cache behavior: <em>change attributes</em> and <em>file delegation</em>.</p><p>The <em>change attribute</em> is a new part of NFS file and directory metadata which tracks data changes. It replaces the use of a file's modification and change time stamps as a way for clients to validate the content of their caches. Change attributes are independent of the time stamp resolution on either the server or client, however.</p><p>A <em>file delegation</em> is a contract between an NFS version 4 client and server that allows the client to treat a file temporarily as if no other client is accessing it. The server promises to notify the client (via a callback request) if another client attempts to access that file. Once a file has been delegated to a client, the client can cache that file's data and metadata aggressively without contacting the server.</p><p>File delegations come in two flavors: <em>read</em> and <em>write</em>. A <em>read</em> delegation means that the server notifies the client about any other clients that want to write to the file. A <em>write</em> delegation means that the client gets notified about either read or write accessors.</p><p>Servers grant file delegations when a file is opened, and can recall delegations at any time when another client wants access to the file that conflicts with any delegations already granted. Delegations on directories are not supported.</p><p>In order to support delegation callback, the server checks the network return path to the client during the client's initial contact with the server. If contact with the client cannot be established, the server simply does not grant any delegations to that client.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SECURITY CONSIDERATIONS</h2>
        <div class="sectioncontent">
<p>NFS servers control access to file data, but they depend on their RPC implementation to provide authentication of NFS requests. Traditional NFS access control mimics the standard mode bit access control provided in local file systems. Traditional RPC authentication uses a number to represent each user (usually the user's own uid), a number to represent the user's group (the user's gid), and a set of up to 16 auxiliary group numbers to represent other groups of which the user may be a member.</p><p>Typically, file data and user ID values appear unencrypted (i.e. "in the clear") on the network. Moreover, NFS versions 2 and 3 use separate sideband protocols for mounting, locking and unlocking files, and reporting system status of clients and servers. These auxiliary protocols use no authentication.</p><p>In addition to combining these sideband protocols with the main NFS protocol, NFS version 4 introduces more advanced forms of access control, authentication, and in-transit data protection. The NFS version 4 specification mandates support for strong authentication and security flavors that provide per-RPC integrity checking and encryption. Because NFS version 4 combines the function of the sideband protocols into the main NFS protocol, the new security features apply to all NFS version 4 operations including mounting, file locking, and so on. RPCGSS authentication can also be used with NFS versions 2 and 3, but it does not protect their sideband protocols.</p><p>The <strong>sec</strong> mount option specifies the security flavor that is in effect on a given NFS mount point. Specifying <strong>sec=krb5</strong> provides cryptographic proof of a user's identity in each RPC request. This provides strong verification of the identity of users accessing data on the server. Note that additional configuration besides adding this mount option is required in order to enable Kerberos security. Refer to the <a href="../man8/rpc.gssd.8.html"><strong>rpc.gssd</strong>(8)</a> man page for details.</p><p>Two additional flavors of Kerberos security are supported: <strong>krb5i</strong> and <strong>krb5p</strong>. The <strong>krb5i</strong> security flavor provides a cryptographically strong guarantee that the data in each RPC request has not been tampered with. The <strong>krb5p</strong> security flavor encrypts every RPC request to prevent data exposure during network transit; however, expect some performance impact when using integrity checking or encryption. Similar support for other forms of cryptographic security is also available.</p><p>The NFS version 4 protocol allows a client to renegotiate the security flavor when the client crosses into a new filesystem on the server. The newly negotiated flavor effects only accesses of the new filesystem.</p><p>Such negotiation typically occurs when a client crosses from a server's pseudo-fs into one of the server's exported physical filesystems, which often have more restrictive security settings than the pseudo-fs.</p><h3>Using non-privileged source ports</h3>
<p>NFS clients usually communicate with NFS servers via network sockets. Each end of a socket is assigned a port value, which is simply a number between 1 and 65535 that distinguishes socket endpoints at the same IP address. A socket is uniquely defined by a tuple that includes the transport protocol (TCP or UDP) and the port values and IP addresses of both endpoints.</p><p>The NFS client can choose any source port value for its sockets, but usually chooses a <em>privileged</em> port. A privileged port is a port value less than 1024. Only a process with root privileges may create a socket with a privileged source port.</p><p>The exact range of privileged source ports that can be chosen is set by a pair of sysctls to avoid choosing a well-known port, such as the port used by ssh. This means the number of source ports available for the NFS client, and therefore the number of socket connections that can be used at the same time, is practically limited to only a few hundred.</p><p>As described above, the traditional default NFS authentication scheme, known as AUTH_SYS, relies on sending local UID and GID numbers to identify users making NFS requests. An NFS server assumes that if a connection comes from a privileged port, the UID and GID numbers in the NFS requests on this connection have been verified by the client's kernel or some other local authority. This is an easy system to spoof, but on a trusted physical network between trusted hosts, it is entirely adequate.</p><p>Roughly speaking, one socket is used for each NFS mount point. If a client could use non-privileged source ports as well, the number of sockets allowed, and thus the maximum number of concurrent mount points, would be much larger.</p><p>Using non-privileged source ports may compromise server security somewhat, since any user on AUTH_SYS mount points can now pretend to be any other when making NFS requests. Thus NFS servers do not support this by default. They explicitly allow it usually via an export option.</p><p>To retain good security while allowing as many mount points as possible, it is best to allow non-privileged client connections only if the server and client both require strong authentication, such as Kerberos.</p>
<h3>Mounting through a firewall</h3>
<p>A firewall may reside between an NFS client and server, or the client or server may block some of its own ports via IP filter rules. It is still possible to mount an NFS server through a firewall, though some of the <a href="../man8/mount.8.html"><strong>mount</strong>(8)</a> command's automatic service endpoint discovery mechanisms may not work; this requires you to provide specific endpoint details via NFS mount options.</p><p>NFS servers normally run a portmapper or rpcbind daemon to advertise their service endpoints to clients. Clients use the rpcbind daemon to determine:</p><ul>
<li><p>What network port each RPC-based service is using</p></li><li><p>What transport protocols each RPC-based service supports</p></li>
</ul><p>The rpcbind daemon uses a well-known port number (111) to help clients find a service endpoint. Although NFS often uses a standard port number (2049), auxiliary services such as the NLM service can choose any unused port number at random.</p><p>Common firewall configurations block the well-known rpcbind port. In the absense of an rpcbind service, the server administrator fixes the port number of NFS-related services so that the firewall can allow access to specific NFS service ports. Client administrators then specify the port number for the mountd service via the <a href="../man8/mount.8.html"><strong>mount</strong>(8)</a> command's <strong>mountport</strong> option. It may also be necessary to enforce the use of TCP or UDP if the firewall blocks one of those transports.</p>
<h3>NFS Access Control Lists</h3>
<p>Solaris allows NFS version 3 clients direct access to POSIX Access Control Lists stored in its local file systems. This proprietary sideband protocol, known as NFSACL, provides richer access control than mode bits. Linux implements this protocol for compatibility with the Solaris NFS implementation. The NFSACL protocol never became a standard part of the NFS version 3 specification, however.</p><p>The NFS version 4 specification mandates a new version of Access Control Lists that are semantically richer than POSIX ACLs. NFS version 4 ACLs are not fully compatible with POSIX ACLs; as such, some translation between the two is required in an environment that mixes POSIX ACLs and NFS version 4.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THE REMOUNT OPTION</h2>
        <div class="sectioncontent">
<p>Generic mount options such as <strong>rw</strong> and <strong>sync</strong> can be modified on NFS mount points using the <strong>remount</strong> option. See <a href="../man8/mount.8.html"><strong>mount</strong>(8)</a> for more information on generic mount options.</p><p>With few exceptions, NFS-specific options are not able to be modified during a remount. The underlying transport or NFS version cannot be changed by a remount, for example.</p><p>Performing a remount on an NFS file system mounted with the <strong>noac</strong> option may have unintended consequences. The <strong>noac</strong> option is a combination of the generic option <strong>sync</strong>, and the NFS-specific option <strong>actimeo=0</strong>.</p><h3>Unmounting after a remount</h3>
<p>For mount points that use NFS versions 2 or 3, the NFS umount subcommand depends on knowing the original set of mount options used to perform the MNT operation. These options are stored on disk by the NFS mount subcommand, and can be erased by a remount.</p><p>To ensure that the saved mount options are not erased during a remount, specify either the local mount directory, or the server hostname and export pathname, but not both, during a remount.  For example,</p>
<pre>
	mount -o remount,ro /mnt
</pre>
<p>merges the mount option <strong>ro</strong> with the mount options already saved on disk for the NFS server mounted at /mnt.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILES</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><em>/etc/fstab</em></p>
  </dt>
  <dd>
    <p>file system table</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>Before 2.4.7, the Linux NFS client did not support NFS over TCP.</p><p>Before 2.4.20, the Linux NFS client used a heuristic to determine whether cached file data was still valid rather than using the standard close-to-open cache coherency method described above.</p><p>Starting with 2.4.22, the Linux NFS client employs a Van Jacobsen-based RTT estimator to determine retransmit timeout values when using NFS over UDP.</p><p>Before 2.6.0, the Linux NFS client did not support NFS version 4.</p><p>Before 2.6.8, the Linux NFS client used only synchronous reads and writes when the <strong>rsize</strong> and <strong>wsize</strong> settings were smaller than the system's page size.</p><p>The Linux NFS client does not yet support certain optional features of the NFS version 4 protocol, such as security negotiation, server referrals, and named attributes.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO nfs&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man5/fstab.5.html"><strong>fstab</strong>(5)</a>, <a href="../man8/mount.8.html"><strong>mount</strong>(8)</a>, <a href="../man8/umount.8.html"><strong>umount</strong>(8)</a>, <strong>mount.nfs</strong>(5), <strong>umount.nfs</strong>(5), <a href="../man5/exports.5.html"><strong>exports</strong>(5)</a>, <strong>netconfig</strong>(5), <a href="../man7/ipv6.7.html"><strong>ipv6</strong>(7)</a>, <a href="../man8/nfsd.8.html"><strong>nfsd</strong>(8)</a>, <a href="../man8/sm-notify.8.html"><strong>sm-notify</strong>(8)</a>, <a href="../man8/rpc.statd.8.html"><strong>rpc.statd</strong>(8)</a>, <strong>rpc.idmapd</strong>(8), <a href="../man8/rpc.gssd.8.html"><strong>rpc.gssd</strong>(8)</a>, <a href="../man8/rpc.svcgssd.8.html"><strong>rpc.svcgssd</strong>(8)</a>, <strong>kerberos</strong>(1)</p><p>RFC 768 for the UDP specification.</p><p>RFC 793 for the TCP specification.</p><p>RFC 1094 for the NFS version 2 specification.</p><p>RFC 1813 for the NFS version 3 specification.</p><p>RFC 1832 for the XDR specification.</p><p>RFC 1833 for the RPC bind specification.</p><p>RFC 2203 for the RPCSEC GSS API protocol specification.</p><p>RFC 3530 for the NFS version 4 specification.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="newslog.5.html"><span aria-hidden="true">&larr;</span> newslog.5: Description of usenet log files</a></li>
   <li class="next"><a href="nfs4_acl.5.html">nfs4_acl.5: Nfsv4 access control lists <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

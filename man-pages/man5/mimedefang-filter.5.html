<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>mimedefang-filter: Configuration file for mimedefang mail filter.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Configuration file for mimedefang mail filter.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="mimedefang-filter (5) manual">
  <meta name="twitter:description" content="Configuration file for mimedefang mail filter.">
  <meta name="twitter:image" content="https://www.carta.tech/images/mimedefang-mimedefang-filter-5.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man5/mimedefang-filter.5.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="mimedefang-filter (5) manual" />
  <meta property="og:description" content="Configuration file for mimedefang mail filter." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/mimedefang-mimedefang-filter-5.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">mimedefang-filter<small> (5)</small></h1>
        <p class="lead">Configuration file for mimedefang mail filter.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/">
      <span itemprop="name">File formats and conventions</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/mimedefang-filter.5.html">
      <span itemprop="name">mimedefang-filter: Configuration file for mimedefang mail filter.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/mimedefang/">
      <span itemprop="name">mimedefang</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/mimedefang-filter.5.html">
      <span itemprop="name">mimedefang-filter: Configuration file for mimedefang mail filter.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><strong>mimedefang-filter</strong> is a Perl fragment that controls how <strong>mimedefang.pl</strong> disposes of various parts of a MIME message. In addition, it contains some global variable settings that affect the operation of <strong>mimedefang.pl</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CALLING SEQUENCE</h2>
        <div class="sectioncontent">
<p>Incoming messages are scanned as follows:</p><p>1) A temporary working directory is created.  It is made the current working directory and the e-mail message is split into parts in this directory. Each part is represented internally as an instance of MIME::Entity.</p><p>2) If the file <strong>/etc/mail/mimedefang-filter.pl</strong> defines a Perl function called <strong>filter_begin</strong>, it is called with a single argument consisting of a MIME::Entity representing the parsed e-mail message.  Any return value is ignored.</p><p>3) For each <em>leaf</em> part of the mail message, <strong>filter</strong> is called with four arguments: <strong>entity</strong>, a MIME::Entity object; <strong>fname</strong>, the suggested filename taken from the MIME Content-Disposition header; <strong>ext</strong>, the file extension, and <strong>type</strong>, the MIME Content-Type value.  For each <em>non-leaf</em> part of the mail message, <strong>filter_multipart</strong> is called with the same four arguments as <strong>filter</strong>.  A non-leaf part of a message is a part that contains nested parts.  Such a part has no useful body, but you should <em>still perform filename checks</em> to check for viruses that use malformed MIME to masquerade as non-leaf parts (like message/rfc822).  In general, any action you perform in <strong>filter_multipart</strong> applies to the part itself <em>and</em> any contained parts.</p><p>Note that both <strong>filter</strong> and <strong>filter_multipart</strong> are optional. If you do not define them, a default function that simply accepts each part is used.</p><p>4) After all parts have been processed, the function <strong>filter_end</strong> is called if it has been defined.  It is passed a single argument consisting of the (possibly modified) MIME::Entity object representing the message about to be delivered.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DISPOSITION</h2>
        <div class="sectioncontent">
<p><strong>mimedefang.pl</strong> examines each part of the MIME message and chooses a <em>disposition</em> for that part.  (A disposition is selected by calling one of the following functions from <strong>filter</strong> and then immediately returning.)  Available dispositions are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>action_accept</strong></p>
  </dt>
  <dd>
    <p>The part is passed through unchanged.  If no disposition function is returned, this is the default.</p>
  </dd>
  <dt>
    <p><strong>action_accept_with_warning</strong></p>
  </dt>
  <dd>
    <p>The part is passed through unchanged, but a warning is added to the mail message.</p>
  </dd>
  <dt>
    <p><strong>action_drop</strong></p>
  </dt>
  <dd>
    <p>The part is deleted without any notification to the recipients.</p>
  </dd>
  <dt>
    <p><strong>action_drop_with_warning</strong></p>
  </dt>
  <dd>
    <p>The part is deleted and a warning is added to the mail message.</p>
  </dd>
  <dt>
    <p><strong>action_replace_with_warning</strong></p>
  </dt>
  <dd>
    <p>The part is deleted and instead replaced with a text message.</p>
  </dd>
  <dt>
    <p><strong>action_quarantine</strong></p>
  </dt>
  <dd>
    <p>The part is deleted and a warning is added to the mail message.  In addition, a copy of the part is saved on the mail server in the directory /var/spool/MIMEDefang and a notification is sent to the MIMEDefang administrator.</p>
  </dd>
  <dt>
    <p><strong>action_bounce</strong></p>
  </dt>
  <dd>
    <p>The entire e-mail message is rejected and an error returned to the sender. The intended recipients are not notified.  Note that in spite of the name, MIMEDefang does <em>not</em> generate and e-mail a failure notification. Rather, it causes the SMTP server to return a 5<em>XX</em> SMTP failure code.</p>
  </dd>
  <dt>
    <p><strong>action_discard</strong></p>
  </dt>
  <dd>
    <p>The entire e-mail message is discarded silently. Neither the sender nor the intended recipients are notified.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONTROLLING RELAYING</h2>
        <div class="sectioncontent">
<p>You can define a function called <strong>filter_relay</strong> in your filter. This lets you reject SMTP connection attempts early on in the SMTP dialog, rather than waiting until the whole message has been sent. Note that for this check to take place, you must use the -r flag with <strong>mimedefang</strong>.</p><p><strong>filter_relay</strong> is passed five arguments: $hostip is the IP address of the relay host (for example, "127.0.0.1"), $hostname is the host name if known (for example, "localhost.localdomain").  If the host name could not be determined, $hostname is $hostip enclosed in square brackets.  (That is, ("$hostname" eq "[$hostip]") will be true.)</p><p>The remaining three arguments to <strong>filter_relay</strong> are $port, $myip and $myport which contain the client's TCP port, the Sendmail daemon's listening IP address and the Sendmail daemon's listening port.</p><p><strong>filter_relay</strong> must return a two-element list: ($code, $msg).  $msg specifies the text message to use for the SMTP reply, but because of limitations in the Milter API, this message is for documentation purposes only---you cannot set the text of the SMTP message returned to the SMTP client from <strong>filter_relay</strong>.</p><p>$code is a literal string, and can have one of the following values:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>'REJECT'</strong></p>
  </dt>
  <dd>
    <p>if the connection should be rejected.</p>
  </dd>
  <dt>
    <p><strong>'CONTINUE'</strong></p>
  </dt>
  <dd>
    <p>if the connection should be accepted.</p>
  </dd>
  <dt>
    <p><strong>'TEMPFAIL'</strong></p>
  </dt>
  <dd>
    <p>if a temporary failure code should be returned.</p>
  </dd>
  <dt>
    <p><strong>'DISCARD'</strong></p>
  </dt>
  <dd>
    <p>if the message should be accepted and silently discarded.</p>
  </dd>
  <dt>
    <p><strong>'ACCEPT_AND_NO_MORE_FILTERING'</strong></p>
  </dt>
  <dd>
    <p>if the connection should be accepted <em>and no further filtering done</em>.</p>
  </dd>

</dl>
<p>Earlier versions of MIMEDefang used -1 for TEMPFAIL, 0 for REJECT and 1 for CONTINUE.  These values still work, but are deprecated.</p><p>In the case of REJECT or TEMPFAIL, $msg specifies the text part of the SMTP reply.  $msg <em>must not</em> contain newlines.</p><p>For example, if you wish to reject connection attempts from any machine in the spammer.com domain, you could use this function:</p>
<pre>
sub filter_relay {
	my ($ip, $name) = @_;
	if ($name =~ /spammer&#92;.com$/) {
		return ('REJECT', "Sorry; spammer.com is blacklisted");
	}
	return ('CONTINUE', "ok");
}
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILTERING BY HELO</h2>
        <div class="sectioncontent">
<p>You can define a function called <strong>filter_helo</strong> in your filter. This lets you reject connections after the HELO/EHLO SMTP command. Note that for this function to be called, you must use the -H flag with <strong>mimedefang</strong>.</p><p><strong>filter_helo</strong> is passed six arguments: $ip and $name are the IP address and name of the sending relay, as in <strong>filter_relay</strong>.  The third argument, $helo, is the argument supplied in the HELO/EHLO command.</p><p>The remaining three arguments to <strong>filter_relay</strong> are $port, $myip and $myport which contain the client's TCP port, the Sendmail daemon's listening IP address and the Sendmail daemon's listening port.</p><p><strong>filter_helo</strong> must return a two-to-five element list: ($code, $msg, $smtp_code, $smtp_dsn, $delay).  $code is a return code, with the same meaning as the $code return from <strong>filter_relay</strong>.  $msg specifies the text message to use for the SMTP reply.  If $smtp_code and $smtp_dsn are supplied, they become the SMTP numerical reply code and the enhanced status delivery code (DSN code).  If they are not supplied, sensible defaults are used.  $delay specifies a delay in seconds; the C milter code will sleep for $delay seconds before returning the reply to Sendmail.  $delay defaults to zero.</p><p>(Note that the delay is implemented in the Milter C code; if you specify a delay of 30 seconds, that doesn't mean a Perl slave is tied up for the duration of the delay.  The delay only costs one Milter thread.)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILTERING BY SENDER</h2>
        <div class="sectioncontent">
<p>You can define a function called <strong>filter_sender</strong> in your filter. This lets you reject messages from certain senders, rather than waiting until the whole message has been sent.  Note that for this check to take place, you must use the -s flag with <strong>mimedefang</strong>.</p><p><strong>filter_sender</strong> is passed four arguments:  $sender is the envelope e-mail address of the sender (for example, "&lt;dfs@roaringpenguin.com&gt;"). The address may or may not be surrounded by angle brackets.  $ip and $name are the IP address and host name of the SMTP relay.  Finally, $helo is the argument to the SMTP "HELO" command.</p><p>Inside <strong>filter_sender</strong>, you can access any ESMTP arguments (such as "SIZE=12345") in the array @ESMTPArgs.  Each ESMTP argument occupies one array element.</p><p><strong>filter_sender</strong> must return a two-to-five element list, with the same meaning as the return value from <strong>filter_helo</strong>.</p><p>For example, if you wish to reject messages from spammer@badguy.com, you could use this function:</p>
<pre>
sub filter_sender {
	my ($sender, $ip, $hostname, $helo) = @_;
	if ($sender =~ /^&lt;?spammer&#92;@badguy&#92;.com&gt;?$/i) {
		return ('REJECT', 'Sorry; spammer@badguy.com is blacklisted.');
	}
	return ('CONTINUE', "ok");
}
</pre>
<p>As another example, some spammers identify their own machine as your machine in the SMTP "HELO" command.  This function rejects a machine claiming to be in the "roaringpenguin.com" domain unless it really is a Roaring Penguin machine:</p>
<pre>
sub filter_sender {
  my($sender, $ip, $hostname, $helo) = @_;
  if ($helo =~ /roaringpenguin.com/i) {
    if ($ip ne "127.0.0.1" and
        $ip ne "216.191.236.23" and
        $ip ne "216.191.236.30") {
          return('REJECT', "Go away... $ip is not in roaringpenguin.com");
    }
  }
  return ('CONTINUE', "ok");
}
</pre>
<p>As a third example, you may wish to prevent spoofs by requiring SMTP authentication when email is sent from some email addresses. This function rejects mail from "king@example.com", unless the connecting user properly authenticated as "elvisp". Note that this needs access to the %SendmailMacros global, that is not available in filter_sender until after a call to <strong>read_commands_file</strong>.</p>
<pre>
sub filter_sender {
        my($sender, $ip, $hostname, $helo) = @_;
        read_commands_file();
        ### notice: This assumes The King uses authentication without realm!
        if ($sender =~ /^&lt;?king&#92;@example&#92;.com&gt;?$/i and
            $SendmailMacros{auth_authen} ne "elvisp") {
                return('REJECT', "Faking mail from the king is not allowed.");
        }
        return ('CONTINUE', "ok");
}
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILTERING BY RECIPIENT</h2>
        <div class="sectioncontent">
<p>You can define a function called <strong>filter_recipient</strong> in your filter.  This lets you reject messages to certain recipients, rather than waiting until the whole message has been sent.  Note that for this check to take place, you must use the -t flag with <strong>mimedefang</strong>.</p><p><strong>filter_recipient</strong> is passed nine arguments:  $recipient is the envelope address of the recipient and $sender is the envelope e-mail address of the sender (for example, "&lt;dfs@roaringpenguin.com&gt;"). The addresses may or may not be surrounded by angle brackets.  $ip and $name are the IP address and host name of the SMTP relay.  $first is the envelope address of the <em>first</em> recipient for this message, and $helo is the argument to the SMTP "HELO" command.  The last three arguments, $rcpt_mailer, $rcpt_host and $rcpt_addr are the Sendmail mailer, host and address triple for the recipient address.  For example, for local recipients, $rcpt_mailer is likely to be "local", while for remote recipients, it is likely to be "esmtp".</p><p>Inside <strong>filter_recipient</strong>, you can access any ESMTP arguments (such as "NOTIFY=never") in the array @ESMTPArgs.  Each ESMTP argument occupies one array element.</p><p><strong>filter_recipient</strong> must return a two-to-five element list whose interpretation is the same as for <strong>filter_sender</strong>. Note, however, that if <strong>filter_recipient</strong> returns 'DISCARD', then the entire message for <em>all</em> recipients is discarded.  (It doesn't really make sense, but that's how Milter works.)</p><p>For example, if you wish to reject messages from spammer@badguy.com, unless they are to postmaster@mydomain.com, you could use this function:</p>
<pre>
sub filter_recipient {
	my ($recipient, $sender, $ip, $hostname, $first, $helo,
            $rcpt_mailer, $rcpt_host, $rcpt_addr) = @_;
	if ($sender =~ /^&lt;?spammer&#92;@badguy&#92;.com&gt;?$/i) {
		if ($recipient =~ /^&lt;?postmaster&#92;@mydomain&#92;.com&gt;?$/i) {
			return ('CONTINUE', "ok");
		}
		return ('REJECT', 'Sorry; spammer@badguy.com is blacklisted.');
	}
	return ('CONTINUE', "ok");
}
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INITIALIZATION AND CLEANUP</h2>
        <div class="sectioncontent">
<p>Just before a slave begins processing messages, <strong>mimedefang.pl</strong> calls the functions <strong>filter_initialize</strong> (if it is defined) with no arguments. By the time <strong>filter_initialize</strong> is called, all the other initialization (such as setting up syslog facility and priority) has been done.</p><p>If you are not using an embedded Perl interpreter, then performing an action inside <strong>filter_initialize</strong> is practically the same as performing it directly in the filter file, outside any function definition.  However, if you are using an embedded Perl interpreter, then anything you call directly from outside a function definition is executed <em>once only</em> in the parent process.  Anything in <strong>filter_initialize</strong> is executed <em>once per slave</em>.  If you use any code that opens a descriptor (for example, a connection to a database server), you <em>must</em> run that code inside <strong>filter_initialize</strong> and not directly from the filter, because the multiplexor closes all open descriptors when it activates a new slave.</p><p>When a slave is about to exit, <strong>mimedefang.pl</strong> calls the function <strong>filter_cleanup</strong> (if it is defined) with no arguments.  This function can do whatever cleanup you like, such as closing file descriptors and cleaning up long-lived slave resources.  The return value from <strong>filter_cleanup</strong> becomes the slave's exit status.</p><p>If <strong>filter_cleanup</strong> takes longer than 10 seconds to run, the slave is sent a SIGTERM signal.  If that doesn't kill it (because you're catching signals, perhaps), then a further 10 seconds later, the slave is sent a SIGKILL signal.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONTROLLING PARSING</h2>
        <div class="sectioncontent">
<p>If you define a function called <strong>filter_create_parser</strong> taking no arguments, then <strong>mimedefang.pl</strong> will call it to create a MIME::Parser object for parsing mail messages.</p><p><strong>Filter_create_parser</strong> is expected to return a MIME::Parser object (or an instance of a class derived from MIME::Parser).</p><p>You can use <strong>filter_create_parser</strong> to change the behavior of the MIME::Parser used by <strong>mimedefang.pl</strong>.</p><p>If you do not define a <strong>filter_create_parser</strong> function, then a built-in version equivalent to this is used:</p>
<pre>
	sub filter_create_parser () {
		my $parser = MIME::Parser-&gt;new();
		$parser-&gt;<strong>extract_nested_messages</strong>(1);
		$parser-&gt;<strong>extract_uuencode</strong>(1);
		$parser-&gt;<strong>output_to_core</strong>(0);
		$parser-&gt;<strong>tmp_to_core</strong>(0);
		return $parser;
	}
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXTENDING MIMEDEFANG</h2>
        <div class="sectioncontent">
<p>The man page for <a href="../man7/mimedefang-protocol.7.html"><strong>mimedefang-protocol</strong>(7)</a> lists commands that are passed to slaves in server mode (see "SERVER COMMANDS".)  You can define a function called <strong>filter_unknown_cmd</strong> to extend the set of commands your filter can handle.</p><p>If you define <strong>filter_unknown_cmd</strong>, it is passed the unknown command as a single argument.  It should return a list of values as follows:  The first element of the list must be either "ok" or "error:" (with the colon.) The remaining arguments are percent-encoded.  All the resulting pieces are joined together with a single space between them, and the resulting string passed back as the reply to the multiplexor.</p><p>For example, the following function will make your filter reply to a "PING" command with "PONG":</p>
<pre>
sub filter_unknown_cmd ($) {
    my($cmd) = @_;
    if ($cmd eq "PING") {
        return("ok", "PONG");
    }
    return("error:", "Unknown command");
}
</pre>
<p>You can test this filter by typing the following as root:</p>
<pre>
md-mx-ctrl PING
</pre>
<p>The response should be:</p>
<pre>
ok PONG
</pre>
<p>If you extend the set of commands using <strong>filter_unknown_cmd</strong>, you should make all your commands start with an upper-case letter to avoid clashes with future built-in commands.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REJECTING UNKNOWN USERS EARLY</h2>
        <div class="sectioncontent">
<p>A very common mail setup is to have a MIMEDefang machine act as an SMTP proxy, accepting and scanning mail and then relaying it to the real mail server.  Unfortunately, this means that the MIMEDefang machine cannot know if a local address is valid or not, and will forward all mail for the appropriate domains.  If a mail comes in for an unknown user, the MIMEDefang machine will be forced to generate a bounce message when it tries to relay the mail.</p><p>It's often desirable to have the MIMEDefang host reply with a "User unknown" SMTP response directly.  While this can be done by copying the list of local users to the MIMEDefang machine, MIMEDefang has a built-in function called <strong>md_check_against_smtp_server</strong> for querying another relay host:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>md_check_against_smtp_server($sender, $recip, $helo, $server, $port) This</strong></p>
  </dt>
  <dd>
    <p>function connects to the SMTP server $server and pretends to send mail from $sender to $recip.  The return value is always a two-element array.  If the RCPT TO: command succeeds, the return value is ("CONTINUE", "OK").  If the RCPT fails with a permanent failure, the return value is ("REJECT", $msg), where $msg is the message from the SMTP server.  Any temporary failures, connection errors, etc. result in a return value of ("TEMPFAIL", $msg).</p><p>The optional argument $port specifies the TCP port to connect to.  If it is not supplied, then the default SMTP port of 25 is used.</p>
  </dd>

</dl>
<p>Suppose the machine <strong>filter.domain.tld</strong> is filtering mail destined for the real mail server <strong>mail.domain.tld</strong>.  You could have a <strong>filter_recipient</strong> function like this:</p>
<pre>
sub filter_recipient
{
    my($recip, $sender, $ip, $host, $first, $helo,
       $rcpt_mailer, $rcpt_host, $rcpt_addr) = @_;
    return md_check_against_smtp_server($sender, $recip,
					"filter.domain.tld",
					"mail.domain.tld");
}
</pre>
<p>For each RCPT TO: command, MIMEDefang opens an SMTP connection to <strong>mail.domain.tld</strong> and checks if the command would succeed.</p><p>Please note that you should only use <strong>md_check_against_smtp_server</strong> if your mail server responds with a failure code for nonexistent users at the RCPT TO: level.  Also, this function may impose too much overhead if you receive a lot of e-mail, and it will generate lots of useless log entries on the real mail server (because of all the RCPT TO: probes.) It may also significantly increase the load on the real mail server.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">GLOBAL VARIABLES YOU CAN SET</h2>
        <div class="sectioncontent">
<p>The following Perl global variables should be set in <strong>mimedefang-filter</strong>:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>$AdminAddress</strong></p>
  </dt>
  <dd>
    <p>The e-mail address of the MIMEDefang administrator.</p>
  </dd>
  <dt>
    <p><strong>$DaemonAddress</strong></p>
  </dt>
  <dd>
    <p>The e-mail address from which MIMEDefang-originated notifications come.</p>
  </dd>
  <dt>
    <p><strong>$AddWarningsInline</strong></p>
  </dt>
  <dd>
    <p>If this variable is set to 0, then all MIMEDefang warnings (such as created by action_quarantine or action_drop_with_warning) are collected together and added in a separate MIME part called WARNING.TXT.  If the variable is set to 1, then the warnings are added directly in the first text/plain and text/html parts of the message.  If the message does not contain any text/plain or text/html parts, then a WARNING.TXT MIME part is added as before.</p>
  </dd>
  <dt>
    <p><strong>$MaxMIMEParts</strong></p>
  </dt>
  <dd>
    <p>A message containing many MIME parts can cause MIME::Tools to consume large amounts of memory and bring your system to its knees.  If you set $MaxMIMEParts to a positive number, then MIME parsing is terminated for messages with more than that many parts, and the message is bounced. In this case, <em>none</em> of your filter functions is called.</p><p>By default, $MaxMIMEParts is set to -1, meaning there is no limit on the number of parts in a message.  Note that in order to use this variable, you <em>must</em> install the Roaring Penguin patched version of MIME::Tools, version 5.411a-RP-Patched-02 or newer.</p>
  </dd>
  <dt>
    <p><strong>$Stupidity{"NoMultipleInlines"}</strong></p>
  </dt>
  <dd>
    <p>Set this to 1 if your e-mail is too stupid to display multiple MIME parts in-line.  In this case, a nasty hack causes the first part of the original message to appear as an attachment if warning are issued.  Mail clients that are not this stupid are Netscape Communicator and Pine.  On the other hand, Microsoft Exchange and Microsoft Outlook are indeed this stupid.  Perhaps users of those clients should switch.</p><p>The following global variables may optionally be set.  If they are not set, sensible defaults are used:</p>
  </dd>
  <dt>
    <p><strong>$AddApparentlyToForSpamAssassin</strong></p>
  </dt>
  <dd>
    <p>By default, MIMEDefang tries to pass SpamAssassin a message that looks exactly like one it would receive via procmail.  This means adding a Received: header, adding a Message-ID header if necessary, and adding a Return-Path: header.  If you set $AddApparentlyToForSpamAssassin to 1, then MIMEDefang also adds an Apparently-To: header with all the envelope recipients before passing the message to SpamAssassin. This lets SpamAssassin detect possibly whitelisted recipient addresses.</p><p>The default value for $AddApparentlyToForSpamAssassin is 0.</p>
  </dd>
  <dt>
    <p><strong>$SyslogFacility</strong></p>
  </dt>
  <dd>
    <p>This specifies the logging facility used by mimedefang.pl.  By default, it is set to "mail", but you can set it to other possibilites.  See the <a href="../man3/openlog.3.html"><strong>openlog</strong>(3)</a> man page for details.  You should name facilities as all-lowercase without the leading "LOG_".  That is, use "local3", not "LOG_LOCAL3".</p>
  </dd>
  <dt>
    <p><strong>$WarningLocation </strong>(default 0)</p>
  </dt>
  <dd>
    <p>If set to 0 (the default), non-inline warnings are placed first.  If you want the warning at the end of the e-mail, set $WarningLocation to -1.</p>
  </dd>
  <dt>
    <p><strong>$DaemonName </strong>(default  MIMEDefang )</p>
  </dt>
  <dd>
    <p>The full name used when MIMEDefang sends out notifications.</p>
  </dd>
  <dt>
    <p><strong>$AdminName </strong>(default  MIMEDefang Administrator )</p>
  </dt>
  <dd>
    <p>The full name of the MIMEDefang administrator.</p>
  </dd>
  <dt>
    <p><strong>$SALocalTestsOnly </strong>(default 1)</p>
  </dt>
  <dd>
    <p>If set to 1, SpamAssassin calls will use only local tests.  This is the default and recommended setting.  This disables Received, RBL and Razor tests in an all or nothing fashion.  To use Razor this <strong>MUST</strong> be set to 0.  You can add 'skip_rbl_checks 1' to your SpamAssassin config file if you need to.</p>
  </dd>
  <dt>
    <p><strong>$NotifySenderSubject </strong>(default  MIMEDefang Notification )</p>
  </dt>
  <dd>
    <p>The subject used when e-mail is sent out by action_notify_sender().  If you set this, you should set it each time you call action_notify_sender() to ensure consistency.</p>
  </dd>
  <dt>
    <p><strong>$NotifyAdministratorSubject </strong>(default  MIMEDefang Notification )</p>
  </dt>
  <dd>
    <p>The subject used when e-mail is sent out by action_notify_administrator().  If you set this, you should set it each time you call action_notify_administrator() to ensure consistency.</p>
  </dd>
  <dt>
    <p><strong>$QuarantineSubject </strong>(default  MIMEDefang Quarantine Report )</p>
  </dt>
  <dd>
    <p>The subject used when a quarantine notice is sent to the administrator.  If you set this, you should set it each time you call action_quarantine() or action_quarantine_entire_message().</p>
  </dd>
  <dt>
    <p><strong>$NotifyNoPreamble </strong>(default 0)</p>
  </dt>
  <dd>
    <p>Normally, notifications sent by action_notify_sender() have a preamble warning about message modifications.  If you do not want this, set $NotifyNoPreamble to 1.</p>
  </dd>
  <dt>
    <p><strong>$CSSHost </strong>(default 127.0.0.1:7777:local)</p>
  </dt>
  <dd>
    <p>Host and port for the Symantec CarrierScan Server virus scanner.  This takes the form <em>ip_addr</em>:<em>port</em>:<em>local_or_nonlocal</em>.  The <em>ip_addr</em> and <em>port</em> are the host and port on which CarrierScan Server is listening.  If you want to scan local files, append :local to force the use of the AVSCANLOCAL command.  If the CarrierScan Server is on another host, append :nonlocal to force the file contents to be sent to the scanner over the socket.</p>
  </dd>
  <dt>
    <p><strong>$SophieSock </strong>(default /var/spool/MIMEDefang/sophie)</p>
  </dt>
  <dd>
    <p>Socket used for Sophie daemon calls within message_contains_virus_sophie and entity_contains_virus_sophie unless a socket is provided by the calling routine.</p>
  </dd>
  <dt>
    <p><strong>$ClamdSock </strong>(default /var/spool/MIMEDefang/clamd.sock)</p>
  </dt>
  <dd>
    <p>Socket used for clamd daemon calls within message_contains_virus_clamd and entity_contains_virus_clamd unless a socket is provided by the calling routine.</p>
  </dd>
  <dt>
    <p><strong>$TrophieSock </strong>(default /var/spool/MIMEDefang/trophie)</p>
  </dt>
  <dd>
    <p>Socket used for Trophie daemon calls within message_contains_virus_trophie and entity_contains_virus_trophie unless a socket is provided by the calling routine.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILTER</h2>
        <div class="sectioncontent">
<p>The heart of <strong>mimedefang-filter</strong> is the <strong>filter</strong> procedure.  See the examples that came with MIMEDefang to learn to write a filter. The filter is called with the following arguments:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>$entity</strong></p>
  </dt>
  <dd>
    <p>The MIME::Entity object.  (See the MIME::tools Perl module documentation.)</p>
  </dd>
  <dt>
    <p><strong>$fname</strong></p>
  </dt>
  <dd>
    <p>The suggested attachment filename, or "" if none was supplied.</p>
  </dd>
  <dt>
    <p><strong>$ext</strong></p>
  </dt>
  <dd>
    <p>The file extension (all characters from the rightmost period to the end of the filename.)</p>
  </dd>
  <dt>
    <p><strong>$type</strong></p>
  </dt>
  <dd>
    <p>The MIME type (for example, "text/plain".)</p>
  </dd>

</dl>
<p>The filename is derived as follows:</p>
<dl class='dl-vertical'>
  <dt>
    <p>o</p>
  </dt>
  <dd>
    <p>First, if the Content-Disposition header has a "filename" field, it is used.</p>
  </dd>
  <dt>
    <p>o</p>
  </dt>
  <dd>
    <p>Otherwise, if the Content-Type header has a "name" field, it is used.</p>
  </dd>
  <dt>
    <p>o</p>
  </dt>
  <dd>
    <p>Otherwise, the Content-Description header value is used.</p>
  </dd>

</dl>
<p>Note that the truly paranoid will check all three fields for matches. The functions <strong>re_match</strong> and <strong>re_match_ext</strong> perform regular expression matches on all three of the fields named above, and return 1 if any field matches.  See the sample filters for details.  The calling sequence is:</p>
<pre>
	re_match($entity, "regexp")
	re_match_ext($entity, "regexp")
</pre>
<p><strong>re_match</strong> returns true if any of the fields matches the regexp without regard to case.  <strong>re_match_ext</strong> returns true if the extension in any field matches.  An extension is defined as the last dot in a name and all remaining characters.</p><p>A third function called <strong>re_match_in_zip_directory</strong> will look inside zip files and return true if any of the file names inside the zip archive match the regular expression.  Call it like this:</p>
<pre>
	my $bh = $entity-&gt;bodyhandle();
	my $path = (defined($bh)) ? $bh-&gt;path() : undef;
	if (defined($path) and re_match_in_zip_directory($path, "regexp")) {
	    # Take action...
	}
</pre>
<p>You should <em>not</em> call <strong>re_match_in_zip_directory</strong> unless you know that the entity is a zip file attachment.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">GLOBAL VARIABLES SET BY MIMEDEFANG.PL</h2>
        <div class="sectioncontent">
<p>The following global variables are set by <strong>mimedefang.pl</strong> and are available for use in your filter.  All of these variables are always available to filter_begin, filter, filter_multipart and filter_end. In addition, some of them are available in <strong>filter_relay</strong>, <strong>filter_sender</strong> or <strong>filter_recipient</strong>.  If this is the case, it will be noted below.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>%Features</strong></p>
  </dt>
  <dd>
    <p>This hash lets you determine at run-time whether certain functionality is available.  This hash is available at all times assuming the detect_and_load_perl_modules() function has been called.  The defined features are:</p><p>$Features{"SpamAssassin"} is 1 if SpamAssassin 1.6 or better is installed; 0 otherwise.</p><p>$Features{"HTML::Parser"} is 1 if HTML::Parser is installed; 0 otherwise.</p><p>$Features{"Virus:FPROTD"} is currently always 0.  Set it to 1 in your filter file if you have F-Risk's FPROTD scanner earlier than version 6.</p><p>$Features{"Virus:FPROTD6"} is currently always 0.  Set it to 1 in your filter file if you have version 6 of F-Risk's FPROTD scanner.</p><p>$Features{"Virus:SymantecCSS"} is currently always 0.  Set it to 1 in your filter file if you have the Symantec CarrierScan Server virus scanner.</p><p>$Features{"Virus:NAI"} is the full path to NAI uvscan if it is installed; 0 if it is not.</p><p>$Features{"Virus:BDC"} is the full path to Bitdefender bdc if it is installed; 0 if it is not.</p><p>$Features{"Virus:NVCC"} is the full path to Norman Virus Control nvcc if it is installed; 0 if it is not.</p><p>$Features{"Virus:HBEDV"} is the full path to H+BEDV AntiVir if it is installed; 0 if it is not.</p><p>$Features{"Virus:VEXIRA"} is the full path to Central Command Vexira if it is installed; 0 if it is not.</p><p>$Features{"Virus:SOPHOS"} is the full path to Sophos sweep if it is installed; 0 if it is not.</p><p>$Features{"Virus:SAVSCAN"} is the full path to Sophos savscan if it is installed; 0 if it is not.</p><p>$Features{"Virus:CLAMAV"} is the full path to Clam AV clamscan if it is installed; 0 if it is not.</p><p>$Features{"Virus:AVP"} is the full path to AVP AvpLinux if it is installed; 0 if it is not.</p><p>$Features{"Virus:AVP5"} is the full path to Kaspersky "aveclient" if it is installed; 0 if it is not.</p><p>$Features{"Virus:CSAV"} is the full path to Command csav if it is installed; 0 if it is not.</p><p>$Features{"Virus:FSAV"} is the full path to F-Secure fsav if it is installed; 0 if it is not.</p><p>$Features{"Virus:FPROT"} is the full path to F-Risk f-prot if it is installed; 0 if it is not.</p><p>$Features{"Virus:FPSCAN"} is the full path to F-Risk fpscan if it is installed; 0 if it is not.</p><p>$Features{"Virus:SOPHIE"} is the full path to Sophie if it is installed; 0 if it is not.</p><p>$Features{"Virus:CLAMD"} is the full path to clamd if it is installed; 0 if it is not.</p><p>$Features{"Virus:TROPHIE"} is the full path to Trophie if it is installed; 0 if it is not.</p><p>$Features{"Virus:NOD32"} is the full path to ESET NOD32 nod32cli if it is installed; 0 if it is not.</p><p><strong>NOTE:</strong> Perl-module based features such as SpamAssassin are determined at runtime and may change as these are added and removed.  Most Virus features are predetermined at the time of configuration and do not adapt to runtime availability unless changed by the filter rules.</p>
  </dd>
  <dt>
    <p><strong>$CWD</strong></p>
  </dt>
  <dd>
    <p>This variable holds the working directory for the current message. During filter processing, <strong>mimedefang.pl</strong> chdir's into this directory before calling any of the filter_ functions.  Note that this variable <em>is</em> set correctly in <strong>filter_sender</strong> and <strong>filter_recipient</strong>, but <em>not</em> in <strong>filter_relay</strong>.</p>
  </dd>
  <dt>
    <p><strong>$SuspiciousCharsInHeaders</strong></p>
  </dt>
  <dd>
    <p>If this variable is true, then <strong>mimedefang</strong> has discovered suspicious characters in message headers.  This might be an exploit for bugs in MIME-parsing routines in some badly-written mail user agents (e.g. Microsoft Outlook.)  You should <em>always</em> drop such messages.</p>
  </dd>
  <dt>
    <p><strong>$SuspiciousCharsInBody</strong></p>
  </dt>
  <dd>
    <p>If this variable is true, then <strong>mimedefang</strong> has discovered suspicious characters in the message body.  This might be an exploit for bugs in MIME-parsing routines in some badly-written mail user agents (e.g. Microsoft Outlook.)  You should <em>always</em> drop such messages.</p>
  </dd>
  <dt>
    <p><strong>$RelayHostname</strong></p>
  </dt>
  <dd>
    <p>The host name of the relay.  This is the name of the host that is attempting to send e-mail to your host.  May be "undef" if the host name could not be determined.  This variable is available in <strong>filter_relay</strong>, <strong>filter_sender</strong> and <strong>filter_recipient</strong> in addition to the body filtering functions.</p>
  </dd>
  <dt>
    <p><strong>$RelayAddr</strong></p>
  </dt>
  <dd>
    <p>The IP address of the sending relay (as a string consisting of four dot-separated decimal numbers.)  One potential use of <strong>$RelayAddr</strong> is to limit mailing to certain lists to people within your organization.  This variable is available in <strong>filter_relay</strong>, <strong>filter_sender</strong> and <strong>filter_recipient</strong> in addition to the body filtering functions.</p><p><strong>$Helo</strong> The argument given to the SMTP "HELO" command.  This variable is available in <strong>filter_sender</strong> and <strong>filter_recipient</strong>, but <em>not</em> in <strong>filter_relay</strong>.</p>
  </dd>
  <dt>
    <p><strong>$Subject</strong></p>
  </dt>
  <dd>
    <p>The contents of the "Subject:" header.</p>
  </dd>
  <dt>
    <p><strong>$Sender</strong></p>
  </dt>
  <dd>
    <p>The sender of the e-mail.  This variable is set in <strong>filter_sender</strong> and <strong>filter_recipient</strong> in addition to the body filtering functions.</p>
  </dd>
  <dt>
    <p><strong>@Recipients</strong></p>
  </dt>
  <dd>
    <p>A list of the recipients.  In <strong>filter_recipient</strong>, it is set to the single recipient currently under consideration. Or, after calling <strong>read_commands_file</strong> within <strong>filter_recipient</strong>, the current recipient under consideration is in the final position of the array, at <strong>$Recipients[-1]</strong>, while any previous (and accepted) recipients are at the beginning of the array, that is, in <strong>@Recipients[0 .. $#Recipients-1]</strong>.</p>
  </dd>
  <dt>
    <p><strong>$MessageID</strong></p>
  </dt>
  <dd>
    <p>The contents of the "Message-ID:" header if one is present.  Otherwise, contains the string "NOQUEUE".</p>
  </dd>
  <dt>
    <p><strong>$QueueID</strong></p>
  </dt>
  <dd>
    <p>The Sendmail queue identifier if it could be determined.  Otherwise, contains the string "NOQUEUE". This variable <em>is</em> set correctly in <strong>filter_sender</strong> and <strong>filter_recipient</strong>, but it is <em>not</em> available in <strong>filter_relay</strong>.</p>
  </dd>
  <dt>
    <p><strong>$MsgID</strong></p>
  </dt>
  <dd>
    <p>Set to $QueueID if the queue ID could be determined; otherwise, set to $MessageID.  This identifier should be used in logging, because it matches the identifier used by Sendmail to log messages.  Note that this variable <em>is</em> set correctly in <strong>filter_sender</strong> and <strong>filter_recipient</strong>, but it is <em>not</em> available in <strong>filter_relay</strong>.</p>
  </dd>
  <dt>
    <p><strong>$VirusScannerMessages</strong></p>
  </dt>
  <dd>
    <p>Each time a virus-scanning function is called, messages (if any) from the virus scanner are accumulated in this variable.  You can use it in filter_end to formulate a notification (if you wish.)</p>
  </dd>
  <dt>
    <p><strong>$VirusName</strong></p>
  </dt>
  <dd>
    <p>If a virus-scanning function found a virus, this variable will hold the virus name (if it could be determined.)</p>
  </dd>
  <dt>
    <p><strong>$SASpamTester</strong></p>
  </dt>
  <dd>
    <p>If defined, this is the configured Mail::SpamAssassin object used for mail tests.  It may be initialized with a call to <strong>spam_assassin_init</strong> which also returns it.</p>
  </dd>
  <dt>
    <p><strong>%SendmailMacros</strong></p>
  </dt>
  <dd>
    <p>This hash contains the values of some Sendmail macros.  The hash elements exist only for macros defined by Sendmail.  See the Sendmail documentation for the meanings of the macros.</p><p>By default, <strong>mimedefang</strong> passes the values of the following macros: ${daemon_name}, ${daemon_port}, ${if_name}, ${if_addr}, $j, $_, $i, ${tls_version}, ${cipher}, ${cipher_bits}, ${cert_subject}, ${cert_issuer}, ${auth_type}, ${auth_authen}, ${auth_ssf}, ${auth_author}, ${mail_mailer}, ${mail_host} and ${mail_addr}. In addition, ${client_port} is set to the client's TCP port.</p><p>If any macro is not set or not passed to milter, it will be unavailable. To access the value of a macro, use:</p>
<pre>
	$SendmailMacros{"macro_name"}

</pre>
<p>Do not place curly brackets around the macro name. This variable is available in <strong>filter_sender</strong> and <strong>filter_recipient</strong> after a call to <strong>read_commands_file</strong>.</p>
  </dd>
  <dt>
    <p><strong>@SenderESMTPArgs</strong></p>
  </dt>
  <dd>
    <p>This array contains all the ESMTP arguments supplied in the MAIL FROM: command.  For example:</p>
<pre>
sub print_sender_esmtp_args {
    foreach (@SenderESMTPArgs) {
        print STDERR "Sender ESMTP arg: $_\n";
    }
}
</pre>

  </dd>
  <dt>
    <p><strong>%RecipientESMTPArgs</strong></p>
  </dt>
  <dd>
    <p>This hash contains all the ESMTP arguments supplied in each RCPT TO: command.  For example:</p>
<pre>
sub print_recip_esmtp_args {
    foreach my $recip (@Recipients) {
        foreach(@{$RecipientESMTPArgs{$recip}}) {
            print STDERR "Recip ESMTP arg for $recip: $_\n";
        }
    }
}
</pre>

  </dd>
  <dt>
    <p><strong>%RecipientMailers</strong></p>
  </dt>
  <dd>
    <p>This hash contains the Sendmail "mailer-host-address" triple for each recipient.  Here's an example of how to use it:</p>
<pre>
sub print_mailer_info {
    my($recip, $mailer, $host, $addr);
    foreach $recip (@Recipients) {
        $mailer = ${RecipientMailers{$recip}}[0];
        $host = ${RecipientMailers{$recip}}[1];
        $addr =  ${RecipientMailers{$recip}}[2];
        print STDERR "$recip: mailer=$mailer, host=$host, addr=$addr&#92;n";
    }
}
</pre>
<p>In <strong>filter_recipient</strong>, this variable by default only contains information on the recipient currently under investigation. Information on all recipients is available after calling <strong>read_commands_file</strong>.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ACTIONS</h2>
        <div class="sectioncontent">
<p>When the filter procedure decides how to dispose of a part, it should call one or more <strong>action_</strong> subroutines.  The action subroutines are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>action_accept()</strong></p>
  </dt>
  <dd>
    <p>Accept the part.</p>
  </dd>
  <dt>
    <p><strong>action_rebuild() </strong></p>
  </dt>
  <dd>
    <p>Rebuild the mail body, even if <strong>mimedefang</strong> thinks no changes were made. Normally, <strong>mimedefang</strong> does not alter a message if no changes were made.  <strong>action_rebuild</strong> may be used if you make changes to entities directly (by manipulating the MIME::Head, for example.) Unless you call <strong>action_rebuild</strong>, <strong>mimedefang</strong> will be unaware of the changes.  Note that all the built-in <strong>action...</strong> routines that change a message implicitly call <strong>action_rebuild</strong>.</p>
  </dd>
  <dt>
    <p><strong>action_add_header($hdr, $val)</strong></p>
  </dt>
  <dd>
    <p>Add a header to the message.  This can be used in <strong>filter_begin</strong> or <strong>filter_end</strong>.  The $hdr component is the header name <em>without the colon</em>, and the $val is the header value.  For example, to add the header:</p>
<pre>
	X-MyHeader: A nice piece of text
</pre>
<p>use:</p>
<pre>
	action_add_header("X-MyHeader", "A nice piece of text");
</pre>

  </dd>
  <dt>
    <p><strong>action_change_header($hdr, $val, $index)</strong></p>
  </dt>
  <dd>
    <p>Changes an existing header in the message. This can be used in <strong>filter_begin</strong> or <strong>filter_end</strong>.  The $hdr parameter is the header name <em>without the colon</em>, and $val is the header value. If the header does not exist, then a header with the given name and value is added.</p><p>The $index parameter is optional; it defaults to 1.  If you supply it, then the $index'th occurrence of the header is changed, if there is more than one header with the same name.  (This is common with the Received: header, for example.)</p>
  </dd>
  <dt>
    <p><strong>action_insert_header($hdr, $val, $index)</strong></p>
  </dt>
  <dd>
    <p>Add a header to the message int the specified position $index.  A position of 0 specifies that the header should be prepended before existing headers.  This can be used in <strong>filter_begin</strong> or <strong>filter_end</strong>.  The $hdr component is the header name <em>without</em> the colon, and the $val is the header value.</p>
  </dd>
  <dt>
    <p><strong>action_delete_header($hdr, $index)</strong></p>
  </dt>
  <dd>
    <p>Deletes an existing header in the message. This can be used in <strong>filter_begin</strong> or <strong>filter_end</strong>.  The $hdr parameter is the header name <em>without the colon</em>.</p><p>The $index parameter is optional; it defaults to 1.  If you supply it, then the $index'th occurrence of the header is deleted, if there is more than one header with the same name.</p>
  </dd>
  <dt>
    <p><strong>action_delete_all_headers($hdr)</strong></p>
  </dt>
  <dd>
    <p>Deletes all headers with the specified name.  This can be used in <strong>filter_begin</strong> or <strong>filter_end</strong>.  The $hdr parameter is the header name <em>without the colon</em>.</p>
  </dd>
  <dt>
    <p><strong>action_drop()</strong></p>
  </dt>
  <dd>
    <p>Drop the part.  If called from <strong>filter_multipart</strong>, drops all contained parts also.</p>
  </dd>
  <dt>
    <p><strong>action_drop_with_warning($msg)</strong></p>
  </dt>
  <dd>
    <p>Drop the part, but add the warning <em>$msg</em> to the e-mail message. If called from <strong>filter_multipart</strong>, drops all contained parts also.</p>
  </dd>
  <dt>
    <p><strong>action_accept_with_warning($msg)</strong></p>
  </dt>
  <dd>
    <p>Accept the part, but add the warning <em>$msg</em> to the e-mail message.</p>
  </dd>
  <dt>
    <p><strong>action_replace_with_warning($msg)</strong></p>
  </dt>
  <dd>
    <p>Drop the part and replace it with a text part <em>$msg</em>. If called from <strong>filter_multipart</strong>, drops all contained parts also.</p>
  </dd>
  <dt>
    <p><strong>action_replace_with_url($entity, $doc_root, $base_url, $msg, [$cd_data, $salt])</strong></p>
  </dt>
  <dd>
    <p>Drop the part, but save it in a unique location under $doc_root. The part is replaced with the text message $msg.  The string "_URL_" in $msg is replaced with $base_url/something, that can be used to retrieve the message.</p><p>You should not use this function in <strong>filter_multipart</strong>.</p><p>This action is intended for stripping large parts out of the message and replacing them to a link on a Web server.  Here's how you would use it in filter():</p>
<pre>
$size = (stat($entity-&gt;bodyhandle-&gt;path))[7];
if ($size &gt; 1000000) {
	return action_replace_with_url($entity,
		"/home/httpd/html/mail_parts",
		"http://mailserver.company.com/mail_parts",
		"The attachment was larger than 1,000,000 bytes.&#92;n" .
		"It was removed, but may be accessed at this URL:&#92;n&#92;n" .
		"&#92;t_URL_&#92;n");
}
</pre>
<p>This example moves attachments greater than 1,000,000 bytes into /home/httpd/html/mail_parts and replaces them with a link.  The directory should be accessible via a Web server at http://mailserver.company.com/mail_parts.</p><p>The generated name is created by performing a SHA1 hash of the part and adding the extension to the ASCII-HEX representation of the hash.  If many different e-mails are sent containing an identical large part, only one copy of the part is stored, regardless of the number of senders or recipients.</p><p>For privacy reasons, you <strong>must</strong> turn off Web server indexing in the directory in which you place mail parts, or anyone will be able to read them.  If indexing is disabled, an attacker would have to guess the SHA1 hash of a part in order to read it.</p><p>Optionally, a fifth argument can supply data to be saved into a hidden dot filename based on the generated name.  This data can then be read in on the fly by a CGI script or mod_perl module before serving the file to a web client, and used to add information to the response, such as Content-Disposition data.</p><p>A sixth optional argument, $salt, is mixed in to the SHA1 hash.  This salt can be any string and should be kept confidential.  The salt is designed to prevent people from guessing whether or not a particular attachment has been received on your server by altering the SHA1 hash calculation.</p>
  </dd>
  <dt>
    <p><strong>action_defang($entity, $name, $fname, $type)</strong></p>
  </dt>
  <dd>
    <p>Accept the part, but change its name to <em>$name</em>, its suggested filename to <em>$fname</em> and its MIME type to <em>$type</em>.  If <em>$name</em> or <em>$fname</em> are "", then <strong>mimedefang.pl</strong> generates generic names. Do not use this action in <strong>filter_multipart</strong>.</p><p>If you use <strong>action_defang</strong>, you must define a subroutine called <strong>defang_warning</strong> in your filter.  This routine takes two arguments: $oldfname (the original name of an attachment) and $fname (the defanged version.)  It should return a message telling the user what happened.  For example:</p>
<pre>
sub defang_warning {
    my($oldfname, $fname) = @_;
    return "The attachment '$oldfname' was renamed to '$fname'&#92;n";
}
</pre>

  </dd>
  <dt>
    <p><strong>action_external_filter($entity, $cmd)</strong></p>
  </dt>
  <dd>
    <p>Run an external UNIX command <strong>$cmd</strong>.  This command must read the part from the file <strong>./FILTERINPUT</strong> and leave the result in <strong>./FILTEROUTPUT</strong>. If the command executes successfully, returns 1, otherwise 0.  You can test the return value and call another <strong>action_</strong> if the filter failed. Do not use this action in <strong>filter_multipart</strong>.</p>
  </dd>
  <dt>
    <p><strong>action_quarantine($entity, $msg)</strong></p>
  </dt>
  <dd>
    <p>Drop and quarantine the part, but add the warning <em>$msg</em> to the e-mail message.</p>
  </dd>
  <dt>
    <p><strong>action_quarantine_entire_message($msg)</strong></p>
  </dt>
  <dd>
    <p>Quarantines the entire message in a quarantine directory on the mail server, but does not otherwise affect disposition of the message. If "$msg" is non-empty, it is included in any administrator notification.</p>
  </dd>
  <dt>
    <p><strong>action_sm_quarantine($reason)</strong></p>
  </dt>
  <dd>
    <p>Quarantines a message <em>in the Sendmail mail queue</em> using the new QUARANTINE facility of Sendmail 8.13.  Consult the Sendmail documentation for details about this facility.  If you use <strong>action_sm_quarantine</strong> with a version of Sendmail that lacks the QUARANTINE facility, <strong>mimedefang</strong> will log an error message and not quarantine the message.</p>
  </dd>
  <dt>
    <p><strong>action_bounce($reply, $code, $dsn)</strong></p>
  </dt>
  <dd>
    <p>Reject the entire e-mail message with an SMTP failure code, and the one-line error message <em>$reply</em>.  If the optional $code and $dsn arguments are supplied, they specify the numerical SMTP reply code and the extended status code (DSN code).  If the codes you supply do not make sense for a bounce, they are replaced with "554" and "5.7.1" respectively.</p><p><strong>action_bounce</strong> merely makes a note that the message is to be bounced; remaining parts are still processed.  If <strong>action_bounce</strong> is called for more than one part, the mail is bounced with the message in the final call to <strong>action_bounce</strong>. You can profitably call <strong>action_quarantine</strong> followed by <strong>action_bounce</strong> if you want to keep a copy of the offending part. Note that the message is not bounced immediately; rather, remaining parts are processed and the message is bounced after all parts have been processed.</p><p>Note that despite its name, <strong>action_bounce</strong> does <em>not</em> generate a "bounce message".  It merely rejects the message with an SMTP failure code.</p><p><strong>WARNING:</strong> <strong>action_bounce()</strong> may cause the sending relay to generate spurious bounce messages if the sender address is faked.  This is a particular problem with viruses.  However, we believe that on balance, it's better to bounce a virus than to silently discard it.  It's almost never a good idea to hide a problem.</p>
  </dd>
  <dt>
    <p><strong>action_tempfail($msg, $code, $dsn)</strong></p>
  </dt>
  <dd>
    <p>Cause an SMTP "temporary failure" code to be returned, so the sending mail relay requeues the message and tries again later.  The message $msg is included with the temporary failure code.  If the optional $code and $dsn arguments are supplied, they specify the numerical SMTP reply code and the extended status code (DSN code).  If the codes you supply do not make sense for a temporary failure, they are replaced with "450" and "4.7.1" respectively.</p>
  </dd>
  <dt>
    <p><strong>action_discard()</strong></p>
  </dt>
  <dd>
    <p>Silently discard the message, notifying nobody.  You can profitably call <strong>action_quarantine</strong> followed by <strong>action_discard</strong> if you want to keep a copy of the offending part.  Note that the message is not discarded immediately; rather, remaining parts are processed and the message is discarded after all parts have been processed.</p>
  </dd>
  <dt>
    <p><strong>action_notify_sender($message)</strong></p>
  </dt>
  <dd>
    <p>This action sends an e-mail back to the original sender with the indicated message.  You may call another action after this one.  If <strong>action_notify_sender</strong> is called more than once, the messages are accumulated into a single e-mail message -- at most one notification message is sent per incoming message.  The message should be terminated with a newline.</p><p>The notification is delivered in deferred mode; you should run a client-queue runner if you are using Sendmail 8.12.</p><p><em>NOTE</em>: Viruses often fake the sender address.  For that reason, if a virus-scanner has detected a virus, <strong>action_notify_sender</strong> is <em>disabled</em> and will simply log an error message if you try to use it.</p>
  </dd>
  <dt>
    <p><strong>action_notify_administrator($message)</strong></p>
  </dt>
  <dd>
    <p>This action e-mails the MIMEDefang administrator the supplied message. You may call another action after this one; <strong>action_notify_administrator</strong> does not affect mail processing.  If <strong>action_notify_administrator</strong> is called more than once, the messages are accumulated into a single e-mail message -- at most one notification message is sent per incoming message.  The message should be terminated with a newline.</p><p>The notification is delivered in deferred mode; you should run a client-queue runner if you are using Sendmail 8.12.</p>
  </dd>
  <dt>
    <p><strong>append_text_boilerplate($entity, $boilerplate, $all)</strong></p>
  </dt>
  <dd>
    <p>This action should <em>only</em> be called from <strong>filter_end</strong>.  It appends the text "&#92;n$boilerplate&#92;n" to the first text/plain part (if $all is 0) or to <em>all</em> text/plain parts (if $all is 1).</p>
  </dd>
  <dt>
    <p><strong>append_html_boilerplate($entity, $boilerplate, $all)</strong></p>
  </dt>
  <dd>
    <p>This action should <em>only</em> be called from <strong>filter_end</strong>.  It adds the text "&#92;n$boilerplate&#92;n" to the first text/html part (if $all is 0) or to <em>all</em> text/html parts (if $all is 1).  This function tries to be smart about inserting the boilerplate; it uses HTML::Parser to detect closing tags and inserts the boilerplate before the &lt;/body&gt; tag if there is one, or before the &lt;/html&gt; tag if there is no &lt;/body&gt;.  If there is no &lt;/body&gt; or &lt;/html&gt; tag, it appends the boilerplate to the end of the part.</p><p>Do not use append_html_boilerplate unless you have installed the HTML::Parser Perl module.</p><p>Here is an example illustrating how to use the boilerplate functions:</p>
<pre>
	sub filter_end {
		my($entity) = @_;
		append_text_boilerplate($entity,
			"Lame text disclaimer", 0);
		append_html_boilerplate($entity,
			"&lt;em&gt;Lame&lt;/em&gt; HTML disclaimer", 0);
	}
</pre>

  </dd>
  <dt>
    <p><strong>action_add_part($entity, $type, $encoding, $data, $fname, $disposition [, $offset])</strong></p>
  </dt>
  <dd>
    <p>This action should <em>only</em> be called from the <strong>filter_end</strong> routine.  It adds a new part to the message, converting the original message to mutipart if necessary.  The function returns the part so that additional mime attributes may be set on it.  Here's an example:</p>
<pre>
	sub filter_end {
		my($entity) = @_;

		action_add_part($entity, "text/plain", "-suggest",
 				"This e-mail does not represent" .
				"the official policy of FuBar, Inc.&#92;n",
				"disclaimer.txt", "inline");
        }
</pre>
<p>The $entity parameter <em>must</em> be the argument passed in to <strong>filter_end</strong>.  The $offset parameter is optional; if omitted, it defaults to -1, which adds the new part at the end.  See the MIME::Entity man page and the <strong>add_part</strong> member function for the meaning of $offset.</p><p>Note that <strong>action_add_part</strong> tries to be more intelligent than simply calling $entity-&gt;add_part.  The decision process is as follows:</p>
  </dd>
  <dt>
    <p><strong>o</strong></p>
  </dt>
  <dd>
    <p>If the top-level entity is multipart/mixed, then the part is simply added.</p>
  </dd>
  <dt>
    <p><strong>o</strong></p>
  </dt>
  <dd>
    <p>Otherwise, a new top-level multipart/mixed container is generated, and the original top-level entity is made the first part of the multipart/mixed container.  The new part is then added to the multipart/mixed container.</p>
  </dd>
  <dt>
    <p><strong>action_add_entity($entity [, $offset])</strong></p>
  </dt>
  <dd>
    <p>This is similar to <strong>action_add_part</strong> but takes a pre-built MIME::Entity object rather than constructing one based on $type, $encoding, $data, $fname and $disposition arguments.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">USEFUL ROUTINES</h2>
        <div class="sectioncontent">
<p><strong>mimedefang.pl</strong> includes some useful functions you can call from your filter:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>detect_and_load_perl_modules()</strong></p>
  </dt>
  <dd>
    <p>Unless you <em>really</em> know what you're doing, this function <strong>must</strong> be called first thing in your filter file.  It causes <strong>mimedefang.pl</strong> to detect and load Perl modules such as Mail::SpamAssassin, Net::DNS, etc., and to populate the %Features hash.</p>
  </dd>
  <dt>
    <p><strong>send_quarantine_notifications()</strong></p>
  </dt>
  <dd>
    <p>This function should be called from <strong>filter_end</strong>.  If any parts were quarantined, a quarantine notification is sent to the MIMEDefang administrator.  Please note that if you do not call <strong>send_quarantine_notifications</strong>, then <em>no</em> quarantine notifications are sent.</p>
  </dd>
  <dt>
    <p><strong>get_quarantine_dir()</strong></p>
  </dt>
  <dd>
    <p>This function returns the full path name of the quarantine directory. If you have not yet quarantined any parts of the message, a quarantine directory is created and its pathname returned.</p>
  </dd>
  <dt>
    <p><strong>change_sender($sender)</strong></p>
  </dt>
  <dd>
    <p>This function changes the envelope sender to $sender.  It can only be called from <strong>filter_begin</strong> or any later function.  Please note that this function is <em>only</em> supported with Sendmail/Milter 8.14.0 or newer.  It has <em>no effect</em> if you're running older versions.</p>
  </dd>
  <dt>
    <p><strong>add_recipient($recip)</strong></p>
  </dt>
  <dd>
    <p>This function adds $recip to the list of envelope recipients.  A copy of the message (after any modifications by MIMEDefang) will be sent to $recip in addition to the original recipients.  Note that <strong>add_recipient</strong> does <em>not</em> modify the @Recipients array; it just makes a note to Sendmail to add the recipient.</p>
  </dd>
  <dt>
    <p><strong>delete_recipient($recip)</strong></p>
  </dt>
  <dd>
    <p>This function deletes $recip from the list of recipients.  That person will not receive a copy of the mail.  $recip should exactly match an entry in the @Recipients array for delete_recipient() to work.  Note that <strong>delete_recipient</strong> does <em>not</em> modify the @Recipients array; it just makes a note to Sendmail to delete the recipient.</p>
  </dd>
  <dt>
    <p><strong>resend_message($recip1, $recip2, ...)</strong></p>
  </dt>
  <dd>
    <p>or</p>
  </dd>
  <dt>
    <p><strong>resend_message(@recips)</strong></p>
  </dt>
  <dd>
    <p>This function <em>immediately</em> resends the <em>original, unmodified</em> mail message to each of the named recipients.  The sender's address is preserved.  Be very careful when using this function, because it resends the <em>original</em> message, which may contain undesired attachments.  Also, you should <em>not</em> call this function from filter(), because it resends the message <em>each time</em> it is called.  This may result in multiple copies being sent if you are not careful.  Call from filter_begin() or filter_end() to be safe.</p><p>The function returns true on success, or false if it fails.</p><p>Note that the resend_message function delivers the mail in deferred mode (using Sendmail's "-odd" flag.)  You <em>must</em> run a client-submission queue processor if you use Sendmail 8.12.  We recommend executing this command as part of the Sendmail startup sequence:</p>
<pre>
	sendmail -Ac -q5m
</pre>

  </dd>
  <dt>
    <p><strong>remove_redundant_html_parts($entity)</strong></p>
  </dt>
  <dd>
    <p>This function should only be called from <strong>filter_end</strong>. It removes redundant HTML parts from the message.  It works by deleting any part of type text/html from the message if (1) it is a sub-part of a multipart/alternative part, and (2) there is another part of type text/plain under the multipart/alternative part.</p>
  </dd>
  <dt>
    <p><strong>replace_entire_message($entity)</strong></p>
  </dt>
  <dd>
    <p>This function can only be called from <strong>filter_end</strong>.  It replaces the entire message with $entity, a MIME::Entity object that you have constructed.  You can use any of the MIME::Tools functions to construct the entity.</p>
  </dd>
  <dt>
    <p><strong>read_commands_file()</strong></p>
  </dt>
  <dd>
    <p>This function should only be called from <strong>filter_sender</strong> and <strong>filter_recipient</strong>. This will read the <strong>COMMANDS</strong> file (as described in <a href="../man7/mimedefang-protocol.7.html"><strong>mimedefang-protocol</strong>(7)</a>), and will fill or update the following global variables: $Sender, @Recipients, %RecipientMailers, $RelayAddr, $RealRelayAddr, $RelayHostname, $RealRelayHostname, $QueueID, $Helo, %SendmailMacros.</p><p>If you do not call <strong>read_commands_file</strong>, then the only information available in <strong>filter_sender</strong> and <strong>filter_recipient</strong> is that which is passed as an argument to the function.</p>
  </dd>
  <dt>
    <p><strong>stream_by_domain()</strong></p>
  </dt>
  <dd>
    <p><em>Do not use this function unless you have Sendmail 8.12 and locally-</em> submitted e-mail is submitted using SMTP.</p><p>This function should <em>only</em> be called at the very beginning of filter_begin(), like this:</p>
<pre>
	sub filter_begin {
		if (stream_by_domain()) {
			return;
		}
		# Rest of filter_begin
	}
</pre>
<p>stream_by_domain() looks at all the recipients of the message, and if they belong to the same domain (e.g., joe@domain.com, jane@domain.com and sue@domain.com), it returns 0 and sets the global variable $Domain to the domain (domain.com in this example.)</p><p>If users are in different domains, stream_by_domain() <em>resends</em> the message (once to each domain) and returns 1 For example, if the original recipients are joe@abc.net, jane@xyz.net and sue@abc.net, the original message is resent twice: One copy to joe@abc.net and sue@abc.net, and another copy to jane@xyz.net.  Also, any subsequent scanning is canceled (filter() and filter_end() will <em>not</em> be called for the original message) and the message is silently discarded.</p><p>If you have Sendmail 8.12, then locally-submitted messages are sent via SMTP, and MIMEDefang will be called for each resent message. It is possible to set up Sendmail 8.12 so locally-submitted messages are delivered directly; in this case, stream_by_domain will <em>not</em> work.</p><p>Using stream_by_domain allows you to customize your filter rules for each domain.  If you use the function as described above, you can do this in your filter routine:</p>
<pre>
	sub filter {
		my($entity, $fname, $ext, $type) = @_;
		if ($Domain eq "abc.com") {
			# Filter actions for abc.com
		} elsif ($Domain eq "xyz.com") {
			# Filter actions for xyz.com
		} else {
			# Default filter actions
		}
	}
</pre>
<p>You cannot rely on $Domain being set unless you have called stream_by_domain().</p>
  </dd>
  <dt>
    <p><strong>stream_by_recipient()</strong></p>
  </dt>
  <dd>
    <p><em>Do not use this function unless you have Sendmail 8.12 and locally-</em> submitted e-mail is submitted using SMTP.</p><p>This function should <em>only</em> be called at the very beginning of filter_begin(), like this:</p>
<pre>
	sub filter_begin {
		if (stream_by_recipient()) {
			return;
		}
		# Rest of filter_begin
	}
</pre>
<p>If there is more than one recipient, stream_by_recipient() resends the message once to each recipient.  That way, you can customize your filter rules on a per-recipient basis.  This may increase the load on your mail server considerably.</p><p>Also, a "recipient" is determined before alias expansion.  So "all@mydomain.com" is considered a single recipient, even if Sendmail delivers to a list.</p><p>If you have Sendmail 8.12, then locally-submitted messages are sent via SMTP, and MIMEDefang will be called for each resent message. It is possible to set up Sendmail 8.12 so locally-submitted messages are delivered directly; in this case, stream_by_recipient() will <em>not</em> work.</p><p>stream_by_recipient() allows you to customize your filter rules for each recipient in a manner similar to stream_by_domain().</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LOGGING</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>md_graphdefang_log_enable($facility, $enum_recips)</strong></p>
  </dt>
  <dd>
    <p>Enables the md_graphdefang_log function (described next).  The function logs to syslog using the specified facility.  If you omit $facility, it defaults to 'mail'. If you do not call md_graphdefang_log_enable in your filter, then any calls to md_graphdefang_log simply do nothing.</p><p>If you supply $enum_recips as 1, then a line of logging is output for <em>each</em> recipient of a mail message.  If it is zero, then only a single line is output for each message.  If you omit $enum_recips, it defaults to 1.</p>
  </dd>
  <dt>
    <p><strong>md_graphdefang_log($event, $v1, $v2)</strong></p>
  </dt>
  <dd>
    <p>Logs an event with up to two optional additional parameters.  The log message has a specific format useful for graphing tools; the message looks like this:</p>
<pre>
	MDLOG,msgid,event,v1,v2,sender,recipient,subj
</pre>
<p>"MDLOG" is literal text.  "msgid" is the Sendmail queue identifier. "event" is the event name, and "v1" and "v2" are the additional parameters.  "sender" is the sender's e-mail address. "recipient" is the recipient's e-mail address, and "subj" is the message subject. If a message has more than one recipient, md_graphdefang_log may log an event message for <em>each</em> recipient, depending on how you called md_graphdefang_log_enable.</p><p>Note that md_graphdefang_log should not be used in filter_relay, filter_sender or filter_recipient.  The global variables it relies on are not valid in that context.</p><p>If you want to log general text strings, <em>do not</em> use md_graphdefang_log. Instead, use md_syslog (described next).</p>
  </dd>
  <dt>
    <p><strong>md_syslog($level, $msg)</strong></p>
  </dt>
  <dd>
    <p>Logs the message $msg to syslog, using level $level.  The level is a literal string, and should be one of 'err', 'debug', 'warning', \'emerg', 'crit', 'notice' or 'info'.  (See <a href="../man3/syslog.3.html"><strong>syslog</strong>(3)</a> for details.)</p><p>Note that md_syslog does <em>not</em> perform %-subsitutions like <a href="../man3/syslog.3.html"><strong>syslog</strong>(3)</a> does.  Depending on your Perl installation, md_syslog boils down to a call to Unix::Syslog::syslog or Sys::Syslog::syslog.  See the Unix::Syslog or Sys::Syslog man pages for more details.</p>
  </dd>
  <dt>
    <p><strong>md_openlog($tag, $facility)</strong></p>
  </dt>
  <dd>
    <p>Sets the tag used in syslog messages to $tag, and sends the logs to the $facility facility.  If you do not call md_openlog before you call md_syslog, then it is called implicitly with $tag set to <strong>mimedefang.pl</strong> and $facility set to <strong>mail</strong>.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RBL LOOKUP FUNCTIONS</h2>
        <div class="sectioncontent">
<p><strong>mimedefang.pl</strong> includes the following functions for looking up IP addresses in DNS-based real-time blacklists.  Note that the "relay_is_blacklisted" functions are deprecated and may be removed in a future release.  Instead, you should use the module Net::DNSBL::Client from CPAN.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>relay_is_blacklisted($relay, $domain)</strong></p>
  </dt>
  <dd>
    <p>This checks a DNS-based real-time spam blacklist, and returns true if the relay host is blacklisted, or false otherwise.  (In fact, the return value is whatever the blacklist returns as a resolved hostname, such as "127.0.0.4")</p><p>Note that <strong>relay_is_blacklisted</strong> uses the built-in <strong>gethostbyname</strong> function; this is usually quite inefficient and does not permit you to set a timeout on the lookup.  Instead, we recommend using one of the other DNS lookup function described in this section.  (Note, though, that the other functions require the Perl Net::DNS module, whereas <strong>relay_is_blacklisted</strong> does not.)</p><p>Here's an example of how to use <strong>relay_is_blacklisted</strong>:</p>
<pre>
	if (relay_is_blacklisted($RelayAddr, "rbl.spamhaus.org")) {
		action_add_header("X-Blacklist-Warning",
			  "Relay $RelayAddr is blacklisted by Spamhaus");
	}
</pre>

  </dd>
  <dt>
    <p><strong>relay_is_blacklisted_multi($relay, $timeout, $answers_wanted, [$domain1, $domain2, ...], $res)</strong></p>
  </dt>
  <dd>
    <p>This function is similar to <strong>relay_is_blacklisted</strong>, except that it takes a timeout argument (specified in seconds) and an array of domains to check. The function checks all domains in parallel, and is guaranteed to return in <strong>$timeout</strong> seconds.  (Actually, it may take up to one second longer.)</p><p>The parameters are:</p><p>$relay -- the IP address you want to look up</p><p>$timeout -- a timeout in seconds after which the function should return</p><p>$answers_wanted -- the maximum number of positive answers you care about. For example, if you're looking up an address in 10 different RBLs, but are going to bounce it if it is on four or more, you can set $answers_wanted to 4, and the function returns as soon as four "hits" are discovered.  If you set $answers_wanted to zero, then the function does not return early.</p><p>[$domain1, $domain2, ...] -- a reference to an array of strings, where each string is an RBL domain.</p><p>$res -- a Net::DNS::Resolver object.  This argument is optional; if you do not supply it, then <strong>relay_is_blacklisted_multi</strong> constructs its own resolver.</p><p>The return value is a reference to a hash; the keys of the hash are the original domains, and the corresponding values are either SERVFAIL, NXDOMAIN, or a list of IP addresses in dotted-quad notation.</p><p>Here's an example:</p>
<pre>
    $ans = relay_is_blacklisted_multi($RelayAddr, 8, 0,
        ["sbl.spamhaus.org", "relays.ordb.org"]);

    foreach $domain (keys(%$ans)) {
        $r = $ans-&gt;{$domain};
        if (ref($r) eq "ARRAY") {
            # It's an array -- it IS listed in RBL
            print STDERR "Lookup in $domain yields [ ";
            foreach $addr (@$r) {
                print STDERR $addr . " ";
            }
            print STDERR "]&#92;n";
        } else {
            # It is NOT listed in RBL
            print STDERR "Lookup in $domain yields "
                         . $ans-&gt;{$domain} . "&#92;n";
        }
    }
</pre>
<p>You should compare each of $ans-&gt;{$domain} to "SERVFAIL" and "NXDOMAIN" to see if the relay is <em>not</em> listed.  Any other return value will be an array of IP addresses indicating that the relay is listed.</p><p>Any lookup that does not succeed within $timeout seconds has the corresponding return value set to SERVFAIL.</p>
  </dd>
  <dt>
    <p><strong>relay_is_blacklisted_multi_list($relay, $timeout, $answers_wanted, [$domain1, $domain2, ...], $res)</strong></p>
  </dt>
  <dd>
    <p>This function is similar to <strong>relay_is_blacklisted_multi</strong> except that the return value is simply an array of RBL domains in which the relay was listed.</p>
  </dd>
  <dt>
    <p><strong>relay_is_blacklisted_multi_count($relay, $timeout, $answers_wanted, [$domain1, $domain2, ...], $res)</strong></p>
  </dt>
  <dd>
    <p>This function is similar to <strong>relay_is_blacklisted_multi</strong> except that the return value is an integer specifying the number of domains on which the relay was blacklisted.</p>
  </dd>
  <dt>
    <p><strong>md_get_bogus_mx_hosts($domain)</strong></p>
  </dt>
  <dd>
    <p>This function looks up all the MX records for the specified domain (or A records if there are no MX records) and returns a list of "bogus" IP addresses found amongst the records.  A "bogus" IP address is an IP address in a private network (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16), the loopback network (127.0.0.0/8), local-link for auto-DHCP (169.254.0.0/16), IPv4 multicast (224.0.0.0/4) or reserved (240.0.0.0/4).</p>
  </dd>

</dl>
<p>Here's how you might use the function in filter_sender:</p>
<pre>
sub filter_sender {
    my ($sender, $ip, $hostname, $helo) = @_;
    if ($sender =~ /\@([^&gt;]+)/) {
        my $domain = $1;
        my @bogushosts = md_get_bogus_mx_hosts($domain);
        if (scalar(@bogushosts)) {
            return('REJECT', "Domain $domain contains bogus MX record(s) " .
                   join(', ', @bogushosts));
        }
    }
    return ('CONTINUE', 'ok');
}
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TEST FUNCTIONS</h2>
        <div class="sectioncontent">
<p><strong>mimedefang.pl</strong> includes some "test" functions:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>md_version()</strong></p>
  </dt>
  <dd>
    <p>returns the version of MIMEDefang as a string (for example, "2.75").</p>
  </dd>
  <dt>
    <p><strong>message_rejected()</strong></p>
  </dt>
  <dd>
    <p>Returns true if any of <strong>action_tempfail</strong>, <strong>action_bounce</strong> or <strong>action_discard</strong> have been called for this message; returns false otherwise.</p>
  </dd>

</dl>
<p>If you have the Mail::SpamAssassin Perl module installed (see http://www.spamassassin.org) you may call any of the spam_assassin_* functions.  They should only be called from <strong>filter_begin</strong> or <strong>filter_end</strong> because they operate on the entire message at once. Most functions use an optionally provided config file.  If no config file is provided, mimedefang.pl will look for one of four default SpamAssassin preference files.  The first of the following found will be used:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>o</strong></p>
  </dt>
  <dd>
    <p>/etc/sa-mimedefang.cf</p>
  </dd>
  <dt>
    <p><strong>o</strong></p>
  </dt>
  <dd>
    <p>/etc/mail/sa-mimedefang.cf</p>
  </dd>
  <dt>
    <p><strong>o</strong></p>
  </dt>
  <dd>
    <p>/etc/spamassassin/local.cf</p>
  </dd>
  <dt>
    <p><strong>o</strong></p>
  </dt>
  <dd>
    <p>/etc/spamassassin.cf</p>
  </dd>

</dl>
<p><strong>Important Note</strong>:  MIMEDefang does <em>not</em> permit SpamAssassin to modify messages.  If you want to tag spam messages with special headers or alter the subject line, you must use MIMEDefang functions to do it. Setting SpamAssassin configuration options to alter messages will not work.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>spam_assassin_is_spam([ $config_file ])</strong></p>
  </dt>
  <dd>
    <p>Determine if the current message is SPAM/UCE as determined by SpamAssassin. Compares the score of the message against the threshold score (see below) and returns true if it is.  Uses <strong>spam_assassin_check</strong> below.</p>
  </dd>
  <dt>
    <p><strong>spam_assassin_check([ $config_file ])</strong></p>
  </dt>
  <dd>
    <p>This function returns a four-element list of the form ($hits, $required, $tests, $report).  $hits is the "score" given to the message by SpamAssassin (higher score means more likely SPAM). $required is the number of hits required before SpamAssassin concludes that the message is SPAM.  $tests is a comma-separated list of SpamAssassin test names, and $report is text detailing which tests triggered and their point score.  This gives you insight into why SpamAssassin concluded that the message is SPAM.  Uses <strong>spam_assassin_status</strong> below.</p>
  </dd>
  <dt>
    <p><strong>spam_assassin_status([ $config_file ])</strong></p>
  </dt>
  <dd>
    <p>This function returns a Mail::SpamAssasin::PerMsgStatus object.  Read the SpamAssassin documentation for details about this object.  You are responsible for calling the <strong>finish</strong> method when you are done with it. Uses <strong>spam_assassin_init</strong> and <strong>spam_assassin_mail</strong> below.</p>
  </dd>
  <dt>
    <p><strong>spam_assassin_init([ $config_file ])</strong></p>
  </dt>
  <dd>
    <p>This function returns the new global Mail::SpamAssassin object with the specified or default config (outlined above).  If the global object is already defined, returns it -- does not change config files!  The object can be used to perform other SpamAssassin related functions.</p>
  </dd>
  <dt>
    <p><strong>spam_assassin_mail()</strong></p>
  </dt>
  <dd>
    <p>This function returns a Mail::SpamAssassin::NoMailAudit object with the current email message contained in it.  It may be used to perform other SpamAssassin related functions.</p>
  </dd>
  <dt>
    <p><strong>md_copy_orig_msg_to_work_dir()</strong></p>
  </dt>
  <dd>
    <p>Normally, virus-scanners are passed only the unpacked, decoded parts of a MIME message.  If you want to pass the original, undecoded message in as well, call <strong>md_copy_orig_msg_to_work_dir</strong> <em>prior to</em> calling <strong>message_contains_virus</strong>.</p>
  </dd>
  <dt>
    <p><strong>md_copy_orig_msg_to_work_dir_as_mbox_file()</strong></p>
  </dt>
  <dd>
    <p>Normally, virus-scanners are passed only the unpacked, decoded parts of a MIME message.  If you want to pass the original, undecoded message in as a UNIX-style "mbox" file, call <strong>md_copy_orig_msg_to_work_dir_as_mbox_file</strong> <em>prior to</em> calling <strong>message_contains_virus</strong>.  The only difference between this function and <strong>md_copy_orig_msg_to_work_dir</strong> is that this function prepends a "From_" line to make the message look like a UNIX-style mbox file. This is required for some virus scanners (such as Clam AntiVirus) to recognize the file as an e-mail message.</p>
  </dd>
  <dt>
    <p><strong>message_contains_virus()</strong></p>
  </dt>
  <dd>
    <p>This function runs <em>every</em> installed virus-scanner and returns the scanner results.  The function should be called in list context; the return value is a three-element list ($code, $category, $action).</p><p>$code is the actual return code from the virus scanner.</p><p>$category is a string categorizing the return code:</p><p>"ok" - no viruses detected.</p><p>"not-installed" - indicated virus scanner is not installed.</p><p>"cannot-execute" - for some reason, the scanner could not be executed.</p><p>"virus" - a virus was found.</p><p>"suspicious" - a "suspicious" file was found.</p><p>"interrupted" - scanning was interrupted.</p><p>"swerr" - an internal scanner software error occurred.</p><p>$action is a string containing the recommended action:</p><p>"ok" - allow the message through unmolested.</p><p>"quarantine" - a virus was detected; quarantine it.</p><p>"tempfail" - something went wrong; tempfail the message.</p>
  </dd>
  <dt>
    <p><strong>message_contains_virus_trend()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>message_contains_virus_nai()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>message_contains_virus_bdc()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>message_contains_virus_nvcc()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>message_contains_virus_csav()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>message_contains_virus_fsav()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>message_contains_virus_hbedv()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>message_contains_virus_vexira()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>message_contains_virus_sophos()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>message_contains_virus_clamav()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>message_contains_virus_avp()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>message_contains_virus_avp5()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>message_contains_virus_fprot()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>message_contains_virus_fpscan()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>message_contains_virus_fprotd()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>message_contains_virus_fprotd_v6()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>message_contains_virus_nod32()</strong></p>
  </dt>
  <dd>
    <p>These functions should be called in <strong>list context</strong>.  They use the indicated anti-virus software to scan the message for viruses.  These functions are intended for use in filter_begin() to make an initial scan of the e-mail message.</p><p>The supported virus scanners are:</p>
  </dd>
  <dt>
    <p><strong>nai</strong></p>
  </dt>
  <dd>
    <p>NAI "uvscan" - http://www.nai.com/</p>
  </dd>
  <dt>
    <p><strong>bdc</strong></p>
  </dt>
  <dd>
    <p>Bitdefender "bdc" - http://www.bitdefender.com/</p>
  </dd>
  <dt>
    <p><strong>csav</strong></p>
  </dt>
  <dd>
    <p>Command Anti-Virus - http://www.commandsoftware.com/</p>
  </dd>
  <dt>
    <p><strong>fsav</strong></p>
  </dt>
  <dd>
    <p>F-Secure Anti-Virus - http://www.f-secure.com/</p>
  </dd>
  <dt>
    <p><strong>hbedv</strong></p>
  </dt>
  <dd>
    <p>H+BEDV "AntiVir" - http://www.hbedv.com/</p>
  </dd>
  <dt>
    <p><strong>vexira</strong></p>
  </dt>
  <dd>
    <p>Vexira "Vexira" - http://www.centralcommand.com/</p>
  </dd>
  <dt>
    <p><strong>sophos</strong></p>
  </dt>
  <dd>
    <p>Sophos AntiVirus - http://www.sophos.com/</p>
  </dd>
  <dt>
    <p><strong>avp</strong></p>
  </dt>
  <dd>
    <p>Kaspersky AVP and aveclient (AVP5) - http://www.avp.ru/</p>
  </dd>
  <dt>
    <p><strong>clamav</strong></p>
  </dt>
  <dd>
    <p>Clam AntiVirus - http://www.clamav.net/</p>
  </dd>
  <dt>
    <p><strong>f-prot</strong></p>
  </dt>
  <dd>
    <p>F-RISK F-PROT - http://www.f-prot.com/</p>
  </dd>
  <dt>
    <p><strong>nod32cli</strong></p>
  </dt>
  <dd>
    <p>ESET NOD32 - http://www.eset.com/</p>
  </dd>
  <dt>
    <p><strong>message_contains_virus_carrier_scan([$host])</strong></p>
  </dt>
  <dd>
    <p>Connects to the specified host:port:local_or_nonlocal (default <strong>$CSSHost</strong>), where the Symantec CarrierScan Server daemon is expected to be listening.  Return values are the same as the other message_contains_virus functions.</p>
  </dd>
  <dt>
    <p><strong>message_contains_virus_sophie([$sophie_sock])</strong></p>
  </dt>
  <dd>
    <p>Connects to the specified socket (default <strong>$SophieSock</strong>), where the Sophie daemon is expected to be listening.  Return values are the same as the other message_contains_virus functions.</p>
  </dd>
  <dt>
    <p><strong>message_contains_virus_clamd([$clamd_sock])</strong></p>
  </dt>
  <dd>
    <p>Connects to the specified socket (default <strong>$ClamdSock</strong>), where the clamd daemon is expected to be listening.  Return values are the same as the other message_contains_virus functions.</p>
  </dd>
  <dt>
    <p><strong>message_contains_virus_trophie([$trophie_sock])</strong></p>
  </dt>
  <dd>
    <p>Connects to the specified socket (default <strong>$TrophieSock</strong>), where the Trophie daemon is expected to be listening.  Return values are the same as the other message_contains_virus functions.</p>
  </dd>
  <dt>
    <p><strong>entity_contains_virus($entity)</strong></p>
  </dt>
  <dd>
    <p>This function runs the specified MIME::Entity through <em>every</em> installed virus-scanner and returns the scanner results.  The return values are the same as for <strong>message_contains_virus()</strong>.</p>
  </dd>
  <dt>
    <p><strong>entity_contains_virus_trend($entity)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>entity_contains_virus_nai($entity)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>entity_contains_virus_bdc($entity)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>entity_contains_virus_nvcc($entity)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>entity_contains_virus_csav($entity)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>entity_contains_virus_fsav($entity)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>entity_contains_virus_hbedv($entity)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>entity_contains_virus_sophos($entity)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>entity_contains_virus_clamav($entity)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>entity_contains_virus_avp($entity)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>entity_contains_virus_avp5($entity)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>entity_contains_virus_fprot($entity)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>entity_contains_virus_fpscan($entity)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>entity_contains_virus_fprotd($entity)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>entity_contains_virus_fprotd_v6($entity)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>entity_contains_virus_nod32($entity)</strong></p>
  </dt>
  <dd>
    <p>These functions, meant to be called from filter(), are similar to the message_contains_virus functions except they scan only the current part. They should be called from list context, and their return values are as described for the message_contains_virus functions.</p>
  </dd>
  <dt>
    <p><strong>entity_contains_virus_carrier_scan($entity[, $host])</strong></p>
  </dt>
  <dd>
    <p>Connects to the specified host:port:local_or_nonlocal (default <strong>$CSSHost</strong>), where the Symantec CarrierScan Server daemon is expected to be listening.  Return values are the same as the other entity_contains_virus functions.</p>
  </dd>
  <dt>
    <p><strong>entity_contains_virus_sophie($entity[, $sophie_sock])</strong></p>
  </dt>
  <dd>
    <p>Connects to the specified socket (default <strong>$SophieSock</strong>), where the Sophie daemon is expected to be listening.  Return values are the same as the other entity_contains_virus functions.</p>
  </dd>
  <dt>
    <p><strong>entity_contains_virus_trophie($entity[, $trophie_sock])</strong></p>
  </dt>
  <dd>
    <p>Connects to the specified socket (default <strong>$TrophieSock</strong>), where the Trophie daemon is expected to be listening.  Return values are the same as the other entity_contains_virus functions.</p>
  </dd>
  <dt>
    <p><strong>entity_contains_virus_clamd($entity[, $clamd_sock])</strong></p>
  </dt>
  <dd>
    <p>Connects to the specified socket (default <strong>$ClamdSock</strong>), where the clamd daemon is expected to be listening.  Return values are the same as the other entity_contains_virus functions.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SMTP FLOW</h2>
        <div class="sectioncontent">
<p>This section illustrates the flow of messages through MIMEDefang.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>1. INITIAL CONNECTION</strong></p>
  </dt>
  <dd>
    <p>If you invoked <strong>mimedefang</strong> with the <strong>-r</strong> option and have defined a filter_relay routine, it is called.</p>
  </dd>
  <dt>
    <p><strong>2. SMTP HELO COMMAND</strong></p>
  </dt>
  <dd>
    <p>The HELO string is stored internally, but no filter functions are called.</p>
  </dd>
  <dt>
    <p><strong>3. SMTP MAIL FROM: COMMAND</strong></p>
  </dt>
  <dd>
    <p>If you invoked <strong>mimedefang</strong> with the <strong>-s</strong> option and have defined a filter_sender routine, it is called.</p>
  </dd>
  <dt>
    <p><strong>4. SMTP RCPT TO: COMMAND</strong></p>
  </dt>
  <dd>
    <p>If you invoked <strong>mimedefang</strong> with the <strong>-t</strong> option and have defined a filter_recipient routine, it is called.</p>
  </dd>
  <dt>
    <p><strong>5. END OF SMTP DATA</strong></p>
  </dt>
  <dd>
    <p>filter_begin is called.  For each MIME part, filter is called.  Then filter_end is called.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PRESERVING RELAY INFORMATION</h2>
        <div class="sectioncontent">
<p>Most organizations have more than one machine handling internet e-mail.  If the primary machine is down, mail is routed to a secondary (or tertiary, etc.) MX server, which stores the mail until the primary MX host comes back up.  Mail is then relayed to the primary MX host.</p><p>Relaying from a secondary to a primary MX host has the unfortunate side effect of losing the original relay's IP address information. MIMEDefang allows you to preserve this information.  One way around the problem is to run MIMEDefang on all the secondary MX hosts and use the same filter.  However, you may not have control over the secondary MX hosts.  If you can persuade the owners of the secondary MX hosts to run MIMEDefang with a simple filter that only preserves relay information and does no other scanning, your primary MX host can obtain relay information and make decisions using $RelayAddr and $RelayHostname.</p><p>When you configure MIMEDefang, supply the "--with-ipheader" argument to the ./configure script.  When you install MIMEDefang, a file called <strong>/etc/mimedefang-ip-key</strong> will be created which contains a randomly-generated header name.  Copy this file to all of your mail relays.  It is important that all of your MX hosts have the <strong>same</strong> key.  The key should be kept confidential, but it's not disastrous if it leaks out.</p><p>On your secondary MX hosts, add this line to filter_end:</p>
<pre>
	add_ip_validation_header();
</pre>
<p><em>Note</em>:  You should <em>only</em> add the validation header to mail destined for one of your other MX hosts!  Otherwise, the validation header will leak out.</p><p>When the secondary MX hosts relay to the primary MX host, $RelayAddr and $RelayHostname will be set based on the IP validation header.  If MIMEDefang notices this header, it sets the global variable $WasResent to 1.  Since you don't want to trust the header unless it was set by one of your secondary MX hosts, you should put this code in filter_begin:</p>
<pre>
	if ($WasResent) {
		if ($RealRelayAddr ne "ip.of.secondary.mx" and
		    $RealRelayAddr ne "ip.of.tertiary.mx") {
			$RelayAddr = $RealRelayAddr;
			$RelayHostname = $RealRelayHostname;
		}
	}
</pre>
<p>This resets the relay address and hostname to the actual relay address and hostname, unless the message is coming from one of your other MX hosts.</p><p>On the primary MX host, you should add this in filter_begin:</p>
<pre>
	delete_ip_validation_header();
</pre>
<p>This prevents the validation header from leaking out to recipients.</p><p><em>Note</em>: The IP validation header works only in message-oriented functions.  It (obviously) has no effect on <strong>filter_relay</strong>, <strong>filter_sender</strong> and <strong>filter_recipient</strong>, because no header information is available yet.  You must take this into account when writing your filter; you must defer relay-based decisions to the message filter for mail arriving from your other MX hosts.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">GLOBAL VARIABLE LIFETIME</h2>
        <div class="sectioncontent">
<p>The following list describes the lifetime of global variables (thanks to Tony Nugent for providing this documentation.)</p><p>If you set a global variable:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>Outside a subroutine in your filter file</strong></p>
  </dt>
  <dd>
    <p>It is available to all functions, all the time.</p>
  </dd>
  <dt>
    <p><strong>In filter_relay, filter_sender or filter_recipient</strong></p>
  </dt>
  <dd>
    <p>Not guaranteed to be available to any other function, not even from one filter_recipient call to the next, when receiving a multi-recipient email message.</p>
  </dd>
  <dt>
    <p><strong>In filter_begin</strong></p>
  </dt>
  <dd>
    <p>Available to filter_begin, filter and filter_end</p>
  </dd>
  <dt>
    <p><strong>In filter</strong></p>
  </dt>
  <dd>
    <p>Available to filter and filter_end</p>
  </dd>
  <dt>
    <p><strong>In filter_end</strong></p>
  </dt>
  <dd>
    <p>Available within filter_end</p>
  </dd>

</dl>
<p>The "built-in" globals like $Subject, $Sender, etc. are always available to filter_begin, filter and filter_end. Some are available to filter_relay, filter_sender or filter_recipient, but you should check the documentation of the variable above for details.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MAINTAINING STATE</h2>
        <div class="sectioncontent">
<p>There are four basic groups of filtering functions:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>1</strong></p>
  </dt>
  <dd>
    <p>filter_relay</p>
  </dd>
  <dt>
    <p><strong>2</strong></p>
  </dt>
  <dd>
    <p>filter_sender</p>
  </dd>
  <dt>
    <p><strong>3</strong></p>
  </dt>
  <dd>
    <p>filter_recipient</p>
  </dd>
  <dt>
    <p><strong>4</strong></p>
  </dt>
  <dd>
    <p>filter_begin, filter, filter_multipart, filter_end</p>
  </dd>

</dl>
<p>In general, for a given mail message, these groups of functions may be called in completely different Perl processes.  Thus, there is <em>no way</em> to maintain state inside Perl between groups of functions. That is, you cannot set a variable in <strong>filter_relay</strong> and expect it to be available in <strong>filter_sender</strong>, because the <strong>filter_sender</strong> invocation might take place in a completely different process.</p><p>However, for a given mail message, the $CWD global variable holds the message spool directory, and the current working directory is set to $CWD.  Therefore, you can store state in files inside $CWD.  If <strong>filter_sender</strong> stores data in a file inside $CWD, then <strong>filter_recipient</strong> can retrieve that data.</p><p>Since <strong>filter_relay</strong> is called directly after a mail connection is established, there is no message context yet, no per-message mimedefang spool directory, and the $CWD global is not set. Therefore, it is not possible to share information from <strong>filter_relay</strong> to one of the other filter functions. The only thing that <strong>filter_relay</strong> has in common with the other functions are the values in the globals $RelayAddr, and $RelayHostname. These could be used to access per-remote-host information in some database.</p><p>Inside $CWD, we reserve filenames beginning with upper-case letters for internal MIMEDefang use.  If you want to create files to store state, name them beginning with a lower-case letter to avoid clashes with future releases of MIMEDefang.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SOCKET MAPS</h2>
        <div class="sectioncontent">
<p>If you have Sendmail 8.13 or later, and have compiled it with the SOCKETMAP option, then you can use a special map type that communicates over a socket with another program (rather than looking up a key in a Berkeley database, for example.)</p><p><strong>mimedefang-multiplexor</strong> implements the Sendmail SOCKETMAP protocol if you supply the <strong>-N</strong> option.  In that case, you can define a function called <strong>filter_map</strong> to implement map lookups.  <strong>filter_map</strong> takes two arguments:  $mapname is the name of the Sendmail map (as given in the K sendmail configuration directive), and $key is the key to be looked up.</p><p><strong>filter_map</strong> must return a two-element list: ($code, $val) $code can be one of:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>OK</strong></p>
  </dt>
  <dd>
    <p>The lookup was successful.  In this case, $val must be the result of the lookup</p>
  </dd>
  <dt>
    <p><strong>NOTFOUND</strong></p>
  </dt>
  <dd>
    <p>The lookup was unsuccessful -- the key was not found.  In this case, $val should be the empty string.</p>
  </dd>
  <dt>
    <p><strong>TEMP</strong></p>
  </dt>
  <dd>
    <p>There was a temporary failure of some kind.  $val can be an explanatory error message.</p>
  </dd>
  <dt>
    <p><strong>TIMEOUT</strong></p>
  </dt>
  <dd>
    <p>There was a timeout of some kind.  $val can be an explanatory error message.</p>
  </dd>
  <dt>
    <p><strong>PERM</strong></p>
  </dt>
  <dd>
    <p>There was a permanent failure.  This is <em>not</em> the same as an unsuccessful lookup; it should be used only to indicate a serious misconfiguration.  As before, $val can be an explanatory error message.</p>
  </dd>

</dl>
<p>Consider this small example.  Here is a minimal Sendmail configuration file:</p>
<pre>
	V10/Berkeley
	Kmysock socket unix:/var/spool/MIMEDefang/map.sock
	kothersock socket unix:/var/spool/MIMEDefang/map.sock
</pre>
<p>If <strong>mimedefang-multiplexor</strong> is invoked with the arguments <strong>-N unix:/var/spool/MIMEDefang/map.sock</strong>, and the filter defines <strong>filter_map</strong> as follows:</p>
<pre>
	sub filter_map ($$) {
	    my($mapname, $key) = @_;
	    my $ans;
	    if($mapname ne "mysock") {
	        return("PERM", "Unknown map $mapname");
	    }
	    $ans = reverse($key);
	    return ("OK", $ans);
	}
</pre>
<p>Then in Sendmail's testing mode, we see the following:</p>
<pre>
	&gt; /map mysock testing123
	map_lookup: mysock (testing123) returns 321gnitset (0)
	&gt; /map othersock foo
	map_lookup: othersock (foo) no match (69)
</pre>
<p>(The return code of 69 means EX_UNAVAILABLE or Service Unavailable)</p><p>A real-world example could do map lookups in an LDAP directory or SQL database, or perform other kinds of processing.  You can even implement standard Sendmail maps like virtusertable, mailertable, access_db, etc. using SOCKETMAP.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TICK REQUESTS</h2>
        <div class="sectioncontent">
<p>If you supply the <strong>-X</strong> option to <strong>mimedefang-multiplexor</strong>, then every so often, a "tick" request is sent to a free slave.  If your filter defines a function called <strong>filter_tick</strong>, then this function is called with a single argument: the tick type.  If you run multiple parallel ticks, then each tick has a type ranging from 0 to <em>n</em>-1, where <em>n</em> is the number of parallel ticks.  If you're only running one tick request, then the argument to <strong>filter_tick</strong> is always 0.</p><p>You can use this facility to run periodic tasks from within MIMEDefang.  Note, however, that you have no control over which slave is picked to run <strong>filter_tick</strong>.  Also, at most one <strong>filter_tick</strong> call with a particular "type" argument will be active at any time, and if there are no free slaves when a tick would occur, the tick is skipped.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SUPPORTED VIRUS SCANNERS</h2>
        <div class="sectioncontent">
<p>The following virus scanners are supported by MIMEDefang:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>o</strong></p>
  </dt>
  <dd>
    <p>Symantec CarrierScan Server (http://www.symantec.com/region/can/eng/product/scs/)</p>
  </dd>
  <dt>
    <p><strong>o</strong></p>
  </dt>
  <dd>
    <p>Trend Micro vscan (http://www.antivirus.com/)</p>
  </dd>
  <dt>
    <p><strong>o</strong></p>
  </dt>
  <dd>
    <p>Sophos Sweep (http://www.sophos.com/products/antivirus/savunix.html)</p>
  </dd>
  <dt>
    <p><strong>o</strong></p>
  </dt>
  <dd>
    <p>H+BEDV AntiVir (http://www.hbedv.com/)</p>
  </dd>
  <dt>
    <p><strong>o</strong></p>
  </dt>
  <dd>
    <p>Central Command Vexira (http://www.centralcommand.com/)</p>
  </dd>
  <dt>
    <p><strong>o</strong></p>
  </dt>
  <dd>
    <p>NAI uvscan (http://www.nai.com)</p>
  </dd>
  <dt>
    <p><strong>o</strong></p>
  </dt>
  <dd>
    <p>Bitdefender bdc (http://www.bitdefender.com)</p>
  </dd>
  <dt>
    <p><strong>o</strong></p>
  </dt>
  <dd>
    <p>Norman Virus Control (NVCC) (http://www.norman.no/)</p>
  </dd>
  <dt>
    <p><strong>o</strong></p>
  </dt>
  <dd>
    <p>Command csav (http://www.commandsoftware.com)</p>
  </dd>
  <dt>
    <p><strong>o</strong></p>
  </dt>
  <dd>
    <p>F-Secure fsav (http://www.f-secure.com)</p>
  </dd>
  <dt>
    <p><strong>o</strong></p>
  </dt>
  <dd>
    <p>The clamscan command-line scanner and the clamd daemon from Clam AntiVirus (http://www.clamav.net/)</p>
  </dd>
  <dt>
    <p><strong>o</strong></p>
  </dt>
  <dd>
    <p>Kaspersky Anti-Virus (AVP) (http://www.kaspersky.com/)</p>
  </dd>
  <dt>
    <p><strong>o</strong></p>
  </dt>
  <dd>
    <p>F-Risk F-Prot (http://www.f-prot.com/)</p>
  </dd>
  <dt>
    <p><strong>o</strong></p>
  </dt>
  <dd>
    <p>F-Risk F-Prot v6 (http://www.f-prot.com/)</p>
  </dd>
  <dt>
    <p><strong>o</strong></p>
  </dt>
  <dd>
    <p>F-Risk FPROTD (daemonized version of F-Prot)</p>
  </dd>
  <dt>
    <p><strong>o</strong></p>
  </dt>
  <dd>
    <p>Symantec CarrierScan Server (http://www.symantec.ca/region/can/eng/product/scs/buymenu.html)</p>
  </dd>
  <dt>
    <p><strong>o</strong></p>
  </dt>
  <dd>
    <p>Sophie (http://www.vanja.com/tools/sophie/), which uses the libsavi library from Sophos, is supported in daemon-scanning mode.</p>
  </dd>
  <dt>
    <p><strong>o</strong></p>
  </dt>
  <dd>
    <p>Trophie (http://www.vanja.com/tools/trophie/), which uses the libvsapi library from Trend Micro, is supported in daemon-scanning mode.</p>
  </dd>
  <dt>
    <p><strong>o</strong></p>
  </dt>
  <dd>
    <p>ESET NOD32 (http://www.eset.com/)</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p><strong>mimedefang</strong> was written by David F. Skoll &lt;dfs@roaringpenguin.com&gt;. The <strong>mimedefang</strong> home page is <em>http://www.mimedefang.org/</em>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO mimedefang-filter&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man8/mimedefang.8.html"><strong>mimedefang</strong>(8)</a>, <a href="../man8/mimedefang.pl.8.html"><strong>mimedefang.pl</strong>(8)</a></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="mime.types.5.html"><span aria-hidden="true">&larr;</span> mime.types.5: Mime type description file for cups</a></li>
   <li class="next"><a href="miredo-server.conf.5.html">miredo-server.conf.5: Configuration for miredo-server <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>yaws.conf: Configuration file for the yaws web server</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Configuration file for the yaws web server">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="yaws.conf (5) manual">
  <meta name="twitter:description" content="Configuration file for the yaws web server">
  <meta name="twitter:image" content="https://www.carta.tech/images/yaws-yaws.conf-5.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man5/yaws.conf.5.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="yaws.conf (5) manual" />
  <meta property="og:description" content="Configuration file for the yaws web server" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/yaws-yaws.conf-5.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">yaws.conf<small> (5)</small></h1>
        <p class="lead">Configuration file for the yaws web server</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/">
      <span itemprop="name">File formats and conventions</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/yaws.conf.5.html">
      <span itemprop="name">yaws.conf: Configuration file for the yaws web server</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/yaws/">
      <span itemprop="name">yaws</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/yaws.conf.5.html">
      <span itemprop="name">yaws.conf: Configuration file for the yaws web server</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Yaws is fast lightweight web server. It reads a configuration file called yaws.conf to control its operations. The configuration contains two distinct parts a global part which affects all the virtual hosts and a server part where options for each virtual host is supplied.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">GLOBAL PART</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>logdir = [+]Directory</strong></p>
  </dt>
  <dd>
    <p>All Yaws logs will be written to files in this directory. If specified with <strong>+</strong>, Yaws will attempt to create the directory if it does not exist. There are several different log files written by Yaws:</p><p><strong>report.log</strong> - this is a text file that contains all error logger printouts from Yaws.</p><p><strong>&lt;Host&gt;.access</strong> - for each virtual host served by Yaws, a file &lt;Host&gt;.access will be written which contains an access log in Common Log Format. (See http://en.wikipedia.org/wiki/Common_Log_Format for more details on Common Log Format.)</p><p><strong>&lt;Host&gt;.auth</strong> - for each virtual host served by Yaws, a file &lt;Host&gt;.auth will be written which contains all http auth related messages.</p><p><strong>trace_&lt;YYYYMMDD_hhmmss&gt;</strong> - Trace files are written in this subdirectory, suffixed by the creation date.</p><p><strong>trace.&lt;Pid&gt;.http</strong> - this file contains the HTTP trace if that is enabled, where &lt;Pid&gt; is the process id handling the TCP connection.</p><p><strong>trace.&lt;Pid&gt;.traffic</strong> - this file contains the traffic trace if that is enabled, where &lt;Pid&gt; is the process id handling the TCP connection.</p><ul>
<li><p>Note that &lt;Host&gt;.access and &lt;Host&gt;.auth files will be used only if the directive <strong>logger_mod</strong> is not set or set to yaws_log. The default value for logdir is <em>"."</em></p></li>
</ul>
  </dd>
  <dt>
    <p><strong>ebin_dir = Directory</strong></p>
  </dt>
  <dd>
    <p>This directive adds Directory to the Erlang search path. It is possible to have several of these commands in the configuration file. The default value is <em>"yaws_dir"/examples/ebin</em></p>
  </dd>
  <dt>
    <p><strong>src_dir = Directory</strong></p>
  </dt>
  <dd>
    <p>This directive defines a Directory as a <em>source</em> directory. Yaws will compile all erlang modules found in this directory and all its subdirectories. The compilation occurs when the configuration is loaded or reloaded. The <strong>include_dir</strong> directives are used to search for includes files. Multiple <strong>src_dir</strong> directives may be used. There is no such directory configured by default.</p>
  </dd>
  <dt>
    <p><strong>id = String</strong></p>
  </dt>
  <dd>
    <p>It is possible run multiple Yaws servers on the same machine. We use the id of a Yaws server to control it using the different control commands such as:</p>
<pre>
  # /usr/local/bin/yaws --id foobar --stop
</pre>
<p>To stop the Yaws server with id "foobar". Each Yaws server will write its internals data into a file called $HOME/.yaws/yaws/ID where ID is the identity of the server. Yaws also creates a file called ${VARDIR}/run/yaws/ctl-${ID} which contain the port number where the server is listening for control commands. The default id is <em>"default"</em>.</p>
  </dd>
  <dt>
    <p><strong>server_signature = String</strong></p>
  </dt>
  <dd>
    <p>This directive sets the "Server: " output header to the custom value. The default value is <em>"yaws/%VSN%, Yet Another Web Server"</em>.</p>
  </dd>
  <dt>
    <p><strong>include_dir = Directory</strong></p>
  </dt>
  <dd>
    <p>This directive adds Directory to the path of directories where the Erlang compiler searches for include files. We need to use this if we want to include .hrl files in our Yaws Erlang code. It is possible to have several of these commands in the configuration file. The default value is <em>"yaws_dir"/examples/include</em>.</p>
  </dd>
  <dt>
    <p><strong>max_num_cached_files = Integer</strong></p>
  </dt>
  <dd>
    <p>Yaws will cache small files such as commonly accessed GIF images in RAM.  This directive sets a maximum number on the number of cached files.  The default value is <em>400</em>.</p>
  </dd>
  <dt>
    <p><strong>max_num_cached_bytes = Integer</strong></p>
  </dt>
  <dd>
    <p>This directive controls the total amount of RAM which can maximally be used for cached RAM files. The default value is <em>1000000</em>, 1 megabyte.</p>
  </dd>
  <dt>
    <p><strong>max_size_cached_file = Integer</strong></p>
  </dt>
  <dd>
    <p>This directive sets a maximum size on the files that are RAM cached by Yaws. The default value is <em>8000</em>, 8 kBytes.</p>
  </dd>
  <dt>
    <p><strong>cache_refresh_secs = Integer</strong></p>
  </dt>
  <dd>
    <p>The RAM cache is used to serve pages that sit in the cache. An entry sits in cache at most cache_refresh_secs number of seconds. The default is <em>30</em>. This means that when the content is updated under the docroot, that change doesn't show until 30 seconds have passed. While developing a Yaws site, it may be convenient to set this value to 0. If the debug flag (-d) is passed to the Yaws start script, this value is automatically set to 0.</p>
  </dd>
  <dt>
    <p><strong>trace  = false | traffic | http</strong></p>
  </dt>
  <dd>
    <p>This enables traffic or http tracing. Tracing is also possible to enable with a command line flag to Yaws. Default is <em>false</em>.</p>
  </dd>
  <dt>
    <p><strong>use_old_ssl = true | false</strong></p>
  </dt>
  <dd>
    <p>This re-enables the old OTP SSL implementation. By default we use the new SSL implementation.</p>
  </dd>
  <dt>
    <p><strong>auth_log  = true | false</strong></p>
  </dt>
  <dd>
    <p><strong>Deprecated and ignored. Now, this target must be set in server part.</strong></p>
  </dd>
  <dt>
    <p><strong>max_connections = nolimit | Integer</strong></p>
  </dt>
  <dd>
    <p>Set this value to control the maximum number of connections from HTTP clients into the server. This is implemented by closing the last socket if the limit threshold is reached.</p>
  </dd>
  <dt>
    <p><strong>keepalive_maxuses = nolimit | Integer</strong></p>
  </dt>
  <dd>
    <p>Normally, Yaws does not restrict the number of times a connection is kept alive using keepalive. Setting this parameter to an integer X will ensure that connections are closed once they have been used X times.  This can be a useful to guard against long running connections collecting too much garbage in the Erlang VM.</p>
  </dd>
  <dt>
    <p><strong>process_options = undefined | Proplist</strong></p>
  </dt>
  <dd>
    <p>Set process spawn options for client acceptor processes.  Options must be specified as a quoted string of either the atom <em>undefined</em> or as a proplist of valid process options. The supported options are <em>fullsweep_after</em>, <em>min_heap_size</em>, and <em>min_bin_vheap_size</em>, each taking an associated integer value. Other process options are ignored. The proplist may also be empty. See <strong>erlang:spawn_opt/4</strong> for details on these options.</p>
  </dd>
  <dt>
    <p><strong>large_file_chunk_size = Integer</strong></p>
  </dt>
  <dd>
    <p>Set the chunk size used by Yaws to send large files when sendfile is not supported or disabled. The default value is <em>10240</em>.</p>
  </dd>
  <dt>
    <p><strong>large_file_sendfile = erlang | yaws | disable</strong></p>
  </dt>
  <dd>
    <p>Set the version of sendfile method to use to send large files (if supported):</p><p><strong>erlang</strong> - use <em>file:sendfile/5</em>, if supported.</p><p><strong>yaws</strong> - use Yaws sendfile linked-in driver, if supported.</p><p><strong>disable</strong> - do not use any sendfile method, but <em>gen_tcp:send/2</em>.</p><p>The default value is <em>yaws</em>.</p>
  </dd>
  <dt>
    <p><strong>acceptor_pool_size = Integer</strong></p>
  </dt>
  <dd>
    <p>Set the size of the pool of cached acceptor processes. The specified value must be greater than or equal to 0. The default value is <em>8</em>. Specifying a value of 0 effectively disables the process pool.</p>
  </dd>
  <dt>
    <p><strong>log_wrap_size = Integer</strong></p>
  </dt>
  <dd>
    <p>The logs written by Yaws are all wrap logs, the default value at the size where they wrap around and the original gets renamed to File.old is <em>1000000</em>, 1 megabyte. This value can be changed.</p><p>If we set the value to 0 the logs will never wrap. If we want to use Yaws in combination with a more traditional log wrapper such as logrotate, set the size to 0 and Yaws will reopen the logfiles once they have be renamed/removed.</p>
  </dd>
  <dt>
    <p><strong>log_resolve_hostname = true | false</strong></p>
  </dt>
  <dd>
    <p>By default the client host IP is not resolved in the access logs.</p>
  </dd>
  <dt>
    <p><strong>fail_on_bind_err = true | false</strong></p>
  </dt>
  <dd>
    <p>Fail completely or not if Yaws fails to bind a listen socket Default is <em>true</em>.</p>
  </dd>
  <dt>
    <p><strong>enable_soap = true | false</strong></p>
  </dt>
  <dd>
    <p>If true, a soap server will be started at startup of Yaws.  Default is <em>false</em>.</p>
  </dd>
  <dt>
    <p><strong>soap_srv_mods = ListOfModuleSetting</strong></p>
  </dt>
  <dd>
    <p>If enable_soap is true, a startup Yaws will invoke <em>yaws_soap_srv:setup()</em> to setup modules set here. ModuleSetting is either a triad like <em>&lt;Mod,</em> HandlerFunc, WsdlFile&gt; or a quadruple form like <em>&lt;Mod, HandlerFunc,</em> WsdlFile, Prefix&gt; which specifies the <em>prefix</em>. A <em>prefix</em> will be used as argument of <em>yaws_soap_lib:initModel()</em> and then be used as a XML namespace prefix.  Note, the <em>WsdlFile</em> here should be an absolute-path file in local file systems.</p><p>For example, we can specify</p>
<pre>
  soap_srv_mods=&lt;Mod1, Handler, Wsdl1&gt; &lt;Mod2, Handler, Wsdl2, Prefix&gt; ...
</pre>

  </dd>
  <dt>
    <p><strong>php_exe_path = Path</strong></p>
  </dt>
  <dd>
    <p><strong>this target is deprecated and useless. use 'php_handler' target in server</strong> part instead.</p><p>The name of (and possibly path to) the php executable used to interpret php scripts (if allowed).  Default is <em>php_exe_path = php-cgi</em>.</p>
  </dd>
  <dt>
    <p><strong>copy_error_log  = true | false</strong></p>
  </dt>
  <dd>
    <p>Enable or disable copying of the error log. When we run in embedded mode, there may very well be some other systems process that is responsible for writing the errorlog to a file whereas when we run in normal standalone mode, we typically want the Erlang errorlog written to a report.log file.  Default value is <em>true</em>.</p>
  </dd>
  <dt>
    <p><strong>ysession_mod = Module</strong></p>
  </dt>
  <dd>
    <p>Allows to specify a different Yaws session storage mechanism instead of an ETS table. One of the drawbacks of the default yaws_session_server implementation is that server side cookies are lost when the server restarts. Specifying a different module here will pass all writes/read operations to this module (it must implements appropriate callbacks).</p>
  </dd>
  <dt>
    <p><strong>runmod = ModuleName</strong></p>
  </dt>
  <dd>
    <p>At startup Yaws will invoke <em>ModuleName:start()</em> in a separate process. It is possible to have several runmods.  This is useful if we want to reuse the Yaws startup shell script for our own application.</p>
  </dd>
  <dt>
    <p><strong>pick_first_virthost_on_nomatch = true | false</strong></p>
  </dt>
  <dd>
    <p>When Yaws gets a request, it extracts the Host: header from the client request to choose a virtual server amongst all servers with the same IP/Port pair.  This configuration parameter decides whether Yaws should pick the first (as defined in the yaws.conf file) if no name match or not.  In real live hosting scenarios we typically want this to be false whereas in testing/development scenarios it may be convenient to set it to true. Default is <em>true</em>.</p>
  </dd>
  <dt>
    <p><strong>keepalive_timeout = TimeInMilliseconds | infinity</strong></p>
  </dt>
  <dd>
    <p>If the HTTP session will be kept alive (i.e., not immediately closed) it will close after keepalive_timeout milliseconds unless a new request is received in that time. The default value is <em>30000</em>. The value <em>infinity</em> is legal but not recommended.</p>
  </dd>
  <dt>
    <p><strong>subconfig = File</strong></p>
  </dt>
  <dd>
    <p>Load specified config file.</p>
  </dd>
  <dt>
    <p><strong>subconfigdir = Directory</strong></p>
  </dt>
  <dd>
    <p>Load all config file in specified directory.</p>
  </dd>
  <dt>
    <p><strong>x_forwarded_for_log_proxy_whitelist = ListOfUpstreamProxyServerIps</strong></p>
  </dt>
  <dd>
    <p><strong>this target is deprecated and will be ignored.</strong></p>
  </dd>
  <dt>
    <p><strong>default_type = MimeType</strong></p>
  </dt>
  <dd>
    <p>Defines the default MIME type to be used where Yaws cannot determine it by its MIME types mappings. Default is <em>text/plain</em>.</p>
  </dd>
  <dt>
    <p><strong>default_charset = Charset</strong></p>
  </dt>
  <dd>
    <p>Defines the default charset to be added when a response content-type is <em>text/*</em>. By default, no charset is added.</p>
  </dd>
  <dt>
    <p><strong>mime_types_file = File</strong></p>
  </dt>
  <dd>
    <p>Overrides the default <em>mime.types</em> file included with Yaws. This file must use the following format:</p>
<pre>
  # Lines beginning with a '#' or a whitespace are ignored
  # blank lines are also ignored
  &lt;MIME type&gt; &lt;space separated file extensions&gt;
</pre>
<p>The default file is located at <em>${PREFIX}/lib/yaws/priv/mime.types</em>. You should not edit this file because it may be replaced when you upgrade your server.</p>
  </dd>
  <dt>
    <p><strong>add_types = ListOfTypes</strong></p>
  </dt>
  <dd>
    <p>Specifies one or more mappings between MIME types and file extensions. More than one extension can be assigned to a MIME type. <em>ListOfTypes</em> is defined as follows:</p>
<pre>
  add_types = &lt;MimeType1, Ext&gt; &lt;MimeType2, Ext1 Ext2 ...&gt; ...
</pre>
<p>The mappings defined using this directive will overload all other definitions. If a file extension is defined several times, only the last one is kept. Multiple <strong>add_types</strong> directives may be used.</p>
  </dd>
  <dt>
    <p><strong>add_charsets = ListOfCharsets</strong></p>
  </dt>
  <dd>
    <p>Specifies one or more mappings between charsets and file extensions. More than one extension can be assigned to a charset. <em>ListOfCharsets</em> is defined as follows:</p>
<pre>
  add_charsets = &lt;Charset1, Ext&gt; &lt;Charset2, Ext1 Ext2 ...&gt; ...
</pre>
<p>The mappings defined using this directive will overload all other definitions. If a file extension is defined several times, only the last one is kept. Multiple <strong>add_charsets</strong> directives may be used.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SERVER PART</h2>
        <div class="sectioncontent">
<p>Yaws can virthost several web servers on the same IP address as well as several web servers on different IP addresses. This includes SSL servers.</p><p>Each virtual host is defined within a matching pair of <strong>&lt;server ServerName&gt;</strong> and <strong>&lt;/server&gt;</strong>. The ServerName will be the name of the webserver.</p><p>The following directives are allowed inside a server definition.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>port = Port</strong></p>
  </dt>
  <dd>
    <p>This makes the server listen on Port. Default is <em>8000</em>.</p>
  </dd>
  <dt>
    <p><strong>listen = IpAddress</strong></p>
  </dt>
  <dd>
    <p>This makes the server listen on IpAddress.  When virthosting several servers on the same ip/port address, if the browser doesn't send a Host: field, Yaws will pick the <em>first</em> server specified in the config file.  If the specified IP address is 0.0.0.0 Yaws will listen on all local IP addresses on the specified port. Default is <em>127.0.0.1</em>.  Multiple <strong>listen</strong> directives may be used to specify several addresses to listen on.</p>
  </dd>
  <dt>
    <p><strong>listen_backlog = Integer</strong></p>
  </dt>
  <dd>
    <p>This sets the TCP listen backlog for the server to define the maximum length the queue of pending connections may grow to. The default is 1024.</p>
  </dd>
  <dt>
    <p><strong>&lt;listen_opts&gt; ... &lt;/listen_opts&gt;</strong></p>
  </dt>
  <dd>
    <p>Defines extra options to be set on the listen socket and, by inheritance, on accepted sockets. See <em>inet:setopts/2</em> for details. Supported options are:</p><p><strong>buffer = Integer</strong> (default: same as <em>inet:setopts/2</em>)</p><p><strong>delay_send = true  | false </strong> (default: same as <em>inet:setopts/2</em>)</p><p><strong>linger = Integer | false </strong> (default: same as <em>inet:setopts/2</em>)</p><p><strong>nodelay = true | false </strong> (default: same as <em>inet:setopts/2</em>)</p><p><strong>priority = Integer</strong> (default: same as <em>inet:setopts/2</em>)</p><p><strong>sndbuf = Integer</strong> (default: same as <em>inet:setopts/2</em>)</p><p><strong>recbuf = Integer</strong> (default: 8196)</p><p><strong>send_timeout = Integer | infinity</strong> (default: same as <em>inet:setopts/2</em>)</p><p><strong>send_timeout_close = true | false </strong> (default: same as <em>inet:setopts/2</em>)</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p><strong>server_signature = String</strong></p>
  </dt>
  <dd>
    <p>This directive sets the "Server: " output header to the custom value and overloads the global one for this virtual server.</p>
  </dd>
  <dt>
    <p><strong>rhost = Host[:Port]</strong></p>
  </dt>
  <dd>
    <p>This forces all local redirects issued by the server to go to Host.  This is useful when Yaws listens to a port which is different from the port that the user connects to. For example, running Yaws as a non-privileged user makes it impossible to listen to port 80, since that port can only be opened by a privileged user. Instead Yaws listens to a high port number port, 8000, and iptables are used to redirect traffic to port 80 to port 8000 (most NAT:ing firewalls will also do this for you).</p>
  </dd>
  <dt>
    <p><strong>rscheme = http | https</strong></p>
  </dt>
  <dd>
    <p>This forces all local redirects issued by the server to use this method. This is useful when an SSL off-loader, or stunnel, is used in front of Yaws.</p>
  </dd>
  <dt>
    <p><strong>auth_log  = true | false</strong></p>
  </dt>
  <dd>
    <p>Enable or disable the auth log for this virtual server. Default is <em>true</em>.</p>
  </dd>
  <dt>
    <p><strong>access_log = true | false</strong></p>
  </dt>
  <dd>
    <p>Setting this directive to false turns of traffic logging for this virtual server. The default value is <em>true</em>.</p>
  </dd>
  <dt>
    <p><strong>logger_mod = Module</strong></p>
  </dt>
  <dd>
    <p>It is possible to set a special module that handles access and auth logging. The default is to log all web server traffic to &lt;Host&gt;.access and &lt;Host&gt;.auth files in the configured or default logdir.</p><p>This module must implement the behaviour <em>yaws_logger</em>. Default value is <em>yaws_log</em>.</p><p>The following functions should be exported:</p><p><strong>Module:open_log(ServerName, Type, LogDir)</strong></p><p>When Yaws is started, this function is called for this virtual server. If the initialization is successful, the function must return <em>{true,State}</em> and if an error occurred, it must return <em>false</em>.</p><ul>
<li><p><strong>Module:close_log(ServerName, Type, State)</strong></p><p>This function is called for this virtual server when Yaws is stopped.</p></li><li><p><strong>Module:wrap_log(ServerName, Type, State, LogWrapSize)</strong></p><p>This function is used to rotate log files. It is regularly called by Yaws and must return the possibly updated internal NewState.</p></li><li><p><strong>Module:write_log(ServerName, Type, State, Infos)</strong></p><p>When it needs to log a message, Yaws will call this function. The parameter Infos is <em>{Ip,Req,InHdrs,OutHdrs,Time}</em> for an access log and <em>{Ip,Path,Item}</em> for an auth log, where:</p><p><strong>Ip</strong> - IP address of the accessing client (as a tuple).</p><p><strong>Req</strong> - the HTTP method, URI path, and HTTP version of the request (as a #http_request{} record).</p><p><strong>InHdrs</strong> - the HTTP headers which were received from the WWW client (as a #headers{} record).</p><p><strong>OutHdrs</strong> - the HTTP headers sent to the WWW client (as a #outh{} record)</p><p><strong>Path</strong> - the URI path of the request (as a string).</p><p><strong>Item</strong> - the result of an authentication request. May be <em>{ok,User}</em>, <em>403</em> or <em>{401,Realm}</em>.</p><p><strong>Time</strong> - The time taken to serve the request, in microseconds.</p></li><li><p>For all of these callbacks, <strong>ServerName</strong> is the virtual server's name, <em>Type</em> is the atom access or auth and <em>State</em> is the internal state of the logger.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>shaper = Module</strong></p>
  </dt>
  <dd>
    <p>Defines a module to control access to this virtual server. Access can be controlled based on the IP address of the client. It is also possible to throttles HTTP requests based on the client's download rate. This module must implement the behaviour <em>yaws_shaper</em>.</p><p>There is no such module configured by default.</p>
  </dd>
  <dt>
    <p><strong>dir_listings = true | true_nozip | false</strong></p>
  </dt>
  <dd>
    <p>Setting this directive to false disallows the automatic dir listing feature of Yaws. A status code 403 Forbidden will be sent.  Set to true_nozip to avoid the auto-generated all.zip entries. Default is <em>false</em>.</p>
  </dd>
  <dt>
    <p><strong>extra_cgi_vars = .....</strong></p>
  </dt>
  <dd>
    <p>Add additional CGI or FastCGI variables. For example:</p>
<pre>
  &lt;extra_cgi_vars dir='/path/to/some/scripts'&gt;
    var = val
    ...
  &lt;/extra_cgi_vars&gt;
</pre>

  </dd>
  <dt>
    <p><strong>statistics  = true | false</strong></p>
  </dt>
  <dd>
    <p>Turns on/off statistics gathering for a virtual server. Default is <em>false</em>.</p>
  </dd>
  <dt>
    <p><strong>fcgi_app_server = Host:Port</strong></p>
  </dt>
  <dd>
    <p>The hostname and TCP port number of a FastCGI application server. The TCP port number is not optional. There is no default value.</p>
  </dd>
  <dt>
    <p><strong>fcgi_trace_protocol = true | false</strong></p>
  </dt>
  <dd>
    <p>Enable or disable tracing of FastCGI protocol messages as info log messages. Disabled by default.</p>
  </dd>
  <dt>
    <p><strong>fcgi_log_app_error = true | false</strong></p>
  </dt>
  <dd>
    <p>Enable or disable logging of application error messages (output to stderr and non-zero exit value). Disabled by default.</p>
  </dd>
  <dt>
    <p><strong>deflate = true | false</strong></p>
  </dt>
  <dd>
    <p>Turns on or off deflate compression for a server. Default is <em>false</em>.</p>
  </dd>
  <dt>
    <p><strong>&lt;deflate&gt; ... &lt;/deflate&gt;</strong></p>
  </dt>
  <dd>
    <p>This begins and ends the deflate compression configuration for this server. The following items are allowed within a matching pair of &lt;deflate&gt; and &lt;/deflate&gt; delimiters.</p><p><strong>min_compress_size = nolimit | Integer</strong></p><p>Defines the smallest response size that will be compressed. If nolimit is not used, the specified value must be strictly positive. The default value is <em>nolimit</em>.</p><ul>
<li><p><strong>compress_level = none | default | best_compression | best_speed | 0..9</strong></p><p>Defines the compression level to be used. 0 (none), gives no compression at all, 1 (best_speed) gives best speed and 9 (best_compression) gives best compression. The default value is <em>default</em>.</p></li><li><p><strong>window_size = 9..15</strong></p><p>Specifies the zlib compression window size. It should be in the range 9 through 15. Larger values of this parameter result in better compression at the expense of memory usage. The default value is <em>15</em>.</p></li><li><p><strong>mem_level = 1..9</strong></p><p>Specifies how much memory should be allocated for the internal compression state. <em>mem_level=1</em> uses minimum memory but is slow and reduces compression ratio; <em>mem_level=9</em> uses maximum memory for optimal speed. The default value is <em>8</em>.</p></li><li><p><strong>strategy = default | filtered | huffman_only</strong></p><p>This parameter is used to tune the compression algorithm. See <strong>zlib(3erl)</strong> for more details on the <em>strategy</em> parameter. The default value is <em>default</em>.</p></li><li><p><strong>use_gzip_static = true | false</strong></p><p>If true, Yaws will try to serve precompressed versions of static files. It will look for precompressed files in the same location as original files that end in ".gz". Only files that do not fit in the cache are concerned. The default value is <em>false</em>.</p></li><li><p><strong>mime_types = ListOfTypes | defaults | all</strong></p><p>Restricts the deflate compression to particular MIME types. The special value <em>all</em> enable it for all types (It is a synonym of `*/*'). MIME types into <em>ListOfTypes</em> must have the form `type/subtype' or `type/*' (indicating all subtypes of that type). Here is an example:</p>
<pre>
  mime_types = default image/*
  mime_types = application/xml application/xhtml+xml application/rss+xml
</pre>
<p>By default, following MIME types are compressed (if <strong>deflate</strong> is set to true): <em>text/*, application/rtf, application/msword,</em> application/pdf, application/x-dvi, application/javascript, application/x-javascript. Multiple <strong>mime_types</strong> directive can be used.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>docroot = Directory ...</strong></p>
  </dt>
  <dd>
    <p>This makes the server serve all its content from Directory.</p><p>It is possible to pass a space-separated list of directories as docroot. If this is the case, the various directories will be searched in order for the requested file. This also works with the ssi and yssi constructs where the full list of directories will be searched for files to ssi/yssi include. Multiple docroot directives can be used.  You need at least one valid docroot, invalid docroots are skipped with their associated auth structures.</p>
  </dd>
  <dt>
    <p><strong>auth_skip_docroot = true | false</strong></p>
  </dt>
  <dd>
    <p>If true, the docroot will not be searched for <em>.yaws_auth</em> files. This is useful when the docroot is quite large and the time to search it is prohibitive when Yaws starts up. Defaults to <em>false</em>.</p>
  </dd>
  <dt>
    <p><strong>partial_post_size = Integer | nolimit</strong></p>
  </dt>
  <dd>
    <p>When a Yaws file receives large POSTs, the amount of data received in each chunk is determined by the this parameter.  The default value is <em>10240</em>. Setting it to nolimit is potentially dangerous.</p>
  </dd>
  <dt>
    <p><strong>dav = true | false</strong></p>
  </dt>
  <dd>
    <p>Turns on the DAV protocol for this server. The dav support in Yaws is highly limited. If dav is turned on, .yaws processing of .yaws pages is turned off. Default is <em>false</em>. The socket read timeout is supplied by the keepalive_timeout setting.  If the read is not done within the timeout, the POST will fail.</p>
  </dd>
  <dt>
    <p><strong>tilde_expand = true|false</strong></p>
  </dt>
  <dd>
    <p>If this value is set to false Yaws will never do tilde expansion. The default is <em>false</em>. tilde_expansion is the mechanism whereby a URL on the form http://www.foo.com/~username is changed into a request where the docroot for that particular request is set to the directory ~username/public_html/.</p>
  </dd>
  <dt>
    <p><strong>allowed_scripts = ListOfSuffixes</strong></p>
  </dt>
  <dd>
    <p>The allowed script types for this server.  Recognized are `yaws', `cgi', `fcgi', `php'.  Default is <em>allowed_scripts = yaws php cgi fcgi</em>.</p><p>Note: for fcgi scripts, the FastCGI application server is only called if a local file with the .fcgi extension exists. However, the contents of the local .fcgi file are ignored.</p>
  </dd>
  <dt>
    <p><strong>tilde_allowed_scripts = ListOfSuffixes</strong></p>
  </dt>
  <dd>
    <p>The allowed script types for this server when executing files in a users public_html folder Recognized are `yaws', `cgi', `fcgi', `php'.  Default is <em>tilde_allowed_scripts =</em> i.e. empty</p>
  </dd>
  <dt>
    <p><strong>index_files = ListOfResources</strong></p>
  </dt>
  <dd>
    <p>This directive sets the list of resources to look for, when a directory is requested by the client. If the last entry begins with a `/', and none of the earlier resources are found, Yaws will perform a redirect to this uri. Default is <em>index_files = index.yaws index.html index.php</em>.</p>
  </dd>
  <dt>
    <p><strong>appmods = ListOfModuleNames</strong></p>
  </dt>
  <dd>
    <p>If any the names in ListOfModuleNames appear as components in the path for a request, the path request parsing will terminate and that module will be called. There is also an alternate syntax for specifying the appmods if we don't want our internal erlang module names to be exposed in the URL paths.  We can specify</p>
<pre>
  appmods = &lt;Path1, Module1&gt; &lt;Path2, Modules2&gt; ...
</pre>
<p>Assume for example that we have the URL http://www.hyber.org/myapp/foo/bar/baz?user=joe while we have the module foo defined as an appmod, the function foo:out(Arg) will be invoked instead of searching the filesystems below the point foo.</p><p>The Arg argument will have the missing path part supplied in its appmoddata field.</p><p>It is also possible to exclude certain directories from appmod processing. This is particulaly interesting for '/' appmods.  Here is an example:</p>
<pre>
  appmods = &lt;/, myapp exclude_paths icons js top/static&gt;
</pre>
<p>The above configuration will invoke the 'myapp' erlang module on everything except any file found in directories, 'icons', 'js' and 'top/static' relative to the docroot.</p>
  </dd>
  <dt>
    <p><strong>dispatchmod = DispatchModule</strong></p>
  </dt>
  <dd>
    <p>Set <em>DispatchModule</em> as a server-specific request dispatching module. Yaws expects <em>DispatchModule</em> to export a <em>dispatch/1</em> function. When it receives a request, Yaws passes an <em>#arg{}</em> record to the dispatch module's <em>dispatch/1</em> function, which returns one of the following atom results:</p><p><strong>done</strong> - this indicates the dispatch module handled the request itself and already sent the response, and Yaws should resume watching for new requests on the connection</p><p><strong>closed</strong> - same as <em>done</em> but the <em>DispatchModule</em> also closed the connection</p><p><strong>continue</strong> - the dispatch module has decided not to handle the request, and instead wants Yaws to perform its regular request dispatching</p><ul>
<li><p>Note that when <em>DispatchModule</em> handles a request itself, Yaws does not support tracing, increment statistics counters or allow traffic shaping for that request. It does however still keep track of maximum keepalive uses on the connection.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>errormod_404 = Module</strong></p>
  </dt>
  <dd>
    <p>It is possible to set a special module that handles 404 Not Found messages. The function <em>Module:out404(Arg, GC, SC)</em> will be invoked. The arguments are</p><p><strong>Arg</strong> - a #arg{} record</p><p><strong>GC</strong> - a #gconf{} record (defined in yaws.hrl)</p><p><strong>SC</strong> - a #sconf{} record (defined in yaws.hrl)</p><ul>
<li><p>The function can and must do the same things that a normal <em>out/1</em> does.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>errormod_401 = Module</strong></p>
  </dt>
  <dd>
    <p>It is possible to set a special module that handles 401 Unauthorized messages. This can for example be used to display a login page instead. The function <em>Module:out401(Arg, Auth, Realm)</em> will be invoked. The arguments are</p><p><strong>Arg</strong> - a #arg{} record</p><p><strong>Auth</strong> - a #auth{} record</p><p><strong>Realm</strong> - a string</p><ul>
<li><p>The function can and must do the same things that a normal <em>out/1</em> does.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>errormod_crash = Module</strong></p>
  </dt>
  <dd>
    <p>It is possible to set a special module that handles the HTML generation of server crash messages. The default is to display the entire formated crash message in the browser. This is good for debugging but not in production.</p><p>The function <em>Module:crashmsg(Arg, SC, Str)</em> will be called. The <em>Str</em> is the real crash message formated as a string.</p><p>The function must return, <em>{content,MimeType,Cont}</em> or <em>{html, Str}</em> or <em>{ehtml, Term}</em>. That data will be shipped to the client.</p>
  </dd>
  <dt>
    <p><strong>expires = ListOfExpires</strong></p>
  </dt>
  <dd>
    <p>Controls the setting of the <em>Expires</em> HTTP header and the <em>max-age</em> directive of the <em>Cache-Control</em> HTTP header in server responses for specific MIME types. The expiration date can set to be relative to either the time the source file was last modified, or to the time of the client access. ListOfExpires is defined as follows:</p>
<pre>
  expires = &lt;MimeType1, access+Seconds&gt; &lt;MimeType2, modify+Seconds&gt; ...
</pre>
<p>These HTTP headers are an instruction to the client about the document's validity and persistence. If cached, the document may be fetched from the cache rather than from the source until this time has passed. After that, the cache copy is considered "expired" and invalid, and a new copy must be obtained from the source. Here is an example:</p>
<pre>
  expires = &lt;image/gif, access+2592000&gt; &lt;image/png, access+2592000&gt;
  expires = &lt;image/jpeg, access+2592000&gt; &lt;text/css, access+2592000&gt;
</pre>

  </dd>
  <dt>
    <p><strong>arg_rewrite_mod = Module</strong></p>
  </dt>
  <dd>
    <p>It is possible to install a module that rewrites all the Arg #arg{} records at an early stage in the Yaws server.  This can be used to do various things such as checking a cookie, rewriting paths etc.</p><p>The module <em>yaws_vdir</em> can be used in case you want to serve static content that is not located in your docroot. See the example at the bottom of this man page for how to use the <em>opaque</em> + <em>vdir</em> elements to instruct the <em>yaws_vdir</em> module what paths to rewrite.</p>
  </dd>
  <dt>
    <p><strong>start_mod = Module</strong></p>
  </dt>
  <dd>
    <p>Defines a user provided callback module.  At startup of the server, Module:start/1 will be called.  The #sconf{} record (defined in yaws.hrl) will be used as the input argument. This makes it possible for a user application to synchronize the startup with the Yaws server as well as getting hold of user specific configuration data, see the explanation for the &lt;opaque&gt; context.</p>
  </dd>
  <dt>
    <p><strong>revproxy = Prefix Url [intercept_mod Module]</strong></p>
  </dt>
  <dd>
    <p>Make Yaws a reverse proxy. <em>Prefix</em> is a path inside our own docroot and <em>Url</em><strong> argument is a URL pointing to a website we want to "mount"</strong> under the <em>Prefix</em> path. This example:</p>
<pre>
  revproxy = /tmp/foo http://yaws.hyber.org
</pre>
<p>makes the hyber website appear under <em>/tmp/foo</em>.</p><p>It is possible to have multiple reverse proxies inside the same server.</p><p>You can optionally configure an interception module for each reverse proxy, allowing your application to examine and modify requests and HTTP headers as they pass through the proxy from client to backend server and also examine and modify responses and HTTP headers as they return from the backend server through the proxy to the client.</p><p>You specify an interception module by including the optional <em>intercept_mod</em> keyword followed by <em>Module</em>, which should be the name of your interception module.</p><p>An interception module is expected to export two functions: <em>rewrite_request/2</em> and <em>rewrite_response/2</em>. The two arguments passed to <em>rewrite_request/2</em> function are a <em>#http_request{}</em> record and a <em>#headers{}</em> record, whereas <em>rewrite_response/2</em> function takes a <em>#http_response{}</em> record and also a <em>#headers{}</em> record. You can find definitions for these record types in the <em>yaws_api.hrl</em> header file. Each function can examine each record instance and can either return each original instance or can return a modified copy of each instance in its response. The <em>rewrite_request/2</em> function should return a tuple of the following form:</p>
<pre>
  <em>{ok, #http_request{}, #headers{}}</em>
</pre>
<p>and the <em>rewrite_response/2</em> function should similarly return a tuple of the following form:</p>
<pre>
  <em>{ok, #http_response{}, #headers{}}</em>
</pre>
<p>A <em>#headers{}</em> record can easily be manipulated in an interceptor using the functions listed below:</p>
<pre>
  <em>yaws_api:set_header/2</em>, <em>yaws_api:set_header/3</em>
  <em>yaws_api:get_header/2</em>, <em>yaws_api:get_header/3</em>
  <em>yaws_api:delete_header/2</em>
</pre>
<p>Any failures in your interception module's functions will result in HTTP status code 500, indicating an internal server error.</p>
  </dd>
  <dt>
    <p><strong>fwdproxy = true|false</strong></p>
  </dt>
  <dd>
    <p>Make Yaws a forward proxy. By enabling this option you can use Yaws as a proxy for outgoing web traffic, typically by configuring the proxy settings in a web-browser to explicitly target Yaws as its proxy server.</p>
  </dd>
  <dt>
    <p><strong>servername = Name</strong></p>
  </dt>
  <dd>
    <p>If we're virthosting several servers and want to force a server to match specific Host: headers we can do this with the "servername" directive. This name doesn't necessarily have to be the same as the the name inside &lt;server Name&gt; in certain NAT scenarios. Rarely used feature.</p>
  </dd>
  <dt>
    <p><strong>serveralias = ListOfNames</strong></p>
  </dt>
  <dd>
    <p>This directive sets the alternate names for a virtual host. A server alias may contain wildcards:</p><p> '*' matches any sequence of zero or more characters  '?' matches one character unless that character is a period ('.')</p><ul>
<li><p>Multiple <strong>serveralias</strong> directives may be used. Here is an example:</p>
<pre>
  &lt;server server.domain.com&gt;
    serveralias = server server2.domain.com server2
    serveralias = *.server.domain.com *.server?.domain.com
    ...
  &lt;/server&gt;
</pre>
</li>
</ul>
  </dd>
  <dt>
    <p><strong>php_handler = &lt;Type, Spec&gt;</strong></p>
  </dt>
  <dd>
    <p>Set handler to interpret .php files. It can be one of the following definitions:</p><p><strong>php_handler = &lt;cgi, Filename&gt;</strong> - The name of (and possibly path to) the php executable used to interpret php scripts (if allowed).</p><p><strong>php_handler = &lt;fcgi, Host:Port&gt;</strong> - Use the specified fastcgi server to interpret .php files (if allowed).</p><p>Yaws does not start the PHP interpreter in fastcgi mode for you. To run PHP in fastcgi mode, call it with the -b option. For example:</p>
<pre>
  php5-cgi -b '127.0.0.1:54321'
</pre>
<p>This starts a php5 in fastcgi mode listening on the local network interface. To make use of this PHP server from Yaws, specify:</p>
<pre>
  php_handler = &lt;fcgi, 127.0.0.1:54321&gt;
</pre>
<p>The PHP interpreter needs read access to the files it is to serve. Thus, if you run it in a different security context than Yaws itself, make sure it has access to the .php files.</p><p>Please note that anyone who is able to connect to the php fastcgi server directly can use it to read any file to which it has read access. You should consider this when setting up a system with several mutually untrusted instances of php.</p><ul>
<li><p><strong>php_handler = &lt;extern, Module:Function | Node:Module:Function&gt;</strong> - Use an external handler, possibly on another node, to interpret .php files (if allowed).</p><p>To interpret a .php file, the function <em>Module:Function(Arg)</em> will be invoked (Evaluated inside a rpc call if a <em>Node</em> is specified), where Arg is a #arg{} record.</p><p>The function must do the same things that a normal out/1 does.</p></li><li><p>Default value is <em>&lt;cgi, "/usr/bin/php-cgi"&gt;</em>.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>phpfcgi = Host:Port</strong></p>
  </dt>
  <dd>
    <p><strong>this target is deprecated. use 'php_handler' target in server part</strong> instead.</p><p>Use this directive is same as: php_handler = &lt;fcgi, Host:Port&gt;.</p>
  </dd>
  <dt>
    <p><strong>default_type = MimeType</strong></p>
  </dt>
  <dd>
    <p>Overloads the global <strong>default_type</strong> value for this virtual server.</p>
  </dd>
  <dt>
    <p><strong>default_charset = Charset</strong></p>
  </dt>
  <dd>
    <p>Overloads the global <strong>default_charset</strong> value for this virtual server.</p>
  </dd>
  <dt>
    <p><strong>mime_types_file = File</strong></p>
  </dt>
  <dd>
    <p>Overloads the global <strong>mime_type_file</strong> value for this virtual server. Mappings defined in <em>File</em> will not overload those defined by <strong>add_types</strong> directives in the global part.</p>
  </dd>
  <dt>
    <p><strong>add_types = ListOfTypes</strong></p>
  </dt>
  <dd>
    <p>Overloads the global <strong>add_types</strong> values for this virtual server. If a mapping is defined in the global part and redefined in a server part using this directive, then it is replaced. Else it is kept.</p>
  </dd>
  <dt>
    <p><strong>add_charsets = ListOfCharsets</strong></p>
  </dt>
  <dd>
    <p>Overloads the global <strong>add_charsets</strong> values for this virtual server. If a mapping is defined in the global part and redefined in a server part using this directive, then it is replaced. Else it is kept.</p>
  </dd>
  <dt>
    <p><strong>&lt;ssl&gt; ... &lt;/ssl&gt;</strong></p>
  </dt>
  <dd>
    <p>This begins and ends an SSL configuration for this server.  It's possible to virthost several SSL servers on the same IP given that they all share the same certificate configuration.  In general it is complicated to virthost several SSL servers on the same IP address since the certificate is typically bound to a domainname in the common name part of the certificate.  One solution (the only?) to this problem is to have a certificate with multiple subjectAltNames. See http://wiki.cacert.org/VhostTaskForce#Interoperability_Test</p><p><strong>keyfile = File</strong></p><p>Specifies which file contains the private key for the certificate. If not specified then the certificate file will be used.</p><ul>
<li><p><strong>certfile = File</strong></p><p>Specifies which file contains the certificate for the server.</p></li><li><p><strong>cacertfile = File</strong></p><p>A file containing trusted certificates to use during client authentication and to use when attempting to build the server certificate chain.  The list is also used in the list of acceptable client CAs passed to the client when a certificate is requested.</p></li><li><p><strong>verify = 0 | 1 | 2 | verify_none | verify_peer</strong></p><p>Specifies the level of verification the server does on client certs.  0 means that the server will not ask for a cert (verify_none), 1 means that the server will ask the client for a cert but not fail if the client does not supply a client cert (verify_peer, fail_if_no_peer_cert = false), 2 means that the server requires the client to supply a client cert (verify_peer, fail_if_no_peer_cert = true).</p><p>Setting verify_none means that the x509 validation will be skipped (no certificate request is sent to the client), verify_peer means that a certificate request is sent to the client (x509 validation is performed.</p><p>You might want to use fail_if_no_peer_cert in combination with verify_peer.</p></li><li><p><strong>fail_if_no_peer_cert = true | false</strong></p><p>If verify is set to verify_peer and set to true the connection will fail if the client does not send a certificate (i.e. an empty certificate). If set to false the server will fail only if an invalid certificate is supplied (an empty certificate is considered valid).</p></li><li><p><strong>depth = Int</strong></p><p>Specifies the depth of certificate chains the server is prepared to follow when verifying client certs. For the OTP new SSL implementation it is also used to specify how far the server, i.e. we, shall follow the SSL certificates we present to the clients. Hence, using self-signed certs, we typically need to set this to 0.</p></li><li><p><strong>password = String</strong></p><p>String If the private key is encrypted on disc, this password is the 3Dee key to decrypt it.</p></li><li><p><strong>ciphers = String</strong></p><p>This string specifies the SSL cipher string. The syntax of the SSL cipher string is  an erlang term compliant with the output of ssl:cipher_suites().</p>
<pre>
ciphers = "[{dhe_rsa,aes_256_cbc,sha}, &#92;
            {dhe_dss,aes_256_cbc,sha}]"
</pre>
</li>
</ul>
  </dd>
  <dt>
    <p><strong>&lt;redirect&gt; ... &lt;/redirect&gt;</strong></p>
  </dt>
  <dd>
    <p>Defines a redirect mapping. The following items are allowed within a matching pair of &lt;redirect&gt; and &lt;/redirect&gt; delimiters.</p><p>We can have a series of redirect rules in one of formats below:</p>
<pre>
  Path = URL
  Path = code
  Path = code URL
</pre>
<p><strong>Path</strong> must be an url-decoded path beginning with a slash. <strong>URL</strong> may be either a relative URL (a path beginning with a slash), or an absolute URL. In the first case, the <em>scheme:hostname:port</em> of the current server will be added. All accesses to <strong>Path</strong> will be redirected to <strong>URL/Path</strong> (or <strong>scheme:hostname:port/URL/Path</strong> if <strong>URL</strong> is relative). <strong>URL</strong> must be url-encoded. Note that the original path is appended to the redirected URL.</p><p>For example, assume we have the following redirect configuration:</p>
<pre>
  &lt;redirect&gt;
    /foo = http://www.mysite.org/zapp
    /bar = /tomato.html
  &lt;/redirect&gt;
</pre>
<p>Assuming this config resides on a site called http://abc.com, we have the following redirects:</p>
<pre>
  http://abc.com/foo -&gt; http://www.mysite.org/zapp/foo
  http://abc.com/foo/test -&gt; http://www.mysite.org/zapp/foo/test
  http://abc.com/bar -&gt; http://abc.com/tomato.html/bar
  http://abc.com/bar/x/y/z -&gt; http://abc.com/tomato.html/bar/x/y/z
</pre>
<p>By default, Yaws will perform a 302 redirect. The HTTP status code can be changed using the <strong>code</strong> parameter. Note that the status code must be known by Yaws.</p>
<dl class='dl-vertical'>
  <dt>
    \[bu]
  </dt>
  <dd>
    <p>For 3xx status codes, the <strong>URL</strong> parameter must be present and will be used to build the new location.</p>
  </dd>
  <dt>
    \[bu]
  </dt>
  <dd>
    <p>For other status codes (1xx, 2xx, 4xx and 5xx), it can be omitted. In the absence of <strong>URL</strong>, Yaws will return a generic response with the specified status code.</p>
  </dd>
  <dt>
    \[bu]
  </dt>
  <dd>
    <p>Otherwise, the <strong>URL</strong> parameter must be a relative URL and will be used to customize the response.</p>
  </dd>

</dl>
<p>Sometimes we do not want to have the original path appended to the redirected path. To get that behaviour we specify the config with '==' instead of '='.</p>
<pre>
  &lt;redirect&gt;
    /foo == http://www.mysite.org/zapp
    /bar = /tomato.html
  &lt;/redirect&gt;
</pre>
<p>Now a request for http://abc.com/foo/x/y/z simply gets redirected to http://www.mysite.org/zapp. This is typically used when we simply want a static redirect at some place in the docroot.</p><p>When we specify a relative URL as the target for the redirect, the redirect will be to the current http(s) server.</p>
  </dd>
  <dt>
    <p><strong>&lt;auth&gt; ... &lt;/auth&gt;</strong></p>
  </dt>
  <dd>
    <p>Defines an auth structure. The following items are allowed within a matching pair of &lt;auth&gt; and &lt;/auth&gt; delimiters.</p><p><strong>docroot = Docroot </strong></p><p>If a docroot is defined, this auth structure will be tested only for requests in the specified docroot. No docroot configured means all docroots.  If two auth structures are defined, one with a docroot and one with no docroot, the first of both overrides the second one for requests in the configured docroot.</p><ul>
<li><p><strong>dir = Dir</strong></p><p>Makes Dir to be controlled by WWW-authenticate headers. In order for a user to have access to WWW-Authenticate controlled directory, the user must supply a password. The Dir must be specified relative to the docroot.  Multiple dir can be used. If no dir is set, the default value, <em>"/"</em>, will be used.</p></li><li><p><strong>realm = Realm</strong></p><p>In the directory defined here, the WWW-Authenticate Realm is set to this value.</p></li><li><p><strong>authmod = AuthMod</strong></p><p>If an auth module is defined then AuthMod:auth(Arg, Auth) will be called for all access to the directory. The auth/2 function should return one of: true, false, {false, Realm}, {appmod, Mod}.  If {appmod, Mod} is returned then a call to Mod:out401(Arg, Auth, Realm) will be used to deliver the content. If errormod_401 is defined, the call to Mod will be ignored. (Mod:out(Arg) is deprecated).</p><p>This can, for example, be used to implement cookie authentication.  The auth() callback would check if a valid cookie header is present, if not it would return {appmod, ?MODULE} and the out401/1 function in the same module would return {redirect_local, "/login.html"}.</p></li><li><p><strong>user = User:Password</strong></p><p>Inside this directory, the user User has access if the user supplies the password Password in the popup dialogue presented by the browser.  We can obviously have several of these value inside a single &lt;auth&gt; &lt;/auth&gt; pair.</p><p>The usage of User:Password in the actual config file is deprecated as of release 1.51. It is preferred to have the users in a file called <em>.yaws_auth</em> in the actual directory. The .yaws_auth file has to be file parseable by <em>file:consult/1</em></p><p>Each row of the file must contain terms on the form</p>
<pre>
    {User, Password}.
</pre>
<p>Where both User and Password should be strings. The .yaws_auth file mechanism is recursive. Thus any subdirectories to Dir are automatically also protected.</p><p>The .yaws_auth file is never visible in a dir listing</p></li><li><p><strong>pam service = </strong><em>pam-service</em></p><p>If the item <strong>pam</strong> is part of the auth structure, Yaws will also try to authenticate the user using "pam" using the pam <em>service</em> indicated. Usual services are typically found under /etc/pam.d. Usual values are "system-auth" etc.</p><p>pam authentication is performed by an Erlang port program which is typically installed as suid root by the Yaws install script.</p></li><li><p><strong>allow = all | ListOfHost</strong></p><p>The <em>allow</em> directive affects which hosts can access an area of the server. Access can be controlled by IP address or IP address range. If all is specified, then all hosts are allowed access, subject to the configuration of the <em>deny</em> and <em>order</em> directives. To allow only particular hosts or groups of hosts to access the server, the host can be specified in any of the following formats:</p><p><strong>A full IP address</strong></p>
<pre>
  allow = 10.1.2.3
  allow = 192.168.1.104, 192.168.1.205
</pre>
<p><strong>A network/netmask pair</strong></p>
<pre>
  allow = 10.1.0.0/255.255.0.0
</pre>
<p><strong>A network/nnn CIDR specification</strong></p>
<pre>
  allow = 10.1.0.0/16
</pre>
</li><li><p><strong>deny = all | ListOfHost</strong></p><p>This directive allows access to the server to be restricted based on IP address. The arguments for the <em>deny</em> directive are identical to the arguments for the <em>allow</em> directive.</p></li><li><p><strong>order = Ordering</strong></p><p>The <em>order</em> directive, along with <em>allow</em> and <em>deny</em> directives, controls a three-pass access control system. The first pass processes either all <em>allow</em> or all <em>deny</em> directives, as specified by the <em>order</em> directive. The second pass parses the rest of the directives (<em>deny</em> or <em>allow</em>). The third pass applies to all requests which do not match either of the first two.</p><p>Ordering is one of (Default value is <em>deny,allow</em>):</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>allow,deny</strong></p>
  </dt>
  <dd>
    <p>First, all <em>allow</em> directives are evaluated; at least one must match, or the request is rejected. Next, <em>deny</em> directives are evaluated. If any matches, the request is rejected. Last, any requests which do not match an <em>allow</em> or a <em>deny</em> directive are denied by default.</p>
  </dd>
  <dt>
    <p><strong>deny,allow</strong></p>
  </dt>
  <dd>
    <p>First, all <em>deny</em> directives are evaluated; if any matched, the request is denied unless it also matches an <em>allow</em> directive. Any requests which do not match any <em>allow</em> or <em>deny</em> directives are permitted.</p>
  </dd>

</dl>
</li>
</ul>
  </dd>
  <dt>
    <p><strong>&lt;opaque&gt; ... &lt;/opaque&gt;</strong></p>
  </dt>
  <dd>
    <p>This begins and ends an opaque configuration context for this server, where 'Key = Value' directives can be specified. These directives are ignored by Yaws (hence the name opaque), but can be accessed as a list of tuples <em>{Key,Value}</em> stored in the #sconf.opaque record entry. See also the description of the <em>start_mod</em> directive.</p><p>This mechanism can be used to pass data from a surrounding application into the individual .yaws pages.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>The following example defines a single server on port 80.</p>
<pre>
    logdir = /var/log/yaws
    &lt;server www.mydomain.org&gt;
        port = 80
        listen = 192.168.128.31
        docroot = /var/yaws/www
    &lt;/server&gt;
</pre>
<p>And this example shows a similar setup but two web servers on the same IP address.</p>
<pre>
    logdir = /var/log/yaws
    &lt;server www.mydomain.org&gt;
        port = 80
        listen = 192.168.128.31
        docroot = /var/yaws/www
    &lt;/server&gt;

    &lt;server www.funky.org&gt;
        port = 80
        listen = 192.168.128.31
        docroot = /var/yaws/www_funky_org
    &lt;/server&gt;
</pre>
<p>An example with www-authenticate and no access logging at all.</p>
<pre>
    logdir = /var/log/yaws
    &lt;server www.mydomain.org&gt;
        port = 80
        listen = 192.168.128.31
        docroot = /var/yaws/www
        access_log = false
        &lt;auth&gt;
            dir = secret/dir1
            realm = foobar
            user = jonny:verysecretpwd
            user = benny:thequestion
            user = ronny:havinganamethatendswithy
       &lt;/auth&gt;
    &lt;/server&gt;
</pre>
<p>An example specifying a user defined module to be called at startup, as well as some user specific configuration.</p>
<pre>
    &lt;server www.funky.org&gt;
        port = 80
        listen = 192.168.128.31
        docroot = /var/yaws/www_funky_org
        start_mod = btt
        &lt;opaque&gt;
                mydbdir = /tmp
                mylogdir = /tmp/log
        &lt;/opaque&gt;
    &lt;/server&gt;
</pre>
<p>An example specifying the GSSAPI/SPNEGO module (authmod_gssapi) to be used for authentication. This module requires egssapi version 0.1~pre2 or later available at http://www.hem.za.org/egssapi/.</p><p>The Kerberos5 keytab is specified as 'keytab = File' directive in opaque. This keytab should contain the keys of the HTTP service principal, 'HTTP/www.funky.org' in this example.</p>
<pre>
    &lt;server www.funky.org&gt;
        port = 80
        listen = 192.168.128.31
        docroot = /var/yaws/www_funky_org
        start_mod = authmod_gssapi
        &lt;auth&gt;
                authmod = authmod_gssapi
                dir = secret/dir1
        &lt;/auth&gt;
        &lt;opaque&gt;
                keytab = /etc/yaws/http.keytab
        &lt;/opaque&gt;
    &lt;/server&gt;
</pre>
<p>And finally a slightly more complex example with two servers on the same IP, and one SSL server on a different IP.</p><p>When there are more than one server on the same IP, and they have different names the server must be able to choose one of them if the client doesn't send a Host: header. Yaws will choose the first one defined in the conf file.</p>
<pre>
    logdir = /var/log/yaws
    max_num_cached_files = 8000
    max_num_cached_bytes = 6000000

    &lt;server www.mydomain.org&gt;
        port = 80
        listen = 192.168.128.31
        docroot = /var/yaws/www
    &lt;/server&gt;

    &lt;server www.funky.org&gt;
        port = 80
        listen = 192.168.128.31
        docroot = /var/yaws/www_funky_org
    &lt;/server&gt;

    &lt;server www.funky.org&gt;
        port = 443
        listen = 192.168.128.32
        docroot = /var/yaws/www_funky_org
        &lt;ssl&gt;
           keyfile = /etc/funky.key
           certfile = /etc/funky.cert
           password = gazonk
        &lt;/ssl&gt;
    &lt;/server&gt;
</pre>
<p>Finally an example with virtual directories, vdirs.</p>
<pre>
    &lt;server server.domain&gt;
        port = 80
        listen = 192.168.128.31
        docroot = /var/yaws/www
        arg_rewrite_mod = yaws_vdir
        &lt;opaque&gt;
            vdir = "/virtual1/ /usr/local/somewhere/notrelated/to/main/docroot"
            vdir = "/myapp/ /some/other/path can include/spaces"
            vdir = "/icons/  /usr/local/www/yaws/icons"
        &lt;/opaque&gt;
    &lt;/server&gt;
</pre>
<p>The first defined vdir can then be accessed at or under http://server.domain/virtual1/ or http://server.domain/virtual1</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Written by Claes Wikstrom</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO yaws.conf&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man1/yaws.1.html"><strong>yaws</strong>(1)</a> <a href="../man1/erl.1.html"><strong>erl</strong>(1)</a></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="yapet_config.5.html"><span aria-hidden="true">&larr;</span> yapet_config.5: Format of yapet configuration file</a></li>
   <li class="next"><a href="yaws_api.5.html">yaws_api.5: Api available to yaws web server programmers <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

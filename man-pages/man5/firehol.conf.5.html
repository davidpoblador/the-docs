<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>firehol.conf: Configuration file for firehol(1)</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Configuration file for firehol(1)">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="firehol.conf (5) manual">
  <meta name="twitter:description" content="Configuration file for firehol(1)">
  <meta name="twitter:image" content="https://www.carta.tech/images/firehol-firehol.conf-5.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man5/firehol.conf.5.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="firehol.conf (5) manual" />
  <meta property="og:description" content="Configuration file for firehol(1)" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/firehol-firehol.conf-5.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">firehol.conf<small> (5)</small></h1>
        <p class="lead">Configuration file for firehol(1)</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/">
      <span itemprop="name">File formats and conventions</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/firehol.conf.5.html">
      <span itemprop="name">firehol.conf: Configuration file for firehol(1)</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/firehol/">
      <span itemprop="name">firehol</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man5/firehol.conf.5.html">
      <span itemprop="name">firehol.conf: Configuration file for firehol(1)</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><em>firehol.conf</em> is the configuration file for <em>firehol</em>\|(1), which creates an iptables firewall from the simple rules in this file.</p><p>This file is parsed as a <em>bash</em>\|(1) script, so it's no problem to use variables or complex bashisms.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Commands</h2>
        <div class="sectioncontent">
<p><strong>&#92;$1</strong></p><p>The interface command creates a firewall for protecting the host the firewall is running, from the given interface. The default interface policy is drop, so that if no subcommands are given, the firewall will just drop all incoming and outgoing traffic using this interface. <em>Parameters</em></p>
<dl class='dl-vertical'>
  <dt>
    &bull; real interface
  </dt>
  <dd>
    <p>This is the interface name as shown by ip link show. Generally anything iptables accepts, including the pattern character + (the plus sign), is valid. The plus sign after some text will match all interfaces that start with this text. It is allowed to use more than one interfaces separated by spaces, but all of them should be given within one quoted argument. Example:</p><p>interface \*(L"eth0 eth1 ppp0\*(R" myname</p>
  </dd>
  <dt>
    &bull; name
  </dt>
  <dd>
    <p>This is a name for this interface. Generally you should use short names (10 characters max) without spaces or other symbols. You should not use the same name more than once in FireHOL primary commands.</p>
  </dd>
  <dt>
    &bull; optional rule parameters
  </dt>
  <dd>
    <p>This is a set of rules that allow further restriction of the traffic that gets matched for this interface. See section <strong>Optional Rules Parameters</strong> for more information. Examples:</p><p>interface eth0 intranet src 10.0.0.0/16 interface eth0 internet src not \*(L"$UNROUTABLE_IPS\*(R" (note: \s-1UNROUTABLE_IPS\s0 is a variable defined by FireHOL that includes all IPs that should not be routable by the Internet).</p>
  </dd>

</dl>
<p>The router command creates a firewall for the traffic passing through the host running the firewall. The only acceptable policy on all router commands is return and therefore the policy subcommand cannot be used on routers. This means that no packets are dropped in a router. Packets not matched by any router command will be dropped at the end of the firewall. <em>Parameters</em></p>
<dl class='dl-vertical'>
  <dt>
    &bull; name
  </dt>
  <dd>
    <p>This is a name for this router. The same restrictions of interface names apply here too.</p>
  </dd>
  <dt>
    &bull; optional rule parameters
  </dt>
  <dd>
    <p>This is a set of rules that allow further restriction of the traffic that gets matched for this router. See section <strong>Optional Rules Parameters</strong> for more information.</p>
  </dd>

</dl>
<p><em>Description</em></p><p>Router statements produce similar iptables commands the interface statements produce. For each router statement an in_<em>name</em> and an out_<em>name</em> chain are produced to match the traffic in both directions of the router. To match some client or server traffic the administrator has to specify the input/output interface or the source/destination of the request. All inface/outface, src/dst optional rule parameters can be given either on the router statement in which case will be applied to all subcommands for this router, or on each subcommand within a router. Both are valid. For example:</p><p>router mylan inface ppp+ outface eth0</p>
<pre>
  server http accept
  client smtp accept
</pre>
<p>The above says: Define a router that matches all requests that originate from some \s-1PPP\s0 interface and go out to eth0. There is an \s-1HTTP\s0 server in eth0 that client from the \s-1PPP\s0 interfaces are allowed to reach. Clients on eth0 are allowed to get \s-1SMTP\s0 traffic from the \s-1PPP\s0 interfaces. While:</p><p>router mylan</p>
<pre>
  server http accept inface ppp+ outface eth0
  server smtp accept inface eth0 outface ppp+
</pre>
<p>The above says: Define a router that matches any kind of forwarded traffic. For \s-1HTTP\s0 traffic the clients are on a \s-1PPP\s0 interface and the servers on eth0. For \s-1SMTP\s0 traffic the clients are on a eth0 interface and the servers o a \s-1PPP\s0 interface. Please note that in the second example the \s-1SMTP\s0 traffic is matched again with a server subcommand, not a client (as in the first example). The client subcommand reverses all the optional rules that are applied indirectly to it. Indirect rule parameters are those that are inherited from the parent command (router in this case). To make it simple, for FireHOL a client is: \*(L"a server with all the implicit optional rule parameters reversed\*(R". So, in the first example, the client simply flipped the inface and outface rules defined at the router and became an \s-1SMTP\s0 server. In the second example there is nothing to be flipped, so server and client are exactly the same. I suggest to use client subcommands in routers only if you have inface/outface or src/dst in the router statements. If you are building routers like the second example, don't use client, it is confusing. Older versions of FireHOL did not allow server and client subcommands in routers. Only the route subcommand was allowed. Today, route is just an alias for server and can be used only in routers, not interfaces. Any number of router statements can exist. Since the policy is \s-1RETURN\s0 on all of them, any traffic not matched by a router will continue to be checked against the second.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Subcommands</h2>
        <div class="sectioncontent">
<p>Subcommands must be given within Primary commands.</p><p>The policy subcommand defines the default policy for an interface. This directive accepts all the actions specified in the section <strong>Actions</strong>. The policy of routers cannot be changed and is always \s-1RETURN\s0.</p><p>The protection subcommand sets a number of protection rules on an interface. In router configurations, protections are setup on inface. <em>Parameters</em></p>
<dl class='dl-vertical'>
  <dt>
    reverse
  </dt>
  <dd>
    <p>The reverse keyword will make the protections setup on outface.</p>
  </dd>
  <dt>
    type
  </dt>
  <dd>
    <p>One of the following values:</p>
<dl class='dl-vertical'>
  <dt>
    strong, full or all
  </dt>
  <dd>
    <p>Turns on all known protections</p>
  </dd>
  <dt>
    fragments
  </dt>
  <dd>
    <p>Drops all packet fragments. Please note that most probably this rule will never match anything since iptables reconstructs all packets automatically, before the iptables firewall rules are processed, when its connection tracker is running.</p>
  </dd>
  <dt>
    new-tcp-w/o-syn
  </dt>
  <dd>
    <p>Drops all \s-1TCP\s0 packets that initiate a socket but have no the \s-1SYN\s0 bit set.</p>
  </dd>
  <dt>
    syn-floods [requests/sec [burst]]
  </dt>
  <dd>
    <p>Allows only a certain amount of new \s-1TCP\s0 connections per second. The optional two arguments [requests/sec] and [burst] are used by this rule in order to provide control on the number of connections to be allowed. The default is 100 connections per second that can match 50 (it was 4 in v1.38 and before) packets initially (this is implemented using the limit module of iptables: see man iptables for more). Note that this rule applies to all connections attempted regardless of their final result (rejected, dropped, established, etc). Therefore it might not be a good idea to set it too low.</p>
  </dd>
  <dt>
    icmp-floods [requests/sec [burst]]
  </dt>
  <dd>
    <p>Allows only a certain amount of \s-1ICMP\s0 echo requests per second. The optional two arguments [requests/sec] and [burst] are used by this rule in order to provide control on the number of connections to be allowed. The default is 100 connections per second that can match 50 (it was 4 in v1.38 and before) packets initially (this is implemented using the limit module of iptables: see man iptables for more).</p>
  </dd>
  <dt>
    malformed-xmas
  </dt>
  <dd>
    <p>Drops all \s-1TCP\s0 packets that have all \s-1TCP\s0 flags set.</p>
  </dd>
  <dt>
    malformed-null
  </dt>
  <dd>
    <p>Drops all \s-1TCP\s0 packets that have all \s-1TCP\s0 flags unset.</p>
  </dd>
  <dt>
    malformed-bad
  </dt>
  <dd>
    <p>Drops all \s-1TCP\s0 packets that have illegal combinations of \s-1TCP\s0 flags set.</p>
  </dd>

</dl>

  </dd>

</dl>
<p>The server subcommand defines a server of a service. For FireHOL a server is the destination of a request, and even if this is more complex for multi-socket services, for FireHOL a server always accepts requests. The optional rule parameters given to the parent primary command (interface or router) are inherited by the server as they have been given. This subcommand can be used on both interfaces and routers. <em>Parameters</em></p>
<dl class='dl-vertical'>
  <dt>
    service
  </dt>
  <dd>
    <p>This is one of the supported service names. The command accepts more than one services in the same argument if they are separated by space and quoted as a single argument. Example:</p><p>server smtp accept server \*(L"smtp pop3 imap\*(R" accept</p>
  </dd>
  <dt>
    action
  </dt>
  <dd>
    <p>This tells FireHOL what to do with the traffic matching this rule. FireHOL supports the actions defined in the section <strong>Actions</strong>.</p>
  </dd>
  <dt>
    optional rule parameters
  </dt>
  <dd>
    <p>This is a set of rules that allow further restriction of the traffic that gets matched by this rule. See section <strong>Optional Rules Parameters</strong> for more information. Examples:</p><p>server smtp accept src 1.2.3.4 server smtp accept log \*(L"its mail\*(R" src 1.2.3.4</p>
  </dd>

</dl>
<p>The client subcommand defines a client of a service. For FireHOL a client is the source of a request. FireHOL follows this simple rule even on multi-socket complex protocols, so that for FireHOL a client always sends requests. The parameters are exactly the same with the server subcommand. The optional rule parameters given to the parent primary command (interface or router) are inherited by the client, but they are reversed. For an explanation of this please refer to the documentation of the router primary command. This subcommand can be used on both interfaces and routers.</p><p>The route subcommand is an alias for the server command that can be used only on routers, not interfaces.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Helper commands</h2>
        <div class="sectioncontent">
<p>The version command states the FireHOL release the configuration file was created for. In case the configuration file is newer than FireHOL, FireHOL will deny to run it. This command is here to allow you or anyone else design and distribute FireHOL configuration files, while ensuring that the correct FireHOL version is going to run them. The FireHOL release is increased every time the format of the configuration file and the internals of FireHOL are changed. Since FireHOL v1.67 version is not required to be present in every configuration file.</p><p>The iptables command passes all its arguments to the real iptables command, during run-time. You should not use /sbin/iptables directly to alter a FireHOL firewall in its configurations. If you do, your commands will be run before FireHOL activates its firewall and while the previous firewall is still running. Also, since FireHOL will delete all previous firewall rules in order to activate the new firewall, any changes you will make, will be deleted too. Always use the iptables directive to hook iptables commands in a FireHOL firewall. Nothing else.</p><p>Masquerading is a special from of \s-1SNAT\s0 (Source \s-1NAT\s0) that changes the source of requests when they go out and replaces their original source when replies come in. This way a Linux box can become an internet router for a \s-1LAN\s0 of clients having unroutable \s-1IP\s0 addresses. Masquerading takes care to re-map \s-1IP\s0 addresses and ports as required. Masquerading is \*(L"expensive\*(R" compared to \s-1SNAT\s0 because it checks the \s-1IP\s0 address of the ougoing interface every time for every packet, and therefore it is suggested that if you connect to the internet with a static \s-1IP\s0 address, to prefer \s-1SNAT\s0. The masquerade helper sets up masquerading on the output of a network interface (not the interface command, but a real network interface). If the masquerade command is placed within an interface command, its network interface[s] will be used. If the masquerade command is placed within a router command that has an outface defined, then the outface network interface[s] will be used. If placed within a router command but the keyword reverse is specified and the router command has an inface defined, then the inface network interface[s] will be used. If placed outside and before all primary commands, an interface (or list of space separated interfaces, within double quotes) can be specified on the masquerade command. In all cases, masquerade will setup itself on the output of the given interface[s]. Please note that if masquerade is used within some interface or router, it does not respect the optional rule parameters given to this interface or router command. Masquerade uses only its own optional rule parameters. inface and outface should not be given as parameters to masquerade (inface because iptables does not support this in the \s-1POSTROUTING\s0 chain, and outface because it will be overwritten by the interface(s) mentioned above). Finally, the masquerade helper will turn on \s-1FIREHOL_NAT\s0 and instruct the kernel to do packet forwarding (like the router commands do). Examples:</p><p>Before the first interface or router:</p>
<pre>
  masquerade eth0 src 10.0.0.0/8 dst not 10.0.0.0/8
</pre>
<p>Within an interface rule to masquerade on the output of this interface:</p>
<pre>
  masquerade
</pre>
<p>Within a router rule to masquerade on the output of the router's inface:</p>
<pre>
  masquerade reverse
</pre>
<p>The transparent_squid helper sets up trasparent caching for \s-1HTTP\s0 traffic. The squid proxy is assumed to be running on the firewall host at port <em>port</em> (<em>port</em> defaults to squid), with the credentials of the local user <em>user</em> (<em>user</em> defaults to squid). The transparent_squid helper can be used for two kinds of traffic:</p>
<dl class='dl-vertical'>
  <dt>
    &bull; Incoming \s-1HTTP\s0 traffic
  </dt>
  <dd>
    <p>Incoming \s-1HTTP\s0 traffic, which is either targeted to the firewall host or passing through the firewall host. The optional rule parameters can be used to specify which kind of incoming traffic to be catched (by using inface, src, dst, etc \*(-- outface should not be used here, because the rules generated are placed before the routing decision and therefore the outgoing interface is not yet known). If no optional rule parameters are given, then the transparent cache will be setup on all network interfaces for all \s-1HTTP\s0 traffic (use this with care since you are risking to serve requests from the internet using your squid).</p>
  </dd>
  <dt>
    &bull; Locally \s-1HTTP\s0 traffic
  </dt>
  <dd>
    <p>Locally generated \s-1HTTP\s0 traffic except traffic generated by processes running as user <em>user</em>. The optional rule parameters inface, outface and src are ignored for this type of traffic. This kind of matching makes it possible to support transparent caching for \s-1WEB\s0 browsers running on the firewall host, as far as they do not run as the user excluded. More than one users can be specified by space-separating and enclosing them in double quotes. This rule can be disabled by specifying as user the empty string: ""</p>
  </dd>

</dl>
<p>Examples:</p><p>transparent_squid 3128 squid inface eth0 src 10.0.0.0/8 transparent_squid 8080 \*(L"squid privoxy root bin\*(R" inface not \*(L"ppp+ ipsec+\*(R" dst not \*(L"a.not.proxied.server\*(R"</p><p>The nat helper sets up a \s-1NAT\s0 rule for routed traffic. The type parameter can be:</p>
<dl class='dl-vertical'>
  <dt>
    to-source
  </dt>
  <dd>
    <p>Defines a Source \s-1NAT\s0 (created in \s-1NAT/POSTROUTING\s0). The <em>target</em> in this case is the source address to be set in packets matching the optional rule parameters (if no optional rule parameters, all forwarded traffic will be matched). <em>target</em> accepts all --to-source values iptables accepts (see iptables -j \s-1SNAT\s0 --help). Multiple --to-source values can be given, if separated by space and quoted as a single argument. inface should not be used in \s-1SNAT\s0, because iptables does provide this information at this point.</p>
  </dd>
  <dt>
    to-destination
  </dt>
  <dd>
    <p>Defines a Destination \s-1NAT\s0 (created in \s-1NAT/PREROUTING\s0). The <em>target</em> in this case is the destination address to be set in packets matching the optional rule parameters (if no optional rule parameters, all forwarded traffic will be matched). <em>target</em> accepts all --to-destination values iptables accepts (see iptables -j \s-1DNAT\s0 --help). Multiple --to-destination values can be given, if separated by space and quoted as a single argument. outface should not be used in \s-1DNAT\s0, because iptables does provide this information at this point.</p>
  </dd>
  <dt>
    redirect-to
  </dt>
  <dd>
    <p>Catches traffic comming in and send it to the local machine (created in \s-1NAT/PREROUTING\s0). The <em>target</em> in this case is a port or a range of ports (\s-1XXX-YYY\s0) that packets matching the rule will be redirected to (if no optional rule parameters are given, all incoming traffic will be matched). <em>target</em> accepts all --to-ports values iptables accepts (see iptables -j \s-1REDIRECT\s0 --help). outface should not be used in \s-1REDIRECT\s0, because iptables does provide this information at this point.</p>
  </dd>

</dl>
<p>Please understand that the optional rule parameters are used only to limit the traffic to be matched. Consider these examples:</p>
<dl class='dl-vertical'>
  <dt>
    Sends to 1.1.1.1 all traffic comming in or passing trhough the firewall host:
  </dt>
  <dd>
    <p>nat to-destination 1.1.1.1</p>
  </dd>
  <dt>
    Redirects to 1.1.1.1 all traffic comming in or passing through, and going to 2.2.2.2:
  </dt>
  <dd>
    
<pre>
  nat to-destination 1.1.1.1 dst 2.2.2.2
</pre>

  </dd>
  <dt>
    Redirects to 1.1.1.1 all \s-1TCP\s0 traffic comming in or passing through and going to 2.2.2.2:
  </dt>
  <dd>
    <p>  nat to-destination 1.1.1.1 proto tcp dst 2.2.2.2</p>
  </dd>
  <dt>
    Redirects to 1.1.1.1 all traffic comming in or passing through and going to 2.2.2.2 to port tcp/25:
  </dt>
  <dd>
    <p>  nat to-destination 1.1.1.1 proto tcp dport 25 dst 2.2.2.2</p>
  </dd>

</dl>
<p>More examples:</p><p>nat to-source 1.1.1.1 outface eth0 src 2.2.2.2 dst 3.3.3.3 nat to-destination 4.4.4.4 inface eth0 src 5.5.5.5 dst 6.6.6.6 nat redirect-to 8080 inface eth0 src 2.2.2.0/24 proto tcp dport 80</p><p>The snat helper sets up a Source \s-1NAT\s0 rule for routed traffic, by calling nat to-source <em>target</em> [optional rule parameters] See the nat helper. Example:</p><p>snat to 1.1.1.1 outface eth0 src 2.2.2.2 dst 3.3.3.3</p><p>The dnat helper sets up a Destination \s-1NAT\s0 rule for routed traffic, by calling nat to-destination <em>target</em> [optional rule parameters] See the nat helper. Example:</p><p>dnat to 1.1.1.1 inface eth0 src 2.2.2.2 dst 3.3.3.3</p><p>The redirect helper catches all incoming traffic matching the optional rule parameters given and redirects it to ports on the local host, by calling nat redirect-to <em>target</em> [optional rule parameters] See the nat helper. Example:</p><p>nat redirect-to 8080 inface eth0 src 2.2.2.0/24 proto tcp dport 80</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Actions</h2>
        <div class="sectioncontent">
<p>Actions are the actions to be taken on services and traffic described by other commands and functions. Please note that normally, FireHOL will pass-through to the generated iptables statements all the possible actions iptables accepts, but only the ones defined here can be used with lower case letters and currently it will be impossible to pass arguments to some unknown action. Also, keep in mind that the iptables action \s-1LOG\s0 is a FireHOL optional rule parameter (see log and loglimit) that can be defined together with one of the following actions and FireHOL will actually produce multiple iptables statements to achieve both the logging and the action.</p><p>accept allows the traffic matching the rules to reach its destination. Example:</p><p>server smtp accept, to allow \s-1SMTP\s0 requests and their replies to flow.</p><p>reject discards the matching traffic but sends a rejecting message back to the sender. with is used to offer control on the message to be returned to the sender. with accepts all the arguments the --reject-with iptables expression accepts. For an updated list of these messages type iptables -j \s-1REJECT\s0 --help. Examples:</p><p>policy reject with host-unreach server ident reject with tcp-reset UNMATCHED_INPUT_POLICY=\*(L"reject with host-prohib\*(R"</p><p>drop silently discards the matching traffic. The fact that the traffic is silently discarded makes the sender timeout in order to conclude that it is not possible to use the wanted service. Example:</p><p>server smtp drop, to silently discard \s-1SMTP\s0 requests and their replies.</p><p>deny is just an alias for drop, made for those who are used to ipchains terminology. Example:</p><p>server smtp deny, to silently discard \s-1SMTP\s0 requests and their replies.</p><p>return will return the flow of processing to the parent of the current command. Currently, it has meaning to specify the action return only as a policy to some interface. Example:</p>
<dl class='dl-vertical'>
  <dt>
    policy return
  </dt>
  <dd>
    <p>Traffic not matched by any rule within an interface continues traveling through the firewall and is possibly matched by other interfaces bellow.</p>
  </dd>

</dl>
<p><em>mirror</em> will return the traffic to the wanted port, back to the sending host. Use this with care, and only if you understand what you doing. Keep also in mind that FireHOL will apply this action to both requests and replies comming in or passing through, and will replace it with \s-1REJECT\s0 for traffic generated by the local host.</p><p><em>redirect</em> is used internally by FireHOL Helper Commands to redirect traffic to ports on the local host. Unless you are a developer, you will never need to use this directly.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Optional Rule Parameters</h2>
        <div class="sectioncontent">
<p>Optional rule parameters are accepted by many commands to narrow the match they do by default. The parameters described bellow are all that FireHOL supports. You should check the documentation of each command to find which parameters should not be used with it. Normally, all FireHOL commands are designed so that if you specify a parameters that is also used internally, the internal one will overwrite the one given in the configuration file. In such a case, FireHOL will present you a warning with the old and the new value.</p><p>Not all parameters should be used in all cases. For example <em>sport</em> and <em>dport</em> should not be used in normal server and client commands since such ports are internally defined by the services themselves. In any case, FireHOL will complain about optional rule parameters that should not be used in certain commands.</p><p><em>src</em> defines the source \s-1IP\s0 address of the \s-1REQUEST\s0. If <em>src</em> is defined on a server statement it matches the source of the request which is the remote host, while if it is defined on a client statement it matches again the source of the request, but this time it is the local host. Focus on the \s-1REQUEST\s0!!! Forget the reply. <em>Parameters</em></p>
<dl class='dl-vertical'>
  <dt>
    not
  </dt>
  <dd>
    <p>Optional argument that reverses the match. When defined, the rule will match all hosts except the ones defined. Example:</p>
<pre>
  server smtp accept src not 1.2.3.4
</pre>

  </dd>
  <dt>
    <em>host</em>
  </dt>
  <dd>
    <p>An \s-1IP\s0 address, a hostname, or a subnet. Multiple hosts/networks can be defined if separated by space and quoted as a single argument. Examples:</p>
<pre>
  server smtp accept src 1.2.3.4
  server smtp accept src not \*(L"1.2.3.0/24 5.6.7.8 badhost.example.com\*(R"
</pre>

  </dd>

</dl>
<p><em>dst</em> defines the destination of the \s-1REQUEST\s0. If dst is defined on a server statement it matches the destination of the request which is the local host, while if it is defined on a client statement it matches again the destination of the request, but this time it is the remote host. Focus on the \s-1REQUEST\s0!!! Forget the reply. <em>dst</em> accepts the same parameters as src.</p><p><em>inface</em> defines the interface the \s-1REQUEST\s0 is received via. inface cannot be used in interface commands. <em>Parameters</em></p>
<dl class='dl-vertical'>
  <dt>
    not
  </dt>
  <dd>
    <p>An optional argument that reverses the match. When defined, the rule will match all interfaces except the ones defined. Example:</p>
<pre>
  server smtp accept inface not eth0
</pre>

  </dd>
  <dt>
    <em>interface</em>
  </dt>
  <dd>
    <p>if an interface name in the same format the interface command accepts. Multiple interfaces can be defined if separated by space and quoted as a single argument. Examples:</p>
<pre>
  server smtp accept inface not eth0
  server smtp accept inface not \*(L"eth0 eth1\*(R"
</pre>

  </dd>

</dl>
<p><em>outface</em> defines the interface the \s-1REQUEST\s0 is send via. outface cannot be used in interface commands. <em>outface</em> accepts the same parameters as inface.</p><p><em>custom</em> passes its arguments to the generated iptables commands. It is required to quote all the parameters given to custom. If the parameters include a space character between some text that is required to be given to iptables as one argument, it is required to escape another set of quotes in order. Another way is to use double quotes externally and single quotes internally. Examples:   server smtp accept custom "--some-iptables-option and_its_value"   server smtp accept custom "--some-iptables-option 'one_value another_value'</p><p><em>log</em> will log the matching packets to syslog. Note that this is not an action (in iptables it is). FireHOL will actually produce multiple iptables commands to accomplish both the action for the rule and the logging. You can control how logging works, by altering the variables \s-1FIREHOL_LOG_OPTIONS\s0 and \s-1FIREHOL_LOG_LEVEL\s0. You can also change the level of just one rule by using the level argument of the log parameter. FireHOL logs traffic, exactly the same way iptables does. Many users have complained about packet logs appearing at their console. To avoid this you will have to:</p>
<dl class='dl-vertical'>
  <dt>
    &bull; setup klogd to log only more important traffic
  </dt>
  <dd>
    
  </dd>
  <dt>
    &bull; change \s-1FIREHOL_LOG_LEVEL\s0 to log at a not so important log-level
  </dt>
  <dd>
    
  </dd>

</dl>
<p>Actually klogd's -c option and iptables' --log-level option are the same thing (iptables accepts also the numeric values klogd accepts). If iptables logs at a higher priority than klogd is configured to use, then your packets will appear in the console too.</p><p><em>loglimit</em> is the same with log but limits the frequency of logging according to the setting of \s-1FIREHOL_LOG_FREQUENCY\s0 and \s-1FIREHOL_LOG_BURST\s0.</p><p><em>proto</em> sets the required protocol for the traffic. This command accepts anything iptables accepts as protocols.</p><p><em>limit</em> will limit the match in both directions of the traffic (request and reply). This is used internally by FireHOL and its effects has not been tested in the high level configuration file directives.</p><p><em>sport</em> defines the source port of a request. It accepts port names, port numbers, port ranges (\s-1FROM:TO\s0) and multiple ports (or ranges) separated by spaces and quoted as a single argument. This parameter should not be used in normal services definitions (client and server commands) or interface and router definitions, unless you really understand what you are doing.</p><p><em>dport</em> defines the destination port of a request. It accepts port names, port numbers, port ranges (\s-1FROM:TO\s0) and multiple ports (or ranges) separated by spaces and quoted as a single argument. This parameter should not be used in normal services definitions (client and server commands) or interface and router definitions, unless you really understand what you are doing.</p><p><em>uid</em> or <em>user</em> define the operating system user sending this traffic. The parameter can be a username, a user number or a list of these two, separated by spaces and quoted as a single argument. This parameter can be used only in services (client and server commands) defined within interfaces, not routers. FireHOL is \*(L"smart\*(R" enough to apply this parameter only to traffic send by the localhost, i.e. the replies of servers and requests of clients. It is not possible, and FireHOL will simply ignore this parameter, on traffic coming in or passign through the firewall host. Example 1:   client "pop3 imap" accept user not "user1 user2 user3" dst mymailer.example.com</p><p>The above will allow local users except user1, user2 and user3 to use \s-1POP3\s0 and \s-1IMAP\s0 services on mymailer.example.com. You can use this, for example, to allow only a few of the local users use the fetchmail program to fetch their mail from the mail server. Example 2:   server http accept user apache</p><p>The above will allow all \s-1HTTP\s0 to reach the local http server, but only if the web server is running as user apache the replies will be send back to the \s-1HTTP\s0 client.</p><p><em>gid</em> or <em>group</em> define the operating system user group sending this traffic. The parameter can be a group name, a group number or a list of these two, separated by spaces and quoted as a single argument. This parameter can be used only in services (client and server commands) defined within interfaces, not routers. FireHOL is \*(L"smart\*(R" enough to apply this parameter only to traffic send by the localhost, i.e. the replies of servers and requests of clients. It is not possible, and FireHOL will simply ignore this parameter, on traffic coming in or passing through the firewall host.</p><p><em>pid</em> or <em>process</em> define the operating system process \s-1ID\s0 (or \s-1PID\s0) sending this traffic. The parameter can be a \s-1PID\s0 or a list of PIDs, separated by spaces and quoted as a single argument. This parameter can be used only in services (client and server commands) defined within interfaces, not routers. FireHOL is \*(L"smart\*(R" enough to apply this parameter only to traffic send by the localhost, i.e. the replies of servers and requests of clients. It is not possible, and FireHOL will simply ignore this parameter, on traffic coming in or passign through the firewall host.</p><p><em>sid</em> or <em>session</em> define the operating system session \s-1ID\s0 of the process sending this traffic (The session \s-1ID\s0 of a process is the process group \s-1ID\s0 of the session leader). The parameter can be a list of such IDs, separated by spaces and quoted as a single argument. This parameter can be used only in services (client and server commands) defined within interfaces, not routers. FireHOL is \*(L"smart\*(R" enough to apply this parameter only to traffic send by the localhost, i.e. the replies of servers and requests of clients. It is not possible, and FireHOL will simply ignore this parameter, on traffic coming in or passign through the firewall host.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Variables that control FireHOL</h2>
        <div class="sectioncontent">
<p><em>\s-1DEFAULT_INTERFACE_POLICY\s0</em> controls the default action to be taken on traffic not matched by any rule within an interface. Actually, this is a global setting for what policy does for an interface. All packets that reach the end of an interface are logged only if the action is not return or accept. You can control the frequency of this logging by altering the frequency loglimit uses.  Default: DEFAULT_INTERFACE_POLICY="DROP"  Example: DEFAULT_INTERFACE_POLICY="REJECT"</p><p><em>\s-1UNMATCHED_INPUT_POLICY\s0</em> controls the default action to be taken for incoming traffic not matched by any interface command. <em>\s-1UNMATCHED_OUTPUT_POLICY\s0</em> controls the default action to be taken for outgoing traffic not matched by any interface command. <em>\s-1UNMATCHED_FORWARD_POLICY\s0</em> controls the default action to be taken for forwarded traffic not matched by any router command. All variables accept all the Actions FireHOL supports. All packets that reach the end of firewall in all three chains are logged (always, regardless of these settings). You can control the frequency of this logging by altering the frequency loglimit uses.  Default: UNMATCHED_INPUT_POLICY="DROP"  Default: UNMATCHED_OUTPUT_POLICY="DROP"  Default: UNMATCHED_FORWARD_POLICY="DROP"  Example: UNMATCHED_INPUT_POLICY="REJECT"  Example: UNMATCHED_OUTPUT_POLICY="REJECT"  Example: UNMATCHED_FORWARD_POLICY="REJECT"</p><p><em>\s-1FIREHOL_LOG_LEVEL\s0</em> controls the level at which iptables will log things to the syslog. For a description of the possible values supported and for per-rule control of log level, see the log optional rule parameter. <em>\s-1FIREHOL_LOG_OPTIONS\s0</em> controls the way iptables will log things to the syslog. The value of this variable is passed as is to iptables, so use exact iptables parameters. <em>\s-1FIREHOL_LOG_FREQUENCY\s0</em> and <em>\s-1FIREHOL_LOG_BURST\s0</em> (added in v1.39 of FireHOL) control the frequency at each each logging rule will write packets to the syslog. \s-1FIREHOL_LOG_FREQUENCY\s0 is set to the maximum average frequency and \s-1FIREHOL_LOG_BURST\s0 specifies the maximum initial number of packets to match.  Default: FIREHOL_LOG_OPTIONS="--log-level warning"  Default: FIREHOL_LOG_FREQUENCY="1/second"  Default: FIREHOL_LOG_BURST="5"  Example: FIREHOL_LOG_OPTIONS="--log-level info --log-tcp-options --log-ip-options"  Example: FIREHOL_LOG_FREQUENCY="30/minute"  Example: FIREHOL_LOG_BURST="2" To see the available iptables log options, run \*(C`/sbin/iptables -j LOG --help\*(C' To see what iptables accepts as frequencies and bursts, run \*(C`/sbin/iptables -m limit --help\*(C' You can also check man iptables.</p><p><em>\s-1DEFAULT_CLIENT_PORTS\s0</em> controls the port range to be used when a remote client is specified. For localhost clients, FireHOL finds the exact client ports by querying the kernel options.  Default: 1000:65535  Example: DEFAULT_CLIENT_PORTS="0:65535"</p><p>If <em>\s-1FIREHOL_NAT\s0</em> is set to 1, FireHOL will load \s-1NAT\s0 kernel modules for those services that they are require such. FireHOL sets this to 1 automatically if you use the Helper Commands that do \s-1NAT\s0.  Default: FIREHOL_NAT="0"  Example: FIREHOL_NAT="1"</p><p>\s-1FIREHOL_AUTOSAVE\s0 controls the file that will be created when FireHOL is called with the save command line argument. If this variable is empty (the default), FireHOL will try to detect where to save the file. Currently, the RedHat way (/etc/sysconfig/iptables) and the Debian way (/var/lib/iptables/autosave) are automatically detected (in the order given here) based on the existance of the directory this file should be created in. Default: FIREHOL_AUTOSAVE="\*(L" Example: FIREHOL_AUTOSAVE=\*(R"/tmp/firehol-saved.txt"</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Variables that FireHOL offers</h2>
        <div class="sectioncontent">
<p>This variable includes all the \s-1IP\s0 addresses defined as \s-1IANA\s0 - Reserved by \s-1IANA\s0.  Example: interface eth0 internet src not "${RESERVED_IPS}"</p><p>This variable includes all the \s-1IP\s0 addresses defined as Private or Test by \s-1RFC\s0 3330.  Example: interface eth0 internet src not "${PRIVATE_IPS}"</p><p>This variable is both <em>\s-1RESERVED_IPS\s0</em> and <em>\s-1PRIVATE_IPS\s0</em> together. I suggest to use this variable on interfaces and routers accepting Internet traffic.  Example: interface eth0 internet src not "${UNROUTABLE_IPS}"</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILES</h2>
        <div class="sectioncontent">
<p><em>/etc/firehol/firehol.conf</em></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>firehol written by Costa Tsaousis &lt;costa@tsaousis.gr&gt;.</p><p>Man page written by Marc Brockschmidt &lt;&lt;marc@marcbrockschmidt.de&gt;.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO firehol.conf&hellip;</h2>
        <div class="sectioncontent">
<p><em>firehol</em>\|(1), <em>iptables</em>\|(8), <em>bash</em>\|(1)</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="findlib.conf.5.html"><span aria-hidden="true">&larr;</span> findlib.conf.5: [configuration of findlib/ocamlfind] .sh "general" there are three possibilities to configure the findlib library:    build time: .re  before findlib is compiled, a "configure" script is invoked to figure   out the settings that are most likely to work on the system. most   settings are simply entered into text files and can easily be changed   after installation. the following properties cannot be changed later   because they are compiled into the resulting binaries:     \h'-3m'\z\h'3m' .ft r the default location of the configuration file findlib.conf. however,   you can set a different location by the environment variable   ocamlfind_conf .    \h'-3m'\z\h'3m' .ft r whether the installed o'caml version supports autolinking or not.     configuration file findlib.conf: .re  an initial version of this file is generated by the configure script,   but you are free to modify it later. most important, this file   contains the system-wide search path used to look up packages, and the   default location where to install new packages.    all files with the suffix ".conf" found in the directory   findlib.conf.d are also scanned for parameters.    environment variables: .re  the settings of findlib.conf can be overridden by environment variables.    last but not least, several settings can also be passed as  command-line options, or by invoking the function  findlib.init .</a></li>
   <li class="next"><a href="firewalld.conf.5.html">firewalld.conf.5: Firewalld configuration file <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

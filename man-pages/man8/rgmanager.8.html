<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>rgmanager: Resource group (cluster service) manager daemon</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Resource group (cluster service) manager daemon">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="rgmanager (8) manual">
  <meta name="twitter:description" content="Resource group (cluster service) manager daemon">
  <meta name="twitter:image" content="https://www.carta.tech/images/rgmanager-rgmanager-8.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man8/rgmanager.8.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="rgmanager (8) manual" />
  <meta property="og:description" content="Resource group (cluster service) manager daemon" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/rgmanager-rgmanager-8.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">rgmanager<small> (8)</small></h1>
        <p class="lead">Resource group (cluster service) manager daemon</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man8/">
      <span itemprop="name">System administration commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man8/rgmanager.8.html">
      <span itemprop="name">rgmanager: Resource group (cluster service) manager daemon</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/rgmanager/">
      <span itemprop="name">rgmanager</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man8/rgmanager.8.html">
      <span itemprop="name">rgmanager: Resource group (cluster service) manager daemon</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><strong>rgmanager</strong> handles management of user-defined cluster services (also known as resource groups).  This includes handling of user requests including service start, service disable, service relocate, and service restart.  The service manager daemon also handles restarting and relocating services in the event of failures.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">HOW IT WORKS</h2>
        <div class="sectioncontent">
<p>The service manager is spawned by an init script after the cluster infrastructure has been started and only functions when the cluster is quorate and locks are working.</p><p>During initialization, the service manager runs scripts which ensure that all services are clear to be started.  After that, it determines which services need to be started and starts them.</p><p>When an event is received, members which are no longer online have their services taken away from them.  The event should only occur in the case that the member has been fenced whenever fencing is available.</p><p>When a cluster member determines that it is no longer in the cluster quorum, the service manager stops all services and waits for a new quorum to form.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONFIGURATION</h2>
        <div class="sectioncontent">
<p>Rgmanager is configured via cluster.conf.  With the exception of logging, all of rgmanager's configuration resides with the <strong>&lt;rm&gt;</strong> tag.  The general parameters for rgmanager are as follows:</p><p><strong>central_processing</strong> - Enable central processing mode (requires cluster-wide shut down and restart of rgmanager).  This alternative mode of handling failures externalizes most of rgmanager's features into a user-editable script. This mode is disabled by default.</p><p><strong>status_poll_interval</strong> - This defines the amount of time, in seconds, rgmanager waits between resource tree scans for status checks.  Decreasing this value may improve rgmanager's ability to detect failures in services, but at a cost of decreased performance and increased system utilization. The default is 10 seconds.</p><p><strong>status_child_max</strong> - Maximum number of status check threads (default = 5).  It is not recommended that this ever be changed.  This simply controls how many instances of clustat queries may be outstanding on a single node at any given time.</p><p><strong>transition_throttling</strong> - This is the amount of time the event processing thread stays alive after the last event has been processed.  The default is 5 seconds. It is not recommended that this ever be changed.</p><p><strong>log_level</strong> - DEPRECATED; DO NOT USE.  Controls log level filtering to syslog. Default is 5; valid values range from 0-7.  See <a href="../man5/cluster.conf.5.html"><strong>cluster.conf</strong>(5)</a> for the current method to configure logging.</p><p><strong>log_facility</strong> - DEPRECATED; DO NOT USE.  Controls log level facility when sending messages to syslog.  Default is "daemon".  See <a href="../man5/cluster.conf.5.html"><strong>cluster.conf</strong>(5)</a> for the current method to configure logging.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RESOURCE AGENTS</h2>
        <div class="sectioncontent">
<p><strong>Resource agents</strong> define resource classes rgmanager can manage.  Rgmanager follows the Open Cluster Framework Resource Agent API v1.0 (draft) standard, with the following two notable exceptions:</p><p>* Rgmanager does not call <em>monitor</em>; it only calls <em>status</em> * Rgmanager looks for resource agets in /usr/share/cluster</p><p>Rgmanager uses the metadata from resource agents to determine what parameters to look for in cluster.conf for a each resource type.  Viewing the resource agent metadata is the best way to understand all the various resource agent parameters.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SERVICES / RESOURCE GROUPS</h2>
        <div class="sectioncontent">
<p>A <strong>service</strong> or <strong>resource group</strong> is a collection of resources defined in cluster.conf for rgmanager's use.  Resource groups are also called <strong>resource trees.</strong></p><p>A resource group is the atomic unit of failover in rgmanager.  That is, even though rgmanager calls out to various resource agents individually in order to start or stop various resources, everything in the resource group is always moved around together in the event of a relocation or failover.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">STARTUP POLICIES</h2>
        <div class="sectioncontent">
<p>Rgmanager supports only two startup policies,</p><p><strong>autostart</strong> - if set to 1 (the default), the service is started when a quorum forms.  If set to 0, the service is not automatically started.</p><p>Startup Policy Configuration: Recovery Configuration: &lt;rm&gt; &lt;service name="service1" autostart="[0|1]" .../&gt;  ... &lt;/rm&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RECOVERY POLICIES</h2>
        <div class="sectioncontent">
<p>Rgmanager supports three recovery policies for services; this is configured by the <strong></strong> recovery parameter in the service definition.</p><p><strong>restart</strong> - means to attempt to restart the resource group in place in the event of one or more failures of individual resources.  This can further be augmented by the <strong>max_restarts</strong> and <strong>restart_expire_time</strong> parameters, which define a tolerance for the amount of service restarts over the given amount of time.</p><p><strong>relocate</strong> - means to move the resource group to another host in the cluster instead of restarting on the same host.</p><p><strong>disable</strong> - means to not try to recover the resource group.  Instead, just place it in to the disabled state.</p><p>Recovery Configuration: &lt;rm&gt; &lt;service name="service1" recovery="[restart|relocate|disable]" .../&gt;  ... &lt;/rm&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FAILOVER DOMAINS</h2>
        <div class="sectioncontent">
<p>A failover domain is an ordered subset of members to which a service may be bound. The following is a list of semantics governing the options as to how the different configuration options affect the behavior of a failover domain:</p><p><strong>preferred node</strong> or <strong>preferred member</strong> : The preferred node was the member designated to run a given service if the member is online. We can emulate this behavior by specifying an unordered, unrestricted failover domain of exactly one member.</p><p><strong>restricted domain</strong> : Services bound to the domain may only run on cluster members which are also members of the failover domain. If no members of the failover domain are available, the service is placed in the stopped state.</p><p><strong>unrestricted domain</strong> : Services bound to this domain may run on all cluster members, but will run on a member of the domain whenever one is available. This means that if a service is running outside of the domain and a member of the domain comes online, the service will migrate to that member.</p><p><strong>ordered domain</strong> : The order specified in the configuration dictates the order of preference of members within the domain. The highest-ranking member of the domain will run the service whenever it is online.  This means that if member A has a higher rank than member B, the service will migrate to A if it was running on B if A transitions from offline to online.</p><p><strong>unordered domain</strong> : Members of the domain have no order of preference; any member may run the service. Services will always migrate to members of their failover domain whenever possible, however, in an unordered domain.</p><p><strong>nofailback</strong> : Enabling this option for an ordered failover domain will prevent automated fail-back after a more-preferred node rejoins the cluster. Consequently, nofailback requires an ordered domain in order to be meaningful.  When nofailback is used, the following two behaviors should be noted: * If a subset of cluster nodes forms a quorum, the node with the highest priority in the failover domain is selected to run a service bound to the domain. After this point, a higher priority member joining the cluster will not trigger a relocation. * When a service is running outside of its unrestricted failover domain and a cluster member boots which is a part of the service's failover domain, the service will relocate to that member. That is, nofailback does not prevent transitions from outside of a failover domain to inside a failover domain. After this point, a higher priority member joining the cluster will not trigger a relocation.</p><p>Ordering, restriction, and nofailback are flags and may be combined in almost any way (ie, ordered+restricted, unordered+unrestricted, etc.). These combinations affect both where services start after initial quorum formation and which cluster members will take over services in the event that the service has failed.</p><p>Failover Domain Configuration: &lt;rm&gt; &lt;failoverdomains&gt; &lt;failoverdomain name="NAME" ordered="[0|1]" restricted="[0|1]" nofailback="[0|1" &gt; &lt;failoverdomainnode name="node1" priority="[1..100]" /&gt;  ... &lt;/failoverdomain&gt; &lt;/failoverdomains&gt;  ... &lt;/rm&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SERVICE OPERATIONS</h2>
        <div class="sectioncontent">
<p>These are how the basic user-initiated service operations (via <strong>clusvcadm</strong> ) work.</p><p><strong>enable</strong> - start the service, optionally on a preferred target and optionally according to failover domain rules. In absence of either, the local host where clusvcadm is run will start the service. If the original start fails, the service behaves as though a relocate operation was requested (see below). If the operation succeeds, the service is placed in the started state.</p><p><strong>disable</strong> - stop the service and place into the disabled state. This is the only permissible operation when a service is in the failed state.</p><p><strong>relocate</strong> - move the service to another node. Optionally, the administrator may specify a preferred node to receive the service, but the inability for the service to run on that host (e.g. if the service fails to start or the host is offline) does not prevent relocation, and another node is chosen. Rgmanager attempts to start the service on every permissible node in the cluster. If no permissible target node in the cluster successfully starts the service, the relocation fails and the service is attempted to be restarted on the original owner. If the original owner can not restart the service, the service is placed in the stopped state.</p><p><strong>stop</strong> - stop the service and place into the stopped state.</p><p><strong>migrate</strong> - migrate the virtual machine to another node. The administrator must specify a target node. Depending on the failure, a failure to migrate may result with the virtual machine in the failed state or in the started state on the original owner.</p><p><strong>freeze</strong> - freeze the service or virtual machine in place and prevent status checks from occurring.  Administrators may do this in order to perform maintenance on one or more parts of a given service without having rgmanager interfere.  It is very important that the administrator unfreezes the service once maintenance is complete, as a frozen service will not fail over.  Freezing a service does NOT affect is operational state.  For example, it does not 'pause' virtual machines or suspend them to disk.</p><p><strong>unfreeze</strong> - unfreeze (thaw) the service or virtual machine.  This command makes rgmanager perform status checks on the service again.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SERVICE STATES</h2>
        <div class="sectioncontent">
<p>These are the most common service states.</p><p><strong>disabled</strong> - The service will remain in the disabled state until either an administrator re-enables the service or the cluster loses quorum (when the cluster regains quorum, the autostart parameter is evaluated). An administrator may enable the service from this state.</p><p><strong>failed</strong> - The service is presumed dead.  A service is placed in to this state whenever a resource's stop operation fails.  After a service is placed in to this state, the administrator must verify that there are no allocated resources (mounted file systems, etc.) prior to issuing a disable request. The only operation which can take place when a service has entered this state is a disable.</p><p><strong>stopped</strong> - When in the stopped state, the service will be evaluated for starting after the next service or node transition.  This is considered a temporary state. An administrator may disable or enable the service from this state.</p><p><strong>recovering</strong> - The cluster is trying to recover the service. An administrator may disable the service to prevent recovery if desired.</p><p><strong>started</strong> - If a service status check fails, recover it according to the service recovery policy. If the host running the service fails, recover it following failover domain & exclusive service rules. An administrator may relocate, stop, disable, and (with virtual machines) migrate the service from this state.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">VIRTUAL MACHINE FEATURES</h2>
        <div class="sectioncontent">
<p>Apart from what is noted in the VM resource agent, rgmanager provides a few convenience features when dealing with virtual machines. * it will use live migration when transferring a virtual machine to a more-preferred host in the cluster as a consequence of failover domain operation * it will search the other instances of rgmanager in the cluster in the case that a user accidentally moves a virtual machine using other management tools * unlike services, adding a virtual machine to rgmanager's configuration will not cause the virtual machine to be restarted * removing a virtual machine from rgmanager's configuration will leave the virtual machine running.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COMMAND LINE OPTIONS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    -f
  </dt>
  <dd>
    <p>Run in the foreground (do not fork).</p>
  </dd>
  <dt>
    -d
  </dt>
  <dd>
    <p>Enable debug-level logging.</p>
  </dd>
  <dt>
    -q
  </dt>
  <dd>
    <p>Disable DBus signals which are normally sent when services change state.</p>
  </dd>
  <dt>
    -w
  </dt>
  <dd>
    <p>Disable internal process monitoring (for debugging).</p>
  </dd>
  <dt>
    -N
  </dt>
  <dd>
    <p>Do not perform stop-before-start.  Combined with the <em>-Z</em> flag to clusvcadm, this can be used to allow rgmanager to be upgraded without stopping a given user service or set of services.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO rgmanager&hellip;</h2>
        <div class="sectioncontent">
<p>http://sources.redhat.com/cluster/wiki/RGManager</p><p><a href="../man8/clusvcadm.8.html"><strong>clusvcadm</strong>(8)</a>, <a href="../man5/cluster.conf.5.html"><strong>cluster.conf</strong>(5)</a></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="rfkill.8.html"><span aria-hidden="true">&larr;</span> rfkill.8: Tool for enabling and disabling wireless devices</a></li>
   <li class="next"><a href="rhino.8.html">rhino.8: Driver for brazilian microsol rhino ups equipment <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

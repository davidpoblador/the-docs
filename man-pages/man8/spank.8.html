<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>spank: Slurm plug-in architecture for node and job (k)control</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Slurm plug-in architecture for node and job (k)control">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="spank (8) manual">
  <meta name="twitter:description" content="Slurm plug-in architecture for node and job (k)control">
  <meta name="twitter:image" content="https://www.carta.tech/images/slurm-client-spank-8.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man8/spank.8.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="spank (8) manual" />
  <meta property="og:description" content="Slurm plug-in architecture for node and job (k)control" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/slurm-client-spank-8.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">spank<small> (8)</small></h1>
        <p class="lead">Slurm plug-in architecture for node and job (k)control</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man8/">
      <span itemprop="name">System administration commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man8/spank.8.html">
      <span itemprop="name">spank: Slurm plug-in architecture for node and job (k)control</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/slurm-client/">
      <span itemprop="name">slurm-client</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man8/spank.8.html">
      <span itemprop="name">spank: Slurm plug-in architecture for node and job (k)control</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This manual briefly describes the capabilities of the SLURM Plug-in architecture for Node and job Kontrol (<strong>SPANK</strong>) as well as the <strong>SPANK</strong> configuration file: (By default: <strong>plugstack.conf</strong>.)</p><p><strong>SPANK</strong> provides a very generic interface for stackable plug-ins which may be used to dynamically modify the job launch code in SLURM. <strong>SPANK</strong> plugins may be built without access to SLURM source code. They need only be compiled against SLURM's <strong>spank.h</strong> header file, added to the <strong>SPANK</strong> config file <strong>plugstack.conf</strong>, and they will be loaded at runtime during the next job launch. Thus, the <strong>SPANK</strong> infrastructure provides administrators and other developers a low cost, low effort ability to dynamically modify the runtime behavior of SLURM job launch.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SPANK PLUGINS</h2>
        <div class="sectioncontent">
<p><strong>SPANK</strong> plugins are loaded in up to five separate contexts during a <strong>SLURM</strong> job. Briefly, the three contexts are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>local</strong><strong></strong></p>
  </dt>
  <dd>
    <p>In <strong>local</strong> context, the plugin is loaded by <strong>srun</strong>. (i.e. the "local" part of a parallel job).</p>
  </dd>
  <dt>
    <p><strong>remote</strong></p>
  </dt>
  <dd>
    <p>In <strong>remote</strong> context, the plugin is loaded by <strong>slurmstepd</strong>. (i.e. the "remote" part of a parallel job).</p>
  </dd>
  <dt>
    <p><strong>allocator</strong></p>
  </dt>
  <dd>
    <p>In <strong>allocator</strong> context, the plugin is loaded in one of the job allocation utilities <strong>sbatch</strong> or <strong>salloc</strong>.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p><strong>slurmd</strong> In <strong>slurmd</strong> context, the plugin is loaded in the</p>
  </dt>
  <dd>
    <p><strong>slurmd</strong> daemon itself. <strong>Note</strong>: Plugins loaded in slurmd context persist for the entire time slurmd is running, so if configuration is changed or plugins are updated, slurmd must be restarted for the changes to take effect.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p><strong>job_script</strong></p>
  </dt>
  <dd>
    <p>In the <strong>job_script</strong> context, plugins are loaded in the context of the job prolog or epilog. <strong>Note</strong>: Plugins are loaded in <strong>job_script</strong> context on each run on the job prolog or epilog, in a separate address space from plugins in <strong>slurmd</strong> context. This means there is no state shared between this context and other contexts, or even between one call to <strong>slurm_spank_job_prolog</strong> or <strong>slurm_spank_job_epilog</strong> and subsequent calls.</p>
  </dd>

</dl>
<p>In local context, only the <strong>init</strong>, <strong>exit</strong>, <strong>init_post_opt</strong>, and <strong>user_local_init</strong> functions are called. In allocator context, only the <strong>init</strong>, <strong>exit</strong>, and <strong>init_post_opt</strong> functions are called. Similarly, in slurmd context, only the <strong>slurmd_init</strong> and <strong>slurmd_exit</strong> callbacks are active, and in the job_script context, only the <strong>job_prolog</strong> and job_epilog callbacks are used. Plugins may query the context in which they are running with the <strong>spank_context</strong> and <strong>spank_remote</strong> functions defined in <strong>&lt;slurm/spank.h&gt;</strong>.</p><p><strong>SPANK</strong> plugins may be called from multiple points during the SLURM job launch. A plugin may define the following functions:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>slurm_spank_init</strong></p>
  </dt>
  <dd>
    <p>Called just after plugins are loaded. In remote context, this is just after job step is initialized. This function is called before any plugin option processing. This function is not called in slurmd context.</p>
  </dd>
  <dt>
    <p><strong>slurm_spank_slurmd_init</strong></p>
  </dt>
  <dd>
    <p>Called in slurmd just after the daemon is started.</p>
  </dd>
  <dt>
    <p><strong>slurm_spank_job_prolog</strong></p>
  </dt>
  <dd>
    <p>Called at the same time as the job prolog.</p>
  </dd>
  <dt>
    <p><strong>slurm_spank_init_post_opt</strong></p>
  </dt>
  <dd>
    <p>Called at the same point as <strong>slurm_spank_init</strong>, but after all user options to the plugin have been processed. The reason that the <strong>init</strong> and <strong>init_post_opt</strong> callbacks are separated is so that plugins can process system-wide options specified in plugstack.conf in the <strong>init</strong> callback, then process user options, and finally take some action in <strong>slurm_spank_init_post_opt</strong> if necessary.</p>
  </dd>
  <dt>
    <p><strong>slurm_spank_local_user_init</strong></p>
  </dt>
  <dd>
    <p>Called in local (<strong>srun</strong>) context only after all options have been processed. This is called after the job ID and step IDs are available. This happens in <strong>srun</strong> after the allocation is made, but before tasks are launched.</p>
  </dd>
  <dt>
    <p><strong>slurm_spank_user_init</strong></p>
  </dt>
  <dd>
    <p>Called after privileges are temporarily dropped. (remote context only)</p>
  </dd>
  <dt>
    <p><strong>slurm_spank_task_init_privileged</strong></p>
  </dt>
  <dd>
    <p>Called for each task just after fork, but before all elevated privileges are dropped. (remote context only)</p>
  </dd>
  <dt>
    <p><strong>slurm_spank_task_init</strong></p>
  </dt>
  <dd>
    <p>Called for each task just before execve (2). (remote context only)</p>
  </dd>
  <dt>
    <p><strong>slurm_spank_task_post_fork</strong></p>
  </dt>
  <dd>
    <p>Called for each task from parent process after fork (2) is complete. Due to the fact that <strong>slurmd</strong> does not exec any tasks until all tasks have completed fork (2), this call is guaranteed to run before the user task is executed. (remote context only)</p>
  </dd>
  <dt>
    <p><strong>slurm_spank_task_exit</strong></p>
  </dt>
  <dd>
    <p>Called for each task as its exit status is collected by SLURM. (remote context only)</p>
  </dd>
  <dt>
    <p><strong>slurm_spank_exit</strong></p>
  </dt>
  <dd>
    <p>Called once just before <strong>slurmstepd</strong> exits in remote context. In local context, called before <strong>srun</strong> exits.</p>
  </dd>
  <dt>
    <p><strong>slurm_spank_job_epilog</strong></p>
  </dt>
  <dd>
    <p>Called at the same time as the job epilog.</p>
  </dd>
  <dt>
    <p><strong>slurm_spank_slurmd_exit</strong></p>
  </dt>
  <dd>
    <p>Called in slurmd when the daemon is shut down.</p>
  </dd>

</dl>
<p>All of these functions have the same prototype, for example:</p>
<pre>
   int <strong>slurm_spank_init</strong> (spank_t spank, int ac, char *argv[])

</pre>
<p>Where <strong>spank</strong> is the <strong>SPANK</strong> handle which must be passed back to SLURM when the plugin calls functions like <strong>spank_get_item</strong> and <strong>spank_getenv</strong>. Configured arguments (See <strong>CONFIGURATION</strong> below) are passed in the argument vector <strong>argv</strong> with argument count <strong>ac</strong>.</p><p><strong>SPANK</strong> plugins can query the current list of supported slurm_spank symbols to determine if the current version supports a given plugin hook. This may be useful because the list of plugin symbols may grow in the future. The query is done using the <strong>spank_symbol_supported</strong> function, which has the following prototype:</p>
<pre>
    int <strong>spank_symbol_supported</strong> (const char *sym);

</pre>
<p>The return value is 1 if the symbol is supported, 0 if not.</p><p><strong>SPANK</strong> plugins do not have direct access to internally defined SLURM data structures. Instead, information about the currently executing job is obtained via the <strong>spank_get_item</strong> function call.</p>
<pre>
  spank_err_t <strong>spank_get_item</strong> (spank_t spank, spank_item_t item, ...);

</pre>
<p>The <strong>spank_get_item</strong> call must be passed the current <strong>SPANK</strong> handle as well as the item requested, which is defined by the passed <strong>spank_item_t</strong>. A variable number of pointer arguments are also passed, depending on which item was requested by the plugin. A list of the valid values for <strong>item</strong> is kept in the <strong>spank.h</strong> header file. Some examples are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>S_JOB_UID</strong></p>
  </dt>
  <dd>
    <p>User id for running job. (uid_t *) is third arg of <strong>spank_get_item</strong></p>
  </dd>
  <dt>
    <p><strong>S_JOB_STEPID</strong></p>
  </dt>
  <dd>
    <p>Job step id for running job. (uint32_t *) is third arg of <strong>spank_get_item</strong>.</p>
  </dd>
  <dt>
    <p><strong>S_TASK_EXIT_STATUS</strong></p>
  </dt>
  <dd>
    <p>Exit status for exited task. Only valid from <strong>slurm_spank_task_exit</strong>. (int *) is third arg of <strong>spank_get_item</strong>.</p>
  </dd>
  <dt>
    <p><strong>S_JOB_ARGV</strong></p>
  </dt>
  <dd>
    <p>Complete job command line. Third and fourth args to <strong>spank_get_item</strong> are (int *, char ***).</p>
  </dd>

</dl>
<p>See <strong>spank.h</strong> for more details, and <strong>EXAMPLES</strong> below for an example of <strong>spank_get_item</strong> usage.</p><p><strong>SPANK</strong> plugins may also use the <strong>spank_getenv</strong>, <strong>spank_setenv</strong>, and <strong>spank_unsetenv</strong> functions to view and modify the job's environment. <strong>spank_getenv</strong> searches the job's environment for the environment variable <em>var</em> and copies the current value into a buffer <em>buf</em> of length <em>len</em>.  <strong>spank_setenv</strong> allows a <strong>SPANK</strong> plugin to set or overwrite a variable in the job's environment, and <strong>spank_unsetenv</strong> unsets an environment variable in the job's environment. The prototypes are:</p>
<pre>
 spank_err_t <strong>spank_getenv</strong> (spank_t spank, const char *var,
		           char *buf, int len);
 spank_err_t <strong>spank_setenv</strong> (spank_t spank, const char *var,
		           const char *val, int overwrite);
 spank_err_t <strong>spank_unsetenv</strong> (spank_t spank, const char *var);
</pre>
<p>These are only necessary in remote context since modifications of the standard process environment using <strong>setenv</strong> (3), <strong>getenv</strong> (3), and <strong>unsetenv</strong> (3) may be used in local context.</p><p>Functions are also available from within the <strong>SPANK</strong> plugins to establish environment variables to be exported to the SLURM <strong>PrologSlurmctld</strong>, <strong>Prolog</strong>, <strong>Epilog</strong> and <strong>EpilogSlurmctld</strong> programs (the so-called <strong>job control</strong> environment). The name of environment variables established by these calls will be prepended with the string <em>SPANK_</em> in order to avoid any security implications of arbitrary environment variable control. (After all, the job control scripts do run as root or the SLURM user.).</p><p>These functions are available from <strong>local</strong> context only.</p>
<pre>
  spank_err_t <strong>spank_job_control_getenv</strong>(spank_t spank, const char *var,
		             char *buf, int len);
  spank_err_t <strong>spank_job_control_setenv</strong>(spank_t spank, const char *var,
		             const char *val, int overwrite);
  spank_err_t <strong>spank_job_control_unsetenv</strong>(spank_t spank, const char *var);
</pre>
<p>See <strong>spank.h</strong> for more information, and <strong>EXAMPLES</strong> below for an example for <strong>spank_getenv</strong> usage.</p><p>Many of the described <strong>SPANK</strong> functions available to plugins return errors via the <strong>spank_err_t</strong> error type. On success, the return value will be set to <strong>ESPANK_SUCCESS</strong>, while on failure, the return value will be set to one of many error values defined in slurm/spank.h. The <strong>SPANK</strong> interface provides a simple function</p>
<pre>
  const char * <strong>spank_strerror</strong>(spank_err_t err);

</pre>
<p>which may be used to translate a <strong>spank_err_t</strong> value into its string representation.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SPANK OPTIONS</h2>
        <div class="sectioncontent">
<p>SPANK plugins also have an interface through which they may define and implement extra job options. These options are made available to the user through SLURM commands such as <a href="../man1/srun.1.html"><strong>srun</strong>(1)</a>, <a href="../man1/salloc.1.html"><strong>salloc</strong>(1)</a>, and <a href="../man1/sbatch.1.html"><strong>sbatch</strong>(1)</a>. if the option is specified by the user, its value is forwarded and registered with the plugin in slurmd when the job is run. In this way, <strong>SPANK</strong> plugins may dynamically provide new options and functionality to SLURM.</p><p>Each option registered by a plugin to SLURM takes the form of a <strong>struct spank_option</strong> which is declared in <strong>&lt;slurm/spank.h&gt;</strong> as</p>
<pre>
   struct spank_option {
      char *         name;
      char *         arginfo;
      char *         usage;
      int            has_arg;
      int            val;
      spank_opt_cb_f cb;
   };

</pre>
<p>Where</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>name</em></p>
  </dt>
  <dd>
    <p>is the name of the option. Its length is limited to <strong>SPANK_OPTION_MAXLEN</strong> defined in <strong>&lt;slurm/spank.h&gt;</strong>.</p>
  </dd>
  <dt>
    <p><em>arginfo</em></p>
  </dt>
  <dd>
    <p>is a description of the argument to the option, if the option does take an argument.</p>
  </dd>
  <dt>
    <p><em>usage</em></p>
  </dt>
  <dd>
    <p>is a short description of the option suitable for --help output.</p>
  </dd>
  <dt>
    <p><em>has_arg</em></p>
  </dt>
  <dd>
    <p>0 if option takes no argument, 1 if option takes an argument, and 2 if the option takes an optional argument. (See <strong>getopt_long</strong> (3)).</p>
  </dd>
  <dt>
    <p><em>val</em></p>
  </dt>
  <dd>
    <p>A plugin-local value to return to the option callback function.</p>
  </dd>
  <dt>
    <p><em>cb</em></p>
  </dt>
  <dd>
    <p>A callback function that is invoked when the plugin option is registered with SLURM. <strong>spank_opt_cb_f</strong> is typedef'd in <strong>&lt;slurm/spank.h&gt;</strong> as</p>
<pre>
  typedef int (*spank_opt_cb_f) (int val, const char *optarg,
		                 int remote);

</pre>
<p>Where <em>val</em> is the value of the <em>val</em> field in the <strong>spank_option</strong> struct, <em>optarg</em> is the supplied argument if applicable, and <em>remote</em> is 0 if the function is being called from the "local" host (e.g. <strong>srun</strong>) or 1 from the "remote" host (<strong>slurmd</strong>).</p>
  </dd>

</dl>
<p>Plugin options may be registered with SLURM using the <strong>spank_option_register</strong> function. This function is only valid when called from the plugin's <strong>slurm_spank_init</strong> handler, and registers one option at a time. The prototype is</p>
<pre>
   spank_err_t spank_option_register (spank_t sp,
		   struct spank_option *opt);

</pre>
<p>This function will return <strong>ESPANK_SUCCESS</strong> on successful registration of an option, or <strong>ESPANK_BAD_ARG</strong> for errors including invalid spank_t handle, or when the function is not called from the <strong>slurm_spank_init</strong> function. All options need to be registered from all contexts in which they will be used. For instance, if an option is only used in local (srun) and remote (slurmd) contexts, then <strong>spank_option_register</strong> should only be called from within those contexts. For example:</p>
<pre>
   if (spank_context() != S_CTX_ALLOCATOR)
      spank_option_register (sp, opt);

</pre>
<p>If, however, the option is used in all contexts, the <strong>spank_option_register</strong> needs to be called everywhere.</p><p>In addition to <strong>spank_option_register</strong>, plugins may also export options to SLURM by defining a table of <strong>struct spank_option</strong> with the symbol name <strong>spank_options</strong>. This method, however, is not supported for use with <strong>sbatch</strong> and <strong>salloc</strong> (allocator context), thus the use of <strong>spank_option_register</strong> is preferred. When using the <strong>spank_options</strong> table, the final element in the array must be filled with zeros. A <strong>SPANK_OPTIONS_TABLE_END</strong> macro is provided in <strong>&lt;slurm/spank.h&gt;</strong> for this purpose.</p><p>When an option is provided by the user on the local side, <strong>SLURM</strong> will immediately invoke the option's callback with <em>remote</em>=0. This is meant for the plugin to do local sanity checking of the option before the value is sent to the remote side during job launch. If the argument the user specified is invalid, the plugin should issue an error and issue a non-zero return code from the callback.</p><p>On the remote side, options and their arguments are registered just after <strong>SPANK</strong> plugins are loaded and before the <strong>spank_init</strong> handler is called. This allows plugins to modify behavior of all plugin functionality based on the value of user-provided options. (See EXAMPLES below for a plugin that registers an option with <strong>SLURM</strong>).</p><p>As an alternative to use of an option callback and global variable, plugins can use the <strong>spank_option_getopt</strong> option to check for supplied options after option processing. This function has the prototype:</p>
<pre>
   spank_err_t spank_option_getopt(spank_t sp,
       struct spank_option *opt, char **optargp);

This function returns <strong>ESPANK_SUCCESS</strong> if the option defined in the
struct spank_option <em>opt</em> has been used by the user. If <em>optargp</em>
is non-NULL then it is set to any option argument passed (if the option
takes an argument). The use of this method is <em>required</em> to process
options in <strong>job_script</strong> context (<strong>slurm_spank_job_prolog</strong> and
<strong>slurm_spank_job_epilog</strong>).

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONFIGURATION</h2>
        <div class="sectioncontent">
<p>The default <strong>SPANK</strong> plug-in stack configuration file is <strong>plugstack.conf</strong> in the same directory as <a href="../man5/slurm.conf.5.html"><strong>slurm.conf</strong>(5)</a>, though this may be changed via the SLURM config parameter <em>PlugStackConfig</em>.  Normally the <strong>plugstack.conf</strong> file should be identical on all nodes of the cluster. The config file lists <strong>SPANK</strong> plugins, one per line, along with whether the plugin is <em>required</em> or <em>optional</em>, and any global arguments that are to be passed to the plugin for runtime configuration.  Comments are preceded with '#' and extend to the end of the line.  If the configuration file is missing or empty, it will simply be ignored.</p><p>The format of each non-comment line in the configuration file is: <strong></strong></p>
<pre>
  required/optional   plugin   arguments

</pre>
<p> For example:</p>
<pre>
  optional /usr/lib/slurm/test.so

</pre>
<p>Tells <strong>slurmd</strong> to load the plugin <strong>test.so</strong> passing no arguments. If a <strong>SPANK</strong> plugin is <em>required</em>, then failure of any of the plugin's functions will cause <strong>slurmd</strong> to terminate the job, while <em>optional</em> plugins only cause a warning.</p><p>If a fully-qualified path is not specified for a plugin, then the currently configured <em>PluginDir</em> in <a href="../man5/slurm.conf.5.html"><strong>slurm.conf</strong>(5)</a> is searched.</p><p><strong>SPANK</strong> plugins are stackable, meaning that more than one plugin may be placed into the config file. The plugins will simply be called in order, one after the other, and appropriate action taken on failure given that state of the plugin's <em>optional</em> flag.</p><p>Additional config files or directories of config files may be included in <strong>plugstack.conf</strong> with the <strong>include</strong> keyword. The <strong>include</strong> keyword must appear on its own line, and takes a glob as its parameter, so multiple files may be included from one <strong>include</strong> line. For example, the following syntax will load all config files in the /etc/slurm/plugstack.conf.d directory, in local collation order:</p>
<pre>
  include /etc/slurm/plugstack.conf.d/*

</pre>
<p>which might be considered a more flexible method for building up a spank plugin stack.</p><p>The <strong>SPANK</strong> config file is re-read on each job launch, so editing the config file will not affect running jobs. However care should be taken so that a partially edited config file is not read by a launching job.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>Simple <strong>SPANK</strong> config file:</p>
<pre>
#
# SPANK config file
#
# required?       plugin                     args
#
optional          renice.so                  min_prio=-10
required          /usr/lib/slurm/test.so

</pre>
<p>The following is a simple <strong>SPANK</strong> plugin to modify the nice value of job tasks. This plugin adds a --renice=[prio] option to <strong>srun</strong> which users can use to set the priority of all remote tasks. Priority may also be specified via a SLURM_RENICE environment variable. A minimum priority may be established via a "min_prio" parameter in <strong>plugstack.conf</strong> (See above for example).</p>
<pre>
/*
 *   To compile:
 *    gcc -shared -o renice.so renice.c
 *
 */
#include &lt;sys/types.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/resource.h&gt;

#include &lt;slurm/spank.h&gt;

/*
 * All spank plugins must define this macro for the
 * SLURM plugin loader.
 */
SPANK_PLUGIN(renice, 1);

#define PRIO_ENV_VAR "SLURM_RENICE"
#define PRIO_NOT_SET 42

/*
 * Minimum allowable value for priority. May be
 * set globally via plugin option min_prio=&lt;prio&gt;
 */
static int min_prio = -20;

static int prio = PRIO_NOT_SET;

static int _renice_opt_process (int val,
                                const char *optarg,
                                int remote);
static int _str2prio (const char *str, int *p2int);

/*
 *  Provide a --renice=[prio] option to srun:
 */
struct spank_option spank_options[] =
{
    { "renice", "[prio]",
      "Re-nice job tasks to priority [prio].", 2, 0,
      (spank_opt_cb_f) _renice_opt_process
    },
    SPANK_OPTIONS_TABLE_END
};

/*
 *  Called from both srun and slurmd.
 */
int slurm_spank_init (spank_t sp, int ac, char **av)
{
    int i;

    /* Don't do anything in sbatch/salloc */
    if (spank_context () == S_CTX_ALLOCATOR)
        return (0);

    for (i = 0; i &lt; ac; i++) {
        if (strncmp ("min_prio=", av[i], 9) == 0) {
            const char *optarg = av[i] + 9;
            if (_str2prio (optarg, &min_prio) &lt; 0)
                slurm_error ("Ignoring invalid min_prio value: %s",
                             av[i]);
        } else {
            slurm_error ("renice: Invalid option: %s", av[i]);
        }
    }

    if (!spank_remote (sp))
        slurm_verbose ("renice: min_prio = %d", min_prio);

    return (0);
}


int slurm_spank_task_post_fork (spank_t sp, int ac, char **av)
{
    pid_t pid;
    int taskid;

    if (prio == PRIO_NOT_SET) {
        /* See if SLURM_RENICE env var is set by user */
        char val [1024];

        if (spank_getenv (sp, PRIO_ENV_VAR, val, 1024)
            != ESPANK_SUCCESS)
            return (0);

        if (_str2prio (val, &prio) &lt; 0) {
            slurm_error ("Bad value for %s: %s",
                         PRIO_ENV_VAR, optarg);
            return (-1);
        }

        if (prio &lt; min_prio) {
            slurm_error ("%s=%d not allowed, using min=%d",
                         PRIO_ENV_VAR, prio, min_prio);
        }
    }

    if (prio &lt; min_prio)
        prio = min_prio;

    spank_get_item (sp, S_TASK_GLOBAL_ID, &taskid);
    spank_get_item (sp, S_TASK_PID, &pid);

    slurm_info ("re-nicing task%d pid %ld to %ld",
                taskid, pid, prio);

    if (setpriority (PRIO_PROCESS, (int) pid,
                     (int) prio) &lt; 0) {
        slurm_error ("setpriority: %m");
        return (-1);
    }

    return (0);
}

static int _str2prio (const char *str, int *p2int)
{
    long int l;
    char *p;

    l = strtol (str, &p, 10);
    if ((*p != '&nbsp;') || (l &lt; -20) || (l &gt; 20))
        return (-1);

    *p2int = (int) l;

    return (0);
}

static int _renice_opt_process (int val,
                                const char *optarg,
                                int remote)
{
    if (optarg == NULL) {
        slurm_error ("renice: invalid argument!");
        return (-1);
    }

    if (_str2prio (optarg, &prio) &lt; 0) {
        slurm_error ("Bad value for --renice: %s",
                     optarg);
        return (-1);
    }

    if (prio &lt; min_prio) {
        slurm_error ("--renice=%d not allowed, will use min=%d",
                     prio, min_prio);
    }

    return (0);
}

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYING</h2>
        <div class="sectioncontent">
<p>Copyright (C) 2006 The Regents of the University of California. Produced at Lawrence Livermore National Laboratory (cf, DISCLAIMER). CODE-OCEC-09-009. All rights reserved.</p><p>This file is part of SLURM, a resource management program. For details, see &lt;http://slurm.schedmd.com/&gt;.</p><p>SLURM is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.</p><p>SLURM is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILES</h2>
        <div class="sectioncontent">
<p><strong>/etc/slurm/slurm.conf</strong> - SLURM configuration file.</p><p><strong>/etc/slurm/plugstack.conf</strong> - SPANK configuration file.</p><p><strong>/usr/include/slurm/spank.h</strong> - SPANK header file.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO spank&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man1/srun.1.html"><strong>srun</strong>(1)</a>, <a href="../man5/slurm.conf.5.html"><strong>slurm.conf</strong>(5)</a></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="spacewalk-channel.8.html"><span aria-hidden="true">&larr;</span> spacewalk-channel.8: Subscribe to or unsubscribe system from channel.</a></li>
   <li class="next"><a href="spfqueue.8.html">spfqueue.8: A queue realtime scanner for mta <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>flashrom: Detect, read, write, verify and erase flash chips</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Detect, read, write, verify and erase flash chips">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="flashrom (8) manual">
  <meta name="twitter:description" content="Detect, read, write, verify and erase flash chips">
  <meta name="twitter:image" content="https://www.carta.tech/images/flashrom-flashrom-8.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man8/flashrom.8.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="flashrom (8) manual" />
  <meta property="og:description" content="Detect, read, write, verify and erase flash chips" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/flashrom-flashrom-8.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">flashrom<small> (8)</small></h1>
        <p class="lead">Detect, read, write, verify and erase flash chips</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man8/">
      <span itemprop="name">System administration commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man8/flashrom.8.html">
      <span itemprop="name">flashrom: Detect, read, write, verify and erase flash chips</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/flashrom/">
      <span itemprop="name">flashrom</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man8/flashrom.8.html">
      <span itemprop="name">flashrom: Detect, read, write, verify and erase flash chips</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>flashrom </strong>[<strong>-h</strong>|<strong>-R</strong>|<strong>-L</strong>|<strong>-z</strong>| <strong>-p</strong> &lt;programmername&gt;[:&lt;parameters&gt;]</p>
<pre>
               [<strong>-E</strong>|<strong>-r</strong> &lt;file&gt;|<strong>-w</strong> &lt;file&gt;|<strong>-v</strong> &lt;file&gt;]  [<strong>-c</strong> &lt;chipname&gt;]
               [<strong>-l</strong> &lt;file&gt; [<strong>-i</strong> &lt;image&gt;]] [<strong>-n</strong>] [<strong>-f</strong>]]
         [<strong>-V</strong>[<strong>V</strong>[<strong>V</strong>]]] [<strong>-o</strong> &lt;logfile&gt;]
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><strong>flashrom</strong> is a utility for detecting, reading, writing, verifying and erasing flash chips. It's often used to flash BIOS/EFI/coreboot/firmware images in-system using a supported mainboard. However, it also supports various external PCI/USB/parallel-port/serial-port based devices which can program flash chips, including some network cards (NICs), SATA/IDE controller cards, graphics cards, the Bus Pirate device, various FTDI FT2232/FT4232H/FT232H based USB devices, and more.</p><p>It supports a wide range of DIP32, PLCC32, DIP8, SO8/SOIC8, TSOP32, TSOP40, TSOP48, and BGA chips, which use various protocols such as LPC, FWH, parallel flash, or SPI.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONS</h2>
        <div class="sectioncontent">
<p><strong>IMPORTANT:</strong> Please note that the command line interface for flashrom will change before flashrom 1.0. Do not use flashrom in scripts or other automated tools without checking that your flashrom version won't interpret options in a different way.</p><p>You can specify one of <strong>-h</strong>, <strong>-R</strong>, <strong>-L</strong>, <strong>-z</strong>, <strong>-E</strong>, <strong>-r</strong>, <strong>-w</strong>, <strong>-v</strong> or no operation. If no operation is specified, flashrom will only probe for flash chips. It is recommended that if you try flashrom the first time on a system, you run it in probe-only mode and check the output. Also you are advised to make a backup of your current ROM contents with <strong>-r</strong> before you try to write a new image. All operations involving any chip access (probe/read/write/...) require the <strong>-p/--programmer</strong> option to be used (please see below).</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>-r, --read &lt;file&gt;</strong></p>
  </dt>
  <dd>
    <p>Read flash ROM contents and save them into the given <strong>&lt;file&gt;</strong>. If the file already exists, it will be overwritten.</p>
  </dd>
  <dt>
    <p><strong>-w, --write &lt;file&gt;</strong></p>
  </dt>
  <dd>
    <p>Write <strong>&lt;file&gt;</strong> into flash ROM. This will first automatically <strong>erase</strong> the chip, then write to it.</p><p>In the process the chip is also read several times. First an in-memory backup is made for disaster recovery and to be able to skip regions that are already equal to the image file. This copy is updated along with the write operation. In case of erase errors it is even re-read completely. After writing has finished and if verification is enabled, the whole flash chip is read out and compared with the input image.</p>
  </dd>
  <dt>
    <p><strong>-n, --noverify</strong></p>
  </dt>
  <dd>
    <p>Skip the automatic verification of flash ROM contents after writing. Using this option is <strong>not</strong> recommended, you should only use it if you know what you are doing and if you feel that the time for verification takes too long.</p><p>Typical usage is: <strong>flashrom -p prog -n -w &lt;file&gt;</strong></p><p>This option is only useful in combination with <strong>--write</strong>.</p>
  </dd>
  <dt>
    <p><strong>-v, --verify &lt;file&gt;</strong></p>
  </dt>
  <dd>
    <p>Verify the flash ROM contents against the given <strong>&lt;file&gt;</strong>.</p>
  </dd>
  <dt>
    <p><strong>-E, --erase</strong></p>
  </dt>
  <dd>
    <p>Erase the flash ROM chip.</p>
  </dd>
  <dt>
    <p><strong>-V, --verbose</strong></p>
  </dt>
  <dd>
    <p>More verbose output. This option can be supplied multiple times (max. 3 times, i.e. <strong>-VVV</strong>) for even more debug output.</p>
  </dd>
  <dt>
    <p><strong>-c, --chip &lt;chipname&gt;</strong></p>
  </dt>
  <dd>
    <p>Probe only for the specified flash ROM chip. This option takes the chip name as printed by <strong>flashrom -L</strong> without the vendor name as parameter. Please note that the chip name is case sensitive.</p>
  </dd>
  <dt>
    <p><strong>-f, --force</strong></p>
  </dt>
  <dd>
    <p>Force one or more of the following actions:</p><p>* Force chip read and pretend the chip is there.</p><p>* Force chip access even if the chip is bigger than the maximum supported  size for the flash bus.</p><p>* Force erase even if erase is known bad.</p><p>* Force write even if write is known bad.</p>
  </dd>
  <dt>
    <p><strong>-l, --layout &lt;file&gt;</strong></p>
  </dt>
  <dd>
    <p>Read ROM layout from <strong>&lt;file&gt;</strong>.</p><p>flashrom supports ROM layouts. This allows you to flash certain parts of the flash chip only. A ROM layout file contains multiple lines with the following syntax:</p><p><strong>  startaddr:endaddr imagename</strong></p><p><strong>startaddr </strong>and <strong>endaddr </strong> are hexadecimal addresses within the ROM file and do not refer to any physical address. Please note that using a 0x prefix for those hexadecimal numbers is not necessary, but you can't specify decimal/octal numbers. <strong>imagename </strong>is an arbitrary name for the region/image from <strong> startaddr </strong>to <strong>endaddr </strong>(both addresses included).</p><p>Example:</p>
<pre>
  00000000:00008fff gfxrom
  00009000:0003ffff normal
  00040000:0007ffff fallback
</pre>
<p>If you only want to update the image named <strong>normal </strong>in a ROM based on the layout above, run</p><p><strong>  flashrom -p prog --layout rom.layout --image normal -w some.rom</strong></p><p>To update only the images named <strong>normal </strong>and <strong>fallback</strong>, run:</p><p><strong>  flashrom -p prog -l rom.layout -i normal -i fallback -w some.rom</strong></p><p>Overlapping sections are not supported.</p>
  </dd>
  <dt>
    <p><strong>-i, --image &lt;imagename&gt;</strong></p>
  </dt>
  <dd>
    <p>Only flash region/image <strong>&lt;imagename&gt;</strong> from flash layout.</p>
  </dd>
  <dt>
    <p><strong>-L, --list-supported</strong></p>
  </dt>
  <dd>
    <p>List the flash chips, chipsets, mainboards, and external programmers (including PCI, USB, parallel port, and serial port based devices) supported by flashrom.</p><p>There are many unlisted boards which will work out of the box, without special support in flashrom. Please let us know if you can verify that other boards work or do not work out of the box.</p><p><strong>IMPORTANT:</strong> For verification you have to test an ERASE and/or WRITE operation, so make sure you only do that if you have proper means to recover from failure!</p>
  </dd>
  <dt>
    <p><strong>-z, --list-supported-wiki</strong></p>
  </dt>
  <dd>
    <p>Same as <strong>--list-supported</strong>, but outputs the supported hardware in MediaWiki syntax, so that it can be easily pasted into the wiki page at <strong>http://www.flashrom.org/</strong>. Please note that MediaWiki output is not compiled in by default.</p>
  </dd>
  <dt>
    <p><strong>-p, --programmer &lt;name&gt;[:parameter[,parameter[,parameter]]]</strong></p>
  </dt>
  <dd>
    <p>Specify the programmer device. This is mandatory for all operations involving any chip access (probe/read/write/...). Currently supported are:</p><p><strong>* internal</strong> (default, for in-system flashing in the mainboard)</p><p><strong>* dummy</strong> (virtual programmer for testing flashrom)</p><p><strong>* nic3com</strong> (for flash ROMs on 3COM network cards)</p><p><strong>* nicrealtek</strong> (for flash ROMs on Realtek and SMC 1211 network cards)</p><p><strong>* nicnatsemi</strong> (for flash ROMs on National Semiconductor DP838* network  cards)</p><p><strong>* nicintel</strong> (for parallel flash ROMs on Intel 10/100Mbit network cards)</p><p><strong>* gfxnvidia</strong> (for flash ROMs on NVIDIA graphics cards)</p><p><strong>* drkaiser</strong> (for flash ROMs on Dr. Kaiser PC-Waechter PCI cards)</p><p><strong>* satasii</strong> (for flash ROMs on Silicon Image SATA/IDE controllers)</p><p><strong>* satamv</strong> (for flash ROMs on Marvell SATA controllers)</p><p><strong>* atahpt</strong> (for flash ROMs on Highpoint ATA/RAID controllers)</p><p><strong>* ft2232_spi</strong> (for SPI flash ROMs attached to an FT2232/FT4232H/FT232H family  based USB SPI programmer), including the DLP Design DLP-USB1232H,  FTDI FT2232H Mini-Module, FTDI FT4232H Mini-Module, openbiosprog-spi, Amontec  JTAGkey/JTAGkey-tiny/JTAGkey-2, Dangerous Prototypes Bus Blaster,  Olimex ARM-USB-TINY/-H, Olimex ARM-USB-OCD/-H, TIAO/DIYGADGET USB Multi-Protocol Adapter (TUMPA), TUMPA Lite, and GOEPEL PicoTAP.</p><p><strong>* serprog</strong> (for flash ROMs attached to a programmer speaking serprog),  including AVR flasher by Urja Rannikko, AVR flasher by eightdot,  Arduino Mega flasher by fritz, InSystemFlasher by Juhana Helovuo, and  atmegaXXu2-flasher by Stefan Tauner.</p><p><strong>* buspirate_spi</strong> (for SPI flash ROMs attached to a Bus Pirate)</p><p><strong>* dediprog</strong> (for SPI flash ROMs attached to a Dediprog SF100)</p><p><strong>* rayer_spi</strong> (for SPI flash ROMs attached to a parallel port by one of various cable types)</p><p><strong>* pony_spi</strong> (for SPI flash ROMs attached to a SI-Prog serial port  bitbanging adapter)</p><p><strong>* nicintel_spi</strong> (for SPI flash ROMs on Intel Gigabit network cards)</p><p><strong>* ogp_spi</strong> (for SPI flash ROMs on Open Graphics Project graphics card)</p><p><strong>* linux_spi</strong> (for SPI flash ROMs accessible via /dev/spidevX.Y on Linux)</p><p><strong>* usbblaster_spi</strong> (for SPI flash ROMs attached to an Altera USB-Blaster compatible cable)</p><p>Some programmers have optional or mandatory parameters which are described in detail in the <strong>PROGRAMMER SPECIFIC INFO</strong> section. Support for some programmers can be disabled at compile time. <strong>flashrom -h</strong> lists all supported programmers.</p>
  </dd>
  <dt>
    <p><strong>-h, --help</strong></p>
  </dt>
  <dd>
    <p>Show a help text and exit.</p>
  </dd>
  <dt>
    <p><strong>-o, --output &lt;logfile&gt;</strong></p>
  </dt>
  <dd>
    <p>Save the full debug log to <strong>&lt;logfile&gt;</strong>. If the file already exists, it will be overwritten. This is the recommended way to gather logs from flashrom because they will be verbose even if the on-screen messages are not verbose.</p>
  </dd>
  <dt>
    <p><strong>-R, --version</strong></p>
  </dt>
  <dd>
    <p>Show version information and exit.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PROGRAMMER SPECIFIC INFO</h2>
        <div class="sectioncontent">
<p>Some programmer drivers accept further parameters to set programmer-specific parameters. These parameters are separated from the programmer name by a colon. While some programmers take arguments at fixed positions, other programmers use a key/value interface in which the key and value is separated by an equal sign and different pairs are separated by a comma or a colon.</p><h3></h3>
<p><strong>internal </strong>programmer</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>Board Enables</strong></p>
  </dt>
  <dd>
    <p>Some mainboards require to run mainboard specific code to enable flash erase and write support (and probe support on old systems with parallel flash). The mainboard brand and model (if it requires specific code) is usually autodetected using one of the following mechanisms: If your system is running coreboot, the mainboard type is determined from the coreboot table. Otherwise, the mainboard is detected by examining the onboard PCI devices and possibly DMI info. If PCI and DMI do not contain information to uniquely identify the mainboard (which is the exception), or if you want to override the detected mainboard model, you can specify the mainboard using the</p><p><strong>  flashrom -p internal:mainboard=&lt;vendor&gt;:&lt;board&gt;</strong> syntax.</p><p>See the 'Known boards' or 'Known laptops' section in the output of 'flashrom -L' for a list of boards which require the specification of the board name, if no coreboot table is found.</p><p>Some of these board-specific flash enabling functions (called <strong>board enables</strong>) in flashrom have not yet been tested. If your mainboard is detected needing an untested board enable function, a warning message is printed and the board enable is not executed, because a wrong board enable function might cause the system to behave erratically, as board enable functions touch the low-level internals of a mainboard. Not executing a board enable function (if one is needed) might cause detection or erasing failure. If your board protects only part of the flash (commonly the top end, called boot block), flashrom might encounter an error only after erasing the unprotected part, so running without the board-enable function might be dangerous for erase and write (which includes erase).</p><p>The suggested procedure for a mainboard with untested board specific code is to first try to probe the ROM (just invoke flashrom and check that it detects your flash chip type) without running the board enable code (i.e. without any parameters). If it finds your chip, fine. Otherwise, retry probing your chip with the board-enable code running, using</p><p><strong>  flashrom -p internal:boardenable=force</strong></p><p>If your chip is still not detected, the board enable code seems to be broken or the flash chip unsupported. Otherwise, make a backup of your current ROM contents (using <strong>-r</strong>) and store it to a medium outside of your computer, like a USB drive or a network share. If you needed to run the board enable code already for probing, use it for reading too. If reading succeeds and the contens of the read file look legit you can try to write the new image. You should enable the board enable code in any case now, as it has been written because it is known that writing/erasing without the board enable is going to fail. In any case (success or failure), please report to the flashrom mailing list, see below.</p>
  </dd>
  <dt>
    <p><strong>Coreboot</strong></p>
  </dt>
  <dd>
    <p>On systems running coreboot, flashrom checks whether the desired image matches your mainboard. This needs some special board ID to be present in the image. If flashrom detects that the image you want to write and the current board do not match, it will refuse to write the image unless you specify</p><p><strong>  flashrom -p internal:boardmismatch=force</strong></p>
  </dd>
  <dt>
    <p><strong>ITE IT87 Super I/O</strong></p>
  </dt>
  <dd>
    <p>If your mainboard is manufactured by GIGABYTE and supports DualBIOS it is very likely that it uses an ITE IT87 series Super I/O to switch between the two flash chips. Only one of them can be accessed at a time and you can manually select which one to use with the</p><p><strong>  flashrom -p internal:dualbiosindex=chip</strong></p><p>syntax where <strong>chip</strong> is the index of the chip to use (0 = main, 1 = backup). You can check which one is currently selected by leaving out the <strong>chip</strong> parameter.</p><p>If your mainboard uses an ITE IT87 series Super I/O for LPC&lt;-&gt;SPI flash bus translation, flashrom should autodetect that configuration. If you want to set the I/O base port of the IT87 series SPI controller manually instead of using the value provided by the BIOS, use the</p><p><strong>  flashrom -p internal:it87spiport=portnum</strong></p><p>syntax where <strong>portnum</strong> is the I/O port number (must be a multiple of 8). In the unlikely case flashrom doesn't detect an active IT87 LPC&lt;-&gt;SPI bridge, please send a bug report so we can diagnose the problem.</p>
  </dd>
  <dt>
    <p><strong>AMD chipsets</strong></p>
  </dt>
  <dd>
    <p>Beginning with the SB700 chipset there is an integrated microcontroller (IMC) based on the 8051 embedded in every AMD southbridge. Its firmware resides in the same flash chip as the host's which makes writing to the flash risky if the IMC is active. Flashrom tries to temporarily disable the IMC but even then changing the contents of the flash can have unwanted effects: when the IMC continues (at the latest after a reboot) it will continue executing code from the flash. If the code was removed or changed in an unfortunate way it is unpredictable what the IMC will do. Therefore, if flashrom detects an active IMC it will disable write support unless the user forces it with the</p><p><strong>  flashrom -p internal:amd_imc_force=yes</strong></p><p>syntax. The user is responsible for supplying a suitable image or leaving out the IMC region with the help of a layout file. This limitation might be removed in the future when we understand the details better and have received enough feedback from users. Please report the outcome if you had to use this option to write a chip.</p>
  </dd>
  <dt>
    <p><strong>Intel chipsets</strong></p>
  </dt>
  <dd>
    <p>If you have an Intel chipset with an ICH8 or later southbridge with SPI flash attached, and if a valid descriptor was written to it (e.g. by the vendor), the chipset provides an alternative way to access the flash chip(s) named <strong>Hardware Sequencing</strong>. It is much simpler than the normal access method (called <strong>Software Sequencing</strong>), but does not allow the software to choose the SPI commands to be sent. You can use the</p><p><strong>  flashrom -p internal:ich_spi_mode=value</strong></p><p>syntax where <strong>value </strong>can be <strong>auto</strong>, <strong>swseq</strong> or <strong>hwseq</strong>. By default (or when setting <strong>ich_spi_mode=auto</strong>) the module tries to use swseq and only activates hwseq if need be (e.g. if important opcodes are inaccessible due to lockdown; or if more than one flash chip is attached). The other options (swseq, hwseq) select the respective mode (if possible).</p><p>ICH8 and later southbridges may also have locked address ranges of different kinds if a valid descriptor was written to it. The flash address space is then partitioned in multiple so called "Flash Regions" containing the host firmware, the ME firmware and so on respectively. The flash descriptor can also specify up to 5 so called "Protected Regions", which are freely chosen address ranges independent from the aforementioned "Flash Regions". All of them can be write and/or read protected individually. If flashrom detects such a lock it will disable write support unless the user forces it with the</p><p><strong>  flashrom -p internal:ich_spi_force=yes</strong></p><p>syntax. If this leads to erase or write accesses to the flash it would most probably bring it into an inconsistent and unbootable state and we will not provide any support in such a case.</p><p>If you have an Intel chipset with an ICH2 or later southbridge and if you want to set specific IDSEL values for a non-default flash chip or an embedded controller (EC), you can use the</p><p><strong>  flashrom -p internal:fwh_idsel=value</strong></p><p>syntax where <strong>value</strong> is the 48-bit hexadecimal raw value to be written in the IDSEL registers of the Intel southbridge. The upper 32 bits use one hex digit each per 512 kB range between 0xffc00000 and 0xffffffff, and the lower 16 bits use one hex digit each per 1024 kB range between 0xff400000 and 0xff7fffff. The rightmost hex digit corresponds with the lowest address range. All address ranges have a corresponding sister range 4 MB below with identical IDSEL settings. The default value for ICH7 is given in the example below.</p><p>Example: <strong>flashrom -p internal:fwh_idsel=0x001122334567</strong></p>
  </dd>
  <dt>
    <p><strong>Laptops</strong></p>
  </dt>
  <dd>
    <p>Using flashrom on laptops is dangerous and may easily make your hardware unusable (see also the <strong>BUGS</strong> section). The embedded controller (EC) in these machines often interacts badly with flashing. <strong>http://www.flashrom.org/Laptops</strong> has more information. For example the EC firmware sometimes resides on the same flash chip as the host firmware. While flashrom tries to change the contents of that memory the EC might need to fetch new instructions or data from it and could stop working correctly. Probing for and reading from the chip may also irritate your EC and cause fan failure, backlight failure, sudden poweroff, and other nasty effects. flashrom will attempt to detect if it is running on a laptop and abort immediately for safety reasons if it clearly identifies the host computer as one. If you want to proceed anyway at your own risk, use</p><p><strong>  flashrom -p internal:laptop=force_I_want_a_brick</strong></p><p>We will not help you if you force flashing on a laptop because this is a really dumb idea.</p><p>You have been warned.</p><p>Currently we rely on the chassis type encoded in the DMI/SMBIOS data to detect laptops. Some vendors did not implement those bits correctly or set them to generic and/or dummy values. flashrom will then issue a warning and bail out like above. In this case you can use</p><p><strong>  flashrom -p internal:laptop=this_is_not_a_laptop</strong></p><p>to tell flashrom (at your own risk) that it does not running on a laptop.</p>
  </dd>

</dl>

<h3></h3>
<p><strong>dummy </strong>programmer The dummy programmer operates on a buffer in memory only. It provides a safe and fast way to test various aspects of flashrom and is mainly used in development and while debugging.</p><p>It is able to emulate some chips to a certain degree (basic identify/read/erase/write operations work).</p><p>An optional parameter specifies the bus types it should support. For that you have to use the</p><p><strong>  flashrom -p dummy:bus=[type[+type[+type]]]</strong></p><p>syntax where <strong>type</strong> can be <strong>parallel</strong>, <strong>lpc</strong>, <strong>fwh</strong>, <strong>spi</strong> in any order. If you specify bus without type, all buses will be disabled. If you do not specify bus, all buses will be enabled.</p><p>Example: <strong>flashrom -p dummy:bus=lpc+fwh</strong></p><p>The dummy programmer supports flash chip emulation for automated self-tests without hardware access. If you want to emulate a flash chip, use the</p><p><strong>  flashrom -p dummy:emulate=chip</strong></p><p>syntax where <strong>chip</strong> is one of the following chips (please specify only the chip name, not the vendor):</p><p>* ST <strong>M25P10.RES</strong> SPI flash chip (RES, page write)</p><p>* SST <strong>SST25VF040.REMS</strong> SPI flash chip (REMS, byte write)</p><p>* SST <strong>SST25VF032B</strong> SPI flash chip (RDID, AAI write)</p><p>* Macronix <strong>MX25L6436</strong> SPI flash chip (RDID, SFDP)</p><p>Example: <strong>flashrom -p dummy:emulate=SST25VF040.REMS</strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>Persistent images</strong></p>
  </dt>
  <dd>
    <p>If you use flash chip emulation, flash image persistence is available as well by using the</p><p><strong>  flashrom -p dummy:emulate=chip,image=image.rom</strong></p><p>syntax where <strong>image.rom</strong> is the file where the simulated chip contents are read on flashrom startup and where the chip contents on flashrom shutdown are written to.</p><p>Example: <strong>flashrom -p dummy:emulate=M25P10.RES,image=dummy.bin</strong></p>
  </dd>
  <dt>
    <p><strong>SPI write chunk size</strong></p>
  </dt>
  <dd>
    <p>If you use SPI flash chip emulation for a chip which supports SPI page write with the default opcode, you can set the maximum allowed write chunk size with the</p><p><strong>  flashrom -p dummy:emulate=chip,spi_write_256_chunksize=size</strong></p><p>syntax where <strong>size</strong> is the number of bytes (min. 1, max. 256).</p><p>Example:</p><p><strong>  flashrom -p dummy:emulate=M25P10.RES,spi_write_256_chunksize=5</strong></p>
  </dd>
  <dt>
    <p><strong>SPI blacklist</strong></p>
  </dt>
  <dd>
    <p>To simulate a programmer which refuses to send certain SPI commands to the flash chip, you can specify a blacklist of SPI commands with the</p><p><strong>  flashrom -p dummy:spi_blacklist=commandlist</strong></p><p>syntax where <strong>commandlist</strong> is a list of two-digit hexadecimal representations of SPI commands. If commandlist is e.g. 0302, flashrom will behave as if the SPI controller refuses to run command 0x03 (READ) and command 0x02 (WRITE). commandlist may be up to 512 characters (256 commands) long. Implementation note: flashrom will detect an error during command execution.</p>
  </dd>
  <dt>
    <p><strong>SPI ignorelist</strong></p>
  </dt>
  <dd>
    <p>To simulate a flash chip which ignores (doesn't support) certain SPI commands, you can specify an ignorelist of SPI commands with the</p><p><strong>  flashrom -p dummy:spi_ignorelist=commandlist</strong></p><p>syntax where <strong>commandlist</strong> is a list of two-digit hexadecimal representations of SPI commands. If commandlist is e.g. 0302, the emulated flash chip will ignore command 0x03 (READ) and command 0x02 (WRITE).  commandlist may be up to 512 characters (256 commands) long. Implementation note: flashrom won't detect an error during command execution.</p>
  </dd>
  <dt>
    <p><strong>SPI status register</strong></p>
  </dt>
  <dd>
    <p>You can specify the initial content of the chip's status register with the</p><p><strong>  flashrom -p dummy:spi_status=content</strong></p><p>syntax where <strong>content</strong> is an 8-bit hexadecimal value.</p>
  </dd>

</dl>

<h3></h3>
<p><strong>nic3com</strong>,<strong> nicrealtek</strong>,<strong> nicnatsemi</strong>,<strong> nicintel </strong>,<strong> nicintel_spi</strong>,<strong> gfxnvidia</strong>,<strong> ogp_spi</strong>,<strong> drkaiser</strong>,<strong> satasii </strong>,<strong> satamv</strong>, and <strong>atahpt</strong> programmers These programmers have an option to specify the PCI address of the card your want to use, which must be specified if more than one card supported by the selected programmer is installed in your system. The syntax is</p><p><strong>  flashrom -p xxxx:pci=bb:dd.f</strong>,</p><p>where <strong>xxxx</strong> is the name of the programmer <strong>bb</strong> is the PCI bus number, <strong>dd</strong> is the PCI device number, and <strong>f</strong> is the PCI function number of the desired device.</p><p>Example: <strong>flashrom -p nic3com:pci=05:04.0</strong></p>
<h3></h3>
<p><strong>ft2232_spi </strong>programmer An optional parameter specifies the controller type and channel/interface/port it should support. For that you have to use the</p><p><strong>  flashrom -p ft2232_spi:type=model,port=interface</strong></p><p>syntax where <strong>model</strong> can be <strong>2232H</strong>, <strong>4232H</strong>, <strong>232H</strong>, <strong>jtagkey</strong>, <strong>busblaster</strong>, <strong>openmoko</strong>, <strong>arm-usb-tiny</strong>, <strong>arm-usb-tiny-h</strong>, <strong>arm-usb-ocd</strong>, <strong>arm-usb-ocd-h</strong>, <strong>tumpa</strong>, <strong>tumpalite</strong>, or <strong>picotap</strong> and <strong>interface</strong> can be <strong>A</strong>, <strong>B</strong>, <strong>C</strong>, or <strong>D</strong>. The default model is <strong>4232H</strong> and the default interface is <strong>A</strong>.</p><p>If there is more than one ft2232_spi-compatible device connected, you can select which one should be used by specifying its serial number with the</p><p><strong>  flashrom -p ft2232_spi:serial=number</strong></p><p>syntax where <strong>number</strong> is the serial number of the device (which can be found for example in the output of lsusb -v).</p><p>All models supported by the ft2232_spi driver can configure the SPI clock rate by setting a divisor. The expressible divisors are all <strong>even</strong> numbers between 2 and 2^17 (=131072) resulting in SPI clock frequencies of 6 MHz down to about 92 Hz for 12 MHz inputs. The default divisor is set to 2, but you can use another one by specifying the optional <strong>divisor</strong> parameter with the</p><p><strong>  flashrom -p ft2232_spi:divisor=div</strong></p><p>syntax.</p>
<h3></h3>
<p><strong>serprog </strong>programmer A mandatory parameter specifies either a serial device/baud combination or an IP/port combination for communication with the programmer. In the device/baud combination, the device has to start with a slash. For serial, you have to use the</p><p><strong>  flashrom -p serprog:dev=/dev/device:baud</strong></p><p>syntax and for IP, you have to use</p><p><strong>  flashrom -p serprog:ip=ipaddr:port</strong></p><p>instead. In case the device supports it, you can set the SPI clock frequency with the optional <strong>spispeed</strong> parameter. The frequency is parsed as hertz, unless an <strong>M</strong>, or <strong>k</strong> suffix is given, then megahertz or kilohertz are used respectively. Example that sets the frequency to 2 MHz:</p><p><strong>  flashrom -p serprog:dev=/dev/device:baud,spispeed=2M</strong></p><p>More information about serprog is available in <strong>serprog-protocol.txt</strong> in the source distribution.</p>
<h3></h3>
<p><strong>buspirate_spi </strong>programmer A required <strong>dev</strong> parameter specifies the Bus Pirate device node and an optional <strong>spispeed</strong> parameter specifies the frequency of the SPI bus. The parameter delimiter is a comma. Syntax is</p><p><strong>  flashrom -p buspirate_spi:dev=/dev/device,spispeed=frequency</strong></p><p>where <strong>frequency</strong> can be <strong>30k</strong>, <strong>125k</strong>, <strong>250k</strong>, <strong>1M</strong>, <strong>2M</strong>, <strong>2.6M</strong>, <strong>4M</strong> or <strong>8M</strong> (in Hz). The default is the maximum frequency of 8 MHz.</p><p>An optional pullups parameter specifies the use of the Bus Pirate internal pull-up resistors. This may be needed if you are working with a flash ROM chip that you have physically removed from the board. Syntax is</p><p><strong>  flashrom -p buspirate_spi:pullups=state</strong></p><p>where <strong>state</strong> can be <strong>on</strong> or <strong>off</strong>. More information about the Bus Pirate pull-up resistors and their purpose is available at <strong>http://dangerousprototypes.com/docs/Practical_guide_to_Bus_Pirate_pull-up_resistors </strong>. Only the external supply voltage (Vpu) is supported as of this writing.</p>
<h3></h3>
<p><strong>dediprog </strong>programmer An optional <strong>voltage</strong> parameter specifies the voltage the Dediprog should use. The default unit is Volt if no unit is specified. You can use <strong>mV</strong>, <strong>milliVolt</strong>, <strong>V</strong> or <strong>Volt</strong> as unit specifier. Syntax is</p><p><strong>  flashrom -p dediprog:voltage=value</strong></p><p>where <strong>value</strong> can be <strong>0V</strong>, <strong>1.8V</strong>, <strong>2.5V</strong>, <strong>3.5V</strong> or the equivalent in mV.</p><p>An optional <strong>device</strong> parameter specifies which of multiple connected Dediprog devices should be used. Please be aware that the order depends on libusb's usb_get_busses() function and that the numbering starts at 0. Usage example to select the second device:</p><p><strong>  flashrom -p dediprog:device=1</strong></p><p>An optional <strong>spispeed</strong> parameter specifies the frequency of the SPI bus. The firmware on the device needs to be 5.0.0 or newer. Syntax is</p><p><strong>  flashrom -p dediprog:spispeed=frequency</strong></p><p>where <strong>frequency</strong> can be <strong>375k</strong>, <strong>750k</strong>, <strong>1.5M</strong>, <strong>2.18M</strong>, <strong>3M</strong>, <strong>8M</strong>, <strong>12M</strong> or <strong>24M</strong> (in Hz). The default is a frequency of 12 MHz.</p><p>An optional <strong>target</strong> parameter specifies which target chip should be used. Syntax is</p><p><strong>  flashrom -p dediprog:target=value</strong></p><p>where <strong>value</strong> can be <strong>1</strong> or <strong>2</strong> to select target chip 1 or 2 repectively. The default is target chip 1.</p>
<h3></h3>
<p><strong>rayer_spi </strong>programmer The default I/O base address used for the parallel port is 0x378 and you can use the optional <strong>iobase</strong> parameter to specify an alternate base I/O address with the</p><p><strong>  flashrom -p rayer_spi:iobase=baseaddr</strong></p><p>syntax where <strong>baseaddr</strong> is base I/O port address of the parallel port, which must be a multiple of four. Make sure to not forget the "0x" prefix for hexadecimal port addresses.</p><p>The default cable type is the RayeR cable. You can use the optional <strong>type</strong> parameter to specify the cable type with the</p><p><strong>  flashrom -p rayer_spi:type=model</strong></p><p>syntax where <strong>model</strong> can be <strong>rayer</strong> for the RayeR cable, <strong>byteblastermv</strong> for the Altera ByteBlasterMV, <strong>stk200</strong> for the Atmel  STK200/300, <strong>wiggler</strong> for the Macraigor Wiggler, or <strong>xilinx</strong> for the Xilinx Parallel Cable III (DLC 5).</p><p>More information about the RayeR hardware is available at <strong>http://rayer.ic.cz/elektro/spipgm.htm </strong>. The Altera ByteBlasterMV datasheet can be obtained from <strong>http://www.altera.co.jp/literature/ds/dsbytemv.pdf </strong>. For more information about the Macraigor Wiggler see <strong>http://www.macraigor.com/wiggler.htm </strong>. The schematic of the Xilinx DLC 5 was published in <strong>http://www.xilinx.com/support/documentation/user_guides/xtp029.pdf </strong>.</p>
<h3></h3>
<p><strong>pony_spi </strong>programmer The serial port (like /dev/ttyS0, /dev/ttyUSB0 on Linux or COM3 on windows) is specified using the mandatory <strong>dev</strong> parameter. The adapter type is selectable between SI-Prog (used for SPI devices with PonyProg 2000) or a custom made serial bitbanging programmer named "serbang". The optional <strong>type</strong> parameter accepts the values "si_prog" (default) or "serbang".</p><p>Information about the SI-Prog adapter can be found at <strong>http://www.lancos.com/siprogsch.html </strong>.</p><p>An example call to flashrom is</p><p><strong>  flashrom -p pony_spi:dev=/dev/ttyS0,type=serbang</strong></p><p>Please note that while USB-to-serial adapters work under certain circumstances, this slows down operation considerably.</p>
<h3></h3>
<p><strong>ogp_spi </strong>programmer The flash ROM chip to access must be specified with the <strong>rom</strong> parameter.</p><p><strong>  flashrom -p ogp_spi:rom=name</strong></p><p>Where <strong>name</strong> is either <strong>cprom</strong> or <strong>s3</strong> for the configuration ROM and <strong>bprom</strong> or <strong>bios</strong> for the BIOS ROM. If more than one card supported by the ogp_spi programmer is installed in your system, you have to specify the PCI address of the card you want to use with the <strong>pci=</strong> parameter as explained in the <strong>nic3com et al.</strong> section above.</p><p>More information about the hardware is available at <strong>http://wiki.opengraphics.org</strong>.</p>
<h3></h3>
<p><strong>linux_spi </strong>programmer You have to specify the SPI controller to use with the</p><p><strong>  flashrom -p linux_spi:dev=/dev/spidevX.Y</strong></p><p>syntax where <strong>/dev/spidevX.Y</strong> is the Linux device node for your SPI controller.</p><p>In case the device supports it, you can set the SPI clock frequency with the optional <strong>spispeed</strong> parameter. The frequency is parsed as kilohertz. Example that sets the frequency to 8 MHz:</p><p><strong>  flashrom -p linux_spi:dev=/dev/spidevX.Y,spispeed=8000</strong></p><p>Please note that the linux_spi driver only works on Linux.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>To back up and update your BIOS, run</p><p><strong>flashrom -p internal -r backup.rom -o backuplog.txt</strong></p><p><strong>flashrom -p internal -w newbios.rom -o writelog.txt</strong></p><p>Please make sure to copy backup.rom to some external media before you try to write. That makes offline recovery easier.</p><p>If writing fails and flashrom complains about the chip being in an unknown state, you can try to restore the backup by running</p><p><strong>flashrom -p internal -w backup.rom -o restorelog.txt</strong></p><p>If you encounter any problems, please contact us and supply backuplog.txt, writelog.txt and restorelog.txt. See section <strong>BUGS</strong> for contact info.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXIT STATUS</h2>
        <div class="sectioncontent">
<p>flashrom exits with 0 on success, 1 on most failures but with 3 if a call to mmap() fails.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REQUIREMENTS</h2>
        <div class="sectioncontent">
<p>flashrom needs different access permissions for different programmers.</p><p><strong>internal</strong> needs raw memory access, PCI configuration space access, raw I/O port access (x86) and MSR access (x86).</p><p><strong>nic3com</strong>, <strong>nicrealtek</strong> and <strong>nicnatsemi</strong> need PCI configuration space read access and raw I/O port access.</p><p><strong>atahpt</strong> needs PCI configuration space access and raw I/O port access.</p><p><strong>gfxnvidia</strong> and <strong>drkaiser</strong> need PCI configuration space access and raw memory access.</p><p><strong>rayer_spi</strong> needs raw I/O port access.</p><p><strong>satasii</strong> needs PCI configuration space read access and raw memory access.</p><p><strong>satamv</strong> needs PCI configuration space read access, raw I/O port access and raw memory access.</p><p><strong>serprog</strong> needs TCP access to the network or userspace access to a serial port.</p><p><strong>buspirate_spi</strong> needs userspace access to a serial port.</p><p><strong>dediprog</strong>, <strong>ft2232_spi</strong> and <strong>usbblaster_spi</strong> need access to the USB device via libusb.</p><p><strong>dummy</strong> needs no access permissions at all.</p><p><strong>internal</strong>, <strong>nic3com</strong>, <strong>nicrealtek</strong>, <strong>nicnatsemi</strong>,  <strong>gfxnvidia</strong>, <strong>drkaiser</strong>, <strong>satasii</strong>, <strong>satamv</strong> and <strong>atahpt</strong> have to be run as superuser/root, and need additional raw access permission.</p><p><strong>serprog</strong>, <strong>buspirate_spi</strong>, <strong>dediprog</strong>, <strong>usbblaster_spi</strong> and <strong>ft2232_spi</strong> can be run as normal user on most operating systems if appropriate device permissions are set.</p><p><strong>ogp</strong> needs PCI configuration space read access and raw memory access.</p><p>On OpenBSD, you can obtain raw access permission by setting <strong>securelevel=-1</strong> in <strong>/etc/rc.securelevel</strong> and rebooting, or rebooting into single user mode.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>Please report any bugs to the flashrom mailing list at <strong>&lt;flashrom@flashrom.org&gt;</strong></p><p>We recommend to subscribe first at</p><p><strong>  http://www.flashrom.org/mailman/listinfo/flashrom</strong></p><p>Many of the developers communicate via the <strong>#flashrom</strong> IRC channel on <strong>chat.freenode.net</strong>. You are welcome to join and ask questions, send us bug and success reports there too. Please provide a way to contact you later (e.g. a mail address) and be patient if there is no immediate reaction. Also, we provide a pastebin service at <strong>http://paste.flashrom.org</strong> that is very useful when you want to share logs etc. without spamming the channel.</p><h3></h3>
<p><strong>Laptops</strong></p><p>Using flashrom on laptops is dangerous and may easily make your hardware unusable. flashrom will attempt to detect if it is running on a laptop and abort immediately for safety reasons. Please see the detailed discussion of this topic and associated flashrom options in the <strong>Laptops</strong> paragraph in the <strong>internal programmer</strong> subsection of the <strong>PROGRAMMER SPECIFIC INFO</strong> section and the information in our wiki at <strong>http://www.flashrom.org/Laptops </strong>.</p>
<h3></h3>
<p>One-time programmable (OTP) memory and unique IDs</p><p>Some flash chips contain OTP memory often denoted as "security registers". They usually have a capacity in the range of some bytes to a few hundred bytes and can be used to give devices unique IDs etc.  flashrom is not able to read or write these memories and may therefore not be able to duplicate a chip completely. For chip types known to include OTP memories a warning is printed when they are detected.</p><p>Similar to OTP memories are unique, factory programmed, unforgeable IDs. They are not modifiable by the user at all.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LICENSE</h2>
        <div class="sectioncontent">
<p><strong>flashrom</strong> is covered by the GNU General Public License (GPL), version 2. Some files are additionally available under the GPL (version 2, or any later version).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Please see the individual files.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p>Andrew Morgan</p><p>Carl-Daniel Hailfinger</p><p>Claus Gindhart</p><p>David Borg</p><p>David Hendricks</p><p>Dominik Geyer</p><p>Eric Biederman</p><p>Giampiero Giancipoli</p><p>Helge Wagner</p><p>Idwer Vollering</p><p>Joe Bao</p><p>Joerg Fischer</p><p>Joshua Roys</p><p>Luc Verhaegen</p><p>Li-Ta Lo</p><p>Mark Marshall</p><p>Markus Boas</p><p>Mattias Mattsson</p><p>Michael Karcher</p><p>Nikolay Petukhov</p><p>Patrick Georgi</p><p>Peter Lemenkov</p><p>Peter Stuge</p><p>Reinder E.N. de Haan</p><p>Ronald G. Minnich</p><p>Ronald Hoogenboom</p><p>Sean Nelson</p><p>Stefan Reinauer</p><p>Stefan Tauner</p><p>Stefan Wildemann</p><p>Stephan Guilloux</p><p>Steven James</p><p>Uwe Hermann</p><p>Wang Qingpei</p><p>Yinghai Lu</p><p>some others, please see the flashrom svn changelog for details.</p><p>All authors can be reached via email at &lt;flashrom@flashrom.org&gt;.</p><p>This manual page was written by Uwe Hermann &lt;uwe@hermann-uwe.de&gt;, Carl-Daniel Hailfinger and others. It is licensed under the terms of the GNU GPL (version 2 or later).</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="flashcache_setioctl.8.html"><span aria-hidden="true">&larr;</span> flashcache_setioctl.8: Set i/o behavior for special process in flashcache</a></li>
   <li class="next"><a href="flashstat.8.html">flashstat.8: Display flashcache statistic information <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

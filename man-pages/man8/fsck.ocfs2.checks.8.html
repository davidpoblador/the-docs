<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>fsck.ocfs2.checks: Consistency checks that fsck.ocfs2(8) performs and its means for fixing inconsistencies.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Consistency checks that fsck.ocfs2(8) performs and its means for fixing inconsistencies.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="fsck.ocfs2.checks (8) manual">
  <meta name="twitter:description" content="Consistency checks that fsck.ocfs2(8) performs and its means for fixing inconsistencies.">
  <meta name="twitter:image" content="https://www.carta.tech/images/ocfs2-tools-fsck.ocfs2.checks-8.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man8/fsck.ocfs2.checks.8.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="fsck.ocfs2.checks (8) manual" />
  <meta property="og:description" content="Consistency checks that fsck.ocfs2(8) performs and its means for fixing inconsistencies." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/ocfs2-tools-fsck.ocfs2.checks-8.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">fsck.ocfs2.checks<small> (8)</small></h1>
        <p class="lead">Consistency checks that fsck.ocfs2(8) performs and its means for fixing inconsistencies.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man8/">
      <span itemprop="name">System administration commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man8/fsck.ocfs2.checks.8.html">
      <span itemprop="name">fsck.ocfs2.checks: Consistency checks that fsck.ocfs2(8) performs and its means for fixing inconsistencies.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/ocfs2-tools/">
      <span itemprop="name">ocfs2-tools</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man8/fsck.ocfs2.checks.8.html">
      <span itemprop="name">fsck.ocfs2.checks: Consistency checks that fsck.ocfs2(8) performs and its means for fixing inconsistencies.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><a href="../man8/fsck.ocfs2.8.html"><strong>fsck.ocfs2</strong>(8)</a></strong> is used to check an OCFS2 file system.  It performs many consistency checks and will offer to fix faults that it finds.  This man page lists the problems it may find and describes their fixes.  The problems are indexed by the error number that <a href="../man8/fsck.ocfs2.8.html"><strong>fsck.ocfs2</strong>(8)</a></strong> emits when it describes the problem and asks if it should be fixed.</p><p>The prompts are constructed such that answering 'no' results in no changes to the file system.  This may result in errors later on that stop <a href="../man8/fsck.ocfs2.8.html"><strong>fsck.ocfs2</strong>(8)</a></strong> from proceeding.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CHECKS</h2>
        <div class="sectioncontent">
<h3>EB_BLKNO</h3>
<p>Extent blocks contain a record of the disk block where they are located.  An extent block was found at a block that didn't match its recorded location.</p><p>Answering yes will update the data structure in the extent block to reflect its real location on disk.</p>
<h3>EB_GEN</h3>
<p>Extent blocks are created with a generation number to match the generation number of the volume at the time of creation.  An extent block was found which contains a generation number that doesn't match.</p><p>Answering yes implies that the generation number is correct and that the extent block is from a previous file system.  The extent block will be ignored and the file that contains it will lose the data it referenced.</p>
<h3>EB_GEN_FIX</h3>
<p>Extent blocks are created with a generation number to match the generation number of the volume at the time of creation.  An extent block was found which contains a generation number that doesn't match.</p><p>Answering yes implies that the generation number in the extent block is incorrect and that the extent block is valid.  The generation number in the block is updated to match the generation number in the volume.</p>
<h3>EXTENT_MARKED_UNWRITTEN</h3>
<p>An extent record has the UNWRITTEN flag set, but the filesystem feature set does not include unwritten extents.</p><p>Answering yes clears the UNWRITTEN flag.  This is safe to do; as the feature is disabled anyway.</p>
<h3>EXTENT_MARKED_REFCOUNTED</h3>
<p>An extent record has the REFCOUNTED flag set, but neither the filesystem nor the file has the REFCOUNTED flag set.</p><p>Answering yes clears the REFCOUNTED flag.</p>
<h3>EXTENT_BLKNO_UNALIGNED</h3>
<p>The block that marks the start of an extent should always fall on the start of a cluster.  An extent was found that starts part-way into a cluster.</p><p>Answering yes moves the start of the extent back to the start of the addressed cluster.  This may add data to the middle of the file that contains this extent.</p>
<h3>EXTENT_CLUSTERS_OVERRUN</h3>
<p>An extent was found which claims to contain clusters which are beyond the end of the volume.</p><p>Answering yes clamps the extent to the end of the volume.  This may result in a reduced file size for the file that contains the extent, but it couldn't have addressed those final clusters anyway.  One can imagine this problem arising if there are problems shrinking a volume.</p>
<h3>EXTENT_EB_INVALID</h3>
<p>Deep extent trees are built by forming a tree out of extent blocks.  An extent tree references an invalid extent block.</p><p>Answering yes stops the tree from referencing the invalid extent block.  This may truncate data from the file which contains the tree.</p>
<h3>EXTENT_LIST_DEPTH</h3>
<p>Extent lists contain a record of their depth in the tree.  An extent list was found whose recorded depth doesn't match the position they have in the tree.</p><p>Answering yes updates the depth field in the list to match the tree on disk.</p>
<h3>EXTENT_LIST_COUNT</h3>
<p>The number of entries in an extent list is bounded by either the size of the inode or the size of the block which contains it.  An extent list was found which claims to have more entries than would fit in its container.</p><p>Answering yes updates the count field in the extent list to match the container. Answering no to this question may stop further fixes from being done because the count value can not be trusted.</p>
<h3>EXTENT_LIST_FREE</h3>
<p>The number of free entries in an extent list must be less than the total number of entries in the list.   A list was found which claims to have more free entries than possible entries.</p><p>Answering yes sets the number of free entries in the list equal to the total possible entries.</p>
<h3>EXTENT_BLKNO_RANGE</h3>
<p>An extent record was found which references a block which can not be referenced by an extent.  The referenced block is either very early in the volume, and thus reserved, or beyond the end of the volume.</p><p>Answering yes removes this extent record from the tree.  This may remove data from the file which owns the tree but any such data was inaccessible.</p>
<h3>CHAIN_CPG</h3>
<p>The bitmap inode indicates a different clusters per group than the group descriptor. This value is typically static and only modified by tunefs during volume resize and that too only on volumes having only one cluster group.</p><p>Answering yes updates the clusters per group on the bitmap inode to the corresponding value in the group descriptor.</p>
<h3>SUPERBLOCK_CLUSTERS</h3>
<p>The super block indicates a different total clusters value than the global bitmap. This is only possible due to a failed volume resize operation.</p><p>Answering yes updates the total clusters in the super block to the value specified in the global bitmap.</p>
<h3>FIXED_CHAIN_CLUSTERS</h3>
<p>The global bitmap inode was repaired, resulting in a change to the total cluster count of the filesystem.</p><p>Answering yes updates the total clusters in the super block to the value specified in the global bitmap.</p>
<h3>GROUP_UNEXPECTED_DESC</h3>
<p>The group descriptors that make up the global bitmap chain allocator reside at predictable locations on disk.  A group descriptor was found in the global bitmap allocator which isn't at one of these locations and so shouldn't be in the allocator.</p><p>Answering yes removes this descriptor from the global bitmap allocator.</p>
<h3>GROUP_EXPECTED_DESC</h3>
<p>The group descriptors that make up the global bitmap chain allocator reside at predictable locations on disk.  A group descriptor at one of these locations was not linked into the global bitmap allocator.</p><p>Answering yes will relink this group into the allocator.</p>
<h3>GROUP_GEN</h3>
<p>A group descriptor was found with a generation number that doesn't match the generation number of the volume.</p><p>Answering yes sets the group descriptor's generation equal to the generation number in the volume.</p>
<h3>GROUP_PARENT</h3>
<p>Group descriptors contain a pointer to the allocator inode which contains the chain they belong to.  A group descriptor was found in an allocator inode that doesn't match the descriptor's parent pointer.</p><p>Answering yes updates the group descriptor's parent pointer to match the inode it resides in.</p>
<h3>GROUP_DUPLICATE</h3>
<p>Group descriptors contain a pointer to the allocator inode which contains the chain they belong to.  A group descriptor was found in two allocator inodes so it may be duplicated.</p><p>Answering yes removes the group descriptor from current allocator inode.</p>
<h3>GROUP_BLKNO</h3>
<p>Group descriptors have a field which records their block location on disk.  A group descriptor was found at a given location but is recorded as being located somewhere else.</p><p>Answering yes updates the group descriptor's recorded location to match where it actually is found on disk.</p>
<h3>GROUP_CHAIN</h3>
<p>Group descriptors are found in a number of different singly-linked chains in an allocator inode.  A group descriptor records the chain number that it is linked in.  A group descriptor was found whose chain field doesn't match the chain it was found in.</p><p>Answering yes sets the group descriptor's chain field to match the chain it is found in.</p>
<h3>GROUP_FREE_BITS</h3>
<p>A group descriptor records the number of bits in its bitmap that are free. A group descriptor was found which claims to have more free bits than are valid in its bitmap.</p><p>Answering yes decreases the number of recorded free bits so that it equals the total number of bits in the group descriptor's bitmap.</p>
<h3>CHAIN_COUNT</h3>
<p>The chain list embedded in an inode is limited by the block size and the number of bytes consumed by the rest of the inode.  A chain list header was found which claimed that there are more entries in the list then could fit in the inode.</p><p>Answering yes resets the header's cl_count member to the maximum size allowed by the block size after accounting for the space consumed by the inode.</p>
<h3>CHAIN_NEXT_FREE</h3>
<p>This is identical to CHAIN_COUNT except that it is testing and fixing the pointer to the next free list entry recorded in the cl_next_free_rec member instead of the total number of entries.</p>
<h3>CHAIN_EMPTY</h3>
<p>Chain entries need to be packed such that there are no chains without descriptors found before the chain that is marked as free by the chain header. A chain without descriptors was found found before that chain that was marked free.</p><p>Answering yes will remove the unused chain and shift the remaining chains forward in the list.</p>
<h3>CHAIN_I_CLUSTERS</h3>
<p>Chain allocator inodes have an i_clusters value that represents the number of clusters used by the allocator.  An inode was found whose i_clusters value doesn't match the number of clusters its chains cover.</p><p>Answering yes updates i_clusters in the inode to reflect what was actually found by walking the chain.</p>
<h3>CHAIN_I_SIZE</h3>
<p>Chain allocator inodes multiply the number of bytes per cluster by the their i_clusters value and store it in i_size.  An inode was found which didn't have the correct value in its i_size.</p><p>Answering yes updates i_size to be the product of i_clusters and the cluster size.  Nothing else uses this value, and previous versions of tools didn't calculate it properly, so don't be too worried if this error appears.</p>
<h3>CHAIN_GROUP_BITS</h3>
<p>The inode that contains an embedded chain list has fields which record the total number of bits covered by the chain as well as the amount free.  These fields didn't match what was found in the chain.</p><p>Answering yes updates the fields in the inode to reflect what was actually found by walking the chain.</p>
<h3>CHAIN_HEAD_LINK_RANGE</h3>
<p>The header that starts a chain tried to reference a group descriptor at a block number that couldn't be valid.</p><p>Answering yes will clear the reference to this invalid block and truncate the chain that it started.</p>
<h3>CHAIN_LINK_GEN</h3>
<p>A reference was made to a group descriptor whose generation number doesn't match the generation of the volume.</p><p>Answering yes to this question implies that the group descriptor is invalid and the chain is truncated at the point that it referred to this invalid group descriptor.  Answering no to this question considers the group descriptor as valid and its generation may be fixed.</p>
<h3>CHAIN_LINK_MAGIC</h3>
<p>Chains are built by chain headers and group descriptors which are linked together by block references.  A reference was made to a group descriptor at a given block but a valid group descriptor signature wasn't found at that block.</p><p>Answering yes clears the reference to this invalid block and truncates the chain at the point of the reference.</p>
<h3>CHAIN_LINK_RANGE</h3>
<p>Chains are built by chain headers and group descriptors which are linked together by block references.  A reference a block was found which can't possibly be valid because it was either too small or extended beyond the volume.</p><p>Answering yes truncates the chain in question by zeroing the invalid block reference.  This shortens the chain in question and could result in more fixes later if the part of the chain that couldn't be referenced was valid at some point.</p>
<h3>CHAIN_BITS</h3>
<p>A chain's header contains members which record the total number of bits in the chain as well as the number of bits that are free.  After walking through a chain it was found that the number of bits recorded in its header don't match what was found by totalling up the group descriptors.</p><p>Answering yes updates the c_total and c_free members of the header to reflect what was found in the group descriptors in the chain.</p>
<h3>DISCONTIG_BG_DEPTH</h3>
<p>A discontiguous block group has an extent list which records all the clusters allocated to it.  Discontiguous block groups only support extent lists with a tree depth of 0.  A block group claims to have a tree depth greater than 0.</p><p>Answering yes will set the tree depth of the extent list to 0.</p>
<h3>DISCONTIG_BG_COUNT</h3>
<p>A discontiguous block group has an extent list which records all the clusters allocated to it. A block group claims to have more records than can actually fit.</p><p>Answering yes will set the record count to the maximum possible.</p>
<h3>DISCONTIG_BG_REC_RANGE</h3>
<p>Block groups set aside clusters to be used for metadata.  A discontiguous block group claims to contain clusters beyond the end of the volume.</p><p>Answering yes will remove the block group.</p>
<h3>DISCONTIG_BG_CORRUPT_LEAVES</h3>
<p>A discontiguous block group has an extent list which records all the clusters allocated to it.  A group has more than one extent claiming to have an impossible number of clusters.</p><p>Answering yes will remove the block group.</p>
<h3>DISCONTIG_BG_CLUSTERS</h3>
<p>Extent records in a discontiguous block group were found having more clusters allocated then a block group can have.</p><p>Answering yes will remove the block group.</p>
<h3>DISCONTIG_BG_LESS_CLUSTERS</h3>
<p>Extent records in a discontiguous block group were found having less clusters allocated then a block group can have.</p><p>Answering yes will remove the block group.</p>
<h3>DISCONTIG_BG_NEXT_FREE_REC</h3>
<p>A discontiguous block group has an extent list which records all the clusters allocated to it. A group was found with fewer filled in extents than it claims to have.  The filled in extents describe a complete and correct group.</p><p>Answering yes will set the used extent count to the number of filled extents.</p>
<h3>DISCONTIG_BG_LIST_CORRUPT</h3>
<p>A discontiguous block group has an extent list which records all the clusters allocated to it.  The group claims to have more extents than is possible, and the existing extents contain errors.</p><p>Answering yes will remove the block group.</p>
<h3>DISCONTIG_BG_REC_CORRUPT</h3>
<p>A discontiguous block group has a extent list which records all the clusters allocated to it.  A group was found with one extent claiming too many clusters but the sum of the remaining extents are equal to the total clusters a group must have.</p><p>Answering yes will remove the block group.</p>
<h3>DISCONTIG_BG_LEAF_CLUSTERS</h3>
<p>A discontiguous block group has a extent list which records all the clusters allocated to it.  A group was found with one extent claiming too many clusters, but the remaining extents are correct.</p><p>Answering yes will set the number of the clusters on the broken extent to the difference between the total clusters a group must have and the sum of the remaining extents.</p>
<h3>INODE_ALLOC_REPAIR</h3>
<p>The inode allocator did not accurately reflect the set of inodes that are free and in use in the volume.</p><p>Answering yes will update the inode allocator bitmaps.  Each bit that doesn't match the state of its inode will be inverted.</p>
<h3>INODE_SUBALLOC</h3>
<p>Each inode records the node whose allocator is responsible for the inode.  An inode was found in a given node's allocator but the inode itself claimed to belong to a different node.</p><p>Answering yes will correct the inode to point to the node's allocator that it belongs to.</p>
<h3>LALLOC_SIZE</h3>
<p>Each node has a local allocator contained in a block that is used to allocate clusters in batches.  A node's local allocator claims to reflect more bytes than are possible for the volume's block size.</p><p>Answering yes decreases the local allocator's size to reflect the volume's block size.</p>
<h3>LALLOC_NZ_USED</h3>
<p>A given node's local allocator isn't in use but it claims to have bits in use in its bitmap.</p><p>Answering yes zeros this used field.</p>
<h3>LALLOC_NZ_BM</h3>
<p>A given node's local allocator isn't in use but it has a field which records the bitmap as starting at a non-zero cluster offset.</p><p>Answering yes zeros the bm_off field.</p>
<h3>LALLOC_BM_OVERRUN</h3>
<p>Each local allocator contains a reference to the first cluster that its bitmap addresses.  A given local allocator was found which references a starting cluster that is beyond the end of the volume.</p><p>Answering yes resets the given local allocator.  No allocated data will be lost.</p>
<h3>LALLOC_BM_SIZE</h3>
<p>The given local allocator claims to cover more bits than are possible for the size in bytes of its bitmap.</p><p>Answering yes decreases the number of bits the allocator covers to reflect the size in bytes of the bitmap and resets the allocator.  No allocated data will be lost.</p>
<h3>LALLOC_BM_STRADDLE</h3>
<p>The given local allocator claims to cover a region of clusters which extents beyond the end of the volume.</p><p>Answering yes resets the given local allocator.  No allocated data will be lost.</p>
<h3>LALLOC_USED_OVERRUN</h3>
<p>The given local allocator claims to have more bits in use than it has total bits in its bitmap.</p><p>Answering yes decreases the number of bits used so that it equals the total number of available bits.</p>
<h3>LALLOC_CLEAR</h3>
<p>A local allocator inode was found to have problems.  This gives the operator a chance to just reset the local allocator inode.</p><p>Answering yes clears the local allocator.  No information is lost but the global bitmap allocator may need to be updated to reflect clusters that were reserved for the local allocator but were free.</p>
<h3>DEALLOC_COUNT</h3>
<p>The given truncate log inode contains a count that is greater than the value that is possible given the size of the inode.</p><p>Answering yes resets the count value to the possible maximum.</p>
<h3>DEALLOC_USED</h3>
<p>The given truncate log inode claims to have more records in use than it is possible to store in the inode.</p><p>Answering yes resets the record of the number used to the maximum value possible.</p>
<h3>TRUNCATE_REC_START_RANGE</h3>
<p>A truncate record was found which claims to start at a cluster that is beyond the number of clusters in the volume.</p><p>Answering yes will clear the truncate record.  This may result in previously freed space being marked as allocated.  This will be fixed up later as the allocator is updated to match what is used by the file system.</p>
<h3>TRUNCATE_REC_WRAP</h3>
<p>Clusters are recorded as 32bit values.  A truncate record was found which claims to have enough clusters to cause this value to wrap.  This could never be the case and is a sure sign of corruption.</p><p>Answering yes will clear the truncate record.  This may result in previously freed space being marked as allocated.  This will be fixed up later as the allocator is updated to match what is used by the file system.</p>
<h3>TRUNCATE_REC_RANGE</h3>
<p>A truncate record was found which claims to reference a region of clusters which partially extends beyond the number of clusters in the volume.</p><p>Answering yes will clear the truncate record.  This may result in previously freed space being marked as allocated.  This will be fixed up later as the allocator is updated to match what is used by the file system.</p>
<h3>INODE_GEN</h3>
<p>Inodes are created with a generation number to match the generation number of the volume at the time of creation.  An Inode was found which contains a generation number that doesn't match.</p><p>Answering yes implies that the generation number is correct and that the inode is from a previous file system.  The inode will be recorded as free.</p>
<h3>INODE_GEN_FIX</h3>
<p>Inodes are created with a generation number to match the generation number of the volume at the time of creation.  An inode was found which contains a generation number that doesn't match.</p><p>Answering yes implies that the generation number in the inode is incorrect and that the inode is valid.  The generation number in the inode is updated to match the generation number in the volume.</p>
<h3>INODE_BLKNO</h3>
<p>Inodes contain a field that must match the block that they reside in. An inode was found at a block that doesn't match the field in the inode.</p><p>Answering yes updates the field to match the inode's position on disk.</p>
<h3>ROOT_NOTDIR</h3>
<p>The super block contains a reference to the inode that contains the root directory.  This block was found to contain an inode that isn't a directory.</p><p>Answering yes clears this inode.  The operator will be asked to recreate the root directory at a point in the near future.</p>
<h3>INODE_NZ_DTIME</h3>
<p>Inodes contain a field describing the time at which they were deleted.  This can not be set for an inode that is still in use.  An inode was found which is in use but which contains a non-zero dtime.</p><p>Answering yes implies that the inode is still valid and resets its dtime to zero.</p>
<h3>LINK_FAST_DATA</h3>
<p>The target name for a symbolic link is stored either as file contents for that inode or in the inode structure itself on disk.  Only small destination names are stored in the inode structure.  The i_blocks field of the inode indicates that the name is stored in the inode when it is zero.  An inode was found that has both i_blocks set to zero and file contents.</p><p>Answering yes clears the inode and so deletes the link.</p>
<h3>LINK_NULLTERM</h3>
<p>The targets of links on disk must be null terminated.  A link was found whose target wasn't null terminated.</p><p>Answering yes clears the inode and so deletes the link.</p>
<h3>LINK_SIZE</h3>
<p>The size of a link on disk must match the length of its target string. A link was found whose size does not.</p><p>Answering yes updates the link's size to reflect the length of its target string.</p>
<h3>LINK_BLOCKS</h3>
<p>Links can not be sparse.  There must be exactly as many blocks allocated as are needed to cover its size.  A link was found which doesn't have enough blocks allocated to cover its size.</p><p>Answering yes clears the link's inode thus deleting the link.</p>
<h3>DIR_ZERO</h3>
<p>Directories must at least contain a block that has the "." and ".." entries. A directory was found which doesn't contain any blocks.</p><p>Answering yes to this question clears the directory's inode thus deleting the directory.</p>
<h3>INODE_SIZE</h3>
<p>Certain inodes record the size of the data they reference in an i_size field. This can be the number of bytes in a file, directory, or symlink target which are stored in data mapped by extents of clusters.  This error occurs when the extent lists are walked and the amount of data found does not match what is stored in i_size.</p><p>Answering yes to this question updates the inode's i_size to match the amount of data referenced by the extent lists.  It is vitally important that i_size matches the extent lists and so answering yes is strongly encouraged.</p>
<h3>INODE_SPARSE_SIZE</h3>
<p>Certain inodes record the size of the data they reference in an i_size field. This can be the number of bytes in a file, directory, or symlink target which are stored in data mapped by extents of clusters. This error occurs when a sparse inode was found that had data allocated past its i_size.</p><p>Answering yes to this question will update the inode's i_size to cover all of its allocated storage.  It is vitally important that i_size matches the extent lists and so answering yes is strongly encouraged.</p>
<h3>INODE_INLINE_SIZE</h3>
<p>Inodes can only fit a certain amount of inline data.  This inode has its data inline but claims an i_size larger than will actually fit.</p><p>Answering yes to this question updates the inode's i_size to the maximum available inline space.</p>
<h3>INODE_CLUSTERS</h3>
<p>Inodes contain a record of how many clusters are allocated to them.  An inode was found whose recorded number of clusters doesn't match the number of blocks that were found associated with the inode.</p><p>Answering yes resets the inode's number of clusters to reflect the number of blocks that were associated with the file.</p>
<h3>INODE_SPARSE_CLUSTERS</h3>
<p>Inodes contain a record of how many clusters are allocated to them.  An sparse inode was found whose recorded number of clusters doesn't match the number of blocks that were found associated with the inode.</p><p>Answering yes resets the inode's number of clusters to reflect the number of blocks that were associated with the file.</p>
<h3>INODE_INLINE_CLUSTERS</h3>
<p>Inlined inode should not have allocated clusters.  An inode who has inline data flag set was found with clusters allocated.</p><p>Answering yes resets the inode's number of clusters to zero.</p>
<h3>LALLOC_REPAIR</h3>
<p>An active local allocator did not accurately reflect the set of clusters that are free and in use in its region.</p><p>Answering yes will update the local allocator bitmap.  Each bit that doesn't match the use of its cluster will be inverted.</p>
<h3>LALLOC_USED</h3>
<p>A local allocator records the number of bits that are used in its bitmap.  An allocator was found whose used value doesn't reflect the number of bits that are set in its bitmap.</p><p>Answering yes sets the used value to match the number of bits set in the allocator's bitmap.</p>
<h3>CLUSTER_ALLOC_BIT</h3>
<p>A specific cluster's use didn't match the setting of its bit in the cluster allocator.</p><p>Answering yes will invert the bit in the allocator to match the use of the cluster -- either allocated and in use or free.</p>
<h3>REFCOUNT_FLAG_INVALID</h3>
<p>Refcount file can only exist in a volume with refcount supported, Fsck has found that a file in a non-refcount volume has refcount flag set.</p><p>Answering yes remove this flag from the file.</p>
<h3>REFCOUNT_LOC_INVALID</h3>
<p>Refcount loc can only be valid if the file has refcount flag set. Fsck has found that a file has refcount loc while it does't have refcount flag set.</p><p>Answering yes reset refcount loc to zero for the file.</p>
<h3>RB_BLKNO</h3>
<p>refcount blocks contain a record of the disk block where they are located. An refcount block was found at a block that didn't match its recorded location.</p><p>Answering yes will update the data structure in the refcount block to reflect its real location on disk.</p>
<h3>RB_GEN</h3>
<p>Refcount blocks are created with a generation number to match the generation number of the volume at the time of creation.  An refcount block was found which contains a generation number that doesn't match.</p><p>Answering yes implies that the generation number is correct and that the refcount block is from a previous file system.  The refcount block will be removed and the file that uses it will lose the refcounted information, but it may be regenerated later.</p>
<h3>RB_GEN_FIX</h3>
<p>Refcount blocks are created with a generation number to match the generation number of the volume at the time of creation.  An refcount block was found which contains a generation number that doesn't match.</p><p>Answering yes implies that the generation number in the refcount block is incorrect and that the refcount block is valid.  The generation number in the block is updated to match the generation number in the volume.</p>
<h3>RB_PARENT</h3>
<p>refcount blocks contain a record of the parent this disk block belongs to. An refcount block was found storing a wrong parent location.</p><p>Answering yes will update the data structure in the refcount block to reflect its parent's real location on disk.</p>
<h3>REFCOUNT_LIST_COUNT</h3>
<p>The number of entries in a refcount list is bounded by the size of the block which contains it.  An refcount list was found which claims to have more entries than would fit in its container.</p><p>Answering yes updates the count field in the refcount list to match the container. Answering no to this question may stop further fixes from being done because the count value can not be trusted.</p>
<h3>REFCOUNT_LIST_USED</h3>
<p>The number of free entries in a refcount list must be less than the total number of entries in the list.   A list was found which claims to have more free entries than possible entries.</p><p>Answering yes sets the number of free entries in the list equal to the total possible entries.</p>
<h3>REFCOUNT_CLUSTER_RANGE</h3>
<p>A refcount record was found which references a cluster which can not be referenced by a refcount.  The referenced cluster is either very early in the volume, and thus reserved, or beyond the end of the volume.</p><p>Answering yes removes this refcount record from the tree.</p>
<h3>REFCOUNT_CLUSTER_COLLISION</h3>
<p>A refcount record was found which references a cluster which has a collision with the previous valid refcount record.</p><p>Answering yes removes this refcount record from the tree.</p>
<h3>REFCOUNT_LIST_EMPTY</h3>
<p>A refcount list was found which has no refcount record in it. It is normally caused by a corrupted refcount record.</p><p>Answering yes removes this refcount block from the tree. It will be re-generated in refcounted extent records handler if all the other information is sane.</p>
<h3>REFCOUNT_BLOCK_INVALID</h3>
<p>Refcount block stores the refcount record for physical clusters of a file. It is found refering an invalid refcount block.</p><p>Answering yes remove this refcount block.</p>
<h3>REFCOUNT_CLUSTERS</h3>
<p>Refcount tree contains a record of how many clusters are allocated to them. A tree was found whose recorded number of clusters doesn't match the number of blocks that were found associated with it.</p><p>Answering yes resets the number of clusters to reflect the real number of clusters that were associated with the tree.</p>
<h3>REFCOUNT_ROOT_BLOCK_INVALID</h3>
<p>Root refcount block is the root of the refcount record for a file. It is found refering an invalid refcount block.</p><p>Answering yes remove this refcount block and clear refcount flag from this file.</p>
<h3>REFCOUNT_REC_REDUNDANT</h3>
<p>Refcount record is used to store the refcount for physical clusters. Some refcount record is found to have no physical clusters corresponding to it.</p><p>Answering yes remove the refcount record.</p>
<h3>REFCOUNT_COUNT_INVALID</h3>
<p>Refcount record is used to store the refcount for physical clusters. A record record is found whichs claims the wrong refcount for some physical clusters.</p><p>Answering yes update the corresponding refcount record.</p>
<h3>REFCOUNT_COUNT</h3>
<p>Refcount tree contains a record of how many files refering to this tree. A tree was found whose recorded number of files doesn't match the real files refering to the tree.</p><p>Answering yes resets the number of files to reflect the real number of files that were associated with the tree.</p>
<h3>DUP_CLUSTERS_SYSFILE_CLONE</h3>
<p>A system file inode claims clusters that are also claimed by another inode. ocfs2 does not allow this.  System files may be cloned but may not be deleted.  Allocation system files may not be cloned or deleted.</p><p>Answering yes will copy the data of this inode to newly allocated extents. This will break the claim on the overcommitted clusters.</p>
<h3>DUP_CLUSTERS_CLONE</h3>
<p>An inode claims clusters that are also claimed by another inode.  ocfs2 does not allow this.</p><p>Answering yes will copy the data of this inode to newly allocated extents. This will break the claim on the overcommitted clusters.</p>
<h3>DUP_CLUSTERS_DELETE</h3>
<p>An inode claims clusters that are also claimed by another inode.  ocfs2 does not allow this.</p><p>Answering yes will remove this inode, thus breaking its claim on the overcommitted clusters.</p>
<h3>DUP_CLUSTERS_ADD_REFCOUNT</h3>
<p>An inode claims clusters that are also claimed by another inode.  ocfs2 does not allow this.</p><p>Answering yes will try to add a refcount record for all these inodes, so that they will share the cluster.</p>
<h3>DIRENT_DOTTY_DUP</h3>
<p>There can be only one instance of both the "." and ".." entries in a directory. A directory entry was found which duplicated one of these entries.</p><p>Answering yes will remove the duplicate directory entry.</p>
<h3>DIRENT_NOT_DOTTY</h3>
<p>The first and second directory entries in a directory must be "." and ".." respectively.  One of these directory entries was found to not match these rules.</p><p>Answering yes will force the directory entry to be either "." or "..".  This might consume otherwise valid entries and cause some files to appear in lost+found.</p>
<h3>DIRENT_DOT_INODE</h3>
<p>The inode field of the "." directory entry must refer to the directory inode that contains the given directory block.  A "." entry was found which doesn't do so.</p><p>Answering yes sets the directory entry's inode reference to the parent directory that contains the entry.</p>
<h3>DIRENT_DOT_EXCESS</h3>
<p>A "." directory entry was found whose lengths exceeds the amount required for the single dot in the name.</p><p>Answering yes creates another empty directory entry in this excess space.</p>
<h3>DIRENT_ZERO</h3>
<p>A directory entry was found with a zero length name.</p><p>Answering yes clears the directory entry so its space can be reused.</p>
<h3>DIRENT_NAME_CHARS</h3>
<p>Directory entries can not contain either the NULL character (ASCII 0) or the forward slash (ASCII 47).  A directory entry was found which contains either.</p><p>Answering yes will change each instance of these forbidden characters into a period (ASCII 46).</p>
<h3>DIRENT_INODE_RANGE</h3>
<p>Each directory entry contains a inode field which the entry's name corresponds to.  An entry was found which referenced an inode number that is invalid for the current volume.</p><p>Answering yes clears this entry so its space can be reused.  If the entry once corresponded to a real inode and was corrupted this inode may appear in lost+found.</p>
<h3>DIRENT_INODE_FREE</h3>
<p>Each directory entry contains a inode field which the entry's name corresponds to.  An entry was found which referenced an inode number that isn't in use.</p><p>Answering yes clears this directory entry.</p>
<h3>DIRENT_TYPE</h3>
<p>Each directory entry contains a field which describes the type of file that the entry refers to.  An entry was found whose type doesn't match the inode it is referring to.</p><p>Answering yes resets the entry's type to match the target inode.</p>
<h3>DIR_PARENT_DUP</h3>
<p>Each directory can only be pointed to by one directory entry in a parent directory.  A directory entry was found which was the second entry to point to a given directory inode.</p><p>Answering yes clears this entry which was the second to refer to a given directory.  This reflects the policy that hard links to directories are not allowed.</p>
<h3>DIRENT_DUPLICATE</h3>
<p>File names within a directory must be unique.  A file name occurred in more than one directory entry in a given directory.</p><p>Answering yes renames the duplicate entry to a name that doesn't collide with recent entries and is unlikely to collide with future entries in the directory.</p>
<h3>DIRENT_LENGTH</h3>
<p>There are very few directory entry lengths that are valid.  The lengths must be greater than the minimum required to record a single character directory, be rounded to 12 bytes, be within the amount of space remaining in a directory block, and be properly rounded for the size of the name of the directory entry. An entry was found which didn't meet these criteria.</p><p>Answering yes will try to repair the directory entry.  This runs a very good chance of invalidating all the entries in the directory block.  Orphaned inodes may appear in lost+found.</p>
<h3>DIR_TRAILER_INODE</h3>
<p>A directory block trailer is a fake directory entry at the end of the block.  The trailer has compatibility fields for when it is viewed as a directory entry.  The inode field must be zero.</p><p>Answering yes will set the inode field to zero.</p>
<h3>DIR_TRAILER_NAME_LEN</h3>
<p>A directory block trailer is a fake directory entry at the end of the block.  The trailer has compatibility fields for when it is viewed as a directory entry.  The name length field must be zero.</p><p>Answering yes will set the name length field to zero.</p>
<h3>DIR_TRAILER_REC_LEN</h3>
<p>A directory block trailer is a fake directory entry at the end of the block.  The trailer has compatibility fields for when it is viewed as a directory entry.  The record length field must be equal to the size of the trailer.</p><p>Answering yes will set the record length field to the size of the trailer.</p>
<h3>DIR_TRAILER_BLKNO</h3>
<p>A directory block trailer is a fake directory entry at the end of the block.  The self-referential block number is incorrect.</p><p>Answering yes will set the block number to the correct block on disk.</p>
<h3>DIR_TRAILER_PARENT_INODE</h3>
<p>A directory block trailer is a fake directory entry at the end of the block.  It has a pointer to the directory inode it belongs to.  This pointer is incorrect.</p><p>Answering yes will set the parent inode pointer to the inode referencing this directory block.</p>
<h3>ROOT_DIR_MISSING</h3>
<p>The super block contains a reference to the inode that serves as the root directory.  This reference points to an inode that isn't in use.</p><p>Answering yes will create a new inode and update the super block to refer to this inode as the root directory.</p>
<h3>LOSTFOUND_MISSING</h3>
<p>The super block contains a reference to the inode that serves as the lost+found directory.  This reference points to an inode that isn't in use.</p><p>Answering yes will create a new lost+found directory in the root directory.</p>
<h3>DIR_NOT_CONNECTED</h3>
<p>Every directory in the file system should be reachable by a directory entry in its parent directory.  This is verified by walking every directory in the system.  A directory inode was found during this walk which doesn't have a parent directory entry.</p><p>Answering yes moves this directory entry into the lost+found directory and gives it a name based on its inode number.</p>
<h3>DIR_DOTDOT</h3>
<p>A directory inode's ".." directory entry must refer to the parent directory. A directory was found whose ".." doesn't refer to its parent.</p><p>Answering yes will read the directory block for the given directory and update its ".." entry to reflect its parent.</p>
<h3>INODE_NOT_CONNECTED</h3>
<p>Most all inodes in the system should be referenced by a directory entry. An inode was found which isn't referred to by any directory entry.</p><p>Answering yes moves this inode into the lost+found directory and gives it a name based on its inode number.</p>
<h3>INODE_COUNT</h3>
<p>Each inode records the number of directory entries that refer to it.  An inode was found whose recorded count doesn't match the number of entries that refer to it.</p><p>Answering yes sets the inode's count to match the number of referring directory entries.</p>
<h3>INODE_ORPHANED</h3>
<p>While files are being deleted they are placed in an internal directory.  If the machine crashes while this is taking place the files will be left in this directory.  Fsck has found an inode in this directory and would like to finish the job of truncating and removing it.</p><p>Answering yes removes the file data associated with the inode and frees the inode.</p>
<h3>RECOVER_BACKUP_SUPERBLOCK</h3>
<p>When <em>fsck.ocfs2</em> successfully uses the specified backup superblock, it provides the user with this option to overwrite the existing superblock with that backup.</p><p>Answering yes will refresh the superblock from the backup. Answering no will only disable the copying of the backup superblock and will not effect the remaining <em>fsck.ocfs2</em> processing.</p>
<h3>ORPHAN_DIR_MISSING</h3>
<p>While files are being deleted they are placed in an internal directory, named orphan directory. If an orphan directory does not exist, an OCFS2 volume cannot be mounted successfully. Fsck has found the orphan directory is missing and would like to create it for future use.</p><p>Answering yes creates the orphan directory in the system directory.</p>
<h3>JOURNAL_FILE_INVALID</h3>
<p>OCFS2 uses JDB for journalling and some journal files exist in the system directory. Fsck has found some journal files that are invalid.</p><p>Answering yes to this question will regenerate the invalid journal files.</p>
<h3>JOURNAL_UNKNOWN_FEATURE</h3>
<p>Fsck has found some journal files with unknown features.  Other journals on the filesystem have only known features, so this is likely a corruption. If you think your filesystem may be newer than this version of fsck.ocfs2, say N here and grab the latest version of fsck.ocfs2.</p><p>Answering yes resets the journal features to match other journals.</p>
<h3>JOURNAL_MISSING_FEATURE</h3>
<p>Fsck has found some journal files have features that are not set on all journal files. All journals on filesystem should have the same set of features.</p><p>Answering yes will set all journals to the union of set features.</p>
<h3>JOURNAL_TOO_SMALL</h3>
<p>Fsck has found some journal files are too small.</p><p>Answering yes extends these journals.</p>
<h3>RECOVER_CLUSTER_INFO</h3>
<p>The currently active cluster stack is different than the one the filesystem is configured for.  Thus, fsck.ocfs2 cannot determine whether the filesystem is mounted on an another node or not. The recommended solution is to exit and run fsck.ocfs2 on this device from a node that has the appropriate active cluster stack. However, you can proceed with the fsck if you are sure that the volume is not in use on any node.</p><p>Answering yes reconfigures the filesystem to use the current cluster stack. DANGER: YOU MUST BE ABSOLUTELY SURE THAT NO OTHER NODE IS USING THIS FILESYSTEM BEFORE CONTINUING.  OTHERWISE, YOU CAN CORRUPT THE FILESYSTEM AND LOSE DATA.</p>
<h3>INLINE_DATA_FLAG_INVALID</h3>
<p>Inline file can only exist in a volume with inline supported, Fsck has found that a file in a non-inline volume has inline flag set.</p><p>Answering yes remove this flag from the file.</p>
<h3>INLINE_DATA_COUNT_INVALID</h3>
<p>For an inline file, there is a limit for id2.id_data.id_count. Fsck has found that this value isn't right.</p><p>Answering yes change this value to the right number.</p>
<h3>XATTR_BLOCK_INVALID</h3>
<p>Extended attributes are stored off an extended attribute block referenced by the inode.  This inode references an invalid extended attribute block.</p><p>Answering yes will remove this block.</p>
<h3>XATTR_COUNT_INVALID</h3>
<p>The count of extended attributes in an inode, block, or bucket does not match the number of entries found by fsck.</p><p>Answering yes will change this to the correct count.</p>
<h3>XATTR_ENTRY_INVALID</h3>
<p>An extended attribute entry points to already used space.</p><p>Answering yes will remove this entry.</p>
<h3>XATTR_NAME_OFFSET_INVALID</h3>
<p>The name_offset field of an extended attribute entry is not correct. Without a correct name_offset field, the entry cannot be used.</p><p>Answering yes will remove this entry.</p>
<h3>XATTR_VALUE_INVALID</h3>
<p>The value region of an extended attribute points to already used space.</p><p>Answering yes will remove this entry.</p>
<h3>XATTR_LOCATION_INVALID</h3>
<p>The xe_local field and xe_value_size field of an extended attribute entry does not match. So the entry cannot be used.</p><p>Answering yes will remove this entry.</p>
<h3>XATTR_HASH_INVALID</h3>
<p>Extended attributes use a hash of their name for lookup purposes. The name_hash of this extended attribute entry is not correct.</p><p>Answering yes will change this to the correct hash.</p>
<h3>XATTR_FREE_START_INVALID</h3>
<p>Extended attributes use free_start to indicate the offset of the free space in inode, block, or bucket. The free_start field of this object is not correct.</p><p>Answering yes will change this to the correct offset.</p>
<h3>XATTR_VALUE_LEN_INVALID</h3>
<p>Extended attributes use name_value_len to store the total length of all entry's name and value in inode, block or bucket. the name_value_len filed of this object is not correct.</p><p>Answering yes will change this to the correct value.</p>
<h3>XATTR_BUCKET_COUNT_INVALID</h3>
<p>The count of extended attributes bucket pointed by one extent record does not match the number of buckets found by fsck.</p><p>Answering yes will change this to the correct count.</p>
<h3>QMAGIC_INVALID</h3>
<p>The magic number in the header of quota file does not match the proper number.</p><p>Answering yes will make fsck use values in the quota file header anyway.</p>
<h3>QTREE_BLK_INVALID</h3>
<p>Block with references to other blocks with quota data is corrupted.</p><p>Answering yes will make fsck use references in the block.</p>
<h3>DQBLK_INVALID</h3>
<p>The structure with quota limits was found in a corrupted block.</p><p>Answering yes will use the values of limits for the user / group.</p>
<h3>DUP_DQBLK_INVALID</h3>
<p>The structure with quota limits was found in a corrupted block and fsck has already found quota limits for this user / group.</p><p>Answering yes will use new values of limits for the user / group.</p>
<h3>DUP_DQBLK_VALID</h3>
<p>The structure with quota limits was found in a correct block but fsck has already found quota limits for this user / group.</p><p>Answering yes will use new values of limits for the user / group.</p>
<h3>IV_DX_TREE</h3>
<p>A directory index was found on an inode but that feature is not enabled on the file system.</p><p>Answering yes will truncate the invalid index.</p>
<h3>DX_LOOKUP_FAILED</h3>
<p>A directory entry is missing an entry in the directory index. The missing index entry will cause lookups on this name to fail.</p><p>Answering yes will rebuild the directory index, restoring the missing entry.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO fsck.ocfs2.checks&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man8/fsck.ocfs2.8.html"><strong>fsck.ocfs2</strong>(8)</a></strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p>Oracle Corporation.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright &copy; 2004, 2010 Oracle. All rights reserved.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="fsck.ocfs2.8.html"><span aria-hidden="true">&larr;</span> fsck.ocfs2.8: Check an ocfs2 file system.</a></li>
   <li class="next"><a href="fsck.reiser4.8.html">fsck.reiser4.8: The program for checking and repairing reiser4 filesystem. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>trafgen: A fast, multithreaded network packet generator</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="A fast, multithreaded network packet generator">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="trafgen (8) manual">
  <meta name="twitter:description" content="A fast, multithreaded network packet generator">
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">trafgen<small> (8)</small></h1>
        <p class="lead">A fast, multithreaded network packet generator</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man8/">
      <span itemprop="name">System administration commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man8/trafgen.8.html">
      <span itemprop="name">trafgen: A fast, multithreaded network packet generator</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/netsniff-ng/">
      <span itemprop="name">netsniff-ng</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man8/trafgen.8.html">
      <span itemprop="name">trafgen: A fast, multithreaded network packet generator</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>trafgen</strong> [<em>options</em>] [<em>packet</em>]</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>trafgen is a fast, zero-copy network traffic generator for debugging, performance evaluation, and fuzz-testing. trafgen utilizes the <a href="../man7/packet.7.html"><strong>packet</strong>(7)</a> socket interface of Linux which postpones complete control over packet data and packet headers into the user space. It has a powerful packet configuration language, which is rather low-level and not limited to particular protocols. Thus, trafgen can be used for many purposes. Its only limitation is that it cannot mimic full streams resp. sessions. However, it is very useful for various kinds of load testing in order to analyze and subsequently improve systems behaviour under DoS attack scenarios, for instance.</p><p>trafgen is Linux specific, meaning there is no support for other operating systems, same as <a href="../man8/netsniff-ng.8.html"><strong>netsniff-ng</strong>(8)</a>, thus we can keep the code footprint quite minimal and to the point. trafgen makes use of <a href="../man7/packet.7.html"><strong>packet</strong>(7)</a> socket's TX_RING interface of the Linux kernel, which is a <a href="../man2/mmap.2.html"><strong>mmap</strong>(2)</a>'ed ring buffer shared between user and kernel space.</p><p>By default, trafgen starts as many processes as available CPUs, pins each of them to their respective CPU and sets up the ring buffer each in their own process space after having compiled a list of packets to transmit. Thus, this is likely the fastest one can get out of the box in terms of transmission performance from user space, without having to load unsupported or non-mainline third-party kernel modules. On Gigabit Ethernet, trafgen has a comparable performance to pktgen, the built-in Linux kernel traffic generator, except that trafgen is more flexible in terms of packet configuration possibilities. On 10-Gigabit-per-second Ethernet, trafgen might be slower than pktgen due to the user/kernel space overhead but still has a fairly high performance for out of the box kernels.</p><p>trafgen has the potential to do fuzz testing, meaning a packet configuration can be built with random numbers on all or certain packet offsets that are freshly generated each time a packet is sent out. With a built-in IPv4 ping, trafgen can send out an ICMP probe after each packet injection to the remote host in order to test if it is still responsive/alive. Assuming there is no answer from the remote host after a certain threshold of probes, the machine is considered dead and the last sent packet is printed together with the random seed that was used by trafgen. You might not really get lucky fuzz-testing the Linux kernel, but presumably there are buggy closed-source embedded systems or network driver's firmware files that are prone to bugs, where trafgen could help in finding them.</p><p>trafgen's configuration language is quite powerful, also due to the fact, that it supports C preprocessor macros. A stddef.h is being shipped with trafgen for this purpose, so that well known defines from Linux kernel or network programming can be reused. After a configuration file has passed the C preprocessor stage, it is processed by the trafgen packet compiler. The language itself supports a couple of features that are useful when assembling packets, such as built-in runtime checksum support for IP, UDP and TCP. Also it has an expression evaluator where arithmetic (basic operations, bit operations, bit shifting, ...) on constant expressions is being reduced to a single constant on compile time. Other features are ''fill'' macros, where a packet can be filled with n bytes by a constant, a compile-time random number or run-time random number (as mentioned with fuzz testing). Also, <a href="../man8/netsniff-ng.8.html"><strong>netsniff-ng</strong>(8)</a> is able to convert a pcap file into a trafgen configuration file, thus such a configuration can then be further tweaked for a given scenario.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONS</h2>
        <div class="sectioncontent">
<h3>-i &lt;cfg|-&gt;, -c &lt;cfg|i&gt;, --in &lt;cfg|-&gt;, --conf &lt;cfg|-&gt;</h3>
<p>Defines the input configuration file that can either be passed as a normal plain text file or via stdin (''-''). Note that currently, if a configuration is passed through stdin, only 1 CPU will be used.</p>
<h3>-o &lt;dev&gt;, -d &lt;dev&gt;, --out &lt;dev&gt;, --dev &lt;dev&gt;</h3>
<p>Defines the outgoing networking device such as eth0, wlan0 and others.</p>
<h3>-p, --cpp</h3>
<p>Pass the packet configuration to the C preprocessor before reading it into trafgen. This allows #define and #include directives (e.g. to include definitions from system headers) to be used in the trafgen configuration file.</p>
<h3>-D &lt;name&gt;=&lt;definition&gt;, --define &lt;name&gt;=&lt;definition&gt;</h3>
<p>Add macro definition for the C preprocessor to use it within trafgen file. This option is used in combination with the -p,--cpp option.</p>
<h3>-J, --jumbo-support</h3>
<p>By default trafgen's ring buffer frames are of a fixed size of 2048 bytes. This means that if you're expecting jumbo frames or even super jumbo frames to pass your line, then you will need to enable support for that with the help of this option. However, this has the disadvantage of a performance regression and a bigger memory footprint for the ring buffer.</p>
<h3>-R, --rfraw</h3>
<p>In case the output networking device is a wireless device, it is possible with trafgen to turn this into monitor mode and create a mon&lt;X&gt; device that trafgen will be transmitting on instead of wlan&lt;X&gt;, for instance. This enables trafgen to inject raw 802.11 frames.</p>
<h3>-s &lt;ipv4&gt;, --smoke-test &lt;ipv4&gt;</h3>
<p>In case this option is enabled, trafgen will perform a smoke test. In other words, it will probe the remote end, specified by an &lt;ipv4&gt; address, that is being ''attacked'' with trafgen network traffic, if it is still alive and responsive. That means, after each transmitted packet that has been configured, trafgen sends out ICMP echo requests and waits for an answer before it continues. In case the remote end stays unresponsive, trafgen assumes that the machine has crashed and will print out the content of the last packet as a trafgen packet configuration and the random seed that has been used in order to reproduce a possible bug. This might be useful when testing proprietary embedded devices. It is recommended to have a direct link between the host running trafgen and the host being attacked by trafgen.</p>
<h3>-n &lt;0|uint&gt;, --num &lt;0|uint&gt;</h3>
<p>Process a number of packets and then exit. If the number of packets is 0, then this is equivalent to infinite packets resp. processing until interrupted. Otherwise, a number given as an unsigned integer will limit processing.</p>
<h3>-r, --rand</h3>
<p>Randomize the packet selection of the configuration file. By default, if more than one packet is defined in a packet configuration, packets are scheduled for transmission in a round robin fashion. With this option, they are selected randomly instread.</p>
<h3>-P &lt;uint&gt;, --cpus &lt;uint&gt;</h3>
<p>Specify the number of processes trafgen shall <a href="../man2/fork.2.html"><strong>fork</strong>(2)</a> off. By default trafgen will start as many processes as CPUs that are online and pin them to each, respectively. Allowed value must be within interval [1,CPUs].</p>
<h3>-t &lt;time&gt;, --gap &lt;time&gt;</h3>
<p>Specify a static inter-packet timegap in seconds, milliseconds, microseconds, or nanoseconds: ''&lt;num&gt;s/ms/us/ns''. If no postfix is given default to microseconds. If this option is given, then instead of <a href="../man7/packet.7.html"><strong>packet</strong>(7)</a>'s TX_RING interface, trafgen will use <a href="../man2/sendto.2.html"><strong>sendto</strong>(2)</a> I/O for network packets, even if the &lt;time&gt; argument is 0. This option is useful for a couple of reasons: i) comparison between <a href="../man2/sendto.2.html"><strong>sendto</strong>(2)</a> and TX_RING performance, ii) low-traffic packet probing for a given interval, iii) ping-like debugging with specific payload patterns. Furthermore, the TX_RING interface does not cope with interpacket gaps.</p>
<h3>-b &lt;rate&gt;, --rate &lt;rate&gt;</h3>
<p>Specify the packet send rate &lt;num&gt;pps/B/kB/MB/GB/kbit/Mbit/Gbit/KiB/MiB/GiB units. Like with the -t,--gap option, the packets are sent in slow mode.</p>
<h3>-S &lt;size&gt;, --ring-size &lt;size&gt;</h3>
<p>Manually define the TX_RING resp. TX_RING size in ''&lt;num&gt;KiB/MiB/GiB''. On default the size is being determined based on the network connectivity rate.</p>
<h3>-E &lt;uint&gt;, --seed &lt;uint&gt;</h3>
<p>Manually set the seed for pseudo random number generator (PRNG) in trafgen. By default, a random seed from /dev/urandom is used to feed glibc's PRNG. If that fails, it falls back to the unix timestamp. It can be useful to set the seed manually in order to be able to reproduce a trafgen session, e.g. after fuzz testing.</p>
<h3>-u &lt;uid&gt;, --user &lt;uid&gt; resp. -g &lt;gid&gt;, --group &lt;gid&gt;</h3>
<p>After ring setup, drop privileges to a non-root user/group combination.</p>
<h3>-H, --prio-high</h3>
<p>Set this process as a high priority process in order to achieve a higher scheduling rate resp. CPU time. This is however not the default setting, since it could lead to starvation of other processes, for example low priority kernel threads.</p>
<h3>-A, --no-sock-mem</h3>
<p>Do not change systems default socket memory setting during testrun. Default is to boost socket buffer memory during the test to:</p>
<pre>
   /proc/sys/net/core/rmem_default:4194304
   /proc/sys/net/core/wmem_default:4194304
   /proc/sys/net/core/rmem_max:104857600
   /proc/sys/net/core/wmem_max:104857600
</pre>

<h3>-Q, --notouch-irq</h3>
<p>Do not reassign the NIC's IRQ CPU affinity settings.</p>
<h3>-q, --qdisc-path</h3>
<p>Since Linux 3.14, the kernel supports a socket option PACKET_QDISC_BYPASS, which trafgen enables by default.  This options disables the qdisc bypass, and uses the normal send path through the kernel's qdisc (traffic control) layer, which can be usefully for testing the qdisc path.</p>
<h3>-V, --verbose</h3>
<p>Let trafgen be more talkative and let it print the parsed configuration and some ring buffer statistics.</p>
<h3>-e, --example</h3>
<p>Show a built-in packet configuration example. This might be a good starting point for an initial packet configuration scenario.</p>
<h3>-C, --no-cpu-stats</h3>
<p>Do not print CPU time statistics on exit.</p>
<h3>-v, --version</h3>
<p>Show version information and exit.</p>
<h3>-h, --help</h3>
<p>Show user help and exit.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNTAX</h2>
        <div class="sectioncontent">
<p>trafgen's packet configuration syntax is fairly simple. The very basic things one needs to know is that a configuration file is a simple plain text file where packets are defined. It can contain one or more packets. Packets are enclosed by opening '{' and closing '}' braces, for example:</p>
<pre>
   { /* packet 1 content goes here ... */ }
   { /* packet 2 content goes here ... */ }
</pre>
<p>Alternatively, packets can also be specified directly on the command line, using the same syntax as used in the configuration files.</p><p>When trafgen is started using multiple CPUs (default), then each of those packets will be scheduled for transmission on all CPUs by default. However, it is possible to tell trafgen to schedule a packet only on a particular CPU:</p>
<pre>
   <strong>cpu</strong>(1): { /* packet 1 content goes here ... */ }
   cpu(2-3): { /* packet 2 content goes here ... */ }
</pre>
<p>Thus, in case we have a 4 core machine with CPU0-CPU3, packet 1 will be scheduled only on CPU1, packet 2 on CPU2 and CPU3. When using trafgen with --num option, then these constraints will still be valid and the packet is fairly distributed among those CPUs.</p><p>Packet content is delimited either by a comma or whitespace, or both:</p>
<pre>
   { 0xca, 0xfe, 0xba 0xbe }
</pre>
<p>Packet content can be of the following:</p>
<pre>
   hex bytes:   0xca, xff
   decimal:     42
   binary:      0b11110000, b11110000
   octal:       011
   character:   'a'
   string:      "hello world"
   shellcode:   "&#92;x31&#92;xdb&#92;x8d&#92;x43&#92;x17&#92;x99&#92;xcd&#92;x80&#92;x31&#92;xc9"
</pre>
<p>Thus, a quite useless packet configuration might look like this (one can verify this when running this with trafgen in combination with -V):</p>
<pre>
   { 0xca, 42, 0b11110000, 011, 'a', "hello world",
     "&#92;x31&#92;xdb&#92;x8d&#92;x43&#92;x17&#92;x99&#92;xcd&#92;x80&#92;x31&#92;xc9" }
</pre>
<p>There are a couple of helper functions in trafgen's language to make life easier to write configurations:</p><p>i) Fill with garbage functions:</p>
<pre>
   byte fill function:      fill(&lt;content&gt;, &lt;times&gt;): fill(0xca, 128)
   compile-time random:     rnd(&lt;times&gt;): rnd(128), rnd()
   runtime random numbers:  drnd(&lt;times&gt;): drnd(128), drnd()
   compile-time counter:    seqinc(&lt;start-val&gt;, &lt;increment&gt;, &lt;times&gt;)
                            seqdec(&lt;start-val&gt;, &lt;decrement&gt;, &lt;times&gt;)
   runtime counter (1byte): dinc(&lt;min-val&gt;, &lt;max-val&gt;, &lt;increment&gt;)
                            ddec(&lt;min-val&gt;, &lt;max-val&gt;, &lt;decrement&gt;)
</pre>
<p>ii) Checksum helper functions (packet offsets start with 0):</p>
<pre>
   IP/ICMP checksum:        csumip/csumicmp(&lt;off-from&gt;, &lt;off-to&gt;)
   UDP checksum:            csumudp(&lt;off-iphdr&gt;, &lt;off-udpdr&gt;)
   TCP checksum:            csumtcp(&lt;off-iphdr&gt;, &lt;off-tcphdr&gt;)
   UDP checksum (IPv6):     csumudp6(&lt;off-ip6hdr&gt;, &lt;off-udpdr&gt;)
   TCP checksum (IPv6):     csumtcp6(&lt;off-ip6hdr&gt;, &lt;off-tcphdr&gt;)
</pre>
<p>iii) Multibyte functions, compile-time expression evaluation:</p>
<pre>
   const8(&lt;content&gt;), c8(&lt;content&gt;), const16(&lt;content&gt;), c16(&lt;content&gt;),
   const32(&lt;content&gt;), c32(&lt;content&gt;), const64(&lt;content&gt;), c64(&lt;content&gt;)
</pre>

<pre>
   These functions write their result in network byte order into the packet
</pre>
<p>configuration, e.g. const16(0xaa) will result in ''00 aa''. Within c*() functions, it is possible to do some arithmetics: -,+,*,/,%,&,|,&lt;&lt;,&gt;&gt;,^ E.g. const16((((1&lt;&lt;8)+0x32)|0b110)*2) will be evaluated to ''02 6c''.</p><p>iv) Protocol header functions: The protocol header functions allow to fill protocol header fields by using following generic syntax:</p><p>&lt;proto&gt;(&lt;field&gt;=&lt;value&gt;,&lt;field2&gt;=&lt;value2&gt;,...,&lt;field3&gt;,...)</p><p>If a field is not specified, then a default value will be used (usually 0). Protocol fields might be set in any order. However, the offset of the fields in the resulting packet is according to the respective protocol.</p><p>All required lower layer headers will be filled automatically if they were not specified by the user. The headers will be filled in the order they were specified. Each header will be filled with some mimimum required set of fields.</p><p>Supported protocol headers:</p><p><em>Ethernet</em> : <strong>eth(da=&lt;mac&gt;, sa=&lt;mac&gt;, type=&lt;number&gt;)</strong></p><p><strong>da|daddr</strong> - Destination MAC address (default: 00:00:00:00:00:00)</p><p><strong>sa|saddr</strong> - Source MAC address (default: device MAC address)</p><p><strong>etype|type|prot|proto</strong> - Ethernet type (default: 0)</p><p><em>VLAN</em> : <strong>vlan(tpid=&lt;number&gt;, id=&lt;number&gt;, dei=&lt;number&gt;, tci=&lt;number&gt;, pcp=&lt;number&gt;, 1q, 1ad)</strong></p><p><strong>tpid|prot|proto</strong> - Tag Protocol Identifier (TPID) (default: 0x8100)</p><p><strong>tci</strong> - Tag Control Information (TCI) field (VLAN Id + PCP + DEI) (default: 0)</p><p><strong>dei|cfi</strong> - Drop Eligible Indicator (DEI), formerly Canonical Format Indicator (CFI) (default: 0)</p><p><strong>pcp</strong> - Priority code point (PCP) (default: 0)</p><p><strong>id</strong> - VLAN Identifier (default: 0)</p><p><strong>1q</strong> - Set 802.1q header (TPID: 0x8100)</p><p><strong>1ad</strong> - Set 802.1ad header (TPID: 0x88a8)</p><p>By default, if the lower level header is Ethernet, its EtherType is set to 0x8100 (802.1q).</p><p><em>MPLS</em> : <strong>mpls(label=&lt;number&gt;, tc|exp=&lt;number&gt;, last=&lt;number&gt;, ttl=&lt;number&gt;)</strong></p><p><strong>label|lbl</strong> - MPLS label value (default: 0)</p><p><strong>tclass|tc|exp</strong> - Traffic Class for QoS field (default: 0)</p><p><strong>last</strong> - Bottom of stack S-flag (default: 1 for most last label)</p><p><strong>ttl</strong> - Time To Live (TTL) (default: 0)</p><p>By default, if the lower level header is Ethernet, its EtherType is set to 0x8847 (MPLS Unicast). S-flag is set automatically to 1 for the last label and resets to 0 if the lower MPLS label was added after.</p><p><em>ARP</em> : <strong>arp(htype=&lt;number&gt;, ptype=&lt;number&gt;, op=&lt;request|reply|number&gt;, request,</strong> <strong>reply, smac=&lt;mac&gt;, sip=&lt;ip4_addr&gt;, tmac=&lt;mac&gt;, tip=&lt;ip4_addr&gt;)</strong></p><p><strong>htype</strong> - ARP hardware type (default: 1 [Ethernet])</p><p><strong>ptype</strong> - ARP protocol type (default: 0x0800 [IPv4])</p><p><strong>op</strong> - ARP operation type (request/reply) (default: request)</p><p><strong>req|request</strong> - ARP Request operation type</p><p><strong>reply</strong> - ARP Reply operation type</p><p><strong>smac|sha</strong> - Sender hardware (MAC) address (default: device MAC address)</p><p><strong>sip|spa</strong> - Sender protocol (IPv4) address (default: device IPv4 address)</p><p><strong>tmac|tha</strong> - Target hardware (MAC) address (default: 00:00:00:00:00:00)</p><p><strong>tip|tpa</strong> - Target protocol (IPv4) address (default: device IPv4 address)</p><p>By default, the ARP operation field is set to request and the Ethernet destination MAC address is set to the broadcast address (ff:ff:ff:ff:ff:ff).</p><p><em>IPv4</em> : <strong>ip4|ipv4(ihl=&lt;number&gt;, ver=&lt;number&gt;, len=&lt;number&gt;, csum=&lt;number&gt;,</strong> <strong>ttl=&lt;number&gt;, tos=&lt;number&gt;, dscp=&lt;number&gt;, ecn=&lt;number&gt;,</strong> <strong>id=&lt;number&gt;, flags=&lt;number&gt;, frag=&lt;number&gt;, df, mf, da=&lt;ip4_addr&gt;, sa=&lt;ip4_addr&gt;,</strong> <strong>prot[o]=&lt;number&gt;)</strong></p><p><strong>ver|version</strong> - Version field (default: 4)</p><p><strong>ihl</strong> - Header length in number of 32-bit words (default: 5)</p><p><strong>tos</strong> - Type of Service (ToS) field (default: 0)</p><p><strong>dscp</strong> - Differentiated Services Code Point (DSCP, DiffServ) field (default: 0)</p><p><strong>ecn</strong> - Explicit Congestion Notification (ECN) field (default: 0)</p><p><strong>len|length</strong> - Total length of header and payload (calculated by default)</p><p><strong>id</strong> - IPv4 datagram identification (default: 0)</p><p><strong>flags</strong> - IPv4 flags value (DF, MF) (default: 0)</p><p><strong>df</strong> - Don't fragment (DF) flag (default: 0)</p><p><strong>mf</strong> - More fragments (MF) flag (default: 0)</p><p><strong>frag</strong> - Fragment offset field in number of 8 byte blocks (default: 0)</p><p><strong>ttl</strong> - Time to live (TTL) field (default: 0)</p><p><strong>csum</strong> - Header checksum (calculated by default)</p><p><strong>sa|saddr</strong> - Source IPv4 address (default: device IPv4 address)</p><p><strong>da|daddr</strong> - Destination IPv4 address (default: 0.0.0.0)</p><p><strong>prot|proto</strong> - IPv4 protocol number (default: 0)</p><p>By default, if the lower level header is Ethernet, its EtherType field is set to 0x0800 (IPv4). If the lower level header is IPv4, its protocol field is set to 0x4 (IP-in-IP).</p><p><em>IPv6</em> : <strong>ip6|ipv6(ver=&lt;number&gt;, class=&lt;number&gt;, flow=&lt;number&gt; len=&lt;number&gt;,</strong> <strong>nexthdr=&lt;number&gt;, hoplimit=&lt;number&gt;,</strong> <strong>da=&lt;ip6_addr&gt;, sa=&lt;ip6_addr&gt;)</strong></p><p><strong>ver|version</strong> - Version field (default: 6)</p><p><strong>tc|tclass</strong> - Traffic class (default: 0)</p><p><strong>fl|flow</strong> - Flow label (default: 0)</p><p><strong>len|length</strong> - Payload length (calculated by default)</p><p><strong>nh|nexthdr</strong> - Type of next header, i.e. transport layer protocol number (default: 0)</p><p><strong>hl|hoplimit|ttl</strong> - Hop limit, i.e. time to live (default: 0)</p><p><strong>sa|saddr</strong> - Source IPv6 address (default: device IPv6 address)</p><p><strong>da|daddr</strong> - Destination IPv6 address (default: 0:0:0:0:0:0:0:0)</p><p>By default, if the lower level header is Ethernet, its EtherType field is set to 0x86DD (IPv6).</p><p><em>ICMPv4</em> : <strong>icmp4|icmpv4(type=&lt;number&gt;, code=&lt;number&gt;, echorequest, echoreply,</strong> <strong>csum=&lt;number&gt;, mtu=&lt;number&gt;, seq=&lt;number&gt;, id=&lt;number&gt;, addr=&lt;ip4_addr&gt;)</strong></p><p><strong>type</strong> - Message type (default: 0 - Echo reply)</p><p><strong>code</strong> - Message code (default: 0)</p><p><strong>echorequest</strong> - ICMPv4 echo (ping) request (type: 8, code: 0)</p><p><strong>echoreply</strong> - ICMPv4 echo (ping) reply (type: 0, code: 0)</p><p><strong>csum</strong> - Checksum of ICMPv4 header and payload (calculated by default)</p><p><strong>mtu</strong> - Next-hop MTU field used in 'Datagram is too big' message type (default; 0)</p><p><strong>seq</strong> - Sequence number used in Echo/Timestamp/Address mask messages (default: 0)</p><p><strong>id</strong> - Identifier used in Echo/Timestamp/Address mask messages (default: 0)</p><p><strong>addr</strong> - IPv4 address used in Redirect messages (default: 0.0.0.0)</p><p>Example ICMP echo request (ping):</p><p>{ icmpv4(echorequest, seq=1, id=1326) }</p><p><em>ICMPv6</em> : <strong>icmp6|icmpv6(type=&lt;number&gt;, echorequest, echoreply, code=&lt;number&gt;,</strong> <strong>csum=&lt;number&gt;)</strong></p><p><strong>type</strong> - Message type (default: 0)</p><p><strong>code</strong> - Code (default: 0)</p><p><strong>echorequest</strong> - ICMPv6 echo (ping) request</p><p><strong>echoreply</strong> - ICMPv6 echo (ping) reply</p><p><strong>csum</strong> - Message checksum (calculated by default)</p><p>By default, if the lower level header is IPv6, its Next Header field is set to 58 (ICMPv6).</p><p><em>UDP</em> : <strong>udp(sp=&lt;number&gt;, dp=&lt;number&gt;, len=&lt;number&gt;, csum=&lt;number&gt;)</strong></p><p><strong>sp|sport</strong> - Source port (default: 0)</p><p><strong>dp|dport</strong> - Destination port (default: 0)</p><p><strong>len|length</strong> - Length of UDP header and data (calculated by default)</p><p><strong>csum</strong> - Checksum field over IPv4 pseudo header (calculated by default)</p><p>By default, if the lower level header is IPv4, its protocol field is set to 0x11 (UDP).</p><p><em>TCP</em> : <strong>tcp(sp=&lt;number&gt;, dp=&lt;number&gt;, seq=&lt;number&gt;, aseq|ackseq=&lt;number&gt;, doff|hlen=&lt;number&gt;,</strong> <strong>cwr, ece|ecn, urg, ack, psh, rst, syn, fin, win|window=&lt;number&gt;, csum=&lt;number&gt;,</strong> <strong>urgptr=&lt;number&gt;)</strong></p><p><strong>sp|sport</strong> - Source port (default: 0)</p><p><strong>dp|dport</strong> - Destination port (default: 0)</p><p><strong>seq</strong> - Sequence number (default: 0)</p><p><strong>aseq|ackseq</strong> - Acknowledgement number (default: 0)</p><p><strong>doff|hlen</strong> - Header size (data offset) in number of 32-bit words (default: 5)</p><p><strong>cwr</strong> - Congestion Window Reduced (CWR) flag (default: 0)</p><p><strong>ece|ecn</strong> - ECN-Echo (ECE) flag (default: 0)</p><p><strong>urg</strong> - Urgent flag (default: 0)</p><p><strong>ack</strong> - Acknowledgement flag (default: 0)</p><p><strong>psh</strong> - Push flag (default: 0)</p><p><strong>rst</strong> - Reset flag (default: 0)</p><p><strong>syn</strong> - Synchronize flag (default: 0)</p><p><strong>fin</strong> - Finish flag (default: 0)</p><p><strong>win|window</strong> - Receive window size (default: 0)</p><p><strong>csum</strong> - Checksum field over IPv4 pseudo header (calculated by default)</p><p><strong>urgptr</strong> - Urgent pointer (default: 0)</p><p>By default, if the lower level header is IPv4, its protocol field is set to 0x6 (TCP).</p><p>Simple example of a UDP Echo packet:</p>
<pre>
   {
     eth(da=11:22:33:44:55:66),
     ipv4(daddr=1.2.3.4)
     udp(dp=7),
     "Hello world"
   }
</pre>
<p>Furthermore, there are two types of comments in trafgen configuration files:</p>
<pre>
  1. Multi-line C-style comments:        /* put comment here */
  2. Single-line Shell-style comments:   #  put comment here
</pre>
<p>Next to all of this, a configuration can be passed through the C preprocessor before the trafgen compiler gets to see it with option --cpp. To give you a taste of a more advanced example, run ''trafgen -e'', fields are commented:</p>
<pre>
   /* Note: dynamic elements make trafgen slower! */
   #include &lt;stddef.h&gt;
</pre>

<pre>
   {
     /* MAC Destination */
     fill(0xff, ETH_ALEN),
     /* MAC Source */
     0x00, 0x02, 0xb3, <strong>drnd</strong>(3),
     /* IPv4 Protocol */
     c16(ETH_P_IP),
     /* IPv4 Version, IHL, TOS */
     0b01000101, 0,
     /* IPv4 Total Len */
     c16(59),
     /* IPv4 Ident */
     <strong>drnd</strong>(2),
     /* IPv4 Flags, Frag Off */
     0b01000000, 0,
     /* IPv4 TTL */
     64,
     /* Proto TCP */
     0x06,
     /* IPv4 Checksum (IP header from, to) */
     csumip(14, 33),
     /* Source IP */
     <strong>drnd</strong>(4),
     /* Dest IP */
     <strong>drnd</strong>(4),
     /* TCP Source Port */
     <strong>drnd</strong>(2),
     /* TCP Dest Port */
     c16(80),
     /* TCP Sequence Number */
     <strong>drnd</strong>(4),
     /* TCP Ackn. Number */
     <strong>c32</strong>(0),
     /* TCP Header length + TCP SYN/ECN Flag */
     c16((8 &lt;&lt; 12) | TCP_FLAG_SYN | TCP_FLAG_ECE)
     /* Window Size */
     c16(16),
     /* TCP Checksum (offset IP, offset TCP) */
     csumtcp(14, 34),
     /* TCP Options */
     0x00, 0x00, 0x01, 0x01, 0x08, 0x0a, 0x06,
     0x91, 0x68, 0x7d, 0x06, 0x91, 0x68, 0x6f,
     /* Data blob */
     "gotcha!",
   }
</pre>
<p>Another real-world example by Jesper Dangaard Brouer [1]:</p>
<pre>
   {
     # --- ethernet header ---
     0x00, 0x1b, 0x21, 0x3c, 0x9d, 0xf8,  # mac destination
     0x90, 0xe2, 0xba, 0x0a, 0x56, 0xb4,  # mac source
     const16(0x0800), # protocol
     # --- ip header ---
     # ipv4 version (4-bit) + ihl (4-bit), tos
     0b01000101, 0,
     # ipv4 total len
     const16(40),
     # id (note: runtime dynamic random)
     <strong>drnd</strong>(2),
     # ipv4 3-bit flags + 13-bit fragment offset
     # 001 = more fragments
     0b00100000, 0,
     64, # ttl
     17, # proto udp
     # dynamic ip checksum (note: offsets are zero indexed)
     csumip(14, 33),
     192, 168, 51, 1, # source ip
     192, 168, 51, 2, # dest ip
     # --- udp header ---
     # as this is a fragment the below stuff does not matter too much
     const16(48054), # src port
     const16(43514), # dst port
     const16(20),    # udp length
     # udp checksum can be dyn calc via csumudp(offset ip, offset tcp)
     # which is csumudp(14, 34), but for udp its allowed to be zero
     <strong>const16</strong>(0),
     # payload
     'A',  fill(0x41, 11),
   }
</pre>

<pre>
   [1] http://thread.gmane.org/gmane.linux.network/257155
</pre>
<p>The above example rewritten using the header generation functions:</p>
<pre>
   {
     # --- ethernet header ---
     eth(da=00:1b:21:3c:9d:f8, da=90:e2:ba:0a:56:b4, proto=0x0800)
     # --- ip header ---
     ipv4(len=40, id=<strong>drnd</strong>(2), mf, ttl=64, proto=17, sa=192.168.51.1, da=192.168.51.2)
     # --- udp header ---
     udp(sport=48054, dport=43514, len=20, csum=0)
     # payload
     'A',  fill(0x41, 11),
   }
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">USAGE EXAMPLE</h2>
        <div class="sectioncontent">
<h3>trafgen --dev eth0 --conf trafgen.cfg</h3>
<p>This is the most simple and, probably, the most common use of trafgen. It will generate traffic defined in the configuration file ''trafgen.cfg'' and transmit this via the ''eth0'' networking device. All online CPUs are used.</p>
<h3>trafgen -e | trafgen -i - -o lo --cpp -n 1</h3>
<p>This is an example where we send one packet of the built-in example through the loopback device. The example configuration is passed via stdin and also through the C preprocessor before trafgen's packet compiler will see it.</p>
<h3>trafgen --dev eth0 --conf fuzzing.cfg --smoke-test 10.0.0.1</h3>
<p>Read the ''fuzzing.cfg'' packet configuration file (which contains drnd() calls) and send out the generated packets to the ''eth0'' device. After each sent packet, ping probe the attacked host with address 10.0.0.1 to check if it's still alive. This also means, that we utilize 1 CPU only, and do not use the TX_RING, but <a href="../man2/sendto.2.html"><strong>sendto</strong>(2)</a> packet I/O due to ''slow mode''.</p>
<h3>trafgen --dev wlan0 --rfraw --conf beacon-test.txf -V --cpus 2</h3>
<p>As an output device ''wlan0'' is used and put into monitoring mode, thus we are going to transmit raw 802.11 frames through the air. Use the  ''beacon-test.txf'' configuration file, set trafgen into verbose mode and use only 2 CPUs.</p>
<h3>trafgen --dev em1 --conf frag_dos.cfg --rand --gap 1000us</h3>
<p>Use trafgen in <a href="../man2/sendto.2.html"><strong>sendto</strong>(2)</a> mode instead of TX_RING mode and sleep after each sent packet a static timegap for 1000us. Generate packets from ''frag_dos.cfg'' and select next packets to send randomly instead of a round-robin fashion. The output device for packets is ''em1''.</p>
<h3>trafgen --dev eth0 --conf icmp.cfg --rand --num 1400000 -k1000</h3>
<p>Send only 1400000 packets using the ''icmp.cfg'' configuration file and then exit trafgen. Select packets randomly from that file for transmission and send them out via ''eth0''. Also, trigger the kernel every 1000us for batching the ring frames from user space (default is 10us).</p>
<h3>trafgen --dev eth0 --conf tcp_syn.cfg -u `id -u bob` -g `id -g bob`</h3>
<p>Send out packets generated from the configuration file ''tcp_syn.cfg'' via the ''eth0'' networking device. After setting up the ring for transmission, drop credentials to the non-root user/group bob/bob.</p>
<h3>trafgen --dev eth0 '{ fill(0xff, 6), 0x00, 0x02, 0xb3, <strong>rnd</strong>(3), c16(0x0800), fill(0xca, 64) }' -n 1</h3>
<p>Send out 1 invaid IPv4 packet built from command line to all hosts.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTE</h2>
        <div class="sectioncontent">
<p>trafgen can saturate a Gigabit Ethernet link without problems. As always, of course, this depends on your hardware as well. Not everywhere where it says Gigabit Ethernet on the box, will you reach almost physical line rate! Please also read the <a href="../man8/netsniff-ng.8.html"><strong>netsniff-ng</strong>(8)</a> man page, section NOTE for further details about tuning your system e.g. with <strong>tuned</strong>(8).</p><p>If you intend to use trafgen on a 10-Gbit/s Ethernet NIC, make sure you are using a multiqueue tc(8) discipline, and make sure that the packets you generate with trafgen will have a good distribution among tx_hashes so that you'll actually make use of multiqueues.</p><p>For introducing bit errors, delays with random variation and more, there is no built-in option in trafgen. Rather, one should reuse existing methods for that which integrate nicely with trafgen, such as tc(8) with its different disciplines, i.e. netem.</p><p>For more complex packet configurations, it is recommended to use high-level scripting for generating trafgen packet configurations in a more automated way, i.e. also to create different traffic distributions that are common for industrial benchmarking:</p>
<pre>
    Traffic model              Distribution
</pre>

<pre>
    IMIX                       64:7,  570:4,  1518:1
    Tolly                      64:55,  78:5,   576:17, 1518:23
    Cisco                      64:7,  594:4,  1518:1
    RPR Trimodal               64:60, 512:20, 1518:20
    RPR Quadrimodal            64:50, 512:15, 1518:15, 9218:20
</pre>
<p>The low-level nature of trafgen makes trafgen rather protocol independent and therefore useful in many scenarios when stress testing is needed, for instance. However, if a traffic generator with higher level packet descriptions is desired, netsniff-ng's <a href="../man8/mausezahn.8.html"><strong>mausezahn</strong>(8)</a> can be of good use as well.</p><p>For smoke/fuzz testing with trafgen, it is recommended to have a direct link between the host you want to analyze (''victim'' machine) and the host you run trafgen on (''attacker'' machine). If the ICMP reply from the victim fails, we assume that probably its kernel crashed, thus we print the last sent packet together with the seed and quit probing. It might be very unlikely to find such a ping-of-death on modern Linux systems. However, there might be a good chance to find it on some proprietary (e.g. embedded) systems or buggy driver firmwares that are in the wild. Also, fuzz testing can be done on raw 802.11 frames, of course. In case you find a ping-of-death, please mention that you were using trafgen in your commit message of the fix!</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>For old trafgen versions only, there could occur kernel crashes: we have fixed this bug in the mainline and stable kernels under commit 7f5c3e3a8 (''af_packet: remove BUG statement in tpacket_destruct_skb'') and also in trafgen.</p><p>Probably the best is if you upgrade trafgen to the latest version.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LEGAL</h2>
        <div class="sectioncontent">
<p>trafgen is licensed under the GNU GPL version 2.0.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">HISTORY</h2>
        <div class="sectioncontent">
<p><strong>trafgen</strong> was originally written for the netsniff-ng toolkit by Daniel Borkmann. It is currently maintained by Tobias Klauser &lt;tklauser@distanz.ch&gt; and Daniel Borkmann &lt;dborkma@tik.ee.ethz.ch&gt;.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO trafgen&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man8/netsniff-ng.8.html"><strong>netsniff-ng</strong>(8)</a>, <a href="../man8/mausezahn.8.html"><strong>mausezahn</strong>(8)</a>, <a href="../man8/ifpps.8.html"><strong>ifpps</strong>(8)</a>, <a href="../man8/bpfc.8.html"><strong>bpfc</strong>(8)</a>, <a href="../man8/flowtop.8.html"><strong>flowtop</strong>(8)</a>, <a href="../man8/astraceroute.8.html"><strong>astraceroute</strong>(8)</a>, <a href="../man8/curvetun.8.html"><strong>curvetun</strong>(8)</a></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Manpage was written by Daniel Borkmann.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COLOPHON</h2>
        <div class="sectioncontent">
<p>This page is part of the Linux netsniff-ng toolkit project. A description of the project, and information about reporting bugs, can be found at http://netsniff-ng.org/.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="togglesebool.8.html"><span aria-hidden="true">&larr;</span> togglesebool.8: Flip the current value of a selinux boolean</a></li>
   <li class="next"><a href="tunelp.8.html">tunelp.8: Set various parameters for the lp device <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

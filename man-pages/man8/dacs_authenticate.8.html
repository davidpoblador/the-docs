<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>dacs_authenticate: Dacs authentication service</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Dacs authentication service">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="dacs_authenticate (8) manual">
  <meta name="twitter:description" content="Dacs authentication service">
  <meta name="twitter:image" content="https://www.carta.tech/images/dacs-dacs_authenticate-8.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man8/dacs_authenticate.8.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="dacs_authenticate (8) manual" />
  <meta property="og:description" content="Dacs authentication service" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/dacs-dacs_authenticate-8.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">dacs_authenticate<small> (8)</small></h1>
        <p class="lead">Dacs authentication service</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man8/">
      <span itemprop="name">System administration commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man8/dacs_authenticate.8.html">
      <span itemprop="name">dacs_authenticate: Dacs authentication service</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/dacs/">
      <span itemprop="name">dacs</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man8/dacs_authenticate.8.html">
      <span itemprop="name">dacs_authenticate: Dacs authentication service</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>dacs_authenticate</strong> [<em>\m[blue]</em><strong>dacsoptions</strong>\m[]\s-2\u[1]\d\s+2]</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This web service is part of the <strong>DACS</strong> suite.</p><p>The <strong>dacs_authenticate</strong> web service is an authentication "driver" for <strong>DACS</strong>. When it receives a request to authenticate a user, it usually invokes one or more authentication modules, depending on its configuration. Successful authentication assigns a <strong>DACS</strong> user identity to the user and roles modules may be invoked to determine the roles with which the identity is associated; <strong>DACS</strong>credentials are generated and returned to the user. The caller of <strong>dacs_authenticate</strong> can be redirected to a configured URL, called the post-authentication handler (or just the handler), depending on whether authentication fails or succeeds.</p><p>General <strong>DACS</strong> configuration directives are discussed in \m[blue]<strong>dacs.conf</strong>(5)</strong>\m[]\s-2\u[2]\d\s+2. Configuration directives specific to authentication are described here.</p><p><strong>DACS</strong> expressions are described in \m[blue]<a href="../man5/dacs.exprs.5.html"><strong>dacs.exprs</strong>(5)</a></strong>\m[]\s-2\u[3]\d\s+2.</p><p><strong>dacs_authenticate</strong> might be called from an HTML form (see the distribution&apos;s \m[blue]<strong>html/examples</strong>\m[]\s-2\u[4]\d\s+2 directory for examples of simple login pages), directly through a link on a web page, indirectly by <strong>DACS</strong>\m[blue]<strong>HTTP Authentication</strong>\m[]\s-2\u[5]\d\s+2, or from middleware.</p><p>Command line authentication functionality is provided by \m[blue]<a href="../man1/dacsauth.1.html"><strong>dacsauth</strong>(1)</a></strong>\m[]\s-2\u[6]\d\s+2. Other authentication mechanisms are provided by \m[blue]<a href="../man8/dacs_auth_agent.8.html"><strong>dacs_auth_agent</strong>(8)</a></strong>\m[]\s-2\u[7]\d\s+2, \m[blue]<a href="../man8/dacs_auth_transfer.8.html"><strong>dacs_auth_transfer</strong>(8)</a></strong>\m[]\s-2\u[8]\d\s+2, and \m[blue]<a href="../man1/dacscookie.1.html"><strong>dacscookie</strong>(1)</a></strong>\m[]\s-2\u[9]\d\s+2.</p><h3>Authentication</h3>
<p>Authentication is the procedure by which a claimed identity is confirmed. Following successful authentication, <strong>DACS</strong> credentials may be created that represent the identity. For maximum convenience and interoperability in a web environment, <strong>DACS</strong> credentials are usually encapsulated within an HTTP cookie and transmitted over a TCP/IP connection secured by SSL. Any secure method of transporting credentials can be used instead, however, such as the value of an HTTP extension-header entity-header field in a request message sent over a VPN.</p><p>While <strong>dacs_authenticate</strong> provides powerful and flexible ways to combine and compose a variety of authentication methods, most <strong>DACS</strong> jurisdictions will configure only one method, or perhaps just a few methods, in simple ways.</p><p>To help integrate <strong>DACS</strong> seamlessly within a web site, <strong>dacs_authenticate</strong> allows handlers to be configured. Handlers allow various exceptions to be caught and processed so that an appropriate flow of control can occur. For example, if authentication succeeds the user can be redirected to a specific page, including the one originally requested before the exception occurred.</p><p>Authentication succeeds (and the user is authenticated) if and only if:</p><p>at least one \m[blue]<strong>Auth clause</strong>\m[]\s-2\u[10]\d\s+2 has been configured,</p><p>the semantics of all \m[blue]<strong>CONTROL</strong>\m[]\s-2\u[11]\d\s+2 directives satisfy the requirements for success,</p><p>the <strong>DACS</strong>\m[blue]<strong>username</strong>\m[]\s-2\u[12]\d\s+2 arrived at is syntactically valid, and</p><p>the identity&apos;s access has not been revoked or denied (see \m[blue]<a href="../man5/dacs.acls.5.html"><strong>dacs.acls</strong>(5)</a></strong>\m[]\s-2\u[13]\d\s+2).</p><p>An incorrect password, for instance, is not considered to be an error; it will cause its Auth clause to fail but depending on the control directives that have been configured, the user may still be successfully authenticated by some other Auth clause. True errors are fatal and cause <strong>dacs_authenticate</strong> to terminate without issuing credentials and possibly without invoking a handler.</p><p>If a <strong>DACS</strong> identity reauthenticates, the user agent is expected to replace the old credentials with new ones; if re-authentication fails (e.g., the password is incorrect), the old credentials should continue to exist. If a user establishes multiple concurrent identities, the user agent is expected to send all credentials with each service request in accordance with the relevant standards. This is standard behaviour for most common web browsers.</p><p>As an efficiency measure, the authentication architecture allows an authentication module to return roles.</p><p><strong>Names</strong></p><p>Please refer to \m[blue]<a href="../man1/dacs.1.html"><strong>dacs</strong>(1)</a></strong>\m[]\s-2\u[14]\d\s+2 for details about naming.</p><p><strong>Credentials and Cookies</strong></p><p><strong>DACS</strong> credentials are cryptographically protected XML documents (\m[blue]<strong>credentials.dtd</strong>\m[]\s-2\u[15]\d\s+2). They have been carefully designed to make it extremely difficult for an attacker to generate valid credentials, modify captured credentials to impersonate another user, or obtain greater access rights without being detected. <strong>DACS</strong> is careful to not produce log information or error messages that might benefit an attacker.</p><p>User agents and other software outside of <strong>DACS</strong> do not need to decrypt the credentials and do not possess the required encryption key.</p><p>New credentials are created and returned to the user after successful authentication. The lifetime of each set of credentials is independently configurable, but they are intended to be fairly transitory. If a user reauthenticates, new credentials different than previous credentials might well be returned (e.g., with different roles).</p><p><strong>DACS</strong> does not verify that a user&apos;s browser is configured to accept cookies - this is the responsibility of the <strong>DACS</strong> administrator (by supplying client-side code to test that cookies have been enabled, for instance). Failure to accept cookies may cause some features to be unavailable or work incorrectly. Also note that despite what <strong>DACS</strong> (or any other program) tells a browser about the lifetime of an HTTP cookie, browsers may be configured to impose a shorter lifetime and can delete a cookie at any time. (Aside: Firefox 2.0.0.3 appears to show cookies that have been deleted.)</p><p><strong>Security</strong></p><p>For <strong>DACS</strong> to operate securely, communication between a user (or middleware) and <strong>dacs_authenticate</strong>, which may include information such as passwords, <em>must only be transmitted over a secure connection (SSL)</em>.</p><p>Communication between <strong>dacs_authenticate</strong> (and <strong>dacsauth</strong>) and an external (not built-in) authentication module may include information such as passwords and therefore <em>should only be transmitted over a secure connection (SSL)</em> or in a way that is not subject to eavesdropping or attack.</p><p>For <strong>DACS</strong> to operate securely, regardless of how they are obtained, <strong>DACS</strong> credentials <em>must only be transmitted over a secure connection (SSL) so that they cannot easily be captured and reused by an attacker</em>.</p><p>It is unwise to configure both SSL and non-SSL communication. Besides providing an avenue for attack, it may cause <strong>DACS</strong> to behave strangely (e.g., infinite loops may occur because cookies obtained over an SSL connection are not subsequently forwarded over a non-SSL connection).</p><p>The apparent IP address of an authenticated user, as provided by the web server, is stored in credentials. <strong>DACS</strong> can be configured to consider credentials to be valid only for requests that come from that address (refer to the \m[blue]<strong>VERIFY_IP</strong>\m[]\s-2\u[16]\d\s+2 configuration directive), making it more difficult for an attacker to replay captured credentials.</p><p>In some environments this constraint is a good idea, but in general it is of dubious value so enable it with care. Where a user is behind a firewall or router that has multiple IP addresses, successive service requests might legitimately not appear to be coming from the same address and some requests would be denied if this constraint were enabled. In situations where credentials are being forwarded between web services they might be rejected. In the case of dial-up Internet access, a user might be issued credentials, lose the connection, and be assigned a different IP address upon reconnecting; the user would be forced to reauthenticate. Also, more than one user may be associated with a particular IP address, as when a Network Address Translation (NAT) facility such as \m[blue]<strong>natd</strong>(8)</strong>\m[]\s-2\u[17]\d\s+2 is used, so the check does not guarantee uniqueness.</p><p>Information associated with a user&apos;s browser can be included in credentials created for that user to make it difficult to reuse captured credentials with a different browser. Please refer to \m[blue]<strong>VERIFY_UA</strong>\m[]\s-2\u[18]\d\s+2 for details.</p><p>Credentials have a limit on their lifetime that is independent of the lifetime of the HTTP cookie that contains them; that is, credentials can expire without their cookie having expired, and vice versa. Expired credentials are recognized and will not be used by <strong>DACS</strong>. Refer to the \m[blue]<strong>AUTH_CREDENTIALS_DEFAULT_LIFETIME_SECS</strong>\m[]\s-2\u[19]\d\s+2 configuration directive for details.</p><p>Passwords do not appear in any credentials and are not stored once the user has been authenticated.</p><p>It is forbidden to submit multiple credentials for the same identity to <strong>DACS</strong> and such a request will trigger an error.</p><p>All <strong>DACS</strong> jurisdictions within the same federation share an algorithm and key to encrypt and decrypt credentials. A cryptographically secure, symmetric encryption function, Rijndael (the \m[blue]<strong>Advanced Encryption Standard</strong>\m[]\s-2\u[20]\d\s+2 (AES) algorithm and \m[blue]<strong>Federal Information Processing Standard</strong>\m[]\s-2\u[21]\d\s+2), is used. The same 128 bit key is used by all <strong>DACS</strong> jurisdictions. AES also supports 192 and 256 bit key lengths and either can be configured at build-time.</p><p>A cryptographically secure message authentication code (MAC) is employed to detect modification of credentials. A key different from the encryption key is used. The Keyed-Hash Message Authentication Code (HMAC, \m[blue]<strong>FIPS 198</strong>\m[]\s-2\u[22]\d\s+2, \m[blue]<strong>RFC 2104</strong>\m[]\s-2\u[23]\d\s+2, \m[blue]<strong>RFC 4635</strong>\m[]\s-2\u[24]\d\s+2, \m[blue]<strong>RFC 4868</strong>\m[]\s-2\u[25]\d\s+2), is employed using the 160-bit \m[blue]<strong>NIST</strong>\m[]\s-2\u[26]\d\s+2 secure hash standard, SHA-1 (\m[blue]<strong>FIPS 180-1</strong>\m[]\s-2\u[27]\d\s+2, \m[blue]<strong>RFC 4634</strong>\m[]\s-2\u[28]\d\s+2). In addition to SHA-1, SHA-224, SHA-256, SHA-384, and SHA-512 (\m[blue]<strong>FIPS 180-3</strong>\m[]\s-2\u[29]\d\s+2) can be used, although they must be configured at build-time.</p><p>The AES key length and HMAC digest algorithm used by a federation can be changed at any time, perhaps forcing some users to reauthenticate, but the same key length and digest algorithm must be used throughout a federation.</p><p><strong>Security</strong></p><p><strong>DACS</strong> can be configured to use the less secure but widely-used and somewhat more efficient \m[blue]<strong>MD5 algorithm</strong>\m[]\s-2\u[30]\d\s+2 instead, although it is deprecated and it will eventually be removed.</p><p>The \m[blue]<strong>Netscape HTTP Cookies Specification</strong>\m[]\s-2\u[31]\d\s+2 defines the syntax and semantics of the HTTP response header that a web server sends to a client; this syntax is used by default, but the \m[blue]<strong></strong><em>COOKIE_SYNTAX</em>\m[]\s-2\u[32]\d\s+2 argument can be used to request a different syntax. The Netscape format is as follows:</p>
<pre>
Set-Cookie: NAME=VALUE; expires=DATE; path=PATH; domain=DOMAIN_NAME; secure
</pre>
<p><strong>DACS</strong> formulates these response headers as follows.</p><p>The NAME attribute of an authentication cookie returned to the user (e.g., by <strong>dacs_authenticate</strong>) has the following format:</p>
<pre>
DACS:<em>federation-name</em>::[<em>jurisdiction-name</em>]:[<em>username</em>]
</pre>
<p>where <em>federation-name</em> is the official name assigned to the federation for which the cookie is valid, <em>jurisdiction-name</em> is the name of the authenticating jurisdiction, and <em>username</em> is the authenticated name of the user. If the <em>jurisdiction-name</em> is omitted, the <em>username</em> must also be omitted. Semicolons, commas, and whitespace within the name must be URL-style encoded. Colons are not allowed in any of the name components. Here is an example of a cookie name:</p>
<pre>
DACS:EXAMPLE::METALOGIC:rick@example.com
</pre>
<p>The VALUE attribute of a cookie is a printable text encoding of credentials.</p><p><strong>Security</strong></p><p>Although <strong>DACS</strong> performs validity tests on cookie names, middleware should not rely on cookie names for any purpose. An apparently valid <strong>DACS</strong> cookie can easily be crafted with any value. Also, an apparently legitimate cookie might convey expired or otherwise invalid credentials. Middleware should use \m[blue]<a href="../man8/dacs_current_credentials.8.html"><strong>dacs_current_credentials</strong>(8)</a></strong>\m[]\s-2\u[33]\d\s+2 to validate an authentication cookie and not trust cookie names.</p><p>No expires attribute is set; this will cause the cookie to be automatically deleted by a conforming browser when the user&apos;s browser session ends and not made persistent (i.e., not stored on disk for use in a subsequent browser session), closing a potential security hole.</p><p>By default, the value of the path attribute is "/", meaning the cookie will be sent with every request to the domain that created the cookie, whether it is for a <strong>DACS</strong>-wrapped service request or not. The \m[blue]<strong>COOKIE_PATH</strong>\m[]\s-2\u[34]\d\s+2 configuration directive can specify an alternative value. Using a more restricted path can potentially improve security. All of the jurisdiction&apos;s <strong>DACS</strong>-wrapped services must appear under that path, of course, or the cookie will not be sent; ideally, no non-<strong>DACS</strong> wrapped service would appear under that path.</p><p>The value of the domain attribute associated with the cookie is dependent on the uniform domain name scheme chosen for the jurisdictions. The value will be configured to be the most specific tail string that tail matches all participating domain names. For example, if the uniform domain name scheme has hostnames of the form xxx.example.com, yyy.example.com, and zzz.example.com, then the value of the attribute will be example.com. This will ensure that the user agent sends the cookie with any service request directed to a hostname ending in example.com.</p><p><strong>Tip</strong></p><p>The HTTP cookie specifications appear to say that a cookie having a domain attribute of example.com should <em>not</em> be sent to a host of the same name, yet both Mozilla and IE (and perhaps other browsers) do just that. Without this behaviour, it would not be possible to use a single domain name with multiple <strong>DACS</strong> jurisdictions below it; that is, given domain=example.com, it is expected that jurisdictions can be identified by URI path prefixes such as example.com/metalogic, example.com/test, and so on.</p><p>When operating securely (see the \m[blue]<strong>SECURE_MODE</strong>\m[]\s-2\u[35]\d\s+2 directive in \m[blue]<strong>dacs.conf</strong>(5)</strong>\m[]\s-2\u[2]\d\s+2) or when an authentication request is sent over SSL, the secure attribute will be present so that the cookie will only be transmitted if the communications channel with the host is a secure one. At present, browsers define this to mean that secure cookies will only be sent to HTTPS (HTTP over SSL) servers.</p>
<h3>Web Service Arguments</h3>
<p>In addition to the \m[blue]<strong>standard CGI arguments</strong>\m[]\s-2\u[36]\d\s+2, <strong>dacs_authenticate</strong> understands the following CGI arguments. Some arguments are optional, while others are required depending on the authentication configuration. An invalid argument value will usually cause authentication to fail immediately. Unrecognized arguments are ignored.</p><p><em>AUTH_ID</em></p><p>This optional argument is used with the user_sufficient keyword (refer to the \m[blue]<strong>CONTROL</strong>\m[]\s-2\u[11]\d\s+2 directive).</p><p><em>AUTH_PROMPT_VAR_PREFIX</em></p><p>Reserved for use by \m[blue]<strong>local_pam_authenticate</strong>\m[]\s-2\u[37]\d\s+2.</p><p><em>AUTH_TRANSID</em></p><p>Reserved for use by \m[blue]<strong>local_pam_authenticate</strong>\m[]\s-2\u[37]\d\s+2.</p><p><em>AUTHORIZATION</em></p><p>Used internally with \m[blue]<strong>HTTP Authentication</strong>\m[]\s-2\u[5]\d\s+2.</p><p><em>AUXILIARY</em></p><p>This argument can be used to pass additional authentication material to authentication modules.</p><p><em>COOKIE_SYNTAX</em></p><p>By default, the <em>de facto</em> standard \m[blue]<strong>Netscape HTTP Cookies Specification</strong>\m[]\s-2\u[31]\d\s+2 syntax is followed when cookies are created (COOKIE_SYNTAX=COOKIE_NETSCAPE). The value COOKIE_EXT_NETSCAPE selects an "extended" Netscape spec syntax (it&apos;s not the Netscape syntax but it&apos;s not fully RFC 2109 compliant either); instead of using the expires attribute it will use the Max-Age attribute as defined in \m[blue]<strong>RFC 2109</strong>\m[]\s-2\u[38]\d\s+2 and \m[blue]<strong>RFC 2965</strong>\m[]\s-2\u[39]\d\s+2. Attribute values are not quoted and there is no support for the Comment field. Parameter values COOKIE_RFC2109 and COOKIE_RFC2965 are recognized but not implemented.</p><p><strong>Note</strong></p><p>\m[blue]<strong>RFC 2109</strong>\m[]\s-2\u[38]\d\s+2 and \m[blue]<strong>RFC 2965</strong>\m[]\s-2\u[39]\d\s+2 forbid the following characters from appearing in the value of an HTTP cookie&apos;s NAME attribute:</p>
<pre>
( ) &lt;  &gt; @ , ; : &#92; "  /  [  ]  ? = {  }
</pre>
<p>Additionally, the space, tab, and all US-ASCII control characters (octets 0 - 31) and DEL (127) are disallowed. As <strong>DACS</strong> currently follows only the Netscape spec syntax in this respect, it produces cookies that are invalid with respect to RFC 2109 and RFC 2965. While this limitation does not appear to cause problems for web browsers, it may be noteworthy for users of some cookie handling APIs.</p><p><em>DACS_AUTH_SUCCESS_HANDLER</em></p><p>This argument provides a way for the caller to specify where the user agent should be redirected after successful authentication, regardless of whether authentication handlers are configured or enabled. If its value is DACS_ERROR_URL and an argument by that name is present, the user agent will be redirected to the value of that argument; otherwise, the user agent will be redirected to the value of <em>DACS_AUTH_SUCCESS_HANDLER</em>. The <em>DACS_ERROR_URL</em> is passed to this web service by \m[blue]<a href="../man8/dacs_acs.8.html"><strong>dacs_acs</strong>(8)</a></strong>\m[]\s-2\u[40]\d\s+2 as part of an authentication workflow initiated by a request that is denied because no credentials were supplied; <em>DACS_ERROR_URL</em> should not be generated by any non-<strong>DACS</strong> software.</p><p><em>DACS_BROWSER</em></p><p>If an argument named <em>DACS_BROWSER</em> is present and has the value 1, it signifies that the request is coming from a browser rather than middleware. If the request comes from a browser, <strong>DACS</strong> will return a cookie using the Set-Cookie HTTP response header, otherwise it will not.</p><p><em>DACS_DEBUG</em></p><p>If this argument is present, the web service will produce more detailed log information.</p><p><em>ENABLE_AUTH_HANDLERS</em></p><p>The jurisdiction&apos;s authentication handler directives are honoured if and only if this argument is present and has the value 1.</p><p><em>OPERATION</em></p><p>This is used with the identity selection mechanism described by \m[blue]<a href="../man8/dacs_select_credentials.8.html"><strong>dacs_select_credentials</strong>(8)</a></strong>\m[]\s-2\u[41]\d\s+2. If the value of this parameter is SELECT and authentication is successful, any currently selected credentials are deselected and the new credentials are selected.</p><p><em>PASSWORD</em></p><p>This argument is the password that corresponds to <em>USERNAME</em>.</p><p><em>USERNAME</em></p><p>This argument, which is (almost) always required, is the name provided by the user and is usually the name being authenticated. It will not necessarily be the same as the final <strong>DACS</strong> username. For example, if the value of <em>USERNAME</em> is not a syntactically valid <strong>DACS</strong> username, the authentication procedure must transform it into something acceptable (using the \m[blue]<strong></strong><strong>strtr()</strong>\m[]\s-2\u[42]\d\s+2 function, for instance; see \m[blue]<a href="../man5/dacs.exprs.5.html"><strong>dacs.exprs</strong>(5)</a></strong>\m[]\s-2\u[3]\d\s+2).</p><p><em>WWW_AUTHENTICATE</em></p><p>Reserved for internal use by \m[blue]<strong>HTTP Authentication</strong>\m[]\s-2\u[5]\d\s+2.</p>
<h3>Auth Clause Directives</h3>
<p>Each Auth clause in a <strong>DACS</strong> configuration file contains directives that describe a procedure for authenticating users. Some of these directives are common to all authentication modules, while others are understood only by a certain module; for example, \m[blue]<strong>LDAP_USERNAME_URL</strong>\m[]\s-2\u[43]\d\s+2 is only meaningful to the \m[blue]<strong>local_ldap_authenticate</strong>\m[]\s-2\u[44]\d\s+2 module. The general-purpose \m[blue]<strong>OPTION</strong>\m[]\s-2\u[45]\d\s+2 directive may sometimes be used to specify an argument to an authentication module.</p><p><strong>Important</strong></p><p>The order in which the Auth clauses appear is significant. See the \m[blue]<strong>CONTROL</strong>\m[]\s-2\u[11]\d\s+2 directive.</p><p>Every Auth element must have an id attribute. Its value is merely a label (an alphabetic followed by zero or more alphanumerics, hyphens, and underscores) that allows the clause to be referenced. Each id attribute value must be unique (case-sensitively) within the Jurisdiction section that contains it.</p><p>The following configuration directives are recognized by <strong>dacs_authenticate</strong> within any Auth clause (see \m[blue]<strong>dacs.conf</strong>(5)</strong>\m[]\s-2\u[46]\d\s+2 for general information about directives).</p><p><strong>Auth Clause Common Directives Index:</strong></p><p>CONTROL (Required1)</p><p>CREDENTIALS_LIFETIME_SECS (Optional1)</p><p>EXIT* (Optional1)</p><p>EXPR (Optional1)</p><p>FLAGS (Optional1)</p><p>INIT* (Optional1)</p><p>OPTION (Optional)</p><p>OPTION* (Optional)</p><p>PASSWORD_AUDIT (Optional)</p><p>PREDICATE (Optional1)</p><p>STYLE (Required1)</p><p>URL (Optional1)</p><p>URL* (Optional1)</p><p>CONTROL (Required1)</p><p>This directive specifies a PAM-like control keyword that determines what will happen if the authentication module succeeds or fails; see \m[blue]<a href="../man3/pam.3.html"><strong>pam</strong>(3)</a></strong>\m[]\s-2\u[47]\d\s+2 and the \m[blue]<strong>X/Open Single Sign-On Service (XSSO) preliminary specification</strong>\m[]\s-2\u[48]\d\s+2 (page 30), from which the description of these directives was adapted. Although this control mechanism allows for rather complicated authentication sequences to be described, in practice jurisdictions tend to construct fairly simple configurations. Most processing errors (other than errors encountered by a module) are considered fatal.</p><p>The first Auth clause that appears after configuration merging (see \m[blue]<strong>dacs.conf</strong>(5)</strong>\m[]\s-2\u[49]\d\s+2) is the "top" or first module in the stack, the next one is the second module in the stack, and so on.</p><p>The value of this directive is a case-insensitive keyword that can be abbreviated up to the indicated minimum:</p><p>require[d]</p><p>requisite</p><p>opt[ional]</p><p>suff[icient]</p><p>user_suff[icient]</p><p>For example, the keywords require and required are equivalent.</p><p>The control flow of authentication module processing is as follows:</p><p>If a requisite module fails, authentication fails and <strong>dacs_authenticate</strong> stops processing the module stack, returning the error reported by the requisite module;</p><p>If all requisite and required modules in the stack succeed, then authentication succeeds (any errors reported by optional, sufficient, and user_sufficient modules are ignored);</p><p>If one or more required modules fail, then the error value from the first required module that failed is returned; unlike failure of a requisite module, processing continues;</p><p>If none of the modules in the stack are designated as required or requisite, then <strong>dacs_authenticate</strong> requires that at least one optional, sufficient, or user_sufficient module succeed. If all fail, then the error value from the first module in the stack is returned;</p><p>The first exception to the above is caused by the sufficient keyword. If a module that is designated as sufficient succeeds, then <strong>dacs_authenticate</strong> immediately returns success (all subsequent modules are ignored, even required and requisite ones), given that all prior required and requisite modules have also succeeded. If a prior required module failed, then the error value from that module is returned;</p><p>The second exception to the above involves the user_sufficient keyword, which enables at most one user_sufficientAuth clause and disables all other user_sufficient<em>and</em>sufficientAuth clauses. This control simplifies configuring user-selectable authentication methods. Note that this mechanism will necessarily reveal additional information about a jurisdiction&apos;s authentication configuration.</p><p>If the <em>AUTH_ID</em> argument is <em>not</em> given, then all Auth clauses with the user_sufficient control are disabled - none of their directives are evaluated - and any sufficient controlled clauses are processed normally. If the <em>AUTH_ID</em> is present, then only an Auth clause with a user_sufficient control <em>and</em> an exactly matching id attribute is used. There can be at most one such Auth clause; all other Auth clauses having a user_sufficient<em>or</em>sufficient control is disabled. In all other respects, an enabled user_sufficientAuth clause is processed as for the sufficient control;</p><p>If an error occurs while processing a directive, then <strong>dacs_authenticate</strong> fails immediately.</p><p>CREDENTIALS_LIFETIME_SECS (Optional1)</p><p>The lifetime, in seconds, of credentials returned after successful authentication. This overrides the general directive of the same name, and may in turn be overridden by setting the variable <em>${Auth::CREDENTIALS_LIFETIME_SECS}</em>. Authentication will fail if this value is invalid.</p><p>EXIT* (Optional1)</p><p>If authentication is successful, this expression is evaluated immediately after the module&apos;s authentication processing is executed (but refer to the FLAGS directive).</p><p>EXPR (Optional1)</p><p>This directive, which is required when STYLE is expr, gives an expression that is evaluated to decide whether to grant credentials and the <strong>DACS</strong> identity to use. See \m[blue]<strong>Authenticating Using an Expression</strong>\m[]\s-2\u[50]\d\s+2.</p><p>FLAGS (Optional1)</p><p>This directive gives control flags that are interpreted by <strong>dacs_authenticate</strong>. Each directive consists of a whitespace-separated list of values.</p><p>The only value currently recognized is the keyword ident.</p><p><strong>Important</strong></p><p>If there is more than one Auth clause, the ident flag should ordinarily be specified in at least one of them to indicate that the username returned by the module, if authentication is successful, is to become the "current" username. Those Auth clauses without the ident flag will not change the current username. After the last Auth clause is processed, the current username is used in the resulting credentials.</p><p>The <em>${Auth::CURRENT_USERNAME}</em> variable (see below) is updated only if there is exactly one Auth clause or if the ident flag is given. This update occurs immediately prior to execution of any EXIT* directive.</p><p>If ident is not specified in any successfully processed Auth clause (i.e., one where authentication succeeds), the username returned by the last successfully processed clause is used. If the ident flag is specified in one or more successfully processed clauses, the username returned by the last such module will be used.</p><p>INIT* (Optional1)</p><p>The given expression is evaluated immediately prior to the URL* and EXPR expressions, all of which are evaluated before a module&apos;s authentication processing is invoked.</p><p>OPTION (Optional)</p><p>The directive value is a <em>name</em>=<em>value</em> pair that may be interpreted by <strong>dacs_authenticate</strong> or the authentication module specified by the Auth clause. It causes a variable called <em>name</em> to be put into the Options namespace, which only exists within the context of the Auth clause containing this OPTION. The variables in this namespace are passed as arguments to the authentication module. Whitespace may not precede or follow the &apos;=&apos; and any quotes around the value are considered to be part of the value. A given <em>name</em> may not be specified more than once within a particular Auth clause. The Options namespace is initialized with <em>USERNAME</em>, <em>PASSWORD</em>, <em>AUXILIARY</em>, <em>DACS_JURISDICTION</em>, and <em>DACS_VERSION</em> variables. If these variables are specified by an OPTION, the argument ordinarily used will be overridden.</p><p>For example, this directive causes SAMBA_PORT=139 to be passed as a POST method parameter:</p>
<pre>
OPTION "SAMBA_PORT=139"
</pre>
<p>OPTION* (Optional)</p><p>The given expression is evaluated before the module is called, and after all OPTION directives and all OPTION* directives that appear earlier. The value of the expression must be a <em>name</em>=<em>value</em> pair, as with the OPTION directive, and overrides any <em>name</em> in the Options namespace.</p><p>PASSWORD_AUDIT (Optional)</p><p>This directive is used to audit password-type arguments passed to authentication modules by <strong>dacs_authenticate</strong>, regardless of the authentication method, against the criteria selected by the specified constraint string, which is in the format used by \m[blue]<strong>PASSWORD_CONSTRAINTS</strong>\m[]\s-2\u[51]\d\s+2. If any password does not meet the requirements, a log message will be emitted (which does not include the password itself). The message will be tagged as audit and sensitive; please refer to the \m[blue]<strong>LOG_FILTER</strong>\m[]\s-2\u[52]\d\s+2 directive. This feature can be used to notify the administrator about weak passwords.</p><p>The directive value can be a variable name, which is matched exactly against the <em>PASSWORD</em> or <em>AUXILIARY</em> arguments, or a keyword in one of the OPTION directives within the same clause. In this form, the PASSWORD_CONSTRAINTS directive must be configured and its value is used as the constraint. In the second form, the directive value is a variable name as in the first form, followed by spaces or tabs, followed by the constraint string to use in the syntax of PASSWORD_CONSTRAINTS. Consider the following directives:</p>
<pre>
PASSWORD_CONSTRAINTS "8L,1C,1P"

&lt;Auth id="auth1"&gt;
  URL "https://foo.example.com/cgi-bin/dacs/local_woof_authenticate"
  STYLE "pass"
  CONTROL "sufficient"
  PASSWORD_AUDIT "PASSWORD 10L"
  PASSWORD_AUDIT "AUXILIARY"
&lt;/Auth&gt;
</pre>
<p>Here, the <em>PASSWORD</em> argument must be at least ten characters long but <em>AUXILIARY</em> must only be eight characters long and include an upper case character and punctuation.</p><p><strong>Note</strong></p><p>Not all authentication modules require a <em>PASSWORD</em> argument, such as \m[blue]<strong>local_cas_authenticate</strong>\m[]\s-2\u[53]\d\s+2 in its interactive mode. This directive is ignored if the argument is not passed to the module.</p><p>PREDICATE (Optional1)</p><p>If provided, this expression is evaluated before any other authentication module processing is done. If there is an evaluation error or it returns <strong>False</strong> (zero or the empty string), processing continues just as if the module were run and indicated that authentication failed. Otherwise, processing of the clause continues normally.</p><p>This directive provides a way to effectively enable or disable a module based on run time context. This can be used to configure layered authentication or risk-based authentication because a predicate can examine various aspects of an authentication request, such as the <em>USERNAME</em>, current date and time, IP address from where the request originates, and so on.</p><p>STYLE (Required1)</p><p>Each authentication module implements one or more authentication styles. The value of the STYLE directive is a comma-separated list of case-insensitive style names and style options; the order is insignificant. No whitespace is allowed. Keywords can be abbreviated up to the indicated minimum.</p><p>cas</p><p>This style selects username/password authentication using the \m[blue]<strong>Central Authentication Service (CAS)</strong>\m[]\s-2\u[54]\d\s+2 protocol through the \m[blue]<strong>local_cas_authenticate</strong>\m[]\s-2\u[53]\d\s+2 authentication module.</p><p>cert[ificate]</p><p>An X.509 client certificate, obtained from the SSL layer, will be provided for authentication. The request must be sent using SSL and the client certificate must be provided by <strong>Apache</strong> through the <strong>SSL_CLIENT_CERT</strong> environment variable.</p><p>digest</p><p>This selects the \m[blue]<strong>RFC 2617</strong>\m[]\s-2\u[55]\d\s+2 Digest Access Authentication scheme as implemented by <strong>DACS</strong> in conjunction with the \m[blue]<strong>local_apache_authenticate</strong>\m[]\s-2\u[56]\d\s+2 authentication module. See \m[blue]<strong>HTTP Authentication</strong>\m[]\s-2\u[5]\d\s+2.</p><p>expr</p><p>No authentication module will be used; \m[blue]<strong>expression evaluation</strong>\m[]\s-2\u[50]\d\s+2 will be used instead.</p><p>infocard</p><p>A self-issued or managed \m[blue]<strong>Information Card</strong>\m[]\s-2\u[57]\d\s+2 (InfoCard) must be provided for authentication. To be recognized, the InfoCard must have been previously registered at this jurisdiction using \m[blue]<a href="../man1/dacsinfocard.1.html"><strong>dacsinfocard</strong>(1)</a></strong>\m[]\s-2\u[58]\d\s+2, \m[blue]<a href="../man8/dacs_infocard.8.html"><strong>dacs_infocard</strong>(8)</a></strong>\m[]\s-2\u[59]\d\s+2, or \m[blue]<a href="../man8/dacs_managed_infocard.8.html"><strong>dacs_managed_infocard</strong>(8)</a></strong>\m[]\s-2\u[60]\d\s+2. This style is implemented by the \m[blue]<strong>local_infocard_authenticate</strong>\m[]\s-2\u[61]\d\s+2 authentication module.</p><p>managed_infocard</p><p>A managed \m[blue]<strong>Information Card</strong>\m[]\s-2\u[57]\d\s+2 (InfoCard) must be provided for authentication. To be recognized, the InfoCard must have been previously registered at this jurisdiction using \m[blue]<a href="../man8/dacs_managed_infocard.8.html"><strong>dacs_managed_infocard</strong>(8)</a></strong>\m[]\s-2\u[60]\d\s+2. This style is implemented by the \m[blue]<strong>local_infocard_authenticate</strong>\m[]\s-2\u[61]\d\s+2 authentication module.</p><p>nat[ive]</p><p>The user is expected to have already authenticated through the web server&apos;s native authentication mechanism (e.g., HTTP Basic or Digest authentication); <strong>DACS</strong> will import this identity without any additional requirements. The <strong>AUTH_TYPE</strong> environment variable but be available and have the value Basic or Digest (case insensitive), and the <strong>REMOTE_USER</strong> environment variable must be set.</p><p>pass[word]</p><p>passwd</p><p>The username must be provided through a <em>USERNAME</em> argument and the password must accompany the authentication request through a <em>PASSWORD</em> argument.</p><p>prompt[ed]</p><p>A dialog-based interaction will be conducted, such as one based on Pluggable Authentication Modules (PAM). See \m[blue]<strong>local_pam_authenticate</strong>\m[].</p><p>selfissued_infocard</p><p>A self-issued \m[blue]<strong>Information Card</strong>\m[]\s-2\u[57]\d\s+2 (InfoCard) must be provided for authentication. To be recognized, the InfoCard must have been previously registered at this jurisdiction using \m[blue]<a href="../man1/dacsinfocard.1.html"><strong>dacsinfocard</strong>(1)</a></strong>\m[]\s-2\u[58]\d\s+2 or \m[blue]<a href="../man8/dacs_infocard.8.html"><strong>dacs_infocard</strong>(8)</a></strong>\m[]\s-2\u[59]\d\s+2. This style is implemented by the \m[blue]<strong>local_infocard_authenticate</strong>\m[]\s-2\u[61]\d\s+2 authentication module.</p><p>simple</p><p>This style of authentication merely requires a recognized username, provided through a <em>USERNAME</em> argument and therefore offers little security. Still, it can be used in appropriate situations to authenticate a user that can provide a valid account name, which might be a membership number or randomly generated (and perhaps hard to guess) username. If a <em>PASSWORD</em> argument is provided, it is logged as sensitive data, much as an anonymous FTP password might be logged. This style is implemented by the \m[blue]<strong>local_simple_authenticate</strong>\m[]\s-2\u[62]\d\s+2 authentication module.</p><p>set_roles</p><p>If the authentication module returns roles, this style modifier says that they should override any other roles currently in effect and no roles module should be executed. This option may appear at most once among all Auth clauses and only if \m[blue]<strong>add_roles</strong>\m[]\s-2\u[63]\d\s+2 is not used.</p><p>add_roles</p><p>If the authentication module returns roles, this style modifier says that they should be appended to any other roles currently in effect. Any configured roles modules will still be executed. This option may be repeated in other Auth clauses but may not appear if the \m[blue]<strong>set_roles</strong>\m[]\s-2\u[64]\d\s+2 option also appears.</p><p>URL (Optional1)</p><p>URL* (Optional1)</p><p>Exactly one of these two directives must be specified, except when STYLE is expr, where neither directive is used. These directives specify the URL to be used to invoke the authentication module; use of an absolute URL is recommended.</p><p>The difference between the two directives is that the value of URL* is an expression that is evaluated immediately before the module is invoked to determine the URL to be used.</p><p>In the current implementation, the standard set of modules must run within the context of a <strong>DACS</strong> jurisdiction. This is not an architectural limitation, however.</p><p><strong>Tip</strong></p><p>Some authentication modules are available as built-in components of <strong>dacs_authenticate</strong> and <strong>dacsauth</strong>. These modules are identified by specific relative URLs; a module&apos;s description will provide its built-in name when this capability is available. The built-in capability will automatically be provided if the module has been enabled at build-time.</p><p>Although it will be more efficient (and possibly more secure) to use a built-in module, they are executed on the same host as <strong>dacs_authenticate</strong> thereby giving up some flexibility because access control rules are not applied to them (other than the one for <strong>dacs_authenticate</strong>), and <strong>dacs_authenticate</strong> may need to be executed setuid root or setgid www so that it can access password files. The same applies for <strong>dacsauth</strong>.</p><p>Here is an example of a configuration that will authenticate using Unix user names and passwords:</p>
<pre>
&lt;Auth id="passwd"&gt;
  URL "https://foo.example.com:8443/cgi-bin/dacs/local_unix_authenticate"
  STYLE "pass"
  CONTROL "sufficient"
&lt;/Auth&gt;
</pre>
<p>In the following example, <strong>dacs_authenticate</strong> will first try to authenticate using a Unix login name and password; if that fails, it will then try a <strong>DACS</strong> account name and password.</p>
<pre>
&lt;Auth id="passwd"&gt;
  URL "https://foo.example.com:8443/cgi-bin/dacs/local_unix_authenticate"
  STYLE "pass"
  CONTROL "sufficient"
&lt;/Auth&gt;

&lt;Auth id="passwd2"&gt;
  URL "https://foo2.example.com/cgi-bin/dacs/local_passwd_authenticate"
  STYLE "pass"
  CONTROL "sufficient"
&lt;/Auth&gt;
</pre>
<p>The preceding example can be changed to try authenticating using a <strong>DACS</strong> account name and password if and only if the <em>AUXILIARY</em> argument has the value "guest" (which might have been provided when the user selected a button on a login form):</p>
<pre>
&lt;Auth id="passwd"&gt;
  URL "https://foo.example.com:8443/cgi-bin/dacs/local_unix_authenticate"
  STYLE "pass"
  CONTROL "sufficient"
  PREDICATE &apos;${Args::AUXILIARY} ne "guest"&apos;
&lt;/Auth&gt;

&lt;Auth id="passwd2"&gt;
  URL "https://foo2.example.com/cgi-bin/dacs/local_passwd_authenticate"
  STYLE "pass"
  CONTROL "sufficient"
  PREDICATE &apos;${Args::AUXILIARY} eq "guest"&apos;
&lt;/Auth&gt;
</pre>
<p>In this example, a jurisdiction offers users a choice from among three authentication methods: a Googleaccount, a Windows NTLM account, or a <strong>DACS</strong> password-based account. The jurisdiction&apos;s login form would be written to provide the appropriate <em>AUTH_ID</em> argument for the corresponding method;</p>
<pre>
# For AUTH_ID=google
&lt;Auth id="google"&gt;
  URL "local_http_authenticate"
  STYLE "password"
  CONTROL "user_sufficient"
  OPTION &apos;AUTH_URL="https://www.google.com/accounts/ClientLogin"&apos;
  OPTION &apos;AUTH_METHOD=POST&apos;
  OPTION &apos;USERNAME_PARAMETER="Email"&apos;
  OPTION &apos;PASSWORD_PARAMETER="Passwd"&apos;
  OPTION &apos;service=xapi&apos;
  OPTION "source=DSS-DACS-1.4"
&lt;/Auth&gt;

# For AUTH_ID=ntlm
&lt;Auth id="ntlm"&gt;
  URL "local__ntlm_authenticate"
  STYLE "password"
  CONTROL "user_sufficient"
  OPTION &apos;SAMBA_SERVER="samba.example.com"&apos;
  OPTION &apos;SAMBA_PORT="139"&apos;
  EXIT* &apos;${Auth::CURRENT_USERNAME}=strtr(${Auth::CURRENT_USERNAME}, "a-z", "A-Z")&apos;
&lt;/Auth&gt;

# For AUTH_ID=passwd
&lt;Auth id="passwd"&gt;
  URL "local_passwd_authenticate"
  STYLE "password"
  CONTROL "user_sufficient"
&lt;/Auth&gt;
</pre>

<h3>Initialization and the Auth Namespace</h3>
<p><strong>dacs_authenticate</strong> uses a variable namespace called Auth to make authentication-related context available to its configuration directives (see \m[blue]<a href="../man5/dacs.exprs.5.html"><strong>dacs.exprs</strong>(5)</a></strong>\m[]\s-2\u[65]\d\s+2). Aspects of <strong>dacs_authenticate</strong>&apos;s behaviour can be controlled by modifying these variables. This namespace disappears when <strong>dacs_authenticate</strong> terminates. The next section describes how these variables are used.</p><p>Additionally, all environment variables are accessible through the Env namespace (e.g., <em>${Env::REMOTE_ADDR}</em>) during authentication processing.</p>
<h3>Authentication Clause Control Flow</h3>
<p>Auth clauses are processed in the order in which they appear in the configuration file, subject to the semantics of the CONTROL directives.</p><p><strong>dacs_authenticate</strong> is typically configured so that the last thing it does is to redirect its caller to an appropriate web page. If authentication is successful, any \m[blue]<strong>AUTH_SUCCESS</strong>\m[]\s-2\u[66]\d\s+2 expression is evaluated and the \m[blue]<strong>AUTH_SUCCESS_HANDLER</strong>\m[]\s-2\u[67]\d\s+2 directive is consulted; if authentication fails, the \m[blue]<strong>AUTH_ERROR_HANDLER</strong>\m[]\s-2\u[68]\d\s+2 and \m[blue]<strong>AUTH_FAIL_DELAY_SECS</strong>\m[]\s-2\u[69]\d\s+2 directives are used. This behaviour is partially under the control of the caller through the \m[blue]<strong></strong><em>DACS_AUTH_SUCCESS_HANDLER</em>\m[]\s-2\u[70]\d\s+2 and \m[blue]<strong></strong><em>ENABLE_AUTH_HANDLERS</em>\m[]\s-2\u[71]\d\s+2 arguments, however.</p><p><strong>Tip</strong></p><p>To redirect the newly authenticated user to a web page based on the user&apos;s identity, jurisdiction, roles, or other contextual state, configure AUTH_SUCCESS_HANDLER to specify the URL of a <strong>DACS</strong>-wrapped CGI program. After examining environment variables automatically passed to it by <strong>DACS</strong> or its query arguments, this program can emit an appropriate redirect. To test this, configure:</p>
<pre>
AUTH_SUCCESS_HANDLER "url /cgi-bin/dacs/dacs_prenv"
</pre>
<p>(making sure that \m[blue]<a href="../man8/dacs_prenv.8.html"><strong>dacs_prenv</strong>(8)</a></strong>\m[]\s-2\u[72]\d\s+2 has been installed) and examine the information that is available.</p><p>An Auth clause is processed in a sequence of steps, and with various hooks to provide fine-grained control. Only advanced <strong>DACS</strong> administrators usually need to be concerned with this level of detail.</p><p>Before the first clause is examined, the variable <em>${Auth::CURRENT_USERNAME}</em> is set to the empty string; this variable is automatically updated by <strong>dacs_authenticate</strong>. The contents of the Args, DACS, Conf, and Env\m[blue]<strong>namespaces</strong>\m[]\s-2\u[65]\d\s+2 are made available to all expressions evaluated during authentication module processing. Processing of each Auth clause is performed in the following sequence:</p><p>If the clause has a PREDICATE directive, it is evaluated in the current context. If the value is not <strong>True</strong> (including cases where the expression was invalid), processing of the clause terminates immediately with the same result as if its authentication had been unsuccessful.</p><p>If a variable named <em>${Auth::ABORT}</em> has the value yes (case insensitive), authentication terminates. If the variable <em>${Auth::MODULE_SKIP}</em> has the value yes (case insensitive), processing of the clause terminates immediately with the same result as if its authentication had been unsuccessful.</p><p>If the clause has an INIT* directive, it is evaluated; if an error occurs, authentication terminates.</p><p>If the clause has a URL directive, it names the authentication module to be invoked (or is the name of a built-in module).</p><p>If the URL* directive is used instead, it is evaluated to obtain the URL to be invoked; if an error occurs, authentication terminates.</p><p>If a variable named <em>${Auth::ABORT}</em> has the value yes (case insensitive), authentication terminates. If the variable <em>${Auth::MODULE_SKIP}</em> has the value yes (case insensitive), processing of the clause terminates immediately with the same result as if its authentication had been unsuccessful.</p><p>If the clause&apos;s STYLE is expr, the EXPR directive is evaluated and is expected to either return <strong>False</strong> or a valid <strong>DACS</strong> username. If the expression&apos;s value is <strong>False</strong>, processing of the clause terminates immediately with the same result as if its authentication had been unsuccessful; if its value is an invalid username, authentication terminates, otherwise the module is deemed to have been successful. If an error occurs, authentication terminates.</p><p>If the clause&apos;s STYLE is not expr, the authentication module is invoked.</p><p>If an error occurs while executing the authentication module, authentication terminates. If the authentication module does not authenticate the user, the CONTROL directive determines whether authentication fails or continues.</p><p>The username passed to the module, or returned by the module, becomes the tentative <strong>DACS</strong> username and the variable <em>${Auth::CURRENT_USERNAME}</em> is set to it. If the variable <em>${Auth::ROLES}</em> is set to a valid role descriptor, it becomes the current tentative roles for the user.</p><p>The expression given by the EXIT* directive, if any, is evaluated. If an error occurs, authentication terminates. The expression may update <em>${Auth::CURRENT_USERNAME}</em>. For instance, the directive:</p>
<pre>
EXIT* &apos;${Auth::CURRENT_USERNAME}="bobo"&apos;
</pre>
<p>completely ignores the username returned by the module and simply assigns one, while this directive:</p>
<pre>
EXIT* &apos;${Auth::CURRENT_USERNAME} = &#92;
       strtr(${Auth::CURRENT_USERNAME}, "A-Z", "a-z")&apos;
</pre>
<p>converts all upper case characters in the username returned by the module to their lower case equivalents.</p><p>If a variable named <em>${Auth::ABORT}</em> has the value yes (case insensitive), authentication terminates despite success of the module. If the variable <em>${Auth::MODULE_SKIP}</em> has the value yes (case insensitive), processing of the clause terminates immediately with the same result as if its authentication had been unsuccessful.</p><p>The value of <em>${Auth::CURRENT_USERNAME}</em> when the last module has been processed is the username that will be assigned to a successfully authenticated user. If set, the value of <em>${Auth::CREDENTIALS_LIFETIME_SECS}</em> will be used as the lifetime of the generated credentials; if not set, the value returned by the last successful authentication module is used (typically that of the module&apos;s CREDENTIALS_LIFETIME_SECS directive), if available, or the jurisdiction&apos;s CREDENTIALS_LIFETIME_SECS directive&apos;s value.</p>
<h3>Authenticating Using an Expression</h3>
<p>Rather than using an authentication module, the expr style of authentication involves evaluating an expression. The value of the expression is the <strong>DACS</strong> username to associate with the user. If no value is returned, an invalid value is returned, or an error occurs, the Auth clause fails.</p><p>Here is a simple example that is unlikely to be used in practice. If the <em>PASSWORD</em> argument is "xyzzy", then authentication will succeed and the user will be assigned the <strong>DACS</strong> username bobo.</p>
<pre>
&lt;Auth id="expr1"&gt;
  STYLE "expr"
  CONTROL "sufficient"
  EXPR &apos;${Args::PASSWORD} eq "xyzzy" ? "bobo" : ""&apos;
&lt;/Auth&gt;
</pre>
<p>This example illustrates how an expression can be used to read a password (its hex-encoded SHA-256 hash, actually) from a file and compare it with the one provided in the service request. Each user has his own password file that consists of a single line of text containing the hash. If a username is given that does not have a corresponding password file, or if the hash of the provided password does not match the stored one, the Auth clause will fail, otherwise the given username is returned as the authenticated name.</p>
<pre>
&lt;Auth id="expr5"&gt;
STYLE "expr"
EXPR &apos;${pwd} = get("/usr/local/dacs/pwd/pwd." . ${Args::USERNAME}); &#92;
  digest(${Args::PASSWORD}, 0, sha256) eq decode(hex, ${pwd}) &#92;
      ? ${Args::USERNAME} : ""&apos;
CONTROL "sufficient"
&lt;/Auth&gt;
</pre>
<p>The expression can also assign a valid role string to <em>${Auth::ROLES}</em> to establish roles for the user (in conjunction with the \m[blue]<strong>add_roles</strong>\m[]\s-2\u[63]\d\s+2 or \m[blue]<strong>set_roles</strong>\m[]\s-2\u[64]\d\s+2 style modifier):</p>
<pre>
&lt;Auth id="expr2"&gt;
  STYLE "expr,add_roles"
  CONTROL "sufficient"
  EXPR &apos;${Auth::ROLES}="foo,bar"; ${Args::PASSWORD} eq &#92;
    "xyzzy" ? "bobo" : ""&apos;
&lt;/Auth&gt;
</pre>
<p>This style of authentication can be a useful alternative to the cert style with the <strong>local_cert_authenticate</strong> module. If the client has provided an X.509 certificate that has been adequately verified by the web server, then in many cases all that remains to be done is to assign a syntactically valid DACS username to the client. \m[blue]<strong>Environment variables</strong>\m[]\s-2\u[73]\d\s+2 created by \m[blue]<strong>mod_ssl</strong>\m[]\s-2\u[74]\d\s+2 can be referenced as <em>${Auth::</em><em></em><em>ssl_variable_name</em><em>}</em>. Something such as the following might be suitable:</p>
<pre>
&lt;Auth id="expr3"&gt;
  STYLE "expr"
  CONTROL "sufficient"
  EXPR &apos;${Auth::SSL_CLIENT_VERIFY} eq "SUCCESS" and
    ${Auth::SSL_CLIENT_S_DN_Email:ei} &#92;
        ? ${Auth::SSL_CLIENT_S_DN_Email:i} : ""&apos;
&lt;/Auth&gt;
</pre>
<p>Another application of this style of authentication is where it is the location of the user that is important rather than the user&apos;s identity <em>per se</em>. For example, if a system administrator needs to restrict access to a web server to the hosts in a lab or desktops in a group of offices (that presumably share a subnet) but does not require individual users to authenticate, a configuration like the following might be adequate:</p>
<pre>
&lt;Auth id="expr4"&gt;
  STYLE "expr"
  CONTROL "sufficient"
  EXPR &apos;${Auth::CURRENT_USERNAME} = "user-${Env::REMOTE_ADDR}"&apos;
&lt;/Auth&gt;
</pre>
<p>A user would not provide a username or a password; by simply clicking on a link that invokes <strong>dacs_authenticate</strong>, a user from the computer with IP address 10.0.0.213 (for example) would be assigned the identity user-10.0.0.213. Access control rules could be expressed in terms of those identities or the corresponding IP addresses.</p>
<h3>Middleware Support</h3>
<p>As with most <strong>DACS</strong> web services, the <em>FORMAT</em> argument can be used to request a particular type of output (see \m[blue]<a href="../man8/dacs.services.8.html"><strong>dacs.services</strong>(8)</a></strong>\m[]\s-2\u[75]\d\s+2) from <strong>dacs_authenticate</strong>. If any XML type is specified, the reply from <strong>dacs_authenticate</strong> will conform to the DTD \m[blue]<strong>dacs_auth_reply.dtd</strong>\m[]\s-2\u[76]\d\s+2. The reply indicates whether the user has been successfully authenticated or not. If authentication was successful, a description of the new credentials is returned as a dacs_current_credentials element, (as described by \m[blue]<strong>dacs_current_credentials.dtd</strong>\m[]\s-2\u[77]\d\s+2). If authentication was unsuccessful because of a transient error condition, a reason may optionally be provided.</p><p><strong>Security</strong></p><p>This reason is solely used to inform the user; it should not reveal any details that might compromise security.</p><p>Authentication modules return an \m[blue]<strong>auth_reply.dtd</strong>\m[]\s-2\u[78]\d\s+2 document to <strong>dacs_authenticate</strong>.</p>
<h3>Authentication Modules</h3>
<p><strong>Important</strong></p><p><strong>DACS</strong> provides a set of authentication modules. At the time <strong>DACS</strong> is compiled, some standard modules are enabled by default while others needed must be specifically enabled (see \m[blue]<a href="../man7/dacs.install.7.html"><strong>dacs.install</strong>(7)</a></strong>\m[]\s-2\u[79]\d\s+2). You should not enable authentication modules that you do not plan to use.</p><p><strong>Security</strong></p><p>As a security measure, these modules should be executable only by <strong>dacs_authenticate</strong>, which is the default.</p><p>By default, access control rules are configured to restrict access to all authentication and roles modules. This prevents an attacker from calling an authentication module directly in an attempt to guess account names, passwords, and so on.</p><p>Modules may need to be installed setuid or setgid as appropriate so that it is possible for them to read the password files that they require or obtain encryption keys.</p><p>Modules may need to be installed setuid or setgid, and never run as the UID of a less-privileged user, so that it is impossible to circumvent the module&apos;s functionality (e.g., by attaching to the running module with a debugger).</p><p>Each authentication module is called with the following arguments. Authentication modules are always invoked using the POST method.</p><p><em>AUXILIARY</em></p><p>The value of the <em>AUXILIARY</em> argument to <strong>dacs_authenticate</strong> if one was given, otherwise the empty string.</p><p><em>DACS_JURISDICTION</em></p><p>The value of the <em>DACS_JURISDICTION</em> argument to <strong>dacs_authenticate</strong>.</p><p><em>DACS_VERSION</em></p><p>The DACS_VERSION_NUMBER for this version of <strong>dacs_authenticate</strong>.</p><p><em>PASSWORD</em></p><p>The value of the <em>PASSWORD</em> argument to <strong>dacs_authenticate</strong> if one was given, otherwise the empty string.</p><p><em>USERNAME</em></p><p>The value of the <em>USERNAME</em> argument to <strong>dacs_authenticate</strong>.</p><p>Directives</p><p>Each directive in the Auth section being processed and its value is passed.</p><p>SSL environment variables</p><p>Each SSL environment variable passed to <strong>dacs_authenticate</strong> is passed.</p><p>Transaction state data</p><p>With respect to the prompted style of authentication, transaction state variables are passed.</p><p>Ordinarily, a particular argument may not appear more than once.</p><p><strong>Authentication Module Index:</strong></p><p>local_apache_authenticate: Password-protected accounts maintained by <strong>Apache</strong> utilities</p><p>local_cas_authenticate: Central Authentication Service (CAS)</p><p>local_cert_authenticate: SSL-based X.509 client certificates</p><p>local_grid_authenticate: Grid-based one-time passwords</p><p>local_http_authenticate: Generic authentication via HTTP</p><p>local_infocard_authenticate: Information Card-based accounts and identities</p><p>local_ldap_authenticate: Lightweight Directory Access Protocol (LDAP) / Microsoft Active Directory</p><p>local_native_authenticate: Importing an identity established by <strong>Apache</strong></p><p>local_ntlm_authenticate: Microsoft Windows NT LAN Manager usernames and passwords</p><p>local_pam_authenticate: Pluggable Authentication Modules (PAM)</p><p>local_passwd_authenticate: Password-protected <strong>DACS</strong> accounts</p><p>local_simple_authenticate: Account name without a password</p><p>local_token_authenticate: One-time passwords, two-factor authentication</p><p>local_unix_authenticate: Unix usernames and passwords</p><p><strong>local_apache_authenticate</strong></p><p>The <strong>local_apache_authenticate</strong> module is used to authenticate against password files used by the <strong>Apache</strong>\m[blue]<strong></strong><strong>mod_auth</strong>\m[]\s-2\u[80]\d\s+2, \m[blue]<strong></strong><strong>mod_auth_digest</strong>\m[]\s-2\u[81]\d\s+2, or \m[blue]<strong></strong><strong>mod_auth_dbm</strong>\m[]\s-2\u[82]\d\s+2 modules. These password files are managed by <strong>Apache&apos;s</strong>\m[blue]<a href="../man1/htpasswd.1.html"><strong>htpasswd</strong>(1)</a></strong>\m[]\s-2\u[83]\d\s+2, \m[blue]<a href="../man1/htdigest.1.html"><strong>htdigest</strong>(1)</a></strong>\m[]\s-2\u[84]\d\s+2, and \m[blue]<a href="../man1/htdbm.1.html"><strong>htdbm</strong>(1)</a></strong>\m[]\s-2\u[85]\d\s+2 utilities, respectively. An administrator can configure <strong>DACS</strong> to use an existing htpasswd file, for instance, and so avoid dealing with creating and managing a duplicate set of usernames and passwords.</p><p>If Basic authentication is used, the STYLE should be password. If Digest authentication is used, because no password is passed to <strong>DACS</strong>, the STYLE for this module should be configured as digest.</p><p>The following configuration options are recognized by this module. They should be provided using the OPTION directive.</p><p>AUTH_MODULE</p><p>This must be "mod_auth" (or "htpasswd"), "mod_auth_digest" (or "htdigest"), or "mod_auth_dbm" (or "htdbm"), depending on which module&apos;s authentication method is to be used. This value is case-insensitive.</p><p>AUTH_FILE</p><p>This is the absolute pathname of the flat-file or database file to use.</p><p><strong>Note</strong></p><p>This pathname is resolved on the host that runs this module. This should eventually be extended to accept a <strong>DACS</strong> virtual filestore URI.</p><p>DBM_TYPE</p><p>Required only in conjunction with mod_auth_dbm compatibility, this argument identifies the database format of AUTH_FILE. The names "sdbm" (not yet implemented), "gdbm", "ndbm", and "db" are recognized, although not all types may be available on a particular platform.</p><p><strong>Notes</strong></p><p>This module does not rely on any <strong>Apache</strong> module (other than <strong>mod_auth_dacs</strong>).</p><p>This module does not require any <strong>Apache</strong> configuration with respect to authentication; only <strong>DACS</strong> needs to be configured.</p><p>It is not necessary to use <strong>DACS&apos;s</strong>\m[blue]<strong>HTTP Authentication</strong>\m[]\s-2\u[5]\d\s+2 feature in order to use this module. For example, using Basic authentication, the <em>USERNAME</em> and <em>PASSWORD</em> arguments can be submitted from a site&apos;s login page and verified by this module against an <strong>htpasswd</strong> file.</p><p><strong>htpasswd</strong> allows plaintext passwords to be stored in a password file, although <strong>httpd</strong> apparently restricts the use of these passwords. This module imposes no such restrictions. Under normal circumstances passwords should not be stored in plaintext form.</p><p>The major difference between this module and \m[blue]<strong>local_native_authenticate</strong>\m[]\s-2\u[86]\d\s+2 is that the latter "imports" an identity already established by an <strong>Apache</strong> authentication module, whereas this module authenticates using information that can also be used by <strong>Apache</strong> and which is administered using <strong>Apache</strong> utiltities.</p><p><strong>DACS</strong> will access <strong>Apache</strong> password files in read-only mode only; <strong>DACS</strong> never modifies those files.</p><p>Some platforms may not support all possible DBM-type databases and some types of database may not have been configured at build-time.</p><p>Here is an example configuration that uses an <strong>htpasswd</strong>-managed file for authentication:</p>
<pre>
HTTP_AUTH_ENABLE "yes"
HTTP_AUTH "Basic &#92;"DACS Basic Auth Area&#92;" /restricted/*"

&lt;Auth id="apache-htpasswd"&gt;
URL "https://example.com/cgi-bin/dacs/local_apache_authenticate"
STYLE "pass"
CONTROL "sufficient"
OPTION "AUTH_FILE=/usr/local/apache2/conf/passwords"
OPTION "AUTH_MODULE=mod_auth"
&lt;/Auth&gt;
</pre>
<p>If the passwords were kept in a Berkeley DB database instead, the configuration might look like:</p>
<pre>
HTTP_AUTH_ENABLE "yes"
HTTP_AUTH "Basic &#92;"DACS Basic Auth Area&#92;" /restricted/*"

&lt;Auth id="apache-htpasswd"&gt;
URL "https://example.com/cgi-bin/dacs/local_apache_authenticate"
STYLE "pass"
CONTROL "sufficient"
OPTION "AUTH_FILE=/usr/local/apache2/conf/passwords.db"
OPTION "AUTH_MODULE=mod_auth_dbm"
OPTION "DBM_TYPE=db"
&lt;/Auth&gt;
</pre>
<p>This example configuration is similar; the difference is that the username and password obtained through HTTP Basic authentication are verified against a Unix account:</p>
<pre>
HTTP_AUTH_ENABLE "yes"
HTTP_AUTH "Basic &#92;"DACS Basic Auth Area&#92;" /private/*"

&lt;Auth id="basic"&gt;
URL "https://example.com/cgi-bin/dacs/local_unix_authenticate"
STYLE "pass"
CONTROL "sufficient"
&lt;/Auth&gt;
</pre>
<p>This example configures HTTP Digest authentication and references an <strong>htdigest</strong>-managed file:</p>
<pre>
HTTP_AUTH_ENABLE "yes"
HTTP_AUTH "Digest &#92;"DACS Digest Auth Area&#92;" /digest/*"

&lt;Auth id="apache-htdigest"&gt;
URL "apache"
STYLE "digest"
CONTROL "sufficient"
OPTION "AUTH_FILE=/usr/local/apache2/conf/passwords.digest"
OPTION "AUTH_MODULE=mod_auth_digest"
&lt;/Auth&gt;
</pre>
<p><strong>Tip</strong></p><p>A built-in version of this module can be selected by using the URL local_apache_authenticate or just apache.</p><p><strong>local_cas_authenticate</strong></p><p>This module coordinates with a specified \m[blue]<strong>Central Authentication Service (CAS)</strong>\m[]\s-2\u[54]\d\s+2 server to authenticate a user that is purportedly known to that server. The module implements the client side of the \m[blue]<strong>CAS 2.0 Protocol</strong>\m[]\s-2\u[87]\d\s+2 and can be used in two different modes: interactive and non-interactive.</p><p>Interactive mode is employed if neither a <em>USERNAME</em> nor a <em>PASSWORD</em> argument is given to <strong>dacs_authenticate</strong>. When <strong>dacs_authenticate</strong> is called, whether directly or as the result of redirection after access was denied to an unauthenticated user, it redirects the user to a CAS login page. After successful CAS authentication (which may return a ticket granting cookie to the user&apos;s browser), CAS redirects the user to <strong>dacs_authenticate</strong>, passing it the CAS session ticket as an argument called <em>ticket</em>. After successfully validating the session ticket at the CAS server, <strong>DACS</strong> authentication succeeds.</p><p><strong>Security</strong></p><p>When interactive mode is used, <strong>DACS</strong> does not see the username and password, only CAS does. The username is obtained by the module as part of the session ticket validation protocol. This mode of operation is similar to, but simpler than, the \m[blue]<strong>OpenID</strong>\m[]\s-2\u[88]\d\s+2 Authentication protocol.</p><p>A variant of this flow of control can occur if the user has authenticated against the CAS server outside of <strong>DACS</strong> and therefore holds a ticket granting cookie. This cookie will automatically be sent by the user&apos;s browser when it is redirected to the CAS server; as a result, the CAS server may not prompt the user to authenticate.</p><p>In non-interactive mode, both a <em>USERNAME</em><em>and</em> a <em>PASSWORD</em> argument are passed to <strong>dacs_authenticate</strong>. This module will use these arguments to authenticate the user against the CAS server. In this mode, no ticket granting cookie will be returned to the user. This mode can be used with the <strong>DACS</strong>\m[blue]<strong>HTTP authentication</strong>\m[]\s-2\u[5]\d\s+2 feature.</p><p>The STYLE should be configured as cas for this module.</p><p>The following module-specific OPTION directive value is understood:</p><p>CAS_SERVER_URI (Required1)</p><p>This is the URI of the CAS server to authenticate against. For example, dacs.conf might contain authentication configuration similar to the following:</p>
<pre>
&lt;Auth id="CAS"&gt;
URL "cas"
STYLE "cas"
CONTROL "sufficient"
OPTION "CAS_SERVER_URI=https://cas.example.com/castest"
&lt;/Auth&gt;
</pre>
<p>The module recognizes the following arguments (which are automatically passed to it as necessary by <strong>dacs_authenticate</strong>):</p><p>CAS_TICKET (Required1-C)</p><p>This is the session ticket returned by CAS via a callback to <strong>dacs_authenticate</strong> (i.e., the <em>ticket</em> argument).</p><p>CAS_REDIRECT_ARGS (Optional1)</p><p>These are additional arguments to <strong>dacs_authenticate</strong> that must be provided when CAS performs its callback to <strong>dacs_authenticate</strong> to preserve user preferences. The <em>DACS_BROWSER</em>, <em>FORMAT</em>, <em>DACS_ERROR_URL</em>, and <em>ENABLE_AUTH_HANDLERS</em> arguments may be forwarded in this way.</p><p>CAS_SERVER_URI (Required1-C)</p><p>This argument has the value specified in the Auth clause&apos;s OPTION directive. Note that HTTP redirects are not handled in this context, so invoking GET on CAS_SERVER_URI must return a valid document.</p><p><strong>Note</strong></p><p>The <strong>local_cas_authenticate</strong> module extends the response of the <strong>validate</strong> service of the CAS protocol to allow a role descriptor string (<em>role_string</em>) to be returned. If authentication succeeds, the standard service returns the following text: yes&#92;n<em>username</em>&#92;n.PP This module understands a third line, which is optional: yes&#92;n<em>username</em>&#92;n<em>role_string</em>&#92;n An invalid role string is discarded. If these roles should be used, it will be necessary to use either the \m[blue]<strong>set_roles</strong>\m[]\s-2\u[64]\d\s+2 or \m[blue]<strong>add_roles</strong>\m[]\s-2\u[63]\d\s+2 style modifier with the \m[blue]<strong>STYLE</strong>\m[]\s-2\u[89]\d\s+2 directive.</p><p><strong>Tip</strong></p><p>The authentication procedure described by the CAS protocol is notable because the authentication material provided by the user in interactive mode <em>does not flow through </em><em></em><strong>DACS</strong>; in particular, <strong>DACS</strong> does not see a user&apos;s password when this module is used. This may be an important consideration in some environments.</p><p>Because the protocol implemented by this module is general purpose and relatively simple, writing middleware that implements a subset of the server-side CAS protocol to interface with this module may be a sensible solution for <strong>DACS</strong> administrators who require a CAS-like control flow but do not want to use actual CAS server-side software. The user would be redirected to the middleware component by <strong>local_cas_authenticate</strong> to perform the /login service; then it would prompt and authenticate the user, and redirect the user to a URL provided to it by <strong>local_cas_authenticate</strong>; then <strong>local_cas_authenticate</strong> would call the middleware component directly, this time to perform the /validate service. The usual flow of control within <strong>DACS</strong> would follow.</p><p>A simple script for testing and working with <strong>local_cas_authenticate</strong> is available in src/cas_middleware_test.</p><p><strong>Tip</strong></p><p>A built-in version of this module can be selected by using the URL local_cas_authenticate or just cas.</p><p><strong>local_cert_authenticate</strong></p><p>The <strong>local_cert_authenticate</strong> module authenticates a user that supplies an acceptable X.509 client certificate via SSL. <strong>Apache</strong> must be appropriately configured to request and verify client certificates, check for revocation, and so on (see \m[blue]<strong>SSLVerifyClient</strong>\m[]\s-2\u[90]\d\s+2 and related directives). As part of the SSL protocol, <strong>Apache</strong>&apos;s \m[blue]<strong>mod_ssl</strong>\m[]\s-2\u[74]\d\s+2 module verifies that the client possesses the private key that corresponds to the client certificate. <strong>Apache</strong> will usually be configured to verify the correctness and suitability of the client certificate. <strong>Apache</strong> directives such as \m[blue]<strong>SSLRequire</strong>\m[]\s-2\u[91]\d\s+2 might be used, for example.</p><p>The STYLE should be configured as certificate for this module.</p><p>The verification of the client certificate done by <strong>Apache</strong> may be sufficient, in which case the only remaining configuration task for the Auth clause is to assign a username and possibly extract role information from the certificate; it may impose additional tests on the certificate, however, by inspecting its fields. If verification beyond the ability of \m[blue]<strong>mod_ssl</strong>\m[]\s-2\u[74]\d\s+2 is required, or if it needs to be performed on a system other than where the web server is running, <strong>local_cert_authenticate</strong> can execute an external program to decide whether the client certificate is suitable for authentication. This program is currently limited to \m[blue]<strong>OpenSSL</strong>\m[]\s-2\u[92]\d\s+2 but this may be generalized in future versions.</p><p>To ensure that <strong>local_cert_authenticate</strong> is able to obtain information contained within the client certificate, <strong>Apache</strong> must be configured so that <strong>StdEnvVars</strong> and <strong>ExportCertData</strong> are enabled in an appropriate \m[blue]<strong>SSLOptions</strong>\m[]\s-2\u[93]\d\s+2 directive, such as the following:</p>
<pre>
SSLOptions +StdEnvVars +ExportCertData
</pre>
<p>The following configuration directives are specific to this module:</p><p>CERT_CA_PATH (Required1)</p><p>This is the absolute pathname of a directory that contains trusted certificates. Refer to the <strong>-CApath</strong> argument to <strong>OpenSSL</strong>&apos;s verify command.</p><p>CERT_DUMP_CLIENT (Optional1)</p><p>If configured, this gives the absolute pathname of a file to which the client certificate is to be written in PEM format. The file is created or truncated, as necessary. This is useful for debugging purposes.</p><p>CERT_NAME_ATTR (Optional1)</p><p>If this directive is configured, it gives the name of an \m[blue]<strong>SSL environment variable</strong>\m[]\s-2\u[73]\d\s+2. The value of that variable is used as a key for the certnamemap item type (which must also be configured); the key&apos;s value becomes the username returned by the module (if the environment variable is not found or the lookup is unsuccessful, the module will fail to authenticate the user). If the module is not fully configured for this lookup, the value of the <em>USERNAME</em> is returned by the module.</p><p>To illustrate this, consider the following configuration:</p>
<pre>
VFS "[certmap]dacs-kwv-fs:/usr/local/dacs/federations/certnamemap"

&lt;Auth id="cert"&gt;
  URL "https://example.com/cgi-bin/dacs/local_cert_authenticate"
  STYLE "cert"
  CONTROL "sufficient"
  CERT_CA_PATH "/usr/local/apache2/conf/ssl.crt"
  CERT_NAME_ATTR "SSL_CLIENT_S_DN_CN"
&lt;/Auth&gt;
</pre>
<p>with the file /usr/local/dacs/federations/certnamemap containing the two lines:</p>
<pre>
Clark Kent:superman
Bruce Wayne:batman
</pre>
<p>Given the configuration above, if the value of the <strong>SSL_CLIENT_S_DN_CN</strong> environment variable is "Clark Kent", the username returned by the module will be "superman".</p><p>As with any module, an expression can be used within an Auth clause to modify or override the value returned by a module.</p><p>CERT_OPENSSL_PATH (Optional1)</p><p>This is the absolute pathname of the <strong>openssl</strong> program. If not provided, a build-time value is used (<em>OPENSSL_PATH</em>).</p><p><strong>Security</strong></p><p>The lifetime of credentials obtained through the local authentication service may be independent of the validity period of the certificate presented for authentication. It is therefore possible for the certificate to expire before the <strong>DACS</strong> credentials. The local authentication service might take this into consideration before granting access and when computing a lifetime for the resulting <strong>DACS</strong> credentials.</p><p><strong>local_grid_authenticate</strong></p><p>This module works in concert with the \m[blue]<a href="../man1/dacsgrid.1.html"><strong>dacsgrid</strong>(1)</a></strong>\m[]\s-2\u[94]\d\s+2 utility to provide users with one-time passwords. It is also an approximation of the "something you have" factor of two-factor authentication.</p><p>The STYLE should be configured as password for this module.</p><p>Please refer to \m[blue]<a href="../man1/dacsgrid.1.html"><strong>dacsgrid</strong>(1)</a></strong>\m[]\s-2\u[94]\d\s+2 for a complete description.</p><p>In addition to the usual <em>USERNAME</em> argument, the module requires the <em>PASSWORD</em> argument to be the user&apos;s response to the challenge and the <em>AUXILIARY</em> argument to be the encoded challenge. The latter two arguments must be produced by \m[blue]<a href="../man1/dacsgrid.1.html"><strong>dacsgrid</strong>(1)</a></strong>\m[]\s-2\u[94]\d\s+2.</p><p>The following OPTION directive values are understood:</p><p>AUTH_GRID_CHALLENGE_SECS (Optional1)</p><p>The number of seconds between when a challenge is created and when it expires, overriding the default value. This value should be relatively small, at most on the order of a few tens of seconds. If this module runs on a host other than the one running <strong>dacs_authenticate</strong>, the two system clocks must be suitably synchronized.</p><p>AUTH_GRID_LIFETIME_SECS (Optional1)</p><p>The length of time, in seconds, for which a grid is valid. After this period, all authentication against a grid will fail.</p><p><strong>Tip</strong></p><p>A built-in version of this module can be selected by using the URL local_grid_authenticate or just grid.</p><p><strong>local_http_authenticate</strong></p><p>This module authenticates by invoking a given (non-interactive) web service with specified arguments. If the web service reports success by returning HTTP status code <strong>200</strong> (see \m[blue]<strong>RFC 2616</strong>\m[]\s-2\u[95]\d\s+2, Section 10), then the module succeeds, otherwise it fails. Any output, including cookies, returned by the web service is discarded. No session is established with the web service and no additional requests are made to it; the web service is used solely to determine whether a username/password is correct.</p><p>This module can be used to authenticate against any existing web service that follows the expected protocol, or can provide a way to add a new, custom authentication method to <strong>DACS</strong>.</p><p>The STYLE should be configured as password for this module.</p><p>The following OPTION directive values are understood:</p><p>AUTH_URL (Required1)</p><p>The URL to invoke, which may use either the http or https scheme.</p><p>AUTH_METHOD (Optional1)</p><p>The HTTP method to use to invoke AUTH_URL. The default is POST. Keep in mind that if query arguments are present (or if the GET method is used) they may appear in log files.</p><p>USERNAME_PARAMETER (Required1)</p><p>The name of the argument by which <em>USERNAME</em> is passed. The default is <em>USERNAME</em>.</p><p>PASSWORD_PARAMETER (Required1)</p><p>The name of the argument by which <em>PASSWORD</em> is passed. The default is <em>PASSWORD</em>.</p><p>Any other OPTION directive values are simply passed to the web service. Duplicate argument names will be passed.</p><p>For \m[blue]<strong>Google</strong>\m[]\s-2\u[96]\d\s+2\m[blue]<strong>account authentication</strong>\m[]\s-2\u[97]\d\s+2, for instance, the following configuration might be used:</p>
<pre>
&lt;Auth id="google"&gt;
URL "local_http_authenticate"
STYLE "password"
CONTROL "required"
OPTION &apos;AUTH_URL="https://www.google.com/accounts/ClientLogin"&apos;
OPTION &apos;USERNAME_PARAMETER=Email&apos;
OPTION &apos;PASSWORD_PARAMETER=Passwd&apos;
OPTION &apos;service=xapi&apos;
OPTION "source=DSS-DACS-1.4"
&lt;/Auth&gt;
</pre>
<p>This web service returns an HTTP status code of <strong>200</strong> if the correct username and password are given (i.e., login succeeded), and <strong>403</strong> if login fails. If <strong>ClientLogin</strong> fails and requests a CAPTCHA challenge the request will not be passed back to the user.</p><p><strong>Note</strong></p><p>One of the reasons for inclusion of this module is to support reuse of accounts widely used by the public. Googleprovides exactly the right interface needed by systems such as <strong>DACS</strong>. Accounts provided by \m[blue]<strong>eBay</strong>\m[]\s-2\u[98]\d\s+2and \m[blue]<strong>Yahoo!</strong>\m[]\s-2\u[99]\d\s+2, for instance, do not appear to be directly usable in this way. In some cases, \m[blue]<a href="../man8/dacs_auth_transfer.8.html"><strong>dacs_auth_transfer</strong>(8)</a></strong>\m[]\s-2\u[8]\d\s+2 may be a better approach than this module.</p><p><strong>Tip</strong></p><p>A built-in version of this module can be selected by using the URL local_http_authenticate or just http.</p><p><strong>local_infocard_authenticate</strong></p><p>The <strong>local_infocard_authenticate</strong> module performs <strong>DACS</strong> authentication using an \m[blue]<strong>Information Card</strong>\m[]\s-2\u[57]\d\s+2 (InfoCard) previously registered at the jurisdiction. Self-issued InfoCards are registered using \m[blue]<a href="../man8/dacs_infocard.8.html"><strong>dacs_infocard</strong>(8)</a></strong>\m[]\s-2\u[59]\d\s+2 or \m[blue]<a href="../man1/dacsinfocard.1.html"><strong>dacsinfocard</strong>(1)</a></strong>\m[]\s-2\u[58]\d\s+2. Managed InfoCards are also supported, provided they have been registered using \m[blue]<a href="../man8/dacs_managed_infocard.8.html"><strong>dacs_managed_infocard</strong>(8)</a></strong>\m[]\s-2\u[60]\d\s+2 and include a dacs_identity claim in the <strong>DACS</strong> namespace. <strong>DACS</strong> aims to conform to \m[blue]<strong>Identity Selector Interoperability Profile (ISIP) 1.5</strong>\m[]\s-2\u[100]\d\s+2.</p><p>A <strong>DACS</strong>\m[blue]<strong>role descriptor string</strong>\m[]\s-2\u[101]\d\s+2 can be associated with a managed InfoCard through the dacs_roles claim name in the <strong>DACS</strong> namespace (see \m[blue]<a href="../man8/dacs_infocard.8.html"><strong>dacs_infocard</strong>(8)</a></strong>\m[]\s-2\u[102]\d\s+2. These roles can be associated with new credentials via the \m[blue]<strong>add_roles</strong>\m[]\s-2\u[63]\d\s+2 and \m[blue]<strong>set_roles</strong>\m[]\s-2\u[64]\d\s+2 modifiers.</p><p><strong>Security</strong></p><p>At present, to be valid for authentication, the dacs_identity claim value must specify a user at the current jurisdiction; that is, it cannot specify an identity at a jurisdiction other than the one where authentication is being performed.</p><p>The authentication style infocard causes the module to accept either type of InfoCard - the type of InfoCard actually used will be available in the resulting credentials. The styles managed_infocard and selfissued_infocard tell the module to limit authentication to managed InfoCards or self-issued InfoCards, respectively. When invoked as a web service, <strong>local_infocard_authenticate</strong> understands an optional argument, <em>TYPE</em>, that may have the value "selfissued" or "managed" to restrict authentication to the corresponding InfoCard type; the default behaviour accepts either type of InfoCard.</p><p><strong>Tip</strong></p><p>The \m[blue]<strong>expression-based authentication style</strong>\m[]\s-2\u[103]\d\s+2, which does not employ this module, provides an alternative way to support InfoCard-based authentication. It is somewhat more complicated to use, however, and may require a small amount of programming.</p><p>For additional information about InfoCards, please refer to:</p><p>\m[blue]<a href="../man8/dacs_managed_infocard.8.html"><strong>dacs_managed_infocard</strong>(8)</a></strong>\m[]\s-2\u[104]\d\s+2, \m[blue]<strong>dacs.conf</strong>(5)</strong>\m[]\s-2\u[105]\d\s+2 (the INFOCARD_ prefixed directives), \m[blue]<a href="../man8/dacs_mex.8.html"><strong>dacs_mex</strong>(8)</a></strong>\m[]\s-2\u[106]\d\s+2, and \m[blue]<a href="../man8/dacs_sts.8.html"><strong>dacs_sts</strong>(8)</a></strong>\m[]\s-2\u[107]\d\s+2.</p><p>\m[blue]<strong>Using InfoCards With DACS</strong>\m[]\s-2\u[108]\d\s+2, Distributed Systems Software (July, 2009).</p><p>\m[blue]<strong></strong><em>Identity Selector Interoperability Profile specification and companion guides</em>\m[]\s-2\u[109]\d\s+2 (August, 2008).</p><p>\m[blue]<strong></strong><em>Introducing Windows CardSpace</em>\m[]\s-2\u[110]\d\s+2 (April, 2006).</p><p><strong>Tip</strong></p><p>A built-in version of this module can be selected by using the URL local_infocard_authenticate or just infocard.</p><p><strong>local_ldap_authenticate</strong></p><p>The <strong>local_ldap_authenticate</strong> module performs <strong>DACS</strong> authentication using the Lightweight Directory Access Protocol, also known as LDAP, (see \m[blue]<strong>RFC 2251</strong>\m[]\s-2\u[111]\d\s+2, \m[blue]<strong>RFC 2252</strong>\m[]\s-2\u[112]\d\s+2, \m[blue]<strong>RFC 2253</strong>\m[]\s-2\u[113]\d\s+2, \m[blue]<strong>RFC 3377</strong>\m[]\s-2\u[114]\d\s+2, and many others). This form of authentication can be used with Microsoft&apos;s \m[blue]<strong>Active Directory (ADS)</strong>\m[]\s-2\u[115]\d\s+2. \m[blue]<strong>OpenLDAP</strong>\m[]\s-2\u[116]\d\s+2 is used to supply LDAP client support.</p><p>The STYLE should be configured as password for this module.</p><p>In general, authentication using LDAP is challenging because an LDAP name (a distinguished name, or DN) is typically long and often has a site-specific structure. For this reason, this module often requires more local expertise for configuring and testing than other <strong>DACS</strong> authentication modules. At least a basic familiarity with LDAP will be required to configure this module.</p><p>The module implements two different approaches to authentication:</p><p>In the direct method, which is the simpler and more efficient approach, the <em>USERNAME</em> argument is directly mapped to the corresponding DN. The module binds to that DN using the given <em>PASSWORD</em>. If the bind operation succeeds, the user has been authenticated.</p><p>When the simpler method is not possible, the indirect method can be used to bind to the directory as an LDAP administrator (or an identity with the ability to search the appropriate portion of the directory tree) and perform an LDAP search operation for a directory entry having an attribute that matches the <em>USERNAME</em> argument. If the search returns exactly one entry, it binds to that entry&apos;s DN using the <em>PASSWORD</em> argument; if the bind operation succeeds, the user has been authenticated.</p><p>Regardless of the approach, after successful authentication it may be necessary to map the <em>USERNAME</em> or the DN into a valid <strong>DACS</strong> username.</p><p>The following configuration directives are specific to this module:</p><p>LDAP_ADMIN_PASSWORD (Optional1)</p><p>This is the password for the LDAP administrator account that corresponds to LDAP_ADMIN_URL.</p><p>LDAP_ADMIN_URL (Required1-C)</p><p>If the indirect method is used, this directive is required. This value is a URI like LDAP_USERNAME_URL except that it identifies the LDAP directory&apos;s administrator. Example:</p>
<pre>
LDAP_ADMIN_URL
  "ldap://example.com/cn=Administrator, cn=Users, dc=example, dc=com"
</pre>
<p>LDAP_BIND_METHOD (Required1-C)</p><p>This directive tells the module to use the direct method, indirect method, or both methods (case insensitive). When both are used, the indirect method is attempted only if the direct method fails.</p><p>LDAP_ROLES_SELECTOR* (Optional)</p><p>Since LDAP directory operations are usually relatively expensive, this module can return role information for the authenticated user, avoiding a second LDAP operation during Roles clause processing. Roles are typically extracted from information in the user&apos;s directory entry. Each occurrence of this directive specifies an expression that is evaluated by iterating through each attribute of the entry and making the attribute name (<em>${LDAP::attrname}</em>) and its value (<em>${LDAP::attrvalue}</em>) available. All of the entry&apos;s attribute names and values are made available within the LDAP namespace. If the result of the expression is a valid role string (which excludes the empty string, ""), it is added to the list of roles.</p><p>An example:</p>
<pre>
LDAP_ROLES_SELECTOR* &apos;"${LDAP::attrname}" eq "memberOf" &#92;
    ? strtr(ldap(rdn_attrvalue, &#92;
        ldap(dn_index, "${LDAP::attrvalue}", 1)), " ", "_") &#92;
    : ""&apos;
</pre>
<p>For each instance of the entry&apos;s memberOf attribute, this expression selects the least significant (left-most) component of the attribute value (a DN) using \m[blue]<strong>ldap()</strong>\m[]\s-2\u[117]\d\s+2 and converts spaces to underscores. If the user&apos;s entry contains:</p>
<pre>
memberOf: CN=Domain Guests,CN=Users,DC=example,DC=com
memberOf: CN=Guests,CN=Builtin,DC=example,DC=com
</pre>
<p>the resulting roles would be Domain_Guests and Guests.</p><p><strong>Note</strong></p><p>These roles are discarded unless the \m[blue]<strong>STYLE</strong>\m[]\s-2\u[89]\d\s+2 directive for this module allows the roles to be incorporated into the user&apos;s credentials.</p><p>LDAP_SEARCH_FILTER (Required1-C)</p><p>If the indirect method is used, either this directive or LDAP_SEARCH_FILTER* (but not both) must be configured. This search filter is used to select the unique directory entry that corresponds to this user.</p><p>LDAP_SEARCH_FILTER* (Required1-C)</p><p>If the indirect method is used, either this directive or LDAP_SEARCH_FILTER (but not both) must be configured. This search filter is used to select the unique directory entry that corresponds to this user. This directive is exactly like LDAP_SEARCH_FILTER except that it is evaluated just before it is used, allowing various elements of the execution context to appear in the string. Example:</p>
<pre>
LDAP_SEARCH_FILTER* &apos;"(sAMAccountName=${Args::USERNAME})"&apos;
</pre>
<p>LDAP_SEARCH_ROOT_DN (Required1-C)</p><p>This is the root DN at which the indirect method should begin searching for user entries.</p><p>LDAP_TIMEOUT_SECS (Optional1)</p><p>This is a maximum time limit, in seconds, for any individual LDAP read or search operation performed by the module. If not specified, there will not be an application-specified time limit.</p><p>LDAP_USERNAME_EXPR* (Optional1)</p><p>If authentication succeeds, this directive is evaluated to yield the <strong>DACS</strong> username returned to <strong>dacs_authenticate</strong>. All of the entry&apos;s attribute names and values are made available within the LDAP namespace. If unspecified, the value of the <em>USERNAME</em> parameter is returned. Example:</p>
<pre>
LDAP_USERNAME_EXPR* &apos;"${LDAP::sAMAccountName}"&apos;
</pre>
<p>LDAP_USERNAME_URL (Optional1)</p><p>If the direct method is used, either this directive or \m[blue]<strong>LDAP_USERNAME_URL*</strong>\m[]\s-2\u[118]\d\s+2 (but not both) must be configured. This directive identifies both the LDAP server to use and the user being authenticated. The value of this directive is a URI (see \m[blue]<strong>RFC 2396</strong>\m[]\s-2\u[119]\d\s+2 and \m[blue]<strong>RFC 3986</strong>\m[]\s-2\u[120]\d\s+2) that gives the name of the LDAP server to contact to authenticate the user (as the scheme and authority part of the URI) and the DN for the user (as the path part of the URI). The scheme must be either ldap or ldaps (case insensitive). If no port number is specified, 389 is used with the former scheme and 636 with the latter.</p>
<pre>
LDAP_USERNAME_URL
  &apos;"ldap://example.com/cn=Auggie%20Doggie, cn=Users, dc=example, dc=com"&apos;
</pre>
<p><strong>Security</strong></p><p>The ldaps scheme is not implemented. Communication between this module and the LDAP server should use a secure channel or at least not be snoopable.</p><p>LDAP_USERNAME_URL* (Optional1)</p><p>If the direct method is used, either this directive or LDAP_USERNAME_URL (but not both) must be configured. This directive is exactly like LDAP_USERNAME_URL except that it is evaluated just before it is used, allowing various elements of the execution context to appear in the string. Example:</p>
<pre>
LDAP_USERNAME_URL*
  &apos;"ldap://example.com/cn=${Args::USERNAME}, cn=Users, dc=example, dc=com"&apos;
</pre>
<p><strong>Tip</strong></p><p>Before using LDAP authentication with <strong>DACS</strong>, you should first make sure that your LDAP server is functioning as you expect and that the host that will run the <strong>local_ldap_authenticate</strong> module can communicate with the LDAP server.</p><p>One way to do this is to use the \m[blue]<a href="../man1/ldapsearch.1.html"><strong>ldapsearch</strong>(1)</a></strong>\m[]\s-2\u[121]\d\s+2 command (found in the clients/tools directory of the OpenLDAP distribution) to bind to the directory and perform some searches. You should run this command on the same machine that will be running <strong>DACS</strong>&apos;s LDAP authentication module (<strong>local_ldap_authenticate</strong>). Some of the information that you obtain from this exercise may be helpful when you configure <strong>DACS</strong> to use this form of authentication.</p><p>Here are some examples to try - you must adapt the names for your environment:</p>
<pre>
% ./ldapsearch -h win2k.example.com -x -b "dc=example,dc=com" &#92;
     -D "CN=Administrator,CN=Users,DC=example,DC=com" -W -LLL
% ./ldapsearch -h win2k.example.com -x -b "dc=example,dc=com" &#92;
     -D "CN=Auggie Doggie,CN=Users,DC=example,DC=com" -W -LLL
% ./ldapsearch -h win2k.example.com -x -b "dc=example,dc=com" &#92;
     -D "CN=Administrator,CN=Users,DC=example,DC=com" -W -LLL &#92;
     "(cn=Administrator)" memberOf
% ./ldapsearch -h win2k.example.com -x -b "dc=example,dc=com" &#92;
     -D "CN=Administrator,CN=Users,DC=example,DC=com" -W -LLL &#92;
     "(sAMAccountName=auggie)"
</pre>
<p>In these examples, the LDAP server runs on a host named win2k.example.com (so change win2k.example.com, example, and com), and it expects a user named "Auggie Doggie" to exist and have the account name "auggie" (again, change to names that exist in your LDAP directory). You should be prompted for the LDAP password (in Windows, that will be the login password) for either Administrator or a user named "Auggie Doggie", depending on the argument that follows the <strong>-D</strong> flag.</p><p>The following configuration illustrates authentication using this module:</p>
<pre>
&lt;Auth id="ldap"&gt;
  URL "https://example.com/cgi-bin/dacs/local_ldap_authenticate"
  STYLE "password,add_roles"
  CONTROL "required"
  LDAP_BIND_METHOD "direct"
  LDAP_USERNAME_URL* &apos;"ldap://windows.example.com/cn=" &#92;
     . encode(url, ${Args::USERNAME}) . ",cn=Users,dc=example,dc=com"&apos;
  LDAP_USERNAME_EXPR* &apos;"${LDAP::sAMAccountName}"&apos;
  LDAP_ROLES_SELECTOR* &apos;"${LDAP::attrname}" eq "memberOf" &#92;
    ? strtr(ldap(rdn_attrvalue, &#92;
        ldap(dn_index, "${LDAP::attrvalue}", 1)), " ", "_") &#92;
    : 0&apos;
&lt;/Auth&gt;
</pre>
<p>Here, the LDAP authentication module will construct a DN by plugging the user-provided <em>USERNAME</em> argument into the template and binding to that DN with the <em>PASSWORD</em> argument. If successful, the <strong>DACS</strong> username will be the value of the user&apos;s entry&apos;s sAMAccountName attribute, and roles will extracted from the entry&apos;s memberOf attribute values, as described above.</p><p><strong>Note</strong></p><p>In Windows, the SAM-Account-Name Active Directory attribute value (sAMAccountName) need not be the same as the entry&apos;s Common Name; for instance, the former might be "doggie" and the latter "CN=Auggie Doggie". The sAMAccountName must not exceed 20 characters in length and must be unique within the domain. It is composed of printable characters other than the following:</p>
<pre>
&#92;   /   [   ]   :   ;   |   =   ,   +   *   ?   &lt;   &gt;   @   "
</pre>
<p>The userPrincipalName attribute value is a user account name (or "user login name") that is unique within its domain and a domain name identifying the domain in which the user account is located. The format is the same as a domain-name based email address; e.g., doggie@example.com.</p><p><strong>local_native_authenticate</strong></p><p>The <strong>local_native_authenticate</strong> module transfers a user&apos;s current, context-dependent web server identity to a <strong>DACS</strong> identity. The web server will most likely have used \m[blue]<strong>RFC 2617</strong>\m[]\s-2\u[55]\d\s+2 Basic or Digest authentication. The user, having already been authenticated by the web server at a particular jurisdiction, will automatically be given <strong>DACS</strong> credentials associated with that jurisdiction and typically having the same username.</p><p>The STYLE should be configured as native for this module.</p><p>This method of authentication also depends on a CGI helper program (\m[blue]<a href="../man8/autologin.8.html"><strong>autologin</strong>(8)</a></strong>\m[]\s-2\u[122]\d\s+2) and appropriate configuration of <strong>Apache</strong> authentication. The general idea is that the helper program must be executable only by users that have been properly authenticated by the web server (by any <strong>Apache</strong> method and using any <strong>Apache</strong> authentication module). The helper program then invokes <strong>dacs_authenticate</strong> with appropriate arguments; if this module has been enabled and accepts its arguments, the user will be given <strong>DACS</strong> credentials.</p><p>There are no directives or options specific to this module.</p><p><strong>local_ntlm_authenticate</strong></p><p>The <strong>local_ntlm_authenticate</strong> module authenticates users through Windows NT LAN Manager using the NTLM protocol [\m[blue]<strong>1</strong>\m[]\s-2\u[123]\d\s+2, \m[blue]<strong>2</strong>\m[]\s-2\u[124]\d\s+2]. This module, which makes use of \m[blue]<strong>Samba</strong>\m[]\s-2\u[125]\d\s+2 libraries, provides Windows \m[blue]<strong>NTLM authentication</strong>\m[]\s-2\u[126]\d\s+2 based on a username and password. The module does not need to be (and will not usually be) executed on the host running Windows.</p><p>The STYLE should be configured as password for this module.</p><p>The following OPTION directive values are understood:</p><p>SAMBA_SERVER (Required1)</p><p>The domain name or numeric IP address of the Windows system providing NTLM authentication.</p><p>SAMBA_PORT (Optional1)</p><p>The port number to use on SAMBA_SERVER. The default is 0, which tells Samba to use a sequence of default ports until one works.</p><p>SAMBA_DOMAIN (Optional1)</p><p>The domain name to use on SAMBA_SERVER. The default is "".</p><p>The module-specific option SAMBA_SERVER must be given to provide the domain name of the host providing the NTLM authentication. The module-specific options SAMBA_DOMAIN and SAMBA_PORT, which are optional, can be used to override the default port(s) used by Samba to contact SAMBA_SERVER.</p><p>The following illustrates how this module might be configured:</p>
<pre>
&lt;Auth id="ntlm"&gt;
  URL "https://example.com/cgi-bin/dacs/local_ntlm_authenticate"
  STYLE "pass"
  CONTROL "sufficient"
  OPTION &apos;SAMBA_SERVER="10.0.0.123"&apos;
  OPTION &apos;SAMBA_PORT="139"&apos;
&lt;/Auth&gt;
</pre>
<p>Here, <strong>dacs_authenticate</strong> will invoke the NTLM authentication module at the given URL. That module will try to authenticate the username and password given to it by asking the NTLM service at port 139 on the Windows system at 10.0.0.213.</p><p>There are no directives specific to this module.</p><p><strong>Security</strong></p><p>Attacks against some versions of NTLM \m[blue]<strong>have been identified</strong>\m[]\s-2\u[127]\d\s+2. Communication between this module and the NTLM service should use a secure channel or at least not be snoopable.</p><p><strong>Tip</strong></p><p>A built-in version of this module can be selected by using the URL local_ntlm_authenticate or just ntlm.</p><p>Before attempting to use this module, it may save a lot of time and aggravation if you first check that it is possible to authenticate against NTLM, <em>from the machine on which you intend to run this module</em>, using a username/password combination that you know is correct. If you are not able to successfully authenticate in this way, obviously you will not have any luck with the <strong>DACS</strong> module.</p><p>To test whether it is possible to authenticate using a particular username and password, you may be able to use \m[blue]<a href="../man1/smbclient.1.html"><strong>smbclient</strong>(1)</a></strong>\m[]\s-2\u[128]\d\s+2. For example, if C:&#92;Shared is a network shared folder or HPLaserJ-PS is a shared printer on the Windows machine on which you want to perform authentication, to authenticate as the Administrator try something like:</p>
<pre>
% smbclient //mywinhost/shared -U Administrator
</pre>
<p>or to authenticate as the user bob, try:</p>
<pre>
% smbclient //mywinhost/HPLaserJ-PS -U bob
</pre>
<p>Replace <em>mywinhost</em> with the name of your Windows machine. You should be prompted for the account&apos;s password. If <strong>smbclient</strong> successfully connects and establishes a session using the username and password you provide, then this module should also be able to authenticate that user, otherwise you should see an error message.</p><p>Before you have configured <strong>DACS</strong>, you can test NTLM authentication from the command line using \m[blue]<a href="../man1/dacsauth.1.html"><strong>dacsauth</strong>(1)</a></strong>\m[]\s-2\u[6]\d\s+2. For example, try something like:</p>
<pre>
% dacsauth -m ntlm passwd suff -OSAMBA_SERVER="windows.example.com" -prompt -u bob
</pre>
<p>Change "bob" to the username you want to authenticate and "windows.example.com" to the domain name of the Windows machine where the user&apos;s account is. You may also need to specify <em>SAMBA_PORT</em> if a non-standard port is being used. You will be prompted for the password for the user&apos;s account The program&apos;s exit status indicates success ("ok" is exit status 0) or failure (exit status 1). Repeat this with an invalid password to make sure that it fails.</p><p>After you have configured <strong>DACS</strong>, there is another method of testing <strong>local_ntlm_authenticate</strong> from the command line. Set the environment variable <strong>QUERY_STRING</strong> (using your preferred shell&apos;s syntax) to something like this:</p>
<pre>
% export QUERY_STRING="USERNAME=bob&PASSWORD=test&DACS_JURISDICTION=Test&#92;
&SAMBA_SERVER=windows.example.com"
</pre>
<p>Change "bob" to the username you want to authenticate, "test" to the password for that username, "Test" to the name of the <strong>DACS</strong> jurisdiction that will perform the authentication, and "windows.example.com" to the domain name of the Windows machine where the user&apos;s account is. You may also need to specify <em>SAMBA_PORT</em>. Then from the distribution&apos;s src directory:</p>
<pre>
% ./local_ntlm_auth -uj Test
</pre>
<p>Use the <strong>-u</strong>, <strong>-uj</strong>, or <strong>-us</strong> flag to specify a jurisdiction that you have configured (see \m[blue]<a href="../man1/dacs.1.html"><strong>dacs</strong>(1)</a></strong>\m[]\s-2\u[129]\d\s+2). The output, an XML document, indicates success ("ok", exit status 0) or failure ("failed", exit status 1). Repeat this with an invalid password to make sure that it fails. When you are done, remember to delete the <strong>QUERY_STRING</strong> environment variable.</p><p><strong>local_pam_authenticate</strong></p><p>This module makes a local or remote Pluggable Authentication Modules (PAM) infrastructure available for authentication. PAM authenticates a user that is known to the PAM-capable operating system (i.e., a user with an existing account) through one or more PAM authentication service modules that have been configured by the system administrator. Other PAM operations, such as password management, are currently unsupported by <strong>DACS</strong>. Please refer to \m[blue]<strong>X/Open Single Sign-On Service (XSSO) -- Pluggable Authentication</strong>\m[]\s-2\u[48]\d\s+2 for additional information about PAM.</p><p><strong>Note</strong></p><p>By default, the <strong>pamd</strong> server uses "dacs" as the name of the PAM policy (see \m[blue]<a href="../man3/pam_start.3.html"><strong>pam_start</strong>(3)</a></strong>\m[]\s-2\u[130]\d\s+2). Some systems may revert to a default policy (such as "other") if no "dacs" policy is defined. A policy name can be specified as a <strong>pamd</strong> argument.</p><p>There is a huge selection of open source and vendor-supplied PAM authentication modules for a wide variety of platforms, including some that provide functionality similar to that of <strong>DACS</strong> authentication modules [\m[blue]<strong>GNU/Linux</strong>\m[]\s-2\u[131]\d\s+2, \m[blue]<strong>FreeBSD</strong>\m[]\s-2\u[132]\d\s+2, \m[blue]<strong>Solaris</strong>\m[]\s-2\u[133]\d\s+2]. For example, \m[blue]<a href="../man8/pam_unix.8.html"><strong>pam_unix</strong>(8)</a></strong>\m[]\s-2\u[134]\d\s+2 performs essentially the same authentication function as \m[blue]<strong>local_unix_authenticate</strong>\m[]\s-2\u[135]\d\s+2, except that the latter is not interactive (it does not prompt).</p><p>The STYLE should be configured as prompted for this module.</p><p><strong>Note</strong></p><p>While this authentication module has been tested with only a few PAM authentication service modules, in theory it should work with any conformant PAM authentication module. If this module is used, the current implementation does not allow any other authentication modules to be configured for the jurisdiction; this can be partially ameliorated by configuring PAM to try multiple PAM modules.</p><p><strong>Important</strong></p><p>The <strong>local_pam_authenticate</strong> module depends on functionality provided by \m[blue]<a href="../man8/pamd.8.html"><strong>pamd</strong>(8)</a></strong>\m[]\s-2\u[136]\d\s+2 running on a PAM-capable system, which does not need to be the same host where <strong>local_pam_authenticate</strong> is run. The <strong>local_pam_authenticate</strong> module establishes connections with <strong>pamd</strong>, which interacts with the \m[blue]<a href="../man3/pam.3.html"><strong>pam</strong>(3)</a></strong>\m[]\s-2\u[47]\d\s+2 library. Unlike the other <strong>DACS</strong> authentication styles, authentication using the prompted style may involve more than one request to <strong>dacs_authenticate</strong>, each of which supplies additional authentication material.</p><p>The prompted authentication style implements a <em>session</em> between the user and the PAM library that consists of a sequence of operations that comprise a PAM <em>transaction</em>. For each operation, <strong>dacs_authenticate</strong> (via <strong>local_pam_authenticate</strong> and <strong>pamd</strong>) supplies the PAM library with authentication material (either initial data or data requested by the PAM library from the previous operation), determines if authentication has succeeded or failed, or whether the user must be prompted for additional data. If the PAM library requires additional data, the user is prompted for it, and the response is submitted to <strong>dacs_authenticate</strong> in the transaction&apos;s next operation.</p><p>If PAM requires information from the user, <strong>local_pam_authenticate</strong> can be configured to prompt for it using one of three methods. The first method is used if the Auth clause has an OPTION directive that configures PAM_HANDLER_URL; the user will be redirected to this URL. The other possibilities are selected by the <em>FORMAT</em> argument (see \m[blue]<a href="../man8/dacs.services.8.html"><strong>dacs.services</strong>(8)</a></strong>\m[]\s-2\u[75]\d\s+2). If any XML type is specified, the reply from <strong>dacs_authenticate</strong> will conform to the DTD \m[blue]<strong>dacs_auth_reply.dtd</strong>\m[]\s-2\u[76]\d\s+2. If HTML is specified and PAM authentication requires additional information from the user, <strong>dacs_authenticate</strong> will return a rudimentary HTML form that must be completed and submitted by the user. For example, if <strong>pam_unix</strong> is configured, <strong>dacs_authenticate</strong> may emit a web page that prompts for a username (if none was provided with the initial invocation of <strong>dacs_authenticate</strong>), and after that form has been submitted by the user emit a web page that prompts for a password.</p><p>If PAM_HANDLER_URL is configured, the handler to which the administrator redirects users has complete control over user prompting. In most implementations, the handler will emit a web page that includes a form element, with appropriate inputs and hidden variables, which is submitted to the web service named in the <em>service</em> argument (see below). The handler is required to obtain values for a set of requested variables and submit them to a given URL (<strong>dacs_authenticate</strong>). Each variable has a type, an optional descriptive text label, and a name. The value of PAM_HANDLER_URL may either be an absolute URL or a web service name, beginning with a &apos;/&apos;, that is interpreted relative to the current jurisdiction (i.e., the \m[blue]<strong>dacs_url</strong>\m[]\s-2\u[137]\d\s+2 is prepended). Query arguments may be included, provided none of the argument names used by <strong>dacs_authenticate</strong>, described below, are duplicated.</p><p>The <strong>pamd</strong> server requires the handler to respond within <strong>60</strong> seconds (configured at compile time). The <strong>local_pam_authenticate</strong> module requires <strong>pamd</strong> to respond to the initial request with the first prompt within <strong>20</strong> seconds (configured at compile time). Should the handler encounter a serious error, it can simply terminate; this will cause <strong>pamd</strong> to eventually time out, which will abort the PAM transaction.</p><p><strong>Security</strong></p><p>The handler does not have to be <strong>DACS</strong>-wrapped, but ideally it should be. If it is, don&apos;t forget to add an access control rule to grant access to any user that might authenticate through <strong>local_pam_authenticate</strong>.</p><p>This "prompter" service might be configured as follows:</p>
<pre>
OPTION "PAM_HANDLER_URL=/dacs_pam_handler"
</pre>
<p>This will be expanded into a URL that looks something like https://example.com/cgi-bin/dacs/dacs_pam_handler. When a user is redirected to this handler, <strong>dacs_authenticate</strong> adds the following query arguments:</p><p><em>service</em>: This is the URL of the <strong>dacs_authenticate</strong> service to which the handler must submit the requested values. This URL will not include any query arguments. Because private information, such as a password, may be present, it will typically use the https scheme. The handler should use the POST method to invoke <em>service</em>.</p><p><em>CSS_PATH</em>: This is the path configured for HTML stylesheets.</p><p><em>AUTH_TRANSID</em>: This is the unique transaction identifier for this PAM interaction. As part of a single authentication transaction, the handler may be called several times with the same <em>AUTH_TRANSID</em>. The handler is not required to retain state between these calls, but it may do so. The handler must pass this argument when calling <em>service</em>. Although the lifetime of this identifier is relatively brief, it should be kept private by the handler.</p><p><em>auth_prompt_var_prefix</em>: Each requested value will be identified by an argument to <em>service</em> having this prefix, with a positive integer (<em>int</em>, which is assigned consecutive integers starting with <strong>1</strong>) appended. For instance, if <em>auth_prompt_var_prefix</em> is "AUTH_PROMPT_VAR", then the handler must submit the requested values as <em>AUTH_PROMPT_VAR1</em>, <em>AUTH_PROMPT_VAR2</em>, and so on. The first absent <em>int</em> value signals the end of the variable argument list.</p><p><em>TYPE</em><em></em><em>int</em>: This is the type ("text", "password", or "error") of the variable numbered <em>int</em>. The password type indicates the value should not be displayed during user input.</p><p><em>LABEL</em><em></em><em>int</em>: This argument, which is optional, indicates a label that might be displayed beside the user prompt (e.g., "Username?") for variable <em>int</em>.</p><p><em>NAME</em><em></em><em>int</em>: If this argument is not present for a given <em>int</em>, then no value is required for this variable - presumably <em>LABEL</em><em></em><em>int</em> is informational. If <em>NAME</em><em></em><em>int</em> is present, it gives the name of the variable to use when the handler submits the value. For example, suppose the handler is called with arguments <em>TYPE2</em> as "text", <em>LABEL2</em> as "Login:", and <em>NAME2</em> as "AUTH_PROMPT_VAR2". This asks the handler to prompt for text input labeled "Login:". If the user submits the value "Auggie", then included with the arguments to <em>service</em> there should be a variable named <em>AUTH_PROMPT_VAR2</em> with the value "Auggie".</p><p>Any other arguments to the handler should be forwarded to <em>service</em> verbatim. Such arguments include <em>DACS_VERSION</em>, <em>DACS_JURISDICTION</em>, <em>DACS_BROWSER</em>, and <em>ENABLE_AUTH_HANDLERS</em>.</p><p><strong>Note</strong></p><p>For testing purposes, it may be helpful to set PAM_HANDLER_URL to <strong>dacs_prenv</strong>, which will display the arguments passed to the handler and other context. The <strong>DACS</strong> distribution includes an example handler, html/handlers/dacs_pam_handler.</p><p>If an HTML form is emitted, its appearance can be customized somewhat through the default stylesheet \m[blue]<strong>local_pam_authenticate.css</strong>\m[]\s-2\u[138]\d\s+2. The content of the generated web page can be customized through the local_pam_authenticate VFS item type. The following items relative to that item type are emitted if they exist:</p><p>header: Initial HTML to emit instead of the default.</p><p>prologue: HTML to emit immediately after the header.</p><p>instructions: HTML to emit immediately after the prologue and before the form.</p><p>form: Additional HTML to emit within the form.</p><p>epilogue: HTML to emit immediately after the form.</p><p>trailer: Final HTML to emit instead of the default.</p><p>For example, consider the configuration directive:</p>
<pre>
VFS "[local_pam_authenticate]dacs-fs:${Conf::DACS_HOME}/pam_auth"
</pre>
<p>Here, pam_auth is the directory ${Conf::DACS_HOME}/pam_auth. If files named header and trailer exist in that directory, they are expected to contain the initial and final HTML content, respectively. These files consist of text and HTML markup but are not complete HTML documents.</p><p>Customization of the HTML form is possible using configuration variables:</p><p><em>prompt_submit_label</em>: the text label to put in the form&apos;s submit button.</p><p>For example, the submit button&apos;s text can be specified using the directive:</p>
<pre>
EVAL ${Conf::prompt_submit_label} = " Continue "
</pre>
<p><strong>Tip</strong></p><p>A built-in version of this module can be selected by using the URL local_pam_authenticate or just pam.</p><p><strong>local_passwd_authenticate</strong></p><p>The <strong>local_passwd_authenticate</strong> module provides support for <strong>DACS</strong> identities, strictly private to <strong>DACS</strong>, through password-protected accounts (similar to what <strong>Apache</strong>&apos;s \m[blue]<strong></strong><strong>mod_auth</strong>\m[]\s-2\u[80]\d\s+2 and \m[blue]<strong></strong><strong>mod_auth_dbm</strong>\m[]\s-2\u[82]\d\s+2 modules do, along with the \m[blue]<a href="../man1/htpasswd.1.html"><strong>htpasswd</strong>(1)</a></strong>\m[]\s-2\u[83]\d\s+2 utility). A secure hash of a password is stored rather than the plaintext password itself. Several hashing methods are available (see \m[blue]<strong>PASSWORD_DIGEST</strong>\m[]\s-2\u[139]\d\s+2).</p><p>The <strong>local_passwd_authenticate</strong> module performs authentication by consulting the <em>USERNAME</em> and <em>PASSWORD</em> parameters and comparing them to the information previously stored by the administrator.</p><p><strong>Security</strong></p><p>This module always requires the <em>PASSWORD</em> argument and will not accept the empty string as a password value (even if that actually is the password). Use \m[blue]<strong>local_simple_authenticate</strong>\m[]\s-2\u[62]\d\s+2 for password-less accounts.</p><p>The STYLE should be configured as password for this module.</p><p>The \m[blue]<a href="../man1/dacspasswd.1.html"><strong>dacspasswd</strong>(1)</a></strong>\m[]\s-2\u[140]\d\s+2 utility is used to manage these accounts. The item type is "passwds".</p><p>The following example configuration, which reflects typical usage, maintains user and password information in a plain text file named /usr/local/dacs/federations/passwd.</p>
<pre>
VFS "[passwds]dacs-kwv-fs:/usr/local/dacs/federations/passwd"
</pre>
<p>There are no directives or options specific to this module.</p><p><strong>Note</strong></p><p>The name "local_passwd_authenticate" may be a little confusing because there are other modules that implement some form of password-based authentication. This module might more appropriately be called "local_dacspasswd_authenticate".</p><p><strong>Tip</strong></p><p>A built-in version of this module can be selected by using the URL local_passwd_authenticate or just passwd.</p><p><strong>local_simple_authenticate</strong></p><p>The <strong>local_simple_authenticate</strong> module supports <strong>DACS</strong> identities, strictly private to <strong>DACS</strong>, through accounts that are <em>not</em> password-protected. The <strong>local_simple_authenticate</strong> module performs authentication by looking up an account named by the <em>USERNAME</em> argument. In typical use, the username will be an email address, account or membership number, or random character string.</p><p><strong>Security</strong></p><p>This form of authentication is <em>inherently insecure</em> because no password is provided. It is only appropriate when the consequences of a valid account name being guessed or misappropriated are of little concern. Administrators should not assume that using difficult-to-guess account names with this module offers much security. Keep in mind that depending on the larger context of how these identities are used, these usernames may be publicly visible.</p><p>The STYLE should be configured as simple for this module.</p><p>The \m[blue]<a href="../man1/dacspasswd.1.html"><strong>dacspasswd</strong>(1)</a></strong>\m[]\s-2\u[140]\d\s+2 utility is used to manage these accounts. The item type is "simple".</p><p>The following example configuration, which reflects typical usage, maintains user account information in a plain text file named /usr/local/dacs/federations/simple_accounts.</p>
<pre>
VFS "[simple]dacs-kwv-fs:/usr/local/dacs/federations/simple_accounts"
</pre>
<p><strong>Note</strong></p><p>Although it is possible to combine password-protected accounts and password-less accounts in the same VFS object (i.e., with the item types passwds and simple pointing to the same file or database), putting them in separate objects is recommended.</p><p>There are no directives or options specific to this module.</p><p><strong>Tip</strong></p><p>A built-in version of this module can be selected by using the URL local_simple_authenticate or just simple.</p><p><strong>local_token_authenticate</strong></p><p>This module works in concert with the \m[blue]<a href="../man1/dacstoken.1.html"><strong>dacstoken</strong>(1)</a></strong>\m[]\s-2\u[141]\d\s+2 utility to support one-time passwords. Two-factor authentication, a strong authentication method, is supported by combining hardware token-based one-time passwords ("something you have") with a PIN (a password, "something you know"). Software-based clients may also be used. The implementation follows \m[blue]<strong>RFC 4226</strong>\m[]\s-2\u[142]\d\s+2, which has been adopted by \m[blue]<strong>OATH</strong>\m[]\s-2\u[143]\d\s+2, and other standards. Please refer to \m[blue]<a href="../man1/dacstoken.1.html"><strong>dacstoken</strong>(1)</a></strong>\m[]\s-2\u[141]\d\s+2 for complete details.</p><p>The STYLE should be configured as password for this module.</p><p>In addition to the usual <em>USERNAME</em> argument, the module requires the <em>PASSWORD</em> argument to be the next one-time password (e.g., the value produced by the user&apos;s hardware token). If the user&apos;s <strong>DACS</strong> account has a PIN associated with it, the PIN must be passed as the <em>AUXILIARY</em> argument. The PIN referred to here is the one managed by <strong>dacstoken</strong>, not a PIN that may be entered into the token device to unlock it.</p><p>One-time password generation depends on a secret that is shared between the client and <strong>DACS</strong>, and a non-repeating value that may be based on synchronized counters or clocks. The client&apos;s token can become unsynchronized with the server&apos;s state. This can happen for many reasons, such as if a password is generated by the device but not used, if a password or PIN is typed incorrectly, or because of a configuration error. The method can tolerate a configurable deviation of the client&apos;s token from the server&apos;s state; that is, provided the client&apos;s password falls within a window of <em>N</em> from the one expected by <strong>DACS</strong>, <strong>DACS</strong> will accept the client&apos;s token. For counter-based tokens, only the "forward" side of the window is examined, so <strong>DACS</strong> can "catch up" to the client.</p><p>If the user&apos;s password does not fall within the window, it is deemed to have become unsynchronized with <strong>local_token_authenticate</strong> and authentication will fail. The user can attempt to resynchronize by entering a sequence of passwords as <em>PASSWORD</em>, using a comma to separate them. Three consecutive, valid passwords are required (this number can be configured at build time). If the account has a PIN, it must be provided to enable synchronization. If synchronization succeeds, the user&apos;s account information is corrected and the module also reports successful authentication. If synchronization fails, the module also fails and a <strong>DACS</strong> administrator must be contacted to resynchronize the token.</p><p><strong>Note</strong></p><p>The token value must be entered exactly as it is displayed on the token. Leading zeroes must be typed, for example, and no spaces or punctuation are allowed. Whenever authentication fails, the user must obtain a new password from the token.</p><p>The following OPTION directive value is understood:</p><p>ACCEPT_WINDOW (Optional1)</p><p>The (non-negative) size of the acceptance window for one-time passwords, overriding the default. If the size is zero, <strong>DACS</strong> will only consider a match with the expected password and will not try to match the user&apos;s password against "nearby" passwords. With some modes of operation, only forward matches are allowed.</p><p><strong>Tip</strong></p><p>A built-in version of this module can be selected by using the URL local_token_authenticate or just token.</p><p><strong>local_unix_authenticate</strong></p><p>The <strong>local_unix_authenticate</strong> module implements native Unix username/password authentication, allowing a user having a pre-existing Unix account to be authenticated by <strong>DACS</strong> using the username and password for that account. The \m[blue]<a href="../man3/getpwnam.3.html"><strong>getpwnam</strong>(3)</a></strong>\m[]\s-2\u[144]\d\s+2 library function is passed the <em>USERNAME</em> and <em>PASSWORD</em> parameters given to <strong>dacs_authenticate</strong>. It can be configured for systems with or without shadow passwords. On some Unix systems, when the \m[blue]<strong>yp(8)</strong>\m[]\s-2\u[145]\d\s+2 password database is enabled, the \m[blue]<a href="../man3/getpwnam.3.html"><strong>getpwnam</strong>(3)</a></strong>\m[]\s-2\u[144]\d\s+2 function will use the YP map "passwd.byname" if the requested password entry is not found in the local database.</p><p>The STYLE should be configured as password for this module.</p><p><strong>Tip</strong></p><p>A built-in version of this module can be selected by using the URL local_unix_authenticate or just unix. If the module is used, <strong>dacs_authenticate</strong> must be setuid root since it must be able to read the shadow password file.</p>
<h3>Roles</h3>
<p>Each user authenticated by <strong>DACS</strong> may be associated with one or more roles. The \m[blue]<strong>syntax of roles and role descriptors</strong>\m[]\s-2\u[14]\d\s+2 is described elsewhere. Role-based group membership is discussed in \m[blue]<a href="../man5/dacs.groups.5.html"><strong>dacs.groups</strong>(5)</a></strong>\m[]\s-2\u[146]\d\s+2. Configuration of a Roles clause is optional and if none are specified, an empty role descriptor string will be used. If more than one Roles clause is configured, their role strings are concatenated (duplicates are not removed). If a roles service fails, it is treated as if it returned no roles and processing continues normally.</p><p>Like authentication, a modular mechanism is used to find the roles with which a user is associated. A roles module, analogous to an authentication module, can be called by <strong>dacs_authenticate</strong> to return roles. A roles service returns a roles_reply element (see \m[blue]<strong>roles_reply.dtd</strong>\m[]\s-2\u[147]\d\s+2).</p><p>Each Roles element must have an id attribute. Its value is merely a label (an alphabetic followed by zero or more alphanumerics, hyphens, and underscores) that allows the clause to be referenced. The id attribute values must be unique (case-sensitively) within the clause&apos;s Jurisdiction section.</p><p><strong>Note</strong></p><p>A maximum limit is imposed on the length of a role descriptor string. Please refer to the \m[blue]<strong>ROLE_STRING_MAX_LENGTH</strong>\m[]\s-2\u[148]\d\s+2 directive.</p>
<h3>Roles Clause Directives</h3>
<p>The roles directives are largely analogous to the authentication directives.</p><p>When evaluation of the Roles clauses begins, several variables are available in the Auth namespace to reflect the outcome of authentication. These variables may be useful when determining the user&apos;s roles: <em>DACS_USERNAME</em>, <em>DACS_IDENTITY</em>, <em>DACS_JURISDICTION</em>, and <em>DACS_VERSION</em>.</p><p><strong>Roles Clause Directives Index:</strong></p><p>EXIT* (Optional1)</p><p>EXPR (Optional1)</p><p>INIT* (Optional1)</p><p>OPTION (Optional)</p><p>OPTION* (Optional)</p><p>PREDICATE (Optional1)</p><p>URL (Optional1)</p><p>URL* (Optional1)</p><p>URL (Optional1)</p><p>URL* (Optional1)</p><p>Exactly one of these two directives must be specified, unless EXPR is specified, in which case neither URL nor URL* may be specified. These directives specify the URL to be used to invoke the roles module (or is the name of a built-in module). The difference between the two directives is that the value of URL* is an expression that is evaluated to determine the URL to be used; this evaluation occurs immediately before the module is invoked.</p><p>INIT* (Optional1)</p><p>An expression can be specified that is to be evaluated immediately prior to the URL* and EXPR expressions, all of which are evaluated before a module is invoked.</p><p>EXIT* (Optional1)</p><p>If authentication is successful, this expression is evaluated immediately after the module is executed or EXPR evaluated.</p><p>EXPR (Optional1)</p><p>This directive gives an expression that is evaluated to obtain roles instead of invoking a roles module. Please refer to Advanced Techniques.</p><p>OPTION (Optional)</p><p>Similar to the Auth clause&apos;s \m[blue]<strong>OPTION</strong>\m[]\s-2\u[45]\d\s+2 directive, this is used to pass an argument to the roles module. A given <em>name</em> may not be specified more than once within a particular Roles clause. The Options namespace is initialized with <em>DACS_USERNAME</em>, <em>DACS_JURISDICTION</em>, and <em>DACS_VERSION</em> variables. If these are specified by an OPTION, the argument ordinarily used will be overridden.</p><p>For example:</p>
<pre>
OPTION "PASSWORD=bobo"
</pre>
<p>causes PASSWORD=bobo to be passed as a POST method parameter.</p><p>OPTION* (Optional)</p><p>The given expression is evaluated before the module is called, and after all OPTION directives and all OPTION* directives that appear earlier. The value of the expression must be a <em>name</em>=<em>value</em> pair, as with the OPTION directive, and overrides any <em>name</em> in the Options namespace.</p><p>PREDICATE (Optional1)</p><p>If provided, this expression is evaluated before any other roles module processing is done. If there is an evaluation error or it returns <strong>False</strong> (zero or the empty string), processing of the clause terminates and the next Roles clause, if any, is processed. Otherwise, processing of the clause continues normally.</p>
<h3>Roles Clause Control Flow</h3>
<p>If authentication succeeds, Roles clauses are processed in which they appear, but only if \m[blue]<strong>set_roles</strong>\m[]\s-2\u[64]\d\s+2 has not been specified for some authentication module&apos;s STYLE.</p><p>A Roles clause is processed in a sequence of steps, and with various hooks to provide fine-grained control. Before the first clause is examined, the variables <em>${Auth::CURRENT_ROLES}</em> and <em>${Auth::LAST_ROLES}</em> are initialized to the role string, if any, obtained during authentication module processing. Processing of each Roles clause proceeds as follows:</p><p>If the clause has a PREDICATE directive, it is evaluated in the current context. If the value is not <strong>True</strong> the clause is not evaluated further. No variables are updated. If the expression was invalid, processing of roles is terminated.</p><p>If the clause has an INIT* directive, it is evaluated; if an error occurs, processing of roles is terminated.</p><p>If the clause has a URL* directive, it is evaluated to obtain the URL of the <strong>DACS</strong> roles service to be invoked; if an error occurs, processing of roles is terminated. If the clause has an EXPR* directive, it is evaluated to obtain the role string; if an error occurs during evaluation it is treated as if the expression returned the empty string.</p><p>If a roles service has been specified, it is invoked. If an error occurs, roles processing <em>continues as if the module returned the empty string for the role string</em>.</p><p>The variable <em>${Auth::LAST_ROLES}</em> is set to the roles string returned by the module or expression.</p><p>If the clause has an EXIT* directive, it is evaluated; if an error occurs, processing of roles is terminated. The value of <em>${Auth::LAST_ROLES}</em> becomes the role string returned by the clause.</p><p>The role string returned by the clause is appended to the variable <em>${Auth::CURRENT_ROLES}</em>.</p><p>The value of <em>${Auth::CURRENT_ROLES}</em> when the last module has been processed is the roles string that will be used in the generated credentials.</p><p><strong>Tip</strong></p><p>Some roles modules are available as built-in components of <strong>dacs_authenticate</strong>. These modules are identified by specific relative URLs; a module&apos;s description will provide its built-in name when this capability is available. The built-in capability will automatically be provided if the module has been enabled at build-time. The same applies for <strong>dacsauth</strong>.</p><p>Although it will be more efficient (and possibly more secure) to use a built-in module, they are executed on the same host as <strong>dacs_authenticate</strong> (thereby giving up some flexibility), access control rules are not applied to them (other than the one for <strong>dacs_authenticate</strong>), and <strong>dacs_authenticate</strong> may need to be executed setuid (probably as root) or setgid (as www, for example) so that it can access password files.</p>
<h3>Roles Modules</h3>
<p>If and only if authentication succeeds, <strong>DACS</strong> can request the user&apos;s role descriptor from the jurisdiction. Roles modules are always invoked using the POST method and are passed the following arguments:</p><p><em>DACS_USERNAME</em></p><p>The <em>username</em> component of the user&apos;s <strong>DACS</strong> identity.</p><p><em>DACS_JURISDICTION</em></p><p>The name of the jurisdiction that authenticated <em>DACS_USERNAME</em>.</p><p><em>DACS_VERSION</em></p><p>The DACS_VERSION_NUMBER for this version of <strong>dacs_authenticate</strong>.</p><p>OPTION directives</p><p>For each \m[blue]<strong>OPTION directive</strong>\m[]\s-2\u[149]\d\s+2 or \m[blue]<strong>OPTION* directive</strong>\m[]\s-2\u[150]\d\s+2 in the Roles section being processed, the variable name and its value are passed.</p><p>Any of the standard web service arguments will also be accepted; anything else will be ignored.</p><p>Roles modules return an \m[blue]<strong>roles_reply.dtd</strong>\m[]\s-2\u[147]\d\s+2 document to <strong>dacs_authenticate</strong>.</p><p><strong>Note</strong></p><p>Although there is a roles module for obtaining LDAP or ADS roles, you may also get them by authenticating through \m[blue]<strong>local_ldap_authenticate</strong>\m[]\s-2\u[44]\d\s+2 or by using a Roles clause with an appropriate EXPR directive.</p><p><strong>Roles Module Index:</strong></p><p>local_roles: Private <strong>DACS</strong> roles</p><p>local_ldap_roles: Roles imported from an LDAP/ADS directory</p><p>local_unix_roles: Roles imported from Unix group membership</p><p><strong>local_roles</strong></p><p>This roles service consults a private list to obtain a username-to-roles mapping using <strong>DACS</strong> virtual storage (the item type is "roles"). The following example configuration, which reflects typical usage, maintains mappings in a plain text file named /usr/local/dacs/federations/roles.</p>
<pre>
VFS "[roles]dacs-kwv-fs:/usr/local/dacs/federations/roles"
</pre>
<p>The file /usr/local/dacs/federations/roles might look something like this:</p>
<pre>
admin:dacs,admin
rick:metalogic,guests
bobo:staff,users
auggie:staff,users
</pre>
<p>Here, user auggie is associated with the roles staff and users.</p><p><strong>Tip</strong></p><p>A built-in version of this module can be selected by using the URL local_roles or just roles.</p><p><strong>local_ldap_roles</strong></p><p>This roles service returns roles derived from the attributes of a user&apos;s LDAP/ADS directory entry. This module is based on \m[blue]<strong>local_ldap_authenticate</strong>\m[]\s-2\u[44]\d\s+2; please consult the description and examples presented with that authentication module for additional information.</p><p><strong>Note</strong></p><p>The user need not have been authenticated by LDAP/ADS for this module to be used. For example, the user can be authenticated on a Unix system but his roles can come from LDAP/ADS.</p><p>The following configuration directives are recognized by this module. They function identically to the directives of the same name used by \m[blue]<strong>local_ldap_authenticate</strong>\m[]\s-2\u[44]\d\s+2, so for the most part their descriptions will not be repeated here.</p><p><strong>Note</strong></p><p>These module directives must be passed using either the \m[blue]<strong>OPTION</strong>\m[]\s-2\u[149]\d\s+2 or \m[blue]<strong>OPTION*</strong>\m[]\s-2\u[150]\d\s+2 directive. Ensure that the option value is properly quoted.</p><p>LDAP_BIND_METHOD (Required1-C)</p><p>This tells the module how to find the user&apos;s entry.</p><p>LDAP_USERNAME_URL (Optional1)</p><p>LDAP_USERNAME_URL* (Optional1)</p><p>With the direct method, one of these options is used to name the user&apos;s entry as a URI.</p><p>LDAP_ADMIN_URL (Required1-C)</p><p>If the indirect method is used, this option is required. This value is a URI like LDAP_USERNAME_URL except that it identifies the LDAP directory&apos;s administrator.</p><p>LDAP_ADMIN_PASSWORD (Optional1)</p><p>This is the password for the LDAP administrator account that corresponds to LDAP_ADMIN_URL.</p><p>LDAP_SEARCH_ROOT_DN (Required1-C)</p><p>This is the root DN at which the indirect method should begin searching for user entries.</p><p>LDAP_SEARCH_FILTER (Required1-C)</p><p>LDAP_SEARCH_FILTER* (Required1-C)</p><p>If the indirect method is used, either this option or LDAP_SEARCH_FILTER* (but not both) must be configured. This search filter is used to select the unique directory entry that corresponds to this user. The LDAP_SEARCH_FILTER* option is exactly like LDAP_SEARCH_FILTER except that it is evaluated just before it is used, allowing various elements of the execution context to appear in the string. The <strong>DACS</strong> username obtained from the preceding authentication phase can be referenced as <em>${Args::DACS_USERNAME}</em>.</p><p>LDAP_USERNAME_EXPR* (Optional1)</p><p>This option is evaluated to yield a username that can be referenced by the LDAP_ROLES_SELECTOR* option as <em>${LDAP::USERNAME}</em>.</p><p>LDAP_ROLES_SELECTOR* (Optional)</p><p>Each occurrence of this directive specifies an expression that is evaluated by iterating through each attribute of the entry and making the attribute name (<em>${LDAP::attrname}</em>) and its value (<em>${LDAP::attrvalue}</em>) available. All of the entry&apos;s attribute names and values are made available within the LDAP namespace. If the result of the expression is a valid role string (which excludes the empty string, ""), it is added to the list of roles.</p><p>LDAP_TIMEOUT_SECS (Optional1)</p><p>This is a maximum time limit, in seconds, for any individual LDAP read or search operation performed by the module. If not specified, there will not be an application-specified time limit.</p><p>Here is an example that binds to the directory on x.example.com as the administrator, searches for the entry for the account of the authenticated user, and assigns the user a role from the attribute value of each memberOf attribute in the entry:</p>
<pre>
&lt;Roles id="ldap_roles"&gt;
URL "http://example.com/cgi-bin/dacs/local_ldap_roles"
OPTION "LDAP_BIND_METHOD=indirect"
OPTION &#92;
&apos;LDAP_ADMIN_URL="ldap://x.example.com/CN=Administrator,CN=Users,DC=example,DC=com"&apos;
OPTION &apos;LDAP_ADMIN_PASSWORD="secretpassword"&apos;

OPTION &apos;LDAP_SEARCH_ROOT_DN="cn=Users,dc=example,dc=com"&apos;
OPTION &apos;LDAP_SEARCH_FILTER*=&#92;&apos;"(sAMAccountName=${Args::DACS_USERNAME})"&#92;&apos;&apos;

OPTION &apos;LDAP_ROLES_SELECTOR*=&#92;&apos;"${LDAP::attrname}" eq "memberOf" &#92;
    ? strtr(ldap(rdn_attrvalue, &#92;
        ldap(dn_index, "${LDAP::attrvalue}", 1)), " ", "_") &#92;
    : ""&#92;&apos;&apos;
&lt;/Roles&gt;
</pre>
<p>For example, the resulting role string might look like:</p>
<pre>
DnsAdmins,Print_Operators,Domain_Admins,Administrators
</pre>
<p><strong>local_unix_roles</strong></p><p>This roles service returns the Unix group membership associated with an authenticated username; that it, the resulting list of roles is the same as would be obtained if the user ran the Unix \m[blue]<a href="../man1/groups.1.html"><strong>groups</strong>(1)</a></strong>\m[]\s-2\u[151]\d\s+2.</p><p><strong>Note</strong></p><p>The user need not have been authenticated as this username on the Unix system where this service is run.</p><p><strong>Tip</strong></p><p>A built-in version of this module can be selected by using the URL local_unix_roles or just unix.</p>
<h3>Related Services</h3>
<p>The \m[blue]<a href="../man8/dacs_current_credentials.8.html"><strong>dacs_current_credentials</strong>(8)</a></strong>\m[]\s-2\u[33]\d\s+2 web service displays elements of each set of credentials sent with the request. The \m[blue]<a href="../man8/dacs_signout.8.html"><strong>dacs_signout</strong>(8)</a></strong>\m[]\s-2\u[152]\d\s+2 service is typically called from a browser to cause one or more cookies (each representing a <strong>DACS</strong> identity) to be deleted. Cookies are automatically deleted when a browser terminates, but it is sometimes useful to explicitly logoff.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DIAGNOSTICS</h2>
        <div class="sectioncontent">
<p>The program exits 0 if everything was fine, 1 if an error occurred.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTES</h2>
        <div class="sectioncontent">
<p>A separate but similar mechanism called "affiliated <strong>DACS</strong> federations" supports cross-federation single sign-on; see \m[blue]<a href="../man8/dacs_auth_transfer.8.html"><strong>dacs_auth_transfer</strong>(8)</a></strong>\m[]\s-2\u[8]\d\s+2.</p><p><strong>dacs_authenticate</strong> could be modified to temporarily disable an account after some number of unsuccessful login attempts over a certain time period. The flip side of such a feature is that it could be used in a denial of service attack. Rather than disabling an account, a designated administrator might receive an email notification or a console message might be logged.</p><p>It might be worthwhile to include a rule-based mechanism, called after the user has been identified but before credentials are returned, to decide whether authentication should be permitted. This might be used, for example, to restrict a particular user to login from a specified IP address or range of addresses, or limit the time of day at which login is allowed.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>It would be nice to provide assistance to programs that generate login pages. Composing modules should be easier, to make multi-factor authentication more accessible.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO dacs_authenticate&hellip;</h2>
        <div class="sectioncontent">
<p>\m[blue]<a href="../man1/dacsauth.1.html"><strong>dacsauth</strong>(1)</a></strong>\m[]\s-2\u[6]\d\s+2, \m[blue]<a href="../man1/dacscred.1.html"><strong>dacscred</strong>(1)</a></strong>\m[]\s-2\u[153]\d\s+2, \m[blue]<a href="../man1/dacscookie.1.html"><strong>dacscookie</strong>(1)</a></strong>\m[]\s-2\u[9]\d\s+2, \m[blue]<a href="../man5/dacs.exprs.5.html"><strong>dacs.exprs</strong>(5)</a></strong>\m[]\s-2\u[3]\d\s+2, \m[blue]<a href="../man8/dacs_autologin_ssl.8.html"><strong>dacs_autologin_ssl</strong>(8)</a></strong>\m[]\s-2\u[154]\d\s+2, \m[blue]<a href="../man8/autologin.8.html"><strong>autologin</strong>(8)</a></strong>\m[]\s-2\u[122]\d\s+2, \m[blue]<a href="../man8/dacs_auth_agent.8.html"><strong>dacs_auth_agent</strong>(8)</a></strong>\m[]\s-2\u[7]\d\s+2, \m[blue]<a href="../man8/dacs_auth_transfer.8.html"><strong>dacs_auth_transfer</strong>(8)</a></strong>\m[]\s-2\u[8]\d\s+2, \m[blue]<a href="../man8/dacs_current_credentials.8.html"><strong>dacs_current_credentials</strong>(8)</a></strong>\m[]\s-2\u[33]\d\s+2, \m[blue]<a href="../man8/dacs_select_credentials.8.html"><strong>dacs_select_credentials</strong>(8)</a></strong>\m[]\s-2\u[41]\d\s+2, \m[blue]<a href="../man8/dacs_signout.8.html"><strong>dacs_signout</strong>(8)</a></strong>\m[]\s-2\u[152]\d\s+2, \m[blue]<a href="../man8/pamd.8.html"><strong>pamd</strong>(8)</a></strong>\m[]\s-2\u[136]\d\s+2</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Distributed Systems Software (\m[blue]<strong>www.dss.ca</strong>\m[]\s-2\u[155]\d\s+2)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYING</h2>
        <div class="sectioncontent">
<p>Copyright2003-2013 Distributed Systems Software. See the \m[blue]<strong>LICENSE</strong>\m[]\s-2\u[156]\d\s+2 file that accompanies the distribution for licensing information.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTES</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
     1.
  </dt>
  <dd>
    <p>dacsoptions</p><p>http://dacs.dss.ca/man/dacs.1.html#dacsoptions</p>
  </dd>
  <dt>
     2.
  </dt>
  <dd>
    <p><strong>dacs.conf</strong>(5)</p><p>http://dacs.dss.ca/man/dacs.conf.5.html</p>
  </dd>
  <dt>
     3.
  </dt>
  <dd>
    <p><a href="../man5/dacs.exprs.5.html"><strong>dacs.exprs</strong>(5)</a></p><p>http://dacs.dss.ca/man/dacs.exprs.5.html</p>
  </dd>
  <dt>
     4.
  </dt>
  <dd>
    <p>html/examples</p><p>http://dacs.dss.ca/man//examples</p>
  </dd>
  <dt>
     5.
  </dt>
  <dd>
    <p>HTTP Authentication</p><p>http://dacs.dss.ca/man/dacs_acs.8.html#http_authentication</p>
  </dd>
  <dt>
     6.
  </dt>
  <dd>
    <p><a href="../man1/dacsauth.1.html"><strong>dacsauth</strong>(1)</a></p><p>http://dacs.dss.ca/man/dacsauth.1.html</p>
  </dd>
  <dt>
     7.
  </dt>
  <dd>
    <p><a href="../man8/dacs_auth_agent.8.html"><strong>dacs_auth_agent</strong>(8)</a></p><p>http://dacs.dss.ca/man/dacs_auth_agent.8.html</p>
  </dd>
  <dt>
     8.
  </dt>
  <dd>
    <p><a href="../man8/dacs_auth_transfer.8.html"><strong>dacs_auth_transfer</strong>(8)</a></p><p>http://dacs.dss.ca/man/dacs_auth_transfer.8.html</p>
  </dd>
  <dt>
     9.
  </dt>
  <dd>
    <p><a href="../man1/dacscookie.1.html"><strong>dacscookie</strong>(1)</a></p><p>http://dacs.dss.ca/man/dacscookie.1.html</p>
  </dd>
  <dt>
    10.
  </dt>
  <dd>
    <p>Auth clause</p><p>http://dacs.dss.ca/man/#auth_clause</p>
  </dd>
  <dt>
    11.
  </dt>
  <dd>
    <p>CONTROL</p><p>http://dacs.dss.ca/man/#CONTROL</p>
  </dd>
  <dt>
    12.
  </dt>
  <dd>
    <p>username</p><p>http://dacs.dss.ca/man/dacs.1.html#dacs_identity</p>
  </dd>
  <dt>
    13.
  </dt>
  <dd>
    <p><a href="../man5/dacs.acls.5.html"><strong>dacs.acls</strong>(5)</a></p><p>http://dacs.dss.ca/man/dacs.acls.5.html#revocation_list</p>
  </dd>
  <dt>
    14.
  </dt>
  <dd>
    <p><a href="../man1/dacs.1.html"><strong>dacs</strong>(1)</a></p><p>http://dacs.dss.ca/man/dacs.1.html#naming</p>
  </dd>
  <dt>
    15.
  </dt>
  <dd>
    <p>credentials.dtd</p><p>http://dacs.dss.ca/man/../dtd-xsd/credentials.dtd</p>
  </dd>
  <dt>
    16.
  </dt>
  <dd>
    <p>VERIFY_IP</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#VERIFY_IP</p>
  </dd>
  <dt>
    17.
  </dt>
  <dd>
    <p><strong>natd</strong>(8)</p><p>http://www.freebsd.org/cgi/man.cgi?query=natd&apropos=0&sektion=8&manpath=FreeBSD+9.1-RELEASE&format=html</p>
  </dd>
  <dt>
    18.
  </dt>
  <dd>
    <p>VERIFY_UA</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#VERIFY_UA</p>
  </dd>
  <dt>
    19.
  </dt>
  <dd>
    <p>AUTH_CREDENTIALS_DEFAULT_LIFETIME_SECS</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#AUTH_CREDENTIALS_DEFAULT_LIFETIME_SECS</p>
  </dd>
  <dt>
    20.
  </dt>
  <dd>
    <p>Advanced Encryption Standard</p><p>http://csrc.nist.gov/encryption/aes/aes_home.htm</p>
  </dd>
  <dt>
    21.
  </dt>
  <dd>
    <p>Federal Information Processing Standard</p><p>http://www.nist.gov/public_affairs/releases/g01-111.htm</p>
  </dd>
  <dt>
    22.
  </dt>
  <dd>
    <p>FIPS 198</p><p>http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf</p>
  </dd>
  <dt>
    23.
  </dt>
  <dd>
    <p>RFC 2104</p><p>http://www.rfc-editor.org/rfc/rfc2104.txt</p>
  </dd>
  <dt>
    24.
  </dt>
  <dd>
    <p>RFC 4635</p><p>http://www.rfc-editor.org/rfc/rfc4635.txt</p>
  </dd>
  <dt>
    25.
  </dt>
  <dd>
    <p>RFC 4868</p><p>http://www.rfc-editor.org/rfc/rfc4868.txt</p>
  </dd>
  <dt>
    26.
  </dt>
  <dd>
    <p>NIST</p><p>http://www.nist.gov/</p>
  </dd>
  <dt>
    27.
  </dt>
  <dd>
    <p>FIPS 180-1</p><p>http://www.itl.nist.gov/fipspubs/fip180-1.htm</p>
  </dd>
  <dt>
    28.
  </dt>
  <dd>
    <p>RFC 4634</p><p>http://www.rfc-editor.org/rfc/rfc4634.txt</p>
  </dd>
  <dt>
    29.
  </dt>
  <dd>
    <p>FIPS 180-3</p><p>http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf</p>
  </dd>
  <dt>
    30.
  </dt>
  <dd>
    <p>MD5 algorithm</p><p>http://www.rfc-editor.org/rfc/rfc1321.txt</p>
  </dd>
  <dt>
    31.
  </dt>
  <dd>
    <p>Netscape HTTP Cookies Specification</p><p>http://web.archive.org/web/20070805052634/http://wp.netscape.com/newsref/std/cookie_spec.html</p>
  </dd>
  <dt>
    32.
  </dt>
  <dd>
    <p><em>COOKIE_SYNTAX</em></p><p>http://dacs.dss.ca/man/#COOKIE_SYNTAX</p>
  </dd>
  <dt>
    33.
  </dt>
  <dd>
    <p><a href="../man8/dacs_current_credentials.8.html"><strong>dacs_current_credentials</strong>(8)</a></p><p>http://dacs.dss.ca/man/dacs_current_credentials.8.html</p>
  </dd>
  <dt>
    34.
  </dt>
  <dd>
    <p>COOKIE_PATH</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#COOKIE_PATH</p>
  </dd>
  <dt>
    35.
  </dt>
  <dd>
    <p>SECURE_MODE</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#SECURE_MODE</p>
  </dd>
  <dt>
    36.
  </dt>
  <dd>
    <p>standard CGI arguments</p><p>http://dacs.dss.ca/man/dacs.services.8.html#standard_cgi_args</p>
  </dd>
  <dt>
    37.
  </dt>
  <dd>
    <p>local_pam_authenticate</p><p>http://dacs.dss.ca/man/#local_pam_authenticate</p>
  </dd>
  <dt>
    38.
  </dt>
  <dd>
    <p>RFC 2109</p><p>http://www.rfc-editor.org/rfc/rfc2109.txt</p>
  </dd>
  <dt>
    39.
  </dt>
  <dd>
    <p>RFC 2965</p><p>http://www.rfc-editor.org/rfc/rfc2965.txt</p>
  </dd>
  <dt>
    40.
  </dt>
  <dd>
    <p><a href="../man8/dacs_acs.8.html"><strong>dacs_acs</strong>(8)</a></p><p>http://dacs.dss.ca/man/dacs_acs.8.html</p>
  </dd>
  <dt>
    41.
  </dt>
  <dd>
    <p><a href="../man8/dacs_select_credentials.8.html"><strong>dacs_select_credentials</strong>(8)</a></p><p>http://dacs.dss.ca/man/dacs_select_credentials.8.html</p>
  </dd>
  <dt>
    42.
  </dt>
  <dd>
    <p><strong>strtr()</strong></p><p>http://dacs.dss.ca/man/dacs.exprs.5.html#strtr</p>
  </dd>
  <dt>
    43.
  </dt>
  <dd>
    <p>LDAP_USERNAME_URL</p><p>http://dacs.dss.ca/man/#LDAP_USERNAME_URL</p>
  </dd>
  <dt>
    44.
  </dt>
  <dd>
    <p>local_ldap_authenticate</p><p>http://dacs.dss.ca/man/#local_ldap_authenticate</p>
  </dd>
  <dt>
    45.
  </dt>
  <dd>
    <p>OPTION</p><p>http://dacs.dss.ca/man/#OPTION</p>
  </dd>
  <dt>
    46.
  </dt>
  <dd>
    <p><strong>dacs.conf</strong>(5)</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#auth_clause</p>
  </dd>
  <dt>
    47.
  </dt>
  <dd>
    <p><a href="../man3/pam.3.html"><strong>pam</strong>(3)</a></p><p>http://www.freebsd.org/cgi/man.cgi?query=pam&apropos=0&sektion=0&manpath=FreeBSD+9.1-RELEASE&format=html</p>
  </dd>
  <dt>
    48.
  </dt>
  <dd>
    <p>X/Open Single Sign-On Service (XSSO) preliminary specification</p><p>http://www.opengroup.org/pubs/catalog/p702.htm</p>
  </dd>
  <dt>
    49.
  </dt>
  <dd>
    <p><strong>dacs.conf</strong>(5)</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#merging</p>
  </dd>
  <dt>
    50.
  </dt>
  <dd>
    <p>Authenticating Using an Expression</p><p>http://dacs.dss.ca/man/#expr</p>
  </dd>
  <dt>
    51.
  </dt>
  <dd>
    <p>PASSWORD_CONSTRAINTS</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#PASSWORD_CONSTRAINTS</p>
  </dd>
  <dt>
    52.
  </dt>
  <dd>
    <p>LOG_FILTER</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#LOG_FILTER</p>
  </dd>
  <dt>
    53.
  </dt>
  <dd>
    <p>local_cas_authenticate</p><p>http://dacs.dss.ca/man/#local_cas_authenticate</p>
  </dd>
  <dt>
    54.
  </dt>
  <dd>
    <p>Central Authentication Service (CAS)</p><p>http://www.ja-sig.org/products/cas/index.html</p>
  </dd>
  <dt>
    55.
  </dt>
  <dd>
    <p>RFC 2617</p><p>http://www.rfc-editor.org/rfc/rfc2617.txt</p>
  </dd>
  <dt>
    56.
  </dt>
  <dd>
    <p>local_apache_authenticate</p><p>http://dacs.dss.ca/man/#local_apache_authenticate</p>
  </dd>
  <dt>
    57.
  </dt>
  <dd>
    <p>Information Card</p><p>http://en.wikipedia.org/wiki/Information_Card</p>
  </dd>
  <dt>
    58.
  </dt>
  <dd>
    <p><a href="../man1/dacsinfocard.1.html"><strong>dacsinfocard</strong>(1)</a></p><p>http://dacs.dss.ca/man/dacsinfocard.1.html</p>
  </dd>
  <dt>
    59.
  </dt>
  <dd>
    <p><a href="../man8/dacs_infocard.8.html"><strong>dacs_infocard</strong>(8)</a></p><p>http://dacs.dss.ca/man/dacs_infocard.8.html</p>
  </dd>
  <dt>
    60.
  </dt>
  <dd>
    <p><a href="../man8/dacs_managed_infocard.8.html"><strong>dacs_managed_infocard</strong>(8)</a></p><p>http://dacs.dss.ca/man/dacs_managed_infocard.8.html</p>
  </dd>
  <dt>
    61.
  </dt>
  <dd>
    <p>local_infocard_authenticate</p><p>http://dacs.dss.ca/man/#local_infocard_authenticate</p>
  </dd>
  <dt>
    62.
  </dt>
  <dd>
    <p>local_simple_authenticate</p><p>http://dacs.dss.ca/man/#local_simple_authenticate</p>
  </dd>
  <dt>
    63.
  </dt>
  <dd>
    <p>add_roles</p><p>http://dacs.dss.ca/man/#add_roles</p>
  </dd>
  <dt>
    64.
  </dt>
  <dd>
    <p>set_roles</p><p>http://dacs.dss.ca/man/#set_roles</p>
  </dd>
  <dt>
    65.
  </dt>
  <dd>
    <p><a href="../man5/dacs.exprs.5.html"><strong>dacs.exprs</strong>(5)</a></p><p>http://dacs.dss.ca/man/dacs.exprs.5.html#variables</p>
  </dd>
  <dt>
    66.
  </dt>
  <dd>
    <p>AUTH_SUCCESS</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#AUTH_SUCCESS</p>
  </dd>
  <dt>
    67.
  </dt>
  <dd>
    <p>AUTH_SUCCESS_HANDLER</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#AUTH_SUCCESS_HANDLER</p>
  </dd>
  <dt>
    68.
  </dt>
  <dd>
    <p>AUTH_ERROR_HANDLER</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#AUTH_ERROR_HANDLER</p>
  </dd>
  <dt>
    69.
  </dt>
  <dd>
    <p>AUTH_FAIL_DELAY_SECS</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#AUTH_FAIL_DELAY_SECS</p>
  </dd>
  <dt>
    70.
  </dt>
  <dd>
    <p><em>DACS_AUTH_SUCCESS_HANDLER</em></p><p>http://dacs.dss.ca/man/#DACS_AUTH_SUCCESS_HANDLER</p>
  </dd>
  <dt>
    71.
  </dt>
  <dd>
    <p><em>ENABLE_AUTH_HANDLERS</em></p><p>http://dacs.dss.ca/man/#ENABLE_AUTH_HANDLERS</p>
  </dd>
  <dt>
    72.
  </dt>
  <dd>
    <p><a href="../man8/dacs_prenv.8.html"><strong>dacs_prenv</strong>(8)</a></p><p>http://dacs.dss.ca/man/dacs_prenv.8.html</p>
  </dd>
  <dt>
    73.
  </dt>
  <dd>
    <p>Environment variables</p><p>http://httpd.apache.org/docs-2.2/mod/mod_ssl.html#envvars</p>
  </dd>
  <dt>
    74.
  </dt>
  <dd>
    <p>mod_ssl</p><p>http://httpd.apache.org/docs-2.2/mod/mod_ssl.html</p>
  </dd>
  <dt>
    75.
  </dt>
  <dd>
    <p><a href="../man8/dacs.services.8.html"><strong>dacs.services</strong>(8)</a></p><p>http://dacs.dss.ca/man/dacs.services.8.html#FORMAT</p>
  </dd>
  <dt>
    76.
  </dt>
  <dd>
    <p>dacs_auth_reply.dtd</p><p>http://dacs.dss.ca/man/../dtd-xsd/dacs_auth_reply.dtd</p>
  </dd>
  <dt>
    77.
  </dt>
  <dd>
    <p>dacs_current_credentials.dtd</p><p>http://dacs.dss.ca/man/../dtd-xsd/dacs_current_credentials.dtd</p>
  </dd>
  <dt>
    78.
  </dt>
  <dd>
    <p>auth_reply.dtd</p><p>http://dacs.dss.ca/man/../dtd-xsd/auth_reply.dtd</p>
  </dd>
  <dt>
    79.
  </dt>
  <dd>
    <p><a href="../man7/dacs.install.7.html"><strong>dacs.install</strong>(7)</a></p><p>http://dacs.dss.ca/man//man/dacs.install.7.html</p>
  </dd>
  <dt>
    80.
  </dt>
  <dd>
    <p><strong>mod_auth</strong></p><p>http://httpd.apache.org/docs-2.2/mod/mod_auth.html</p>
  </dd>
  <dt>
    81.
  </dt>
  <dd>
    <p><strong>mod_auth_digest</strong></p><p>http://httpd.apache.org/docs-2.2/mod/mod_auth_digest.html</p>
  </dd>
  <dt>
    82.
  </dt>
  <dd>
    <p><strong>mod_auth_dbm</strong></p><p>http://httpd.apache.org/docs-2.2/mod/mod_auth_dbm.html</p>
  </dd>
  <dt>
    83.
  </dt>
  <dd>
    <p><a href="../man1/htpasswd.1.html"><strong>htpasswd</strong>(1)</a></p><p>http://httpd.apache.org/docs/2.2/programs/htpasswd.html</p>
  </dd>
  <dt>
    84.
  </dt>
  <dd>
    <p><a href="../man1/htdigest.1.html"><strong>htdigest</strong>(1)</a></p><p>http://httpd.apache.org/docs/2.2/programs/htdigest.html</p>
  </dd>
  <dt>
    85.
  </dt>
  <dd>
    <p><a href="../man1/htdbm.1.html"><strong>htdbm</strong>(1)</a></p><p>http://httpd.apache.org/docs/2.2/programs/htdbm.html</p>
  </dd>
  <dt>
    86.
  </dt>
  <dd>
    <p>local_native_authenticate</p><p>http://dacs.dss.ca/man/#local_native_authenticate</p>
  </dd>
  <dt>
    87.
  </dt>
  <dd>
    <p>CAS 2.0 Protocol</p><p>http://www.ja-sig.org/products/cas/overview/protocol/index.html</p>
  </dd>
  <dt>
    88.
  </dt>
  <dd>
    <p>OpenID</p><p>http://openid.net/</p>
  </dd>
  <dt>
    89.
  </dt>
  <dd>
    <p>STYLE</p><p>http://dacs.dss.ca/man/#STYLE</p>
  </dd>
  <dt>
    90.
  </dt>
  <dd>
    <p>SSLVerifyClient</p><p>http://httpd.apache.org/docs-2.2/mod/mod_ssl.html#sslverifyclient</p>
  </dd>
  <dt>
    91.
  </dt>
  <dd>
    <p>SSLRequire</p><p>http://httpd.apache.org/docs-2.2/mod/mod_ssl.html#sslrequire</p>
  </dd>
  <dt>
    92.
  </dt>
  <dd>
    <p>OpenSSL</p><p>http://www.openssl.org</p>
  </dd>
  <dt>
    93.
  </dt>
  <dd>
    <p>SSLOptions</p><p>http://httpd.apache.org/docs-2.2/mod/mod_ssl.html#ssloptions</p>
  </dd>
  <dt>
    94.
  </dt>
  <dd>
    <p><a href="../man1/dacsgrid.1.html"><strong>dacsgrid</strong>(1)</a></p><p>http://dacs.dss.ca/man/dacsgrid.1.html</p>
  </dd>
  <dt>
    95.
  </dt>
  <dd>
    <p>RFC 2616</p><p>http://www.rfc-editor.org/rfc/rfc2616.txt</p>
  </dd>
  <dt>
    96.
  </dt>
  <dd>
    <p>Google</p><p>http://www.google.com</p>
  </dd>
  <dt>
    97.
  </dt>
  <dd>
    <p>account authentication</p><p>http://code.google.com/apis/accounts/AuthForInstalledApps.html</p>
  </dd>
  <dt>
    98.
  </dt>
  <dd>
    <p>eBay</p><p>http://developer.ebay.com/developercenter/rest/</p>
  </dd>
  <dt>
    99.
  </dt>
  <dd>
    <p>Yahoo!</p><p>http://developer.yahoo.com/auth/</p>
  </dd>
  <dt>
    00.
  </dt>
  <dd>
    <p>Identity Selector Interoperability Profile (ISIP) 1.5</p><p>http://download.microsoft.com/download/1/1/a/11ac6505-e4c0-4e05-987c-6f1d31855cd2/Identity_Selector_Interoperability_Profile_V1.5.pdf</p>
  </dd>
  <dt>
    01.
  </dt>
  <dd>
    <p>role descriptor string</p><p>http://dacs.dss.ca/man/dacs.1.html#roles</p>
  </dd>
  <dt>
    02.
  </dt>
  <dd>
    <p><a href="../man8/dacs_infocard.8.html"><strong>dacs_infocard</strong>(8)</a></p><p>http://dacs.dss.ca/man/dacs_infocard.8.html#about_claims</p>
  </dd>
  <dt>
    03.
  </dt>
  <dd>
    <p>expression-based authentication style</p><p>http://dacs.dss.ca/man//man/dacs_authenticate.8.html#expr</p>
  </dd>
  <dt>
    04.
  </dt>
  <dd>
    <p><a href="../man8/dacs_managed_infocard.8.html"><strong>dacs_managed_infocard</strong>(8)</a></p><p>http://dacs.dss.ca/man//man/dacs_managed_infocard.8.html</p>
  </dd>
  <dt>
    05.
  </dt>
  <dd>
    <p><strong>dacs.conf</strong>(5)</p><p>http://dacs.dss.ca/man//man/dacs.conf.5.html#INFOCARD_prefixed</p>
  </dd>
  <dt>
    06.
  </dt>
  <dd>
    <p><a href="../man8/dacs_mex.8.html"><strong>dacs_mex</strong>(8)</a></p><p>http://dacs.dss.ca/man//man/dacs_mex.8.html</p>
  </dd>
  <dt>
    07.
  </dt>
  <dd>
    <p><a href="../man8/dacs_sts.8.html"><strong>dacs_sts</strong>(8)</a></p><p>http://dacs.dss.ca/man//man/dacs_sts.8.html</p>
  </dd>
  <dt>
    08.
  </dt>
  <dd>
    <p>Using InfoCards With DACS</p><p>http://dacs.dss.ca/man/using-infocards-with-dacs.html</p>
  </dd>
  <dt>
    09.
  </dt>
  <dd>
    <p><em>Identity Selector Interoperability Profile specification and companion guides</em></p><p>http://www.microsoft.com/downloads/details.aspx?FamilyID=b94817fc-3991-4dd0-8e85-b73e626f6764&DisplayLang=en</p>
  </dd>
  <dt>
    10.
  </dt>
  <dd>
    <p><em>Introducing Windows CardSpace</em></p><p>http://msdn.microsoft.com/en-us/library/aa480189.aspx</p>
  </dd>
  <dt>
    11.
  </dt>
  <dd>
    <p>RFC 2251</p><p>http://www.faqs.org/rfcs/rfc2251.html</p>
  </dd>
  <dt>
    12.
  </dt>
  <dd>
    <p>RFC 2252</p><p>http://www.faqs.org/rfcs/rfc2252.html</p>
  </dd>
  <dt>
    13.
  </dt>
  <dd>
    <p>RFC 2253</p><p>http://www.faqs.org/rfcs/rfc2253.html</p>
  </dd>
  <dt>
    14.
  </dt>
  <dd>
    <p>RFC 3377</p><p>http://www.faqs.org/rfcs/rfc3377.html</p>
  </dd>
  <dt>
    15.
  </dt>
  <dd>
    <p>Active Directory (ADS)</p><p>http://www.microsoft.com/windows2000/technologies/directory/ad/default.asp</p>
  </dd>
  <dt>
    16.
  </dt>
  <dd>
    <p>OpenLDAP</p><p>http://www.openldap.org</p>
  </dd>
  <dt>
    17.
  </dt>
  <dd>
    <p>ldap()</p><p>http://dacs.dss.ca/man/dacs.exprs.5.html#ldap</p>
  </dd>
  <dt>
    18.
  </dt>
  <dd>
    <p>LDAP_USERNAME_URL*</p><p>http://dacs.dss.ca/man/#LDAP_USERNAME_URL*</p>
  </dd>
  <dt>
    19.
  </dt>
  <dd>
    <p>RFC 2396</p><p>http://www.faqs.org/rfcs/rfc2396.html</p>
  </dd>
  <dt>
    20.
  </dt>
  <dd>
    <p>RFC 3986</p><p>http://www.rfc-editor.org/rfc/rfc3986.txt</p>
  </dd>
  <dt>
    21.
  </dt>
  <dd>
    <p><a href="../man1/ldapsearch.1.html"><strong>ldapsearch</strong>(1)</a></p><p>http://www.openldap.org/software/man.cgi?query=ldapsearch&apropos=0&sektion=0&manpath=OpenLDAP+2.4-Release&format=html</p>
  </dd>
  <dt>
    22.
  </dt>
  <dd>
    <p><a href="../man8/autologin.8.html"><strong>autologin</strong>(8)</a></p><p>http://dacs.dss.ca/man/autologin.8.html</p>
  </dd>
  <dt>
    23.
  </dt>
  <dd>
    <p>1</p><p>http://curl.haxx.se/rfc/ntlm.html</p>
  </dd>
  <dt>
    24.
  </dt>
  <dd>
    <p>2</p><p>http://msdn.microsoft.com/en-us/library/cc236621%28PROT.10%29.aspx</p>
  </dd>
  <dt>
    25.
  </dt>
  <dd>
    <p>Samba</p><p>http://www.samba.org</p>
  </dd>
  <dt>
    26.
  </dt>
  <dd>
    <p>NTLM authentication</p><p>http://davenport.sourceforge.net/ntlm.html</p>
  </dd>
  <dt>
    27.
  </dt>
  <dd>
    <p>have been identified</p><p>http://support.microsoft.com/kb/2793313</p>
  </dd>
  <dt>
    28.
  </dt>
  <dd>
    <p><a href="../man1/smbclient.1.html"><strong>smbclient</strong>(1)</a></p><p>http://us2.samba.org/samba/docs/man/manpages-3/smbclient.1.html</p>
  </dd>
  <dt>
    29.
  </dt>
  <dd>
    <p><a href="../man1/dacs.1.html"><strong>dacs</strong>(1)</a></p><p>http://dacs.dss.ca/man/dacs.1.html</p>
  </dd>
  <dt>
    30.
  </dt>
  <dd>
    <p><a href="../man3/pam_start.3.html"><strong>pam_start</strong>(3)</a></p><p>http://www.freebsd.org/cgi/man.cgi?query=pam_start&apropos=0&sektion=3&manpath=FreeBSD+9.1-RELEASE&format=html</p>
  </dd>
  <dt>
    31.
  </dt>
  <dd>
    <p>GNU/Linux</p><p>http://www.kernel.org/pub/linux/libs/pam/modules.html</p>
  </dd>
  <dt>
    32.
  </dt>
  <dd>
    <p>FreeBSD</p><p>http://www.freebsd.org/doc/en_US.ISO8859-1/articles/pam/pam-freebsd-modules.html</p>
  </dd>
  <dt>
    33.
  </dt>
  <dd>
    <p>Solaris</p><p>http://www.sun.com/software/solaris/pam/</p>
  </dd>
  <dt>
    34.
  </dt>
  <dd>
    <p><a href="../man8/pam_unix.8.html"><strong>pam_unix</strong>(8)</a></p><p>http://www.freebsd.org/cgi/man.cgi?query=pam_unix&apropos=0&sektion=8&manpath=FreeBSD+9.1-RELEASE&format=html</p>
  </dd>
  <dt>
    35.
  </dt>
  <dd>
    <p>local_unix_authenticate</p><p>http://dacs.dss.ca/man/#local_unix_authenticate</p>
  </dd>
  <dt>
    36.
  </dt>
  <dd>
    <p><a href="../man8/pamd.8.html"><strong>pamd</strong>(8)</a></p><p>http://dacs.dss.ca/man/pamd.8.html</p>
  </dd>
  <dt>
    37.
  </dt>
  <dd>
    <p>dacs_url</p><p>http://dacs.dss.ca/man/dacs.groups.5.html#group_syntax</p>
  </dd>
  <dt>
    38.
  </dt>
  <dd>
    <p>local_pam_authenticate.css</p><p>http://dacs.dss.ca/man//css/local_pam_authenticate.css</p>
  </dd>
  <dt>
    39.
  </dt>
  <dd>
    <p>PASSWORD_DIGEST</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#PASSWORD_DIGEST</p>
  </dd>
  <dt>
    40.
  </dt>
  <dd>
    <p><a href="../man1/dacspasswd.1.html"><strong>dacspasswd</strong>(1)</a></p><p>http://dacs.dss.ca/man/dacspasswd.1.html</p>
  </dd>
  <dt>
    41.
  </dt>
  <dd>
    <p><a href="../man1/dacstoken.1.html"><strong>dacstoken</strong>(1)</a></p><p>http://dacs.dss.ca/man/dacstoken.1.html</p>
  </dd>
  <dt>
    42.
  </dt>
  <dd>
    <p>RFC 4226</p><p>http://www.rfc-editor.org/rfc/rfc4226.txt</p>
  </dd>
  <dt>
    43.
  </dt>
  <dd>
    <p>OATH</p><p>http://www.openauthentication.org</p>
  </dd>
  <dt>
    44.
  </dt>
  <dd>
    <p><a href="../man3/getpwnam.3.html"><strong>getpwnam</strong>(3)</a></p><p>http://www.freebsd.org/cgi/man.cgi?query=getpwnam&apropos=0&sektion=3&manpath=FreeBSD+9.1-RELEASE&format=html</p>
  </dd>
  <dt>
    45.
  </dt>
  <dd>
    <p>yp(8)</p><p>http://www.freebsd.org/cgi/man.cgi?query=yp&apropos=0&sektion=8&manpath=FreeBSD+9.1-RELEASE&format=html</p>
  </dd>
  <dt>
    46.
  </dt>
  <dd>
    <p><a href="../man5/dacs.groups.5.html"><strong>dacs.groups</strong>(5)</a></p><p>http://dacs.dss.ca/man/dacs.groups.5.html</p>
  </dd>
  <dt>
    47.
  </dt>
  <dd>
    <p>roles_reply.dtd</p><p>http://dacs.dss.ca/man/../dtd-xsd/roles_reply.dtd</p>
  </dd>
  <dt>
    48.
  </dt>
  <dd>
    <p>ROLE_STRING_MAX_LENGTH</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#ROLE_STRING_MAX_LENGTH</p>
  </dd>
  <dt>
    49.
  </dt>
  <dd>
    <p>OPTION directive</p><p>http://dacs.dss.ca/man/#r_OPTION</p>
  </dd>
  <dt>
    50.
  </dt>
  <dd>
    <p>OPTION* directive</p><p>http://dacs.dss.ca/man/#r_OPTION*</p>
  </dd>
  <dt>
    51.
  </dt>
  <dd>
    <p><a href="../man1/groups.1.html"><strong>groups</strong>(1)</a></p><p>http://www.freebsd.org/cgi/man.cgi?query=groups&apropos=0&sektion=1&manpath=FreeBSD+9.1-RELEASE&format=html</p>
  </dd>
  <dt>
    52.
  </dt>
  <dd>
    <p><a href="../man8/dacs_signout.8.html"><strong>dacs_signout</strong>(8)</a></p><p>http://dacs.dss.ca/man/dacs_signout.8.html</p>
  </dd>
  <dt>
    53.
  </dt>
  <dd>
    <p><a href="../man1/dacscred.1.html"><strong>dacscred</strong>(1)</a></p><p>http://dacs.dss.ca/man/dacscred.1.html</p>
  </dd>
  <dt>
    54.
  </dt>
  <dd>
    <p><a href="../man8/dacs_autologin_ssl.8.html"><strong>dacs_autologin_ssl</strong>(8)</a></p><p>http://dacs.dss.ca/man/dacs_autologin_ssl.8.html</p>
  </dd>
  <dt>
    55.
  </dt>
  <dd>
    <p>www.dss.ca</p><p>http://www.dss.ca</p>
  </dd>
  <dt>
    56.
  </dt>
  <dd>
    <p>LICENSE</p><p>http://dacs.dss.ca/man/../misc/LICENSE</p>
  </dd>

</dl>

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="dacs_auth_transfer.8.html"><span aria-hidden="true">&larr;</span> dacs_auth_transfer.8: Transfer credentials between federations</a></li>
   <li class="next"><a href="dacs_autologin_ssl.8.html">dacs_autologin_ssl.8: Use an ssl client certificate to automatically obtain dacs credentials <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

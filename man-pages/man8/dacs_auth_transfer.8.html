<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>dacs_auth_transfer: Transfer credentials between federations</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Transfer credentials between federations">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="dacs_auth_transfer (8) manual">
  <meta name="twitter:description" content="Transfer credentials between federations">
  <meta name="twitter:image" content="https://www.carta.tech/images/dacs-dacs_auth_transfer-8.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man8/dacs_auth_transfer.8.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="dacs_auth_transfer (8) manual" />
  <meta property="og:description" content="Transfer credentials between federations" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/dacs-dacs_auth_transfer-8.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">dacs_auth_transfer<small> (8)</small></h1>
        <p class="lead">Transfer credentials between federations</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man8/">
      <span itemprop="name">System administration commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man8/dacs_auth_transfer.8.html">
      <span itemprop="name">dacs_auth_transfer: Transfer credentials between federations</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/dacs/">
      <span itemprop="name">dacs</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man8/dacs_auth_transfer.8.html">
      <span itemprop="name">dacs_auth_transfer: Transfer credentials between federations</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>dacs_auth_transfer</strong> [<em>\m[blue]</em><strong>dacsoptions</strong>\m[]\s-2\u[1]\d\s+2]</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This web service is part of the <strong>DACS</strong> suite.</p><p>The <strong>dacs_auth_transfer</strong> service securely exports credentials (which represent an identity) from one <strong>DACS</strong> federation to another (or from <strong>DACS</strong> to a different identity management system), or securely imports an identity from one <strong>DACS</strong> federation to another (or from a different identity management system to <strong>DACS</strong>). This ability to <em>transfer</em> credentials (i.e., import or export them) lets a <strong>DACS</strong> federation federate with another system, creating a "super federation" with single sign-on capability. <strong>DACS</strong> calls such federations affiliated federations.</p><p>A <strong>DACS</strong> federation can use <strong>dacs_auth_transfer</strong> to leverage authentication mechanisms not available to it, other systems can use it to leverage <strong>DACS</strong>, and users can potentially access any access-controlled resource located in any of the cooperating federations.</p><p><strong>In a Nutshell</strong></p><p>For two <strong>DACS</strong> federations, here is how the service is typically used. A user authenticates somewhere in Federation A, obtaining credentials understood only in that federation. One or more jurisdictions in Federation A will provide a link labelled "Transfer Login To Federation B" (or similar). Alternatively, or additionally, one or more jurisdictions in Federation B may provide a link labelled "Transfer Login From Federation A". Later, when the user decides to access resources in Federation B, he follows one of the links. Assuming all access control constraints are satisfied, new credentials will be returned to him that are understood in Federation B. His existing Federation A credentials continue to exist.</p><p>The user is now recognized by both federations. If the user is known as FedA::J1:bobo in Federation A, then he will also be known by that name in Federation B. If Federation B happens to have a jurisdiction named J1 and a user at that jurisdiction named bobo, that user (FedB::J1:bobo) is separate and distinct as far as <strong>DACS</strong> is concerned.</p><p>Note that, in general, it is not correct in the scenario above for Federation B to automatically initiate a credential transfer if an unauthenticated user (with respect to Federation B) is denied access. This is because Federation B cannot tell with which federation it should be initiated (if there is more than one) or even if this is something that the user wants done (perhaps the user needs to authenticate in the usual way at Federation A). Therefore, except perhaps in special circumstances, explicit user interaction is necessary.</p><p>For <strong>DACS</strong>, the complete protocol is implemented by one program, <strong>dacs_auth_transfer</strong>. It provides the importing, exporting, and server-to-server stages of the protocol and it can also optionally assist middleware with the initial presentation stage of the protocol. The protocol is described below.</p><p>If an identity needs to be imported to a non-<strong>DACS</strong> system, that system must implement the identity transfer protocol described here, or a subset of it. If a non-<strong>DACS</strong> only needs to export an identity to a <strong>DACS</strong> federation, it may only need a small amount of middleware to initiate the transfer.</p><p><strong>Security</strong></p><p>A small degree of cooperation is required between <strong>DACS</strong> administrators at two affiliated federations so that they each know how to configure the feature. The two federations remain autonomous, however.</p><p>Transferring credentials <em>to</em> a <strong>DACS</strong> federation neither creates a new account nor creates a new identity. It merely converts credentials that were obtained in one federation into <strong>DACS</strong> credentials that are recognized within another federation. Because a <strong>DACS</strong> user identity includes a federation name, among federated <strong>DACS</strong> systems a user&apos;s identity is unique. After transfer to a different federation, the original credentials continue to exist and are unaltered.</p><p>Exporting credentials to another federation and later transferring them back to the initial <strong>DACS</strong> federation (or exporting credentials within a federation) will replace the initial credentials with new ones for the same identity. The two sets of credentials will not be identical, however, and the imported ones may be less complete and therefore "weaker" than the original credentials with respect to authorization processing.</p><p>System administrators should ensure that <strong>dacs_auth_transfer</strong> is configured so that it is impossible to import credentials to a federation from which they were exported, otherwise it may be possible for users to defeat the expiry of credentials by repeatedly regenerating them.</p><p>The identity transfer protocol includes a server-to-server operation that must use SSL. The identity of the server issuing the request must be verified, either through its X.509 (SSL) client certificate, <strong>DACS</strong> credentials, or perhaps its IP address.</p><p>As an additional security measure, a jurisdiction will only accept credentials for an identity outside of its federation if enabled by \m[blue]<strong>ACCEPT_ALIEN_CREDENTIALS</strong>\m[]\s-2\u[2]\d\s+2.</p><p>While this document talks in terms of a <strong>DACS</strong><em>federation</em> importing credentials, importation actually takes place at a <strong>DACS</strong><em>jurisdiction</em>, just as authentication does. That target jurisdiction is similarly responsible for the resulting credentials and is identified within the new credentials for access control testing and audit purposes.</p><p>Any appropriately configured jurisdiction is capable of exporting or importing credentials. Some federations might choose to create "administrative jurisdictions" solely for this purpose (e.g., export.example.com and import.example.com), however, just as a federation might be structured to limit authentication services to a designated jurisdiction.</p><h3>The Identity Transfer Protocol</h3>
<p><strong>Overview</strong></p><p>The ability to transfer credentials from one identity management system to another is a feature that can be beneficial to both users and system administrators. For users, it can provide the convenience of single sign-on; a user need only be authenticated by one federation to be able to access resources within a different federated system. For a system administrator, it means that fewer user identities need to be created and managed.</p><p>The systems being federated might exist within a single organization or be associated with different, autonomous organizations that have a trust relationship, very much as <strong>DACS</strong> jurisdictions do. The transfer of credentials need not be reciprocal; that is, Federation A may allow identities to be imported from Federation B but not <em>vice versa</em>.</p><p>The architecture of the transfer mechanism is primarily constrained by the typical browser-oriented usage of <strong>DACS</strong>, where credentials are encapsulated within an HTTP cookie, thereby dictating how credentials are set in an off-the-shelf browser and when credentials will be sent by the browser. The approach is complicated somewhat because a <strong>DACS</strong> user may have multiple concurrent credentials or may be unauthenticated. Also, a <strong>DACS</strong> federation may wish to federate with more than one foreign federation. Therefore, interaction with the user will sometimes be necessary so that she can select the particular identity to be transferred and a <em>target federation</em> to which that identity is to be transferred. A jurisdiction or federation must be able to customize this interaction for appropriate web site integration (i.e., look and feel), but a bare-bones capability must still be provided by <strong>dacs_auth_transfer</strong>.</p><p>The design tries to balance security, usability, performance, availability, configuration complexity, implementation effort, administrative needs, generality, and extensibility, all within the constraints of the <strong>DACS</strong> architecture and requirements.</p><p>Though it is assumed that SSL is used to secure all network communication and identify the communicating hosts where necessary, some major potential threats against a transfer capability must be addressed by the design:</p><p><em>Replay</em>: the system must prevent the malicious or accidental use of expired credentials, reuse of authentication material by a different browser user (such as through browser history or a bookmark), use of authentication material discovered in a log file, and so on</p><p><em>Forgery and Tampering</em>: the system must prevent a malicious user from changing authentication material to get different or "better" credentials using the transfer protocol</p><p>Replay is addressed in the transfer protocol by restricting the exposure of authentication and protocol material and by limiting its validity period. Injection of copied material is also made difficult. Forgery and tampering are addressed through cryptographic means; using well-established techniques, it is thought to be practically impossible to create forged authentication material or modify it undetectably.</p><p><strong>Security</strong></p><p>Importation of identities has federation-wide ramifications but it is the responsibility of each jurisdiction to decide whether it will allow its <strong>dacs_auth_transfer</strong> service to import an identity or its rules to honour an identity imported by another jurisdiction within the federation. A jurisdiction may independently allow identities to be imported from an external system, just as it may unilaterally decide whether it will authenticate users and how it will do so. On the other hand, a jurisdiction is free to reject imported identities, just as it is free to reject an identity vouched for by another jurisdiction in its federation. Federation members may wish to establish guidelines and procedures for importing identities.</p><p><strong>Protocol Operation</strong></p><p>The purpose of the protocol is to transfer an identity understood by the initial federation to the <em>target federation</em>. The initial federation <em>exports</em> an identity; the target federation <em>imports</em> the identity.</p><p>The four stages (operations) of the protocol are now described, in the order in which they are used. In all cases, "the user" can be a browser or middleware.</p><p>The PRESENTATION operation, which is performed in the initial federation and is optional, is used for prompting the user to select the credentials to be transferred and identify the target federation. The purpose of the PRESENTATION operation is simply to make it easier for a user or middleware to invoke the EXPORT operation; the EXPORT operation can be invoked directly without engaging in this step of the protocol, however.</p><p>The EXPORT operation is invoked at the initial federation by a user to request that the initial federation initiate the transfer of credentials representing a given identity to a given federation. After receiving and validating its arguments, the EXPORT operation invokes the TOKEN operation at the target federation. If the target federation tentatively approves the importation of the identity, it returns a URL to which the EXPORT stage redirects the user. If the target federation rejects the request (or the request fails), the EXPORT stage returns an error indication that should be reflected back to the user and terminates the protocol.</p><p>The TOKEN operation is the heart of the protocol. By invoking it at the target federation, the initial federation vouches for the identity to be transferred and requests that the target federation honour the user&apos;s request for credentials valid within the target federation; the latter is free to reject the request for any reason. To accomplish the transfer, the initial federation requests a token from the target federation.</p><p>A token is cryptographically protected, opaque information encapsulated within a URL as its query component; the token is meaningful only to the target federation (i.e., its meaning is unspecified by the protocol). It could contain a database key for the transaction, a nonce, or a self-contained description of the transaction. All that is required by the protocol is that it be kept secret among the communicating parties for as long as it is valid, that its validity period be no longer than what is required to complete the last stage of identity transfer, that it be difficult to forge, and that it be tamper-resistant.</p><p>If the request for a token is granted, the target federation returns a URL that encapsulates it, otherwise an error indication is returned to the initial federation which in turn returns an error indication to the user and terminates the protocol.</p><p>The IMPORT request is sent by the user to the target federation. A complete URL containing the IMPORT request will typically be created by the target federation, returned to the initial federation, and forwarded to the user as a browser redirect by the EXPORT stage. Upon successfully validating the request, which includes an examination of the token and checking for revocation of the identity (see \m[blue]<a href="../man5/dacs.acls.5.html"><strong>dacs.acls</strong>(5)</a></strong>\m[]\s-2\u[3]\d\s+2 for a description of how authentication/access revocation works), the target federation returns credentials (as an HTTP cookie) that are returned to the user in the final step of the IMPORT operation - this is the end-goal of the protocol - and the user is redirected by the target federation to an appropriate "success" URL as a convenience to the user. If the transfer fails, no new credentials are returned and the user is redirected to an appropriate "failure" URL by the target federation.</p><p><strong>Implementation</strong></p><p>The <strong>dacs_auth_transfer</strong> service implements all of the stages as separate operations of a single web service; a different implementation might create separate services for each stage or operation, or implement a subset of the functionality (e.g., it might only support exporting identities).</p><p>Each of the federating systems must be assigned a unique name (for <strong>DACS</strong>, through the FEDERATION_NAME directive) so that identities can be globally unique. <em>The federating systems need not share a common domain name suffix</em>.</p><p><strong>Note</strong></p><p>In the current implementation of <strong>dacs_auth_transfer</strong>, configuration information associated with target federations is not automatically distributed by <strong>DACS</strong> to a federation&apos;s jurisdictions. This means that only those jurisdictions that have been specifically configured to import identities will be able to do so; a jurisdiction will not automatically understand how to interact with a given target federation that is configured at a different jurisdiction. Each jurisdiction&apos;s administrator wanting to provide this service must configure his site&apos;s <strong>dacs_auth_transfer</strong> service appropriately.</p><p>Details of the <strong>dacs_auth_transfer</strong> implementation and configuration requirements are now presented. A different implementation of the protocol could look very different.</p><p>PRESENTATION</p><p><strong>dacs_auth_transfer</strong> can emit an HTML document to prompt the user (by default, using the style sheet \m[blue]<strong>dacs_auth_transfer.css</strong>\m[]\s-2\u[4]\d\s+2). The user selects an identity and target federation and submits a form. Alternatively, the information necessary to construct prompts can be returned within an XML document that conforms to \m[blue]<strong>dacs_auth_transfer.dtd</strong>\m[]\s-2\u[5]\d\s+2. A site is also free to implement its own presentation stage.</p><p>The list of known target federation names from which a user can select is obtained from mappings that have been configured at this jurisdiction (see below).</p><p>When emitting HTML, the web page generated by <strong>dacs_auth_transfer</strong> can be customized through the auth_transfer VFS item type. The following items are emitted if they exist:</p><p>header: Initial HTML to emit instead of the default.</p><p>prologue: HTML to emit immediately after the header.</p><p>instructions: HTML to emit immediately after the prologue and before the form.</p><p>form: Additional HTML to emit within the form. A likely use of this is to specify a hidden <em>TRANSFER_SUCCESS_URL</em> argument.</p><p>epilogue: HTML to emit immediately after the form.</p><p>trailer: Final HTML to emit instead of the default.</p><p>For example, consider the configuration directive:</p>
<pre>
VFS "[auth_transfer]dacs-fs:${Conf::DACS_HOME}/auth_transfer"
</pre>
<p>If files named header and trailer exist in the directory ${Conf::DACS_HOME}/auth_transfer, they are expected to contain the initial and final HTML content, respectively. Note that these files consist of text and HTML markup but are not complete HTML documents.</p><p>Customization of the HTML form is possible using configuration variables:</p><p><em>transfer_export_uri</em>: the URL of the program to which the form should be submitted. By default, the URL is created from the one used to invoke the presentation stage, which will usually be that of <strong>dacs_auth_transfer</strong>.</p><p><em>transfer_submit_label</em>: the text label to put in the form&apos;s submit button.</p><p><em>transfer_submit_method</em>: the HTTP method to use to submit the form (GET is the default).</p><p>For example, the submit button&apos;s text can be specified using the directive:</p>
<pre>
EVAL ${Conf::transfer_submit_label} = "Execute the transfer!"
</pre>
<p>EXPORT</p><p>The identity to be transferred and the name of the target federation are submitted to <strong>dacs_auth_transfer</strong> as arguments of the EXPORT operation. The request must be accompanied by <strong>DACS</strong> credentials that match this identity and the target federation must be recognized by the receiving jurisdiction.</p><p>For example, this URL asks the jurisdiction associated with example.com to export the identity EXAMPLE:bobo to the target federation DSS:</p>
<pre>
https://example.com/dacs/dacs_auth_transfer?OPERATION=EXPORT&#92;
    &TARGET_FEDERATION=DSS&#92;
    &DACS_IDENTITY=EXAMPLE:bobo
</pre>
<p>For the request to succeed, credentials for EXAMPLE:bobo must be sent with the request, permission must be granted (by example.com) to export the identity, example.com must be configured with an appropriate mapping, described below, such that it knows how to submit a TOKEN request to a service associated with federation DSS, and that service must allow importation of the identity.</p><p>The mappings of federation identifiers to URLs for export purposes are provided through the \m[blue]<strong>AUTH_TRANSFER_EXPORT</strong>\m[]\s-2\u[6]\d\s+2 directive. That is, these mappings indicate which target federations have been configured at this jurisdiction and associate a target federation identifier (a short, descriptive keyword) with a URL of a web service that implements the TOKEN operation for the target federation. It is from these mappings that the list of selectable target federations is obtained.</p><p><strong>Note</strong></p><p>Unless jurisdictions coordinate mappings with each other, the same jurisdiction must perform both the PRESENTATION and EXPORT operations.</p><p>For example, dacs.conf might include the directive:</p>
<pre>
AUTH_TRANSFER_EXPORT "DSS https://dacs.dss.ca/cgi-bin/dacs/dacs_auth_transfer"
</pre>
<p>This directive specifies one target federation, identified by the name DSS, and associates it with the URL of a service implementing the TOKEN operation.</p><p><strong>Security</strong></p><p>The TOKEN operation must be performed over a secure communication channel, typically using SSL. URLs appearing in these mappings should therefore specify https. The issuer of the TOKEN operation may identify itself using an SSL client certificate; if \m[blue]<strong>SSL_PROG_CLIENT_CRT</strong>\m[]\s-2\u[7]\d\s+2 is configured, that certificate will automatically be used.</p><p>If the issuer of the TOKEN operation possesses <strong>DACS</strong> credentials obtained offline from the target federation (e.g., using \m[blue]<a href="../man1/dacscookie.1.html"><strong>dacscookie</strong>(1)</a></strong>\m[]\s-2\u[8]\d\s+2), it can specify that they be sent with the request by putting them in an object named <em>FEDNAME</em>.cookies relative to the auth_transfer item type. directory ${Conf::DACS_HOME}/auth_transfer, one cookie per line. The <em>FEDNAME</em> filename suffix is the federation identifier for the importing federation.</p><p>For instance, given the AUTH_TRANSFER_EXPORT directive and the VFS directive for auth_transfer above, all cookies found in a file named /usr/local/dacs/auth_transfer/DSS.cookies would be sent with the TOKEN operation to identify the initial federation. These cookies would have been obtained from federation DSS over a secure communication channel.</p><p>TOKEN</p><p>The syntax and semantics of a token are meaningful only to the target federation and can be changed without affecting any initial federation. In the current implementation, the token is comprised of information such as the identity to be transferred, the current date at the transfer federation, the client&apos;s IP address, and (optionally) the client&apos;s role string, which is encrypted using the target federation&apos;s federation-wide key and base-64 encoded.</p><p><strong>Note</strong></p><p>The identity to be transferred must be a syntactically valid <strong>DACS</strong> username.</p><p>The period during which a token is valid is determined solely by the target federation. Its lifetime will ordinarily be just a few seconds, after which it will be treated as invalid by the IMPORT stage. The \m[blue]<strong>AUTH_TRANSFER_TOKEN_LIFETIME_SECS</strong>\m[]\s-2\u[9]\d\s+2 directive specifies this value for <strong>dacs_auth_transfer</strong>; if not given, a compile-time default is used.</p><p>A jurisdiction within the target federation that provides identity importation must must configure at least one Transfer clause. The transfer directives are largely analogous to the authentication and roles directives. Each Transfer element must have an id attribute. Its value is merely a label (an alphabetic followed by zero or more alphanumerics, hyphens, and underscores) that allows the clause to be referenced. The id attribute values must be unique (case-sensitively) within the clause&apos;s Jurisdiction section.</p><p><strong>Security</strong></p><p>An access control rule must be in place to ensure that this operation can only be executed by a legitimate server belonging to a recognized initial federation.</p><p>The caller may not have supplied <strong>DACS</strong> credentials to identify itself and therefore the \m[blue]<strong>user()</strong>\m[]\s-2\u[10]\d\s+2 function may not be of use.</p><p><strong>Transfer Clause Directives Index:</strong></p><p>CREDENTIALS_LIFETIME_SECS (Optional1)</p><p>ERROR_URL (Optional1)</p><p>EXIT* (Optional1)</p><p>IMPORT_FROM (Required)</p><p>IMPORT_ROLES (Optional1)</p><p>IMPORT_URL (Optional1)</p><p>PREDICATE (Optional1)</p><p>REFEDERATE (Optional1)</p><p>ROLES* (Optional1)</p><p>SUCCESS_URL (Optional1)</p><p>IMPORT_FROM (Required)</p><p>This directive, which may be repeated, names an initial federation, as identified by the <em>INITIAL_FEDERATION</em> argument, to which this clause applies. It must be a syntactically valid federation name. These names are case-sensitive.</p><p>REFEDERATE (Optional1)</p><p>If "yes" (case insensitive), the federation and jurisdiction of the imported identity (i.e., the <em>DACS_IDENTITY</em> argument) are changed to that of the target jurisdiction. If this directive is unspecified or has another value, the original identity is retained.</p><p>For example, if the TOKEN operation at jurisdiction ALPHA of federation FED2 is passed <em>DACS_IDENTITY</em> with a value of FED1::BETA:bobo and REFEDERATE is enabled, then the imported identity will be FED2::ALPHA:bobo .</p><p><strong>Security</strong></p><p>This directive is useful in certain circumstances in that it can prevent a particular individual from being known by multiple names, which may complicate access control rules. It must be used with care, however.</p><p>Say Bobo is naturally known as ALPHA:bobo within federation FED2. If she authenticates as FED1::BETA:bobo and uses <strong>dacs_auth_transfer</strong> to obtain credentials in FED2, then by default her new credentials will be for the name FED1::BETA:bobo; i.e., her <strong>DACS</strong> identity is retained.</p><p>Access control rules in FED2 may need to handle both names, however, which can lead to problems. Some <strong>DACS</strong> administrators in FED2 may not even be aware of FED1, and so access to FED1::BETA:bobo may be denied while access to the same resource may be granted to FED2::ALPHA:bobo.</p><p>If no two distinct identities in FED1 can be mapped to the same identity in FED2 (i.e., the same <em>username</em> component is not associated with more than one jurisdiction that can export the identity to FED2), then the administrator at the initial federation can advise the administrator at the target federation that the REFEDERATE directive should be enabled. Transferred identities will then be modified to appear to have been authenticated by FED2::ALPHA. When this feature is configured, although Bobo authenticates as FED1::BETA:bobo, her imported identity will be FED2::ALPHA:bobo.</p><p>If enabling this directive would cause two or more distinct identities to be mapped to the same <strong>DACS</strong> identity, the directive should not be used because different individuals may be assigned the same <strong>DACS</strong> name in the target federation.</p><p>PREDICATE (Optional1)</p><p>The value of this directive is an expression. If the expression does not evaluate to <strong>True</strong>, importation will not be permitted.</p><p>CREDENTIALS_LIFETIME_SECS (Optional1)</p><p>This directive is used to override the value of the \m[blue]<strong>AUTH_CREDENTIALS_DEFAULT_LIFETIME_SECS</strong>\m[]\s-2\u[11]\d\s+2 directive or the default.</p><p>IMPORT_ROLES (Optional1)</p><p>If "yes" (case insensitive), any roles in the existing credentials will be copied to the new credentials. The roles must be syntactically valid at the target jurisdiction. Within the context of the clause, the variable <em>${Auth::IMPORTED_ROLES}</em> is assigned the roles string. The default is "no".</p><p>IMPORT_URL (Optional1)</p><p>This is the URL of the IMPORT stage of the protocol. By default, this is the same as that of the TOKEN stage, which is correct for <strong>dacs_auth_transfer</strong> since it implements all stages of the protocol.</p><p>SUCCESS_URL (Optional1)</p><p>If the transfer is successful and the user has not specified another URL via the <em>TRANSFER_SUCCESS_URL</em> argument, the user will be redirected to SUCCESS_URL. This directive is used by <strong>dacs_auth_transfer</strong> in the IMPORT stage.</p><p>ERROR_URL (Optional1)</p><p>If the transfer fails and the user has not specified another URL via the <em>TRANSFER_ERROR_URL</em> argument, the user will be redirected to ERROR_URL. This directive is used by <strong>dacs_auth_transfer</strong> in the IMPORT stage.</p><p>ROLES* (Optional1)</p><p>The value of this directive is an expression that is evaluated at run-time. Provided an error does not occur, the resulting string becomes the role string for the new credentials. The new role string must be syntactically valid at the target jurisdiction. The variable <em>${Auth::IMPORTED_ROLES}</em> is initialized to the role string (if any - see IMPORT_ROLES) from the existing credentials and is assigned the value of the expression.</p><p>For example, to add fed1 to those found in the existing credentials:</p>
<pre>
IMPORT_ROLES "yes"
ROLES* &apos;${Auth::IMPORTED_ROLES} . ",fed1"&apos;
</pre>
<p>EXIT* (Optional1)</p><p>The value of this directive is an expression that is evaluated at run-time. Provided an error does not occur, side effects from the evaluation may alter the final result of the clause. The variable <em>${Auth::IMPORTED_ROLES}</em> is initialized to the role string (if any - see IMPORT_ROLES) from the existing credentials and <em>${Auth::IMPORTED_USERNAME}</em> is assigned the (tentative) imported username component from the imported credentials. Either variable may be modified by the expression. The new role string must be syntactically valid at the target jurisdiction. The new username must be syntactically valid.</p><p>This directive maps all imported usernames to guest, relative to the target jurisdiction:</p>
<pre>
EXIT* &apos;${Auth::IMPORTED_USERNAME} = "guest"&apos;
</pre>
<p>IMPORT</p><p>An IMPORT request is validated before being accepted, which includes examining the token and checking for revocation of the identity. There is no guarantee that if the TOKEN operation succeeds the IMPORT operation will also.</p><p><strong>DACS</strong> credentials imported by <strong>dacs_auth_transfer</strong> are marked as being alien and imported, the jurisdiction that executed the importation is recorded, and the IP address associated with the user&apos;s initial credentials are associated with the new credentials; these characteristics can be tested using the \m[blue]<a href="../man5/dacs.exprs.5.html"><strong>dacs.exprs</strong>(5)</a></strong>\m[]\s-2\u[10]\d\s+2 function.</p><p><strong>Security</strong></p><p>An access control rule must be in place to ensure that this operation can only be executed by appropriate users. Access might well be granted to any user but might reasonably be restricted based on IP address, etc.</p><p>To recap, assuming <strong>dacs_auth_transfer</strong> is used to transfer credentials between two <strong>DACS</strong> federations (which we will call <em>Federation A</em> and <em>Federation B</em>) and no errors occur, the flow of control will typically be as follows:</p><p>The user follows a link that invokes <strong>dacs_auth_transfer</strong> at some jurisdiction within <em>Federation A</em>.</p><p><strong>dacs_auth_transfer</strong> generates an HTML document that is displayed on the user&apos;s browser. The user selects a target federation (<em>Federation B</em>) and credentials to transfer from those presented within an HTML form and submits it, invoking <strong>dacs_auth_transfer</strong> at <em>Federation A</em> again, but this time to perform the EXPORT operation. The list of credentials from which the user can choose depends on the user&apos;s current credentials in <em>Federation A</em>. The list of target federations depends on those known to the jurisdiction that processes the request.</p><p>The <strong>dacs_auth_transfer</strong> at <em>Federation A</em> processes the EXPORT operation and invokes the TOKEN operation at <em>Federation B</em>. This action is transparent to the user. The response from <em>Federation B</em> is a URL that represents a complete IMPORT operation directed at <em>Federation B</em>. The EXPORT operation redirects the user&apos;s browser to that URL.</p><p>Upon receiving the redirect, the user&apos;s browser invokes the IMPORT operation at <em>Federation B</em>. <em>Federation B</em> returns new credentials and redirects the user&apos;s browser to a configured or requested URL.</p><p>To interoperate with <strong>dacs_auth_transfer</strong> to import <strong>DACS</strong> credentials, a program must implement the TOKEN operation. It must also provide functionality similar to that of the IMPORT operation. Because the TOKEN operation returns a URL encapsulating an IMPORT request to which the client is redirected, however, the IMPORT operation can be implementation-dependent and does need to interoperate with <strong>dacs_auth_transfer</strong>.</p><p>To interoperate with <strong>dacs_auth_transfer</strong> to export credentials to a <strong>DACS</strong> federation, a program must be capable of invoking <strong>dacs_auth_transfer</strong> with the TOKEN operation and its arguments, and redirect the client to the URL provided by <strong>dacs_auth_transfer</strong>.</p>
<h3>Web Service Arguments</h3>
<p>In addition to the \m[blue]<strong>standard CGI arguments</strong>\m[]\s-2\u[12]\d\s+2, <strong>dacs_auth_agent</strong> understands a variety of arguments that depend on the operation being requested. The descriptions of the arguments that follow are therefore grouped by operation.</p><p>The additional arguments accepted by <strong>dacs_auth_transfer</strong> follow.</p><p><strong>Presentation</strong></p><p>For this stage, the value of the <em>OPERATION</em> argument is PRESENTATION (case insensitive).</p><p>The <em>FORMAT</em> argument (see \m[blue]<a href="../man1/dacs.1.html"><strong>dacs</strong>(1)</a></strong>\m[]\s-2\u[13]\d\s+2) determines the type of output, with the default being HTML.</p><p>Additional arguments:</p><p><em>REDIRECT_DEFAULT</em></p><p>If "yes" and there is exactly one set of credentials and one target federation (i.e., there is nothing for the client to select), then automatically redirect the client to a URL representing the EXPORT stage of the protocol. Though the client will not be required to submit a form, he will not have the opportunity to see which identity is being transferred or the name of the target federation.</p><p><strong>Export</strong></p><p>For this stage, the value of the <em>OPERATION</em> argument is EXPORT (case insensitive).</p><p>Additional arguments:</p><p><em>DACS_IDENTITY</em></p><p>This is the identity corresponding to the credentials to be exported, expressed as a full <strong>DACS</strong> user identity (see \m[blue]<a href="../man1/dacs.1.html"><strong>dacs</strong>(1)</a></strong>\m[]\s-2\u[14]\d\s+2).</p><p><em>TARGET_FEDERATION</em></p><p>This is the jurisdiction&apos;s identifier for the federation to which the selected credentials are to be transferred. The user will typically select this identifier from a list produced by the same jurisdiction that performs the PRESENTATION operation.</p><p><em>TRANSFER_SUCCESS_URL</em></p><p>If the transfer operation is successful, the user will be redirected to this URL.</p><p><em>TRANSFER_ERROR_URL</em></p><p>If the transfer operation fails, the user will be redirected to this URL. If unspecified, the AUTH_TRANSFER_ERROR_URL will be used if configured, otherwise a message will be emitted.</p><p><em>DACS_DEBUG</em></p><p>If "yes", operate in a debugging mode.</p><p><strong>Token</strong></p><p>For this stage, the value of the <em>OPERATION</em> argument is TOKEN (case insensitive).</p><p>Additional arguments:</p><p><em>DACS_IDENTITY</em></p><p>The value of this argument is identical to the argument of the same name that is passed to the EXPORT stage. If the transfer succeeds, this is the identity for which new credentials will be issued.</p><p><em>INITIAL_FEDERATION</em></p><p>This is the identifier for the federation that received the EXPORT request. The target federation must have a mapping for this identifier.</p><p><em>CLIENT_ADDR</em></p><p>The IP address from which the EXPORT request was issued.</p><p><em>TRANSFER_SUCCESS_URL</em></p><p>If the transfer operation is successful, the user wants to be redirected to this URL. If unspecified, a default URL will be used.</p><p><em>TRANSFER_ERROR_URL</em></p><p>If the transfer operation fails, the user will be redirected to this URL. If unspecified, a default URL will be used.</p><p><em>DACS_DEBUG</em></p><p>If "yes", operate in a debugging mode.</p><p><strong>Import</strong></p><p>For this stage, the value of the <em>OPERATION</em> argument is IMPORT (case insensitive).</p><p>Additional arguments:</p><p><em>TOKEN</em></p><p>This is the value of the token returned by a previous call to the TOKEN stage of the protocol.</p><p><em>TRANSFER_SUCCESS_URL</em></p><p>If the transfer operation is successful, the user wants to be redirected to this URL. If unspecified, a default URL configured at the target federation using the \m[blue]<strong>AUTH_TRANSFER_SUCCESS_URL</strong>\m[]\s-2\u[15]\d\s+2 directive will be used.</p><p><em>TRANSFER_ERROR_URL</em></p><p>If the transfer operation fails, the user wants to be redirected to this URL. If unspecified, a default URL configured at the target federation using the \m[blue]<strong>AUTH_TRANSFER_ERROR_URL</strong>\m[]\s-2\u[16]\d\s+2 will be used.</p><p><em>DACS_DEBUG</em></p><p>If "yes", operate in a debugging mode.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLE</h2>
        <div class="sectioncontent">
<p>The following example describes step-by-step how to configure two <strong>DACS</strong> federations, FED_EX1 (example.com) and FED_EX2 (example.net), to enable credentials to be transferred <em>from</em>FED_EX1<em>to</em>FED_EX2. For FED_EX1, the jurisdiction J1 (j1.example.com) will be configured to export credentials and for FED_EX2, J2 (j2.example.net) will be configured to import credentials. The example assumes that these two jurisdictions have already installed and configured <strong>DACS</strong> and that it is possible to authenticate (obtain credentials) somewhere within FED_EX1.</p><p><strong>Note</strong></p><p>This example will not actually work without changing the domain names, URLs, and identities that it uses for demonstration purposes to those configured for your federations and jurisdictions. Having successfully reproduced this example functionality on your systems, it should be apparent how to extend it for additional jurisdictions and federations, and how to make credential transfer bidirectional.</p><p>At J1, add a jurisdiction-specific access control rule that allows <strong>dacs_auth_transfer</strong> to be used to export an identity:</p>
<pre>
&lt;acl_rule status="enabled"&gt;
 &lt;services&gt;
  &lt;service url_expr=&apos;"${Conf::dacs_cgi_bin_prefix}/dacs_auth_transfer"&apos;/&gt;
 &lt;/services&gt;

 &lt;rule order="allow,deny" pass_credentials="all"&gt;
  &lt;allow&gt;
    user("auth") and (${Args::OPERATION} eq "PRESENTATION"
      or ${Args::OPERATION} eq "EXPORT")
  &lt;/allow&gt;
 &lt;/rule&gt;
&lt;/acl_rule&gt;
</pre>
<p>At J2, add a jurisdiction-specific access control rule that allows <strong>dacs_auth_transfer</strong> to be used to import an identity:</p>
<pre>
&lt;acl_rule status="enabled"&gt;
 &lt;services&gt;
  &lt;service url_expr=&apos;"${Conf::dacs_cgi_bin_prefix}/dacs_auth_transfer"&apos;/&gt;
 &lt;/services&gt;

 &lt;rule order="allow,deny" pass_credentials="all"&gt;
  &lt;allow&gt;
    (from("j1.example.com") and ${Args::OPERATION} eq "TOKEN")
      or ${Args::OPERATION} eq "IMPORT"
  &lt;/allow&gt;
 &lt;/rule&gt;
&lt;/acl_rule&gt;
</pre>
<p><strong>Security</strong></p><p>In particular, the rule at the target federation must restrict access based on the identity, or possibly the IP address, associated with the request. If the cookie-based authentication method is used, the rule would test for that specific identity.</p><p>At J1, configure <strong>dacs_auth_transfer</strong> to know how to invoke the TOKEN operation so that it can export credentials to FED_EX2. Add this directive to dacs.conf:</p>
<pre>
AUTH_TRANSFER_EXPORT &#92;
  "FED_EX2 https://j2.example.net/cgi-bin/dacs/dacs_auth_transfer"
</pre>
<p>Note that this is the only required additional configuration at J1.</p><p>At J2, configure <strong>dacs_auth_transfer</strong> so that it will import credentials from FED_EX1. Add a Transfer clause to dacs.conf:</p>
<pre>
ACCEPT_ALIEN_CREDENTIALS "yes"

&lt;Transfer id="fed_ex1"&gt;
IMPORT_FROM "FED_EX1"
SUCCESS_URL &#92;
  "https://j2.example.net/cgi-bin/dacs/dacs_current_credentials"
&lt;/Transfer&gt;
</pre>
<p>This configuration allows credentials to be imported from federation FED_EX1. As the default, after successful importation users will be redirected to a page that lists their identities in federation FED_EX2. In practice this might point to the site&apos;s home page, for example. The jurisdiction must be told to recognize credentials imported from FED_EX2 using the ACCEPT_ALIEN_CREDENTIALS directive.</p><p>The configuration can now be tested. First, authenticate somewhere within FED_EX1 using your browser. Let&apos;s assume that you authenticated as the identity FED_EX1::J1:bob so that this example can refer to a specific name. Invoke this URL from the browser:</p>
<pre>
https://j1.example.com/cgi-bin/dacs/dacs_auth_transfer?OPERATION=PRESENTATION
</pre>
<p>You should be presented with a web page that displays the identity FED_EX1::J1:bob (and any others that happen to be in effect) and the target federation name FED_EX2 (and any other federations specified by a AUTH_TRANSFER_EXPORT directive). It might be instructive to view the source for the HTML page if you are still not clear about what the PRESENTATION operation does. Click on the Transfer button (if necessary, first selecting an identity and target federation).</p><p>One can bypass the PRESENTATION operation by directly invoking the URL:</p>
<pre>
https://j1.example.com/cgi-bin/dacs/dacs_auth_transfer?&#92;
OPERATION=EXPORT&DACS_IDENTITY=FED_EX1::J1:bob
</pre>
<p>If the transfer is successful, your browser should now possess the original credentials for the identity FED_EX1::J1:bob, valid within FED_EX1, and credentials for the identity FED_EX1::J1:bob that are valid within FED_EX2; <strong>dacs_current_credentials</strong>, where your browser should be redirected to in this example, should display the latter. Note that though issued by different sites, the two cookies have the same cookie name.</p><p>The following example illustrates how an identity might be transferred from a non-<strong>DACS</strong> federation (SOME_FED) to a <strong>DACS</strong> federation (again, FED_EX2 via its jurisdiction J2). We will assume that an appropriate access control rule has been configured at J2.</p><p>As in the previous example, at J2, configure <strong>dacs_auth_transfer</strong> so that it will import credentials from SOME_FED by adding a Transfer clause to dacs.conf:</p>
<pre>
ACCEPT_ALIEN_CREDENTIALS "yes"

&lt;Transfer id="some_fed"&gt;
IMPORT_FROM  "SOME_FED"
REFEDERATE   "YES"
IMPORT_ROLES "NO"
&lt;/Transfer&gt;
</pre>
<p>This configuration allows credentials to be imported from federation SOME_FED.</p><p>A system administrator must write a small program, run somewhere within SOME_FED, that will invoke <strong>dacs_auth_transfer</strong> at J2 with appropriate arguments. The program might be run automatically as part of the login procedure at SOME_FED or explicitly by providing a link that a user can follow (e.g., labelled "Transfer Login To FED_EX2", or similar). The program simply invokes the TOKEN operation at J2 and, if successful, redirects the user to the URL that is returned to it by <strong>dacs_auth_transfer</strong> (which represents an IMPORT operation). If the IMPORT operation succeeds, the user will be issued an HTTP cookie bearing the <strong>DACS</strong> credentials. If desired, the URL that the user should visit after a successful transfer can be specified through the <em>TRANSFER_SUCCESS_URL</em> argument.</p><p>The program might initiate the transfer by constructing and invoking a URL (via the POST method) much like this:</p>
<pre>
import_url=`http -p INITIAL_FEDERATION "SOME_FED" &#92;
  -p DACS_IDENTITY "FED_EX2::J2:bobo" &#92;
  -p CLIENT_ADDR 127.0.0.1 &#92;
  -p TRANSFER_SUCCESS_URL &#92;
    "https://j2.example.net/cgi-bin/dacs/dacs_current_credentials" &#92;
  -p OPERATION TOKEN &#92;
  &apos;https://j2.example.net/cgi-bin/dacs/dacs_auth_transfer&apos;`
</pre>
<p>Here, the requested <strong>DACS</strong> identity is FED_EX2::J2:bobo. If the response looks like a URL, then the TOKEN operation succeeded; to continue the transfer, the program must redirect the user to the URL. In this example, if credentials are returned to the user, the user will be redirected to <strong>dacs_current_credentials</strong> by <strong>DACS</strong> (which is useful for testing but unlikely in actual use).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILES</h2>
        <div class="sectioncontent">
<p>\m[blue]<strong>dacs_auth_transfer.css</strong>\m[]\s-2\u[4]\d\s+2</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DIAGNOSTICS</h2>
        <div class="sectioncontent">
<p>The program exits 0 if everything was fine, 1 if an error occurred.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO dacs_auth_transfer&hellip;</h2>
        <div class="sectioncontent">
<p>\m[blue]<a href="../man8/dacs_authenticate.8.html"><strong>dacs_authenticate</strong>(8)</a></strong>\m[]\s-2\u[17]\d\s+2, \m[blue]<a href="../man8/dacs_auth_agent.8.html"><strong>dacs_auth_agent</strong>(8)</a></strong>\m[]\s-2\u[18]\d\s+2, \m[blue]<strong>dacs.conf</strong>(5)</strong>\m[]\s-2\u[19]\d\s+2</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>The jurisdictional meta information should be extended to identify importing and exporting jurisdictions (e.g., as reported by \m[blue]<a href="../man8/dacs_list_jurisdictions.8.html"><strong>dacs_list_jurisdictions</strong>(8)</a></strong>\m[]\s-2\u[20]\d\s+2).</p><p>It should be possible to optionally perform comparative checks on the IP address from which the EXPORT request was issued and the IP address from which the IMPORT request was issued. At present, if they are not identical a warning message is logged but importation is allowed.</p><p>The current implementation is stateless on the server side. By including a nonce in the token, the possibility of replay could be further reduced.</p><p>A mechanism for mapping imported names may be needed.</p><p>Although the credential&apos;s <strong>DACS</strong> role string is passed to the target federation, a flexible mechanism for optionally including them in the imported credentials should be added.</p><p>The protocol should be improved with respect to peer identification for the TOKEN operation.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Distributed Systems Software (\m[blue]<strong>www.dss.ca</strong>\m[]\s-2\u[21]\d\s+2)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYING</h2>
        <div class="sectioncontent">
<p>Copyright2003-2012 Distributed Systems Software. See the \m[blue]<strong>LICENSE</strong>\m[]\s-2\u[22]\d\s+2 file that accompanies the distribution for licensing information.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTES</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
     1.
  </dt>
  <dd>
    <p>dacsoptions</p><p>http://dacs.dss.ca/man/dacs.1.html#dacsoptions</p>
  </dd>
  <dt>
     2.
  </dt>
  <dd>
    <p>ACCEPT_ALIEN_CREDENTIALS</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#ACCEPT_ALIEN_CREDENTIALS</p>
  </dd>
  <dt>
     3.
  </dt>
  <dd>
    <p><a href="../man5/dacs.acls.5.html"><strong>dacs.acls</strong>(5)</a></p><p>http://dacs.dss.ca/man/dacs.acls.5.html</p>
  </dd>
  <dt>
     4.
  </dt>
  <dd>
    <p>dacs_auth_transfer.css</p><p>http://dacs.dss.ca/man//css/dacs_auth_transfer.css</p>
  </dd>
  <dt>
     5.
  </dt>
  <dd>
    <p>dacs_auth_transfer.dtd</p><p>http://dacs.dss.ca/man/../dtd-xsd/dacs_auth_transfer.dtd</p>
  </dd>
  <dt>
     6.
  </dt>
  <dd>
    <p>AUTH_TRANSFER_EXPORT</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#AUTH_TRANSFER_EXPORT</p>
  </dd>
  <dt>
     7.
  </dt>
  <dd>
    <p>SSL_PROG_CLIENT_CRT</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#SSL_PROG_CLIENT_CRT</p>
  </dd>
  <dt>
     8.
  </dt>
  <dd>
    <p><a href="../man1/dacscookie.1.html"><strong>dacscookie</strong>(1)</a></p><p>http://dacs.dss.ca/man/dacscookie.1.html</p>
  </dd>
  <dt>
     9.
  </dt>
  <dd>
    <p>AUTH_TRANSFER_TOKEN_LIFETIME_SECS</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#AUTH_TRANSFER_TOKEN_LIFETIME_SECS</p>
  </dd>
  <dt>
    10.
  </dt>
  <dd>
    <p>user()</p><p>http://dacs.dss.ca/man/dacs.exprs.5.html#user</p>
  </dd>
  <dt>
    11.
  </dt>
  <dd>
    <p>AUTH_CREDENTIALS_DEFAULT_LIFETIME_SECS</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#AUTH_CREDENTIALS_DEFAULT_LIFETIME_SECS</p>
  </dd>
  <dt>
    12.
  </dt>
  <dd>
    <p>standard CGI arguments</p><p>http://dacs.dss.ca/man/dacs.services.8.html#standard_cgi_args</p>
  </dd>
  <dt>
    13.
  </dt>
  <dd>
    <p><a href="../man1/dacs.1.html"><strong>dacs</strong>(1)</a></p><p>http://dacs.dss.ca/man/dacs.1.html</p>
  </dd>
  <dt>
    14.
  </dt>
  <dd>
    <p><a href="../man1/dacs.1.html"><strong>dacs</strong>(1)</a></p><p>http://dacs.dss.ca/man/dacs.1.html#naming</p>
  </dd>
  <dt>
    15.
  </dt>
  <dd>
    <p>AUTH_TRANSFER_SUCCESS_URL</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#AUTH_TRANSFER_SUCCESS_URL</p>
  </dd>
  <dt>
    16.
  </dt>
  <dd>
    <p>AUTH_TRANSFER_ERROR_URL</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#AUTH_TRANSFER_ERROR_URL</p>
  </dd>
  <dt>
    17.
  </dt>
  <dd>
    <p><a href="../man8/dacs_authenticate.8.html"><strong>dacs_authenticate</strong>(8)</a></p><p>http://dacs.dss.ca/man/dacs_authenticate.8.html</p>
  </dd>
  <dt>
    18.
  </dt>
  <dd>
    <p><a href="../man8/dacs_auth_agent.8.html"><strong>dacs_auth_agent</strong>(8)</a></p><p>http://dacs.dss.ca/man/dacs_auth_agent.8.html</p>
  </dd>
  <dt>
    19.
  </dt>
  <dd>
    <p><strong>dacs.conf</strong>(5)</p><p>http://dacs.dss.ca/man/dacs.conf.5.html</p>
  </dd>
  <dt>
    20.
  </dt>
  <dd>
    <p><a href="../man8/dacs_list_jurisdictions.8.html"><strong>dacs_list_jurisdictions</strong>(8)</a></p><p>http://dacs.dss.ca/man/dacs_list_jurisdictions.8.html</p>
  </dd>
  <dt>
    21.
  </dt>
  <dd>
    <p>www.dss.ca</p><p>http://www.dss.ca</p>
  </dd>
  <dt>
    22.
  </dt>
  <dd>
    <p>LICENSE</p><p>http://dacs.dss.ca/man/../misc/LICENSE</p>
  </dd>

</dl>

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="dacs_auth_agent.8.html"><span aria-hidden="true">&larr;</span> dacs_auth_agent.8: Dacs delegated authentication service</a></li>
   <li class="next"><a href="dacs_authenticate.8.html">dacs_authenticate.8: Dacs authentication service <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

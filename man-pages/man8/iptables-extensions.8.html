<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>iptables-extensions: Iptables-extensions  list of extensions in the standard iptables distribution</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Iptables-extensions  list of extensions in the standard iptables distribution">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="iptables-extensions (8) manual">
  <meta name="twitter:description" content="Iptables-extensions  list of extensions in the standard iptables distribution">
  <meta name="twitter:image" content="https://www.carta.tech/images/iptables-iptables-extensions-8.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man8/iptables-extensions.8.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="iptables-extensions (8) manual" />
  <meta property="og:description" content="Iptables-extensions  list of extensions in the standard iptables distribution" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/iptables-iptables-extensions-8.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">iptables-extensions<small> (8)</small></h1>
        <p class="lead">Iptables-extensions  list of extensions in the standard iptables distribution</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man8/">
      <span itemprop="name">System administration commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man8/iptables-extensions.8.html">
      <span itemprop="name">iptables-extensions: Iptables-extensions  list of extensions in the standard iptables distribution</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/iptables/">
      <span itemprop="name">iptables</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man8/iptables-extensions.8.html">
      <span itemprop="name">iptables-extensions: Iptables-extensions  list of extensions in the standard iptables distribution</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>ip6tables</strong> [<strong>-m</strong> <em>name</em> [<em>module-options</em>...]] [<strong>-j</strong> <em>target-name</em> [<em>target-options</em>...]</p><p><strong>iptables</strong> [<strong>-m</strong> <em>name</em> [<em>module-options</em>...]] [<strong>-j</strong> <em>target-name</em> [<em>target-options</em>...]</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MATCH EXTENSIONS</h2>
        <div class="sectioncontent">
<p>iptables can use extended packet matching modules with the <strong>-m</strong> or <strong>--match</strong> options, followed by the matching module name; after these, various extra command line options become available, depending on the specific module.  You can specify multiple extended match modules in one line, and you can use the <strong>-h</strong> or <strong>--help</strong> options after the module has been specified to receive help specific to that module.  The extended match modules are evaluated in the order they are specified in the rule.</p><p>If the <strong>-p</strong> or <strong>--protocol</strong> was specified and if and only if an unknown option is encountered, iptables will try load a match module of the same name as the protocol, to try making the option available.</p><h3>addrtype</h3>
<p>This module matches packets based on their <strong>address type.</strong> Address types are used within the kernel networking stack and categorize addresses into various groups.  The exact definition of that group depends on the specific layer three protocol.</p><p>The following address types are possible:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>UNSPEC</strong></p>
  </dt>
  <dd>
    <p>an unspecified address (i.e. 0.0.0.0)</p>
  </dd>
  <dt>
    <p><strong>UNICAST</strong></p>
  </dt>
  <dd>
    <p>an unicast address</p>
  </dd>
  <dt>
    <p><strong>LOCAL</strong></p>
  </dt>
  <dd>
    <p>a local address</p>
  </dd>
  <dt>
    <p><strong>BROADCAST</strong></p>
  </dt>
  <dd>
    <p>a broadcast address</p>
  </dd>
  <dt>
    <p><strong>ANYCAST</strong></p>
  </dt>
  <dd>
    <p>an anycast packet</p>
  </dd>
  <dt>
    <p><strong>MULTICAST</strong></p>
  </dt>
  <dd>
    <p>a multicast address</p>
  </dd>
  <dt>
    <p><strong>BLACKHOLE</strong></p>
  </dt>
  <dd>
    <p>a blackhole address</p>
  </dd>
  <dt>
    <p><strong>UNREACHABLE</strong></p>
  </dt>
  <dd>
    <p>an unreachable address</p>
  </dd>
  <dt>
    <p><strong>PROHIBIT</strong></p>
  </dt>
  <dd>
    <p>a prohibited address</p>
  </dd>
  <dt>
    <p><strong>THROW</strong></p>
  </dt>
  <dd>
    <p>FIXME</p>
  </dd>
  <dt>
    <p><strong>NAT</strong></p>
  </dt>
  <dd>
    <p>FIXME</p>
  </dd>
  <dt>
    <p><strong>XRESOLVE</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--src-type</strong> <em>type</em></p>
  </dt>
  <dd>
    <p>Matches if the source address is of given type</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--dst-type</strong> <em>type</em></p>
  </dt>
  <dd>
    <p>Matches if the destination address is of given type</p>
  </dd>
  <dt>
    <p><strong>--limit-iface-in</strong></p>
  </dt>
  <dd>
    <p>The address type checking can be limited to the interface the packet is coming in. This option is only valid in the <strong>PREROUTING</strong>, <strong>INPUT</strong> and <strong>FORWARD</strong> chains. It cannot be specified with the <strong>--limit-iface-out</strong> option.</p>
  </dd>
  <dt>
    <p><strong>--limit-iface-out</strong></p>
  </dt>
  <dd>
    <p>The address type checking can be limited to the interface the packet is going out. This option is only valid in the <strong>POSTROUTING</strong>, <strong>OUTPUT</strong> and <strong>FORWARD</strong> chains. It cannot be specified with the <strong>--limit-iface-in</strong> option.</p>
  </dd>

</dl>

<h3>ah (IPv6-specific)</h3>
<p>This module matches the parameters in Authentication header of IPsec packets.</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--ahspi</strong> <em>spi</em>[<strong>:</strong><em>spi</em>]</p>
  </dt>
  <dd>
    <p>Matches SPI.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--ahlen</strong> <em>length</em></p>
  </dt>
  <dd>
    <p>Total length of this header in octets.</p>
  </dd>
  <dt>
    <p><strong>--ahres</strong></p>
  </dt>
  <dd>
    <p>Matches if the reserved field is filled with zero.</p>
  </dd>

</dl>

<h3>ah (IPv4-specific)</h3>
<p>This module matches the SPIs in Authentication header of IPsec packets.</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--ahspi</strong> <em>spi</em>[<strong>:</strong><em>spi</em>]</p>
  </dt>
  <dd>
    
  </dd>

</dl>

<h3>bpf</h3>
<p>Match using Linux Socket Filter. Expects a BPF program in decimal format. This is the format generated by the <strong>nfbpf_compile</strong> utility.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--bytecode</strong> <em>code</em></p>
  </dt>
  <dd>
    <p>Pass the BPF byte code format (described in the example below).</p>
  </dd>

</dl>
<p>The code format is similar to the output of the tcpdump -ddd command: one line that stores the number of instructions, followed by one line for each instruction. Instruction lines follow the pattern 'u16 u8 u8 u32' in decimal notation. Fields encode the operation, jump offset if true, jump offset if false and generic multiuse field 'K'. Comments are not supported.</p><p>For example, to read only packets matching 'ip proto 6', insert the following, without the comments or trailing whitespace:</p><ul>
<li><p>4               # number of instructions</p><p>48 0 0 9        # load byte  ip-&gt;proto</p><p>21 0 1 6        # jump equal IPPROTO_TCP</p><p>6 0 0 1         # return     pass (non-zero)</p><p>6 0 0 0         # return     fail (zero)</p></li>
</ul><p>You can pass this filter to the bpf match with the following command:</p><ul>
<li><p>iptables -A OUTPUT -m bpf --bytecode '4,48 0 0 9,21 0 1 6,6 0 0 1,6 0 0 0' -j ACCEPT</p></li>
</ul><p>Or instead, you can invoke the nfbpf_compile utility.</p><ul>
<li><p>iptables -A OUTPUT -m bpf --bytecode "`nfbpf_compile RAW 'ip proto 6'`" -j ACCEPT</p></li>
</ul><p>You may want to learn more about BPF from FreeBSD's <strong>bpf</strong>(4) manpage.</p>
<h3>cluster</h3>
<p>Allows you to deploy gateway and back-end load-sharing clusters without the need of load-balancers.</p><p>This match requires that all the nodes see the same packets. Thus, the cluster match decides if this node has to handle a packet given the following options:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--cluster-total-nodes</strong> <em>num</em></p>
  </dt>
  <dd>
    <p>Set number of total nodes in cluster.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--cluster-local-node</strong> <em>num</em></p>
  </dt>
  <dd>
    <p>Set the local node number ID.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--cluster-local-nodemask</strong> <em>mask</em></p>
  </dt>
  <dd>
    <p>Set the local node number ID mask. You can use this option instead of <strong>--cluster-local-node</strong>.</p>
  </dd>
  <dt>
    <p><strong>--cluster-hash-seed</strong> <em>value</em></p>
  </dt>
  <dd>
    <p>Set seed value of the Jenkins hash.</p>
  </dd>

</dl>
<p>Example:</p><ul>
<li><p>iptables -A PREROUTING -t mangle -i eth1 -m cluster --cluster-total-nodes 2 --cluster-local-node 1 --cluster-hash-seed 0xdeadbeef -j MARK --set-mark 0xffff</p></li><li><p>iptables -A PREROUTING -t mangle -i eth2 -m cluster --cluster-total-nodes 2 --cluster-local-node 1 --cluster-hash-seed 0xdeadbeef -j MARK --set-mark 0xffff</p></li><li><p>iptables -A PREROUTING -t mangle -i eth1 -m mark ! --mark 0xffff -j DROP</p></li><li><p>iptables -A PREROUTING -t mangle -i eth2 -m mark ! --mark 0xffff -j DROP</p></li>
</ul><p>And the following commands to make all nodes see the same packets:</p><ul>
<li><p>ip maddr add 01:00:5e:00:01:01 dev eth1</p></li><li><p>ip maddr add 01:00:5e:00:01:02 dev eth2</p></li><li><p>arptables -A OUTPUT -o eth1 --h-length 6 -j mangle --mangle-mac-s 01:00:5e:00:01:01</p></li><li><p>arptables -A INPUT -i eth1 --h-length 6 --destination-mac 01:00:5e:00:01:01 -j mangle --mangle-mac-d 00:zz:yy:xx:5a:27</p></li><li><p>arptables -A OUTPUT -o eth2 --h-length 6 -j mangle --mangle-mac-s 01:00:5e:00:01:02</p></li><li><p>arptables -A INPUT -i eth2 --h-length 6 --destination-mac 01:00:5e:00:01:02 -j mangle --mangle-mac-d 00:zz:yy:xx:5a:27</p></li>
</ul><p><strong>NOTE</strong>: the arptables commands above use mainstream syntax. If you are using arptables-jf included in some RedHat, CentOS and Fedora versions, you will hit syntax errors. Therefore, you'll have to adapt these to the arptables-jf syntax to get them working.</p><p>In the case of TCP connections, pickup facility has to be disabled to avoid marking TCP ACK packets coming in the reply direction as valid.</p><ul>
<li><p>echo 0 &gt; /proc/sys/net/netfilter/nf_conntrack_tcp_loose</p></li>
</ul>
<h3>comment</h3>
<p>Allows you to add comments (up to 256 characters) to any rule.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--comment</strong> <em>comment</em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p>Example:</p>
  </dt>
  <dd>
    <p>iptables -A INPUT -i eth1 -m comment --comment "my local LAN"</p>
  </dd>

</dl>

<h3>connbytes</h3>
<p>Match by how many bytes or packets a connection (or one of the two flows constituting the connection) has transferred so far, or by average bytes per packet.</p><p>The counters are 64-bit and are thus not expected to overflow ;)</p><p>The primary use is to detect long-lived downloads and mark them to be scheduled using a lower priority band in traffic control.</p><p>The transferred bytes per connection can also be viewed through `conntrack -L` and accessed via ctnetlink.</p><p>NOTE that for connections which have no accounting information, the match will always return false. The "net.netfilter.nf_conntrack_acct" sysctl flag controls whether <strong>new</strong> connections will be byte/packet counted. Existing connection flows will not be gaining/losing a/the accounting structure when be sysctl flag is flipped.</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--connbytes</strong> <em>from</em>[<strong>:</strong><em>to</em>]</p>
  </dt>
  <dd>
    <p>match packets from a connection whose packets/bytes/average packet size is more than FROM and less than TO bytes/packets. if TO is omitted only FROM check is done. "!" is used to match packets not falling in the range.</p>
  </dd>
  <dt>
    <p><strong>--connbytes-dir</strong> {<strong>original</strong>|<strong>reply</strong>|<strong>both</strong>}</p>
  </dt>
  <dd>
    <p>which packets to consider</p>
  </dd>
  <dt>
    <p><strong>--connbytes-mode</strong> {<strong>packets</strong>|<strong>bytes</strong>|<strong>avgpkt</strong>}</p>
  </dt>
  <dd>
    <p>whether to check the amount of packets, number of bytes transferred or the average size (in bytes) of all packets received so far. Note that when "both" is used together with "avgpkt", and data is going (mainly) only in one direction (for example HTTP), the average packet size will be about half of the actual data packets.</p>
  </dd>
  <dt>
    <p>Example:</p>
  </dt>
  <dd>
    <p>iptables .. -m connbytes --connbytes 10000:100000 --connbytes-dir both --connbytes-mode bytes ...</p>
  </dd>

</dl>

<h3>connlabel</h3>
<p>Module matches or adds connlabels to a connection. connlabels are similar to connmarks, except labels are bit-based; i.e. all labels may be attached to a flow at the same time. Up to 128 unique labels are currently supported.</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--label</strong> <strong>name</strong></p>
  </dt>
  <dd>
    <p>matches if label <strong>name</strong> has been set on a connection. Instead of a name (which will be translated to a number, see EXAMPLE below), a number may be used instead.  Using a number always overrides connlabel.conf.</p>
  </dd>
  <dt>
    <p><strong>--set</strong></p>
  </dt>
  <dd>
    <p>if the label has not been set on the connection, set it. Note that setting a label can fail.  This is because the kernel allocates the conntrack label storage area when the connection is created, and it only reserves the amount of memory required by the ruleset that exists at the time the connection is created. In this case, the match will fail (or succeed, in case <strong>--label</strong> option was negated).</p>
  </dd>

</dl>
<p>This match depends on libnetfilter_conntrack 1.0.4 or later. Label translation is done via the <strong>/etc/xtables/connlabel.conf</strong> configuration file.</p><p>Example:</p><ul>
<li>
<pre>
0	eth0-in
1	eth0-out
2	ppp-in
3	ppp-out
4	bulk-traffic
5	interactive
</pre>
</li>
</ul>
<h3>connlimit</h3>
<p>Allows you to restrict the number of parallel connections to a server per client IP address (or client address block).</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--connlimit-upto</strong> <em>n</em></p>
  </dt>
  <dd>
    <p>Match if the number of existing connections is below or equal <em>n</em>.</p>
  </dd>
  <dt>
    <p><strong>--connlimit-above</strong> <em>n</em></p>
  </dt>
  <dd>
    <p>Match if the number of existing connections is above <em>n</em>.</p>
  </dd>
  <dt>
    <p><strong>--connlimit-mask</strong> <em>prefix_length</em></p>
  </dt>
  <dd>
    <p>Group hosts using the prefix length. For IPv4, this must be a number between (including) 0 and 32. For IPv6, between 0 and 128. If not specified, the maximum prefix length for the applicable protocol is used.</p>
  </dd>
  <dt>
    <p><strong>--connlimit-saddr</strong></p>
  </dt>
  <dd>
    <p>Apply the limit onto the source group. This is the default if --connlimit-daddr is not specified.</p>
  </dd>
  <dt>
    <p><strong>--connlimit-daddr</strong></p>
  </dt>
  <dd>
    <p>Apply the limit onto the destination group.</p>
  </dd>

</dl>
<p>Examples:</p>
<dl class='dl-vertical'>
  <dt>
    <p># allow 2 telnet connections per client host</p>
  </dt>
  <dd>
    <p>iptables -A INPUT -p tcp --syn --dport 23 -m connlimit --connlimit-above 2 -j REJECT</p>
  </dd>
  <dt>
    <p># you can also match the other way around:</p>
  </dt>
  <dd>
    <p>iptables -A INPUT -p tcp --syn --dport 23 -m connlimit --connlimit-upto 2 -j ACCEPT</p>
  </dd>
  <dt>
    <p># limit the number of parallel HTTP requests to 16 per class C sized  source network (24 bit netmask)</p>
  </dt>
  <dd>
    <p>iptables -p tcp --syn --dport 80 -m connlimit --connlimit-above 16 --connlimit-mask 24 -j REJECT</p>
  </dd>
  <dt>
    <p># limit the number of parallel HTTP requests to 16 for the link local network</p>
  </dt>
  <dd>
    <p>(ipv6) ip6tables -p tcp --syn --dport 80 -s fe80::/64 -m connlimit --connlimit-above 16 --connlimit-mask 64 -j REJECT</p>
  </dd>
  <dt>
    <p># Limit the number of connections to a particular host:</p>
  </dt>
  <dd>
    <p>ip6tables -p tcp --syn --dport 49152:65535 -d 2001:db8::1 -m connlimit --connlimit-above 100 -j REJECT</p>
  </dd>

</dl>

<h3>connmark</h3>
<p>This module matches the netfilter mark field associated with a connection (which can be set using the <strong>CONNMARK</strong> target below).</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--mark</strong> <em>value</em>[<strong>/</strong><em>mask</em>]</p>
  </dt>
  <dd>
    <p>Matches packets in connections with the given mark value (if a mask is specified, this is logically ANDed with the mark before the comparison).</p>
  </dd>

</dl>

<h3>conntrack</h3>
<p>This module, when combined with connection tracking, allows access to the connection tracking state for this packet/connection.</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--ctstate</strong> <em>statelist</em></p>
  </dt>
  <dd>
    <p><em>statelist</em> is a comma separated list of the connection states to match. Possible states are listed below.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--ctproto</strong> <em>l4proto</em></p>
  </dt>
  <dd>
    <p>Layer-4 protocol to match (by number or name)</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--ctorigsrc</strong> <em>address</em>[<strong>/</strong><em>mask</em>]</p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--ctorigdst</strong> <em>address</em>[<strong>/</strong><em>mask</em>]</p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--ctreplsrc</strong> <em>address</em>[<strong>/</strong><em>mask</em>]</p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--ctrepldst</strong> <em>address</em>[<strong>/</strong><em>mask</em>]</p>
  </dt>
  <dd>
    <p>Match against original/reply source/destination address</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--ctorigsrcport</strong> <em>port</em>[<strong>:</strong><em>port</em>]</p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--ctorigdstport</strong> <em>port</em>[<strong>:</strong><em>port</em>]</p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--ctreplsrcport</strong> <em>port</em>[<strong>:</strong><em>port</em>]</p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--ctrepldstport</strong> <em>port</em>[<strong>:</strong><em>port</em>]</p>
  </dt>
  <dd>
    <p>Match against original/reply source/destination port (TCP/UDP/etc.) or GRE key. Matching against port ranges is only supported in kernel versions above 2.6.38.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--ctstatus</strong> <em>statelist</em></p>
  </dt>
  <dd>
    <p><em>statuslist</em> is a comma separated list of the connection statuses to match. Possible statuses are listed below.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--ctexpire</strong> <em>time</em>[<strong>:</strong><em>time</em>]</p>
  </dt>
  <dd>
    <p>Match remaining lifetime in seconds against given value or range of values (inclusive)</p>
  </dd>
  <dt>
    <p><strong>--ctdir</strong> {<strong>ORIGINAL</strong>|<strong>REPLY</strong>}</p>
  </dt>
  <dd>
    <p>Match packets that are flowing in the specified direction. If this flag is not specified at all, matches packets in both directions.</p>
  </dd>

</dl>
<p>States for <strong>--ctstate</strong>:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>INVALID</strong></p>
  </dt>
  <dd>
    <p>The packet is associated with no known connection.</p>
  </dd>
  <dt>
    <p><strong>NEW</strong></p>
  </dt>
  <dd>
    <p>The packet has started a new connection or otherwise associated with a connection which has not seen packets in both directions.</p>
  </dd>
  <dt>
    <p><strong>ESTABLISHED</strong></p>
  </dt>
  <dd>
    <p>The packet is associated with a connection which has seen packets in both directions.</p>
  </dd>
  <dt>
    <p><strong>RELATED</strong></p>
  </dt>
  <dd>
    <p>The packet is starting a new connection, but is associated with an existing connection, such as an FTP data transfer or an ICMP error.</p>
  </dd>
  <dt>
    <p><strong>UNTRACKED</strong></p>
  </dt>
  <dd>
    <p>The packet is not tracked at all, which happens if you explicitly untrack it by using -j CT --notrack in the raw table.</p>
  </dd>
  <dt>
    <p><strong>SNAT</strong></p>
  </dt>
  <dd>
    <p>A virtual state, matching if the original source address differs from the reply destination.</p>
  </dd>
  <dt>
    <p><strong>DNAT</strong></p>
  </dt>
  <dd>
    <p>A virtual state, matching if the original destination differs from the reply source.</p>
  </dd>

</dl>
<p>Statuses for <strong>--ctstatus</strong>:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>NONE</strong></p>
  </dt>
  <dd>
    <p>None of the below.</p>
  </dd>
  <dt>
    <p><strong>EXPECTED</strong></p>
  </dt>
  <dd>
    <p>This is an expected connection (i.e. a conntrack helper set it up).</p>
  </dd>
  <dt>
    <p><strong>SEEN_REPLY</strong></p>
  </dt>
  <dd>
    <p>Conntrack has seen packets in both directions.</p>
  </dd>
  <dt>
    <p><strong>ASSURED</strong></p>
  </dt>
  <dd>
    <p>Conntrack entry should never be early-expired.</p>
  </dd>
  <dt>
    <p><strong>CONFIRMED</strong></p>
  </dt>
  <dd>
    <p>Connection is confirmed: originating packet has left box.</p>
  </dd>

</dl>

<h3>cpu</h3>

<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--cpu</strong> <em>number</em></p>
  </dt>
  <dd>
    <p>Match cpu handling this packet. cpus are numbered from 0 to NR_CPUS-1 Can be used in combination with RPS (Remote Packet Steering) or multiqueue NICs to spread network traffic on different queues.</p>
  </dd>

</dl>
<p>Example:</p><p>iptables -t nat -A PREROUTING -p tcp --dport 80 -m cpu --cpu 0 -j REDIRECT --to-port 8080</p><p>iptables -t nat -A PREROUTING -p tcp --dport 80 -m cpu --cpu 1 -j REDIRECT --to-port 8081</p><p>Available since Linux 2.6.36.</p>
<h3>dccp</h3>

<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--source-port</strong>,<strong>--sport</strong> <em>port</em>[<strong>:</strong><em>port</em>]</p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--destination-port</strong>,<strong>--dport</strong> <em>port</em>[<strong>:</strong><em>port</em>]</p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--dccp-types</strong> <em>mask</em></p>
  </dt>
  <dd>
    <p>Match when the DCCP packet type is one of 'mask'. 'mask' is a comma-separated list of packet types.  Packet types are: <strong>REQUEST RESPONSE DATA ACK DATAACK CLOSEREQ CLOSE RESET SYNC SYNCACK INVALID</strong>.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--dccp-option</strong> <em>number</em></p>
  </dt>
  <dd>
    <p>Match if DCCP option set.</p>
  </dd>

</dl>

<h3>devgroup</h3>
<p>Match device group of a packets incoming/outgoing interface.</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--src-group</strong> <em>name</em></p>
  </dt>
  <dd>
    <p>Match device group of incoming device</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--dst-group</strong> <em>name</em></p>
  </dt>
  <dd>
    <p>Match device group of outgoing device</p>
  </dd>

</dl>

<h3>dscp</h3>
<p>This module matches the 6 bit DSCP field within the TOS field in the IP header.  DSCP has superseded TOS within the IETF.</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--dscp</strong> <em>value</em></p>
  </dt>
  <dd>
    <p>Match against a numeric (decimal or hex) value [0-63].</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--dscp-class</strong> <em>class</em></p>
  </dt>
  <dd>
    <p>Match the DiffServ class. This value may be any of the BE, EF, AFxx or CSx classes.  It will then be converted into its according numeric value.</p>
  </dd>

</dl>

<h3>dst (IPv6-specific)</h3>
<p>This module matches the parameters in Destination Options header</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--dst-len</strong> <em>length</em></p>
  </dt>
  <dd>
    <p>Total length of this header in octets.</p>
  </dd>
  <dt>
    <p><strong>--dst-opts</strong> <em>type</em>[<strong>:</strong><em>length</em>][<strong>,</strong><em>type</em>[<strong>:</strong><em>length</em>]...]</p>
  </dt>
  <dd>
    <p>numeric type of option and the length of the option data in octets.</p>
  </dd>

</dl>

<h3>ecn</h3>
<p>This allows you to match the ECN bits of the IPv4/IPv6 and TCP header.  ECN is the Explicit Congestion Notification mechanism as specified in RFC3168</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--ecn-tcp-cwr</strong></p>
  </dt>
  <dd>
    <p>This matches if the TCP ECN CWR (Congestion Window Received) bit is set.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--ecn-tcp-ece</strong></p>
  </dt>
  <dd>
    <p>This matches if the TCP ECN ECE (ECN Echo) bit is set.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--ecn-ip-ect</strong> <em>num</em></p>
  </dt>
  <dd>
    <p>This matches a particular IPv4/IPv6 ECT (ECN-Capable Transport). You have to specify a number between `0' and `3'.</p>
  </dd>

</dl>

<h3>esp</h3>
<p>This module matches the SPIs in ESP header of IPsec packets.</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--espspi</strong> <em>spi</em>[<strong>:</strong><em>spi</em>]</p>
  </dt>
  <dd>
    
  </dd>

</dl>

<h3>eui64 (IPv6-specific)</h3>
<p>This module matches the EUI-64 part of a stateless autoconfigured IPv6 address. It compares the EUI-64 derived from the source MAC address in Ethernet frame with the lower 64 bits of the IPv6 source address. But "Universal/Local" bit is not compared. This module doesn't match other link layer frame, and is only valid in the <strong>PREROUTING</strong>, <strong>INPUT</strong> and <strong>FORWARD</strong> chains.</p>
<h3>frag (IPv6-specific)</h3>
<p>This module matches the parameters in Fragment header.</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--fragid</strong> <em>id</em>[<strong>:</strong><em>id</em>]</p>
  </dt>
  <dd>
    <p>Matches the given Identification or range of it.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--fraglen</strong> <em>length</em></p>
  </dt>
  <dd>
    <p>This option cannot be used with kernel version 2.6.10 or later. The length of Fragment header is static and this option doesn't make sense.</p>
  </dd>
  <dt>
    <p><strong>--fragres</strong></p>
  </dt>
  <dd>
    <p>Matches if the reserved fields are filled with zero.</p>
  </dd>
  <dt>
    <p><strong>--fragfirst</strong></p>
  </dt>
  <dd>
    <p>Matches on the first fragment.</p>
  </dd>
  <dt>
    <p><strong>--fragmore</strong></p>
  </dt>
  <dd>
    <p>Matches if there are more fragments.</p>
  </dd>
  <dt>
    <p><strong>--fraglast</strong></p>
  </dt>
  <dd>
    <p>Matches if this is the last fragment.</p>
  </dd>

</dl>

<h3>hashlimit</h3>
<p><strong>hashlimit</strong> uses hash buckets to express a rate limiting match (like the <strong>limit</strong> match) for a group of connections using a <strong>single</strong> iptables rule. Grouping can be done per-hostgroup (source and/or destination address) and/or per-port. It gives you the ability to express "<em>N</em> packets per time quantum per group" or "<em>N</em> bytes per seconds" (see below for some examples).</p><p>A hash limit option (<strong>--hashlimit-upto</strong>, <strong>--hashlimit-above</strong>) and <strong>--hashlimit-name</strong> are required.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--hashlimit-upto</strong> <em>amount</em>[<strong>/second</strong>|<strong>/minute</strong>|<strong>/hour</strong>|<strong>/day</strong>]</p>
  </dt>
  <dd>
    <p>Match if the rate is below or equal to <em>amount</em>/quantum. It is specified either as a number, with an optional time quantum suffix (the default is 3/hour), or as <em>amount</em>b/second (number of bytes per second).</p>
  </dd>
  <dt>
    <p><strong>--hashlimit-above</strong> <em>amount</em>[<strong>/second</strong>|<strong>/minute</strong>|<strong>/hour</strong>|<strong>/day</strong>]</p>
  </dt>
  <dd>
    <p>Match if the rate is above <em>amount</em>/quantum.</p>
  </dd>
  <dt>
    <p><strong>--hashlimit-burst</strong> <em>amount</em></p>
  </dt>
  <dd>
    <p>Maximum initial number of packets to match: this number gets recharged by one every time the limit specified above is not reached, up to this number; the default is 5.  When byte-based rate matching is requested, this option specifies the amount of bytes that can exceed the given rate.  This option should be used with caution -- if the entry expires, the burst value is reset too.</p>
  </dd>
  <dt>
    <p><strong>--hashlimit-mode</strong> {<strong>srcip</strong>|<strong>srcport</strong>|<strong>dstip</strong>|<strong>dstport</strong>}<strong>,</strong>...</p>
  </dt>
  <dd>
    <p>A comma-separated list of objects to take into consideration. If no --hashlimit-mode option is given, hashlimit acts like limit, but at the expensive of doing the hash housekeeping.</p>
  </dd>
  <dt>
    <p><strong>--hashlimit-srcmask</strong> <em>prefix</em></p>
  </dt>
  <dd>
    <p>When --hashlimit-mode srcip is used, all source addresses encountered will be grouped according to the given prefix length and the so-created subnet will be subject to hashlimit. <em>prefix</em> must be between (inclusive) 0 and 32. Note that --hashlimit-srcmask 0 is basically doing the same thing as not specifying srcip for --hashlimit-mode, but is technically more expensive.</p>
  </dd>
  <dt>
    <p><strong>--hashlimit-dstmask</strong> <em>prefix</em></p>
  </dt>
  <dd>
    <p>Like --hashlimit-srcmask, but for destination addresses.</p>
  </dd>
  <dt>
    <p><strong>--hashlimit-name</strong> <em>foo</em></p>
  </dt>
  <dd>
    <p>The name for the /proc/net/ipt_hashlimit/foo entry.</p>
  </dd>
  <dt>
    <p><strong>--hashlimit-htable-size</strong> <em>buckets</em></p>
  </dt>
  <dd>
    <p>The number of buckets of the hash table</p>
  </dd>
  <dt>
    <p><strong>--hashlimit-htable-max</strong> <em>entries</em></p>
  </dt>
  <dd>
    <p>Maximum entries in the hash.</p>
  </dd>
  <dt>
    <p><strong>--hashlimit-htable-expire</strong> <em>msec</em></p>
  </dt>
  <dd>
    <p>After how many milliseconds do hash entries expire.</p>
  </dd>
  <dt>
    <p><strong>--hashlimit-htable-gcinterval</strong> <em>msec</em></p>
  </dt>
  <dd>
    <p>How many milliseconds between garbage collection intervals.</p>
  </dd>

</dl>
<p>Examples:</p>
<dl class='dl-vertical'>
  <dt>
    <p>matching on source host</p>
  </dt>
  <dd>
    <p>"1000 packets per second for every host in 192.168.0.0/16" =&gt; -s 192.168.0.0/16 --hashlimit-mode srcip --hashlimit-upto 1000/sec</p>
  </dd>
  <dt>
    <p>matching on source port</p>
  </dt>
  <dd>
    <p>"100 packets per second for every service of 192.168.1.1" =&gt; -s 192.168.1.1 --hashlimit-mode srcport --hashlimit-upto 100/sec</p>
  </dd>
  <dt>
    <p>matching on subnet</p>
  </dt>
  <dd>
    <p>"10000 packets per minute for every /28 subnet (groups of 8 addresses) in 10.0.0.0/8" =&gt; -s 10.0.0.0/8 --hashlimit-mask 28 --hashlimit-upto 10000/min</p>
  </dd>
  <dt>
    <p>matching bytes per second</p>
  </dt>
  <dd>
    <p>"flows exceeding 512kbyte/s" =&gt; --hashlimit-mode srcip,dstip,srcport,dstport --hashlimit-above 512kb/s</p>
  </dd>
  <dt>
    <p>matching bytes per second</p>
  </dt>
  <dd>
    <p>"hosts that exceed 512kbyte/s, but permit up to 1Megabytes without matching" --hashlimit-mode dstip --hashlimit-above 512kb/s --hashlimit-burst 1mb</p>
  </dd>

</dl>

<h3>hbh (IPv6-specific)</h3>
<p>This module matches the parameters in Hop-by-Hop Options header</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--hbh-len</strong> <em>length</em></p>
  </dt>
  <dd>
    <p>Total length of this header in octets.</p>
  </dd>
  <dt>
    <p><strong>--hbh-opts</strong> <em>type</em>[<strong>:</strong><em>length</em>][<strong>,</strong><em>type</em>[<strong>:</strong><em>length</em>]...]</p>
  </dt>
  <dd>
    <p>numeric type of option and the length of the option data in octets.</p>
  </dd>

</dl>

<h3>helper</h3>
<p>This module matches packets related to a specific conntrack-helper.</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--helper</strong> <em>string</em></p>
  </dt>
  <dd>
    <p>Matches packets related to the specified conntrack-helper.</p><p>string can be "ftp" for packets related to a ftp-session on default port. For other ports append -portnr to the value, ie. "ftp-2121".</p><p>Same rules apply for other conntrack-helpers.</p>
  </dd>

</dl>

<h3>hl (IPv6-specific)</h3>
<p>This module matches the Hop Limit field in the IPv6 header.</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--hl-eq</strong> <em>value</em></p>
  </dt>
  <dd>
    <p>Matches if Hop Limit equals <em>value</em>.</p>
  </dd>
  <dt>
    <p><strong>--hl-lt</strong> <em>value</em></p>
  </dt>
  <dd>
    <p>Matches if Hop Limit is less than <em>value</em>.</p>
  </dd>
  <dt>
    <p><strong>--hl-gt</strong> <em>value</em></p>
  </dt>
  <dd>
    <p>Matches if Hop Limit is greater than <em>value</em>.</p>
  </dd>

</dl>

<h3>icmp (IPv4-specific)</h3>
<p>This extension can be used if `--protocol icmp' is specified. It provides the following option:</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--icmp-type</strong> {<em>type</em>[<strong>/</strong><em>code</em>]|<em>typename</em>}</p>
  </dt>
  <dd>
    <p>This allows specification of the ICMP type, which can be a numeric ICMP type, type/code pair, or one of the ICMP type names shown by the command</p>
<pre>
 iptables -p icmp -h
</pre>

  </dd>

</dl>

<h3>icmp6 (IPv6-specific)</h3>
<p>This extension can be used if `--protocol ipv6-icmp' or `--protocol icmpv6' is specified. It provides the following option:</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--icmpv6-type</strong> <em>type</em>[<strong>/</strong><em>code</em>]|<em>typename</em></p>
  </dt>
  <dd>
    <p>This allows specification of the ICMPv6 type, which can be a numeric ICMPv6 <em>type</em>, <em>type</em> and <em>code</em>, or one of the ICMPv6 type names shown by the command</p>
<pre>
 ip6tables -p ipv6-icmp -h
</pre>

  </dd>

</dl>

<h3>iprange</h3>
<p>This matches on a given arbitrary range of IP addresses.</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--src-range</strong> <em>from</em>[<strong>-</strong><em>to</em>]</p>
  </dt>
  <dd>
    <p>Match source IP in the specified range.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--dst-range</strong> <em>from</em>[<strong>-</strong><em>to</em>]</p>
  </dt>
  <dd>
    <p>Match destination IP in the specified range.</p>
  </dd>

</dl>

<h3>ipv6header (IPv6-specific)</h3>
<p>This module matches IPv6 extension headers and/or upper layer header.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--soft</strong></p>
  </dt>
  <dd>
    <p>Matches if the packet includes <strong>any</strong> of the headers specified with <strong>--header</strong>.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--header</strong> <em>header</em>[<strong>,</strong><em>header</em>...]</p>
  </dt>
  <dd>
    <p>Matches the packet which EXACTLY includes all specified headers. The headers encapsulated with ESP header are out of scope. Possible <em>header</em> types can be:</p>
  </dd>
  <dt>
    <p><strong>hop</strong>|<strong>hop-by-hop</strong></p>
  </dt>
  <dd>
    <p>Hop-by-Hop Options header</p>
  </dd>
  <dt>
    <p><strong>dst</strong></p>
  </dt>
  <dd>
    <p>Destination Options header</p>
  </dd>
  <dt>
    <p><strong>route</strong></p>
  </dt>
  <dd>
    <p>Routing header</p>
  </dd>
  <dt>
    <p><strong>frag</strong></p>
  </dt>
  <dd>
    <p>Fragment header</p>
  </dd>
  <dt>
    <p><strong>auth</strong></p>
  </dt>
  <dd>
    <p>Authentication header</p>
  </dd>
  <dt>
    <p><strong>esp</strong></p>
  </dt>
  <dd>
    <p>Encapsulating Security Payload header</p>
  </dd>
  <dt>
    <p><strong>none</strong></p>
  </dt>
  <dd>
    <p>No Next header which matches 59 in the 'Next Header field' of IPv6 header or any IPv6 extension headers</p>
  </dd>
  <dt>
    <p><strong>proto</strong></p>
  </dt>
  <dd>
    <p>which matches any upper layer protocol header. A protocol name from /etc/protocols and numeric value also allowed. The number 255 is equivalent to <strong>proto</strong>.</p>
  </dd>

</dl>

<h3>ipvs</h3>
<p>Match IPVS connection properties.</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--ipvs</strong></p>
  </dt>
  <dd>
    <p>packet belongs to an IPVS connection</p>
  </dd>
  <dt>
    <p>Any of the following options implies --ipvs (even negated)</p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--vproto</strong> <em>protocol</em></p>
  </dt>
  <dd>
    <p>VIP protocol to match; by number or name, e.g. "tcp"</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--vaddr</strong> <em>address</em>[<strong>/</strong><em>mask</em>]</p>
  </dt>
  <dd>
    <p>VIP address to match</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--vport</strong> <em>port</em></p>
  </dt>
  <dd>
    <p>VIP port to match; by number or name, e.g. "http"</p>
  </dd>
  <dt>
    <p><strong>--vdir</strong> {<strong>ORIGINAL</strong>|<strong>REPLY</strong>}</p>
  </dt>
  <dd>
    <p>flow direction of packet</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--vmethod</strong> {<strong>GATE</strong>|<strong>IPIP</strong>|<strong>MASQ</strong>}</p>
  </dt>
  <dd>
    <p>IPVS forwarding method used</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--vportctl</strong> <em>port</em></p>
  </dt>
  <dd>
    <p>VIP port of the controlling connection to match, e.g. 21 for FTP</p>
  </dd>

</dl>

<h3>length</h3>
<p>This module matches the length of the layer-3 payload (e.g. layer-4 packet) of a packet against a specific value or range of values.</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--length</strong> <em>length</em>[<strong>:</strong><em>length</em>]</p>
  </dt>
  <dd>
    
  </dd>

</dl>

<h3>limit</h3>
<p>This module matches at a limited rate using a token bucket filter. A rule using this extension will match until this limit is reached. It can be used in combination with the <strong>LOG</strong> target to give limited logging, for example.</p><p>xt_limit has no negation support - you will have to use -m hashlimit ! --hashlimit <em>rate</em> in this case whilst omitting --hashlimit-mode.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--limit</strong> <em>rate</em>[<strong>/second</strong>|<strong>/minute</strong>|<strong>/hour</strong>|<strong>/day</strong>]</p>
  </dt>
  <dd>
    <p>Maximum average matching rate: specified as a number, with an optional `/second', `/minute', `/hour', or `/day' suffix; the default is 3/hour.</p>
  </dd>
  <dt>
    <p><strong>--limit-burst</strong> <em>number</em></p>
  </dt>
  <dd>
    <p>Maximum initial number of packets to match: this number gets recharged by one every time the limit specified above is not reached, up to this number; the default is 5.</p>
  </dd>

</dl>

<h3>mac</h3>

<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--mac-source</strong> <em>address</em></p>
  </dt>
  <dd>
    <p>Match source MAC address.  It must be of the form XX:XX:XX:XX:XX:XX. Note that this only makes sense for packets coming from an Ethernet device and entering the <strong>PREROUTING</strong>, <strong>FORWARD</strong> or <strong>INPUT</strong> chains.</p>
  </dd>

</dl>

<h3>mark</h3>
<p>This module matches the netfilter mark field associated with a packet (which can be set using the <strong>MARK</strong> target below).</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--mark</strong> <em>value</em>[<strong>/</strong><em>mask</em>]</p>
  </dt>
  <dd>
    <p>Matches packets with the given unsigned mark value (if a <em>mask</em> is specified, this is logically ANDed with the <em>mask</em> before the comparison).</p>
  </dd>

</dl>

<h3>mh (IPv6-specific)</h3>
<p>This extension is loaded if `--protocol ipv6-mh' or `--protocol mh' is specified. It provides the following option:</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--mh-type</strong> <em>type</em>[<strong>:</strong><em>type</em>]</p>
  </dt>
  <dd>
    <p>This allows specification of the Mobility Header(MH) type, which can be a numeric MH <em>type</em>, <em>type</em> or one of the MH type names shown by the command</p>
<pre>
 ip6tables -p mh -h
</pre>

  </dd>

</dl>

<h3>multiport</h3>
<p>This module matches a set of source or destination ports.  Up to 15 ports can be specified.  A port range (port:port) counts as two ports.  It can only be used in conjunction with one of the following protocols: <strong>tcp</strong>, <strong>udp</strong>, <strong>udplite</strong>, <strong>dccp</strong> and <strong>sctp</strong>.</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--source-ports</strong>,<strong>--sports</strong> <em>port</em>[<strong>,</strong><em>port</em>|<strong>,</strong><em>port</em><strong>:</strong><em>port</em>]...</p>
  </dt>
  <dd>
    <p>Match if the source port is one of the given ports.  The flag <strong>--sports</strong> is a convenient alias for this option. Multiple ports or port ranges are separated using a comma, and a port range is specified using a colon. <strong>53,1024:65535</strong> would therefore match ports 53 and all from 1024 through 65535.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--destination-ports</strong>,<strong>--dports</strong> <em>port</em>[<strong>,</strong><em>port</em>|<strong>,</strong><em>port</em><strong>:</strong><em>port</em>]...</p>
  </dt>
  <dd>
    <p>Match if the destination port is one of the given ports.  The flag <strong>--dports</strong> is a convenient alias for this option.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--ports</strong> <em>port</em>[<strong>,</strong><em>port</em>|<strong>,</strong><em>port</em><strong>:</strong><em>port</em>]...</p>
  </dt>
  <dd>
    <p>Match if either the source or destination ports are equal to one of the given ports.</p>
  </dd>

</dl>

<h3>nfacct</h3>
<p>The nfacct match provides the extended accounting infrastructure for iptables. You have to use this match together with the standalone user-space utility <a href="../man8/nfacct.8.html"><strong>nfacct</strong>(8)</a></strong></p><p>The only option available for this match is the following:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--nfacct-name</strong> <em>name</em></p>
  </dt>
  <dd>
    <p>This allows you to specify the existing object name that will be use for accounting the traffic that this rule-set is matching.</p>
  </dd>

</dl>
<p>To use this extension, you have to create an accounting object:</p><ul>
<li><p>nfacct add http-traffic</p></li>
</ul><p>Then, you have to attach it to the accounting object via iptables:</p><ul>
<li><p>iptables -I INPUT -p tcp --sport 80 -m nfacct --nfacct-name http-traffic</p></li><li><p>iptables -I OUTPUT -p tcp --dport 80 -m nfacct --nfacct-name http-traffic</p></li>
</ul><p>Then, you can check for the amount of traffic that the rules match:</p><ul>
<li><p>nfacct get http-traffic</p></li><li><p>{ pkts = 00000000000000000156, bytes = 00000000000000151786 } = http-traffic;</p></li>
</ul><p>You can obtain <a href="../man8/nfacct.8.html"><strong>nfacct</strong>(8)</a></strong> from http://www.netfilter.org or, alternatively, from the git.netfilter.org repository.</p>
<h3>osf</h3>
<p>The osf module does passive operating system fingerprinting. This modules compares some data (Window Size, MSS, options and their order, TTL, DF, and others) from packets with the SYN bit set.</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--genre</strong> <em>string</em></p>
  </dt>
  <dd>
    <p>Match an operating system genre by using a passive fingerprinting.</p>
  </dd>
  <dt>
    <p><strong>--ttl</strong> <em>level</em></p>
  </dt>
  <dd>
    <p>Do additional TTL checks on the packet to determine the operating system. <em>level</em> can be one of the following values:</p><ul>
<li><p>0 - True IP address and fingerprint TTL comparison. This generally works for LANs.</p></li><li><p>1 - Check if the IP header's TTL is less than the fingerprint one. Works for globally-routable addresses.</p></li><li><p>2 - Do not compare the TTL at all.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>--log</strong> <em>level</em></p>
  </dt>
  <dd>
    <p>Log determined genres into dmesg even if they do not match the desired one. <em>level</em> can be one of the following values:</p><ul>
<li><p>0 - Log all matched or unknown signatures</p></li><li><p>1 - Log only the first one</p></li><li><p>2 - Log all known matched signatures</p></li>
</ul>
  </dd>

</dl>
<p>You may find something like this in syslog:</p><p>Windows [2000:SP3:Windows XP Pro SP1, 2000 SP3]: 11.22.33.55:4024 -&gt; 11.22.33.44:139 hops=3 Linux [2.5-2.6:] : 1.2.3.4:42624 -&gt; 1.2.3.5:22 hops=4</p><p>OS fingerprints are loadable using the <strong>nfnl_osf</strong> program. To load fingerprints from a file, use:</p><p><strong>nfnl_osf -f /usr/share/xtables/pf.os</strong></p><p>To remove them again,</p><p><strong>nfnl_osf -f /usr/share/xtables/pf.os -d</strong></p><p>The fingerprint database can be downlaoded from http://www.openbsd.org/cgi-bin/cvsweb/src/etc/pf.os .</p>
<h3>owner</h3>
<p>This module attempts to match various characteristics of the packet creator, for locally generated packets. This match is only valid in the OUTPUT and POSTROUTING chains. Forwarded packets do not have any socket associated with them. Packets from kernel threads do have a socket, but usually no owner.</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--uid-owner</strong> <em>username</em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--uid-owner</strong> <em>userid</em>[<strong>-</strong><em>userid</em>]</p>
  </dt>
  <dd>
    <p>Matches if the packet socket's file structure (if it has one) is owned by the given user. You may also specify a numerical UID, or an UID range.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--gid-owner</strong> <em>groupname</em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--gid-owner</strong> <em>groupid</em>[<strong>-</strong><em>groupid</em>]</p>
  </dt>
  <dd>
    <p>Matches if the packet socket's file structure is owned by the given group. You may also specify a numerical GID, or a GID range.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--socket-exists</strong></p>
  </dt>
  <dd>
    <p>Matches if the packet is associated with a socket.</p>
  </dd>

</dl>

<h3>physdev</h3>
<p>This module matches on the bridge port input and output devices enslaved to a bridge device. This module is a part of the infrastructure that enables a transparent bridging IP firewall and is only useful for kernel versions above version 2.5.44.</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--physdev-in</strong> <em>name</em></p>
  </dt>
  <dd>
    <p>Name of a bridge port via which a packet is received (only for packets entering the <strong>INPUT</strong>, <strong>FORWARD</strong> and <strong>PREROUTING</strong> chains). If the interface name ends in a "+", then any interface which begins with this name will match. If the packet didn't arrive through a bridge device, this packet won't match this option, unless '!' is used.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--physdev-out</strong> <em>name</em></p>
  </dt>
  <dd>
    <p>Name of a bridge port via which a packet is going to be sent (for packets entering the <strong>FORWARD</strong>, <strong>OUTPUT</strong> and <strong>POSTROUTING</strong> chains).  If the interface name ends in a "+", then any interface which begins with this name will match. Note that in the <strong>nat</strong> and <strong>mangle</strong> <strong>OUTPUT</strong> chains one cannot match on the bridge output port, however one can in the <strong>filter OUTPUT</strong> chain. If the packet won't leave by a bridge device or if it is yet unknown what the output device will be, then the packet won't match this option, unless '!' is used.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--physdev-is-in</strong></p>
  </dt>
  <dd>
    <p>Matches if the packet has entered through a bridge interface.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--physdev-is-out</strong></p>
  </dt>
  <dd>
    <p>Matches if the packet will leave through a bridge interface.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--physdev-is-bridged</strong></p>
  </dt>
  <dd>
    <p>Matches if the packet is being bridged and therefore is not being routed. This is only useful in the FORWARD and POSTROUTING chains.</p>
  </dd>

</dl>

<h3>pkttype</h3>
<p>This module matches the link-layer packet type.</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--pkt-type</strong> {<strong>unicast</strong>|<strong>broadcast</strong>|<strong>multicast</strong>}</p>
  </dt>
  <dd>
    
  </dd>

</dl>

<h3>policy</h3>
<p>This modules matches the policy used by IPsec for handling a packet.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--dir</strong> {<strong>in</strong>|<strong>out</strong>}</p>
  </dt>
  <dd>
    <p>Used to select whether to match the policy used for decapsulation or the policy that will be used for encapsulation. <strong>in</strong> is valid in the <strong>PREROUTING, INPUT and FORWARD</strong> chains, <strong>out</strong> is valid in the <strong>POSTROUTING, OUTPUT and FORWARD</strong> chains.</p>
  </dd>
  <dt>
    <p><strong>--pol</strong> {<strong>none</strong>|<strong>ipsec</strong>}</p>
  </dt>
  <dd>
    <p>Matches if the packet is subject to IPsec processing. <strong>--pol none</strong> cannot be combined with <strong>--strict</strong>.</p>
  </dd>
  <dt>
    <p><strong>--strict</strong></p>
  </dt>
  <dd>
    <p>Selects whether to match the exact policy or match if any rule of the policy matches the given policy.</p>
  </dd>

</dl>
<p>For each policy element that is to be described, one can use one or more of the following options. When <strong>--strict</strong> is in effect, at least one must be used per element.</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--reqid</strong> <em>id</em></p>
  </dt>
  <dd>
    <p>Matches the reqid of the policy rule. The reqid can be specified with <strong>setkey</strong>(8)</strong> using <strong>unique:id</strong> as level.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--spi</strong> <em>spi</em></p>
  </dt>
  <dd>
    <p>Matches the SPI of the SA.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--proto</strong> {<strong>ah</strong>|<strong>esp</strong>|<strong>ipcomp</strong>}</p>
  </dt>
  <dd>
    <p>Matches the encapsulation protocol.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--mode</strong> {<strong>tunnel</strong>|<strong>transport</strong>}</p>
  </dt>
  <dd>
    <p>Matches the encapsulation mode.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--tunnel-src</strong> <em>addr</em>[<strong>/</strong><em>mask</em>]</p>
  </dt>
  <dd>
    <p>Matches the source end-point address of a tunnel mode SA. Only valid with <strong>--mode tunnel</strong>.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--tunnel-dst</strong> <em>addr</em>[<strong>/</strong><em>mask</em>]</p>
  </dt>
  <dd>
    <p>Matches the destination end-point address of a tunnel mode SA. Only valid with <strong>--mode tunnel</strong>.</p>
  </dd>
  <dt>
    <p><strong>--next</strong></p>
  </dt>
  <dd>
    <p>Start the next element in the policy specification. Can only be used with <strong>--strict</strong>.</p>
  </dd>

</dl>

<h3>quota</h3>
<p>Implements network quotas by decrementing a byte counter with each packet. The condition matches until the byte counter reaches zero. Behavior is reversed with negation (i.e. the condition does not match until the byte counter reaches zero).</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--quota</strong> <em>bytes</em></p>
  </dt>
  <dd>
    <p>The quota in bytes.</p>
  </dd>

</dl>

<h3>rateest</h3>
<p>The rate estimator can match on estimated rates as collected by the RATEEST target. It supports matching on absolute bps/pps values, comparing two rate estimators and matching on the difference between two rate estimators.</p><p>For a better understanding of the available options, these are all possible combinations:</p><ul>
<li><p><strong>rateest</strong> <em>operator</em> <strong>rateest-bps</strong></p></li><li><p><strong>rateest</strong> <em>operator</em> <strong>rateest-pps</strong></p></li><li><p>(<strong>rateest</strong> minus <strong>rateest-bps1</strong>) <em>operator</em> <strong>rateest-bps2</strong></p></li><li><p>(<strong>rateest</strong> minus <strong>rateest-pps1</strong>) <em>operator</em> <strong>rateest-pps2</strong></p></li><li><p><strong>rateest1</strong> <em>operator</em> <strong>rateest2</strong> <strong>rateest-bps</strong>(without rate!)</p></li><li><p><strong>rateest1</strong> <em>operator</em> <strong>rateest2</strong> <strong>rateest-pps</strong>(without rate!)</p></li><li><p>(<strong>rateest1</strong> minus <strong>rateest-bps1</strong>) <em>operator</em> (<strong>rateest2</strong> minus <strong>rateest-bps2</strong>)</p></li><li><p>(<strong>rateest1</strong> minus <strong>rateest-pps1</strong>) <em>operator</em> (<strong>rateest2</strong> minus <strong>rateest-pps2</strong>)</p></li>
</ul>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--rateest-delta</strong></p>
  </dt>
  <dd>
    <p>For each estimator (either absolute or relative mode), calculate the difference between the estimator-determined flow rate and the static value chosen with the BPS/PPS options. If the flow rate is higher than the specified BPS/PPS, 0 will be used instead of a negative value. In other words, "max(0, rateest#_rate - rateest#_bps)" is used.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--rateest-lt</strong></p>
  </dt>
  <dd>
    <p>Match if rate is less than given rate/estimator.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--rateest-gt</strong></p>
  </dt>
  <dd>
    <p>Match if rate is greater than given rate/estimator.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--rateest-eq</strong></p>
  </dt>
  <dd>
    <p>Match if rate is equal to given rate/estimator.</p>
  </dd>

</dl>
<p>In the so-called "absolute mode", only one rate estimator is used and compared against a static value, while in "relative mode", two rate estimators are compared against another.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--rateest</strong> <em>name</em></p>
  </dt>
  <dd>
    <p>Name of the one rate estimator for absolute mode.</p>
  </dd>
  <dt>
    <p><strong>--rateest1</strong> <em>name</em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--rateest2</strong> <em>name</em></p>
  </dt>
  <dd>
    <p>The names of the two rate estimators for relative mode.</p>
  </dd>
  <dt>
    <p><strong>--rateest-bps</strong> [<em>value</em>]</p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--rateest-pps</strong> [<em>value</em>]</p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--rateest-bps1</strong> [<em>value</em>]</p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--rateest-bps2</strong> [<em>value</em>]</p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--rateest-pps1</strong> [<em>value</em>]</p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--rateest-pps2</strong> [<em>value</em>]</p>
  </dt>
  <dd>
    <p>Compare the estimator(s) by bytes or packets per second, and compare against the chosen value. See the above bullet list for which option is to be used in which case. A unit suffix may be used - available ones are: bit, [kmgt]bit, [KMGT]ibit, Bps, [KMGT]Bps, [KMGT]iBps.</p>
  </dd>

</dl>
<p>Example: This is what can be used to route outgoing data connections from an FTP server over two lines based on the available bandwidth at the time the data connection was started:</p><p># Estimate outgoing rates</p><p>iptables -t mangle -A POSTROUTING -o eth0 -j RATEEST --rateest-name eth0 --rateest-interval 250ms --rateest-ewma 0.5s</p><p>iptables -t mangle -A POSTROUTING -o ppp0 -j RATEEST --rateest-name ppp0 --rateest-interval 250ms --rateest-ewma 0.5s</p><p># Mark based on available bandwidth</p><p>iptables -t mangle -A balance -m conntrack --ctstate NEW -m helper --helper ftp -m rateest --rateest-delta --rateest1 eth0 --rateest-bps1 2.5mbit --rateest-gt --rateest2 ppp0 --rateest-bps2 2mbit -j CONNMARK --set-mark 1</p><p>iptables -t mangle -A balance -m conntrack --ctstate NEW -m helper --helper ftp -m rateest --rateest-delta --rateest1 ppp0 --rateest-bps1 2mbit --rateest-gt --rateest2 eth0 --rateest-bps2 2.5mbit -j CONNMARK --set-mark 2</p><p>iptables -t mangle -A balance -j CONNMARK --restore-mark</p>
<h3>realm (IPv4-specific)</h3>
<p>This matches the routing realm.  Routing realms are used in complex routing setups involving dynamic routing protocols like BGP.</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--realm</strong> <em>value</em>[<strong>/</strong><em>mask</em>]</p>
  </dt>
  <dd>
    <p>Matches a given realm number (and optionally mask). If not a number, value can be a named realm from /etc/iproute2/rt_realms (mask can not be used in that case).</p>
  </dd>

</dl>

<h3>recent</h3>
<p>Allows you to dynamically create a list of IP addresses and then match against that list in a few different ways.</p><p>For example, you can create a "badguy" list out of people attempting to connect to port 139 on your firewall and then DROP all future packets from them without considering them.</p><p><strong>--set</strong>, <strong>--rcheck</strong>, <strong>--update</strong> and <strong>--remove</strong> are mutually exclusive.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--name</strong> <em>name</em></p>
  </dt>
  <dd>
    <p>Specify the list to use for the commands. If no name is given then <strong>DEFAULT</strong> will be used.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--set</strong></p>
  </dt>
  <dd>
    <p>This will add the source address of the packet to the list. If the source address is already in the list, this will update the existing entry. This will always return success (or failure if <strong>!</strong> is passed in).</p>
  </dd>
  <dt>
    <p><strong>--rsource</strong></p>
  </dt>
  <dd>
    <p>Match/save the source address of each packet in the recent list table. This is the default.</p>
  </dd>
  <dt>
    <p><strong>--rdest</strong></p>
  </dt>
  <dd>
    <p>Match/save the destination address of each packet in the recent list table.</p>
  </dd>
  <dt>
    <p><strong>--mask</strong> <em>netmask</em></p>
  </dt>
  <dd>
    <p>Netmask that will be applied to this recent list.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--rcheck</strong></p>
  </dt>
  <dd>
    <p>Check if the source address of the packet is currently in the list.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--update</strong></p>
  </dt>
  <dd>
    <p>Like <strong>--rcheck</strong>, except it will update the "last seen" timestamp if it matches.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--remove</strong></p>
  </dt>
  <dd>
    <p>Check if the source address of the packet is currently in the list and if so that address will be removed from the list and the rule will return true. If the address is not found, false is returned.</p>
  </dd>
  <dt>
    <p><strong>--seconds</strong> <em>seconds</em></p>
  </dt>
  <dd>
    <p>This option must be used in conjunction with one of <strong>--rcheck</strong> or <strong>--update</strong>. When used, this will narrow the match to only happen when the address is in the list and was seen within the last given number of seconds.</p>
  </dd>
  <dt>
    <p><strong>--reap</strong></p>
  </dt>
  <dd>
    <p>This option can only be used in conjunction with <strong>--seconds</strong>. When used, this will cause entries older than the last given number of seconds to be purged.</p>
  </dd>
  <dt>
    <p><strong>--hitcount</strong> <em>hits</em></p>
  </dt>
  <dd>
    <p>This option must be used in conjunction with one of <strong>--rcheck</strong> or <strong>--update</strong>. When used, this will narrow the match to only happen when the address is in the list and packets had been received greater than or equal to the given value. This option may be used along with <strong>--seconds</strong> to create an even narrower match requiring a certain number of hits within a specific time frame. The maximum value for the hitcount parameter is given by the "ip_pkt_list_tot" parameter of the xt_recent kernel module. Exceeding this value on the command line will cause the rule to be rejected.</p>
  </dd>
  <dt>
    <p><strong>--rttl</strong></p>
  </dt>
  <dd>
    <p>This option may only be used in conjunction with one of <strong>--rcheck</strong> or <strong>--update</strong>. When used, this will narrow the match to only happen when the address is in the list and the TTL of the current packet matches that of the packet which hit the <strong>--set</strong> rule. This may be useful if you have problems with people faking their source address in order to DoS you via this module by disallowing others access to your site by sending bogus packets to you.</p>
  </dd>

</dl>
<p>Examples:</p><ul>
<li><p>iptables -A FORWARD -m recent --name badguy --rcheck --seconds 60 -j DROP</p></li><li><p>iptables -A FORWARD -p tcp -i eth0 --dport 139 -m recent --name badguy --set -j DROP</p></li>
</ul><p><strong>/proc/net/xt_recent/*</strong> are the current lists of addresses and information about each entry of each list.</p><p>Each file in <strong>/proc/net/xt_recent/</strong> can be read from to see the current list or written two using the following commands to modify the list:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>echo +</strong><em>addr</em><strong> &gt;/proc/net/xt_recent/DEFAULT</strong></p>
  </dt>
  <dd>
    <p>to add <em>addr</em> to the DEFAULT list</p>
  </dd>
  <dt>
    <p><strong>echo -</strong><em>addr</em><strong> &gt;/proc/net/xt_recent/DEFAULT</strong></p>
  </dt>
  <dd>
    <p>to remove <em>addr</em> from the DEFAULT list</p>
  </dd>
  <dt>
    <p><strong>echo / &gt;/proc/net/xt_recent/DEFAULT</strong></p>
  </dt>
  <dd>
    <p>to flush the DEFAULT list (remove all entries).</p>
  </dd>

</dl>
<p>The module itself accepts parameters, defaults shown:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>ip_list_tot</strong>=<em>100</em></p>
  </dt>
  <dd>
    <p>Number of addresses remembered per table.</p>
  </dd>
  <dt>
    <p><strong>ip_pkt_list_tot</strong>=<em>20</em></p>
  </dt>
  <dd>
    <p>Number of packets per address remembered.</p>
  </dd>
  <dt>
    <p><strong>ip_list_hash_size</strong>=<em>0</em></p>
  </dt>
  <dd>
    <p>Hash table size. 0 means to calculate it based on ip_list_tot, default: 512.</p>
  </dd>
  <dt>
    <p><strong>ip_list_perms</strong>=<em>0644</em></p>
  </dt>
  <dd>
    <p>Permissions for /proc/net/xt_recent/* files.</p>
  </dd>
  <dt>
    <p><strong>ip_list_uid</strong>=<em>0</em></p>
  </dt>
  <dd>
    <p>Numerical UID for ownership of /proc/net/xt_recent/* files.</p>
  </dd>
  <dt>
    <p><strong>ip_list_gid</strong>=<em>0</em></p>
  </dt>
  <dd>
    <p>Numerical GID for ownership of /proc/net/xt_recent/* files.</p>
  </dd>

</dl>

<h3>rpfilter</h3>
<p>Performs a reverse path filter test on a packet. If a reply to the packet would be sent via the same interface that the packet arrived on, the packet will match. Note that, unlike the in-kernel rp_filter, packets protected by IPSec are not treated specially.  Combine this match with the policy match if you want this. Also, packets arriving via the loopback interface are always permitted. This match can only be used in the PREROUTING chain of the raw or mangle table.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--loose</strong></p>
  </dt>
  <dd>
    <p>Used to specifiy that the reverse path filter test should match even if the selected output device is not the expected one.</p>
  </dd>
  <dt>
    <p><strong>--validmark</strong></p>
  </dt>
  <dd>
    <p>Also use the packets' nfmark value when performing the reverse path route lookup.</p>
  </dd>
  <dt>
    <p><strong>--accept-local</strong></p>
  </dt>
  <dd>
    <p>This will permit packets arriving from the network with a source address that is also assigned to the local machine.</p>
  </dd>
  <dt>
    <p><strong>--invert</strong></p>
  </dt>
  <dd>
    <p>This will invert the sense of the match.  Instead of matching packets that passed the reverse path filter test, match those that have failed it.</p>
  </dd>

</dl>
<p>Example to log and drop packets failing the reverse path filter test:</p><p>iptables -t raw -N RPFILTER</p><p>iptables -t raw -A RPFILTER -m rpfilter -j RETURN</p><p>iptables -t raw -A RPFILTER -m limit --limit 10/minute -j NFLOG --nflog-prefix "rpfilter drop"</p><p>iptables -t raw -A RPFILTER -j DROP</p><p>iptables -t raw -A PREROUTING -j RPFILTER</p><p>Example to drop failed packets, without logging:</p><p>iptables -t raw -A RPFILTER -m rpfilter --invert -j DROP</p>
<h3>rt (IPv6-specific)</h3>
<p>Match on IPv6 routing header</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--rt-type</strong> <em>type</em></p>
  </dt>
  <dd>
    <p>Match the type (numeric).</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--rt-segsleft</strong> <em>num</em>[<strong>:</strong><em>num</em>]</p>
  </dt>
  <dd>
    <p>Match the `segments left' field (range).</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--rt-len</strong> <em>length</em></p>
  </dt>
  <dd>
    <p>Match the length of this header.</p>
  </dd>
  <dt>
    <p><strong>--rt-0-res</strong></p>
  </dt>
  <dd>
    <p>Match the reserved field, too (type=0)</p>
  </dd>
  <dt>
    <p><strong>--rt-0-addrs</strong> <em>addr</em>[<strong>,</strong><em>addr</em>...]</p>
  </dt>
  <dd>
    <p>Match type=0 addresses (list).</p>
  </dd>
  <dt>
    <p><strong>--rt-0-not-strict</strong></p>
  </dt>
  <dd>
    <p>List of type=0 addresses is not a strict list.</p>
  </dd>

</dl>

<h3>sctp</h3>
<p>This module matches Stream Control Transmission Protocol headers.</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--source-port</strong>,<strong>--sport</strong> <em>port</em>[<strong>:</strong><em>port</em>]</p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--destination-port</strong>,<strong>--dport</strong> <em>port</em>[<strong>:</strong><em>port</em>]</p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--chunk-types</strong> {<strong>all</strong>|<strong>any</strong>|<strong>only</strong>} <em>chunktype</em>[<strong>:</strong><em>flags</em>] [...]</p>
  </dt>
  <dd>
    <p>The flag letter in upper case indicates that the flag is to match if set, in the lower case indicates to match if unset.</p><p>Chunk types: DATA INIT INIT_ACK SACK HEARTBEAT HEARTBEAT_ACK ABORT SHUTDOWN SHUTDOWN_ACK ERROR COOKIE_ECHO COOKIE_ACK ECN_ECNE ECN_CWR SHUTDOWN_COMPLETE ASCONF ASCONF_ACK FORWARD_TSN</p><p>chunk type            available flags</p><p>DATA                  I U B E i u b e</p><p>ABORT                 T t</p><p>SHUTDOWN_COMPLETE     T t</p><p>(lowercase means flag should be "off", uppercase means "on")</p>
  </dd>

</dl>
<p>Examples:</p><p>iptables -A INPUT -p sctp --dport 80 -j DROP</p><p>iptables -A INPUT -p sctp --chunk-types any DATA,INIT -j DROP</p><p>iptables -A INPUT -p sctp --chunk-types any DATA:Be -j ACCEPT</p>
<h3>set</h3>
<p>This module matches IP sets which can be defined by <a href="../man8/ipset.8.html"><strong>ipset</strong>(8)</a>.</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--match-set</strong> <em>setname</em> <em>flag</em>[<strong>,</strong><em>flag</em>]...</p>
  </dt>
  <dd>
    <p>where flags are the comma separated list of <strong>src</strong> and/or <strong>dst</strong> specifications and there can be no more than six of them. Hence the command</p><ul>
<li><p> iptables -A FORWARD -m set --match-set test src,dst</p></li><li><p>will match packets, for which (if the set type is ipportmap) the source address and destination port pair can be found in the specified set. If the set type of the specified set is single dimension (for example ipmap), then the command will match packets for which the source address can be found in the specified set.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>--return-nomatch</strong></p>
  </dt>
  <dd>
    <p>If the <strong>--return-nomatch</strong> option is specified and the set type supports the <strong>nomatch</strong> flag, then the matching is reversed: a match with an element flagged with <strong>nomatch</strong> returns <strong>true</strong>, while a match with a plain element returns <strong>false</strong>.</p>
  </dd>
  <dt>
    <p><strong>!</strong> <strong>--update-counters</strong></p>
  </dt>
  <dd>
    <p>If the <strong>--update-counters</strong> flag is negated, then the packet and byte counters of the matching element in the set won't be updated. Default the packet and byte counters are updated.</p>
  </dd>
  <dt>
    <p><strong>!</strong> <strong>--update-subcounters</strong></p>
  </dt>
  <dd>
    <p>If the <strong>--update-subcounters</strong> flag is negated, then the packet and byte counters of the matching element in the member set of a list type of set won't be updated. Default the packet and byte counters are updated.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--packets-eq</strong> <em>value</em></p>
  </dt>
  <dd>
    <p>If the packet is matched an element in the set, match only if the packet counter of the element matches the given value too.</p>
  </dd>
  <dt>
    <p><strong>--packets-lt</strong> <em>value</em></p>
  </dt>
  <dd>
    <p>If the packet is matched an element in the set, match only if the packet counter of the element is less than the given value as well.</p>
  </dd>
  <dt>
    <p><strong>--packets-gt</strong> <em>value</em></p>
  </dt>
  <dd>
    <p>If the packet is matched an element in the set, match only if the packet counter of the element is greater than the given value as well.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>-bytes-eq</strong> <em>value</em></p>
  </dt>
  <dd>
    <p>If the packet is matched an element in the set, match only if the byte counter of the element matches the given value too.</p>
  </dd>
  <dt>
    <p><strong>--bytes-lt</strong> <em>value</em></p>
  </dt>
  <dd>
    <p>If the packet is matched an element in the set, match only if the byte counter of the element is less than the given value as well.</p>
  </dd>
  <dt>
    <p><strong>--bytes-gt</strong> <em>value</em></p>
  </dt>
  <dd>
    <p>If the packet is matched an element in the set, match only if the byte counter of the element is greater than the given value as well.</p>
  </dd>

</dl>
<p>The packet and byte counters related options and flags are ignored when the set was defined without counter support.</p><p>The option <strong>--match-set</strong> can be replaced by <strong>--set</strong> if that does not clash with an option of other extensions.</p><p>Use of -m set requires that ipset kernel support is provided, which, for standard kernels, is the case since Linux 2.6.39.</p>
<h3>socket</h3>
<p>This matches if an open TCP/UDP socket can be found by doing a socket lookup on the packet. It matches if there is an established or non-zero bound listening socket (possibly with a non-local address). The lookup is performed using the <strong>packet</strong> tuple of TCP/UDP packets, or the original TCP/UDP header <strong>embedded</strong> in an ICMP/ICPMv6 error packet.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--transparent</strong></p>
  </dt>
  <dd>
    <p>Ignore non-transparent sockets.</p>
  </dd>
  <dt>
    <p><strong>--nowildcard</strong></p>
  </dt>
  <dd>
    <p>Do not ignore sockets bound to 'any' address. The socket match won't accept zero-bound listeners by default, since then local services could intercept traffic that would otherwise be forwarded. This option therefore has security implications when used to match traffic being forwarded to redirect such packets to local machine with policy routing. When using the socket match to implement fully transparent proxies bound to non-local addresses it is recommended to use the --transparent option instead.</p>
  </dd>

</dl>
<p>Example (assuming packets with mark 1 are delivered locally):</p><ul>
<li><p>-t mangle -A PREROUTING -m socket --transparent -j MARK --set-mark 1</p></li>
</ul>
<h3>state</h3>
<p>The "state" extension is a subset of the "conntrack" module. "state" allows access to the connection tracking state for this packet.</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--state</strong> <em>state</em></p>
  </dt>
  <dd>
    <p>Where state is a comma separated list of the connection states to match. Only a subset of the states unterstood by "conntrack" are recognized: <strong>INVALID</strong>, <strong>ESTABLISHED</strong>, <strong>NEW</strong>, <strong>RELATED</strong> or <strong>UNTRACKED</strong>. For their description, see the "conntrack" heading in this manpage.</p>
  </dd>

</dl>

<h3>statistic</h3>
<p>This module matches packets based on some statistic condition. It supports two distinct modes settable with the <strong>--mode</strong> option.</p><p>Supported options:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--mode</strong> <em>mode</em></p>
  </dt>
  <dd>
    <p>Set the matching mode of the matching rule, supported modes are <strong>random</strong> and <strong>nth.</strong></p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--probability</strong> <em>p</em></p>
  </dt>
  <dd>
    <p>Set the probability for a packet to be randomly matched. It only works with the <strong>random</strong> mode. <em>p</em> must be within 0.0 and 1.0. The supported granularity is in 1/2147483648th increments.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--every</strong> <em>n</em></p>
  </dt>
  <dd>
    <p>Match one packet every nth packet. It works only with the <strong>nth</strong> mode (see also the <strong>--packet</strong> option).</p>
  </dd>
  <dt>
    <p><strong>--packet</strong> <em>p</em></p>
  </dt>
  <dd>
    <p>Set the initial counter value (0 &lt;= p &lt;= n-1, default 0) for the <strong>nth</strong> mode.</p>
  </dd>

</dl>

<h3>string</h3>
<p>This modules matches a given string by using some pattern matching strategy. It requires a linux kernel &gt;= 2.6.14.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--algo</strong> {<strong>bm</strong>|<strong>kmp</strong>}</p>
  </dt>
  <dd>
    <p>Select the pattern matching strategy. (bm = Boyer-Moore, kmp = Knuth-Pratt-Morris)</p>
  </dd>
  <dt>
    <p><strong>--from</strong> <em>offset</em></p>
  </dt>
  <dd>
    <p>Set the offset from which it starts looking for any matching. If not passed, default is 0.</p>
  </dd>
  <dt>
    <p><strong>--to</strong> <em>offset</em></p>
  </dt>
  <dd>
    <p>Set the offset up to which should be scanned. That is, byte <em>offset</em>-1 (counting from 0) is the last one that is scanned. If not passed, default is the packet size.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--string</strong> <em>pattern</em></p>
  </dt>
  <dd>
    <p>Matches the given pattern.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--hex-string</strong> <em>pattern</em></p>
  </dt>
  <dd>
    <p>Matches the given pattern in hex notation.</p>
  </dd>
  <dt>
    <p>Examples:</p>
  </dt>
  <dd>
    <ul>
<li><p># The string pattern can be used for simple text characters.</p><p>iptables -A INPUT -p tcp --dport 80 -m string --algo bm --string 'GET /index.html' -j LOG</p></li><li><p># The hex string pattern can be used for non-printable characters, like |0D 0A| or |0D0A|.</p><p>iptables -p udp --dport 53 -m string --algo bm --from 40 --to 57 --hex-string '|03|www|09|netfilter|03|org|00|'</p></li>
</ul>
  </dd>

</dl>

<h3>tcp</h3>
<p>These extensions can be used if `--protocol tcp' is specified. It provides the following options:</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--source-port</strong>,<strong>--sport</strong> <em>port</em>[<strong>:</strong><em>port</em>]</p>
  </dt>
  <dd>
    <p>Source port or port range specification. This can either be a service name or a port number. An inclusive range can also be specified, using the format <em>first</em><strong>:</strong><em>last</em>. If the first port is omitted, "0" is assumed; if the last is omitted, "65535" is assumed. If the first port is greater than the second one they will be swapped. The flag <strong>--sport</strong> is a convenient alias for this option.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--destination-port</strong>,<strong>--dport</strong> <em>port</em>[<strong>:</strong><em>port</em>]</p>
  </dt>
  <dd>
    <p>Destination port or port range specification.  The flag <strong>--dport</strong> is a convenient alias for this option.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--tcp-flags</strong> <em>mask</em> <em>comp</em></p>
  </dt>
  <dd>
    <p>Match when the TCP flags are as specified.  The first argument <em>mask</em> is the flags which we should examine, written as a comma-separated list, and the second argument <em>comp</em> is a comma-separated list of flags which must be set.  Flags are: <strong>SYN ACK FIN RST URG PSH ALL NONE</strong>. Hence the command</p>
<pre>
 iptables -A FORWARD -p tcp --tcp-flags SYN,ACK,FIN,RST SYN
</pre>
<p>will only match packets with the SYN flag set, and the ACK, FIN and RST flags unset.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--syn</strong></p>
  </dt>
  <dd>
    <p>Only match TCP packets with the SYN bit set and the ACK,RST and FIN bits cleared.  Such packets are used to request TCP connection initiation; for example, blocking such packets coming in an interface will prevent incoming TCP connections, but outgoing TCP connections will be unaffected. It is equivalent to <strong>--tcp-flags SYN,RST,ACK,FIN SYN</strong>. If the "!" flag precedes the "--syn", the sense of the option is inverted.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--tcp-option</strong> <em>number</em></p>
  </dt>
  <dd>
    <p>Match if TCP option set.</p>
  </dd>

</dl>

<h3>tcpmss</h3>
<p>This matches the TCP MSS (maximum segment size) field of the TCP header.  You can only use this on TCP SYN or SYN/ACK packets, since the MSS is only negotiated during the TCP handshake at connection startup time.</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--mss</strong> <em>value</em>[<strong>:</strong><em>value</em>]</p>
  </dt>
  <dd>
    <p>Match a given TCP MSS value or range.</p>
  </dd>

</dl>

<h3>time</h3>
<p>This matches if the packet arrival time/date is within a given range. All options are optional, but are ANDed when specified. All times are interpreted as UTC by default.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--datestart</strong> <em>YYYY</em>[<strong>-</strong><em>MM</em>[<strong>-</strong><em>DD</em>[<strong>T</strong><em>hh</em>[<strong>:</strong><em>mm</em>[<strong>:</strong><em>ss</em>]]]]]</p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--datestop</strong> <em>YYYY</em>[<strong>-</strong><em>MM</em>[<strong>-</strong><em>DD</em>[<strong>T</strong><em>hh</em>[<strong>:</strong><em>mm</em>[<strong>:</strong><em>ss</em>]]]]]</p>
  </dt>
  <dd>
    <p>Only match during the given time, which must be in ISO 8601 "T" notation. The possible time range is 1970-01-01T00:00:00 to 2038-01-19T04:17:07.</p><ul>
<li><p>If --datestart or --datestop are not specified, it will default to 1970-01-01 and 2038-01-19, respectively.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>--timestart</strong> <em>hh</em><strong>:</strong><em>mm</em>[<strong>:</strong><em>ss</em>]</p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--timestop</strong> <em>hh</em><strong>:</strong><em>mm</em>[<strong>:</strong><em>ss</em>]</p>
  </dt>
  <dd>
    <p>Only match during the given daytime. The possible time range is 00:00:00 to 23:59:59. Leading zeroes are allowed (e.g. "06:03") and correctly interpreted as base-10.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--monthdays</strong> <em>day</em>[<strong>,</strong><em>day</em>...]</p>
  </dt>
  <dd>
    <p>Only match on the given days of the month. Possible values are <strong>1</strong> to <strong>31</strong>. Note that specifying <strong>31</strong> will of course not match on months which do not have a 31st day; the same goes for 28- or 29-day February.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--weekdays</strong> <em>day</em>[<strong>,</strong><em>day</em>...]</p>
  </dt>
  <dd>
    <p>Only match on the given weekdays. Possible values are <strong>Mon</strong>, <strong>Tue</strong>, <strong>Wed</strong>, <strong>Thu</strong>, <strong>Fri</strong>, <strong>Sat</strong>, <strong>Sun</strong>, or values from <strong>1</strong> to <strong>7</strong>, respectively. You may also use two-character variants (<strong>Mo</strong>, <strong>Tu</strong>, etc.).</p>
  </dd>
  <dt>
    <p><strong>--contiguous</strong></p>
  </dt>
  <dd>
    <p>When <strong>--timestop</strong> is smaller than <strong>--timestart</strong> value, match this as a single time period instead distinct intervals.  See EXAMPLES.</p>
  </dd>
  <dt>
    <p><strong>--kerneltz</strong></p>
  </dt>
  <dd>
    <p>Use the kernel timezone instead of UTC to determine whether a packet meets the time regulations.</p>
  </dd>

</dl>
<p>About kernel timezones: Linux keeps the system time in UTC, and always does so. On boot, system time is initialized from a referential time source. Where this time source has no timezone information, such as the x86 CMOS RTC, UTC will be assumed. If the time source is however not in UTC, userspace should provide the correct system time and timezone to the kernel once it has the information.</p><p>Local time is a feature on top of the (timezone independent) system time. Each process has its own idea of local time, specified via the TZ environment variable. The kernel also has its own timezone offset variable. The TZ userspace environment variable specifies how the UTC-based system time is displayed, e.g. when you run <a href="../man1/date.1.html"><strong>date</strong>(1)</a>, or what you see on your desktop clock. The TZ string may resolve to different offsets at different dates, which is what enables the automatic time-jumping in userspace. when DST changes. The kernel's timezone offset variable is used when it has to convert between non-UTC sources, such as FAT filesystems, to UTC (since the latter is what the rest of the system uses).</p><p>The caveat with the kernel timezone is that Linux distributions may ignore to set the kernel timezone, and instead only set the system time. Even if a particular distribution does set the timezone at boot, it is usually does not keep the kernel timezone offset - which is what changes on DST - up to date. ntpd will not touch the kernel timezone, so running it will not resolve the issue. As such, one may encounter a timezone that is always +0000, or one that is wrong half of the time of the year. As such, <strong>using --kerneltz is highly</strong> discouraged.</p><p>EXAMPLES. To match on weekends, use:</p><ul>
<li><p>-m time --weekdays Sa,Su</p></li>
</ul><p>Or, to match (once) on a national holiday block:</p><ul>
<li><p>-m time --datestart 2007-12-24 --datestop 2007-12-27</p></li>
</ul><p>Since the stop time is actually inclusive, you would need the following stop time to not match the first second of the new day:</p><ul>
<li><p>-m time --datestart 2007-01-01T17:00 --datestop 2007-01-01T23:59:59</p></li>
</ul><p>During lunch hour:</p><ul>
<li><p>-m time --timestart 12:30 --timestop 13:30</p></li>
</ul><p>The fourth Friday in the month:</p><ul>
<li><p>-m time --weekdays Fr --monthdays 22,23,24,25,26,27,28</p></li>
</ul><p>(Note that this exploits a certain mathematical property. It is not possible to say "fourth Thursday OR fourth Friday" in one rule. It is possible with multiple rules, though.)</p><p>Matching across days might not do what is expected.  For instance,</p><ul>
<li><p>-m time --weekdays Mo --timestart 23:00  --timestop 01:00 Will match Monday, for one hour from midnight to 1 a.m., and then again for another hour from 23:00 onwards.  If this is unwanted, e.g. if you would like 'match for two hours from Montay 23:00 onwards' you need to also specify the --contiguous option in the example above.</p></li>
</ul>
<h3>tos</h3>
<p>This module matches the 8-bit Type of Service field in the IPv4 header (i.e. including the "Precedence" bits) or the (also 8-bit) Priority field in the IPv6 header.</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--tos</strong> <em>value</em>[<strong>/</strong><em>mask</em>]</p>
  </dt>
  <dd>
    <p>Matches packets with the given TOS mark value. If a mask is specified, it is logically ANDed with the TOS mark before the comparison.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--tos</strong> <em>symbol</em></p>
  </dt>
  <dd>
    <p>You can specify a symbolic name when using the tos match for IPv4. The list of recognized TOS names can be obtained by calling iptables with <strong>-m tos -h</strong>. Note that this implies a mask of 0x3F, i.e. all but the ECN bits.</p>
  </dd>

</dl>

<h3>ttl (IPv4-specific)</h3>
<p>This module matches the time to live field in the IP header.</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--ttl-eq</strong> <em>ttl</em></p>
  </dt>
  <dd>
    <p>Matches the given TTL value.</p>
  </dd>
  <dt>
    <p><strong>--ttl-gt</strong> <em>ttl</em></p>
  </dt>
  <dd>
    <p>Matches if TTL is greater than the given TTL value.</p>
  </dd>
  <dt>
    <p><strong>--ttl-lt</strong> <em>ttl</em></p>
  </dt>
  <dd>
    <p>Matches if TTL is less than the given TTL value.</p>
  </dd>

</dl>

<h3>u32</h3>
<p>U32 tests whether quantities of up to 4 bytes extracted from a packet have specified values. The specification of what to extract is general enough to find data at given offsets from tcp headers or payloads.</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--u32</strong> <em>tests</em></p>
  </dt>
  <dd>
    <p>The argument amounts to a program in a small language described below.</p><ul>
<li><p>tests := location "=" value | tests "&&" location "=" value</p></li><li><p>value := range | value "," range</p></li><li><p>range := number | number ":" number</p></li>
</ul>
  </dd>

</dl>
<p>a single number, <em>n</em>, is interpreted the same as <em>n:n</em>. <em>n:m</em> is interpreted as the range of numbers <strong>&gt;=n</strong> and <strong>&lt;=m</strong>.</p><ul>
<li><p>location := number | location operator number</p></li><li><p>operator := "&" | "&lt;&lt;" | "&gt;&gt;" | "@"</p></li>
</ul><p>The operators <strong>&</strong>, <strong>&lt;&lt;</strong>, <strong>&gt;&gt;</strong> and <strong>&&</strong> mean the same as in C. The <strong>=</strong> is really a set membership operator and the value syntax describes a set. The <strong>@</strong> operator is what allows moving to the next header and is described further below.</p><p>There are currently some artificial implementation limits on the size of the tests:</p>
<dl class='dl-vertical'>
  <dt>
        *
  </dt>
  <dd>
    <p>no more than 10 of "<strong>=</strong>" (and 9 "<strong>&&</strong>"s) in the u32 argument</p>
  </dd>
  <dt>
        *
  </dt>
  <dd>
    <p>no more than 10 ranges (and 9 commas) per value</p>
  </dd>
  <dt>
        *
  </dt>
  <dd>
    <p>no more than 10 numbers (and 9 operators) per location</p>
  </dd>

</dl>
<p>To describe the meaning of location, imagine the following machine that interprets it. There are three registers:</p><ul>
<li><p>A is of type <strong>char *</strong>, initially the address of the IP header</p></li><li><p>B and C are unsigned 32 bit integers, initially zero</p></li>
</ul><p>The instructions are:</p><ul>
<li><p>number B = number;</p></li><li><p>C = (*(A+B)&lt;&lt;24) + (*(A+B+1)&lt;&lt;16) + (*(A+B+2)&lt;&lt;8) + *(A+B+3)</p></li><li><p>&number C = C & number</p></li><li><p>&lt;&lt; number C = C &lt;&lt; number</p></li><li><p>&gt;&gt; number C = C &gt;&gt; number</p></li><li><p>@number A = A + C; then do the instruction number</p></li>
</ul><p>Any access of memory outside [skb-&gt;data,skb-&gt;end] causes the match to fail. Otherwise the result of the computation is the final value of C.</p><p>Whitespace is allowed but not required in the tests. However, the characters that do occur there are likely to require shell quoting, so it is a good idea to enclose the arguments in quotes.</p><p>Example:</p><ul>
<li><p>match IP packets with total length &gt;= 256</p></li><li><p>The IP header contains a total length field in bytes 2-3.</p></li><li><p>--u32 "<strong>0 & 0xFFFF = 0x100:0xFFFF</strong>"</p></li><li><p>read bytes 0-3</p></li><li><p>AND that with 0xFFFF (giving bytes 2-3), and test whether that is in the range [0x100:0xFFFF]</p></li>
</ul><p>Example: (more realistic, hence more complicated)</p><ul>
<li><p>match ICMP packets with icmp type 0</p></li><li><p>First test that it is an ICMP packet, true iff byte 9 (protocol) = 1</p></li><li><p>--u32 "<strong>6 & 0xFF = 1 &&</strong> ...</p></li><li><p>read bytes 6-9, use <strong>&</strong> to throw away bytes 6-8 and compare the result to 1. Next test that it is not a fragment. (If so, it might be part of such a packet but we cannot always tell.) N.B.: This test is generally needed if you want to match anything beyond the IP header. The last 6 bits of byte 6 and all of byte 7 are 0 iff this is a complete packet (not a fragment). Alternatively, you can allow first fragments by only testing the last 5 bits of byte 6.</p></li><li><p> ... <strong>4 & 0x3FFF = 0 &&</strong> ...</p></li><li><p>Last test: the first byte past the IP header (the type) is 0. This is where we have to use the @syntax. The length of the IP header (IHL) in 32 bit words is stored in the right half of byte 0 of the IP header itself.</p></li><li><p> ... <strong>0 &gt;&gt; 22 & 0x3C @ 0 &gt;&gt; 24 = 0</strong>"</p></li><li><p>The first 0 means read bytes 0-3, <strong>&gt;&gt;22</strong> means shift that 22 bits to the right. Shifting 24 bits would give the first byte, so only 22 bits is four times that plus a few more bits. <strong>&3C</strong> then eliminates the two extra bits on the right and the first four bits of the first byte. For instance, if IHL=5, then the IP header is 20 (4 x 5) bytes long. In this case, bytes 0-1 are (in binary) xxxx0101 yyzzzzzz, <strong>&gt;&gt;22</strong> gives the 10 bit value xxxx0101yy and <strong>&3C</strong> gives 010100. <strong>@</strong> means to use this number as a new offset into the packet, and read four bytes starting from there. This is the first 4 bytes of the ICMP payload, of which byte 0 is the ICMP type. Therefore, we simply shift the value 24 to the right to throw out all but the first byte and compare the result with 0.</p></li>
</ul><p>Example:</p><ul>
<li><p>TCP payload bytes 8-12 is any of 1, 2, 5 or 8</p></li><li><p>First we test that the packet is a tcp packet (similar to ICMP).</p></li><li><p>--u32 "<strong>6 & 0xFF = 6 &&</strong> ...</p></li><li><p>Next, test that it is not a fragment (same as above).</p></li><li><p> ... <strong>0 &gt;&gt; 22 & 0x3C @ 12 &gt;&gt; 26 & 0x3C @ 8 = 1,2,5,8</strong>"</p></li><li><p><strong>0&gt;&gt;22&3C</strong> as above computes the number of bytes in the IP header. <strong>@</strong> makes this the new offset into the packet, which is the start of the TCP header. The length of the TCP header (again in 32 bit words) is the left half of byte 12 of the TCP header. The <strong>12&gt;&gt;26&3C</strong> computes this length in bytes (similar to the IP header before). "@" makes this the new offset, which is the start of the TCP payload. Finally, 8 reads bytes 8-12 of the payload and <strong>=</strong> checks whether the result is any of 1, 2, 5 or 8.</p></li>
</ul>
<h3>udp</h3>
<p>These extensions can be used if `--protocol udp' is specified. It provides the following options:</p>
<dl class='dl-vertical'>
  <dt>
    <p>[<strong>!</strong>] <strong>--source-port</strong>,<strong>--sport</strong> <em>port</em>[<strong>:</strong><em>port</em>]</p>
  </dt>
  <dd>
    <p>Source port or port range specification. See the description of the <strong>--source-port</strong> option of the TCP extension for details.</p>
  </dd>
  <dt>
    <p>[<strong>!</strong>] <strong>--destination-port</strong>,<strong>--dport</strong> <em>port</em>[<strong>:</strong><em>port</em>]</p>
  </dt>
  <dd>
    <p>Destination port or port range specification. See the description of the <strong>--destination-port</strong> option of the TCP extension for details.</p>
  </dd>

</dl>

<h3>unclean (IPv4-specific)</h3>
<p>This module takes no options, but attempts to match packets which seem malformed or unusual.  This is regarded as experimental.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TARGET EXTENSIONS</h2>
        <div class="sectioncontent">
<p>iptables can use extended target modules: the following are included in the standard distribution.</p><h3>AUDIT</h3>
<p>This target allows creates audit records for packets hitting the target. It can be used to record accepted, dropped, and rejected packets. See <a href="../man8/auditd.8.html"><strong>auditd</strong>(8)</a> for additional details.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--type</strong> {<strong>accept</strong>|<strong>drop</strong>|<strong>reject</strong>}</p>
  </dt>
  <dd>
    <p>Set type of audit record.</p>
  </dd>

</dl>
<p>Example:</p><ul>
<li><p>iptables -N AUDIT_DROP</p></li><li><p>iptables -A AUDIT_DROP -j AUDIT --type drop</p></li><li><p>iptables -A AUDIT_DROP -j DROP</p></li>
</ul>
<h3>CHECKSUM</h3>
<p>This target selectively works around broken/old applications. It can only be used in the mangle table.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--checksum-fill</strong></p>
  </dt>
  <dd>
    <p>Compute and fill in the checksum in a packet that lacks a checksum. This is particularly useful, if you need to work around old applications such as dhcp clients, that do not work well with checksum offloads, but don't want to disable checksum offload in your device.</p>
  </dd>

</dl>

<h3>CLASSIFY</h3>
<p>This module allows you to set the skb-&gt;priority value (and thus classify the packet into a specific CBQ class).</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--set-class</strong> <em>major</em><strong>:</strong><em>minor</em></p>
  </dt>
  <dd>
    <p>Set the major and minor class value. The values are always interpreted as hexadecimal even if no 0x prefix is given.</p>
  </dd>

</dl>

<h3>CLUSTERIP (IPv4-specific)</h3>
<p>This module allows you to configure a simple cluster of nodes that share a certain IP and MAC address without an explicit load balancer in front of them.  Connections are statically distributed between the nodes in this cluster.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--new</strong></p>
  </dt>
  <dd>
    <p>Create a new ClusterIP.  You always have to set this on the first rule for a given ClusterIP.</p>
  </dd>
  <dt>
    <p><strong>--hashmode</strong> <em>mode</em></p>
  </dt>
  <dd>
    <p>Specify the hashing mode.  Has to be one of <strong>sourceip</strong>, <strong>sourceip-sourceport</strong>, <strong>sourceip-sourceport-destport</strong>.</p>
  </dd>
  <dt>
    <p><strong>--clustermac</strong> <em>mac</em></p>
  </dt>
  <dd>
    <p>Specify the ClusterIP MAC address. Has to be a link-layer multicast address</p>
  </dd>
  <dt>
    <p><strong>--total-nodes</strong> <em>num</em></p>
  </dt>
  <dd>
    <p>Number of total nodes within this cluster.</p>
  </dd>
  <dt>
    <p><strong>--local-node</strong> <em>num</em></p>
  </dt>
  <dd>
    <p>Local node number within this cluster.</p>
  </dd>
  <dt>
    <p><strong>--hash-init</strong> <em>rnd</em></p>
  </dt>
  <dd>
    <p>Specify the random seed used for hash initialization.</p>
  </dd>

</dl>

<h3>CONNMARK</h3>
<p>This module sets the netfilter mark value associated with a connection. The mark is 32 bits wide.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--set-xmark</strong> <em>value</em>[<strong>/</strong><em>mask</em>]</p>
  </dt>
  <dd>
    <p>Zero out the bits given by <em>mask</em> and XOR <em>value</em> into the ctmark.</p>
  </dd>
  <dt>
    <p><strong>--save-mark</strong> [<strong>--nfmask</strong> <em>nfmask</em>] [<strong>--ctmask</strong> <em>ctmask</em>]</p>
  </dt>
  <dd>
    <p>Copy the packet mark (nfmark) to the connection mark (ctmark) using the given masks. The new nfmark value is determined as follows:</p><ul>
<li><p>ctmark = (ctmark & ~ctmask) ^ (nfmark & nfmask)</p></li><li><p>i.e. <em>ctmask</em> defines what bits to clear and <em>nfmask</em> what bits of the nfmark to XOR into the ctmark. <em>ctmask</em> and <em>nfmask</em> default to 0xFFFFFFFF.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>--restore-mark</strong> [<strong>--nfmask</strong> <em>nfmask</em>] [<strong>--ctmask</strong> <em>ctmask</em>]</p>
  </dt>
  <dd>
    <p>Copy the connection mark (ctmark) to the packet mark (nfmark) using the given masks. The new ctmark value is determined as follows:</p><ul>
<li><p>nfmark = (nfmark & ~<em>nfmask</em>) ^ (ctmark & <em>ctmask</em>);</p></li><li><p>i.e. <em>nfmask</em> defines what bits to clear and <em>ctmask</em> what bits of the ctmark to XOR into the nfmark. <em>ctmask</em> and <em>nfmask</em> default to 0xFFFFFFFF.</p></li><li><p><strong>--restore-mark</strong> is only valid in the <strong>mangle</strong> table.</p></li>
</ul>
  </dd>

</dl>
<p>The following mnemonics are available for <strong>--set-xmark</strong>:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--and-mark</strong> <em>bits</em></p>
  </dt>
  <dd>
    <p>Binary AND the ctmark with <em>bits</em>. (Mnemonic for <strong>--set-xmark</strong> 0/<em>invbits</em>, where <em>invbits</em> is the binary negation of <em>bits</em>.)</p>
  </dd>
  <dt>
    <p><strong>--or-mark</strong> <em>bits</em></p>
  </dt>
  <dd>
    <p>Binary OR the ctmark with <em>bits</em>. (Mnemonic for <strong>--set-xmark</strong> <em>bits</em><strong>/</strong><em>bits</em>.)</p>
  </dd>
  <dt>
    <p><strong>--xor-mark</strong> <em>bits</em></p>
  </dt>
  <dd>
    <p>Binary XOR the ctmark with <em>bits</em>. (Mnemonic for <strong>--set-xmark</strong> <em>bits</em><strong>/0</strong>.)</p>
  </dd>
  <dt>
    <p><strong>--set-mark</strong> <em>value</em>[<strong>/</strong><em>mask</em>]</p>
  </dt>
  <dd>
    <p>Set the connection mark. If a mask is specified then only those bits set in the mask are modified.</p>
  </dd>
  <dt>
    <p><strong>--save-mark</strong> [<strong>--mask</strong> <em>mask</em>]</p>
  </dt>
  <dd>
    <p>Copy the nfmark to the ctmark. If a mask is specified, only those bits are copied.</p>
  </dd>
  <dt>
    <p><strong>--restore-mark</strong> [<strong>--mask</strong> <em>mask</em>]</p>
  </dt>
  <dd>
    <p>Copy the ctmark to the nfmark. If a mask is specified, only those bits are copied. This is only valid in the <strong>mangle</strong> table.</p>
  </dd>

</dl>

<h3>CONNSECMARK</h3>
<p>This module copies security markings from packets to connections (if unlabeled), and from connections back to packets (also only if unlabeled).  Typically used in conjunction with SECMARK, it is valid in the <strong>security</strong> table (for backwards compatibility with older kernels, it is also valid in the <strong>mangle</strong> table).</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--save</strong></p>
  </dt>
  <dd>
    <p>If the packet has a security marking, copy it to the connection if the connection is not marked.</p>
  </dd>
  <dt>
    <p><strong>--restore</strong></p>
  </dt>
  <dd>
    <p>If the packet does not have a security marking, and the connection does, copy the security marking from the connection to the packet.</p>
  </dd>

</dl>

<h3>CT</h3>
<p>The CT target sets parameters for a packet or its associated connection. The target attaches a "template" connection tracking entry to the packet, which is then used by the conntrack core when initializing a new ct entry. This target is thus only valid in the "raw" table.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--notrack</strong></p>
  </dt>
  <dd>
    <p>Disables connection tracking for this packet.</p>
  </dd>
  <dt>
    <p><strong>--helper</strong> <em>name</em></p>
  </dt>
  <dd>
    <p>Use the helper identified by <em>name</em> for the connection. This is more flexible than loading the conntrack helper modules with preset ports.</p>
  </dd>
  <dt>
    <p><strong>--ctevents</strong> <em>event</em>[<strong>,</strong>...]</p>
  </dt>
  <dd>
    <p>Only generate the specified conntrack events for this connection. Possible event types are: <strong>new</strong>, <strong>related</strong>, <strong>destroy</strong>, <strong>reply</strong>, <strong>assured</strong>, <strong>protoinfo</strong>, <strong>helper</strong>, <strong>mark</strong> (this refers to the ctmark, not nfmark), <strong>natseqinfo</strong>, <strong>secmark</strong> (ctsecmark).</p>
  </dd>
  <dt>
    <p><strong>--expevents</strong> <em>event</em>[<strong>,</strong>...]</p>
  </dt>
  <dd>
    <p>Only generate the specified expectation events for this connection. Possible event types are: <strong>new</strong>.</p>
  </dd>
  <dt>
    <p><strong>--zone</strong> <em>id</em></p>
  </dt>
  <dd>
    <p>Assign this packet to zone <em>id</em> and only have lookups done in that zone. By default, packets have zone 0.</p>
  </dd>
  <dt>
    <p><strong>--timeout</strong> <em>name</em></p>
  </dt>
  <dd>
    <p>Use the timeout policy identified by <em>name</em> for the connection. This is provides more flexible timeout policy definition than global timeout values available at /proc/sys/net/netfilter/nf_conntrack_*_timeout_*.</p>
  </dd>

</dl>

<h3>DNAT</h3>
<p>This target is only valid in the <strong>nat</strong> table, in the <strong>PREROUTING</strong> and <strong>OUTPUT</strong> chains, and user-defined chains which are only called from those chains.  It specifies that the destination address of the packet should be modified (and all future packets in this connection will also be mangled), and rules should cease being examined.  It takes the following options:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--to-destination</strong> [<em>ipaddr</em>[<strong>-</strong><em>ipaddr</em>]][<strong>:</strong><em>port</em>[<strong>-</strong><em>port</em>]]</p>
  </dt>
  <dd>
    <p>which can specify a single new destination IP address, an inclusive range of IP addresses. Optionally a port range, if the rule also specifies one of the following protocols: <strong>tcp</strong>, <strong>udp</strong>, <strong>dccp</strong> or <strong>sctp</strong>. If no port range is specified, then the destination port will never be modified. If no IP address is specified then only the destination port will be modified. In Kernels up to 2.6.10 you can add several --to-destination options. For those kernels, if you specify more than one destination address, either via an address range or multiple --to-destination options, a simple round-robin (one after another in cycle) load balancing takes place between these addresses. Later Kernels (&gt;= 2.6.11-rc1) don't have the ability to NAT to multiple ranges anymore.</p>
  </dd>
  <dt>
    <p><strong>--random</strong></p>
  </dt>
  <dd>
    <p>If option <strong>--random</strong> is used then port mapping will be randomized (kernel &gt;= 2.6.22).</p>
  </dd>
  <dt>
    <p><strong>--persistent</strong></p>
  </dt>
  <dd>
    <p>Gives a client the same source-/destination-address for each connection. This supersedes the SAME target. Support for persistent mappings is available from 2.6.29-rc2.</p>
  </dd>
  <dt>
    <p>IPv6 support available since Linux kernels &gt;= 3.7.</p>
  </dt>
  <dd>
    
  </dd>

</dl>

<h3>DNPT (IPv6-specific)</h3>
<p>Provides stateless destination IPv6-to-IPv6 Network Prefix Translation (as described by RFC 6296).</p><p>You have to use this target in the <strong>mangle</strong> table, not in the <strong>nat</strong> table. It takes the following options:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--src-pfx</strong> [<em>prefix/</em><em>length]</em></p>
  </dt>
  <dd>
    <p>Set source prefix that you want to translate and length</p>
  </dd>
  <dt>
    <p><strong>--dst-pfx</strong> [<em>prefix/</em><em>length]</em></p>
  </dt>
  <dd>
    <p>Set destination prefix that you want to use in the translation and length</p>
  </dd>

</dl>
<p>You have to use the SNPT target to undo the translation. Example:</p><ul>
<li><p>ip6tables -t mangle -I POSTROUTING -s fd00::/64 \! -o vboxnet0 -j SNPT --src-pfx fd00::/64 --dst-pfx 2001:e20:2000:40f::/64</p></li><li><p>ip6tables -t mangle -I PREROUTING -i wlan0 -d 2001:e20:2000:40f::/64 -j DNPT --src-pfx 2001:e20:2000:40f::/64 --dst-pfx fd00::/64</p></li>
</ul><p>You may need to enable IPv6 neighbor proxy:</p><ul>
<li><p>sysctl -w net.ipv6.conf.all.proxy_ndp=1</p></li>
</ul><p>You also have to use the <strong>NOTRACK</strong> target to disable connection tracking for translated flows.</p>
<h3>DSCP</h3>
<p>This target alters the value of the DSCP bits within the TOS header of the IPv4 packet.  As this manipulates a packet, it can only be used in the mangle table.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--set-dscp</strong> <em>value</em></p>
  </dt>
  <dd>
    <p>Set the DSCP field to a numerical value (can be decimal or hex)</p>
  </dd>
  <dt>
    <p><strong>--set-dscp-class</strong> <em>class</em></p>
  </dt>
  <dd>
    <p>Set the DSCP field to a DiffServ class.</p>
  </dd>

</dl>

<h3>ECN (IPv4-specific)</h3>
<p>This target selectively works around known ECN blackholes. It can only be used in the mangle table.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--ecn-tcp-remove</strong></p>
  </dt>
  <dd>
    <p>Remove all ECN bits from the TCP header.  Of course, it can only be used in conjunction with <strong>-p tcp</strong>.</p>
  </dd>

</dl>

<h3>HL (IPv6-specific)</h3>
<p>This is used to modify the Hop Limit field in IPv6 header. The Hop Limit field is similar to what is known as TTL value in IPv4.  Setting or incrementing the Hop Limit field can potentially be very dangerous, so it should be avoided at any cost. This target is only valid in <strong>mangle</strong> table.</p><p><strong>Don't ever set or increment the value on packets that leave your local network!</strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--hl-set</strong> <em>value</em></p>
  </dt>
  <dd>
    <p>Set the Hop Limit to `value'.</p>
  </dd>
  <dt>
    <p><strong>--hl-dec</strong> <em>value</em></p>
  </dt>
  <dd>
    <p>Decrement the Hop Limit `value' times.</p>
  </dd>
  <dt>
    <p><strong>--hl-inc</strong> <em>value</em></p>
  </dt>
  <dd>
    <p>Increment the Hop Limit `value' times.</p>
  </dd>

</dl>

<h3>HMARK</h3>
<p>Like MARK, i.e. set the fwmark, but the mark is calculated from hashing packet selector at choice. You have also to specify the mark range and, optionally, the offset to start from. ICMP error messages are inspected and used to calculate the hashing.</p><p>Existing options are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--hmark-tuple</strong> tuple<em></em></p>
  </dt>
  <dd>
    <p>Possible tuple members are: <strong>src</strong> meaning source address (IPv4, IPv6 address), <strong>dst</strong> meaning destination address (IPv4, IPv6 address), <strong>sport</strong> meaning source port (TCP, UDP, UDPlite, SCTP, DCCP), <strong>dport</strong> meaning destination port (TCP, UDP, UDPlite, SCTP, DCCP), <strong>spi</strong> meaning Security Parameter Index (AH, ESP), and <strong>ct</strong> meaning the usage of the conntrack tuple instead of the packet selectors.</p>
  </dd>
  <dt>
    <p><strong>--hmark-mod</strong> <em>value (must be &gt; 0)</em></p>
  </dt>
  <dd>
    <p>Modulus for hash calculation (to limit the range of possible marks)</p>
  </dd>
  <dt>
    <p><strong>--hmark-offset</strong> <em>value</em></p>
  </dt>
  <dd>
    <p>Offset to start marks from.</p>
  </dd>
  <dt>
    <p>For advanced usage, instead of using --hmark-tuple, you can specify custom</p>
  </dt>
  <dd>
    <p>prefixes and masks:</p>
  </dd>
  <dt>
    <p><strong>--hmark-src-prefix</strong> <em>cidr</em></p>
  </dt>
  <dd>
    <p>The source address mask in CIDR notation.</p>
  </dd>
  <dt>
    <p><strong>--hmark-dst-prefix</strong> <em>cidr</em></p>
  </dt>
  <dd>
    <p>The destination address mask in CIDR notation.</p>
  </dd>
  <dt>
    <p><strong>--hmark-sport-mask</strong> <em>value</em></p>
  </dt>
  <dd>
    <p>A 16 bit source port mask in hexadecimal.</p>
  </dd>
  <dt>
    <p><strong>--hmark-dport-mask</strong> <em>value</em></p>
  </dt>
  <dd>
    <p>A 16 bit destination port mask in hexadecimal.</p>
  </dd>
  <dt>
    <p><strong>--hmark-spi-mask</strong> <em>value</em></p>
  </dt>
  <dd>
    <p>A 32 bit field with spi mask.</p>
  </dd>
  <dt>
    <p><strong>--hmark-proto-mask</strong> <em>value</em></p>
  </dt>
  <dd>
    <p>An 8 bit field with layer 4 protocol number.</p>
  </dd>
  <dt>
    <p><strong>--hmark-rnd</strong> <em>value</em></p>
  </dt>
  <dd>
    <p>A 32 bit random custom value to feed hash calculation.</p>
  </dd>

</dl>
<p><em>Examples:</em></p><p>iptables -t mangle -A PREROUTING -m conntrack --ctstate NEW  -j HMARK --hmark-tuple ct,src,dst,proto --hmark-offset 10000 --hmark-mod 10 --hmark-rnd 0xfeedcafe</p><p>iptables -t mangle -A PREROUTING -j HMARK --hmark-offset 10000 --hmark-tuple src,dst,proto --hmark-mod 10 --hmark-rnd 0xdeafbeef</p>
<h3>IDLETIMER</h3>
<p>This target can be used to identify when interfaces have been idle for a certain period of time.  Timers are identified by labels and are created when a rule is set with a new label.  The rules also take a timeout value (in seconds) as an option.  If more than one rule uses the same timer label, the timer will be restarted whenever any of the rules get a hit.  One entry for each timer is created in sysfs.  This attribute contains the timer remaining for the timer to expire.  The attributes are located under the xt_idletimer class:</p><p>/sys/class/xt_idletimer/timers/&lt;label&gt;</p><p>When the timer expires, the target module sends a sysfs notification to the userspace, which can then decide what to do (eg. disconnect to save power).</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--timeout</strong> <em>amount</em></p>
  </dt>
  <dd>
    <p>This is the time in seconds that will trigger the notification.</p>
  </dd>
  <dt>
    <p><strong>--label</strong> <em>string</em></p>
  </dt>
  <dd>
    <p>This is a unique identifier for the timer.  The maximum length for the label string is 27 characters.</p>
  </dd>

</dl>

<h3>LED</h3>
<p>This creates an LED-trigger that can then be attached to system indicator lights, to blink or illuminate them when certain packets pass through the system. One example might be to light up an LED for a few minutes every time an SSH connection is made to the local machine. The following options control the trigger behavior:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--led-trigger-id</strong> <em>name</em></p>
  </dt>
  <dd>
    <p>This is the name given to the LED trigger. The actual name of the trigger will be prefixed with "netfilter-".</p>
  </dd>
  <dt>
    <p><strong>--led-delay</strong> <em>ms</em></p>
  </dt>
  <dd>
    <p>This indicates how long (in milliseconds) the LED should be left illuminated when a packet arrives before being switched off again. The default is 0 (blink as fast as possible.) The special value <em>inf</em> can be given to leave the LED on permanently once activated. (In this case the trigger will need to be manually detached and reattached to the LED device to switch it off again.)</p>
  </dd>
  <dt>
    <p><strong>--led-always-blink</strong></p>
  </dt>
  <dd>
    <p>Always make the LED blink on packet arrival, even if the LED is already on. This allows notification of new packets even with long delay values (which otherwise would result in a silent prolonging of the delay time.)</p>
  </dd>
  <dt>
    <p>Example:</p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p>Create an LED trigger for incoming SSH traffic:</p>
  </dt>
  <dd>
    <p>iptables -A INPUT -p tcp --dport 22 -j LED --led-trigger-id ssh</p>
  </dd>
  <dt>
    <p>Then attach the new trigger to an LED:</p>
  </dt>
  <dd>
    <p>echo netfilter-ssh &gt;/sys/class/leds/<em>ledname</em>/trigger</p>
  </dd>

</dl>

<h3>LOG</h3>
<p>Turn on kernel logging of matching packets.  When this option is set for a rule, the Linux kernel will print some information on all matching packets (like most IP/IPv6 header fields) via the kernel log (where it can be read with <a href="../man1/dmesg.1.html"><strong>dmesg</strong>(1)</a></em> or read in the syslog).</p><p>This is a "non-terminating target", i.e. rule traversal continues at the next rule.  So if you want to LOG the packets you refuse, use two separate rules with the same matching criteria, first using target LOG then DROP (or REJECT).</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--log-level</strong> <em>level</em></p>
  </dt>
  <dd>
    <p>Level of logging, which can be (system-specific) numeric or a mnemonic. Possible values are (in decreasing order of priority): <strong>emerg</strong>, <strong>alert</strong>, <strong>crit</strong>, <strong>error</strong>, <strong>warning</strong>, <strong>notice</strong>, <strong>info</strong> or <strong>debug</strong>.</p>
  </dd>
  <dt>
    <p><strong>--log-prefix</strong> <em>prefix</em></p>
  </dt>
  <dd>
    <p>Prefix log messages with the specified prefix; up to 29 letters long, and useful for distinguishing messages in the logs.</p>
  </dd>
  <dt>
    <p><strong>--log-tcp-sequence</strong></p>
  </dt>
  <dd>
    <p>Log TCP sequence numbers. This is a security risk if the log is readable by users.</p>
  </dd>
  <dt>
    <p><strong>--log-tcp-options</strong></p>
  </dt>
  <dd>
    <p>Log options from the TCP packet header.</p>
  </dd>
  <dt>
    <p><strong>--log-ip-options</strong></p>
  </dt>
  <dd>
    <p>Log options from the IP/IPv6 packet header.</p>
  </dd>
  <dt>
    <p><strong>--log-uid</strong></p>
  </dt>
  <dd>
    <p>Log the userid of the process which generated the packet.</p>
  </dd>

</dl>

<h3>MARK</h3>
<p>This target is used to set the Netfilter mark value associated with the packet. It can, for example, be used in conjunction with routing based on fwmark (needs iproute2). If you plan on doing so, note that the mark needs to be set in the PREROUTING chain of the mangle table to affect routing. The mark field is 32 bits wide.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--set-xmark</strong> <em>value</em>[<strong>/</strong><em>mask</em>]</p>
  </dt>
  <dd>
    <p>Zeroes out the bits given by <em>mask</em> and XORs <em>value</em> into the packet mark ("nfmark"). If <em>mask</em> is omitted, 0xFFFFFFFF is assumed.</p>
  </dd>
  <dt>
    <p><strong>--set-mark</strong> <em>value</em>[<strong>/</strong><em>mask</em>]</p>
  </dt>
  <dd>
    <p>Zeroes out the bits given by <em>mask</em> and ORs <em>value</em> into the packet mark. If <em>mask</em> is omitted, 0xFFFFFFFF is assumed.</p>
  </dd>

</dl>
<p>The following mnemonics are available:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--and-mark</strong> <em>bits</em></p>
  </dt>
  <dd>
    <p>Binary AND the nfmark with <em>bits</em>. (Mnemonic for <strong>--set-xmark</strong> 0/<em>invbits</em>, where <em>invbits</em> is the binary negation of <em>bits</em>.)</p>
  </dd>
  <dt>
    <p><strong>--or-mark</strong> <em>bits</em></p>
  </dt>
  <dd>
    <p>Binary OR the nfmark with <em>bits</em>. (Mnemonic for <strong>--set-xmark</strong> <em>bits</em><strong>/</strong><em>bits</em>.)</p>
  </dd>
  <dt>
    <p><strong>--xor-mark</strong> <em>bits</em></p>
  </dt>
  <dd>
    <p>Binary XOR the nfmark with <em>bits</em>. (Mnemonic for <strong>--set-xmark</strong> <em>bits</em><strong>/0</strong>.)</p>
  </dd>

</dl>

<h3>MASQUERADE</h3>
<p>This target is only valid in the <strong>nat</strong> table, in the <strong>POSTROUTING</strong> chain.  It should only be used with dynamically assigned IP (dialup) connections: if you have a static IP address, you should use the SNAT target.  Masquerading is equivalent to specifying a mapping to the IP address of the interface the packet is going out, but also has the effect that connections are <em>forgotten</em> when the interface goes down.  This is the correct behavior when the next dialup is unlikely to have the same interface address (and hence any established connections are lost anyway).</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--to-ports</strong> <em>port</em>[<strong>-</strong><em>port</em>]</p>
  </dt>
  <dd>
    <p>This specifies a range of source ports to use, overriding the default <strong>SNAT</strong> source port-selection heuristics (see above).  This is only valid if the rule also specifies one of the following protocols: <strong>tcp</strong>, <strong>udp</strong>, <strong>dccp</strong> or <strong>sctp</strong>.</p>
  </dd>
  <dt>
    <p><strong>--random</strong></p>
  </dt>
  <dd>
    <p>Randomize source port mapping If option <strong>--random</strong> is used then port mapping will be randomized (kernel &gt;= 2.6.21).</p>
  </dd>
  <dt>
    <p>IPv6 support available since Linux kernels &gt;= 3.7.</p>
  </dt>
  <dd>
    
  </dd>

</dl>

<h3>MIRROR (IPv4-specific)</h3>
<p>This is an experimental demonstration target which inverts the source and destination fields in the IP header and retransmits the packet. It is only valid in the <strong>INPUT</strong>, <strong>FORWARD</strong> and <strong>PREROUTING</strong> chains, and user-defined chains which are only called from those chains.  Note that the outgoing packets are <strong>NOT</strong> seen by any packet filtering chains, connection tracking or NAT, to avoid loops and other problems.</p>
<h3>NETMAP</h3>
<p>This target allows you to statically map a whole network of addresses onto another network of addresses.  It can only be used from rules in the <strong>nat</strong> table.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--to</strong> <em>address</em>[<strong>/</strong><em>mask</em>]</p>
  </dt>
  <dd>
    <p>Network address to map to.  The resulting address will be constructed in the following way: All 'one' bits in the mask are filled in from the new `address'. All bits that are zero in the mask are filled in from the original address.</p>
  </dd>
  <dt>
    <p>IPv6 support available since Linux kernels &gt;= 3.7.</p>
  </dt>
  <dd>
    
  </dd>

</dl>

<h3>NFLOG</h3>
<p>This target provides logging of matching packets. When this target is set for a rule, the Linux kernel will pass the packet to the loaded logging backend to log the packet. This is usually used in combination with nfnetlink_log as logging backend, which will multicast the packet through a <em>netlink</em> socket to the specified multicast group. One or more userspace processes may subscribe to the group to receive the packets. Like LOG, this is a non-terminating target, i.e. rule traversal continues at the next rule.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--nflog-group</strong> <em>nlgroup</em></p>
  </dt>
  <dd>
    <p>The netlink group (0 - 2^16-1) to which packets are (only applicable for nfnetlink_log). The default value is 0.</p>
  </dd>
  <dt>
    <p><strong>--nflog-prefix</strong> <em>prefix</em></p>
  </dt>
  <dd>
    <p>A prefix string to include in the log message, up to 64 characters long, useful for distinguishing messages in the logs.</p>
  </dd>
  <dt>
    <p><strong>--nflog-range</strong> <em>size</em></p>
  </dt>
  <dd>
    <p>The number of bytes to be copied to userspace (only applicable for nfnetlink_log). nfnetlink_log instances may specify their own range, this option overrides it.</p>
  </dd>
  <dt>
    <p><strong>--nflog-threshold</strong> <em>size</em></p>
  </dt>
  <dd>
    <p>Number of packets to queue inside the kernel before sending them to userspace (only applicable for nfnetlink_log). Higher values result in less overhead per packet, but increase delay until the packets reach userspace. The default value is 1.</p>
  </dd>

</dl>

<h3>NFQUEUE</h3>
<p>This target passes the packet to userspace using the <strong>nfnetlink_queue</strong> handler.  The packet is put into the queue identified by its 16-bit queue number.  Userspace can inspect and modify the packet if desired. Userspace must then drop or reinject the packet into the kernel.  Please see libnetfilter_queue for details. <strong></strong> nfnetlink_queue was added in Linux 2.6.14. The <strong>queue-balance</strong> option was added in Linux 2.6.31, <strong>queue-bypass</strong> in 2.6.39.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--queue-num</strong> <em>value</em></p>
  </dt>
  <dd>
    <p>This specifies the QUEUE number to use. Valid queue numbers are 0 to 65535. The default value is 0.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p><strong>--queue-balance</strong> <em>value</em><strong>:</strong><em>value</em></p>
  </dt>
  <dd>
    <p>This specifies a range of queues to use. Packets are then balanced across the given queues. This is useful for multicore systems: start multiple instances of the userspace program on queues x, x+1, .. x+n and use "--queue-balance <em>x</em><strong>:</strong><em>x+n</em>". Packets belonging to the same connection are put into the same nfqueue.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p><strong>--queue-bypass</strong></p>
  </dt>
  <dd>
    <p>By default, if no userspace program is listening on an NFQUEUE, then all packets that are to be queued are dropped.  When this option is used, the NFQUEUE rule behaves like ACCEPT instead, and the packet will move on to the next table.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p><strong>--queue-cpu-fanout</strong></p>
  </dt>
  <dd>
    <p>Available starting Linux kernel 3.10. When used together with <strong>--queue-balance</strong> this will use the CPU ID as an index to map packets to the queues. The idea is that you can improve performance if there's a queue per CPU. This requires <strong>--queue-balance</strong> to be specified.</p>
  </dd>

</dl>

<h3>NOTRACK</h3>
<p>This extension disables connection tracking for all packets matching that rule. It is equivalent with -j CT --notrack. Like CT, NOTRACK can only be used in the <strong>raw</strong> table.</p>
<h3>RATEEST</h3>
<p>The RATEEST target collects statistics, performs rate estimation calculation and saves the results for later evaluation using the <strong>rateest</strong> match.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--rateest-name</strong> <em>name</em></p>
  </dt>
  <dd>
    <p>Count matched packets into the pool referred to by <em>name</em>, which is freely choosable.</p>
  </dd>
  <dt>
    <p><strong>--rateest-interval</strong> <em>amount</em>{<strong>s</strong>|<strong>ms</strong>|<strong>us</strong>}</p>
  </dt>
  <dd>
    <p>Rate measurement interval, in seconds, milliseconds or microseconds.</p>
  </dd>
  <dt>
    <p><strong>--rateest-ewmalog</strong> <em>value</em></p>
  </dt>
  <dd>
    <p>Rate measurement averaging time constant.</p>
  </dd>

</dl>

<h3>REDIRECT</h3>
<p>This target is only valid in the <strong>nat</strong> table, in the <strong>PREROUTING</strong> and <strong>OUTPUT</strong> chains, and user-defined chains which are only called from those chains.  It redirects the packet to the machine itself by changing the destination IP to the primary address of the incoming interface (locally-generated packets are mapped to the localhost address, 127.0.0.1 for IPv4 and ::1 for IPv6).</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--to-ports</strong> <em>port</em>[<strong>-</strong><em>port</em>]</p>
  </dt>
  <dd>
    <p>This specifies a destination port or range of ports to use: without this, the destination port is never altered.  This is only valid if the rule also specifies one of the following protocols: <strong>tcp</strong>, <strong>udp</strong>, <strong>dccp</strong> or <strong>sctp</strong>.</p>
  </dd>
  <dt>
    <p><strong>--random</strong></p>
  </dt>
  <dd>
    <p>If option <strong>--random</strong> is used then port mapping will be randomized (kernel &gt;= 2.6.22).</p>
  </dd>
  <dt>
    <p>IPv6 support available starting Linux kernels &gt;= 3.7.</p>
  </dt>
  <dd>
    
  </dd>

</dl>

<h3>REJECT (IPv6-specific)</h3>
<p>This is used to send back an error packet in response to the matched packet: otherwise it is equivalent to <strong>DROP</strong> so it is a terminating TARGET, ending rule traversal. This target is only valid in the <strong>INPUT</strong>, <strong>FORWARD</strong> and <strong>OUTPUT</strong> chains, and user-defined chains which are only called from those chains.  The following option controls the nature of the error packet returned:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--reject-with</strong> <em>type</em></p>
  </dt>
  <dd>
    <p>The type given can be <strong>icmp6-no-route</strong>, <strong>no-route</strong>, <strong>icmp6-adm-prohibited</strong>, <strong>adm-prohibited</strong>, <strong>icmp6-addr-unreachable</strong>, <strong>addr-unreach</strong>, or <strong>icmp6-port-unreachable</strong>, which return the appropriate ICMPv6 error message (<strong>icmp6-port-unreachable</strong> is the default). Finally, the option <strong>tcp-reset</strong> can be used on rules which only match the TCP protocol: this causes a TCP RST packet to be sent back.  This is mainly useful for blocking <em>ident</em> (113/tcp) probes which frequently occur when sending mail to broken mail hosts (which won't accept your mail otherwise). <strong>tcp-reset</strong> can only be used with kernel versions 2.6.14 or later.</p>
  </dd>

</dl>

<h3>REJECT (IPv4-specific)</h3>
<p>This is used to send back an error packet in response to the matched packet: otherwise it is equivalent to <strong>DROP</strong> so it is a terminating TARGET, ending rule traversal. This target is only valid in the <strong>INPUT</strong>, <strong>FORWARD</strong> and <strong>OUTPUT</strong> chains, and user-defined chains which are only called from those chains.  The following option controls the nature of the error packet returned:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--reject-with</strong> <em>type</em></p>
  </dt>
  <dd>
    <p>The type given can be <strong>icmp-net-unreachable</strong>, <strong>icmp-host-unreachable</strong>, <strong>icmp-port-unreachable</strong>, <strong>icmp-proto-unreachable</strong>, <strong>icmp-net-prohibited</strong>, <strong>icmp-host-prohibited</strong>, or <strong>icmp-admin-prohibited</strong> (*), which return the appropriate ICMP error message (<strong>icmp-port-unreachable</strong> is the default).  The option <strong>tcp-reset</strong> can be used on rules which only match the TCP protocol: this causes a TCP RST packet to be sent back.  This is mainly useful for blocking <em>ident</em> (113/tcp) probes which frequently occur when sending mail to broken mail hosts (which won't accept your mail otherwise).</p>
  </dd>

</dl>
<p>(*) Using icmp-admin-prohibited with kernels that do not support it will result in a plain DROP instead of REJECT</p>
<h3>SAME (IPv4-specific)</h3>
<p>Similar to SNAT/DNAT depending on chain: it takes a range of addresses (`--to 1.2.3.4-1.2.3.7') and gives a client the same source-/destination-address for each connection.</p><p>N.B.: The DNAT target's <strong>--persistent</strong> option replaced the SAME target.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--to</strong> <em>ipaddr</em>[<strong>-</strong><em>ipaddr</em>]</p>
  </dt>
  <dd>
    <p>Addresses to map source to. May be specified more than once for multiple ranges.</p>
  </dd>
  <dt>
    <p><strong>--nodst</strong></p>
  </dt>
  <dd>
    <p>Don't use the destination-ip in the calculations when selecting the new source-ip</p>
  </dd>
  <dt>
    <p><strong>--random</strong></p>
  </dt>
  <dd>
    <p>Port mapping will be forcibly randomized to avoid attacks based on port prediction (kernel &gt;= 2.6.21).</p>
  </dd>

</dl>

<h3>SECMARK</h3>
<p>This is used to set the security mark value associated with the packet for use by security subsystems such as SELinux.  It is valid in the <strong>security</strong> table (for backwards compatibility with older kernels, it is also valid in the <strong>mangle</strong> table). The mark is 32 bits wide.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--selctx</strong> <em>security_context</em></p>
  </dt>
  <dd>
    
  </dd>

</dl>

<h3>SET</h3>
<p>This module adds and/or deletes entries from IP sets which can be defined by <a href="../man8/ipset.8.html"><strong>ipset</strong>(8)</a>.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--add-set</strong> <em>setname</em> <em>flag</em>[<strong>,</strong><em>flag</em>...]</p>
  </dt>
  <dd>
    <p>add the address(es)/port(s) of the packet to the set</p>
  </dd>
  <dt>
    <p><strong>--del-set</strong> <em>setname</em> <em>flag</em>[<strong>,</strong><em>flag</em>...]</p>
  </dt>
  <dd>
    <p>delete the address(es)/port(s) of the packet from the set</p><ul>
<li><p>where <em>flag</em>(s) are <strong>src</strong> and/or <strong>dst</strong> specifications and there can be no more than six of them.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>--timeout</strong> <em>value</em></p>
  </dt>
  <dd>
    <p>when adding an entry, the timeout value to use instead of the default one from the set definition</p>
  </dd>
  <dt>
    <p><strong>--exist</strong></p>
  </dt>
  <dd>
    <p>when adding an entry if it already exists, reset the timeout value to the specified one or to the default from the set definition</p>
  </dd>

</dl>
<p>Use of -j SET requires that ipset kernel support is provided, which, for standard kernels, is the case since Linux 2.6.39.</p>
<h3>SNAT</h3>
<p>This target is only valid in the <strong>nat</strong> table, in the <strong>POSTROUTING</strong> and <strong>INPUT</strong> chains, and user-defined chains which are only called from those chains.  It specifies that the source address of the packet should be modified (and all future packets in this connection will also be mangled), and rules should cease being examined.  It takes the following options:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--to-source</strong> [<em>ipaddr</em>[<strong>-</strong><em>ipaddr</em>]][<strong>:</strong><em>port</em>[<strong>-</strong><em>port</em>]]</p>
  </dt>
  <dd>
    <p>which can specify a single new source IP address, an inclusive range of IP addresses. Optionally a port range, if the rule also specifies one of the following protocols: <strong>tcp</strong>, <strong>udp</strong>, <strong>dccp</strong> or <strong>sctp</strong>. If no port range is specified, then source ports below 512 will be mapped to other ports below 512: those between 512 and 1023 inclusive will be mapped to ports below 1024, and other ports will be mapped to 1024 or above. Where possible, no port alteration will occur. In Kernels up to 2.6.10, you can add several --to-source options. For those kernels, if you specify more than one source address, either via an address range or multiple --to-source options, a simple round-robin (one after another in cycle) takes place between these addresses. Later Kernels (&gt;= 2.6.11-rc1) don't have the ability to NAT to multiple ranges anymore.</p>
  </dd>
  <dt>
    <p><strong>--random</strong></p>
  </dt>
  <dd>
    <p>If option <strong>--random</strong> is used then port mapping will be randomized (kernel &gt;= 2.6.21).</p>
  </dd>
  <dt>
    <p><strong>--persistent</strong></p>
  </dt>
  <dd>
    <p>Gives a client the same source-/destination-address for each connection. This supersedes the SAME target. Support for persistent mappings is available from 2.6.29-rc2.</p>
  </dd>

</dl>
<p>Kernels prior to 2.6.36-rc1 don't have the ability to <strong>SNAT</strong> in the <strong>INPUT</strong> chain.</p>
<dl class='dl-vertical'>
  <dt>
    <p>IPv6 support available since Linux kernels &gt;= 3.7.</p>
  </dt>
  <dd>
    
  </dd>

</dl>

<h3>SNPT (IPv6-specific)</h3>
<p>Provides stateless source IPv6-to-IPv6 Network Prefix Translation (as described by RFC 6296).</p><p>You have to use this target in the <strong>mangle</strong> table, not in the <strong>nat</strong> table. It takes the following options:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--src-pfx</strong> [<em>prefix/</em><em>length]</em></p>
  </dt>
  <dd>
    <p>Set source prefix that you want to translate and length</p>
  </dd>
  <dt>
    <p><strong>--dst-pfx</strong> [<em>prefix/</em><em>length]</em></p>
  </dt>
  <dd>
    <p>Set destination prefix that you want to use in the translation and length</p>
  </dd>

</dl>
<p>You have to use the DNPT target to undo the translation. Example:</p><ul>
<li><p>ip6tables -t mangle -I POSTROUTING -s fd00::/64 \! -o vboxnet0 -j SNPT --src-pfx fd00::/64 --dst-pfx 2001:e20:2000:40f::/64</p></li><li><p>ip6tables -t mangle -I PREROUTING -i wlan0 -d 2001:e20:2000:40f::/64 -j DNPT --src-pfx 2001:e20:2000:40f::/64 --dst-pfx fd00::/64</p></li>
</ul><p>You may need to enable IPv6 neighbor proxy:</p><ul>
<li><p>sysctl -w net.ipv6.conf.all.proxy_ndp=1</p></li>
</ul><p>You also have to use the <strong>NOTRACK</strong> target to disable connection tracking for translated flows.</p>
<h3>TCPMSS</h3>
<p>This target alters the MSS value of TCP SYN packets, to control the maximum size for that connection (usually limiting it to your outgoing interface's MTU minus 40 for IPv4 or 60 for IPv6, respectively). Of course, it can only be used in conjunction with <strong>-p tcp</strong>.</p><p>This target is used to overcome criminally braindead ISPs or servers which block "ICMP Fragmentation Needed" or "ICMPv6 Packet Too Big" packets.  The symptoms of this problem are that everything works fine from your Linux firewall/router, but machines behind it can never exchange large packets:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>Web browsers connect, then hang with no data received.</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>Small mail works fine, but large emails hang.</p>
  </dd>
  <dt>
    3.
  </dt>
  <dd>
    <p>ssh works fine, but scp hangs after initial handshaking.</p>
  </dd>

</dl>
<p>Workaround: activate this option and add a rule to your firewall configuration like:</p><ul>
<li><p> iptables -t mangle -A FORWARD -p tcp --tcp-flags SYN,RST SYN</p>
<pre>
             -j TCPMSS --clamp-mss-to-pmtu
</pre>
</li>
</ul>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--set-mss</strong> <em>value</em></p>
  </dt>
  <dd>
    <p>Explicitly sets MSS option to specified value. If the MSS of the packet is already lower than <em>value</em>, it will <strong>not</strong> be increased (from Linux 2.6.25 onwards) to avoid more problems with hosts relying on a proper MSS.</p>
  </dd>
  <dt>
    <p><strong>--clamp-mss-to-pmtu</strong></p>
  </dt>
  <dd>
    <p>Automatically clamp MSS value to (path_MTU - 40 for IPv4; -60 for IPv6). This may not function as desired where asymmetric routes with differing path MTU exist &ndash; the kernel uses the path MTU which it would use to send packets from itself to the source and destination IP addresses. Prior to Linux 2.6.25, only the path MTU to the destination IP address was considered by this option; subsequent kernels also consider the path MTU to the source IP address.</p>
  </dd>

</dl>
<p>These options are mutually exclusive.</p>
<h3>TCPOPTSTRIP</h3>
<p>This target will strip TCP options off a TCP packet. (It will actually replace them by NO-OPs.) As such, you will need to add the <strong>-p tcp</strong> parameters.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--strip-options</strong> <em>option</em>[<strong>,</strong><em>option</em>...]</p>
  </dt>
  <dd>
    <p>Strip the given option(s). The options may be specified by TCP option number or by symbolic name. The list of recognized options can be obtained by calling iptables with <strong>-j TCPOPTSTRIP -h</strong>.</p>
  </dd>

</dl>

<h3>TEE</h3>
<p>The <strong>TEE</strong> target will clone a packet and redirect this clone to another machine on the <strong>local</strong> network segment. In other words, the nexthop must be the target, or you will have to configure the nexthop to forward it further if so desired.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--gateway</strong> <em>ipaddr</em></p>
  </dt>
  <dd>
    <p>Send the cloned packet to the host reachable at the given IP address. Use of 0.0.0.0 (for IPv4 packets) or :: (IPv6) is invalid.</p>
  </dd>

</dl>
<p>To forward all incoming traffic on eth0 to an Network Layer logging box:</p><p>-t mangle -A PREROUTING -i eth0 -j TEE --gateway 2001:db8::1</p>
<h3>TOS</h3>
<p>This module sets the Type of Service field in the IPv4 header (including the "precedence" bits) or the Priority field in the IPv6 header. Note that TOS shares the same bits as DSCP and ECN. The TOS target is only valid in the <strong>mangle</strong> table.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--set-tos</strong> <em>value</em>[<strong>/</strong><em>mask</em>]</p>
  </dt>
  <dd>
    <p>Zeroes out the bits given by <em>mask</em> (see NOTE below) and XORs <em>value</em> into the TOS/Priority field. If <em>mask</em> is omitted, 0xFF is assumed.</p>
  </dd>
  <dt>
    <p><strong>--set-tos</strong> <em>symbol</em></p>
  </dt>
  <dd>
    <p>You can specify a symbolic name when using the TOS target for IPv4. It implies a mask of 0xFF (see NOTE below). The list of recognized TOS names can be obtained by calling iptables with <strong>-j TOS -h</strong>.</p>
  </dd>

</dl>
<p>The following mnemonics are available:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--and-tos</strong> <em>bits</em></p>
  </dt>
  <dd>
    <p>Binary AND the TOS value with <em>bits</em>. (Mnemonic for <strong>--set-tos</strong> 0/<em>invbits</em>, where <em>invbits</em> is the binary negation of <em>bits</em>. See NOTE below.)</p>
  </dd>
  <dt>
    <p><strong>--or-tos</strong> <em>bits</em></p>
  </dt>
  <dd>
    <p>Binary OR the TOS value with <em>bits</em>. (Mnemonic for <strong>--set-tos</strong> <em>bits</em><strong>/</strong><em>bits</em>. See NOTE below.)</p>
  </dd>
  <dt>
    <p><strong>--xor-tos</strong> <em>bits</em></p>
  </dt>
  <dd>
    <p>Binary XOR the TOS value with <em>bits</em>. (Mnemonic for <strong>--set-tos</strong> <em>bits</em><strong>/0</strong>. See NOTE below.)</p>
  </dd>

</dl>
<p>NOTE: In Linux kernels up to and including 2.6.38, with the exception of longterm releases 2.6.32 (&gt;=.42), 2.6.33 (&gt;=.15), and 2.6.35 (&gt;=.14), there is a bug whereby IPv6 TOS mangling does not behave as documented and differs from the IPv4 version. The TOS mask indicates the bits one wants to zero out, so it needs to be inverted before applying it to the original TOS field. However, the aformentioned kernels forgo the inversion which breaks --set-tos and its mnemonics.</p>
<h3>TPROXY</h3>
<p>This target is only valid in the <strong>mangle</strong> table, in the <strong>PREROUTING</strong> chain and user-defined chains which are only called from this chain. It redirects the packet to a local socket without changing the packet header in any way. It can also change the mark value which can then be used in advanced routing rules. It takes three options:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--on-port</strong> <em>port</em></p>
  </dt>
  <dd>
    <p>This specifies a destination port to use. It is a required option, 0 means the new destination port is the same as the original. This is only valid if the rule also specifies <strong>-p tcp</strong> or <strong>-p udp</strong>.</p>
  </dd>
  <dt>
    <p><strong>--on-ip</strong> <em>address</em></p>
  </dt>
  <dd>
    <p>This specifies a destination address to use. By default the address is the IP address of the incoming interface. This is only valid if the rule also specifies <strong>-p tcp</strong> or <strong>-p udp</strong>.</p>
  </dd>
  <dt>
    <p><strong>--tproxy-mark</strong> <em>value</em>[<strong>/</strong><em>mask</em>]</p>
  </dt>
  <dd>
    <p>Marks packets with the given value/mask. The fwmark value set here can be used by advanced routing. (Required for transparent proxying to work: otherwise these packets will get forwarded, which is probably not what you want.)</p>
  </dd>

</dl>

<h3>TRACE</h3>
<p>This target marks packets so that the kernel will log every rule which match the packets as those traverse the tables, chains, rules.</p><p>A logging backend, such as ip(6)t_LOG or nfnetlink_log, must be loaded for this to be visible. The packets are logged with the string prefix: "TRACE: tablename:chainname:type:rulenum " where type can be "rule" for plain rule, "return" for implicit rule at the end of a user defined chain and "policy" for the policy of the built in chains.</p><p>It can only be used in the <strong>raw</strong> table.</p>
<h3>TTL (IPv4-specific)</h3>
<p>This is used to modify the IPv4 TTL header field.  The TTL field determines how many hops (routers) a packet can traverse until it's time to live is exceeded.</p><p>Setting or incrementing the TTL field can potentially be very dangerous, so it should be avoided at any cost. This target is only valid in <strong>mangle</strong> table.</p><p><strong>Don't ever set or increment the value on packets that leave your local network!</strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--ttl-set</strong> <em>value</em></p>
  </dt>
  <dd>
    <p>Set the TTL value to `value'.</p>
  </dd>
  <dt>
    <p><strong>--ttl-dec</strong> <em>value</em></p>
  </dt>
  <dd>
    <p>Decrement the TTL value `value' times.</p>
  </dd>
  <dt>
    <p><strong>--ttl-inc</strong> <em>value</em></p>
  </dt>
  <dd>
    <p>Increment the TTL value `value' times.</p>
  </dd>

</dl>

<h3>ULOG (IPv4-specific)</h3>
<p>This is the deprecated ipv4-only predecessor of the NFLOG target. It provides userspace logging of matching packets.  When this target is set for a rule, the Linux kernel will multicast this packet through a <em>netlink</em> socket. One or more userspace processes may then subscribe to various multicast groups and receive the packets. Like LOG, this is a "non-terminating target", i.e. rule traversal continues at the next rule.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--ulog-nlgroup</strong> <em>nlgroup</em></p>
  </dt>
  <dd>
    <p>This specifies the netlink group (1-32) to which the packet is sent. Default value is 1.</p>
  </dd>
  <dt>
    <p><strong>--ulog-prefix</strong> <em>prefix</em></p>
  </dt>
  <dd>
    <p>Prefix log messages with the specified prefix; up to 32 characters long, and useful for distinguishing messages in the logs.</p>
  </dd>
  <dt>
    <p><strong>--ulog-cprange</strong> <em>size</em></p>
  </dt>
  <dd>
    <p>Number of bytes to be copied to userspace.  A value of 0 always copies the entire packet, regardless of its size.  Default is 0.</p>
  </dd>
  <dt>
    <p><strong>--ulog-qthreshold</strong> <em>size</em></p>
  </dt>
  <dd>
    <p>Number of packet to queue inside kernel.  Setting this value to, e.g. 10 accumulates ten packets inside the kernel and transmits them as one netlink multipart message to userspace.  Default is 1 (for backwards compatibility).</p>
  </dd>

</dl>


        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="iptables-converter.8.html"><span aria-hidden="true">&larr;</span> iptables-converter.8: Program to convert iptables commands from file to iptables-restore format</a></li>
   <li class="next"><a href="iptables-restore.8.html">iptables-restore.8: Iptables-restore  restore ip tables  ip6tables-restore  restore ipv6 tables <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

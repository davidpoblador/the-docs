<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>dacs_acs: Dacs access control service</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Dacs access control service">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="dacs_acs (8) manual">
  <meta name="twitter:description" content="Dacs access control service">
  <meta name="twitter:image" content="https://www.carta.tech/images/dacs-dacs_acs-8.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man8/dacs_acs.8.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="dacs_acs (8) manual" />
  <meta property="og:description" content="Dacs access control service" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/dacs-dacs_acs-8.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">dacs_acs<small> (8)</small></h1>
        <p class="lead">Dacs access control service</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man8/">
      <span itemprop="name">System administration commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man8/dacs_acs.8.html">
      <span itemprop="name">dacs_acs: Dacs access control service</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/dacs/">
      <span itemprop="name">dacs</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man8/dacs_acs.8.html">
      <span itemprop="name">dacs_acs: Dacs access control service</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>dacs_acs</strong> [<em>\m[blue]</em><strong>dacsoptions</strong>\m[]\s-2\u[1]\d\s+2] [<strong>-proxy-static</strong>] [<strong>-proxy-exec</strong>]</p><p><strong>dacs_acs</strong><strong>-test</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This program is part of the <strong>DACS</strong> suite.</p><p>The <strong>DACS</strong> access control service, <strong>dacs_acs</strong> (or simply <strong>ACS</strong>) is responsible for making access control decisions on web service requests. It is run by a web server. In the current implementation, <strong>dacs_acs</strong> is executed by the web server as an external program. <strong>ACS</strong> provides role-based access control using the <strong>DACS</strong> rule-processing engine, which consults access control rules (also referred to as ACLs) provided with <strong>DACS</strong> or written by a <strong>DACS</strong> administrator. Because access control is performed on URIs, <strong>ACS</strong> can control access to arbitrary resources, such as web pages, files, or programs.</p><p>A generic interface to <strong>DACS&apos;s</strong> rule processing engine is given by \m[blue]<a href="../man1/dacscheck.1.html"><strong>dacscheck</strong>(1)</a></strong>\m[]\s-2\u[2]\d\s+2.</p><p>A web server runs <strong>dacs_acs</strong> to determine whether a particular service request is authorized. Although in theory any web server that provides appropriate hooks could call <strong>dacs_acs</strong>, at present only <strong>Apache</strong> 2.x and 2.2.x web servers are supported. A <strong>DACS</strong>-aware <strong>Apache</strong> module called \m[blue]<strong>mod_auth_dacs</strong>\m[]\s-2\u[3]\d\s+2 is configured using custom <strong>Apache</strong> directives and runs <strong>dacs_acs</strong>. A web server having \m[blue]<strong>mod_auth_dacs</strong>\m[]\s-2\u[3]\d\s+2 functionality is said to be <strong>DACS</strong>-enhanced and web services that are under the control of \m[blue]<strong>mod_auth_dacs</strong>\m[]\s-2\u[3]\d\s+2 are said to be <strong>DACS</strong>-wrapped.</p><p>When <strong>Apache</strong> receives a <strong>DACS</strong>-wrapped service request, the <strong>mod_auth_dacs</strong> module is run, which in turn runs <strong>dacs_acs</strong> to determine whether the request should be granted. The module provides <strong>dacs_acs</strong> with the name of the requested service ("What is being accessed?"), parameters that were passed in the request ("How is it being accessed?"), the identity of the client ("Who is making the request?"), and other context associated with the request. With this information at hand, <strong>dacs_acs</strong> consults a set of access control rules (the ruleset) (see \m[blue]<a href="../man5/dacs.acls.5.html"><strong>dacs.acls</strong>(5)</a></strong>\m[]\s-2\u[4]\d\s+2). Additional contextual information, such as <strong>DACS</strong> configuration directives and build-time options, and the run-time environment, is also available. The information returned by <strong>dacs_acs</strong> to the module either causes <strong>Apache</strong> to grant permission, possibly with a constraint that specifies additional, service-specific information, or denies permission, possibly with a reason for denial. <strong>dacs_acs</strong> may also instruct the web server to redirect the client.</p><p>All <strong>DACS</strong> services must be under the control of <strong>dacs_acs</strong>, even those that do not require the client to be authenticated. Also, a web server must be configured such that only <strong>DACS</strong>-controlled services and no other services can be invoked through URLs associated with its <strong>DACS</strong> jurisdiction.</p><p>It is not a requirement that all of a web server&apos;s resources be under the control of <strong>DACS</strong>. That is, it is not necessary to <strong>DACS</strong>-wrap everything, but it is certainly possible.</p><p>Please refer to the documentation for \m[blue]<strong>mod_auth_dacs</strong>\m[]\s-2\u[3]\d\s+2 for information on configuring the <strong>DACS</strong><strong>Apache</strong> module.</p><p><strong>Security</strong></p><p>A <strong>dacs_acs</strong> process, which is created by <strong>httpd</strong>, should ordinarily run as the same user id as <strong>httpd</strong>. File and directory ownership and modes must be set so that it can read its configuration files, access control rules, and so on. The <strong>DACS</strong> expression language includes functions that can execute an arbitrary program and perform file system operations, so care must be taken to ensure that files used by <strong>DACS</strong> cannot be edited or replaced by non-privileged users. In some circumstances, it may be necessary for <strong>dacs_acs</strong> to run as root, in which case a <strong>DACS</strong> administrator must be extra careful in this regard.</p><p><strong>Tip</strong></p><p>One way to understand what <strong>dacs_acs</strong> is doing, or to debug it, is to enable the most detailed level of \m[blue]<strong>logging</strong>\m[]\s-2\u[5]\d\s+2. This will emit a copious quantity of output to the <strong>DACS</strong> log file, so be sure to reduce the logging level and delete the log file when you are finished.</p><p>Setting the \m[blue]<strong>LOG_LEVEL</strong>\m[]\s-2\u[6]\d\s+2 directive to "debug" or "trace" will produce detailed output (although it can be moderated using the \m[blue]<strong>LOG_FILTER</strong>\m[]\s-2\u[7]\d\s+2 directive). LOG_LEVEL has the disadvantage that it cannot take effect until after configuration processing.</p><p>To enable logging output at the earliest possible time, you can add the desired \m[blue]<strong></strong><em>dacsoptions</em>\m[]\s-2\u[1]\d\s+2 flags to Apache&apos;s \m[blue]<strong>AddDACSAuth</strong>\m[]\s-2\u[8]\d\s+2 directive; for example, by using a directive like the following in httpd.conf:</p>
<pre>
AddDACSAuth dacs-acs /usr/local/dacs/bin/dacs_acs "-t -v"
</pre>
<p>Note that <strong>httpd</strong> must be restarted before changes to this directive take effect.</p><p>An alternative method of enabling detailed logging, equivalent to using the <strong>-t</strong> and <strong>-v</strong> flags if neither has been specified, is to create a file in the \m[blue]<strong>DACS_HOME</strong>\m[]\s-2\u[9]\d\s+2 directory with the name debug_<em>progname</em>. For example, to enable detailed logging for <strong>dacs_acs</strong>, the following command might be used:</p>
<pre>
% touch /usr/local/dacs/debug_dacs_acs
</pre>
<p>This method takes effect immediately and applies to any <strong>DACS</strong> web service or command that accepts \m[blue]<strong></strong><em>dacsoptions</em>\m[]\s-2\u[1]\d\s+2 at the time they begin execution. It overrides the current value of LOG_LEVEL, is more selective because it applies only to <em>progname</em> (unlike LOG_LEVEL), is easily turned on by creating the file and turned off by removing the file, and neither requires changes to httpd.conf nor an <strong>httpd</strong> restart.</p><h3>Module-to-ACS Protocol</h3>
<p><strong>DACS</strong>&apos;s \m[blue]<strong>mod_auth_dacs</strong>\m[]\s-2\u[3]\d\s+2 module for <strong>Apache</strong> invokes the <strong>dacs_acs</strong> program to do the hard part of deciding whether a request should be granted or denied. The module is responsible for configuring itself using new <strong>Apache</strong> directives, gathering information required to make the access control decision, passing that information to <strong>dacs_acs</strong>, and receiving the access control decision from <strong>dacs_acs</strong>, together with either environment information (if access is granted to an executable request) or error handling directives (if access is denied).</p><p>To prevent potentially sensitive information from becoming visible, \m[blue]<strong>mod_auth_dacs</strong>\m[]\s-2\u[3]\d\s+2 passes information to <strong>dacs_acs</strong> over an interprocess communication channel (\m[blue]<a href="../man2/pipe.2.html"><strong>pipe</strong>(2)</a></strong>\m[]\s-2\u[10]\d\s+2). <strong>dacs_acs</strong> reads its standard input, makes the access control decision, and writes either environment information or an optional error handling directive to its standard output. The exit status of <strong>dacs_acs</strong> communicates its decision: zero means the request should be granted, anything else means the request should be denied.</p><p>The information passed <em>to</em><strong>dacs_acs</strong><em>from</em><strong>Apache</strong> is in the format:</p>
<pre>
<em>variable-name</em>="<em>variable-value</em>"
</pre>
<p>each of which is terminated by a newline character. These variables are listed below. For details about how to reference these values, see \m[blue]<strong>Variables Available To Rules</strong>\m[]\s-2\u[11]\d\s+2.</p><p><em>SERVICE_ARGS</em></p><p>The query arguments (if any and whether GET or POST method is being used) followed by POST arguments (if any and to the maximum length configured), base-64 encoded.</p><p><em>SERVICE_ARGS_TRUNCATED</em></p><p>For POST method requests, if the POST data stream (i.e., the request&apos;s entity-body) was not completely captured, such as if the maximum length was reached, this variable will be present and assigned the value 1.</p><p><em>SERVICE_AUTHORIZATION</em></p><p>The value of the Authorization HTTP header field, if present.</p><p><em>SERVICE_CONTENT_ENCODING</em></p><p>The value of the Content-Encoding HTTP header field, if present.</p><p><em>SERVICE_CONTENT_LENGTH</em></p><p>The value of the Content-Length HTTP header field, if present.</p><p><em>SERVICE_CONTENT_TYPE</em></p><p>The value of the Content-Type HTTP header field, if present.</p><p><em>SERVICE_COOKIE</em></p><p>The value of the Cookie HTTP header field, if present.</p><p><em>SERVICE_FILENAME</em></p><p>The name of the file, as determined by <strong>Apache</strong>, corresponding to this response.</p><p><em>SERVICE_HOSTNAME</em></p><p>The name of the host as set by the full URI or Host HTTP header field, as determined by <strong>Apache</strong>.</p><p><em>SERVICE_HTTPS</em></p><p>If the request came over SSL (HTTPS), this variable will be present and set to "on".</p><p><em>SERVICE_METHOD</em></p><p>The request method, as set by <strong>Apache</strong> (e.g., "GET").</p><p><em>SERVICE_PATH_INFO</em></p><p>The <strong>PATH_INFO</strong> part of the URI, as set by <strong>Apache</strong>.</p><p><em>SERVICE_POSTDATA</em></p><p>When available, the POST data stream (the HTTP message body) (or part of it: see the description of the SetDACSAuthPostBuffer directive to \m[blue]<strong>mod_auth_dacs</strong>\m[]\s-2\u[12]\d\s+2). It is MIME base-64 encoded.</p><p><em>SERVICE_PROXY_AUTH</em></p><p>The value of the DACS-Proxy-Authorization HTTP header field, if present. (Not currently used).</p><p><em>SERVICE_PROXYREQ</em></p><p>If the current request involves proxy processing on this server, this identifies the type of processing as "proxy" (for "forward proxying"), "proxy_reverse" (for "reverse proxying"), or "proxy_response".</p><p><em>SERVICE_QUERY</em></p><p>The value of the query string component of the URI.</p><p><em>SERVICE_REMOTE_ADDR</em></p><p>The client&apos;s IP address.</p><p><em>SERVICE_REMOTE_HOST</em></p><p>The client&apos;s DNS name, if known by <strong>Apache</strong>.</p><p><em>SERVICE_SERVER_PORT</em></p><p>The TCP/IP port on which the request was received by <strong>Apache</strong>.</p><p><em>SERVICE_URI</em></p><p>The path portion of the URI, as determined by <strong>Apache</strong>.</p><p><em>SERVICE_USER_AGENT</em></p><p>The value of the User-Agent HTTP header field, if present.</p><p>If access is granted, <strong>dacs_acs</strong> may provide a set of control directives for \m[blue]<strong>mod_auth_dacs</strong>\m[]\s-2\u[3]\d\s+2 to interpret, followed by a set of environment variables for \m[blue]<strong>mod_auth_dacs</strong>\m[]\s-2\u[3]\d\s+2 to introduce into the environment of an executable request. Each control directive starts with a "=" character and is terminated by a newline. Environment variables are specified in the format:</p>
<pre>
<em>variable-name</em>=<em>variable-value</em>
</pre>
<p>each of which is terminated by a newline character.</p><p>If access is denied, <strong>dacs_acs</strong> may instead provide an error handling directive, newline terminated, in the form expected as the third argument to <strong>Apache</strong>&apos;s <strong>ap_custom_response()</strong> function.</p>
<h3>Credentials</h3>
<p><strong>DACS</strong> credentials can be passed to <strong>dacs_acs</strong> in several ways, but they have the following representation:</p>
<pre>
DACS:<em>federation-name</em>::[<em>jurisdiction-name</em>]:[<em>username</em>]=<em>value</em>[; ...]
</pre>
<p>If the <em>jurisdiction-name</em> is omitted, the <em>username</em> must also be omitted. The string is URL encoded. If there are multiple credentials, they are separated by any combination of spaces and ";" characters.</p><p>Credentials are passed from \m[blue]<strong>mod_auth_dacs</strong>\m[]\s-2\u[3]\d\s+2 to <strong>dacs_acs</strong> using the <em>SERVICE_COOKIE</em> variable (transmitted over a \m[blue]<a href="../man2/pipe.2.html"><strong>pipe</strong>(2)</a></strong>\m[]\s-2\u[10]\d\s+2)</p><p>Because a process&apos;s environment is public on some systems, <strong>DACS</strong> takes care not to pass credentials using environment variables. Passing credentials through the <strong>HTTP_COOKIE</strong> environment variable is forbidden unless enabled by the \m[blue]<strong>ALLOW_HTTP_COOKIE</strong>\m[]\s-2\u[13]\d\s+2 directive. When specifically enabled by a rule&apos;s attribute, they can be passed using the <strong>DACS_COOKIE</strong> environment variable (see the pass_credentials attribute described in \m[blue]<a href="../man5/dacs.acls.5.html"><strong>dacs.acls</strong>(5)</a></strong>\m[]\s-2\u[4]\d\s+2).</p><p>If an HTTP Authorization header is used with the "DACS" authentication scheme, the "basic-credentials" component of the header may contain <strong>DACS</strong> credentials. Please refer to \m[blue]<strong>RFC 2617</strong>\m[]\s-2\u[14]\d\s+2. These credentials have the format given above but are also base-64 encoded.</p><p><strong>Security</strong></p><p>It is forbidden to submit multiple credentials for the same identity to <strong>DACS</strong> and such a request will trigger an error.</p><p>it is also forbidden to submit multiple <strong>DACS</strong> authentication cookies with the same cookie name.</p><p>Please refer to \m[blue]<a href="../man8/dacs_authenticate.8.html"><strong>dacs_authenticate</strong>(8)</a></strong>\m[]\s-2\u[15]\d\s+2 for additional information.</p>
<h3>Rlinks</h3>
<p>An Rlink (rule link) is an alternate mechanism for providing <strong>DACS</strong> authentication and authorization. Instead of matching the name of a requested resource against rules, as is normally done by <strong>DACS</strong>, the request indirectly specifies authorization constraints that must be applied to the request. Optionally, a <strong>DACS</strong> identity and other information can accompany the request. An Rname, which is essentially the name of an access control rule, is used to point at the authorization constraints.</p><p>An Rlink is a URL that includes an Rname. During authorization processing, the Rname is resolved to an access control rule that is processed the same as any other access control rule and the requested resource must be <strong>DACS</strong>-wrapped. In other words, a request that is recognized as an Rlink essentially says "use the rule identified by this request&apos;s Rname to decide whether or not to grant access and do not consider any other rule". Subsequent access control processing is identical to the normal case.</p><p>In typical usage, an Rlink is created (probably, but not necessarily by \m[blue]<a href="../man1/dacsrlink.1.html"><strong>dacsrlink</strong>(1)</a></strong>\m[]\s-2\u[16]\d\s+2) and the resulting URL is distributed (e.g., by email) to those parties intended to be able to access the resource. Similar mechanisms are widely used by web-based applications.</p><p>When an Rlink is used as a kind of "secret URL" that grants access to anyone who uses it, an Rname is a randomly generated identifier that is unique, with very high probability, relative to its namespace at a jurisdiction. By default, an Rname consists of eight symbols from the set of upper- and lower-case alphabetics and digits, yielding a namespace in excess of 10^14 identifiers. This makes guessing a valid Rname highly unlikely. The characteristics of new Rnames can be changed at will; the alphabet from which they are generated should be considered carefully, however, to avoid problems that might arise when they are embedded within a URL or used as a filename. \m[blue]<strong>RLINK</strong>\m[]\s-2\u[17]\d\s+2 directives can map Rnames to the same or different namespaces, depending on the filestore selected by a directive.</p><p><strong>Note</strong></p><p>An Rlink does not have to be used as a secret URL though, and its creator can choose any Rname that will work with the mechanism described here.</p><p>If a rule contains the optional name attribute, the attribute value must exactly match the Rname.</p><p>The base name of a file containing an Rlink will be its Rname. This naming scheme is different from \m[blue]<strong>the one used for normal rules</strong>\m[]\s-2\u[18]\d\s+2.</p><p>This feature allows multiple versions of an Rlink to be created, each bound to a different identity. By attaching an identity to an Rlink, its creator can confer different rights to different users, or simply track who has used the Rlink. These identities may or may not correspond to "real" identities that are associated with <strong>DACS</strong> authentication (i.e., there may or may not be an account associated with them); <strong>DACS</strong> administrators should keep this mind to avoid any confusion.</p><p>An Rname may be followed by a suffix that directly or indirectly associates a <strong>DACS</strong> identity with the Rlink. For want of a better name, this composite identifier is called an RnameIdent and has the following syntax:</p>
<pre>
  <em>RnameIdent</em>  -&gt; <em>Rname</em> &apos;:&apos; <em>ident</em> | <em>Rname</em> &apos;;&apos; <em>iptr</em>
</pre>
<p>In the <em>direct</em> mode of identity attachment, the Rname is followed by a separator (a colon, which cannot appear in an Rname) and <em>ident</em>, a cryptographically protected and base-64 encoded \m[blue]<strong>concise user identity</strong>\m[]\s-2\u[19]\d\s+2 that is created by \m[blue]<a href="../man1/dacsrlink.1.html"><strong>dacsrlink</strong>(1)</a></strong>\m[]\s-2\u[16]\d\s+2. These encrypted identities are <em>not</em> the same as encrypted credentials. Note that different encrypted identifiers may represent exactly the same identity. If <strong>DACS</strong> recognizes the Rname, when it performs authorization checking it will do so assuming the specified identity, <em>ignoring any other credentials that might have accompanied the request</em>.</p><p>In the <em>indirect</em> mode, the Rname is followed by a different separator (a semi-colon, which cannot appear in an Rname) and an arbitrary string, called an <em>iptr</em> (identity pointer) that is safe to embed in a URI. The same character set from which an Rname can be generated is safe for an <em>iptr</em>: any number of alphanumerics, hyphens, and underscores. The rule that is specified by the Rname is expected to map the string to an identity, probably by using the \m[blue]<strong>identity element</strong>\m[]\s-2\u[20]\d\s+2, and the identity is used in the same way as in the direct mode. Like an Rname, in typical usage an <em>iptr</em> must be difficult to guess and be kept secret, otherwise a valid Rlink might easily be constructed that is associated with a chosen identity. The indirect mode has the advantages of keeping the URL relatively short, is immune to changes of the encryption key, and allows identities to be modified after an Rlink is shared.</p><p>An identity obtained using either attachment mode is tested for revocation.</p><p>The Rname, specified identity, and identity pointer are accessible in the \m[blue]<strong></strong><em>DACS</em> namespace\m[]\s-2\u[11]\d\s+2, when they are available, as <em>${DACS::RNAME}</em>, <em>${DACS::RIDENT}</em>, and <em>${DACS::RIPTR}</em>, respectively.</p><p>Rlinks can easily be created manually or by a custom program, but the \m[blue]<a href="../man1/dacsrlink.1.html"><strong>dacsrlink</strong>(1)</a></strong>\m[]\s-2\u[16]\d\s+2 utility provides a simple interface to create and administer them. Rules created by <strong>dacsrlink</strong> can be manually edited and deleted just like any other rule. Their is no <em>a priori</em> limit on the lifetime of an Rlink; it continues to exist as far as <strong>DACS</strong> is concerned if the Rname is recognized by an RLINK directive and the named rule exists and is valid. Deleting the rule corresponding to an Rname effectively invalidates that Rlink.</p><p>An Rname can be presented as an ordinary web service argument, as a component of the request URI, or via the special \m[blue]<strong>DACS_ACS argument</strong>\m[]\s-2\u[21]\d\s+2:</p>
<pre>
https://example.com/~alice/photos/myphoto.gif?RNAME=jigrFUwF
https://example.com/cgi-bin/manage.cgi/jigrFUwF
https://example.com/private/data?DACS_ACS=-rname+jigrFUwF
</pre>
<p>Each of these approaches has advantages and disadvantages; the best choice depends on web site and application details. For example, embedding an Rname as a component of a URI is particularly well suited to CGI programs and web services (e.g., https://example.com/cgi-bin/manage/jigrFUwF, where manage is the name of the program). Using the <em>DACS_ACS</em> argument allows the Rname to be used during access control testing but completely hidden from the requested resource.</p><p>\m[blue]<strong>RLINK</strong>\m[]\s-2\u[17]\d\s+2 directives are used to examine an incoming request, decide whether an Rname is present, extract the Rname, and specify where the rule can be found. If an Rname is present, normal access control processing is disabled and no search of the usual <strong>DACS</strong> rulesets for an applicable rule occurs. If no RLINK directive finds an Rname, normal access control processing occurs.</p><p>The main advantage of Rlinks is that they make controlled file sharing and web service access simple. An Rlink is created and disseminated, and all recipients can access the named resource (subject to the Rlink&apos;s rule) using any web browser. Any number of different rules can be created for the same resource, with each one having a different Rname. An Rlink&apos;s rule can be changed or deleted by its owner at any time, even after it has been distributed.</p><p>Rlinks also offer an alternative way to make exceptions to the rule normally applicable. Rather than revising the "normal" rule for a resource or set of resources to take account for the exceptions, one or more Rlinks can be created to handle the special cases and the normal rules need not be touched.</p><p>Another application of Rlinks is as a short representation of an arbitrary URL. Someone accessing an Rlink that has been configured in this way is redirected to a specified URL; see the \m[blue]<strong>redirect()</strong>\m[]\s-2\u[22]\d\s+2 function. The URL can be changed at will simply by editing the Rlink&apos;s rule. The Rlink need not be kept secret when it is used for this purpose.</p><p>The main disadvantage of Rlinks is that security may rely on keeping Rnames secret, and because an Rlink may be visible in a URL, this can be difficult to keep up. Anyone who can capture an Rname and use it properly with a resource to which it applies can potentially gain access to that resource. An Rname might be found in a log file, or in a browser&apos;s history or bookmark list. Although this method is convenient for users, the requirement for secrecy means that it might not be appropriate in some situations. At the expense of some convenience, however, a password can be bound to an Rlink when it is created; for the Rlink to be valid when it is invoked, the same password must be presented as an argument. Furthermore, because the access control rule associated with an Rname is the same as any other rule, it may express any conditions it likes, so it can still require authentication to have been performed, restrict the user&apos;s IP address, and so on. Also, an Rlink cannot be used to gain access to a resource that is not described by its rule&apos;s services element.</p>
<h3>HTTP Authentication</h3>
<p><strong>dacs_acs</strong> can be configured to trigger HTTP authentication (see \m[blue]<strong>RFC 2617</strong>\m[]\s-2\u[14]\d\s+2) by returning a WWW-Authenticate response header in certain circumstances. This will usually cause a browser or other web user agent to use its built-in mechanism for prompting the user for a username and password that corresponds to a particular access realm (a label that identifies a URL path prefix belonging to the server).</p><p>If <strong>dacs_acs</strong> denies access because the user is not authenticated (code <strong>902</strong>, ACS_DENIAL_REASON_NO_AUTH), it checks to see if HTTP authentication has been enabled for the request. If not, processing of the denied request proceeds normally, otherwise <strong>DACS</strong> will try to use the \m[blue]<strong>RFC 2617</strong>\m[]\s-2\u[14]\d\s+2 protocol to have <strong>dacs_authenticate</strong> authenticate the user.</p><p><strong>Tip</strong></p><p>This feature is configured through the \m[blue]<strong>HTTP_AUTH_ENABLE</strong>\m[]\s-2\u[23]\d\s+2 and \m[blue]<strong>HTTP_AUTH</strong>\m[]\s-2\u[24]\d\s+2 directives, some configuration variables, and \m[blue]<strong>Auth clause directives</strong>\m[]\s-2\u[25]\d\s+2. Please refer to them for details.</p><p>When HTTP authentication is triggered in this way, <em>no extra </em><em></em><strong>Apache</strong><em> configuration needs to be done or should be done</em>. All that is required of <strong>Apache</strong> is that the resource that should trigger authentication be <strong>DACS</strong>-wrapped.</p><p><em>Any</em>password style authentication module, or the CAS authentication module, can be configured in conjunction with <strong>DACS&apos;s</strong> HTTP Basic authentication. That is, <strong>DACS</strong> can be configured to cause a browser to pop-up a username/password prompt and then use the values supplied by the user as if they were the <em>USERNAME</em> and <em>PASSWORD</em> arguments to <strong>dacs_authenticate</strong>. The authentication module on the backend of the authentication procedure can use any type of <strong>Apache</strong> password file or <strong>DACS</strong> password file, NTLM, CAS, etc.</p><p>Besides authenticating against an <strong>Apache</strong> password file created by <strong>htpasswd</strong>, <strong>htdigest</strong>, or <strong>htdbm</strong>, this means that an ordinary browser can be used to capture a username and password for any <strong>DACS</strong> authentication module that requires it. Please refer to the description of the \m[blue]<strong>local_apache_authenticate</strong>\m[]\s-2\u[26]\d\s+2 module for details.</p><p>If the feature is enabled and applies to a request:</p><p>any \m[blue]<strong>ACS_ERROR_HANDLER</strong>\m[]\s-2\u[27]\d\s+2, \m[blue]<strong>AUTH_SUCCESS_HANDLER</strong>\m[]\s-2\u[28]\d\s+2, and \m[blue]<strong>AUTH_ERROR_HANDLER</strong>\m[]\s-2\u[29]\d\s+2 directives that would ordinarily apply are overridden.</p><p>the \m[blue]<strong>HTTP_AUTH</strong>\m[]\s-2\u[24]\d\s+2 directive that applies to the request specifies the authentication scheme, realm, and any additional authentication parameters.</p><p>a WWW-Authenticate response header is returned to the browser. For example, for Basic authentication this header might look like:</p>
<pre>
WWW-Authenticate: Basic realm="My Realm"
</pre>
<p>an HTTP status value of <strong>401</strong> (\m[blue]<strong>RFC 2616</strong>\m[]\s-2\u[30]\d\s+2) is returned. If the variable <em>${Conf::http_auth_message}</em> is defined, its value is used as the message body; if it is "", then no message body will be sent; if not provided, the string "902 Authentication by DACS is required" is used.</p><p>if the variable <em>${Conf::http_auth_jurisdiction}</em> is configured, it is expected to be the name of the jurisdiction (within the current federation) at which <strong>dacs_authenticate</strong> is to be invoked to authenticate the user; if the variable is undefined, the name of the current jurisdiction is used.</p><p>The values of some of these variables are neither examined by <strong>DACS</strong> nor meaningful to it. For example, all that <strong>DACS</strong> requires of the realm string is that it be syntactically valid.</p><p>When enabled, the following flow of control occurs:</p><p>The user hits a <strong>DACS</strong>-wrapped URL when not authenticated; if <strong>dacs_acs</strong> is configured to perform HTTP authentication for the request, it returns a <strong>401</strong> ("Unauthorized") status code and a WWW-Authenticate header;</p><p>The browser prompts for a username and password; the user enters the information and the browser re-submits the request, which this time includes an Authorization header;</p><p><strong>dacs_acs</strong> again denies the request because the user is not authenticated, but sees an Authorization header and redirects the user to <strong>dacs_authenticate</strong> (at <em>${Conf::http_auth_jurisdiction}</em> or the current jurisdiction) with arguments necessary for the selected authentication scheme; <strong>dacs_authenticate</strong> maps the given username (and password, if available) to the <em>USERNAME</em> argument (and possibly the <em>PASSWORD</em> argument) and invokes authentication modules as necessary;</p><p>If authentication succeeds, credentials are issued and the user is redirected to the original request (via the GET method);</p><p>If authentication fails, the procedure is repeated from the beginning.</p><p><strong>Note</strong></p><p>If a user authenticates using Basic authentication, signs out of <strong>DACS</strong>, and in the same browser session hits the link to trigger authentication, credentials may be automatically re-issued without prompting. This is because the browser will continue to send the Authorization request header, which <strong>dacs_authenticate</strong> may continue to honour.</p><p>With Digest authentication, various aspects of the authentication protocol are subject to time limits as a security measure. The configuration variable <em>${Conf::http_auth_timeout_secs}</em> can be set to the number of seconds for which a nonce is valid, thereby overriding the default; only advanced administrators familiar with \m[blue]<strong>RFC 2617</strong>\m[]\s-2\u[14]\d\s+2 should change the default.</p><p>The following is an example of configuration that might appear in the appropriate section (or sections) in <strong>DACS</strong> configuration files:</p>
<pre>
HTTP_AUTH_ENABLE "yes"
HTTP_AUTH "Basic &#92;"Doggies&#92;" /basic/*"

EVAL ${Conf::http_auth_message} = &#92;
  "902 https://example.com/cgi-bin/dacs/dacs_authenticate"
</pre>
<p>Given this example configuration, whenever access is denied for a resource having a URL path that begins with "/basic/" because the user is not authenticated, the following response-headers will be returned:</p>
<pre>
WWW-Authenticate: Basic realm="Doggies"
Status: 401
</pre>
<p>and the message body will contain the single line:</p>
<pre>
902 https://example.com/cgi-bin/dacs/dacs_authenticate
</pre>
<p>Instead of enabling the feature for <em>all</em> requests, the following example enables it only for those user agents that supply a User-Agent request-header that matches the regular expression "DACS-http/.*" (which happens to match the default User-Agent string sent by the <strong>DACS</strong>\m[blue]<a href="../man1/dacshttp.1.html"><strong>dacshttp</strong>(1)</a></strong>\m[]\s-2\u[31]\d\s+2 utility).</p>
<pre>
HTTP_AUTH_ENABLE = regmatch("${DACS::USER_AGENT}", "DACS-http/.*") ? "yes" : "no"
</pre>
<p>A similar expression would enable the feature only for <strong>Internet Explorer</strong>, <strong>Mozilla</strong>, <strong>curl</strong>, \m[blue]<a href="../man1/dacshttp.1.html"><strong>dacshttp</strong>(1)</a></strong>\m[]\s-2\u[31]\d\s+2, etc., or some combination of browsers. Simply obtain the User-Agent string(s) sent by the browser(s) and write the appropriate regular expression to match it/them.</p><p>Although \m[blue]<strong>RFC 2617</strong>\m[]\s-2\u[14]\d\s+2 allows multiple WWW-Authenticate response-headers to be returned, this mechanism can only send one.</p><p>When provided by a user agent, <strong>dacs_acs</strong> makes the value of the Authorization request-header available to access control rules through the <em>${DACS::AUTHORIZATION}</em> variable. <strong>DACS</strong> credentials can also be \m[blue]<strong>passed using this request-header</strong>\m[]\s-2\u[32]\d\s+2.</p>
<h3>Authorization Caching</h3>
<p>After a rule grants access, <strong>dacs_acs</strong> can be configured to save some context about its access control decision so that if the user makes a subsequent request for a resource managed by the same rule in a similar context, authorization can be granted quickly and without having to search for the applicable rule or re-evaluate it. Basically, the administrator tells <strong>DACS</strong> that if the rule grants access to a particular user, then it is safe for <strong>DACS</strong> to assume that future requests for the same resource by the same user should be granted without doing a complete authorization check.</p><p>This mechanism offers improved performance in cases where:</p><p>users tend to make many requests for the same resource, or for a set of resources that are managed by the same rule (such as CSS files or images);</p><p>rule evaluation is relatively slow or expensive;</p><p>there are a large number of rules and/or rule retrieval is relatively slow;</p><p>re-evaluation of the rule is unnecessary (e.g., the rule does not update any state information)</p><p>it is acceptable for changes to the ruleset to not immediately affect cachable decisions</p><p><strong>Security</strong></p><p>Pending further testing, this feature should be considered experimental. Use it in production situations only after you have satisfied yourself that it is working properly with your access control rules.</p><p>Authorization caching is implemented using a special HTTP cookie, called an access token (not related to the tokens used in authentication), and a simple database maintained by <strong>dacs_acs</strong>. A cookie is returned to the user when caching is possible and the user does not already possess a valid cookie. An access token points to server-side data that describes the cached authorization, including the context in which it is valid. Immediately after revocation testing, <strong>dacs_acs</strong> checks if authorization caching applies to the current request; if it does, no access control rules are examined and access is immediately granted. If caching does not apply, process continues as usual. If any invalid access tokens were sent with the request, <strong>dacs_acs</strong> will ask for them to be deleted (i.e., it unsets the cookies). These cookies have the following format:</p>
<pre>
DACS:<em>federation-name</em>::<em>jurisdiction-name</em>::TOKEN-<em>unique</em>
</pre>
<p>Here, <em>unique</em> is the "dacs64" encoding (see \m[blue]<a href="../man5/dacs.exprs.5.html"><strong>dacs.exprs</strong>(5)</a></strong>\m[]\s-2\u[33]\d\s+2) of a cryptographically strong pseudo-random 16 byte value. Since access control is purely a jurisdictional responsibility in <strong>DACS</strong>, a cookie is meaningful only to the jurisdiction that issues it.</p><p>These cookies are non-persistent (they are supposed to disappear when a browser session ends). The value of \m[blue]<strong>COOKIE_PATH</strong>\m[]\s-2\u[34]\d\s+2, or "/", determines the cookie&apos;s path attribute. The \m[blue]<strong>COOKIE_NO_DOMAIN</strong>\m[]\s-2\u[35]\d\s+2 and \m[blue]<strong>COOKIE_HTTP_ONLY</strong>\m[]\s-2\u[36]\d\s+2 directives are also honoured.</p><p>Here is a simple example of how <strong>DACS</strong> might be configured to enable authorization caching for a particular resource. The jurisdiction&apos;s dacs.conf would include directives similar to the following:</p>
<pre>
ACS_ACCESS_TOKEN_ENABLE        "yes"
ACS_ACCESS_TOKEN_LIFETIME_SECS "43200"
VFS                            "[tokens]dacs-kwv-fs:/usr/local/dacs/conf/tokens"
</pre>
<p>A rule for the resource might look like this:</p>
<pre>
&lt;acl_rule status="enabled"&gt;
   &lt;services&gt;
     &lt;service url_pattern="/cgi-bin/database.cgi"/&gt;
     &lt;service url_pattern="/cgi-bin/someprog.cgi"/&gt;
   &lt;/services&gt;

   &lt;rule order="allow,deny"&gt;
     &lt;allow permit_caching="yes"&gt;
       user("auth")
     &lt;/allow&gt;
   &lt;/rule&gt;
&lt;/acl_rule&gt;
</pre>
<p>Given this configuration, the first time an authenticated user requests, say, https://example.com/cgi-bin/database.cgi, he will be issued an access token. This token will be valid for up to 12 hours, and its associated data will be stored as an entry in the file /usr/local/dacs/conf/tokens.</p><p><strong>Note</strong></p><p>In the current implementation, each access token is contained within its own cookie, rather than a jurisdiction collecting all of the user&apos;s tokens within a single cookie. A user might therefore simultaneously hold many access tokens from each jurisdiction. This should not be significant for middleware agents, but web browsers typically impose various kinds of limits on cookie "real estate". Administrators should take this into account when using this feature.</p><p>Before it can be used, <strong>DACS</strong> must be built with the feature enabled (see <strong>--enable-access-tokens</strong> in \m[blue]<a href="../man7/dacs.install.7.html"><strong>dacs.install</strong>(7)</a></strong>\m[]\s-2\u[37]\d\s+2). The virtual filestore item type "tokens" must be configured to identify an indexed virtual storage method and location for storing cache entries. Also, the authorization caching mechanism must be configured (see \m[blue]<strong>ACS_ACCESS_TOKEN_ENABLE</strong>\m[]\s-2\u[38]\d\s+2, \m[blue]<strong>ACS_ACCESS_TOKEN_LIFETIME_LIMIT</strong>\m[]\s-2\u[39]\d\s+2, and \m[blue]<strong>ACS_ACCESS_TOKEN_LIFETIME_SECS</strong>\m[]\s-2\u[40]\d\s+2).</p><p>Enabling the feature in a particular context also requires setting a rule&apos;s permit_caching attribute to "yes" (see \m[blue]<a href="../man5/dacs.acls.5.html"><strong>dacs.acls</strong>(5)</a></strong>\m[]\s-2\u[41]\d\s+2). Whenever access is granted because of the rule, authorization caching of the rule is possible.</p><p><strong>Note</strong></p><p>Only the url_pattern of the rule&apos;s matching Service element (or the path derived from a url_expr attribute) is associated with the access token. This implies that when a rule has more than one service element, as in the example rule above, a single access token would be associated with only one of the two resources. Requests for different services could result in multiple access tokens being returned to a user, one for each service. A wildcard pattern is required if an access token is intended to grant access to more than one resource (this restriction may be lifted in future releases).</p><p>Note that although a service request&apos;s arguments may be significant when initially granting access, they are not significant with respect to authorization caching applied to subsequent requests that use the access token. Once an access token is issued, the resource or resources named by it may therefore be invoked with different arguments without negating authorization caching.</p><p>If any constraint, permit_chainingpass_credentials, or pass_http_cookie attributes are associated with the cachable rule, their values are also remembered and set if the access token subsequently causes access to be granted.</p><p>Authorization caching is possible irrespective of whether a user has been authenticated. Caching is not allowed, however, in cases where the granting rule uses \m[blue]<strong>tail matching</strong>\m[]\s-2\u[42]\d\s+2<em>and</em> a rule exists for a subordinate URL (i.e., where there is a "more specific" rule for some other resource that should not be overridden by caching the "more general" rule). These cases are simply ignored; they are not considered to be errors. It is therefore not possible to cache the outcome of a rule with a url_pattern of "/*", for example, unless it is the only rule in the ruleset.</p><p><strong>Note</strong></p><p>A positive result will be cached regardless of whether the requested resource actually exists or is subsequently processed without error by the web server. It is therefore possible for an access token to be issued for a resource that does not exist at the time of issue but which is created at some later time.</p><p>The store of tokens may be deleted or modified at any time. Any access token that points to an invalid or missing entry in the store becomes invalid.</p><p>Over time, the server-side access token database tends to accumulate entries for access tokens that no longer exist or have expired. These should be garbage collected. (This is currently not automated, so the database needs to be truncated. There should also be way to list the entries and manually delete entries.) The \m[blue]<a href="../man1/dacsacl.1.html"><strong>dacsacl</strong>(1)</a></strong>\m[]\s-2\u[43]\d\s+2 command and \m[blue]<a href="../man8/dacs_admin.8.html"><strong>dacs_admin</strong>(8)</a></strong>\m[]\s-2\u[44]\d\s+2 service can perform administrative functions on the entry database.</p><p><strong>Security</strong></p><p>Access tokens are created and used in such a way that it is practically impossible for an attacker to manufacture a valid access token or to convert an access token valid for one resource into one valid for a different resource.</p><p>If a user is authenticated at the time an access token is generated, the token is "tied" to those credentials (all of them) and becomes invalid if any of the credentials become invalid or are not sent with the access token. If a user signs out or reauthenticates after being issued an access token, therefore, the access token will become invalid. Additional credentials, beyond what were present at the time an access token was generated, have no effect in this regard.</p><p>As with cookies bearing <strong>DACS</strong> credentials, cookies containing access tokens must be kept private. For an authenticated user, an attacker would need to acquire an access token <em>and all credentials</em> to make use of the token. For an unauthenticated user, only the access token is needed; presumably (but not necessarily) in this case a lower level of security is being applied to the resource in any case.</p><p>It is the administrator&apos;s responsibility to ensure that authorization caching does not break the intended semantics of a rule - <strong>DACS</strong> does not do any consistency or sanity checks. For instance, if a rule is written to grant access only between 12:00 and 12:59 but an access token produced by the rule could continue to be valid beyond that time interval, authorization caching could violate the intent of the rule. Also, a rule that ordinarily produces side effects would not do so for any requests granted through authorization caching.</p><p>As long as an authorization decision remains valid, changes to the ruleset will not cause a cached decision to be reversed. That is, a change to the ruleset that would ordinarily cause a request to be denied will have no effect on a cached decision. The \m[blue]<strong>revocation list</strong>\m[]\s-2\u[45]\d\s+2 is, however, processed as usual, so it is possible for a cached decision to be denied due to revocation. An error encountered during processing would also cause access to be denied, regardless of authorization caching.</p>
<h3>XML Output</h3>
<p>When XML output has been enabled, <strong>dacs_acs</strong> will emit a document (conforming to \m[blue]<strong>dacs_acs.dtd</strong>\m[]\s-2\u[46]\d\s+2) when access is denied, a processing error occurs, or when an access testing mode has been requested using the <em>DACS_ACS</em> argument.</p><p><strong>dacs_acs</strong> associates an error code with each event or reason for which access might be denied (see the description of the ACS_ERROR_HANDLER directive in \m[blue]<strong>dacs.conf</strong>(5)</strong>\m[]\s-2\u[47]\d\s+2). The error code is itself sufficient for a client to know why access was denied. When access is denied, an appropriately named XML element is emitted. The element will include an explanatory text message, and optionally, the URI of a handler that the client might call to continue the workflow. This URI is obtained from the applicable ACS_ERROR_HANDLER directive, if any.</p><p>The event905 element corresponds to the ACK_NEEDED (equivalent to error code <strong>905</strong>) <strong>DACS</strong> error event. It is emitted if the client must acknowledge one or more notices before the request will be granted. Its handler attributes, which are optional, are obtained from the ACS_ERROR_HANDLER directive that applies to this error and the NOTICES_ACK_HANDLER directive. If the ack_handler attribute is absent, then the presentation_handler is expected to perform both presentation and acknowledgement handling functions. The notice_uris attribute is a comma-separated list of URIs of notices that must be acknowledged by the user. The resource_uris attribute is a comma-separated list of URIs of resources associated with this request; this will usually be only a single URI. The time and hmac attributes are used to enforce a secure workflow mode. Please refer to \m[blue]<a href="../man8/dacs_notices.8.html"><strong>dacs_notices</strong>(8)</a></strong>\m[]\s-2\u[48]\d\s+2 and \m[blue]<strong>dacs.conf</strong>(5)</strong>\m[]\s-2\u[47]\d\s+2 for additional detail.</p><p>A common_status element indicates that <strong>dacs_acs</strong> could not process the request. This might happen, for example, if <strong>dacs_acs</strong> were not properly configured.</p>
<h3>Variables Available To Rules</h3>
<p><strong>dacs_acs</strong> predefines several variables that may be accessed by rules. Additionally, variables obtained from the request&apos;s credentials are exported into the environment of an invoked CGI program. In this way, services can know who is making the request, to retrieve user preferences, for example.</p><p>In addition, parameters passed to a CGI program, whether through a query string or a message body (e.g., POST method data), may be accessed as variables. For example, for the service request:</p>
<pre>
 .../cgi-bin/foo?A=hello&B=world
</pre>
<p>the variables <em>${Args::A}</em> with the value hello and <em>${Args::B}</em> with the value world will be defined at the time ACL rulesets are evaluated. Also, variables obtained from the authenticated credentials may be referenced (e.g., <em>${DACS::JURISDICTION}</em>).</p><p><strong>Note</strong></p><p>Because at present a variable cannot be multi-valued, if a variable is set more than once its value at the time of evaluation is not predictable. For example, given this query string you cannot depend on which value is assigned to <em>${Args::ARG}</em>:</p>
<pre>
 .../cgi-bin/foo?ARG=hello&ARG=world
</pre>
<p>This also creates problems if you need to examine arguments produced by an HTML SELECT element within a form when the MULTIPLE attribute is used because each OPTION selected by the user will be associated with the same argument name. Syntactical and functional improvements are planned in this regard.</p><p>Any "null" arguments in the query string (e.g., "&&") are ignored. A query string with a component that has a value but not a name (e.g., "&=foo") is considered to be invalid.</p><p>From these sources, the execution environment, and from the <strong>DACS</strong> configuration, <strong>dacs_acs</strong> automatically creates four "classes" of variables: CGI parameter variables, configuration variables, environment variables, and request-specific variables created by <strong>DACS</strong>. These classes are called namespaces; please refer to \m[blue]<a href="../man5/dacs.exprs.5.html"><strong>dacs.exprs</strong>(5)</a></strong>\m[]\s-2\u[49]\d\s+2 for details. For example, the value of a CGI parameter is accessed by <em>${Args::</em><em></em><em>varname</em><em>}</em>, the value of a <strong>DACS</strong> context variable is accessed by <em>${DACS::</em><em></em><em>varname</em><em>}</em> (e.g., <em>${DACS::JURISDICTION}</em>), and the value of configuration variable is obtained using <em>${Conf::</em><em></em><em>varname</em><em>}</em> (e.g., <em>${Conf::FEDERATION_DOMAIN}</em>).</p><p>For <strong>dacs_acs</strong>, the <em>Env</em> namespace is comprised of all CGI variables exported by <strong>Apache</strong>, which includes HTTP request variables such as <em>${Env::HTTP_USER_AGENT}</em>. The values of recognized headers that might compromise security are edited or deleted. Note that <strong>Apache</strong> will export unrecognized HTTP request headers by prefixing the header name with HTTP_ and mapping the header name to upper case; this example results in <em>${Env::AUGGIE}</em> having the value "Doggie":</p>
<pre>
% http -header Auggie Doggie https://example.com/cgi-bin/dacs/someprog
</pre>
<p>For other programs, the <em>Env</em> namespace is populated from the program&apos;s normal environment.</p><p>These namespaces are reserved from other uses and their contents are, for the most part, read-only.</p><p>The only MIME content types currently supported with respect to capturing CGI parameters are application/x-www-form-urlencoded, which is the default used by browsers when submitting a form, and multipart/form-data. At present, only 7bit data encoding is supported. The methods by which values from forms can be returned to a server are described in \m[blue]<strong>RFC 1867</strong>\m[]\s-2\u[50]\d\s+2, \m[blue]<strong>RFC 2388</strong>\m[]\s-2\u[51]\d\s+2, and \m[blue]<strong>HTML 4</strong>\m[]\s-2\u[52]\d\s+2.</p><p>The following variables are exported to the "<em>DACS</em>" namespace (e.g., <em>${DACS::QUERY}</em>). Upper and lower case are distinct in variable names. These values are either obtained from <strong>Apache</strong> or are elements of the client&apos;s credentials.</p><p><em>ACS</em></p><p>If <strong>dacs_acs</strong> is requested to test access, this variable will be defined and have the value of the <em>DACS_ACS</em> argument.</p><p><em>ARGS</em></p><p>A string representing all of the parameters to a CGI program, excluding multipart/form-data, encoded as a query string. If the number or total size of the parameters exceeded the implementation-dependent limit, the variable <em>ARGS_TRUNCATED</em> will be defined and have a non-zero value.</p><p><em>ARGS_TRUNCATED</em></p><p>If this variable is defined and its value is non-zero, the argument list has been truncated. This means that not all arguments to the CGI program are accessible to <strong>dacs_acs</strong> and the value of one argument may have been truncated. See \m[blue]<strong>ACS_POST_EXCEPTION_MODE</strong>\m[]\s-2\u[53]\d\s+2.</p><p><em>ARG_COUNT</em></p><p>The number of arguments available in the <em>Args</em> namespace. If there are four arguments in a request&apos;s query string and two arguments within its application/x-www-form-urlencoded message body, for instance, then the value of <em>${DACS::ARG_COUNT}</em> will be six. These arguments will be available collectively as the value of <em>${DACS::ARGS}</em> and individually in the <em>Args</em> namespace.</p><p><em>AUTHORIZATION</em></p><p>The value of the Authorization HTTP header field, if available.</p><p><em>CONTENT_ENCODING</em></p><p>The value of the Content-Encoding HTTP header field, if available.</p><p><em>CONTENT_LENGTH</em></p><p>The value of the Content-Length HTTP header field, if available.</p><p><em>CONTENT_TYPE</em></p><p>The value of the Content-Type HTTP header field, if available.</p><p><em>CURRENT_URI</em></p><p>The full URI for the requested resource, including any query component.</p><p><em>CURRENT_URI_NO_QUERY</em></p><p>The full URI for the requested resource, excluding any query component.</p><p><em>FEDERATION</em></p><p>The official name of the federation to which <em>JURISDICTION</em> belongs. If the user was not authenticated, this variable will be undefined.</p><p><em>FILENAME</em></p><p>The full path of the file corresponding to the URL being invoked, equivalent to <strong>Apache</strong>&apos;s <strong>SCRIPT_FILENAME</strong> environment variable or its <em>REQUEST_FILENAME</em> variable.</p><p><em>IDENTITY</em></p><p>The <strong>DACS</strong> identity (the username component plus federation and jurisdiction components) if the user was authenticated, otherwise undefined.</p><p><em>INTERACTIVE</em></p><p>If the standard input is a valid terminal type device, this variable is set to 1, otherwise it is undefined.</p><p><em>IP</em></p><p>The IP address, in standard numeric dot notation, associated with <em>USERNAME</em>. If the user was not authenticated, this variable will be undefined.</p><p><em>JURISDICTION</em></p><p>The official, abbreviated name of the jurisdiction that authenticated <em>USERNAME</em>. If the user was not authenticated, this variable will be undefined.</p><p><em>METHOD</em></p><p>The method used to invoke the URL, equivalent to <strong>Apache</strong>&apos;s <strong>REQUEST_METHOD</strong> environment variable.</p><p><em>PATH_INFO</em></p><p>The <strong>PATH_INFO</strong> part of the URI, as set by <strong>Apache</strong>.</p><p><em>POSTDATA</em></p><p>A MIME base-64 encoded string representing the data stream (message body) sent to a CGI program. If the number or total size of the parameters exceeded the configured limit, the variable <em>ARGS_TRUNCATED</em> will be defined and have a non-zero value. See the description of the SetDACSAuthPostBuffer directive to \m[blue]<strong>mod_auth_dacs</strong>\m[]\s-2\u[12]\d\s+2).</p><p><em>PROXYREQ</em></p><p>If set, the type of proxy processing performed for this request by Apache (from <em>SERVICE_PROXYREQ</em>).</p><p><em>QUERY</em></p><p>The query string, if any, that was appended to the URL.</p><p><em>REMOTE_ADDR</em></p><p>The <strong>REMOTE_ADDR</strong>, as set by <strong>Apache</strong>.</p><p><em>REMOTE_HOST</em></p><p>The <strong>REMOTE_HOST</strong>, as set by <strong>Apache</strong>.</p><p><em>RIDENT</em></p><p>The Rlink identity, if any, associated with the rule currently being evaluated. See \m[blue]<strong>Rlinks</strong>\m[]\s-2\u[54]\d\s+2.</p><p><em>RIPTR</em></p><p>The Rlink identity pointer, if any, associated with the rule currently being evaluated. See \m[blue]<strong>Rlinks</strong>\m[]\s-2\u[54]\d\s+2.</p><p><em>RNAME</em></p><p>The Rname, if any, associated with the rule currently being evaluated. This is also available as <em>${Args::RNAME}</em>. See \m[blue]<strong>Rlinks</strong>\m[]\s-2\u[54]\d\s+2.</p><p><em>ROLES</em></p><p>The role string associated with <em>USERNAME</em>. If the user was not authenticated, this variable will be undefined.</p><p><em>URI</em> and <em>URL</em></p><p>The URL being invoked.</p><p><em>USERNAME</em></p><p>The username (without any federation or jurisdiction component). If the user was not authenticated, this variable will be undefined.</p><p><em>USER_AGENT</em></p><p>When provided by the user agent, this is equivalent to the HTTP User-Agent request-header field and <strong>HTTP_USER_AGENT</strong> environment variable provided by <strong>Apache</strong>. When an actual value is unavailable, this variable is set to "unknown".</p>
<h3>Exported Environment Variables</h3>
<p>The normal execution environment of a CGI program or internally processed script (e.g., <strong>mod_php</strong>) invoked through <strong>DACS</strong> is augmented with environment variables instantiated from validated credentials, access control rules, configuration information, and so on. Through these variables, services have access to the identity of the user making the request to retrieve user preferences, for example, or make run-time decisions.</p><p><strong>Note</strong></p><p>Environment variables with the prefix "DACS_" are reserved for use by <strong>DACS</strong> and should not be used for other purposes by an application. Upper and lower case are distinct in variable names.</p><p><strong>Tip</strong></p><p>If \m[blue]<strong>PHP</strong>\m[]\s-2\u[55]\d\s+2 is installed, a nice way to see the <strong>DACS</strong> environment variables that are passed to a CGI program is to run a <strong>DACS</strong>-wrapped script like this:</p>
<pre>
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;
&lt;html&gt;&lt;head&gt;
&lt;meta http-equiv="Content-type" content="text/html;charset=ISO-8859-1"&gt;
&lt;title&gt;&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;
&lt;?php
phpinfo();
?&gt;
&lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;
</pre>
<p>Alternatively, you can use \m[blue]<a href="../man8/dacs_prenv.8.html"><strong>dacs_prenv</strong>(8)</a></strong>\m[]\s-2\u[56]\d\s+2.</p><p>Currently defined environment variables are listed here. More detailed descriptions of these variables appear in other <strong>DACS</strong> documents.</p><p><strong>DACS_ACS_JURISDICTION</strong></p><p>This is the official <strong>DACS</strong> internal, abbreviated name for the jurisdiction that has granted access.</p><p><strong>DACS_APPROVAL</strong></p><p>A digitally signed message that confirms that <strong>DACS</strong> authorized the request. See \m[blue]<a href="../man8/dacs_acs.8.html"><strong>dacs_acs</strong>(8)</a></strong>\m[]\s-2\u[57]\d\s+2.</p><p><strong>DACS_CONCISE_IDENTITY</strong></p><p>This is the full <strong>DACS</strong> identity to which access was granted expressed in the concise syntax used by \m[blue]<a href="../man1/dacscheck.1.html"><strong>dacscheck</strong>(1)</a></strong>\m[]\s-2\u[2]\d\s+2. When available, the user&apos;s roles and IP address are included.</p><p><strong>DACS_CONF</strong></p><p>This is the full pathname of the <strong>DACS</strong> configuration file.</p><p><strong>DACS_CONSTRAINT</strong></p><p>A constraint string associated with a sub-component of the matching access control rule permitting the service request.</p><p><strong>DACS_DEFAULT_CONSTRAINT</strong></p><p>A constraint string associated with the matching access control rule.</p><p><strong>DACS_FEDERATION</strong></p><p>This is the federation name component of <strong>DACS_IDENTITY</strong>.</p><p><strong>DACS_IDENTITY</strong></p><p>This is the full <strong>DACS</strong> identity to which access was granted. <strong>Apache</strong>&apos;s <strong>REMOTE_USER</strong> environment variable is also set to this value, so it is available for logging purposes and export to CGI programs.</p><p><strong>DACS_JURISDICTION</strong></p><p>This is the jurisdiction component of <strong>DACS_IDENTITY</strong>.</p><p><strong>DACS_MOD_AUTH_DACS</strong></p><p>This is a version identification string for \m[blue]<strong>mod_auth_dacs</strong>\m[]\s-2\u[3]\d\s+2.</p><p><strong>DACS_ROLES</strong></p><p>This is the role string associated with <strong>DACS_USERNAME</strong> within <strong>DACS_JURISDICTION</strong>.</p><p><strong>DACS_SITE_CONF</strong></p><p>This is the full pathname of the <strong>DACS</strong> site configuration file.</p><p><strong>DACS_USERNAME</strong></p><p>This is the username component of the identity to which access was granted.</p><p><strong>DACS_VERSION</strong></p><p>The major version number of <strong>DACS</strong>.</p><p><strong>About Servlets</strong></p><p><strong>Note</strong></p><p>The details of how environment variables are passed from <strong>Apache</strong> to servlets are beyond the scope of <strong>DACS</strong>. But for what it&apos;s worth, the following illustrates how to export and access them from servlets that are under the control of <strong>DACS</strong> in conjunction with \m[blue]<strong>mod_jk</strong>\m[]\s-2\u[58]\d\s+2 and \m[blue]<strong>Tomcat</strong>\m[]\s-2\u[59]\d\s+2. This used to work at one time but may no longer be correct.</p><p>The following directives (which appear in, or are included in, the <strong>Apache</strong> configuration file) are used (this list may be expanded):</p>
<pre>
&lt;IfModule mod_jk.c&gt;
  JkEnvVar DACS_FEDERATION         NONE
  JkEnvVar DACS_JURISDICTION       NONE
  JkEnvVar DACS_ACS_JURISDICTION   NONE
  JkEnvVar DACS_ROLES              NONE
  JkEnvVar DACS_USERNAME           NONE
  JkEnvVar DACS_CONSTRAINT         NONE
  JkEnvVar DACS_DEFAULT_CONSTRAINT NONE
  JkEnvVar DACS_COOKIE             NONE
  JkEnvVar DACS_MOD_AUTH_DACS      NONE
&lt;/IfModule mod_jk.c&gt;
</pre>
<p>From a servlet, the values of these variables can be obtained through the <strong>getAttribute()</strong> method, invoked on an <em>HttpServletRequest</em> object. For example:</p>
<pre>
Object username = req.getAttribute("DACS_USERNAME");
out.println("roles = " + req.getAttribute("DACS_ROLES"));
</pre>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONS</h2>
        <div class="sectioncontent">
<p>In addition to the standard \m[blue]<strong></strong><em>dacsoptions</em>\m[]\s-2\u[1]\d\s+2, <strong>dacs_acs</strong> recognizes the following arguments:</p><p><strong>-proxy-static</strong></p><p>Reserved for future use.</p><p><strong>-proxy-exec</strong></p><p>Reserved for future use.</p><p><strong>-test</strong></p><p>Perform some self-tests, then exit. A non-zero exit status means an error occurred. If <strong>-test</strong> is the only argument (recommended), no configuration is necessary; otherwise, normal configuration processing will be performed before the self-tests.</p><h3>The DACS_ACS Argument</h3>
<p>Various aspects of the behaviour of <strong>dacs_acs</strong> can be controlled by an optional argument named <em>DACS_ACS</em>. This argument, which may be passed to <em>any</em> web service, is interpreted by <strong>dacs_acs</strong> rather than the web service that is being invoked. The value of this argument is parsed as a list of space-separated command line flags.</p><p><strong>Tip</strong></p><p>The space character(s) must be properly escaped; e.g., as %20 or +.</p><p>One use of this feature is when an application or middleware would like to know whether <strong>DACS</strong> will grant or deny a service request without having to actually execute the service request. When building a menu, for instance, an application might want to exclude items involving service requests that would be denied to the user. <strong>dacs_acs</strong> provides this capability.</p><p>To check whether access would be granted or denied, the application invokes the <strong>DACS</strong>-wrapped service or resource exactly as it would normally except that it provides the <em>DACS_ACS</em> argument. In some situations, if access would be denied <strong>dacs_acs</strong> will return an indication of what must be done; e.g., the user must authenticate or a notice must be acknowledged. Note that there can be multiple reasons for denying access, in which case an application may have to repeatedly request a check and address the reason for denial before access may be granted.</p><p>The <em>DACS_ACS</em> argument can be a query argument or can appear in a message body with the content type application/x-www-form-urlencoded (as in the case of an HTML form submitted using the POST method, for example). The <em>DACS_ACS</em> argument may not be specified more than once. It is not always possible to escape this argument (see \m[blue]<strong></strong><strong>-invisible</strong>\m[]\s-2\u[60]\d\s+2).</p><p>The following flags are recognized:</p><p><strong>-check_only</strong></p><p>The presence of this flag tells <strong>dacs_acs</strong> not to actually execute the web service or return the resource, but to merely return the access control decision. This flag and the <strong>-check_fail</strong> flag are mutually exclusive.</p><p>If the access check was performed, HTTP status code <strong>200</strong> (OK) will be returned; any other result indicates that the check could not be executed (e.g., due to an <strong>Apache</strong> configuration problem or a <strong>DACS</strong> error). If the check is performed, a DACS-Status-Line HTTP extension header is included in the response by default (see below).</p><p>The default response consists of a single line of text that gives the result. This line consists of a three digit result code, followed by a space, an explanatory message, and a newline character; for example,</p>
<pre>
797 Access denied
798 Access granted
799 Access error
</pre>
<p>Inspecting the result code is sufficient to obtain the outcome of the check. Any <strong>Apache</strong>ErrorDocument directive for "error-code" 200 is overridden. The <strong>-format</strong> flag (see below) can be used to select a different output format.</p><p><strong>Note</strong></p><p>The service or resource in question does not have to exist for <strong>dacs_acs</strong> to grant access; for instance, this can happen if a wildcard rule pattern is used. Also, keep in mind that access control rules can be written to be highly context specific; there is no guarantee that the same decision made at one point in time will also be made an instant later (access control rules can depend on the current date or time, for instance).</p><p>Rules can be written such that their evaluation results in persistent changes; for example, a database might be updated. These kinds of changes will occur both in normal operation and when only checking access. <strong>dacs_acs</strong> defines the variable <em>${DACS::ACS}</em> only during the testing mode of operation so that, if necessary, rules can be written to differentiate between testing mode and normal operation.</p><p><strong>-check_fail</strong></p><p>This flag is like the <strong>-check_only</strong> flag, except if access is granted the request is allowed to proceed. If access is not granted and HTTP status code <strong>200</strong> is returned, a DACS-Status-Line HTTP extension header is included in the response by default (see below). The <strong>-check_fail</strong> flag is useful in situations where a <strong>-check_only</strong> test that indicates that access would be granted is always immediately followed by the actual request. This flag and the <strong>-check_only</strong> flag are mutually exclusive.</p><p><strong>-format</strong> <em>fmt</em></p><p>By default, the <strong>-check_only</strong> flag (and in the case where access is denied, also the <strong>-check_fail</strong> flag) results in a single line of text being output (equivalent to "<strong>-format text</strong>"). If more detail is required, an XML description can be produced by specifying any of the XML output formats. Refer to \m[blue]<strong>XML Output</strong>\m[]\s-2\u[61]\d\s+2, the \m[blue]<strong></strong><em>FORMAT</em> CGI argument\m[]\s-2\u[62]\d\s+2, and the \m[blue]<strong></strong><strong>-format</strong>\m[]\s-2\u[63]\d\s+2 command line argument.</p><p><strong>-rname</strong> <em>rname</em></p><p>The string <em>rname</em>, which is assumed to be the name of an Rlink, is made available available as <em>${Args::RNAME}</em> during evaluation of \m[blue]<strong>ACS_PRE_AUTH</strong>\m[]\s-2\u[64]\d\s+2 directive expressions.</p><p><strong>-status_line</strong></p><p><strong>-no-status_line</strong></p><p>The <strong>-status_line</strong> flag enables the \m[blue]<strong>DACS-Status-Line</strong>\m[]\s-2\u[65]\d\s+2 header, overriding the setting of the \m[blue]<strong>STATUS_LINE</strong>\m[]\s-2\u[66]\d\s+2 configuration directive. The <strong>-no_status_line</strong> flag <em>always</em> suppresses this header, regardless of the \m[blue]<strong>STATUS_LINE</strong>\m[]\s-2\u[66]\d\s+2 directive and the <strong>-check_only</strong> and <strong>-check_fail</strong> flags.</p><p><strong>-visible</strong></p><p><strong>-invisible</strong></p><p>If the <em>DACS_ACS</em> argument is passed as a query argument, the default behaviour is to delete it so that it cannot be seen after access control processing grants access. This deletion is explicitly enabled by the <strong>-invisible</strong> flag and disabled by the <strong>-visible</strong> flag. If <em>DACS_ACS</em> is not deleted, it will be passed to an invoked program and might affect subsequent processing.</p><p><strong>Important</strong></p><p>Deletion of the <em>DACS_ACS</em> argument is currently possible only if it is passed as a query argument.</p><p>For example, consider the hypothetical URL:</p>
<pre>
https://example.com/cgi-bin/myprog?DACS_ACS=-check_fail+-visible&foo=baz
</pre>
<p>If the CGI program <strong>myprog</strong> is executed, it will not only see the <em>foo=baz</em> argument, but also the <em>DACS_ACS=-check_fail+-visible</em> argument, and this could trigger an error or incorrect behaviour when <strong>myprog</strong> processes it.</p><p>All <strong>DACS</strong> web services ignore a <em>DACS_ACS</em> argument, however, so its presence will not affect them.</p><p>The flag list is processed from left to right. Any flag may be repeated, with the value of a later occurrence overriding an earlier one. If some part of the <em>DACS_ACS</em> argument is invalid, the initial, valid part will still be effective; e.g., if the initial part is <strong>-format</strong>XML, the output format will be XML.</p><p><strong>dacs_acs</strong> removes the <em>DACS_ACS</em> argument from the rule-processing environment so as not to disturb access control processing. <strong>DACS</strong> credentials may accompany the service request just as they would a real request and are incorporated into the check.</p><p>Assuming the target resource is <strong>DACS</strong>-wrapped, instead of returning the resource, accessing the following URL would return an indication of whether an actual request to access the resource would be granted or denied:</p>
<pre>
% http -v -v &#92;
 &apos;https://dacs.dss.ca/infocard-demo/cgi-bin/dacs/dacs_version?DACS_ACS=-check_only%20-format+xml&apos;
</pre>
<p><strong>The DACS-Status-Line header</strong></p><p>When the <strong>DACS_ACS=-check_only</strong> argument is present, the response from <strong>DACS</strong> includes an extension header named DACS-Status-Line. The format of this extension header follows that of the HTTP Status-Line (\m[blue]<strong>RFC 2616</strong>\m[]\s-2\u[30]\d\s+2, section 6.1):</p>
<pre>
DACS-Status-Line = "DACS-Status-Line" ":" <em>DACS-Version</em> SP <em>ACS-Status-Code</em>
  SP <em>Reason-Phrase</em> CRLF
</pre>
<p>Where:</p>
<pre>
<em>DACS-Version</em> = "DACS-" <em>Version</em>
</pre>
<p>and <em>Version</em> is the <strong>DACS_VERSION_RELEASE</strong> string (e.g., 1.4.8b), and where:</p>
<pre>
<em>ACS-Status-Code</em> = "797" | "798" | "799"
</pre>
<p>The status code <strong>797</strong> means that <strong>DACS</strong> denies access, <strong>798</strong> means that it grants access, and <strong>799</strong> means that an error occurred during processing.</p><p>Here are some examples:</p>
<pre>
DACS-Status-Line: DACS-1.4.8b 797 Access denied
DACS-Status-Line: DACS-1.4.8b 798 Access granted
DACS-Status-Line: DACS-1.4.8b 799 Access error
</pre>
<p>The reason phrases in the examples are only recommendations; they may be replaced by local equivalents without affecting the protocol.</p><p><strong>Note</strong></p><p>The reason phrase may include additional information, such as an audit identifier, that can be used to track the request in the <strong>DACS</strong> logs:</p>
<pre>
DACS-Status-Line: DACS-1.4.10 798 Access granted, unauth user (j10OXL2Z)
</pre>
<p>This header is also returned when <strong>-check_fail</strong> is requested, but only if access is not granted.</p><p><strong>The DACS_APPROVAL environment variable</strong></p><p>If enabled by the \m[blue]<strong>ACS_EMIT_APPROVAL</strong>\m[]\s-2\u[67]\d\s+2 directive, the <strong>DACS_APPROVAL</strong> environment variable will be passed to a <strong>DACS</strong>-wrapped program. If the program cares to verify that its execution has been authorized, it may validate the approval&apos;s signature (to ensure that the approval has not been forged) and validate the stamp (to ensure that the approval is not being replayed). Note that if a man-in-the-middle attack is of concern, end-to-end encryption should be used.</p><p>With proper configuration, this feature can be used by a web-based program that is not <strong>DACS</strong>-wrapped but for which authorization has been obtained indirectly. For example, when \m[blue]<a href="../man8/dacs_uproxy.8.html"><strong>dacs_uproxy</strong>(8)</a></strong>\m[]\s-2\u[68]\d\s+2, invokes a program, <strong>dacs_uproxy</strong> will forward the value of <strong>DACS_APPROVAL</strong> (when available) to the invoked program, which can obtain the value in its <strong>HTTP_DACS_UPROXY_APPROVAL</strong> environment variable. If it is able to validate the value (or can trust it), the invoked program knows that its execution was authorized by <strong>DACS</strong>, even though <strong>DACS</strong> may not be configured or even installed on the host where the invoked program runs.</p><p>A jurisdiction&apos;s cryptographic keys, identified by the virtual filestore item type jurisdiction_keys, must be configured so that the approval can be digitally signed.</p><p>The value of <strong>DACS_APPROVAL</strong> has the following format:</p>
<pre>
a="<em>dacs64-approval-message</em>", s="<em>dacs64-signature</em>"
</pre>
<p>The <em>dacs64-approval-message</em> is a \m[blue]<strong>dacs64</strong>\m[]\s-2\u[33]\d\s+2 encoded string, described below. The <em>dacs64-signature</em> is the dacs64 encoded RSA signature of the approval message, which is the unencoded <em>dacs64-approval-message</em>.</p><p>An approval message has the following format:</p>
<pre>
j="<em>jurisdiction-name</em>"&lt;newline&gt;
h="<em>digest-name</em>"&lt;newline&gt;
s="<em>stamp</em>"&lt;newline&gt;
u="<em>uri</em>"&lt;newline&gt;
m="<em>method</em>"&lt;newline&gt;
i="<em>ident</em>"
</pre>
<p>Here, <em>jurisdiction-name</em> is the name of the jurisdiction (including its federation name) that generated the approval. The name of the message digest (secure hash) algorithm used to sign the approval is <em>digest-name</em>. The unique stamp is <em>stamp</em> (as generated by \m[blue]<strong>ustamp()</strong>\m[]\s-2\u[69]\d\s+2) and the URI, including any query component, is <em>uri</em>. The HTTP method is <em>method</em>. The <strong>DACS</strong> identity of the user for which access was granted is <em>ident</em> (or "unauth", if none). The <em>stamp</em> and <em>method</em> are mapped to lowercase. Here is an example of an approval message:</p>
<pre>
j="DSS::DSS-dacs"
h="SHA1"
s="1185565675:130",
u="http://example.com/cgi-bin/dacs/dacs_current_credentials?FORMAT=HTML"
m="get"
i="unauth"
</pre>
<p>The RSA signature is computed using the jurisdiction&apos;s private key and SHA-1 (by default) over the approval message. A different message digest algorithm can be used by setting the configuration variable <em>${Conf::dacs_approval_digest_name}</em> (see \m[blue]<strong>digest()</strong>\m[]\s-2\u[70]\d\s+2 for information about message digest algorithms):</p>
<pre>
EVAL ${Conf::dacs_approval_digest_name} = "SHA256"
</pre>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DIAGNOSTICS</h2>
        <div class="sectioncontent">
<p>The program exits 0 if everything was fine, 1 if an error occurred.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO dacs_acs&hellip;</h2>
        <div class="sectioncontent">
<p>\m[blue]<a href="../man1/dacsacl.1.html"><strong>dacsacl</strong>(1)</a></strong>\m[]\s-2\u[43]\d\s+2, \m[blue]<a href="../man1/dacscheck.1.html"><strong>dacscheck</strong>(1)</a></strong>\m[]\s-2\u[2]\d\s+2, \m[blue]<a href="../man5/dacs.acls.5.html"><strong>dacs.acls</strong>(5)</a></strong>\m[]\s-2\u[4]\d\s+2, \m[blue]<strong>dacs.conf</strong>(5)</strong>\m[]\s-2\u[47]\d\s+2, \m[blue]<a href="../man8/dacs_admin.8.html"><strong>dacs_admin</strong>(8)</a></strong>\m[]\s-2\u[44]\d\s+2</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>While the <em>DACS_ACS</em> mechanism can be useful, it is still a kludge,</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Distributed Systems Software (\m[blue]<strong>www.dss.ca</strong>\m[]\s-2\u[71]\d\s+2)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYING</h2>
        <div class="sectioncontent">
<p>Copyright2003-2013 Distributed Systems Software. See the \m[blue]<strong>LICENSE</strong>\m[]\s-2\u[72]\d\s+2 file that accompanies the distribution for licensing information.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTES</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
     1.
  </dt>
  <dd>
    <p>dacsoptions</p><p>http://dacs.dss.ca/man/dacs.1.html#dacsoptions</p>
  </dd>
  <dt>
     2.
  </dt>
  <dd>
    <p><a href="../man1/dacscheck.1.html"><strong>dacscheck</strong>(1)</a></p><p>http://dacs.dss.ca/man/dacscheck.1.html</p>
  </dd>
  <dt>
     3.
  </dt>
  <dd>
    <p>mod_auth_dacs</p><p>http://dacs.dss.ca/man/mod_auth_dacs.html</p>
  </dd>
  <dt>
     4.
  </dt>
  <dd>
    <p><a href="../man5/dacs.acls.5.html"><strong>dacs.acls</strong>(5)</a></p><p>http://dacs.dss.ca/man/dacs.acls.5.html</p>
  </dd>
  <dt>
     5.
  </dt>
  <dd>
    <p>logging</p><p>http://dacs.dss.ca/man/dacs.1.html#logging</p>
  </dd>
  <dt>
     6.
  </dt>
  <dd>
    <p>LOG_LEVEL</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#LOG_LEVEL</p>
  </dd>
  <dt>
     7.
  </dt>
  <dd>
    <p>LOG_FILTER</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#LOG_FILTER</p>
  </dd>
  <dt>
     8.
  </dt>
  <dd>
    <p>AddDACSAuth</p><p>http://dacs.dss.ca/man/mod_auth_dacs.html#AddDACSAuth</p>
  </dd>
  <dt>
     9.
  </dt>
  <dd>
    <p>DACS_HOME</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#var_dacs_home</p>
  </dd>
  <dt>
    10.
  </dt>
  <dd>
    <p><a href="../man2/pipe.2.html"><strong>pipe</strong>(2)</a></p><p>http://www.freebsd.org/cgi/man.cgi?query=pipe&apropos=0&sektion=2&manpath=FreeBSD+9.1-RELEASE&format=html</p>
  </dd>
  <dt>
    11.
  </dt>
  <dd>
    <p>Variables Available To Rules</p><p>http://dacs.dss.ca/man/#vars_in_rules</p>
  </dd>
  <dt>
    12.
  </dt>
  <dd>
    <p>mod_auth_dacs</p><p>http://dacs.dss.ca/man/mod_auth_dacs.html#SetDACSAuthPostBuffer</p>
  </dd>
  <dt>
    13.
  </dt>
  <dd>
    <p>ALLOW_HTTP_COOKIE</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#ALLOW_HTTP_COOKIE</p>
  </dd>
  <dt>
    14.
  </dt>
  <dd>
    <p>RFC 2617</p><p>http://www.rfc-editor.org/rfc/rfc2617.txt</p>
  </dd>
  <dt>
    15.
  </dt>
  <dd>
    <p><a href="../man8/dacs_authenticate.8.html"><strong>dacs_authenticate</strong>(8)</a></p><p>http://dacs.dss.ca/man/dacs_authenticate.8.html#credentials</p>
  </dd>
  <dt>
    16.
  </dt>
  <dd>
    <p><a href="../man1/dacsrlink.1.html"><strong>dacsrlink</strong>(1)</a></p><p>http://dacs.dss.ca/man/dacsrlink.1.html</p>
  </dd>
  <dt>
    17.
  </dt>
  <dd>
    <p>RLINK</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#RLINK</p>
  </dd>
  <dt>
    18.
  </dt>
  <dd>
    <p>the one used for normal rules</p><p>http://dacs.dss.ca/man/dacs.acls.5.html#acl_files</p>
  </dd>
  <dt>
    19.
  </dt>
  <dd>
    <p>concise user identity</p><p>http://dacs.dss.ca/man/dacs.1.html#concise_user_syntax</p>
  </dd>
  <dt>
    20.
  </dt>
  <dd>
    <p>identity element</p><p>http://dacs.dss.ca/man/dacs.acls.5.html#elements</p>
  </dd>
  <dt>
    21.
  </dt>
  <dd>
    <p>DACS_ACS argument</p><p>http://dacs.dss.ca/man/#dacs_acs_argument</p>
  </dd>
  <dt>
    22.
  </dt>
  <dd>
    <p>redirect()</p><p>http://dacs.dss.ca/man/dacs.exprs.5.html#redirect</p>
  </dd>
  <dt>
    23.
  </dt>
  <dd>
    <p>HTTP_AUTH_ENABLE</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#HTTP_AUTH_ENABLE</p>
  </dd>
  <dt>
    24.
  </dt>
  <dd>
    <p>HTTP_AUTH</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#HTTP_AUTH</p>
  </dd>
  <dt>
    25.
  </dt>
  <dd>
    <p>Auth clause directives</p><p>http://dacs.dss.ca/man/dacs_authenticate.8.html#auth_clause</p>
  </dd>
  <dt>
    26.
  </dt>
  <dd>
    <p>local_apache_authenticate</p><p>http://dacs.dss.ca/man/dacs_authenticate.8.html#local_apache_authenticate</p>
  </dd>
  <dt>
    27.
  </dt>
  <dd>
    <p>ACS_ERROR_HANDLER</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#ACS_ERROR_HANDLER</p>
  </dd>
  <dt>
    28.
  </dt>
  <dd>
    <p>AUTH_SUCCESS_HANDLER</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#AUTH_SUCCESS_HANDLER</p>
  </dd>
  <dt>
    29.
  </dt>
  <dd>
    <p>AUTH_ERROR_HANDLER</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#AUTH_ERROR_HANDLER</p>
  </dd>
  <dt>
    30.
  </dt>
  <dd>
    <p>RFC 2616</p><p>http://www.rfc-editor.org/rfc/rfc2616.txt</p>
  </dd>
  <dt>
    31.
  </dt>
  <dd>
    <p><a href="../man1/dacshttp.1.html"><strong>dacshttp</strong>(1)</a></p><p>http://dacs.dss.ca/man/dacshttp.1.html</p>
  </dd>
  <dt>
    32.
  </dt>
  <dd>
    <p>passed using this request-header</p><p>http://dacs.dss.ca/man/#http_authentication</p>
  </dd>
  <dt>
    33.
  </dt>
  <dd>
    <p><a href="../man5/dacs.exprs.5.html"><strong>dacs.exprs</strong>(5)</a></p><p>http://dacs.dss.ca/man/dacs.exprs.5.html#encode</p>
  </dd>
  <dt>
    34.
  </dt>
  <dd>
    <p>COOKIE_PATH</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#COOKIE_PATH</p>
  </dd>
  <dt>
    35.
  </dt>
  <dd>
    <p>COOKIE_NO_DOMAIN</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#COOKIE_NO_DOMAIN</p>
  </dd>
  <dt>
    36.
  </dt>
  <dd>
    <p>COOKIE_HTTP_ONLY</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#COOKIE_HTTP_ONLY</p>
  </dd>
  <dt>
    37.
  </dt>
  <dd>
    <p><a href="../man7/dacs.install.7.html"><strong>dacs.install</strong>(7)</a></p><p>http://dacs.dss.ca/man/dacs.install.7.html#configure_options</p>
  </dd>
  <dt>
    38.
  </dt>
  <dd>
    <p>ACS_ACCESS_TOKEN_ENABLE</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#ACS_ACCESS_TOKEN_ENABLE</p>
  </dd>
  <dt>
    39.
  </dt>
  <dd>
    <p>ACS_ACCESS_TOKEN_LIFETIME_LIMIT</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#ACS_ACCESS_TOKEN_LIFETIME_LIMIT</p>
  </dd>
  <dt>
    40.
  </dt>
  <dd>
    <p>ACS_ACCESS_TOKEN_LIFETIME_SECS</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#ACS_ACCESS_TOKEN_LIFETIME_SECS</p>
  </dd>
  <dt>
    41.
  </dt>
  <dd>
    <p><a href="../man5/dacs.acls.5.html"><strong>dacs.acls</strong>(5)</a></p><p>http://dacs.dss.ca/man/dacs.acls.5.html#acl_syntax</p>
  </dd>
  <dt>
    42.
  </dt>
  <dd>
    <p>tail matching</p><p>http://dacs.dss.ca/man/dacs.acls.5.html#tail_matching</p>
  </dd>
  <dt>
    43.
  </dt>
  <dd>
    <p><a href="../man1/dacsacl.1.html"><strong>dacsacl</strong>(1)</a></p><p>http://dacs.dss.ca/man/dacsacl.1.html</p>
  </dd>
  <dt>
    44.
  </dt>
  <dd>
    <p><a href="../man8/dacs_admin.8.html"><strong>dacs_admin</strong>(8)</a></p><p>http://dacs.dss.ca/man/dacs_admin.8.html</p>
  </dd>
  <dt>
    45.
  </dt>
  <dd>
    <p>revocation list</p><p>http://dacs.dss.ca/man/dacs.acls.5.html#revocation_list</p>
  </dd>
  <dt>
    46.
  </dt>
  <dd>
    <p>dacs_acs.dtd</p><p>http://dacs.dss.ca/man/../dtd-xsd/dacs_acs.dtd</p>
  </dd>
  <dt>
    47.
  </dt>
  <dd>
    <p><strong>dacs.conf</strong>(5)</p><p>http://dacs.dss.ca/man/dacs.conf.5.html</p>
  </dd>
  <dt>
    48.
  </dt>
  <dd>
    <p><a href="../man8/dacs_notices.8.html"><strong>dacs_notices</strong>(8)</a></p><p>http://dacs.dss.ca/man/dacs_notices.8.html</p>
  </dd>
  <dt>
    49.
  </dt>
  <dd>
    <p><a href="../man5/dacs.exprs.5.html"><strong>dacs.exprs</strong>(5)</a></p><p>http://dacs.dss.ca/man/dacs.exprs.5.html#variables</p>
  </dd>
  <dt>
    50.
  </dt>
  <dd>
    <p>RFC 1867</p><p>http://www.rfc-editor.org/rfc/rfc1867.txt</p>
  </dd>
  <dt>
    51.
  </dt>
  <dd>
    <p>RFC 2388</p><p>http://www.rfc-editor.org/rfc/rfc2388.txt</p>
  </dd>
  <dt>
    52.
  </dt>
  <dd>
    <p>HTML 4</p><p>http://www.w3.org/TR/html4</p>
  </dd>
  <dt>
    53.
  </dt>
  <dd>
    <p>ACS_POST_EXCEPTION_MODE</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#ACS_POST_EXCEPTION_MODE</p>
  </dd>
  <dt>
    54.
  </dt>
  <dd>
    <p>Rlinks</p><p>http://dacs.dss.ca/man/#rlinks</p>
  </dd>
  <dt>
    55.
  </dt>
  <dd>
    <p>PHP</p><p>http://www.php.net</p>
  </dd>
  <dt>
    56.
  </dt>
  <dd>
    <p><a href="../man8/dacs_prenv.8.html"><strong>dacs_prenv</strong>(8)</a></p><p>http://dacs.dss.ca/man/dacs_prenv.8.html</p>
  </dd>
  <dt>
    57.
  </dt>
  <dd>
    <p><a href="../man8/dacs_acs.8.html"><strong>dacs_acs</strong>(8)</a></p><p>http://dacs.dss.ca/man/dacs_acs.8.html#dacs_approval</p>
  </dd>
  <dt>
    58.
  </dt>
  <dd>
    <p>mod_jk</p><p>http://tomcat.apache.org/connectors-doc/generic_howto/quick.html</p>
  </dd>
  <dt>
    59.
  </dt>
  <dd>
    <p>Tomcat</p><p>http://jakarta.apache.org</p>
  </dd>
  <dt>
    60.
  </dt>
  <dd>
    <p><strong>-invisible</strong></p><p>http://dacs.dss.ca/man/#invisible_flag</p>
  </dd>
  <dt>
    61.
  </dt>
  <dd>
    <p>XML Output</p><p>http://dacs.dss.ca/man/#XML-output</p>
  </dd>
  <dt>
    62.
  </dt>
  <dd>
    <p><em>FORMAT</em> CGI argument</p><p>http://dacs.dss.ca/man/dacs.1.html#FORMAT</p>
  </dd>
  <dt>
    63.
  </dt>
  <dd>
    <p><strong>-format</strong></p><p>http://dacs.dss.ca/man/dacs.1.html#format-arg</p>
  </dd>
  <dt>
    64.
  </dt>
  <dd>
    <p>ACS_PRE_AUTH</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#ACS_PRE_AUTH</p>
  </dd>
  <dt>
    65.
  </dt>
  <dd>
    <p>DACS-Status-Line</p><p>http://dacs.dss.ca/man/dacs_acs.8.html#dacs_status_line</p>
  </dd>
  <dt>
    66.
  </dt>
  <dd>
    <p>STATUS_LINE</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#STATUS_LINE</p>
  </dd>
  <dt>
    67.
  </dt>
  <dd>
    <p>ACS_EMIT_APPROVAL</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#ACS_EMIT_APPROVAL</p>
  </dd>
  <dt>
    68.
  </dt>
  <dd>
    <p><a href="../man8/dacs_uproxy.8.html"><strong>dacs_uproxy</strong>(8)</a></p><p>http://dacs.dss.ca/man/dacs_uproxy.8.html</p>
  </dd>
  <dt>
    69.
  </dt>
  <dd>
    <p>ustamp()</p><p>http://dacs.dss.ca/man/dacs.exprs.5.html#ustamp</p>
  </dd>
  <dt>
    70.
  </dt>
  <dd>
    <p>digest()</p><p>http://dacs.dss.ca/man/dacs.exprs.5.html#digest</p>
  </dd>
  <dt>
    71.
  </dt>
  <dd>
    <p>www.dss.ca</p><p>http://www.dss.ca</p>
  </dd>
  <dt>
    72.
  </dt>
  <dd>
    <p>LICENSE</p><p>http://dacs.dss.ca/man/../misc/LICENSE</p>
  </dd>

</dl>

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="dacs.services.8.html"><span aria-hidden="true">&larr;</span> dacs.services.8: Dacs web services</a></li>
   <li class="next"><a href="dacs_admin.8.html">dacs_admin.8: Dacs administration service <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

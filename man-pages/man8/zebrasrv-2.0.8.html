<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>zebrasrv-2.0: Zebra server</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Zebra server">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="zebrasrv-2.0 (8) manual">
  <meta name="twitter:description" content="Zebra server">
  <meta name="twitter:image" content="https://www.carta.tech/images/idzebra-2.0-utils-zebrasrv-2.0-8.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man8/zebrasrv-2.0.8.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="zebrasrv-2.0 (8) manual" />
  <meta property="og:description" content="Zebra server" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/idzebra-2.0-utils-zebrasrv-2.0-8.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">zebrasrv-2.0<small> (8)</small></h1>
        <p class="lead">Zebra server</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man8/">
      <span itemprop="name">System administration commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man8/zebrasrv-2.0.8.html">
      <span itemprop="name">zebrasrv-2.0: Zebra server</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/idzebra-2.0-utils/">
      <span itemprop="name">idzebra-2.0-utils</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man8/zebrasrv-2.0.8.html">
      <span itemprop="name">zebrasrv-2.0: Zebra server</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>zebrasrv</strong> [<strong>-install</strong>] [<strong>-installa</strong>] [<strong>-remove</strong>] [<strong>-a&nbsp;</strong><strong></strong><em>file</em>] [<strong>-v&nbsp;</strong><strong></strong><em>level</em>] [<strong>-l&nbsp;</strong><strong></strong><em>file</em>] [<strong>-u&nbsp;</strong><strong></strong><em>uid</em>] [<strong>-c&nbsp;</strong><strong></strong><em>config</em>] [<strong>-f&nbsp;</strong><strong></strong><em>vconfig</em>] [<strong>-C&nbsp;</strong><strong></strong><em>fname</em>] [<strong>-t&nbsp;</strong><strong></strong><em>minutes</em>] [<strong>-k&nbsp;</strong><strong></strong><em>kilobytes</em>] [<strong>-d&nbsp;</strong><strong></strong><em>daemon</em>] [<strong>-w&nbsp;</strong><strong></strong><em>dir</em>] [<strong>-p&nbsp;</strong><strong></strong><em>pidfile</em>] [<strong>-ziDST1</strong>] [listener-spec...]</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Zebra is a high-performance, general-purpose structured text indexing and retrieval engine. It reads structured records in a variety of input formats (e.g. email, XML, MARC) and allows access to them through exact boolean search expressions and relevance-ranked free-text queries.</p><p><strong>zebrasrv</strong> is the Z39.50 and SRU frontend server for the <strong>Zebra</strong> search engine and indexer.</p><p>On Unix you can run the <strong>zebrasrv</strong> server from the command line - and put it in the background. It may also operate under the inet daemon. On WIN32 you can run the server as a console application or as a WIN32 Service.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONS</h2>
        <div class="sectioncontent">
<p>The options for <strong>zebrasrv</strong> are the same as those for YAZ&apos; <strong>yaz-ztest</strong>. Option -c specifies a Zebra configuration file - if omitted zebra.cfg is read.</p><p>-a <em>file</em></p><p>Specify a file for dumping PDUs (for diagnostic purposes). The special name - (dash) sends output to stderr.</p><p>-S</p><p>Don&apos;t fork or make threads on connection requests. This is good for debugging, but not recommended for real operation: Although the server is asynchronous and non-blocking, it can be nice to keep a software malfunction (okay then, a crash) from affecting all current users. The server can only accept a single connection in this mode.</p><p>-1</p><p>Like -S but after one session the server exits. This mode is for debugging <em>only</em>.</p><p>-T</p><p>Operate the server in threaded mode. The server creates a thread for each connection rather than a fork a process. Only available on UNIX systems that offers POSIX threads.</p><p>-s</p><p>Use the SR protocol (obsolete).</p><p>-z</p><p>Use the Z39.50 protocol (default). This option and -s complement each other. You can use both multiple times on the same command line, between listener-specifications (see below). This way, you can set up the server to listen for connections in both protocols concurrently, on different local ports.</p><p>-l <em>file</em></p><p>Specify an output file for the diagnostic messages. The default is to write this information to stderr</p><p>-c <em>config-file</em></p><p>Read configuration information from <em>config-file</em>. The default configuration is ./zebra.cfg</p><p>-f <em>vconfig</em></p><p>This specifies an XML file that describes one or more YAZ frontend virtual servers. See section VIRTUAL HOSTS for details.</p><p>-C <em>fname</em></p><p>Sets SSL certificate file name for server (PEM).</p><p>-v <em>level</em></p><p>The log level. Use a comma-separated list of members of the set {fatal,debug,warn,log,malloc,all,none}.</p><p>-u <em>uid</em></p><p>Set user ID. Sets the real UID of the server process to that of the given user. It&apos;s useful if you aren&apos;t comfortable with having the server run as root, but you need to start it as such to bind a privileged port.</p><p>-w <em>working-directory</em></p><p>The server changes to this working directory during before listening on incoming connections. This option is useful when the server is operating from the inetd daemon (see -i).</p><p>-p <em>pidfile</em></p><p>Specifies that the server should write its Process ID to file given by <em>pidfile</em>. A typical location would be /var/run/zebrasrv.pid.</p><p>-i</p><p>Use this to make the the server run from the inetd server (UNIX only). Make sure you use the logfile option -l in conjunction with this mode and specify the -l option before any other options.</p><p>-D</p><p>Use this to make the server put itself in the background and run as a daemon. If neither -i nor -D is given, the server starts in the foreground.</p><p>-install</p><p>Use this to install the server as an NT service (Windows NT/2000/XP only). Control the server by going to the Services in the Control Panel.</p><p>-installa</p><p>Use this to install and activate the server as an NT service (Windows NT/2000/XP only). Control the server by going to the Services in the Control Panel.</p><p>-remove</p><p>Use this to remove the server from the NT services (Windows NT/2000/XP only).</p><p>-t <em>minutes</em></p><p>Idle session timeout, in minutes. Default is 60 minutes.</p><p>-k <em>size</em></p><p>Maximum record size/message size, in kilobytes. Default is 1024 KB (1 MB).</p><p>-d <em>daemon</em></p><p>Set name of daemon to be used in hosts access file. See <a href="../man5/hosts_access.5.html"><strong>hosts_access</strong>(5)</a> and <a href="../man8/tcpd.8.html"><strong>tcpd</strong>(8)</a>.</p><p>A <em>listener-address</em> consists of an optional transport mode followed by a colon (:) followed by a listener address. The transport mode is either a file system socket unix, a SSL TCP/IP socket ssl, or a plain TCP/IP socket tcp (default).</p><p>For TCP, an address has the form</p>
<pre>
    hostname | IP-number [: portnumber]

</pre>
<p>The port number defaults to 210 (standard Z39.50 port) for privileged users (root), and 9999 for normal users. The special hostname "@" is mapped to the address INADDR_ANY, which causes the server to listen on any local interface.</p><p>The default behavior for zebrasrv - if started as non-privileged user - is to establish a single TCP/IP listener, for the Z39.50 protocol, on port 9999.</p>
<pre>
    zebrasrv @
    zebrasrv tcp:some.server.name.org:1234
    zebrasrv ssl:@:3000

</pre>
<p>To start the server listening on the registered port for Z39.50, or on a filesystem socket, and to drop root privileges once the ports are bound, execute the server like this from a root shell:</p>
<pre>
    zebrasrv -u daemon @
    zebrasrv -u daemon tcp:@:210
    zebrasrv -u daemon unix:/some/file/system/socket

</pre>
<p>Here daemon is an existing user account, and the unix socket /some/file/system/socket is readable and writable for the daemon account.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Z39.50 PROTOCOL SUPPORT AND BEHAVIOR</h2>
        <div class="sectioncontent">
<h3>Z39.50 Initialization</h3>
<p>During initialization, the server will negotiate to version 3 of the Z39.50 protocol, and the option bits for Search, Present, Scan, NamedResultSets, and concurrentOperations will be set, if requested by the client. The maximum PDU size is negotiated down to a maximum of 1 MB by default.</p>
<h3>Z39.50 Search</h3>
<p>The supported query type are 1 and 101. All operators are currently supported with the restriction that only proximity units of type "word" are supported for the proximity operator. Queries can be arbitrarily complex. Named result sets are supported, and result sets can be used as operands without limitations. Searches may span multiple databases.</p><p>The server has full support for piggy-backed retrieval (see also the following section).</p>
<h3>Z39.50 Present</h3>
<p>The present facility is supported in a standard fashion. The requested record syntax is matched against the ones supported by the profile of each record retrieved. If no record syntax is given, SUTRS is the default. The requested element set name, again, is matched against any provided by the relevant record profiles.</p>
<h3>Z39.50 Scan</h3>
<p>The attribute combinations provided with the termListAndStartPoint are processed in the same way as operands in a query (see above). Currently, only the term and the globalOccurrences are returned with the termInfo structure.</p>
<h3>Z39.50 Sort</h3>
<p>Z39.50 specifies three different types of sort criteria. Of these Zebra supports the attribute specification type in which case the use attribute specifies the "Sort register". Sort registers are created for those fields that are of type "sort" in the default.idx file. The corresponding character mapping file in default.idx specifies the ordinal of each character used in the actual sort.</p><p>Z39.50 allows the client to specify sorting on one or more input result sets and one output result set. Zebra supports sorting on one result set only which may or may not be the same as the output result set.</p>
<h3>Z39.50 Close</h3>
<p>If a Close PDU is received, the server will respond with a Close PDU with reason=FINISHED, no matter which protocol version was negotiated during initialization. If the protocol version is 3 or more, the server will generate a Close PDU under certain circumstances, including a session timeout (60 minutes by default), and certain kinds of protocol errors. Once a Close PDU has been sent, the protocol association is considered broken, and the transport connection will be closed immediately upon receipt of further data, or following a short timeout.</p>
<h3>Z39.50 Explain</h3>
<p>Zebra maintains a "classic" \m[blue]<strong>Z39.50 Explain</strong>\m[]\s-2\u[1]\d\s+2 database on the side. This database is called IR-Explain-1 and can be searched using the attribute set exp-1.</p><p>The records in the explain database are of type grs.sgml. The root element for the Explain grs.sgml records is explain, thus explain.abs is used for indexing.</p><p><strong>Note</strong></p><p>Zebra <em>must</em> be able to locate explain.abs in order to index the Explain records properly. Zebra will work without it but the information will not be searchable.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THE SRU SERVER</h2>
        <div class="sectioncontent">
<p>In addition to Z39.50, Zebra supports the more recent and web-friendly IR protocol \m[blue]<strong>SRU</strong>\m[]\s-2\u[2]\d\s+2. SRU can be carried over SOAP or a REST-like protocol that uses HTTP GET or POST to request search responses. The request itself is made of parameters such as query, startRecord, maximumRecords and recordSchema; the response is an XML document containing hit-count, result-set records, diagnostics, etc. SRU can be thought of as a re-casting of Z39.50 semantics in web-friendly terms; or as a standardisation of the ad-hoc query parameters used by search engines such as Google and AltaVista; or as a superset of A9&apos;s OpenSearch (which it predates).</p><p>Zebra supports Z39.50, SRUGET, SRU POST, SRU SOAP (SRW) - on the same port, recognising what protocol is used by each incoming requests and handling them accordingly. This is a achieved through the use of Deep Magic; civilians are warned not to stand too close.</p><h3>Running zebrasrv as an SRU Server</h3>
<p>Because Zebra supports all protocols on one port, it would seem to follow that the SRU server is run in the same way as the Z39.50 server, as described above. This is true, but only in an uninterestingly vacuous way: a Zebra server run in this manner will indeed recognise and accept SRU requests; but since it doesn&apos;t know how to handle the CQL queries that these protocols use, all it can do is send failure responses.</p><p><strong>Note</strong></p><p>It is possible to cheat, by having SRU search Zebra with a PQF query instead of CQL, using the x-pquery parameter instead of query. This is a <strong>non-standard extension</strong> of CQL, and a <strong>very naughty</strong> thing to do, but it does give you a way to see Zebra serving SRU ``right out of the box&apos;&apos;. If you start your favourite Zebra server in the usual way, on port 9999, then you can send your web browser to:</p>
<pre>
     http://localhost:9999/Default?version=1.1
     &operation=searchRetrieve
     &x-pquery=mineral
     &startRecord=1
     &maximumRecords=1

</pre>
<p>This will display the XML-formatted SRU response that includes the first record in the result-set found by the query mineral. (For clarity, the SRU URL is shown here broken across lines, but the lines should be joined together to make single-line URL for the browser to submit.)</p><p>In order to turn on Zebra&apos;s support for CQL queries, it&apos;s necessary to have the YAZ generic front-end (which Zebra uses) translate them into the Z39.50 Type-1 query format that is used internally. And to do this, the generic front-end&apos;s own configuration file must be used. See the section called &ldquo;YAZ SERVER VIRTUAL HOSTS&rdquo;; the salient point for SRU support is that <strong>zebrasrv</strong> must be started with the -f&nbsp;frontendConfigFile option rather than the -c&nbsp;zebraConfigFile option, and that the front-end configuration file must include both a reference to the Zebra configuration file and the CQL-to-PQF translator configuration file.</p><p>A minimal front-end configuration file that does this would read as follows:</p>
<pre>
    &lt;yazgfs&gt;
    &lt;server&gt;
    &lt;config&gt;zebra.cfg&lt;/config&gt;
    &lt;cql2rpn&gt;../../tab/pqf.properties&lt;/cql2rpn&gt;
   &lt;/server&gt;
   &lt;/yazgfs&gt;

</pre>
<p>The &lt;config&gt; element contains the name of the Zebra configuration file that was previously specified by the -c command-line argument, and the &lt;cql2rpn&gt; element contains the name of the CQL properties file specifying how various CQL indexes, relations, etc. are translated into Type-1 queries.</p><p>A zebra server running with such a configuration can then be queried using proper, conformant SRU URLs with CQL queries:</p>
<pre>
    http://localhost:9999/Default?version=1.1
    &operation=searchRetrieve
    &query=title=utah and description=epicent*
    &startRecord=1
    &maximumRecords=1

</pre>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SRU PROTOCOL SUPPORT AND BEHAVIOR</h2>
        <div class="sectioncontent">
<p>Zebra running as an SRU server supports SRU version 1.1, including CQL version 1.1. In particular, it provides support for the following elements of the protocol.</p><h3>SRU Search and Retrieval</h3>
<p>Zebra supports the searchRetrieve operation.</p><p>One of the great strengths of SRU is that it mandates a standard query language, CQL, and that all conforming implementations can therefore be trusted to correctly interpret the same queries. It is with some shame, then, that we admit that Zebra also supports an additional query language, our own Prefix Query Format (\m[blue]<strong>PQF</strong>\m[]\s-2\u[3]\d\s+2). A PQF query is submitted by using the extension parameter x-pquery, in which case the query parameter must be omitted, which makes the request not valid SRU. Please feel free to use this facility within your own applications; but be aware that it is not only non-standard SRU but not even syntactically valid, since it omits the mandatory query parameter.</p>
<h3>SRU Scan</h3>
<p>Zebra supports scan operation. Scanning using CQL syntax is the default, where the standard scanClause parameter is used.</p><p>In addition, a mutant form of SRU scan is supported, using the non-standard x-pScanClause parameter in place of the standard scanClause to scan on a PQF query clause.</p>
<h3>SRU Explain</h3>
<p>Zebra supports explain.</p><p>The ZeeRex record explaining a database may be requested either with a fully fledged SRU request (with operation=explain and version-number specified) or with a simple HTTP GET at the server&apos;s basename. The ZeeRex record returned in response is the one embedded in the YAZ Frontend Server configuration file that is described in the the section called &ldquo;YAZ SERVER VIRTUAL HOSTS&rdquo;.</p><p>Unfortunately, the data found in the CQL-to-PQF text file must be added by hand-craft into the explain section of the YAZ Frontend Server configuration file to be able to provide a suitable explain record. Too bad, but this is all extreme new alpha stuff, and a lot of work has yet to be done ..</p><p>There is no linkage whatsoever between the Z39.50 explain model and the SRU explain response (well, at least not implemented in Zebra, that is ..). Zebra does not provide a means using Z39.50 to obtain the ZeeRex record.</p>
<h3>Other SRU operations</h3>
<p>In the Z39.50 protocol, Initialization, Present, Sort and Close are separate operations. In SRU, however, these operations do not exist.</p><p>SRU has no explicit initialization handshake phase, but commences immediately with searching, scanning and explain operations.</p><p>Neither does SRU have a close operation, since the protocol is stateless and each request is self-contained. (It is true that multiple SRU request/response pairs may be implemented as multiple HTTP request/response pairs over a single persistent TCP/IP connection; but the closure of that connection is not a protocol-level operation.)</p><p>Retrieval in SRU is part of the searchRetrieve operation, in which a search is submitted and the response includes a subset of the records in the result set. There is no direct analogue of Z39.50&apos;s Present operation which requests records from an established result set. In SRU, this is achieved by sending a subsequent searchRetrieve request with the query cql.resultSetId=<em>id</em> where <em>id</em> is the identifier of the previously generated result-set.</p><p>Sorting in CQL is done within the searchRetrieve operation - in v1.1, by an explicit sort parameter, but the forthcoming v1.2 or v2.0 will most likely use an extension of the query language, \m[blue]<strong>CQL sorting</strong>\m[]\s-2\u[4]\d\s+2.</p><p>It can be seen, then, that while Zebra operating as an SRU server does not provide the same set of operations as when operating as a Z39.50 server, it does provide equivalent functionality.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SRU EXAMPLES</h2>
        <div class="sectioncontent">
<p>Surf into http://localhost:9999 to get an explain response, or use</p>
<pre>
    http://localhost:9999/?version=1.1&operation=explain

</pre>
<p>See number of hits for a query</p>
<pre>
    http://localhost:9999/?version=1.1&operation=searchRetrieve
    &query=text=(plant%20and%20soil)

</pre>
<p>Fetch record 5-7 in Dublin Core format</p>
<pre>
    http://localhost:9999/?version=1.1&operation=searchRetrieve
    &query=text=(plant%20and%20soil)
    &startRecord=5&maximumRecords=2&recordSchema=dc

</pre>
<p>Even search using PQF queries using the <em>extended naughty parameter</em>x-pquery</p>
<pre>
    http://localhost:9999/?version=1.1&operation=searchRetrieve
    &x-pquery=@attr%201=text%20@and%20plant%20soil

</pre>
<p>Or scan indexes using the <em>extended extremely naughty parameter</em>x-pScanClause</p>
<pre>
    http://localhost:9999/?version=1.1&operation=scan
    &x-pScanClause=@attr%201=text%20something

</pre>
<p><em>Don&apos;t do this in production code!</em> But it&apos;s a great fast debugging aid.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">YAZ SERVER VIRTUAL HOSTS</h2>
        <div class="sectioncontent">
<p>The Virtual hosts mechanism allows a YAZ frontend server to support multiple backends. A backend is selected on the basis of the TCP/IP binding (port+listening address) and/or the virtual host.</p><p>A backend can be configured to execute in a particular working directory. Or the YAZ frontend may perform \m[blue]<strong>CQL</strong>\m[]\s-2\u[5]\d\s+2 to RPN conversion, thus allowing traditional Z39.50 backends to be offered as a \m[blue]<strong>SRU</strong>\m[]\s-2\u[2]\d\s+2 service. SRU Explain information for a particular backend may also be specified.</p><p>For the HTTP protocol, the virtual host is specified in the Host header. For the Z39.50 protocol, the virtual host is specified as in the Initialize Request in the OtherInfo, OID 1.2.840.10003.10.1000.81.1.</p><p><strong>Note</strong></p><p>Not all Z39.50 clients allows the VHOST information to be set. For those the selection of the backend must rely on the TCP/IP information alone (port and address).</p><p>The YAZ frontend server uses XML to describe the backend configurations. Command-line option -f specifies filename of the XML configuration.</p><p>The configuration uses the root element yazgfs. This element includes a list of listen elements, followed by one or more server elements.</p><p>The listen describes listener (transport end point), such as TCP/IP, Unix file socket or SSL server. Content for a listener:</p><p>CDATA (required)</p><p>The CDATA for the listen element holds the listener string, such as tcp:@:210, tcp:server1:2100, etc.</p><p>attribute id (optional)</p><p>identifier for this listener. This may be referred to from server sections.</p><p><strong>Note</strong></p><p>We expect more information to be added for the listen section in a future version, such as CERT file for SSL servers.</p><p>The server describes a server and the parameters for this server type. Content for a server:</p><p>attribute id (optional)</p><p>Identifier for this server. Currently not used for anything, but it might be for logging purposes.</p><p>attribute listenref (optional)</p><p>Specifies listener for this server. If this attribute is not given, the server is accessible from all listener. In order for the server to be used for real, however, the virtual host must match (if specified in the configuration).</p><p>element config (optional)</p><p>Specifies the server configuration. This is equivalent to the config specified using command line option -c.</p><p>element directory (optional)</p><p>Specifies a working directory for this backend server. If specified, the YAZ frontend changes current working directory to this directory whenever a backend of this type is started (backend handler bend_start), stopped (backend handler hand_stop) and initialized (bend_init).</p><p>element host (optional)</p><p>Specifies the virtual host for this server. If this is specified a client <em>must</em> specify this host string in order to use this backend.</p><p>element cql2rpn (optional)</p><p>Specifies a filename that includes \m[blue]<strong>CQL</strong>\m[]\s-2\u[5]\d\s+2 to RPN conversion for this backend server. See \m[blue]<strong>CQL</strong>\m[]\s-2\u[5]\d\s+2 section in YAZ manual. If given, the backend server will only "see" a Type-1/RPN query.</p><p>element explain (optional)</p><p>Specifies \m[blue]<strong>SRU</strong>\m[]\s-2\u[2]\d\s+2 ZeeRex content for this server - copied verbatim to the client. As things are now, some of the Explain content seems redundant because host information, etc. is also stored elsewhere.</p><p>The format of the Explain record is described in detail, with examples, on the file at the \m[blue]<strong>ZeeRex</strong>\m[]\s-2\u[6]\d\s+2 web-site.</p><p>The XML below configures a server that accepts connections from two ports, TCP/IP port 9900 and a local UNIX file socket. We name the TCP/IP server public and the other server internal.</p>
<pre>
 &lt;yazgfs&gt;
  &lt;listen id="public"&gt;tcp:@:9900&lt;/listen&gt;
  &lt;listen id="internal"&gt;unix:/var/tmp/socket&lt;/listen&gt;
  &lt;server id="server1"&gt;
    &lt;host&gt;server1.mydomain&lt;/host&gt;
    &lt;directory&gt;/var/www/s1&lt;/directory&gt;
    &lt;config&gt;config.cfg&lt;/config&gt;
  &lt;/server&gt;
  &lt;server id="server2"&gt;
    &lt;host&gt;server2.mydomain&lt;/host&gt;
    &lt;directory&gt;/var/www/s2&lt;/directory&gt;
    &lt;config&gt;config.cfg&lt;/config&gt;
    &lt;cql2rpn&gt;../etc/pqf.properties&lt;/cql2rpn&gt;
    &lt;explain xmlns="http://explain.z3950.org/dtd/2.0/"&gt;
      &lt;serverInfo&gt;
        &lt;host&gt;server2.mydomain&lt;/host&gt;
        &lt;port&gt;9900&lt;/port&gt;
        &lt;database&gt;a&lt;/database&gt;
      &lt;/serverInfo&gt;
    &lt;/explain&gt;
  &lt;/server&gt;
  &lt;server id="server3" listenref="internal"&gt;
    &lt;directory&gt;/var/www/s3&lt;/directory&gt;
    &lt;config&gt;config.cfg&lt;/config&gt;
  &lt;/server&gt;
 &lt;/yazgfs&gt;


</pre>
<p>There are three configured backend servers. The first two servers, "server1" and "server2", can be reached by both listener addresses - since no listenref attribute is specified. In order to distinguish between the two a virtual host has been specified for each of server in the host elements.</p><p>For "server2" elements for \m[blue]<strong>CQL</strong>\m[]\s-2\u[5]\d\s+2 to RPN conversion is supported and explain information has been added (a short one here to keep the example small).</p><p>The third server, "server3" can only be reached via listener "internal".</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO zebrasrv-2.0&hellip;</h2>
        <div class="sectioncontent">
<p><strong>zebraidx</strong>(1)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTES</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
     1.
  </dt>
  <dd>
    <p>Z39.50 Explain</p><p>http://www.loc.gov/z3950/agency/markup/07.html</p>
  </dd>
  <dt>
     2.
  </dt>
  <dd>
    <p>SRU</p><p>http://www.loc.gov/standards/sru/</p>
  </dd>
  <dt>
     3.
  </dt>
  <dd>
    <p>PQF</p><p>http://www.indexdata.com/yaz/doc/tools.html#PQF</p>
  </dd>
  <dt>
     4.
  </dt>
  <dd>
    <p>CQL sorting</p><p>http://zing.z3950.org/cql/sorting.html</p>
  </dd>
  <dt>
     5.
  </dt>
  <dd>
    <p>CQL</p><p>http://www.loc.gov/standards/sru/cql/</p>
  </dd>
  <dt>
     6.
  </dt>
  <dd>
    <p>ZeeRex</p><p>http://explain.z3950.org/</p>
  </dd>

</dl>

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="zebra.8.html"><span aria-hidden="true">&larr;</span> zebra.8: A routing manager for use with associated quagga components.</a></li>
   <li class="next"><a href="zephyr-server-zephyrd.8.html">zephyrd.8: Zephyr server daemon <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>nast: Network analyzer sniffer tool</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Network analyzer sniffer tool">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="nast (8) manual">
  <meta name="twitter:description" content="Network analyzer sniffer tool">
  <meta name="twitter:image" content="https://www.carta.tech/images/nast-nast-8.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man8/nast.8.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="nast (8) manual" />
  <meta property="og:description" content="Network analyzer sniffer tool" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/nast-nast-8.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">nast<small> (8)</small></h1>
        <p class="lead">Network analyzer sniffer tool</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man8/">
      <span itemprop="name">System administration commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man8/nast.8.html">
      <span itemprop="name">nast: Network analyzer sniffer tool</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/nast/">
      <span itemprop="name">nast</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man8/nast.8.html">
      <span itemprop="name">nast: Network analyzer sniffer tool</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>nast [-G] [-i interface] [-l filename] [-f filter] [--ld filename] [-pdxPmsgrSMLbcCBVh]</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Nast is a packet sniffer and a LAN analyzer based on Libnet and Libpcap.</p><p>It can sniff in normal mode or in promiscuous mode the packets on a network interface and log it. It dumps the headers of packets and the payload in ascii or ascii-hex format. You can apply a filter. The sniffed data can be saved in a separated file.</p>
<dl class='dl-vertical'>
  <dt>
    <p>As analyzer tool, it has many features like:</p>
  </dt>
  <dd>
    <p>* Build LAN hosts list</p><p>* Follow a TCP-DATA stream</p><p>* Find LAN Internet gateways</p><p>* Discover promiscuous nodes</p><p>* Reset an established connection</p><p>* Perform a single half-open portscanner</p><p>* Perform a multi half-open portscanner</p><p>* Find link type (hub or switch)</p><p>* Catch daemon banner of LAN nodes</p><p>* Control ARP answers to discover possible ARP-spoofing</p><p>* Byte counting with an optional filter</p><p>* Write reports logging</p>
  </dd>
  <dt>
    <p>It also provides a new ncurses interface.</p>
  </dt>
  <dd>
    
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CMDLINE SNIFFER OPTIONS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>-i, --interface</strong></p>
  </dt>
  <dd>
    <p>Select the Interface, if not specified will be auto-detected.</p>
  </dd>
  <dt>
    <p><strong>-p, --promisc</strong></p>
  </dt>
  <dd>
    <p>Disable promiscuous mode on NIC.</p>
  </dd>
  <dt>
    <p><strong>-d, --ascii-data</strong></p>
  </dt>
  <dd>
    <p>Print data in ascii format.</p>
  </dd>
  <dt>
    <p><strong>-x, --ascii-hex-data</strong></p>
  </dt>
  <dd>
    <p>Print data in ascii-hex format.</p>
  </dd>
  <dt>
    <p><strong>-f, --filter &lt;"filter"&gt;</strong></p>
  </dt>
  <dd>
    <p>Apply &lt;"filter"&gt; to sniffer (see "FILTER SYNTAX" section below for syntax)</p>
  </dd>
  <dt>
    <p><strong>    --ld &lt;filename&gt;</strong></p>
  </dt>
  <dd>
    <p>Log captured data to &lt;filename&gt; (only payload). Use -l to log all packet instead, useful with -B</p>
  </dd>
  <dt>
    <p><strong>-T, --tcpdump-log &lt;filename&gt;</strong></p>
  </dt>
  <dd>
    <p>Log all packets in tcpdump format to &lt;filename&gt;</p>
  </dd>
  <dt>
    <p><strong>-R, --tcpdump-log-read &lt;filename&gt;</strong></p>
  </dt>
  <dd>
    <p>Read all packets saved in tcpdump format from &lt;filename&gt;</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ANALYZER FEATURES</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>-P, --check-promisc &lt;ip&gt;</strong></p>
  </dt>
  <dd>
    <p>Check other NIC on the LAN with the promiscuous flag set.</p><p>By performing a fake ARP broadcast, we can determine if a NIC is in promiscuous mode or not. If the checked host is in promiscuous mode it will responds with an ARP response otherwise it drop the packet.</p><p>Note: This method doesn't work with all OS</p><p>Use <strong>-P all</strong> to query all network NIC</p><p>eg: root@localhost:~/$ nast -P 192.168.1.2</p><p>NAST "NETWORK ANALYZER SNIFFER TOOL"</p><p>192.168.1.2 (localhost.org)             Found!!</p><p>We can check all nodes by using:</p><p>root@localhost:~/$ nast -P all</p>
  </dd>
  <dt>
    <p><strong>-m, --host-list</strong></p>
  </dt>
  <dd>
    <p>Map the LAN by performing a series of ARP request to sequential subnet IP addresses.</p><p>eg: root@localhost:~/$ nast -m</p><p>NAST "NETWORK ANALYZER SNIFFER TOOL"</p><p>Mapping the Lan for 255.255.255.0 subnet ... please wait</p><p>MAC address             IP address (hostname)</p><p>===========================================================</p><p>00:4R:BR:3E:21:12       192.168.1.1(nast.experiment.net)</p><p>00:50:BA:80:AC:11       192.168.1.2 (localhost.org) (*)</p><p>(*) This is localhost</p>
  </dd>
  <dt>
    <p><strong>-s, --tcp-stream</strong></p>
  </dt>
  <dd>
    <p>Follow a TCP/IP connection printing all data in payload. You must specify the IP addresses of the ends.</p><p>eg of a ftp connection:</p><p>root@localhost:~/$ nast -s</p><p>NAST "NETWORK ANALYZER SNIFFER TOOL"</p><p>Type connection extremes</p><p>------------------------</p><p>1st ip : 192.168.1.1</p><p>1st port : 1041</p><p>2nd : 192.168.1.2</p><p>2nd port : 21</p><p>NAST TCP STREAM LOG</p><p>192.168.1.1-&gt;mistaya.neverland.org</p><p>PASV</p><p>192.168.1.1&lt;-mistaya.neverland.org</p><p>227 Entering Passive Mode (192,168,1,2,4,12).</p><p>192.168.1.1-&gt;mistaya.neverland.org</p><p>LIST</p><p>(...)</p>
  </dd>
  <dt>
    <p><strong>-g, --find-gateway</strong></p>
  </dt>
  <dd>
    <p>Try to find possible Internet-gateways.</p><p>We send a SYN packet to a public host on port 80 through sequential host-lan and if a SYN-ACK return we have find the gateway.</p>
  </dd>
  <dt>
    <p><strong>-r, --reset-connection</strong></p>
  </dt>
  <dd>
    <p>Destroy an established connection. You must specify the IP addresses of the ends and at least one port . Please, pay attention when use this function.</p><p>eg: root@localhost:~/$ nast -r</p><p>NAST "NETWORK ANALYZER SNIFFER TOOL"</p><p>Type connection extremes</p><p>------------------------</p><p>1 ip / hostname : 192.168.1.1</p><p>1 port (0 to autodetect) : 0</p><p>2 ip / hostname : 192.168.1.2</p><p>2 port (0 to autodetect) : 21</p><p>- Waiting for SEQ ACK (192.168.1.1 -&gt; 192.168.1.2:21)</p><p>- Stoled SEQ (247656261) ACK (3764364876)...</p><p>- Connection has been resetted</p><p>This feature works only if we can read SEQ and ACK numbers, because RST mechanism works with them.</p>
  </dd>
  <dt>
    <p><strong>-S, --port-scanner</strong></p>
  </dt>
  <dd>
    <p>Performs a half-open port scanning on the selected host. It tries also to determine some firewall (just iptables) rules.</p><p>About this technique NMAP says: This technique is often referred to as "half-open" scanning, because you don't open a full TCP  connection.  You send  a SYN packet, as if you are going to open a real connection and you wait for a response. A SYN|ACK indicates the port is listening. A RST is indicative of a non-listener.  If a SYN|ACK is received, a RST is immediately sent to tear down  the  connection  (actually  our OS kernel does this for us). The primary advantage to this scanning technique is that fewer sites will log it.  Unfortunately you need root privileges to build these custom SYN packets.</p><p>eg: root@localhost:~/$ nast -S</p><p>NAST "NETWORK ANALYZER SNIFFER TOOL"</p><p>Port Scanner extremes</p><p>Insert IP to scan   : 192.168.1.3</p><p>Insert Port range   : 1-100</p><p>Wait for scanning...</p><p>State           Port            Services                Notes</p><p>Open            22              ssh                     None</p><p>Open            27              nsw-fe                  None</p><p>All the other 98 ports are in state closed</p><p>Scanning terminated on Apr 14 21:46:55</p><p>The Port range could be in the following style:</p><p>eg: 1-100       (means from port 1 to 100)</p>
<pre>
    1,3,5,1000  (means ports 1,3,5 and 1000)
    1-50,60     (means from port 1 to 50 and port 60)
</pre>

  </dd>
  <dt>
    <p><strong>-M, --multi-port-scanner</strong></p>
  </dt>
  <dd>
    <p>Same as above but done on all hosts of the lan.</p>
  </dd>
  <dt>
    <p><strong>-L, --find-link</strong></p>
  </dt>
  <dd>
    <p>Tries to determine what type of link is used in the LAN (Hub or switch).</p><p>In the LAN segment is there a HUB or a SWITCH? We can find it by sending a spoofed ICMP echo-request (to work there must be at least 3 host in LAN and at least one of them must reply with a ICMP echo-replay)</p>
  </dd>
  <dt>
    <p><strong>-b, --daemon-banner</strong></p>
  </dt>
  <dd>
    <p>Checks the most famous daemon banner on the LAN's hosts.</p><p>You can customize ports database adding them to ports[] variable in main.c</p>
  </dd>
  <dt>
    <p><strong>-c, --check-arp-poisoning</strong></p>
  </dt>
  <dd>
    <p>Control ARP answers to discover possible ARP spoofing attacks like man-in-the-middle</p><p>When run, Nast make a database of all network node (IP and MAC address), then sniff ARP response and verify the correctness of IP-mac address association. Remember to execute Nast when you are sure that nobody is making ARP-poisoning, than have fun and relax and check program output:).</p>
  </dd>
  <dt>
    <p><strong>-C, --byte-counting &lt;"filter"&gt;</strong></p>
  </dt>
  <dd>
    <p>Apply traffic counting to &lt;"filter"&gt; (see FILTER SYNTAX section below for syntax)</p><p>Use <strong>-C any</strong> if you don't want to use a filter.</p><p>eg: root@localhost:~/$ nast -C any</p><p>NAST "NETWORK ANALYZER SNIFFER TOOL"</p><p>Reading from "eth0"</p><p>Packets         Total           Current speed           Average speed</p><p>----------------------------------------------------------------</p><p>- 24            1008B           18B/s                   21B/s</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">GENERAL OPTIONS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>-G, --ncurses</strong></p>
  </dt>
  <dd>
    <p>Run Nast with the ncurses interfaces (only if compiled with ncurses support)</p>
  </dd>
  <dt>
    <p><strong>-l, --log-file &lt;filename&gt;</strong></p>
  </dt>
  <dd>
    <p>Log reports to &lt;filename&gt;. Work with many features.</p>
  </dd>
  <dt>
    <p><strong>-B, --daemon</strong></p>
  </dt>
  <dd>
    <p>Run in background like daemon and turn off stdout (very useful for sniffer/stream/ARP control logging)</p>
  </dd>
  <dt>
    <p><strong>-V, --version</strong></p>
  </dt>
  <dd>
    <p>Show version information</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NCURSES INTERFACE NOTE</h2>
        <div class="sectioncontent">
<p>Versions later 0.2.0 have a new ncurses interface which has many improvements regarding the correspondent command line version. For example you can select the connection interactively for tcp stream and reset features and byte counting module show much more information (packets type and connections load).</p>
<dl class='dl-vertical'>
  <dt>
    <p>Please read NCURSES_README file before using the ncurses interface!</p>
  </dt>
  <dd>
    
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILTER SYNTAX, WHAT PCAP GIVE US!</h2>
        <div class="sectioncontent">
<p>Important: this section has been copied from Tcpdump 3.7.1 manpage and "expression" here stand from "filter".</p><p><strong>Remeber</strong> to enclose filter between apexes ("something like this")</p>
<dl class='dl-vertical'>
  <dt>
    <em> expression</em>
  </dt>
  <dd>
    <p>selects which packets will be dumped. If no <em>expression</em> is given, all packets on the net will be dumped. Otherwise, only packets for which <em>expression</em> is `true' will be dumped.</p><p>The <em>expression</em> consists of one or more <em>primitives.</em> Primitives usually consist of an <em>id</em> (name or number) preceded by one or more qualifiers. There are three different kinds of qualifier:</p>
<dl class='dl-vertical'>
  <dt>
    <em>type</em>
  </dt>
  <dd>
    <p>qualifiers say what kind of thing the id name or number refers to. Possible types are <strong>host</strong>, <strong>net</strong> and <strong>port</strong>. E.g., `host foo', `net 128.3', `port 20'. If there is no type qualifier, <strong>host</strong> is assumed.</p>
  </dd>
  <dt>
    <em>dir</em>
  </dt>
  <dd>
    <p>qualifiers specify a particular transfer direction to and/or from <em>id</em>. Possible directions are <strong>src</strong>, <strong>dst</strong>, <strong>src or dst</strong> and <strong>src and</strong> <strong>dst</strong>. E.g., `src foo', `dst net 128.3', `src or dst port ftp-data'. If there is no dir qualifier, <strong>src or dst</strong> is assumed. For `null' link layers (i.e. point to point protocols such as slip) the <strong>inbound</strong> and <strong>outbound</strong> qualifiers can be used to specify a desired direction.</p>
  </dd>
  <dt>
    <em>proto</em>
  </dt>
  <dd>
    <p>qualifiers restrict the match to a particular protocol. Possible protos are: <strong>ether</strong>, <strong>fddi</strong>, <strong>tr</strong>, <strong>ip</strong>, <strong>ip6</strong>, <strong>arp</strong>, <strong>rarp</strong>, <strong>decnet</strong>, <strong>tcp</strong> and <strong>udp</strong>. E.g., `ether src foo', `arp net 128.3', `tcp port 21'. If there is no proto qualifier, all protocols consistent with the type are assumed. E.g., `src foo' means `(ip or arp or rarp) src foo' (except the latter is not legal syntax), `net bar' means `(ip or arp or rarp) net bar' and `port 53' means `(tcp or udp) port 53'.</p>
  </dd>

</dl>
<p>[`fddi' is actually an alias for `ether'; the parser treats them identically as meaning ``the data link level used on the specified network interface.''  FDDI headers contain Ethernet-like source and destination addresses, and often contain Ethernet-like packet types, so you can filter on these FDDI fields just as with the analogous Ethernet fields. FDDI headers also contain other fields, but you cannot name them explicitly in a filter expression.</p><p>Similarly, `tr' is an alias for `ether'; the previous paragraph's statements about FDDI headers also apply to Token Ring headers.]</p><p>In addition to the above, there are some special `primitive' keywords that don't follow the pattern: <strong>gateway</strong>, <strong>broadcast</strong>, <strong>less</strong>, <strong>greater</strong> and arithmetic expressions. All of these are described below.</p><p>More complex filter expressions are built up by using the words <strong>and</strong>, <strong>or</strong> and <strong>not</strong> to combine primitives. E.g., `host foo and not port ftp and not port ftp-data'. To save typing, identical qualifier lists can be omitted. E.g., `tcp dst port ftp or ftp-data or domain' is exactly the same as `tcp dst port ftp or tcp dst port ftp-data or tcp dst port domain'.</p><p>Allowable primitives are:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>dst host </strong><em>host</em>
  </dt>
  <dd>
    <p>True if the IPv4/v6 destination field of the packet is <em>host</em>, which may be either an address or a name.</p>
  </dd>
  <dt>
    <strong>src host </strong><em>host</em>
  </dt>
  <dd>
    <p>True if the IPv4/v6 source field of the packet is <em>host</em>.</p>
  </dd>
  <dt>
    <strong>host </strong><em>host</em><strong></strong>
  </dt>
  <dd>
    <p>True if either the IPv4/v6 source or destination of the packet is <em>host</em>. Any of the above host expressions can be prepended with the keywords, <strong>ip</strong>, <strong>arp</strong>, <strong>rarp</strong>, or <strong>ip6</strong> as in:</p>
<pre>
<strong>ip host </strong><em>host</em>
</pre>
<p>which is equivalent to:</p>
<pre>
<strong>ether proto </strong><em>&#92;ip</em><strong> and host </strong><em>host</em>
</pre>
<p>If <em>host</em> is a name with multiple IP addresses, each address will be checked for a match.</p>
  </dd>
  <dt>
    <strong>ether dst </strong><em>ehost</em><strong></strong>
  </dt>
  <dd>
    <p>True if the ethernet destination address is <em>ehost</em>. <em>Ehost</em> may be either a name from /etc/ethers or a number (see <em>ethers</em>(3N) for numeric format).</p>
  </dd>
  <dt>
    <strong>ether src </strong><em>ehost</em><strong></strong>
  </dt>
  <dd>
    <p>True if the ethernet source address is <em>ehost</em>.</p>
  </dd>
  <dt>
    <strong>ether host </strong><em>ehost</em><strong></strong>
  </dt>
  <dd>
    <p>True if either the ethernet source or destination address is <em>ehost</em>.</p>
  </dd>
  <dt>
    <strong>gateway</strong> <em>host</em>
  </dt>
  <dd>
    <p>True if the packet used <em>host</em> as a gateway. I.e., the ethernet source or destination address was <em>host</em> but neither the IP source nor the IP destination was <em>host</em>. <em>Host</em> must be a name and must be found both by the machine's host-name-to-IP-address resolution mechanisms (host name file, DNS, NIS, etc.) and by the machine's host-name-to-Ethernet-address resolution mechanism (/etc/ethers, etc.). (An equivalent expression is</p>
<pre>
<strong>ether host </strong><em>ehost </em><strong>and not host </strong><em>host</em>
</pre>
<p>which can be used with either names or numbers for <em>host / ehost</em>.) This syntax does not work in IPv6-enabled configuration at this moment.</p>
  </dd>
  <dt>
    <strong>dst net </strong><em>net</em>
  </dt>
  <dd>
    <p>True if the IPv4/v6 destination address of the packet has a network number of <em>net</em>. <em>Net</em> may be either a name from /etc/networks or a network number (see <strong>networks</strong>(4)</em> for details).</p>
  </dd>
  <dt>
    <strong>src net </strong><em>net</em>
  </dt>
  <dd>
    <p>True if the IPv4/v6 source address of the packet has a network number of <em>net</em>.</p>
  </dd>
  <dt>
    <strong>net </strong><em>net</em>
  </dt>
  <dd>
    <p>True if either the IPv4/v6 source or destination address of the packet has a network number of <em>net</em>.</p>
  </dd>
  <dt>
    <strong>net </strong><em>net</em> <strong>mask </strong><em>netmask</em>
  </dt>
  <dd>
    <p>True if the IP address matches <em>net</em> with the specific <em>netmask</em>. May be qualified with <strong>src</strong> or <strong>dst</strong>. Note that this syntax is not valid for IPv6 <em>net</em>.</p>
  </dd>
  <dt>
    <strong>net </strong><em>net</em>/<em>len</em>
  </dt>
  <dd>
    <p>True if the IPv4/v6 address matches <em>net</em> with a netmask <em>len</em> bits wide. May be qualified with <strong>src</strong> or <strong>dst</strong>.</p>
  </dd>
  <dt>
    <strong>dst port </strong><em>port</em>
  </dt>
  <dd>
    <p>True if the packet is ip/tcp, ip/udp, ip6/tcp or ip6/udp and has a destination port value of <em>port</em>. The <em>port</em> can be a number or a name used in /etc/services (see <em>tcp</em>(4P) and <em>udp</em>(4P)). If a name is used, both the port number and protocol are checked. If a number or ambiguous name is used, only the port number is checked (e.g., <strong>dst port 513</strong> will print both tcp/login traffic and udp/who traffic, and <strong>port domain</strong> will print both tcp/domain and udp/domain traffic).</p>
  </dd>
  <dt>
    <strong>src port </strong><em>port</em>
  </dt>
  <dd>
    <p>True if the packet has a source port value of <em>port</em>.</p>
  </dd>
  <dt>
    <strong>port </strong><em>port</em>
  </dt>
  <dd>
    <p>True if either the source or destination port of the packet is <em>port</em>. Any of the above port expressions can be prepended with the keywords, <strong>tcp</strong> or <strong>udp</strong>, as in:</p>
<pre>
<strong>tcp src port </strong><em>port</em>
</pre>
<p>which matches only tcp packets whose source port is <em>port</em>.</p>
  </dd>
  <dt>
    <strong>less </strong><em>length</em>
  </dt>
  <dd>
    <p>True if the packet has a length less than or equal to <em>length</em>. This is equivalent to:</p>
<pre>
<strong>len &lt;= </strong><em>length</em><strong>.</strong>
</pre>

  </dd>
  <dt>
    <strong>greater </strong><em>length</em>
  </dt>
  <dd>
    <p>True if the packet has a length greater than or equal to <em>length</em>. This is equivalent to:</p>
<pre>
<strong>len &gt;= </strong><em>length</em><strong>.</strong>
</pre>

  </dd>
  <dt>
    <strong>ip proto </strong><em>protocol</em>
  </dt>
  <dd>
    <p>True if the packet is an IP packet (see <em>ip</em>(4P)) of protocol type <em>protocol</em>. <em>Protocol</em> can be a number or one of the names <em>icmp</em>, <em>icmp6</em>, <em>igmp</em>, <em>igrp</em>, <em>pim</em>, <em>ah</em>, <em>esp</em>, <em>vrrp</em>, <em>udp</em>, or <em>tcp</em>. Note that the identifiers <em>tcp</em>, <em>udp</em>, and <em>icmp</em> are also keywords and must be escaped via backslash (&#92;), which is &#92;nbsp;in the C-shell. Note that this primitive does not chase the protocol header chain.</p>
  </dd>
  <dt>
    <strong>ip6 proto </strong><em>protocol</em>
  </dt>
  <dd>
    <p>True if the packet is an IPv6 packet of protocol type <em>protocol</em>. Note that this primitive does not chase the protocol header chain.</p>
  </dd>
  <dt>
    <strong>ip6 protochain </strong><em>protocol</em>
  </dt>
  <dd>
    <p>True if the packet is IPv6 packet, and contains protocol header with type <em>protocol</em> in its protocol header chain. For example,</p>
<pre>
<strong>ip6 protochain 6</strong>
</pre>
<p>matches any IPv6 packet with TCP protocol header in the protocol header chain. The packet may contain, for example, authentication header, routing header, or hop-by-hop option header, between IPv6 header and TCP header. The BPF code emitted by this primitive is complex and cannot be optimized by BPF optimizer code in <em>tcpdump</em>, so this can be somewhat slow.</p>
  </dd>
  <dt>
    <strong>ip protochain </strong><em>protocol</em>
  </dt>
  <dd>
    <p>Equivalent to <strong>ip6 protochain </strong><em>protocol</em>, but this is for IPv4.</p>
  </dd>
  <dt>
    <strong>ether broadcast</strong>
  </dt>
  <dd>
    <p>True if the packet is an ethernet broadcast packet. The <em>ether</em> keyword is optional.</p>
  </dd>
  <dt>
    <strong>ip broadcast</strong>
  </dt>
  <dd>
    <p>True if the packet is an IP broadcast packet. It checks for both the all-zeroes and all-ones broadcast conventions, and looks up the local subnet mask.</p>
  </dd>
  <dt>
    <strong>ether multicast</strong>
  </dt>
  <dd>
    <p>True if the packet is an ethernet multicast packet. The <em>ether</em> keyword is optional. This is shorthand for `<strong>ether[0] & 1 != 0</strong>'.</p>
  </dd>
  <dt>
    <strong>ip multicast</strong>
  </dt>
  <dd>
    <p>True if the packet is an IP multicast packet.</p>
  </dd>
  <dt>
    <strong>ip6 multicast</strong>
  </dt>
  <dd>
    <p>True if the packet is an IPv6 multicast packet.</p>
  </dd>
  <dt>
    <strong>ether proto </strong><em>protocol</em>
  </dt>
  <dd>
    <p>True if the packet is of ether type <em>protocol</em>. <em>Protocol</em> can be a number or one of the names <em>ip</em>, <em>ip6</em>, <em>arp</em>, <em>rarp</em>, <em>atalk</em>, <em>aarp</em>, <em>decnet</em>, <em>sca</em>, <em>lat</em>, <em>mopdl</em>, <em>moprc</em>, <em>iso</em>, <em>stp</em>, <em>ipx</em>, or <em>netbeui</em>. Note these identifiers are also keywords and must be escaped via backslash (&#92;).</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>[In the case of FDDI (e.g., `<strong>fddi protocol arp</strong>') and Token Ring (e.g., `<strong>tr protocol arp</strong>'), for most of those protocols, the protocol identification comes from the 802.2 Logical Link Control (LLC) header, which is usually layered on top of the FDDI or Token Ring header.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>When filtering for most protocol identifiers on FDDI or Token Ring, <em>tcpdump</em> checks only the protocol ID field of an LLC header in so-called SNAP format with an Organizational Unit Identifier (OUI) of 0x000000, for encapsulated Ethernet; it doesn't check whether the packet is in SNAP format with an OUI of 0x000000.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>The exceptions are <em>iso</em>, for which it checks the DSAP (Destination Service Access Point) and SSAP (Source Service Access Point) fields of the LLC header, <em>stp</em> and <em>netbeui</em>, where it checks the DSAP of the LLC header, and <em>atalk</em>, where it checks for a SNAP-format packet with an OUI of 0x080007 and the Appletalk etype.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>In the case of Ethernet, <em>tcpdump</em> checks the Ethernet type field for most of those protocols; the exceptions are <em>iso</em>, <em>sap</em>, and <em>netbeui</em>, for which it checks for an 802.3 frame and then checks the LLC header as it does for FDDI and Token Ring, <em>atalk</em>, where it checks both for the Appletalk etype in an Ethernet frame and for a SNAP-format packet as it does for FDDI and Token Ring, <em>aarp</em>, where it checks for the Appletalk ARP etype in either an Ethernet frame or an 802.2 SNAP frame with an OUI of 0x000000, and <em>ipx</em>, where it checks for the IPX etype in an Ethernet frame, the IPX DSAP in the LLC header, the 802.3 with no LLC header encapsulation of IPX, and the IPX etype in a SNAP frame.]</p>
  </dd>
  <dt>
    <strong>decnet src </strong><em>host</em>
  </dt>
  <dd>
    <p>True if the DECNET source address is <em>host</em>, which may be an address of the form ``10.123'', or a DECNET host name. [DECNET host name support is only available on Ultrix systems that are configured to run DECNET.]</p>
  </dd>
  <dt>
    <strong>decnet dst </strong><em>host</em>
  </dt>
  <dd>
    <p>True if the DECNET destination address is <em>host</em>.</p>
  </dd>
  <dt>
    <strong>decnet host </strong><em>host</em>
  </dt>
  <dd>
    <p>True if either the DECNET source or destination address is <em>host</em>.</p>
  </dd>
  <dt>
    <strong>ip</strong>, <strong>ip6</strong>, <strong>arp</strong>, <strong>rarp</strong>, <strong>atalk</strong>, <strong>aarp</strong>, <strong>decnet</strong>, <strong>iso</strong>, <strong>stp</strong>, <strong>ipx</strong>, <em>netbeui</em>
  </dt>
  <dd>
    <p>Abbreviations for:</p>
<pre>
<strong>ether proto </strong><em>p</em>
</pre>
<p>where <em>p</em> is one of the above protocols.</p>
  </dd>
  <dt>
    <strong>lat</strong>, <strong>moprc</strong>, <strong>mopdl</strong>
  </dt>
  <dd>
    <p>Abbreviations for:</p>
<pre>
<strong>ether proto </strong><em>p</em>
</pre>
<p>where <em>p</em> is one of the above protocols. Note that <em>tcpdump</em> does not currently know how to parse these protocols.</p>
  </dd>
  <dt>
    <strong>vlan </strong><em>[vlan_id]</em>
  </dt>
  <dd>
    <p>True if the packet is an IEEE 802.1Q VLAN packet. If <em>[vlan_id]</em> is specified, only true is the packet has the specified <em>vlan_id</em>. Note that the first <strong>vlan</strong> keyword encountered in <em>expression</em> changes the decoding offsets for the remainder of <em>expression</em> on the assumption that the packet is a VLAN packet.</p>
  </dd>
  <dt>
    <strong>tcp</strong>, <strong>udp</strong>, <strong>icmp</strong>
  </dt>
  <dd>
    <p>Abbreviations for:</p>
<pre>
<strong>ip proto </strong><em>p</em><strong> or ip6 proto </strong><em>p</em>
</pre>
<p>where <em>p</em> is one of the above protocols.</p>
  </dd>
  <dt>
    <strong>iso proto </strong><em>protocol</em>
  </dt>
  <dd>
    <p>True if the packet is an OSI packet of protocol type <em>protocol</em>. <em>Protocol</em> can be a number or one of the names <em>clnp</em>, <em>esis</em>, or <em>isis</em>.</p>
  </dd>
  <dt>
    <strong>clnp</strong>, <strong>esis</strong>, <strong>isis</strong>
  </dt>
  <dd>
    <p>Abbreviations for:</p>
<pre>
<strong>iso proto </strong><em>p</em>
</pre>
<p>where <em>p</em> is one of the above protocols. Note that <em>tcpdump</em> does an incomplete job of parsing these protocols.</p>
  </dd>

</dl>

  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>Here are some examples of the use of NAST:</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple"></h2>
        <div class="sectioncontent">

<pre>
   nast -f "src 192.168.1.2"
</pre>
<p>In this example with the help of the filter we choose to see only the traffic from 192.168.1.2</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple"></h2>
        <div class="sectioncontent">

<pre>
   nast -p -B --ld logfile.txt
</pre>
<p>Here we run nast in background mode and log all data that pass through our NIC.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple"></h2>
        <div class="sectioncontent">

<pre>
   nast -S -l logfile.txt
</pre>
<p>In this other case we log the results of the port scanner in the file "logfile.txt"</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple"></h2>
        <div class="sectioncontent">

<pre>
   nast -c -B
</pre>
<p>This is a very useful options. We run in background mode nast that checks if someone is arp-poisoning.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SUPPORTED PLATFORMS</h2>
        <div class="sectioncontent">
<p>Tested:</p><p>* Linux 2.4.x</p><p>* Linux 2.6.x</p><p>* FreeBSD 5.x</p><p>* FreeBSD 4.x</p><p>Not tested yet:</p><p>* Linux 2.2.x</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AVAILABILITY</h2>
        <div class="sectioncontent">
<p>Official web site: http://nast.berlios.de</p><p>Newsletter: http://lists.berlios.de/mailman/listinfo/nast-news</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">KNOWN BUGS</h2>
        <div class="sectioncontent">
<p>* Promiscuous mode scanner many times returns wrong results</p><p>* Sometimes the port scanner generates false results</p><p>Please report bugs to authors</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p>Embyte &lt;embyte@madlab.it&gt;</p><p>Snifth &lt;snifth@box.it&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LICENSE</h2>
        <div class="sectioncontent">
<p>GNU GENERAL PUBLIC LICENSE Version 2, June 1991</p><p>See COPYING for details.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="nameif.8.html"><span aria-hidden="true">&larr;</span> nameif.8: Name network interfaces based on mac addresses</a></li>
   <li class="next"><a href="natsemi-diag.8.html">natsemi-diag.8: Eeprom setup and diagnostic program for ethernet cards based on the national semiconductor dp83810 / 83815 chips. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

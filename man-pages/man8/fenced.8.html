<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>fenced: The i/o fencing daemon</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The i/o fencing daemon">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="fenced (8) manual">
  <meta name="twitter:description" content="The i/o fencing daemon">
  <meta name="twitter:image" content="https://www.carta.tech/images/cman-fenced-8.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man8/fenced.8.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="fenced (8) manual" />
  <meta property="og:description" content="The i/o fencing daemon" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/cman-fenced-8.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">fenced<small> (8)</small></h1>
        <p class="lead">The i/o fencing daemon</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man8/">
      <span itemprop="name">System administration commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man8/fenced.8.html">
      <span itemprop="name">fenced: The i/o fencing daemon</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/cman/">
      <span itemprop="name">cman</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man8/fenced.8.html">
      <span itemprop="name">fenced: The i/o fencing daemon</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>fenced</strong> [OPTIONS]</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The fencing daemon, fenced, fences cluster nodes that have failed. Fencing a node generally means rebooting it or otherwise preventing it from writing to storage, e.g. disabling its port on a SAN switch.  Fencing involves interacting with a hardware device, e.g. network power switch, SAN switch, storage array.  Different "fencing agents" are run by fenced to interact with various hardware devices.</p><p>Software related to sharing storage among nodes in a cluster, e.g. GFS, usually requires fencing to be configured to prevent corruption of the storage in the presence of node failure and recovery.  GFS will not allow a node to mount a GFS file system unless the node is running fenced.</p><p>Once started, fenced waits for the <a href="../man8/fence_tool.8.html"><strong>fence_tool</strong>(8)</a> join command to be run, telling it to join the fence domain: a group of nodes that will fence group members that fail.  When the cluster does not have quorum, fencing operations are postponed until quorum is restored. If a failed fence domain member is reset and rejoins the cluster before the remaining domain members have fenced it, the fencing is no longer needed and will be skipped.</p><p>fenced uses the corosync cluster membership system, it's closed process group library (libcpg), and the cman quorum and configuration libraries (libcman, libccs).</p><p>The cman init script usually starts the fenced daemon and runs fence_tool join and leave.</p><h3>Node failure</h3>
<p>When a fence domain member fails, fenced runs an agent to fence it.  The specific agent to run and the agent parameters are all read from the cluster.conf file (using libccs) at the time of fencing.  The fencing operation against a failed node is not considered complete until the exec'ed agent exits.  The exit value of the agent indicates the success or failure of the operation.  If the operation failed, fenced will retry (possibly with a different agent, depending on the configuration) until fencing succeeds.  Other systems such as DLM and GFS wait for fencing to complete before starting their own recovery for a failed node. Information about fencing operations will also appear in syslog.</p><p>When a domain member fails, the actual fencing operation can be delayed by a configurable number of seconds (cluster.conf post_fail_delay or -f). Within this time, the failed node could be reset and rejoin the cluster to avoid being fenced.  This delay is 0 by default to minimize the time that other systems are blocked.</p>
<h3>Domain startup</h3>
<p>When the fence domain is first created in the cluster (by the first node to join it) and subsequently enabled (by the cluster gaining quorum) any nodes listed in cluster.conf that are not presently members of the corosync cluster are fenced.  The status of these nodes is unknown, and to be safe they are assumed to need fencing.  This startup fencing can be disabled, but it's only truly safe to do so if an operator is present to verify that no cluster nodes are in need of fencing.</p><p>The following example illustrates why startup fencing is important.  Take a three node cluster with nodes A, B and C; all three have a GFS file system mounted.  All three nodes experience a low-level kernel hang at about the same time.  A watchdog triggers a reboot on nodes A and B, but not C.  A and B reboot, form the cluster again, gain quorum, join the fence domain, _don't_ fence node C which is still hung and unresponsive, and mount the GFS fs again.  If C were to come back to life, it could corrupt the fs.  So, A and B need to fence C when they reform the fence domain since they don't know the state of C.  If C _had_ been reset by a watchdog like A and B, but was just slow in rebooting, then A and B might be fencing C unnecessarily when they do startup fencing.</p><p>The first way to avoid fencing nodes unnecessarily on startup is to ensure that all nodes have joined the cluster before any of the nodes start the fence daemon.  This method is difficult to automate.</p><p>A second way to avoid fencing nodes unnecessarily on startup is using the cluster.conf post_join_delay setting (or -j option).  This is the number of seconds fenced will delay before actually fencing any victims after nodes join the domain.  This delay gives nodes that have been tagged for fencing a chance to join the cluster and avoid being fenced.  A delay of -1 here will cause the daemon to wait indefinitely for all nodes to join the cluster and no nodes will actually be fenced on startup.</p><p>To disable fencing at domain-creation time entirely, the cluster.conf clean_start setting (or -c option) can be used to declare that all nodes are in a clean or safe state to start.  This setting/option should not generally be used since it risks not fencing a node that needs it, which can lead to corruption in other applications (like GFS) that depend on fencing.</p><p>Avoiding unnecessary fencing at startup is primarily a concern when nodes are fenced by power cycling.  If nodes are fenced by disabling their SAN access, then unnecessarily fencing a node is usually less disruptive.</p>
<h3>Fencing override</h3>
<p>If a fencing device fails, the agent may repeatedly return errors as fenced tries to fence a failed node.  In this case, the admin can manually reset the failed node, and then use <a href="../man8/fence_ack_manual.8.html"><strong>fence_ack_manual</strong>(8)</a> to tell fenced to continue without fencing the node.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONS</h2>
        <div class="sectioncontent">
<p>Command line options override a corresponding setting in cluster.conf.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>-D</strong></p>
  </dt>
  <dd>
    <p>Enable debugging to stderr and don't fork.</p><p>See also <strong>fence_tool dump</strong> in <a href="../man8/fence_tool.8.html"><strong>fence_tool</strong>(8)</a>.</p>
  </dd>
  <dt>
    <p><strong>-L</strong></p>
  </dt>
  <dd>
    <p>Enable debugging to log file.</p><p>See also <strong>logging</strong> in <a href="../man5/cluster.conf.5.html"><strong>cluster.conf</strong>(5)</a>.</p>
  </dd>
  <dt>
    <p><strong>-g</strong><em> num</em></p>
  </dt>
  <dd>
    <p>groupd compatibility mode, 0 off, 1 on. Default 0.</p>
  </dd>
  <dt>
    <p><strong>-r</strong><em> path</em></p>
  </dt>
  <dd>
    <p>Register a directory that needs to be empty for the daemon to start.  Use a dash (-) to skip default directories /sys/fs/gfs, /sys/fs/gfs2, /sys/kernel/dlm.</p>
  </dd>
  <dt>
    <p><strong>-c</strong></p>
  </dt>
  <dd>
    <p>All nodes are in a clean state to start. Do no startup fencing.</p>
  </dd>
  <dt>
    <p><strong>-s</strong></p>
  </dt>
  <dd>
    <p>Skip startup fencing of nodes with no defined fence methods.</p>
  </dd>
  <dt>
    <p><strong>-q</strong></p>
  </dt>
  <dd>
    <p>Disable dbus signals.</p>
  </dd>
  <dt>
    <p><strong>-j</strong><em> secs</em></p>
  </dt>
  <dd>
    <p>Post-join fencing delay. Default 6.</p>
  </dd>
  <dt>
    <p><strong>-f</strong><em> secs</em></p>
  </dt>
  <dd>
    <p>Post-fail fencing delay. Default 0.</p>
  </dd>
  <dt>
    <p><strong>-R</strong><em> secs</em></p>
  </dt>
  <dd>
    <p>Number of seconds to wait for a manual override after a failed fencing attempt before the next attempt. Default 3.</p>
  </dd>
  <dt>
    <p><strong>-O</strong><em> path</em></p>
  </dt>
  <dd>
    <p>Location of a FIFO used for communication between fenced and fence_ack_manual.</p>
  </dd>
  <dt>
    <p><strong>-h</strong></p>
  </dt>
  <dd>
    <p>Print a help message describing available options, then exit.</p>
  </dd>
  <dt>
    <p><strong>-V</strong></p>
  </dt>
  <dd>
    <p>Print program version information, then exit.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILES</h2>
        <div class="sectioncontent">
<p><a href="../man5/cluster.conf.5.html"><strong>cluster.conf</strong>(5)</a> is usually located at /etc/cluster/cluster.conf.  It is not read directly. Other cluster components load the contents into memory, and the values are accessed through the libccs library.</p><p>Configuration options for fenced are added to the &lt;fence_daemon /&gt; section of cluster.conf, within the top level &lt;cluster&gt; section.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>post_join_delay</strong></p>
  </dt>
  <dd>
    <p>is the number of seconds the daemon will wait before fencing any victims after a node joins the domain.  Default 6.</p><p>&lt;fence_daemon post_join_delay="6"/&gt;</p>
  </dd>
  <dt>
    <p><strong>post_fail_delay</strong></p>
  </dt>
  <dd>
    <p>is the number of seconds the daemon will wait before fencing any victims after a domain member fails.  Default 0.</p><p>&lt;fence_daemon post_fail_delay="0"/&gt;</p>
  </dd>
  <dt>
    <p><strong>clean_start</strong></p>
  </dt>
  <dd>
    <p>is used to prevent any startup fencing the daemon might do. It indicates that the daemon should assume all nodes are in a clean state to start. Default 0.</p><p>&lt;fence_daemon clean_start="0"/&gt;</p>
  </dd>
  <dt>
    <p><strong>override_path</strong></p>
  </dt>
  <dd>
    <p>is the location of a FIFO used for communication between fenced and fence_ack_manual. Default shown.</p><p>&lt;fence_daemon override_path="/var/run/cluster/fenced_override"/&gt;</p>
  </dd>
  <dt>
    <p><strong>override_time</strong></p>
  </dt>
  <dd>
    <p>is the number of seconds to wait for administrator intervention between fencing attempts following fence agent failures. Default 3.</p><p>&lt;fence_daemon override_time="3"/&gt;</p>
  </dd>

</dl>
<h3>Per-node fencing settings</h3>
<p>The per-node fencing configuration is partly dependant on the specific agent/hardware being used.  The general framework begins like this:</p>
<pre>
&lt;clusternodes&gt;

&lt;clusternode name="node1" nodeid="1"&gt;
        &lt;fence&gt;
        &lt;/fence&gt;
&lt;/clusternode&gt;

&lt;clusternode name="node2" nodeid="2"&gt;
        &lt;fence&gt;
        &lt;/fence&gt;
&lt;/clusternode&gt;

&lt;/clusternodes&gt;
</pre>
<p>The simple fragment above is a valid configuration: there is no way to fence these nodes.  If one of these nodes is in the fence domain and fails, fenced will repeatedly fail in its attempts to fence it.  The admin will need to manually reset the failed node and then use fence_ack_manual to tell fenced to continue without fencing it (see override above).</p><p>There is typically a single method used to fence each node (the name given to the method is not significant).  A method refers to a specific device listed in the separate &lt;fencedevices&gt; section, and then lists any node-specific parameters related to using the device.</p>
<pre>
&lt;clusternodes&gt;

&lt;clusternode name="node1" nodeid="1"&gt;
        &lt;fence&gt;
        &lt;method name="1"&gt;
        &lt;device name="myswitch" foo="x"/&gt;
        &lt;/method&gt;
        &lt;/fence&gt;
&lt;/clusternode&gt;

&lt;clusternode name="node2" nodeid="2"&gt;
        &lt;fence&gt;
        &lt;method name="1"&gt;
        &lt;device name="myswitch" foo="y"/&gt;
        &lt;/method&gt;
        &lt;/fence&gt;
&lt;/clusternode&gt;

&lt;/clusternodes&gt;
</pre>

<h3>Fence device settings</h3>
<p>This section defines properties of the devices used to fence nodes.  There may be one or more devices listed.  The per-node fencing sections above reference one of these fence devices by name.</p>
<pre>
&lt;fencedevices&gt;
        &lt;fencedevice name="myswitch" agent="..." something="..."/&gt;
&lt;/fencedevices&gt;
</pre>

<h3>Multiple methods for a node</h3>
<p>In more advanced configurations, multiple fencing methods can be defined for a node.  If fencing fails using the first method, fenced will try the next method, and continue to cycle through methods until one succeeds.</p>
<pre>
&lt;clusternode name="node1" nodeid="1"&gt;
        &lt;fence&gt;
        &lt;method name="1"&gt;
        &lt;device name="myswitch" foo="x"/&gt;
        &lt;/method&gt;
        &lt;method name="2"&gt;
        &lt;device name="another" bar="123"/&gt;
        &lt;/method&gt;
        &lt;/fence&gt;
&lt;/clusternode&gt;

&lt;fencedevices&gt;
        &lt;fencedevice name="myswitch" agent="..." something="..."/&gt;
        &lt;fencedevice name="another" agent="..."/&gt;
&lt;/fencedevices&gt;
</pre>

<h3>Dual path, redundant power</h3>
<p>Sometimes fencing a node requires disabling two power ports or two i/o paths.  This is done by specifying two or more devices within a method. fenced will run the agent for the device twice, once for each device line, and both must succeed for fencing to be considered successful.</p>
<pre>
&lt;clusternode name="node1" nodeid="1"&gt;
        &lt;fence&gt;
        &lt;method name="1"&gt;
        &lt;device name="sanswitch1" port="11"/&gt;
        &lt;device name="sanswitch2" port="11"/&gt;
        &lt;/method&gt;
        &lt;/fence&gt;
&lt;/clusternode&gt;
</pre>
<p>When using power switches to fence nodes with dual power supplies, the agents must be told to turn off both power ports before restoring power to either port.  The default off-on behavior of the agent could result in the power never being fully disabled to the node.</p>
<pre>
&lt;clusternode name="node1" nodeid="1"&gt;
        &lt;fence&gt;
        &lt;method name="1"&gt;
        &lt;device name="nps1" port="11" action="off"/&gt;
        &lt;device name="nps2" port="11" action="off"/&gt;
        &lt;device name="nps1" port="11" action="on"/&gt;
        &lt;device name="nps2" port="11" action="on"/&gt;
        &lt;/method&gt;
        &lt;/fence&gt;
&lt;/clusternode&gt;
</pre>

<h3>Hardware-specific settings</h3>
<p>Find documentation for configuring specific devices from the device agent's man page.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO fenced&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man8/fence_tool.8.html"><strong>fence_tool</strong>(8)</a>, <a href="../man8/fence_ack_manual.8.html"><strong>fence_ack_manual</strong>(8)</a>, <a href="../man8/fence_node.8.html"><strong>fence_node</strong>(8)</a>, <a href="../man5/cluster.conf.5.html"><strong>cluster.conf</strong>(5)</a></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="fence_zvm.8.html"><span aria-hidden="true">&larr;</span> fence_zvm.8: I/o fencing agent for gfs on s390 and zseries vm clusters</a></li>
   <li class="next"><a href="fetch-crl.8.html">fetch-crl.8: Retrieve certificate revocation lists <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

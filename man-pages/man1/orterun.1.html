<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>orterun: Execute serial and parallel jobs in open mpi.  note: mpirun, mpiexec, and orterun are all synonyms for each other.  using any of the names will produce the same behavior.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Execute serial and parallel jobs in open mpi.  note: mpirun, mpiexec, and orterun are all synonyms for each other.  using any of the names will produce the same behavior.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="orterun (1) manual">
  <meta name="twitter:description" content="Execute serial and parallel jobs in open mpi.  note: mpirun, mpiexec, and orterun are all synonyms for each other.  using any of the names will produce the same behavior.">
  <meta name="twitter:image" content="https://www.carta.tech/images/openmpi-bin-orterun-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/orterun.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="orterun (1) manual" />
  <meta property="og:description" content="Execute serial and parallel jobs in open mpi.  note: mpirun, mpiexec, and orterun are all synonyms for each other.  using any of the names will produce the same behavior." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/openmpi-bin-orterun-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">orterun<small> (1)</small></h1>
        <p class="lead">Execute serial and parallel jobs in open mpi.  note: mpirun, mpiexec, and orterun are all synonyms for each other.  using any of the names will produce the same behavior.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/orterun.1.html">
      <span itemprop="name">orterun: Execute serial and parallel jobs in open mpi.  note: mpirun, mpiexec, and orterun are all synonyms for each other.  using any of the names will produce the same behavior.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/openmpi-bin/">
      <span itemprop="name">openmpi-bin</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/orterun.1.html">
      <span itemprop="name">orterun: Execute serial and parallel jobs in open mpi.  note: mpirun, mpiexec, and orterun are all synonyms for each other.  using any of the names will produce the same behavior.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>Single Process Multiple Data (SPMD) Model:</p><p><strong>mpirun</strong> [ options ] <strong>&lt;program&gt;</strong> [ &lt;args&gt; ]</p><p>Multiple Instruction Multiple Data (MIMD) Model:</p><p><strong>mpirun</strong> [ global_options ]</p>
<pre>
       [ local_options1 ]
</pre>
<p><strong>&lt;program1&gt;</strong> [ &lt;args1&gt; ] :</p>
<pre>
       [ local_options2 ]
</pre>
<p><strong>&lt;program2&gt;</strong> [ &lt;args2&gt; ] :</p>
<pre>
       ... :
       [ local_optionsN ]
</pre>
<p><strong>&lt;programN&gt;</strong> [ &lt;argsN&gt; ]</p><p>Note that in both models, invoking <em>mpirun</em> via an absolute path name is equivalent to specifying the <em>--prefix</em> option with a <em>&lt;dir&gt;</em> value equivalent to the directory where <em>mpirun</em> resides, minus its last subdirectory.  For example:</p>
<pre>
    <strong>%</strong> /usr/local/bin/mpirun ...
</pre>
<p>is equivalent to</p>
<pre>
    <strong>%</strong> mpirun --prefix /usr/local
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">QUICK SUMMARY</h2>
        <div class="sectioncontent">
<p>If you are simply looking for how to run an MPI application, you probably want to use a command line of the following form:</p>
<pre>
    <strong>%</strong> mpirun [ -np X ] [ --hostfile &lt;filename&gt; ]  &lt;program&gt;
</pre>
<p>This will run X copies of <em>&lt;program&gt;</em> in your current run-time environment (if running under a supported resource manager, Open MPI's <em>mpirun</em> will usually automatically use the corresponding resource manager process starter, as opposed to, for example, <em>rsh</em> or <em>ssh</em>, which require the use of a hostfile, or will default to running all X copies on the localhost), scheduling (by default) in a round-robin fashion by CPU slot.  See the rest of this page for more details.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONS</h2>
        <div class="sectioncontent">
<p><em>mpirun</em> will send the name of the directory where it was invoked on the local node to each of the remote nodes, and attempt to change to that directory.  See the "Current Working Directory" section below for further details.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>&lt;program&gt;</strong></p>
  </dt>
  <dd>
    <p>The program executable. This is identified as the first non-recognized argument to mpirun.</p>
  </dd>
  <dt>
    <p><strong>&lt;args&gt;</strong></p>
  </dt>
  <dd>
    <p>Pass these run-time arguments to every new process.  These must always be the last arguments to <em>mpirun</em>. If an app context file is used, <em>&lt;args&gt;</em> will be ignored.</p>
  </dd>
  <dt>
    <p><strong>-h</strong>,<strong> --help</strong></p>
  </dt>
  <dd>
    <p>Display help for this command</p>
  </dd>
  <dt>
    <p><strong>-q</strong>,<strong> --quiet</strong></p>
  </dt>
  <dd>
    <p>Suppress informative messages from orterun during application execution.</p>
  </dd>
  <dt>
    <p><strong>-v</strong>,<strong> --verbose</strong></p>
  </dt>
  <dd>
    <p>Be verbose</p>
  </dd>
  <dt>
    <p><strong>-V</strong>,<strong> --version</strong></p>
  </dt>
  <dd>
    <p>Print version number.  If no other arguments are given, this will also cause orterun to exit.</p>
  </dd>

</dl>
<p>To specify which hosts (nodes) of the cluster to run on:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>-H</strong>,<strong> -host</strong>,<strong> --host </strong>&lt;host1,host2,...,hostN&gt;<strong></strong></p>
  </dt>
  <dd>
    <p>List of hosts on which to invoke processes.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>-hostfile, --hostfile &lt;hostfile&gt; Provide a hostfile to use.</p>
  </dd>
  <dt>
    <p><strong>-machinefile</strong>,<strong> --machinefile </strong>&lt;machinefile&gt;<strong></strong></p>
  </dt>
  <dd>
    <p>Synonym for <em>-hostfile</em>.</p>
  </dd>

</dl>
<p>To specify the number of processes to launch:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>-c</strong>,<strong> -n</strong>,<strong> --n</strong>,<strong> -np </strong>&lt;#&gt;<strong></strong></p>
  </dt>
  <dd>
    <p>Run this many copies of the program on the given nodes.  This option indicates that the specified file is an executable program and not an application context. If no value is provided for the number of copies to execute (i.e., neither the "-np" nor its synonyms are provided on the command line), Open MPI will automatically execute a copy of the program on each process slot (see below for description of a "process slot"). This feature, however, can only be used in the SPMD model and will return an error (without beginning execution of the application) otherwise.</p>
  </dd>
  <dt>
    <p><strong>-npersocket</strong>,<strong> --npersocket &lt;#persocket&gt;</strong></p>
  </dt>
  <dd>
    <p>On each node, launch this many processes times the number of processor sockets on the node. The <em>-npersocket</em> option also turns on the <em>-bind-to-socket</em> option.</p>
  </dd>
  <dt>
    <p><strong>-npernode</strong>,<strong> --npernode &lt;#pernode&gt;</strong></p>
  </dt>
  <dd>
    <p>On each node, launch this many processes.</p>
  </dd>
  <dt>
    <p><strong>-pernode</strong>,<strong> --pernode</strong></p>
  </dt>
  <dd>
    <p>On each node, launch one process -- equivalent to <em>-npernode</em> 1.</p>
  </dd>

</dl>
<p>To map processes to nodes:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>-loadbalance</strong>,<strong> --loadbalance</strong></p>
  </dt>
  <dd>
    <p>Uniform distribution of ranks across all nodes. See more detailed description below.</p>
  </dd>
  <dt>
    <p><strong>-nolocal</strong>,<strong> --nolocal</strong></p>
  </dt>
  <dd>
    <p>Do not run any copies of the launched application on the same node as orterun is running.  This option will override listing the localhost with <strong>--host</strong> or any other host-specifying mechanism.</p>
  </dd>
  <dt>
    <p><strong>-nooversubscribe</strong>,<strong> --nooversubscribe</strong></p>
  </dt>
  <dd>
    <p>Do not oversubscribe any nodes; error (without starting any processes) if the requested number of processes would cause oversubscription. This option implicitly sets "max_slots" equal to the "slots" value for each node.</p>
  </dd>
  <dt>
    <p><strong>-bynode</strong>,<strong> --bynode</strong></p>
  </dt>
  <dd>
    <p>Launch processes one per node, cycling by node in a round-robin fashion.  This spreads processes evenly among nodes and assigns ranks in a round-robin, "by node" manner.</p>
  </dd>

</dl>
<p>For process binding:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>-bycore</strong>,<strong> --bycore</strong></p>
  </dt>
  <dd>
    <p>Associate processes with successive cores if used with one of the <em>-bind-to-*</em> options.</p>
  </dd>
  <dt>
    <p><strong>-bysocket</strong>,<strong> --bysocket</strong></p>
  </dt>
  <dd>
    <p>Associate processes with successive processor sockets if used with one of the <em>-bind-to-*</em> options.</p>
  </dd>
  <dt>
    <p><strong>-cpus-per-proc</strong>,<strong> --cpus-per-proc &lt;#perproc&gt;</strong></p>
  </dt>
  <dd>
    <p>Use the number of cores per process if used with one of the <em>-bind-to-*</em> options.</p>
  </dd>
  <dt>
    <p><strong>-cpus-per-rank</strong>,<strong> --cpus-per-rank &lt;#perrank&gt;</strong></p>
  </dt>
  <dd>
    <p>Alias for <em>-cpus-per-proc</em>.</p>
  </dd>
  <dt>
    <p><strong>-bind-to-core</strong>,<strong> --bind-to-core</strong></p>
  </dt>
  <dd>
    <p>Bind processes to cores.</p>
  </dd>
  <dt>
    <p><strong>-bind-to-socket</strong>,<strong> --bind-to-socket</strong></p>
  </dt>
  <dd>
    <p>Bind processes to processor sockets.</p>
  </dd>
  <dt>
    <p><strong>-bind-to-none</strong>,<strong> --bind-to-none</strong></p>
  </dt>
  <dd>
    <p>Do not bind processes.  (Default.)</p>
  </dd>
  <dt>
    <p><strong>-report-bindings</strong>,<strong> --report-bindings</strong></p>
  </dt>
  <dd>
    <p>Report any bindings for launched processes.</p>
  </dd>
  <dt>
    <p><strong>-slot-list</strong>,<strong> --slot-list &lt;slots&gt;</strong></p>
  </dt>
  <dd>
    <p>List of processor IDs to be used for binding MPI processes. The specified bindings will be applied to all MPI processes. See explanation below for syntax.</p>
  </dd>

</dl>
<p>For rankfiles:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>-rf</strong>,<strong> --rankfile &lt;rankfile&gt;</strong></p>
  </dt>
  <dd>
    <p>Provide a rankfile file.</p>
  </dd>

</dl>
<p>To manage standard I/O:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>-output-filename</strong>,<strong> --output-filename </strong>&lt;filename&gt;<strong></strong></p>
  </dt>
  <dd>
    <p>Redirect the stdout, stderr, and stddiag of all ranks to a rank-unique version of the specified filename. Any directories in the filename will automatically be created. Each output file will consist of filename.rank, where the rank will be left-filled with zero's for correct ordering in listings.</p>
  </dd>
  <dt>
    <p><strong>-stdin</strong>,<strong> --stdin &lt;rank&gt;</strong></p>
  </dt>
  <dd>
    <p>The MPI rank that is to receive stdin. The default is to forward stdin to rank=0, but this option can be used to forward stdin to any rank. It is also acceptable to specify <em>none</em>, indicating that no ranks are to receive stdin.</p>
  </dd>
  <dt>
    <p><strong>-tag-output</strong>,<strong> --tag-output</strong></p>
  </dt>
  <dd>
    <p>Tag each line of output to stdout, stderr, and stddiag with <strong>[jobid, rank]&lt;stdxxx&gt;</strong> indicating the process jobid and rank that generated the output, and the channel which generated it.</p>
  </dd>
  <dt>
    <p><strong>-timestamp-output</strong>,<strong> --timestamp-output</strong></p>
  </dt>
  <dd>
    <p>Timestamp each line of output to stdout, stderr, and stddiag.</p>
  </dd>
  <dt>
    <p><strong>-xml</strong>,<strong> --xml</strong></p>
  </dt>
  <dd>
    <p>Provide all output to stdout, stderr, and stddiag in an xml format.</p>
  </dd>
  <dt>
    <p><strong>-xterm</strong>,<strong> --xterm </strong>&lt;ranks&gt;<strong></strong></p>
  </dt>
  <dd>
    <p>Display the specified ranks in separate xterm windows. The ranks are specified as a comma-separated list of ranges, with a -1 indicating all. A separate window will be created for each specified rank. <strong>Note:</strong> xterm will normally terminate the window upon termination of the process running within it. However, by adding a "!" to the end of the list of specified ranks, the proper options will be provided to ensure that xterm keeps the window open <em>after</em> the process terminates, thus allowing you to see the process' output. Each xterm window will subsequently need to be manually closed. <strong>Note:</strong> In some environments, xterm may require that the executable be in the user's path, or be specified in absolute or relative terms. Thus, it may be necessary to specify a local executable as "./foo" instead of just "foo". If xterm fails to find the executable, mpirun will hang, but still respond correctly to a ctrl-c. If this happens, please check that the executable is being specified correctly and try again.</p>
  </dd>

</dl>
<p>To manage files and runtime environment:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>-path</strong>,<strong> --path </strong>&lt;path&gt;<strong></strong></p>
  </dt>
  <dd>
    <p>&lt;path&gt; that will be used when attempting to locate the requested executables.  This is used prior to using the local PATH setting.</p>
  </dd>
  <dt>
    <p><strong>--prefix </strong>&lt;dir&gt;<strong></strong></p>
  </dt>
  <dd>
    <p>Prefix directory that will be used to set the <em>PATH</em> and <em>LD_LIBRARY_PATH</em> on the remote node before invoking Open MPI or the target process.  See the "Remote Execution" section, below.</p>
  </dd>
  <dt>
    <p><strong>--preload-binary</strong></p>
  </dt>
  <dd>
    <p>Copy the specified executable(s) to remote machines prior to starting remote processes. The executables will be copied to the Open MPI session directory and will be deleted upon completion of the job.</p>
  </dd>
  <dt>
    <p><strong>--preload-files &lt;files&gt;</strong></p>
  </dt>
  <dd>
    <p>Preload the comma separated list of files to the current working directory of the remote machines where processes will be launched prior to starting those processes.</p>
  </dd>
  <dt>
    <p><strong>--preload-files-dest-dir &lt;path&gt;</strong></p>
  </dt>
  <dd>
    <p>The destination directory to be used for preload-files, if other than the current working directory. By default, the absolute and relative paths provided by --preload-files are used.</p>
  </dd>
  <dt>
    <p><strong>--tmpdir </strong>&lt;dir&gt;<strong></strong></p>
  </dt>
  <dd>
    <p>Set the root for the session directory tree for mpirun only.</p>
  </dd>
  <dt>
    <p><strong>-wd </strong>&lt;dir&gt;<strong></strong></p>
  </dt>
  <dd>
    <p>Synonym for <em>-wdir</em>.</p>
  </dd>
  <dt>
    <p><strong>-wdir </strong>&lt;dir&gt;<strong></strong></p>
  </dt>
  <dd>
    <p>Change to the directory &lt;dir&gt; before the user's program executes. See the "Current Working Directory" section for notes on relative paths. <strong>Note:</strong> If the <em>-wdir</em> option appears both on the command line and in an application context, the context will take precedence over the command line. Thus, if the path to the desired wdir is different on the backend nodes, then it must be specified as an absolute path that is correct for the backend node.</p>
  </dd>
  <dt>
    <p><strong>-x </strong>&lt;env&gt;<strong></strong></p>
  </dt>
  <dd>
    <p>Export the specified environment variables to the remote nodes before executing the program.  Only one environment variable can be specified per <em>-x</em> option.  Existing environment variables can be specified or new variable names specified with corresponding values.  For example:</p>
<pre>
    <strong>%</strong> mpirun -x DISPLAY -x OFILE=/tmp/out ...
</pre>
<p>The parser for the <em>-x</em> option is not very sophisticated; it does not even understand quoted values.  Users are advised to set variables in the environment, and then use <em>-x</em> to export (not define) them.</p>
  </dd>

</dl>
<p>Setting MCA parameters:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>-gmca</strong>,<strong> --gmca </strong>&lt;key&gt; &lt;value&gt;<strong></strong></p>
  </dt>
  <dd>
    <p>Pass global MCA parameters that are applicable to all contexts. <em>&lt;key&gt;</em> is the parameter name; <em>&lt;value&gt;</em> is the parameter value.</p>
  </dd>
  <dt>
    <p><strong>-mca</strong>,<strong> --mca &lt;key&gt; &lt;value&gt;</strong></p>
  </dt>
  <dd>
    <p>Send arguments to various MCA modules.  See the "MCA" section, below.</p>
  </dd>

</dl>
<p>For debugging:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>-debug</strong>,<strong> --debug</strong></p>
  </dt>
  <dd>
    <p>Invoke the user-level debugger indicated by the <em>orte_base_user_debugger</em> MCA parameter.</p>
  </dd>
  <dt>
    <p><strong>-debugger</strong>,<strong> --debugger</strong></p>
  </dt>
  <dd>
    <p>Sequence of debuggers to search for when <em>--debug</em> is used (i.e. a synonym for <em>orte_base_user_debugger</em> MCA parameter).</p>
  </dd>
  <dt>
    <p><strong>-tv</strong>,<strong> --tv</strong></p>
  </dt>
  <dd>
    <p>Launch processes under the TotalView debugger. Deprecated backwards compatibility flag. Synonym for <em>--debug</em>.</p>
  </dd>

</dl>
<p>There are also other options:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>-aborted</strong>,<strong> --aborted </strong>&lt;#&gt;<strong></strong></p>
  </dt>
  <dd>
    <p>Set the maximum number of aborted processes to display.</p>
  </dd>
  <dt>
    <p><strong>--app </strong>&lt;appfile&gt;<strong></strong></p>
  </dt>
  <dd>
    <p>Provide an appfile, ignoring all other command line options.</p>
  </dd>
  <dt>
    <p><strong>-cf</strong>,<strong> --cartofile </strong>&lt;cartofile&gt;<strong></strong></p>
  </dt>
  <dd>
    <p>Provide a cartography file.</p>
  </dd>
  <dt>
    <p><strong>--hetero</strong></p>
  </dt>
  <dd>
    <p>Indicates that multiple app_contexts are being provided that are a mix of 32/64-bit binaries.</p>
  </dd>
  <dt>
    <p><strong>-leave-session-attached</strong>,<strong> --leave-session-attached</strong></p>
  </dt>
  <dd>
    <p>Do not detach OmpiRTE daemons used by this application. This allows error messages from the daemons as well as the underlying environment (e.g., when failing to launch a daemon) to be output.</p>
  </dd>
  <dt>
    <p><strong>-ompi-server</strong>,<strong> --ompi-server &lt;uri or file&gt;</strong></p>
  </dt>
  <dd>
    <p>Specify the URI of the Open MPI server (or the mpirun to be used as the server) , the name of the file (specified as file:filename) that contains that info, or the PID (specified as pid:#) of the mpirun to be used as  the server. The Open MPI server is used to support multi-application data exchange via the MPI-2 MPI_Publish_name and MPI_Lookup_name functions.</p>
  </dd>
  <dt>
    <p><strong>-report-pid</strong>,<strong> --report-pid &lt;channel&gt;</strong></p>
  </dt>
  <dd>
    <p>Print out mpirun's PID during startup. The channel must be either a '-' to indi cate that the pid is to be output to stdout, a '+' to indicate that the pid is to be outp ut to stderr, or a filename to which the pid is to be written.</p>
  </dd>
  <dt>
    <p><strong>-report-uri</strong>,<strong> --report-uri &lt;channel&gt;</strong></p>
  </dt>
  <dd>
    <p>Print out mpirun's URI during startup. The channel must be either a '-' to indi cate that the URI is to be output to stdout, a '+' to indicate that the URI is to be outp ut to stderr, or a filename to which the URI is to be written.</p>
  </dd>
  <dt>
    <p><strong>-wait-for-server</strong>,<strong> --wait-for-server</strong></p>
  </dt>
  <dd>
    <p>Pause mpirun before launching the job until ompi-server is detected. This is useful in scripts where ompi-server may be started in the background, followed immediately by an <em>mpirun</em> command that wishes to connect to it. Mpirun will pause until either the specified ompi-server is contacted or the server-wait-time is exceeded.</p>
  </dd>
  <dt>
    <p><strong>-server-wait-time</strong>,<strong> --server-wait-time &lt;secs&gt;</strong></p>
  </dt>
  <dd>
    <p>The max amount of time (in seconds) mpirun should wait for the ompi-server to start. The default is 10 seconds.</p>
  </dd>

</dl>
<p>The following options are useful for developers; they are not generally useful to most ORTE and/or MPI users:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>-d</strong>,<strong> --debug-devel</strong></p>
  </dt>
  <dd>
    <p>Enable debugging of the OmpiRTE (the run-time layer in Open MPI). This is not generally useful for most users.</p>
  </dd>
  <dt>
    <p><strong>--debug-daemons</strong></p>
  </dt>
  <dd>
    <p>Enable debugging of any OmpiRTE daemons used by this application.</p>
  </dd>
  <dt>
    <p><strong>--debug-daemons-file</strong></p>
  </dt>
  <dd>
    <p>Enable debugging of any OmpiRTE daemons used by this application, storing output in files.</p>
  </dd>
  <dt>
    <p><strong>-launch-agent</strong>,<strong> --launch-agent</strong></p>
  </dt>
  <dd>
    <p>Name of the executable that is to be used to start processes on the remote nodes. The default is "orted". This option can be used to test new daemon concepts, or to pass options back to the daemons without having mpirun itself see them. For example, specifying a launch agent of orted -mca odls_base_verbose 5 allows the developer to ask the orted for debugging output without clutter from mpirun itself.</p>
  </dd>
  <dt>
    <p><strong>--noprefix</strong></p>
  </dt>
  <dd>
    <p>Disable the automatic --prefix behavior</p>
  </dd>

</dl>
<p>There may be other options listed with <em>mpirun --help</em>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>One invocation of <em>mpirun</em> starts an MPI application running under Open MPI. If the application is single process multiple data (SPMD), the application can be specified on the <em>mpirun</em> command line.</p><p>If the application is multiple instruction multiple data (MIMD), comprising of multiple programs, the set of programs and argument can be specified in one of two ways: Extended Command Line Arguments, and Application Context.</p><p>An application context describes the MIMD program set including all arguments in a separate file. This file essentially contains multiple <em>mpirun</em> command lines, less the command name itself.  The ability to specify different options for different instantiations of a program is another reason to use an application context.</p><p>Extended command line arguments allow for the description of the application layout on the command line using colons (<em>:</em>) to separate the specification of programs and arguments. Some options are globally set across all specified programs (e.g. --hostfile), while others are specific to a single program (e.g. -np).</p><h3>Specifying Host Nodes</h3>
<p>Host nodes can be identified on the <em>mpirun</em> command line with the <em>-host</em> option or in a hostfile.</p><p>For example,</p>
<dl class='dl-vertical'>
  <dt>
    <p>mpirun -H aa,aa,bb ./a.out</p>
  </dt>
  <dd>
    <p>launches two processes on node aa and one on bb.</p>
  </dd>

</dl>
<p>Or, consider the hostfile</p>
<pre>
   <strong>%</strong> cat myhostfile
   aa slots=2
   bb slots=2
   cc slots=2
</pre>
<p>Here, we list both the host names (aa, bb, and cc) but also how many "slots" there are for each.  Slots indicate how many processes can potentially execute on a node.  For best performance, the number of slots may be chosen to be the number of cores on the node or the number of processor sockets.  If the hostfile does not provide slots information, a default of 1 is assumed. When running under resource managers (e.g., SLURM, Torque, etc.), Open MPI will obtain both the hostnames and the number of slots directly from the resource manger.</p>
<dl class='dl-vertical'>
  <dt>
    <p>mpirun -hostfile myhostfile ./a.out</p>
  </dt>
  <dd>
    <p>will launch two processes on each of the three nodes.</p>
  </dd>
  <dt>
    <p>mpirun -hostfile myhostfile -host aa ./a.out</p>
  </dt>
  <dd>
    <p>will launch two processes, both on node aa.</p>
  </dd>
  <dt>
    <p>mpirun -hostfile myhostfile -host dd ./a.out</p>
  </dt>
  <dd>
    <p>will find no hosts to run on and abort with an error. That is, the specified host dd is not in the specified hostfile.</p>
  </dd>

</dl>

<h3>Specifying Number of Processes</h3>
<p>As we have just seen, the number of processes to run can be set using the hostfile.  Other mechanisms exist.</p><p>The number of processes launched can be specified as a multiple of the number of nodes or processor sockets available.  For example,</p>
<dl class='dl-vertical'>
  <dt>
    <p>mpirun -H aa,bb -npersocket 2 ./a.out</p>
  </dt>
  <dd>
    <p>launches processes 0-3 on node aa and process 4-7 on node bb, where aa and bb are both dual-socket nodes. The <em>-npersocket</em> option also turns on the <em>-bind-to-socket</em> option, which is discussed in a later section.</p>
  </dd>
  <dt>
    <p>mpirun -H aa,bb -npernode 2 ./a.out</p>
  </dt>
  <dd>
    <p>launches processes 0-1 on node aa and processes 2-3 on node bb.</p>
  </dd>
  <dt>
    <p>mpirun -H aa,bb -npernode 1 ./a.out</p>
  </dt>
  <dd>
    <p>launches one process per host node.</p>
  </dd>
  <dt>
    <p>mpirun -H aa,bb -pernode ./a.out</p>
  </dt>
  <dd>
    <p>is the same as <em>-npernode</em> 1.</p>
  </dd>

</dl>
<p>Another alternative is to specify the number of processes with the <em>-np</em> option.  Consider now the hostfile</p>
<pre>
   <strong>%</strong> cat myhostfile
   aa slots=4
   bb slots=4
   cc slots=4
</pre>
<p>Now,</p>
<dl class='dl-vertical'>
  <dt>
    <p>mpirun -hostfile myhostfile -np 6 ./a.out</p>
  </dt>
  <dd>
    <p>will launch ranks 0-3 on node aa and ranks 4-5 on node bb.  The remaining slots in the hostfile will not be used since the <em>-np</em> option indicated that only 6 processes should be launched.</p>
  </dd>

</dl>

<h3>Mapping Processes to Nodes</h3>
<p>The examples above illustrate the default mapping of process ranks to nodes.  This mapping can also be controlled with various <em>mpirun</em> options.  Here, we consider the same hostfile as above with <em>-np</em> 6 again:</p>
<pre>
                          node aa      node bb      node cc
</pre>

<pre>
  mpirun                  0 1 2 3      4 5
</pre>

<pre>
  mpirun -loadbalance     0 1          2 3          4 5
</pre>

<pre>
  mpirun -bynode          0 3          1 4          2 5
</pre>

<pre>
  mpirun -nolocal                      0 1 2 3      4 5
</pre>
<p>The <em>-loadbalance</em> option tries to spread processes out fairly among the nodes.</p><p>The <em>-bynode</em> option does likewise but numbers the processes in "by node" in a round-robin fashion.</p><p>The <em>-nolocal</em> option prevents any processes from being mapped onto the local host (in this case node aa).  While <em>mpirun</em> typically consumes few system resources, <em>-nolocal</em> can be helpful for launching very large jobs where <em>mpirun</em> may actually need to use noticeable amounts of memory and/or processing time.</p><p>Just as <em>-np</em> can specify fewer processes than there are slots, it can also oversubscribe the slots.  For example, with the same hostfile:</p>
<dl class='dl-vertical'>
  <dt>
    <p>mpirun -hostfile myhostfile -np 14 ./a.out</p>
  </dt>
  <dd>
    <p>will launch processes 0-3 on node aa, 4-7 on bb, and 8-11 on cc.  It will then add the remaining two processes to whichever nodes it chooses.</p>
  </dd>

</dl>
<p>One can also specify limits to oversubscription.  For example, with the same hostfile:</p>
<dl class='dl-vertical'>
  <dt>
    <p>mpirun -hostfile myhostfile -np 14 -nooversubscribe ./a.out</p>
  </dt>
  <dd>
    <p>will produce an error since <em>-nooversubscribe</em> prevents oversubscription.</p>
  </dd>

</dl>
<p>Limits to oversubscription can also be specified in the hostfile itself:  % cat myhostfile  aa slots=4 max_slots=4  bb         max_slots=4  cc slots=4</p><p>The <em>max_slots</em> field specifies such a limit.  When it does, the <em>slots</em> value defaults to the limit.  Now:</p>
<dl class='dl-vertical'>
  <dt>
    <p>mpirun -hostfile myhostfile -np 14 ./a.out</p>
  </dt>
  <dd>
    <p>causes the first 12 processes to be launched as before, but the remaining two processes will be forced onto node cc.  The other two nodes are protected by the hostfile against oversubscription by this job.</p>
  </dd>

</dl>
<p>Using the <em>--nooversubscribe</em> option can be helpful since Open MPI currently does not get "max_slots" values from the resource manager.</p><p>Of course, <em>-np</em> can also be used with the <em>-H</em> or <em>-host</em> option.  For example,</p>
<dl class='dl-vertical'>
  <dt>
    <p>mpirun -H aa,bb -np 8 ./a.out</p>
  </dt>
  <dd>
    <p>launches 8 processes.  Since only two hosts are specified, after the first two processes are mapped, one to aa and one to bb, the remaining processes oversubscribe the specified hosts.</p>
  </dd>

</dl>
<p>And here is a MIMD example:</p>
<dl class='dl-vertical'>
  <dt>
    <p>mpirun -H aa -np 1 hostname : -H bb,cc -np 2 uptime</p>
  </dt>
  <dd>
    <p>will launch process 0 running <em>hostname</em> on node aa and processes 1 and 2 each running <em>uptime</em> on nodes bb and cc, respectively.</p>
  </dd>

</dl>

<h3>Process Binding</h3>
<p>Processes may be bound to specific resources on a node.  This can improve performance if the operating system is placing processes suboptimally.  For example, it might oversubscribe some multi-core processor sockets, leaving other sockets idle;  this can lead processes to contend unnecessarily for common resources.  Or, it might spread processes out too widely;  this can be suboptimal if application performance is sensitive to interprocess communication costs.  Binding can also keep the operating system from migrating processes excessively, regardless of how optimally those processes were placed to begin with.</p><p>To bind processes, one must first associate them with the resources on which they should run.  For example, the <em>-bycore</em> option associates the processes on a node with successive cores.  Or, <em>-bysocket</em> associates the processes with successive processor sockets, cycling through the sockets in a round-robin fashion if necessary. And <em>-cpus-per-proc</em> indicates how many cores to bind per process.</p><p>But, such association is meaningless unless the processes are actually bound to those resources.  The binding option specifies the granularity of binding -- say, with <em>-bind-to-core</em> or <em>-bind-to-socket</em>. One can also turn binding off with <em>-bind-to-none</em>, which is typically the default.</p><p>Finally, <em>-report-bindings</em> can be used to report bindings.</p><p>As an example, consider a node with two processor sockets, each comprising four cores.  We run <em>mpirun</em> with <em>-np 4 -report-bindings</em> and the following additional options:</p><p> % mpirun ... -bycore -bind-to-core  [...] ... binding child [...,0] to cpus 0001  [...] ... binding child [...,1] to cpus 0002  [...] ... binding child [...,2] to cpus 0004  [...] ... binding child [...,3] to cpus 0008</p><p> % mpirun ... -bysocket -bind-to-socket  [...] ... binding child [...,0] to socket 0 cpus 000f  [...] ... binding child [...,1] to socket 1 cpus 00f0  [...] ... binding child [...,2] to socket 0 cpus 000f  [...] ... binding child [...,3] to socket 1 cpus 00f0</p><p> % mpirun ... -cpus-per-proc 2 -bind-to-core  [...] ... binding child [...,0] to cpus 0003  [...] ... binding child [...,1] to cpus 000c  [...] ... binding child [...,2] to cpus 0030  [...] ... binding child [...,3] to cpus 00c0</p><p> % mpirun ... -bind-to-none</p><p>Here, <em>-report-bindings</em> shows the binding of each process as a mask. In the first case, the processes bind to successive cores as indicated by the masks 0001, 0002, 0004, and 0008.  In the second case, processes bind to all cores on successive sockets as indicated by the masks 000f and 00f0. The processes cycle through the processor sockets in a round-robin fashion as many times as are needed.  In the third case, the masks show us that 2 cores have been bind per process.  In the fourth case, binding is turned off and no bindings are reported.</p><p>Open MPI's support for process binding depends on the underlying operating system.  Therefore, processing binding may not be available on every system.</p><p>Process binding can also be set with MCA parameters. Their usage is less convenient than that of <em>mpirun</em> options. On the other hand, MCA parameters can be set not only on the <em>mpirun</em> command line, but alternatively in a system or user mca-params.conf file or as environment variables, as described in the MCA section below. The correspondences are:</p>
<pre>
  mpirun option          MCA parameter key           value
</pre>

<pre>
  -bycore                rmaps_base_schedule_policy  core
  -bysocket              rmaps_base_schedule_policy  socket
  -bind-to-core          orte_process_binding        core
  -bind-to-socket        orte_process_binding        socket
  -bind-to-none          orte_process_binding        none
</pre>
<p>The <em>orte_process_binding</em> value can also take on the <em>:if-avail</em> attribute.  This attribute means that processes will be bound only if this is supported on the underlying operating system.  Without the attribute, if there is no such support, the binding request results in an error. For example, you could have</p>
<pre>
  % cat $HOME/.openmpi/mca-params.conf
  rmaps_base_schedule_policy = socket
  orte_process_binding       = socket:if-avail
</pre>

<h3>Rankfiles</h3>
<p>Rankfiles provide a means for specifying detailed information about how process ranks should be mapped to nodes and how they should be bound. Consider the following:</p>
<pre>
    cat myrankfile
    rank 0=aa slot=1:0-2
    rank 1=bb slot=0:0,1
    rank 2=cc slot=1-2
    mpirun -H aa,bb,cc,dd -rf myrankfile ./a.out
</pre>
<p>So that</p>
<pre>
  Rank 0 runs on node aa, bound to socket 1, cores 0-2.
  Rank 1 runs on node bb, bound to socket 0, cores 0 and 1.
  Rank 2 runs on node cc, bound to cores 1 and 2.
</pre>
<p>Note that all slot locations are to be specified as <em>physical</em> indexes.  You can use tools such as HWLOC's "lstopo -v" to find the physical indexes of socket and cores.</p>
<h3>Application Context or Executable Program?</h3>
<p>To distinguish the two different forms, <em>mpirun</em> looks on the command line for <em>--app</em> option.  If it is specified, then the file named on the command line is assumed to be an application context.  If it is not specified, then the file is assumed to be an executable program.</p>
<h3>Locating Files</h3>
<p>If no relative or absolute path is specified for a file, Open MPI will first look for files by searching the directories specified by the <em>--path</em> option.  If there is no <em>--path</em> option set or if the file is not found at the <em>--path</em> location, then Open MPI will search the user's PATH environment variable as defined on the source node(s).</p><p>If a relative directory is specified, it must be relative to the initial working directory determined by the specific starter used. For example when using the rsh or ssh starters, the initial directory is $HOME by default. Other starters may set the initial directory to the current working directory from the invocation of <em>mpirun</em>.</p>
<h3>Current Working Directory</h3>
<p>The <em>-wdir</em> mpirun option (and its synonym, <em>-wd</em>) allows the user to change to an arbitrary directory before the program is invoked.  It can also be used in application context files to specify working directories on specific nodes and/or for specific applications.</p><p>If the <em>-wdir</em> option appears both in a context file and on the command line, the context file directory will override the command line value.</p><p>If the <em>-wdir</em> option is specified, Open MPI will attempt to change to the specified directory on all of the remote nodes. If this fails, <em>mpirun</em> will abort.</p><p>If the <em>-wdir</em> option is <strong>not</strong> specified, Open MPI will send the directory name where <em>mpirun</em> was invoked to each of the remote nodes. The remote nodes will try to change to that directory. If they are unable (e.g., if the directory does not exist on that node), then Open MPI will use the default directory determined by the starter.</p><p>All directory changing occurs before the user's program is invoked; it does not wait until <em>MPI_INIT</em> is called.</p>
<h3>Standard I/O</h3>
<p>Open MPI directs UNIX standard input to /dev/null on all processes except the MPI_COMM_WORLD rank 0 process. The MPI_COMM_WORLD rank 0 process inherits standard input from <em>mpirun</em>. <strong>Note:</strong> The node that invoked <em>mpirun</em> need not be the same as the node where the MPI_COMM_WORLD rank 0 process resides. Open MPI handles the redirection of <em>mpirun</em>'s standard input to the rank 0 process.</p><p>Open MPI directs UNIX standard output and error from remote nodes to the node that invoked <em>mpirun</em> and prints it on the standard output/error of <em>mpirun</em>. Local processes inherit the standard output/error of <em>mpirun</em> and transfer to it directly.</p><p>Thus it is possible to redirect standard I/O for Open MPI applications by using the typical shell redirection procedure on <em>mpirun</em>.</p>
<pre>
      <strong>%</strong> mpirun -np 2 my_app &lt; my_input &gt; my_output
</pre>
<p>Note that in this example <em>only</em> the MPI_COMM_WORLD rank 0 process will receive the stream from <em>my_input</em> on stdin.  The stdin on all the other nodes will be tied to /dev/null.  However, the stdout from all nodes will be collected into the <em>my_output</em> file.</p>
<h3>Signal Propagation</h3>
<p>When orterun receives a SIGTERM and SIGINT, it will attempt to kill the entire job by sending all processes in the job a SIGTERM, waiting a small number of seconds, then sending all processes in the job a SIGKILL.</p><p>SIGUSR1 and SIGUSR2 signals received by orterun are propagated to all processes in the job.</p><p>One can turn on forwarding of SIGSTOP and SIGCONT to the program executed by mpirun by setting the MCA parameter orte_forward_job_control to 1. A SIGTSTOP signal to mpirun will then cause a SIGSTOP signal to be sent to all of the programs started by mpirun and likewise a SIGCONT signal to mpirun will cause a SIGCONT sent.</p><p>Other signals are not currently propagated by orterun.</p>
<h3>Process Termination / Signal Handling</h3>
<p>During the run of an MPI application, if any rank dies abnormally (either exiting before invoking <em>MPI_FINALIZE</em>, or dying as the result of a signal), <em>mpirun</em> will print out an error message and kill the rest of the MPI application.</p><p>User signal handlers should probably avoid trying to cleanup MPI state (Open MPI is currently not async-signal-safe; see <a href="../man3/MPI_Init_thread.3.html"><strong>MPI_Init_thread</strong>(3)</a> for details about <em>MPI_THREAD_MULTIPLE</em> and thread safety).  For example, if a segmentation fault occurs in <em>MPI_SEND</em> (perhaps because a bad buffer was passed in) and a user signal handler is invoked, if this user handler attempts to invoke <em>MPI_FINALIZE</em>, Bad Things could happen since Open MPI was already "in" MPI when the error occurred.  Since <em>mpirun</em> will notice that the process died due to a signal, it is probably not necessary (and safest) for the user to only clean up non-MPI state.</p>
<h3>Process Environment</h3>
<p>Processes in the MPI application inherit their environment from the Open RTE daemon upon the node on which they are running.  The environment is typically inherited from the user's shell.  On remote nodes, the exact environment is determined by the boot MCA module used.  The <em>rsh</em> launch module, for example, uses either <em>rsh</em>/<em>ssh</em> to launch the Open RTE daemon on remote nodes, and typically executes one or more of the user's shell-setup files before launching the Open RTE daemon.  When running dynamically linked applications which require the <em>LD_LIBRARY_PATH</em> environment variable to be set, care must be taken to ensure that it is correctly set when booting Open MPI.</p><p>See the "Remote Execution" section for more details.</p>
<h3>Remote Execution</h3>
<p>Open MPI requires that the <em>PATH</em> environment variable be set to find executables on remote nodes (this is typically only necessary in <em>rsh</em>- or <em>ssh</em>-based environments -- batch/scheduled environments typically copy the current environment to the execution of remote jobs, so if the current environment has <em>PATH</em> and/or <em>LD_LIBRARY_PATH</em> set properly, the remote nodes will also have it set properly).  If Open MPI was compiled with shared library support, it may also be necessary to have the <em>LD_LIBRARY_PATH</em> environment variable set on remote nodes as well (especially to find the shared libraries required to run user MPI applications).</p><p>However, it is not always desirable or possible to edit shell startup files to set <em>PATH</em> and/or <em>LD_LIBRARY_PATH</em>.  The <em>--prefix</em> option is provided for some simple configurations where this is not possible.</p><p>The <em>--prefix</em> option takes a single argument: the base directory on the remote node where Open MPI is installed.  Open MPI will use this directory to set the remote <em>PATH</em> and <em>LD_LIBRARY_PATH</em> before executing any Open MPI or user applications.  This allows running Open MPI jobs without having pre-configured the <em>PATH</em> and <em>LD_LIBRARY_PATH</em> on the remote nodes.</p><p>Open MPI adds the basename of the current node's "bindir" (the directory where Open MPI's executables are installed) to the prefix and uses that to set the <em>PATH</em> on the remote node.  Similarly, Open MPI adds the basename of the current node's "libdir" (the directory where Open MPI's libraries are installed) to the prefix and uses that to set the <em>LD_LIBRARY_PATH</em> on the remote node.  For example:</p>
<dl class='dl-vertical'>
  <dt>
    <p>Local bindir:</p>
  </dt>
  <dd>
    <p>/local/node/directory/bin</p>
  </dd>
  <dt>
    <p>Local libdir:</p>
  </dt>
  <dd>
    <p>/local/node/directory/lib64</p>
  </dd>

</dl>
<p>If the following command line is used:</p>
<pre>
    <strong>%</strong> mpirun --prefix /remote/node/directory
</pre>
<p>Open MPI will add "/remote/node/directory/bin" to the <em>PATH</em> and "/remote/node/directory/lib64" to the <strong>D_LIBRARY_PATH</strong> on the remote node before attempting to execute anything.</p><p>The <em>--prefix</em> option is not sufficient if the installation paths on the remote node are different than the local node (e.g., if "/lib" is used on the local node, but "/lib64" is used on the remote node), or if the installation paths are something other than a subdirectory under a common prefix.</p><p>Note that executing <em>mpirun</em> via an absolute pathname is equivalent to specifying <em>--prefix</em> without the last subdirectory in the absolute pathname to <em>mpirun</em>.  For example:</p>
<pre>
    <strong>%</strong> /usr/local/bin/mpirun ...
</pre>
<p>is equivalent to</p>
<pre>
    <strong>%</strong> mpirun --prefix /usr/local
</pre>

<h3>Exported Environment Variables</h3>
<p>All environment variables that are named in the form OMPI_* will automatically be exported to new processes on the local and remote nodes. The <em>-x</em> option to <em>mpirun</em> can be used to export specific environment variables to the new processes.  While the syntax of the <em>-x</em> option allows the definition of new variables, note that the parser for this option is currently not very sophisticated - it does not even understand quoted values.  Users are advised to set variables in the environment and use <em>-x</em> to export them; not to define them.</p>
<h3>Setting MCA Parameters</h3>
<p>The <em>-mca</em> switch allows the passing of parameters to various MCA (Modular Component Architecture) modules. MCA modules have direct impact on MPI programs because they allow tunable parameters to be set at run time (such as which BTL communication device driver to use, what parameters to pass to that BTL, etc.).</p><p>The <em>-mca</em> switch takes two arguments: <em>&lt;key&gt;</em> and <em>&lt;value&gt;</em>. The <em>&lt;key&gt;</em> argument generally specifies which MCA module will receive the value. For example, the <em>&lt;key&gt;</em> "btl" is used to select which BTL to be used for transporting MPI messages.  The <em>&lt;value&gt;</em> argument is the value that is passed. For example:</p>
<dl class='dl-vertical'>
  <dt>
    <p>mpirun -mca btl tcp,self -np 1 foo</p>
  </dt>
  <dd>
    <p>Tells Open MPI to use the "tcp" and "self" BTLs, and to run a single copy of "foo" an allocated node.</p>
  </dd>
  <dt>
    <p>mpirun -mca btl self -np 1 foo</p>
  </dt>
  <dd>
    <p>Tells Open MPI to use the "self" BTL, and to run a single copy of "foo" an allocated node.</p>
  </dd>

</dl>
<p>The <em>-mca</em> switch can be used multiple times to specify different <em>&lt;key&gt;</em> and/or <em>&lt;value&gt;</em> arguments.  If the same <em>&lt;key&gt;</em> is specified more than once, the <em>&lt;value&gt;</em>s are concatenated with a comma (",") separating them.</p><p>Note that the <em>-mca</em> switch is simply a shortcut for setting environment variables. The same effect may be accomplished by setting corresponding environment variables before running <em>mpirun</em>. The form of the environment variables that Open MPI sets is:</p>
<pre>
      OMPI_MCA_&lt;key&gt;=&lt;value&gt;
</pre>
<p>Thus, the <em>-mca</em> switch overrides any previously set environment variables.  The <em>-mca</em> settings similarly override MCA parameters set in the $OPAL_PREFIX/etc/openmpi-mca-params.conf or $HOME/.openmpi/mca-params.conf file.</p><p>Unknown <em>&lt;key&gt;</em> arguments are still set as environment variable -- they are not checked (by <em>mpirun</em>) for correctness. Illegal or incorrect <em>&lt;value&gt;</em> arguments may or may not be reported -- it depends on the specific MCA module.</p><p>To find the available component types under the MCA architecture, or to find the available parameters for a specific component, use the <em>ompi_info</em> command. See the <a href="../man1/ompi_info.1.html"><strong>ompi_info</strong>(1)</a></em> man page for detailed information on the command.</p>
<h3>Exit status</h3>
<p>There is no standard definition for what <em>mpirun</em> should return as an exit status. After considerable discussion, we settled on the following method for assigning the <em>mpirun</em> exit status (note: in the following description, the "primary" job is the initial application started by mpirun - all jobs that are spawned by that job are designated "secondary" jobs):</p>
<dl class='dl-vertical'>
  <dt>
    \[bu]
  </dt>
  <dd>
    <p>if all processes in the primary job normally terminate with exit status 0, we return 0</p>
  </dd>
  <dt>
    \[bu]
  </dt>
  <dd>
    <p>if one or more processes in the primary job normally terminate with non-zero exit status, we return the exit status of the lowest rank to have a non-zero status</p>
  </dd>
  <dt>
    \[bu]
  </dt>
  <dd>
    <p>if all processes in the primary job normally terminate with exit status 0, and one or more processes in a secondary job normally terminate with non-zero exit status, we (a) return the exit status of the lowest rank in the lowest jobid to have a non-zero status, and (b) output a message summarizing the exit status of the primary and all secondary jobs.</p>
  </dd>
  <dt>
    \[bu]
  </dt>
  <dd>
    <p>if the cmd line option --report-child-jobs-separately is set, we will return -only- the exit status of the primary job. Any non-zero exit status in secondary jobs will be reported solely in a summary print statement.</p>
  </dd>

</dl>
<p>By default, OMPI records and notes that MPI processes exited with non-zero termination status. This is generally not considered an "abnormal termination" - i.e., OMPI will not abort an MPI job if one or more processes return a non-zero status. Instead, the default behavior simply reports the number of processes terminating with non-zero status upon completion of the job.</p><p>However, in some cases it can be desirable to have the job abort when any process terminates with non-zero status. For example, a non-MPI job might detect a bad result from a calculation and want to abort, but doesn't want to generate a core file. Or an MPI job might continue past a call to MPI_Finalize, but indicate that all processes should abort due to some post-MPI result.</p><p>It is not anticipated that this situation will occur frequently. However, in the interest of serving the broader community, OMPI now has a means for allowing users to direct that jobs be aborted upon any process exiting with non-zero status. Setting the MCA parameter "orte_abort_on_non_zero_status" to 1 will cause OMPI to abort all processes once any process  exits with non-zero status.</p><p>Terminations caused in this manner will be reported on the console as an "abnormal termination", with the first process to so exit identified along with its exit status.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>Be sure also to see the examples throughout the sections above.</p>
<dl class='dl-vertical'>
  <dt>
    <p>mpirun -np 4 -mca btl ib,tcp,self prog1</p>
  </dt>
  <dd>
    <p>Run 4 copies of prog1 using the "ib", "tcp", and "self" BTL's for the transport of MPI messages.</p>
  </dd>
  <dt>
    <p>mpirun -np 4 -mca btl tcp,sm,self</p>
  </dt>
  <dd>
    <p>--mca btl_tcp_if_include eth0 prog1</p><p>Run 4 copies of prog1 using the "tcp", "sm" and "self" BTLs for the transport of MPI messages, with TCP using only the eth0 interface to communicate.  Note that other BTLs have similar if_include MCA parameters.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p><em>mpirun</em> returns 0 if all ranks started by <em>mpirun</em> exit after calling MPI_FINALIZE.  A non-zero value is returned if an internal error occurred in mpirun, or one or more ranks exited before calling MPI_FINALIZE.  If an internal error occurred in mpirun, the corresponding error code is returned. In the event that one or more ranks exit before calling MPI_FINALIZE, the return value of the rank of the process that <em>mpirun</em> first notices died before calling MPI_FINALIZE will be returned.  Note that, in general, this will be the first rank that died but is not guaranteed to be so.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO orterun&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man3/MPI_Init_thread.3.html"><strong>MPI_Init_thread</strong>(3)</a></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="orted.1.html"><span aria-hidden="true">&larr;</span> orted.1: Start an open rte user-level daemon</a></li>
   <li class="next"><a href="osage.1.html">osage.1: Filter for drawing clustered graphs <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

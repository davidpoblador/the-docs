<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>mspdebug: Debugging tool for msp430 mcus</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Debugging tool for msp430 mcus">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="mspdebug (1) manual">
  <meta name="twitter:description" content="Debugging tool for msp430 mcus">
  <meta name="twitter:image" content="https://www.carta.tech/images/mspdebug-mspdebug-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/mspdebug.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="mspdebug (1) manual" />
  <meta property="og:description" content="Debugging tool for msp430 mcus" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/mspdebug-mspdebug-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">mspdebug<small> (1)</small></h1>
        <p class="lead">Debugging tool for msp430 mcus</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/mspdebug.1.html">
      <span itemprop="name">mspdebug: Debugging tool for msp430 mcus</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/mspdebug/">
      <span itemprop="name">mspdebug</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/mspdebug.1.html">
      <span itemprop="name">mspdebug: Debugging tool for msp430 mcus</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>mspdebug</strong> [options] <em>driver</em> [<em>command</em> ...]</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>MSPDebug is a command-line tool designed for debugging and programming the MSP430 family of MCUs. It supports the eZ430-F2013, eZ430-RF2500, Launchpad, Chronos, FET430UIF, GoodFET, Olimex MSP430-JTAG-TINY and MSP430-JTAG-ISO programming tools, as well as a simulation mode.</p><p>When started with appropriate options, MSPDebug will attempt to connect to the debugging tool specified and identify the device under test. Once connected, the user is presented with a command prompt which can be used to reflash the device memory, inspect memory and registers, set registers, and control the CPU (single step, run and run to breakpoint).</p><p>It supports a variety of file formats, described in the section <strong>BINARY FORMATS</strong> below. It can also be used as a remote stub for <strong>gdb</strong>(1).</p><p>On startup, MSPDebug will look for a file called .mspdebug first in the current directory, and then in the user's home directory. If either file exists, commands will be read and executed from this file before executing any other commands or starting the interactive reader.</p><p>Alternatively, a configuration file can be explicitly specified with the <strong>-C</strong> option.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COMMAND-LINE OPTIONS</h2>
        <div class="sectioncontent">
<p>Command-line options accepted by MSPDebug are described below. If commands are specified on the end of the command-line, then they are executed after connecting to the device, and the interactive prompt is not started. Please be aware that commands consisting of multiple words need to be enclosed in quotation marks, otherwise they are treated as single commands. Thus the common prog command would be used as "prog main.elf". See the section labelled <strong>COMMANDS</strong> for more information.</p>
<dl class='dl-vertical'>
  <dt>
    -q
  </dt>
  <dd>
    <p>Start in quiet mode. See the "quiet" option described below.</p>
  </dd>
  <dt>
    -v <em>voltage</em>
  </dt>
  <dd>
    <p>Set the programming voltage. The voltage should be specified as an integer in millivolts. It defaults to 3000 (3.0 V).</p>
  </dd>
  <dt>
    -j
  </dt>
  <dd>
    <p>Use JTAG instead of Spy-Bi-Wire to communicate with the MSP430. This option doesn't work with eZ430 or eZ430-RF2500 devices, which support Spy-Bi-Wire only.</p>
  </dd>
  <dt>
    -d <em>device</em>
  </dt>
  <dd>
    <p>Specify that the driver should connect via a tty device rather than USB. The supported connection methods vary depending on the driver. See the section <strong>DRIVERS</strong> below for details.</p>
  </dd>
  <dt>
    -U <em>bus</em>:<em>device</em>
  </dt>
  <dd>
    <p>Specify a particular USB device to connect to. Without this option, the first device of the appropriate type is opened.</p>
  </dd>
  <dt>
    -s <em>serial</em>
  </dt>
  <dd>
    <p>Specify a particular USB device serial number to connect to. Use this option to distinguish between multiple devices of the same type.</p>
  </dd>
  <dt>
    -n
  </dt>
  <dd>
    <p>Do not process the startup file (~/.mspdebug).</p>
  </dd>
  <dt>
    -C <em>file</em>
  </dt>
  <dd>
    <p>Specify an alternative configuration file (default is ~/.mspdebug). If -n is specified as well, no file will be read.</p>
  </dd>
  <dt>
    --long-password
  </dt>
  <dd>
    <p>When using the flash-bsl driver, send a 32-byte BSL password instead of the standard 16-byte password.</p>
  </dd>
  <dt>
    --help
  </dt>
  <dd>
    <p>Display a brief help message and exit.</p>
  </dd>
  <dt>
    --fet-list
  </dt>
  <dd>
    <p>Display a list of chips supported by the FET driver (the driver used for UIF, RF2500 and Olimex devices).</p>
  </dd>
  <dt>
    --fet-force-id <em>string</em>
  </dt>
  <dd>
    <p>When using a FET device, force the connected chip to be recognised by MSPDebug as one of the given type during initialization. This overrides the device ID returned by the FET. The given string should be a chip name in long form, for example "MSP430F2274".</p>
  </dd>
  <dt>
    --fet-skip-close
  </dt>
  <dd>
    <p>When using a FET device, skip the JTAG close procedure when disconnecting. With some boards, this removes the need to replug the debugger after use.</p>
  </dd>
  <dt>
    --usb-list
  </dt>
  <dd>
    <p>List available USB devices and exit.</p>
  </dd>
  <dt>
    --force-reset
  </dt>
  <dd>
    <p>When using a FET device, always send a reset during initialization. By default, an initialization without reset will be tried first.</p>
  </dd>
  <dt>
    --allow-fw-update
  </dt>
  <dd>
    <p>When using a V3 FET device via the TI library, allow the library to perform a firmware update if the FET firmware is incompatible with the library.</p>
  </dd>
  <dt>
    --require-fw-update <em>image.txt</em>
  </dt>
  <dd>
    <p>When using a V3 FET device, or certain Olimex devices, force a firmware update using the given firmware image. The firmware format depends on the driver.</p>
  </dd>
  <dt>
    --version
  </dt>
  <dd>
    <p>Show program version and copyright information.</p>
  </dd>
  <dt>
    --embedded
  </dt>
  <dd>
    <p>Start mspdebug as an embedded subprocess. See the documentation accompanying the source release for more information on embedded mode.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DRIVERS</h2>
        <div class="sectioncontent">
<p>A driver name must be specified on the command line for MSPDebug to connect to. Valid driver names are listed here.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>rf2500</strong>
  </dt>
  <dd>
    <p>Connect to an eZ430-RF2500, Launchpad or Chronos device. Only USB connection is supported.</p>
  </dd>
  <dt>
    <strong>olimex</strong>
  </dt>
  <dd>
    <p>Connect to an Olimex MSP430-JTAG-TINY device. Both USB and tty access are supported.</p>
  </dd>
  <dt>
    <strong>olimex-v1</strong>
  </dt>
  <dd>
    <p>Connect to an Olimex MSP430-JTAG-TINY (V1) device. Both USB and tty access are supported. This driver must be used instead of <strong>olimex</strong> if connecting to a V1 device via a tty interface.</p>
  </dd>
  <dt>
    <strong>olimex-iso</strong>
  </dt>
  <dd>
    <p>Connect to an Olimex MSP430-JTAG-ISO device. Both USB and tty access are supported.</p>
  </dd>
  <dt>
    <strong>olimex-iso-mk2</strong>
  </dt>
  <dd>
    <p>Connect to an Olimex MSP430-JTAG-ISO-MK2 device. Both USB and tty access are supported.</p>
  </dd>
  <dt>
    <strong>sim</strong>
  </dt>
  <dd>
    <p>Do not connect to any hardware device, but instead start in simulation mode. A 64k buffer is allocated to simulate the device memory.</p><p>During simulation, addresses below 0x0200 are assumed to be IO memory. Programmed IO writes to and from IO memory are handled by the IO simulator, which can be configured and controlled with the <strong>simio</strong> command, described below.</p><p>This mode is intended for testing of changes to MSPDebug, and for aiding the disassembly of MSP430 binaries (as all binary and symbol table formats are still usable in this mode).</p>
  </dd>
  <dt>
    <strong>uif</strong>
  </dt>
  <dd>
    <p>Connect to an eZ430-F2013 or a FET430UIF device. The device argument should be the filename of the appropriate tty device. The TI serial converter chips on these devices are supported by newer versions of the Linux kernel, and should appear as /dev/tty<em>XX</em> when attached.</p><p>USB connection is supported for this driver. The USB interface chip in these devices is a TI3410, which requires a firmware download on startup. MSPDebug will search for a file called ti_3410.fw.ihex in the configured library directory and the current directory. You can specify an alternate location for the file via the <strong>MSPDEBUG_TI3410_FW</strong> environment variable.</p>
  </dd>
  <dt>
    <strong>uif-bsl</strong>
  </dt>
  <dd>
    <p>Connect to the bootloader on a FET430UIF device. These devices contain MSP430F1612 chips. By sending a special command sequence, you can obtain access to the bootloader and inspect memory on the MSP430F1612 in the programming device itself.</p><p>Currently, only memory read/write and erase are supported. CPU control via the bootloader is not possible.</p>
  </dd>
  <dt>
    <strong>flash-bsl</strong>
  </dt>
  <dd>
    <p>Connect to the built-in bootloader in MSP430 devices with flash bootloader memory. Devices with ROM bootloaders require another driver. Currently, this driver must mass-erase the device in order to gain access. Read, write, and erase operations are supported.</p><p>USB connection is not supported for this driver. Connection is via serial port, and bootloader entry is accomplished via the RTS and DTR lines. Connect RTS to the device's TEST pin and DTR to the device's RST pin. Use an appropriate serial level-shifter to make the connection, if necessary. If connecting to a device with non-multiplexed JTAG pins, connect RTS to the device's TCK pin via an inverter.</p>
  </dd>
  <dt>
    <strong>gdbc</strong>
  </dt>
  <dd>
    <p>GDB client mode. Connect to a server which implements the GDB remote protocol and provide an interface to it. To use this driver, specify the remote address in <em>hostname:port</em> format using the <strong>-d</strong> option.</p>
  </dd>
  <dt>
    <strong>tilib</strong>
  </dt>
  <dd>
    <p>Use the Texas Instruments MSP430.DLL to access the device. The library file (MSP430.DLL for Windows, libmsp430.so for Unix-like systems) must be present in the dynamic loader search path.</p><p>USB connection is not supported for this driver. This driver supports watchpoints. Note that the <strong>-d</strong> option for this driver passes its argument straight through to the library's <strong>MSP430_Initialize</strong> function. Any special argument supported by that function is therefore accessible via the <strong>-d</strong> option.</p>
  </dd>
  <dt>
    <strong>goodfet</strong>
  </dt>
  <dd>
    <p>Connect to a GoodFET device. JTAG mode must be used, and only TTY access is supported. This device can be used for memory access (read, erase and program), but CPU control is limited. The CPU may be halted, run and reset, but register access and breakpoints aren't supported.</p>
  </dd>
  <dt>
    <strong>pif</strong>
  </dt>
  <dd>
    <p>Connect to a parallel-port JTAG controller. Currently, this driver is only supported for Linux. A parallel port device must be specified via the <strong>-d</strong> option.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COMMANDS</h2>
        <div class="sectioncontent">
<p>MSPDebug can accept commands either through an interactive prompt, or non-interactively when specified on the command line. The supported commands are listed below.</p><p>Commands take arguments separated by spaces. Any text string enclosed in double-quotation marks is considered to be a single argument, even if it contains space characters. Within a quoted string, the usual C-style backslash substitutions can be used.</p><p>Commands can be specified by giving the first few characters of the command name, provided that the prefix is unambiguous. Some commands support automatic repeat. For these commands, pressing enter at the reader prompt without typing anything will cause repeat execution.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>=</strong> <em>expression</em>
  </dt>
  <dd>
    <p>Evaluate an address expression and show both its value, and the result when the value is looked up in reverse in the current symbol table. This result is of the form <em>symbol</em>+<em>offset</em>, where <em>symbol</em> is the name of the nearest symbol not past the address in question.</p><p>See the section marked <strong>ADDRESS EXPRESSIONS</strong> for more information on the syntax of expressions.</p>
  </dd>
  <dt>
    <strong>alias</strong>
  </dt>
  <dd>
    <p>Show a list of defined command aliases.</p>
  </dd>
  <dt>
    <strong>alias</strong> <em>name</em>
  </dt>
  <dd>
    <p>Remove a previously defined command alias.</p>
  </dd>
  <dt>
    <strong>alias</strong> <em>name</em> <em>command</em>
  </dt>
  <dd>
    <p>Define a command alias. The text <em>command</em> will be substituted for <em>name</em> when looking up commands. The given command text may contain a command plus arguments, if the entire text is wrapped in quotes when defining the alias. To avoid alias substitution when interpreting commands, prefix the command with nbsp;(a backslash character).</p>
  </dd>
  <dt>
    <strong>break</strong>
  </dt>
  <dd>
    <p>Show a list of active breakpoints. Breakpoints can be added and removed with the <strong>setbreak</strong> and <strong>delbreak</strong> commands. Each breakpoint is numbered with an integer index starting at 0.</p>
  </dd>
  <dt>
    <strong>cgraph</strong> <em>address</em> <em>length</em> [<em>address</em>]
  </dt>
  <dd>
    <p>Construct the call graph of all functions contained or referenced in the given range of memory. If a particular function is specified, then details for that node of the graph are displayed. Otherwise, a summary of all nodes is displayed.</p><p>Information from the symbol table is used for hinting at the possible locations of function starts. Any symbol which does not contain a "." is considered a possible function start.</p><p>Callers and callee names are shown prefixed by a "*" where the transition is a tail-call type transition.</p>
  </dd>
  <dt>
    <strong>delbreak</strong> [<em>index</em>]
  </dt>
  <dd>
    <p>Delete one or all breakpoints. If an index is given, the selected breakpoint is deleted. Otherwise, all breakpoints are cleared.</p>
  </dd>
  <dt>
    <strong>dis</strong> <em>address</em> [<em>length</em>]
  </dt>
  <dd>
    <p>Dissassemble a section of memory. Both arguments may be address expressions. If no length is specified, a section of the default length (64 bytes) is disassembled and shown.</p><p>If symbols are available, then all addresses used as operands are translated into <em>symbol</em>+<em>offset</em> form.</p><p>This command supports repeat execution. If repeated, it continues to disassemble another block of memory following that last printed.</p>
  </dd>
  <dt>
    <strong>erase</strong> [<strong>all</strong>|<strong>segment</strong>|<strong>segrange</strong>] [<em>address</em>] [<em>size</em>] [<em>segrange</em>]
  </dt>
  <dd>
    <p>Erase the device under test. With no arguments, all code memory is erased (but not information or boot memory). With the argument "all", a mass erase is performed (the results may depend on the state of the LOCKA bit in the flash memory controller).</p><p>Specify "segment" and a memory address to erase an individual flash segment. Specify "segrange", an address, size and segment size to erase an arbitrary set of contiguous segments.</p>
  </dd>
  <dt>
    <strong>exit</strong>
  </dt>
  <dd>
    <p>Exit from MSPDebug.</p>
  </dd>
  <dt>
    <strong>fill</strong> <em>address</em> <em>length</em> <em>b0</em> [<em>b1</em> <em>b2</em> ...]
  </dt>
  <dd>
    <p>Fill the memory region of size <em>length</em> starting at <em>address</em> with the pattern of bytes given (specified in hexadecimal). The pattern will be repeated without padding as many times as necessary without exceeding the bounds of the specified region.</p>
  </dd>
  <dt>
    <strong>gdb</strong> [<em>port</em>]
  </dt>
  <dd>
    <p>Start a GDB remote stub, optionally specifying a TCP port to listen on. If no port is given, the default port is controlled by the option <strong>gdb_default_port</strong>.</p><p>MSPDebug will wait for a connection on this port, and then act as a GDB remote stub until GDB disconnects.</p><p>GDB's "monitor" command can be used to issue MSPDebug commands via the GDB interface. Supplied commands are executed non-interactively, and the output is sent back to be displayed in GDB.</p>
  </dd>
  <dt>
    <strong>help</strong> [<em>command</em>]
  </dt>
  <dd>
    <p>Show a brief listing of available commands. If an argument is specified, show the syntax for the given command. The help text shown when no argument is given is also shown when MSPDebug starts up.</p>
  </dd>
  <dt>
    <strong>hexout</strong> <em>address</em> <em>length</em> <em>filename</em>
  </dt>
  <dd>
    <p>Read the specified section of the device memory and save it to an Intel HEX file. The address and length arguments may both be address expressions.</p><p>If the specified file already exists, then it will be overwritten. If you need to dump memory from several disjoint memory regions, you can do this by saving each section to a separate file. The resulting files can then be concatenated together to form a single valid HEX file.</p>
  </dd>
  <dt>
    <strong>isearch</strong> <em>address</em> <em>length</em> [<em>options</em> ...]
  </dt>
  <dd>
    <p>Search over the given range for an instruction which matches the specified search criteria. The search may be narrowed by specifying one or more of the following terms:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>opcode</strong> <em>opcode</em>
  </dt>
  <dd>
    <p>Match the specified opcode. Byte/word specifiers are not recognised, as they are specified with other options.</p>
  </dd>
  <dt>
    <strong>byte</strong>
  </dt>
  <dd>
    <p>Match only byte operations.</p>
  </dd>
  <dt>
    <strong>word</strong>
  </dt>
  <dd>
    <p>Match only word operations.</p>
  </dd>
  <dt>
    <strong>aword</strong>
  </dt>
  <dd>
    <p>Match only address-word (20-bit) operations.</p>
  </dd>
  <dt>
    <strong>jump</strong>
  </dt>
  <dd>
    <p>Match only jump instructions (conditional and unconditional jumps, but not instructions such as BR which load the program counter explicitly).</p>
  </dd>
  <dt>
    <strong>single</strong>
  </dt>
  <dd>
    <p>Match only single-operand instructions.</p>
  </dd>
  <dt>
    <strong>double</strong>
  </dt>
  <dd>
    <p>Match only double-operand instructions.</p>
  </dd>
  <dt>
    <strong>noarg</strong>
  </dt>
  <dd>
    <p>Match only instructions with no arguments.</p>
  </dd>
  <dt>
    <strong>src</strong> <em>address</em>
  </dt>
  <dd>
    <p>Match instructions with the specified value in the source operand. The value may be given as an address expression. Specifying this option implies matching of only double-operand instructions.</p>
  </dd>
  <dt>
    <strong>dst</strong> <em>address</em>
  </dt>
  <dd>
    <p>Match instructions with the specified value in the destination operand. This option implies that no-argument instructions are not matched.</p>
  </dd>
  <dt>
    <strong>srcreg</strong> <em>register</em>
  </dt>
  <dd>
    <p>Match instructions using the specified register in the source operand. This option implies matching of only double-operand instructions.</p>
  </dd>
  <dt>
    <strong>dstreg</strong> <em>register</em>
  </dt>
  <dd>
    <p>Match instructions using the specified register in the destination operand. This option implies that no-argument instructions are not matched.</p>
  </dd>
  <dt>
    <strong>srcmode</strong> <em>mode</em>
  </dt>
  <dd>
    <p>Match instructions using the specified mode in the source operand. See below for a list of modes recognised. This option implies matching of only double-operand instructions.</p>
  </dd>
  <dt>
    <strong>dstmode</strong> <em>mode</em>
  </dt>
  <dd>
    <p>Match instructions using the specified mode in the destination operand. See below for a list of modes. This option implies that no-argument instructions are not matched.</p>
  </dd>

</dl>

  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>For single-operand instructions, the operand is considered to be the destination operand.</p><p>The seven addressing modes used by the MSP430 are represented by single characters, and are listed here:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>R</strong>
  </dt>
  <dd>
    <p>Register mode.</p>
  </dd>
  <dt>
    <strong>I</strong>
  </dt>
  <dd>
    <p>Indexed mode.</p>
  </dd>
  <dt>
    <strong>S</strong>
  </dt>
  <dd>
    <p>Symbolic mode.</p>
  </dd>
  <dt>
    <strong>&</strong>
  </dt>
  <dd>
    <p>Absolute mode.</p>
  </dd>
  <dt>
    <strong>@</strong>
  </dt>
  <dd>
    <p>Register-indirect mode.</p>
  </dd>
  <dt>
    <strong>+</strong>
  </dt>
  <dd>
    <p>Register-indirect mode with auto-increment.</p>
  </dd>
  <dt>
    <strong>#</strong>
  </dt>
  <dd>
    <p>Immediate mode.</p>
  </dd>

</dl>

  </dd>
  <dt>
    <strong>load</strong> <em>filename</em>
  </dt>
  <dd>
    <p>Program the device under test using the binary file supplied. This command is like <strong>prog</strong>, but it does not load symbols or erase the device before programming.</p><p>The CPU is reset and halted before and after programming.</p>
  </dd>
  <dt>
    <strong>load_raw</strong> <em>filename</em> <em>address</em>
  </dt>
  <dd>
    <p>Write the data contained in a raw binary file to the given memory address.</p><p>The CPU is reset and halted before and after programming.</p>
  </dd>
  <dt>
    <strong>md</strong> <em>address</em> [<em>length</em>]
  </dt>
  <dd>
    <p>Read the specified section of device memory and display it as a canonical-style hexdump. Both arguments may be address expressions. If no length is specified, a section of the default length (64 bytes) is shown.</p><p>The output is split into three columns. The first column shows the starting address for the line. The second column lists the hexadecimal values of the bytes. The final column shows the ASCII characters corresponding to printable bytes, and . for non-printing characters.</p><p>This command supports repeat execution. If repeated, it continues to print another block of memory following that last printed.</p>
  </dd>
  <dt>
    <strong>mw</strong> <em>address</em> <em>bytes</em> ...
  </dt>
  <dd>
    <p>Write a sequence of bytes at the given memory address. The address given may be an address expression. Bytes values are two-digit hexadecimal numbers separated by spaces.</p><p>Unless used in the simulation mode, this command can only be used for programming flash memory.</p>
  </dd>
  <dt>
    <strong>opt</strong> [<em>name</em>] [<em>value</em>]
  </dt>
  <dd>
    <p>Query, set or list option variables. MSPDebug's behaviour can be configured using option variables, described below in the section <strong>OPTIONS</strong>.</p><p>Option variables may be of three types: boolean, numeric or text. Numeric values may be specified as address expressions.</p><p>With no arguments, this command displays all available option variables. With just an option name as its argument, it displays the current value of that option.</p>
  </dd>
  <dt>
    <strong>power info</strong>
  </dt>
  <dd>
    <p>Show basic power statistics gathered over the last few sessions. This includes total charge consumption, run time and average current.</p>
  </dd>
  <dt>
    <strong>power clear</strong>
  </dt>
  <dd>
    <p>Clear all recorded power statistics.</p>
  </dd>
  <dt>
    <strong>power all</strong> [<em>granularity</em>]
  </dt>
  <dd>
    <p>Show sample data gathered over all sessions. An optional granularity can be specified, in microseconds. For each time slice, relative session time, charge consumption, current consumption and approximate code location are shown.</p>
  </dd>
  <dt>
    <strong>power session</strong> <em>N</em> [<em>granularity</em>]
  </dt>
  <dd>
    <p>Same as <strong>power all</strong>, except that data is shown only for the <em>N</em>th session.</p>
  </dd>
  <dt>
    <strong>power export-csv</strong> <em>N</em> <em>filename</em>
  </dt>
  <dd>
    <p>Export raw sample data for the <em>N</em>th session to the given file in CSV format. For each line, the columns are, in order: relative time in microseconds, current consumption in microamps, memory address.</p>
  </dd>
  <dt>
    <strong>power profile</strong>
  </dt>
  <dd>
    <p>If a symbol table is loaded, compile and correlate all gathered power data against the symbol table. A single table is then shown listing, per function, charge consumption, run time and average current. The functions are listed in order of charge consumption (biggest consumers first).</p>
  </dd>
  <dt>
    <strong>prog</strong> <em>filename</em>
  </dt>
  <dd>
    <p>Erase and reprogram the device under test using the binary file supplied. The file format will be auto-detected and may be any of the supported file formats.</p><p>In the case of a file containing symbols, symbols will be automatically loaded from the file into the symbol table (discarding any existing symbols), if they are present.</p><p>The CPU is reset and halted before and after programming.</p>
  </dd>
  <dt>
    <strong>read</strong> <em>filename</em>
  </dt>
  <dd>
    <p>Read commands from the given file, line by line and process each one. Any lines whose first non-space character is <strong>#</strong> are ignored. If an error occurs while processing a command, the rest of the file is not processed.</p>
  </dd>
  <dt>
    <strong>regs</strong>
  </dt>
  <dd>
    <p>Show the current value of all CPU registers in the device under test.</p>
  </dd>
  <dt>
    <strong>reset</strong>
  </dt>
  <dd>
    <p>Reset (and halt) the CPU of the device under test.</p>
  </dd>
  <dt>
    <strong>run</strong>
  </dt>
  <dd>
    <p>Start running the CPU. The interactive command prompt is blocked when the CPU is started and the prompt will not appear again until the CPU halts. The CPU will halt if it encounters a breakpoint, or if Ctrl-C is pressed by the user.</p><p>After the CPU halts, the current register values are shown as well as a disassembly of the first few instructions at the address selected by the program counter.</p>
  </dd>
  <dt>
    <strong>save_raw</strong> <em>address</em> <em>length</em> <em>filename</em>
  </dt>
  <dd>
    <p>Save a region of memory to a raw binary file. The address and length arguments may both be address expressions.</p><p>If the specified file already exists, then it will be overwritten.</p>
  </dd>
  <dt>
    <strong>set</strong> <em>register</em> <em>value</em>
  </dt>
  <dd>
    <p>Alter the value of a register. Registers are specified as numbers from 0 through 15. Any leading non-numeric characters are ignored (so a register may be specified as, for example, "R12"). The value argument is an address expression.</p>
  </dd>
  <dt>
    <strong>setbreak</strong> <em>address</em> [<em>index</em>]
  </dt>
  <dd>
    <p>Add a new breakpoint. The breakpoint location is an address expression. An optional index may be specified, indicating that this new breakpoint should overwrite an existing slot. If no index is specified, then the breakpoint will be stored in the next unused slot.</p>
  </dd>
  <dt>
    <strong>setwatch</strong> <em>address</em> [<em>index</em>]
  </dt>
  <dd>
    <p>Add a new watchpoint. The watchpoint location is an address expression, and an optional index may be specified. Watchpoints are considered to be a type of breakpoint and can be inspected or removed using the <strong>break</strong> and <strong>delbreak</strong> commands. Note that not all drivers support watchpoints.</p>
  </dd>
  <dt>
    <strong>setwatch_r</strong> <em>address</em> [<em>index</em>]
  </dt>
  <dd>
    <p>Add a watchpoint which is triggered only on read access.</p>
  </dd>
  <dt>
    <strong>setwatch_w</strong> <em>address</em> [<em>index</em>]
  </dt>
  <dd>
    <p>Add a watchpoint which is triggered only on write access.</p>
  </dd>
  <dt>
    <strong>simio add</strong> <em>class</em> <em>name</em> [<em>args ...</em>]
  </dt>
  <dd>
    <p>Add a new peripheral to the IO simulator. The <em>class</em> parameter may be any of the peripheral types named in the output of the <strong>simio classes</strong> command. The <em>name</em> parameter is a unique name assigned by the user to this peripheral instance, and is used with other commands to refer to this instance of the peripheral.</p><p>Some peripheral classes take arguments upon creation. These are documented in the output to the <strong>simio help</strong> command.</p>
  </dd>
  <dt>
    <strong>simio classes</strong>
  </dt>
  <dd>
    <p>List the names of the different types of peripherals which may be added to the simulator. You can use the <strong>simio help</strong> command to obtain more information about each peripheral type.</p>
  </dd>
  <dt>
    <strong>simio config</strong> <em>name</em> <em>param</em> [<em>args ...</em>]
  </dt>
  <dd>
    <p>Configure or perform some action on a peripheral instance. The <em>param</em> argument is specific to the peripheral type. A list of valid configuration commands can be obtained by using the <strong>simio help</strong> command.</p>
  </dd>
  <dt>
    <strong>simio del</strong> <em>name</em>
  </dt>
  <dd>
    <p>Remove a previously added peripheral instance. The <em>name</em> argument should be the name of the peripheral that was assigned with the <strong>simio add</strong> command.</p>
  </dd>
  <dt>
    <strong>simio devices</strong>
  </dt>
  <dd>
    <p>List all peripheral instances currently attached to the simulator, along with their types and interrupt status. You can obtain more detailed information for each instance with the <strong>simio info</strong> command.</p>
  </dd>
  <dt>
    <strong>simio help</strong> <em>class</em>
  </dt>
  <dd>
    <p>Obtain more information about a peripheral class. The documentation given will list constructor arguments and configuration parameters for the device type.</p>
  </dd>
  <dt>
    <strong>simio info</strong> <em>name</em>
  </dt>
  <dd>
    <p>Display detailed status information for a particular peripheral. The type of information displayed is specific to each type of peripheral.</p>
  </dd>
  <dt>
    <strong>step</strong> [<em>count</em>]
  </dt>
  <dd>
    <p>Step the CPU through one or more instructions. After stepping, the new register values are displayed, as well as a disassembly of the instructions at the address selected by the program counter.</p><p>An optional count can be specified to step multiple times. If no argument is given, the CPU steps once. This command supports repeat execution.</p>
  </dd>
  <dt>
    <strong>sym clear</strong>
  </dt>
  <dd>
    <p>Clear the symbol table, deleting all symbols.</p>
  </dd>
  <dt>
    <strong>sym set</strong> <em>name</em> <em>value</em>
  </dt>
  <dd>
    <p>Set or alter the value of a symbol. The value given may be an address expression.</p>
  </dd>
  <dt>
    <strong>sym del</strong> <em>name</em>
  </dt>
  <dd>
    <p>Delete the given symbol from the symbol table.</p>
  </dd>
  <dt>
    <strong>sym import</strong> <em>filename</em>
  </dt>
  <dd>
    <p>Load symbols from the specified file and add them to the symbol table. The file format will be auto-detected and may be either ELF32 or a BSD-style symbol listing (like the output from <strong>nm</strong>(1)).</p><p>Symbols can be combined from many sources, as the syms command adds to the existing symbol table without discarding existing symbols.</p>
  </dd>
  <dt>
    <strong>sym import+</strong> <em>filename</em>
  </dt>
  <dd>
    <p>This command is similar to <strong>sym import</strong>, except that the symbol table is not cleared first. By using this command, symbols from multiple sources can be combined.</p>
  </dd>
  <dt>
    <strong>sym export</strong> <em>filename</em>
  </dt>
  <dd>
    <p>Save all symbols currently defined to the given file. The symbols are saved as a BSD-style symbol table. Note that symbol types are not stored by MSPDebug, and all symbols are saved as type <strong>t</strong>.</p>
  </dd>
  <dt>
    <strong>sym find</strong> [<em>regex</em>]
  </dt>
  <dd>
    <p>Search for symbols. If a regular expression is given, then all symbols matching the expression are printed. If no expression is specified, then the entire symbol table is listed.</p>
  </dd>
  <dt>
    <strong>sym rename</strong> <em>regex</em> <em>string</em>
  </dt>
  <dd>
    <p>Rename symbols by searching for those matching the given regular expression and substituting the given string for the matched portion. The symbols renamed are displayed, as well as a total count of all symbols renamed.</p>
  </dd>
  <dt>
    <strong>verify </strong><em>filename</em>
  </dt>
  <dd>
    <p>Compare the contents of the given binary file to the chip memory. If any differences are found, a message is printed for the first mismatched byte.</p>
  </dd>
  <dt>
    <strong>verify_raw </strong><em>filename</em> <em>address</em>
  </dt>
  <dd>
    <p>Compare the contents of a raw binary file to the device memory at the given address. If any differences are found, a message is printed for the first mismatched byte.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BINARY FORMATS</h2>
        <div class="sectioncontent">
<p>The following binary/symbol formats are supported by MSPDebug:</p><p>ELF32</p><p>COFF</p><p>Intel HEX (program only)</p><p>BSD symbol table (symbols only)</p><p>TI Text (program only)</p><p>SREC (program only)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">IO SIMULATOR</h2>
        <div class="sectioncontent">
<p>The IO simulator subsystem consists of a database of device classes, and a list of instances of those classes. Each device class has a different set of constructor arguments, configuration parameters and information which may be displayed. This section describes the operation of the available device classes in detail.</p><p>In the list below, each device class is listed, followed by its constructor arguments.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>gpio</strong>
  </dt>
  <dd>
    <p>Digital IO port simulator. This device simulates any of the digital ports with or without interrupt capability. It has the following configuration parameters:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>base</strong> <em>address</em>
  </dt>
  <dd>
    <p>Set the base address for this port. Note that for ports without interrupt capability, the resistor enable port has a special address which is computable from the base address.</p>
  </dd>
  <dt>
    <strong>irq</strong> <em>vector</em>
  </dt>
  <dd>
    <p>Enable interrupt functionality for this port by specifying an interrupt vector number.</p>
  </dd>
  <dt>
    <strong>noirq</strong>
  </dt>
  <dd>
    <p>Disable interrupt functionality for this port.</p>
  </dd>
  <dt>
    <strong>verbose</strong>
  </dt>
  <dd>
    <p>Print a state change message every time the port output changes.</p>
  </dd>
  <dt>
    <strong>quiet</strong>
  </dt>
  <dd>
    <p>Don't print anything when the port state changes (the default).</p>
  </dd>
  <dt>
    <strong>set</strong> <em>pin</em> <em>value</em>
  </dt>
  <dd>
    <p>Set the input pin state for the given pin on this port. The <em>pin</em> parameter should be an index between 0 and 7. The <em>value</em> should be either zero (for a low state) or non-zero (for a high state).</p>
  </dd>

</dl>

  </dd>
  <dt>
    <strong>hwmult</strong>
  </dt>
  <dd>
    <p>This peripheral simulates the hardware multiplier. It has no constructor or configuration parameters, and does not provide any extended information.</p>
  </dd>
  <dt>
    <strong>timer</strong> [<em>size</em>]
  </dt>
  <dd>
    <p>This peripheral simulators Timer_A modules, and can be used to simulate Timer_B modules, provided that the extended features aren't required.</p><p>The constructor takes a size argument specifying the number of capture/compare registers in this peripheral instance. The number of such registers may not be less than 2, or greater than 7.</p><p>The IO addresses and IRQs used are configurable. The default IO addresses used are those specified for Timer_A in the MSP430 hardware documentation.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>base</strong> <em>address</em>
  </dt>
  <dd>
    <p>Alter the base IO address. By default, this is 0x0160. By setting this to 0x0180, a Timer_B module may be simulated.</p>
  </dd>
  <dt>
    <strong>irq0</strong> <em>number</em>
  </dt>
  <dd>
    <p>Set the TACCR0 interrupt vector number. By default, this is interrupt vector 9. This interrupt is self-clearing, and higher priority than the TACCR1/TAIFG vector.</p>
  </dd>
  <dt>
    <strong>irq1</strong> <em>number</em>
  </dt>
  <dd>
    <p>Set the TACCR1/TAIFG interrupt vector. By default, this is interrupt vector 8.</p>
  </dd>
  <dt>
    <strong>iv</strong> <em>address</em>
  </dt>
  <dd>
    <p>Alter the address of the interrupt vector register. By default, this is 0x012E. By setting this to 0x011E, a Timer_B module may be simulated.</p>
  </dd>
  <dt>
    <strong>set</strong> <em>channel</em> <em>value</em>
  </dt>
  <dd>
    <p>When Timer_A is used in capture mode, the CCI bit in each capture register reflects the state of the corresponding input pin, and can't be altered in software. This configuration command can be used to simulate changes in input pin state, and will trigger the corresponding interrupts if the peripheral is so configured.</p>
  </dd>

</dl>

  </dd>
  <dt>
    <strong>tracer</strong> [<em>history-size</em>]
  </dt>
  <dd>
    <p>The tracer peripheral is a debugging device. It can be used to investigate and record the IO activity of a running program, to benchmark execution time, and to simulate interrupts.</p><p>The information displayed by the tracer gives a running count of clock cycles from each of the system clocks, and an instruction count. A list of the <em>N</em> most recent IO events is also displayed (this is configurable via the <em>history-size</em> argument of the constructor). Each IO event is timestamped by the number of MCLK cycles that have elapsed since the last reset of the device's counter.</p><p>The IO events that it records consist of programmed IO reads and writes, interrupt acceptance, and system resets. As well as keeping the IO events in a rotating buffer, the tracer can be configured to display the events as they occur.</p><p>Note that since clock cycles don't advance while the CPU isn't running, this peripheral can be used to calculate execution times for blocks of code. This can be achieved by setting a breakpoint at the end of the code block, setting the program counter to the start of the code block, clearing the tracer and running the code. After the breakpoint is reached, the information displayed by the tracer will contain a count of MCLK cycles elapsed during the last run.</p><p>The configuration parameters for this device class are:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>verbose</strong>
  </dt>
  <dd>
    <p>Start displaying IO events as they occur, as well as recording them in the rotating buffer.</p>
  </dd>
  <dt>
    <strong>quiet</strong>
  </dt>
  <dd>
    <p>Stop displaying IO events as they occur, and just record them in the buffer.</p>
  </dd>
  <dt>
    <strong>trigger</strong> <em>irq</em>
  </dt>
  <dd>
    <p>Signal an interrupt request to the CPU. This request will remain raised until accepted by the CPU or cleared by the user.</p>
  </dd>
  <dt>
    <strong>untrigger</strong>
  </dt>
  <dd>
    <p>Clear a signalled interrupt request.</p>
  </dd>
  <dt>
    <strong>clear</strong>
  </dt>
  <dd>
    <p>Reset the clock cycle and instruction counts to 0, and clear the IO event history.</p>
  </dd>

</dl>

  </dd>
  <dt>
    <strong>wdt</strong>
  </dt>
  <dd>
    <p>This peripheral simulates the Watchdog Timer+, which can be used in software either as a watchdog or as an interval timer. It has no constructor arguments.</p><p>The simulated state of the NMI/RST# pin can be controlled through a configuration parameter. Note that if this pin state is held low with the pin mode selected as a reset (the default), the CPU will not run.</p><p>The extended information for this peripheral shows all register states, including the hidden counter register. Configuration parameters are:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>nmi</strong> <em>state</em>
  </dt>
  <dd>
    <p>Set the NMI/RST# pin state. The argument should be zero to indicate a low state or non-zero for a high state.</p>
  </dd>
  <dt>
    <strong>irq</strong> <em>irq</em>
  </dt>
  <dd>
    <p>Select the interrupt vector for interval timer mode. The default is to use interrupt vector 10.</p>
  </dd>

</dl>

  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ADDRESS EXPRESSIONS</h2>
        <div class="sectioncontent">
<p>Any command which accepts a memory address, length or register value as an argument may be given an address expression. An address expression consists of an algebraic combination of values.</p><p>An address value may be either a symbol name, a hex value preceded with the specifier "0x", a decimal value preceded with the specifier "0d", or a number in the default input radix (without a specifier). See the option <strong>iradix</strong> for more information.</p><p>The operators recognised are the usual algebraic operators: <strong>+</strong>, <strong>-</strong>, <strong>*</strong>, <strong>/</strong>, <strong>%</strong>, <strong>(</strong> and <strong>)</strong>. Operator precedence is the same as in C-like languages, and the <strong>-</strong> operator may be used as a unary negation operator.</p><p>The following are all valid examples of address expressions:</p><p><strong>2+2</strong></p><p><strong>table_start + (elem_size + elem_pad)*4</strong></p><p><strong>main+0x3f</strong></p><p><strong>__bss_end-__bss_start</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONS</h2>
        <div class="sectioncontent">
<p>MSPDebug's behaviour can be configured via the following variables:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>color</strong> (boolean)
  </dt>
  <dd>
    <p>If true, MSPDebug will colorize debugging output.</p>
  </dd>
  <dt>
    <strong>fet_block_size</strong> (numeric)
  </dt>
  <dd>
    <p>Change the size of the buffer used to transfer memory to and from the FET. Increasing the value from the default of 64 will improve transfer speed, but may cause problems with some chips.</p>
  </dd>
  <dt>
    <strong>enable_bsl_access</strong> (boolean)
  </dt>
  <dd>
    <p>If set, some drivers will allow erase/program access to flash BSL memory. If in doubt, do not enable this.</p>
  </dd>
  <dt>
    <strong>enable_locked_flash_access</strong> (boolean)
  </dt>
  <dd>
    <p>If set, some drivers will allow erase/program access to the info A segment. If in doubt, do not enable this. Currently, the tilib and uif drivers are affected by this option.</p>
  </dd>
  <dt>
    <strong>gdb_default_port</strong> (numeric)
  </dt>
  <dd>
    <p>This option controls the default TCP port for the GDB server, if no argument is given to the "<strong>gdb</strong>" command.</p>
  </dd>
  <dt>
    <strong>gdb_loop</strong> (boolean)
  </dt>
  <dd>
    <p>Automatically restart the GDB server after disconnection. If this option is set, then the GDB server keeps running until an error occurs, or the user interrupts with Ctrl+C.</p>
  </dd>
  <dt>
    <strong>gdbc_xfer_size</strong> (numeric)
  </dt>
  <dd>
    <p>Maximum size of memory transfers for the GDB client. Increasing this value will result in faster transfers, but may cause problems with some servers.</p>
  </dd>
  <dt>
    <strong>iradix</strong> (numeric)
  </dt>
  <dd>
    <p>Default input radix for address expressions. For address values with no radix specifier, this value gives the input radix, which is 10 (decimal) by default.</p>
  </dd>
  <dt>
    <strong>quiet</strong> (boolean)
  </dt>
  <dd>
    <p>If set, MSPDebug will supress most of its debug-related output. This option defaults to false, but can be set true on start-up using the <strong>-q</strong> command-line option.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ENVIRONMENT</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <strong>MSPDEBUG_TI3410_FW</strong><em></em>
  </dt>
  <dd>
    <p>Specifies the location of TI3410 firmware, for raw USB access to FET430UIF or eZ430 devices. This variable should contain the path to an Intel HEX file containing suitable firmware for the TI3410.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILES</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    ~/.mspdebug
  </dt>
  <dd>
    <p>File containing commands to be executed on startup.</p>
  </dd>
  <dt>
    ti_3410.fw.ihex
  </dt>
  <dd>
    <p>Firmware image for the TI3410 USB interface chip. This file is only required for raw USB access to FET430UIF or eZ430 devices.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO mspdebug&hellip;</h2>
        <div class="sectioncontent">
<p><strong>nm</strong>(1), <strong>gdb</strong>(1), <strong>objcopy</strong>(1)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>If you find any bugs, you should report them to the author at dlbeer@gmail.com. It would help if you could include a transcript of an MSPDebug session illustrating the program, as well as any relevant binaries or other files.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright (C) 2009-2013 Daniel Beer &lt;dlbeer@gmail.com&gt;</p><p>MSPDebug is free software, distributed under the terms of the GNU General Public license (version 2 or later). See the file COPYING included with the source code for more details.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="msp430-windres.1.html"><span aria-hidden="true">&larr;</span> msp430-windres.1: Manipulate windows resources.</a></li>
   <li class="next"><a href="mariadb-server-10.0-msql2mysql.1.html">msql2mysql.1: Convert msql programs for use with mysql <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

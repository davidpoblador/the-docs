<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>sec: Simple event correlator</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Simple event correlator">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="sec (1) manual">
  <meta name="twitter:description" content="Simple event correlator">
  <meta name="twitter:image" content="https://www.carta.tech/images/sec-sec-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/sec.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="sec (1) manual" />
  <meta property="og:description" content="Simple event correlator" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/sec-sec-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">sec<small> (1)</small></h1>
        <p class="lead">Simple event correlator</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/sec.1.html">
      <span itemprop="name">sec: Simple event correlator</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/sec/">
      <span itemprop="name">sec</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/sec.1.html">
      <span itemprop="name">sec: Simple event correlator</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>sec</strong></p>
  </dt>
  <dd>
    <p>[--conf=&lt;file pattern&gt; ...]</p><p>[--input=&lt;file pattern&gt;[=&lt;context&gt;] ...]</p><p>[--input-timeout=&lt;input timeout&gt;]</p><p>[--timeout-script=&lt;timeout script&gt;]</p><p>[--reopen-timeout=&lt;reopen timeout&gt;]</p><p>[--check-timeout=&lt;check timeout&gt;]</p><p>[--poll-timeout=&lt;poll timeout&gt;]</p><p>[--socket-timeout=&lt;socket timeout&gt;]</p><p>[--blocksize=&lt;io block size&gt;]</p><p>[--bufsize=&lt;input buffer size&gt;]</p><p>[--evstoresize=&lt;event store size&gt;]</p><p>[--cleantime=&lt;clean time&gt;]</p><p>[--log=&lt;logfile&gt;]</p><p>[--syslog=&lt;facility&gt;]</p><p>[--debug=&lt;debuglevel&gt;]</p><p>[--pid=&lt;pidfile&gt;]</p><p>[--dump=&lt;dumpfile&gt;]</p><p>[--quoting | --noquoting]</p><p>[--tail | --notail]</p><p>[--fromstart | --nofromstart]</p><p>[--detach | --nodetach]</p><p>[--jointbuf | --nojointbuf]</p><p>[--keepopen | --nokeepopen]</p><p>[--rwfifo | --norwfifo]</p><p>[--childterm | --nochildterm]</p><p>[--intevents | --nointevents]</p><p>[--intcontexts | --nointcontexts]</p><p>[--testonly | --notestonly]</p><p>[--help] [-?]</p><p>[--version]</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>SEC is an event correlation tool for advanced event processing which can be harnessed for event log monitoring, for network and security management, for fraud detection, and for any other task which involves event correlation. Event correlation is a procedure where a stream of events is processed, in order to detect (and act on) certain event groups that occur within predefined time windows. Unlike many other event correlation products which are heavyweight solutions, SEC is a lightweight and platform-independent event correlator which runs as a single process. The user can start it as a daemon, employ it in shell pipelines, execute it interactively in a terminal, run many SEC processes simultaneously for different tasks, and use it in a wide variety of other ways.</p><p>SEC reads lines from files, named pipes, or standard input, matches the lines with patterns (regular expressions, Perl subroutines, etc.) for recognizing input events, and correlates events according to the rules in its configuration file(s). Rules are matched against input in the order they are given in the configuration file. If there are two or more configuration files, rule sequence from every file is matched against input (unless explicitly specified otherwise). SEC can produce output by executing external programs (e.g., <a href="../man1/snmptrap.1.html"><strong>snmptrap</strong>(1)</a> or <strong>mail</strong>(1)), by writing to files, by sending data to TCP and UDP based servers, by calling precompiled Perl subroutines, etc.</p><p>SEC can be run in various ways. For example, the following command line starts it as a daemon, in order to monitor events appended to the /var/log/messages syslog file with rules from /etc/sec/syslog.rules:</p><p>/usr/bin/sec --detach --conf=/etc/sec/syslog.rules &#92;</p>
<pre>
             --input=/var/log/messages
</pre>
<p>Each time /var/log/messages is rotated, a new instance of /var/log/messages is opened and processed from the beginning. The following command line runs SEC in a shell pipeline, configuring it to process lines from standard input, and to exit when the /usr/bin/nc tool closes its standard output and exits:</p><p>/usr/bin/nc -l 8080 | /usr/bin/sec --notail --input=- &#92;</p>
<pre>
                                   --conf=/etc/sec/my.conf
</pre>
<p>Some SEC rules start event correlation operations, while other rules react immediately to input events or system clock. For example, suppose that SEC has been started with the following command line</p><p>/usr/bin/sec --conf=/etc/sec/sshd.rules --input=/var/log/secure</p><p>in order to monitor the /var/log/secure syslog file for sshd events. Also, suppose that the /etc/sec/sshd.rules configuration file contains the following rule for correlating SSH failed login syslog events:</p><p>type=SingleWithThreshold</p><p>ptype=RegExp</p><p>pattern=sshd&#92;[&#92;d+&#92;]: Failed .+ for (&#92;S+) from [&#92;d.]+ port &#92;d+ ssh2</p><p>desc=Three SSH login failures within 1m for user $1</p><p>action=pipe '%s' /bin/mail -s 'SSH login alert' root@localhost</p><p>window=60</p><p>thresh=3</p><p>The <em>pattern</em> field of the rule defines the pattern for recognizing input events, while the <em>ptype</em> field defines its type (regular expression). Suppose that user risto fails to log in over SSH and the following message is logged to /var/log/secure:</p><p>Dec 16 16:24:59 myserver sshd[13685]: Failed password for risto from 10.12.2.5 port 41063 ssh2</p><p>This input message will match the regular expression pattern of the above rule, and the match variable $1 will be set to the string <em>risto</em> (see <strong>perlre</strong>(1) for details). After a match, SEC will evaluate the operation description string given with the <em>desc</em> field. This is done by substituting $1 with its current value which yields <em>Three SSH login failures within 1m for user risto</em>. SEC will then check if there already exists an event correlation operation identified with this string and triggered by the same rule. If the operation is not found, SEC will create a new operation for the user name risto, and the occurrence time of the input event will be recorded into the operation. Note that for event occurrence time SEC always uses the current time as returned by the <a href="../man2/time.2.html"><strong>time</strong>(2)</a> system call, *not* the timestamp extracted from the event. Suppose that after 25 seconds, a similar SSH login failure event for the same user name is observed. In this case, a running operation will be found for the operation description string <em>Three SSH login failures within 1m for user risto</em>, and the occurrence time of the second event is recorded into the operation. If after 30 seconds a third event for the user name risto is observed, the operation has processed 3 events within 55 seconds. Since the threshold condition "3 events within 60 seconds" (as defined by the <em>thresh</em> and <em>window</em> fields) is now satisfied, SEC will execute the action defined with the <em>action</em> field -- it will fork a command</p><p>/bin/mail -s 'SSH login alert' root@localhost</p><p>with a pipe connected to its standard input. Then, SEC writes the operation description string <em>Three SSH login failures within 1m for user risto</em> (held by the %s special variable) to the standard input of the command through the pipe. In other words, an e-mail warning is sent to the local root-user. Finally, since there are 5 seconds left until the end of the event correlation window, the operation will consume the following SSH login failure events for user risto without any further action, and finish after 5 seconds.</p><p>The above example illustrates that the <em>desc</em> field of a rule defines the scope of event correlation and influences the number of operations created by the rule. For example, if we set the <em>desc</em> field to <em>Three SSH login failures within 1m</em>, the root-user would be also alerted on 3 SSH login failure events for *different* users within 1 minute. In order to avoid clashes between operations started by different rules, operation ID contains not only the value set by the <em>desc</em> field, but also the rule file name and the rule number inside the file. For example, if the rule file /etc/sec/sshd.rules contains one rule</p><p>type=SingleWithThreshold</p><p>ptype=RegExp</p><p>pattern=sshd&#92;[&#92;d+&#92;]: Failed .+ for (&#92;S+) from [&#92;d.]+ port &#92;d+ ssh2</p><p>desc=Three SSH login failures within 1m for user $1</p><p>action=pipe '%s' /bin/mail -s 'SSH login alert' root@localhost</p><p>window=60</p><p>thresh=3</p><p>and the event</p><p>Dec 16 16:24:59 myserver sshd[13685]: Failed password for risto from 10.12.2.5 port 41063 ssh2</p><p>is the first matching event for the above rule, this event will trigger a new event correlation operation with the ID</p><p>/etc/sec/sshd.rules | 0 | Three SSH login failures within 1m for user risto</p><p>(0 is the number assigned to the first rule in the file, see EVENT CORRELATION OPERATIONS section for more information).</p><p>The following simple example demonstrates that event correlation schemes can be defined by combining several rules. In this example, two rules harness contexts and synthetic events for achieving their goal:</p><p>type=SingleWithThreshold</p><p>ptype=RegExp</p><p>pattern=sshd&#92;[&#92;d+&#92;]: Failed .+ for (&#92;S+) from [&#92;d.]+ port &#92;d+ ssh2</p><p>desc=Three SSH login failures within 1m for user $1</p><p>action=event 3_SSH_LOGIN_FAILURES_FOR_$1</p><p>window=60</p><p>thresh=3</p><p>type=EventGroup</p><p>init=create USER_COUNTING</p><p>end=delete USER_COUNTING</p><p>ptype=RegExp</p><p>pattern=3_SSH_LOGIN_FAILURES_FOR_(&#92;S+)</p><p>context=!USER_$1_COUNTED</p><p>count=alias USER_COUNTING USER_$1_COUNTED</p><p>desc=Repeated SSH login failures for 30 distinct users within 1m</p><p>action=pipe '%s' /bin/mail -s 'SSH login alert' root@localhost</p><p>window=60</p><p>thresh=30</p><p>The first rule looks almost identical to the rule from the previous example, but its <em>action</em> field is different -- after three SSH login failures have been observed for the same user name within one minute by an event correlation operation, the operation will emit the synthetic event 3_SSH_LOGIN_FAILURES_FOR_&lt;username&gt;. Although synthetic events are created by SEC, they are treated like regular events received from input sources and are matched against rules. The regular expression pattern of the second rule will match the 3_SSH_LOGIN_FAILURES_FOR_&lt;username&gt; event and start a new event correlation operation if no such events have been previously seen. When the operation is initialized, the context USER_COUNTING is created, and when the operation finishes, this context is deleted (as specified by the <em>init</em> and <em>end</em> fields). Also, each time a synthetic event for some user name has matched the rule, a context alias for that user name is created (see the <em>count</em> field). Note that this prevents further matches for the same user name, since a synthetic event for &lt;username&gt; can match the rule only if the context alias USER_&lt;username&gt;_COUNTED *does not* exist (as requested by the <em>context</em> field; see CONTEXTS AND CONTEXT EXPRESSIONS section for more information). The operation started by the rule sends an e-mail warning to the local root-user if 30 synthetic events have been observed within 1 minute (see the <em>thresh</em> and <em>window</em> fields). Note that due to the use of the USER_&lt;username&gt;_COUNTED aliases, all synthetic events concern different user names. After sending an e-mail warning, the operation will continue to run until the 1 minute event correlation window expires. When the operation finishes, the deletion of the USER_COUNTING context also erases the USER_&lt;username&gt;_COUNTED aliases.</p><p>The above examples have presented the event correlation capabilities of SEC in a very brief fashion. The following sections will provide an in-depth  discussion of SEC features.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>--conf=&lt;file_pattern&gt;</strong></p>
  </dt>
  <dd>
    <p>expand &lt;file_pattern&gt; to filenames (with the Perl <strong>glob</strong>() function) and read event correlation rules from every file. Multiple <strong>--conf</strong> options can be specified at command line. Each time SEC receives a signal that forces a configuration reload, &lt;file_pattern&gt; is re-evaluated. See also INPUT PROCESSING AND TIMING section for a discussion on rule processing order for multiple configuration files.</p>
  </dd>
  <dt>
    <p><strong>--input=&lt;file_pattern&gt;[=&lt;context&gt;]</strong></p>
  </dt>
  <dd>
    <p>expand &lt;file_pattern&gt; to filenames (with the Perl <strong>glob</strong>() function) and use the files as input sources. An input file can be a regular file, named pipe, or standard input if <strong>-</strong> was specified. Multiple <strong>--input</strong> options can be specified at command line. Each time SEC receives the <strong>SIGHUP</strong> or <strong>SIGABRT</strong> signal, &lt;file_pattern&gt; is re-evaluated. If SEC experiences a system error when reading from an input file, it will close the file (use the <strong>--reopen-timeout</strong> option for reopening the file). If &lt;context&gt; is given, SEC will set up the context &lt;context&gt; each time it reads a line from input files that correspond to &lt;file_pattern&gt;. This will help the user to write rules that match data from particular input source(s) only. When there is an <strong>--input</strong> option with &lt;context&gt; specified, it will automatically enable the <strong>--intcontexts</strong> option. See INTERNAL EVENTS AND CONTEXTS section for more information.</p>
  </dd>
  <dt>
    <p><strong>--input-timeout=&lt;input_timeout&gt;</strong>, <strong>--timeout-script=&lt;timeout_script&gt;</strong></p>
  </dt>
  <dd>
    <p>if SEC has not observed new data in an input file during &lt;input_timeout&gt; seconds (or the file was closed &lt;input_timeout&gt; seconds ago), &lt;timeout_script&gt; will be executed with command line parameters 1 and &lt;the name of the input file&gt;. If fresh data become available again, &lt;timeout_script&gt; will be executed with command line parameters 0 and &lt;the name of the input file&gt;. Note that <strong>--input_timeout</strong> and <strong>--timeout_script</strong> options can be used as synonyms for <strong>--input-timeout</strong> and <strong>--timeout-script</strong>, respectively.</p>
  </dd>
  <dt>
    <p><strong>--reopen-timeout=&lt;reopen_timeout&gt;</strong></p>
  </dt>
  <dd>
    <p>if an input file is in the closed state (e.g., SEC fails to open the file at startup, because it has not been created yet), SEC will attempt to reopen the file after every &lt;reopen_timeout&gt; seconds until open succeeds. This option has no meaning when the <strong>--notail</strong> option is also specified. Note that <strong>--reopen_timeout</strong> is a synonym for <strong>--reopen-timeout</strong>.</p>
  </dd>
  <dt>
    <p><strong>--check-timeout=&lt;check_timeout&gt;</strong></p>
  </dt>
  <dd>
    <p>if SEC has not observed new data in an input file, the file will not be polled (both for status and data) during the next &lt;check_timeout&gt; seconds. Note that <strong>--check_timeout</strong> is a synonym for <strong>--check-timeout</strong>.</p>
  </dd>
  <dt>
    <p><strong>--poll-timeout=&lt;poll_timeout&gt;</strong></p>
  </dt>
  <dd>
    <p>a real number that specifies how many seconds SEC will sleep when no new data were read from input files. Default is 0.1 seconds. Note that <strong>--poll_timeout</strong> is a synonym for <strong>--poll-timeout</strong>.</p>
  </dd>
  <dt>
    <p><strong>--socket-timeout=&lt;socket_timeout&gt;</strong></p>
  </dt>
  <dd>
    <p>if a network connection to a remote peer can't be established within &lt;socket_timeout&gt; seconds, give up. Default is 60 seconds. Note that <strong>--socket_timeout</strong> is a synonym for <strong>--socket-timeout</strong>.</p>
  </dd>
  <dt>
    <p><strong>--blocksize=&lt;io_block_size&gt;</strong></p>
  </dt>
  <dd>
    <p>the number of bytes SEC will attempt to read at once from an input file. Default is 1024 (i.e., read from input files by 1KB blocks).</p>
  </dd>
  <dt>
    <p><strong>--bufsize=&lt;input_buffer_size&gt;</strong></p>
  </dt>
  <dd>
    <p>set all input buffers to hold last &lt;input_buffer_size&gt; lines. The content of input buffers will be compared with patterns that are part of rule definitions (i.e., no more than &lt;input_buffer_size&gt; lines can be matched by a pattern at a time). Default buffer size is 10 lines.</p>
  </dd>
  <dt>
    <p><strong>--evstoresize=&lt;event_store_size&gt;</strong></p>
  </dt>
  <dd>
    <p>set an upper limit to the number of events in context event stores.</p>
  </dd>
  <dt>
    <p><strong>--cleantime=&lt;clean_time&gt;</strong></p>
  </dt>
  <dd>
    <p>time interval in seconds that specifies how often internal event correlation and context lists are processed, in order to accomplish time-related tasks and to remove obsolete elements. See INPUT PROCESSING AND TIMING section for more information. Default is 1 second.</p>
  </dd>
  <dt>
    <p><strong>--log=&lt;logfile&gt;</strong></p>
  </dt>
  <dd>
    <p>use &lt;logfile&gt; for logging SEC activities. Note that if the SEC standard error is connected to a terminal, messages will also be logged there, in order to facilitate debugging.</p>
  </dd>
  <dt>
    <p><strong>--syslog=&lt;facility&gt;</strong></p>
  </dt>
  <dd>
    <p>use syslog for logging SEC activities. All messages will be logged with the facility &lt;facility&gt;, e.g., <em>local0</em> (see <a href="../man3/syslog.3.html"><strong>syslog</strong>(3)</a> for possible facility values). Warning: be careful with using this option if SEC is employed for monitoring syslog logfiles, because message loops might occur.</p>
  </dd>
  <dt>
    <p><strong>--debug=&lt;debuglevel&gt;</strong></p>
  </dt>
  <dd>
    <p>set logging verbosity for SEC. Setting debuglevel to &lt;debuglevel&gt; means that all messages of level &lt;debuglevel&gt; and lower are logged (e.g., if &lt;debuglevel&gt; is 3, messages from levels 1-3 are logged). The following levels are recognized by SEC:</p><p>1 - critical messages (severe faults that cause SEC to terminate, e.g., a failed system call)</p><p>2 - error messages (faults that need attention, e.g., an incorrect rule definition in a configuration file)</p><p>3 - warning messages (possible faults, e.g., a command forked from SEC terminated with a non-zero exit code)</p><p>4 - notification messages (normal system level events and interrupts, e.g., the reception of a signal)</p><p>5 - informative messages (information about external programs forked from SEC)</p><p>6 - debug messages (detailed information about all SEC activities)</p><p>Default &lt;debuglevel&gt; is 6 (i.e., log everything). See SIGNALS section for information on how to change &lt;debuglevel&gt; at runtime.</p>
  </dd>
  <dt>
    <p><strong>--pid=&lt;pidfile&gt;</strong></p>
  </dt>
  <dd>
    <p>SEC will store its process ID to &lt;pidfile&gt; at startup.</p>
  </dd>
  <dt>
    <p><strong>--dump=&lt;dumpfile&gt;</strong></p>
  </dt>
  <dd>
    <p>SEC will use &lt;dumpfile&gt; as its dumpfile. See SIGNALS section for more information. Default is /tmp/sec.dump.</p>
  </dd>
  <dt>
    <p><strong>--quoting</strong>, <strong>--noquoting</strong></p>
  </dt>
  <dd>
    <p>if the <strong>--quoting</strong> option is specified, operation description strings that are supplied to command lines of <em>shellcmd</em>, <em>spawn</em>, and <em>cspawn</em> actions will be put inside apostrophes. All apostrophes ' that strings originally contain will be masked. This option prevents the shell from interpreting special symbols that operation description strings might contain. Default is <strong>--noquoting</strong>.</p>
  </dd>
  <dt>
    <p><strong>--tail</strong>, <strong>--notail</strong></p>
  </dt>
  <dd>
    <p>if the <strong>--notail</strong> option is specified, SEC will process all data that are currently available in input files and exit after reaching all EOFs. If all input is received from a pipe and the <strong>--notail</strong> option is given, SEC terminates when the last writer closes the pipe (EOF condition). Please note that with named pipes <strong>--notail</strong> should be used with <strong>--norwfifo</strong>. With the <strong>--tail</strong> option, SEC will jump to the end of input files and wait for new lines to arrive. Each input file is tracked both by its name and i-node, and input file rotations are handled seamlessly. If the input file is recreated or truncated, SEC will reopen it and process its content from the beginning. If the input file is removed (i.e., there is just an i-node left without a name), SEC will keep the i-node open and wait for the input file recreation. Default is <strong>--tail</strong>.</p>
  </dd>
  <dt>
    <p><strong>--fromstart</strong>, <strong>--nofromstart</strong></p>
  </dt>
  <dd>
    <p>these flags have no meaning when the <strong>--notail</strong> option is also specified. When used in combination with <strong>--tail</strong> (or alone, since <strong>--tail</strong> is enabled by default), <strong>--fromstart</strong> will force SEC to read and process input files from the beginning to the end, before the 'tail' mode is entered. Default is <strong>--nofromstart</strong>.</p>
  </dd>
  <dt>
    <p><strong>--detach</strong>, <strong>--nodetach</strong></p>
  </dt>
  <dd>
    <p>if the <strong>--detach</strong> option is specified, SEC will disassociate itself from the controlling terminal and become a daemon at startup (note that SEC will close its standard input, standard output, and standard error, and change its working directory to the root directory). Default is <strong>--nodetach</strong>.</p>
  </dd>
  <dt>
    <p><strong>--jointbuf</strong>, <strong>--nojointbuf</strong></p>
  </dt>
  <dd>
    <p>if the <strong>--jointbuf</strong> option is specified, SEC uses joint input buffer for all input sources (the size of the buffer is set with the <strong>--bufsize</strong> option). The <strong>--nojointbuf</strong> option creates a separate input buffer for each input file, and a separate buffer for all synthetic and internal events (the sizes of all buffers are set with the <strong>--bufsize</strong> option). The <strong>--jointbuf</strong> option allows multiline patterns to match lines from several input sources, while the <strong>--nojointbuf</strong> pattern restricts the matching to lines from one input source only. See INPUT PROCESSING AND TIMING section for more information. Default is <strong>--jointbuf</strong>.</p>
  </dd>
  <dt>
    <p><strong>--keepopen</strong>, <strong>--nokeepopen</strong></p>
  </dt>
  <dd>
    <p>if the <strong>--keepopen</strong> option is specified, SEC will keep input files open across soft restarts. When the <strong>SIGABRT</strong> signal is received, SEC will not reopen input files which have been opened previously, but will only open input files which are in the closed state. The <strong>--nokeepopen</strong> option forces SEC to close and (re)open all input files during soft restarts. Default is <strong>--nokeepopen</strong>.</p>
  </dd>
  <dt>
    <p><strong>--rwfifo</strong>, <strong>--norwfifo</strong></p>
  </dt>
  <dd>
    <p>if the <strong>--norwfifo</strong> option is specified, named pipe input files are opened in read-only mode. In this mode, the named pipe has to be reopened when the last writer closes the pipe, in order to clear the EOF condition on the pipe. With the <strong>--rwfifo</strong> option, named pipe input files are opened in read-write mode, although SEC never writes to the pipes. In this mode, the pipe does not need to be reopened when an external writer closes it, since there is always at least one writer on the pipe and EOF will never appear. Therefore, if the <strong>--notail</strong> option has been given, <strong>--norwfifo</strong> should also be specified. Default is <strong>--rwfifo</strong>.</p>
  </dd>
  <dt>
    <p><strong>--childterm</strong>, <strong>--nochildterm</strong></p>
  </dt>
  <dd>
    <p>if the <strong>--childterm</strong> option is specified, SEC will send the SIGTERM signal to all its child processes when it terminates or goes through a full restart. Default is <strong>--childterm</strong>.</p>
  </dd>
  <dt>
    <p><strong>--intevents</strong>, <strong>--nointevents</strong></p>
  </dt>
  <dd>
    <p>SEC will generate internal events when it starts up, when it receives certain signals, and when it terminates gracefully. Specific rules can be written to match those internal events, in order to accomplish special tasks at SEC startup, restart, and shutdown. See INTERNAL EVENTS AND CONTEXTS section for more information. Default is <strong>--nointevents</strong>.</p>
  </dd>
  <dt>
    <p><strong>--intcontexts</strong>, <strong>--nointcontexts</strong></p>
  </dt>
  <dd>
    <p>SEC will create an internal context when it reads a line from an input file. This will help the user to write rules that match data from particular input source only. See INTERNAL EVENTS AND CONTEXTS section for more information. Default is <strong>--nointcontexts</strong>.</p>
  </dd>
  <dt>
    <p><strong>--testonly</strong>, <strong>--notestonly</strong></p>
  </dt>
  <dd>
    <p>if the <strong>--testonly</strong> option is specified, SEC will exit immediately after parsing the configuration file(s). If the configuration file(s) contained no faulty rules, SEC will exit with 0, otherwise with 1. Default is <strong>--notestonly</strong>.</p>
  </dd>
  <dt>
    <p><strong>--help</strong>, <strong>-?</strong></p>
  </dt>
  <dd>
    <p>SEC will output usage information and exit.</p>
  </dd>
  <dt>
    <p><strong>--version</strong></p>
  </dt>
  <dd>
    <p>SEC will output version information and exit.</p>
  </dd>

</dl>
<p>Note that options can be introduced both with the single dash (-) and double dash (--), and both the equal sign (=) and whitespace can be used for separating the option name from the option value. For example, <strong>-conf=&lt;file_pattern&gt;</strong> and <strong>--conf &lt;file_pattern&gt;</strong> options are equivalent.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONFIGURATION FILES</h2>
        <div class="sectioncontent">
<p>Each SEC configuration file consists of rule definitions which are separated by empty lines, whitespace lines and/or comment lines. Each rule definition consists of keyword=value fields, one keyword and value per line. Values are case insensitive only where character case is not important (like the values specifying rule types, e.g., 'Single' and 'single' are treated identically). The backslash character (&#92;) may be used at the end of a line to continue the current rule field in the next line. Lines which begin with the number sign (#) are treated as comments and ignored (whitespace characters may precede #). Any comment line, empty line, whitespace line, or end of file will terminate the preceding rule definition. For inserting comments into rule definitions, the <em>rem</em> keyword can be used. For example, the following lines define two rules:</p><p>type=Single</p><p>rem=this rule matches any line which contains &#92;</p>
<pre>
    three consecutive A characters and writes the string &#92;
    "three A characters were observed" to standard output
</pre>
<p>ptype=SubStr</p><p>pattern=AAA</p><p>desc=Three A characters</p><p>action=write - three A characters were observed</p><p># This comment line ends preceding rule definition.</p><p># The following rule works like the previous rule,</p><p># but looks for three consecutive B characters and</p><p># writes the string "three B characters were observed"</p><p># to standard output</p><p>type=Single</p><p>ptype=SubStr</p><p>pattern=BBB</p><p>desc=Three B characters</p><p>action=write - three B characters were observed</p><p>Apart from keywords that are part of rule definitions, <em>label</em> keywords may appear anywhere in the configuration file. The value of each <em>label</em> keyword will be treated as a label that can be referred to in rule definitions as a point-of-continue. This allows for continuing event processing at a rule that follows the label, after the current rule has matched and processed the event.</p><p>The points-of-continue are defined with <em>continue*</em> fields. Accepted values for these fields are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>TakeNext</em></p>
  </dt>
  <dd>
    <p>after an event has matched the rule, search for matching rules in the configuration file will continue from the next rule.</p>
  </dd>
  <dt>
    <p><em>GoTo &lt;label&gt;</em></p>
  </dt>
  <dd>
    <p>after an event has matched the rule, search for matching rules will continue from the location of &lt;label&gt; in the configuration file (&lt;label&gt; must be defined with the <em>label</em> keyword anywhere in the configuration file *after* the current rule definition).</p>
  </dd>
  <dt>
    <p><em>DontCont</em> (default value)</p>
  </dt>
  <dd>
    <p>after an event has matched the rule, search for matching rules ends in the *current* configuration file.</p>
  </dd>
  <dt>
    <p><em>EndMatch</em></p>
  </dt>
  <dd>
    <p>after an event has matched the rule, search for matching rules ends for *all* configuration files.</p>
  </dd>

</dl>
<p>SEC rules from the same configuration file are matched against input in the order they have been given in the file. For example, consider a configuration file which contains the following rule sequence:</p><p>type=Single</p><p>ptype=SubStr</p><p>pattern=AAA</p><p>rem=after this rule has matched, continue from last rule</p><p>continue=GoTo lastRule</p><p>desc=Three A characters</p><p>action=write - three A characters were observed</p><p>type=Single</p><p>ptype=SubStr</p><p>pattern=BBB</p><p>rem=after this rule has matched, don't consider following rules, &#92;</p>
<pre>
    since 'continue' defaults to 'DontCont'
</pre>
<p>desc=Three B characters</p><p>action=write - three B characters were observed</p><p>type=Single</p><p>ptype=SubStr</p><p>pattern=CCC</p><p>rem=after this rule has matched, continue from next rule</p><p>continue=TakeNext</p><p>desc=Three C characters</p><p>action=write - three C characters were observed</p><p>label=lastRule</p><p>type=Single</p><p>ptype=SubStr</p><p>pattern=DDD</p><p>desc=Three D characters</p><p>action=write - three D characters were observed</p><p>For the input line "AAABBBCCCDDD", this ruleset writes strings "three A characters were observed" and "three D characters were observed" to standard output. If the input line is "BBBCCCDDD", the string "three B characters were observed" is written to standard output. For the input line "CCCDDD", strings "three C characters were observed" and "three D characters were observed" are sent to standard output, while the input line "DDD" produces the output string "three D characters were observed".</p><p>If there are two or more configuration files, rule sequence from every file is matched against input (unless explicitly specified otherwise). For example, suppose SEC is started with the command line</p><p>/usr/bin/sec --input=- &#92;</p>
<pre>
             --conf=/etc/sec/sec1.rules --conf=/etc/sec/sec2.rules
</pre>
<p>and the configuration file /etc/sec/sec1.rules has the following content:</p><p>type=Single</p><p>ptype=SubStr</p><p>pattern=AAA</p><p>desc=Three A characters</p><p>action=write - three A characters were observed</p><p>type=Single</p><p>ptype=SubStr</p><p>pattern=BBB</p><p>continue=EndMatch</p><p>desc=Three B characters</p><p>action=write - three B characters were observed</p><p>Also, suppose the  configuration file /etc/sec/sec2.rules has the following content:</p><p>type=Single</p><p>ptype=SubStr</p><p>pattern=CCC</p><p>desc=Three C characters</p><p>action=write - three C characters were observed</p><p>If SEC receives the line "AAABBBCCC" from standard input, rules from both configuration files are tried, and as a result, the strings "three A characters were observed" and "three C characters were observed" are written to standard output. Note that rules from /etc/sec/sec1.rules are tried first against the input line, since the option <strong>--conf=/etc/sec/sec1.rules</strong> is given before <strong>--conf=/etc/sec/sec2.rules</strong> in the SEC command line (see also INPUT PROCESSING AND TIMING section for a more detailed discussion). If SEC receives the line "BBBCCC" from standard input, the second rule from /etc/sec/sec1.rules produces a match, and the string "three B characters were observed" is written to standard output. Since the rule contains <em>continue=EndMatch</em> statement, the search for matching rules will end for all configuration files, and rules from /etc/sec/sec2.rules will not be not tried. Without this statement, the search for matching rules would continue in /etc/sec/sec2.rules, and the first rule would write the string "three C characters were observed" to standard output.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PATTERNS, PATTERN TYPES AND MATCH VARIABLES</h2>
        <div class="sectioncontent">
<p>Patterns and pattern types are defined with <em>pattern*</em> and <em>ptype*</em> rule fields. Many pattern types define the number of lines <em>N</em> which the pattern matches (if <em>N</em> is omitted, 1 is assumed). If <em>N</em> is greater than 1, the scope of matching is set with the <strong>--jointbuf</strong> and <strong>--nojointbuf</strong> options. With <strong>--jointbuf</strong>, the pattern is used for matching <em>N</em> last input lines taken from the joint input buffer (the lines can come from different input sources). With <strong>--nojointbuf</strong>, the source of the last input line is identified, and the pattern is matched with <em>N</em> last input lines from the input buffer of the identified source.</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>SubStr[N]</em></p>
  </dt>
  <dd>
    <p>pattern is a string that is searched in the last N input lines L1, L2, ..., LN. If N is greater than 1, the input lines are joined into a string "L1&lt;NEWLINE&gt;L2&lt;NEWLINE&gt;...&lt;NEWLINE&gt;LN", and the pattern string will be searched from it. If the pattern string is found in input line(s), the pattern matches. Backslash sequences &#92;t, &#92;n, &#92;r, &#92;s, and &#92;0 can be used in the pattern for denoting tabulation, newline, carriage return, space character, and empty string, respectively, while &#92;nbsp;denotes backslash itself. For example, consider the following pattern definition:</p><p>ptype=substr</p><p>pattern=Backup done:&#92;tsuccess</p><p>The pattern matches lines containing "Backup done:&lt;TAB&gt;success".</p>
  </dd>
  <dt>
    <p><em>RegExp[N]</em></p>
  </dt>
  <dd>
    <p>pattern is a Perl regular expression (see <strong>perlre</strong>(1) for more information) for matching the last N input lines L1, L2, ..., LN. If N is greater than 1, the input lines are joined into a string "L1&lt;NEWLINE&gt;L2&lt;NEWLINE&gt;...&lt;NEWLINE&gt;LN", and the regular expression is matched with this string. If the regular expression matches, match variables will be set, and these match variables can be used in other parts of the rule definition.</p><p>In addition to numbered match variables ($1, $2, etc.), SEC supports named match variables $+{name} and the $0 variable. The $0 variable holds the entire string of last N input lines that the regular expression has matched. Named match variables can be created in newer versions of Perl regular expression language, e.g., (?&lt;myvar&gt;AB|CD) sets $+{myvar} to AB or CD. The special named match variable $+{_inputsrc} is created by SEC and holds input file name(s) where matching line(s) came from.</p><p>For example, the following pattern matches the SSH "Connection from" event, and sets $0 to the entire event line, both $1 and $+{ip} to the IP address of the remote node, $2 to the port number at the remote node, and $+{_inputsrc} to the input file name:</p><p>ptype=RegExp</p><p>pattern=sshd&#92;[&#92;d+&#92;]: Connection from (?&lt;ip&gt;[&#92;d.]+) port (&#92;d+)</p><p>Also, SEC allows for match caching and for the creation of additional named match variables through variable maps which are defined with the <em>varmap*</em> fields. Variable map is a list of <em>name=number</em> mappings separated by semicolons, where <em>name</em> is the name for the named variable and <em>number</em> identifies a numbered match variable that is set by the regular expression. Each name must begin with a letter and consist of letters, digits and underscores. After the regular expression has matched, named variables specified by the map are created from corresponding numbered variables. If the same named variable is set up both from the regular expression and variable map, the map takes precedence.</p><p>If <em>name</em> is not followed by the equal sign and number in the <em>varmap*</em> field, it is regarded as a common name for all match variables and their values from a successful match. This name is used for caching a successful match by the pattern -- match variables and their values are stored in the memory-based pattern match cache under <em>name</em>. Cached match results can be reused by <em>Cached</em> and <em>NCached</em> patterns. Note that before processing each new input line, previous content of the pattern match cache is cleared. Also note that a successful pattern match is cached even if the subsequent context expression evaluation yields FALSE (see INPUT PROCESSING AND TIMING section for more information).</p><p>For example, consider the following pattern definition:</p><p>ptype=regexp</p><p>pattern=(?i)(&#92;S+&#92;.mydomain).*printer: toner&#92;/ink low</p><p>varmap=printer_toner_or_ink_low; message=0; hostname=1</p><p>The pattern matches "printer: toner/ink low" messages in a case insensitive manner from printers belonging to .mydomain. Note that the printer hostname is assigned to $1 and $+{hostname}, while the whole message line is assigned to $0 and $+{message}. The name of the file where message line came from is assigned to $+{_inputsrc}. Also, these variables and their values are stored to the pattern match cache under the name "printer_toner_or_ink_low".</p><p>The following pattern definition produces a match if the last two input lines are AAA and BBB:</p><p>ptype=regexp2</p><p>pattern=^AAA&#92;nBBB$</p><p>varmap=aaa_bbb</p><p>Note that with the <strong>--nojointbuf</strong> option the pattern only matches if the matching lines are coming from the *same* input file, while the <strong>--jointbuf</strong> option lifts that restriction.</p><p>In the case of a match, $0 is set to "AAA&lt;NEWLINE&gt;BBB" and $+{_inputsrc} to file name(s) for matching lines. Also, these variable-value pairs are cached under the name "aaa_bbb".</p>
  </dd>
  <dt>
    <p><em>PerlFunc[N]</em></p>
  </dt>
  <dd>
    <p>pattern is a Perl function for matching the last N input lines L1, L2, ..., LN. The Perl function is compiled at SEC startup with the Perl <strong>eval</strong>() function, and <strong>eval</strong>() must return a code reference for the pattern to be valid (see also PERL INTEGRATION section). In order to check whether the pattern matches input line(s), SEC will call the function in list context and pass lines L1, L2, ..., LN and the names of corresponding input files F1, F2, ..., FN to the function as parameters:</p><p>function(L1, L2, ..., LN, F1, F2, ..., FN)</p><p>Note that with the <strong>--nojointbuf</strong> option, the function is called with a single file name parameter F, since lines L1, ..., LN are coming from the same input file:</p><p>function(L1, L2, ..., LN, F)</p><p>Also note that if the input line is a synthetic event, the input file name is Perl undefined value.</p><p>If the function returns several values or a single value that is true in Perl boolean context, the pattern matches. If the function returns no values or a single value that is false in Perl boolean context (0, empty string or undefined value), the pattern does not match. If the pattern matches, return values will be assigned to numbered match variables ($1, $2, etc.). Like with RegExp patterns, the $0 variable is set to matching input line(s), the $+{_inputsrc} variable is set to input file name(s), and named match variables can be created from variable maps. For example, consider the following pattern definition:</p><p>ptype=perlfunc2</p><p>pattern=sub { return ($_[0] cmp $_[1]); }</p><p>The pattern compares last two input lines in a stringwise manner ($_[1] holds the last line and $_[0] the preceding one), and matches if the lines are different. Note that the result of the comparison is assigned to $1, while two matching lines are concatenated (with the newline character between them) and assigned to $0. The file name(s) for matching lines are assigned to $+{_inputsrc}.</p><p>The following pattern produces a match for any line, and sets $1, $2 and $3 variables to strings "abc", "def" and "ghi", respectively (also, $0 is set to the whole input line and $+{_inputsrc} to the input file name):</p><p>ptype=perlfunc</p><p>pattern=sub { return ("abc", "def", "ghi"); }</p><p>The following pattern definition produces a match if the input line is not a synthetic event and contains either the string "abc" or "def". The $0 variable is set to the matching line, while $1, $+{file} and $+{_inputsrc} are set to the name of the input file:</p><p>ptype=perlfunc</p><p>pattern=sub { if (defined($_[1]) && $_[0] =~ /abc|def/) &#92;</p><p>{ return $_[1]; } return 0; }</p><p>varmap= file=1</p><p>Finally, if a function pattern returns a single value which is a reference to a Perl hash, named match variables are created from key-value pairs in the hash. For example, the following pattern matches a line if it contains either the string "three" or "four". Apart from setting $0 and $+{_inputsrc}, the pattern also creates match variables $+{three} and $+{four}, and sets them to 3 and 4, respectively:</p><p>ptype=perlfunc</p><p>pattern=sub { my(%hash); &#92;</p><p>if ($_[0] !~ /three|four/) { return 0; } &#92;</p><p>$hash{"three"} = 3; $hash{"four"} = 4; return \hash; }</p>
  </dd>
  <dt>
    <p><em>Cached</em></p>
  </dt>
  <dd>
    <p>pattern is a name that is searched in the pattern match cache (entries are stored into the cache with the <em>varmap*</em> fields). If an entry with the given name is found in the cache, the pattern matches, and match variables and values are retrieved from the cache. For example, if the input line matches the following pattern</p><p>ptype=perlfunc</p><p>pattern=sub { if (defined($_[1]) && $_[0] =~ /abc|def/) &#92;</p><p>{ return $_[1]; } return 0; }</p><p>varmap=abc_or_def_found; file=1</p><p>then the entry "abc_or_def_found" is created in the pattern match cache. Therefore, the pattern</p><p>ptype=cached</p><p>pattern=abc_or_def_found</p><p>will also produce a match for this input line, and set the $0, $1, $+{file}, and $+{_inputsrc} variables to values from the previous match.</p>
  </dd>
  <dt>
    <p><em>NSubStr[N]</em></p>
  </dt>
  <dd>
    <p>like <em>SubStr[N]</em>, except that the result of the match is negated.</p>
  </dd>
  <dt>
    <p><em>NRegExp[N]</em></p>
  </dt>
  <dd>
    <p>like <em>RegExp[N]</em>, except that the result of the match is negated and variable maps are not supported. Note that the only match variables set by the pattern are $0 and $+{_inputsrc}.</p>
  </dd>
  <dt>
    <p><em>NPerlFunc[N]</em></p>
  </dt>
  <dd>
    <p>like <em>PerlFunc[N]</em>, except that the result of the match is negated and variable maps are not supported. Note that the only match variables set by the pattern are $0 and $+{_inputsrc}.</p>
  </dd>
  <dt>
    <p><em>NCached</em></p>
  </dt>
  <dd>
    <p>like <em>Cached</em>, except that the result of the match is negated.</p>
  </dd>
  <dt>
    <p><em>TValue</em></p>
  </dt>
  <dd>
    <p>pattern is a truth value, with TRUE and FALSE being legitimate values. TRUE always matches an input line, while FALSE never matches anything.</p>
  </dd>

</dl>
<p>When match variables are substituted, each "$$" sequence is interpreted as a literal dollar sign ($) which allows for masking match variables. For example, the string "Received $$1" becomes "Received $1" after substitution, while "Received $$$1" becomes "Received $&lt;value_of_1st_var&gt;". In order to disambiguate numbered match variables from the following text, variable number must be enclosed in braces. For example, the string "Received ${1}0" becomes "Received &lt;value_of_1st_var&gt;0" after substitution, while the string "Received $10" would become "Received &lt;value_of_10th_var&gt;".</p><p>If the match variable was not set by the pattern, it is substituted with an empty string (i.e., a zero-width string). Thus the string "Received $10!" becomes "Received !" after substitution if the pattern did not set $10. (Note that prior to SEC-2.6, unset variables were *not* substituted.)</p><p>In the current version of SEC, names of $+{name} match variables must comply with the following naming convention -- the first character can be a letter or underscore, while remaining characters can be letters, digits, underscores and exclamation marks (!). However, when setting named match variables from a pattern, it is recommended to begin the variable name with a letter, since names of special automatically created variables begin with an underscore (e.g., $+{_inputsrc}).</p><p>After the pattern has matched an event and match variables have been set, it is also possible to refer to previously cached match variables with the syntax <em>$:{entryname:varname}</em>, where <em>entryname</em> is the name of the pattern match cache entry, and <em>varname</em> is the name of the variable stored under the entry. For example, if the variable $+{ip} has been previously cached under the entry "SSH", it can be referred as $:{SSH:ip}. For the reasons of efficiency, the $:{entryname:varname} syntax is not supported for fast pattern types which do not set match variables (i.e., SubStr, NSubStr and TValue).</p><p>Note that since Pair and PairWithWindow rules have two patterns, match variables of the first pattern are shadowed for some rule fields when the second pattern matches and sets variables. In order to refer to shadowed variables, their names must begin with % instead of $ (e.g., %1 refers to match variable $1 set by the first pattern). However, the use of the %-prefix is only valid under the following circumstances -- *both* pattern types support match variables *and* in the given rule field match variables from *both* patterns can be used.</p><p>The %-prefixed match variables are masked with the "%%" sequence (like regular match variables with "$$"). Similarly, the braces can be used for disambiguating the %-prefixed variables from the following text.</p><p>Finally, note that the second pattern of Pair and PairWithWindow rules may contain match variables if the second pattern is of type SubStr, NSubStr, Regexp, or NRegExp. The variables are substituted at runtime with the values set by the first pattern. If the pattern is a regular expression, all special characters inside substituted values are masked with the Perl <strong>quotemeta</strong>() function and the final expression is checked for correctness.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONTEXTS AND CONTEXT EXPRESSIONS</h2>
        <div class="sectioncontent">
<p>A SEC context is a memory based entity which has one or more names, a lifetime, and an event store. Also, an action list can be set up for a context which is executed immediately before the context expires.</p><p>For example, the action <em>create MYCONTEXT 3600 (report MYCONTEXT /bin/mail root@localhost)</em> creates the context <strong>MYCONTEXT</strong> which has a lifetime of 3600 seconds and empty event store. Also, immediately before <strong>MYCONTEXT</strong> expires and is dropped from memory, the action <em>report MYCONTEXT /bin/mail root@localhost</em> is executed which mails the event store of <strong>MYCONTEXT</strong> to root@localhost.</p><p>Contexts can be used for event aggregation and reporting. Suppose the following actions are executed in this order:</p><p>create MYCONTEXT</p><p>add MYCONTEXT This is a test</p><p>alias MYCONTEXT MYALIAS</p><p>add MYALIAS This is another test</p><p>report MYCONTEXT /bin/mail root@localhost</p><p>delete MYALIAS</p><p>The first action creates the context <strong>MYCONTEXT</strong> with infinite lifetime and empty event store. The second action appends the string "This is a test" to the event store of <strong>MYCONTEXT</strong>. The third action sets up an alias name <strong>MYALIAS</strong> for the context (names <strong>MYCONTEXT</strong> and <strong>MYALIAS</strong> refer to the same context data structure). The fourth action appends the string "This is another test" to the event store of the context. The fifth action writes the lines</p><p>This is a test</p><p>This is another test</p><p>to the standard input of the <em>/bin/mail root@localhost</em> command. The sixth action deletes the context data structure from memory and drops its names <strong>MYCONTEXT</strong> and <strong>MYALIAS</strong>.</p><p>Since contexts are accessible from all rules and event correlation operations, they can be used for data sharing and joining several rules into one event correlation scheme. In order to check for the presence of contexts from rules, context expressions can be employed.</p><p>Context expressions are boolean expressions that are defined with the <em>context*</em> rule fields. Context expressions can be used for restricting the matches produced by patterns, since if the expression evaluates FALSE, the rule will not match an input event.</p><p>The context expression accepts context names, Perl miniprograms, and Perl functions as operands. These operands can be combined with the following operators:</p><p>!  - logical NOT,</p><p>&&  - short-circuit logical AND,</p><p>||  - short-circuit logical OR.</p><p>In addition, parentheses can be used for grouping purposes.</p><p>If the operand contains the arrow operator (-&gt;), the text following the arrow must be a valid Perl function definition that is compiled at SEC startup with the Perl <strong>eval</strong>() function. The <strong>eval</strong>() must return a code reference (see also PERL INTEGRATION section for more information). If any text precedes the arrow, it is treated as a list of parameters for the function. Parameters must be separated by whitespace and may contain match variables set by pattern(s). In order to evaluate the Perl function operand, the function is called in the Perl scalar context. If the return value of the function is true in the Perl boolean context, the operand evaluates TRUE, otherwise it evaluates FALSE.</p><p>If instead of arrow the :&gt; operator is used, each parameter is treated as a name of an entry in the pattern match cache. In that case, the parameter is passed to the Perl function as a reference to the Perl hash which contains all match variables for the given entry. In the hash, each key-value pair represents some variable name and value, e.g., if cached match variable $+{ip} is holding 10.1.1.1, the hash contains the value <strong>10.1.1.1</strong> with the key <strong>ip</strong>.</p><p>If the operand begins with the equal sign (=), the following text must be a Perl miniprogram which is a valid parameter for the Perl <strong>eval</strong>() function. The miniprogram may contain match variables set by the pattern(s). In order to evaluate the Perl miniprogram operand, it will be compiled and executed by calling the Perl <strong>eval</strong>() function in the Perl scalar context (see also PERL INTEGRATION section). If the return value from <strong>eval</strong>() is true in the Perl boolean context, the operand evaluates TRUE, otherwise it evaluates FALSE.</p><p>Note that since Perl functions, miniprograms, and parameter lists may contain strings that clash with context expression operators (e.g., '!'), it is strongly recommended to enclose them in parentheses, e.g.,</p><p>($1 $2) -&gt; (sub { return ($_[0] != $_[1]); })</p><p>=({my($temp) = 0; return !$temp;})</p><p>If the <em>varset</em> keyword precedes the operand, it is treated as a name of an entry in the pattern match cache. The operand evaluates TRUE if the given entry exists, and FALSE otherwise.</p><p>If the operand is not a Perl function or miniprogram, it is treated as a context name. As other operands, context names may contain match variables. If the context name refers to an existing context, the operand evaluates TRUE, otherwise it evaluates FALSE.</p><p>If the whole context expression is enclosed in square brackets [], e.g., [<strong>MYCONTEXT1</strong> && !<strong>MYCONTEXT2</strong>], SEC evaluates the expression *before* pattern matching (normally, the pattern is matched with input line(s) first, so that match variables would be initialized and ready for expression evaluation). However, if the expression does not contain match variables and many input events are known to match the pattern but not the expression, the []-operator could save substantial amount of CPU time.</p><p>In order to illustrate the discussion, consider the context expressions below. The following expression evaluates TRUE if the /var/log/messages file does not exist or was last modified more than 1 hour ago:</p><p>-&gt; ( sub { my(@stat) = stat("/var/log/messages"); &#92;</p><p>return (!scalar(@stat) || time() - $stat[9] &gt; 3600); } )</p><p>The following expression evaluates TRUE if the values of $1 and $2 match variables are numerically unequal and the context <strong>C1</strong> exists:</p><p>($1 $2) -&gt; (sub { return ($_[0] != $_[1]); }) && C1</p><p>The following expression evaluates TRUE when neither the context <strong>C1</strong> nor the context <strong>C2</strong> exists and the value of $1 the variable equals to the string "myhost.mydomain". Note that since && is a short-circuiting operator, the Perl code is not evaluated if <strong>C1</strong> and/or <strong>C2</strong> exist:</p><p>!(C1 || C2) && =("$1" eq "myhost.mydomain")</p><p>The following expression evaluates true if the pattern match cache entry <strong>SSH</strong> exists and under this entry, the value of the match variable $+{user} equals to the string "risto". Note that inside the Perl function, the first input parameter $_[0] holds a reference to the hash of variable name-value pairs:</p><p>varset SSH && SSH :&gt; ( sub { $_[0]-&gt;{"user"} eq "risto" } )</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ACTIONS, ACTION LISTS AND ACTION LIST VARIABLES</h2>
        <div class="sectioncontent">
<p>Action lists are defined with the <em>action*</em> rule fields. An action list consists of action definitions that are separated by semicolons. Each action definition begins with a keyword specifying the action type. Depending on the action type, parameters may follow, and non-constant parameters may contain match variables. In order to use semicolons inside a non-constant parameter, the parameter must be enclosed in parentheses (the outermost set of parentheses will be removed by SEC during configuration file parsing).</p><p>For example, the following action list consists of <em>delete</em> and <em>shellcmd</em> actions:</p><p>delete MYCONTEXT; shellcmd (rm /tmp/sec1.tmp; rm /tmp/sec2.tmp)</p><p>The <em>delete</em> action deletes the context <strong>MYCONTEXT</strong>, while the <em>shellcmd</em> action executes the command line <em>rm /tmp/sec1.tmp; rm /tmp/sec2.tmp</em>. Since the command line contains a semicolon, it has been enclosed in parentheses, since otherwise the semicolon would be mistakenly considered a separator between two actions.</p><p>Apart from match variables, SEC supports <em>action list variables</em> in action lists which facilitate data sharing between actions and Perl integration. Each action list variable has a name which must begin with a letter and consist of letters, digits and underscores. In order to refer to an action list variable, its name must be prefixed by a percent sign (%). Unlike match variables, action list variables can only be used in action lists and they are substituted with their values immediately before the action list execution. Also, action list variables continue to exist after the current action list has been executed and can be employed in action lists of other rules.</p><p>The following action list variables are predefined by SEC:</p><p>%s - operation description string (the value of the <em>desc</em> field after match variables have been substituted with their values). Note that for the <em>action2</em> field of Pair and PairWithWindow rules, the %s variable is set by evaluating the <em>desc2</em> field of the rule.</p><p>%t - current time in human-readable format (as returned by the <a href="../man1/date.1.html"><strong>date</strong>(1)</a> utility).</p><p>%u - current time in seconds since Epoch (as returned by the <a href="../man2/time.2.html"><strong>time</strong>(2)</a> system call).</p><p>Note that in order to disambiguate the variable from the following text, the variable name must be enclosed in braces (e.g., %{s}). Also, when action list variables are substituted with their values, each sequence "%%" is interpreted as a literal percent sign (%) which allows for masking the variables. For example, the string "s%%t" becomes "s%t" after substitution, not "s%&lt;timestamp&gt;".</p><p>However, note that if %-prefixed match variables are supported for the <em>action2</em> field of the Pair or PairWithWindow rule, the sequence "%%%" must be used in <em>action2</em> for masking a variable, since the string goes through *two* variable substitution rounds (first for %-prefixed match variables and then for action list variables, e.g., the string "s%%%t" first becomes "s%%t" and finally "s%t").</p><p>Whenever a rule field goes through several substitution rounds, the $ or % characters are masked inside values substituted during earlier rounds, in order to avoid unwanted side effects during later rounds.</p><p>If the action list variable has not been set, it is substituted with an empty string (i.e., a zero-width string). Thus the string "Value of A is: %a" becomes "Value of A is: " after substitution if the variable %a is unset. (Note that prior to SEC-2.6, unset variables were *not* substituted.)</p><p>Finally, the values are substituted as strings, therefore values of other types (e.g., references) lose their original meaning, unless explicitly noted otherwise (e.g., if a Perl function reference is stored to an action list variable, the function can later be invoked through this variable with the <em>call</em> action).</p><p>The following actions are supported (optional parameters are enclosed in square brackets):</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>none</em></p>
  </dt>
  <dd>
    <p>No action.</p>
  </dd>
  <dt>
    <p><em>logonly [&lt;string&gt;]</em></p>
  </dt>
  <dd>
    <p>Message &lt;string&gt; is logged to destinations given with the <strong>--log</strong> and <strong>--syslog</strong> options. The level of the log message is set to 4 (see the <strong>--debug</strong> option for more information on log message levels). Default value for &lt;string&gt; is %s.</p>
  </dd>
  <dt>
    <p><em>write &lt;filename&gt; [&lt;string&gt;]</em></p>
  </dt>
  <dd>
    <p>String &lt;string&gt; with a terminating newline is written to the file &lt;filename&gt; (&lt;filename&gt; may not contain whitespace). File may be a regular file, named pipe, or standard output (denoted by <strong>-</strong>). If the file is a regular file, &lt;string&gt; is appended to the end of the file. If the file does not exist, it is created as a regular file before writing. Note that the file will not be closed after the action completes, and the following <em>write</em> actions will access an already open file. However, several signals cause the file to be closed and reopened (see SIGNALS section for more information). Default value for &lt;string&gt; is %s.</p>
  </dd>
  <dt>
    <p><em>owritecl &lt;filename&gt; [&lt;string&gt;]</em></p>
  </dt>
  <dd>
    <p>Similar to the <em>write</em> action, except that the file &lt;filename&gt; is opened and closed at each write. Also, the string &lt;string&gt; is written without a terminating newline. If the file has already been opened by a previous <em>write</em> action, <em>owritecl</em> does not use existing filehandle, but opens and closes the file separately.</p>
  </dd>
  <dt>
    <p><em>udgram &lt;filename&gt; [&lt;string&gt;]</em></p>
  </dt>
  <dd>
    <p>String &lt;string&gt; is written to the UNIX datagram socket &lt;filename&gt; (&lt;filename&gt; may not contain whitespace). Note that the socket will not be closed after the action completes, and the following <em>udgram</em> actions will access an already open socket. However, several signals cause the socket to be closed and reopened (see SIGNALS section for more information). Default value for &lt;string&gt; is %s.</p>
  </dd>
  <dt>
    <p><em>ustream &lt;filename&gt; [&lt;string&gt;]</em></p>
  </dt>
  <dd>
    <p>String &lt;string&gt; is written to the UNIX stream socket &lt;filename&gt; (&lt;filename&gt; may not contain whitespace). Note that the socket will not be closed after the action completes, and the following <em>ustream</em> actions will access an already open socket. However, several signals cause the socket to be closed and reopened (see SIGNALS section for more information). Default value for &lt;string&gt; is %s.</p>
  </dd>
  <dt>
    <p><em>udpsock &lt;host&gt;:&lt;port&gt; [&lt;string&gt;]</em></p>
  </dt>
  <dd>
    <p>String &lt;string&gt; is sent to the UDP port &lt;port&gt; of the host &lt;host&gt;. Note that the UDP socket which is used for communication will not be closed after the action completes, and the following <em>udpsock</em> actions for the same remote peer will use an already existing socket. However, several signals cause the socket to be closed and recreated (see SIGNALS section for more information). Default value for &lt;string&gt; is %s.</p>
  </dd>
  <dt>
    <p><em>tcpsock &lt;host&gt;:&lt;port&gt; [&lt;string&gt;]</em></p>
  </dt>
  <dd>
    <p>String &lt;string&gt; is sent to the TCP port &lt;port&gt; of the host &lt;host&gt;. The timeout value given with the <strong>--socket-timeout</strong> option determines for how many seconds SEC will attempt to establish a connection to the remote peer. If the connection establishment does not succeed immediately, the <em>tcpsock</em> action buffers &lt;string&gt; in memory for later sending to the remote peer. Note that the relevant TCP socket will not be closed after &lt;string&gt; has been transmitted, and the following <em>tcpsock</em> actions for the same peer will use an already existing socket. However, several signals cause the socket to be closed and recreated (see SIGNALS section for more information). Default value for &lt;string&gt; is %s.</p>
  </dd>
  <dt>
    <p><em>shellcmd &lt;cmdline&gt;</em></p>
  </dt>
  <dd>
    <p>Fork a process for executing command line &lt;cmdline&gt;. If the <strong>--quoting</strong> option was specified and &lt;cmdline&gt; contains %s variables, the value of %s is quoted with apostrophes before substituting it into &lt;cmdline&gt;; note if the value of %s contains apostrophes, they are masked with backslashes (e.g., abc is converted to 'abc' and aa'bb is converted to 'aa'&#92;''bb'). For additional information, see INTERPROCESS COMMUNICATION section.</p>
  </dd>
  <dt>
    <p><em>spawn &lt;cmdline&gt;</em></p>
  </dt>
  <dd>
    <p>Similar to the <em>shellcmd</em> action, except that each line from the standard output of &lt;cmdline&gt; becomes a synthetic event and will be treated like a line from input file (see the <em>event</em> action for more information). If the <strong>--intcontexts</strong> command line option is given, internal context _INTERNAL_EVENT is set up before each synthetic event is processed (see INTERNAL EVENTS AND CONTEXTS section for more information).</p>
  </dd>
  <dt>
    <p><em>cspawn &lt;name&gt; &lt;cmdline&gt;</em></p>
  </dt>
  <dd>
    <p>Similar to the <em>spawn</em> action, except that if the <strong>--intcontexts</strong> command line option is given, internal context &lt;name&gt; is set up for each synthetic event.</p>
  </dd>
  <dt>
    <p><em>pipe '[&lt;string&gt;]' [&lt;cmdline&gt;]</em></p>
  </dt>
  <dd>
    <p>Fork a process for executing command line &lt;cmdline&gt;. The string &lt;string&gt; with a terminating newline is written to the standard input of &lt;cmdline&gt; (apostrophes are used for disambiguating &lt;string&gt; from &lt;cmdline&gt;). If &lt;string&gt; contains semicolons, &lt;string&gt; must be enclosed in parentheses (e.g., <em>pipe '($1;$2)' /bin/cat</em>). Default value for &lt;string&gt; is %s. If &lt;cmdline&gt; is omitted, &lt;string&gt; is written to standard output. For additional information, see INTERPROCESS COMMUNICATION section.</p>
  </dd>
  <dt>
    <p><em>create [&lt;name&gt; [&lt;time&gt; [&lt;action list&gt;] ] ]</em></p>
  </dt>
  <dd>
    <p>Create a context with the name &lt;name&gt;, lifetime of &lt;time&gt; seconds, and empty event store. The &lt;name&gt; parameter may not contain whitespace and defaults to %s. The &lt;time&gt; parameter must evaluate to an unsigned integer at runtime. Specifying 0 for &lt;time&gt; or omitting the value means infinite lifetime. If &lt;action list&gt; is given, it will be executed when the context expires. If &lt;action list&gt; contains several actions, the list must be enclosed in parentheses. In &lt;action list&gt;, the internal context name _THIS may be used for referring to the current context (see INTERNAL EVENTS AND CONTEXTS section for a detailed discussion). If an already existing context is recreated with <em>create</em>, its remaining lifetime is set to &lt;time&gt; seconds, its action list is reinitialized, and its event store is emptied.</p>
  </dd>
  <dt>
    <p><em>delete [&lt;name&gt;]</em></p>
  </dt>
  <dd>
    <p>Delete the context &lt;name&gt;. The &lt;name&gt; parameter may not contain whitespace and defaults to %s.</p>
  </dd>
  <dt>
    <p><em>obsolete [&lt;name&gt;]</em></p>
  </dt>
  <dd>
    <p>Similar to the <em>delete</em> action, except that the action list of the context &lt;name&gt; (if present) is executed before deletion.</p>
  </dd>
  <dt>
    <p><em>set &lt;name&gt; &lt;time&gt; [&lt;action list&gt;]</em></p>
  </dt>
  <dd>
    <p>Change settings for the context &lt;name&gt;. The creation time of the context is set to the current time, and the lifetime of the context is set to &lt;time&gt; seconds. If the &lt;action list&gt; parameter is given, the context action list is set to &lt;action list&gt;. The &lt;name&gt; parameter may not contain whitespace and defaults to %s. The &lt;time&gt; parameter must evaluate to an unsigned integer or hyphen (-) at runtime. Specifying 0 for &lt;time&gt; means infinite lifetime. If &lt;time&gt; equals to -, the creation time and lifetime of the context are not changed. If &lt;action list&gt; contains several actions, the list must be enclosed in parentheses. In &lt;action list&gt;, the internal context name _THIS may be used for referring to the current context (see INTERNAL EVENTS AND CONTEXTS section for a detailed discussion).</p>
  </dd>
  <dt>
    <p><em>alias &lt;name&gt; [&lt;alias&gt;]</em></p>
  </dt>
  <dd>
    <p>Create an alias name &lt;alias&gt; for the context &lt;name&gt;. After creation, both &lt;alias&gt; and &lt;name&gt; will point to the same context data structure, and can thus be used interchangeably for referring to the context. The &lt;name&gt; and &lt;alias&gt; parameters may not contain whitespace, and &lt;alias&gt; defaults to %s. If the context &lt;name&gt; does not exist, the alias name is not created. If the <em>delete</em> action is called for one of the context names, the context data structure is destroyed, and all context names (which are now pointers to unallocated memory) cease to exist. Also note that when the context expires, its action list is executed only once, no matter how many names the context has.</p>
  </dd>
  <dt>
    <p><em>unalias [&lt;alias&gt;]</em></p>
  </dt>
  <dd>
    <p>Drop an existing context name &lt;alias&gt;, so that it can no longer be used for referring to the given context. The &lt;alias&gt; parameter may not contain whitespace and defaults to %s. If the name &lt;alias&gt; is the last reference to the context, the <em>unalias</em> action is identical to <em>delete</em>.</p>
  </dd>
  <dt>
    <p><em>add &lt;name&gt; [&lt;string&gt;]</em></p>
  </dt>
  <dd>
    <p>String &lt;string&gt; is appended to the end of the event store of the context &lt;name&gt;. The &lt;name&gt; parameter may not contain whitespace, and the &lt;string&gt; parameter defaults to %s. If the context &lt;name&gt; does not exist, the context is created with an infinite lifetime, empty action list and empty event store (as with <em>create &lt;name&gt;</em>) before adding the string to event store. If &lt;string&gt; is a multi-line string (i.e., it contains newlines), it is split into lines, and each line is appended to the event store separately.</p>
  </dd>
  <dt>
    <p><em>prepend &lt;name&gt; [&lt;string&gt;]</em></p>
  </dt>
  <dd>
    <p>Similar to the <em>add</em> action, except that the string &lt;string&gt; is prepended to the beginning of the event store of context &lt;name&gt;.</p>
  </dd>
  <dt>
    <p><em>fill &lt;name&gt; [&lt;string&gt;]</em></p>
  </dt>
  <dd>
    <p>Similar to the <em>add</em> action, except that the event store of the context &lt;name&gt; is emptied before &lt;string&gt; is added.</p>
  </dd>
  <dt>
    <p><em>report &lt;name&gt; [&lt;cmdline&gt;]</em></p>
  </dt>
  <dd>
    <p>Fork a process for executing command line &lt;cmdline&gt;, and write strings from the event store of the context &lt;name&gt; to the standard input of &lt;cmdline&gt;. Strings are written in the order they appear in the event store, with a terminating newline appended to each string. If the context &lt;name&gt; does not exist or its event store is empty, &lt;cmdline&gt; is not executed. The &lt;name&gt; parameter may not contain whitespace, and if &lt;cmdline&gt; is omitted, strings are written to standard output. For additional information, see INTERPROCESS COMMUNICATION section.</p>
  </dd>
  <dt>
    <p><em>copy &lt;name&gt; %&lt;var&gt;</em></p>
  </dt>
  <dd>
    <p>Strings s1,...,sn from the event store of the context &lt;name&gt; are joined into a multi-line string "s1&lt;NEWLINE&gt;...&lt;NEWLINE&gt;sn", and this string is assigned to the action list variable %&lt;var&gt;. If the context &lt;name&gt; does not exist, the value of %&lt;var&gt; does not change.</p>
  </dd>
  <dt>
    <p><em>empty &lt;name&gt; [%&lt;var&gt;]</em></p>
  </dt>
  <dd>
    <p>Similar to the <em>copy</em> action, except that the event store of the context &lt;name&gt; will be emptied after the assignment. If %&lt;var&gt; is omitted, the content of the event store is dropped without an assignment.</p>
  </dd>
  <dt>
    <p><em>pop &lt;name&gt; %&lt;var&gt;</em></p>
  </dt>
  <dd>
    <p>Remove the last string from the event store of context &lt;name&gt;, and assign it to the action list variable %&lt;var&gt;. If the event store is empty, %&lt;var&gt; is set to empty string. If the context &lt;name&gt; does not exist, the value of %&lt;var&gt; does not change.</p>
  </dd>
  <dt>
    <p><em>shift &lt;name&gt; %&lt;var&gt;</em></p>
  </dt>
  <dd>
    <p>Remove the first string from the event store of context &lt;name&gt;, and assign it to the action list variable %&lt;var&gt;. If the event store is empty, %&lt;var&gt; is set to empty string. If the context &lt;name&gt; does not exist, the value of %&lt;var&gt; does not change.</p>
  </dd>
  <dt>
    <p><em>exists %&lt;var&gt; &lt;name&gt;</em></p>
  </dt>
  <dd>
    <p>If the context &lt;name&gt; exists, set the action list variable %&lt;var&gt; to 1, otherwise set %&lt;var&gt; to 0.</p>
  </dd>
  <dt>
    <p><em>getsize %&lt;var&gt; &lt;name&gt;</em></p>
  </dt>
  <dd>
    <p>Find the number of strings in the event store of context &lt;name&gt;, and assign this number to the action list variable %&lt;var&gt;. If the context &lt;name&gt; does not exist, %&lt;var&gt; is set to Perl undefined value.</p>
  </dd>
  <dt>
    <p><em>getaliases %&lt;var&gt; &lt;name&gt;</em></p>
  </dt>
  <dd>
    <p>Find all alias names for context &lt;name&gt;, join the names into a multi-line string "alias1&lt;NEWLINE&gt;...&lt;NEWLINE&gt;aliasn", and assign this string to the action list variable %&lt;var&gt;. If the context &lt;name&gt; does not exist, the value of %&lt;var&gt; does not change.</p>
  </dd>
  <dt>
    <p><em>getltime %&lt;var&gt; &lt;name&gt;</em></p>
  </dt>
  <dd>
    <p>Find the lifetime of context &lt;name&gt;, and assign this number to the action list variable %&lt;var&gt;. If the context &lt;name&gt; does not exist, the value of %&lt;var&gt; does not change.</p>
  </dd>
  <dt>
    <p><em>getctime %&lt;var&gt; &lt;name&gt;</em></p>
  </dt>
  <dd>
    <p>Find the creation time of context &lt;name&gt;, and assign this number to the action list variable %&lt;var&gt;. If the context &lt;name&gt; does not exist, the value of %&lt;var&gt; does not change.</p>
  </dd>
  <dt>
    <p><em>setctime &lt;time&gt; &lt;name&gt;</em></p>
  </dt>
  <dd>
    <p>Set the creation time of context &lt;name&gt; to &lt;time&gt;. The &lt;time&gt; parameter must evaluate to seconds since Epoch (as reported by the <a href="../man2/time.2.html"><strong>time</strong>(2)</a> system call), and must reflect a time moment between the previous creation time and the current time (both endpoints included).</p>
  </dd>
  <dt>
    <p><em>event [&lt;time&gt;] [&lt;string&gt;]</em></p>
  </dt>
  <dd>
    <p>After &lt;time&gt; seconds, create a synthetic event &lt;string&gt;. If &lt;string&gt; is a multi-line string (i.e., it contains newlines), it is split into lines, and from each line a separate synthetic event is created. SEC will treat each synthetic event like a line from an input file -- the event will be matched against rules and it might trigger further actions. If the <strong>--intcontexts</strong> command line option is given, internal context _INTERNAL_EVENT is set up for synthetic event(s) (see INTERNAL EVENTS AND CONTEXTS section for more information). The &lt;time&gt; parameter is an integer constant. Specifying 0 for &lt;time&gt; or omitting the value means "now". Default value for &lt;string&gt; is %s.</p>
  </dd>
  <dt>
    <p><em>tevent &lt;time&gt; [&lt;string&gt;]</em></p>
  </dt>
  <dd>
    <p>Similar to the <em>event</em> action, except that the &lt;time&gt; parameter may contain variables and must evaluate to an unsigned integer at runtime.</p>
  </dd>
  <dt>
    <p><em>cevent &lt;name&gt; &lt;time&gt; [&lt;string&gt;]</em></p>
  </dt>
  <dd>
    <p>Similar to the <em>tevent</em> action, except that if the <strong>--intcontexts</strong> command line option is given, internal context &lt;name&gt; is set up for synthetic event(s).</p>
  </dd>
  <dt>
    <p><em>reset [&lt;offset&gt;] [&lt;string&gt;]</em></p>
  </dt>
  <dd>
    <p>Terminate event correlation operation(s) with the operation description string &lt;string&gt;. Note that the <em>reset</em> action works only for operations started from the same configuration file. The &lt;offset&gt; parameter is used to refer to a specific rule in the configuration file. If &lt;offset&gt; is given, the operation started by the given rule is terminated (if it exists). If &lt;offset&gt; is an unsigned integer N, it refers to the N-th rule in the configuration file. If &lt;offset&gt; is 0, it refers to the current rule. If &lt;offset&gt; begins with the plus (+) or minus (-) sign, it specifies an offset from the current rule (e.g., -1 denotes the previous and +1 the next rule). If &lt;offset&gt; is not given, SEC checks for each rule from the current configuration file if an operation with &lt;string&gt; has been started by this rule, and the operation is terminated if it exists. Default value for &lt;string&gt; is %s. For additional information, see EVENT CORRELATION OPERATIONS section.</p>
  </dd>
  <dt>
    <p><em>getwpos %&lt;var&gt; &lt;offset&gt; [&lt;string&gt;]</em></p>
  </dt>
  <dd>
    <p>Find the beginning of the event correlation window for an event correlation operation, and set the action list variable %&lt;var&gt; to this timestamp. The value assigned to %&lt;var&gt; is measured in seconds since Epoch (as reported by the <a href="../man2/time.2.html"><strong>time</strong>(2)</a> system call). As with the <em>reset</em> action, the event correlation operation is identified by the operation description string &lt;string&gt; and the rule offset &lt;offset&gt;. If the operation does not exist, the value of %&lt;var&gt; does not change. Default value for &lt;string&gt; is %s. For additional information, see EVENT CORRELATION OPERATIONS section.</p>
  </dd>
  <dt>
    <p><em>setwpos &lt;time&gt; &lt;offset&gt; [&lt;string&gt;]</em></p>
  </dt>
  <dd>
    <p>Set the beginning of the event correlation window to &lt;time&gt; for an event correlation operation (if it exists). The &lt;time&gt; parameter must evaluate to seconds since Epoch (as reported by the <a href="../man2/time.2.html"><strong>time</strong>(2)</a> system call), and must reflect a time moment between the previous window position and the current time (both endpoints included). As with the <em>reset</em> action, the event correlation operation is identified by the operation description string &lt;string&gt; and the rule offset &lt;offset&gt;. Default value for &lt;string&gt; is %s. For additional information, see EVENT CORRELATION OPERATIONS section.</p>
  </dd>
  <dt>
    <p><em>assign %&lt;var&gt; [&lt;string&gt;]</em></p>
  </dt>
  <dd>
    <p>Assign string &lt;string&gt; to the action list variable %&lt;var&gt;. Default value for &lt;string&gt; is %s.</p>
  </dd>
  <dt>
    <p><em>free %&lt;var&gt;</em></p>
  </dt>
  <dd>
    <p>Unset the action list variable %&lt;var&gt;.</p>
  </dd>
  <dt>
    <p><em>eval %&lt;var&gt; &lt;code&gt;</em></p>
  </dt>
  <dd>
    <p>The parameter &lt;code&gt; is a Perl miniprogram that is compiled and executed by calling the Perl <strong>eval</strong>() function in the Perl list context. If the miniprogram returns a single value, it is assigned to the action list variable %&lt;var&gt;. If the miniprogram returns several values s1,...,sn, they are joined into a multi-line string "s1&lt;NEWLINE&gt;...&lt;NEWLINE&gt;sn", and this string is assigned to %&lt;var&gt;. If no value is returned, %&lt;var&gt; is set to Perl undefined value. If <strong>eval</strong>() fails, the value of %&lt;var&gt; does not change. Since most Perl programs contain semicolons which are also employed by SEC as action separators, it is recommended to enclose the &lt;code&gt; parameter in parentheses, in order to mask the semicolons in &lt;code&gt;. For additional information, see PERL INTEGRATION section.</p>
  </dd>
  <dt>
    <p><em>call %&lt;var&gt; %&lt;ref&gt; [&lt;paramlist&gt;]</em></p>
  </dt>
  <dd>
    <p>Call the precompiled Perl function referenced by the action list variable %&lt;ref&gt;, and assign the result to the action list variable %&lt;var&gt;. The %&lt;ref&gt; parameter must be a code reference that has been previously created with the <em>eval</em> action. The &lt;paramlist&gt; parameter (if given) is a string which specifies parameters for the function. The parameters must be separated by whitespace in the &lt;paramlist&gt; string. If the function returns a single value, it is assigned to %&lt;var&gt;. If the function returns several values s1,...,sn, they are joined into a multi-line string "s1&lt;NEWLINE&gt;...&lt;NEWLINE&gt;sn", and this string is assigned to %&lt;var&gt;. If no value is returned, %&lt;var&gt; is set to Perl undefined value. If the function encounters a fatal runtime error or %&lt;ref&gt; is not a code reference, the value of %&lt;var&gt; does not change. For additional information, see PERL INTEGRATION section.</p>
  </dd>
  <dt>
    <p><em>lcall %&lt;var&gt; [&lt;paramlist&gt;] -&gt; &lt;code&gt;</em></p>
  </dt>
  <dd>
    <p>Call the precompiled Perl function &lt;code&gt; and assign the result to the action list variable %&lt;var&gt;. The &lt;code&gt; parameter must be a valid Perl function definition that is compiled at SEC startup with the Perl <strong>eval</strong>() function, and <strong>eval</strong>() must return a code reference. The &lt;paramlist&gt; parameter (if given) is a string which specifies parameters for the function. The parameters must be separated by whitespace in the &lt;paramlist&gt; string. If the function returns a single value, it is assigned to %&lt;var&gt;. If the function returns several values s1,...,sn, they are joined into a multi-line string "s1&lt;NEWLINE&gt;...&lt;NEWLINE&gt;sn", and this string is assigned to %&lt;var&gt;. If no value is returned, %&lt;var&gt; is set to Perl undefined value. If the function encounters a fatal runtime error, the value of %&lt;var&gt; does not change. Since most Perl functions contain semicolons which are also employed by SEC as action separators, it is recommended to enclose the &lt;code&gt; parameter in parentheses, in order to mask the semicolons in &lt;code&gt;. For additional information, see PERL INTEGRATION section.</p>
  </dd>
  <dt>
    <p><em>rewrite &lt;lnum&gt; [&lt;string&gt;]</em></p>
  </dt>
  <dd>
    <p>Replace last &lt;lnum&gt; lines in the input buffer with string &lt;string&gt;. If the <strong>--nojointbuf</strong> option was specified and the action is triggered by a matching event, the action modifies the buffer which holds this event. If the <strong>--nojointbuf</strong> option was specified and the action is triggered by the system clock (e.g., the action is executed from the Calendar rule), the action modifies the buffer which holds the last already processed event. With the <strong>--jointbuf</strong> option, the content of the joint input buffer is rewritten. The &lt;lnum&gt; parameter must evaluate to an unsigned integer at runtime. If &lt;lnum&gt; evaluates to 0, &lt;lnum&gt; is reset to the number of lines in &lt;string&gt;. If the value of &lt;lnum&gt; is greater than the buffer size N, &lt;lnum&gt; is reset to N. If &lt;string&gt; contains less than &lt;lnum&gt; lines, &lt;string&gt; will be padded with leading empty lines. If &lt;string&gt; contains more than &lt;lnum&gt; lines, only leading &lt;lnum&gt; lines from &lt;string&gt; are written into the buffer. Default value for &lt;string&gt; is %s. For additional information, see INPUT PROCESSING AND TIMING section.</p>
  </dd>
  <dt>
    <p><em>if %&lt;var&gt; ( &lt;action list&gt; ) [ else ( &lt;action list2&gt; ) ]</em></p>
  </dt>
  <dd>
    <p>If the action list variable %&lt;var&gt; evaluates true in the Perl boolean context (i.e., it holds a defined value which is neither 0 nor empty string), execute the action list &lt;action list&gt;. If the second action list &lt;action list2&gt; is given with the optional else-statement, it is executed if %&lt;var&gt; either does not exist or evaluates false (i.e., %&lt;var&gt; holds 0, empty string or Perl undefined value).</p>
  </dd>
  <dt>
    <p><em>while %&lt;var&gt; ( &lt;action list&gt; )</em></p>
  </dt>
  <dd>
    <p>Execute the action list &lt;action list&gt; repeatedly until the action list variable %&lt;var&gt; evaluates true in the Perl boolean context (i.e., it holds a defined value which is neither 0 nor empty string).</p>
  </dd>
  <dt>
    <p><em>break</em></p>
  </dt>
  <dd>
    <p>If used inside a while-loop, terminates its execution; otherwise terminates the execution of the entire action list.</p>
  </dd>
  <dt>
    <p><em>continue</em></p>
  </dt>
  <dd>
    <p>If used inside a while-loop, starts the next iteration of the loop; otherwise terminates the execution of the entire action list.</p>
  </dd>

</dl>
<p><strong>Examples:</strong></p><p>Follow the /var/log/trapd.log file and feed to SEC input all lines that are appended to the file:</p><p>spawn /bin/tail -f /var/log/trapd.log</p><p>Mail the timestamp and the value of the $0 variable to the local root:</p><p>pipe '%t: $0' /bin/mail -s "alert message" root@localhost</p><p>Add the value of the $0 variable to the event store of the context <strong>ftp_&lt;the value of $1&gt;</strong>, and set the context to expire after 30 minutes. When the context expires, its event store will be mailed to the local root:</p><p>add ftp_$1 $0; set ftp_$1 1800 (report ftp_$1 /bin/mail root@localhost)</p><p>Create a subroutine for weeding out comment lines from the input list, and use this subroutine for removing comment lines from the event store of the context <strong>C1</strong>:</p><p>eval %funcptr ( sub { my(@buf) = split(/&#92;n/, $_[0]); &#92;</p><p>my(@ret) = grep(!/^#/, @buf); return @ret; } ); &#92;</p><p>copy C1 %in; call %out %funcptr %in; fill C1 %out</p><p>The following action list achieves the same goal as the previous action list with <em>while</em> and <em>if</em> actions:</p><p>getsize %size C1; while %size ( shift C1 %event; &#92;</p><p>lcall %nocomment %event -&gt; ( sub { $_[0] !~ /^#/ } ); &#92;</p><p>if %nocomment ( add C1 %event ); &#92;</p><p>lcall %size %size -&gt; ( sub { $_[0]-1; } ) )</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PARSING ISSUES</h2>
        <div class="sectioncontent">
<p>As already noted, SEC context expressions and action lists may contain parentheses which are used for grouping and masking purposes. When SEC parses its configuration, it checks whether parentheses in context expressions and action lists are balanced (i.e., whether each parenthesis has a counterpart), since unbalanced parentheses introduce ambiguity. This can cause SEC to reject some legitimate constructs, e.g.,</p><p>action=eval %o (print ")";)</p><p>is considered an invalid action list (however, note that</p><p>action=eval %o (print "()";)</p><p>would be passed by SEC, since now parentheses are balanced). In order to avoid such parsing errors, each parenthesis without a counterpart must be masked with a backslash (the backslash will be removed by SEC during configuration file parsing). For example, the above action could be written as</p><p>action=eval %o (print "&#92;)";)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RULE TYPES</h2>
        <div class="sectioncontent">
<p>This section provides a detailed discussion of SEC rule types.</p><h3>SINGLE RULE</h3>
<p>The <strong>Single</strong> rule immediately executes an action list when an event has matched the rule. An event matches the rule if the pattern matches the event and the context expression (if given) evaluates TRUE.</p><p>The Single rule supports the following fields:</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>type</em></p>
  </dt>
  <dd>
    <p>fixed to Single (value is case insensitive, so single or sIngLe can be used instead).</p>
  </dd>
  <dt>
    <p><em>continue</em> (optional)</p>
  </dt>
  <dd>
    <p>TakeNext, DontCont, EndMatch or GoTo &lt;label&gt; (apart from &lt;label&gt;, values are case insensitive).</p>
  </dd>
  <dt>
    <p><em>ptype</em></p>
  </dt>
  <dd>
    <p>pattern type (value is case insensitive).</p>
  </dd>
  <dt>
    <p><em>pattern</em></p>
  </dt>
  <dd>
    <p>pattern.</p>
  </dd>
  <dt>
    <p><em>varmap</em> (optional)</p>
  </dt>
  <dd>
    <p>variable map.</p>
  </dd>
  <dt>
    <p><em>context</em> (optional)</p>
  </dt>
  <dd>
    <p>context expression.</p>
  </dd>
  <dt>
    <p><em>desc</em></p>
  </dt>
  <dd>
    <p>operation description string.</p>
  </dd>
  <dt>
    <p><em>action</em></p>
  </dt>
  <dd>
    <p>action list.</p>
  </dd>
  <dt>
    <p><em>rem</em> (optional, may appear more than once)</p>
  </dt>
  <dd>
    <p>remarks and comments.</p>
  </dd>

</dl>
<p>Note that match variables may be used in <em>context</em>, <em>desc</em>, and <em>action</em> fields. Also note that this rule does not start an event correlation operation, and the <em>desc</em> field is merely used for setting the %s action list variable.</p><p><strong>Examples:</strong></p><p>type=single</p><p>continue=takenext</p><p>ptype=regexp</p><p>pattern=ftpd&#92;[(&#92;d+)&#92;]: &#92;S+ &#92;(ristov2.*FTP session opened</p><p>desc=ftp session opened for ristov2 pid $1</p><p>action=create ftp_$1</p><p>type=single</p><p>continue=takenext</p><p>ptype=regexp</p><p>pattern=ftpd&#92;[(&#92;d+)&#92;]:</p><p>context=ftp_$1</p><p>desc=ftp session event for ristov2 pid $1</p><p>action=add ftp_$1 $0; set ftp_$1 1800 &#92;</p>
<pre>
         (report ftp_$1 /bin/mail root@localhost)
</pre>
<p>type=single</p><p>ptype=regexp</p><p>pattern=ftpd&#92;[(&#92;d+)&#92;]: &#92;S+ &#92;(ristov2.*FTP session closed</p><p>desc=ftp session closed for ristov2 pid $1</p><p>action=report ftp_$1 /bin/mail root@localhost; &#92;</p>
<pre>
       delete ftp_$1
</pre>
<p>This ruleset is created for monitoring the ftpd log file. The first rule creates the context <strong>ftp_&lt;pid&gt;</strong> when someone connects from host ristov2 over FTP and establishes a new ftp session (the session is identified by the PID of the process which has been created for handling this session). The second rule adds all further log file lines for the session &lt;pid&gt; to the event store of the context <strong>ftp_&lt;pid&gt;</strong> (before adding a line, the rule checks if the context exists). After adding a line, the rule extends context's lifetime for 30 minutes and sets the action list that will be executed when the context expires. The third rule mails collected log file lines to root@localhost when the session &lt;pid&gt; is closed. Collected lines will also be mailed when the session &lt;pid&gt; has been inactive for 30 minutes (no log file lines observed for that session).</p><p>Note that the log file line that has matched the first rule is also matched against the second rule (since the first rule has the <em>continue</em> field set to TakeNext). Since the second rule always matches this line, it will become the first line in the event store of <strong>ftp_&lt;pid&gt;</strong>. The second rule has also its <em>continue</em> field set to TakeNext, since otherwise no log file lines would reach the third rule.</p>
<h3>SINGLEWITHSCRIPT RULE</h3>
<p>The <strong>SingleWithScript</strong> rule forks a process for executing an external program when an event has matched the rule. The names of all currently existing contexts are written to the standard input of the program. After the program has been forked, the rule matching continues immediately, and the program status will be checked periodically until the program exits. If the program returns 0 exit status, the action list defined by the <em>action</em> field is executed; otherwise the action list defined by the <em>action2</em> field is executed (if given).</p><p>The SingleWithScript rule supports the following fields:</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>type</em></p>
  </dt>
  <dd>
    <p>fixed to SingleWithScript (value is case insensitive).</p>
  </dd>
  <dt>
    <p><em>continue</em> (optional)</p>
  </dt>
  <dd>
    <p>TakeNext, DontCont, EndMatch or GoTo &lt;label&gt; (apart from &lt;label&gt;, values are case insensitive).</p>
  </dd>
  <dt>
    <p><em>ptype</em></p>
  </dt>
  <dd>
    <p>pattern type (value is case insensitive).</p>
  </dd>
  <dt>
    <p><em>pattern</em></p>
  </dt>
  <dd>
    <p>pattern.</p>
  </dd>
  <dt>
    <p><em>varmap</em> (optional)</p>
  </dt>
  <dd>
    <p>variable map.</p>
  </dd>
  <dt>
    <p><em>context</em> (optional)</p>
  </dt>
  <dd>
    <p>context expression.</p>
  </dd>
  <dt>
    <p><em>script</em></p>
  </dt>
  <dd>
    <p>an external program.</p>
  </dd>
  <dt>
    <p><em>desc</em></p>
  </dt>
  <dd>
    <p>operation description string.</p>
  </dd>
  <dt>
    <p><em>action</em></p>
  </dt>
  <dd>
    <p>action list.</p>
  </dd>
  <dt>
    <p><em>action2</em> (optional)</p>
  </dt>
  <dd>
    <p>action list.</p>
  </dd>
  <dt>
    <p><em>rem</em> (optional, may appear more than once)</p>
  </dt>
  <dd>
    <p>remarks and comments.</p>
  </dd>

</dl>
<p>Note that match variables may be used in <em>context</em>, <em>script</em>, <em>desc</em>, <em>action</em>, and <em>action2</em> fields. Also note that this rule does not start an event correlation operation, and the <em>desc</em> field is merely used for setting the %s action list variable.</p><p><strong>Examples:</strong></p><p>type=SingleWithScript</p><p>ptype=RegExp</p><p>pattern=interface ([&#92;d.]+) down</p><p>script=/bin/ping -c 3 -q $1</p><p>desc=Check if $1 responds to ping</p><p>action=logonly Interface $1 reported down, but is pingable</p><p>action2=pipe '%t: Interface $1 is down' /bin/mail root@localhost</p><p>When "interface &lt;ipaddress&gt; down" line appears in input, the rule checks if &lt;ipaddress&gt; responds to ping. If &lt;ipaddress&gt; is pingable, the message "Interface &lt;ipaddress&gt; reported down, but is pingable" is logged; otherwise an e-mail warning containing a human-readable timestamp is sent to root@localhost.</p>
<h3>SINGLEWITHSUPPRESS RULE</h3>
<p>The <strong>SingleWithSuppress</strong> rule runs event correlation operations for filtering repeated instances of the same event during T seconds. The value of T is defined by the <em>window</em> field.</p><p>When an event has matched the rule, SEC evaluates the operation description string given with the <em>desc</em> field. If the operation for the given string and rule does not exist, SEC will create it with the lifetime of T seconds, and the operation immediately executes an action list. If the operation exists, it consumes the matching event without any action.</p><p>The SingleWithSuppress rule supports the following fields:</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>type</em></p>
  </dt>
  <dd>
    <p>fixed to SingleWithSuppress (value is case insensitive).</p>
  </dd>
  <dt>
    <p><em>continue</em> (optional)</p>
  </dt>
  <dd>
    <p>TakeNext, DontCont, EndMatch or GoTo &lt;label&gt; (apart from &lt;label&gt;, values are case insensitive).</p>
  </dd>
  <dt>
    <p><em>ptype</em></p>
  </dt>
  <dd>
    <p>pattern type (value is case insensitive).</p>
  </dd>
  <dt>
    <p><em>pattern</em></p>
  </dt>
  <dd>
    <p>pattern.</p>
  </dd>
  <dt>
    <p><em>varmap</em> (optional)</p>
  </dt>
  <dd>
    <p>variable map.</p>
  </dd>
  <dt>
    <p><em>context</em> (optional)</p>
  </dt>
  <dd>
    <p>context expression.</p>
  </dd>
  <dt>
    <p><em>desc</em></p>
  </dt>
  <dd>
    <p>operation description string.</p>
  </dd>
  <dt>
    <p><em>action</em></p>
  </dt>
  <dd>
    <p>action list.</p>
  </dd>
  <dt>
    <p><em>window</em></p>
  </dt>
  <dd>
    <p>event correlation window size (value is an integer constant).</p>
  </dd>
  <dt>
    <p><em>rem</em> (optional, may appear more than once)</p>
  </dt>
  <dd>
    <p>remarks and comments.</p>
  </dd>

</dl>
<p>Note that match variables may be used in <em>context</em>, <em>desc</em>, and <em>action</em> fields.</p><p><strong>Examples:</strong></p><p>type=SingleWithSuppress</p><p>ptype=RegExp</p><p>pattern=(&#92;S+): [fF]ile system full</p><p>desc=File system $1 full</p><p>action=pipe '%t: %s' /bin/mail root@localhost</p><p>window=900</p><p>This rule runs event correlation operations for processing "file system full" syslog messages, e.g.,</p><p>Dec 16 14:26:09 test ufs: [ID 845546 kern.notice] NOTICE: alloc: /var: file system full</p><p>When the first message for a file system is observed, an operation is created which sends an e-mail warning about this file system to root@localhost. The operation will then run for 900 seconds and silently consume further messages for the *same* file system. However, if a message for a different file system is observed, another operation will be started which sends a warning to root@localhost again (since the <em>desc</em> field contains the $1 match variable which evaluates to the file system name).</p>
<h3>PAIR RULE</h3>
<p>The <strong>Pair</strong> rule runs event correlation operations for processing event pairs during T seconds. The value of T is defined by the <em>window</em> field. Default value is 0 which means infinity.</p><p>When an event has matched the conditions defined by the <em>pattern</em> and <em>context</em> field, SEC evaluates the operation description string given with the <em>desc</em> field. If the operation for the given string and rule exists, it consumes the matching event without any action. If the operation does not exist, SEC will create it with the lifetime of T seconds, and the operation immediately executes an action list defined by the <em>action</em> field. SEC will also copy the match conditions given with the <em>pattern2</em> and <em>context2</em> field into the operation, and substitute match variables with their values in copied conditions.</p><p>If the event does not match conditions defined by the <em>pattern</em> and <em>context</em> field, SEC will check the match conditions of all operations started by the given rule. Each matching operation executes the action list given with the <em>action2</em> field and finishes.</p><p>The Pair rule supports the following fields:</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>type</em></p>
  </dt>
  <dd>
    <p>fixed to Pair (value is case insensitive).</p>
  </dd>
  <dt>
    <p><em>continue</em> (optional)</p>
  </dt>
  <dd>
    <p>TakeNext, DontCont, EndMatch or GoTo &lt;label&gt; (apart from &lt;label&gt;, values are case insensitive). Specifies the point-of-continue after a match by <em>pattern</em> and <em>context</em>.</p>
  </dd>
  <dt>
    <p><em>ptype</em></p>
  </dt>
  <dd>
    <p>pattern type for <em>pattern</em> (value is case insensitive).</p>
  </dd>
  <dt>
    <p><em>pattern</em></p>
  </dt>
  <dd>
    <p>pattern.</p>
  </dd>
  <dt>
    <p><em>varmap</em> (optional)</p>
  </dt>
  <dd>
    <p>variable map for <em>pattern</em>.</p>
  </dd>
  <dt>
    <p><em>context</em> (optional)</p>
  </dt>
  <dd>
    <p>context expression, evaluated together with <em>pattern</em>.</p>
  </dd>
  <dt>
    <p><em>desc</em></p>
  </dt>
  <dd>
    <p>operation description string.</p>
  </dd>
  <dt>
    <p><em>action</em></p>
  </dt>
  <dd>
    <p>action list.</p>
  </dd>
  <dt>
    <p><em>continue2</em> (optional)</p>
  </dt>
  <dd>
    <p>TakeNext, DontCont, EndMatch or GoTo &lt;label&gt; (apart from &lt;label&gt;, values are case insensitive). Specifies the point-of-continue after a match by <em>pattern2</em> and <em>context2</em>.</p>
  </dd>
  <dt>
    <p><em>ptype2</em></p>
  </dt>
  <dd>
    <p>pattern type for <em>pattern2</em> (value is case insensitive).</p>
  </dd>
  <dt>
    <p><em>pattern2</em></p>
  </dt>
  <dd>
    <p>pattern.</p>
  </dd>
  <dt>
    <p><em>varmap2</em> (optional)</p>
  </dt>
  <dd>
    <p>variable map for <em>pattern2</em>.</p>
  </dd>
  <dt>
    <p><em>context2</em> (optional)</p>
  </dt>
  <dd>
    <p>context expression, evaluated together with <em>pattern2</em>.</p>
  </dd>
  <dt>
    <p><em>desc2</em></p>
  </dt>
  <dd>
    <p>format string that sets the %s variable for <em>action2</em>.</p>
  </dd>
  <dt>
    <p><em>action2</em></p>
  </dt>
  <dd>
    <p>action list.</p>
  </dd>
  <dt>
    <p><em>window</em> (optional)</p>
  </dt>
  <dd>
    <p>event correlation window size (value is an integer constant).</p>
  </dd>
  <dt>
    <p><em>rem</em> (optional, may appear more than once)</p>
  </dt>
  <dd>
    <p>remarks and comments.</p>
  </dd>

</dl>
<p>Note that match variables may be used in <em>context</em>, <em>desc</em>, <em>action</em>, <em>pattern2</em>, <em>context2</em>, <em>desc2</em>, and <em>action2</em> fields.</p><p><strong>Examples:</strong></p><p>type=Pair</p><p>ptype=RegExp</p><p>pattern=kernel: nfs: server (&#92;S+) not responding, still trying</p><p>desc=Server $1 is not responding</p><p>action=pipe '%t: %s' /bin/mail root@localhost</p><p>ptype2=SubStr</p><p>pattern2=kernel: nfs: server $1 OK</p><p>desc2=Server $1 is responding again</p><p>action2=logonly</p><p>window=3600</p><p>This rule runs event correlation operations for processing NFS "server not responding" and "server OK" syslog messages, e.g.,</p><p>Dec 18 22:39:48 test kernel: nfs: server box1 not responding, still trying</p><p>Dec 18 22:42:27 test kernel: nfs: server box1 OK</p><p>When the "server not responding" message for an NFS server is observed, an operation is created for this server which sends an e-mail warning about the server to root@localhost. The operation will then run for 3600 seconds and silently consume further "server not responding" messages for the same server. If this operation observes "server OK" message for the *same* server, it will log the message "Server &lt;servername&gt; is responding again" and finish.</p><p>For example, if SEC observes the following event at 22:39:48</p><p>Dec 18 22:39:48 test kernel: nfs: server box1 not responding, still trying</p><p>an event correlation operation is created for server box1 which issues an e-mail warning about this server immediately. After that, the operation will run for 3600 seconds (until 23:39:48), waiting for an event which would contain the substring "kernel: nfs: server box1 OK" (because the <em>pattern2</em> field contains the $1 match variable which evaluates to the server name).</p><p>If any further error messages appear for server box1 during the 3600 second lifetime of the operation, e.g.,</p><p>Dec 18 22:40:28 test kernel: nfs: server box1 not responding, still trying</p><p>Dec 18 22:41:09 test kernel: nfs: server box1 not responding, still trying</p><p>these messages will be silently consumed by the operation. If before its expiration the operation observes an event which contains the substring  "kernel: nfs: server box1 OK", e.g.,</p><p>Dec 18 22:42:27 test kernel: nfs: server box1 OK</p><p>the operation will log the message "Server box1 is responding again" and terminate immediately. If no such message appears during the 3600 second lifetime of the operation, the operation will expire without taking any action. Please note that if the <em>window</em> field would be either removed from the rule definition or set to 0, the operation would never silently expire, but would terminate only after observing an event which contains the substring  "kernel: nfs: server box1 OK".</p>
<h3>PAIRWITHWINDOW RULE</h3>
<p>The <strong>PairWithWindow</strong> rule runs event correlation operations for processing event pairs during T seconds. The value of T is defined by the <em>window</em> field.</p><p>When an event has matched the conditions defined by the <em>pattern</em> and <em>context</em> field, SEC evaluates the operation description string given with the <em>desc</em> field. If the operation for the given string and rule exists, it consumes the matching event without any action. If the operation does not exist, SEC will create it with the lifetime of T seconds. SEC will also copy the match conditions given with the <em>pattern2</em> and <em>context2</em> field into the operation, and substitute match variables with their values in copied conditions.</p><p>If the event does not match conditions defined by the <em>pattern</em> and <em>context</em> field, SEC will check the match conditions of all operations started by the given rule. Each matching operation executes the action list given with the <em>action2</em> field and finishes. If the operation has not observed a matching event by the end of its lifetime, it executes the action list given with the <em>action</em> field before finishing.</p><p>The PairWithWindow rule supports the following fields:</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>type</em></p>
  </dt>
  <dd>
    <p>fixed to PairWithWindow (value is case insensitive).</p>
  </dd>
  <dt>
    <p><em>continue</em> (optional)</p>
  </dt>
  <dd>
    <p>TakeNext, DontCont, EndMatch or GoTo &lt;label&gt; (apart from &lt;label&gt;, values are case insensitive). Specifies the point-of-continue after a match by <em>pattern</em> and <em>context</em>.</p>
  </dd>
  <dt>
    <p><em>ptype</em></p>
  </dt>
  <dd>
    <p>pattern type for <em>pattern</em> (value is case insensitive).</p>
  </dd>
  <dt>
    <p><em>pattern</em></p>
  </dt>
  <dd>
    <p>pattern.</p>
  </dd>
  <dt>
    <p><em>varmap</em> (optional)</p>
  </dt>
  <dd>
    <p>variable map for <em>pattern</em>.</p>
  </dd>
  <dt>
    <p><em>context</em> (optional)</p>
  </dt>
  <dd>
    <p>context expression, evaluated together with <em>pattern</em>.</p>
  </dd>
  <dt>
    <p><em>desc</em></p>
  </dt>
  <dd>
    <p>operation description string.</p>
  </dd>
  <dt>
    <p><em>action</em></p>
  </dt>
  <dd>
    <p>action list.</p>
  </dd>
  <dt>
    <p><em>continue2</em> (optional)</p>
  </dt>
  <dd>
    <p>TakeNext, DontCont, EndMatch or GoTo &lt;label&gt; (apart from &lt;label&gt;, values are case insensitive). Specifies the point-of-continue after a match by <em>pattern2</em> and <em>context2</em>.</p>
  </dd>
  <dt>
    <p><em>ptype2</em></p>
  </dt>
  <dd>
    <p>pattern type for <em>pattern2</em> (value is case insensitive).</p>
  </dd>
  <dt>
    <p><em>pattern2</em></p>
  </dt>
  <dd>
    <p>pattern.</p>
  </dd>
  <dt>
    <p><em>varmap2</em> (optional)</p>
  </dt>
  <dd>
    <p>variable map for <em>pattern2</em>.</p>
  </dd>
  <dt>
    <p><em>context2</em> (optional)</p>
  </dt>
  <dd>
    <p>context expression, evaluated together with <em>pattern2</em>.</p>
  </dd>
  <dt>
    <p><em>desc2</em></p>
  </dt>
  <dd>
    <p>format string that sets the %s variable for <em>action2</em>.</p>
  </dd>
  <dt>
    <p><em>action2</em></p>
  </dt>
  <dd>
    <p>action list.</p>
  </dd>
  <dt>
    <p><em>window</em></p>
  </dt>
  <dd>
    <p>event correlation window size (value is an integer constant).</p>
  </dd>
  <dt>
    <p><em>rem</em> (optional, may appear more than once)</p>
  </dt>
  <dd>
    <p>remarks and comments.</p>
  </dd>

</dl>
<p>Note that match variables may be used in <em>context</em>, <em>desc</em>, <em>action</em>, <em>pattern2</em>, <em>context2</em>, <em>desc2</em>, and <em>action2</em> fields.</p><p><strong>Examples:</strong></p><p>type=PairWithWindow</p><p>ptype=RegExp</p><p>pattern=sshd&#92;[&#92;d+&#92;]: Failed .+ for (&#92;S+) from ([&#92;d.]+) port &#92;d+ ssh2</p><p>desc=User $1 has been unable to log in from $2 over SSH during 1 minute</p><p>action=pipe '%t: %s' /bin/mail root@localhost</p><p>ptype2=RegExp</p><p>pattern2=sshd&#92;[&#92;d+&#92;]: Accepted .+ for $1 from $2 port &#92;d+ ssh2</p><p>desc2=SSH login successful for %1 from %2 after initial failure</p><p>action2=logonly</p><p>window=60</p><p>This rule runs event correlation operations for processing SSH login events, e.g.,</p><p>Dec 27 19:00:24 test sshd[10526]: Failed password for risto from 10.1.2.7 port 52622 ssh2</p><p>Dec 27 19:00:27 test sshd[10526]: Accepted password for risto from 10.1.2.7 port 52622 ssh2</p><p>When an SSH login failure is observed for a user name and a source IP address, an operation is created for this user name and IP address combination which will expect a successful login for the *same* user name and *same* IP address during 60 seconds. If the user will not log in from the same IP address during 60 seconds, the operation will send an e-mail warning to root@localhost before finishing, otherwise it will log the message "SSH login successful for &lt;username&gt; from &lt;ipaddress&gt; after initial failure" and finish.</p><p>Suppose the following events are generated by an SSH daemon, and each event timestamp reflects the time SEC observes the event:</p><p>Dec 30 13:02:01 test sshd[30517]: Failed password for risto from 10.1.2.7 port 42172 ssh2</p><p>Dec 30 13:02:30 test sshd[30810]: Failed password for root from 192.168.1.104 port 46125 ssh2</p><p>Dec 30 13:02:37 test sshd[30517]: Failed password for risto from 10.1.2.7 port 42172 ssh2</p><p>Dec 30 13:02:59 test sshd[30810]: Failed password for root from 192.168.1.104 port 46125 ssh2</p><p>Dec 30 13:03:04 test sshd[30810]: Accepted password for root from 192.168.1.104 port 46125 ssh2</p><p>When the first event is observed at 13:02:01, an operation is started for user risto and IP address 10.1.2.7 which will expect a successful login for risto from 10.1.2.7. The operation will run for 60 seconds, waiting for an event which would match the regular expression</p><p>sshd&#92;[&#92;d+&#92;]: Accepted .+ for risto from 10&#92;.1&#92;.2&#92;.7 port &#92;d+ ssh2</p><p>When the second event is observed at 13:02:30, another operation is started for user root and IP address 192.168.1.104 which will expect root to log in successfully from 192.168.1.104. This operation will run for 60 seconds, waiting for an event matching the regular expression</p><p>sshd&#92;[&#92;d+&#92;]: Accepted .+ for root from 192&#92;.168&#92;.1&#92;.104 port &#92;d+ ssh2</p><p>The third event at 13:02:37 represents a second login failure for user risto and IP address 10.1.2.7, and is silently consumed by the first operation. Likewise, the fourth event at 13:02:59 is silently consumed by the second operation. The first operation will run until 13:03:01 and then expire without seeing a successful login for risto from 10.1.2.7. Before terminating, the operation will send an e-mail warning to root@localhost that user risto has not managed to log in from 10.1.2.7 during one minute. At 13:03:04, the second operation will observe an event which matches its regular expression</p><p>sshd&#92;[&#92;d+&#92;]: Accepted .+ for root from 192&#92;.168&#92;.1&#92;.104 port &#92;d+ ssh2</p><p>After seeing this event, the operation will log the message "SSH login successful for root from 192.168.1.104 after initial failure" and terminate immediately. Please note that the match by the regular expression</p><p>sshd&#92;[&#92;d+&#92;]: Accepted .+ for root from 192&#92;.168&#92;.1&#92;.104 port &#92;d+ ssh2</p><p>sets the $1 match variable to 1 and unsets $2. Therefore, the %1 and %2 match variables have to be used in the <em>desc2</em> field, in order to refer to the original values of $1 (root) and $2 (192.168.1.104) when the operation was created.</p>
<h3>SINGLEWITHTHRESHOLD RULE</h3>
<p>The <strong>SingleWithThreshold</strong> rule runs event correlation operations for counting repeated instances of the same event during T seconds, and taking an action if N events are observed. The values of T and N are defined by the <em>window</em> and <em>thresh</em> field, respectively.</p><p>When an event has matched the rule, SEC evaluates the operation description string given with the <em>desc</em> field. If the operation for the given string and rule does not exist, SEC will create it with the lifetime of T seconds. The operation will memorize the occurrence time of the event (current time as returned by the <a href="../man2/time.2.html"><strong>time</strong>(2)</a> system call), and compare the number of memorized occurrence times with the threshold N. If the operation has observed N events, it executes the action list defined by the <em>action</em> field, and consumes all further matching events without any action. If the rule has an optional action list defined with the <em>action2</em> field, the operation will execute it before finishing, provided that the action list given with <em>action</em> has been previously executed by the operation. Note that  a sliding window is employed for event counting -- if the operation has observed less than N events by the end of its lifetime, it drops occurrence times which are older than T seconds, and extends its lifetime for T seconds from the earliest remaining occurrence time. If there are no remaining occurrence times, the operation finishes without executing an action list.</p><p>The SingleWithThreshold rule supports the following fields:</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>type</em></p>
  </dt>
  <dd>
    <p>fixed to SingleWithThreshold (value is case insensitive).</p>
  </dd>
  <dt>
    <p><em>continue</em> (optional)</p>
  </dt>
  <dd>
    <p>TakeNext, DontCont, EndMatch or GoTo &lt;label&gt; (apart from &lt;label&gt;, values are case insensitive).</p>
  </dd>
  <dt>
    <p><em>ptype</em></p>
  </dt>
  <dd>
    <p>pattern type (value is case insensitive).</p>
  </dd>
  <dt>
    <p><em>pattern</em></p>
  </dt>
  <dd>
    <p>pattern.</p>
  </dd>
  <dt>
    <p><em>varmap</em> (optional)</p>
  </dt>
  <dd>
    <p>variable map.</p>
  </dd>
  <dt>
    <p><em>context</em> (optional)</p>
  </dt>
  <dd>
    <p>context expression.</p>
  </dd>
  <dt>
    <p><em>desc</em></p>
  </dt>
  <dd>
    <p>operation description string.</p>
  </dd>
  <dt>
    <p><em>action</em></p>
  </dt>
  <dd>
    <p>action list.</p>
  </dd>
  <dt>
    <p><em>action2</em> (optional)</p>
  </dt>
  <dd>
    <p>action list.</p>
  </dd>
  <dt>
    <p><em>window</em></p>
  </dt>
  <dd>
    <p>event correlation window size (value is an integer constant).</p>
  </dd>
  <dt>
    <p><em>thresh</em></p>
  </dt>
  <dd>
    <p>counting threshold (value is an integer constant).</p>
  </dd>
  <dt>
    <p><em>rem</em> (optional, may appear more than once)</p>
  </dt>
  <dd>
    <p>remarks and comments.</p>
  </dd>

</dl>
<p>Note that match variables may be used in <em>context</em>, <em>desc</em>, <em>action</em>, and <em>action2</em> fields.</p><p><strong>Examples:</strong></p><p>type=SingleWithThreshold</p><p>ptype=RegExp</p><p>pattern=sshd&#92;[&#92;d+&#92;]: Failed .+ for (&#92;S+) from [&#92;d.]+ port &#92;d+ ssh2</p><p>desc=Three SSH login failures within 1m for user $1</p><p>action=pipe '%t: %s' /bin/mail root@localhost</p><p>window=60</p><p>thresh=3</p><p>This rule runs event correlation operations for counting the number of SSH login failure events. Each operation counts events for one user name, and if the operation has observed three login failures within 60 seconds, it sends an e-mail warning to root@localhost.</p><p>Suppose the following events are generated by an SSH daemon, and each event timestamp reflects the time SEC observes the event:</p><p>Dec 28 01:42:21 test sshd[28132]: Failed password for risto from 10.1.2.7 port 42172 ssh2</p><p>Dec 28 01:43:10 test sshd[28132]: Failed password for risto from 10.1.2.7 port 42172 ssh2</p><p>Dec 28 01:43:29 test sshd[28132]: Failed password for risto from 10.1.2.7 port 42172 ssh2</p><p>Dec 28 01:44:00 test sshd[28149]: Failed password for risto2 from 10.1.2.7 port 42176 ssh2</p><p>Dec 28 01:44:03 test sshd[28211]: Failed password for risto from 10.1.2.7 port 42192 ssh2</p><p>Dec 28 01:44:07 test sshd[28211]: Failed password for risto from 10.1.2.7 port 42192 ssh2</p><p>When the first event is observed at 01:42:21, a counting operation is started for user risto, with its event correlation window ending at 01:43:21. Since by 01:43:21 two SSH login failures for user risto have occurred, the threshold condition remains unsatisfied for the operation. Therefore, the beginning of its event correlation window will be moved to 01:43:10 (the occurrence time of the second event), leaving the first event outside the window. At 01:44:00, another counting operation is started for user risto2. The threshold condition for the first operation will become satisfied at 01:44:03 (since the operation has seen three login failure events for user risto within 60 seconds), and thus an e-mail warning will be issued. Finally, the event occurring at 01:44:07 will be consumed silently by the first operation (the operation will run until 01:44:10). Since there will be no further login failure events for user risto2, the second operation will exist until 01:45:00 without taking any action.</p>
<h3>SINGLEWITH2THRESHOLDS RULE</h3>
<p>The <strong>SingleWith2Thresholds</strong> rule runs event correlation operations which take action if N1 events have been observed in the window of T1 seconds, and then at most N2 events will be observed in the window of T2 seconds. The values of T1, N1, T2, and N2 are defined by the <em>window</em>, <em>thresh</em>, <em>window2</em>, and <em>thresh2</em> field, respectively.</p><p>When an event has matched the rule, SEC evaluates the operation description string given with the <em>desc</em> field. If the operation for the given string and rule does not exist, SEC will create it with the lifetime of T1 seconds. The operation will memorize the occurrence time of the event (current time as returned by the <a href="../man2/time.2.html"><strong>time</strong>(2)</a> system call), and compare the number of memorized occurrence times with the threshold N1. If the operation has observed N1 events, it executes the action list defined by the <em>action</em> field, and starts another counting round for T2 seconds. If no more than N2 events have been observed by the end of the window, the operation executes the action list defined by the <em>action2</em> field and finishes. Note that both windows are sliding -- the first window slides like the window of the SingleWithThreshold operation, while the beginning of the second window is moved to the second earliest memorized event occurrence time when the threshold N2 is violated.</p><p>The SingleWith2Thresholds rule supports the following fields:</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>type</em></p>
  </dt>
  <dd>
    <p>fixed to SingleWith2Thresholds (value is case insensitive).</p>
  </dd>
  <dt>
    <p><em>continue</em> (optional)</p>
  </dt>
  <dd>
    <p>TakeNext, DontCont, EndMatch or GoTo &lt;label&gt; (apart from &lt;label&gt;, values are case insensitive).</p>
  </dd>
  <dt>
    <p><em>ptype</em></p>
  </dt>
  <dd>
    <p>pattern type (value is case insensitive).</p>
  </dd>
  <dt>
    <p><em>pattern</em></p>
  </dt>
  <dd>
    <p>pattern.</p>
  </dd>
  <dt>
    <p><em>varmap</em> (optional)</p>
  </dt>
  <dd>
    <p>variable map.</p>
  </dd>
  <dt>
    <p><em>context</em> (optional)</p>
  </dt>
  <dd>
    <p>context expression.</p>
  </dd>
  <dt>
    <p><em>desc</em></p>
  </dt>
  <dd>
    <p>operation description string.</p>
  </dd>
  <dt>
    <p><em>action</em></p>
  </dt>
  <dd>
    <p>action list.</p>
  </dd>
  <dt>
    <p><em>window</em></p>
  </dt>
  <dd>
    <p>event correlation window size (value is an integer constant).</p>
  </dd>
  <dt>
    <p><em>thresh</em></p>
  </dt>
  <dd>
    <p>counting threshold.</p>
  </dd>
  <dt>
    <p><em>desc2</em></p>
  </dt>
  <dd>
    <p>format string that sets the %s variable for <em>action2</em>.</p>
  </dd>
  <dt>
    <p><em>action2</em></p>
  </dt>
  <dd>
    <p>action list.</p>
  </dd>
  <dt>
    <p><em>window2</em></p>
  </dt>
  <dd>
    <p>event correlation window size (value is an integer constant).</p>
  </dd>
  <dt>
    <p><em>thresh2</em></p>
  </dt>
  <dd>
    <p>counting threshold.</p>
  </dd>
  <dt>
    <p><em>rem</em> (optional, may appear more than once)</p>
  </dt>
  <dd>
    <p>remarks and comments.</p>
  </dd>

</dl>
<p>Note that match variables may be used in <em>context</em>, <em>desc</em>, <em>action</em>, <em>desc2</em>, and <em>action2</em> fields.</p><p><strong>Examples:</strong></p><p>type=SingleWith2Thresholds</p><p>ptype=RegExp</p><p>pattern=(&#92;S+): %SYS-3-CPUHOG</p><p>desc=Router $1 CPU overload</p><p>action=pipe '%t: %s' /bin/mail root@localhost</p><p>window=300</p><p>thresh=2</p><p>desc2=Router $1 CPU load has been normal for 1h</p><p>action2=logonly</p><p>window2=3600</p><p>thresh2=0</p><p>When a SYS-3-CPUHOG syslog message is received from a router, the rule starts a counting operation for this router which sends an e-mail warning to root@localhost if another such message is received from the same router within 300 seconds. After sending the warning, the operation will continue to run until no SYS-3-CPUHOG syslog messages have been received from the router for 3600 seconds. When this condition becomes satisfied, the operation will log the message "Router &lt;routername&gt; CPU load has been normal for 1h" and finish.</p><p>Suppose the following events are generated by a router, and each event timestamp reflects the time SEC observes the event:</p><p>Dec 30 12:23:25 router1.mydomain Router1: %SYS-3-CPUHOG: cpu is hogged</p><p>Dec 30 12:25:38 router1.mydomain Router1: %SYS-3-CPUHOG: cpu is hogged</p><p>Dec 30 12:28:53 router1.mydomain Router1: %SYS-3-CPUHOG: cpu is hogged</p><p>When the first event is observed at 12:23:25, a counting operation is started for router Router1. The appearance of the second event at 12:25:38 fulfills the threshold condition given with the <em>thresh</em> and <em>window</em> fields (two events have been observed within 300 seconds). Therefore, the operation will send an e-mail warning about the CPU overload of Router1 to root@localhost.</p><p>After that, the operation will start another counting round, expecting to see no SYS-3-CPUHOG events (since <em>thresh2=0</em>) for Router1 during the following 3600 seconds (the beginning of the operation's event correlation window will be moved to 12:25:38 for the second counting round). Since the appearance of the third event at 12:28:53 violates the threshold condition given with the <em>thresh2</em> and <em>window2</em> fields, the beginning of the event correlation window will be moved to 12:28:53. Since there will be no further SYS-3-CPUHOG messages for Router1, the operation will run until 13:28:53 and then expire, logging the message "Router Router1 CPU load has been normal for 1h" before finishing.</p>
<h3>EVENTGROUP RULE</h3>
<p>The <strong>EventGroup</strong> rule runs event correlation operations for counting repeated instances of N different events e1,...,eK during T seconds, and taking an action if threshold conditions c1,...,cN for *all* events are satisfied (i.e., for each event eK there are at least cK event instances in the window). The values for N and T are defined by the <em>type</em> and <em>window</em> field, respectively, while values for c1,...,cN are given with the <em>thresh*</em> fields. Values for N and c1,...,cN default to 1. Note that the event correlation window is sliding like the window of the SingleWithThreshold operation.</p><p>When an event has matched the rule, SEC evaluates the operation description string given with the <em>desc</em> field. If the operation for the given string and rule does not exist, SEC will create it with the lifetime of T seconds. The operation will memorize the occurrence time of the event (current time as returned by the <a href="../man2/time.2.html"><strong>time</strong>(2)</a> system call), and compare the number of memorized occurrence times for each eK with the threshold cK. If all threshold confitions are satisfied, the operation executes the action list defined by the <em>action</em> field, and consumes all further matching events without re-executing the action list if the <em>multact</em> field is set to No (this is the default). However, if <em>multact</em> is set to Yes, the operation will evaluate the threshold conditions on every further matching event, executing the action list given with the <em>action</em> field if all conditions are satisfied, and sliding the event correlation window forward when the window is about to expire (if no events remain in the window, the operation will finish).</p><p>If the rule definition has an optional action list defined with the <em>count*</em> field for event eK, the operation executes it every time an instance of eK is observed (even if <em>multact</em> is set to No and the operation has already executed the action list given with <em>action</em>).</p><p>If the rule definition has an optional action list defined with the <em>init</em> field, the operation executes it immediately after the operation has been created.</p><p>If the rule definition has an optional action list defined with the <em>end</em> field, the operation executes it immediately before the operation finishes. Note that this action list is *not* executed when the operation is terminated with the <em>reset</em> action.</p><p>If the rule definition has an optional action list defined with the <em>slide</em> field, the operation executes it immediately after the event correlation window has slidden forward. However, note that moving the window with the <em>setwpos</em> action will *not* trigger the execution.</p><p>The EventGroup rule supports the following fields:</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>type</em></p>
  </dt>
  <dd>
    <p><em></em>EventGroup[<em>N</em>] (value is case insensitive, N defaults to 1).</p>
  </dd>
  <dt>
    <p><em>continue</em> (optional)</p>
  </dt>
  <dd>
    <p>TakeNext, DontCont, EndMatch or GoTo &lt;label&gt; (apart from &lt;label&gt;, values are case insensitive). Specifies the point-of-continue after a match by <em>pattern</em> and <em>context</em>.</p>
  </dd>
  <dt>
    <p><em>ptype</em></p>
  </dt>
  <dd>
    <p>pattern type for <em>pattern</em> (value is case insensitive).</p>
  </dd>
  <dt>
    <p><em>pattern</em></p>
  </dt>
  <dd>
    <p>pattern.</p>
  </dd>
  <dt>
    <p><em>varmap</em> (optional)</p>
  </dt>
  <dd>
    <p>variable map for <em>pattern</em>.</p>
  </dd>
  <dt>
    <p><em>context</em> (optional)</p>
  </dt>
  <dd>
    <p>context expression, evaluated together with <em>pattern</em>.</p>
  </dd>
  <dt>
    <p><em>count</em> (optional)</p>
  </dt>
  <dd>
    <p>action list for execution after a match by <em>pattern</em> and <em>context</em>.</p>
  </dd>
  <dt>
    <p><em>thresh</em> (optional)</p>
  </dt>
  <dd>
    <p>counting threshold for events matched by <em>pattern</em> and <em>context</em> (value is an integer constant, default is 1).</p>
  </dd>
  <dt>
    <p><strong>...</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><em>continueN</em> (optional)</p>
  </dt>
  <dd>
    <p>TakeNext, DontCont, EndMatch or GoTo &lt;label&gt; (apart from &lt;label&gt;, values are case insensitive). Specifies the point-of-continue after a match by <em>patternN</em> and <em>contextN</em>.</p>
  </dd>
  <dt>
    <p><em>ptypeN</em></p>
  </dt>
  <dd>
    <p>pattern type for <em>patternN</em> (value is case insensitive).</p>
  </dd>
  <dt>
    <p><em>patternN</em></p>
  </dt>
  <dd>
    <p>pattern.</p>
  </dd>
  <dt>
    <p><em>varmapN</em> (optional)</p>
  </dt>
  <dd>
    <p>variable map for <em>patternN</em>.</p>
  </dd>
  <dt>
    <p><em>contextN</em> (optional)</p>
  </dt>
  <dd>
    <p>context expression, evaluated together with <em>patternN</em>.</p>
  </dd>
  <dt>
    <p><em>countN</em> (optional)</p>
  </dt>
  <dd>
    <p>action list for execution after a match by <em>patternN</em> and <em>contextN</em>.</p>
  </dd>
  <dt>
    <p><em>threshN</em> (optional)</p>
  </dt>
  <dd>
    <p>counting threshold for events matched by <em>patternN</em> and <em>contextN</em> (value is an integer constant, default is 1).</p>
  </dd>
  <dt>
    <p><em>desc</em></p>
  </dt>
  <dd>
    <p>operation description string.</p>
  </dd>
  <dt>
    <p><em>action</em></p>
  </dt>
  <dd>
    <p>action list.</p>
  </dd>
  <dt>
    <p><em>init</em> (optional)</p>
  </dt>
  <dd>
    <p>action list.</p>
  </dd>
  <dt>
    <p><em>end</em> (optional)</p>
  </dt>
  <dd>
    <p>action list.</p>
  </dd>
  <dt>
    <p><em>slide</em> (optional)</p>
  </dt>
  <dd>
    <p>action list.</p>
  </dd>
  <dt>
    <p><em>multact</em> (optional)</p>
  </dt>
  <dd>
    <p>Yes or No (values are case insensitive, default is No).</p>
  </dd>
  <dt>
    <p><em>window</em></p>
  </dt>
  <dd>
    <p>event correlation window size (value is an integer constant).</p>
  </dd>
  <dt>
    <p><em>rem</em> (optional, may appear more than once)</p>
  </dt>
  <dd>
    <p>remarks and comments.</p>
  </dd>

</dl>
<p>Note that match variables may be used in <em>context*</em>, <em>count*</em>, <em>desc</em>, <em>action</em>, <em>init</em>, <em>end</em>, and <em>slide</em> fields.</p><p><strong>Examples:</strong></p><p>The following example rule cross-correlates iptables events, Apache web server access log messages with 4xx response codes, and SSH login failure events:</p><p>type=EventGroup3</p><p>ptype=RegExp</p><p>pattern=sshd&#92;[&#92;d+&#92;]: Failed .+ for (?:invalid user )?&#92;S+ from ([&#92;d.]+) port &#92;d+ ssh2</p><p>thresh=2</p><p>ptype2=RegExp</p><p>pattern2=^([&#92;d.]+) &#92;S+ &#92;S+ &#92;[.+?&#92;] ".+? HTTP&#92;/[&#92;d.]+" 4&#92;d+</p><p>thresh2=3</p><p>ptype3=RegExp</p><p>pattern3=kernel: iptables:.* SRC=([&#92;d.]+)</p><p>thresh3=5</p><p>desc=Repeated probing from host $1</p><p>action=pipe '%t: %s' /bin/mail root@localhost</p><p>window=120</p><p>The rule starts an event correlation operation for an IP address if SSH login failure event, iptables event, or Apache 4xx event is observed for that IP address. The operation sends an e-mail warning to root@localhost if within 120 seconds three threshold conditions are satisfied for the IP address it tracks -- (1) at least two SSH login failure events have occurred for this client IP, (2) at least three Apache 4xx events have occured for this client IP, (3) at least five iptables events have been observed for this source IP.</p><p>Suppose the following events occur, and each event timestamp reflects the time SEC observes the event:</p><p>192.168.1.104 - - [05/Jan/2014:01:11:22 +0200] "GET /test.html HTTP/1.1" 404 286 "-" "Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:26.0) Gecko/20100101 Firefox/26.0"</p><p>Jan  5 01:12:52 localhost kernel: iptables: IN=eth0 OUT= MAC=08:00:27:8e:a1:3a:00:1d:e0:7e:89:b1:08:00 SRC=192.168.1.104 DST=192.168.1.107 LEN=60 TOS=0x10 PREC=0x00 TTL=64 ID=48422 DF PROTO=TCP SPT=46351 DPT=21 WINDOW=29200 RES=0x00 SYN URGP=0</p><p>Jan  5 01:12:53 localhost kernel: iptables: IN=eth0 OUT= MAC=08:00:27:8e:a1:3a:00:1d:e0:7e:89:b1:08:00 SRC=192.168.1.104 DST=192.168.1.107 LEN=60 TOS=0x10 PREC=0x00 TTL=64 ID=48423 DF PROTO=TCP SPT=46351 DPT=21 WINDOW=29200 RES=0x00 SYN URGP=0</p><p>Jan  5 01:13:01 localhost kernel: iptables: IN=eth0 OUT= MAC=08:00:27:8e:a1:3a:00:1d:e0:7e:89:b1:08:00 SRC=192.168.1.104 DST=192.168.1.107 LEN=60 TOS=0x10 PREC=0x00 TTL=64 ID=20048 DF PROTO=TCP SPT=44963 DPT=23 WINDOW=29200 RES=0x00 SYN URGP=0</p><p>Jan  5 01:13:02 localhost kernel: iptables: IN=eth0 OUT= MAC=08:00:27:8e:a1:3a:00:1d:e0:7e:89:b1:08:00 SRC=192.168.1.104 DST=192.168.1.107 LEN=60 TOS=0x10 PREC=0x00 TTL=64 ID=20049 DF PROTO=TCP SPT=44963 DPT=23 WINDOW=29200 RES=0x00 SYN URGP=0</p><p>Jan  5 01:13:08 localhost kernel: iptables: IN=eth0 OUT= MAC=08:00:27:8e:a1:3a:00:1d:e0:7e:89:b1:08:00 SRC=192.168.1.104 DST=192.168.1.107 LEN=60 TOS=0x10 PREC=0x00 TTL=64 ID=36362 DF PROTO=TCP SPT=56918 DPT=25 WINDOW=29200 RES=0x00 SYN URGP=0</p><p>Jan  5 01:13:09 localhost kernel: iptables: IN=eth0 OUT= MAC=08:00:27:8e:a1:3a:00:1d:e0:7e:89:b1:08:00 SRC=192.168.1.104 DST=192.168.1.107 LEN=60 TOS=0x10 PREC=0x00 TTL=64 ID=36363 DF PROTO=TCP SPT=56918 DPT=25 WINDOW=29200 RES=0x00 SYN URGP=0</p><p>192.168.1.104 - - [05/Jan/2014:01:13:51 +0200] "GET /test.html HTTP/1.1" 404 286 "-" "Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:26.0) Gecko/20100101 Firefox/26.0"</p><p>192.168.1.104 - - [05/Jan/2014:01:13:54 +0200] "GET /test.html HTTP/1.1" 404 286 "-" "Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:26.0) Gecko/20100101 Firefox/26.0"</p><p>192.168.1.104 - - [05/Jan/2014:01:14:00 +0200] "GET /login.html HTTP/1.1" 404 287 "-" "Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:26.0) Gecko/20100101 Firefox/26.0"</p><p>192.168.1.104 - - [05/Jan/2014:01:14:03 +0200] "GET /login.html HTTP/1.1" 404 287 "-" "Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:26.0) Gecko/20100101 Firefox/26.0"</p><p>192.168.1.104 - - [05/Jan/2014:01:14:03 +0200] "GET /login.html HTTP/1.1" 404 287 "-" "Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:26.0) Gecko/20100101 Firefox/26.0"</p><p>Jan  5 01:14:11 localhost sshd[1810]: Failed password for root from 192.168.1.104 port 46125 ssh2</p><p>Jan  5 01:14:12 localhost sshd[1810]: Failed password for root from 192.168.1.104 port 46125 ssh2</p><p>Jan  5 01:14:18 localhost sshd[1822]: Failed password for root from 192.168.1.104 port 46126 ssh2</p><p>Jan  5 01:14:19 localhost sshd[1822]: Failed password for root from 192.168.1.104 port 46126 ssh2</p><p>192.168.1.104 - - [05/Jan/2014:01:14:34 +0200] "GET /test.html HTTP/1.1" 404 286 "-" "Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:26.0) Gecko/20100101 Firefox/26.0"</p><p>The Apache 4xx event at 01:11:22 starts an event correlation operation for 192.168.1.104 which has the event correlation window of 120 seconds, thus ending at 01:13:22. Between 01:12:52 and 01:13:09, six iptables events appear for 192.168.1.104, and the appearance of the fifth event at 01:13:08 fulfills the third threshold condition (within 120 seconds, at least five iptables events have been observed).</p><p>Since by 01:13:22 (the end of the event correlation window) no additional events have occurred, the first and second threshold condition remain unsatisfied. Therefore, the beginning of the event correlation window will be moved to 01:12:52 (the occurrence time of the earliest event which is at most 120 seconds old). As a result, the end of the window will move from 01:13:22 to 01:14:52. The only event which is left outside the window is the Apache 4xx event at 01:11:22, and thus the threshold condition for iptables events remains satisfied.</p><p>Between 01:13:51 and 01:14:03, five Apache 4xx events occur, and the appearance of the third event at 01:14:00 fulfills the second threshold condition (within 120 seconds, at least three Apache 4xx events have been observed). These events are followed by four SSH login failure events which occur between 01:14:11 and 01:14:19. The appearance of the second event at 01:14:12 fulfills the first threshold condition (within 120 seconds, at least two SSH login failure events have been observed). Since at this particular moment (01:14:12) the other two conditions are also fulfilled, the operation sends an e-mail warning about 192.168.1.104 to root@localhost. After that, the operation silently consumes all further matching events for 192.168.1.104 until 01:14:52, and then terminates.</p><p>Please note that if the above rule definition would contain <em>multact=yes</em> statement, the operation would continue sending e-mails at each matching event after 01:14:12, provided that all threshold conditions are satisfied. Therefore, the operation would send three additional e-mails at 01:14:18, 01:14:19, and 01:14:34. Also, the operation would not terminate after its window ends at 01:14:52, but would rather slide the window forward and expect new events. At the occurence of any iptables, SSH login failure or Apache 4xx event for 192.168.1.104, the operation would produce a warning e-mail if all threshold conditions are fulfilled.</p><p>The following example rule cross-correlates iptables events and SSH login events:</p><p>type=EventGroup3</p><p>ptype=regexp</p><p>pattern=sshd&#92;[&#92;d+&#92;]: Failed .+ for (&#92;S+) from ([&#92;d.]+) port &#92;d+ ssh2</p><p>varmap= user=1; ip=2</p><p>count=alias OPER_$+{ip} LOGIN_FAILED_$+{user}_$+{ip}</p><p>ptype2=regexp</p><p>pattern2=sshd&#92;[&#92;d+&#92;]: Accepted .+ for (&#92;S+) from ([&#92;d.]+) port &#92;d+ ssh2</p><p>varmap2= user=1; ip=2</p><p>context2=LOGIN_FAILED_$+{user}_$+{ip}</p><p>ptype3=regexp</p><p>pattern3=kernel: iptables:.* SRC=([&#92;d.]+)</p><p>varmap3= ip=1</p><p>desc=Client $+{ip} accessed a firewalled port and had difficulties with logging in</p><p>action=pipe '%t: %s' /bin/mail root@localhost</p><p>init=create OPER_$+{ip}</p><p>slide=delete OPER_$+{ip}; reset 0</p><p>end=delete OPER_$+{ip}</p><p>window=120</p><p>The rule starts an event correlation operation for an IP address if SSH login failure or iptables event was observed for that IP address. The operation exists for 120 seconds (since when the event correlation window slides forward, the operation terminates itself with the <em>reset</em> action as specified with the <em>slide</em> field). The operation sends an e-mail warning to root@localhost if within 120 seconds three threshold conditions are satisfied for the IP address it tracks -- (1) at least one iptables event has been observed for this source IP, (2) at least one SSH login failure has been observed for this client IP, (3) at least one successful SSH login has been observed for this client IP and for some user, provided that the operation has previously observed an SSH login failure for the same user and same client IP.</p><p>Suppose the following events occur, and each event timestamp reflects the time SEC observes the event:</p><p>Dec 27 19:00:06 test kernel: iptables: IN=eth0 OUT= MAC=00:13:72:8a:83:d2:00:1b:25:07:e2:1b:08:00 SRC=10.1.2.7 DST=10.2.5.5 LEN=60 TOS=0x00 PREC=0x00 TTL=62 ID=1881 DF PROTO=TCP SPT=34342 DPT=23 WINDOW=5840 RES=0x00 SYN URGP=0</p><p>Dec 27 19:00:14 test sshd[10520]: Accepted password for root from 10.1.2.7 port 52609 ssh2</p><p>Dec 27 19:00:24 test sshd[10526]: Failed password for risto from 10.1.2.7 port 52622 ssh2</p><p>Dec 27 19:00:27 test sshd[10526]: Accepted password for risto from 10.1.2.7 port 52622 ssh2</p><p>The iptables event at 19:00:06 starts an event correlation operation for 10.1.2.7 which has the event correlation window of 120 seconds. Immediately after the operation has been started, it creates the context OPER_10.1.2.7. The second event at 19:00:14 does not match the rule, since the context LOGIN_FAILED_root_10.1.2.7 does not exist. The third event at 19:00:24 matches the rule, and the operation which is running for 10.1.2.7 sets up the alias name LOGIN_FAILED_risto_10.1.2.7 for the context OPER_10.1.2.7. Finally, the fourth event at 19:00:27 matches the rule, since the context LOGIN_FAILED_risto_10.1.2.7 exists, and the event is therefore processed by the operation (the presence of the context indicates that the operation has previously observed a login failure for user risto from 10.1.2.7). At this particular moment (19:00:27), all three threshold conditions for the operation are fulfilled, and therefore it sends an e-mail warning about 10.1.2.7 to root@localhost. After that, the operation silently consumes all further matching events for 10.1.2.7 until 19:02:06, and then terminates. Immediately before termination, the operation deletes the context OPER_10.1.2.7 which also drops its alias name LOGIN_FAILED_risto_10.1.2.7.</p>
<h3>SUPPRESS RULE</h3>
<p>The <strong>Suppress</strong> rule takes no action when an event has matched the rule, and keeps matching events from being processed by later rules in the configuration file.</p><p>The Suppress rule supports the following fields:</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>type</em></p>
  </dt>
  <dd>
    <p>fixed to Suppress (value is case insensitive).</p>
  </dd>
  <dt>
    <p><em>ptype</em></p>
  </dt>
  <dd>
    <p>pattern type (value is case insensitive).</p>
  </dd>
  <dt>
    <p><em>pattern</em></p>
  </dt>
  <dd>
    <p>pattern.</p>
  </dd>
  <dt>
    <p><em>varmap</em> (optional)</p>
  </dt>
  <dd>
    <p>variable map.</p>
  </dd>
  <dt>
    <p><em>context</em> (optional)</p>
  </dt>
  <dd>
    <p>context expression.</p>
  </dd>
  <dt>
    <p><em>desc</em> (optional)</p>
  </dt>
  <dd>
    <p>string for describing the rule.</p>
  </dd>
  <dt>
    <p><em>rem</em> (optional, may appear more than once)</p>
  </dt>
  <dd>
    <p>remarks and comments.</p>
  </dd>

</dl>
<p>Note that match variables may be used in the <em>context</em> field. Also note that this rule does not start an event correlation operation, and the optional <em>desc</em> field is merely used for describing the rule.</p><p><strong>Examples:</strong></p><p>type=Suppress</p><p>ptype=RegExp</p><p>pattern=sshd&#92;[&#92;d+&#92;]: Failed .+ for &#92;S+ from ([&#92;d.]+) port &#92;d+ ssh2</p><p>context=SUPPRESS_IP_$1</p><p>type=SingleWithThreshold</p><p>ptype=RegExp</p><p>pattern=sshd&#92;[&#92;d+&#92;]: Failed .+ for (&#92;S+) from ([&#92;d.]+) port &#92;d+ ssh2</p><p>desc=Three SSH login failures within 1m for user $1 from $2</p><p>action=pipe '%t: %s' /bin/mail root@localhost; &#92;</p>
<pre>
       create SUPPRESS_IP_$2 3600
</pre>
<p>window=60</p><p>thresh=3</p><p>The first rule filters out SSH login failure events for an already reported source IP address, so that they will not be matched against the second rule during 3600 seconds after sending an e-mail warning.</p>
<h3>CALENDAR RULE</h3>
<p>The <strong>Calendar</strong> rule was designed for executing actions at specific times. Unlike all other rules, this rule reacts only to the system clock, ignoring other input. The Calendar rule executes the action list given with the <em>action</em> field if the current time matches all conditions of the time specification given with the <em>time</em> field. The action list is executed only once for any matching minute.</p><p>The rule employs a time specification which closely resembles the <a href="../man1/crontab.1.html"><strong>crontab</strong>(1)</a> style, but there are some subtle differences. The time specification consists of five or six conditions separated by whitespace. The first condition matches minutes (allowed values are 0-59), the second condition matches hours (allowed values are 0-23), the third condition days (allowed values are 0-31, with 0 denoting the last day of the month), the fourth condition months (allowed values are 1-12), and the fifth condition weekdays (allowed values are 0-7, with 0 and 7 denoting Sunday). The sixth condition is optional and matches years (allowed values are 0-99 which denote the last two digits of the year).</p><p>Asterisks (*), ranges of numbers (e.g., 8-11), and lists (e.g., 2,5,7-9) are allowed as conditions. Asterisks and ranges may be augmented with step values (e.g., 47-55/2 means 47,49,51,53,55).</p><p>Note that unlike <a href="../man1/crontab.1.html"><strong>crontab</strong>(1)</a> time specification, the day and weekday conditions are *not* joined with logical OR, but rather with logical AND. Therefore, 0 1 25-31 10 7 means 1AM on last Sunday in October. On the other hand, with <a href="../man1/crontab.1.html"><strong>crontab</strong>(1)</a> the same specification means 1AM in every last seven days or every Sunday in October. Also, unlike some versions of <a href="../man8/cron.8.html"><strong>cron</strong>(8)</a>, SEC is not restricted to take action only during the first second of the current minute (for example, if SEC is started at the 22th second of a minute, the wildcard condition produces a match for this minute).</p><p>The Calendar rule supports the following fields:</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>type</em></p>
  </dt>
  <dd>
    <p>fixed to Calendar (value is case insensitive).</p>
  </dd>
  <dt>
    <p><em>time</em></p>
  </dt>
  <dd>
    <p>time specification.</p>
  </dd>
  <dt>
    <p><em>context</em> (optional)</p>
  </dt>
  <dd>
    <p>context expression.</p>
  </dd>
  <dt>
    <p><em>desc</em></p>
  </dt>
  <dd>
    <p>operation description string.</p>
  </dd>
  <dt>
    <p><em>action</em></p>
  </dt>
  <dd>
    <p>action list.</p>
  </dd>
  <dt>
    <p><em>rem</em> (optional, may appear more than once)</p>
  </dt>
  <dd>
    <p>remarks and comments.</p>
  </dd>

</dl>
<p>Note that this rule does not start event correlation operation, and the <em>desc</em> field is merely used for setting the %s action list variable.</p><p><strong>Examples:</strong></p><p>type=Calendar</p><p>time=0 2 25-31 3,12 6</p><p>desc=Check if backup is done on last Saturday of Q1 and Q4</p><p>action=event WAITING_FOR_BACKUP</p><p>type=Calendar</p><p>time=0 2 24-30 6,9 6</p><p>desc=Check if backup is done on last Saturday of Q2 and Q3</p><p>action=event WAITING_FOR_BACKUP</p><p>type=PairWithWindow</p><p>ptype=SubStr</p><p>pattern=WAITING_FOR_BACKUP</p><p>desc=Quarterly backup not completed on time!</p><p>action=pipe '%t: %s' /bin/mail root@localhost</p><p>ptype2=SubStr</p><p>pattern2=BACKUP READY</p><p>desc2=Quarterly backup successfully completed</p><p>action2=none</p><p>window=1800</p><p>The first two rules create a synthetic event WAITING_FOR_BACKUP at 2AM on last Saturday of March, June, September and December. The third rule matches this event and starts an event correlation operation which waits for the BACKUP READY event for 1800 seconds. If this event has not arrived by 2:30AM, the operation sends an e-mail warning to root@localhost.</p>
<h3>JUMP RULE</h3>
<p>The <strong>Jump</strong> rule submits matching events to specific ruleset(s) for further processing. If the event matches the rule, SEC continues the search for matching rules in configuration file set(s) given with the <em>cfset</em> field. Rules from every file are tried in the order of their appearance in the file. Configuration file sets can be created from Options rules with the <em>joincfset</em> field, with each set containing at least one configuration file. If more that one set name is given with <em>cfset</em>, sets are processed from left to right; a matching rule in one set doesn't prevent SEC from processing the following sets. If the <em>constset</em> field is set to Yes, set names are assumed to be constants and will not be searched for match variables at runtime.</p><p>The Jump rule supports the following fields:</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>type</em></p>
  </dt>
  <dd>
    <p>fixed to Jump (value is case insensitive).</p>
  </dd>
  <dt>
    <p><em>continue</em> (optional)</p>
  </dt>
  <dd>
    <p>TakeNext, DontCont, EndMatch or GoTo &lt;label&gt; (apart from &lt;label&gt;, values are case insensitive).</p>
  </dd>
  <dt>
    <p><em>ptype</em></p>
  </dt>
  <dd>
    <p>pattern type (value is case insensitive).</p>
  </dd>
  <dt>
    <p><em>pattern</em></p>
  </dt>
  <dd>
    <p>pattern.</p>
  </dd>
  <dt>
    <p><em>varmap</em> (optional)</p>
  </dt>
  <dd>
    <p>variable map.</p>
  </dd>
  <dt>
    <p><em>context</em> (optional)</p>
  </dt>
  <dd>
    <p>context expression.</p>
  </dd>
  <dt>
    <p><em>cfset</em> (optional)</p>
  </dt>
  <dd>
    <p>configuration file set names that are separated by whitespace.</p>
  </dd>
  <dt>
    <p><em>constset</em> (optional)</p>
  </dt>
  <dd>
    <p>Yes or No (values are case insensitive, default is Yes).</p>
  </dd>
  <dt>
    <p><em>desc</em> (optional)</p>
  </dt>
  <dd>
    <p>string for describing the rule.</p>
  </dd>
  <dt>
    <p><em>rem</em> (optional, may appear more than once)</p>
  </dt>
  <dd>
    <p>remarks and comments.</p>
  </dd>

</dl>
<p>Note that match variables may be used in the <em>context</em> and <em>cfset</em> fields. Also note that this rule does not start event correlation operations, and the optional <em>desc</em> field is merely used for describing the rule.</p><p>Finally, if the <em>cfset</em> field is not present and the <em>continue</em> field is set to GoTo, the Jump rule can be used for skipping rules inside the current configuration file; if both <em>cfset</em> and <em>continue</em> are not present, Jump is identical to Suppress.</p><p><strong>Examples:</strong></p><p>type=Jump</p><p>ptype=RegExp</p><p>pattern=sshd&#92;[&#92;d+&#92;]:</p><p>cfset=sshd-rules auth-rules</p><p>When an sshd syslog message appears in input, rules from configuration files of the set <strong>sshd-rules</strong> are first used for matching the message, and then rules from the configuration file set <strong>auth-rules</strong> are tried.</p>
<h3>OPTIONS RULE</h3>
<p>The <strong>Options</strong> rule sets processing options for the ruleset in the current configuration file. If more than one Options rule is present in the configuration file, the last instance overrides all previous ones. Note that the Options rule is only processed when SEC (re)starts and reads in the configuration file. Since this rule is not applied at runtime, it can never match events, react to the system clock, or start event correlation operations.</p><p>The <em>joincfset</em> field lists the names of one or more configuration file sets, and the current configuration file will be added to each set. If a set doesn't exist, it will be created and the current configuration file becomes its first member. If the <em>procallin</em> field is set to No, the rules from the configuration file will be used for matching input from Jump rules only.</p><p>The Options rule supports the following fields:</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>type</em></p>
  </dt>
  <dd>
    <p>fixed to Options (value is case insensitive).</p>
  </dd>
  <dt>
    <p><em>joincfset</em> (optional)</p>
  </dt>
  <dd>
    <p>configuration file set names that are separated by whitespace.</p>
  </dd>
  <dt>
    <p><em>procallin</em> (optional)</p>
  </dt>
  <dd>
    <p>Yes or No (values are case insensitive, default is Yes).</p>
  </dd>
  <dt>
    <p><em>rem</em> (optional, may appear more than once)</p>
  </dt>
  <dd>
    <p>remarks and comments.</p>
  </dd>

</dl>
<p><strong>Examples:</strong></p><p>The following rule adds the current configuration file to the set <strong>sshd-rules</strong> which is used for matching input from Jump rules only:</p><p>type=Options</p><p>joincfset=sshd-rules</p><p>procallin=no</p><p>The following rule adds the current configuration file to sets <strong>linux</strong> and <strong>solaris</strong> which are used for matching all input:</p><p>type=Options</p><p>joincfset=linux solaris</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EVENT CORRELATION OPERATIONS</h2>
        <div class="sectioncontent">
<p>In order to identify event correlation operations, SEC assigns an ID to every operation that is composed from the configuration file name, the rule number, and the operation description string (defined by the <em>desc</em> field of the rule). If there are N rules in the configuration file, the rule numbers belong to the range 0..N-1, and the number of the k-th rule is k-1. Note that since the configuration file name and rule number are part of the operation ID, different rules can have identical <em>desc</em> fields without a danger of a clash between operations.</p><p>For example, if the configuration file my.conf contains only one rule</p><p>type=SingleWithThreshold</p><p>ptype=RegExp</p><p>pattern=user (&#92;S+) login failure on (&#92;S+)</p><p>desc=Repeated login failures for user $1 on $2</p><p>action=pipe '%t: %s' /bin/mail root@localhost</p><p>window=60</p><p>thresh=3</p><p>then the number of this rule is 0. When this rule matches an input event "user admin login failure on tty1", the <em>desc</em> field yields an operation description string <em>Repeated login failures for user admin on tty1</em>, and the event will be processed by the operation with the following ID:</p><p>my.conf | 0 | Repeated login failures for user admin on tty1</p><p>(If the operation for this ID does not exist, SEC will start it.) By tuning the <em>desc</em> field of the rule, the scope of individual event correlation operations can be changed. For instance, the above rule starts three event correlation operations for the following events:</p><p>user admin login failure on tty1</p><p>user admin login failure on tty5</p><p>user admin login failure on tty2</p><p>However, if the <em>desc</em> field is set to <em>Repeated login failures for user $1</em>, these events are processed by the *same* event correlation operation.</p><p>Each operation has an event correlation window which defines its scope in time. The size of the window is defined by the <em>window*</em> field, and the beginning of the window can be obtained with the <em>getwpos</em> action. SingleWithThreshold, SingleWith2Thresholds and EventGroup operations can slide its window forward during event processing, while for all operations the window can also be moved explicitly with the <em>setwpos</em> action. Also, with the <em>reset</em> action event correlation operations can be terminated. Note that <em>getwpos</em>, <em>setwpos</em>, and <em>reset</em> actions only work for operations started by the rules from the same configuration file.</p><p>For example, consider the configuration file /etc/sec/sshd.rules that contains the following rules:</p><p>type=SingleWithThreshold</p><p>ptype=RegExp</p><p>pattern=sshd&#92;[&#92;d+&#92;]: Failed .+ for (&#92;S+) from [&#92;d.]+ port &#92;d+ ssh2</p><p>desc=Three SSH login failures within 1m for user $1</p><p>action=pipe '%t: %s' /bin/mail root@localhost</p><p>window=60</p><p>thresh=3</p><p>type=Single</p><p>ptype=RegExp</p><p>pattern=sshd&#92;[&#92;d+&#92;]: Accepted .+ for (&#92;S+) from [&#92;d.]+ port &#92;d+ ssh2</p><p>desc=SSH login successful for user $1</p><p>action=reset -1 Three SSH login failures within 1m for user $1</p><p>Suppose the following events are generated by an SSH daemon, and each event timestamp reflects the time SEC observes the event:</p><p>Dec 29 15:00:03 test sshd[14129]: Failed password for risto from 10.1.2.7 port 31312 ssh2</p><p>Dec 29 15:00:08 test sshd[14129]: Failed password for risto from 10.1.2.7 port 31312 ssh2</p><p>Dec 29 15:00:17 test sshd[14129]: Accepted password for risto from 10.1.2.7 port 31312 ssh2</p><p>Dec 29 15:00:52 test sshd[14142]: Failed password for risto from 10.1.1.2 port 17721 ssh2</p><p>The first event at 15:00:03 starts an event correlation operation with the ID</p><p>/etc/sec/sshd.rules | 0 | Three SSH login failures within 1m for user risto</p><p>However, when the third event occurs at 15:00:17, the second rule matches it and terminates the operation with the action</p><p>reset -1 Three SSH login failures within 1m for user risto</p><p>The -1 parameter of <em>reset</em> restricts the action to operations started by the previous rule (i.e., the first rule that has a number 0), while the <em>Three SSH login failures within 1m for user risto</em> parameter refers to the operation description string. Together with the current configuration file name (/etc/sec/sshd.rules), the parameters yield the operation ID</p><p>/etc/sec/sshd.rules | 0 | Three SSH login failures within 1m for user risto</p><p>(If the operation with the given ID would not exist, <em>reset</em> would perform no operation.)</p><p>As a consequence, the fourth event at 15:00:52 starts another operation with the same ID as the terminated operation had. Without the second rule, the operation that was started at 15:00:03 would not be terminated, and the appearance of the fourth event would trigger a warning e-mail from that operation.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUT PROCESSING AND TIMING</h2>
        <div class="sectioncontent">
<p>SEC processes input data iteratively by reading one line at each iteration, writing this line into a relevant input buffer, and matching the content of the updated buffer with rules from configuration files. If during the matching process an action list is executed which creates new input events (e.g., through the <em>event</em> action), they are *not* written to buffer(s) immediately, but rather consumed at following iterations.</p><p>Note that when both synthetic events and regular input are available for processing, synthetic events are always consumed first. When all synthetic events have been consumed iteratively, SEC will start processing new data from input files.</p><p>With the <strong>--jointbuf</strong> option, SEC employs a joint input buffer for all input sources which holds N last input lines (the value of N can be set with the <strong>--bufsize</strong> option). Updating the input buffer means that the new line becomes the first element of the buffer, while the last element (the oldest line) is removed from the end of the buffer. With the <strong>--nojointbuf</strong> option, SEC maintains a buffer of N lines for each input file, and if the input line comes from file F, the buffer of F is updated as described previously. There is also a separate buffer for synthetic and internal events.</p><p>Suppose SEC is started with the following command line</p><p>/usr/bin/sec --conf=/etc/sec/test-multiline.conf --jointbuf &#92;</p>
<pre>
             --input=/var/log/prog1.log --input=/var/log/prog2.log
</pre>
<p>and the configuration file /etc/sec/test-multiline.conf has the following content:</p><p>type=Single</p><p>rem=this rule matches two consecutive lines where the first &#92;</p>
<pre>
    line contains "test1" and the second line "test2", and &#92;
    writes the matching lines to standard output
</pre>
<p>ptype=RegExp2</p><p>pattern=test1.*&#92;n.*test2</p><p>desc=two consecutive test lines</p><p>action=write - $0</p><p>When the following lines appear in input files /var/log/prog1.log and /var/log/prog2.log</p><p>Dec 31 12:33:12 test prog1: test1 (file /var/log/prog1.log)</p><p>Dec 31 12:34:09 test prog2: test1 (file /var/log/prog2.log)</p><p>Dec 31 12:39:35 test prog1: test2 (file /var/log/prog1.log)</p><p>Dec 31 12:41:53 test prog2: test2 (file /var/log/prog2.log)</p><p>they are stored in a common input buffer. Therefore, rule fires after the third event has appeared, and writes the following lines to standard output:</p><p>Dec 31 12:34:09 test prog2: test1 (file /var/log/prog2.log)</p><p>Dec 31 12:39:35 test prog1: test2 (file /var/log/prog1.log)</p><p>However, if SEC is started with the <strong>--nojointbuf</strong> option, separate input buffers are set up for /var/log/prog1.log and /var/log/prog2.log. Therefore, the rule fires after the third event has occurred, and writes the following lines to standard output:</p><p>Dec 31 12:33:12 test prog1: test1 (file /var/log/prog1.log)</p><p>Dec 31 12:39:35 test prog1: test2 (file /var/log/prog1.log)</p><p>The rule also fires after the fourth event has occurred, producing the following output:</p><p>Dec 31 12:34:09 test prog2: test1 (file /var/log/prog2.log)</p><p>Dec 31 12:41:53 test prog2: test2 (file /var/log/prog2.log)</p><p>The content of input buffers can be modified with the <em>rewrite</em> action, and modifications become visible immediately during ongoing event processing iteration. Suppose SEC is started with the following command line</p><p>/usr/bin/sec --conf=/etc/sec/test-rewrite.conf &#92;</p>
<pre>
             --input=- --nojointbuf
</pre>
<p>and the configuration file /etc/sec/test-rewrite.conf has the following content:</p><p>type=Single</p><p>rem=this rule matches two consecutive lines where the first &#92;</p>
<pre>
    line contains "test1" and the second line "test2", and &#92;
    joins these lines in the input buffer
</pre>
<p>ptype=RegExp2</p><p>pattern=^(.*test1.*)&#92;n(.*test2.*)$</p><p>continue=TakeNext</p><p>desc=join two test lines</p><p>action=rewrite 2 Joined $1 and $2</p><p>type=Single</p><p>rem=this rule matches a line which begins with "Joined", &#92;</p>
<pre>
    and writes this line to standard output
</pre>
<p>ptype=RegExp</p><p>pattern=^Joined</p><p>desc=output joined lines</p><p>action=write - $0</p><p>When the following two lines appear in standard input</p><p>This is a test1</p><p>This is a test2</p><p>they are matched by the first rule which uses the <em>rewrite</em> action for replacing those two lines in the input buffer with a new content. The last line in the input buffer ("This is a test2") is replaced with "Joined This is a test1 and This is a test2", while the previous line in the input buffer ("This is a test1") is replaced with an empty string. Since the rule contains <em>continue=TakeNext</em> statement, the matching process will continue from the following rule. This rule matches the last line in the input buffer if it begins with "Joined", and writes the line to standard output, producing</p><p>Joined This is a test1 and This is a test2</p><p>After each event processing iteration, the pattern match cache is cleared. In other words, if a match is cached with the rule <em>varmap*</em> field, it is available during ongoing iteration only. Note that results from a successful pattern matching are also cached when the subsequent context expression evaluation yields FALSE. This allows for reusing results from partial rule matches. For example, the following rule creates the cache entry "ssh_failed_login" for any SSH failed login event, even if the context ALERTING_ON does not exist:</p><p>type=Single</p><p>ptype=RegExp</p><p>pattern=sshd&#92;[&#92;d+&#92;]: Failed .+ for (&#92;S+) from ([&#92;d.]+) port &#92;d+ ssh2</p><p>varmap=ssh_failed_login; user=1; ip=2</p><p>context=ALERTING_ON</p><p>desc=SSH login failure for user $1 from $2</p><p>action=pipe '%s' /bin/mail -s 'SSH login alert' root@localhost</p><p>However, provided the context expression does not contain match variables, enclosing the expression in square brackets (e.g., [ALERTING_ON]) forces its evaluation before the pattern matching, and will thus prevent the matching and the creation of the cache entry if the evaluation yields FALSE.</p><p>Rules from the same configuration file are matched against the buffer content in the order they are given in that file. When multiple configuration files have been specified, rule sequences from all files are matched against the buffer content (unless specified otherwise with Options rules). The matching order is determined by the order of configuration files in SEC command line. For example, if the Perl <strong>glob</strong>() function returns filenames in ascending ASCII order, and configuration files /home/risto/A.conf, /home/risto/B.conf2, and /home/risto/C.conf are specified with <strong>--conf=/home/risto/*.conf --conf=/home/risto/*.conf2</strong> in SEC command line, then SEC first matches the input against the rule sequence from A.conf, then from C.conf, and finally from B.conf2. Also, note that even if A.conf contains a Suppress rule for a particular event, the event is still processed by rulesets in C.conf and B.conf2. However, note that <strong>glob</strong>() might return file names in different order if locale settings change. If you want to enforce a fixed order for configuration file application in a portable way, it is recommended to create a unique set for each file with the Options rule, and employ the Jump rule for defining the processing order for sets, e.g.:</p><p># This rule appears in A.conf</p><p>type=Options</p><p>joincfset=FileA</p><p>procallin=no</p><p># This rule appears in B.conf2</p><p>type=Options</p><p>joincfset=FileB</p><p>procallin=no</p><p># This rule appears in C.conf</p><p>type=Options</p><p>joincfset=FileC</p><p>procallin=no</p><p># This rule appears in main.conf</p><p>type=Jump</p><p>ptype=TValue</p><p>pattern=TRUE</p><p>cfset=FileA FileC FileB</p><p>After the relevant input buffer has been updated and its content has been matched by the rules, SEC handles caught signals and checks the status of child processes. When the timeout specified with the <strong>--cleantime</strong> option has expired, SEC also checks the status of contexts and event correlation operations. Therefore, relatively small values should be specified with the <strong>--cleantime</strong> option, in order to retain the accuracy of the event correlation process. If the <strong>--cleantime</strong> option is set to 0, SEC checks event correlation operations and contexts after processing every input line, but this consumes more CPU time. If the <strong>--poll-timeout</strong> option value exceeds the value given with <strong>--cleantime</strong>, the <strong>--poll-timeout</strong> option value takes precedence (i.e., sleeps after unsuccessful polls will not be shortened).</p><p>Finally, note that apart from the sleeps after unsuccessful polls, SEC measures all time intervals and occurrence times in seconds, and always uses the <a href="../man2/time.2.html"><strong>time</strong>(2)</a> system call for obtaining the current time. Also, for input event occurrence time SEC always uses the time it observed the event, *not* the timestamp extracted from the event.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INTERNAL EVENTS AND CONTEXTS</h2>
        <div class="sectioncontent">
<p>In the action list of a context, the context can also be referred with the internal context name _THIS. The name _THIS is created and deleted dynamically by SEC and it points to the context only during its action list execution. This feature is useful when the context has had several names during its lifetime (created with the <em>alias</em> action), and it is hard to determine which names exist when the context expires. For example, if the context is created with <em>create A 60 (report A /bin/mail root)</em> which is immediately followed by <em>alias A B</em> and <em>unalias A</em>, the <em>report</em> action will fail since the name A no longer refers to the context. However, replacing the first action with <em>create A 60 (report _THIS /bin/mail root)</em> will produce the correct result.</p><p>If the <strong>--intevents</strong> command line option is given, SEC will generate internal events when it is started up, when it receives certain signals, and when it terminates normally. Inside SEC, internal event is treated as if it was a line that was read from a SEC input file. Specific rules can be written to match internal events, in order to take some action (e.g., start an external event correlation module with <em>spawn</em> when SEC starts up). The following internal events are supported:</p><p>SEC_STARTUP - generated when SEC is started (this event will always be the first event that SEC sees)</p><p>SEC_RESTART - generated after SEC has received the <strong>SIGHUP</strong> signal and all internal data structures have been cleared (this event will be the first event that SEC sees after reloading its configuration)</p><p>SEC_SOFTRESTART - generated after SEC has received the <strong>SIGABRT</strong> signal (this event will be the first event that SEC sees after reloading its configuration)</p><p>SEC_LOGROTATE - generated after SEC has received the <strong>SIGUSR2</strong> signal (this event will be the first event that SEC sees after reopening its log file and closing its outputs)</p><p>SEC_SHUTDOWN - generated when SEC receives the <strong>SIGTERM</strong> signal, or when SEC reaches all EOFs of input files after being started with the <strong>--notail</strong> option. With the <strong>--childterm</strong> option, SEC sleeps for 3 seconds after generating SEC_SHUTDOWN event, and then sends SIGTERM to its child processes (if a child process was triggered by SEC_SHUTDOWN, this delay leaves the process enough time for setting a signal handler for SIGTERM).</p><p>Before generating an internal event, SEC sets up a context named SEC_INTERNAL_EVENT, in order to disambiguate internal events from regular input. The SEC_INTERNAL_EVENT context is deleted immediately after the internal event has been matched against all rules.</p><p>If the <strong>--intcontexts</strong> command line option is given, or there is an <strong>--input</strong> option with a context specified, SEC creates an internal context each time it reads a line from an input file or a synthetic event. The internal context is deleted immediately after the line has been matched against all rules. For all input files that have the context name explicitly set with <strong>--input=&lt;file_pattern&gt;=&lt;context&gt;</strong>, the name of the internal context is &lt;context&gt;. If the line was read from the input file &lt;filename&gt; for which there is no context name set, the name of the internal context is _FILE_EVENT_&lt;filename&gt;. For synthetic events, the name of the internal context defaults to _INTERNAL_EVENT, but <em>cspawn</em> and <em>cevent</em> actions can be used for generating synthetic events with custom internal context names. This allows for writing rules that match data from one particular input source only. For example, the rule</p><p>type=Suppress</p><p>ptype=TValue</p><p>pattern=TRUE</p><p>context=[!_FILE_EVENT_/dev/logpipe]</p><p>passes only the lines that were read from /dev/logpipe, and also synthetic events that were generated with the _FILE_EVENT_/dev/logpipe internal context (e.g., with the action <em>cevent _FILE_EVENT_/dev/logpipe 0 This is a test event</em>). As another example, if SEC has been started with the command line</p><p>/usr/bin/sec --intevents --intcontexts --conf=/etc/sec/my.conf &#92;</p>
<pre>
             --input=/var/log/messages=MESSAGES &#92;
             --input=/var/log/secure=SECURE &#92;
             --input=/var/log/cron=CRON
</pre>
<p>and the rule file /etc/sec/my.conf contains the following rules</p><p>type=Single</p><p>ptype=RegExp</p><p>pattern=^(?:SEC_STARTUP|SEC_RESTART)$</p><p>context=[SEC_INTERNAL_EVENT]</p><p>desc=listen on 10514/tcp for incoming events</p><p>action=cspawn MESSAGES /usr/bin/nc -l -k 10514</p><p>type=Single</p><p>ptype=RegExp</p><p>pattern=.</p><p>context=[MESSAGES]</p><p>desc=echo everything from 10514/tcp and /var/log/messages</p><p>action=write - $0</p><p>then SEC will receive input lines from the log files /var/log/messages, /var/log/secure, and /var/log/cron, and will also run /usr/bin/nc for receiving input lines from the port 10514/tcp. All input lines from /var/log/messages and 10514/tcp are matched by the second rule and written to standard output.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INTERPROCESS COMMUNICATION</h2>
        <div class="sectioncontent">
<p>The SingleWithScript rule and <em>shellcmd</em>, <em>spawn</em>, <em>cspawn</em>, <em>pipe</em>, and <em>report</em> actions fork a child process for executing an external program. If the program command line contains shell metacharacters, the command line is first parsed by the shell which then starts the program. SEC communicates with its child processes through pipes (created with the <a href="../man2/pipe.2.html"><strong>pipe</strong>(2)</a> system call). When the child process is at the read end of the pipe, data have to be written to the pipe in blocking mode which ensures reliable data transmission. In order to avoid being blocked, SEC forks another child process for writing data to the pipe reliably.</p><p>After forking an external program, SEC continues immediately, and checks the program status periodically until the program exits. The running time of a child process is not limited in any way. With the <strong>--childterm</strong> option, SEC sends the <strong>SIGTERM</strong> signal to all child processes when it terminates. If some special exit procedures need to be accomplished in the child process (or the child wishes to ignore <strong>SIGTERM</strong>), then the child must install a handler for the <strong>SIGTERM</strong> signal. Note that if the program command line contains shell metacharacters, the parsing shell will run as a child process of SEC and the parent process of the program. Therefore, the <strong>SIGTERM</strong> signal will be sent to the shell, *not* the program. In order to avoid this, the shell's builtin <em>exec</em> command can be used (see <strong>sh</strong>(1) for more information) which replaces the shell with the program without forking a new process, e.g.,</p><p>action=spawn exec /usr/local/bin/myscript.pl 2&gt;/var/log/myscript.log</p><p>Note that if an action list includes two actions which fork external programs, the execution order these programs is not determined by the order of actions in the list, since both programs are running asynchronously. In order to address this issue, the execution order must be specified explicitly (e.g., instead of writing <em>action=shellcmd cmd1; shellcmd cmd2</em>, use the shell && operator and write <em>action=shellcmd cmd1 && cmd2</em>).</p><p>Sometimes it is desireable to start an external program and provide it with data from several rules. In order to create such setup, names pipes can be used. For example, if /var/log/pipe is a named pipe, then</p><p>action=shellcmd /usr/bin/logger -f /var/log/pipe -p user.notice</p><p>starts the /usr/bin/logger utility which sends all lines read from /var/log/pipe to the local syslog daemon with the "user" facility and "notice" level. In order to feed events to /usr/bin/logger, the <em>write</em> action can be used (e.g., <em>write /var/log/pipe This is my event</em>). Although SEC keeps the named pipe open across different <em>write</em> actions, the pipe will be closed on the reception of SIGHUP, SIGABRT and SIGUSR2 signals. Since a number of command line tools terminate on receiving EOF from input, they need restarting after such signals have arrived. For this purpose, the <strong>--intevents</strong> option and SEC internal events can be used. For example, the following rule starts the /usr/bin/logger utility at SEC startup, and also restarts it after the reception of relevant signals:</p><p>type=Single</p><p>ptype=RegExp</p><p>pattern=^(?:SEC_STARTUP|SEC_RESTART|SEC_SOFTRESTART|SEC_LOGROTATE)$</p><p>context=SEC_INTERNAL_EVENT</p><p>desc=start the logger tool</p><p>action=free %emptystring; owritecl /var/log/pipe %emptystring; &#92;</p>
<pre>
       shellcmd /usr/bin/logger -f /var/log/pipe -p user.notice
</pre>
<p>Note that if /var/log/pipe is never opened for writing by a <em>write</em> action, /usr/bin/logger will never see EOF and will thus not terminate. The <em>owritecl</em> action opens and closes /var/log/pipe, in order to ensure the presence of EOF in such cases.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PERL INTEGRATION</h2>
        <div class="sectioncontent">
<p>SEC supports patterns, context expressions, and actions which involve calls to the Perl <strong>eval</strong>() function or the execution of precompiled Perl code. The use of Perl code in SEC patterns and context expressions allows for creating proper match conditions for scenarios which can't be handled by a simple regular expression match. For example, consider the following iptables syslog events:</p><p>May 27 10:00:15 box1 kernel: iptables: IN=eth0 OUT= MAC=08:00:27:be:9e:2f:00:10:db:ff:20:03:08:00 SRC=10.6.4.14 DST=10.1.8.2 LEN=84 TOS=0x00 PREC=0x00 TTL=251 ID=61426 PROTO=ICMP TYPE=8 CODE=0 ID=11670 SEQ=2</p><p>May 27 10:02:22 box1 kernel: iptables: IN=eth0 OUT= MAC=08:00:27:be:9e:2f:00:10:db:ff:20:03:08:00 SRC=10.6.4.14 DST=10.1.8.2 LEN=52 TOS=0x00 PREC=0x00 TTL=60 ID=61441 DF PROTO=TCP SPT=53125 DPT=23 WINDOW=49640 RES=0x00 SYN URGP=0</p><p>Depending on the protocol and the nature of the traffic, events can have a wide variety of fields, and parsing out all event data with one regular expression is infeasible. For addressing this issue, a PerlFunc pattern can be used which creates match variables from all fields of the matching event, stores them in one Perl hash, and returns a reference to this hash. Outside the PerlFunc pattern, match variables are initialized from the key-value pairs in the returned hash. Suppose the following Jump rule with a PerlFunc pattern is defined in the main.rules rule file:</p><p>type=Jump</p><p>ptype=PerlFunc</p><p>pattern=sub { my(%var); my($line) = $_[0]; &#92;</p>
<pre>
        if ($line !~ /kernel: iptables:/g) { return 0; } &#92;
        while ($line =~ /&#92;G&#92;s*([A-Z]+)(?:=(&#92;S*))?/g) { &#92;
          $var{$1} = defined($2)?$2:1; &#92;
        } return \var; }
</pre>
<p>varmap=IPTABLES</p><p>desc=parse iptables event</p><p>cfset=iptables</p><p>For example, if the iptables event contains the fields SRC=10.6.4.14, DST=10.1.8.2 and SYN, the above PerlFunc pattern sets up match variable $+{SRC} which holds 10.6.4.14, match variable $+{DST} which holds 10.1.8.2, and match variable $+{SYN} which holds 1. The Jump rule caches all created match variables under the name IPTABLES, and submits the matching event to <strong>iptables</strong> ruleset for further processing. Suppose the <strong>iptables</strong> ruleset is defined in the iptables.rules rule file:</p><p>type=Options</p><p>procallin=no</p><p>joincfset=iptables</p><p>type=SingleWithThreshold</p><p>ptype=Cached</p><p>pattern=IPTABLES</p><p>context=IPTABLES :&gt; ( sub { return $_[0]-&gt;{"PROTO"} eq "ICMP"; } )</p><p>desc=ICMP flood type $+{TYPE} code $+{CODE} from host $+{SRC}</p><p>action=logonly</p><p>window=10</p><p>thresh=100</p><p>type=SingleWithThreshold</p><p>ptype=Cached</p><p>pattern=IPTABLES</p><p>context=IPTABLES :&gt; ( sub { return exists($_[0]-&gt;{"SYN"}) && &#92;</p>
<pre>
                                   exists($_[0]-&gt;{"FIN"}) ; } )
</pre>
<p>desc=SYN+FIN flood from host $+{SRC}</p><p>action=logonly</p><p>window=10</p><p>thresh=100</p><p>The two SingleWithThreshold rules employ Cached patterns for matching iptables events by looking up the IPTABLES entry in the pattern match cache (created by the above Jump rule for each iptables event). In order to narrow down the match to specific iptables events, the rules employ precompiled Perl functions in context expressions. The :&gt; operator is used for speeding up the matching, providing the function with a single parameter which refers to the hash of variable name-value pairs for the IPTABLES cache entry.</p><p>The first SingleWithThreshold rule logs a warning message if within 10 seconds 100 iptables events have been observed for ICMP packets with the same type, code, and source IP address. The second SingleWithThreshold rule logs a warning message if within 10 seconds 100 iptables events have been observed for TCP packets coming from the same host, and having both SYN and FIN flag set in each packet.</p><p>Apart from using action list variables for data sharing between rules, Perl variables created in Perl code can be employed for the same purpose. For example, when SEC has executed the following action</p><p>action=eval %a ($b = 1)</p><p>the variable $b and its value become visible in the following context expression</p><p>context= =(++$b &gt; 10)</p><p>(with that expression one can implement event counting implicitly). In order to avoid possible clashes with variables inside the SEC code itself, user-defined Perl code is executed in the main::SEC namespace (i.e., inside the special package main::SEC). By using the main:: prefix, SEC data structures can be accessed and modified. For example, the following rules restore and save contexts on SEC startup and shutdown (SEC keeps all contexts in %main::context_list hash):</p><p>type=Single</p><p>ptype=SubStr</p><p>pattern=SEC_STARTUP</p><p>context=SEC_INTERNAL_EVENT</p><p>continue=TakeNext</p><p>desc=Load the Storable module and terminate if it is not found</p><p>action=eval %ret (require Storable); &#92;</p>
<pre>
       if %ret ( logonly Storabe loaded ) else ( eval %o <strong>exit</strong>(1) )
</pre>
<p>type=Single</p><p>ptype=SubStr</p><p>pattern=SEC_STARTUP</p><p>context=SEC_INTERNAL_EVENT</p><p>desc=Restore all SEC contexts from /tmp/SEC_CONTEXTS on startup</p><p>action=lcall %ret -&gt; ( sub { %main::context_list = &#92;</p>
<pre>
       %{Storable::retrieve("/tmp/SEC_CONTEXTS")}; } )
</pre>
<p>type=Single</p><p>ptype=SubStr</p><p>pattern=SEC_SHUTDOWN</p><p>context=SEC_INTERNAL_EVENT</p><p>desc=Save all SEC contexts into /tmp/SEC_CONTEXTS on shutdown</p><p>action=lcall %ret -&gt; ( sub { &#92;</p>
<pre>
       Storable::store(\main::context_list, "/tmp/SEC_CONTEXTS"); } )
</pre>
<p>However, note that modifying data structures within SEC code is recommended only for advanced users who have carefully studied relevant parts of the code.</p><p>Finally, sometimes larger chunks of Perl code have to be used for event processing and correlation. However, writing many lines of code directly into a rule is cumbersome and may decrease its readability. In such cases it is recommended to separate the code into a custom Perl module which is loaded at SEC startup, and use the code through the module interface (see <strong>perlmod</strong>(1) for further details):</p><p>type=Single</p><p>ptype=SubStr</p><p>pattern=SEC_STARTUP</p><p>context=SEC_INTERNAL_EVENT</p><p>desc=Load the SecStuff module</p><p>action=eval %ret (require '/usr/local/sec/SecStuff.pm'); &#92;</p>
<pre>
       if %ret ( none ) else ( eval %o <strong>exit</strong>(1) )
</pre>
<p>type=Single</p><p>ptype=PerlFunc</p><p>pattern=sub { return SecStuff::my_match($_[0]); }</p><p>desc=event '$0' was matched by my_match()</p><p>action=write - %s</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<h3>Example 1 - a ruleset for Cisco events</h3>
<p>This section presents an example rulebase for managing Cisco devices. It is assumed that the managed devices have syslog logging enabled, and that all syslog messages are sent to a central host and written to logfile(s) that are monitored by SEC.</p><p># Set up contexts NIGHT and WEEKEND for nights</p><p># and weekends. The context NIGHT has a lifetime</p><p># of 8 hours and the context WEEKEND 2 days</p><p>type=Calendar</p><p>time=0 23 * * *</p><p>desc=NIGHT</p><p>action=create %s 28800</p><p>type=Calendar</p><p>time=0 0 * * 6</p><p>desc=WEEKEND</p><p>action=create %s 172800</p><p># If a router does not come up within 5 minutes</p><p># after it was rebooted, generate event</p><p># "&lt;router&gt; REBOOT FAILURE". The next rule matches</p><p># this event, checks the router with ping and sends</p><p># a notification if there is no response.</p><p>type=PairWithWindow</p><p>ptype=RegExp</p><p>pattern=&#92;s([&#92;w.-]+) &#92;d+: %SYS-5-RELOAD</p><p>desc=$1 REBOOT FAILURE</p><p>action=event %s</p><p>ptype2=RegExp</p><p>pattern2=&#92;s$1 &#92;d+: %SYS-5-RESTART</p><p>desc2=%1 successful reboot</p><p>action2=logonly</p><p>window=300</p><p>type=SingleWithScript</p><p>ptype=RegExp</p><p>pattern=^([&#92;w.-]+) REBOOT FAILURE</p><p>script=/bin/ping -c 3 -q $1</p><p>desc=$1 did not come up after reboot</p><p>action=logonly $1 is pingable after reboot</p><p>action2=pipe '%t: %s' /bin/mail root@localhost</p><p># Send a notification if CPU load of a router is too</p><p># high (two CPUHOG messages are received within 5</p><p># minutes); send another notification if the load is</p><p># normal again (no CPUHOG messages within last 15</p><p># minutes). Rule is not active at night or weekend.</p><p>type=SingleWith2Thresholds</p><p>ptype=RegExp</p><p>pattern=&#92;s([&#92;w.-]+) &#92;d+: %SYS-3-CPUHOG</p><p>context=!(NIGHT || WEEKEND)</p><p>desc=$1 CPU overload</p><p>action=pipe '%t: %s' /bin/mail root@localhost</p><p>window=300</p><p>thresh=2</p><p>desc2=$1 CPU load normal</p><p>action2=pipe '%t: %s' /bin/mail root@localhost</p><p>window2=900</p><p>thresh2=0</p><p># If a router interface is in down state for less</p><p># than 15 seconds, generate event</p><p># "&lt;router&gt; INTERFACE &lt;interface&gt; SHORT OUTAGE";</p><p># otherwise generate event</p><p># "&lt;router&gt; INTERFACE &lt;interface&gt; DOWN".</p><p>type=PairWithWindow</p><p>ptype=RegExp</p><p>pattern=&#92;s([&#92;w.-]+) &#92;d+: %LINK-3-UPDOWN: Interface ([&#92;w.-]+), changed state to down</p><p>desc=$1 INTERFACE $2 DOWN</p><p>action=event %s</p><p>ptype2=RegExp</p><p>pattern2=&#92;s$1 &#92;d+: %LINK-3-UPDOWN: Interface $2, changed state to up</p><p>desc2=%1 INTERFACE %2 SHORT OUTAGE</p><p>action2=event %s</p><p>window=15</p><p># If "&lt;router&gt; INTERFACE &lt;interface&gt; DOWN" event is</p><p># received, send a notification and wait for</p><p># "interface up" event from the same router interface</p><p># for the next 24 hours</p><p>type=Pair</p><p>ptype=RegExp</p><p>pattern=^([&#92;w.-]+) INTERFACE ([&#92;w.-]+) DOWN</p><p>desc=$1 interface $2 is down</p><p>action=pipe '%t: %s' /bin/mail root@localhost</p><p>ptype2=RegExp</p><p>pattern2=&#92;s$1 &#92;d+: %LINK-3-UPDOWN: Interface $2, changed state to up</p><p>desc2=%1 interface %2 is up</p><p>action2=pipe '%t: %s' /bin/mail root@localhost</p><p>window=86400</p><p># If ten "short outage" events have been observed</p><p># in the window of 6 hours, send a notification</p><p>type=SingleWithThreshold</p><p>ptype=RegExp</p><p>pattern=^([&#92;w.-]+) INTERFACE ([&#92;w.-]+) SHORT OUTAGE</p><p>desc=Interface $2 at node $1 is unstable</p><p>action=pipe '%t: %s' /bin/mail root@localhost</p><p>window=21600</p><p>thresh=10</p>
<h3>Example 2 - hierarchically organized rulesets for iptables and sshd events</h3>
<p>This section presents an example of hierarchically organized rules for processing Linux iptables events from /var/log/messages and SSH login events from /var/log/secure. It is assumed that all rule files reside in the /etc/sec directory and that the rule hierarchy has two levels. The file /etc/sec/main.rules contains first-level Jump rules for matching and parsing events from input files and submitting them to proper rulesets for further processing. All other rule files in the /etc/sec directory contain second-level rules which receive their input from first-level Jump rules. Also, the example assumes that SEC is started with the following command line:</p><p>/usr/bin/sec --conf=/etc/sec/*.rules --intcontexts &#92;</p>
<pre>
             --input=/var/log/messages --input=/var/log/secure
</pre>
<p>#</p><p># the content of /etc/sec/main.rules</p><p>#</p><p>type=Jump</p><p>context=[ _FILE_EVENT_/var/log/messages ]</p><p>ptype=PerlFunc</p><p>pattern=sub { my(%var); my($line) = $_[0]; &#92;</p>
<pre>
        if ($line !~ /kernel: iptables:/g) { return 0; } &#92;
        while ($line =~ /&#92;G&#92;s*([A-Z]+)(?:=(&#92;S*))?/g) { &#92;
          $var{$1} = defined($2)?$2:1; &#92;
        } return \var; }
</pre>
<p>varmap=IPTABLES</p><p>desc=parse iptables events and direct to relevant ruleset</p><p>cfset=iptables</p><p>type=Jump</p><p>context=[ _FILE_EVENT_/var/log/secure ]</p><p>ptype=RegExp</p><p>pattern=sshd&#92;[(?&lt;pid&gt;&#92;d+)\]: (?&lt;status&gt;Accepted|Failed) &#92;</p><p>(?&lt;authmethod&gt;[&#92;w-]+) for (?&lt;invuser&gt;invalid user )?&#92;</p><p>(?&lt;user&gt;[&#92;w-]+) from (?&lt;srcip&gt;[&#92;d.]+) port (?&lt;srcport&gt;&#92;d+) ssh2$</p><p>varmap=SSH_LOGIN</p><p>desc=parse SSH login events and direct to relevant ruleset</p><p>cfset=ssh-login</p><p>type=Jump</p><p>context=[ _INTERNAL_EVENT ]</p><p>ptype=TValue</p><p>pattern=True</p><p>desc=direct synthetic events to relevant ruleset</p><p>cfset=ssh-events</p><p>#</p><p># the content of /etc/sec/iptables.rules</p><p>#</p><p>type=Options</p><p>procallin=no</p><p>joincfset=iptables</p><p>type=SingleWithThreshold</p><p>ptype=Cached</p><p>pattern=IPTABLES</p><p>context=IPTABLES :&gt; ( sub { return exists($_[0]-&gt;{"SYN"}) && &#92;</p>
<pre>
                                   exists($_[0]-&gt;{"FIN"}) ; } ) &#92;
        && !SUPPRESS_IP_$+{SRC}
</pre>
<p>desc=SYN+FIN flood from host $+{SRC}</p><p>action=pipe '%t: %s' /bin/mail -s 'iptables alert' root@localhost; &#92;</p>
<pre>
       create SUPPRESS_IP_$+{SRC} 3600
</pre>
<p>window=10</p><p>thresh=100</p><p>type=SingleWithThreshold</p><p>ptype=Cached</p><p>pattern=IPTABLES</p><p>context=IPTABLES :&gt; ( sub { return exists($_[0]-&gt;{"SYN"}) && &#92;</p>
<pre>
                                  !exists($_[0]-&gt;{"ACK"}) ; } ) &#92;
        && !SUPPRESS_IP_$+{SRC}
</pre>
<p>desc=SYN flood from host $+{SRC}</p><p>action=pipe '%t: %s' /bin/mail -s 'iptables alert' root@localhost; &#92;</p>
<pre>
       create SUPPRESS_IP_$+{SRC} 3600
</pre>
<p>window=10</p><p>thresh=100</p><p>#</p><p># the content of /etc/sec/ssh-login.rules</p><p>#</p><p>type=Options</p><p>procallin=no</p><p>joincfset=ssh-login</p><p>type=Single</p><p>ptype=Cached</p><p>pattern=SSH_LOGIN</p><p>context=SSH_LOGIN :&gt; ( sub { return $_[0]-&gt;{"status"} eq "Failed" && &#92;</p>
<pre>
                                    $_[0]-&gt;{"srcport"} &lt; 1024 && &#92;
                                    defined($_[0]-&gt;{"invuser"}); } )
</pre>
<p>continue=TakeNext</p><p>desc=Probe of invalid user $+{user} from privileged port of $+{srcip}</p><p>action=pipe '%t: %s' /bin/mail -s 'SSH alert' root@localhost</p><p>type=SingleWithThreshold</p><p>ptype=Cached</p><p>pattern=SSH_LOGIN</p><p>context=SSH_LOGIN :&gt; ( sub { return $_[0]-&gt;{"status"} eq "Failed" && &#92;</p>
<pre>
                                    defined($_[0]-&gt;{"invuser"}); } )
</pre>
<p>desc=Ten login probes for invalid users from $+{srcip} within 60s</p><p>action=pipe '%t: %s' /bin/mail -s 'SSH alert' root@localhost</p><p>thresh=10</p><p>window=60</p><p>type=PairWithWindow</p><p>ptype=Cached</p><p>pattern=SSH_LOGIN</p><p>context=SSH_LOGIN :&gt; ( sub { return $_[0]-&gt;{"status"} eq "Failed"; } )</p><p>desc=User $+{user} failed to log in from $+{srcip} within 60s</p><p>action=event %s</p><p>ptype2=Cached</p><p>pattern2=SSH_LOGIN</p><p>context2=SSH_LOGIN :&gt; &#92;</p>
<pre>
           ( sub { return $_[0]-&gt;{"status"} eq "Accepted"; } ) && &#92;
         $+{user} %+{user} $+{srcip} %+{srcip} -&gt; &#92;
           ( sub { return $_[0] eq $_[1]  &&  $_[2] eq $_[3]; }  )
</pre>
<p>desc2=User $+{user} logged in successfully from $+{srcip} within 60s</p><p>action2=logonly</p><p>window=60</p><p>#</p><p># the content of /etc/sec/ssh-events.rules</p><p>#</p><p>type=Options</p><p>procallin=no</p><p>joincfset=ssh-events</p><p>type=SingleWithThreshold</p><p>ptype=RegExp</p><p>pattern=User ([&#92;w-]+) failed to log in from [&#92;d.]+ within 60s</p><p>desc=Ten login failures for user $1 within 1h</p><p>action=pipe '%t: %s' /bin/mail -s 'SSH alert' root@localhost</p><p>thresh=10</p><p>window=3600</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ENVIRONMENT</h2>
        <div class="sectioncontent">
<p>If the <strong></strong> SECRC environment variable is set, SEC expects it to contain the name of its resource file. Resource file lines which are empty or which begin with the number sign (#) are ignored (whitespace may precede #). Each remaining line is appended to the <strong>argv</strong> array of SEC as a *single* element. Also, the lines are appended to <strong>argv</strong> in the order they appear in the resource file. Therefore, if the SEC command line option has a value, the option name and the value must either be separated by the equal sign (=) or a newline. Here is a simple resource file example:</p><p># read events from standard input</p><p>--input=-</p><p># rules are stored in /etc/sec/test.conf</p><p>--conf</p><p>/etc/sec/test.conf</p><p>Note that although SEC rereads its resource file at the reception of the <strong>SIGHUP</strong> or <strong>SIGABRT</strong> signal, adding an option that specifies a certain startup procedure (e.g., <strong>--pid</strong> or <strong>--detach</strong>) will not produce the desired effect at runtime. Also note that the resource file content is *not* parsed by shell, therefore shell metacharacters are passed to SEC as-is.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SIGNALS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>SIGHUP</strong></p>
  </dt>
  <dd>
    <p>full restart -- SEC will reinterpret its command line and resource file options, reopen its log and input files, close its output files and sockets (these will be reopened on demand), reload its configuration, and drop *all* event correlation state (all event correlation operations will be terminated, all contexts will be deleted, all action list variables will be erased, etc.). With the <strong>--childterm</strong> option, SEC will also send the <strong>SIGTERM</strong> signal to its child processes.</p>
  </dd>
  <dt>
    <p><strong>SIGABRT</strong></p>
  </dt>
  <dd>
    <p>soft restart -- SEC will reinterpret its command line and resource file options, reopen its log file, and close its output files and sockets (these will be reopened on demand). If the <strong>--keepopen</strong> option is specified, previously opened input files will remain open across soft restart, otherwise all input files will be reopened. SEC will (re)load configuration from rule files which have been modified (file modification time returned by <a href="../man2/stat.2.html"><strong>stat</strong>(2)</a> has changed) or created after the previous configuration load. SEC will also terminate event correlation operations started from rule files that have been modified or removed after the previous configuration load. Other operations and previously loaded configuration from unmodified rule files will remain intact. Note that on some systems <strong>SIGIOT</strong> is used in place of <strong>SIGABRT</strong>.</p>
  </dd>
  <dt>
    <p><strong>SIGUSR1</strong></p>
  </dt>
  <dd>
    <p>detailed information about the current state of SEC (performance and rule matching statistics, running event correlation operations, created contexts, etc.) will be written to the SEC dumpfile.</p>
  </dd>
  <dt>
    <p><strong>SIGUSR2</strong></p>
  </dt>
  <dd>
    <p>SEC will reopen its logfile (useful for logfile rotation), and also close its output files and sockets which will be reopened on demand.</p>
  </dd>
  <dt>
    <p><strong>SIGINT</strong></p>
  </dt>
  <dd>
    <p>SEC will increase its logging level by one; if the current level is 6, the level will be set back to 1. Please note this feature is available only if SEC is running non-interactively (e.g., in daemon mode).</p>
  </dd>
  <dt>
    <p><strong>SIGTERM</strong></p>
  </dt>
  <dd>
    <p>SEC will terminate gracefully. With the <strong>--childterm</strong> option, all SEC child processes will receive <strong>SIGTERM</strong>.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>With some locale settings, apostrophes (') in this man page might be displayed incorrectly. As a workaround, set the LANG environment variable to C when reading this man page (e.g., env LANG=C man sec).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Risto Vaarandi (ristov at users d0t s0urcef0rge d0t net)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ACKNOWLEDGMENTS</h2>
        <div class="sectioncontent">
<p>This work is supported by SEB. The author thanks the following people for supplying software patches, documentation fixes, and suggesting new features: Al Sorrell, David Lang, James Brown, Jon Frazier, Mark D. Nagel, Peter Eckel, Rick Casey, and William Gertz. Last but not least, the author expresses his profound gratitute to John P. Rouillard for many great ideas and creative discussions that have helped to develop SEC.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO sec&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man8/cron.8.html"><strong>cron</strong>(8)</a>, <a href="../man1/crontab.1.html"><strong>crontab</strong>(1)</a>, <a href="../man1/date.1.html"><strong>date</strong>(1)</a>, <a href="../man2/fork.2.html"><strong>fork</strong>(2)</a>, <strong>mail</strong>(1), <strong>perl</strong>(1), <strong>perlmod</strong>(1), <strong>perlre</strong>(1), <a href="../man2/pipe.2.html"><strong>pipe</strong>(2)</a>, <strong>sh</strong>(1), <a href="../man1/snmptrap.1.html"><strong>snmptrap</strong>(1)</a>, <a href="../man2/stat.2.html"><strong>stat</strong>(2)</a>, <a href="../man3/syslog.3.html"><strong>syslog</strong>(3)</a>, <a href="../man2/time.2.html"><strong>time</strong>(2)</a></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="seaview.1.html"><span aria-hidden="true">&larr;</span> seaview.1: A multiplatform, graphical user interface for multiple sequence alignment and molecular phylogeny.</a></li>
   <li class="next"><a href="sec2ts.1.html">sec2ts.1: Tool from opencaster suite <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

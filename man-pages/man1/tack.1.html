<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>tack: Terminfo action checker</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Terminfo action checker">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="tack (1) manual">
  <meta name="twitter:description" content="Terminfo action checker">
  <meta name="twitter:image" content="https://www.carta.tech/images/tack-tack-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/tack.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="tack (1) manual" />
  <meta property="og:description" content="Terminfo action checker" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/tack-tack-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">tack<small> (1)</small></h1>
        <p class="lead">Terminfo action checker</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/tack.1.html">
      <span itemprop="name">tack: Terminfo action checker</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/tack/">
      <span itemprop="name">tack</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/tack.1.html">
      <span itemprop="name">tack: Terminfo action checker</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>tack</strong> [-itV] [term]</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The <strong>tack</strong> program has three purposes: (1) to help you build a new terminfo entry describing an unknown terminal, (2) to test the correctness of an existing entry, and (3) to develop the correct pad timings needed to ensure that screen updates don't fall behind the incoming data stream.</p><p><strong>Tack</strong> presents a series of screen-painting and interactive tests in ways which are intended to make any mismatches between the terminfo entry and reality visually obvious. <strong>Tack</strong> also provides tools that can help in understanding how the terminal operates.</p><h3>OPTIONS</h3>

<dl class='dl-vertical'>
  <dt>
    <p><em>-i</em></p>
  </dt>
  <dd>
    <p>Usually <strong>tack</strong> will send the reset and init strings to the terminal when the program starts up.  The <em>-i</em> option will inhibit the terminal initialization.</p>
  </dd>
  <dt>
    <p><em>-t</em></p>
  </dt>
  <dd>
    <p>Tell <strong>tack</strong> to override the terminfo settings for basic terminal functions.  When this option is set <strong>tack</strong> will translate (cr) to &#92;r, (cud1) to &#92;n, (ind) to &#92;n, (nel) to &#92;r&#92;n, (cub1) to &#92;b, (bel) to &#92;007, (ff) to &#92;f and (ht) to &#92;t.</p>
  </dd>
  <dt>
    <p><em>-V</em></p>
  </dt>
  <dd>
    <p>Display the version information and exit.</p>
  </dd>
  <dt>
    <p><em>term</em></p>
  </dt>
  <dd>
    <p>Terminfo terminal name to be tested.  If not present then the $TERM environment variable will be used.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OVERVIEW</h2>
        <div class="sectioncontent">
<p>Since <strong>tack</strong> is designed to test terminfo's it is not possible to rely on the correctness of the terminfo data base.  Because of this the menuing system used with <strong>tack</strong> is vary primitive.  When a menu is printed it will scroll the entire screen.  To compensate for this verbose menu system <strong>tack</strong> permits menu selection type ahead. If you already know what action you would like <strong>tack</strong> to perform then you can enter that value immediately and avoid the menu display. When in doubt the question mark (?) is a good character to type. A carriage return will execute the default action.  These default actions are designed to run all the standard tests.</p><p>When <strong>tack</strong> first comes up it will display some basic information about the terminal.  Take some time to verify this information. If it is wrong many of the subsequent tests will fail.  The most important item is the screen size.  If the screen size is wrong there is no point in proceeding.  (home) and (clear) are also critical to the success of subsequent tests.  The values of (cr) (ind) (cub1) and (ht) may effect the tests if they are defined incorrectly. If they are undefined <strong>tack</strong> will set them to reasonable defaults. The last two entries on the display are the enquire and acknowledge strings. These strings are taken from the user strings (u9) and (u8).</p><p>By now you must be wondering why the terminfo names are enclosed in parenthesis.  This has no profound meaning other than it makes them stand out.  The <strong>tack</strong> program uses this convention any time it displays a terminfo name.  Remember <strong>tack</strong> is designed to rely on as little of the terminfo entry as possible.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CREATING NEW ENTRIES</h2>
        <div class="sectioncontent">
<p><strong>Tack</strong> has a number of tools that are designed to help gather information about the terminal.  Although these functions are not dependent on terminal type, you may wish to execute <strong>tack</strong> with options <em>-it</em>.  This will turn off initialization and default the standard entries.</p><p>These tools may be reached from the main menu by selecting the 'tools' entry.</p><p><strong>Echo tool</strong>:  All data typed from the keyboard will be echoed back to the terminal.  Control characters are not translated to the up arrow format but are sent as control characters.  This allows you to test an escape sequence and see what it actually does.  You may also elect to <strong>enable hex output on echo tool</strong> this will echo the characters in hexadecimal.  Once the test is running you may enter the 'lines' or 'columns' keywords which will display a pattern that will help you determine your screen size.  A complete list of keywords will be displayed when the test starts.  Type 'help' to redisplay the list of available commands.</p><p><strong>Reply tool</strong>:  This tool acts much like the echo tool, but control characters that are sent from the terminal more than one character after a carriage return will be expanded to the up arrow format.  For example on a standard ANSI terminal you may type:</p><p>		CR ESC [ c</p><p>and the response will be echoed as something like:</p><p>		^[ [ ? 6 c</p><p><strong>ANSI sgr display</strong>:  This test assumes you have an ANSI terminal.  It goes through attribute numbers 0 to 79, displaying each in turn and using that SGR number to write the text.  This shows you which of the SGR modes are actually implemented by the terminal.  Note: some terminals (such as Tektronix color) use the private use characters to augment the functionality of the SGR command.  These private use characters may be interjected into the escape sequence by typing the character ( &lt;, =, &gt;, ? ) after the original display has been shown.</p><p><strong>ANSI status reports</strong>:  This test queries the terminal in standard ANSI/VT-100 fashion.  The results of this test may help determine what options are supported by your terminal.</p><p><strong>ANSI character sets</strong>:  This test displays the character sets available on a ANSI/VT-100 style terminal. Character sets on a real VT-100 terminal are usually defined with smacs=&#92;E(0 and rmacs=&#92;E(B.  The first character after the escape defines the font bank.  The second character defines the character set.  This test allows you to view any of the possible combinations.  Private use character sets are defined by the digits. Standard character sets are located in the alphabetic range.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">VERIFYING AN EXISTING ENTRY</h2>
        <div class="sectioncontent">
<p>You can verify the correctness of an entry with the `begin testing' function.  This entry is the default action and will be chosen if you hit carriage return (or enter).  This will bring up a secondary menu that allows you to select more specific tests.</p><p>The general philosophy of the program is, for each capability, to send an appropriate test pattern to the terminal then send a description of what the user should expect.  Occasionally (as when checking function-key capabilities) the program will ask you to enter input for it to check.</p><p>If the test fails then you have the option of dynamically changing the terminfo entry and re-running the test.  This is done with the 'edit terminfo' menu item.  The edit submenu allows you to change the offending terminfo entry and immediately retest the capability. The edit menu lets you do other things with the terminfo, such as; display the entire terminfo entry, display which caps have been tested and display which caps cannot be tested.  This menu also allows you to write the newly modified terminfo to disc.  If you have made any modifications to the terminfo <strong>tack</strong> will ask you if you want to save the file to disc before it exits.  The filename will be the same as the terminal name. After the program exits you can run the tic(1M) compiler on the new terminfo to install it in the terminfo data base.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CORRECTING PAD TIMINGS</h2>
        <div class="sectioncontent">
<h3>Theory of Overruns and Padding</h3>
<p>Some terminals require significant amounts of time (that is, more than one transmitted-character interval) to do screen updates that change large portions of the screen, such as screen clears, line insertions, line deletions, and scrolls (including scrolls triggered by line feeds or a write to the lowest, right-hand-most cell of the screen).</p><p>If the computer continues to send characters to the terminal while one of these time-consuming operations is going on, the screen may be garbled. Since the length of a character transmission time varies inversely with transmission speed in cps, entries which function at lower speeds may break at higher speeds.</p><p>Similar problems result if the host machine is simply sending characters at a sustained rate faster than the terminal can buffer and process them.  In either case, when the terminal cannot process them and can't tell the host to stop soon enough, it will just drop them.  The dropped characters could be text, escape sequences or the escape character itself, causing some really strange-looking displays.  This kind of glitch is called an <em>overrun</em>.</p><p>In terminfo entries, you can attach a <strong>pad time</strong> to each string capability that is a number of milliseconds to delay after sending it.  This will give the terminal time to catch up and avoid overruns.</p><p>If you are running a software terminal emulator, or you are on an X pseudo-tty, or your terminal is on an RS-232C line which correctly handles RTS/CTS hardware flow control, then pads are not strictly necessary.  However, some display packages (such as ncurses(3X)) use the pad counts to calculate the fastest way to implement certain functions. For example: scrolling the screen may be faster than deleting the top line.</p><p>One common way to avoid overruns is with XON/XOFF handshaking. But even this handshake may have problems at high baud rates. This is a result of the way XON/XOFF works.  The terminal tells the host to stop with an XOFF.  When the host gets this character, it stops sending.  However, there is a small amount of time between the stop request and the actual stop.  During this window, the terminal must continue to accept characters even though it has told the host to stop.  If the terminal sends the stop request too late, then its internal buffer will overflow.  If it sends the stop character too early, then the terminal is not getting the most efficient use out of its internal buffers.  In a real application at high baud rates, a terminal could get a dozen or more characters before the host gets around to suspending transmission.  Connecting the terminal over a network will make the problem much worse.</p><p>(RTS/CTS handshaking does not have this problem because the UARTs are signal-connected and the "stop flow" is done at the lowest level, without software intervention).</p>
<h3>Timing your terminal</h3>
<p>In order to get accurate timings from your terminal <strong>tack</strong> needs to know when the terminal has finished processing all the characters that were sent.  This requires a different type of handshaking than the XON/XOFF that is supported by most terminals.  <strong>Tack</strong> needs to send a request to the terminal and wait for its reply. Many terminals will respond with an ACK when they receive an ENQ. This is the preferred method since the sequence is short. ANSI/VT-100 style terminals can mimic this handshake with the escape sequence that requests 'primary device attributes'.</p>
<pre>
   ESC [ c
</pre>
<p>The terminal will respond with a sequence like:</p>
<pre>
   ESC [ ? 1 ; 0 c
</pre>
<p><strong>Tack</strong> assumes that (u9) is the enquire sequence and that (u8) is the acknowledge string.  A VT-100 style terminal could set u9=&#92;E[c and u8=&#92;E[?1;0c. Acknowledge strings fall into two categories. 1) Strings with a unique terminating character and, 2) strings of fixed length. The acknowledge string for the VT-100 is of the first type since it always ends with the letter 'c'.  Some Tektronics terminals have fixed length acknowledge strings.  <strong>Tack</strong> supports both types of strings by scanning for the terminating character until the length of the expected acknowledge string has arrived. (u8) should be set to some typical acknowledge that will be returned when (u9) is sent.</p><p><strong>Tack</strong> will test this sequence before running any of the pad tests or the function key tests.  <strong>Tack</strong> will ask you the following:</p>
<pre>
    Hit lower case g to start testing...
</pre>
<p>After it sends this message it will send the enquire string. It will then read characters from the terminal until it sees the letter g.</p>
<h3>Testing and Repairing Pad Timings</h3>
<p>The pad timings in distributed terminfo entries are often incorrect.  One major motivation for this program is to make it relatively easy to tune these timings.</p><p>You can verify and edit the pad timings for a terminal with the `test string capabilities' function (this is also part of the `normal test sequence' function).</p><p>The key to determining pad times is to find out the effective baud rate of the terminal.  The effective baud rate determines the number of characters per second that the terminal can accept without either handshaking or losing data.  This rate is frequently less than the nominal cps rate on the RS-232 line.</p><p><strong>Tack</strong> uses the effective baud rate to judge the duration of the test and how much a particular escape sequence will perturb the terminal.</p><p>Each pad test has two associated variables that can be tweaked to help verify the correctness of the pad timings.  One is the pad test length.  The other is the pad multiplier, which is used if the pad prefix includes `*'.  In curses use, it is often the first parameter of the capability (if there is one). For a capability like (dch) or (il) this will be the number of character positions or lines affected, respectively.</p><p><strong>Tack</strong> will run the pad tests and display the results to the terminal. On capabilities that have multipliers <strong>tack</strong> will not tell you if the pad needs the multiplier or not.  You must make this decision yourself by rerunning the test with a different multiplier. If the padding changes in proportion to the multiplier than the multiplier is required.  If the multiplier has little or no effect on the suggested padding then the multiplier is not needed. Some capabilities will take several runs to get a good feel for the correct values.  You may wish to make the test longer to get more accurate results.  System load will also effect the results (a heavily loaded system will not stress the terminal as much, possibly leading to pad timings that are too short).</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTE</h2>
        <div class="sectioncontent">
<p>The tests done at the beginning of the program are assumed to be correct later in the code.  In particular, <strong>tack</strong> displays the number of lines and columns indicated in the terminfo entry as part of its initial output. If these values are wrong a large number of tests will fail or give incorrect results.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILES</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p>tack.log</p>
  </dt>
  <dd>
    <p>If logging is enabled then all characters written to the terminal will also be written to the log file.  This gives you the ability to see how the tests were performed.  This feature is disabled by default.</p>
  </dd>
  <dt>
    <p><em>term</em></p>
  </dt>
  <dd>
    <p>If you make changes to the terminfo entry <strong>tack</strong> will save the new terminfo to a file.  The file will have the same name as the terminal name.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO tack&hellip;</h2>
        <div class="sectioncontent">
<p><strong>terminfo</strong>(\*n), <strong>ncurses</strong>(3X), <strong>tic</strong>(1M), <strong>infocmp</strong>(1M). You should also have the documentation supplied by the terminal manufacturer.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>If the screen size is incorrect, many of the tests will fail.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Concept, design, and original implementation by Daniel Weaver &lt;danw@znyx.com&gt;.  Portions of the code and documentation are by Eric S. Raymond &lt;esr@snark.thyrsus.com&gt;.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="tachyon.1.html"><span aria-hidden="true">&larr;</span> tachyon.1: Parallel ray-tracer</a></li>
   <li class="next"><a href="tagainijisho.1.html">tagainijisho.1: Japanese dictionary and learning assistant <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

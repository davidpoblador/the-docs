<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>xsdcxx: W3c xml schema to c++ compiler</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="W3c xml schema to c++ compiler">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="xsdcxx (1) manual">
  <meta name="twitter:description" content="W3c xml schema to c++ compiler">
  <meta name="twitter:image" content="https://www.carta.tech/images/xsdcxx-xsdcxx-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/xsdcxx.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="xsdcxx (1) manual" />
  <meta property="og:description" content="W3c xml schema to c++ compiler" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/xsdcxx-xsdcxx-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">xsdcxx<small> (1)</small></h1>
        <p class="lead">W3c xml schema to c++ compiler</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/xsdcxx.1.html">
      <span itemprop="name">xsdcxx: W3c xml schema to c++ compiler</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/xsdcxx/">
      <span itemprop="name">xsdcxx</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/xsdcxx.1.html">
      <span itemprop="name">xsdcxx: W3c xml schema to c++ compiler</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>xsdcxx</strong> <em>command</em> <strong>[</strong> <em>options</em> <strong>]</strong> <em>file</em> <strong>[</strong> <em>file</em> <strong>...]</strong> <strong>xsdcxx help</strong> <strong>[</strong> <em>command</em> <strong>]</strong> <strong>xsdcxx version</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><strong>xsdcxx</strong> generates vocabulary-specific, statically-typed C++ mapping from W3C XML Schema definitions. Particular mapping to produce is selected by a <em>command</em>. Each mapping has a number of mapping-specific <em>options</em> that should appear, if any, after the <em>command</em>. Input files should be W3C XML Schema definitions. The exact set of the generated files depends on the selected mapping and options.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COMMANDS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <strong>cxx-tree</strong>
  </dt>
  <dd>
    <p>Generate the C++/Tree mapping. For each input file in the form <strong>name.xsd</strong> the following C++ files are generated: <strong>name.hxx</strong> (header file), <strong>name.ixx</strong> (inline file, generated only if the <strong>--generate-inline</strong> option is specified), <strong>name.cxx</strong> (source file), and <strong>name-fwd.hxx</strong> (forward declaration file, generated only if the <strong>--generate-forward</strong> option is specified).</p>
  </dd>
  <dt>
    <strong>cxx-parser</strong>
  </dt>
  <dd>
    <p>Generate the C++/Parser mapping. For each input file in the form <strong>name.xsd</strong> the following C++ files are generated: <strong>name-pskel.hxx</strong> (parser skeleton header file), <strong>name-pskel.ixx</strong> (parser skeleton inline file, generated only if the <strong>--generate-inline</strong> option is specified), and <strong>name-pskel.cxx</strong> (parser skeleton source file). If the <strong>--generate-noop-impl</strong> or <strong>--generate-print-impl</strong> option is specified, the following additional sample implementation files are generated: <strong>name-pimpl.hxx</strong> (parser implementation header file) and <strong>name-pimpl.cxx</strong> (parser implementation source file). If the <strong>--generate-test-driver</strong> option is specified, the additional <strong>name-driver.cxx</strong> test driver file is generated.</p>
  </dd>
  <dt>
    <strong>help</strong>
  </dt>
  <dd>
    <p>Print usage information and exit. Use</p>
  </dd>

</dl>
<p><strong>xsdcxx help</strong> <em>command</em></p><p>for command-specific help.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>version</strong>
  </dt>
  <dd>
    <p>Print version and exit.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONS</h2>
        <div class="sectioncontent">
<p>Command-specific <em>options</em>, if any, should appear after the corresponding <em>command</em>.</p><h3>common options</h3>

<dl class='dl-vertical'>
  <dt>
    <strong>--std</strong> <em>version</em>
  </dt>
  <dd>
    <p>Specify the C++ standard that the generated code should conform to. Valid values are <strong>c++98</strong> (default) and <strong>c++11</strong>.</p><p>The C++ standard affects various aspects of the generated code that are discussed in more detail in various mapping-specific documentation. Overall, when C++11 is selected, the generated code relies on the move semantics and uses <strong>std::unique_ptr</strong> instead of deprecated <strong>std::auto_ptr</strong>.</p><p>When the C++11 mode is selected, you normally don't need to perform any extra steps other than enable C++11 in your C++ compiler, if required. The XSDCXX compiler will automatically add the necessary macro defines to the generated header files that will switch the header-only XSDCXX runtime library (<strong>libxsd</strong>) to the C++11 mode. However, if you include any of the XSDCXX runtime headers directly in your application (normally you just include the generated headers), then you will need to define the <strong>XSD_CXX11</strong> macro for your entire project.</p>
  </dd>
  <dt>
    <strong>--char-type</strong> <em>type</em>
  </dt>
  <dd>
    <p>Generate code using the provided character <em>type</em> instead of the default <strong>char</strong>. Valid values are <strong>char</strong> and <strong>wchar_t</strong>.</p>
  </dd>
  <dt>
    <strong>--char-encoding</strong> <em>enc</em>
  </dt>
  <dd>
    <p>Specify the character encoding that should be used in the generated code. Valid values for the <strong>char</strong> character type are <strong>utf8</strong> (default), <strong>iso8859-1</strong>, <strong>lcp</strong> (Xerces-C++ local code page), and <strong>custom</strong>. If you pass <strong>custom</strong> as the value then you will need to include the transcoder implementation header for your encoding at the beginning of the generated header files (see the <strong>--hxx-prologue</strong> option).</p><p>For the <strong>wchar_t</strong> character type the only valid value is <strong>auto</strong> and the encoding is automatically selected between UTF-16 and UTF-32/UCS-4, depending on the <strong>wchar_t</strong> type size.</p>
  </dd>
  <dt>
    <strong>--output-dir</strong> <em>dir</em>
  </dt>
  <dd>
    <p>Write generated files to <em>dir</em> instead of the current directory.</p>
  </dd>
  <dt>
    <strong>--generate-inline</strong>
  </dt>
  <dd>
    <p>Generate simple functions inline. This option triggers creation of the inline file.</p>
  </dd>
  <dt>
    <strong>--generate-xml-schema</strong>
  </dt>
  <dd>
    <p>Generate a C++ header file as if the schema being compiled defines the XML Schema namespace. For the C++/Tree mapping, the resulting file will contain definitions for all XML Schema built-in types. For the C++/Parser mapping, the resulting file will contain definitions for all the parser skeletons and implementations corresponding to the XML Schema built-in types.</p><p>The schema file provided to the compiler need not exist and is only used to derive the name of the resulting header file. Use the <strong>--extern-xml-schema</strong> option to include this file in the generated files for other schemas.</p>
  </dd>
  <dt>
    <strong>--extern-xml-schema</strong> <em>file</em>
  </dt>
  <dd>
    <p>Include a header file derived from <em>file</em> instead of generating the XML Schema namespace mapping inline. The provided file need not exist and is only used to derive the name of the included header file. Use the <strong>--generate-xml-schema</strong> option to generate this header file.</p>
  </dd>
  <dt>
    <strong>--namespace-map</strong> <em>xns</em>=<em>cns</em>
  </dt>
  <dd>
    <p>Map XML Schema namespace <em>xns</em> to C++ namespace <em>cns</em>. Repeat this option to specify mapping for more than one XML Schema namespace. For example, the following option:</p><p><strong>--namespace-map http://example.com/foo/bar=foo::bar</strong></p><p>Will map the <strong>http://example.com/foo/bar</strong> XML Schema namespace to the <strong>foo::bar</strong> C++ namespace.</p>
  </dd>
  <dt>
    <strong>--namespace-regex</strong> <em>regex</em>
  </dt>
  <dd>
    <p>Add <em>regex</em> to the list of regular expressions used to translate XML Schema namespace names to C++ namespace names. <em>regex</em> is a Perl-like regular expression in the form <strong>/</strong><em>pattern</em><strong>/</strong><em>replacement</em><strong>/</strong>. Any character can be used as a delimiter instead of <strong>/</strong>. Escaping of the delimiter character in <em>pattern</em> or <em>replacement</em> is not supported.</p><p>All the regular expressions are pushed into a stack with the last specified expression considered first. The first match that succeeds is used. Regular expressions are applied to a string in the form</p><p><em>filename</em> <em>namespace</em></p><p>For example, if you have file <strong>hello.xsd</strong> with namespace <strong>http://example.com/hello</strong> and you run <strong>xsd</strong> on this file, then the string in question will be:</p><p><strong>hello.xsd. http://example.com/hello</strong></p><p>For the built-in XML Schema namespace the string is:</p><p><strong>XMLSchema.xsd http://www.w3.org/2001/XMLSchema</strong></p><p>The following three steps are performed for each regular expression until the match is found:</p><p>1. The expression is applied and if the result is empty the next expression is considered.</p><p>2. All <strong>/</strong> are replaced with <strong>::</strong>.</p><p>3. The result is verified to be a valid C++ scope name (e.g., <strong>foo::bar</strong>). If this test succeeds, the result is used as a C++ namespace name.</p><p>As an example, the following expression maps XML  Schema namespaces in the form <strong>http://example.com/foo/bar</strong> to C++ namespaces in the form <strong>foo::bar</strong>:</p><p><strong>%.* http://example.com/(.+)%$1%</strong></p><p>See also the REGEX AND SHELL QUOTING section below.</p>
  </dd>
  <dt>
    <strong>--namespace-regex-trace</strong>
  </dt>
  <dd>
    <p>Trace the process of applying regular expressions specified with the <strong>--namespace-regex</strong> option. Use this option to find out why your regular expressions don't do what you expected them to do.</p>
  </dd>
  <dt>
    <strong>--reserved-name</strong> <em>n</em>[=<em>r</em>]
  </dt>
  <dd>
    <p>Add name <em>n</em> to the list of names that should not be used as identifiers. The name can optionally be followed by <strong>=</strong> and the replacement name <em>r</em> that should be used instead. All the C++ keywords are already in this list.</p>
  </dd>
  <dt>
    <strong>--include-with-brackets</strong>
  </dt>
  <dd>
    <p>Use angle brackets (&lt;&gt;) instead of quotes ("") in generated <strong>#include</strong> directives.</p>
  </dd>
  <dt>
    <strong>--include-prefix</strong> <em>prefix</em>
  </dt>
  <dd>
    <p>Add <em>prefix</em> to generated <strong>#include</strong> directive paths.</p><p>For example, if you had the following import element in your schema</p><p><strong>&lt;import namespace="..." schemaLocation="base.xsd"/&gt;</strong></p><p>and compiled this fragment with <strong>--include-prefix schemas/</strong>, then the include directive in the generated code would be:</p><p><strong>#include "schemas/base.hxx"</strong></p>
  </dd>
  <dt>
    <strong>--include-regex</strong> <em>regex</em>
  </dt>
  <dd>
    <p>Add <em>regex</em> to the list of regular expressions used to transform <strong>#include</strong> directive paths. <em>regex</em> is a Perl-like regular expression in the form <strong>/</strong><em>pattern</em><strong>/</strong><em>replacement</em><strong>/</strong>. Any character can be used as a delimiter instead of <strong>/</strong>. Escaping of the delimiter character in <em>pattern</em> or <em>replacement</em> is not supported.</p><p>All the regular expressions are pushed into a stack with the last specified expression considered first. The first match that succeeds is used.</p><p>As an example, the following expression transforms paths in the form <strong>schemas/foo/bar</strong> to paths in the form <strong>generated/foo/bar</strong>:</p><p><strong>%schemas/(.+)%generated/$1%</strong></p><p>See also the REGEX AND SHELL QUOTING section below.</p>
  </dd>
  <dt>
    <strong>--include-regex-trace</strong>
  </dt>
  <dd>
    <p>Trace the process of applying regular expressions specified with the <strong>--include-regex</strong> option. Use this option to find out why your regular expressions don't do what you expected them to do.</p>
  </dd>
  <dt>
    <strong>--guard-prefix</strong> <em>prefix</em>
  </dt>
  <dd>
    <p>Add <em>prefix</em> to generated header inclusion guards. The prefix is transformed to upper case and characters that are illegal in a preprocessor macro name are replaced with underscores. If this option is not specified then the directory part of the input schema file is used as a prefix.</p>
  </dd>
  <dt>
    <strong>--hxx-suffix</strong> <em>suffix</em>
  </dt>
  <dd>
    <p>Use the provided <em>suffix</em> instead of the default <strong>.hxx</strong> to construct the name of the header file. Note that this suffix is also used to construct names of header files corresponding to included/imported schemas.</p>
  </dd>
  <dt>
    <strong>--ixx-suffix</strong> <em>suffix</em>
  </dt>
  <dd>
    <p>Use the provided <em>suffix</em> instead of the default <strong>.ixx</strong> to construct the name of the inline file.</p>
  </dd>
  <dt>
    <strong>--cxx-suffix</strong> <em>suffix</em>
  </dt>
  <dd>
    <p>Use the provided <em>suffix</em> instead of the default <strong>.cxx</strong> to construct the name of the source file.</p>
  </dd>
  <dt>
    <strong>--fwd-suffix</strong> <em>suffix</em>
  </dt>
  <dd>
    <p>Use the provided <em>suffix</em> instead of the default <strong>-fwd.hxx</strong> to construct the name of the forward declaration file.</p>
  </dd>
  <dt>
    <strong>--hxx-regex</strong> <em>regex</em>
  </dt>
  <dd>
    <p>Use the provided expression to construct the name of the header file. <em>regex</em> is a Perl-like regular expression in the form <strong>/</strong><em>pattern</em><strong>/</strong><em>replacement</em><strong>/</strong>. Note that this expression is also used to construct names of header files corresponding to included/imported schemas. See also the REGEX AND SHELL QUOTING section below.</p>
  </dd>
  <dt>
    <strong>--ixx-regex</strong> <em>regex</em>
  </dt>
  <dd>
    <p>Use the provided expression to construct the name of the inline file. <em>regex</em> is a Perl-like regular expression in the form <strong>/</strong><em>pattern</em><strong>/</strong><em>replacement</em><strong>/</strong>. See also the REGEX AND SHELL QUOTING section below.</p>
  </dd>
  <dt>
    <strong>--cxx-regex</strong> <em>regex</em>
  </dt>
  <dd>
    <p>Use the provided expression to construct the name of the source file. <em>regex</em> is a Perl-like regular expression in the form <strong>/</strong><em>pattern</em><strong>/</strong><em>replacement</em><strong>/</strong>. See also the REGEX AND SHELL QUOTING section below.</p>
  </dd>
  <dt>
    <strong>--fwd-regex</strong> <em>regex</em>
  </dt>
  <dd>
    <p>Use the provided expression to construct the name of the forward declaration file. <em>regex</em> is a Perl-like regular expression in the form <strong>/</strong><em>pattern</em><strong>/</strong><em>replacement</em><strong>/</strong>. See also the REGEX AND SHELL QUOTING section below.</p>
  </dd>
  <dt>
    <strong>--hxx-prologue</strong> <em>text</em>
  </dt>
  <dd>
    <p>Insert <em>text</em> at the beginning of the header file.</p>
  </dd>
  <dt>
    <strong>--ixx-prologue</strong> <em>text</em>
  </dt>
  <dd>
    <p>Insert <em>text</em> at the beginning of the inline file.</p>
  </dd>
  <dt>
    <strong>--cxx-prologue</strong> <em>text</em>
  </dt>
  <dd>
    <p>Insert <em>text</em> at the beginning of the source file.</p>
  </dd>
  <dt>
    <strong>--fwd-prologue</strong> <em>text</em>
  </dt>
  <dd>
    <p>Insert <em>text</em> at the beginning of the forward declaration file.</p>
  </dd>
  <dt>
    <strong>--prologue</strong> <em>text</em>
  </dt>
  <dd>
    <p>Insert <em>text</em> at the beginning of each generated file for which there is no file-specific prologue.</p>
  </dd>
  <dt>
    <strong>--hxx-epilogue</strong> <em>text</em>
  </dt>
  <dd>
    <p>Insert <em>text</em> at the end of the header file.</p>
  </dd>
  <dt>
    <strong>--ixx-epilogue</strong> <em>text</em>
  </dt>
  <dd>
    <p>Insert <em>text</em> at the end of the inline file.</p>
  </dd>
  <dt>
    <strong>--cxx-epilogue</strong> <em>text</em>
  </dt>
  <dd>
    <p>Insert <em>text</em> at the end of the source file.</p>
  </dd>
  <dt>
    <strong>--fwd-epilogue</strong> <em>text</em>
  </dt>
  <dd>
    <p>Insert <em>text</em> at the end of the forward declaration file.</p>
  </dd>
  <dt>
    <strong>--epilogue</strong> <em>text</em>
  </dt>
  <dd>
    <p>Insert <em>text</em> at the end of each generated file for which there is no file-specific epilogue.</p>
  </dd>
  <dt>
    <strong>--hxx-prologue-file</strong> <em>file</em>
  </dt>
  <dd>
    <p>Insert the content of the <em>file</em> at the beginning of the header file.</p>
  </dd>
  <dt>
    <strong>--ixx-prologue-file</strong> <em>file</em>
  </dt>
  <dd>
    <p>Insert the content of the <em>file</em> at the beginning of the inline file.</p>
  </dd>
  <dt>
    <strong>--cxx-prologue-file</strong> <em>file</em>
  </dt>
  <dd>
    <p>Insert the content of the <em>file</em> at the beginning of the source file.</p>
  </dd>
  <dt>
    <strong>--fwd-prologue-file</strong> <em>file</em>
  </dt>
  <dd>
    <p>Insert the content of the <em>file</em> at the beginning of the forward declaration file.</p>
  </dd>
  <dt>
    <strong>--prologue-file</strong> <em>file</em>
  </dt>
  <dd>
    <p>Insert the content of the <em>file</em> at the beginning of each generated file for which there is no file-specific prologue file.</p>
  </dd>
  <dt>
    <strong>--hxx-epilogue-file</strong> <em>file</em>
  </dt>
  <dd>
    <p>Insert the content of the <em>file</em> at the end of the header file.</p>
  </dd>
  <dt>
    <strong>--ixx-epilogue-file</strong> <em>file</em>
  </dt>
  <dd>
    <p>Insert the content of the <em>file</em> at the end of the inline file.</p>
  </dd>
  <dt>
    <strong>--cxx-epilogue-file</strong> <em>file</em>
  </dt>
  <dd>
    <p>Insert the content of the <em>file</em> at the end of the source file.</p>
  </dd>
  <dt>
    <strong>--fwd-epilogue-file</strong> <em>file</em>
  </dt>
  <dd>
    <p>Insert the content of the <em>file</em> at the end of the forward declaration file.</p>
  </dd>
  <dt>
    <strong>--epilogue-file</strong> <em>file</em>
  </dt>
  <dd>
    <p>Insert the content of the <em>file</em> at the end of each generated file for which there is no file-specific epilogue file.</p>
  </dd>
  <dt>
    <strong>--export-symbol</strong> <em>symbol</em>
  </dt>
  <dd>
    <p>Insert <em>symbol</em> in places where DLL export/import control statements (<strong>__declspec(dllexport/dllimport)</strong>) are necessary.</p>
  </dd>
  <dt>
    <strong>--export-xml-schema</strong>
  </dt>
  <dd>
    <p>Export/import types in the XML Schema namespace using the export symbol provided with the <strong>--export-symbol</strong> option. The <strong>XSD_NO_EXPORT</strong> macro can be used to omit this code during C++ compilation, which may be useful if you would like to use the same generated code across multiple platforms.</p>
  </dd>
  <dt>
    <strong>--export-maps</strong>
  </dt>
  <dd>
    <p>Export polymorphism support maps from a Win32 DLL into which this generated code is placed. This is necessary when your type hierarchy is split across several DLLs since otherwise each DLL will have its own set of maps. In this situation the generated code for the DLL which contains base types and/or substitution group heads should be compiled with this option and the generated code for all other DLLs should be compiled with <strong>--import-maps</strong>. This option is only valid together with <strong>--generate-polymorphic</strong>. The <strong>XSD_NO_EXPORT</strong> macro can be used to omit this code during C++ compilation, which may be useful if you would like to use the same generated code across multiple platforms.</p>
  </dd>
  <dt>
    <strong>--import-maps</strong>
  </dt>
  <dd>
    <p>Import polymorphism support maps to a Win32 DLL or executable into which this generated code is linked. See the <strong>--export-maps</strong> option documentation for details. This options is only valid together with <strong>--generate-polymorphic</strong>. The <strong>XSD_NO_EXPORT</strong> macro can be used to omit this code during C++ compilation, which may be useful if you would like to use the same generated code across multiple platforms.</p>
  </dd>
  <dt>
    <strong>--generate-dep</strong>
  </dt>
  <dd>
    <p>Generate <strong>make</strong> dependency information. This option triggers the creation of the <strong>.d</strong> file containing the dependencies of the generated files on the main schema file as well as all the schema files that it includes/imports, transitively. This dependency file is then normally included into the main <strong>makefile</strong> to implement automatic dependency tracking.</p><p>Note also that automatic dependency generation is not supported in the file-per-type mode (<strong>--file-per-type</strong>). In this case, all the generated files are produced with a single compiler invocation and depend on all the schemas. As a result, it is easier to establish such a dependency manually, perhaps with the help of the <strong>--file-list*</strong> options.</p>
  </dd>
  <dt>
    <strong>--generate-dep-only</strong>
  </dt>
  <dd>
    <p>Generate <strong>make</strong> dependency information only.</p>
  </dd>
  <dt>
    <strong>--dep-phony</strong>
  </dt>
  <dd>
    <p>Generate phony targets for included/imported schema files, causing each to depend on nothing. Such dummy rules work around <strong>make</strong> errors caused by the removal of schema files without also updating the dependency file to match.</p>
  </dd>
  <dt>
    <strong>--dep-target</strong> <em>target</em>
  </dt>
  <dd>
    <p>Change the target of the dependency rule. By default it contains all the generated C++ files as well as the dependency file itself, without any directory prefixes. If you require multiple targets, then you can specify them as a single, space-separated argument or you can repeat this option multiple times.</p>
  </dd>
  <dt>
    <strong>--dep-suffix</strong> <em>suffix</em>
  </dt>
  <dd>
    <p>Use the provided <em>suffix</em> instead of the default <strong>.d</strong> to construct the name of the dependency file.</p>
  </dd>
  <dt>
    <strong>--dep-regex</strong> <em>regex</em>
  </dt>
  <dd>
    <p>Use the provided expression to construct the name of the dependency file. <em>regex</em> is a Perl-like regular expression in the form <strong>/</strong><em>pattern</em><strong>/</strong><em>replacement</em><strong>/</strong>. See also the REGEX AND SHELL QUOTING section below.</p>
  </dd>
  <dt>
    <strong>--disable-warning</strong> <em>warn</em>
  </dt>
  <dd>
    <p>Disable printing warning with id <em>warn</em>. If <strong>all</strong> is specified for the warning id then all warnings are disabled.</p>
  </dd>
  <dt>
    <strong>--options-file</strong> <em>file</em>
  </dt>
  <dd>
    <p>Read additional options from <em>file</em>. Each option should appearing on a separate line optionally followed by space and an option value. Empty lines and lines starting with <strong>#</strong> are ignored. Option values can be enclosed in double (<strong>"</strong>) or single (<strong>'</strong>) quotes  to preserve leading and trailing whitespaces as well as to specify empty values. If the value itself contains trailing or leading quotes, enclose it with an extra pair of quotes, for example <strong>'"x"'</strong>. Non-leading and non-trailing quotes are interpreted as being part of the option value.</p><p>The semantics of providing options in a file is equivalent to providing the same set of options in the same order on the command line at the point where the <strong>--options-file</strong> option is specified except that the shell escaping and quoting is not required. You can repeat this option to specify more than one options file.</p>
  </dd>
  <dt>
    <strong>--show-sloc</strong>
  </dt>
  <dd>
    <p>Show the number of generated physical source lines of code (SLOC).</p>
  </dd>
  <dt>
    <strong>--sloc-limit</strong> <em>num</em>
  </dt>
  <dd>
    <p>Check that the number of generated physical source lines of code (SLOC) does not exceed <em>num</em>.</p>
  </dd>
  <dt>
    <strong>--proprietary-license</strong>
  </dt>
  <dd>
    <p>Indicate that the generated code is licensed under a proprietary license instead of the GPL.</p>
  </dd>
  <dt>
    <strong>--custom-literals</strong> <em>file</em>
  </dt>
  <dd>
    <p>Load custom XML string to C++ literal mappings from <em>file</em>. This mechanism can be useful if you are using a custom character encoding and some of the strings in your schemas, for example element/attribute names or enumeration values, contain non-ASCII characters. In this case you will need to provide a custom mapping to C++ literals for such strings. The format of this file is specified in the <strong>custom-literals.xsd</strong> XML Schema file that can be found in the documentation directory.</p>
  </dd>
  <dt>
    <strong>--preserve-anonymous</strong>
  </dt>
  <dd>
    <p>Preserve anonymous types. By default anonymous types are automatically named with names derived from the enclosing elements/attributes. Because mappings implemented by this compiler require all types to be named, this option is only useful if you want to make sure your schemas don't have anonymous types.</p>
  </dd>
  <dt>
    <strong>--show-anonymous</strong>
  </dt>
  <dd>
    <p>Show elements and attributes that are of anonymous types. This option only makes sense together with the <strong>--preserve-anonymous</strong> option.</p>
  </dd>
  <dt>
    <strong>--anonymous-regex</strong> <em>regex</em>
  </dt>
  <dd>
    <p>Add <em>regex</em> to the list of regular expressions used to derive names for anonymous types from the enclosing attributes/elements. <em>regex</em> is a Perl-like regular expression in the form <strong>/</strong><em>pattern</em><strong>/</strong><em>replacement</em><strong>/</strong>. Any character can be used as a delimiter instead of <strong>/</strong>. Escaping of the delimiter character in <em>pattern</em> or <em>replacement</em> is not supported.</p><p>All the regular expressions are pushed into a stack with the last specified expression considered first. The first match that succeeds is used. Regular expressions are applied to a string in the form</p><p><em>filename</em> <em>namespace</em> <em>xpath</em></p><p>For instance:</p><p><strong>hello.xsd http://example.com/hello element</strong></p><p><strong>hello.xsd http://example.com/hello type/element</strong></p><p>As an example, the following expression makes all the derived names start with capital letters. This could be useful when your naming convention requires type names to start with capital letters:</p><p><strong>%.* .* (.+/)*(.+)%&#92;u$2%</strong></p><p>See also the REGEX AND SHELL QUOTING section below.</p>
  </dd>
  <dt>
    <strong>--anonymous-regex-trace</strong>
  </dt>
  <dd>
    <p>Trace the process of applying regular expressions specified with the <strong>--anonymous-regex</strong> option. Use this option to find out why your regular expressions don't do what you expected them to do.</p>
  </dd>
  <dt>
    <strong>--location-map</strong> <em>ol</em>=<em>nl</em>
  </dt>
  <dd>
    <p>Map the original schema location <em>ol</em> that is specified in the XML Schema include or import elements to new schema location <em>nl</em>. Repeat this option to map more than one schema location. For example, the following option maps the <strong>http://example.com/foo.xsd</strong> URL to the <strong>foo.xsd</strong> local file.</p><p><strong>--location-map http://example.com/foo.xsd=foo.xsd</strong></p>
  </dd>
  <dt>
    <strong>--location-regex</strong> <em>regex</em>
  </dt>
  <dd>
    <p>Add <em>regex</em> to the list of regular expressions used to map schema locations that are specified in the XML Schema include or import elements. <em>regex</em> is a Perl-like regular expression in the form <strong>/</strong><em>pattern</em><strong>/</strong><em>replacement</em><strong>/</strong>. Any character can be used as a delimiter instead of <strong>/</strong>. Escaping of the delimiter character in <em>pattern</em> or <em>replacement</em> is not supported. All the regular expressions are pushed into a stack with the last specified expression considered first. The first match that succeeds is used.</p><p>For example, the following expression maps URL locations in the form <strong>http://example.com/foo/bar.xsd</strong> to local files in the form <strong>bar.xsd</strong>:</p><p><strong>%http://.+/(.+)%$1%</strong></p><p>See also the REGEX AND SHELL QUOTING section below.</p>
  </dd>
  <dt>
    <strong>--location-regex-trace</strong>
  </dt>
  <dd>
    <p>Trace the process of applying regular expressions specified with the <strong>--location-regex</strong> option. Use this option to find out why your regular expressions don't do what you expected them to do.</p>
  </dd>
  <dt>
    <strong>--file-per-type</strong>
  </dt>
  <dd>
    <p>Generate a separate set of C++ files for each type defined in XML Schema. Note that in this mode you only need to compile the root schema(s) and the code will be generated for all included and imported schemas. This compilation mode is primarily useful when some of your schemas cannot be compiled separately or have cyclic dependencies which involve type inheritance. Other options related to this mode are: <strong>--type-file-regex</strong>, <strong>--schema-file-regex</strong>, <strong>--fat-type-file</strong>, and <strong>--file-list</strong>.</p>
  </dd>
  <dt>
    <strong>--type-file-regex</strong> <em>regex</em>
  </dt>
  <dd>
    <p>Add <em>regex</em> to the list of regular expressions used to translate type names to file names when the <strong>--file-per-type</strong> option is specified. <em>regex</em> is a Perl-like regular expression in the form <strong>/</strong><em>pattern</em><strong>/</strong><em>replacement</em><strong>/</strong>. Any character can be used as a delimiter instead of <strong>/</strong>. Escaping of the delimiter character in <em>pattern</em> or <em>replacement</em> is not supported. All the regular expressions are pushed into a stack with the last specified expression considered first. The first match that succeeds is used. Regular expressions are applied to a string in the form</p><p><em>namespace</em> <em>type-name</em></p><p>For example, the following expression maps type <strong>foo</strong> that is defined in the <strong>http://example.com/bar</strong> namespace to file name <strong>bar-foo</strong>:</p><p><strong>%http://example.com/(.+) (.+)%$1-$2%</strong></p><p>See also the REGEX AND SHELL QUOTING section below.</p>
  </dd>
  <dt>
    <strong>--type-file-regex-trace</strong>
  </dt>
  <dd>
    <p>Trace the process of applying regular expressions specified with the <strong>--type-file-regex</strong> option. Use this option to find out why your regular expressions don't do what you expected them to do.</p>
  </dd>
  <dt>
    <strong>--schema-file-regex</strong> <em>regex</em>
  </dt>
  <dd>
    <p>Add <em>regex</em> to the list of regular expressions used to translate schema file names when the <strong>--file-per-type</strong> option is specified. <em>regex</em> is a Perl-like regular expression in the form <strong>/</strong><em>pattern</em><strong>/</strong><em>replacement</em><strong>/</strong>. Any character can be used as a delimiter instead of <strong>/</strong>. Escaping of the delimiter character in <em>pattern</em> or <em>replacement</em> is not supported. All the regular expressions are pushed into a stack with the last specified expression considered first. The first match that succeeds is used. Regular Expressions are applied to the absolute filesystem path of a schema file and the result, including the directory part, if any, is used to derive the <strong>#include</strong> directive paths as well as the generated C++ file paths. This option, along with <strong>--type-file-regex</strong> are primarily useful to place the generated files into subdirectories or to resolve file name conflicts.</p><p>For example, the following expression maps schema files in the <strong>foo/1.0.0/</strong> subdirectory to the files in the <strong>foo/</strong> subdirectory. As a result, the <strong>#include</strong> directive paths for such schemas will be in the <strong>foo/schema.hxx</strong> form and the generated C++ files will be placed into the <strong>foo/</strong> subdirectory:</p><p><strong>%.*/foo/1.0.0/(.+)%foo/$1%</strong></p><p>See also the REGEX AND SHELL QUOTING section below.</p>
  </dd>
  <dt>
    <strong>--schema-file-regex-trace</strong>
  </dt>
  <dd>
    <p>Trace the process of applying regular expressions specified with the <strong>--schema-file-regex</strong> option. Use this option to find out why your regular expressions don't do what you expected them to do.</p>
  </dd>
  <dt>
    <strong>--fat-type-file</strong>
  </dt>
  <dd>
    <p>Generate code corresponding to global elements into type files instead of schema files when the <strong>--type-file-regex</strong> option is specified. This option is primarily useful when trying to minimize the amount of object code that is linked to an executable by packaging compiled generated code into a static (archive) library.</p>
  </dd>
  <dt>
    <strong>--file-list</strong> <em>file</em>
  </dt>
  <dd>
    <p>Write a list of generated C++ files to <em>file</em>. This option is primarily useful in the file-per-type compilation mode (<strong>--file-per-type</strong>) to create a list of generated C++ files, for example, as a makefile fragment.</p>
  </dd>
  <dt>
    <strong>--file-list-prologue</strong> <em>text</em>
  </dt>
  <dd>
    <p>Insert <em>text</em> at the beginning of the file list. As a convenience, all occurrences of the <strong>&#92;n</strong> character sequence in <em>text</em> are replaced with new lines. This option can, for example, be used to assign the generated file list to a makefile variable.</p>
  </dd>
  <dt>
    <strong>--file-list-epilogue</strong> <em>text</em>
  </dt>
  <dd>
    <p>Insert <em>text</em> at the end of the file list. As a convenience, all occurrences of the <strong>&#92;n</strong> character sequence in <em>text</em> are replaced with new lines.</p>
  </dd>
  <dt>
    <strong>--file-list-delim</strong> <em>text</em>
  </dt>
  <dd>
    <p>Delimit file names written to the file list with <em>text</em> instead of new lines. As a convenience, all occurrences of the <strong>&#92;n</strong> character sequence in <em>text</em> are replaced with new lines.</p>
  </dd>

</dl>

<h3>cxx-tree command options</h3>

<dl class='dl-vertical'>
  <dt>
    <strong>--generate-polymorphic</strong>
  </dt>
  <dd>
    <p>Generate polymorphism-aware code. Specify this option if you use substitution groups or <strong>xsi:type</strong>. Use the <strong>--polymorphic-type</strong> or <strong>--polymorphic-type-all</strong> option to specify which type hierarchies are polymorphic.</p>
  </dd>
  <dt>
    <strong>--polymorphic-type</strong> <em>type</em>
  </dt>
  <dd>
    <p>Indicate that <em>type</em> is a root of a polymorphic type hierarchy. The compiler can often automatically determine which types are polymorphic based on the substitution group declarations. However, you may need to use this option if you are not using substitution groups or if substitution groups are defined in another schema. You need to specify this option when compiling every schema file that references <em>type</em>. The <em>type</em> argument is an XML Schema type name that can be optionally qualified with a namespace in the <em>namespace</em><strong>#</strong><em>name</em> form.</p>
  </dd>
  <dt>
    <strong>--polymorphic-type-all</strong>
  </dt>
  <dd>
    <p>Indicate that all types should be treated as polymorphic.</p>
  </dd>
  <dt>
    <strong>--polymorphic-plate</strong> <em>num</em>
  </dt>
  <dd>
    <p>Specify the polymorphic map plate the generated code should register on. This functionality is primarily useful to segregate multiple schemas that define the same polymorphic types.</p>
  </dd>
  <dt>
    <strong>--ordered-type</strong> <em>type</em>
  </dt>
  <dd>
    <p>Indicate that element order in <em>type</em> is significant. An example would be a complex type with unbounded choice as a content model where the element order in XML has application-specific semantics. For ordered types the compiler generates a special container data member and a corresponding set of accessors and modifiers that are used to capture the order of elements and, for mixed content, of text.</p><p>The <em>type</em> argument is an XML Schema type name that can be optionally qualified with a namespace in the <em>namespace</em><strong>#</strong><em>name</em> form. Note also that you will need to specify this option when compiling every schema file that has other ordered types derived from this type.</p>
  </dd>
  <dt>
    <strong>--ordered-type-derived</strong>
  </dt>
  <dd>
    <p>Automatically treat types derived from ordered bases as also ordered. This is primarily useful if you would like to be able to iterate over the complete content using the content order container.</p>
  </dd>
  <dt>
    <strong>--ordered-type-mixed</strong>
  </dt>
  <dd>
    <p>Automatically treat complex types with mixed content as ordered.</p>
  </dd>
  <dt>
    <strong>--ordered-type-all</strong>
  </dt>
  <dd>
    <p>Indicate that element order in all types is significant.</p>
  </dd>
  <dt>
    <strong>--order-container</strong> <em>type</em>
  </dt>
  <dd>
    <p>Specify a custom class template that should be used as a container for the content order in ordered types instead of the default <strong>std::vector</strong>. See <strong>--ordered-type</strong> for more information on ordered type. This option is primarily useful if you need to perform more complex lookups in the content order container, for example by element id. In this case, a container like Boost multi-index may be more convenient. Note that if using a custom container, you will also most likely need to include the relevant headers using the <strong>--hxx-prologue*</strong> options.</p>
  </dd>
  <dt>
    <strong>--generate-serialization</strong>
  </dt>
  <dd>
    <p>Generate serialization functions. Serialization functions convert the object model back to XML.</p>
  </dd>
  <dt>
    <strong>--generate-ostream</strong>
  </dt>
  <dd>
    <p>Generate ostream insertion operators (<strong>operator&lt;&lt;</strong>) for generated types. This allows one to easily print a fragment or the whole object model for debugging or logging.</p>
  </dd>
  <dt>
    <strong>--generate-doxygen</strong>
  </dt>
  <dd>
    <p>Generate documentation comments suitable for extraction by the Doxygen documentation system. Documentation from annotations is added to the comments if present in the schema.</p>
  </dd>
  <dt>
    <strong>--generate-comparison</strong>
  </dt>
  <dd>
    <p>Generate comparison operators (<strong>operator==</strong> and <strong>operator!=</strong>) for complex types. Comparison is performed member-wise.</p>
  </dd>
  <dt>
    <strong>--generate-default-ctor</strong>
  </dt>
  <dd>
    <p>Generate default constructors even for types that have required members. Required members of an instance constructed using such a constructor are not initialized and accessing them results in undefined behavior.</p>
  </dd>
  <dt>
    <strong>--generate-from-base-ctor</strong>
  </dt>
  <dd>
    <p>Generate constructors that expect an instance of a base type followed by all required members.</p>
  </dd>
  <dt>
    <strong>--suppress-assignment</strong>
  </dt>
  <dd>
    <p>Suppress the generation of copy assignment operators for complex types. If this option is specified, the copy assignment operators for such types are declared private and left unimplemented.</p>
  </dd>
  <dt>
    <strong>--generate-detach</strong>
  </dt>
  <dd>
    <p>Generate detach functions for required elements and attributes. Detach functions for optional and sequence cardinalities are provided by the respective containers. These functions, for example, allow you to move sub-trees in the object model either within the same tree or between different trees.</p>
  </dd>
  <dt>
    <strong>--generate-wildcard</strong>
  </dt>
  <dd>
    <p>Generate accessors and modifiers as well as parsing and serialization code for XML Schema wildcards (<strong>any</strong> and <strong>anyAttribute</strong>). XML content matched by wildcards is presented as DOM fragments. Note that you need to initialize the Xerces-C++ runtime if you are using this option.</p>
  </dd>
  <dt>
    <strong>--generate-any-type</strong>
  </dt>
  <dd>
    <p>Extract and store content of the XML Schema <strong>anyType</strong> type as a DOM fragment. Note that you need to initialize the Xerces-C++ runtime if you are using this option.</p>
  </dd>
  <dt>
    <strong>--generate-insertion</strong> <em>os</em>
  </dt>
  <dd>
    <p>Generate data representation stream insertion operators for the <em>os</em> output stream type. Repeat this option to specify more than one stream type. The ACE CDR stream (<strong>ACE_OutputCDR</strong>) and RPC XDR are recognized by the compiler and the necessary <strong>#include</strong> directives are automatically generated. For custom stream types use the <strong>--hxx-prologue*</strong> options to provide the necessary declarations.</p>
  </dd>
  <dt>
    <strong>--generate-extraction</strong> <em>is</em>
  </dt>
  <dd>
    <p>Generate data representation stream extraction constructors for the <em>is</em> input stream type. Repeat this option to specify more than one stream type. The ACE CDR stream (<strong>ACE_InputCDR</strong>) and RPC XDR are recognized by the compiler and the necessary <strong>#include</strong> directives are automatically generated. For custom stream types use the <strong>--hxx-prologue*</strong> options to provide the necessary declarations.</p>
  </dd>
  <dt>
    <strong>--generate-forward</strong>
  </dt>
  <dd>
    <p>Generate a separate header file with forward declarations for the types being generated.</p>
  </dd>
  <dt>
    <strong>--suppress-parsing</strong>
  </dt>
  <dd>
    <p>Suppress the generation of the parsing functions and constructors. Use this option to reduce the generated code size when parsing from XML is not needed.</p>
  </dd>
  <dt>
    <strong>--generate-element-type</strong>
  </dt>
  <dd>
    <p>Generate types instead of parsing and serialization functions for root elements. This is primarily useful to distinguish object models with the same root type but with different root elements.</p>
  </dd>
  <dt>
    <strong>--generate-element-map</strong>
  </dt>
  <dd>
    <p>Generate a root element map that allows uniform parsing and serialization of multiple root elements. This option is only valid together with <strong>--generate-element-type</strong>.</p>
  </dd>
  <dt>
    <strong>--generate-intellisense</strong>
  </dt>
  <dd>
    <p>Generate workarounds for IntelliSense bugs in Visual Studio 2005 (8.0). When this option is used, the resulting code is slightly more verbose. IntelliSense in Visual Studio 2008 (9.0) and later does not require these workarounds. Support for IntelliSense in Visual Studio 2003 (7.1) is improved with this option but is still incomplete.</p>
  </dd>
  <dt>
    <strong>--omit-default-attributes</strong>
  </dt>
  <dd>
    <p>Omit attributes with default and fixed values from serialized XML documents.</p>
  </dd>
  <dt>
    <strong>--type-naming</strong> <em>style</em>
  </dt>
  <dd>
    <p>Specify the type naming convention that should be used in the generated code. Valid styles are <strong>knr</strong> (default), <strong>ucc</strong>, and <strong>java</strong>. See the NAMING CONVENTION section below for more information.</p>
  </dd>
  <dt>
    <strong>--function-naming</strong> <em>style</em>
  </dt>
  <dd>
    <p>Specify the function naming convention that should be used in the generated code. Valid styles are <strong>knr</strong> (default), <strong>lcc</strong>, and <strong>java</strong>. See the NAMING CONVENTION section below for more information.</p>
  </dd>
  <dt>
    <strong>--type-regex</strong> <em>regex</em>
  </dt>
  <dd>
    <p>Add <em>regex</em> to the list of regular expressions used to translate XML Schema type names to C++ type names. See the NAMING CONVENTION section below for more information.</p>
  </dd>
  <dt>
    <strong>--accessor-regex</strong> <em>regex</em>
  </dt>
  <dd>
    <p>Add <em>regex</em> to the list of regular expressions used to translate XML Schema names of elements/attributes to C++ accessor function names. See the NAMING CONVENTION section below for more information.</p>
  </dd>
  <dt>
    <strong>--one-accessor-regex</strong> <em>regex</em>
  </dt>
  <dd>
    <p>Add <em>regex</em> to the list of regular expressions used to translate XML Schema names of elements/attributes with cardinality one to C++ accessor function names. See the NAMING CONVENTION section below for more information.</p>
  </dd>
  <dt>
    <strong>--opt-accessor-regex</strong> <em>regex</em>
  </dt>
  <dd>
    <p>Add <em>regex</em> to the list of regular expressions used to translate XML Schema names of elements/attributes with cardinality optional to C++ accessor function names. See the NAMING CONVENTION section below for more information.</p>
  </dd>
  <dt>
    <strong>--seq-accessor-regex</strong> <em>regex</em>
  </dt>
  <dd>
    <p>Add <em>regex</em> to the list of regular expressions used to translate XML Schema names of elements/attributes with cardinality sequence to C++ accessor function names. See the NAMING CONVENTION section below for more information.</p>
  </dd>
  <dt>
    <strong>--modifier-regex</strong> <em>regex</em>
  </dt>
  <dd>
    <p>Add <em>regex</em> to the list of regular expressions used to translate XML Schema names of elements/attributes to C++ modifier function names. See the NAMING CONVENTION section below for more information.</p>
  </dd>
  <dt>
    <strong>--one-modifier-regex</strong> <em>regex</em>
  </dt>
  <dd>
    <p>Add <em>regex</em> to the list of regular expressions used to translate XML Schema names of elements/attributes with cardinality one to C++ modifier function names. See the NAMING CONVENTION section below for more information.</p>
  </dd>
  <dt>
    <strong>--opt-modifier-regex</strong> <em>regex</em>
  </dt>
  <dd>
    <p>Add <em>regex</em> to the list of regular expressions used to translate XML Schema names of elements/attributes with cardinality optional to C++ modifier function names. See the NAMING CONVENTION section below for more information.</p>
  </dd>
  <dt>
    <strong>--seq-modifier-regex</strong> <em>regex</em>
  </dt>
  <dd>
    <p>Add <em>regex</em> to the list of regular expressions used to translate XML Schema names of elements/attributes with cardinality sequence to C++ modifier function names. See the NAMING CONVENTION section below for more information.</p>
  </dd>
  <dt>
    <strong>--parser-regex</strong> <em>regex</em>
  </dt>
  <dd>
    <p>Add <em>regex</em> to the list of regular expressions used to translate XML Schema element names to C++ parsing function names. See the NAMING CONVENTION section below for more information.</p>
  </dd>
  <dt>
    <strong>--serializer-regex</strong> <em>regex</em>
  </dt>
  <dd>
    <p>Add <em>regex</em> to the list of regular expressions used to translate XML Schema element names to C++ serialization function names. See the NAMING CONVENTION section below for more information.</p>
  </dd>
  <dt>
    <strong>--const-regex</strong> <em>regex</em>
  </dt>
  <dd>
    <p>Add <em>regex</em> to the list of regular expressions used to translate XML Schema-derived names to C++ constant names. See the NAMING CONVENTION section below for more information.</p>
  </dd>
  <dt>
    <strong>--enumerator-regex</strong> <em>regex</em>
  </dt>
  <dd>
    <p>Add <em>regex</em> to the list of regular expressions used to translate XML Schema enumeration values to C++ enumerator names. See the NAMING CONVENTION section below for more information.</p>
  </dd>
  <dt>
    <strong>--element-type-regex</strong> <em>regex</em>
  </dt>
  <dd>
    <p>Add <em>regex</em> to the list of regular expressions used to translate XML Schema element names to C++ element type names. See the NAMING CONVENTION section below for more information.</p>
  </dd>
  <dt>
    <strong>--name-regex-trace</strong>
  </dt>
  <dd>
    <p>Trace the process of applying regular expressions specified with the name transformation options. Use this option to find out why your regular expressions don't do what you expected them to do.</p>
  </dd>
  <dt>
    <strong>--root-element-first</strong>
  </dt>
  <dd>
    <p>Treat only the first global element as a document root. By default all global elements are considered document roots.</p>
  </dd>
  <dt>
    <strong>--root-element-last</strong>
  </dt>
  <dd>
    <p>Treat only the last global element as a document root. By default all global elements are considered document roots.</p>
  </dd>
  <dt>
    <strong>--root-element-all</strong>
  </dt>
  <dd>
    <p>Treat all global elements as document roots. This is the default behavior. By explicitly specifying this option you can suppress the warning that is issued if more than one global element is defined.</p>
  </dd>
  <dt>
    <strong>--root-element-none</strong>
  </dt>
  <dd>
    <p>Do not treat any global elements as document roots. By default all global elements are considered document roots.</p>
  </dd>
  <dt>
    <strong>--root-element</strong> <em>element</em>
  </dt>
  <dd>
    <p>Treat only <em>element</em> as a document root. Repeat this option to specify more than one root element.</p>
  </dd>
  <dt>
    <strong>--custom-type</strong> <em>map</em>
  </dt>
  <dd>
    <p>Use a custom C++ type instead of the generated class. The <em>map</em> argument is in the form <em>name</em>[<strong>=</strong><em>type</em>[<strong>/</strong><em>base</em>]], where <em>name</em> is a type name as defined in XML Schema and <em>type</em> is a C++ type name that should be used instead. If <em>type</em> is not present or empty then the custom type is assumed to have the same name and be defined in the same namespace as the generated class would have. If <em>base</em> is specified then the generated class is still generated but with that name.</p>
  </dd>
  <dt>
    <strong>--custom-type-regex</strong> <em>regex</em>
  </dt>
  <dd>
    <p>Use custom C++ types instead of the generated classes. The <em>regex</em> argument is in the form <strong>/</strong><em>name-pat</em><strong>/</strong>[<em>type-sub</em><strong>/</strong>[<em>base-sub</em><strong>/</strong>]], where <em>name-pat</em> is a regex pattern that will be matched against type names as defined in XML Schema and <em>type-sub</em> is a C++ type name substitution that should be used instead. If <em>type-sub</em> is not present or its substitution results in an empty string then the custom type is assumed to have the same name and be defined in the same namespace as the generated class would have. If <em>base-sub</em> is present and its substitution results in a non-empty string then the generated class is still generated but with the result of this substitution as its name. The pattern and substitutions are in the Perl regular expression format. See also the REGEX AND SHELL QUOTING section below.</p>
  </dd>
  <dt>
    <strong>--parts</strong> <em>num</em>
  </dt>
  <dd>
    <p>Split generated source code into <em>num</em> parts. This is useful when translating large, monolithic schemas and a C++ compiler is not able to compile the resulting source code at once (usually due to insufficient memory).</p>
  </dd>
  <dt>
    <strong>--parts-suffix</strong> <em>suffix</em>
  </dt>
  <dd>
    <p>Use <em>suffix</em> instead of the default '<strong>-</strong>' to separate the file name from the part number.</p>
  </dd>

</dl>

<h3>cxx-parser command options</h3>

<dl class='dl-vertical'>
  <dt>
    <strong>--type-map</strong> <em>mapfile</em>
  </dt>
  <dd>
    <p>Read XML Schema to C++ type mapping information from <em>mapfile</em>. Repeat this option to specify several type maps. Type maps are considered in order of appearance and the first match is used. By default all user-defined types are mapped to <strong>void</strong>. See the TYPE MAP section below for more information.</p>
  </dd>
  <dt>
    <strong>--xml-parser</strong> <em>parser</em>
  </dt>
  <dd>
    <p>Use <em>parser</em> as the underlying XML parser. Valid values are <strong>xerces</strong> for Xerces-C++ (default) and <strong>expat</strong> for Expat.</p>
  </dd>
  <dt>
    <strong>--generate-validation</strong>
  </dt>
  <dd>
    <p>Generate validation code. The validation code ("perfect parser") ensures that instance documents conform to the schema. Validation code is generated by default when the selected underlying XML parser is non-validating (<strong>expat</strong>).</p>
  </dd>
  <dt>
    <strong>--suppress-validation</strong>
  </dt>
  <dd>
    <p>Suppress the generation of validation code. Validation is suppressed by default when the selected underlying XML parser is validating (<strong>xerces</strong>).</p>
  </dd>
  <dt>
    <strong>--generate-polymorphic</strong>
  </dt>
  <dd>
    <p>Generate polymorphism-aware code. Specify this option if you use substitution groups or <strong>xsi:type</strong>.</p>
  </dd>
  <dt>
    <strong>--generate-noop-impl</strong>
  </dt>
  <dd>
    <p>Generate a sample parser implementation that does nothing (no operation). The sample implementation can then be filled with the application-specific code. For an input file in the form <strong>name.xsd</strong> this option triggers the generation of two additional C++ files in the form: <strong>name-pimpl.hxx</strong> (parser implementation header file) and <strong>name-pimpl.cxx</strong> (parser implementation source file).</p>
  </dd>
  <dt>
    <strong>--generate-print-impl</strong>
  </dt>
  <dd>
    <p>Generate a sample parser implementation that prints the XML data to STDOUT. For an input file in the form <strong>name.xsd</strong> this option triggers the generation of two additional C++ files in the form: <strong>name-pimpl.hxx</strong> (parser implementation header file) and <strong>name-pimpl.cxx</strong> (parser implementation source file).</p>
  </dd>
  <dt>
    <strong>--generate-test-driver</strong>
  </dt>
  <dd>
    <p>Generate a test driver for the sample parser implementation. For an input file in the form <strong>name.xsd</strong> this option triggers the generation of an additional C++ file in the form <strong>name-driver.cxx</strong>.</p>
  </dd>
  <dt>
    <strong>--force-overwrite</strong>
  </dt>
  <dd>
    <p>Force overwriting of the existing implementation and test driver files. Use this option only if you do not mind loosing the changes you have made in the sample implementation or test driver files.</p>
  </dd>
  <dt>
    <strong>--root-element-first</strong>
  </dt>
  <dd>
    <p>Indicate that the first global element is the document root. This information is used to generate the test driver for the sample implementation.</p>
  </dd>
  <dt>
    <strong>--root-element-last</strong>
  </dt>
  <dd>
    <p>Indicate that the last global element is the document root. This information is used to generate the test driver for the sample implementation.</p>
  </dd>
  <dt>
    <strong>--root-element</strong> <em>element</em>
  </dt>
  <dd>
    <p>Indicate that <em>element</em> is the document root. This information is used to generate the test driver for the sample implementation.</p>
  </dd>
  <dt>
    <strong>--skel-type-suffix</strong> <em>suffix</em>
  </dt>
  <dd>
    <p>Use the provided <em>suffix</em> instead of the default <strong>_pskel</strong> to construct the names of the generated parser skeletons.</p>
  </dd>
  <dt>
    <strong>--skel-file-suffix</strong> <em>suffix</em>
  </dt>
  <dd>
    <p>Use the provided <em>suffix</em> instead of the default <strong>-pskel</strong> to construct the names of the generated parser skeleton files.</p>
  </dd>
  <dt>
    <strong>--impl-type-suffix</strong> <em>suffix</em>
  </dt>
  <dd>
    <p>Use the provided <em>suffix</em> instead of the default <strong>_pimpl</strong> to construct the names of the parser implementations for the built-in XML Schema types as well as sample parser implementations.</p>
  </dd>
  <dt>
    <strong>--impl-file-suffix</strong> <em>suffix</em>
  </dt>
  <dd>
    <p>Use the provided <em>suffix</em> instead of the default <strong>-pimpl</strong> to construct the names of the generated sample parser implementation files.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMING CONVENTION</h2>
        <div class="sectioncontent">
<p>The compiler can be instructed to use a particular naming convention in the generated code. A number of widely-used conventions can be selected using the <strong>--type-naming</strong> and <strong>--function-naming</strong> options. A custom naming convention can be achieved using the <strong>--type-regex</strong>, <strong>--accessor-regex</strong>, <strong>--one-accessor-regex</strong>, <strong>--opt-accessor-regex</strong>, <strong>--seq-accessor-regex</strong>, <strong>--modifier-regex</strong>, <strong>--one-modifier-regex</strong>, <strong>--opt-modifier-regex</strong>, <strong>--seq-modifier-regex</strong>, <strong>--parser-regex</strong>, <strong>--serializer-regex</strong>, <strong>--const-regex</strong>, <strong>--enumerator-regex</strong>, and <strong>--element-type-regex</strong> options.</p><p>The <strong>--type-naming</strong> option specifies the convention that should be used for naming C++ types. Possible values for this option are <strong>knr</strong> (default), <strong>ucc</strong>, and <strong>java</strong>. The <strong>knr</strong> value (stands for K&R) signifies the standard, lower-case naming convention with the underscore used as a word delimiter, for example: foo, foo_bar. The <strong>ucc</strong> (stands for upper-camel-case) and <strong>java</strong> values a synonyms for the same naming convention where the first letter of each word in the name is capitalized, for example: Foo, FooBar.</p><p>Similarly, the <strong>--function-naming</strong> option specifies the convention that should be used for naming C++ functions. Possible values for this option are <strong>knr</strong> (default), <strong>lcc</strong>, and <strong>java</strong>. The <strong>knr</strong> value (stands for K&R) signifies the standard, lower-case naming convention with the underscore used as a word delimiter, for example: foo(), foo_bar(). The <strong>lcc</strong> value (stands for lower-camel-case) signifies a naming convention where the first letter of each word except the first is capitalized, for example: foo(), fooBar(). The <strong>java</strong> naming convention is similar to the lower-camel-case one except that accessor functions are prefixed with get, modifier functions are prefixed with set, parsing functions are prefixed with parse, and serialization functions are prefixed with serialize, for example: getFoo(), setFooBar(), parseRoot(), serializeRoot().</p><p>Note that the naming conventions specified with the <strong>--type-naming</strong> and <strong>--function-naming</strong> options perform only limited transformations on the names that come from the schema in the form of type, attribute, and element names. In other words, to get consistent results, your schemas should follow a similar naming convention as the one you would like to have in the generated code. Alternatively, you can use the <strong>--*-regex</strong> options (discussed below) to perform further transformations on the names that come from the schema.</p><p>The <strong>--type-regex</strong>, <strong>--accessor-regex</strong>, <strong>--one-accessor-regex</strong>, <strong>--opt-accessor-regex</strong>, <strong>--seq-accessor-regex</strong>, <strong>--modifier-regex</strong>, <strong>--one-modifier-regex</strong>, <strong>--opt-modifier-regex</strong>, <strong>--seq-modifier-regex</strong>, <strong>--parser-regex</strong>, <strong>--serializer-regex</strong>, <strong>--const-regex</strong>, <strong>--enumerator-regex</strong>, and <strong>--element-type-regex</strong> options allow you to specify extra regular expressions for each name category in addition to the predefined set that is added depending on the <strong>--type-naming</strong> and <strong>--function-naming</strong> options. Expressions that are provided with the <strong>--*-regex</strong> options are evaluated prior to any predefined expressions. This allows you to selectively override some or all of the predefined transformations. When debugging your own expressions, it is often useful to see which expressions match which names. The <strong>--name-regex-trace</strong> option allows you to trace the process of applying regular expressions to names.</p><p>The value for the <strong>--*-regex</strong> options should be a perl-like regular expression in the form <strong>/</strong><em>pattern</em><strong>/</strong><em>replacement</em><strong>/</strong>. Any character can be used as a delimiter instead of <strong>/</strong>. Escaping of the delimiter character in <em>pattern</em> or <em>replacement</em> is not supported. All the regular expressions for each category are pushed into a category-specific stack with the last specified expression considered first. The first match that succeeds is used. For the <strong>--one-accessor-regex</strong> (accessors with cardinality one), <strong>--opt-accessor-regex</strong> (accessors with cardinality optional), and <strong>--seq-accessor-regex</strong> (accessors with cardinality sequence) categories the <strong>--accessor-regex</strong> expressions are used as a fallback. For the <strong>--one-modifier-regex</strong>, <strong>--opt-modifier-regex</strong>, and <strong>--seq-modifier-regex</strong> categories the <strong>--modifier-regex</strong> expressions are used as a fallback. For the <strong>--element-type-regex</strong> category the <strong>--type-regex</strong> expressions are used as a fallback.</p><p>The type name expressions (<strong>--type-regex</strong>) are evaluated on the name string that has the following format:</p><p>[<em>namespace  </em>]<em>name</em>[<strong>,</strong><em>name</em>][<strong>,</strong><em>name</em>][<strong>,</strong><em>name</em>]</p><p>The element type name expressions (<strong>--element-type-regex</strong>), effective only when the <strong>--generate-element-type</strong> option is specified, are evaluated on the name string that has the following format:</p><p><em>namespace name</em></p><p>In the type name format the <em>namespace</em> part followed by a space is only present for global type names. For global types and elements defined in schemas without a target namespace, the <em>namespace</em> part is empty but the space is still present. In the type name format after the initial <em>name</em> component, up to three additional <em>name</em> components can be present, separated by commas. For example:</p><p><strong>http://example.com/hello type</strong></p><p><strong>foo</strong></p><p><strong>foo,iterator</strong></p><p><strong>foo,const,iterator</strong></p><p>The following set of predefined regular expressions is used to transform type names when the upper-camel-case naming convention is selected:</p><p><strong>/(?:[^ ]* )?([^,]+)/&#92;&#92;u$1/</strong></p><p><strong>/(?:[^ ]* )?([^,]+),([^,]+)/&#92;&#92;u$1&#92;&#92;u$2/</strong></p><p><strong>/(?:[^ ]* )?([^,]+),([^,]+),([^,]+)/&#92;&#92;u$1&#92;&#92;u$2&#92;&#92;u$3/</strong></p><p><strong>/(?:[^ ]* )?([^,]+),([^,]+),([^,]+),([^,]+)/&#92;&#92;u$1&#92;&#92;u$2&#92;&#92;u$3&#92;&#92;u$4/</strong></p><p>The accessor and modifier expressions (<strong>--*accessor-regex</strong> and <strong>--*modifier-regex</strong>) are evaluated on the name string that has the following format:</p><p><em>name</em>[<strong>,</strong><em>name</em>][<strong>,</strong><em>name</em>]</p><p>After the initial <em>name</em> component, up to two additional <em>name</em> components can be present, separated by commas. For example:</p><p><strong>foo</strong></p><p><strong>dom,document</strong></p><p><strong>foo,default,value</strong></p><p>The following set of predefined regular expressions is used to transform accessor names when the <strong>java</strong> naming convention is selected:</p><p><strong>/([^,]+)/get&#92;&#92;u$1/</strong></p><p><strong>/([^,]+),([^,]+)/get&#92;&#92;u$1&#92;&#92;u$2/</strong></p><p><strong>/([^,]+),([^,]+),([^,]+)/get&#92;&#92;u$1&#92;&#92;u$2&#92;&#92;u$3/</strong></p><p>For the parser, serializer, and enumerator categories, the corresponding regular expressions are evaluated on local names of elements and on enumeration values, respectively. For example, the following predefined regular expression is used to transform parsing function names when the <strong>java</strong> naming convention is selected:</p><p><strong>/(.+)/parse&#92;&#92;u$1/</strong></p><p>The const category is used to create C++ constant names for the element/wildcard/text content ids in ordered types.</p><p>See also the REGEX AND SHELL QUOTING section below.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TYPE MAP</h2>
        <div class="sectioncontent">
<p>Type map files are used in C++/Parser to define a mapping between XML Schema and C++ types. The compiler uses this information to determine the return types of <strong>post_*</strong> functions in parser skeletons corresponding to XML Schema types as well as argument types for callbacks corresponding to elements and attributes of these types.</p><p>The compiler has a set of predefined mapping rules that map built-in XML Schema types to suitable C++ types (discussed below) and all other types to <strong>void</strong>. By providing your own type maps you can override these predefined rules. The format of the type map file is presented below:</p><p><strong>namespace</strong> <em>schema-namespace</em> [ <em>cxx-namespace</em> ]</p><p><strong>{</strong></p>
<pre>
  (
</pre>
<p><strong>include</strong> <em>file-name</em><strong>;</strong> )*</p>
<pre>
  ([
</pre>
<p><strong>type</strong> ] <em>schema-type cxx-ret-type</em> [ <em>cxx-arg-type</em> ]<strong>;</strong> )*</p><p><strong>}</strong></p><p>Both <em>schema-namespace</em> and <em>schema-type</em> are regex patterns while <em>cxx-namespace</em>, <em>cxx-ret-type</em>, and <em>cxx-arg-type</em> are regex pattern substitutions. All names can be optionally enclosed in " ", for example, to include white-spaces.</p><p><em>schema-namespace</em> determines XML Schema namespace. Optional <em>cxx-namespace</em> is prefixed to every C++ type name in this namespace declaration. <em>cxx-ret-type</em> is a C++ type name that is used as a return type for the <strong>post_*</strong> functions. Optional <em>cxx-arg-type</em> is an argument type for callback functions corresponding to elements and attributes of this type. If <em>cxx-arg-type</em> is not specified, it defaults to <em>cxx-ret-type</em> if <em>cxx-ret-type</em> ends with <strong>*</strong> or <strong>&</strong> (that is, it is a pointer or a reference) and <strong>const</strong> <em>cxx-ret-type</em><strong>&</strong> otherwise. <em>file-name</em> is a file name either in the " " or &lt; &gt; format and is added with the <strong>#include</strong> directive to the generated code.</p><p>The <strong>#</strong> character starts a comment that ends with a new line or end of file. To specify a name that contains <strong>#</strong> enclose it in " ". For example:</p><p>namespace http://www.example.com/xmlns/my my</p><p>{</p>
<pre>
  include "my.hxx";
</pre>

<pre>
  # Pass apples by value.
  #
  apple apple;
</pre>

<pre>
  # Pass oranges as pointers.
  #
  orange orange_t*;
</pre>
<p>}</p><p>In the example above, for the <strong>http://www.example.com/xmlns/my#orange</strong> XML Schema type, the <strong>my::orange_t*</strong> C++ type will be used as both return and argument types.</p><p>Several namespace declarations can be specified in a single file. The namespace declaration can also be completely omitted to map types in a schema without a namespace. For instance:</p><p>include "my.hxx";</p><p>apple apple;</p><p>namespace http://www.example.com/xmlns/my</p><p>{</p>
<pre>
  orange "const orange_t*";
</pre>
<p>}</p><p>The compiler has a number of predefined mapping rules that can be presented as the following map files. The string-based XML Schema built-in types are mapped to either <strong>std::string</strong> or <strong>std::wstring</strong> depending on the character type selected with the <strong>--char-type</strong> option (<strong>char</strong> by default).</p><p>namespace http://www.w3.org/2001/XMLSchema</p><p>{</p>
<pre>
  boolean bool bool;
</pre>

<pre>
  byte "signed char" "signed char";
</pre>

<pre>
  unsignedByte "unsigned char" "unsigned char";
</pre>

<pre>
  short short short;
</pre>

<pre>
  unsignedShort "unsigned short" "unsigned short";
</pre>

<pre>
  int int int;
</pre>

<pre>
  unsignedInt "unsigned int" "unsigned int";
</pre>

<pre>
  long "long long" "long long";
</pre>

<pre>
  unsignedLong "unsigned long long" "unsigned long long";
</pre>

<pre>
  integer "long long" "long long";
</pre>

<pre>
  negativeInteger "long long" "long long";
</pre>

<pre>
  nonPositiveInteger "long long" "long long";
</pre>

<pre>
  positiveInteger "unsigned long long" "unsigned long long";
</pre>

<pre>
  nonNegativeInteger "unsigned long long" "unsigned long long";
</pre>

<pre>
  float float float;
</pre>

<pre>
  double double double;
</pre>

<pre>
  decimal double double;
</pre>

<pre>
  string std::string;
</pre>

<pre>
  normalizedString std::string;
</pre>

<pre>
  token std::string;
</pre>

<pre>
  Name std::string;
</pre>

<pre>
  NMTOKEN std::string;
</pre>

<pre>
  NCName std::string;
</pre>

<pre>
  ID std::string;
</pre>

<pre>
  IDREF std::string;
</pre>

<pre>
  language std::string;
</pre>

<pre>
  anyURI std::string;
</pre>

<pre>
  NMTOKENS xml_schema::string_sequence;
</pre>

<pre>
  IDREFS xml_schema::string_sequence;
</pre>

<pre>
  QName xml_schema::qname;
</pre>

<pre>
  base64Binary std::auto_ptr&lt;xml_schema::buffer&gt;
</pre>

<pre>
               std::auto_ptr&lt;xml_schema::buffer&gt;;
</pre>

<pre>
  hexBinary std::auto_ptr&lt;xml_schema::buffer&gt;
</pre>

<pre>
            std::auto_ptr&lt;xml_schema::buffer&gt;;
</pre>

<pre>
  date xml_schema::date;
</pre>

<pre>
  dateTime xml_schema::date_time;
</pre>

<pre>
  duration xml_schema::duration;
</pre>

<pre>
  gDay xml_schema::gday;
</pre>

<pre>
  gMonth xml_schema::gmonth;
</pre>

<pre>
  gMonthDay xml_schema::gmonth_day;
</pre>

<pre>
  gYear xml_schema::gyear;
</pre>

<pre>
  gYearMonth xml_schema::gyear_month;
</pre>

<pre>
  time xml_schema::time;
</pre>
<p>}</p><p>The last predefined rule maps anything that wasn't mapped by previous rules to <strong>void</strong>:</p><p>namespace .*</p><p>{</p>
<pre>
  .* void void;
</pre>
<p>}</p><p>When you provide your own type maps with the <strong>--type-map</strong> option, they are evaluated first. This allows you to selectively override predefined rules.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REGEX AND SHELL QUOTING</h2>
        <div class="sectioncontent">
<p>When entering a regular expression argument in the shell command line it is often necessary to use quoting (enclosing the argument in " " or ' ') in order to prevent the shell from interpreting certain characters, for example, spaces as argument separators and $ as variable expansions.</p><p>Unfortunately it is hard to achieve this in a manner that is portable across POSIX shells, such as those found on GNU/Linux and UNIX, and Windows shell. For example, if you use " " for quoting you will get a wrong result with POSIX shells if your expression contains $. The standard way of dealing with this on POSIX systems is to use ' ' instead. Unfortunately, Windows shell does not remove ' '  from arguments when they are passed to applications. As a result you may have to use ' ' for POSIX and " " for Windows ($ is not treated as a special character on Windows).</p><p>Alternatively, you can save regular expression options into a file, one option per line, and use this file with the <strong>--options-file</strong> option. With this approach you don't need to worry about shell quoting.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DIAGNOSTICS</h2>
        <div class="sectioncontent">
<p>If the input file is not a valid W3C XML Schema definition, <strong>xsdcxx</strong> will issue diagnostic messages to <strong>STDERR</strong> and exit with non-zero exit code.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>Send bug reports to the xsd-users@codesynthesis.com mailing list.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright (c) 2005-2014 Code Synthesis Tools CC.</p><p>Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, version 1.2; with no Invariant Sections, no Front-Cover Texts and no Back-Cover Texts. Copy of the license can be obtained from http://codesynthesis.com/licenses/fdl-1.2.txt</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="xsd.1.html"><span aria-hidden="true">&larr;</span> xsd.1: Mono's utility for generating schema or class files</a></li>
   <li class="next"><a href="xsddiagram.1.html">xsddiagram.1: Xml schema definition (xsd) diagram viewer <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ocamlfind: [command-line interface of the package manager] .sh "synopsis"</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="[command-line interface of the package manager] .sh "synopsis"">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="ocamlfind (1) manual">
  <meta name="twitter:description" content="[command-line interface of the package manager] .sh "synopsis"">
  <meta name="twitter:image" content="https://www.carta.tech/images/ocaml-findlib-ocamlfind-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/ocamlfind.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="ocamlfind (1) manual" />
  <meta property="og:description" content="[command-line interface of the package manager] .sh "synopsis"" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/ocaml-findlib-ocamlfind-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">ocamlfind<small> (1)</small></h1>
        <p class="lead">[command-line interface of the package manager] .sh "synopsis"</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/ocamlfind.1.html">
      <span itemprop="name">ocamlfind: [command-line interface of the package manager] .sh "synopsis"</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/ocaml-findlib/">
      <span itemprop="name">ocaml-findlib</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/ocamlfind.1.html">
      <span itemprop="name">ocamlfind: [command-line interface of the package manager] .sh "synopsis"</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">THE 'query' SUBCOMMAND</h2>
        <div class="sectioncontent">
<h3>Synopsis</h3>

<pre>
ocamlfind&nbsp;query&nbsp;[&nbsp;-predicates&nbsp; .ft I
p .ft B
&nbsp;&nbsp;|&nbsp; 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-format&nbsp; .ft I
f .ft B
&nbsp;| 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-long-format&nbsp;|&nbsp;-l&nbsp;| 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-i-format&nbsp;| 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-l-format&nbsp;|&nbsp; 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-a-format&nbsp;| 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-o-format&nbsp;|&nbsp; 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-p-format&nbsp;| 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-prefix&nbsp; .ft I
p .ft B
&nbsp;| 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-separator&nbsp; .ft I
s .ft B
&nbsp;|&nbsp; 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-suffix&nbsp; .ft I
s .ft B
&nbsp;| 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-descendants&nbsp;|&nbsp;-d&nbsp;| 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-recursive&nbsp;&nbsp;|&nbsp;-r&nbsp;]&nbsp; .ft I
package .ft B
&nbsp;... .ft R
</pre>

<h3>Description</h3>
<p>This command looks packages up, sorts them optionally, and  prints attributes of them. If the option -recursive (short: -r) is not  specified, exactly the packages given on the command line are looked  up; if -recursive is present, the packages and all their ancestors, or  if -descendants (short: -d) is present, too, all their descendants are printed. .PP Package lookup and the selection of the attributes of the packages can  be modified by specifying predicates; without a -predicates option the  empty set of predicates is used. Note that even the lookup is  influenced by the set of actual predicates as the "requires" variables  may be conditional. .PP What is printed about a package depends on the specified format; there  are a number of options that modify the format. Some formats denote  sets of values (such as -format %a), in which case multiple output  records are printed for every package. (It is even possible to specify  formats denoting the Cartesian product of sets, such as -format %a%o,  but this does not make sense.) Before the first output record the  prefix is printed, and the suffix after the last record. Between two  records the separator is printed. .SS "Options"</p><p>-predicates p .ft R</p><p>Sets the set of actual predicates. The argument </p><p>p .ft R  is a list of predicate names separated   by commas and/or whitespace. If multiple -predicates options are   given, the union of all specified sets is effectively used. .RE</p><p>-format f .ft R</p><p>Sets the format to the string </p><p>f .ft R . Characters preceded by a percent sign   are interpreted as placeholders; all other characters mean   themselves. The defined placeholders are listed below.   The default format is "%d". .RE</p><p>-long-format or -l .RE</p><p>Sets the format such that all relevant variables are printed. .RE</p><p>-i-format .RE</p><p>Same as -format "-I %d", i.e. directory options for ocamlc are printed. .RE</p><p>-l-format .RE</p><p>Same as -format "-ccopt -L%d", i.e. directory options for the  linker backend are printed. .RE</p><p>-a-format .RE</p><p>Same as -format "%a", i.e. archive file names are printed. .RE</p><p>-o-format .RE</p><p>Same as -format "%o", i.e. linker options are printed. .RE</p><p>-p-format .RE</p><p>Same as -format "%p", i.e. package names are printed. .RE</p><p>-prefix p .ft R</p><p>Sets the prefix that is printed before the first output record   to the given string. The default prefix is the empty string. .RE</p><p>-suffix s .ft R</p><p>Sets the suffix that is printed after the last output record   to the given string. The default suffix is the empty string. .RE</p><p>-separator s .ft R</p><p>Sets the separator that is printed between output records to   the given string. The default separator is a linefeed character. .RE</p><p>-recursive or -r .RE</p><p>Not only the packages given on the command line are queried   but also all ancestors or descendants. If the option -descendants is   specified, too, the descendants are printed, otherwise the   ancestors. The packages are topologically sorted. .RE</p><p>-descendants -d .RE</p><p>Instead of the ancestors the descendants of the   given packages are queried. This option implies -recursive . .RE</p>
<h3>Placeholders meaningful in the -format option</h3>
<p>%% .RE</p><p>Replaced by a single percent sign .RE</p><p>%p .RE</p><p>Replaced by the package name .RE</p><p>%d .RE</p><p>Replaced by the package directory .RE</p><p>%D .RE</p><p>Replaced by the package description .RE</p><p>%v .RE</p><p>Replaced by the version string .RE</p><p>%a .RE</p><p>Replaced by the archive filename. If there is more   than one archive, a separate output record is printed for every archive. .RE</p><p>%A .RE</p><p>Replaced by the list of archive filenames. .RE</p><p>%o .RE</p><p>Replaced by one linker option. If there is more than   one option, a separate output record is printed for every option. .RE</p><p>%O .RE</p><p>Replaced by the list of linker options. .RE</p><p>%( .ft I property .ft R ) .RE</p><p>Replaced by the value of the property named in parentheses,  or the empty string if not defined. .RE</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THE SUBCOMMANDS 'ocamlc', 'ocamlcp', 'ocamlopt', and 'ocamlmktop'</h2>
        <div class="sectioncontent">
<h3>Synopsis</h3>

<pre>
ocamlfind&nbsp;(&nbsp;ocamlc&nbsp;|&nbsp;ocamlcp&nbsp;|&nbsp;ocamlopt&nbsp;|&nbsp;ocamlmktop&nbsp;) 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;-package&nbsp; .ft I
package-name-list .ft B
&nbsp;| 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-linkpkg&nbsp;| 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-predicates&nbsp; .ft I
pred-name-list .ft B
&nbsp;| 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-dontlink&nbsp; .ft I
package-name-list .ft B
&nbsp;| 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-syntax&nbsp; .ft I
pred-name-list .ft B
&nbsp;| 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-ppopt&nbsp; .ft I
camlp4-arg .ft B
&nbsp;| 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-dllpath-pkg&nbsp; .ft I
package-name-list .ft B
&nbsp;| 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-dllpath-all&nbsp;| 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-passopt&nbsp; .ft I
arg .ft B
&nbsp;| 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-passrest&nbsp; .ft I
arg... .ft B
&nbsp;| 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .ft I
standard-option .ft B
&nbsp;] 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .ft I
file .ft B
&nbsp;... .ft R
</pre>

<h3>Description</h3>
<p>These subcommands are drivers for the compilers with the same names,  i.e. "ocamlfind ocamlc" is a driver for "ocamlc", and so on. The  subcommands understand all documented options of the compilers (here  called standard-options .ft R ), but also a few  more options. If these subcommands are invoked only with standard  options, they behave as if the underlying compiler had been called  directly. The extra options modify this. .PP Internally, these subcommands transform the given list of options and  file arguments into an invocation of the driven compiler. This  transformation only adds options and files, and the relative order of  the options and files passed directly is unchanged. .PP If there are -package options, additional directory search specifiers  will be included ("-I", and "-ccopt -I"), such that files of all named  packages and all ancestors can be found. .PP The -linkpkg option causes that the packages listed in the -package  options and all necessary ancestors are linked in. This means that the  archive files implementing the packages are inserted into the list of  file arguments. .PP As the package database is queried a set of predicates is needed. Most  predicates are set automatically, see below, but additional predicates  can be given by a -predicates option. .PP If there is a -syntax  option, the drivers assume that  a preprocessor is to be used. In this case, the preprocessor command  is built first in a preprocessor stage, and this command is passed to the  compiler using the -pp  option. The set of predicates  in the preprocessor stage is different from the set in the compiler/linker  stage. .SS "Options for compiling and linking" Here, only the additional options not interpreted by the compiler but  by the driver itself, and options with additional effects are explained.  Some options are only meaningful for the preprocessor call, and are  explained below. .PP</p><p>-package package-name-list .ft R</p><p>Adds the listed package names to the set of included   packages. The package names may be separated by commas and/or   whitespace. In the transformed command, for every package of the set   of included packages and for any ancestor a directory search option   is inserted after the already given options. This means that   "-I" and "-ccopt -I" options are added for every package directory. </p><p>-linkpkg .RE</p><p>Causes that in the transformed command all archives   of the packages specified by -packages and all their ancestors are   added to the file arguments. More precisely, these archives are   inserted before the first given file argument. Furthermore, "-ccopt   -L" options for all package directories, and the linker options of   the selected packages are added, too. Note that the archives are   inserted in topological order while the linker options are added in   reverse toplogical order. .RE</p><p>-predicates pred-name-list .ft R</p><p>Adds the given predicates to the set of actual   predicates. The predicates must be separated by commas and/or   whitespace.</p><p>-dontlink package-name-list .ft R</p><p>This option modifies the behaviour of   -linkpkg. Packages specified here and all ancestors are not linked   in. Again the packages are separated by commas and/or whitespace. .RE</p><p>-dllpath-pkg package-name-list .ft R</p><p>For these packages -dllpath  options   are added to the compiler command. This may be useful when the ld.conf   file is not properly configured. .RE</p><p>-dllpath-all .RE</p><p>For all linked packages -dllpath  options   are added to the compiler command. This may be useful when the ld.conf   file is not properly configured. .RE</p><p>-passopt arg .ft R</p><p>The argument arg .ft R  is   passed directly to the underlying compiler. This is needed to   specify undocumented compiler options. .RE</p><p>-passrest arg... .ft R</p><p>All following arguments arg... .ft R  are   passed directly to the underlying compiler. This is needed to   specify undocumented compiler options. .RE</p><p>-verbose .RE</p><p>This standard option is interpreted by the driver, too. .RE</p><p>-thread .RE</p><p>This standard option causes that the predicate "mt"   is added to the set of actual predicates. If POSIX threads are available,   the predicate "mt_posix" is selected, too. If only VM threads are   available, the predicate "mt_vm" is included into the set, and the   compiler switch is changed into -vmthread. .PP Note that the presence of the "mt" predicate triggers special  fixup of the dependency graph (see below). .RE</p><p>-vmthread .RE</p><p>This standard option causes that the predicates "mt"   and "mt_vm" are added to the set of actual predicates. .PP Note that the presence of the "mt" predicate triggers special  fixup of the dependency graph (see below). .RE</p><p>-p .RE</p><p>This standard option of "ocamlopt" causes that the   predicate "gprof" is added to the set of actual predicates. .RE</p>
<h3>Options for preprocessing</h3>
<p>The options relevant for the preprocessor are the following: .PP</p><p>-package package-name-list .ft R</p><p>These packages are considered while looking up the   preprocessor arguments. (It does not cause problems that the same   -package option is used for this purpose, because the set of predicates   is different.) It is recommended to mention at least camlp4   here if the preprocessor is going to be used. </p><p>-syntax pred-name-list .ft R</p><p>These predicates are assumed to be true in addition   to the standard preprocessor predicates. See below for a list. .RE</p><p>-ppopt camlp4-arg .ft R</p><p>This argument is passed to the camlp4 call. </p>
<h3>Predicates for compiling and linking</h3>
<p>byte .RE</p><p>The "byte" predicate means that one of the bytecode compilers is  used. It is automatically included into the predicate set if the  "ocamlc", "ocamlcp", or "ocamlmktop" compiler is used. .RE</p><p>native .RE</p><p>The "native" predicate means that the native compiler is used. It is  automatically included into the predicate set if the "ocamlopt"  compiler is used. .RE</p><p>toploop .RE</p><p>The "toploop" predicate means that the toploop is available in the  linked program. This predicate is only set when the toploop is actually  being executed, not when the toploop is created (this changed in version  1.0.4 of findlib). .RE</p><p>create_toploop .RE</p><p>This predicate means that a toploop is being created (using  ocamlmktop). .RE</p><p>mt .RE</p><p>The "mt" predicate means that the program is multi-threaded. It is  automatically included into the predicate set if the -thread option is  given.</p><p>mt_posix .RE</p><p>The "mt_posix" predicate means that in the case "mt" is set, too, the  POSIX libraries are used to implement threads. "mt_posix" is automatically  included into the predicate set if the variable "type_of_threads" in the  META description of the "threads" package has the value "posix". This  is normally the case if "findlib" is configured for POSIX threads. .RE</p><p>mt_vm .RE</p><p>The "mt_vm" predicate means that in the case "mt" is set, too, the  VM thread emulation is used to implement multi-threading. .RE</p><p>gprof .RE</p><p>The "gprof" predicate means that in the case "native" is set, too, the  program is compiled for profiling. It is automatically included into  the predicate set if "ocamlopt" is used and the -p option is in  effect. .RE</p><p>autolink .RE</p><p>The "autolink" predicate means that ocamlc is able to perform automatic  linking. It is automatically included into the predicate set if ocamlc  knows automatic linking (from version 3.00), but it is not set if the  -noautolink option is set. .RE</p><p>syntax .RE</p><p>This predicate is set if there is a -syntax   option. It is set both for the preprocessor and the compiler/linker stage,   and it can be used to find out whether the preprocessor is enabled or not. </p>
<h3>Predicates for preprocessing</h3>
<p>preprocessor .RE</p><p>This predicate is always set while looking up the   preprocessor arguments. It can be used to distinguish between the   preprocessor stage and the compiler/linker stage. .RE</p><p>syntax .RE</p><p>This predicate is set if there is a -syntax   option. It is set both for the preprocessor and the compiler/linker stage,   and it can be used to find out whether the preprocessor is enabled or not. </p><p>camlp4o .RE</p><p>This is the reserved predicate for the standard O'Caml syntax.   It can be used in the -syntax  predicate list. </p><p>camlp4r .RE</p><p>This is the reserved predicate for the revised O'Caml syntax.   It can be used in the -syntax  predicate list. </p>
<h3>Special behaviour of 'ocamlmktop'</h3>
<p>As there is a special module Topfind  that  supports loading of packages in scripts, the "ocamlmktop" subcommand  can add initialization code for this module. This extra code is  linked into the executable if "findlib" is in the set of effectively  linked packages.</p>
<h3>Fixup of the dependency graph for multi-threading</h3>
<p>For a number of reasons the presence of the "mt" predicate triggers  that (1) the package "threads" is added to the list of required packages  and (2) the package "threads" becomes prerequisite of all other packages  (except of itself and a few hardcoded exceptions). The effect is that  the options -thread and -vmthread automatically select the "threads"  package, and that "threads" is inserted at the right position in the  package list. .SS "Extended file naming" At a number of places one can not only refer to files by absolute  or relative path names, but also by extended names. These have two  major forms: "+ .ft I name .ft R "  refers to the subdirectory name .ft R  of the  standard library directory, and "@ .ft I name .ft R "  refers to the package directory of the package name .ft R .  Both forms can be continued by a path, e.g. "@netstring/netstring_top.cma". .PP You can use extended names: (1) With -I  options,  (2) as normal file arguments of the compiler, (3) in the</p><p>"archive" property of packages. .SS "How to set the names of the compiler executables" Normally, the O'Caml bytecode compiler can be called under the name  ocamlc . However, this is not always true; sometimes a  different name is chosen. .PP You can instruct ocamlfind to call executables with other names than  ocamlc , ocamlopt ,  ocamlmktop , and ocamlcp . If present,  the environment variable OCAMLFIND_COMMANDS  is interpreted  as a mapping from the standard names to the actual names of the executables. It  must have the following format: </p>
<pre>
standardname1 .ft B
= .ft I
actualname1 .ft B
&nbsp; .ft I
standardname2 .ft B
= .ft I
actualname2 .ft B
&nbsp;... .ft R
</pre>
<p>Example: You may set OCAMLFIND_COMMANDS  as follows: </p>
<pre>
OCAMLFIND_COMMANDS='ocamlc=ocamlc-3.00&nbsp;ocamlopt=ocamlopt-3.00' 

export&nbsp;OCAMLFIND_COMMANDS .ft R
</pre>
<p>Alternatively, you can change the configuration file  findlib.conf . .SH "THE SUBCOMMAND 'ocamlmklib'"</p>
<h3>Synopsis</h3>

<pre>
ocamlfind&nbsp;ocamlmklib 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;-package&nbsp; .ft I
package-name-list .ft B
&nbsp;| 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-predicates&nbsp; .ft I
pred-name-list .ft B
&nbsp;| 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-dllpath-pkg&nbsp; .ft I
package-name-list .ft B
&nbsp;| 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-dllpath-all&nbsp;| 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-passopt&nbsp; .ft I
arg .ft B
&nbsp;| 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-passrest&nbsp; .ft I
arg... .ft B
&nbsp;| 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .ft I
standard-option .ft B
&nbsp;] 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .ft I
file .ft B
&nbsp;... .ft R
</pre>

<h3>Description</h3>
<p>This is a wrapper around ocamlmklib, and creates library archives and  DLLs. In addition to the standard options, one can use -package to  add the search path of packages. Note that no predicates are set by default -  the wrapper does not know whether this is about byte or native code linking. .PP This wrapper is mostly provided for completeness. .SH "THE 'ocamldep' SUBCOMMAND"</p>
<h3>Synopsis</h3>

<pre>
ocamlfind&nbsp;ocamldep&nbsp;[-package&nbsp; .ft I
package-name-list .ft B
&nbsp;| 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-syntax&nbsp; .ft I
pred-name-list .ft B
&nbsp;| 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-ppopt&nbsp; .ft I
camlp4-arg .ft B
&nbsp;| 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-passopt&nbsp; .ft I
arg .ft B
&nbsp;| 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-passrest&nbsp; .ft I
arg... .ft B
&nbsp;| 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-verbose&nbsp;| 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .ft I
standard-option .ft B
]&nbsp; .ft I
file .ft B
&nbsp;... .ft R
</pre>

<h3>Description</h3>
<p>This command is a driver for the tool ocamldep  of the  O'Caml distribution. This driver is only useful in conjunction with  the preprocessor camlp4; otherwise it does not provide more functions  than ocamldep  itself. .SS "Options" Here, only the additional options not interpreted by ocamldep  but  by the driver itself, and options with additional effects are explained. .PP</p><p>-package package-name-list .ft R</p><p>The packages named here are only used to look up the  preprocessor options. The package camlp4  should be  specified anyway, but further packages that add capabilities to the  preprocessor can also be passed. .RE</p><p>-syntax pred-name-list .ft R</p><p>The predicates that are in effect during the look-up  of the preprocessor options. At least, either camlp4o  (selecting the normal syntax), or camlp4r  (selecting  the revised syntax) should be specified. .RE</p><p>-ppopt camlp4-arg .ft R</p><p>An option that is passed through to the camlp4 call. .RE</p><p>-passopt arg .ft R</p><p>An option that is passed through to the ocamldep call. .RE</p><p>-passrest arg... .ft R</p><p>All further arguments are passed down to ocamldep   unprocessed .RE</p><p>-verbose .RE</p><p>Displays the resulting ocamldep command (for debugging) .RE</p>
<h3>Example</h3>
<p>A typical way of using this driver: </p>
<pre>
ocamlfind&nbsp;ocamldep&nbsp;-package&nbsp;camlp4,xstrp4&nbsp;-syntax&nbsp;camlp4r&nbsp;file1.ml&nbsp;file2.ml .ft R
</pre>
<p>This command outputs the dependencies of file1.ml  and  file2.ml , although these modules make use of the  syntax extensions provided by xstrp4  and are written  in revised syntax. .SH "THE 'ocamlbrowser' SUBCOMMAND"</p>
<h3>Synopsis</h3>

<pre>
ocamlfind&nbsp;ocamlbrowser&nbsp;[-package&nbsp; .ft I
package-name-list .ft B
&nbsp;| 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-all&nbsp;| 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-passopt&nbsp; .ft I
arg .ft B
&nbsp; 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-passrest&nbsp;] .ft R
</pre>

<h3>Description</h3>
<p>This driver calls the ocamlbrowser  with package options.  With -package , the specified packages are included into  the search path of the browser, and the modules of these packages become  visible (in addition to the standard library). The option -all  causes that all packages are selected that are managed by findlib. .PP As for other drivers, the options -passopt  and  -passrest  can be used  to pass arguments directly to the ocamlbrowser  program. .SH "THE SUBCOMMAND 'ocamldoc'"</p>
<h3>Synopsis</h3>

<pre>
ocamlfind&nbsp;ocamldoc 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;-package&nbsp; .ft I
package-name-list .ft B
&nbsp;| 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-predicates&nbsp; .ft I
pred-name-list .ft B
&nbsp;| 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-syntax&nbsp; .ft I
pred-name-list .ft B
&nbsp;| 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-ppopt&nbsp; .ft I
camlp4-arg .ft B
&nbsp;| 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .ft I
standard-option .ft B
&nbsp;] 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .ft I
file .ft B
&nbsp;... .ft R
</pre>

<h3>Description</h3>
<p>This subcommand is a driver for ocamldoc. It undestands all options  ocamldoc supports plus the mentioned findlib options. Basically,  the -package options are translated into -I options, and the selected  syntax options are translated into camlp4 options. .SS "Options" Here, only the additional options not interpreted by ocamldep  but  by the driver itself, and options with additional effects are explained. .PP</p><p>-package package-name-list .ft R</p><p>Adds the listed package names to the set of included   packages. The package names may be separated by commas and/or   whitespace. In the transformed command, for every package of the set   of included packages and for any ancestor a directory search option   is inserted after the already given options. This means that   "-I" options are added for every package directory. </p><p>-predicates pred-name-list .ft R</p><p>Adds the given predicates to the set of actual   predicates. The predicates must be separated by commas and/or   whitespace.</p><p>-syntax pred-name-list .ft R</p><p>The predicates that are in effect during the look-up  of the preprocessor options. At least, either camlp4o  (selecting the normal syntax), or camlp4r  (selecting  the revised syntax) should be specified. .RE</p><p>-ppopt camlp4-arg .ft R</p><p>An option that is passed through to the camlp4 call. .RE</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THE 'install' SUBCOMMAND</h2>
        <div class="sectioncontent">
<h3>Synopsis</h3>

<pre>
ocamlfind&nbsp;install&nbsp;[&nbsp;-destdir&nbsp; .ft I
directory .ft B
&nbsp;] 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;-metadir&nbsp; .ft I
directory .ft B
&nbsp;] 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;-ldconf&nbsp; .ft I
path .ft B
&nbsp;] 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;-dont-add-directory-directive&nbsp;] 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;-patch-version&nbsp; .ft I
string .ft B
&nbsp;] 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;-patch-rmpkg&nbsp; .ft I
name .ft B
&nbsp;] 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;-patch-archives&nbsp;] 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;-dll&nbsp;]&nbsp;[&nbsp;-nodll&nbsp;]&nbsp;[&nbsp;-optional&nbsp;]&nbsp;[&nbsp;-add&nbsp;] 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .ft I
package_name .ft B
&nbsp; .ft I
file .ft B
&nbsp;... .ft R
</pre>

<h3>Description</h3>
<p>This subcommand installs a new package either at the default location  (see the variable destdir  of  findlib.conf ), or in the directory  specified by the -destdir option. This  means that a new package directory is created and that the files on  the command line are copied to this directory. It is required that a  META  file is one of the files copied to the target  directory. .PP Note that package directories should be flat (no  subdirectories). Existing packages are never overwritten. .PP It is possible to have a separate directory for all the META files. If  you want that, you have either to set the variable  metadir  of</p><p>findlib.conf , or to specify the  -metadir option. In this case, the file called META is copied to the  specified directory and renamed to META.p (where p is the package  name), while all the other files are copied to the package  directory as usual. Furthermore, the META file is modified such that the  directory  variable contains the path of the package  directory.</p><p>The option -dont-add-directory-directive prevents the installer from  adding a directory  variable. .PP If there are files ending in the suffixes .so  or  .dll , the package directory will be added to the  DLL configuration file ld.conf , such that the dynamic  loader can find the DLL. The location of this file can be overriden by  the -ldconf option. To turn this feature off, use "-ldconf ignore";  this causes that the ld.conf file is not modified. .PP However, if there is a stublibs directory in site-lib, the DLLs are not  installed in the package directory, but in this directory that is  shared by all packages that are installed at the same location.  In this case, the configuration file ld.conf  is  not modified, so you do not need to say "-ldconf ignore" if you  prefer this style of installation. .PP The options -dll and -nodll can be used to control exactly which files  are considered as DLLs and which not. By default, the mentioned  suffix rule is in effect: files ending in ".so" (Unix) or ".dll"  (Windows) are DLLs. The switch -dll changes this, and all following  files are considered as DLLs, regardless of their suffix. The switch</p><p>-nodll expresses that the following files are not DLLs, even if they  have a DLL-like suffix. For example, in the following call the files  f1 and f2 are handled by the suffix rule; f3 and f4 are DLLs anyway;  and f5 and f6 are not DLLs: </p>
<pre>
ocamlfind&nbsp;install&nbsp;p&nbsp;f1&nbsp;f2&nbsp;-dll&nbsp;f3&nbsp;f4&nbsp;-nodll&nbsp;f5&nbsp;f6 .ft R
</pre>
<p>The switch -optional declares that all following files are optional,  i.e. the command will not fail if files do not exist. .PP The -patch options may be used to change the contents of the META files  while it is being installed. The option -patch-version changes the  contents of the top-level "version" variable. The option -patch-rmpkg  removes the given subpackage. The option -patch-archives is experimental,  in particular it removes all non-existing files from "archive" variables,  and even whole subpackages if the archives are missing. .PP The effect of -add is to add further files to an already installed  packages. .SH "THE 'remove' SUBCOMMAND"</p>
<h3>Synopsis</h3>

<pre>
ocamlfind&nbsp;remove&nbsp;[&nbsp;-destdir&nbsp; .ft I
directory .ft B
&nbsp;] 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;-metadir&nbsp; .ft I
directory .ft B
&nbsp;] 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;-ldconf&nbsp; .ft I
path .ft B
&nbsp;] 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .ft I
package_name .ft B
</pre>

<h3>Description</h3>
<p>The package will removed if it is installed at the default location</p><p>(see the variable destdir  of  findlib.conf ). If the package  resides at a different location, it will not be removed by default;  however, you can pass an alternate directory for packages by the  -destdir option. (This must be the same directory as specified at  installation time.) .PP Note that package directories should be flat (no subdirectories); this  subcommand cannot remove deep package directories.</p><p>If you have a separate directory for META files, you must either  configure this directory by the metadir  variable  of findlib.conf , or by specifying  the -metadir option. .PP The command does not fail if the package and/or the META  file cannot be located. You will get a warning only in this case. .PP If the package directory is mentioned in the ld.conf  configuration file for DLLs, it will be tried to remove this entry  from the file. The location of this file can be overriden by  the -ldconf option. To turn this feature off, use "-ldconf ignore";  this causes that the ld.conf file is not modified. .PP If there is a stublibs directory, it is checked whether the package  owns any of the files in this directory, and the owned files will  be deleted. .SH "THE 'list' SUBCOMMAND"</p>
<h3>Synopsis</h3>

<pre>
ocamlfind&nbsp;list&nbsp;[-describe] .ft R
</pre>

<h3>Description</h3>
<p>This command lists all packages in the search path. The option -describe  outputs the package descriptions, too. .SH "THE 'printconf' SUBCOMMAND"</p>
<h3>Synopsis</h3>

<pre>
ocamlfind&nbsp;printconf&nbsp;[&nbsp;conf&nbsp;|&nbsp;path&nbsp;|&nbsp;destdir&nbsp;|&nbsp;metadir&nbsp;|&nbsp;stdlib&nbsp;|&nbsp;ldconf&nbsp;] .ft R
</pre>

<h3>Description</h3>
<p>This command prints the effective configuration after reading the  configuration file, and after applying the various environment  variables overriding settings. When called without arguments, the command  prints all configuration options in a human-readable form. When called  with an argument, only the value of the requested option is printed without  explaining texts: .PP</p><p>conf .RE</p><p>Prints the location of the configuration file findlib.conf </p><p>path .RE</p><p>Prints the search path for packages. The members of the   path are separated by linefeeds. .RE</p><p>destdir .RE</p><p>Prints the location where package are installed and   removed by default. .RE</p><p>metadir .RE</p><p>Prints the location where META files are installed and   removed (if the alternative layout is used). .RE</p><p>stdlib .RE</p><p>Prints the location of the standard library. .RE</p><p>ldconf .RE</p><p>Prints the location of the ld.conf file .RE</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THE SUBCOMMAND CALLING PACKAGE PROGRAMS</h2>
        <div class="sectioncontent">
<h3>Synopsis</h3>

<pre>
ocamlfind&nbsp; .ft I
pkg .ft B
/ .ft I
cmd .ft B
&nbsp; .ft I
argument .ft B
&nbsp;... .ft R
</pre>

<h3>Description</h3>
<p>This subcommand is useful to call programs that are installed in  package directories. It looks up the directory for</p><p>pkg .ft R  and calls the command named  cmd .ft R  in this directory. The remaining arguments  are passed to this command. .PP <strong>argv</strong>(0) contains the absolute path to the command, and <strong>argv</strong>(1) and  the following argv entries contain the arguments. The working directory  is not changed. .PP Example: To call the program "x" that is installed in package "p",  with arguments "y" and "z", run: .PP</p>
<pre>
ocamlfind&nbsp;p/x&nbsp;y&nbsp;z .ft R
</pre>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONFIGURATION FILE, ENVIRONMENT VARIABLES</h2>
        <div class="sectioncontent">
<p>The configuration file and environment variables are documented  in the manual page for </p><p>findlib.conf . .SH "HOW TO SET THE TOOLCHAIN"</p><h3>Synopsis</h3>

<pre>
ocamlfind&nbsp;-toolchain&nbsp; .ft I
name .ft B
&nbsp;... .ft R
</pre>

<h3>Description</h3>
<p>The -toolchain option can be given before any other command,  e.g. </p>
<pre>
ocamlfind&nbsp;-toolchain&nbsp;foo&nbsp;ocamlc&nbsp;-c&nbsp;file.ml .ft R
</pre>
<p>compiles file.ml with toolchain "foo". By selecting toolchains one  can switch to different command sets. For instance, the toolchain  "foo" may consist of a patched ocamlc compiler.</p><p>See findlib.conf  how to </p>

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="ocamldumpobj.1.html"><span aria-hidden="true">&larr;</span> ocamldumpobj.1: Disassembler for ocaml executable and .cmo object files</a></li>
   <li class="next"><a href="ocamlgraph-editor.1.html">ocamlgraph-editor.1: Gtk-based graph editor based on hyperbolic geometry. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

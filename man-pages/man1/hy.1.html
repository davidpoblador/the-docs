<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>hy: Hy documentation [image: hy] [image]</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Hy documentation [image: hy] [image]">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="hy (1) manual">
  <meta name="twitter:description" content="Hy documentation [image: hy] [image]">
  <meta name="twitter:image" content="https://www.carta.tech/images/python3-hy-hy-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/hy.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="hy (1) manual" />
  <meta property="og:description" content="Hy documentation [image: hy] [image]" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/python3-hy-hy-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">hy<small> (1)</small></h1>
        <p class="lead">Hy documentation [image: hy] [image]</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/hy.1.html">
      <span itemprop="name">hy: Hy documentation [image: hy] [image]</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/python3-hy/">
      <span itemprop="name">python3-hy</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/hy.1.html">
      <span itemprop="name">hy: Hy documentation [image: hy] [image]</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">QUICKSTART</h2>
        <div class="sectioncontent">
<p>[image: Karen Rustard's Cuddles] [image]</p><p>(Thanks to Karen Rustad for Cuddles!)</p><p><strong>HOW TO GET HY REAL FAST</strong>:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>Create a <em>Virtual Python Environment</em></p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>Activate your Virtual Python Environment</p>
  </dd>
  <dt>
    3.
  </dt>
  <dd>
    <p>Install <em>hy from PyPI</em> with <strong>pip install hy</strong></p>
  </dd>
  <dt>
    4.
  </dt>
  <dd>
    <p>Start a REPL with <strong>hy</strong></p>
  </dd>
  <dt>
    5.
  </dt>
  <dd>
    <p>Type stuff in the REPL:</p>
<pre>
=&gt; (print "Hy!")
Hy!
=&gt; (defn salutationsnm [name] (print (+ "Hy " name "!")))
=&gt; (salutationsnm "YourName")
Hy YourName!

etc
</pre>

  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    6.
  </dt>
  <dd>
    <p>Hit CTRL-D when you&apos;re done</p><p>OMG! That&apos;s amazing! I want to write a hy program.</p>
  </dd>
  <dt>
    7.
  </dt>
  <dd>
    <p>Open up an elite programming editor and type:</p>
<pre>
(print "I was going to code in python syntax, but then I got hy.")
</pre>

  </dd>
  <dt>
    8.
  </dt>
  <dd>
    <p>Save as <strong>awesome.hy</strong></p>
  </dd>
  <dt>
    9.
  </dt>
  <dd>
    <p>And run your first Hy program:</p>
<pre>
hy awesome.hy
</pre>

  </dd>
  <dt>
    10.
  </dt>
  <dd>
    <p>Take a deep breath so as to not hyperventilate</p>
  </dd>
  <dt>
    11.
  </dt>
  <dd>
    <p>Smile villainously and sneak off to your hydeaway and do unspeakable things</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TUTORIAL</h2>
        <div class="sectioncontent">
<p>Welcome to the Hy tutorial!</p><p>In a nutshell, Hy is a lisp dialect, but one that converts its structure into Python... literally a conversion into Python&apos;s abstract syntax tree!  (Or to put it in more crude terms, Hy is lisp-stick on a python!)</p><p>This is pretty cool because it means Hy is several things:</p><ul>
<li><p>A lisp that feels very pythonic</p></li><li><p>For lispers, a great way to use lisp&apos;s crazy powers but in the wide world of Python&apos;s libraries (why yes, you now can write a Django application in lisp!)</p></li><li><p>For pythonistas, a great way to start exploring lisp, from the comfort of python!</p></li><li><p>For everyone: a pleasant language that has a lot of neat ideas!</p></li>
</ul><h3>Basic intro to lisp for pythonistas</h3>
<p>Okay, maybe you&apos;ve never used lisp before, but you&apos;ve used python!</p><p>A "hello world" in hy is actually super simple.  Let&apos;s try it:</p>
<pre>
(print "hello world")
</pre>
<p>See?  Easy!  As you may have guessed, this is the same as the python version of:</p>
<pre>
print "hello world"
</pre>
<p>To add up some super simple math, we could do:</p>
<pre>
(+ 1 3)
</pre>
<p>Which would return 4 and would be the equivalent of:</p>
<pre>
1 + 3
</pre>
<p>What you&apos;ll notice is that the first item in the list is the function being called and the rest of the arguments are the arguments being passed in.  In fact, in hy (as with most lisps) we can pass in multiple arguments to the plus operator:</p>
<pre>
(+ 1 3 55)
</pre>
<p>Which would return 59.</p><p>Maybe you&apos;ve heard of lisp before but don&apos;t know much about it.  Lisp isn&apos;t as hard as you might think, and hy inherits from python, so hy is a great way to start learning lisp.  The main thing that&apos;s obvious about lisp is that there&apos;s a lot of parentheses.  This might seem confusing at first, but it isn&apos;t so hard.  Let&apos;s look at some simple math that&apos;s wrapped in a bunch of parentheses that we could enter into the hy interpreter:</p>
<pre>
(setv result (- (/ (+ 1 3 88) 2) 8))
</pre>
<p>This would return 38.  But why?  Well, we could look at the equivalent expression in python:</p>
<pre>
result = ((1 + 3 + 88) / 2) - 8
</pre>
<p>If you were to try to figure out how the above were to work in python, you&apos;d of course figure out the results by solving each inner parenthesis.  That&apos;s the same basic idea in hy.  Let&apos;s try this exercise first in python:</p>
<pre>
result = ((1 + 3 + 88) / 2) - 8
# simplified to...
result = (92 / 2) - 8
# simplified to...
result = 46 - 8
# simplified to...
result = 38
</pre>
<p>Now let&apos;s try the same thing in hy:</p>
<pre>
(setv result (- (/ (+ 1 3 88) 2) 8))
; simplified to...
(setv result (- (/ 92 2) 8))
; simplified to...
(setv result (- 46 8))
; simplified to...
(setv result 38)
</pre>
<p>As you probably guessed, this last expression with "setv" means to assign the variable "result" to 38.</p><p>See?  Not too hard!</p><p>This is the basic premise of lisp... lisp stands for "list processing"... this means that the structure of the program is actually lists of lists.  (If you&apos;re familiar with python lists, imagine the entire same structure as above but with square brackets instead, any you&apos;ll be able to see the structure above as both a program and a datastructure.)  This is easier to understand with more examples, so let&apos;s write a simple python program and test it and then show the equivalent hy program:</p>
<pre>
def simple_conversation():
    print "Hello!  I&apos;d like to get to know you.  Tell me about yourself!"
    name = raw_input("What is your name? ")
    age = raw_input("What is your age? ")
    print "Hello " + name + "!  I see you are " + age + " years old."

simple_conversation()
</pre>
<p>If we ran this program, it might go like:</p>
<pre>
Hello!  I&apos;d like to get to know you.  Tell me about yourself!
What is your name? Gary
What is your age? 38
Hello Gary!  I see you are 38 years old.
</pre>
<p>Now let&apos;s look at the equivalent hy program:</p>
<pre>
(defn simple-conversation []
   (print "Hello!  I&apos;d like to get to know you.  Tell me about yourself!")
   (setv name (raw_input "What is your name? "))
   (setv age (raw_input "What is your age? "))
   (print (+ "Hello " name "!  I see you are "
              age " years old.")))

(simple-conversation)
</pre>
<p>If you look at the above program, as long as you remember that the first element in each list of the program is the function (or macro... we&apos;ll get to those later) being called and that the rest are the arguments, it&apos;s pretty easy to figure out what this all means. (As you probably also guessed, defn is the hy method of defining methods.)</p><p>Still, lots of people find this confusing at first because there&apos;s so many parentheses, but there are plenty of things that can help make this easier: keep indentation nice and use an editor with parenthesis matching (this will help you figure out what each parenthesis pairs up with) and things will start to feel comfortable.</p><p>There are some advantages to having a code structure that&apos;s actually a very simple datastructure as the core of lisp is based on.  For one thing, it means that your programs are easy to parse and that the entire actual structure of the program is very clearly exposed to you. (There&apos;s an extra step in hy where the structure you see is converted to python&apos;s own representations... in more "pure" lisps such as common lisp or emacs lisp, the data structure you see for the code and the data structure that is executed is much more literally close.)</p><p>Another implication of this is macros: if a program&apos;s structure is a simple data structure, that means you can write code that can write code very easily, meaning that implementing entirely new language features can be very fast.  Previous to hy, this wasn&apos;t very possible for python programmers... now you too can make use of macros&apos; incredible power (just be careful to not aim them footward)!</p>
<h3>Hy is a Lisp flavored Python</h3>
<p>Hy converts to Python&apos;s own abstract syntax tree, so you&apos;ll soon start to find that all the familiar power of python is at your fingertips.</p><p>You have full access to Python&apos;s data types and standard library in Hy.  Let&apos;s experiment with this in the hy interpreter:</p>
<pre>
=&gt; [1 2 3]
[1, 2, 3]
=&gt; {"dog" "bark"
... "cat" "meow"}
...
{&apos;dog&apos;: &apos;bark&apos;, &apos;cat&apos;: &apos;meow&apos;}
=&gt; (, 1 2 3)
(1, 2, 3)
</pre>
<p>If you are familiar with other lisps, you may be interested that Hy supports the Common Lisp method of quoting:</p>
<pre>
=&gt; &apos;(1 2 3)
(1L 2L 3L)
</pre>
<p>You also have access to all the builtin types&apos; nice methods:</p>
<pre>
=&gt; (.strip " fooooo   ")
"fooooo"
</pre>
<p>What&apos;s this?  Yes indeed, this is precisely the same as:</p>
<pre>
" fooooo   ".strip()
</pre>
<p>That&apos;s right... lisp with dot notation!  If we have this string assigned as a variable, we can also do the following:</p>
<pre>
(setv this-string " fooooo   ")
(this-string.strip)
</pre>
<p>What about conditionals?:</p>
<pre>
(if (try-some-thing)
  (print "this is if true")
  (print "this is if false"))
</pre>
<p>As you can tell above, the first argument to if is a truth test, the second argument is a body if true, and the third argument (optional!) is if false (ie, "else"!).</p><p>If you need to do more complex conditionals, you&apos;ll find that you don&apos;t have elif available in hy.  Instead, you should use something called "cond".  In python, you might do something like:</p>
<pre>
somevar = 33
if somevar &gt; 50:
    print "That variable is too big!"
elif somevar &lt; 10:
    print "That variable is too small!"
else:
    print "That variable is jussssst right!"
</pre>
<p>In hy, you would do:</p>
<pre>
(cond
 [(&gt; somevar 50)
  (print "That variable is too big!")]
 [(&lt; somevar 10)
  (print "That variable is too small!")]
 [true
  (print "That variable is jussssst right!")])
</pre>
<p>What you&apos;ll notice is that cond switches off between a some statement that is executed and checked conditionally for true or falseness, and then a bit of code to execute if it turns out to be true.  You&apos;ll also notice that the "else" is implemented at the end simply by checking for "true"... that&apos;s because true will always be true, so if we get this far, we&apos;ll always run that one!</p><p>You might notice above that if you have code like:</p>
<pre>
(if some-condition
  (body-if-true)
  (body-if-false))
</pre>
<p>But wait!  What if you want to execute more than one statement in the body of one of these?</p><p>You can do the following:</p>
<pre>
(if (try-some-thing)
  (do
    (print "this is if true")
    (print "and why not, let&apos;s keep talking about how true it is!))
  (print "this one&apos;s still simply just false"))
</pre>
<p>You can see that we used "do" to wrap multiple statements.  If you&apos;re familiar with other lisps, this is the equivalent of "progn" elsewhere.</p><p>Comments start with semicolons:</p>
<pre>
(print "this will run")
; (print "but this will not")
(+ 1 2 3)  ; we&apos;ll execute the addition, but not this comment!
</pre>
<p>Looping is not hard but has a kind of special structure.  In python, we might do:</p>
<pre>
for i in range(10):
    print "&apos;i&apos; is now at " + str(i)
</pre>
<p>The equivalent in hy would be:</p>
<pre>
(for [i (range 10)]
  (print (+ "&apos;i&apos; is now at " (str i))))
</pre>
<p>You can also import and make use of various python libraries.  For example:</p>
<pre>
(import os)

(if (os.path.isdir "/tmp/somedir")
  (os.mkdir "/tmp/somedir/anotherdir")
  (print "Hey, that path isn&apos;t there!"))
</pre>
<p>Python&apos;s context managers (&apos;with&apos; statements) are used like this:</p>
<pre>
(with [[f (open "/tmp/data.in")]]
  (print (.read f)))
</pre>
<p>which is equivalent to:</p>
<pre>
with open("/tmp/data.in") as f:
    print f.read()
</pre>
<p>And yes, we do have lisp comprehensions!  In Python you might do:</p>
<pre>
odds_squared = [
  pow(num, 2)
  for num in range(100)
  if num % 2 == 1]
</pre>
<p>In hy, you could do these like:</p>
<pre>
(setv odds-squared
  (list-comp
    (pow num 2)
    (num (range 100))
    (= (% num 2) 1)))
</pre>

<pre>
; And, an example stolen shamelessly from a Clojure page:
; Let&apos;s list all the blocks of a Chessboard:

(list-comp
  (, x y)
  (x (range 8)
   y "ABCDEFGH"))

; [(0, &apos;A&apos;), (0, &apos;B&apos;), (0, &apos;C&apos;), (0, &apos;D&apos;), (0, &apos;E&apos;), (0, &apos;F&apos;), (0, &apos;G&apos;), (0, &apos;H&apos;),
;  (1, &apos;A&apos;), (1, &apos;B&apos;), (1, &apos;C&apos;), (1, &apos;D&apos;), (1, &apos;E&apos;), (1, &apos;F&apos;), (1, &apos;G&apos;), (1, &apos;H&apos;),
;  (2, &apos;A&apos;), (2, &apos;B&apos;), (2, &apos;C&apos;), (2, &apos;D&apos;), (2, &apos;E&apos;), (2, &apos;F&apos;), (2, &apos;G&apos;), (2, &apos;H&apos;),
;  (3, &apos;A&apos;), (3, &apos;B&apos;), (3, &apos;C&apos;), (3, &apos;D&apos;), (3, &apos;E&apos;), (3, &apos;F&apos;), (3, &apos;G&apos;), (3, &apos;H&apos;),
;  (4, &apos;A&apos;), (4, &apos;B&apos;), (4, &apos;C&apos;), (4, &apos;D&apos;), (4, &apos;E&apos;), (4, &apos;F&apos;), (4, &apos;G&apos;), (4, &apos;H&apos;),
;  (5, &apos;A&apos;), (5, &apos;B&apos;), (5, &apos;C&apos;), (5, &apos;D&apos;), (5, &apos;E&apos;), (5, &apos;F&apos;), (5, &apos;G&apos;), (5, &apos;H&apos;),
;  (6, &apos;A&apos;), (6, &apos;B&apos;), (6, &apos;C&apos;), (6, &apos;D&apos;), (6, &apos;E&apos;), (6, &apos;F&apos;), (6, &apos;G&apos;), (6, &apos;H&apos;),
;  (7, &apos;A&apos;), (7, &apos;B&apos;), (7, &apos;C&apos;), (7, &apos;D&apos;), (7, &apos;E&apos;), (7, &apos;F&apos;), (7, &apos;G&apos;), (7, &apos;H&apos;)]
</pre>
<p>Python has support for various fancy argument and keyword arguments. In python we might see:</p>
<pre>
&gt;&gt;&gt; def optional_arg(pos1, pos2, keyword1=None, keyword2=42):
...   return [pos1, pos2, keyword1, keyword2]
...
&gt;&gt;&gt; optional_arg(1, 2)
[1, 2, None, 42]
&gt;&gt;&gt; optional_arg(1, 2, 3, 4)
[1, 2, 3, 4]
&gt;&gt;&gt; optional_arg(keyword1=1, pos2=2, pos1=3, keyword2=4)
[3, 2, 1, 4]
</pre>
<p>The same thing in Hy:</p>
<pre>
=&gt; (defn optional_arg [pos1 pos2 &optional keyword1 [keyword2 42]]
...  [pos1 pos2 keyword1 keyword2])
=&gt; (optional_arg 1 2)
[1 2 None 42]
=&gt; (optional_arg 1 2 3 4)
[1 2 3 4]
=&gt; (apply optional_arg []
...         {"keyword1" 1
...          "pos2" 2
...          "pos1" 3
...          "keyword2" 4})
...
[3, 2, 1, 4]
</pre>
<p>See how we use apply to handle the fancy passing? :)</p><p>There&apos;s also a dictionary-style keyword arguments construction that looks like:</p>
<pre>
(defn another_style [&key {"key1" "val1" "key2" "val2"}]
  [key1 key2])
</pre>
<p>The difference here is that since it&apos;s a dictionary, you can&apos;t rely on any specific ordering to the arguments.</p><p>Hy also supports <strong>*args</strong> and <strong>**kwargs</strong>.  In Python:</p>
<pre>
def some_func(foo, bar, *args, **kwargs):
  import pprint
  pprint.pprint((foo, bar, args, kwargs))
</pre>
<p>The Hy equivalent:</p>
<pre>
(defn some_func [foo bar &rest args &kwargs kwargs]
  (import pprint)
  (pprint.pprint (, foo bar args kwargs)))
</pre>
<p>Finally, of course we need classes!  In python we might have a class like:</p>
<pre>
class FooBar(object):
    """
    Yet Another Example Class
    """
    def __init__(self, x):
        self.x = x

    def get_x(self):
        """
        Return our copy of x
        """
        return self.x
</pre>
<p>In Hy:</p>
<pre>
(defclass FooBar [object]
  "Yet Another Example Class"
  [[--init--
    (fn [self x]
      (setv self.x x)
      ; Currently needed for --init-- because __init__ needs None
      ; Hopefully this will go away :)
      None)]

   [get-x
    (fn [self]
      "Return our copy of x"
      self.x)]])
</pre>
<p>You can also do class-level attributes.  In Python:</p>
<pre>
class Customer(models.Model):
    name = models.CharField(max_length=255)
    address = models.TextField()
    notes = models.TextField()
</pre>
<p>In Hy:</p>
<pre>
(defclass Customer [models.Model]
  [[name (apply models.CharField [] {"max_length" 255})]
   [address (models.TextField)]
   [notes (models.TextField)]])
</pre>

<h3>Protips!</h3>
<p>Hy also features something known as the "threading macro", a really neat feature of Clojure&apos;s. The "threading macro" (written as "-&gt;"), is used to avoid deep nesting of expressions.</p><p>The threading macro inserts each expression into the next expression&apos;s first argument place.</p><p>Let&apos;s take the classic:</p>
<pre>
(loop (print (eval (read))))
</pre>
<p>Rather than write it like that, we can write it as follows:</p>
<pre>
(-&gt; (read) (eval) (print) (loop))
</pre>
<p>Now, using <em>python-sh</em>, we can show how the threading macro (because of python-sh&apos;s setup) can be used like a pipe:</p>
<pre>
=&gt; (import [sh [cat grep wc]])
=&gt; (-&gt; (cat "/usr/share/dict/words") (grep "-E" "^hy") (wc "-l"))
210
</pre>
<p>Which, of course, expands out to:</p>
<pre>
(wc (grep (cat "/usr/share/dict/words") "-E" "^hy") "-l")
</pre>
<p>Much more readable, no? Use the threading macro!</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DOCUMENTATION INDEX</h2>
        <div class="sectioncontent">
<p>Contents:</p><h3>Command Line Interface</h3>

<h3>hy</h3>

<h3>Command line options</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong>-c &lt;command&gt;</strong></p>
  </dt>
  <dd>
    <p>Execute the Hy code in <em>command</em>.</p>
<pre>
$ hy -c "(print (+ 2 2))"
4
</pre>

  </dd>
  <dt>
    <p><strong>-i &lt;command&gt;</strong></p>
  </dt>
  <dd>
    <p>Execute the Hy code in <em>command</em>, then stay in REPL.</p>
  </dd>
  <dt>
    <p><strong>--spy</strong></p>
  </dt>
  <dd>
    <p>Print equivalent Python code before executing. For example:</p>
<pre>
=&gt; (defn salutationsnm [name] (print (+ "Hy " name "!")))
def salutationsnm(name):
    return print(((u&apos;Hy &apos; + name) + u&apos;!&apos;))
=&gt; (salutationsnm "YourName")
salutationsnm(u&apos;YourName&apos;)
Hy YourName!
=&gt;
</pre>
<p>New in version 0.9.11.</p>
  </dd>
  <dt>
    <p><strong>--show-tracebacks</strong></p>
  </dt>
  <dd>
    <p>Print extended tracebacks for Hy exceptions.</p><p>New in version 0.9.12.</p>
  </dd>
  <dt>
    <p><strong>-v</strong></p>
  </dt>
  <dd>
    <p>Print the Hy version number and exit.</p>
  </dd>

</dl>

<h3>hyc</h3>

<h3>Command line options</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong>file[, fileN]</strong></p>
  </dt>
  <dd>
    <p>Compile Hy code to Python bytecode. For example, save the following code as <strong>hyname.hy</strong>:</p>
<pre>
(defn hy-hy [name]
  (print (+ "Hy " name "!")))

(hy-hy "Afroman")
</pre>
<p>Then run:</p>
<pre>
$ hyc hyname.hy
$ python hyname.pyc
Hy Afroman!
</pre>

  </dd>

</dl>

<h3>hy2py</h3>
<p>New in version 0.10.1.</p>
<h3>Command line options</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong>-s</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--with-source</strong></p>
  </dt>
  <dd>
    <p>Show the parsed source structure.</p>
  </dd>
  <dt>
    <p><strong>-a</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--with-ast</strong></p>
  </dt>
  <dd>
    <p>Show the generated AST.</p>
  </dd>
  <dt>
    <p><strong>-np</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--without-python</strong></p>
  </dt>
  <dd>
    <p>Do not show the Python code generated from the AST.</p>
  </dd>

</dl>

<h3>Hy (the language)</h3>
<p><strong>WARNING:</strong> This is incomplete; please consider contributing to the documentation effort.</p>
<h3>Theory of Hy</h3>
<p>Hy maintains, over everything else, 100% compatibility in both directions with Python itself. All Hy code follows a few simple rules. Memorize this, it&apos;s going to come in handy.</p><p>These rules help make sure code is idiomatic and interface-able in both languages.</p><ul>
<li><p>Symbols in earmufs will be translated to the uppercased version of that string. For example, <em>*foo*</em> will become <em>FOO</em>.</p></li><li><p>UTF-8 entities will be encoded using <em>punycode</em> and prefixed with <em>hy_</em>. For instance, <em>⚘</em> will become <em>hy_w7h</em>, <em>♥</em> will become <em>hy_g6h</em>, and <em>i♥u</em> will become <em>hy_iu_t0x</em>.</p></li><li><p>Symbols that contain dashes will have them replaced with underscores. For example, <em>render-template</em> will become <em>render_template</em>. This means that symbols with dashes will shadow their underscore equivalents, and vice versa.</p></li>
</ul>
<h3>Builtins</h3>
<p>Hy features a number of special forms that are used to help generate correct Python AST. The following are "special" forms, which may have behavior that&apos;s slightly unexpected in some situations.</p>
<h3>.</h3>
<p>New in version 0.10.0.</p><p><em>.</em> is used to perform attribute access on objects. It uses a small DSL to allow quick access to attributes and items in a nested datastructure.</p><p>For instance,</p>
<pre>
(. foo bar baz [(+ 1 2)] frob)
</pre>
<p>Compiles down to</p>
<pre>
foo.bar.baz[1 + 2].frob
</pre>
<p><em>.</em> compiles its first argument (in the example, <em>foo</em>) as the object on which to do the attribute dereference. It uses bare symbols as attributes to access (in the example, <em>bar</em>, <em>baz</em>, <em>frob</em>), and compiles the contents of lists (in the example, <strong>[(+ 1 2)]</strong>) for indexation. Other arguments throw a compilation error.</p><p>Access to unknown attributes throws an <strong>AttributeError</strong>. Access to unknown keys throws an <strong>IndexError</strong> (on lists and tuples) or a <strong>KeyError</strong> (on dicts).</p>
<h3>-&gt;</h3>
<p><em>-&gt;</em> or <em>threading macro</em> is used to avoid nesting of expressions. The threading macro inserts each expression into the next expression’s first argument place. The following code demonstrates this:</p>
<pre>
=&gt; (defn output [a b] (print a b))
=&gt; (-&gt; (+ 5 5) (output 5))
10 5
</pre>

<h3>-&gt;&gt;</h3>
<p><em>-&gt;&gt;</em> or <em>threading tail macro</em> is similar to <em>threading macro</em> but instead of inserting each expression into the next expression’s first argument place, it appends it as the last argument. The following code demonstrates this:</p>
<pre>
=&gt; (defn output [a b] (print a b))
=&gt; (-&gt;&gt; (+ 5 5) (output 5))
5 10
</pre>

<h3>apply</h3>
<p><em>apply</em> is used to apply an optional list of arguments and an optional dictionary of kwargs to a function.</p><p>Usage: <em>(apply fn-name [args] [kwargs])</em></p><p>Examples:</p>
<pre>
(defn thunk []
  "hy there")

(apply thunk)
;=&gt; "hy there"

(defn total-purchase [price amount &optional [fees 1.05] [vat 1.1]]
  (* price amount fees vat))

(apply total-purchase [10 15])
;=&gt; 173.25

(apply total-purchase [10 15] {"vat" 1.05})
;=&gt; 165.375

(apply total-purchase [] {"price" 10 "amount" 15 "vat" 1.05})
;=&gt; 165.375
</pre>

<h3>and</h3>
<p><em>and</em> form is used in logical expressions. It takes at least two parameters. If all parameters evaluate to <em>True</em> the last parameter is returned. In any other case the first false value will be returned. Examples of usage:</p>
<pre>
=&gt; (and True False)
False

=&gt; (and True True)
True

=&gt; (and True 1)
1

=&gt; (and True [] False True)
[]
</pre>
<p><strong>NOTE:</strong> <em>and</em> shortcuts and stops evaluating parameters as soon as the first false is encountered.</p>
<pre>
=&gt; (and False (print "hello"))
False
</pre>

<h3>assert</h3>
<p><em>assert</em> is used to verify conditions while the program is running. If the condition is not met, an <em>AssertionError</em> is raised. The example usage:</p>
<pre>
(assert (= variable expected-value))
</pre>
<p>Assert takes a single parameter, a conditional that evaluates to either <em>True</em> or <em>False</em>.</p>
<h3>assoc</h3>
<p><em>assoc</em> form is used to associate a key with a value in a dictionary or to set an index of a list to a value. It takes at least three parameters: <em>datastructure</em> to be modified, <em>key</em> or <em>index</em>  and <em>value</em>. If more than three parameters are used it will associate in pairs.</p><p>Examples of usage:</p>
<pre>
=&gt;(let [[collection {}]]
... (assoc collection "Dog" "Bark")
... (print collection))
{u&apos;Dog&apos;: u&apos;Bark&apos;}

=&gt;(let [[collection {}]]
... (assoc collection "Dog" "Bark" "Cat" "Meow")
... (print collection))
{u&apos;Cat&apos;: u&apos;Meow&apos;, u&apos;Dog&apos;: u&apos;Bark&apos;}

=&gt;(let [[collection [1 2 3 4]]]
... (assoc collection 2 None)
... (print collection))
[1, 2, None, 4]
</pre>
<p><strong>NOTE:</strong> <em>assoc</em> modifies the datastructure in place and returns <em>None</em>.</p>
<h3>break</h3>
<p><em>break</em> is used to break out from a loop. It terminates the loop immediately.</p><p>The following example has an infinite while loop that is terminated as soon as the user enters <em>k</em>.</p>
<pre>
(while True (if (= "k" (raw-input "? "))
              (break)
              (print "Try again")))
</pre>

<h3>cond</h3>
<p><em>cond</em> macro can be used to build nested if-statements.</p><p>The following example shows the relationship between the macro and the expanded code:</p>
<pre>
(cond [condition-1 result-1]
      [condition-2 result-2])

(if condition-1 result-1
  (if condition-2 result-2))
</pre>
<p>As shown below only the first matching result block is executed.</p>
<pre>
=&gt; (defn check-value [value]
...  (cond [(&lt; value 5) (print "value is smaller than 5")]
...        [(= value 5) (print "value is equal to 5")]
...        [(&gt; value 5) (print "value is greater than 5")]
...        [True (print "value is something that it should not be")]))

=&gt; (check-value 6)
value is greater than 5
</pre>

<h3>continue</h3>
<p><em>continue</em> returns execution to the start of a loop. In the following example, function <em>(side-effect1)</em> is called for each iteration. <em>(side-effect2)</em> however is called only for every other value in the list.</p>
<pre>
;; assuming that (side-effect1) and (side-effect2) are functions and
;; collection is a list of numerical values

(for [x collection]
  (do
    (side-effect1 x)
    (if (% x 2)
      (continue))
    (side-effect2 x)))
</pre>

<h3>dict-comp</h3>
<p><em>dict-comp</em> is used to create dictionaries. It takes three or four parameters. The first two parameters are for controlling the return value (key-value pair), while the third is used to select items from a sequence. The fourth and optional parameter can be used to filter out some of the items in the sequence based on a conditional expression.</p>
<pre>
=&gt; (dict-comp x (* x 2) [x (range 10)] (odd? x))
{1: 2, 3: 6, 9: 18, 5: 10, 7: 14}
</pre>

<h3>do / progn</h3>
<p>the <em>do</em> and <em>progn</em> forms are used to evaluate each of their arguments and return the last one. Return values from every other than the last argument are discarded. It can be used in <em>lambda</em> or <em>list-comp</em> to perform more complex logic as shown by one of the examples.</p><p>Some example usage:</p>
<pre>
=&gt; (if true
...  (do (print "Side effects rock!")
...      (print "Yeah, really!")))
Side effects rock!
Yeah, really!

;; assuming that (side-effect) is a function that we want to call for each
;; and every value in the list, but whose return value we do not care about
=&gt; (list-comp (do (side-effect x)
...               (if (&lt; x 5) (* 2 x)
...                   (* 4 x)))
...           (x (range 10)))
[0, 2, 4, 6, 8, 20, 24, 28, 32, 36]
</pre>
<p><em>do</em> can accept any number of arguments, from 1 to n.</p>
<h3>def / setv</h3>
<p><em>def</em> and <em>setv</em> are used to bind value, object or a function to a symbol. For example:</p>
<pre>
=&gt; (def names ["Alice" "Bob" "Charlie"])
=&gt; (print names)
[u&apos;Alice&apos;, u&apos;Bob&apos;, u&apos;Charlie&apos;]

=&gt; (setv counter (fn [collection item] (.count collection item)))
=&gt; (counter [1 2 3 4 5 2 3] 2)
2
</pre>

<h3>defclass</h3>
<p>new classes are declared with <em>defclass</em>. It can takes two optional parameters: a vector defining a possible super classes and another vector containing attributes of the new class as two item vectors.</p>
<pre>
(defclass class-name [super-class-1 super-class-2]
  [[attribute value]])
</pre>
<p>Both values and functions can be bound on the new class as shown by the example below:</p>
<pre>
=&gt; (defclass Cat []
...  [[age None]
...   [colour "white"]
...   [speak (fn [self] (print "Meow"))]])

=&gt; (def spot (Cat))
=&gt; (setv spot.colour "Black")
&apos;Black&apos;
=&gt; (.speak spot)
Meow
</pre>

<h3>defn / defun</h3>
<p><em>defn</em> and <em>defun</em> macros are used to define functions. They take three parameters: <em>name</em> of the function to define, vector of <em>parameters</em> and the <em>body</em> of the function:</p>
<pre>
(defn name [params] body)
</pre>
<p>Parameters may have following keywords in front of them:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>&optional</strong></p>
  </dt>
  <dd>
    <p>parameter is optional. The parameter can be given as a two item list, where the first element is parameter name and the second is the default value. The parameter can be also given as a single item, in which case the default value is None.</p>
<pre>
=&gt; (defn total-value [value &optional [value-added-tax 10]]
...  (+ (/ (* value value-added-tax) 100) value))

=&gt; (total-value 100)
110.0

=&gt; (total-value 100 1)
101.0
</pre>
<p>&key</p>
  </dd>
  <dt>
    <p><strong>&kwargs</strong></p>
  </dt>
  <dd>
    <p>parameter will contain 0 or more keyword arguments.</p><p>The following code examples defines a function that will print all keyword arguments and their values.</p>
<pre>
=&gt; (defn print-parameters [&kwargs kwargs]
...    (for [(, k v) (.items kwargs)] (print k v)))

=&gt; (apply print-parameters [] {"parameter-1" 1 "parameter-2" 2})
parameter-2 2
parameter-1 1
</pre>

  </dd>
  <dt>
    <p><strong>&rest</strong></p>
  </dt>
  <dd>
    <p>parameter will contain 0 or more positional arguments. No other positional arguments may be specified after this one.</p><p>The following code example defines a function that can be given 0 to n numerical parameters. It then sums every odd number and subtracts every even number.</p>
<pre>
=&gt; (defn zig-zag-sum [&rest numbers]
     (let [[odd-numbers (list-comp x [x numbers] (odd? x))]
           [even-numbers (list-comp x [x numbers] (even? x))]]
       (- (sum odd-numbers) (sum even-numbers))))

=&gt; (zig-zag-sum)
0
=&gt; (zig-zag-sum 3 9 4)
8
=&gt; (zig-zag-sum 1 2 3 4 5 6)
-3
</pre>

  </dd>

</dl>

<h3>defn-alias / defun-alias</h3>
<p>New in version 0.10.0.</p><p>The <em>defn-alias</em> and <em>defun-alias</em> macros are much like <em>defn</em> above, with the difference that instead of defining a function with a single name, these can also define aliases. Other than taking a list of symbols for function names as the first parameter, <em>defn-alias</em> and <em>defun-alias</em> have no other differences compared to <em>defn</em> and <em>defun</em>.</p>
<pre>
=&gt; (defn-alias [main-name alias] []
...  (print "Hello!"))
=&gt; (main-name)
"Hello!"
=&gt; (alias)
"Hello!"
</pre>

<h3>defmain</h3>
<p>New in version 0.10.1.</p><p>The <em>defmain</em> macro defines a main function that is immediately called with sys.argv as arguments if and only if this file is being executed as a script.  In other words this:</p>
<pre>
(defmain [&rest args]
  (do-something-with args))
</pre>
<p>is the equivalent of:</p>
<pre>
def main(*args):
    do_something_with(args)
    return 0

if __name__ == "__main__":
    import sys
    retval = main(*sys.arg)

    if isinstance(retval, int):
        sys.exit(retval)
</pre>
<p>Note, as you can see above, if you return an integer from this function, this will be used as the exit status for your script. (Python defaults to exit status 0 otherwise, which means everything&apos;s okay!)</p><p>(Since (sys.exit 0) is not run explicitly in case of a non-integer return from defmain, it&apos;s good to put (defmain) as the last bit of code in your file.)</p>
<h3>defmacro</h3>
<p><em>defmacro</em> is used to define macros. The general format is <em>(defmacro name [parameters] expr)</em>.</p><p>The following example defines a macro that can be used to swap order of elements in code, allowing the user to write code in infix notation, where operator is in between the operands.</p>
<pre>
=&gt; (defmacro infix [code]
...  (quasiquote (
...    (unquote (get code 1))
...    (unquote (get code 0))
...    (unquote (get code 2)))))

=&gt; (infix (1 + 1))
2
</pre>

<h3>defmacro-alias</h3>
<p><em>defmacro-alias</em> is used to define macros with multiple names (aliases). The general format is <em>(defmacro-alias [names] [parameters]</em> expr). It creates multiple macros with the same parameter list and body, under the specified list of names.</p><p>The following example defines two macros, both of which allow the user to write code in infix notation.</p>
<pre>
=&gt; (defmacro-alias [infix infi] [code]
...  (quasiquote (
...    (unquote (get code 1))
...    (unquote (get code 0))
...    (unquote (get code 2)))))

=&gt; (infix (1 + 1))
2
=&gt; (infi (1 + 1))
2
</pre>

<h3>defmacro/g!</h3>
<p>New in version 0.9.12.</p><p><em>defmacro/g!</em> is a special version of <em>defmacro</em> that is used to automatically generate <em>gensym</em> for any symbol that starts with <strong>g!</strong>.</p><p>So <strong>g!a</strong> would become <strong>(gensym "a")</strong>.</p><p><strong>SEE ALSO:</strong> Section <em>using-gensym</em></p>
<h3>defreader</h3>
<p>New in version 0.9.12.</p><p><em>defreader</em> defines a reader macro, enabling you to restructure or modify syntax.</p>
<pre>
=&gt; (defreader ^ [expr] (print expr))
=&gt; #^(1 2 3 4)
(1 2 3 4)
=&gt; #^"Hello"
"Hello"
</pre>
<p><strong>SEE ALSO:</strong> Section <em>Reader Macros</em></p>
<h3>del</h3>
<p>New in version 0.9.12.</p><p><em>del</em> removes an object from the current namespace.</p>
<pre>
=&gt; (setv foo 42)
=&gt; (del foo)
=&gt; foo
Traceback (most recent call last):
  File "&lt;console&gt;", line 1, in &lt;module&gt;
NameError: name &apos;foo&apos; is not defined
</pre>
<p><em>del</em> can also remove objects from a mapping, a list, ...</p>
<pre>
=&gt; (setv test (list (range 10)))
=&gt; test
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
=&gt; (del (slice test 2 4)) ;; remove items from 2 to 4 excluded
=&gt; test
[0, 1, 4, 5, 6, 7, 8, 9]
=&gt; (setv dic {"foo" "bar"})
=&gt; dic
{"foo": "bar"}
=&gt; (del (get dic "foo"))
=&gt; dic
{}
</pre>

<h3>doto</h3>
<p>New in version 0.10.1.</p><p><em>doto</em> macro is used to make a sequence of method calls for an object easy.</p>
<pre>
=&gt; (doto [] (.append 1) (.append 2) .reverse)
[2 1]
</pre>

<pre>
=&gt; (setv collection [])
=&gt; (.append collection 1)
=&gt; (.append collection 2)
=&gt; (.reverse collection)
=&gt; collection
[2 1]
</pre>

<h3>eval</h3>
<p><em>eval</em> evaluates a quoted expression and returns the value.</p>
<pre>
=&gt; (eval &apos;(print "Hello World"))
"Hello World"
</pre>

<h3>eval-and-compile</h3>

<h3>eval-when-compile</h3>

<h3>first / car</h3>
<p><em>first</em> and <em>car</em> are macros for accessing the first element of a collection:</p>
<pre>
=&gt; (first (range 10))
0
</pre>

<h3>for</h3>
<p><em>for</em> is used to call a function for each element in a list or vector. The results of each call are discarded and the for expression returns None instead. The example code iterates over <em>collection</em> and for each <em>element</em> in <em>collection</em> calls the <em>side-effect</em> function with <em>element</em> as its argument:</p>
<pre>
;; assuming that (side-effect) is a function that takes a single parameter
(for [element collection] (side-effect element))

;; for can have an optional else block
(for [element collection] (side-effect element)
     (else (side-effect-2)))
</pre>
<p>The optional <em>else</em> block is executed only if the <em>for</em> loop terminates normally. If the execution is halted with <em>break</em>, the <em>else</em> does not execute.</p>
<pre>
=&gt; (for [element [1 2 3]] (if (&lt; element 3)
...                             (print element)
...                             (break))
...    (else (print "loop finished")))
1
2

=&gt; (for [element [1 2 3]] (if (&lt; element 4)
...                             (print element)
...                             (break))
...    (else (print "loop finished")))
1
2
3
loop finished
</pre>

<h3>genexpr</h3>
<p><em>genexpr</em> is used to create generator expressions. It takes two or three parameters. The first parameter is the expression controlling the return value, while the second is used to select items from a list. The third and optional parameter can be used to filter out some of the items in the list based on a conditional expression. <em>genexpr</em> is similar to <em>list-comp</em>, except that it returns an iterable that evaluates values one by one instead of evaluating them immediately.</p>
<pre>
=&gt; (def collection (range 10))
=&gt; (def filtered (genexpr x [x collection] (even? x)))
=&gt; (list filtered)
[0, 2, 4, 6, 8]
</pre>

<h3>gensym</h3>
<p>New in version 0.9.12.</p><p><em>gensym</em> form is used to generate a unique symbol to allow writing macros without accidental variable name clashes.</p>
<pre>
=&gt; (gensym)
u&apos;:G_1235&apos;

=&gt; (gensym "x")
u&apos;:x_1236&apos;
</pre>
<p><strong>SEE ALSO:</strong> Section <em>using-gensym</em></p>
<h3>get</h3>
<p><em>get</em> form is used to access single elements in lists and dictionaries. <em>get</em> takes two parameters, the <em>datastructure</em> and the <em>index</em> or <em>key</em> of the item. It will then return the corresponding value from the dictionary or the list. Example usages:</p>
<pre>
=&gt; (let [[animals {"dog" "bark" "cat" "meow"}]
...      [numbers ["zero" "one" "two" "three"]]]
...  (print (get animals "dog"))
...  (print (get numbers 2)))
bark
two
</pre>
<p><strong>NOTE:</strong> <em>get</em> raises a KeyError if a dictionary is queried for a non-existing key.</p><p><strong>NOTE:</strong> <em>get</em> raises an IndexError if a list or a tuple is queried for an index that is out of bounds.</p>
<h3>global</h3>
<p><em>global</em> can be used to mark a symbol as global. This allows the programmer to assign a value to a global symbol. Reading a global symbol does not require the <em>global</em> keyword, just the assigning does.</p><p>Following example shows how global <em>a</em> is assigned a value in a function and later on printed on another function. Without the <em>global</em> keyword, the second function would thrown a <em>NameError</em>.</p>
<pre>
(defn set-a [value]
  (global a)
  (setv a value))

(defn print-a []
  (print a))

(set-a 5)
(print-a)
</pre>

<h3>if / if-not</h3>
<p>the <em>if</em> form is used to conditionally select code to be executed. It has to contain the condition block and the block to be executed if the condition evaluates <em>True</em>. Optionally it may contain a block that is executed in case the evaluation of the condition is <em>False</em>. The <em>if-not</em> form (<em>new in</em> 0.10.0) is similar, but the first block after the test will be executed when the test fails, while the other, conditional one, when the test succeeds - opposite of the order of the <em>if</em> form.</p><p>Example usage:</p>
<pre>
(if (money-left? account)
  (print "lets go shopping")
  (print "lets go and work"))

(if-not (money-left? account)
  (print "lets go and work")
  (print "lets go shopping"))
</pre>
<p>Truth values of Python objects are respected. Values <em>None</em>, <em>False</em>, zero of any numeric type, empty sequence and empty dictionary are considered <em>False</em>. Everything else is considered <em>True</em>.</p>
<h3>lisp-if / lif</h3>
<p>New in version 0.10.0.</p><p>For those that prefer a more lisp-y if clause, we have lisp-if, or lif.  This <em>only</em> considers None/nil as false!  All other values of python "falseiness" are considered true.</p>
<pre>
=&gt; (lisp-if True "true" "false")
"true"
=&gt; (lisp-if False "true" "false")
"true"
=&gt; (lisp-if 0 "true" "false")
"true"
=&gt; (lisp-if nil "true" "false")
"false"
=&gt; (lisp-if None "true" "false")
"false"

; And, same thing
=&gt; (lif True "true" "false")
"true"
=&gt; (lif nil "true" "false")
"false"
</pre>

<h3>import</h3>
<p><em>import</em> is used to import modules, like in Python. There are several forms of import you can use.</p>
<pre>
;; Imports each of these modules
;;
;; Python:
;; import sys
;; import os.path
(import sys os.path)

;; Import from a module
;;
;; Python: from os.path import exists, isdir, isfile
(import [os.path [exists isdir isfile]])

;; Import with an alias
;;
;; Python: import sys as systest
(import [sys :as systest])

;; You can list as many imports as you like of different types.
(import [tests.resources [kwtest function-with-a-dash]]
        [os.path [exists isdir isfile]]
        [sys :as systest])

;; Import all module functions into current namespace
(import [sys [*]])
</pre>

<h3>lambda / fn</h3>
<p><em>lambda</em> and <em>fn</em> can be used to define an anonymous function. The parameters are similar to <em>defn</em>: first parameter is vector of parameters and the rest is the body of the function. lambda returns a new function. In the example an anonymous function is defined and passed to another function for filtering output.</p>
<pre>
=&gt; (def people [{:name "Alice" :age 20}
...             {:name "Bob" :age 25}
...             {:name "Charlie" :age 50}
...             {:name "Dave" :age 5}])

=&gt; (defn display-people [people filter]
...  (for [person people] (if (filter person) (print (:name person)))))

=&gt; (display-people people (fn [person] (&lt; (:age person) 25)))
Alice
Dave
</pre>
<p>Just as in normal function definitions, if the first element of the body is a string, it serves as docstring.  This is useful for giving class methods docstrings.</p>
<pre>
=&gt; (setv times-three
...   (fn [x]
...    "Multiplies input by three and returns the result."
...    (* x 3)))
</pre>
<p>Then test it via the Python built-in <strong>help</strong> function:</p>
<pre>
=&gt; (help times-three)
Help on function times_three:

times_three(x)
Multiplies input by three and returns result
(END)
</pre>

<h3>let</h3>
<p><em>let</em> is used to create lexically scoped variables. They are created at the beginning of <em>let</em> form and cease to exist after the form. The following example showcases this behaviour:</p>
<pre>
=&gt; (let [[x 5]] (print x)
...  (let [[x 6]] (print x))
...  (print x))
5
6
5
</pre>
<p><em>let</em> macro takes two parameters: a vector defining <em>variables</em> and <em>body</em>, which is being executed. <em>variables</em> is a vector where each element is either a single variable or a vector defining a variable value pair. In case of a single variable, it is assigned value None, otherwise the supplied value is used.</p>
<pre>
=&gt; (let [x [y 5]] (print x y))
None 5
</pre>

<h3>list-comp</h3>
<p><em>list-comp</em> performs list comprehensions. It takes two or three parameters. The first parameter is the expression controlling the return value, while the second is used to select items from a list. The third and optional parameter can be used to filter out some of the items in the list based on a conditional expression. Some examples:</p>
<pre>
=&gt; (def collection (range 10))
=&gt; (list-comp x [x collection])
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

=&gt; (list-comp (* x 2) [x collection])
[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]

=&gt; (list-comp (* x 2) [x collection] (&lt; x 5))
[0, 2, 4, 6, 8]
</pre>

<h3>not</h3>
<p><em>not</em> form is used in logical expressions. It takes a single parameter and returns a reversed truth value. If <em>True</em> is given as a parameter, <em>False</em> will be returned and vice-versa. Examples for usage:</p>
<pre>
=&gt; (not True)
False

=&gt; (not False)
True

=&gt; (not None)
True
</pre>

<h3>or</h3>
<p><em>or</em> form is used in logical expressions. It takes at least two parameters. It will return the first non-false parameter. If no such value exist, the last parameter will be returned.</p>
<pre>
=&gt; (or True False)
True

=&gt; (and False False)
False

=&gt; (and False 1 True False)
1
</pre>
<p><strong>NOTE:</strong> <em>or</em> shortcuts and stops evaluating parameters as soon as the first true is encountered.</p>
<pre>
=&gt; (or True (print "hello"))
True
</pre>

<h3>print</h3>
<p>the <em>print</em> form is used to output on screen. Example usage:</p>
<pre>
(print "Hello world!")
</pre>
<p><strong>NOTE:</strong> <em>print</em> always returns None</p>
<h3>quasiquote</h3>
<p><em>quasiquote</em> allows you to quote a form, but also to selectively evaluate expressions, expressions inside a <em>quasiquote</em> can be selectively evaluated using <em>unquote</em> (~). The evaluated form can also be spliced using <em>unquote-splice</em> (~@). Quasiquote can be also written using the backquote (\(ga) symbol.</p>
<pre>
;; let \(gaqux&apos; be a variable with value (bar baz)
\(ga(foo ~qux)
; equivalent to &apos;(foo (bar baz))
\(ga(foo ~@qux)
; equivalent to &apos;(foo bar baz)
</pre>

<h3>quote</h3>
<p><em>quote</em> returns the form passed to it without evaluating. <em>quote</em> can be alternatively written using the (&apos;) symbol</p>
<pre>
=&gt; (setv x &apos;(print "Hello World"))
; variable x is set to expression & not evaluated
=&gt; x
(u&apos;print&apos; u&apos;Hello World&apos;)
=&gt; (eval x)
Hello World
</pre>

<h3>require</h3>
<p><em>require</em> is used to import macros from a given module. It takes at least one parameter specifying the module which macros should be imported. Multiple modules can be imported with a single <em>require</em>.</p><p>The following example will import macros from <em>module-1</em> and <em>module-2</em>:</p>
<pre>
(require module-1 module-2)
</pre>

<h3>rest / cdr</h3>
<p><em>rest</em> and <em>cdr</em> return the collection passed as an argument without the first element:</p>
<pre>
=&gt; (rest (range 10))
[1, 2, 3, 4, 5, 6, 7, 8, 9]
</pre>

<h3>set-comp</h3>
<p><em>set-comp</em> is used to create sets. It takes two or three parameters. The first parameter is for controlling the return value, while the second is used to select items from a sequence. The third and optional parameter can be used to filter out some of the items in the sequence based on a conditional expression.</p>
<pre>
=&gt; (setv data [1 2 3 4 5 2 3 4 5 3 4 5])
=&gt; (set-comp x [x data] (odd? x))
{1, 3, 5}
</pre>

<h3>slice</h3>
<p><em>slice</em> can be used to take a subset of a list and create a new list from it. The form takes at least one parameter specifying the list to slice. Two optional parameters can be used to give the start and end position of the subset. If they are not supplied, default value of None will be used instead. Third optional parameter is used to control step between the elements.</p><p><em>slice</em> follows the same rules as the Python counterpart. Negative indecies are counted starting from the end of the list. Some examples of usage:</p>
<pre>
=&gt; (def collection (range 10))

=&gt; (slice collection)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

=&gt; (slice collection 5)
[5, 6, 7, 8, 9]

=&gt; (slice collection 2 8)
[2, 3, 4, 5, 6, 7]

=&gt; (slice collection 2 8 2)
[2, 4, 6]

=&gt; (slice collection -4 -2)
[6, 7]
</pre>

<h3>throw / raise</h3>
<p>the <em>throw</em> or <em>raise</em> forms can be used to raise an Exception at runtime.</p><p>Example usage</p>
<pre>
(throw)
; re-rase the last exception

(throw IOError)
; Throw an IOError

(throw (IOError "foobar"))
; Throw an IOError("foobar")
</pre>
<p><em>throw</em> can accept a single argument (an <em>Exception</em> class or instance), or no arguments to re-raise the last Exception.</p>
<h3>try</h3>
<p>the <em>try</em> form is used to start a <em>try</em> / <em>catch</em> block. The form is used as follows</p>
<pre>
(try
    (error-prone-function)
    (catch [e ZeroDivisionError] (print "Division by zero"))
    (else (print "no errors"))
    (finally (print "all done")))
</pre>
<p><em>try</em> must contain at least one <em>catch</em> block, and may optionally have an <em>else</em> or <em>finally</em> block. If an error is raised with a matching catch block during execution of <em>error-prone-function</em> then that catch block will be executed. If no errors are raised the <em>else</em> block is executed. Regardless if an error was raised or not, the <em>finally</em> block is executed as last.</p>
<h3>unless</h3>
<p><em>unless</em> macro is a shorthand for writing a if-statement that checks if the given conditional is False. The following shows how the macro expands into code.</p>
<pre>
(unless conditional statement)

(if conditional
  None
  (do statement))
</pre>

<h3>unquote</h3>
<p>Within a quasiquoted form, <em>unquote</em> forces evaluation of a symbol. <em>unquote</em> is aliased to the <em>~</em> symbol.</p>
<pre>
(def name "Cuddles")
(quasiquote (= name (unquote name)))
;=&gt; (u&apos;=&apos; u&apos;name&apos; u&apos;Cuddles&apos;)

\(ga(= name ~name)
;=&gt; (u&apos;=&apos; u&apos;name&apos; u&apos;Cuddles&apos;)
</pre>

<h3>unquote-splice</h3>
<p><em>unquote-splice</em> forces the evaluation of a symbol within a quasiquoted form, much like <em>unquote</em>. <em>unquote-splice</em> can only be used when the symbol being unquoted contains an iterable value, as it "splices" that iterable into the quasiquoted form. <em>unquote-splice</em> is aliased to the <em>~@</em> symbol.</p>
<pre>
(def nums [1 2 3 4])
(quasiquote (+ (unquote-splice nums)))
;=&gt; (u&apos;+&apos; 1L 2L 3L 4L)

\(ga(+ ~@nums)
;=&gt; (u&apos;+&apos; 1L 2L 3L 4L)
</pre>

<h3>when</h3>
<p><em>when</em> is similar to <em>unless</em>, except it tests when the given conditional is True. It is not possible to have an <em>else</em> block in <em>when</em> macro. The following shows how the macro is expanded into code.</p>
<pre>
(when conditional statement)

(if conditional (do statement))
</pre>

<h3>while</h3>
<p><em>while</em> form is used to execute a single or more blocks as long as a condition is being met.</p><p>The following example will output "hello world!" on screen indefinitely:</p>
<pre>
(while True (print "hello world!"))
</pre>

<h3>with</h3>
<p><em>with</em> is used to wrap execution of a block with a context manager. The context manager can then set up the local system and tear it down in a controlled manner. Typical example of using <em>with</em> is processing files. <em>with</em>  can bind context to an argument or ignore it completely, as shown below:</p>
<pre>
(with [[arg (expr)]] block)

(with [[(expr)]] block)

(with [[arg (expr)] [(expr)]] block)
</pre>
<p>The following example will open file <em>NEWS</em> and print its content on screen. The file is automatically closed after it has been processed.</p>
<pre>
(with [[f (open "NEWS")]] (print (.read f)))
</pre>

<h3>with-decorator</h3>
<p><em>with-decorator</em> is used to wrap a function with another. The function performing decoration should accept a single value, the function being decorated and return a new function. <em>with-decorator</em> takes a minimum of two parameters, the function performing decoration and the function being decorated. More than one decorator function can be applied, they will be applied in order from outermost to innermost, ie. the first decorator will be the outermost one & so on. Decorators with arguments are called just like a function call.</p>
<pre>
(with-decorator decorator-fun
   (defn some-function [] ...)

(with-decorator decorator1 decorator2 ...
   (defn some-function [] ...)

(with-decorator (decorator arg) ..
   (defn some-function [] ...)
</pre>
<p>In the following example, <em>inc-decorator</em> is used to decorate function <em>addition</em> with a function that takes two parameters and calls the decorated function with values that are incremented by 1. When decorated <em>addition</em> is called with values 1 and 1, the end result will be 4 (1+1 + 1+1).</p>
<pre>
=&gt; (defn inc-decorator [func]
...  (fn [value-1 value-2] (func (+ value-1 1) (+ value-2 1))))
=&gt; (defn inc2-decorator [func]
...  (fn [value-1 value-2] (func (+ value-1 2) (+ value-2 2))))

=&gt; (with-decorator inc-decorator (defn addition [a b] (+ a b)))
=&gt; (addition 1 1)
4
=&gt; (with-decorator inc2-decorator inc-decorator
...  (defn addition [a b] (+ a b)))
=&gt; (addition 1 1)
8
</pre>

<h3>with-gensyms</h3>
<p>New in version 0.9.12.</p><p><em>with-gensym</em> form is used to generate a set of <em>gensym</em> for use in a macro.</p>
<pre>
(with-gensyms [a b c]
  ...)
</pre>
<p>expands to:</p>
<pre>
(let [[a (gensym)
      [b (gensym)
      [c (gensym)]]
  ...)
</pre>
<p><strong>SEE ALSO:</strong> Section <em>using-gensym</em></p>
<h3>yield</h3>
<p><em>yield</em> is used to create a generator object, that returns 1 or more values. The generator is iterable and therefore can be used in loops, list comprehensions and other similar constructs.</p><p>The function random-numbers shows how generators can be used to generate infinite series without consuming infinite amount of memory.</p>
<pre>
=&gt; (defn multiply [bases coefficients]
...  (for [[(, base coefficient) (zip bases coefficients)]]
...   (yield (* base coefficient))))

=&gt; (multiply (range 5) (range 5))
&lt;generator object multiply at 0x978d8ec&gt;

=&gt; (list-comp value [value (multiply (range 10) (range 10))])
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

=&gt; (import random)
=&gt; (defn random-numbers [low high]
...  (while True (yield (.randint random low high))))
=&gt; (list-comp x [x (take 15 (random-numbers 1 50))])])
[7, 41, 6, 22, 32, 17, 5, 38, 18, 38, 17, 14, 23, 23, 19]
</pre>

<h3>yield-from</h3>
<p>New in version 0.9.13.</p><p><strong>PYTHON 3.3 AND UP ONLY!</strong></p><p><em>yield-from</em> is used to call a subgenerator.  This is useful if you want your coroutine to be able to delegate its processes to another coroutine, say if using something fancy like <em>asyncio</em>.</p>
<h3>Hy Core</h3>

<h3>Core Functions</h3>

<h3>coll?</h3>
<p>New in version 0.10.0.</p><p>Usage: <strong>(coll? x)</strong></p><p>Returns true if argument is iterable and not a string.</p>
<pre>
=&gt; (coll? [1 2 3 4])
True

=&gt; (coll? {"a" 1 "b" 2})
True

=&gt; (coll? "abc")
False
</pre>

<h3>cons</h3>
<p>New in version 0.10.0.</p><p>Usage: <strong>(cons a b)</strong></p><p>Returns a fresh <em>cons cell</em> with car <em>a</em> and cdr <em>b</em>.</p>
<pre>
=&gt; (setv a (cons &apos;hd &apos;tl))

=&gt; (= &apos;hd (car a))
True

=&gt; (= &apos;tl (cdr a))
True
</pre>

<h3>cons?</h3>
<p>New in version 0.10.0.</p><p>Usage: <strong>(cons? foo)</strong></p><p>Checks whether <strong>foo</strong> is a <em>cons cell</em>.</p>
<pre>
=&gt; (setv a (cons &apos;hd &apos;tl))

=&gt; (cons? a)
True

=&gt; (cons? nil)
False

=&gt; (cons? [1 2 3])
False
</pre>

<h3>dec</h3>
<p>Usage: <strong>(dec x)</strong></p><p>Return one less than x. Equivalent to <strong>(- x 1)</strong>.</p><p>Raises <strong>TypeError</strong> if <strong>(not (numeric? x))</strong>.</p>
<pre>
=&gt; (dec 3)
2

=&gt; (dec 0)
-1

=&gt; (dec 12.3)
11.3
</pre>

<h3>disassemble</h3>
<p>New in version 0.10.0.</p><p>Usage: <strong>(disassemble tree &optional [codegen false])</strong></p><p>Dump the Python AST for given Hy <strong>tree</strong> to standard output. If <em>codegen</em> is <strong>true</strong> function prints Python code instead.</p>
<pre>
=&gt; (disassemble &apos;(print "Hello World!"))
Module(
 body=[
     Expr(value=Call(func=Name(id=&apos;print&apos;), args=[Str(s=&apos;Hello World!&apos;)], keywords=[], starargs=None, kwargs=None))])

=&gt; (disassemble &apos;(print "Hello World!") true)
print(&apos;Hello World!&apos;)
</pre>

<h3>empty?</h3>
<p>Usage: <strong>(empty? coll)</strong></p><p>Return True if <strong>coll</strong> is empty, i.e. <strong>(= 0 (len coll))</strong>.</p>
<pre>
=&gt; (empty? [])
True

=&gt; (empty? "")
True

=&gt; (empty? (, 1 2))
False
</pre>

<h3>every?</h3>
<p>New in version 0.10.0.</p><p>Usage: <strong>(every? pred coll)</strong></p><p>Return True if <strong>(pred x)</strong> is logical true for every <strong>x</strong> in <strong>coll</strong>, otherwise False. Return True if <strong>coll</strong> is empty.</p>
<pre>
=&gt; (every? even? [2 4 6])
True

=&gt; (every? even? [1 3 5])
False

=&gt; (every? even? [2 4 5])
False

=&gt; (every? even? [])
True
</pre>

<h3>float?</h3>
<p>Usage: <strong>(float? x)</strong></p><p>Return True if x is a float.</p>
<pre>
=&gt; (float? 3.2)
True

=&gt; (float? -2)
False
</pre>

<h3>even?</h3>
<p>Usage: <strong>(even? x)</strong></p><p>Return True if x is even.</p><p>Raises <strong>TypeError</strong> if <strong>(not (numeric? x))</strong>.</p>
<pre>
=&gt; (even? 2)
True

=&gt; (even? 13)
False

=&gt; (even? 0)
True
</pre>

<h3>identity</h3>
<p>Usage: <strong>(identity x)</strong></p><p>Returns argument supplied to the function</p>
<pre>
=&gt; (identity 4)
4

=&gt; (list (map identity [1 2 3 4]))
[1 2 3 4]
</pre>

<h3>inc</h3>
<p>Usage: <strong>(inc x)</strong></p><p>Return one more than x. Equivalent to <strong>(+ x 1)</strong>.</p><p>Raises <strong>TypeError</strong> if <strong>(not (numeric? x))</strong>.</p>
<pre>
=&gt; (inc 3)
4

=&gt; (inc 0)
1

=&gt; (inc 12.3)
13.3
</pre>

<h3>instance?</h3>
<p>Usage: <strong>(instance? CLASS x)</strong></p><p>Return True if x is an instance of CLASS.</p>
<pre>
=&gt; (instance? float 1.0)
True

=&gt; (instance? int 7)
True

=&gt; (instance? str (str "foo"))
True

=&gt; (defclass TestClass [object])
=&gt; (setv inst (TestClass))
=&gt; (instance? TestClass inst)
True
</pre>

<h3>integer?</h3>
<p>Usage: <strong>(integer? x)</strong></p><p>Return True if x is an integer. For Python 2, this is either <strong>int</strong> or <strong>long</strong>. For Python 3, this is <strong>int</strong>.</p>
<pre>
=&gt; (integer? 3)
True

=&gt; (integer? -2.4)
False
</pre>

<h3>interleave</h3>
<p>New in version 0.10.1.</p><p>Usage: <strong>(interleave seq1 seq2 ...)</strong></p><p>Return an iterable of the first item in each of the sequences, then the second etc.</p>
<pre>
=&gt; (list (interleave (range 5) (range 100 105)))
[0, 100, 1, 101, 2, 102, 3, 103, 4, 104]

=&gt; (list (interleave (range 1000000) "abc"))
[0, &apos;a&apos;, 1, &apos;b&apos;, 2, &apos;c&apos;]
</pre>

<h3>interpose</h3>
<p>New in version 0.10.1.</p><p>Usage: <strong>(interpose item seq)</strong></p><p>Return an iterable of the elements of the sequence separated by the item.</p>
<pre>
=&gt; (list (interpose "!" "abcd"))
[&apos;a&apos;, &apos;!&apos;, &apos;b&apos;, &apos;!&apos;, &apos;c&apos;, &apos;!&apos;, &apos;d&apos;]

=&gt; (list (interpose -1 (range 5)))
[0, -1, 1, -1, 2, -1, 3, -1, 4]
</pre>

<h3>iterable?</h3>
<p>Usage: <strong>(iterable? x)</strong></p><p>Return True if x is iterable. Iterable objects return a new iterator when <strong>(iter x)</strong> is called. Contrast with <em>iterator?-fn</em>.</p>
<pre>
=&gt; ;; works for strings
=&gt; (iterable? (str "abcde"))
True

=&gt; ;; works for lists
=&gt; (iterable? [1 2 3 4 5])
True

=&gt; ;; works for tuples
=&gt; (iterable? (, 1 2 3))
True

=&gt; ;; works for dicts
=&gt; (iterable? {:a 1 :b 2 :c 3})
True

=&gt; ;; works for iterators/generators
=&gt; (iterable? (repeat 3))
True
</pre>

<h3>iterator?</h3>
<p>Usage: <strong>(iterator? x)</strong></p><p>Return True if x is an iterator. Iterators are objects that return themselves as an iterator when <strong>(iter x)</strong> is called. Contrast with <em>iterable?-fn</em>.</p>
<pre>
=&gt; ;; doesn&apos;t work for a list
=&gt; (iterator? [1 2 3 4 5])
False

=&gt; ;; but we can get an iter from the list
=&gt; (iterator? (iter [1 2 3 4 5]))
True

=&gt; ;; doesn&apos;t work for dict
=&gt; (iterator? {:a 1 :b 2 :c 3})
False

=&gt; ;; create an iterator from the dict
=&gt; (iterator? (iter {:a 1 :b 2 :c 3}))
True
</pre>

<h3>list*</h3>
<p>Usage: <strong>(list* head &rest tail)</strong></p><p>Generate a chain of nested cons cells (a dotted list) containing the arguments. If the argument list only has one element, return it.</p>
<pre>
=&gt; (list* 1 2 3 4)
(1 2 3 . 4)

=&gt; (list* 1 2 3 [4])
[1, 2, 3, 4]

=&gt; (list* 1)
1

=&gt; (cons? (list* 1 2 3 4))
True
</pre>

<h3>macroexpand</h3>
<p>New in version 0.10.0.</p><p>Usage: <strong>(macroexpand form)</strong></p><p>Returns the full macro expansion of form.</p>
<pre>
=&gt; (macroexpand &apos;(-&gt; (a b) (x y)))
(u&apos;x&apos; (u&apos;a&apos; u&apos;b&apos;) u&apos;y&apos;)

=&gt; (macroexpand &apos;(-&gt; (a b) (-&gt; (c d) (e f))))
(u&apos;e&apos; (u&apos;c&apos; (u&apos;a&apos; u&apos;b&apos;) u&apos;d&apos;) u&apos;f&apos;)
</pre>

<h3>macroexpand-1</h3>
<p>New in version 0.10.0.</p><p>Usage: <strong>(macroexpand-1 form)</strong></p><p>Returns the single step macro expansion of form.</p>
<pre>
=&gt; (macroexpand-1 &apos;(-&gt; (a b) (-&gt; (c d) (e f))))
(u&apos;_&gt;&apos; (u&apos;a&apos; u&apos;b&apos;) (u&apos;c&apos; u&apos;d&apos;) (u&apos;e&apos; u&apos;f&apos;))
</pre>

<h3>merge-with</h3>
<p>New in version 0.10.1.</p><p>Usage:</p>
<pre>
\(ga\(ga
</pre>
<p>(merge-with f &rest maps)</p><p>Returns a map that consist of the rest of the maps joined onto first. If a key occurs in more than one map, the mapping(s) from the latter (left-to-right) will be combined with the mapping in the result by calling <strong>(f val-in-result val-in-latter)</strong>.</p>
<pre>
=&gt; (merge-with (fn [x y] (+ x y)) {"a" 10 "b" 20} {"a" 1 "c" 30})
{u&apos;a&apos;: 11L, u&apos;c&apos;: 30L, u&apos;b&apos;: 20L}
</pre>

<h3>neg?</h3>
<p>Usage: <strong>(neg? x)</strong></p><p>Return True if x is less than zero (0).</p><p>Raises <strong>TypeError</strong> if <strong>(not (numeric? x))</strong>.</p>
<pre>
=&gt; (neg? -2)
True

=&gt; (neg? 3)
False

=&gt; (neg? 0)
False
</pre>

<h3>nil?</h3>
<p>Usage: <strong>(nil? x)</strong></p><p>Return True if x is nil/None.</p>
<pre>
=&gt; (nil? nil)
True

=&gt; (nil? None)
True

=&gt; (nil? 0)
False

=&gt; (setf x nil)
=&gt; (nil? x)
True

=&gt; ;; list.append always returns None
=&gt; (nil? (.append [1 2 3] 4))
True
</pre>

<h3>none?</h3>
<p>Usage: <strong>(none? x)</strong></p><p>Return True if x is None.</p>
<pre>
=&gt; (none? None)
True

=&gt; (none? 0)
False

=&gt; (setf x None)
=&gt; (none? x)
True

=&gt; ;; list.append always returns None
=&gt; (none? (.append [1 2 3] 4))
True
</pre>

<h3>nth</h3>
<p>Usage: <strong>(nth coll n &optional [default nil])</strong></p><p>Return the <em>nth</em> item in a collection, counting from 0. Return the default value, <strong>nil</strong>, if out of bounds (unless specified otherwise). Raise <strong>ValueError</strong> if <strong>n</strong> is negative.</p>
<pre>
=&gt; (nth [1 2 4 7] 1)
2

=&gt; (nth [1 2 4 7] 3)
7

=&gt; (nil? (nth [1 2 4 7] 5))
True

=&gt; (nth [1 2 4 7] 5 "default")
&apos;default&apos;

=&gt; (nth (take 3 (drop 2 [1 2 3 4 5 6])) 2))
5

=&gt; (nth [1 2 4 7] -1)
Traceback (most recent call last):
  ...
ValueError: Indices for islice() must be None or an integer: 0 &lt;= x &lt;= sys.maxsize.
</pre>

<h3>numeric?</h3>
<p>Usage: <strong>(numeric? x)</strong></p><p>Return True if x is a numeric, as defined in the Python numbers module class <strong>numbers.Number</strong>.</p>
<pre>
=&gt; (numeric? -2)
True

=&gt; (numeric? 3.2)
True

=&gt; (numeric? "foo")
False
</pre>

<h3>odd?</h3>
<p>Usage: <strong>(odd? x)</strong></p><p>Return True if x is odd.</p><p>Raises <strong>TypeError</strong> if <strong>(not (numeric? x))</strong>.</p>
<pre>
=&gt; (odd? 13)
True

=&gt; (odd? 2)
False

=&gt; (odd? 0)
False
</pre>

<h3>pos?</h3>
<p>Usage: <strong>(pos? x)</strong></p><p>Return True if x is greater than zero (0).</p><p>Raises <strong>TypeError</strong> if <strong>(not (numeric? x))</strong>.</p>
<pre>
=&gt; (pos? 3)
True

=&gt; (pos? -2)
False

=&gt; (pos? 0)
False
</pre>

<h3>second</h3>
<p>Usage: <strong>(second coll)</strong></p><p>Return the second member of <strong>coll</strong>. Equivalent to <strong>(get coll 1)</strong></p>
<pre>
=&gt; (second [0 1 2])
1
</pre>

<h3>some</h3>
<p>New in version 0.10.0.</p><p>Usage: <strong>(some pred coll)</strong></p><p>Return the first logical true value of <strong>(pred x)</strong> for any <strong>x</strong> in <strong>coll</strong>, otherwise <strong>nil</strong>. Return <strong>nil</strong> if <strong>coll</strong> is empty.</p>
<pre>
=&gt; (some even? [2 4 6])
True

=&gt; (nil? (some even? [1 3 5]))
True

=&gt; (nil? (some identity [0 "" []]))
True

=&gt; (some identity [0 "non-empty-string" []])
&apos;non-empty-string&apos;

=&gt; (nil? (some even? []))
True
</pre>

<h3>string?</h3>
<p>Usage: <strong>(string? x)</strong></p><p>Return True if x is a string.</p>
<pre>
=&gt; (string? "foo")
True

=&gt; (string? -2)
False
</pre>

<h3>zero?</h3>
<p>Usage: <strong>(zero? x)</strong></p><p>Return True if x is zero (0).</p>
<pre>
=&gt; (zero? 3)
False

=&gt; (zero? -2)
False

=&gt; (zero? 0)
True
</pre>

<h3>Sequence Functions</h3>
<p>Sequence functions can either create or operate on a potentially infinite sequence without requiring the sequence be fully realized in a list or similar container. They do this by returning a Python iterator.</p><p>We can use the canonical infinite Fibonacci number generator as an example of how to use some of these functions.</p>
<pre>
(defn fib []
  (setv a 0)
  (setv b 1)
  (while true
    (yield a)
    (setv (, a b) (, b (+ a b)))))
</pre>
<p>Note the <strong>(while true ...)</strong> loop. If we run this in the REPL,</p>
<pre>
=&gt; (fib)
&lt;generator object fib at 0x101e642d0&gt;
</pre>
<p>Calling the function only returns an iterator, but does no work until we consume it. Trying something like this is not recommend as the infinite loop will run until it consumes all available RAM, or in this case until I killed it.</p>
<pre>
=&gt; (list (fib))
[1]    91474 killed     hy
</pre>
<p>To get the first 10 Fibonacci numbers, use <em>take-fn</em>. Note that <em>take-fn</em> also returns a generator, so I create a list from it.</p>
<pre>
=&gt; (list (take 10 (fib)))
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
</pre>
<p>To get the Fibonacci number at index 9, (starting from 0):</p>
<pre>
=&gt; (nth (fib) 9)
34
</pre>

<h3>cycle</h3>
<p>Usage: <strong>(cycle coll)</strong></p><p>Return an infinite iterator of the members of coll.</p>
<pre>
=&gt; (list (take 7 (cycle [1 2 3])))
[1, 2, 3, 1, 2, 3, 1]

=&gt; (list (take 2 (cycle [1 2 3])))
[1, 2]
</pre>

<h3>distinct</h3>
<p>Usage: <strong>(distinct coll)</strong></p><p>Returns an iterator containing only the unique members in <strong>coll</strong>.</p>
<pre>
=&gt; (list (distinct [ 1 2 3 4 3 5 2 ]))
[1, 2, 3, 4, 5]

=&gt; (list (distinct []))
[]

=&gt; (list (distinct (iter [ 1 2 3 4 3 5 2 ])))
[1, 2, 3, 4, 5]
</pre>

<h3>drop</h3>
<p>Usage: <strong>(drop n coll)</strong></p><p>Return an iterator, skipping the first <strong>n</strong> members of <strong>coll</strong> Raises <strong>ValueError</strong> if <strong>n</strong> is negative.</p>
<pre>
=&gt; (list (drop 2 [1 2 3 4 5]))
[3, 4, 5]

=&gt; (list (drop 4 [1 2 3 4 5]))
[5]

=&gt; (list (drop 0 [1 2 3 4 5]))
[1, 2, 3, 4, 5]

=&gt; (list (drop 6 [1 2 3 4 5]))
[]
</pre>

<h3>drop-while</h3>
<p>Usage: <strong>(drop-while pred coll)</strong></p><p>Return an iterator, skipping members of <strong>coll</strong> until <strong>pred</strong> is False.</p>
<pre>
=&gt; (list (drop-while even? [2 4 7 8 9]))
[7, 8, 9]

=&gt; (list (drop-while numeric? [1 2 3 None "a"])))
[None, u&apos;a&apos;]

=&gt; (list (drop-while pos? [2 4 7 8 9]))
[]
</pre>

<h3>filter</h3>
<p>Usage: <strong>(filter pred coll)</strong></p><p>Return an iterator for all items in <strong>coll</strong> that pass the predicate <strong>pred</strong>.</p><p>See also <em>remove-fn</em>.</p>
<pre>
=&gt; (list (filter pos? [1 2 3 -4 5 -7]))
[1, 2, 3, 5]

=&gt; (list (filter even? [1 2 3 -4 5 -7]))
[2, -4]
</pre>

<h3>flatten</h3>
<p>New in version 0.9.12.</p><p>Usage: <strong>(flatten coll)</strong></p><p>Return a single list of all the items in <strong>coll</strong>, by flattening all contained lists and/or tuples.</p>
<pre>
=&gt; (flatten [1 2 [3 4] 5])
[1, 2, 3, 4, 5]

=&gt; (flatten ["foo" (, 1 2) [1 [2 3] 4] "bar"])
[&apos;foo&apos;, 1, 2, 1, 2, 3, 4, &apos;bar&apos;]
</pre>

<h3>iterate</h3>
<p>Usage: <strong>(iterate fn x)</strong></p><p>Return an iterator of <em>x</em>, <em>fn(x)</em>, <em>fn(fn(x))</em>.</p>
<pre>
=&gt; (list (take 5 (iterate inc 5)))
[5, 6, 7, 8, 9]

=&gt; (list (take 5 (iterate (fn [x] (* x x)) 5)))
[5, 25, 625, 390625, 152587890625]
</pre>

<h3>read</h3>
<p>Usage: <strong>(read &optional [from-file eof])</strong></p><p>Reads the next hy expression from <em>from-file</em> (defaults to <em>sys.stdin</em>), and can take a single byte as EOF (defaults to an empty string). Raises an <em>EOFError</em> if <em>from-file</em> ends before a complete expression can be parsed.</p>
<pre>
=&gt; (read)
(+ 2 2)
(&apos;+&apos; 2 2)
=&gt; (eval (read))
(+ 2 2)
4

=&gt; (import io)
=&gt; (def buffer (io.StringIO "(+ 2 2)&#92;n(- 2 1)"))
=&gt; (eval (apply read [] {"from_file" buffer}))
4
=&gt; (eval (apply read [] {"from_file" buffer}))
1

=&gt; ; assuming "example.hy" contains:
=&gt; ;   (print "hello")
=&gt; ;   (print "hyfriends!")
=&gt; (with [[f (open "example.hy")]]
...   (try
...     (while true
...            (let [[exp (read f)]]
...              (do
...                (print "OHY" exp)
...                (eval exp))))
...     (catch [e EOFError]
...            (print "EOF!"))))
OHY (&apos;print&apos; &apos;hello&apos;)
hello
OHY (&apos;print&apos; &apos;hyfriends!&apos;)
hyfriends!
EOF!
</pre>

<h3>remove</h3>
<p>Usage: <strong>(remove pred coll)</strong></p><p>Return an iterator from <strong>coll</strong> with elements that pass the predicate, <strong>pred</strong>, removed.</p><p>See also <em>filter-fn</em>.</p>
<pre>
=&gt; (list (remove odd? [1 2 3 4 5 6 7]))
[2, 4, 6]

=&gt; (list (remove pos? [1 2 3 4 5 6 7]))
[]

=&gt; (list (remove neg? [1 2 3 4 5 6 7]))
[1, 2, 3, 4, 5, 6, 7]
</pre>

<h3>repeat</h3>
<p>Usage: <strong>(repeat x)</strong></p><p>Return an iterator (infinite) of <strong>x</strong>.</p>
<pre>
=&gt; (list (take 6 (repeat "s")))
[u&apos;s&apos;, u&apos;s&apos;, u&apos;s&apos;, u&apos;s&apos;, u&apos;s&apos;, u&apos;s&apos;]
</pre>

<h3>repeatedly</h3>
<p>Usage: <strong>(repeatedly fn)</strong></p><p>Return an iterator by calling <strong>fn</strong> repeatedly.</p>
<pre>
=&gt; (import [random [randint]])

=&gt; (list (take 5 (repeatedly (fn [] (randint 0 10)))))
[6, 2, 0, 6, 7]
</pre>

<h3>take</h3>
<p>Usage: <strong>(take n coll)</strong></p><p>Return an iterator containing the first <strong>n</strong> members of <strong>coll</strong>. Raises <strong>ValueError</strong> if <strong>n</strong> is negative.</p>
<pre>
=&gt; (list (take 3 [1 2 3 4 5]))
[1, 2, 3]

=&gt; (list (take 4 (repeat "s")))
[u&apos;s&apos;, u&apos;s&apos;, u&apos;s&apos;, u&apos;s&apos;]

=&gt; (list (take 0 (repeat "s")))
[]
</pre>

<h3>take-nth</h3>
<p>Usage: <strong>(take-nth n coll)</strong></p><p>Return an iterator containing every <strong>nth</strong> member of <strong>coll</strong>.</p>
<pre>
=&gt; (list (take-nth 2 [1 2 3 4 5 6 7]))
[1, 3, 5, 7]

=&gt; (list (take-nth 3 [1 2 3 4 5 6 7]))
[1, 4, 7]

=&gt; (list (take-nth 4 [1 2 3 4 5 6 7]))
[1, 5]

=&gt; (list (take-nth 10 [1 2 3 4 5 6 7]))
[1]
</pre>

<h3>take-while</h3>
<p>Usage: <strong>(take-while pred coll)</strong></p><p>Return an iterator from <strong>coll</strong> as long as predicate, <strong>pred</strong> returns True.</p>
<pre>
=&gt; (list (take-while pos? [ 1 2 3 -4 5]))
[1, 2, 3]

=&gt; (list (take-while neg? [ -4 -3 1 2 5]))
[-4, -3]

=&gt; (list (take-while neg? [ 1 2 3 -4 5]))
[]
</pre>

<h3>zipwith</h3>
<p>New in version 0.9.13.</p><p>Usage: <strong>(zipwith fn coll ...)</strong></p><p>Equivalent to <strong>zip</strong>, but uses a multi-argument function instead of creating a tuple. If <strong>zipwith</strong> is called with N collections, then <strong>fn</strong> must accept N arguments.</p>
<pre>
=&gt; (import operator)
=&gt; (list (zipwith operator.add [1 2 3] [4 5 6]))
[5, 7, 9]
</pre>

<h3>Reader Macros</h3>
<p>Reader macros gives LISP the power to modify and alter syntax on the fly. You don&apos;t want polish notation? A reader macro can easily do just that. Want Clojure&apos;s way of having a regex? Reader macros can also do this easily.</p>
<h3>Syntax</h3>

<pre>
=&gt; (defreader ^ [expr] (print expr))
=&gt; #^(1 2 3 4)
(1 2 3 4)
=&gt; #^"Hello"
"Hello"
=&gt; #^1+2+3+4+3+2
1+2+3+4+3+2
</pre>
<p>Hy has no literal for tuples. Lets say you dislike <em>(, ...)</em> and want something else. This is a problem reader macros are able to solve in a neat way.</p>
<pre>
=&gt; (defreader t [expr] \(ga(, ~@expr))
=&gt; #t(1 2 3)
(1, 2, 3)
</pre>
<p>You could even do like clojure, and have a literal for regular expressions!</p>
<pre>
=&gt; (import re)
=&gt; (defreader r [expr] \(ga(re.compile ~expr))
=&gt; #r".*"
&lt;_sre.SRE_Pattern object at 0xcv7713ph15#&gt;
</pre>

<h3>Implementation</h3>
<p><strong>defreader</strong> takes a single character as symbol name for the reader macro, anything longer will return an error. Implementation wise, <strong>defreader</strong> expands into a lambda covered with a decorator, this decorater saves the lambda in a dict with its module name and symbol.</p>
<pre>
=&gt; (defreader ^ [expr] (print expr))
;=&gt; (with_decorator (hy.macros.reader ^) (fn [expr] (print expr)))
</pre>
<p><strong>#</strong> expands into <strong>(dispatch_reader_macro ...)</strong> where the symbol and expression is passed to the correct function.</p>
<pre>
=&gt; #^()
;=&gt; (dispatch_reader_macro ^ ())
=&gt; #^"Hello"
"Hello"
</pre>
<p><strong>WARNING:</strong> Because of a limitation in Hy&apos;s lexer and parser, reader macros can&apos;t redefine defined syntax such as <strong>()[]{}</strong>. This will most likely be addressed in the future.</p>
<h3>Internal Hy Documentation</h3>
<p><strong>NOTE:</strong> These bits are mostly useful for folks who hack on Hy itself, but can also be used for those delving deeper in macro programming.</p>
<h3>Hy Models</h3>

<h3>Introduction to Hy models</h3>
<p>Hy models are a very thin layer on top of regular Python objects, representing Hy source code as data. Models only add source position information, and a handful of methods to support clean manipulation of Hy source code, for instance in macros. To achieve that goal, Hy models are mixins of a base Python class and <em>HyObject</em>.</p>
<h3>HyObject</h3>
<p><strong>hy.models.HyObject</strong> is the base class of Hy models. It only implements one method, <strong>replace</strong>, which replaces the source position of the current object with the one passed as argument. This allows us to keep track of the original position of expressions that get modified by macros, be that in the compiler or in pure hy macros.</p><p><strong>HyObject</strong> is not intended to be used directly to instantiate Hy models, but only as a mixin for other classes.</p>
<h3>Compound models</h3>
<p>Parenthesized and bracketed lists are parsed as compound models by the Hy parser.</p>
<h3>HyList</h3>
<p><strong>hy.models.list.HyList</strong> is the base class of "iterable" Hy models. Its basic use is to represent bracketed <strong>[]</strong> lists, which, when used as a top-level expression, translate to Python list literals in the compilation phase.</p><p>Adding a HyList to another iterable object reuses the class of the left-hand-side object, a useful behavior when you want to concatenate Hy objects in a macro, for instance.</p>
<h3>HyExpression</h3>
<p><strong>hy.models.expression.HyExpression</strong> inherits <em>HyList</em> for parenthesized <strong>()</strong> expressions. The compilation result of those expressions depends on the first element of the list: the compiler dispatches expressions between compiler special-forms, user-defined macros, and regular Python function calls.</p>
<h3>HyDict</h3>
<p><strong>hy.models.dict.HyDict</strong> inherits <em>HyList</em> for curly-bracketed <strong>{}</strong> expressions, which compile down to a Python dictionary literal.</p><p>The decision of using a list instead of a dict as the base class for <strong>HyDict</strong> allows easier manipulation of dicts in macros, with the added benefit of allowing compound expressions as dict keys (as, for instance, the <em>HyExpression</em> Python class isn&apos;t hashable).</p>
<h3>Atomic models</h3>
<p>In the input stream, double-quoted strings, respecting the Python notation for strings, are parsed as a single token, which is directly parsed as a <em>HyString</em>.</p><p>An uninterrupted string of characters, excluding spaces, brackets, quotes, double-quotes and comments, is parsed as an identifier.</p><p>Identifiers are resolved to atomic models during the parsing phase in the following order:</p><ul>
<li><p><em>HyInteger</em></p></li><li><p><em>HyFloat</em></p></li><li><p><em>HyComplex</em> (if the atom isn&apos;t a bare <strong>j</strong>)</p></li><li><p><em>HyKeyword</em> (if the atom starts with <strong>:</strong>)</p></li><li><p><em>HyLambdaListKeyword</em> (if the atom starts with <strong>&</strong>)</p></li><li><p><em>HySymbol</em></p></li>
</ul>
<h3>HyString</h3>
<p><strong>hy.models.string.HyString</strong> is the base class of string-equivalent Hy models. It also represents double-quoted string literals, <strong>""</strong>, which compile down to unicode string literals in Python. <strong>HyStrings</strong> inherit unicode objects in Python 2, and string objects in Python 3 (and are therefore not encoding-dependent).</p><p><strong>HyString</strong> based models are immutable.</p><p>Hy literal strings can span multiple lines, and are considered by the parser as a single unit, respecting the Python escapes for unicode strings.</p>
<h3>Numeric models</h3>
<p><strong>hy.models.integer.HyInteger</strong> represents integer literals (using the <strong>long</strong> type on Python 2, and <strong>int</strong> on Python 3).</p><p><strong>hy.models.float.HyFloat</strong> represents floating-point literals.</p><p><strong>hy.models.complex.HyComplex</strong> represents complex literals.</p><p>Numeric models are parsed using the corresponding Python routine, and valid numeric python literals will be turned into their Hy counterpart.</p>
<h3>HySymbol</h3>
<p><strong>hy.models.symbol.HySymbol</strong> is the model used to represent symbols in the Hy language. It inherits <em>HyString</em>.</p><p><strong>HySymbol</strong> objects are mangled in the parsing phase, to help Python interoperability:</p><ul>
<li><p>Symbols surrounded by asterisks (<strong>*</strong>) are turned into uppercase;</p></li><li><p>Dashes (<strong>-</strong>) are turned into underscores (<strong>_</strong>);</p></li><li><p>One trailing question mark (<strong>?</strong>) is turned into a leading <strong>is_</strong>.</p><p>Caveat: as the mangling is done during the parsing phase, it is possible to programmatically generate HySymbols that can&apos;t be generated with Hy source code. Such a mechanism is used by <em>gensym</em> to generate "uninterned" symbols.</p></li>
</ul>
<h3>HyKeyword</h3>
<p><strong>hy.models.keyword.HyKeyword</strong> represents keywords in Hy. Keywords are symbols starting with a <strong>:</strong>. The class inherits <em>HyString</em>.</p><p>To distinguish <em>HyKeywords</em> from <em>HySymbols</em>, without the possibility of (involuntary) clashes, the private-use unicode character <strong>"&#92;uFDD0"</strong> is prepended to the keyword literal before storage.</p>
<h3>HyLambdaListKeyword</h3>
<p><strong>hy.models.lambdalist.HyLambdaListKeyword</strong> represents lambda-list keywords, that is keywords used by the language definition inside function signatures. Lambda-list keywords are symbols starting with a <strong>&</strong>. The class inherits <em>HyString</em></p>
<h3>Cons Cells</h3>
<p><strong>hy.models.cons.HyCons</strong> is a representation of Python-friendly <em>cons</em> cells.  Cons cells are especially useful to mimic features of "usual" LISP variants such as Scheme or Common Lisp.</p><p>A cons cell is a 2-item object, containing a <strong>car</strong> (head) and a <strong>cdr</strong> (tail). In some Lisp variants, the cons cell is the fundamental building block, and S-expressions are actually represented as linked lists of cons cells. This is not the case in Hy, as the usual expressions are made of Python lists wrapped in a <strong>HyExpression</strong>. However, the <strong>HyCons</strong> mimicks the behavior of "usual" Lisp variants thusly:</p><ul>
<li><p><strong>(cons something nil)</strong> is <strong>(HyExpression [something])</strong></p></li><li><p><strong>(cons something some-list)</strong> is <strong>((type some-list) (+ [something]</strong> some-list)) (if <strong>some-list</strong> inherits from <strong>list</strong>).</p></li><li><p><strong>(get (cons a b) 0)</strong> is <strong>a</strong></p></li><li><p><strong>(slice (cons a b) 1)</strong> is <strong>b</strong></p><p>Hy supports a dotted-list syntax, where <strong>&apos;(a . b)</strong> means <strong>(cons &apos;a</strong> &apos;b) and <strong>&apos;(a b . c)</strong> means <strong>(cons &apos;a (cons &apos;b &apos;c))</strong>. If the compiler encounters a cons cell at the top level, it raises a compilation error.</p><p><strong>HyCons</strong> wraps the passed arguments (car and cdr) in Hy types, to ease the manipulation of cons cells in a macro context.</p></li>
</ul>
<h3>Hy Internal Theory</h3>

<h3>Overview</h3>
<p>The Hy internals work by acting as a front-end to Python bytecode, so that Hy itself compiles down to Python Bytecode, allowing an unmodified Python runtime to run Hy code, without even noticing it.</p><p>The way we do this is by translating Hy into an internal Python AST datastructure, and building that AST down into Python bytecode using modules from the Python standard library, so that we don&apos;t have to duplicate all the work of the Python internals for every single Python release.</p><p>Hy works in four stages. The following sections will cover each step of Hy from source to runtime.</p>
<h3>Steps 1 and 2: Tokenizing and parsing</h3>
<p>The first stage of compiling Hy is to lex the source into tokens that we can deal with. We use a project called rply, which is a really nice (and fast) parser, written in a subset of Python called rpython.</p><p>The lexing code is all defined in <strong>hy.lex.lexer</strong>. This code is mostly just defining the Hy grammar, and all the actual hard parts are taken care of by rply -- we just define "callbacks" for rply in <strong>hy.lex.parser</strong>, which takes the tokens generated, and returns the Hy models.</p><p>You can think of the Hy models as the "AST" for Hy, it&apos;s what Macros operate on (directly), and it&apos;s what the compiler uses when it compiles Hy down.</p><p><strong>SEE ALSO:</strong> Section <em>models</em> for more information on Hy models and what they mean.</p>
<h3>Step 3: Hy compilation to Python AST</h3>
<p>This is where most of the magic in Hy happens. This is where we take Hy AST (the models), and compile them into Python AST. A couple of funky things happen here to work past a few problems in AST, and working in the compiler is some of the most important work we do have.</p><p>The compiler is a bit complex, so don&apos;t feel bad if you don&apos;t grok it on the first shot, it may take a bit of time to get right.</p><p>The main entry-point to the Compiler is <strong>HyASTCompiler.compile</strong>. This method is invoked, and the only real "public" method on the class (that is to say, we don&apos;t really promise the API beyond that method).</p><p>In fact, even internally, we don&apos;t recurse directly hardly ever, we almost always force the Hy tree through <strong>compile</strong>, and will often do this with sub-elements of an expression that we have. It&apos;s up to the Type-based dispatcher to properly dispatch sub-elements.</p><p>All methods that preform a compilation are marked with the <strong>@builds()</strong> decorator. You can either pass the class of the Hy model that it compiles, or you can use a string for expressions. I&apos;ll clear this up in a second.</p>
<h3>First stage type-dispatch</h3>
<p>Let&apos;s start in the <strong>compile</strong> method. The first thing we do is check the Type of the thing we&apos;re building. We look up to see if we have a method that can build the <strong>type()</strong> that we have, and dispatch to the method that can handle it. If we don&apos;t have any methods that can build that type, we raise an internal <strong>Exception</strong>.</p><p>For instance, if we have a <strong>HyString</strong>, we have an almost 1-to-1 mapping of Hy AST to Python AST. The <strong>compile_string</strong> method takes the <strong>HyString</strong>, and returns an <strong>ast.Str()</strong> that&apos;s populated with the correct line-numbers and content.</p>
<h3>Macro-expand</h3>
<p>If we get a <strong>HyExpression</strong>, we&apos;ll attempt to see if this is a known Macro, and push to have it expanded by invoking <strong>hy.macros.macroexpand</strong>, then push the result back into <strong>HyASTCompiler.compile</strong>.</p>
<h3>Second stage expression-dispatch</h3>
<p>The only special case is the <strong>HyExpression</strong>, since we need to create different AST depending on the special form in question. For instance, when we hit an <strong>(if true true false)</strong>, we need to generate a <strong>ast.If</strong>, and properly compile the sub-nodes. This is where the <strong>@builds()</strong> with a String as an argument comes in.</p><p>For the <strong>compile_expression</strong> (which is defined with an <strong>@builds(HyExpression)</strong>) will dispatch based on the string of the first argument. If, for some reason, the first argument is not a string, it will properly handle that case as well (most likely by raising an <strong>Exception</strong>).</p><p>If the String isn&apos;t known to Hy, it will default to create an <strong>ast.Call</strong>, which will try to do a runtime call (in Python, something like <strong>foo()</strong>).</p>
<h3>Issues hit with Python AST</h3>
<p>Python AST is great; it&apos;s what&apos;s enabled us to write such a powerful project on top of Python without having to fight Python too hard. Like anything, we&apos;ve had our fair share of issues, and here&apos;s a short list of the common ones you might run into.</p><p><em>Python differentiates between Statements and Expressions</em>.</p><p>This might not sound like a big deal -- in fact, to most Python programmers, this will shortly become a "Well, yeah" moment.</p><p>In Python, doing something like:</p><p><strong>print for x in range(10): pass</strong>, because <strong>print</strong> prints expressions, and <strong>for</strong> isn&apos;t an expression, it&apos;s a control flow statement. Things like <strong>1 + 1</strong> are Expressions, as is <strong>lambda x: 1 + x</strong>, but other language features, such as <strong>if</strong>, <strong>for</strong>, or <strong>while</strong> are statements.</p><p>Since they have no "value" to Python, this makes working in Hy hard, since doing something like <strong>(print (if true true false))</strong> is not just common, it&apos;s expected.</p><p>As a result, we auto-mangle things using a <strong>Result</strong> object, where we offer up any <strong>ast.stmt</strong> that need to get run, and a single <strong>ast.expr</strong> that can be used to get the value of whatever was just run. Hy does this by forcing assignment to things while running.</p><p>As example, the Hy:</p>
<pre>
(print (if true true false))
</pre>
<p>Will turn into:</p>
<pre>
if True:
    _mangled_name_here = True
else:
    _mangled_name_here = False

print _mangled_name_here
</pre>
<p>OK, that was a bit of a lie, since we actually turn that statement into:</p>
<pre>
print True if True else False
</pre>
<p>By forcing things into an <strong>ast.expr</strong> if we can, but the general idea holds.</p>
<h3>Step 4: Python bytecode output and runtime</h3>
<p>After we have a Python AST tree that&apos;s complete, we can try and compile it to Python bytecode by pushing it through <strong>eval</strong>. From here on out, we&apos;re no longer in control, and Python is taking care of everything. This is why things like Python tracebacks, pdb and django apps work.</p>
<h3>Hy Macros</h3>

<h3>Using gensym for safer macros</h3>
<p>When writing macros, one must be careful to avoid capturing external variables or using variable names that might conflict with user code.</p><p>We will use an example macro <strong>nif</strong> (see <em>http://letoverlambda.com/index.cl/guest/chap3.html#sec_5</em> for a more complete description.) <strong>nif</strong> is an example, something like a numeric <strong>if</strong>, where based on the expression, one of the 3 forms is called depending on if the expression is positive, zero or negative.</p><p>A first pass might be something like:</p>
<pre>
(defmacro nif [expr pos-form zero-form neg-form]
  \(ga(let [[obscure-name ~expr]]
    (cond [(pos? obscure-name) ~pos-form]
          [(zero? obscure-name) ~zero-form]
          [(neg? obscure-name) ~neg-form])))
</pre>
<p>where <strong>obsure-name</strong> is an attempt to pick some variable name as not to conflict with other code. But of course, while well-intentioned, this is no guarantee.</p><p>The method <em>gensym</em> is designed to generate a new, unique symbol for just such an occasion. A much better version of <strong>nif</strong> would be:</p>
<pre>
(defmacro nif [expr pos-form zero-form neg-form]
  (let [[g (gensym)]]
    \(ga(let [[~g ~expr]]
       (cond [(pos? ~g) ~pos-form]
             [(zero? ~g) ~zero-form]
             [(neg? ~g) ~neg-form]))))
</pre>
<p>This is an easy case, since there is only one symbol. But if there is a need for several gensym&apos;s there is a second macro <em>with-gensyms</em> that basically expands to a series of <strong>let</strong> statements:</p>
<pre>
(with-gensyms [a b c]
  ...)
</pre>
<p>expands to:</p>
<pre>
(let [[a (gensym)
      [b (gensym)
      [c (gensym)]]
  ...)
</pre>
<p>so our re-written <strong>nif</strong> would look like:</p>
<pre>
(defmacro nif [expr pos-form zero-form neg-form]
  (with-gensyms [g]
    \(ga(let [[~g ~expr]]
       (cond [(pos? ~g) ~pos-form]
             [(zero? ~g) ~zero-form]
             [(neg? ~g) ~neg-form]))))
</pre>
<p>Finally, though we can make a new macro that does all this for us. <em>defmacro/g!</em> will take all symbols that begin with <strong>g!</strong> and automatically call <strong>gensym</strong> with the remainder of the symbol. So <strong>g!a</strong> would become <strong>(gensym "a")</strong>.</p><p>Our final version of <strong>nif</strong>, built with <strong>defmacro/g!</strong> becomes:</p>
<pre>
(defmacro/g! nif [expr pos-form zero-form neg-form]
  \(ga(let [[~g!res ~expr]]
     (cond [(pos? ~g!res) ~pos-form]
           [(zero? ~g!res) ~zero-form]
           [(neg? ~g!res) ~neg-form]))))
</pre>

<h3>Checking macro arguments and raising exceptions</h3>

<h3>Hy Compiler Builtins</h3>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONTRIB MODULES INDEX</h2>
        <div class="sectioncontent">
<p>Contents:</p><h3>Anaphoric Macros</h3>
<p>New in version 0.9.12.</p><p>The anaphoric macros module makes functional programming in Hy very concise and easy to read. An anaphoric macro is a type of programming macro that deliberately captures some form supplied to the macro which may be referred to by an anaphor (an expression referring to another). &ndash; Wikipedia (<em>http://en.wikipedia.org/wiki/Anaphoric_macro</em>)</p>
<h3>Macros</h3>

<h3>ap-if</h3>
<p>Usage: <strong>(ap-if (foo) (print it))</strong></p><p>Evaluate the first form for trutheyness, and bind it to <strong>it</strong> in both the true and false branch.</p>
<h3>ap-each</h3>
<p>Usage: <strong>(ap-each [1 2 3 4 5] (print it))</strong></p><p>Evaluate the form for each element in the list for side-effects.</p>
<h3>ap-each-while</h3>
<p>Usage: <strong>(ap-each-while list pred body)</strong></p><p>Evaluate the form for each element where the predicate form returns True.</p>
<pre>
=&gt; (ap-each-while [1 2 3 4 5 6] (&lt; it 4) (print it))
1
2
3
</pre>

<h3>ap-map</h3>
<p>Usage: <strong>(ap-map form list)</strong></p><p>The anaphoric form of map works just like regular map except that instead of a function object it takes a Hy form. The special name, <strong>it</strong> is bound to the current object from the list in the iteration.</p>
<pre>
=&gt; (list (ap-map (* it 2) [1 2 3]))
[2, 4, 6]
</pre>

<h3>ap-map-when</h3>
<p>Usage: <strong>(ap-map-when predfn rep list)</strong></p><p>Evaluate a mapping over the list using a predicate function to determin when to apply the form.</p>
<pre>
=&gt; (list (ap-map-when odd? (* it 2) [1 2 3 4]))
[2, 2, 6, 4]

=&gt; (list (ap-map-when even? (* it 2) [1 2 3 4]))
[1, 4, 3, 8]
</pre>

<h3>ap-filter</h3>
<p>Usage: <strong>(ap-filter form list)</strong></p><p>As with <strong>ap-map</strong> we take a special form instead of a function to filter the elements of the list. The special name <strong>it</strong> is bound to the current element in the iteration.</p>
<pre>
=&gt; (list (ap-filter (&gt; (* it 2) 6) [1 2 3 4 5]))
[4, 5]
</pre>

<h3>ap-reject</h3>
<p>Usage: <strong>(ap-reject form list)</strong></p><p>This function does the opposite of <strong>ap-filter</strong>, it rejects the elements passing the predicate . The special name <strong>it</strong> is bound to the current element in the iteration.</p>
<pre>
=&gt; (list (ap-reject (&gt; (* it 2) 6) [1 2 3 4 5]))
[1, 2, 3]
</pre>

<h3>ap-dotimes</h3>
<p>Usage <strong>(ap-dotimes n body)</strong></p><p>This function evaluates the body <em>n</em> times, with the special variable <strong>it</strong> bound from <em>0</em> to <em>1-n</em>. It is useful for side-effects.</p>
<pre>
 =&gt; (setv n [])
 =&gt; (ap-dotimes 3 (.append n it))
 =&gt; n
[0, 1, 2]
</pre>

<h3>ap-first</h3>
<p>Usage <strong>(ap-first predfn list)</strong></p><p>This function returns the first element that passes the predicate or <strong>None</strong>, with the special variable <strong>it</strong> bound to the current element in iteration.</p>
<pre>
=&gt;(ap-first (&gt; it 5) (range 10))
6
</pre>

<h3>ap-last</h3>
<p>Usage <strong>(ap-last predfn list)</strong></p><p>This function returns the last element that passes the predicate or <strong>None</strong>, with the special variable <strong>it</strong> bound to the current element in iteration.</p>
<pre>
=&gt;(ap-last (&gt; it 5) (range 10))
9
</pre>

<h3>ap-reduce</h3>
<p>Usage <strong>(ap-reduce form list &optional initial-value)</strong></p><p>This function returns the result of applying form to the first 2 elements in the body and applying the result and the 3rd element etc. until the list is exhausted. Optionally an initial value can be supplied so the function will be applied to initial value and the first element instead. This exposes the element being iterated as <strong>it</strong> and the current accumulated value as <strong>acc</strong>.</p>
<pre>
=&gt;(ap-reduce (+ it acc) (range 10))
45
</pre>

<h3>loop/recur</h3>
<p>New in version 0.10.0.</p><p>The loop/recur macro gives programmers a simple way to use tail-call optimization (TCO) in their Hy code. A tail call is a subroutine call that happens inside another procedure as its final action; it may produce a return value which is then immediately returned by the calling procedure. If any call that a subroutine performs, such that it might eventually lead to this same subroutine being called again down the call chain, is in tail position, such a subroutine is said to be tail-recursive, which is a special case of recursion. Tail calls are significant because they can be implemented without adding a new stack frame to the call stack. Most of the frame of the current procedure is not needed any more, and it can be replaced by the frame of the tail call. The program can then jump to the called subroutine. Producing such code instead of a standard call sequence is called tail call elimination, or tail call optimization. Tail call elimination allows procedure calls in tail position to be implemented as efficiently as goto statements, thus allowing efficient structured programming. &ndash; Wikipedia (<em>http://en.wikipedia.org/wiki/Tail_call</em>)</p>
<h3>Macros</h3>

<h3>loop</h3>
<p><strong>loop</strong> establishes a recursion point. With <strong>loop</strong>, <strong>recur</strong> rebinds the variables set in the recursion point and sends code execution back to that recursion point. If <strong>recur</strong> is used in a non-tail position, an exception is thrown.</p><p>Usage: <em>(loop bindings &rest body)</em></p><p>Example:</p>
<pre>
(require hy.contrib.loop)

(defn factorial [n]
  (loop [[i n] [acc 1]]
    (if (zero? i)
      acc
      (recur (dec i) (* acc i)))))

(factorial 1000)
</pre>

<h3>defmulti</h3>
<p>New in version 0.10.0.</p><p><em>defmulti</em> lets you arity-overload a function by the given number of args and/or kwargs. Inspired by clojures take on <em>defn</em>.</p>
<pre>
=&gt; (require hy.contrib.multi)
=&gt;   (defmulti fun
...     ([a] "a")
...     ([a b] "a b")
...     ([a b c] "a b c"))
=&gt; (fun 1)
"a"
=&gt; (fun 1 2)
"a b"
=&gt; (fun 1 2 3)
"a b c"
</pre>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">HACKING ON HY</h2>
        <div class="sectioncontent">
<h3>Join our hyve!</h3>
<p>Please come hack on hy!</p><p>Please come hang out with us on <strong>#hy</strong> on <strong>irc.freenode.net</strong>!</p><p>Please talk about it on Twitter with the <strong>#hy</strong> hashtag!</p><p>Please blog about it!</p><p>Please don&apos;t spraypaint it on your neighbor&apos;s fence (without asking nicely)!</p>
<h3>Hack!</h3>
<p>Do this:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>create a <em>virtual environment</em>:</p>
<pre>
$ virtualenv venv
</pre>
<p>and activate it:</p>
<pre>
$ . venv/bin/activate
</pre>
<p>or use <em>virtualenvwrapper</em> to create and manage your virtual environment:</p>
<pre>
$ mkvirtualenv hy
$ workon hy
</pre>

  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>get the source code:</p>
<pre>
$ git clone https://github.com/hylang/hy.git
</pre>
<p>or use your fork:</p>
<pre>
$ git clone git@github.com:&lt;YOUR_USERNAME&gt;/hy.git
</pre>

  </dd>
  <dt>
    3.
  </dt>
  <dd>
    <p>install for hacking:</p>
<pre>
$ cd hy/
$ pip install -e .
</pre>

  </dd>
  <dt>
    4.
  </dt>
  <dd>
    <p>install other develop-y requirements:</p>
<pre>
$ pip install -r requirements-dev.txt
</pre>

  </dd>
  <dt>
    5.
  </dt>
  <dd>
    <p>do awesome things; make someone shriek in delight/disgust at what you have wrought.</p>
  </dd>

</dl>

<h3>Test!</h3>
<p>Tests are located in <strong>tests/</strong>. We use <em>nose</em>.</p><p>To run the tests:</p>
<pre>
$ nosetests
</pre>
<p>Write tests---tests are good!</p><p>Also, it is good to run the tests for all the platforms supported and for pep8 compliant code. You can do so by running tox:</p>
<pre>
$ tox
</pre>

<h3>Document!</h3>
<p>Documentation is located in <strong>docs/</strong>. We use <em>Sphinx</em>.</p><p>To build the docs in HTML:</p>
<pre>
$ cd docs
$ make html
</pre>
<p>Write docs---docs are good! Even this doc!</p>
<h3>Contributing</h3>
<p>Contributions are welcome & greatly appreciated, every little bit helps in making Hy more awesome.</p><p>Pull requests are great! We love them, here is a quick guide:</p><ul>
<li><p>Fork the repo, create a topic branch for a feature/fix. Avoid making changes directly on the master branch</p></li><li><p>All incoming features should be accompanied with tests</p></li><li><p>Before you submit a PR, please run the tests and check your code against the style guide.  You can do both these things at once:</p>
<pre>
$ make d
</pre>
</li><li><p>Make commits into logical units, so that it is easier to track & navigate later. Before submitting a PR, try squashing the commits into changesets that are easy to come back to later. Also make sure you don&apos;t leave spurious whitespace in the changesets, this avoids creation of whitespace fix commits later.</p></li><li><p>As far as commit messages go, try to adhere to the following:</p></li><li><p>Try sticking to the 50 character limit for the first line of git commit messages</p></li><li><p>For more explanations etc. follow this up with a blank line and continue describing the commit in detail</p></li><li><p>Finally add yourself to the AUTHORS file (as a separate commit), you deserve it :)</p></li><li><p>All incoming changes need to be acked by 2 different members of Hylang&apos;s core team. Additional review is clearly welcome, but we need a minimum of 2 signoffs for any change.</p></li><li><p>If a core member is sending in a PR, please find 2 core members that doesn&apos;t include the PR submitter. The idea here is that one can work with the PR author, and a second acks the entire change set.</p></li><li><p>For documentation & other trivial changes, we&apos;re good to merge after one ACK. We&apos;ve got low coverage, so it&apos;d be great to keep that barrier low.</p></li>
</ul>
<h3>Core Team</h3>
<p>Core development team of hy consists of following developers.</p><ul>
<li><p><em>Julien Danjou</em></p></li><li><p><em>Morten Linderud</em></p></li><li><p><em>J Kenneth King</em></p></li><li><p><em>Gergely Nagy</em></p></li><li><p><em>Tuukka Turto</em></p></li><li><p><em>Karen Rustad</em></p></li><li><p><em>Abhishek L</em></p></li><li><p><em>Christopher Allan Webber</em></p></li><li><p><em>Konrad Hinsen</em></p></li><li><p><em>Will Kahn-Greene</em></p></li><li><p><em>Paul Tagliamonte</em></p></li><li><p><em>Nicolas Dandrimont</em></p></li><li><p><em>Bob Tolbert</em></p></li><li><p><em>Berker Peksag</em></p></li><li><p><em>Clinton N. Dreisbach</em></p></li><li><p><em>han semaj</em></p></li>
</ul>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Paul Tagliamonte</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>2013-2014, Paul Tagliamonte</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="hxxmlns.1.html"><span aria-hidden="true">&larr;</span> hxxmlns.1: Replace xml namespace prefixes by "global names"</a></li>
   <li class="next"><a href="hyantesite.1.html">hyantesite.1: Hyantesite - software client of libhyantes <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

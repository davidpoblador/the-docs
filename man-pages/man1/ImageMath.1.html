<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ImageMath: Part of ants registration suite</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Part of ants registration suite">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="ImageMath (1) manual">
  <meta name="twitter:description" content="Part of ants registration suite">
  <meta name="twitter:image" content="https://www.carta.tech/images/ants-ImageMath-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/ImageMath.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="ImageMath (1) manual" />
  <meta property="og:description" content="Part of ants registration suite" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/ants-ImageMath-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">ImageMath<small> (1)</small></h1>
        <p class="lead">Part of ants registration suite</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/ImageMath.1.html">
      <span itemprop="name">ImageMath: Part of ants registration suite</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/ants/">
      <span itemprop="name">ants</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/ImageMath.1.html">
      <span itemprop="name">ImageMath: Part of ants registration suite</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>ImageMath</strong> <em>\,ImageDimension &lt;OutputImage.ext&gt; \/</em>[<em>\,operations and inputs\/</em>] <em>\,&lt;Image1.ext&gt; &lt;Image2.ext&gt;\/</em></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Usage Information</p><ul>
<li><p>ImageDimension: 2 or 3 (for 2 or 3 dimensional operations). ImageDimension: 4 (for operations on 4D file, e.g. time-series data). Operator: See list of valid operators below. The last two arguments can be an image or float value NB: Some options output text files</p></li>
</ul><h3>Mathematical Operations:</h3>

<dl class='dl-vertical'>
  <dt>
    <p>m</p>
  </dt>
  <dd>
    <p>: Multiply <strong>---</strong>  use vm for vector multiply</p>
  </dd>
  <dt>
    <p>+</p>
  </dt>
  <dd>
    <p>: Add <strong>---</strong>  use v+ for vector add</p>
  </dd>
  <dt>
    <p>-</p>
  </dt>
  <dd>
    <p>: Subtract <strong>---</strong>  use v- for vector subtract</p>
  </dd>
  <dt>
    <p>/</p>
  </dt>
  <dd>
    <p>: Divide</p>
  </dd>
  <dt>
    <p>^</p>
  </dt>
  <dd>
    <p>: Power</p>
  </dd>
  <dt>
    <p>max</p>
  </dt>
  <dd>
    <p>: voxelwise max</p>
  </dd>
  <dt>
    <p>exp</p>
  </dt>
  <dd>
    <p>: Take exponent exp(imagevalue*value)</p>
  </dd>
  <dt>
    <p>addtozero</p>
  </dt>
  <dd>
    <p>: add image-b to image-a only over points where image-a has zero values</p>
  </dd>
  <dt>
    <p>overadd</p>
  </dt>
  <dd>
    <p>: replace image-a pixel with image-b pixel if image-b pixel is non-zero</p>
  </dd>
  <dt>
    <p>abs</p>
  </dt>
  <dd>
    <p>: absolute value</p>
  </dd>
  <dt>
    <p>total</p>
  </dt>
  <dd>
    <p>: Sums up values in an image or in image1*image2 (img2 is the probability mask)</p>
  </dd>
  <dt>
    <p>mean</p>
  </dt>
  <dd>
    <p>:  Average of values in an image or in image1*image2 (img2 is the probability mask)</p>
  </dd>
  <dt>
    <p>vtotal</p>
  </dt>
  <dd>
    <p>: Sums up volumetrically weighted values in an image or in image1*image2 (img2 is the probability mask)</p>
  </dd>
  <dt>
    <p>Decision</p>
  </dt>
  <dd>
    <p>: Computes result=1./(1.+exp(<strong>-1</strong>.0*( pix1-0.25)/pix2))</p>
  </dd>
  <dt>
    <p>Neg</p>
  </dt>
  <dd>
    <p>: Produce image negative</p>
  </dd>

</dl>

<h3>Spatial Filtering:</h3>

<dl class='dl-vertical'>
  <dt>
    <p>Project Image1.ext axis-a which-projection</p>
  </dt>
  <dd>
    <p>: Project an image along axis a, which-projection=0(sum, 1=max, 2=min)</p>
  </dd>
  <dt>
    <p>G Image1.ext s</p>
  </dt>
  <dd>
    <p>: Smooth with Gaussian of sigma = s</p>
  </dd>
  <dt>
    <p>MD Image1.ext s</p>
  </dt>
  <dd>
    <p>: Morphological Dilation with radius s</p>
  </dd>
  <dt>
    <p>ME Image1.ext s</p>
  </dt>
  <dd>
    <p>: Morphological Erosion with radius s</p>
  </dd>
  <dt>
    <p>MO Image1.ext s</p>
  </dt>
  <dd>
    <p>: Morphological Opening with radius s</p>
  </dd>
  <dt>
    <p>MC Image1.ext s</p>
  </dt>
  <dd>
    <p>: Morphological Closing with radius s</p>
  </dd>
  <dt>
    <p>GD Image1.ext s</p>
  </dt>
  <dd>
    <p>: Grayscale Dilation with radius s</p>
  </dd>
  <dt>
    <p>GE Image1.ext s</p>
  </dt>
  <dd>
    <p>: Grayscale Erosion with radius s</p>
  </dd>
  <dt>
    <p>GO Image1.ext s</p>
  </dt>
  <dd>
    <p>: Grayscale Opening with radius s</p>
  </dd>
  <dt>
    <p>GC Image1.ext s</p>
  </dt>
  <dd>
    <p>: Grayscale Closing with radius s</p>
  </dd>
  <dt>
    <p>BlobDetector Image1.ext NumberOfBlobsToExtract</p>
  </dt>
  <dd>
    <p>Optional-Input-Image2 Blob-2-out.nii.gz N-Blobs-To-Match  :  blob detection by searching for local extrema of the Laplacian of the Gassian (LoG)</p><ul>
<li><p>Example matching 6 best blobs from 2 images: ImageMath 2 blob.nii.gz BlobDetector image1.nii.gz 1000  image2.nii.gz blob2.nii.gz 6</p></li><li><p>MatchBlobs Image1.ext Image1LM.ext Image2.ext</p></li>
</ul>
  </dd>

</dl>
<p>Transform Image: Translate InImage.ext x [ y z ]</p>
<h3>Time Series Operations:</h3>

<dl class='dl-vertical'>
  <dt>
    <p>CompCorrAuto : Outputs a csv file containing global signal vector and N comp-corr eigenvectors determined from PCA of the high-variance voxels.</p>
  </dt>
  <dd>
    <p>Also outputs a comp-corr + global signal corrected 4D image as well as a 3D image measuring the time series variance.  Requires a label image with label 1 identifying voxels in the brain.</p>
  </dd>
  <dt>
    <p>ImageMath 4 ${out}compcorr.nii.gz ThreeTissueConfounds ${out}.nii.gz</p>
  </dt>
  <dd>
    <p>${out}seg.nii.gz 1 3   : Outputs average global, CSF and WM signals.  Requires a label image with 3 labels , csf, gm , wm .</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: ThreeTissueConfounds 4D_TimeSeries.nii.gz LabeLimage.nii.gz  csf-label wm-label</p><ul>
<li><p>TimeSeriesSubset : Outputs n 3D image sub-volumes extracted uniformly from the input time-series 4D image.</p></li>
</ul>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: TimeSeriesSubset 4D_TimeSeries.nii.gz n</p><ul>
<li><p>TimeSeriesDisassemble : Outputs n 3D image volumes for each time-point in time-series 4D image.</p></li>
</ul>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: TimeSeriesDisassemble 4D_TimeSeries.nii.gz</p><ul>
<li><p>TimeSeriesAssemble : Outputs a 4D time-series image from a list of 3D volumes.</p></li>
</ul>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: TimeSeriesAssemble time_spacing time_origin *images.nii.gz</p><ul>
<li><p>TimeSeriesToMatrix : Converts a 4D image + mask to matrix (stored as csv file) where rows are time and columns are space .</p></li>
</ul>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: TimeSeriesToMatrix 4D_TimeSeries.nii.gz mask</p><ul>
<li><p>TimeSeriesSimpleSubtraction : Outputs a 3D mean pair-wise difference list of 3D volumes.</p></li>
</ul>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: TimeSeriesSimpleSubtraction image.nii.gz</p><ul>
<li><p>TimeSeriesSurroundSubtraction : Outputs a 3D mean pair-wise difference list of 3D volumes.</p></li>
</ul>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: TimeSeriesSurroundSubtraction image.nii.gz</p><ul>
<li><p>TimeSeriesSincSubtraction : Outputs a 3D mean pair-wise difference list of 3D volumes.</p></li>
</ul>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: TimeSeriesSincSubtraction image.nii.gz</p><ul>
<li><p>SplitAlternatingTimeSeries : Outputs 2 3D time series</p></li>
</ul>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: SplitAlternatingTimeSeries image.nii.gz</p>
  </dd>
  <dt>
    <p>ComputeTimeSeriesLeverage : Outputs a csv file that identifies the raw leverage and normalized leverage for each time point in the 4D image.</p>
  </dt>
  <dd>
    <p>leverage, here, is the difference of the time-point image from the average of the n images.  the normalized leverage is =  average( sum_k abs(Leverage(t)-Leverage(k)) )/Leverage(t).</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: ComputeTimeSeriesLeverage 4D_TimeSeries.nii.gz k_neighbors</p><ul>
<li><p>SliceTimingCorrection : Outputs a slice-timing corrected 4D time series</p></li>
</ul>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: SliceTimingCorrection image.nii.gz sliceTiming [sinc / bspline] [sincRadius=4 / bsplineOrder=3]</p><ul>
<li><p>PASL : computes the PASL model of CBF</p></li>
</ul>
  </dd>

</dl>
<p>f =  rac{      lambda DeltaM        }</p>
<dl class='dl-vertical'>
  <dt>
    <p>{</p>
  </dt>
  <dd>
    <p>2 alpha M_0 TI_1 exp( - TI_2 / T_{1a} )  }</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: PASL 3D/4D_TimeSeries.nii.gz BoolFirstImageIsControl M0Image parameter_list.txt</p><ul>
<li><p>pCASL : computes the pCASL model of CBF f =  rac{      lambda DeltaM R_{1a}        }</p></li>
</ul>
  </dd>
  <dt>
    <p>{</p>
  </dt>
  <dd>
    <p>2 alpha M_0 [ exp( - w R_{1a} ) - exp( <strong>-w</strong> (     au + w ) R_{1a}) ]     }</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: pCASL 3D/4D_TimeSeries.nii.gz parameter_list.txt</p><ul>
<li><p>PASLQuantifyCBF : Outputs a 3D CBF image in ml/100g/min from a magnetization ratio image</p></li>
</ul>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: PASLQuantifyCBF mag_ratio.nii.gz [TI1=700] [TI2=1900] [T1blood=1664] [Lambda=0.9] [Alpha=0.95] [SliceDelay-45]</p>
  </dd>

</dl>

<h3>Tensor Operations:</h3>

<dl class='dl-vertical'>
  <dt>
    <p>4DTensorTo3DTensor</p>
  </dt>
  <dd>
    <p>: Outputs a 3D_DT_Image with the same information.</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: 4DTensorTo3DTensor 4D_DTImage.ext</p>
  </dd>
  <dt>
    <p>ComponentTo3DTensor</p>
  </dt>
  <dd>
    <p>: Outputs a 3D_DT_Image with the same information as component images.</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: ComponentTo3DTensor component_image_prefix[xx,xy,xz,yy,yz,zz] extension</p>
  </dd>
  <dt>
    <p>ExtractComponentFrom3DTensor</p>
  </dt>
  <dd>
    <p>: Outputs a component images.</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: ExtractComponentFrom3DTensor dtImage.ext which={xx,xy,xz,yy,yz,zz}</p><ul>
<li><p>ExtractVectorComponent: Produces the WhichVec component of the vector</p></li>
</ul>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: ExtractVectorComponent VecImage WhichVec</p>
  </dd>
  <dt>
    <p>TensorColor</p>
  </dt>
  <dd>
    <p>: Produces RGB values identifying principal directions</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: TensorColor DTImage.ext</p>
  </dd>
  <dt>
    <p>TensorFA</p>
  </dt>
  <dd>
    <p>:</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: TensorFA DTImage.ext</p>
  </dd>
  <dt>
    <p>TensorFADenominator</p>
  </dt>
  <dd>
    <p>:</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: TensorFADenominator DTImage.ext</p>
  </dd>
  <dt>
    <p>TensorFANumerator</p>
  </dt>
  <dd>
    <p>:</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: TensorFANumerator DTImage.ext</p>
  </dd>
  <dt>
    <p>TensorIOTest</p>
  </dt>
  <dd>
    <p>: Will write the DT image back out ... tests I/O processes for consistency.</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: TensorIOTest DTImage.ext</p>
  </dd>
  <dt>
    <p>TensorMeanDiffusion</p>
  </dt>
  <dd>
    <p>: Mean of the eigenvalues</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: TensorMeanDiffusion DTImage.ext</p>
  </dd>
  <dt>
    <p>TensorRadialDiffusion</p>
  </dt>
  <dd>
    <p>: Mean of the two smallest eigenvalues</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: TensorRadialDiffusion DTImage.ext</p>
  </dd>
  <dt>
    <p>TensorAxialDiffusion</p>
  </dt>
  <dd>
    <p>: Largest eigenvalue, equivalent to TensorEigenvalue DTImage.ext 2</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: TensorAxialDiffusion DTImage.ext</p>
  </dd>
  <dt>
    <p>TensorEigenvalue</p>
  </dt>
  <dd>
    <p>: Gets a single eigenvalue 0-2, where 0 = smallest, 2 = largest</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: TensorEigenvalue DTImage.ext WhichInd</p>
  </dd>
  <dt>
    <p>TensorToVector</p>
  </dt>
  <dd>
    <p>: Produces vector field identifying one of the principal directions, 2 = largest eigenvalue</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: TensorToVector DTImage.ext WhichVec</p><ul>
<li><p>TensorToVectorComponent: 0 =&gt; 2 produces component of the principal vector field (largest eigenvalue). 3 = 8 =&gt; gets values from the tensor</p></li>
</ul>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: TensorToVectorComponent DTImage.ext WhichVec</p>
  </dd>
  <dt>
    <p>TensorMask</p>
  </dt>
  <dd>
    <p>: Mask a tensor image, sets background tensors to zero or to isotropic tensors with specified mean diffusivity</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: TensorMask DTImage.ext mask.ext [ backgroundMD = 0 ]</p>
  </dd>

</dl>

<h3>Label Fusion:</h3>
<ul>
<li><p>MajorityVoting : Select label with most votes from candidates</p></li><li><p>Usage: MajorityVoting LabelImage1.nii.gz .. LabelImageN.nii.gz</p></li><li><p>CorrelationVoting : Select label with local correlation weights</p></li><li><p>Usage: CorrelationVoting Template.ext IntenistyImages* LabelImages* {Optional-Radius=5}</p></li><li><p>STAPLE : Select label using STAPLE method</p></li><li><p>Usage: STAPLE confidence-weighting LabelImages* Note:  Gives probabilistic output (float)</p></li><li><p>MostLikely : Select label from from maximum probabilistic segmentations</p></li><li><p>Usage: MostLikely probabilityThreshold ProbabilityImages*</p></li><li><p>AverageLabels : Select label using STAPLE method</p></li><li><p>Usage: STAPLE LabelImages* Note:  Gives probabilistic output (float)</p></li>
</ul>
<h3>Image Metrics & Info:</h3>
<ul>
<li><p>PearsonCorrelation: r-value from intesities of two images</p></li><li><p>Usage: PearsonCorrelation image1.ext image2.ext {Optional-mask.ext}</p></li><li><p>NeighborhoodCorrelation: local correlations</p></li><li><p>Usage: NeighborhoodCorrelation image1.ext image2.ext {Optional-radius=5} {Optional-image-mask}</p></li><li><p>NormalizedCorrelation: r-value from intesities of two images</p></li><li><p>Usage: NormalizedCorrelation image1.ext image2.ext {Optional-image-mask}</p></li><li><p>Demons:</p></li><li><p>Usage: Demons image1.ext image2.ext</p></li><li><p>Mattes: mutual information</p></li><li><p>Usage: Mattes image1.ext image2.ext {Optional-number-bins=32} {Optional-image-mask}</p></li>
</ul>
<h3>Unclassified Operators:</h3>
<ul>
<li><p>ReflectionMatrix : Create a reflection matrix about an axis</p></li><li><p>out.mat ReflectionMatrix axis</p></li><li><p>ClosestSimplifiedHeaderMatrix : does what it says ... image-in, image-out Byte            : Convert to Byte image in [0,255]</p></li><li><p>CompareHeadersAndImages: Tries to find and fix header errors. Outputs a repaired image with new header.</p></li><li><p>Never use this if you trust your header information.</p></li>
</ul>
<dl class='dl-vertical'>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: CompareHeadersAndImages Image1 Image2</p><ul>
<li><p>ConvertImageSetToMatrix: Each row/column contains image content extracted from mask applied to images in *img.nii</p></li>
</ul>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: ConvertImageSetToMatrix rowcoloption Mask.nii *images.nii</p><ul>
<li><p>ConvertImageSetToMatrix output can be an image type or csv file type.</p></li><li><p>RandomlySampleImageSetToCSV: N random samples are selected from each image in a list</p></li>
</ul>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: RandomlySampleImageSetToCSV N_samples *images.nii</p><ul>
<li><p>RandomlySampleImageSetToCSV outputs a csv file type.</p></li><li><p>FrobeniusNormOfMatrixDifference: take the difference between two itk-transform matrices and then compute the frobenius norm</p></li>
</ul>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: FrobeniusNormOfMatrixDifference mat1 mat2</p><ul>
<li><p>ConvertImageSetToEigenvectors: Each row/column contains image content extracted from mask applied to images in *img.nii</p></li>
</ul>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: ConvertImageSetToEigenvectors N_Evecs Mask.nii *images.nii</p><ul>
<li><p>ConvertImageSetToEigenvectors output will be a csv file for each label value &gt; 0 in the mask.</p></li>
</ul>
  </dd>
  <dt>
    <p>ConvertImageToFile</p>
  </dt>
  <dd>
    <p>: Writes voxel values to a file</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: ConvertImageToFile imagevalues.nii {Optional-ImageMask.nii}</p>
  </dd>
  <dt>
    <p>ConvertLandmarkFile</p>
  </dt>
  <dd>
    <p>: Converts landmark file between formats. See ANTS.pdf for description of formats.</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: ConvertLandmarkFile InFile.txt</p>
  </dd>
  <dt>
    <p>Example 1</p>
  </dt>
  <dd>
    <p>: ImageMath 3  outfile.vtk  ConvertLandmarkFile  infile.txt</p>
  </dd>
  <dt>
    <p>ConvertToGaussian</p>
  </dt>
  <dd>
    <p>:</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: ConvertToGaussian  TValueImage  sigma-float</p>
  </dd>
  <dt>
    <p>ConvertVectorToImage</p>
  </dt>
  <dd>
    <p>: The vector contains image content extracted from a mask. Here the vector is returned to its spatial origins as image content</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: ConvertVectorToImage Mask.nii vector.nii</p>
  </dd>
  <dt>
    <p>CorrelationUpdate</p>
  </dt>
  <dd>
    <p>: In voxels, compute update that makes Image2 more like Image1.</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: CorrelationUpdate Image1.ext Image2.ext RegionRadius</p>
  </dd>
  <dt>
    <p>CountVoxelDifference</p>
  </dt>
  <dd>
    <p>: The where function from IDL</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: CountVoxelDifference Image1 Image2 Mask</p>
  </dd>
  <dt>
    <p>CorruptImage</p>
  </dt>
  <dd>
    <p>:</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: CorruptImage Image NoiseLevel Smoothing</p>
  </dd>
  <dt>
    <p>D</p>
  </dt>
  <dd>
    <p>: Danielson Distance Transform</p><ul>
<li><p>MaurerDistance : Maurer distance transform (much faster than Danielson)</p></li>
</ul>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: MaurerDistance inputImage {foreground=1}</p>
  </dd>
  <dt>
    <p>DiceAndMinDistSum</p>
  </dt>
  <dd>
    <p>: Outputs DiceAndMinDistSum and Dice Overlap to text log file + optional distance image</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: DiceAndMinDistSum LabelImage1.ext LabelImage2.ext OptionalDistImage</p><ul>
<li><p>EnumerateLabelInterfaces:</p></li>
</ul>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: EnumerateLabelInterfaces ImageIn ColoredImageOutname NeighborFractionToIgnore</p>
  </dd>
  <dt>
    <p>ClusterThresholdVariate</p>
  </dt>
  <dd>
    <p>:  for sparse estimation</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: ClusterThresholdVariate image mask  MinClusterSize</p>
  </dd>
  <dt>
    <p>ExtractSlice</p>
  </dt>
  <dd>
    <p>: Extracts slice number from last dimension of volume (2,3,4) dimensions</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: ExtractSlice volume.nii.gz slicetoextract</p><ul>
<li><p>FastMarchingSegmentation: final output is the propagated label image. Optional stopping value: higher values allow more distant propagation</p></li>
</ul>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: FastMarchingSegmentation speed/binaryimagemask.ext initiallabelimage.ext Optional-Stopping-Value</p>
  </dd>
  <dt>
    <p>FillHoles</p>
  </dt>
  <dd>
    <p>: Parameter = ratio of edge at object to edge at background;  <strong>--</strong></p><ul>
<li><p>Parameter = 1 is a definite hole bounded by object only, 0.99 is close Default of parameter &gt; 1 will fill all holes</p></li>
</ul>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: FillHoles Image.ext parameter</p>
  </dd>
  <dt>
    <p>InPaint</p>
  </dt>
  <dd>
    <p>: very simple inpainting <strong>---</strong> assumes zero values should be inpainted</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: InPaint #iterations</p>
  </dd>
  <dt>
    <p>PeronaMalik</p>
  </dt>
  <dd>
    <p>: anisotropic diffusion w/varying conductance param (0.25 in example below)</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: PeronaMalik image #iterations conductance</p>
  </dd>
  <dt>
    <p>Finite</p>
  </dt>
  <dd>
    <p>: replace non-finite values with finite-value (default = 0)</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: Finite Image.exdt {replace-value=0}</p>
  </dd>
  <dt>
    <p>FitSphere</p>
  </dt>
  <dd>
    <p>:</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: FitSphere GM-ImageIn {WM-Image} {MaxRad-Default=5}</p>
  </dd>
  <dt>
    <p>FlattenImage</p>
  </dt>
  <dd>
    <p>: Replaces values greater than %ofMax*Max to the value %ofMax*Max</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: FlattenImage Image %ofMax</p>
  </dd>
  <dt>
    <p>GetLargestComponent</p>
  </dt>
  <dd>
    <p>: Get the largest object in an image</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: GetLargestComponent InputImage {MinObjectSize}</p>
  </dd>
  <dt>
    <p>Grad</p>
  </dt>
  <dd>
    <p>: Gradient magnitude with sigma s (if normalize, then output in range [0, 1])</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: Grad Image.ext s normalize?</p>
  </dd>
  <dt>
    <p>HistogramMatch</p>
  </dt>
  <dd>
    <p>:</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: HistogramMatch SourceImage ReferenceImage {NumberBins-Default=255} {NumberPoints-Default=64}</p>
  </dd>
  <dt>
    <p>RescaleImage</p>
  </dt>
  <dd>
    <p>:</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: RescaleImage InputImage min max</p>
  </dd>
  <dt>
    <p>NeighborhoodStats</p>
  </dt>
  <dd>
    <p>:</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: NeighborhoodStats inputImage whichStat radius             whichStat:  1 = min, 2 = max, 3 = variance, 4 = sigma, 5 = skewness, 6 = kurtosis, 7 = entropy</p>
  </dd>
  <dt>
    <p>InvId</p>
  </dt>
  <dd>
    <p>: computes the inverse-consistency of two deformations and write the inverse consistency error image</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: InvId VectorFieldName VectorFieldName</p>
  </dd>
  <dt>
    <p>LabelStats</p>
  </dt>
  <dd>
    <p>: Compute volumes / masses of objects in a label image. Writes to text file</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: LabelStats labelimage.ext valueimage.nii</p>
  </dd>
  <dt>
    <p>Laplacian</p>
  </dt>
  <dd>
    <p>: Laplacian computed with sigma s (if normalize, then output in range [0, 1])</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: Laplacian Image.ext s normalize?</p>
  </dd>
  <dt>
    <p>Lipschitz</p>
  </dt>
  <dd>
    <p>: Computes the Lipschitz norm of a vector field</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: Lipschitz VectorFieldName</p>
  </dd>
  <dt>
    <p>MakeImage</p>
  </dt>
  <dd>
    <p>:</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: MakeImage SizeX  SizeY {SizeZ};</p>
  </dd>
  <dt>
    <p>MTR</p>
  </dt>
  <dd>
    <p>: Computes the magnetization transfer ratio ( (M0-M1)/M0 ) and truncates values to [0,1]</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: MTR M0Image M1Image [MaskImage];</p>
  </dd>
  <dt>
    <p>Normalize</p>
  </dt>
  <dd>
    <p>: Normalize to [0,1]. Option instead divides by average value</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: Normalize Image.ext opt</p>
  </dd>
  <dt>
    <p>PadImage</p>
  </dt>
  <dd>
    <p>: If Pad-Number is negative, de-Padding occurs</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: PadImage ImageIn Pad-Number</p>
  </dd>
  <dt>
    <p>SigmoidImage</p>
  </dt>
  <dd>
    <p>:</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: SigmoidImage ImageIn [alpha=1.0] [beta=0.0]</p>
  </dd>
  <dt>
    <p>Sharpen</p>
  </dt>
  <dd>
    <p>:</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: Sharpen ImageIn</p>
  </dd>
  <dt>
    <p>CenterImage2inImage1</p>
  </dt>
  <dd>
    <p>:</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: ReferenceImageSpace ImageToCenter</p>
  </dd>
  <dt>
    <p>PH</p>
  </dt>
  <dd>
    <p>: Print Header</p>
  </dd>
  <dt>
    <p>PoissonDiffusion</p>
  </dt>
  <dd>
    <p>: Solves Poisson's equation in a designated region using non-zero sources</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: PoissonDiffusion inputImage labelImage [sigma=1.0] [regionLabel=1] [numberOfIterations=500] [convergenceThreshold=1e-10]</p><ul>
<li><p>PropagateLabelsThroughMask: Final output is the propagated label image. Optional stopping value: higher values allow more distant propagation</p></li>
</ul>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: PropagateLabelsThroughMask speed/binaryimagemask.nii.gz initiallabelimage.nii.gz Optional-Stopping-Value  0/1/2</p>
  </dd>
  <dt>
    <p>0/1/2</p>
  </dt>
  <dd>
    <p>=&gt;  0, no topology constraint, 1 - strict topology constraint, 2 - no handles</p>
  </dd>
  <dt>
    <p>PValueImage</p>
  </dt>
  <dd>
    <p>:</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: PValueImage TValueImage dof</p><ul>
<li><p>RemoveLabelInterfaces:</p></li>
</ul>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: RemoveLabelInterfaces ImageIn</p><ul>
<li><p>ReplaceVoxelValue: replace voxels in the range [a,b] in the input image with c</p></li>
</ul>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: ReplaceVoxelValue inputImage a b c</p>
  </dd>
  <dt>
    <p>ROIStatistics</p>
  </dt>
  <dd>
    <p>: computes anatomical locations, cluster size and mass of a stat image which should be in the same physical space (but not nec same resolution) as the label image.</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: ROIStatistics LabelNames.txt labelimage.ext valueimage.nii</p>
  </dd>
  <dt>
    <p>SetOrGetPixel</p>
  </dt>
  <dd>
    <p>:</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: SetOrGetPixel ImageIn Get/Set-Value IndexX IndexY {IndexZ}</p>
  </dd>
  <dt>
    <p>Example 1</p>
  </dt>
  <dd>
    <p>: ImageMath 2 outimage.nii SetOrGetPixel Image Get 24 34; Gets the value at 24, 34</p>
  </dd>
  <dt>
    <p>Example 2</p>
  </dt>
  <dd>
    <p>: ImageMath 2 outimage.nii SetOrGetPixel Image 1.e9 24 34; This sets 1.e9 as the value at 23 34</p><ul>
<li><p>You can also pass a boolean at the end to force the physical space to be used</p></li>
</ul>
  </dd>
  <dt>
    <p>Segment</p>
  </dt>
  <dd>
    <p>: Segment an Image  with option of Priors, weight 1 =&gt; maximally local/prior-based )</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: Segment Image1.ext N-Classes LocalityVsGlobalityWeight-In-ZeroToOneRange OptionalPriorImages</p>
  </dd>
  <dt>
    <p>stack</p>
  </dt>
  <dd>
    <p>: Will put 2 images in the same volume</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: Stack Image1.ext Image2.ext</p>
  </dd>
  <dt>
    <p>ThresholdAtMean</p>
  </dt>
  <dd>
    <p>: See the code</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: ThresholdAtMean Image %ofMean</p>
  </dd>
  <dt>
    <p>TileImages</p>
  </dt>
  <dd>
    <p>:</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: TileImages NumColumns ImageList*</p>
  </dd>
  <dt>
    <p>TriPlanarView</p>
  </dt>
  <dd>
    <p>:</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: TriPlanarView  ImageIn.nii.gz PercentageToClampLowIntensity PercentageToClampHiIntensity x-slice y-slice z-slice</p><ul>
<li><p>TruncateImageIntensity:</p></li>
</ul>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: TruncateImageIntensity InputImage.ext {lowerQuantile=0.05} {upperQuantile=0.95} {numberOfBins=65} {binary-maskImage}</p>
  </dd>
  <dt>
    <p>Where</p>
  </dt>
  <dd>
    <p>: The where function from IDL</p>
  </dd>
  <dt>
    <p>Usage</p>
  </dt>
  <dd>
    <p>: Where Image ValueToLookFor maskImage-option tolerance</p>
  </dd>

</dl>


        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="ImageCreator.1.html"><span aria-hidden="true">&larr;</span> ImageCreator.1: Library for lc/ms data management and analysis - tools</a></li>
   <li class="next"><a href="ImageSetStatistics.1.html">ImageSetStatistics.1: Part of ants registration suite <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>tagcoll: Perform various operations on a tagged collection</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Perform various operations on a tagged collection">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="tagcoll (1) manual">
  <meta name="twitter:description" content="Perform various operations on a tagged collection">
  <meta name="twitter:image" content="https://www.carta.tech/images/tagcoll-tagcoll-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/tagcoll.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="tagcoll (1) manual" />
  <meta property="og:description" content="Perform various operations on a tagged collection" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/tagcoll-tagcoll-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">tagcoll<small> (1)</small></h1>
        <p class="lead">Perform various operations on a tagged collection</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/tagcoll.1.html">
      <span itemprop="name">tagcoll: Perform various operations on a tagged collection</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/tagcoll/">
      <span itemprop="name">tagcoll</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/tagcoll.1.html">
      <span itemprop="name">tagcoll: Perform various operations on a tagged collection</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>tagcoll</strong> [options] &lt;command&gt; [options and arguments]</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><strong>tagcoll</strong> is a commandline utility to manage tagged collections.</p><p>A tagged collection is a set of items in which each item is associated with a set of zero or more tags, in no particular order.</p><p><strong>tagcoll</strong> can take a tagged collection and perform various complex operations on it, like applying transformations, finding implicit implications between tags and building a smart intuitive hierarchy to navigate the items.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COMMANDS</h2>
        <div class="sectioncontent">
<p><strong>tagcoll</strong> accepts a non-switch argument, that indicates what is the operation that should be performed:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>help</strong> [command]</p>
  </dt>
  <dd>
    <p>With no arguments, print a summary of available commands.  If given a command name as argument, print detailed informations about that command.</p>
  </dd>
  <dt>
    <p><strong>copy</strong> or <strong>cat</strong> [files...]</p>
  </dt>
  <dd>
    <p>Output the normalized collection on standard output, applying transformations if requested.  This is the default action if no other switches are provided.  A normalized collection is a collection in which an item appears in just one line.</p>
  </dd>
  <dt>
    <p><strong>reverse</strong> [files...]</p>
  </dt>
  <dd>
    <p>Output the inbound collection "reversed" from the tags point of view, that is, associating to each tag the list of items associated to it in the input.</p><p>The --untagged-tag switch can be used to provide a name to which untagged items will be associated in the output.</p>
  </dd>
  <dt>
    <p><strong>diff</strong> &lt;file1&gt; &lt;file2&gt;</p>
  </dt>
  <dd>
    <p>Output a tag patch file with the differences between two files (requires two file arguments).</p><p>The output tag patch file can then be applied when reading a collection with the --patch-with option.</p>
  </dd>
  <dt>
    <p><strong>related</strong> &lt;item&gt; [files...]</p>
  </dt>
  <dd>
    <p>Output a list of the items that are related to the given item or list of items.  If more than one items are to be specified, separate them with commas.</p><p>The --distance option can be used to control how closely related the output items shold be from the item(s) specified.</p>
  </dd>
  <dt>
    <p><strong>implications</strong> [files...]</p>
  </dt>
  <dd>
    <p>Output a list of all implicit implications between tags contained in the hierarchy.  Implication is defined such that tag A implies tag B if every item tagged with A is also tagged with B.</p><p>Implications can be used to discover implicit hierarchical relationships between tags.</p><p>The output is one line per tag, with just tags that have implications, with the name of the package, a colon and a comma-separated list of all implied tags.</p>
  </dd>
  <dt>
    <p><strong>hierarchy</strong> [files...]</p>
  </dt>
  <dd>
    <p>Organize the collection in an intuitively navigable hierarchy.  The output is one line per package, with the package name prepended by the path to the item in the hierarchy.</p><p>A detailed description of the hierarchy generation algorithm is found in the tagbk-draft.pdf draft paper available in this package; if you want to understand what are the goals of the algorithm and how it works, please give it a read.</p>
  </dd>
  <dt>
    <p><strong>cleanhierarchy</strong> [files...]</p>
  </dt>
  <dd>
    <p>Like hiearchy, but in every node it merges tags which are attached to the same set of items.</p>
  </dd>
  <dt>
    <p><strong>dischierarchy</strong> [files...]</p>
  </dt>
  <dd>
    <p>The tree starts with an empty tag set, and branches with the most discriminant tags.</p>
  </dd>
  <dt>
    <p><strong>findspecials</strong> [files...]</p>
  </dt>
  <dd>
    <p>generate a smart hierarchy and print, for each toplevel tag, what are the items that make it toplevel instead of going below another tag</p>
  </dd>
  <dt>
    <p><strong>grep</strong> &lt;expression&gt; [files...]</p>
  </dt>
  <dd>
    <p>output the collection of tags that match the given tag expression</p>
  </dd>
  <dt>
    <p><strong>test</strong> [files...]</p>
  </dt>
  <dd>
    <p>perform internal tests and timings</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONS</h2>
        <div class="sectioncontent">
<p>This program follows the usual GNU command line syntax, with long options starting with two dashes (`-').</p><p>Every one of the commands listed above has its own set of options.  To keep this manpage readable, all the options are presented together.  Please refer to "<strong>tagcoll</strong> help <em>command</em>" to see which options are accepted by a given command.</p><p>Help options:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>-h, -?, --help</strong></p>
  </dt>
  <dd>
    <p>print commandline help and exit.</p>
  </dd>
  <dt>
    <p><strong>--version</strong></p>
  </dt>
  <dd>
    <p>print the program version and exit.</p>
  </dd>
  <dt>
    <p><strong>--manpage=</strong><em>[hooks]</em><strong></strong></p>
  </dt>
  <dd>
    <p>output the tagcoll manpage and exit.</p>
  </dd>

</dl>
<p><strong>Options for command help</strong></p><p><strong>Options for command copy</strong></p><p>Options controlling transformations of input data:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--derived=</strong><em>expand derived tags using the given list</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--implications-from=</strong><em>use an external list of implications</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--rename-from=</strong><em>rename tags using the given mapping list</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>-p </strong><em>apply patches from the given tag patch file</em><strong>, --patch-with=</strong><em>apply patches from the given tag patch file</em><strong>, --patch=</strong><em>apply patches from the given tag patch file</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--remove-unfaceted=</strong><em>while parsing, remove all tags with no facet part</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--remove-tags=</strong><em>&lt;expression&gt;</em><strong></strong></p>
  </dt>
  <dd>
    <p>while parsing, remove all tags matching the given tag expression.</p>
  </dd>

</dl>
<p>Options controlling transformations of output data:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>-g, --group, --group-items</strong></p>
  </dt>
  <dd>
    <p>group items with the same tagset in the output collection.</p>
  </dd>
  <dt>
    <p><strong>--redundant</strong></p>
  </dt>
  <dd>
    <p>when implications are provided, expand them explicitly in the output.</p>
  </dd>
  <dt>
    <p><strong>-i, --items</strong></p>
  </dt>
  <dd>
    <p>output only the names of the items, without the tags.</p>
  </dd>
  <dt>
    <p><strong>-c, --count</strong></p>
  </dt>
  <dd>
    <p>output the count of tags instead of the tags.</p>
  </dd>

</dl>
<p><strong>Options for command reverse</strong></p><p>Options controlling transformations of input data:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--derived=</strong><em>expand derived tags using the given list</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--implications-from=</strong><em>use an external list of implications</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--rename-from=</strong><em>rename tags using the given mapping list</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>-p </strong><em>apply patches from the given tag patch file</em><strong>, --patch-with=</strong><em>apply patches from the given tag patch file</em><strong>, --patch=</strong><em>apply patches from the given tag patch file</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--remove-unfaceted=</strong><em>while parsing, remove all tags with no facet part</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--remove-tags=</strong><em>&lt;expression&gt;</em><strong></strong></p>
  </dt>
  <dd>
    <p>while parsing, remove all tags matching the given tag expression.</p>
  </dd>

</dl>
<p>Options controlling transformations of output data:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>-g, --group, --group-items</strong></p>
  </dt>
  <dd>
    <p>group items with the same tagset in the output collection.</p>
  </dd>
  <dt>
    <p><strong>--redundant</strong></p>
  </dt>
  <dd>
    <p>when implications are provided, expand them explicitly in the output.</p>
  </dd>
  <dt>
    <p><strong>-i, --items</strong></p>
  </dt>
  <dd>
    <p>output only the names of the items, without the tags.</p>
  </dd>
  <dt>
    <p><strong>-c, --count</strong></p>
  </dt>
  <dd>
    <p>output the count of tags instead of the tags.</p>
  </dd>

</dl>
<p>Other options:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--untagged-tag=</strong><em>&lt;tag&gt;</em><strong></strong></p>
  </dt>
  <dd>
    <p>set item name to use for associating untagged items when using the "reverse" command.  If not specified, untagged items are not included in the output. <strong>Options for command diff</strong></p><p><strong>Options for command related</strong></p><p>Options controlling transformations of input data:</p>
  </dd>
  <dt>
    <p><strong>--derived=</strong><em>expand derived tags using the given list</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--implications-from=</strong><em>use an external list of implications</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--rename-from=</strong><em>rename tags using the given mapping list</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>-p </strong><em>apply patches from the given tag patch file</em><strong>, --patch-with=</strong><em>apply patches from the given tag patch file</em><strong>, --patch=</strong><em>apply patches from the given tag patch file</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--remove-unfaceted=</strong><em>while parsing, remove all tags with no facet part</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--remove-tags=</strong><em>&lt;expression&gt;</em><strong></strong></p>
  </dt>
  <dd>
    <p>while parsing, remove all tags matching the given tag expression.</p>
  </dd>

</dl>
<p>Other options:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>-d </strong><em>&lt;val&gt;</em><strong>, --distance=</strong><em>&lt;val&gt;</em><strong></strong></p>
  </dt>
  <dd>
    <p>set the maximum distance to use for the "related" command (defaults to 0). <strong>Options for command implications</strong></p><p>Options controlling transformations of input data:</p>
  </dd>
  <dt>
    <p><strong>--derived=</strong><em>expand derived tags using the given list</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--implications-from=</strong><em>use an external list of implications</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--rename-from=</strong><em>rename tags using the given mapping list</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>-p </strong><em>apply patches from the given tag patch file</em><strong>, --patch-with=</strong><em>apply patches from the given tag patch file</em><strong>, --patch=</strong><em>apply patches from the given tag patch file</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--remove-unfaceted=</strong><em>while parsing, remove all tags with no facet part</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--remove-tags=</strong><em>&lt;expression&gt;</em><strong></strong></p>
  </dt>
  <dd>
    <p>while parsing, remove all tags matching the given tag expression.</p>
  </dd>

</dl>
<p><strong>Options for command hierarchy</strong></p><p>Options controlling transformations of input data:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--derived=</strong><em>expand derived tags using the given list</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--implications-from=</strong><em>use an external list of implications</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--rename-from=</strong><em>rename tags using the given mapping list</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>-p </strong><em>apply patches from the given tag patch file</em><strong>, --patch-with=</strong><em>apply patches from the given tag patch file</em><strong>, --patch=</strong><em>apply patches from the given tag patch file</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--remove-unfaceted=</strong><em>while parsing, remove all tags with no facet part</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--remove-tags=</strong><em>&lt;expression&gt;</em><strong></strong></p>
  </dt>
  <dd>
    <p>while parsing, remove all tags matching the given tag expression.</p>
  </dd>

</dl>
<p>Options controlling generation of tag hierarchies:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--flatten-threshold=</strong><em>&lt;val&gt;</em><strong></strong></p>
  </dt>
  <dd>
    <p>set the number of total items below which a branch is flattened when using the "hierarchy" command (defaults to 0, meaning "don't flatten").</p>
  </dd>
  <dt>
    <p><strong>-f </strong><em>&lt;val&gt;</em><strong>, --filter=</strong><em>&lt;val&gt;</em><strong></strong></p>
  </dt>
  <dd>
    <p>filter out the tags with cardinality less than the given value (defaults to not filter; currently only works when building hierarchies).</p>
  </dd>

</dl>
<p><strong>Options for command cleanhierarchy</strong></p><p>Options controlling transformations of input data:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--derived=</strong><em>expand derived tags using the given list</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--implications-from=</strong><em>use an external list of implications</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--rename-from=</strong><em>rename tags using the given mapping list</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>-p </strong><em>apply patches from the given tag patch file</em><strong>, --patch-with=</strong><em>apply patches from the given tag patch file</em><strong>, --patch=</strong><em>apply patches from the given tag patch file</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--remove-unfaceted=</strong><em>while parsing, remove all tags with no facet part</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--remove-tags=</strong><em>&lt;expression&gt;</em><strong></strong></p>
  </dt>
  <dd>
    <p>while parsing, remove all tags matching the given tag expression.</p>
  </dd>

</dl>
<p>Options controlling generation of tag hierarchies:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--flatten-threshold=</strong><em>&lt;val&gt;</em><strong></strong></p>
  </dt>
  <dd>
    <p>set the number of total items below which a branch is flattened when using the "hierarchy" command (defaults to 0, meaning "don't flatten").</p>
  </dd>
  <dt>
    <p><strong>-f </strong><em>&lt;val&gt;</em><strong>, --filter=</strong><em>&lt;val&gt;</em><strong></strong></p>
  </dt>
  <dd>
    <p>filter out the tags with cardinality less than the given value (defaults to not filter; currently only works when building hierarchies).</p>
  </dd>

</dl>
<p><strong>Options for command dischierarchy</strong></p><p>Options controlling transformations of input data:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--derived=</strong><em>expand derived tags using the given list</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--implications-from=</strong><em>use an external list of implications</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--rename-from=</strong><em>rename tags using the given mapping list</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>-p </strong><em>apply patches from the given tag patch file</em><strong>, --patch-with=</strong><em>apply patches from the given tag patch file</em><strong>, --patch=</strong><em>apply patches from the given tag patch file</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--remove-unfaceted=</strong><em>while parsing, remove all tags with no facet part</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--remove-tags=</strong><em>&lt;expression&gt;</em><strong></strong></p>
  </dt>
  <dd>
    <p>while parsing, remove all tags matching the given tag expression.</p>
  </dd>

</dl>
<p>Options controlling generation of tag hierarchies:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--flatten-threshold=</strong><em>&lt;val&gt;</em><strong></strong></p>
  </dt>
  <dd>
    <p>set the number of total items below which a branch is flattened when using the "hierarchy" command (defaults to 0, meaning "don't flatten").</p>
  </dd>
  <dt>
    <p><strong>-f </strong><em>&lt;val&gt;</em><strong>, --filter=</strong><em>&lt;val&gt;</em><strong></strong></p>
  </dt>
  <dd>
    <p>filter out the tags with cardinality less than the given value (defaults to not filter; currently only works when building hierarchies).</p>
  </dd>

</dl>
<p><strong>Options for command findspecials</strong></p><p>Options controlling transformations of input data:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--derived=</strong><em>expand derived tags using the given list</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--implications-from=</strong><em>use an external list of implications</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--rename-from=</strong><em>rename tags using the given mapping list</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>-p </strong><em>apply patches from the given tag patch file</em><strong>, --patch-with=</strong><em>apply patches from the given tag patch file</em><strong>, --patch=</strong><em>apply patches from the given tag patch file</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--remove-unfaceted=</strong><em>while parsing, remove all tags with no facet part</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--remove-tags=</strong><em>&lt;expression&gt;</em><strong></strong></p>
  </dt>
  <dd>
    <p>while parsing, remove all tags matching the given tag expression.</p>
  </dd>

</dl>
<p>Options controlling generation of tag hierarchies:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--flatten-threshold=</strong><em>&lt;val&gt;</em><strong></strong></p>
  </dt>
  <dd>
    <p>set the number of total items below which a branch is flattened when using the "hierarchy" command (defaults to 0, meaning "don't flatten").</p>
  </dd>
  <dt>
    <p><strong>-f </strong><em>&lt;val&gt;</em><strong>, --filter=</strong><em>&lt;val&gt;</em><strong></strong></p>
  </dt>
  <dd>
    <p>filter out the tags with cardinality less than the given value (defaults to not filter; currently only works when building hierarchies).</p>
  </dd>

</dl>
<p><strong>Options for command grep</strong></p><p>Options controlling transformations of input data:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--derived=</strong><em>expand derived tags using the given list</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--implications-from=</strong><em>use an external list of implications</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--rename-from=</strong><em>rename tags using the given mapping list</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>-p </strong><em>apply patches from the given tag patch file</em><strong>, --patch-with=</strong><em>apply patches from the given tag patch file</em><strong>, --patch=</strong><em>apply patches from the given tag patch file</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--remove-unfaceted=</strong><em>while parsing, remove all tags with no facet part</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--remove-tags=</strong><em>&lt;expression&gt;</em><strong></strong></p>
  </dt>
  <dd>
    <p>while parsing, remove all tags matching the given tag expression.</p>
  </dd>

</dl>
<p>Options controlling transformations of output data:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>-g, --group, --group-items</strong></p>
  </dt>
  <dd>
    <p>group items with the same tagset in the output collection.</p>
  </dd>
  <dt>
    <p><strong>--redundant</strong></p>
  </dt>
  <dd>
    <p>when implications are provided, expand them explicitly in the output.</p>
  </dd>
  <dt>
    <p><strong>-i, --items</strong></p>
  </dt>
  <dd>
    <p>output only the names of the items, without the tags.</p>
  </dd>
  <dt>
    <p><strong>-c, --count</strong></p>
  </dt>
  <dd>
    <p>output the count of tags instead of the tags.</p>
  </dd>

</dl>
<p>Other options:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>-v, --invert-match</strong></p>
  </dt>
  <dd>
    <p>invert the sense of matching, to select non-matching lines.</p>
  </dd>
  <dt>
    <p><strong>-q, --quiet</strong></p>
  </dt>
  <dd>
    <p>do not write anything to standard output, but exit with 0 if any match is found. <strong>Options for command test</strong></p><p>Options controlling transformations of input data:</p>
  </dd>
  <dt>
    <p><strong>--derived=</strong><em>expand derived tags using the given list</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--implications-from=</strong><em>use an external list of implications</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--rename-from=</strong><em>rename tags using the given mapping list</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>-p </strong><em>apply patches from the given tag patch file</em><strong>, --patch-with=</strong><em>apply patches from the given tag patch file</em><strong>, --patch=</strong><em>apply patches from the given tag patch file</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--remove-unfaceted=</strong><em>while parsing, remove all tags with no facet part</em><strong></strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--remove-tags=</strong><em>&lt;expression&gt;</em><strong></strong></p>
  </dt>
  <dd>
    <p>while parsing, remove all tags matching the given tag expression.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Format of the tagged collection input</h2>
        <div class="sectioncontent">
<p>A sequence of lines describing the tagged items.  Order of tags does not matter.  Each line starts with the item name, optionally followed by tag names.</p><p>Tag names are separated by the item name by a colon and one or more spaces or tabs.</p><p>Tag names are separated by each others using a comma followed by one or more spaces.</p><p>Item names can contain colons, but not followed by a space or tab, and cannot end in a colon.  "ui:gnome" is ok, "ui:" is not.</p><p>Tag names can contain commas, but not followed by a space, and cannot end in a comma.  "cult,religion" is ok, "cult," is not.</p><p>An item with tags tag1, tag2, ..., tagN is represented as:</p>
<pre>
	item: tag1, tag2, ..., tagN
</pre>
<p>An item with just tag1 is represented as:</p>
<pre>
	item: tag1
</pre>
<p>An item without tags is represented as:</p>
<pre>
	item:
</pre>
<p>or just as:</p>
<pre>
	item
</pre>
<p>An example input:</p>
<pre>
	mutt: clients/mail/net
	sylpheed: clients/mail/net
	procmail: filters/mail/net
	spamassassin: filters/mail/net
	spamfilter: filters/mail/net
	bulkmail: lists/mail/net
	mailman: lists/mail/net
	smartlist: lists/mail/net
	xeukleides: educational
	new-package-not-yet-categorized:
	another-uncategorized
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Format for the explicit implications input</h2>
        <div class="sectioncontent">
<p>The format for the explicit implications is the same as the one for the tagged collection: put the name of a tag at the left of the colon and the names of the tags it implies to the right.</p><p>Example:</p>
<pre>
	C: language, devel
	gnome: gui, ui, x11
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Format for the rename mapping input</h2>
        <div class="sectioncontent">
<p>The format for the rename mappings is the same as the one for the tagged collection: put the new name of the tags at the left of the colon and the names of the old tags to be renamed on the right.</p><p>Example:</p>
<pre>
	mp3: MP3
	language: languages, devel::language, devel::languages
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Format for the tag patch file</h2>
        <div class="sectioncontent">
<p>The format for the rename mappings is the same as the one for the tagged collection, but the tags are listed prepended with a `<strong>+</strong>' or `<strong>-</strong>' sign.  A tag prepended with a `<strong>+</strong>' sign is added to the item, while a tag with a `<strong>-</strong>' sign is removed from it.</p><p>Example:</p>
<pre>
	cappuccino: +essential
	emacs: +otheros, -editor
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Format for the derived tag list</h2>
        <div class="sectioncontent">
<p>The format for the derived tag list is a line-oriented format with a derived tag per line.  The derived tag name starts as the begining of the line and is separated by his tag expression by colon and space, just like the tagged collection items.</p><p>The tag expression is an expression composed of tags and the operators `&&' (and), `||' (or), '!' (not) and the parenthesis '(' and ')'.</p><p>Example:</p>
<pre>
	userlevel::novice: !specialized && (interface::gui || interface::curses)
</pre>
<p>The tag at the left of the colon is added when the set of tags of an item matches the expression at the right of the colon.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">

<pre>
# Output the collection in normal form
tagcoll copy collection-file

# Output the items associated to a given tag
tagcoll reverse collection-file | grep ^tag:

# Produce tag patch data describing the tag difference between two collections
tagcoll diff coll1 coll2

# Apply a tag patch file to coll1
tagcoll --patch-with=tagpatch copy coll1 &gt; collection-file

# Show the minimal set of implicit implications contained in the collection
tagcoll implications collection-file

# Show the implicit implications contained in the collection, fully expanded
tagcoll --expanded-output implications collection-file

# Build a smart hierarchy with the collection
tagcoll hierarchy collection-file

# Build a cleaner smart hierarchy with the collection (yoy might like to tweak
# the parameters)
tagcoll -f 5 --flatten-threshold=5 cleanhierarchy collection-file

# Apply some transformations to the collection and build a smart hierarchy with
# them
tagcoll --implications-from=explicit-implications-file &#92;
	--rename-from=rename-map &#92;
	--patch-with=patch-file &#92;
	hierarchy collection-file

# Merge the contents two collections
cat coll1 coll2 | tagcoll copy &gt; merged

# Merge the contents two collections and apply an external patch
cat coll1 coll2 | tagcoll --patch-with=patch-file copy &gt; merged

# Build a smart hierarchy out of the implicit implications contained in the
# collection
tagcoll implications collection-file | tagcoll hierarchy

# Build a smart hierarchy out of the combination of explicit implications and
# the implicit implications contained in the collection
tagcoll --implications-from=explicit-implications-file &#92;
	implications collection-file | tagcoll hierarchy

# Show all the items similar to "mutt"
tagcoll related mutt collection-file

# Show all the items similar to "mutt" and "mozilla-browser"
tagcoll related mutt,mozilla-browser collection-file

# Show all the items similar to "mutt", with at most two differences
# in the tag set
tagcoll --distance=2 related mutt collection-file

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO tagcoll&hellip;</h2>
        <div class="sectioncontent">
<p>The <strong>tagbk</strong> draft paper in /usr/share/doc/tagcoll.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p><strong>tagcoll</strong> is maintained by enrico@enricozini.org.</p><p>This manpage has been automatically generated by the tagcoll program.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="tagcloud.1.html"><span aria-hidden="true">&larr;</span> tagcloud.1: Visualize notes as a tagcloud</a></li>
   <li class="next"><a href="taggrepper.1.html">taggrepper.1: Search and match tags of media file for regular expressions <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

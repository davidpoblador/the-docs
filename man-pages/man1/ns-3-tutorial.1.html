<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ns-3-tutorial: Ns-3 tutorial  this is the ns-3 tutorial. primary documentation for the ns-3 project is available in five forms: ns-3 doxygen: documentation of the public apis of the simulator tutorial (this document), manual, and model library for the latest release and development tree ns-3 wiki  this document is written in restructuredtext for sphinx and is maintained in the doc/tutorial directory of ns-3s source code.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Ns-3 tutorial  this is the ns-3 tutorial. primary documentation for the ns-3 project is available in five forms: ns-3 doxygen: documentation of the public apis of the simulator tutorial (this document), manual, and model library for the latest release and development tree ns-3 wiki  this document is written in restructuredtext for sphinx and is maintained in the doc/tutorial directory of ns-3s source code.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="ns-3-tutorial (1) manual">
  <meta name="twitter:description" content="Ns-3 tutorial  this is the ns-3 tutorial. primary documentation for the ns-3 project is available in five forms: ns-3 doxygen: documentation of the public apis of the simulator tutorial (this document), manual, and model library for the latest release and development tree ns-3 wiki  this document is written in restructuredtext for sphinx and is maintained in the doc/tutorial directory of ns-3s source code.">
  <meta name="twitter:image" content="https://www.carta.tech/images/ns3-doc-ns-3-tutorial-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/ns-3-tutorial.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="ns-3-tutorial (1) manual" />
  <meta property="og:description" content="Ns-3 tutorial  this is the ns-3 tutorial. primary documentation for the ns-3 project is available in five forms: ns-3 doxygen: documentation of the public apis of the simulator tutorial (this document), manual, and model library for the latest release and development tree ns-3 wiki  this document is written in restructuredtext for sphinx and is maintained in the doc/tutorial directory of ns-3s source code." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/ns3-doc-ns-3-tutorial-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">ns-3-tutorial<small> (1)</small></h1>
        <p class="lead">Ns-3 tutorial  this is the ns-3 tutorial. primary documentation for the ns-3 project is available in five forms: ns-3 doxygen: documentation of the public apis of the simulator tutorial (this document), manual, and model library for the latest release and development tree ns-3 wiki  this document is written in restructuredtext for sphinx and is maintained in the doc/tutorial directory of ns-3s source code.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/ns-3-tutorial.1.html">
      <span itemprop="name">ns-3-tutorial: Ns-3 tutorial  this is the ns-3 tutorial. primary documentation for the ns-3 project is available in five forms: ns-3 doxygen: documentation of the public apis of the simulator tutorial (this document), manual, and model library for the latest release and development tree ns-3 wiki  this document is written in restructuredtext for sphinx and is maintained in the doc/tutorial directory of ns-3s source code.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/ns3-doc/">
      <span itemprop="name">ns3-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/ns-3-tutorial.1.html">
      <span itemprop="name">ns-3-tutorial: Ns-3 tutorial  this is the ns-3 tutorial. primary documentation for the ns-3 project is available in five forms: ns-3 doxygen: documentation of the public apis of the simulator tutorial (this document), manual, and model library for the latest release and development tree ns-3 wiki  this document is written in restructuredtext for sphinx and is maintained in the doc/tutorial directory of ns-3s source code.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">INTRODUCTION</h2>
        <div class="sectioncontent">
<p>The <em>ns-3</em> simulator is a discrete-event network simulator targeted primarily for research and educational use.  The <em>ns-3 project</em>, started in 2006, is an open-source project developing <em>ns-3</em>.</p><p>The purpose of this tutorial is to introduce new <em>ns-3</em> users to the system in a structured way.  It is sometimes difficult for new users to glean essential information from detailed manuals and to convert this information into working simulations.  In this tutorial, we will build several example simulations, introducing and explaining key concepts and features as we go.</p><p>As the tutorial unfolds, we will introduce the full <em>ns-3</em> documentation and provide pointers to source code for those interested in delving deeper into the workings of the system.</p><p>A few key points are worth noting at the onset:</p><ul>
<li><p>Ns-3 is not an extension of <em>ns-2</em>; it is a new simulator.  The two simulators are both written in C++ but <em>ns-3</em> is a new simulator that does not support the <em>ns-2</em> APIs.  Some models from <em>ns-2</em> have already been ported from <em>ns-2</em> to <em>ns-3</em>. The project will continue to maintain <em>ns-2</em> while <em>ns-3</em> is being built, and will study transition and integration mechanisms.</p></li><li><p><em>ns-3</em> is open-source, and the project strives to maintain an open environment for researchers to contribute and share their software.</p></li>
</ul><h3>For \fIns-2\fP Users</h3>
<p>For those familiar with <em>ns-2</em>, the most visible outward change when moving to <em>ns-3</em> is the choice of scripting language.  Programs in <em>ns-2</em> are scripted in OTcl and results of simulations can be visualized using the Network Animator nam.  It is not possible to run a simulation in <em>ns-2</em> purely from C++ (i.e., as a main() program without any OTcl). Moreover, some components of <em>ns-2</em> are written in C++ and others in OTcl. In <em>ns-3</em>, the simulator is written entirely in C++, with optional Python bindings.  Simulation scripts can therefore be written in C++ or in Python.  New animators and visualizers are available and under current development.  Since <em>ns-3</em> generates pcap packet trace files, other utilities can be used to analyze traces as well. In this tutorial, we will first concentrate on scripting directly in C++ and interpreting results via trace files.</p><p>But there are similarities as well (both, for example, are based on C++ objects, and some code from <em>ns-2</em> has already been ported to <em>ns-3</em>). We will try to highlight differences between <em>ns-2</em> and <em>ns-3</em> as we proceed in this tutorial.</p><p>A question that we often hear is "Should I still use <em>ns-2</em> or move to <em>ns-3</em>?"  The answer is that it depends.  <em>ns-3</em> does not have all of the models that <em>ns-2</em> currently has, but on the other hand, <em>ns-3</em> does have new capabilities (such as handling multiple interfaces on nodes correctly, use of IP addressing and more alignment with Internet protocols and designs, more detailed 802.11 models, etc.).  <em>ns-2</em> models can sometimes be ported to <em>ns-3</em> (a porting guide is under development).  The support available on the user mailing list, and the developer and maintainer activity, is higher for <em>ns-3</em>.  A good guideline would be to look at both simulators, and in particular the models available for your research, but when in doubt or when starting new simulation projects, choose the tool that is under more active development (<em>ns-3</em>).</p>
<h3>Contributing</h3>
<p><em>ns-3</em> is a research and educational simulator, by and for the research community.  It will rely on the ongoing contributions of the community to develop new models, debug or maintain existing ones, and share results.  There are a few policies that we hope will encourage people to contribute to <em>ns-3</em> like they have for <em>ns-2</em>:</p><ul>
<li><p>Open source licensing based on GNU GPLv2 compatibility</p></li><li><p><em>wiki</em></p></li><li><p><em>Contributed Code</em> page, similar to <em>ns-2</em>&apos;s popular Contributed Code <em>page</em></p></li><li><p>Open <em>bug tracker</em></p><p>We realize that if you are reading this document, contributing back to the project is probably not your foremost concern at this point, but we want you to be aware that contributing is in the spirit of the project and that even the act of dropping us a note about your early experience with <em>ns-3</em> (e.g. "this tutorial section was not clear..."), reports of stale documentation, etc. are much appreciated.</p></li>
</ul>
<h3>Tutorial Organization</h3>
<p>The tutorial assumes that new users might initially follow a path such as the following:</p><ul>
<li><p>Try to download and build a copy;</p></li><li><p>Try to run a few sample programs;</p></li><li><p>Look at simulation output, and try to adjust it.</p><p>As a result, we have tried to organize the tutorial along the above broad sequences of events.</p></li>
</ul>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RESOURCES</h2>
        <div class="sectioncontent">
<h3>The Web</h3>
<p>There are several important resources of which any <em>ns-3</em> user must be aware.  The main web site is located at <em>http://www.nsnam.org</em> and provides access to basic information about the <em>ns-3</em> system.  Detailed documentation is available through the main web site at <em>http://www.nsnam.org/documentation/</em>.  You can also find documents relating to the system architecture from this page.</p><p>There is a Wiki that complements the main <em>ns-3</em> web site which you will find at <em>http://www.nsnam.org/wiki/</em>.  You will find user and developer FAQs there, as well as troubleshooting guides, third-party contributed code, papers, etc.</p><p>The source code may be found and browsed at <em>http://code.nsnam.org/</em>. There you will find the current development tree in the repository named <strong>ns-3-dev</strong>. Past releases and experimental repositories of the core developers may also be found there.</p>
<h3>Mercurial</h3>
<p>Complex software systems need some way to manage the organization and changes to the underlying code and documentation.  There are many ways to perform this feat, and you may have heard of some of the systems that are currently used to do this.  The Concurrent Version System (CVS) is probably the most well known.</p><p>The <em>ns-3</em> project uses Mercurial as its source code management system. Although you do not need to know much about Mercurial in order to complete this tutorial, we recommend becoming familiar with Mercurial and using it to access the source code.  Mercurial has a web site at <em>http://www.selenic.com/mercurial/</em>, from which you can get binary or source releases of this Software Configuration Management (SCM) system.  Selenic (the developer of Mercurial) also provides a tutorial at <em>http://www.selenic.com/mercurial/wiki/index.cgi/Tutorial/</em>, and a QuickStart guide at <em>http://www.selenic.com/mercurial/wiki/index.cgi/QuickStart/</em>.</p><p>You can also find vital information about using Mercurial and <em>ns-3</em> on the main <em>ns-3</em> web site.</p>
<h3>Waf</h3>
<p>Once you have source code downloaded to your local system, you will need to compile that source to produce usable programs.  Just as in the case of source code management, there are many tools available to perform this function.  Probably the most well known of these tools is <strong>make</strong>.  Along with being the most well known, <strong>make</strong> is probably the most difficult to use in a very large and highly configurable system.  Because of this, many alternatives have been developed.  Recently these systems have been developed using the Python language.</p><p>The build system Waf is used on the <em>ns-3</em> project.  It is one of the new generation of Python-based build systems.  You will not need to understand any Python to build the existing <em>ns-3</em> system.</p><p>For those interested in the gory details of Waf, the main web site can be found at <em>http://code.google.com/p/waf/</em>.</p>
<h3>Development Environment</h3>
<p>As mentioned above, scripting in <em>ns-3</em> is done in C++ or Python. Most of the <em>ns-3</em> API is available in Python, but the models are written in C++ in either case.  A working knowledge of C++ and object-oriented concepts is assumed in this document. We will take some time to review some of the more advanced concepts or possibly unfamiliar language features, idioms and design patterns as they appear.  We don&apos;t want this tutorial to devolve into a C++ tutorial, though, so we do expect a basic command of the language.  There are an almost unimaginable number of sources of information on C++ available on the web or in print.</p><p>If you are new to C++, you may want to find a tutorial- or cookbook-based book or web site and work through at least the basic features of the language before proceeding.  For instance, <em>this tutorial</em>.</p><p>The <em>ns-3</em> system uses several components of the GNU "toolchain" for development.  A software toolchain is the set of programming tools available in the given environment. For a quick review of what is included in the GNU toolchain see, <em>http://en.wikipedia.org/wiki/GNU_toolchain</em>.  <em>ns-3</em> uses gcc, GNU binutils, and gdb.  However, we do not use the GNU build system tools, neither make nor autotools.  We use Waf for these functions.</p><p>Typically an <em>ns-3</em> author will work in Linux or a Linux-like environment.  For those running under Windows, there do exist environments which simulate the Linux environment to various degrees.  The <em>ns-3</em> project has in the past (but not presently) supported development in the Cygwin environment for these users.  See <em>http://www.cygwin.com/</em> for details on downloading, and visit the <em>ns-3</em> wiki for more information about Cygwin and <em>ns-3</em>.  MinGW is presently not officially supported. Another alternative to Cygwin is to install a virtual machine environment such as VMware server and install a Linux virtual machine.</p>
<h3>Socket Programming</h3>
<p>We will assume a basic facility with the Berkeley Sockets API in the examples used in this tutorial.  If you are new to sockets, we recommend reviewing the API and some common usage cases.  For a good overview of programming TCP/IP sockets we recommend <em>TCP/IP Sockets in C, Donahoo and Calvert</em>.</p><p>There is an associated web site that includes source for the examples in the book, which you can find at: <em>http://cs.baylor.edu/~donahoo/practical/CSockets/</em>.</p><p>If you understand the first four chapters of the book (or for those who do not have access to a copy of the book, the echo clients and servers shown in the website above) you will be in good shape to understand the tutorial. There is a similar book on Multicast Sockets, <em>Multicast Sockets, Makofske and Almeroth</em>. that covers material you may need to understand if you look at the multicast examples in the distribution.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">GETTING STARTED</h2>
        <div class="sectioncontent">
<p>This section is aimed at getting a user to a working state starting with a machine that may never have had <em>ns-3</em> installed.  It covers supported platforms, prerequisites, ways to obtain <em>ns-3</em>, ways to build <em>ns-3</em>, and ways to verify your build and run simple programs.</p><h3>Overview</h3>
<p><em>ns-3</em> is built as a system of software libraries that work together. User programs can be written that links with (or imports from) these libraries.  User programs are written in either the C++ or Python programming languages.</p><p><em>ns-3</em> is distributed as source code, meaning that the target system needs to have a software development environment to build the libraries first, then build the user program.  <em>ns-3</em> could in principle be distributed as pre-built libraries for selected systems, and in the future it may be distributed that way, but at present, many users actually do their work by editing <em>ns-3</em> itself, so having the source code around to rebuild the libraries is useful.  If someone would like to undertake the job of making pre-built libraries and packages for operating systems, please contact the ns-developers mailing list.</p><p>In the following, we&apos;ll look at two ways of downloading and building <em>ns-3</em>.  The first is to download and build an official release from the main web site.  The second is to fetch and build development copies of <em>ns-3</em>.  We&apos;ll walk through both examples since the tools involved are slightly different.</p>
<h3>Downloading ns-3</h3>
<p>The <em>ns-3</em> system as a whole is a fairly complex system and has a number of dependencies on other components.  Along with the systems you will most likely deal with every day (the GNU toolchain, Mercurial, a text editor) you will need to ensure that a number of additional libraries are present on your system before proceeding.  <em>ns-3</em> provides a wiki page that includes pages with many useful hints and tips. One such page is the "Installation" page, <em>http://www.nsnam.org/wiki/index.php/Installation</em>.</p><p>The "Prerequisites" section of this wiki page explains which packages are required to support common <em>ns-3</em> options, and also provides the commands used to install them for common Linux variants.  Cygwin users will have to use the Cygwin installer (if you are a Cygwin user, you used it to install Cygwin).</p><p>You may want to take this opportunity to explore the <em>ns-3</em> wiki a bit since there really is a wealth of information there.</p><p>From this point forward, we are going to assume that the reader is working in Linux or a Linux emulation environment (Linux, Cygwin, etc.) and has the GNU toolchain installed and verified along with the prerequisites mentioned above.  We are also going to assume that you have Mercurial and Waf installed and running on the target system.</p><p>The <em>ns-3</em> code is available in Mercurial repositories on the server <em>http://code.nsnam.org</em>.  You can also download a tarball release at <em>http://www.nsnam.org/releases/</em>, or you can work with repositories using Mercurial.  We recommend using Mercurial unless there&apos;s a good reason not to.  See the end of this section for instructions on how to get a tarball release.</p><p>The simplest way to get started using Mercurial repositories is to use the <strong>ns-3-allinone</strong> environment.  This is a set of scripts that manages the downloading and building of various subsystems of <em>ns-3</em> for you.  We recommend that you begin your <em>ns-3</em> work in this environment.</p>
<h3>Downloading ns-3 Using a Tarball</h3>
<p>A tarball is a particular format of software archive where multiple files are bundled together and the archive possibly compressed. <em>ns-3</em> software releases are provided via a downloadable tarball. The process for downloading <em>ns-3</em> via tarball is simple; you just have to pick a release, download it and decompress it.</p><p>Let&apos;s assume that you, as a user, wish to build <em>ns-3</em> in a local directory called <strong>workspace</strong>. If you adopt the <strong>workspace</strong> directory approach, you can get a copy of a release by typing the following into your Linux shell (substitute the appropriate version numbers, of course):</p>
<pre>
cd
mkdir workspace
cd workspace
wget http://www.nsnam.org/releases/ns-allinone-3.17.tar.bz2
tar xjf ns-allinone-3.17.tar.bz2
</pre>
<p>If you change into the directory <strong>ns-allinone-3.17</strong> you should see a number of files:</p>
<pre>
bake      constants.py   ns-3.17               README
build.py  netanim-3.103  pybindgen-0.16.0.825  util.py
</pre>
<p>You are now ready to build the <em>ns-3</em> distribution.</p>
<h3>Downloading ns-3 Using Bake</h3>
<p>Bake is a tool for distributed integration and building, developed for the <em>ns-3</em> project. &nbsp;First of all, Bake is developed in Python, and should be fetched from the project&apos;s master code repositories using a tool called Mercurial, so to run Bake one must have Python and mercurial on one&apos;s machine.</p><p>One practice is to create a directory called <strong>workspace</strong> in one&apos;s home directory under which one can keep local Mercurial repositories. Any directory name will do, but we&apos;ll assume that <strong>workspace</strong> is used herein (note:  <strong>repos</strong> may also be used in some documentation as an example directory name).  You can get a copy of <strong>bake</strong> by typing the following into your Linux shell (assuming you have installed Mercurial):</p>
<pre>
cd
mkdir workspace
cd workspace
hg clone http://code.nsnam.org/bake
</pre>
<p>As the hg (Mercurial) command executes, you should see something like the following displayed,</p>
<pre>
destination directory: bake
requesting all changes
adding changesets
adding manifests
adding file changes
added 252 changesets with 661 changes to 62 files
updating to branch default
45 files updated, 0 files merged, 0 files removed, 0 files unresolved
</pre>
<p>After the clone command completes, you should have a directory called <strong>bake</strong>, the contents of which should look something like the following:</p>
<pre>
bake                  bakeconf.xml  doc       generate-binary.py  TODO
bake.py               examples      test
</pre>
<p>Notice that you really just downloaded some Python scripts and a Python module called <strong>bake</strong>.  The next step will be to use those scripts to download and build the <em>ns-3</em> distribution of your choice.</p><p>There are a few configuration targets available:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p><strong>ns-3.17</strong>:  the module corresponding to the release; it will download components similar to the release tarball.</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p><strong>ns-3-dev</strong>:  a similar module but using the development code tree</p>
  </dd>
  <dt>
    3.
  </dt>
  <dd>
    <p><strong>ns-allinone-3.17</strong>:  the module that includes other optional features such as click routing, openflow for <em>ns-3</em>, and the Network Simulation Cradle</p>
  </dd>
  <dt>
    4.
  </dt>
  <dd>
    <p><strong>ns-3-allinone</strong>:  similar to the released version of the allinone module, but for development code.</p><p>The current development snapshot (unreleased) of <em>ns-3</em> may be found at <em>http://code.nsnam.org/ns-3-dev/</em>.  The developers attempt to keep these repository in consistent, working states but they are in a development area with unreleased code present, so you may want to consider staying with an official release if you do not need newly- introduced features.</p><p>You can find the latest version  of the code either by inspection of the repository list or by going to the <em>"ns-3 Releases"</em> web page and clicking on the latest release link.  We&apos;ll proceed in this tutorial example with <strong>ns-3.17</strong>.</p><p>We are now going to use the bake tool to pull down the various pieces of <em>ns-3</em> you will be using.  First, we&apos;ll say a word about running bake.</p><p>bake works by downloading source packages into a source directory, and installing libraries into a build directory.  bake can be run by referencing the binary, but if one chooses to run bake from outside of the directory it was downloaded into, it is advisable to put bake into your path, such as follows (Linux bash shell example):</p>
<pre>
export BAKE_HOME=\(gapwd\(ga/bake
export PATH=$PATH:$BAKE_HOME
export PYTHONPATH=$PYTHONPATH:$BAKE_HOME
</pre>
<p>However, setting environment variables is not strictly necessary to complete this tutorial, so we&apos;ll call bake directly by specifying the path to it in our shell commands.</p><p>Step into the workspace directory and type the following into your shell:</p>
<pre>
./bake.py configure -e ns-3-dev
</pre>
<p>Next, we&apos;l ask bake to check whether we have enough tools to download various components.  Type:</p>
<pre>
./bake.py check
</pre>
<p>You should see something like the following,</p>
<pre>
&gt; Python - OK
&gt; GNU C++ compiler - OK
&gt; Mercurial - OK
&gt; CVS - OK
&gt; GIT - OK
&gt; Bazaar - OK
&gt; Tar tool - OK
&gt; Unzip tool - OK
&gt; Unrar tool - is missing
&gt; 7z  data compression utility - OK
&gt; XZ data compression utility - OK
&gt; Make - OK
&gt; cMake - OK
&gt; patch tool - OK
&gt; autoreconf tool - OK

&gt; Path searched for tools: /usr/lib64/qt-3.3/bin /usr/lib64/ccache /usr/local/bin /bin /usr/bin /usr/local/sbin /usr/sbin /sbin /home/tomh/bin bin
</pre>
<p>In particular, download tools such as Mercurial, CVS, GIT, and Bazaar are our principal concerns at this point, since they allow us to fetch the code.  Please install missing tools at this stage if you are able to.</p><p>Next, try to download the software:</p>
<pre>
./bake.py download
</pre>
<p>should yield something like:</p>
<pre>
&gt;&gt; Searching for system dependency pygoocanvas - OK
&gt;&gt; Searching for system dependency python-dev - OK
&gt;&gt; Searching for system dependency pygraphviz - OK
&gt;&gt; Downloading pybindgen-0.16.0.825 - OK
&gt;&gt; Searching for system dependency g++ - OK
&gt;&gt; Searching for system dependency qt4 - OK
&gt;&gt; Downloading netanim-3.103 - OK
&gt;&gt; Downloading ns-3.17 - OK
</pre>
<p>The above suggests that three sources have been downloaded.  Check the <strong>source</strong> directory now and type <strong>ls</strong>; one should see:</p>
<pre>
netanim-3.103  ns-3.17  pybindgen-0.16.0.825
</pre>
<p>You are now ready to build the <em>ns-3</em> distribution.</p>
  </dd>

</dl>

<h3>Building ns-3</h3>

<h3>Building with build.py</h3>
<p>When working from a released tarball, the first time you build the <em>ns-3</em> project you can build using a convenience program found in the <strong>allinone</strong> directory.  This program is called <strong>build.py</strong>.  This program will get the project configured for you in the most commonly useful way.  However, please note that more advanced configuration and work with <em>ns-3</em> will typically involve using the native <em>ns-3</em> build system, Waf, to be introduced later in this tutorial.</p><p>If you downloaded using a tarball you should have a directory called something like <strong>ns-allinone-3.17</strong> under your <strong>~/workspace</strong> directory. Type the following:</p>
<pre>
./build.py --enable-examples --enable-tests
</pre>
<p>Because we are working with examples and tests in this tutorial, and because they are not built by default in <em>ns-3</em>, the arguments for build.py tells it to build them for us.  The program also defaults to building all available modules.  Later, you can build <em>ns-3</em> without examples and tests, or eliminate the modules that are not necessary for your work, if you wish.</p><p>You will see lots of typical compiler output messages displayed as the build script builds the various pieces you downloaded.  Eventually you should see the following magic words:</p>
<pre>
Waf: Leaving directory \(ga/path/to/workspace/ns-allinone-3.17/ns-3.17/build&apos;
&apos;build&apos; finished successfully (6m25.032s)

Modules built:
antenna                   aodv                      applications
bridge                    buildings                 config-store
core                      csma                      csma-layout
dsdv                      dsr                       emu
energy                    fd-net-device             flow-monitor
internet                  lte                       mesh
mobility                  mpi                       netanim (no Python)
network                   nix-vector-routing        olsr
point-to-point            point-to-point-layout     propagation
spectrum                  stats                     tap-bridge
test (no Python)          tools                     topology-read
uan                       virtual-net-device        wifi
wimax

Modules not built (see ns-3 tutorial for explanation):
brite                     click                     openflow
visualizer

Leaving directory \(ga./ns-3.17\(ga
</pre>
<p>Regarding the portion about modules not built:</p>
<pre>
Modules not built (see ns-3 tutorial for explanation):
brite                     click                     openflow
visualizer
</pre>
<p>This just means that some ns-3 modules that have dependencies on outside libraries may not have been built, or that the configuration specifically asked not to build them.  It does not mean that the simulator did not build successfully or that it will provide wrong results for the modules listed as being built.</p>
<h3>Building with bake</h3>
<p>If you used bake above to fetch source code from project repositories, you may continue to use it to build <em>ns-3</em>.  Type</p>
<pre>
./bake.py build
</pre>
<p>and you should see something like:</p>
<pre>
&gt;&gt; Building pybindgen-0.16.0.825 - OK
&gt;&gt; Building netanim-3.103 - OK
&gt;&gt; Building ns-3.17 - OK
</pre>
<p><em>Hint:  you can also perform both steps, download and build by calling &apos;bake.py deploy&apos;.</em></p><p>If there happens to be a failure, please have a look at what the following command tells you; it may give a hint as to a missing dependency:</p>
<pre>
./bake.py show
</pre>
<p>This will list out the various dependencies of the packages you are trying to build.</p>
<h3>Building with Waf</h3>
<p>Up to this point, we have used either the <em>build.py</em> script, or the <em>bake</em> tool, to get started with building <em>ns-3</em>.  These tools are useful for building <em>ns-3</em> and supporting libraries, and they call into the <em>ns-3</em> directory to call the Waf build tool to do the actual building. Most users quickly transition to using Waf directly to configure and build <em>ns-3</em>.  So, to proceed, please change your working directory to the <em>ns-3</em> directory that you have initially built.</p><p>It&apos;s not strictly required at this point, but it will be valuable to take a slight detour and look at how to make changes to the configuration of the project. Probably the most useful configuration change you can make will be to build the optimized version of the code.  By default you have configured your project to build the debug version.  Let&apos;s tell the project to make an optimized build.  To explain to Waf that it should do optimized builds that include the examples and tests, you will need to execute the following commands,</p>
<pre>
./waf clean
./waf -d optimized --enable-examples --enable-tests configure
</pre>
<p>This runs Waf out of the local directory (which is provided as a convenience for you).  The first command to clean out the previous build is not typically strictly necessary but is good practice; it will remove the previously built libraries and object files found in directory <strong>build/</strong>. When the project is reconfigured and the build system checks for various dependencies, you should see output that looks similar to the following,</p>
<pre>
Checking for program g++                 : ok /usr/bin/g++
Checking for program cpp                 : ok /usr/bin/cpp
Checking for program ar                  : ok /usr/bin/ar
Checking for program ranlib              : ok /usr/bin/ranlib
Checking for g++                         : ok
Checking for program pkg-config          : ok /usr/bin/pkg-config
Checking for -Wno-error=deprecated-declarations support : yes
Checking for -Wl,--soname=foo support                   : yes
Checking for header stdlib.h                            : ok
Checking for header signal.h                            : ok
Checking for header pthread.h                           : ok
Checking for high precision time implementation         : 128-bit integer
Checking for header stdint.h                            : ok
Checking for header inttypes.h                          : ok
Checking for header sys/inttypes.h                      : not found
Checking for library rt                                 : ok
Checking for header netpacket/packet.h                  : ok
Checking for pkg-config flags for GSL                   : ok
Checking for header linux/if_tun.h                      : ok
Checking for pkg-config flags for GTK_CONFIG_STORE      : ok
Checking for pkg-config flags for LIBXML2               : ok
Checking for library sqlite3                            : ok
Checking for NSC location                               : ok ../nsc (guessed)
Checking for library dl                                 : ok
Checking for NSC supported architecture x86_64          : ok
Checking for program python                             : ok /usr/bin/python
Checking for Python version &gt;= 2.3                      : ok 2.5.2
Checking for library python2.5                          : ok
Checking for program python2.5-config                   : ok /usr/bin/python2.5-config
Checking for header Python.h                            : ok
Checking for -fvisibility=hidden support                : yes
Checking for pybindgen location                         : ok ../pybindgen (guessed)
Checking for Python module pybindgen                    : ok
Checking for pybindgen version                          : ok 0.10.0.640
Checking for Python module pygccxml                     : ok
Checking for pygccxml version                           : ok 0.9.5
Checking for program gccxml                             : ok /usr/local/bin/gccxml
Checking for gccxml version                             : ok 0.9.0
Checking for program sudo                               : ok /usr/bin/sudo
Checking for program hg                                 : ok /usr/bin/hg
Checking for program valgrind                           : ok /usr/bin/valgrind
---- Summary of optional NS-3 features:
Threading Primitives          : enabled
Real Time Simulator           : enabled
Emulated Net Device           : enabled
GNU Scientific Library (GSL)  : enabled
Tap Bridge                    : enabled
GtkConfigStore                : enabled
XmlIo                         : enabled
SQlite stats data output      : enabled
Network Simulation Cradle     : enabled
Python Bindings               : enabled
Python API Scanning Support   : enabled
Use sudo to set suid bit      : not enabled (option --enable-sudo not selected)
Build tests                   : enabled
Build examples                : enabled
Static build                  : not enabled (option --enable-static not selected)
&apos;configure&apos; finished successfully (2.870s)
</pre>
<p>Note the last part of the above output.  Some ns-3 options are not enabled by default or require support from the underlying system to work properly. For instance, to enable XmlTo, the library libxml-2.0 must be found on the system.  If this library were not found, the corresponding <em>ns-3</em> feature would not be enabled and a message would be displayed.  Note further that there is a feature to use the program <strong>sudo</strong> to set the suid bit of certain programs. This is not enabled by default and so this feature is reported as "not enabled."</p><p>Now go ahead and switch back to the debug build that includes the examples and tests.</p>
<pre>
./waf clean
./waf -d debug --enable-examples --enable-tests configure
</pre>
<p>The build system is now configured and you can build the debug versions of the <em>ns-3</em> programs by simply typing</p>
<pre>
./waf
</pre>
<p>Okay, sorry, I made you build the <em>ns-3</em> part of the system twice, but now you know how to change the configuration and build optimized code.</p><p>Here are a few more introductory tips about Waf. Some waf commands are meaningful during the build phase and some commands are valid in the configuration phase.  For example, if you wanted to use the emulation features of <em>ns-3</em>, you might want to enable setting the suid bit using sudo as described above.  This turns out to be a configuration-time command, and so you could reconfigure using the following command that also includes the examples and tests</p>
<pre>
./waf configure -d debug --enable-sudo --enable-examples --enable-tests
</pre>
<p>If you do this, waf will have run sudo to change the socket creator programs of the emulation code to run as root.  There are many other configure- and build-time options available in waf.  To explore these options, type:</p>
<pre>
./waf --help
</pre>
<p>We&apos;ll use some of the testing-related commands in the next section.</p><p>Finally, as an aside, it is possible to specify that waf builds the project in a directory different than the default <strong>build/</strong> directory by passing the <strong>-o</strong> option to configure; e.g.</p>
<pre>
./waf configure -d debug -o build/debug --enable-examples --enable-tests
</pre>
<p>This allows users to work with multiple builds rather than always overwriting the last build.</p><p>In the examples above, waf uses GCC C++ compiler, command <strong>g++</strong>, for building ns-3. However, it&apos;s possible to change C++ compiler used by waf. Say one wants to use Clang C++ compiler, command <strong>clang++</strong>; it&apos;s done by</p>
<pre>
CXX="clang++" ./waf configure
./waf build
</pre>
<p>One can also set up waf to do distributed compilation with <strong>distcc</strong> in a similar way:</p>
<pre>
CXX="distcc g++" ./waf configure
./waf build
</pre>
<p>More info on distcc and distributed compilation can be found on it&apos;s <em>project page</em> under Documentation section.</p>
<h3>Testing ns-3</h3>
<p>You can run the unit tests of the <em>ns-3</em> distribution by running the "./test.py -c core" script,</p>
<pre>
./test.py -c core
</pre>
<p>These tests are run in parallel by waf. You should eventually see a report saying that,</p>
<pre>
92 of 92 tests passed (92 passed, 0 failed, 0 crashed, 0 valgrind errors)
</pre>
<p>This is the important message.</p><p>You will also see output from the test runner and the output will actually look something like,</p>
<pre>
Waf: Entering directory \(ga/path/to/workspace/ns-3-allinone/ns-3-dev/build&apos;
Waf: Leaving directory \(ga/path/to/workspace/ns-3-allinone/ns-3-dev/build&apos;
&apos;build&apos; finished successfully (1.799s)

Modules built:
aodv                      applications              bridge
click                     config-store              core
csma                      csma-layout               dsdv
emu                       energy                    flow-monitor
internet                  lte                       mesh
mobility                  mpi                       netanim
network                   nix-vector-routing        ns3tcp
ns3wifi                   olsr                      openflow
point-to-point            point-to-point-layout     propagation
spectrum                  stats                     tap-bridge
template                  test                      tools
topology-read             uan                       virtual-net-device
visualizer                wifi                      wimax

PASS: TestSuite ns3-wifi-interference
PASS: TestSuite histogram
PASS: TestSuite sample
PASS: TestSuite ipv4-address-helper
PASS: TestSuite devices-wifi
PASS: TestSuite propagation-loss-model

...

PASS: TestSuite attributes
PASS: TestSuite config
PASS: TestSuite global-value
PASS: TestSuite command-line
PASS: TestSuite basic-random-number
PASS: TestSuite object
PASS: TestSuite random-number-generators
92 of 92 tests passed (92 passed, 0 failed, 0 crashed, 0 valgrind errors)
</pre>
<p>This command is typically run by users to quickly verify that an <em>ns-3</em> distribution has built correctly.</p>
<h3>Running a Script</h3>
<p>We typically run scripts under the control of Waf.  This allows the build system to ensure that the shared library paths are set correctly and that the libraries are available at run time.  To run a program, simply use the <strong>--run</strong> option in Waf.  Let&apos;s run the <em>ns-3</em> equivalent of the ubiquitous hello world program by typing the following:</p>
<pre>
./waf --run hello-simulator
</pre>
<p>Waf first checks to make sure that the program is built correctly and executes a build if required.  Waf then executes the program, which produces the following output.</p>
<pre>
Hello Simulator
</pre>
<p><em>Congratulations.  You are now an ns-3 user.</em></p><p><em>What do I do if I don&apos;t see the output?</em></p><p>If you see <strong>waf</strong> messages indicating that the build was completed successfully, but do not see the "Hello Simulator" output, chances are that you have switched your build mode to "optimized" in the "Building with Waf" section, but have missed the change back to "debug" mode.  All of the console output used in this tutorial uses a special <em>ns-3</em> logging component that is useful for printing user messages to the console.  Output from this component is automatically disabled when you compile optimized code -- it is "optimized out."  If you don&apos;t see the "Hello Simulator" output, type the following,</p>
<pre>
./waf configure -d debug --enable-examples --enable-tests
</pre>
<p>to tell <strong>waf</strong> to build the debug versions of the <em>ns-3</em> programs that includes the examples and tests.  You must still build the actual debug version of the code by typing,</p>
<pre>
./waf
</pre>
<p>Now, if you run the <strong>hello-simulator</strong> program, you should see the expected output.</p><p>If you want to run programs under another tool such as gdb or valgrind, see this <em>wiki entry</em>.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONCEPTUAL OVERVIEW</h2>
        <div class="sectioncontent">
<p>The first thing we need to do before actually starting to look at or write <em>ns-3</em> code is to explain a few core concepts and abstractions in the system.  Much of this may appear transparently obvious to some, but we recommend taking the time to read through this section just to ensure you are starting on a firm foundation.</p><h3>Key Abstractions</h3>
<p>In this section, we&apos;ll review some terms that are commonly used in networking, but have a specific meaning in <em>ns-3</em>.</p>
<h3>Node</h3>
<p>In Internet jargon, a computing device that connects to a network is called a <em>host</em> or sometimes an <em>end system</em>.  Because <em>ns-3</em> is a <em>network</em> simulator, not specifically an <em>Internet</em> simulator, we intentionally do not use the term host since it is closely associated with the Internet and its protocols.  Instead, we use a more generic term also used by other simulators that originates in Graph Theory --- the <em>node</em>.</p><p>In <em>ns-3</em> the basic computing device abstraction is called the node.  This abstraction is represented in C++ by the class <strong>Node</strong>.  The <strong>Node</strong> class provides methods for managing the representations of computing devices in simulations.</p><p>You should think of a <strong>Node</strong> as a computer to which you will add functionality.  One adds things like applications, protocol stacks and peripheral cards with their associated drivers to enable the computer to do useful work.  We use the same basic model in <em>ns-3</em>.</p>
<h3>Application</h3>
<p>Typically, computer software is divided into two broad classes.  <em>System</em> Software organizes various computer resources such as memory, processor cycles, disk, network, etc., according to some computing model.  System software usually does not use those resources to complete tasks that directly benefit a user.  A user would typically run an <em>application</em> that acquires and uses the resources controlled by the system software to accomplish some goal.</p><p>Often, the line of separation between system and application software is made at the privilege level change that happens in operating system traps. In <em>ns-3</em> there is no real concept of operating system and especially no concept of privilege levels or system calls.  We do, however, have the idea of an application.  Just as software applications run on computers to perform tasks in the "real world," <em>ns-3</em> applications run on <em>ns-3</em> <strong>Nodes</strong> to drive simulations in the simulated world.</p><p>In <em>ns-3</em> the basic abstraction for a user program that generates some activity to be simulated is the application.  This abstraction is represented in C++ by the class <strong>Application</strong>.  The <strong>Application</strong> class provides methods for managing the representations of our version of user-level applications in simulations.  Developers are expected to specialize the <strong>Application</strong> class in the object-oriented programming sense to create new applications.  In this tutorial, we will use specializations of class <strong>Application</strong> called <strong>UdpEchoClientApplication</strong> and <strong>UdpEchoServerApplication</strong>.  As you might expect, these applications compose a client/server application set used to generate and echo simulated network packets</p>
<h3>Channel</h3>
<p>In the real world, one can connect a computer to a network.  Often the media over which data flows in these networks are called <em>channels</em>.  When you connect your Ethernet cable to the plug in the wall, you are connecting your computer to an Ethernet communication channel.  In the simulated world of <em>ns-3</em>, one connects a <strong>Node</strong> to an object representing a communication channel.  Here the basic communication subnetwork abstraction is called the channel and is represented in C++ by the class <strong>Channel</strong>.</p><p>The <strong>Channel</strong> class provides methods for managing communication subnetwork objects and connecting nodes to them.  <strong>Channels</strong> may also be specialized by developers in the object oriented programming sense.  A <strong>Channel</strong> specialization may model something as simple as a wire.  The specialized  <strong>Channel</strong> can also model things as complicated as a large Ethernet switch, or three-dimensional space full of obstructions in the case of wireless networks.</p><p>We will use specialized versions of the <strong>Channel</strong> called <strong>CsmaChannel</strong>, <strong>PointToPointChannel</strong> and <strong>WifiChannel</strong> in this tutorial.  The <strong>CsmaChannel</strong>, for example, models a version of a communication subnetwork that implements a <em>carrier sense multiple</em> access communication medium.  This gives us Ethernet-like functionality.</p>
<h3>Net Device</h3>
<p>It used to be the case that if you wanted to connect a computers to a network, you had to buy a specific kind of network cable and a hardware device called (in PC terminology) a <em>peripheral card</em> that needed to be installed in your computer.  If the peripheral card implemented some networking function, they were called Network Interface Cards, or <em>NICs</em>.  Today most computers come with the network interface hardware built in and users don&apos;t see these building blocks.</p><p>A NIC will not work without a software driver to control the hardware.  In Unix (or Linux), a piece of peripheral hardware is classified as a <em>device</em>.  Devices are controlled using <em>device drivers</em>, and network devices (NICs) are controlled using <em>network device drivers</em> collectively known as <em>net devices</em>.  In Unix and Linux you refer to these net devices by names such as <em>eth0</em>.</p><p>In <em>ns-3</em> the <em>net device</em> abstraction covers both the software driver and the simulated hardware.  A net device is "installed" in a <strong>Node</strong> in order to enable the <strong>Node</strong> to communicate with other <strong>Nodes</strong> in the simulation via <strong>Channels</strong>.  Just as in a real computer, a <strong>Node</strong> may be connected to more than one <strong>Channel</strong> via multiple <strong>NetDevices</strong>.</p><p>The net device abstraction is represented in C++ by the class <strong>NetDevice</strong>. The <strong>NetDevice</strong> class provides methods for managing connections to <strong>Node</strong> and <strong>Channel</strong> objects; and may be specialized by developers in the object-oriented programming sense.  We will use the several specialized versions of the <strong>NetDevice</strong> called <strong>CsmaNetDevice</strong>, <strong>PointToPointNetDevice</strong>, and <strong>WifiNetDevice</strong> in this tutorial. Just as an Ethernet NIC is designed to work with an Ethernet network, the <strong>CsmaNetDevice</strong> is designed to work with a <strong>CsmaChannel</strong>; the <strong>PointToPointNetDevice</strong> is designed to work with a <strong>PointToPointChannel</strong> and a <strong>WifiNetNevice</strong> is designed to work with a <strong>WifiChannel</strong>.</p>
<h3>Topology Helpers</h3>
<p>In a real network, you will find host computers with added (or built-in) NICs.  In <em>ns-3</em> we would say that you will find <strong>Nodes</strong> with attached <strong>NetDevices</strong>.  In a large simulated network you will need to arrange many connections between <strong>Nodes</strong>, <strong>NetDevices</strong> and <strong>Channels</strong>.</p><p>Since connecting <strong>NetDevices</strong> to <strong>Nodes</strong>, <strong>NetDevices</strong> to <strong>Channels</strong>, assigning IP addresses,  etc., are such common tasks in <em>ns-3</em>, we provide what we call <em>topology helpers</em> to make this as easy as possible.  For example, it may take many distinct <em>ns-3</em> core operations to create a NetDevice, add a MAC address, install that net device on a <strong>Node</strong>, configure the node&apos;s protocol stack, and then connect the <strong>NetDevice</strong> to a <strong>Channel</strong>.  Even more operations would be required to connect multiple devices onto multipoint channels and then to connect individual networks together into internetworks. We provide topology helper objects that combine those many distinct operations into an easy to use model for your convenience.</p>
<h3>A First ns-3 Script</h3>
<p>If you downloaded the system as was suggested above, you will have a release of <em>ns-3</em> in a directory called <strong>repos</strong> under your home directory.  Change into that release directory, and you should find a directory structure something like the following:</p>
<pre>
AUTHORS       examples       scratch        utils      waf.bat*
bindings      LICENSE        src            utils.py   waf-tools
build         ns3            test.py*       utils.pyc  wscript
CHANGES.html  README         testpy-output  VERSION    wutils.py
doc           RELEASE_NOTES  testpy.supp    waf*       wutils.pyc
</pre>
<p>Change into the <strong>examples/tutorial</strong> directory.  You should see a file named <strong>first.cc</strong> located there.  This is a script that will create a simple point-to-point link between two nodes and echo a single packet between the nodes.  Let&apos;s take a look at that script line by line, so go ahead and open <strong>first.cc</strong> in your favorite editor.</p>
<h3>Boilerplate</h3>
<p>The first line in the file is an emacs mode line.  This tells emacs about the formatting conventions (coding style) we use in our source code.</p>
<pre>
/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
</pre>
<p>This is always a somewhat controversial subject, so we might as well get it out of the way immediately.  The <em>ns-3</em> project, like most large projects, has adopted a coding style to which all contributed code must adhere.  If you want to contribute your code to the project, you will eventually have to conform to the <em>ns-3</em> coding standard as described in the file <strong>doc/codingstd.txt</strong> or shown on the project web page <em>here</em>.</p><p>We recommend that you, well, just get used to the look and feel of <em>ns-3</em> code and adopt this standard whenever you are working with our code.  All of the development team and contributors have done so with various amounts of grumbling.  The emacs mode line above makes it easier to get the formatting correct if you use the emacs editor.</p><p>The <em>ns-3</em> simulator is licensed using the GNU General Public License.  You will see the appropriate GNU legalese at the head of every file in the <em>ns-3</em> distribution.  Often you will see a copyright notice for one of the institutions involved in the <em>ns-3</em> project above the GPL text and an author listed below.</p>
<pre>
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation;
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
 */
</pre>

<h3>Module Includes</h3>
<p>The code proper starts with a number of include statements.</p>
<pre>
#include "ns3/core-module.h"
#include "ns3/network-module.h"
#include "ns3/internet-module.h"
#include "ns3/point-to-point-module.h"
#include "ns3/applications-module.h"
</pre>
<p>To help our high-level script users deal with the large number of include files present in the system, we group includes according to relatively large modules.  We provide a single include file that will recursively load all of the include files used in each module.  Rather than having to look up exactly what header you need, and possibly have to get a number of dependencies right, we give you the ability to load a group of files at a large granularity.  This is not the most efficient approach but it certainly makes writing scripts much easier.</p><p>Each of the <em>ns-3</em> include files is placed in a directory called <strong>ns3</strong> (under the build directory) during the build process to help avoid include file name collisions.  The <strong>ns3/core-module.h</strong> file corresponds to the ns-3 module you will find in the directory <strong>src/core</strong> in your downloaded release distribution.  If you list this directory you will find a large number of header files.  When you do a build, Waf will place public header files in an <strong>ns3</strong> directory under the appropriate <strong>build/debug</strong> or <strong>build/optimized</strong> directory depending on your configuration.  Waf will also automatically generate a module include file to load all of the public header files.</p><p>Since you are, of course, following this tutorial religiously, you will already have done a</p>
<pre>
./waf -d debug --enable-examples --enable-tests configure
</pre>
<p>in order to configure the project to perform debug builds that include examples and tests.  You will also have done a</p>
<pre>
./waf
</pre>
<p>to build the project.  So now if you look in the directory <strong>../../build/debug/ns3</strong> you will find the four module include files shown above.  You can take a look at the contents of these files and find that they do include all of the public include files in their respective modules.</p>
<h3>Ns3 Namespace</h3>
<p>The next line in the <strong>first.cc</strong> script is a namespace declaration.</p>
<pre>
using namespace ns3;
</pre>
<p>The <em>ns-3</em> project is implemented in a C++ namespace called <strong>ns3</strong>.  This groups all <em>ns-3</em>-related declarations in a scope outside the global namespace, which we hope will help with integration with other code.  The C++ <strong>using</strong> statement introduces the <em>ns-3</em> namespace into the current (global) declarative region.  This is a fancy way of saying that after this declaration, you will not have to type <strong>ns3::</strong> scope resolution operator before all of the <em>ns-3</em> code in order to use it.  If you are unfamiliar with namespaces, please consult almost any C++ tutorial and compare the <strong>ns3</strong> namespace and usage here with instances of the <strong>std</strong> namespace and the <strong>using namespace std;</strong> statements you will often find in discussions of <strong>cout</strong> and streams.</p>
<h3>Logging</h3>
<p>The next line of the script is the following,</p>
<pre>
NS_LOG_COMPONENT_DEFINE ("FirstScriptExample");
</pre>
<p>We will use this statement as a convenient place to talk about our Doxygen documentation system.  If you look at the project web site, <em>ns-3 project</em>, you will find a link to "Documentation" in the navigation bar.  If you select this link, you will be taken to our documentation page. There is a link to "Latest Release" that will take you to the documentation for the latest stable release of <em>ns-3</em>. If you select the "API Documentation" link, you will be taken to the <em>ns-3</em> API documentation page.</p><p>Along the left side, you will find a graphical representation of the structure of the documentation.  A good place to start is the <strong>NS-3 Modules</strong> "book" in the <em>ns-3</em> navigation tree.  If you expand <strong>Modules</strong> you will see a list of <em>ns-3</em> module documentation.  The concept of module here ties directly into the module include files discussed above.  The <em>ns-3</em> logging subsystem is discussed in the <strong>C++ Constructs Used by All Modules</strong> section, so go ahead and expand that documentation node.  Now, expand the <strong>Debugging</strong> book and then select the <strong>Logging</strong> page.</p><p>You should now be looking at the Doxygen documentation for the Logging module. In the list of <strong>#define</strong>&apos;s at the top of the page you will see the entry for <strong>NS_LOG_COMPONENT_DEFINE</strong>.  Before jumping in, it would probably be good to look for the "Detailed Description" of the logging module to get a feel for the overall operation.  You can either scroll down or select the "More..." link under the collaboration diagram to do this.</p><p>Once you have a general idea of what is going on, go ahead and take a look at the specific <strong>NS_LOG_COMPONENT_DEFINE</strong> documentation.  I won&apos;t duplicate the documentation here, but to summarize, this line declares a logging component called <strong>FirstScriptExample</strong> that allows you to enable and disable console message logging by reference to the name.</p>
<h3>Main Function</h3>
<p>The next lines of the script you will find are,</p>
<pre>
int
main (int argc, char *argv[])
{
</pre>
<p>This is just the declaration of the main function of your program (script). Just as in any C++ program, you need to define a main function that will be the first function run.  There is nothing at all special here.  Your <em>ns-3</em> script is just a C++ program.</p><p>The next two lines of the script are used to enable two logging components that are built into the Echo Client and Echo Server applications:</p>
<pre>
LogComponentEnable("UdpEchoClientApplication", LOG_LEVEL_INFO);
LogComponentEnable("UdpEchoServerApplication", LOG_LEVEL_INFO);
</pre>
<p>If you have read over the Logging component documentation you will have seen that there are a number of levels of logging verbosity/detail that you can enable on each component.  These two lines of code enable debug logging at the INFO level for echo clients and servers.  This will result in the application printing out messages as packets are sent and received during the simulation.</p><p>Now we will get directly to the business of creating a topology and running a simulation.  We use the topology helper objects to make this job as easy as possible.</p>
<h3>Topology Helpers</h3>

<h3>NodeContainer</h3>
<p>The next two lines of code in our script will actually create the <em>ns-3</em> <strong>Node</strong> objects that will represent the computers in the simulation.</p>
<pre>
NodeContainer nodes;
nodes.Create (2);
</pre>
<p>Let&apos;s find the documentation for the <strong>NodeContainer</strong> class before we continue.  Another way to get into the documentation for a given class is via the <strong>Classes</strong> tab in the Doxygen pages.  If you still have the Doxygen handy, just scroll up to the top of the page and select the <strong>Classes</strong> tab.  You should see a new set of tabs appear, one of which is <strong>Class List</strong>.  Under that tab you will see a list of all of the <em>ns-3</em> classes.  Scroll down, looking for <strong>ns3::NodeContainer</strong>. When you find the class, go ahead and select it to go to the documentation for the class.</p><p>You may recall that one of our key abstractions is the <strong>Node</strong>.  This represents a computer to which we are going to add things like protocol stacks, applications and peripheral cards.  The <strong>NodeContainer</strong> topology helper provides a convenient way to create, manage and access any <strong>Node</strong> objects that we create in order to run a simulation.  The first line above just declares a NodeContainer which we call <strong>nodes</strong>.  The second line calls the <strong>Create</strong> method on the <strong>nodes</strong> object and asks the container to create two nodes.  As described in the Doxygen, the container calls down into the <em>ns-3</em> system proper to create two <strong>Node</strong> objects and stores pointers to those objects internally.</p><p>The nodes as they stand in the script do nothing.  The next step in constructing a topology is to connect our nodes together into a network. The simplest form of network we support is a single point-to-point link between two nodes.  We&apos;ll construct one of those links here.</p>
<h3>PointToPointHelper</h3>
<p>We are constructing a point to point link, and, in a pattern which will become quite familiar to you, we use a topology helper object to do the low-level work required to put the link together.  Recall that two of our key abstractions are the <strong>NetDevice</strong> and the <strong>Channel</strong>.  In the real world, these terms correspond roughly to peripheral cards and network cables. Typically these two things are intimately tied together and one cannot expect to interchange, for example, Ethernet devices and wireless channels.  Our Topology Helpers follow this intimate coupling and therefore you will use a single <strong>PointToPointHelper</strong> to configure and connect <em>ns-3</em> <strong>PointToPointNetDevice</strong> and <strong>PointToPointChannel</strong> objects in this script.</p><p>The next three lines in the script are,</p>
<pre>
PointToPointHelper pointToPoint;
pointToPoint.SetDeviceAttribute ("DataRate", StringValue ("5Mbps"));
pointToPoint.SetChannelAttribute ("Delay", StringValue ("2ms"));
</pre>
<p>The first line,</p>
<pre>
PointToPointHelper pointToPoint;
</pre>
<p>instantiates a <strong>PointToPointHelper</strong> object on the stack.  From a high-level perspective the next line,</p>
<pre>
pointToPoint.SetDeviceAttribute ("DataRate", StringValue ("5Mbps"));
</pre>
<p>tells the <strong>PointToPointHelper</strong> object to use the value "5Mbps" (five megabits per second) as the "DataRate" when it creates a <strong>PointToPointNetDevice</strong> object.</p><p>From a more detailed perspective, the string "DataRate" corresponds to what we call an <strong>Attribute</strong> of the <strong>PointToPointNetDevice</strong>. If you look at the Doxygen for class <strong>ns3::PointToPointNetDevice</strong> and find the documentation for the <strong>GetTypeId</strong> method, you will find a list of  <strong>Attributes</strong> defined for the device.  Among these is the "DataRate" <strong>Attribute</strong>.  Most user-visible <em>ns-3</em> objects have similar lists of <strong>Attributes</strong>.  We use this mechanism to easily configure simulations without recompiling as you will see in a following section.</p><p>Similar to the "DataRate" on the <strong>PointToPointNetDevice</strong> you will find a "Delay" <strong>Attribute</strong> associated with the <strong>PointToPointChannel</strong>.  The final line,</p>
<pre>
pointToPoint.SetChannelAttribute ("Delay", StringValue ("2ms"));
</pre>
<p>tells the <strong>PointToPointHelper</strong> to use the value "2ms" (two milliseconds) as the value of the transmission delay of every point to point channel it subsequently creates.</p>
<h3>NetDeviceContainer</h3>
<p>At this point in the script, we have a <strong>NodeContainer</strong> that contains two nodes.  We have a <strong>PointToPointHelper</strong> that is primed and ready to make <strong>PointToPointNetDevices</strong> and wire <strong>PointToPointChannel</strong> objects between them.  Just as we used the <strong>NodeContainer</strong> topology helper object to create the <strong>Nodes</strong> for our simulation, we will ask the <strong>PointToPointHelper</strong> to do the work involved in creating, configuring and installing our devices for us.  We will need to have a list of all of the NetDevice objects that are created, so we use a NetDeviceContainer to hold them just as we used a NodeContainer to hold the nodes we created.  The following two lines of code,</p>
<pre>
NetDeviceContainer devices;
devices = pointToPoint.Install (nodes);
</pre>
<p>will finish configuring the devices and channel.  The first line declares the device container mentioned above and the second does the heavy lifting.  The <strong>Install</strong> method of the <strong>PointToPointHelper</strong> takes a <strong>NodeContainer</strong> as a parameter.  Internally, a <strong>NetDeviceContainer</strong> is created.  For each node in the <strong>NodeContainer</strong> (there must be exactly two for a point-to-point link) a <strong>PointToPointNetDevice</strong> is created and saved in the device container.  A <strong>PointToPointChannel</strong> is created and the two <strong>PointToPointNetDevices</strong> are attached.  When objects are created by the <strong>PointToPointHelper</strong>, the <strong>Attributes</strong> previously set in the helper are used to initialize the corresponding <strong>Attributes</strong> in the created objects.</p><p>After executing the <strong>pointToPoint.Install (nodes)</strong> call we will have two nodes, each with an installed point-to-point net device and a single point-to-point channel between them.  Both devices will be configured to transmit data at five megabits per second over the channel which has a two millisecond transmission delay.</p>
<h3>InternetStackHelper</h3>
<p>We now have nodes and devices configured, but we don&apos;t have any protocol stacks installed on our nodes.  The next two lines of code will take care of that.</p>
<pre>
InternetStackHelper stack;
stack.Install (nodes);
</pre>
<p>The <strong>InternetStackHelper</strong> is a topology helper that is to internet stacks what the <strong>PointToPointHelper</strong> is to point-to-point net devices.  The <strong>Install</strong> method takes a <strong>NodeContainer</strong> as a parameter.  When it is executed, it will install an Internet Stack (TCP, UDP, IP, etc.) on each of the nodes in the node container.</p>
<h3>Ipv4AddressHelper</h3>
<p>Next we need to associate the devices on our nodes with IP addresses.  We provide a topology helper to manage the allocation of IP addresses.  The only user-visible API is to set the base IP address and network mask to use when performing the actual address allocation (which is done at a lower level inside the helper).</p><p>The next two lines of code in our example script, <strong>first.cc</strong>,</p>
<pre>
Ipv4AddressHelper address;
address.SetBase ("10.1.1.0", "255.255.255.0");
</pre>
<p>declare an address helper object and tell it that it should begin allocating IP addresses from the network 10.1.1.0 using the mask 255.255.255.0 to define the allocatable bits.  By default the addresses allocated will start at one and increase monotonically, so the first address allocated from this base will be 10.1.1.1, followed by 10.1.1.2, etc.  The low level <em>ns-3</em> system actually remembers all of the IP addresses allocated and will generate a fatal error if you accidentally cause the same address to be generated twice (which is a very hard to debug error, by the way).</p><p>The next line of code,</p>
<pre>
Ipv4InterfaceContainer interfaces = address.Assign (devices);
</pre>
<p>performs the actual address assignment.  In <em>ns-3</em> we make the association between an IP address and a device using an <strong>Ipv4Interface</strong> object.  Just as we sometimes need a list of net devices created by a helper for future reference we sometimes need a list of <strong>Ipv4Interface</strong> objects. The <strong>Ipv4InterfaceContainer</strong> provides this functionality.</p><p>Now we have a point-to-point network built, with stacks installed and IP addresses assigned.  What we need at this point are applications to generate traffic.</p>
<h3>Applications</h3>
<p>Another one of the core abstractions of the ns-3 system is the <strong>Application</strong>.  In this script we use two specializations of the core <em>ns-3</em> class <strong>Application</strong> called <strong>UdpEchoServerApplication</strong> and <strong>UdpEchoClientApplication</strong>.  Just as we have in our previous explanations,  we use helper objects to help configure and manage the underlying objects.  Here, we use <strong>UdpEchoServerHelper</strong> and <strong>UdpEchoClientHelper</strong> objects to make our lives easier.</p>
<h3>UdpEchoServerHelper</h3>
<p>The following lines of code in our example script, <strong>first.cc</strong>, are used to set up a UDP echo server application on one of the nodes we have previously created.</p>
<pre>
UdpEchoServerHelper echoServer (9);

ApplicationContainer serverApps = echoServer.Install (nodes.Get (1));
serverApps.Start (Seconds (1.0));
serverApps.Stop (Seconds (10.0));
</pre>
<p>The first line of code in the above snippet declares the <strong>UdpEchoServerHelper</strong>.  As usual, this isn&apos;t the application itself, it is an object used to help us create the actual applications.  One of our conventions is to place <em>required</em> <strong>Attributes</strong> in the helper constructor. In this case, the helper can&apos;t do anything useful unless it is provided with a port number that the client also knows about.  Rather than just picking one and hoping it all works out, we require the port number as a parameter to the constructor.  The constructor, in turn, simply does a <strong>SetAttribute</strong> with the passed value.  If you want, you can set the "Port" <strong>Attribute</strong> to another value later using <strong>SetAttribute</strong>.</p><p>Similar to many other helper objects, the <strong>UdpEchoServerHelper</strong> object has an <strong>Install</strong> method.  It is the execution of this method that actually causes the underlying echo server application to be instantiated and attached to a node.  Interestingly, the <strong>Install</strong> method takes a <strong>NodeContainter</strong> as a parameter just as the other <strong>Install</strong> methods we have seen.  This is actually what is passed to the method even though it doesn&apos;t look so in this case.  There is a C++ <em>implicit conversion</em> at work here that takes the result of <strong>nodes.Get (1)</strong> (which returns a smart pointer to a node object --- <strong>Ptr&lt;Node&gt;</strong>) and uses that in a constructor for an unnamed <strong>NodeContainer</strong> that is then passed to <strong>Install</strong>. If you are ever at a loss to find a particular method signature in C++ code that compiles and runs just fine, look for these kinds of implicit conversions.</p><p>We now see that <strong>echoServer.Install</strong> is going to install a <strong>UdpEchoServerApplication</strong> on the node found at index number one of the <strong>NodeContainer</strong> we used to manage our nodes.  <strong>Install</strong> will return a container that holds pointers to all of the applications (one in this case since we passed a <strong>NodeContainer</strong> containing one node) created by the helper.</p><p>Applications require a time to "start" generating traffic and may take an optional time to "stop".  We provide both.  These times are set using  the <strong>ApplicationContainer</strong> methods <strong>Start</strong> and <strong>Stop</strong>.  These methods take <strong>Time</strong> parameters.  In this case, we use an <em>explicit</em> C++ conversion sequence to take the C++ double 1.0 and convert it to an <em>ns-3</em> <strong>Time</strong> object using a <strong>Seconds</strong> cast.  Be aware that the conversion rules may be controlled by the model author, and C++ has its own rules, so you can&apos;t always just assume that parameters will be happily converted for you.  The two lines,</p>
<pre>
serverApps.Start (Seconds (1.0));
serverApps.Stop (Seconds (10.0));
</pre>
<p>will cause the echo server application to <strong>Start</strong> (enable itself) at one second into the simulation and to <strong>Stop</strong> (disable itself) at ten seconds into the simulation.  By virtue of the fact that we have declared a simulation event (the application stop event) to be executed at ten seconds, the simulation will last <em>at least</em> ten seconds.</p>
<h3>UdpEchoClientHelper</h3>
<p>The echo client application is set up in a method substantially similar to that for the server.  There is an underlying <strong>UdpEchoClientApplication</strong> that is managed by an <strong>UdpEchoClientHelper</strong>.</p>
<pre>
UdpEchoClientHelper echoClient (interfaces.GetAddress (1), 9);
echoClient.SetAttribute ("MaxPackets", UintegerValue (1));
echoClient.SetAttribute ("Interval", TimeValue (Seconds (1.0)));
echoClient.SetAttribute ("PacketSize", UintegerValue (1024));

ApplicationContainer clientApps = echoClient.Install (nodes.Get (0));
clientApps.Start (Seconds (2.0));
clientApps.Stop (Seconds (10.0));
</pre>
<p>For the echo client, however, we need to set five different <strong>Attributes</strong>. The first two <strong>Attributes</strong> are set during construction of the <strong>UdpEchoClientHelper</strong>.  We pass parameters that are used (internally to the helper) to set the "RemoteAddress" and "RemotePort" <strong>Attributes</strong> in accordance with our convention to make required <strong>Attributes</strong> parameters in the helper constructors.</p><p>Recall that we used an <strong>Ipv4InterfaceContainer</strong> to keep track of the IP addresses we assigned to our devices.  The zeroth interface in the <strong>interfaces</strong> container is going to correspond to the IP address of the zeroth node in the <strong>nodes</strong> container.  The first interface in the <strong>interfaces</strong> container corresponds to the IP address of the first node in the <strong>nodes</strong> container.  So, in the first line of code (from above), we are creating the helper and telling it so set the remote address of the client to be  the IP address assigned to the node on which the server resides.  We also tell it to arrange to send packets to port nine.</p><p>The "MaxPackets" <strong>Attribute</strong> tells the client the maximum number of packets we allow it to send during the simulation.  The "Interval" <strong>Attribute</strong> tells the client how long to wait between packets, and the "PacketSize" <strong>Attribute</strong> tells the client how large its packet payloads should be.  With this particular combination of <strong>Attributes</strong>, we are telling the client to send one 1024-byte packet.</p><p>Just as in the case of the echo server, we tell the echo client to <strong>Start</strong> and <strong>Stop</strong>, but here we start the client one second after the server is enabled (at two seconds into the simulation).</p>
<h3>Simulator</h3>
<p>What we need to do at this point is to actually run the simulation.  This is done using the global function <strong>Simulator::Run</strong>.</p>
<pre>
Simulator::Run ();
</pre>
<p>When we previously called the methods,</p>
<pre>
serverApps.Start (Seconds (1.0));
serverApps.Stop (Seconds (10.0));
...
clientApps.Start (Seconds (2.0));
clientApps.Stop (Seconds (10.0));
</pre>
<p>we actually scheduled events in the simulator at 1.0 seconds, 2.0 seconds and two events at 10.0 seconds.  When <strong>Simulator::Run</strong> is called, the system will begin looking through the list of scheduled events and executing them. First it will run the event at 1.0 seconds, which will enable the echo server application (this event may, in turn, schedule many other events).  Then it will run the event scheduled for t=2.0 seconds which will start the echo client application.  Again, this event may schedule many more events.  The start event implementation in the echo client application will begin the data transfer phase of the simulation by sending a packet to the server.</p><p>The act of sending the packet to the server will trigger a chain of events that will be automatically scheduled behind the scenes and which will perform the mechanics of the packet echo according to the various timing parameters that we have set in the script.</p><p>Eventually, since we only send one packet (recall the <strong>MaxPackets</strong> <strong>Attribute</strong> was set to one), the chain of events triggered by that single client echo request will taper off and the simulation will go idle.  Once this happens, the remaining events will be the <strong>Stop</strong> events for the server and the client.  When these events are executed, there are no further events to process and <strong>Simulator::Run</strong> returns.  The simulation is then complete.</p><p>All that remains is to clean up.  This is done by calling the global function <strong>Simulator::Destroy</strong>.  As the helper functions (or low level <em>ns-3</em> code) executed, they arranged it so that hooks were inserted in the simulator to destroy all of the objects that were created.  You did not have to keep track of any of these objects yourself --- all you had to do was to call <strong>Simulator::Destroy</strong> and exit.  The <em>ns-3</em> system took care of the hard part for you.  The remaining lines of our first <em>ns-3</em> script, <strong>first.cc</strong>, do just that:</p>
<pre>
  Simulator::Destroy ();
  return 0;
}
</pre>

<h3>Building Your Script</h3>
<p>We have made it trivial to build your simple scripts.  All you have to do is to drop your script into the scratch directory and it will automatically be built if you run Waf.  Let&apos;s try it.  Copy <strong>examples/tutorial/first.cc</strong> into the <strong>scratch</strong> directory after changing back into the top level directory.</p>
<pre>
cd ../..
cp examples/tutorial/first.cc scratch/myfirst.cc
</pre>
<p>Now build your first example script using waf:</p>
<pre>
./waf
</pre>
<p>You should see messages reporting that your <strong>myfirst</strong> example was built successfully.</p>
<pre>
Waf: Entering directory \(ga/home/craigdo/repos/ns-3-allinone/ns-3-dev/build&apos;
[614/708] cxx: scratch/myfirst.cc -&gt; build/debug/scratch/myfirst_3.o
[706/708] cxx_link: build/debug/scratch/myfirst_3.o -&gt; build/debug/scratch/myfirst
Waf: Leaving directory \(ga/home/craigdo/repos/ns-3-allinone/ns-3-dev/build&apos;
&apos;build&apos; finished successfully (2.357s)
</pre>
<p>You can now run the example (note that if you build your program in the scratch directory you must run it out of the scratch directory):</p>
<pre>
./waf --run scratch/myfirst
</pre>
<p>You should see some output:</p>
<pre>
Waf: Entering directory \(ga/home/craigdo/repos/ns-3-allinone/ns-3-dev/build&apos;
Waf: Leaving directory \(ga/home/craigdo/repos/ns-3-allinone/ns-3-dev/build&apos;
&apos;build&apos; finished successfully (0.418s)
Sent 1024 bytes to 10.1.1.2
Received 1024 bytes from 10.1.1.1
Received 1024 bytes from 10.1.1.2
</pre>
<p>Here you see that the build system checks to make sure that the file has been build and then runs it.  You see the logging component on the echo client indicate that it has sent one 1024 byte packet to the Echo Server on 10.1.1.2.  You also see the logging component on the echo server say that it has received the 1024 bytes from 10.1.1.1.  The echo server silently echoes the packet and you see the echo client log that it has received its packet back from the server.</p>
<h3>Ns-3 Source Code</h3>
<p>Now that you have used some of the <em>ns-3</em> helpers you may want to have a look at some of the source code that implements that functionality. The most recent code can be browsed on our web server at the following link: <em>http://code.nsnam.org/ns-3-dev</em>.  There, you will see the Mercurial summary page for our <em>ns-3</em> development tree.</p><p>At the top of the page, you will see a number of links,</p>
<pre>
summary | shortlog | changelog | graph | tags | files
</pre>
<p>Go ahead and select the <strong>files</strong> link.  This is what the top-level of most of our <em>repositories</em> will look:</p>
<pre>
drwxr-xr-x                               [up]
drwxr-xr-x                               bindings python  files
drwxr-xr-x                               doc              files
drwxr-xr-x                               examples         files
drwxr-xr-x                               ns3              files
drwxr-xr-x                               scratch          files
drwxr-xr-x                               src              files
drwxr-xr-x                               utils            files
-rw-r--r-- 2009-07-01 12:47 +0200 560    .hgignore        file | revisions | annotate
-rw-r--r-- 2009-07-01 12:47 +0200 1886   .hgtags          file | revisions | annotate
-rw-r--r-- 2009-07-01 12:47 +0200 1276   AUTHORS          file | revisions | annotate
-rw-r--r-- 2009-07-01 12:47 +0200 30961  CHANGES.html     file | revisions | annotate
-rw-r--r-- 2009-07-01 12:47 +0200 17987  LICENSE          file | revisions | annotate
-rw-r--r-- 2009-07-01 12:47 +0200 3742   README           file | revisions | annotate
-rw-r--r-- 2009-07-01 12:47 +0200 16171  RELEASE_NOTES    file | revisions | annotate
-rw-r--r-- 2009-07-01 12:47 +0200 6      VERSION          file | revisions | annotate
-rwxr-xr-x 2009-07-01 12:47 +0200 88110  waf              file | revisions | annotate
-rwxr-xr-x 2009-07-01 12:47 +0200 28     waf.bat          file | revisions | annotate
-rw-r--r-- 2009-07-01 12:47 +0200 35395  wscript          file | revisions | annotate
-rw-r--r-- 2009-07-01 12:47 +0200 7673   wutils.py        file | revisions | annotate
</pre>
<p>Our example scripts are in the <strong>examples</strong> directory.  If you click on <strong>examples</strong> you will see a list of subdirectories.  One of the files in <strong>tutorial</strong> subdirectory is <strong>first.cc</strong>.  If you click on <strong>first.cc</strong> you will find the code you just walked through.</p><p>The source code is mainly in the <strong>src</strong> directory.  You can view source code either by clicking on the directory name or by clicking on the <strong>files</strong> link to the right of the directory name.  If you click on the <strong>src</strong> directory, you will be taken to the listing of the <strong>src</strong> subdirectories.  If you then click on <strong>core</strong> subdirectory, you will find a list of files.  The first file you will find (as of this writing) is <strong>abort.h</strong>.  If you click on the <strong>abort.h</strong> link, you will be sent to the source file for <strong>abort.h</strong> which contains useful macros for exiting scripts if abnormal conditions are detected.</p><p>The source code for the helpers we have used in this chapter can be found in the <strong>src/applications/helper</strong> directory.  Feel free to poke around in the directory tree to get a feel for what is there and the style of <em>ns-3</em> programs.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TWEAKING</h2>
        <div class="sectioncontent">
<h3>Using the Logging Module</h3>
<p>We have already taken a brief look at the <em>ns-3</em> logging module while going over the <strong>first.cc</strong> script.  We will now take a closer look and see what kind of use-cases the logging subsystem was designed to cover.</p>
<h3>Logging Overview</h3>
<p>Many large systems support some kind of message logging facility, and <em>ns-3</em> is not an exception.  In some cases, only error messages are logged to the "operator console" (which is typically <strong>stderr</strong> in Unix- based systems).  In other systems, warning messages may be output as well as more detailed informational messages.  In some cases, logging facilities are used to output debug messages which can quickly turn the output into a blur.</p><p><em>ns-3</em> takes the view that all of these verbosity levels are useful and we provide a selectable, multi-level approach to message logging.  Logging can be disabled completely, enabled on a component-by-component basis, or enabled globally; and it provides selectable verbosity levels.  The <em>ns-3</em> log module provides a straightforward, relatively easy to use way to get useful information out of your simulation.</p><p>You should understand that we do provide a general purpose mechanism --- tracing --- to get data out of your models which should be preferred for simulation output (see the tutorial section Using the Tracing System for more details on our tracing system).  Logging should be preferred for debugging information, warnings, error messages, or any time you want to easily get a quick message out of your scripts or models.</p><p>There are currently seven levels of log messages of increasing verbosity defined in the system.</p><ul>
<li><p>LOG_ERROR --- Log error messages (associated macro: NS_LOG_ERROR);</p></li><li><p>LOG_WARN --- Log warning messages (associated macro: NS_LOG_WARN);</p></li><li><p>LOG_DEBUG --- Log relatively rare, ad-hoc debugging messages (associated macro: NS_LOG_DEBUG);</p></li><li><p>LOG_INFO --- Log informational messages about program progress (associated macro: NS_LOG_INFO);</p></li><li><p>LOG_FUNCTION --- Log a message describing each function called (two associated macros: NS_LOG_FUNCTION, used for member functions, and NS_LOG_FUNCTION_NOARGS, used for static functions);</p></li><li><p>LOG_LOGIC -- Log messages describing logical flow within a function (associated macro: NS_LOG_LOGIC);</p></li><li><p>LOG_ALL --- Log everything mentioned above (no associated macro).</p><p>For each LOG_TYPE there is also LOG_LEVEL_TYPE that, if used, enables logging of all the levels above it in addition to it&apos;s level.  (As a consequence of this, LOG_ERROR and LOG_LEVEL_ERROR and also LOG_ALL and LOG_LEVEL_ALL are functionally equivalent.)  For example, enabling LOG_INFO will only enable messages provided by NS_LOG_INFO macro, while enabling LOG_LEVEL_INFO will also enable messages provided by NS_LOG_DEBUG, NS_LOG_WARN and NS_LOG_ERROR macros.</p><p>We also provide an unconditional logging macro that is always displayed, irrespective of logging levels or component selection.</p></li><li><p>NS_LOG_UNCOND -- Log the associated message unconditionally (no associated log level).</p><p>Each level can be requested singly or cumulatively; and logging can be set up using a shell environment variable (NS_LOG) or by logging system function call.  As was seen earlier in the tutorial, the logging system has Doxygen documentation and now would be a good time to peruse the Logging Module documentation if you have not done so.</p><p>Now that you have read the documentation in great detail, let&apos;s use some of that knowledge to get some interesting information out of the <strong>scratch/myfirst.cc</strong> example script you have already built.</p></li>
</ul>
<h3>Enabling Logging</h3>
<p>Let&apos;s use the NS_LOG environment variable to turn on some more logging, but first, just to get our bearings, go ahead and run the last script just as you did previously,</p>
<pre>
./waf --run scratch/myfirst
</pre>
<p>You should see the now familiar output of the first <em>ns-3</em> example program</p>
<pre>
Waf: Entering directory \(ga/home/craigdo/repos/ns-3-allinone/ns-3-dev/build&apos;
Waf: Leaving directory \(ga/home/craigdo/repos/ns-3-allinone/ns-3-dev/build&apos;
&apos;build&apos; finished successfully (0.413s)
Sent 1024 bytes to 10.1.1.2
Received 1024 bytes from 10.1.1.1
Received 1024 bytes from 10.1.1.2
</pre>
<p>It turns out that the "Sent" and "Received" messages you see above are actually logging messages from the <strong>UdpEchoClientApplication</strong> and <strong>UdpEchoServerApplication</strong>.  We can ask the client application, for example, to print more information by setting its logging level via the NS_LOG environment variable.</p><p>I am going to assume from here on that you are using an sh-like shell that uses the"VARIABLE=value" syntax.  If you are using a csh-like shell, then you will have to convert my examples to the "setenv VARIABLE value" syntax required by those shells.</p><p>Right now, the UDP echo client application is responding to the following line of code in <strong>scratch/myfirst.cc</strong>,</p>
<pre>
LogComponentEnable("UdpEchoClientApplication", LOG_LEVEL_INFO);
</pre>
<p>This line of code enables the <strong>LOG_LEVEL_INFO</strong> level of logging.  When we pass a logging level flag, we are actually enabling the given level and all lower levels.  In this case, we have enabled <strong>NS_LOG_INFO</strong>, <strong>NS_LOG_DEBUG</strong>, <strong>NS_LOG_WARN</strong> and <strong>NS_LOG_ERROR</strong>.  We can increase the logging level and get more information without changing the script and recompiling by setting the NS_LOG environment variable like this:</p>
<pre>
export NS_LOG=UdpEchoClientApplication=level_all
</pre>
<p>This sets the shell environment variable <strong>NS_LOG</strong> to the string,</p>
<pre>
UdpEchoClientApplication=level_all
</pre>
<p>The left hand side of the assignment is the name of the logging component we want to set, and the right hand side is the flag we want to use.  In this case, we are going to turn on all of the debugging levels for the application.  If you run the script with NS_LOG set this way, the <em>ns-3</em> logging system will pick up the change and you should see the following output:</p>
<pre>
Waf: Entering directory \(ga/home/craigdo/repos/ns-3-allinone/ns-3-dev/build
Waf: Leaving directory \(ga/home/craigdo/repos/ns-3-allinone/ns-3-dev/build&apos;
&apos;build&apos; finished successfully (0.404s)
UdpEchoClientApplication:UdpEchoClient()
UdpEchoClientApplication:SetDataSize(1024)
UdpEchoClientApplication:StartApplication()
UdpEchoClientApplication:ScheduleTransmit()
UdpEchoClientApplication:Send()
Sent 1024 bytes to 10.1.1.2
Received 1024 bytes from 10.1.1.1
UdpEchoClientApplication:HandleRead(0x6241e0, 0x624a20)
Received 1024 bytes from 10.1.1.2
UdpEchoClientApplication:StopApplication()
UdpEchoClientApplication:DoDispose()
UdpEchoClientApplication:~UdpEchoClient()
</pre>
<p>The additional debug information provided by the application is from the NS_LOG_FUNCTION level.  This shows every time a function in the application is called during script execution.  Generally, use of (at least) NS_LOG_FUNCTION(this) in member functions is preferred. Use NS_LOG_FUNCTION_NOARGS() only in static functions.  Note, however, that there are no requirements in the <em>ns-3</em> system that models must support any particular logging  functionality.  The decision regarding how much information is logged is left to the individual model developer.  In the case of the echo applications, a good deal of log output is available.</p><p>You can now see a log of the function calls that were made to the application. If you look closely you will notice a single colon between the string <strong>UdpEchoClientApplication</strong> and the method name where you might have expected a C++ scope operator (<strong>::</strong>).  This is intentional.</p><p>The name is not actually a class name, it is a logging component name.  When there is a one-to-one correspondence between a source file and a class, this will generally be the class name but you should understand that it is not actually a class name, and there is a single colon there instead of a double colon to remind you in a relatively subtle way to conceptually separate the logging component name from the class name.</p><p>It turns out that in some cases, it can be hard to determine which method actually generates a log message.  If you look in the text above, you may wonder where the string "<strong>Received 1024 bytes from 10.1.1.2</strong>" comes from.  You can resolve this by OR&apos;ing the <strong>prefix_func</strong> level into the <strong>NS_LOG</strong> environment variable.  Try doing the following,</p>
<pre>
export &apos;NS_LOG=UdpEchoClientApplication=level_all|prefix_func&apos;
</pre>
<p>Note that the quotes are required since the vertical bar we use to indicate an OR operation is also a Unix pipe connector.</p><p>Now, if you run the script you will see that the logging system makes sure that every message from the given log component is prefixed with the component name.</p>
<pre>
Waf: Entering directory \(ga/home/craigdo/repos/ns-3-allinone/ns-3-dev/build&apos;
Waf: Leaving directory \(ga/home/craigdo/repos/ns-3-allinone/ns-3-dev/build&apos;
&apos;build&apos; finished successfully (0.417s)
UdpEchoClientApplication:UdpEchoClient()
UdpEchoClientApplication:SetDataSize(1024)
UdpEchoClientApplication:StartApplication()
UdpEchoClientApplication:ScheduleTransmit()
UdpEchoClientApplication:Send()
UdpEchoClientApplication:Send(): Sent 1024 bytes to 10.1.1.2
Received 1024 bytes from 10.1.1.1
UdpEchoClientApplication:HandleRead(0x6241e0, 0x624a20)
UdpEchoClientApplication:HandleRead(): Received 1024 bytes from 10.1.1.2
UdpEchoClientApplication:StopApplication()
UdpEchoClientApplication:DoDispose()
UdpEchoClientApplication:~UdpEchoClient()
</pre>
<p>You can now see all of the messages coming from the UDP echo client application are identified as such.  The message "Received 1024 bytes from 10.1.1.2" is now clearly identified as coming from the echo client application.  The remaining message must be coming from the UDP echo server application.  We can enable that component by entering a colon separated list of components in the NS_LOG environment variable.</p>
<pre>
export &apos;NS_LOG=UdpEchoClientApplication=level_all|prefix_func:
               UdpEchoServerApplication=level_all|prefix_func&apos;
</pre>
<p>Warning:  You will need to remove the newline after the <strong>:</strong> in the example text above which is only there for document formatting purposes.</p><p>Now, if you run the script you will see all of the log messages from both the echo client and server applications.  You may see that this can be very useful in debugging problems.</p>
<pre>
Waf: Entering directory \(ga/home/craigdo/repos/ns-3-allinone/ns-3-dev/build&apos;
Waf: Leaving directory \(ga/home/craigdo/repos/ns-3-allinone/ns-3-dev/build&apos;
&apos;build&apos; finished successfully (0.406s)
UdpEchoServerApplication:UdpEchoServer()
UdpEchoClientApplication:UdpEchoClient()
UdpEchoClientApplication:SetDataSize(1024)
UdpEchoServerApplication:StartApplication()
UdpEchoClientApplication:StartApplication()
UdpEchoClientApplication:ScheduleTransmit()
UdpEchoClientApplication:Send()
UdpEchoClientApplication:Send(): Sent 1024 bytes to 10.1.1.2
UdpEchoServerApplication:HandleRead(): Received 1024 bytes from 10.1.1.1
UdpEchoServerApplication:HandleRead(): Echoing packet
UdpEchoClientApplication:HandleRead(0x624920, 0x625160)
UdpEchoClientApplication:HandleRead(): Received 1024 bytes from 10.1.1.2
UdpEchoServerApplication:StopApplication()
UdpEchoClientApplication:StopApplication()
UdpEchoClientApplication:DoDispose()
UdpEchoServerApplication:DoDispose()
UdpEchoClientApplication:~UdpEchoClient()
UdpEchoServerApplication:~UdpEchoServer()
</pre>
<p>It is also sometimes useful to be able to see the simulation time at which a log message is generated.  You can do this by ORing in the prefix_time bit.</p>
<pre>
export &apos;NS_LOG=UdpEchoClientApplication=level_all|prefix_func|prefix_time:
               UdpEchoServerApplication=level_all|prefix_func|prefix_time&apos;
</pre>
<p>Again, you will have to remove the newline above.  If you run the script now, you should see the following output:</p>
<pre>
Waf: Entering directory \(ga/home/craigdo/repos/ns-3-allinone/ns-3-dev/build&apos;
Waf: Leaving directory \(ga/home/craigdo/repos/ns-3-allinone/ns-3-dev/build&apos;
&apos;build&apos; finished successfully (0.418s)
0s UdpEchoServerApplication:UdpEchoServer()
0s UdpEchoClientApplication:UdpEchoClient()
0s UdpEchoClientApplication:SetDataSize(1024)
1s UdpEchoServerApplication:StartApplication()
2s UdpEchoClientApplication:StartApplication()
2s UdpEchoClientApplication:ScheduleTransmit()
2s UdpEchoClientApplication:Send()
2s UdpEchoClientApplication:Send(): Sent 1024 bytes to 10.1.1.2
2.00369s UdpEchoServerApplication:HandleRead(): Received 1024 bytes from 10.1.1.1
2.00369s UdpEchoServerApplication:HandleRead(): Echoing packet
2.00737s UdpEchoClientApplication:HandleRead(0x624290, 0x624ad0)
2.00737s UdpEchoClientApplication:HandleRead(): Received 1024 bytes from 10.1.1.2
10s UdpEchoServerApplication:StopApplication()
10s UdpEchoClientApplication:StopApplication()
UdpEchoClientApplication:DoDispose()
UdpEchoServerApplication:DoDispose()
UdpEchoClientApplication:~UdpEchoClient()
UdpEchoServerApplication:~UdpEchoServer()
</pre>
<p>You can see that the constructor for the UdpEchoServer was called at a simulation time of 0 seconds.  This is actually happening before the simulation starts, but the time is displayed as zero seconds.  The same is true for the UdpEchoClient constructor message.</p><p>Recall that the <strong>scratch/first.cc</strong> script started the echo server application at one second into the simulation.  You can now see that the <strong>StartApplication</strong> method of the server is, in fact, called at one second. You can also see that the echo client application is started at a simulation time of two seconds as we requested in the script.</p><p>You can now follow the progress of the simulation from the <strong>ScheduleTransmit</strong> call in the client that calls <strong>Send</strong> to the <strong>HandleRead</strong> callback in the echo server application.  Note that the elapsed time for the packet to be sent across the point-to-point link is 3.69 milliseconds.  You see the echo server logging a message telling you that it has echoed the packet and then, after another channel delay, you see the echo client receive the echoed packet in its <strong>HandleRead</strong> method.</p><p>There is a lot that is happening under the covers in this simulation that you are not seeing as well.  You can very easily follow the entire process by turning on all of the logging components in the system.  Try setting the <strong>NS_LOG</strong> variable to the following,</p>
<pre>
export &apos;NS_LOG=*=level_all|prefix_func|prefix_time&apos;
</pre>
<p>The asterisk above is the logging component wildcard.  This will turn on all of the logging in all of the components used in the simulation.  I won&apos;t reproduce the output here (as of this writing it produces 1265 lines of output for the single packet echo) but you can redirect this information into a file and look through it with your favorite editor if you like,</p>
<pre>
./waf --run scratch/myfirst &gt; log.out 2&gt;&1
</pre>
<p>I personally use this extremely verbose version of logging when I am presented with a problem and I have no idea where things are going wrong.  I can follow the progress of the code quite easily without having to set breakpoints and step through code in a debugger.  I can just edit up the output in my favorite editor and search around for things I expect, and see things happening that I don&apos;t expect.  When I have a general idea about what is going wrong, I transition into a debugger for a fine-grained examination of the problem.  This kind of output can be especially useful when your script does something completely unexpected. If you are stepping using a debugger you may miss an unexpected excursion completely.  Logging the excursion makes it quickly visible.</p>
<h3>Adding Logging to your Code</h3>
<p>You can add new logging to your simulations by making calls to the log component via several macros.  Let&apos;s do so in the <strong>myfirst.cc</strong> script we have in the <strong>scratch</strong> directory.</p><p>Recall that we have defined a logging component in that script:</p>
<pre>
NS_LOG_COMPONENT_DEFINE ("FirstScriptExample");
</pre>
<p>You now know that you can enable all of the logging for this component by setting the <strong>NS_LOG</strong> environment variable to the various levels.  Let&apos;s go ahead and add some logging to the script.  The macro used to add an informational level log message is <strong>NS_LOG_INFO</strong>.  Go ahead and add one (just before we start creating the nodes) that tells you that the script is "Creating Topology."  This is done as in this code snippet,</p><p>Open <strong>scratch/myfirst.cc</strong> in your favorite editor and add the line,</p>
<pre>
NS_LOG_INFO ("Creating Topology");
</pre>
<p>right before the lines,</p>
<pre>
NodeContainer nodes;
nodes.Create (2);
</pre>
<p>Now build the script using waf and clear the <strong>NS_LOG</strong> variable to turn off the torrent of logging we previously enabled:</p>
<pre>
./waf
export NS_LOG=
</pre>
<p>Now, if you run the script,</p>
<pre>
./waf --run scratch/myfirst
</pre>
<p>you will <strong>not</strong> see your new message since its associated logging component (<strong>FirstScriptExample</strong>) has not been enabled.  In order to see your message you will have to enable the <strong>FirstScriptExample</strong> logging component with a level greater than or equal to <strong>NS_LOG_INFO</strong>.  If you just want to see this particular level of logging, you can enable it by,</p>
<pre>
export NS_LOG=FirstScriptExample=info
</pre>
<p>If you now run the script you will see your new "Creating Topology" log message,</p>
<pre>
Waf: Entering directory \(ga/home/craigdo/repos/ns-3-allinone/ns-3-dev/build&apos;
Waf: Leaving directory \(ga/home/craigdo/repos/ns-3-allinone/ns-3-dev/build&apos;
&apos;build&apos; finished successfully (0.404s)
Creating Topology
Sent 1024 bytes to 10.1.1.2
Received 1024 bytes from 10.1.1.1
Received 1024 bytes from 10.1.1.2
</pre>

<h3>Using Command Line Arguments</h3>

<h3>Overriding Default Attributes</h3>
<p>Another way you can change how <em>ns-3</em> scripts behave without editing and building is via <em>command line arguments.</em>  We provide a mechanism to parse command line arguments and automatically set local and global variables based on those arguments.</p><p>The first step in using the command line argument system is to declare the command line parser.  This is done quite simply (in your main program) as in the following code,</p>
<pre>
int
main (int argc, char *argv[])
{
  ...

  CommandLine cmd;
  cmd.Parse (argc, argv);

  ...
}
</pre>
<p>This simple two line snippet is actually very useful by itself.  It opens the door to the <em>ns-3</em> global variable and <strong>Attribute</strong> systems.  Go ahead and add that two lines of code to the <strong>scratch/myfirst.cc</strong> script at the start of <strong>main</strong>.  Go ahead and build the script and run it, but ask the script for help in the following way,</p>
<pre>
./waf --run "scratch/myfirst --PrintHelp"
</pre>
<p>This will ask Waf to run the <strong>scratch/myfirst</strong> script and pass the command line argument <strong>--PrintHelp</strong> to the script.  The quotes are required to sort out which program gets which argument.  The command line parser will now see the <strong>--PrintHelp</strong> argument and respond with,</p>
<pre>
Waf: Entering directory \(ga/home/craigdo/repos/ns-3-allinone/ns-3-dev/build&apos;
Waf: Leaving directory \(ga/home/craigdo/repos/ns-3-allinone/ns-3-dev/build&apos;
&apos;build&apos; finished successfully (0.413s)
TcpL4Protocol:TcpStateMachine()
CommandLine:HandleArgument(): Handle arg name=PrintHelp value=
--PrintHelp: Print this help message.
--PrintGroups: Print the list of groups.
--PrintTypeIds: Print all TypeIds.
--PrintGroup=[group]: Print all TypeIds of group.
--PrintAttributes=[typeid]: Print all attributes of typeid.
--PrintGlobals: Print the list of globals.
</pre>
<p>Let&apos;s focus on the <strong>--PrintAttributes</strong> option.  We have already hinted at the <em>ns-3</em> <strong>Attribute</strong> system while walking through the <strong>first.cc</strong> script.  We looked at the following lines of code,</p>
<pre>
PointToPointHelper pointToPoint;
pointToPoint.SetDeviceAttribute ("DataRate", StringValue ("5Mbps"));
pointToPoint.SetChannelAttribute ("Delay", StringValue ("2ms"));
</pre>
<p>and mentioned that <strong>DataRate</strong> was actually an <strong>Attribute</strong> of the <strong>PointToPointNetDevice</strong>.  Let&apos;s use the command line argument parser to take a look at the <strong>Attributes</strong> of the PointToPointNetDevice.  The help listing says that we should provide a <strong>TypeId</strong>.  This corresponds to the class name of the class to which the <strong>Attributes</strong> belong.  In this case it will be <strong>ns3::PointToPointNetDevice</strong>.  Let&apos;s go ahead and type in,</p>
<pre>
./waf --run "scratch/myfirst --PrintAttributes=ns3::PointToPointNetDevice"
</pre>
<p>The system will print out all of the <strong>Attributes</strong> of this kind of net device. Among the <strong>Attributes</strong> you will see listed is,</p>
<pre>
--ns3::PointToPointNetDevice::DataRate=[32768bps]:
  The default data rate for point to point links
</pre>
<p>This is the default value that will be used when a <strong>PointToPointNetDevice</strong> is created in the system.  We overrode this default with the <strong>Attribute</strong> setting in the <strong>PointToPointHelper</strong> above.  Let&apos;s use the default values for the point-to-point devices and channels by deleting the <strong>SetDeviceAttribute</strong> call and the <strong>SetChannelAttribute</strong> call from the <strong>myfirst.cc</strong> we have in the scratch directory.</p><p>Your script should now just declare the <strong>PointToPointHelper</strong> and not do any <strong>set</strong> operations as in the following example,</p>
<pre>
...

NodeContainer nodes;
nodes.Create (2);

PointToPointHelper pointToPoint;

NetDeviceContainer devices;
devices = pointToPoint.Install (nodes);

...
</pre>
<p>Go ahead and build the new script with Waf (<strong>./waf</strong>) and let&apos;s go back and enable some logging from the UDP echo server application and turn on the time prefix.</p>
<pre>
export &apos;NS_LOG=UdpEchoServerApplication=level_all|prefix_time&apos;
</pre>
<p>If you run the script, you should now see the following output,</p>
<pre>
Waf: Entering directory \(ga/home/craigdo/repos/ns-3-allinone/ns-3-dev/build&apos;
Waf: Leaving directory \(ga/home/craigdo/repos/ns-3-allinone/ns-3-dev/build&apos;
&apos;build&apos; finished successfully (0.405s)
0s UdpEchoServerApplication:UdpEchoServer()
1s UdpEchoServerApplication:StartApplication()
Sent 1024 bytes to 10.1.1.2
2.25732s Received 1024 bytes from 10.1.1.1
2.25732s Echoing packet
Received 1024 bytes from 10.1.1.2
10s UdpEchoServerApplication:StopApplication()
UdpEchoServerApplication:DoDispose()
UdpEchoServerApplication:~UdpEchoServer()
</pre>
<p>Recall that the last time we looked at the simulation time at which the packet was received by the echo server, it was at 2.00369 seconds.</p>
<pre>
2.00369s UdpEchoServerApplication:HandleRead(): Received 1024 bytes from 10.1.1.1
</pre>
<p>Now it is receiving the packet at 2.25732 seconds.  This is because we just dropped the data rate of the <strong>PointToPointNetDevice</strong> down to its default of 32768 bits per second from five megabits per second.</p><p>If we were to provide a new <strong>DataRate</strong> using the command line, we could speed our simulation up again.  We do this in the following way, according to the formula implied by the help item:</p>
<pre>
./waf --run "scratch/myfirst --ns3::PointToPointNetDevice::DataRate=5Mbps"
</pre>
<p>This will set the default value of the <strong>DataRate</strong> <strong>Attribute</strong> back to five megabits per second.  Are you surprised by the result?  It turns out that in order to get the original behavior of the script back, we will have to set the speed-of-light delay of the channel as well.  We can ask the command line system to print out the <strong>Attributes</strong> of the channel just like we did for the net device:</p>
<pre>
./waf --run "scratch/myfirst --PrintAttributes=ns3::PointToPointChannel"
</pre>
<p>We discover the <strong>Delay</strong> <strong>Attribute</strong> of the channel is set in the following way:</p>
<pre>
--ns3::PointToPointChannel::Delay=[0ns]:
  Transmission delay through the channel
</pre>
<p>We can then set both of these default values through the command line system,</p>
<pre>
./waf --run "scratch/myfirst
  --ns3::PointToPointNetDevice::DataRate=5Mbps
  --ns3::PointToPointChannel::Delay=2ms"
</pre>
<p>in which case we recover the timing we had when we explicitly set the <strong>DataRate</strong> and <strong>Delay</strong> in the script:</p>
<pre>
Waf: Entering directory \(ga/home/craigdo/repos/ns-3-allinone/ns-3-dev/build&apos;
Waf: Leaving directory \(ga/home/craigdo/repos/ns-3-allinone/ns-3-dev/build&apos;
&apos;build&apos; finished successfully (0.417s)
0s UdpEchoServerApplication:UdpEchoServer()
1s UdpEchoServerApplication:StartApplication()
Sent 1024 bytes to 10.1.1.2
2.00369s Received 1024 bytes from 10.1.1.1
2.00369s Echoing packet
Received 1024 bytes from 10.1.1.2
10s UdpEchoServerApplication:StopApplication()
UdpEchoServerApplication:DoDispose()
UdpEchoServerApplication:~UdpEchoServer()
</pre>
<p>Note that the packet is again received by the server at 2.00369 seconds.  We could actually set any of the <strong>Attributes</strong> used in the script in this way. In particular we could set the <strong>UdpEchoClient Attribute MaxPackets</strong> to some other value than one.</p><p>How would you go about that?  Give it a try.  Remember you have to comment out the place we override the default <strong>Attribute</strong> and explicitly set <strong>MaxPackets</strong> in the script.  Then you have to rebuild the script.  You will also have to find the syntax for actually setting the new default attribute value using the command line help facility.  Once you have this figured out you should be able to control the number of packets echoed from the command line.  Since we&apos;re nice folks, we&apos;ll tell you that your command line should end up looking something like,</p>
<pre>
./waf --run "scratch/myfirst
  --ns3::PointToPointNetDevice::DataRate=5Mbps
  --ns3::PointToPointChannel::Delay=2ms
  --ns3::UdpEchoClient::MaxPackets=2"
</pre>

<h3>Hooking Your Own Values</h3>
<p>You can also add your own hooks to the command line system.  This is done quite simply by using the <strong>AddValue</strong> method to the command line parser.</p><p>Let&apos;s use this facility to specify the number of packets to echo in a completely different way.  Let&apos;s add a local variable called <strong>nPackets</strong> to the <strong>main</strong> function.  We&apos;ll initialize it to one to match our previous default behavior.  To allow the command line parser to change this value, we need to hook the value into the parser.  We do this by adding a call to <strong>AddValue</strong>.  Go ahead and change the <strong>scratch/myfirst.cc</strong> script to start with the following code,</p>
<pre>
int
main (int argc, char *argv[])
{
  uint32_t nPackets = 1;

  CommandLine cmd;
  cmd.AddValue("nPackets", "Number of packets to echo", nPackets);
  cmd.Parse (argc, argv);

  ...
</pre>
<p>Scroll down to the point in the script where we set the <strong>MaxPackets</strong> <strong>Attribute</strong> and change it so that it is set to the variable <strong>nPackets</strong> instead of the constant <strong>1</strong> as is shown below.</p>
<pre>
echoClient.SetAttribute ("MaxPackets", UintegerValue (nPackets));
</pre>
<p>Now if you run the script and provide the <strong>--PrintHelp</strong> argument, you should see your new <strong>User Argument</strong> listed in the help display.</p><p>Try,</p>
<pre>
./waf --run "scratch/myfirst --PrintHelp"
</pre>

<pre>
Waf: Entering directory \(ga/home/craigdo/repos/ns-3-allinone/ns-3-dev/build&apos;
Waf: Leaving directory \(ga/home/craigdo/repos/ns-3-allinone/ns-3-dev/build&apos;
&apos;build&apos; finished successfully (0.403s)
--PrintHelp: Print this help message.
--PrintGroups: Print the list of groups.
--PrintTypeIds: Print all TypeIds.
--PrintGroup=[group]: Print all TypeIds of group.
--PrintAttributes=[typeid]: Print all attributes of typeid.
--PrintGlobals: Print the list of globals.
User Arguments:
    --nPackets: Number of packets to echo
</pre>
<p>If you want to specify the number of packets to echo, you can now do so by setting the <strong>--nPackets</strong> argument in the command line,</p>
<pre>
./waf --run "scratch/myfirst --nPackets=2"
</pre>
<p>You should now see</p>
<pre>
Waf: Entering directory \(ga/home/craigdo/repos/ns-3-allinone/ns-3-dev/build&apos;
Waf: Leaving directory \(ga/home/craigdo/repos/ns-3-allinone/ns-3-dev/build&apos;
&apos;build&apos; finished successfully (0.404s)
0s UdpEchoServerApplication:UdpEchoServer()
1s UdpEchoServerApplication:StartApplication()
Sent 1024 bytes to 10.1.1.2
2.25732s Received 1024 bytes from 10.1.1.1
2.25732s Echoing packet
Received 1024 bytes from 10.1.1.2
Sent 1024 bytes to 10.1.1.2
3.25732s Received 1024 bytes from 10.1.1.1
3.25732s Echoing packet
Received 1024 bytes from 10.1.1.2
10s UdpEchoServerApplication:StopApplication()
UdpEchoServerApplication:DoDispose()
UdpEchoServerApplication:~UdpEchoServer()
</pre>
<p>You have now echoed two packets.  Pretty easy, isn&apos;t it?</p><p>You can see that if you are an <em>ns-3</em> user, you can use the command line argument system to control global values and <strong>Attributes</strong>.  If you are a model author, you can add new <strong>Attributes</strong> to your <strong>Objects</strong> and they will automatically be available for setting by your users through the command line system.  If you are a script author, you can add new variables to your scripts and hook them into the command line system quite painlessly.</p>
<h3>Using the Tracing System</h3>
<p>The whole point of simulation is to generate output for further study, and the <em>ns-3</em> tracing system is a primary mechanism for this.  Since <em>ns-3</em> is a C++ program, standard facilities for generating output from C++ programs could be used:</p>
<pre>
#include &lt;iostream&gt;
...
int main ()
{
  ...
  std::cout &lt;&lt; "The value of x is " &lt;&lt; x &lt;&lt; std::endl;
  ...
}
</pre>
<p>You could even use the logging module to add a little structure to your solution.  There are many well-known problems generated by such approaches and so we have provided a generic event tracing subsystem to address the issues we thought were important.</p><p>The basic goals of the <em>ns-3</em> tracing system are:</p><ul>
<li><p>For basic tasks, the tracing system should allow the user to generate standard tracing for popular tracing sources, and to customize which objects generate the tracing;</p></li><li><p>Intermediate users must be able to extend the tracing system to modify the output format generated, or to insert new tracing sources, without modifying the core of the simulator;</p></li><li><p>Advanced users can modify the simulator core to add new tracing sources and sinks.</p><p>The <em>ns-3</em> tracing system is built on the concepts of independent tracing sources and tracing sinks, and a uniform mechanism for connecting sources to sinks.  Trace sources are entities that can signal events that happen in a simulation and provide access to interesting underlying data. For example, a trace source could indicate when a packet is received by a net device and provide access to the packet contents for interested trace sinks.</p><p>Trace sources are not useful by themselves, they must be "connected" to other pieces of code that actually do something useful with the information provided by the sink.  Trace sinks are consumers of the events and data provided by the trace sources.  For example, one could create a trace sink that would (when connected to the trace source of the previous example) print out interesting parts of the received packet.</p><p>The rationale for this explicit division is to allow users to attach new types of sinks to existing tracing sources, without requiring editing and recompilation of the core of the simulator.  Thus, in the example above, a user could define a new tracing sink in her script and attach it to an existing tracing source defined in the simulation core by editing only the user script.</p><p>In this tutorial, we will walk through some pre-defined sources and sinks and show how they may be customized with little user effort.  See the ns-3 manual or how-to sections for information on advanced tracing configuration including extending the tracing namespace and creating new tracing sources.</p></li>
</ul>
<h3>ASCII Tracing</h3>
<p><em>ns-3</em> provides helper functionality that wraps the low-level tracing system to help you with the details involved in configuring some easily understood packet traces.  If you enable this functionality, you will see output in a ASCII files --- thus the name.  For those familiar with <em>ns-2</em> output, this type of trace is analogous to the <strong>out.tr</strong> generated by many scripts.</p><p>Let&apos;s just jump right in and add some ASCII tracing output to our <strong>scratch/myfirst.cc</strong> script.  Right before the call to <strong>Simulator::Run ()</strong>, add the following lines of code:</p>
<pre>
AsciiTraceHelper ascii;
pointToPoint.EnableAsciiAll (ascii.CreateFileStream ("myfirst.tr"));
</pre>
<p>Like in many other <em>ns-3</em> idioms, this code uses a  helper object to help create ASCII traces.  The second line contains two nested method calls. The "inside" method, <strong>CreateFileStream()</strong> uses an unnamed object idiom to create a file stream object on the stack (without an object  name) and pass it down to the called method.  We&apos;ll go into this more in the future, but all you have to know at this point is that you are creating an object representing a file named "myfirst.tr" and passing it into <strong>ns-3</strong>.  You are telling <strong>ns-3</strong> to deal with the lifetime issues of the created object and also to deal with problems caused by a little-known (intentional) limitation of C++ ofstream objects relating to copy constructors.</p><p>The outside call, to <strong>EnableAsciiAll()</strong>, tells the helper that you want to enable ASCII tracing on all point-to-point devices in your simulation; and you want the (provided) trace sinks to write out information about packet movement in ASCII format.</p><p>For those familiar with <em>ns-2</em>, the traced events are equivalent to the popular trace points that log "+", "-", "d", and "r" events.</p><p>You can now build the script and run it from the command line:</p>
<pre>
./waf --run scratch/myfirst
</pre>
<p>Just as you have seen many times before, you will see some messages from Waf and then "&apos;build&apos; finished successfully" with some number of messages from the running program.</p><p>When it ran, the program will have created a file named <strong>myfirst.tr</strong>. Because of the way that Waf works, the file is not created in the local directory, it is created at the top-level directory of the repository by default.  If you want to control where the traces are saved you can use the <strong>--cwd</strong> option of Waf to specify this.  We have not done so, thus we need to change into the top level directory of our repo and take a look at the ASCII trace file <strong>myfirst.tr</strong> in your favorite editor.</p>
<h3>Parsing Ascii Traces</h3>
<p>There&apos;s a lot of information there in a pretty dense form, but the first thing to notice is that there are a number of distinct lines in this file.  It may be difficult to see this clearly unless you widen your window considerably.</p><p>Each line in the file corresponds to a <em>trace event</em>.  In this case we are tracing events on the <em>transmit queue</em> present in every point-to-point net device in the simulation.  The transmit queue is a queue through which every packet destined for a point-to-point channel must pass. Note that each line in the trace file begins with a lone character (has a space after it).  This character will have the following meaning:</p><ul>
<li><p><strong>+</strong>: An enqueue operation occurred on the device queue;</p></li><li><p><strong>-</strong>: A dequeue operation occurred on the device queue;</p></li><li><p><strong>d</strong>: A packet was dropped, typically because the queue was full;</p></li><li><p><strong>r</strong>: A packet was received by the net device.</p><p>Let&apos;s take a more detailed view of the first line in the trace file.  I&apos;ll break it down into sections (indented for clarity) with a two digit reference number on the left side:</p>
<pre>
00 +
01 2
02 /NodeList/0/DeviceList/0/$ns3::PointToPointNetDevice/TxQueue/Enqueue
03 ns3::PppHeader (
04   Point-to-Point Protocol: IP (0x0021))
05   ns3::Ipv4Header (
06     tos 0x0 ttl 64 id 0 protocol 17 offset 0 flags [none]
07     length: 1052 10.1.1.1 &gt; 10.1.1.2)
08     ns3::UdpHeader (
09       length: 1032 49153 &gt; 9)
10       Payload (size=1024)
</pre>
<p>The first line of this expanded trace event (reference number 00) is the operation.  We have a <strong>+</strong> character, so this corresponds to an <em>enqueue</em> operation on the transmit queue.  The second line (reference 01) is the simulation time expressed in seconds.  You may recall that we asked the <strong>UdpEchoClientApplication</strong> to start sending packets at two seconds.  Here we see confirmation that this is, indeed, happening.</p><p>The next line of the example trace (reference 02) tell us which trace source originated this event (expressed in the tracing namespace).  You can think of the tracing namespace somewhat like you would a filesystem namespace.  The root of the namespace is the <strong>NodeList</strong>.  This corresponds to a container managed in the <em>ns-3</em> core code that contains all of the nodes that are created in a script.  Just as a filesystem may have directories under the root, we may have node numbers in the <strong>NodeList</strong>.  The string <strong>/NodeList/0</strong> therefore refers to the zeroth node in the <strong>NodeList</strong> which we typically think of as "node 0".  In each node there is a list of devices that have been installed.  This list appears next in the namespace. You can see that this trace event comes from <strong>DeviceList/0</strong> which is the zeroth device installed in the node.</p><p>The next string, <strong>$ns3::PointToPointNetDevice</strong> tells you what kind of device is in the zeroth position of the device list for node zero. Recall that the operation <strong>+</strong> found at reference 00 meant that an enqueue operation happened on the transmit queue of the device.  This is reflected in the final segments of the "trace path" which are <strong>TxQueue/Enqueue</strong>.</p><p>The remaining lines in the trace should be fairly intuitive.  References 03-04 indicate that the packet is encapsulated in the point-to-point protocol. References 05-07 show that the packet has an IP version four header and has originated from IP address 10.1.1.1 and is destined for 10.1.1.2.  References 08-09 show that this packet has a UDP header and, finally, reference 10 shows that the payload is the expected 1024 bytes.</p><p>The next line in the trace file shows the same packet being dequeued from the transmit queue on the same node.</p><p>The Third line in the trace file shows the packet being received by the net device on the node with the echo server. I have reproduced that event below.</p>
<pre>
00 r
01 2.25732
02 /NodeList/1/DeviceList/0/$ns3::PointToPointNetDevice/MacRx
03   ns3::Ipv4Header (
04     tos 0x0 ttl 64 id 0 protocol 17 offset 0 flags [none]
05     length: 1052 10.1.1.1 &gt; 10.1.1.2)
06     ns3::UdpHeader (
07       length: 1032 49153 &gt; 9)
08       Payload (size=1024)
</pre>
<p>Notice that the trace operation is now <strong>r</strong> and the simulation time has increased to 2.25732 seconds.  If you have been following the tutorial steps closely this means that you have left the <strong>DataRate</strong> of the net devices and the channel <strong>Delay</strong> set to their default values.  This time should be familiar as you have seen it before in a previous section.</p><p>The trace source namespace entry (reference 02) has changed to reflect that this event is coming from node 1 (<strong>/NodeList/1</strong>) and the packet reception trace source (<strong>/MacRx</strong>).  It should be quite easy for you to follow the progress of the packet through the topology by looking at the rest of the traces in the file.</p></li>
</ul>
<h3>PCAP Tracing</h3>
<p>The <em>ns-3</em> device helpers can also be used to create trace files in the <strong>.pcap</strong> format.  The acronym pcap (usually written in lower case) stands for packet capture, and is actually an API that includes the definition of a <strong>.pcap</strong> file format.  The most popular program that can read and display this format is Wireshark (formerly called Ethereal). However, there are many traffic trace analyzers that use this packet format. We encourage users to exploit the many tools available for analyzing pcap traces.  In this tutorial, we concentrate on viewing pcap traces with tcpdump.</p><p>The code used to enable pcap tracing is a one-liner.</p>
<pre>
pointToPoint.EnablePcapAll ("myfirst");
</pre>
<p>Go ahead and insert this line of code after the ASCII tracing code we just added to <strong>scratch/myfirst.cc</strong>.  Notice that we only passed the string "myfirst," and not "myfirst.pcap" or something similar.  This is because the parameter is a prefix, not a complete file name.  The helper will actually create a trace file for every point-to-point device in the simulation.  The file names will be built using the prefix, the node number, the device number and a ".pcap" suffix.</p><p>In our example script, we will eventually see files named "myfirst-0-0.pcap" and "myfirst-1-0.pcap" which are the pcap traces for node 0-device 0 and node 1-device 0, respectively.</p><p>Once you have added the line of code to enable pcap tracing, you can run the script in the usual way:</p>
<pre>
./waf --run scratch/myfirst
</pre>
<p>If you look at the top level directory of your distribution, you should now see three log files:  <strong>myfirst.tr</strong> is the ASCII trace file we have previously examined.  <strong>myfirst-0-0.pcap</strong> and <strong>myfirst-1-0.pcap</strong> are the new pcap files we just generated.</p>
<h3>Reading output with tcpdump</h3>
<p>The easiest thing to do at this point will be to use <strong>tcpdump</strong> to look at the <strong>pcap</strong> files.</p>
<pre>
tcpdump -nn -tt -r myfirst-0-0.pcap
reading from file myfirst-0-0.pcap, link-type PPP (PPP)
2.000000 IP 10.1.1.1.49153 &gt; 10.1.1.2.9: UDP, length 1024
2.514648 IP 10.1.1.2.9 &gt; 10.1.1.1.49153: UDP, length 1024

tcpdump -nn -tt -r myfirst-1-0.pcap
reading from file myfirst-1-0.pcap, link-type PPP (PPP)
2.257324 IP 10.1.1.1.49153 &gt; 10.1.1.2.9: UDP, length 1024
2.257324 IP 10.1.1.2.9 &gt; 10.1.1.1.49153: UDP, length 1024
</pre>
<p>You can see in the dump of <strong>myfirst-0-0.pcap</strong> (the client device) that the echo packet is sent at 2 seconds into the simulation.  If you look at the second dump (<strong>myfirst-1-0.pcap</strong>) you can see that packet being received at 2.257324 seconds.  You see the packet being echoed back at 2.257324 seconds in the second dump, and finally, you see the packet being received back at the client in the first dump at 2.514648 seconds.</p>
<h3>Reading output with Wireshark</h3>
<p>If you are unfamiliar with Wireshark, there is a web site available from which you can download programs and documentation:  <em>http://www.wireshark.org/</em>.</p><p>Wireshark is a graphical user interface which can be used for displaying these trace files.  If you have Wireshark available, you can open each of the trace files and display the contents as if you had captured the packets using a <em>packet sniffer</em>.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUILDING TOPOLOGIES</h2>
        <div class="sectioncontent">
<h3>Building a Bus Network Topology</h3>
<p>In this section we are going to expand our mastery of <em>ns-3</em> network devices and channels to cover an example of a bus network.  <em>ns-3</em> provides a net device and channel we call CSMA (Carrier Sense Multiple Access).</p><p>The <em>ns-3</em> CSMA device models a simple network in the spirit of Ethernet.  A real Ethernet uses CSMA/CD (Carrier Sense Multiple Access with Collision Detection) scheme with exponentially increasing backoff to contend for the shared transmission medium.  The <em>ns-3</em> CSMA device and channel models only a subset of this.</p><p>Just as we have seen point-to-point topology helper objects when constructing point-to-point topologies, we will see equivalent CSMA topology helpers in this section.  The appearance and operation of these helpers should look quite familiar to you.</p><p>We provide an example script in our examples/tutorial} directory.  This script builds on the <strong>first.cc</strong> script and adds a CSMA network to the point-to-point simulation we&apos;ve already considered.  Go ahead and open <strong>examples/tutorial/second.cc</strong> in your favorite editor.  You will have already seen enough <em>ns-3</em> code to understand most of what is going on in this example, but we will go over the entire script and examine some of the output.</p><p>Just as in the <strong>first.cc</strong> example (and in all ns-3 examples) the file begins with an emacs mode line and some GPL boilerplate.</p><p>The actual code begins by loading module include files just as was done in the <strong>first.cc</strong> example.</p>
<pre>
#include "ns3/core-module.h"
#include "ns3/network-module.h"
#include "ns3/csma-module.h"
#include "ns3/internet-module.h"
#include "ns3/point-to-point-module.h"
#include "ns3/applications-module.h"
#include "ns3/ipv4-global-routing-helper.h"
</pre>
<p>One thing that can be surprisingly useful is a small bit of ASCII art that shows a cartoon of the network topology constructed in the example.  You will find a similar "drawing" in most of our examples.</p><p>In this case, you can see that we are going to extend our point-to-point example (the link between the nodes n0 and n1 below) by hanging a bus network off of the right side.  Notice that this is the default network topology since you can actually vary the number of nodes created on the LAN.  If you set nCsma to one, there will be a total of two nodes on the LAN (CSMA channel) --- one required node and one "extra" node.  By default there are three "extra" nodes as seen below:</p>
<pre>
// Default Network Topology
//
//       10.1.1.0
// n0 -------------- n1   n2   n3   n4
//    point-to-point  |    |    |    |
//                    ================
//                      LAN 10.1.2.0
</pre>
<p>Then the ns-3 namespace is <strong>used</strong> and a logging component is defined. This is all just as it was in <strong>first.cc</strong>, so there is nothing new yet.</p>
<pre>
using namespace ns3;

NS_LOG_COMPONENT_DEFINE ("SecondScriptExample");
</pre>
<p>The main program begins with a slightly different twist.  We use a verbose flag to determine whether or not the <strong>UdpEchoClientApplication</strong> and <strong>UdpEchoServerApplication</strong> logging components are enabled.  This flag defaults to true (the logging components are enabled) but allows us to turn off logging during regression testing of this example.</p><p>You will see some familiar code that will allow you to change the number of devices on the CSMA network via command line argument.  We did something similar when we allowed the number of packets sent to be changed in the section on command line arguments.  The last line makes sure you have at least one "extra" node.</p><p>The code consists of variations of previously covered API so you should be entirely comfortable with the following code at this point in the tutorial.</p>
<pre>
bool verbose = true;
uint32_t nCsma = 3;

CommandLine cmd;
cmd.AddValue ("nCsma", "Number of &#92;"extra&#92;" CSMA nodes/devices", nCsma);
cmd.AddValue ("verbose", "Tell echo applications to log if true", verbose);

cmd.Parse (argc, argv);

if (verbose)
  {
    LogComponentEnable("UdpEchoClientApplication", LOG_LEVEL_INFO);
    LogComponentEnable("UdpEchoServerApplication", LOG_LEVEL_INFO);
  }

nCsma = nCsma == 0 ? 1 : nCsma;
</pre>
<p>The next step is to create two nodes that we will connect via the point-to-point link.  The <strong>NodeContainer</strong> is used to do this just as was done in <strong>first.cc</strong>.</p>
<pre>
NodeContainer p2pNodes;
p2pNodes.Create (2);
</pre>
<p>Next, we declare another <strong>NodeContainer</strong> to hold the nodes that will be part of the bus (CSMA) network.  First, we just instantiate the container object itself.</p>
<pre>
NodeContainer csmaNodes;
csmaNodes.Add (p2pNodes.Get (1));
csmaNodes.Create (nCsma);
</pre>
<p>The next line of code <strong>Gets</strong> the first node (as in having an index of one) from the point-to-point node container and adds it to the container of nodes that will get CSMA devices.  The node in question is going to end up with a point-to-point device <em>and</em> a CSMA device.  We then create a number of "extra" nodes that compose the remainder of the CSMA network.  Since we already have one node in the CSMA network -- the one that will have both a point-to-point and CSMA net device, the number of "extra" nodes means the number nodes you desire in the CSMA section minus one.</p><p>The next bit of code should be quite familiar by now.  We instantiate a <strong>PointToPointHelper</strong> and set the associated default <strong>Attributes</strong> so that we create a five megabit per second transmitter on devices created using the helper and a two millisecond delay on channels created by the helper.</p>
<pre>
PointToPointHelper pointToPoint;
pointToPoint.SetDeviceAttribute ("DataRate", StringValue ("5Mbps"));
pointToPoint.SetChannelAttribute ("Delay", StringValue ("2ms"));

NetDeviceContainer p2pDevices;
p2pDevices = pointToPoint.Install (p2pNodes);
</pre>
<p>We then instantiate a <strong>NetDeviceContainer</strong> to keep track of the point-to-point net devices and we <strong>Install</strong> devices on the point-to-point nodes.</p><p>We mentioned above that you were going to see a helper for CSMA devices and channels, and the next lines introduce them.  The <strong>CsmaHelper</strong> works just like a <strong>PointToPointHelper</strong>, but it creates and connects CSMA devices and channels.  In the case of a CSMA device and channel pair, notice that the data rate is specified by a <em>channel</em> <strong>Attribute</strong> instead of a device <strong>Attribute</strong>.  This is because a real CSMA network does not allow one to mix, for example, 10Base-T and 100Base-T devices on a given channel.  We first set the data rate to 100 megabits per second, and then set the speed-of-light delay of the channel to 6560 nano-seconds (arbitrarily chosen as 1 nanosecond per foot over a 100 meter segment).  Notice that you can set an <strong>Attribute</strong> using its native data type.</p>
<pre>
CsmaHelper csma;
csma.SetChannelAttribute ("DataRate", StringValue ("100Mbps"));
csma.SetChannelAttribute ("Delay", TimeValue (NanoSeconds (6560)));

NetDeviceContainer csmaDevices;
csmaDevices = csma.Install (csmaNodes);
</pre>
<p>Just as we created a <strong>NetDeviceContainer</strong> to hold the devices created by the <strong>PointToPointHelper</strong> we create a <strong>NetDeviceContainer</strong> to hold the devices created by our <strong>CsmaHelper</strong>.  We call the <strong>Install</strong> method of the <strong>CsmaHelper</strong> to install the devices into the nodes of the <strong>csmaNodes NodeContainer</strong>.</p><p>We now have our nodes, devices and channels created, but we have no protocol stacks present.  Just as in the <strong>first.cc</strong> script, we will use the <strong>InternetStackHelper</strong> to install these stacks.</p>
<pre>
InternetStackHelper stack;
stack.Install (p2pNodes.Get (0));
stack.Install (csmaNodes);
</pre>
<p>Recall that we took one of the nodes from the <strong>p2pNodes</strong> container and added it to the <strong>csmaNodes</strong> container.  Thus we only need to install the stacks on the remaining <strong>p2pNodes</strong> node, and all of the nodes in the <strong>csmaNodes</strong> container to cover all of the nodes in the simulation.</p><p>Just as in the <strong>first.cc</strong> example script, we are going to use the <strong>Ipv4AddressHelper</strong> to assign IP addresses to our device interfaces. First we use the network 10.1.1.0 to create the two addresses needed for our two point-to-point devices.</p>
<pre>
Ipv4AddressHelper address;
address.SetBase ("10.1.1.0", "255.255.255.0");
Ipv4InterfaceContainer p2pInterfaces;
p2pInterfaces = address.Assign (p2pDevices);
</pre>
<p>Recall that we save the created interfaces in a container to make it easy to pull out addressing information later for use in setting up the applications.</p><p>We now need to assign IP addresses to our CSMA device interfaces.  The operation works just as it did for the point-to-point case, except we now are performing the operation on a container that has a variable number of CSMA devices --- remember we made the number of CSMA devices changeable by command line argument.  The CSMA devices will be associated with IP addresses from network number 10.1.2.0 in this case, as seen below.</p>
<pre>
address.SetBase ("10.1.2.0", "255.255.255.0");
Ipv4InterfaceContainer csmaInterfaces;
csmaInterfaces = address.Assign (csmaDevices);
</pre>
<p>Now we have a topology built, but we need applications.  This section is going to be fundamentally similar to the applications section of <strong>first.cc</strong> but we are going to instantiate the server on one of the nodes that has a CSMA device and the client on the node having only a point-to-point device.</p><p>First, we set up the echo server.  We create a <strong>UdpEchoServerHelper</strong> and provide a required <strong>Attribute</strong> value to the constructor which is the server port number.  Recall that this port can be changed later using the <strong>SetAttribute</strong> method if desired, but we require it to be provided to the constructor.</p>
<pre>
UdpEchoServerHelper echoServer (9);

ApplicationContainer serverApps = echoServer.Install (csmaNodes.Get (nCsma));
serverApps.Start (Seconds (1.0));
serverApps.Stop (Seconds (10.0));
</pre>
<p>Recall that the <strong>csmaNodes NodeContainer</strong> contains one of the nodes created for the point-to-point network and <strong>nCsma</strong> "extra" nodes. What we want to get at is the last of the "extra" nodes.  The zeroth entry of the <strong>csmaNodes</strong> container will be the point-to-point node.  The easy way to think of this, then, is if we create one "extra" CSMA node, then it will be at index one of the <strong>csmaNodes</strong> container.  By induction, if we create <strong>nCsma</strong> "extra" nodes the last one will be at index <strong>nCsma</strong>.  You see this exhibited in the <strong>Get</strong> of the first line of code.</p><p>The client application is set up exactly as we did in the <strong>first.cc</strong> example script.  Again, we provide required <strong>Attributes</strong> to the <strong>UdpEchoClientHelper</strong> in the constructor (in this case the remote address and port).  We tell the client to send packets to the server we just installed on the last of the "extra" CSMA nodes.  We install the client on the leftmost point-to-point node seen in the topology illustration.</p>
<pre>
UdpEchoClientHelper echoClient (csmaInterfaces.GetAddress (nCsma), 9);
echoClient.SetAttribute ("MaxPackets", UintegerValue (1));
echoClient.SetAttribute ("Interval", TimeValue (Seconds (1.0)));
echoClient.SetAttribute ("PacketSize", UintegerValue (1024));

ApplicationContainer clientApps = echoClient.Install (p2pNodes.Get (0));
clientApps.Start (Seconds (2.0));
clientApps.Stop (Seconds (10.0));
</pre>
<p>Since we have actually built an internetwork here, we need some form of internetwork routing.  <em>ns-3</em> provides what we call global routing to help you out.  Global routing takes advantage of the fact that the entire internetwork is accessible in the simulation and runs through the all of the nodes created for the simulation --- it does the hard work of setting up routing for you without having to configure routers.</p><p>Basically, what happens is that each node behaves as if it were an OSPF router that communicates instantly and magically with all other routers behind the scenes.  Each node generates link advertisements and communicates them directly to a global route manager which uses this global information to construct the routing tables for each node.  Setting up this form of routing is a one-liner:</p>
<pre>
Ipv4GlobalRoutingHelper::PopulateRoutingTables ();
</pre>
<p>Next we enable pcap tracing.  The first line of code to enable pcap tracing in the point-to-point helper should be familiar to you by now.  The second line enables pcap tracing in the CSMA helper and there is an extra parameter you haven&apos;t encountered yet.</p>
<pre>
pointToPoint.EnablePcapAll ("second");
csma.EnablePcap ("second", csmaDevices.Get (1), true);
</pre>
<p>The CSMA network is a multi-point-to-point network.  This means that there can (and are in this case) multiple endpoints on a shared medium.  Each of these endpoints has a net device associated with it.  There are two basic alternatives to gathering trace information from such a network.  One way is to create a trace file for each net device and store only the packets that are emitted or consumed by that net device.  Another way is to pick one of the devices and place it in promiscuous mode.  That single device then "sniffs" the network for all packets and stores them in a single pcap file.  This is how <strong>tcpdump</strong>, for example, works.  That final parameter tells the CSMA helper whether or not to arrange to capture packets in promiscuous mode.</p><p>In this example, we are going to select one of the devices on the CSMA network and ask it to perform a promiscuous sniff of the network, thereby emulating what <strong>tcpdump</strong> would do.  If you were on a Linux machine you might do something like <strong>tcpdump -i eth0</strong> to get the trace. In this case, we specify the device using <strong>csmaDevices.Get</strong>(1)</strong>, which selects the first device in the container.  Setting the final parameter to true enables promiscuous captures.</p><p>The last section of code just runs and cleans up the simulation just like the <strong>first.cc</strong> example.</p>
<pre>
  Simulator::Run ();
  Simulator::Destroy ();
  return 0;
}
</pre>
<p>In order to run this example, copy the <strong>second.cc</strong> example script into the scratch directory and use waf to build just as you did with the <strong>first.cc</strong> example.  If you are in the top-level directory of the repository you just type,</p>
<pre>
cp examples/tutorial/second.cc scratch/mysecond.cc
./waf
</pre>
<p>Warning:  We use the file <strong>second.cc</strong> as one of our regression tests to verify that it works exactly as we think it should in order to make your tutorial experience a positive one.  This means that an executable named <strong>second</strong> already exists in the project.  To avoid any confusion about what you are executing, please do the renaming to <strong>mysecond.cc</strong> suggested above.</p><p>If you are following the tutorial religiously (you are, aren&apos;t you) you will still have the NS_LOG variable set, so go ahead and clear that variable and run the program.</p>
<pre>
export NS_LOG=
./waf --run scratch/mysecond
</pre>
<p>Since we have set up the UDP echo applications to log just as we did in <strong>first.cc</strong>, you will see similar output when you run the script.</p>
<pre>
Waf: Entering directory \(ga/home/craigdo/repos/ns-3-allinone/ns-3-dev/build&apos;
Waf: Leaving directory \(ga/home/craigdo/repos/ns-3-allinone/ns-3-dev/build&apos;
&apos;build&apos; finished successfully (0.415s)
Sent 1024 bytes to 10.1.2.4
Received 1024 bytes from 10.1.1.1
Received 1024 bytes from 10.1.2.4
</pre>
<p>Recall that the first message, "<strong>Sent 1024 bytes to 10.1.2.4</strong>," is the UDP echo client sending a packet to the server.  In this case, the server is on a different network (10.1.2.0).  The second message, "<strong>Received 1024</strong> bytes from 10.1.1.1," is from the UDP echo server, generated when it receives the echo packet.  The final message, "<strong>Received 1024 bytes from 10.1.2.4</strong>," is from the echo client, indicating that it has received its echo back from the server.</p><p>If you now go and look in the top level directory, you will find three trace files:</p>
<pre>
second-0-0.pcap  second-1-0.pcap  second-2-0.pcap
</pre>
<p>Let&apos;s take a moment to look at the naming of these files.  They all have the same form, <strong>&lt;name&gt;-&lt;node&gt;-&lt;device&gt;.pcap</strong>.  For example, the first file in the listing is <strong>second-0-0.pcap</strong> which is the pcap trace from node zero, device zero.  This is the point-to-point net device on node zero.  The file <strong>second-1-0.pcap</strong> is the pcap trace for device zero on node one, also a point-to-point net device; and the file <strong>second-2-0.pcap</strong> is the pcap trace for device zero on node two.</p><p>If you refer back to the topology illustration at the start of the section, you will see that node zero is the leftmost node of the point-to-point link and node one is the node that has both a point-to-point device and a CSMA device.  You will see that node two is the first "extra" node on the CSMA network and its device zero was selected as the device to capture the promiscuous-mode trace.</p><p>Now, let&apos;s follow the echo packet through the internetwork.  First, do a tcpdump of the trace file for the leftmost point-to-point node --- node zero.</p>
<pre>
tcpdump -nn -tt -r second-0-0.pcap
</pre>
<p>You should see the contents of the pcap file displayed:</p>
<pre>
reading from file second-0-0.pcap, link-type PPP (PPP)
2.000000 IP 10.1.1.1.49153 &gt; 10.1.2.4.9: UDP, length 1024
2.007602 IP 10.1.2.4.9 &gt; 10.1.1.1.49153: UDP, length 1024
</pre>
<p>The first line of the dump indicates that the link type is PPP (point-to-point) which we expect.  You then see the echo packet leaving node zero via the device associated with IP address 10.1.1.1 headed for IP address 10.1.2.4 (the rightmost CSMA node).  This packet will move over the point-to-point link and be received by the point-to-point net device on node one.  Let&apos;s take a look:</p>
<pre>
tcpdump -nn -tt -r second-1-0.pcap
</pre>
<p>You should now see the pcap trace output of the other side of the point-to-point link:</p>
<pre>
reading from file second-1-0.pcap, link-type PPP (PPP)
2.003686 IP 10.1.1.1.49153 &gt; 10.1.2.4.9: UDP, length 1024
2.003915 IP 10.1.2.4.9 &gt; 10.1.1.1.49153: UDP, length 1024
</pre>
<p>Here we see that the link type is also PPP as we would expect.  You see the packet from IP address 10.1.1.1 (that was sent at 2.000000 seconds) headed toward IP address 10.1.2.4 appear on this interface.  Now, internally to this node, the packet will be forwarded to the CSMA interface and we should see it pop out on that device headed for its ultimate destination.</p><p>Remember that we selected node 2 as the promiscuous sniffer node for the CSMA network so let&apos;s then look at second-2-0.pcap and see if its there.</p>
<pre>
tcpdump -nn -tt -r second-2-0.pcap
</pre>
<p>You should now see the promiscuous dump of node two, device zero:</p>
<pre>
reading from file second-2-0.pcap, link-type EN10MB (Ethernet)
2.003696 arp who-has 10.1.2.4 (ff:ff:ff:ff:ff:ff) tell 10.1.2.1
2.003707 arp reply 10.1.2.4 is-at 00:00:00:00:00:06
2.003801 IP 10.1.1.1.49153 &gt; 10.1.2.4.9: UDP, length 1024
2.003811 arp who-has 10.1.2.1 (ff:ff:ff:ff:ff:ff) tell 10.1.2.4
2.003822 arp reply 10.1.2.1 is-at 00:00:00:00:00:03
2.003915 IP 10.1.2.4.9 &gt; 10.1.1.1.49153: UDP, length 1024
</pre>
<p>As you can see, the link type is now "Ethernet".  Something new has appeared, though.  The bus network needs <strong>ARP</strong>, the Address Resolution Protocol. Node one knows it needs to send the packet to IP address 10.1.2.4, but it doesn&apos;t know the MAC address of the corresponding node.  It broadcasts on the CSMA network (ff:ff:ff:ff:ff:ff) asking for the device that has IP address 10.1.2.4.  In this case, the rightmost node replies saying it is at MAC address 00:00:00:00:00:06.  Note that node two is not directly involved in this exchange, but is sniffing the network and reporting all of the traffic it sees.</p><p>This exchange is seen in the following lines,</p>
<pre>
2.003696 arp who-has 10.1.2.4 (ff:ff:ff:ff:ff:ff) tell 10.1.2.1
2.003707 arp reply 10.1.2.4 is-at 00:00:00:00:00:06
</pre>
<p>Then node one, device one goes ahead and sends the echo packet to the UDP echo server at IP address 10.1.2.4.</p>
<pre>
2.003801 IP 10.1.1.1.49153 &gt; 10.1.2.4.9: UDP, length 1024
</pre>
<p>The server receives the echo request and turns the packet around trying to send it back to the source.  The server knows that this address is on another network that it reaches via IP address 10.1.2.1.  This is because we initialized global routing and it has figured all of this out for us.  But, the echo server node doesn&apos;t know the MAC address of the first CSMA node, so it has to ARP for it just like the first CSMA node had to do.</p>
<pre>
2.003811 arp who-has 10.1.2.1 (ff:ff:ff:ff:ff:ff) tell 10.1.2.4
2.003822 arp reply 10.1.2.1 is-at 00:00:00:00:00:03
</pre>
<p>The server then sends the echo back to the forwarding node.</p>
<pre>
2.003915 IP 10.1.2.4.9 &gt; 10.1.1.1.49153: UDP, length 1024
</pre>
<p>Looking back at the rightmost node of the point-to-point link,</p>
<pre>
tcpdump -nn -tt -r second-1-0.pcap
</pre>
<p>You can now see the echoed packet coming back onto the point-to-point link as the last line of the trace dump.</p>
<pre>
reading from file second-1-0.pcap, link-type PPP (PPP)
2.003686 IP 10.1.1.1.49153 &gt; 10.1.2.4.9: UDP, length 1024
2.003915 IP 10.1.2.4.9 &gt; 10.1.1.1.49153: UDP, length 1024
</pre>
<p>Lastly, you can look back at the node that originated the echo</p>
<pre>
tcpdump -nn -tt -r second-0-0.pcap
</pre>
<p>and see that the echoed packet arrives back at the source at 2.007602 seconds,</p>
<pre>
reading from file second-0-0.pcap, link-type PPP (PPP)
2.000000 IP 10.1.1.1.49153 &gt; 10.1.2.4.9: UDP, length 1024
2.007602 IP 10.1.2.4.9 &gt; 10.1.1.1.49153: UDP, length 1024
</pre>
<p>Finally, recall that we added the ability to control the number of CSMA devices in the simulation by command line argument.  You can change this argument in the same way as when we looked at changing the number of packets echoed in the <strong>first.cc</strong> example.  Try running the program with the number of "extra" devices set to four:</p>
<pre>
./waf --run "scratch/mysecond --nCsma=4"
</pre>
<p>You should now see,</p>
<pre>
Waf: Entering directory \(ga/home/craigdo/repos/ns-3-allinone/ns-3-dev/build&apos;
Waf: Leaving directory \(ga/home/craigdo/repos/ns-3-allinone/ns-3-dev/build&apos;
&apos;build&apos; finished successfully (0.405s)
Sent 1024 bytes to 10.1.2.5
Received 1024 bytes from 10.1.1.1
Received 1024 bytes from 10.1.2.5
</pre>
<p>Notice that the echo server has now been relocated to the last of the CSMA nodes, which is 10.1.2.5 instead of the default case, 10.1.2.4.</p><p>It is possible that you may not be satisfied with a trace file generated by a bystander in the CSMA network.  You may really want to get a trace from a single device and you may not be interested in any other traffic on the network.  You can do this fairly easily.</p><p>Let&apos;s take a look at <strong>scratch/mysecond.cc</strong> and add that code enabling us to be more specific.  <strong>ns-3</strong> helpers provide methods that take a node number and device number as parameters.  Go ahead and replace the <strong>EnablePcap</strong> calls with the calls below.</p>
<pre>
pointToPoint.EnablePcap ("second", p2pNodes.Get (0)-&gt;GetId (), 0);
csma.EnablePcap ("second", csmaNodes.Get (nCsma)-&gt;GetId (), 0, false);
csma.EnablePcap ("second", csmaNodes.Get (nCsma-1)-&gt;GetId (), 0, false);
</pre>
<p>We know that we want to create a pcap file with the base name "second" and we also know that the device of interest in both cases is going to be zero, so those parameters are not really interesting.</p><p>In order to get the node number, you have two choices:  first, nodes are numbered in a monotonically increasing fashion starting from zero in the order in which you created them.  One way to get a node number is to figure this number out "manually" by contemplating the order of node creation. If you take a look at the network topology illustration at the beginning of the file, we did this for you and you can see that the last CSMA node is going to be node number <strong>nCsma + 1</strong>.  This approach can become annoyingly difficult in larger simulations.</p><p>An alternate way, which we use here, is to realize that the <strong>NodeContainers</strong> contain pointers to <em>ns-3</em> <strong>Node</strong> Objects. The <strong>Node</strong> Object has a method called <strong>GetId</strong> which will return that node&apos;s ID, which is the node number we seek.  Let&apos;s go take a look at the Doxygen for the <strong>Node</strong> and locate that method, which is further down in the <em>ns-3</em> core code than we&apos;ve seen so far; but sometimes you have to search diligently for useful things.</p><p>Go to the Doxygen documentation for your release (recall that you can find it on the project web site).  You can get to the <strong>Node</strong> documentation by looking through at the "Classes" tab and scrolling down the "Class List" until you find <strong>ns3::Node</strong>.  Select <strong>ns3::Node</strong> and you will be taken to the documentation for the <strong>Node</strong> class.  If you now scroll down to the <strong>GetId</strong> method and select it, you will be taken to the detailed documentation for the method.  Using the <strong>GetId</strong> method can make determining node numbers much easier in complex topologies.</p><p>Let&apos;s clear the old trace files out of the top-level directory to avoid confusion about what is going on,</p>
<pre>
rm *.pcap
rm *.tr
</pre>
<p>If you build the new script and run the simulation setting <strong>nCsma</strong> to 100,</p>
<pre>
./waf --run "scratch/mysecond --nCsma=100"
</pre>
<p>you will see the following output:</p>
<pre>
Waf: Entering directory \(ga/home/craigdo/repos/ns-3-allinone/ns-3-dev/build&apos;
Waf: Leaving directory \(ga/home/craigdo/repos/ns-3-allinone/ns-3-dev/build&apos;
&apos;build&apos; finished successfully (0.407s)
Sent 1024 bytes to 10.1.2.101
Received 1024 bytes from 10.1.1.1
Received 1024 bytes from 10.1.2.101
</pre>
<p>Note that the echo server is now located at 10.1.2.101 which corresponds to having 100 "extra" CSMA nodes with the echo server on the last one.  If you list the pcap files in the top level directory you will see,</p>
<pre>
second-0-0.pcap  second-100-0.pcap  second-101-0.pcap
</pre>
<p>The trace file <strong>second-0-0.pcap</strong> is the "leftmost" point-to-point device which is the echo packet source.  The file <strong>second-101-0.pcap</strong> corresponds to the rightmost CSMA device which is where the echo server resides.  You may have noticed that the final parameter on the call to enable pcap tracing on the echo server node was false.  This means that the trace gathered on that node was in non-promiscuous mode.</p><p>To illustrate the difference between promiscuous and non-promiscuous traces, we also requested a non-promiscuous trace for the next-to-last node.  Go ahead and take a look at the <strong>tcpdump</strong> for <strong>second-100-0.pcap</strong>.</p>
<pre>
tcpdump -nn -tt -r second-100-0.pcap
</pre>
<p>You can now see that node 100 is really a bystander in the echo exchange.  The only packets that it receives are the ARP requests which are broadcast to the entire CSMA network.</p>
<pre>
reading from file second-100-0.pcap, link-type EN10MB (Ethernet)
2.003696 arp who-has 10.1.2.101 (ff:ff:ff:ff:ff:ff) tell 10.1.2.1
2.003811 arp who-has 10.1.2.1 (ff:ff:ff:ff:ff:ff) tell 10.1.2.101
</pre>
<p>Now take a look at the <strong>tcpdump</strong> for <strong>second-101-0.pcap</strong>.</p>
<pre>
tcpdump -nn -tt -r second-101-0.pcap
</pre>
<p>You can now see that node 101 is really the participant in the echo exchange.</p>
<pre>
reading from file second-101-0.pcap, link-type EN10MB (Ethernet)
2.003696 arp who-has 10.1.2.101 (ff:ff:ff:ff:ff:ff) tell 10.1.2.1
2.003696 arp reply 10.1.2.101 is-at 00:00:00:00:00:67
2.003801 IP 10.1.1.1.49153 &gt; 10.1.2.101.9: UDP, length 1024
2.003801 arp who-has 10.1.2.1 (ff:ff:ff:ff:ff:ff) tell 10.1.2.101
2.003822 arp reply 10.1.2.1 is-at 00:00:00:00:00:03
2.003822 IP 10.1.2.101.9 &gt; 10.1.1.1.49153: UDP, length 1024
</pre>

<h3>Models, Attributes and Reality</h3>
<p>This is a convenient place to make a small excursion and make an important point.  It may or may not be obvious to you, but whenever one is using a simulation, it is important to understand exactly what is being modeled and what is not.  It is tempting, for example, to think of the CSMA devices and channels used in the previous section as if they were real Ethernet devices; and to expect a simulation result to directly reflect what will happen in a real Ethernet.  This is not the case.</p><p>A model is, by definition, an abstraction of reality.  It is ultimately the responsibility of the simulation script author to determine the so-called "range of accuracy" and "domain of applicability" of the simulation as a whole, and therefore its constituent parts.</p><p>In some cases, like <strong>Csma</strong>, it can be fairly easy to determine what is <em>not</em> modeled.  By reading the model description (<strong>csma.h</strong>) you can find that there is no collision detection in the CSMA model and decide on how applicable its use will be in your simulation or what caveats you may want to include with your results.  In other cases, it can be quite easy to configure behaviors that might not agree with any reality you can go out and buy.  It will prove worthwhile to spend some time investigating a few such instances, and how easily you can swerve outside the bounds of reality in your simulations.</p><p>As you have seen, <em>ns-3</em> provides <strong>Attributes</strong> which a user can easily set to change model behavior.  Consider two of the <strong>Attributes</strong> of the <strong>CsmaNetDevice</strong>:  <strong>Mtu</strong> and <strong>EncapsulationMode</strong>. The <strong>Mtu</strong> attribute indicates the Maximum Transmission Unit to the device.  This is the size of the largest Protocol Data Unit (PDU) that the device can send.</p><p>The MTU defaults to 1500 bytes in the <strong>CsmaNetDevice</strong>.  This default corresponds to a number found in RFC 894, "A Standard for the Transmission of IP Datagrams over Ethernet Networks."  The number is actually derived from the maximum packet size for 10Base5 (full-spec Ethernet) networks -- 1518 bytes.  If you subtract the DIX encapsulation overhead for Ethernet packets (18 bytes) you will end up with a maximum possible data size (MTU) of 1500 bytes.  One can also find that the <strong>MTU</strong> for IEEE 802.3 networks is 1492 bytes.  This is because LLC/SNAP encapsulation adds an extra eight bytes of overhead to the packet.  In both cases, the underlying hardware can only send 1518 bytes, but the data size is different.</p><p>In order to set the encapsulation mode, the <strong>CsmaNetDevice</strong> provides an <strong>Attribute</strong> called <strong>EncapsulationMode</strong> which can take on the values <strong>Dix</strong> or <strong>Llc</strong>.  These correspond to Ethernet and LLC/SNAP framing respectively.</p><p>If one leaves the <strong>Mtu</strong> at 1500 bytes and changes the encapsulation mode to <strong>Llc</strong>, the result will be a network that encapsulates 1500 byte PDUs with LLC/SNAP framing resulting in packets of 1526 bytes, which would be illegal in many networks, since they can transmit a maximum of 1518 bytes per packet.  This would most likely result in a simulation that quite subtly does not reflect the reality you might be expecting.</p><p>Just to complicate the picture, there exist jumbo frames (1500 &lt; MTU &lt;= 9000 bytes) and super-jumbo (MTU &gt; 9000 bytes) frames that are not officially sanctioned by IEEE but are available in some high-speed (Gigabit) networks and NICs.  One could leave the encapsulation mode set to <strong>Dix</strong>, and set the <strong>Mtu</strong> <strong>Attribute</strong> on a <strong>CsmaNetDevice</strong> to 64000 bytes -- even though an associated <strong>CsmaChannel DataRate</strong> was set at 10 megabits per second. This would essentially model an Ethernet switch made out of vampire-tapped 1980s-style 10Base5 networks that support super-jumbo datagrams.  This is certainly not something that was ever made, nor is likely to ever be made, but it is quite easy for you to configure.</p><p>In the previous example, you used the command line to create a simulation that had 100 <strong>Csma</strong> nodes.  You could have just as easily created a simulation with 500 nodes.  If you were actually modeling that 10Base5 vampire-tap network, the maximum length of a full-spec Ethernet cable is 500 meters, with a minimum tap spacing of 2.5 meters.  That means there could only be 200 taps on a real network.  You could have quite easily built an illegal network in that way as well.  This may or may not result in a meaningful simulation depending on what you are trying to model.</p><p>Similar situations can occur in many places in <em>ns-3</em> and in any simulator.  For example, you may be able to position nodes in such a way that they occupy the same space at the same time, or you may be able to configure amplifiers or noise levels that violate the basic laws of physics.</p><p><em>ns-3</em> generally favors flexibility, and many models will allow freely setting <strong>Attributes</strong> without trying to enforce any arbitrary consistency or particular underlying spec.</p><p>The thing to take home from this is that <em>ns-3</em> is going to provide a super-flexible base for you to experiment with.  It is up to you to understand what you are asking the system to do and to  make sure that the simulations you create have some meaning and some connection with a reality defined by you.</p>
<h3>Building a Wireless Network Topology</h3>
<p>In this section we are going to further expand our knowledge of <em>ns-3</em> network devices and channels to cover an example of a wireless network. <em>ns-3</em> provides a set of 802.11 models that attempt to provide an accurate MAC-level implementation of the 802.11 specification and a "not-so-slow" PHY-level model of the 802.11a specification.</p><p>Just as we have seen both point-to-point and CSMA topology helper objects when constructing point-to-point topologies, we will see equivalent <strong>Wifi</strong> topology helpers in this section.  The appearance and operation of these helpers should look quite familiar to you.</p><p>We provide an example script in our <strong>examples/tutorial</strong> directory.  This script builds on the <strong>second.cc</strong> script and adds a Wifi network.  Go ahead and open <strong>examples/tutorial/third.cc</strong> in your favorite editor.  You will have already seen enough <em>ns-3</em> code to understand most of what is going on in this example, but there are a few new things, so we will go over the entire script and examine some of the output.</p><p>Just as in the <strong>second.cc</strong> example (and in all <em>ns-3</em> examples) the file begins with an emacs mode line and some GPL boilerplate.</p><p>Take a look at the ASCII art (reproduced below) that shows the default network topology constructed in the example.  You can see that we are going to further extend our example by hanging a wireless network off of the left side. Notice that this is a default network topology since you can actually vary the number of nodes created on the wired and wireless networks.  Just as in the <strong>second.cc</strong> script case, if you change <strong>nCsma</strong>, it will give you a number of "extra" CSMA nodes.  Similarly, you can set <strong>nWifi</strong> to control how many <strong>STA</strong> (station) nodes are created in the simulation. There will always be one <strong>AP</strong> (access point) node on the wireless network.  By default there are three "extra" CSMA nodes and three wireless <strong>STA</strong> nodes.</p><p>The code begins by loading module include files just as was done in the <strong>second.cc</strong> example.  There are a couple of new includes corresponding to the Wifi module and the mobility module which we will discuss below.</p>
<pre>
#include "ns3/core-module.h"
#include "ns3/point-to-point-module.h"
#include "ns3/network-module.h"
#include "ns3/applications-module.h"
#include "ns3/wifi-module.h"
#include "ns3/mobility-module.h"
#include "ns3/csma-module.h"
#include "ns3/internet-module.h"
</pre>
<p>The network topology illustration follows:</p>
<pre>
// Default Network Topology
//
//   Wifi 10.1.3.0
//                 AP
//  *    *    *    *
//  |    |    |    |    10.1.1.0
// n5   n6   n7   n0 -------------- n1   n2   n3   n4
//                   point-to-point  |    |    |    |
//                                   ================
//                                     LAN 10.1.2.0
</pre>
<p>You can see that we are adding a new network device to the node on the left side of the point-to-point link that becomes the access point for the wireless network.  A number of wireless STA nodes are created to fill out the new 10.1.3.0 network as shown on the left side of the illustration.</p><p>After the illustration, the <strong>ns-3</strong> namespace is <strong>used</strong> and a logging component is defined.  This should all be quite familiar by now.</p>
<pre>
using namespace ns3;

NS_LOG_COMPONENT_DEFINE ("ThirdScriptExample");
</pre>
<p>The main program begins just like <strong>second.cc</strong> by adding some command line parameters for enabling or disabling logging components and for changing the number of devices created.</p>
<pre>
bool verbose = true;
uint32_t nCsma = 3;
uint32_t nWifi = 3;

CommandLine cmd;
cmd.AddValue ("nCsma", "Number of &#92;"extra&#92;" CSMA nodes/devices", nCsma);
cmd.AddValue ("nWifi", "Number of wifi STA devices", nWifi);
cmd.AddValue ("verbose", "Tell echo applications to log if true", verbose);

cmd.Parse (argc,argv);

if (verbose)
  {
    LogComponentEnable("UdpEchoClientApplication", LOG_LEVEL_INFO);
    LogComponentEnable("UdpEchoServerApplication", LOG_LEVEL_INFO);
  }
</pre>
<p>Just as in all of the previous examples, the next step is to create two nodes that we will connect via the point-to-point link.</p>
<pre>
NodeContainer p2pNodes;
p2pNodes.Create (2);
</pre>
<p>Next, we see an old friend.  We instantiate a <strong>PointToPointHelper</strong> and set the associated default <strong>Attributes</strong> so that we create a five megabit per second transmitter on devices created using the helper and a two millisecond delay on channels created by the helper.  We then <strong>Intall</strong> the devices on the nodes and the channel between them.</p>
<pre>
PointToPointHelper pointToPoint;
pointToPoint.SetDeviceAttribute ("DataRate", StringValue ("5Mbps"));
pointToPoint.SetChannelAttribute ("Delay", StringValue ("2ms"));

NetDeviceContainer p2pDevices;
p2pDevices = pointToPoint.Install (p2pNodes);
</pre>
<p>Next, we declare another <strong>NodeContainer</strong> to hold the nodes that will be part of the bus (CSMA) network.</p>
<pre>
NodeContainer csmaNodes;
csmaNodes.Add (p2pNodes.Get (1));
csmaNodes.Create (nCsma);
</pre>
<p>The next line of code <strong>Gets</strong> the first node (as in having an index of one) from the point-to-point node container and adds it to the container of nodes that will get CSMA devices.  The node in question is going to end up with a point-to-point device and a CSMA device.  We then create a number of "extra" nodes that compose the remainder of the CSMA network.</p><p>We then instantiate a <strong>CsmaHelper</strong> and set its <strong>Attributes</strong> as we did in the previous example.  We create a <strong>NetDeviceContainer</strong> to keep track of the created CSMA net devices and then we <strong>Install</strong> CSMA devices on the selected nodes.</p>
<pre>
CsmaHelper csma;
csma.SetChannelAttribute ("DataRate", StringValue ("100Mbps"));
csma.SetChannelAttribute ("Delay", TimeValue (NanoSeconds (6560)));

NetDeviceContainer csmaDevices;
csmaDevices = csma.Install (csmaNodes);
</pre>
<p>Next, we are going to create the nodes that will be part of the Wifi network. We are going to create a number of "station" nodes as specified by the command line argument, and we are going to use the "leftmost" node of the point-to-point link as the node for the access point.</p>
<pre>
NodeContainer wifiStaNodes;
wifiStaNodes.Create (nWifi);
NodeContainer wifiApNode = p2pNodes.Get (0);
</pre>
<p>The next bit of code constructs the wifi devices and the interconnection channel between these wifi nodes. First, we configure the PHY and channel helpers:</p>
<pre>
YansWifiChannelHelper channel = YansWifiChannelHelper::Default ();
YansWifiPhyHelper phy = YansWifiPhyHelper::Default ();
</pre>
<p>For simplicity, this code uses the default PHY layer configuration and channel models which are documented in the API doxygen documentation for the <strong>YansWifiChannelHelper::Default</strong> and <strong>YansWifiPhyHelper::Default</strong> methods. Once these objects are created, we create a channel object and associate it to our PHY layer object manager to make sure that all the PHY layer objects created by the <strong>YansWifiPhyHelper</strong> share the same underlying channel, that is, they share the same wireless medium and can communication and interfere:</p>
<pre>
phy.SetChannel (channel.Create ());
</pre>
<p>Once the PHY helper is configured, we can focus on the MAC layer. Here we choose to work with non-Qos MACs so we use a NqosWifiMacHelper object to set MAC parameters.</p>
<pre>
WifiHelper wifi = WifiHelper::Default ();
wifi.SetRemoteStationManager ("ns3::AarfWifiManager");

NqosWifiMacHelper mac = NqosWifiMacHelper::Default ();
</pre>
<p>The <strong>SetRemoteStationManager</strong> method tells the helper the type of rate control algorithm to use.  Here, it is asking the helper to use the AARF algorithm --- details are, of course, available in Doxygen.</p><p>Next, we configure the type of MAC, the SSID of the infrastructure network we want to setup and make sure that our stations don&apos;t perform active probing:</p>
<pre>
Ssid ssid = Ssid ("ns-3-ssid");
mac.SetType ("ns3::StaWifiMac",
  "Ssid", SsidValue (ssid),
  "ActiveProbing", BooleanValue (false));
</pre>
<p>This code first creates an 802.11 service set identifier (SSID) object that will be used to set the value of the "Ssid" <strong>Attribute</strong> of the MAC layer implementation.  The particular kind of MAC layer that will be created by the helper is specified by <strong>Attribute</strong> as being of the "ns3::StaWifiMac" type.  The use of <strong>NqosWifiMacHelper</strong> will ensure that the "QosSupported" <strong>Attribute</strong> for created MAC objects is set false. The combination of these two configurations means that the MAC instance next created will be a non-QoS non-AP station (STA) in an infrastructure BSS (i.e., a BSS with an AP).  Finally, the "ActiveProbing" <strong>Attribute</strong> is set to false.  This means that probe requests will not be sent by MACs created by this helper.</p><p>Once all the station-specific parameters are fully configured, both at the MAC and PHY layers, we can invoke our now-familiar <strong>Install</strong> method to create the wifi devices of these stations:</p>
<pre>
NetDeviceContainer staDevices;
staDevices = wifi.Install (phy, mac, wifiStaNodes);
</pre>
<p>We have configured Wifi for all of our STA nodes, and now we need to configure the AP (access point) node.  We begin this process by changing the default <strong>Attributes</strong> of the <strong>NqosWifiMacHelper</strong> to reflect the requirements of the AP.</p>
<pre>
mac.SetType ("ns3::ApWifiMac",
             "Ssid", SsidValue (ssid));
</pre>
<p>In this case, the <strong>NqosWifiMacHelper</strong> is going to create MAC layers of the "ns3::ApWifiMac", the latter specifying that a MAC instance configured as an AP should be created, with the helper type implying that the "QosSupported" <strong>Attribute</strong> should be set to false - disabling 802.11e/WMM-style QoS support at created APs.</p><p>The next lines create the single AP which shares the same set of PHY-level <strong>Attributes</strong> (and channel) as the stations:</p>
<pre>
NetDeviceContainer apDevices;
apDevices = wifi.Install (phy, mac, wifiApNode);
</pre>
<p>Now, we are going to add mobility models.  We want the STA nodes to be mobile, wandering around inside a bounding box, and we want to make the AP node stationary.  We use the <strong>MobilityHelper</strong> to make this easy for us. First, we instantiate a <strong>MobilityHelper</strong> object and set some <strong>Attributes</strong> controlling the "position allocator" functionality.</p>
<pre>
MobilityHelper mobility;

mobility.SetPositionAllocator ("ns3::GridPositionAllocator",
  "MinX", DoubleValue (0.0),
  "MinY", DoubleValue (0.0),
  "DeltaX", DoubleValue (5.0),
  "DeltaY", DoubleValue (10.0),
  "GridWidth", UintegerValue (3),
  "LayoutType", StringValue ("RowFirst"));
</pre>
<p>This code tells the mobility helper to use a two-dimensional grid to initially place the STA nodes.  Feel free to explore the Doxygen for class <strong>ns3::GridPositionAllocator</strong> to see exactly what is being done.</p><p>We have arranged our nodes on an initial grid, but now we need to tell them how to move.  We choose the <strong>RandomWalk2dMobilityModel</strong> which has the nodes move in a random direction at a random speed around inside a bounding box.</p>
<pre>
mobility.SetMobilityModel ("ns3::RandomWalk2dMobilityModel",
  "Bounds", RectangleValue (Rectangle (-50, 50, -50, 50)));
</pre>
<p>We now tell the <strong>MobilityHelper</strong> to install the mobility models on the STA nodes.</p>
<pre>
mobility.Install (wifiStaNodes);
</pre>
<p>We want the access point to remain in a fixed position during the simulation. We accomplish this by setting the mobility model for this node to be the <strong>ns3::ConstantPositionMobilityModel</strong>:</p>
<pre>
mobility.SetMobilityModel ("ns3::ConstantPositionMobilityModel");
mobility.Install (wifiApNode);
</pre>
<p>We now have our nodes, devices and channels created, and mobility models chosen for the Wifi nodes, but we have no protocol stacks present.  Just as we have done previously many times, we will use the <strong>InternetStackHelper</strong> to install these stacks.</p>
<pre>
InternetStackHelper stack;
stack.Install (csmaNodes);
stack.Install (wifiApNode);
stack.Install (wifiStaNodes);
</pre>
<p>Just as in the <strong>second.cc</strong> example script, we are going to use the <strong>Ipv4AddressHelper</strong> to assign IP addresses to our device interfaces. First we use the network 10.1.1.0 to create the two addresses needed for our two point-to-point devices.  Then we use network 10.1.2.0 to assign addresses to the CSMA network and then we assign addresses from network 10.1.3.0 to both the STA devices and the AP on the wireless network.</p>
<pre>
Ipv4AddressHelper address;

address.SetBase ("10.1.1.0", "255.255.255.0");
Ipv4InterfaceContainer p2pInterfaces;
p2pInterfaces = address.Assign (p2pDevices);

address.SetBase ("10.1.2.0", "255.255.255.0");
Ipv4InterfaceContainer csmaInterfaces;
csmaInterfaces = address.Assign (csmaDevices);

address.SetBase ("10.1.3.0", "255.255.255.0");
address.Assign (staDevices);
address.Assign (apDevices);
</pre>
<p>We put the echo server on the "rightmost" node in the illustration at the start of the file.  We have done this before.</p>
<pre>
UdpEchoServerHelper echoServer (9);

ApplicationContainer serverApps = echoServer.Install (csmaNodes.Get (nCsma));
serverApps.Start (Seconds (1.0));
serverApps.Stop (Seconds (10.0));
</pre>
<p>And we put the echo client on the last STA node we created, pointing it to the server on the CSMA network.  We have also seen similar operations before.</p>
<pre>
UdpEchoClientHelper echoClient (csmaInterfaces.GetAddress (nCsma), 9);
echoClient.SetAttribute ("MaxPackets", UintegerValue (1));
echoClient.SetAttribute ("Interval", TimeValue (Seconds (1.0)));
echoClient.SetAttribute ("PacketSize", UintegerValue (1024));

ApplicationContainer clientApps =
  echoClient.Install (wifiStaNodes.Get (nWifi - 1));
clientApps.Start (Seconds (2.0));
clientApps.Stop (Seconds (10.0));
</pre>
<p>Since we have built an internetwork here, we need to enable internetwork routing just as we did in the <strong>second.cc</strong> example script.</p>
<pre>
Ipv4GlobalRoutingHelper::PopulateRoutingTables ();
</pre>
<p>One thing that can surprise some users is the fact that the simulation we just created will never "naturally" stop.  This is because we asked the wireless access point to generate beacons.  It will generate beacons forever, and this will result in simulator events being scheduled into the future indefinitely, so we must tell the simulator to stop even though it may have beacon generation events scheduled.  The following line of code tells the simulator to stop so that we don&apos;t simulate beacons forever and enter what is essentially an endless loop.</p>
<pre>
Simulator::Stop (Seconds (10.0));
</pre>
<p>We create just enough tracing to cover all three networks:</p>
<pre>
pointToPoint.EnablePcapAll ("third");
phy.EnablePcap ("third", apDevices.Get (0));
csma.EnablePcap ("third", csmaDevices.Get (0), true);
</pre>
<p>These three lines of code will start pcap tracing on both of the point-to-point nodes that serves as our backbone, will start a promiscuous (monitor) mode trace on the Wifi network, and will start a promiscuous trace on the CSMA network.  This will let us see all of the traffic with a minimum number of trace files.</p><p>Finally, we actually run the simulation, clean up and then exit the program.</p>
<pre>
  Simulator::Run ();
  Simulator::Destroy ();
  return 0;
}
</pre>
<p>In order to run this example, you have to copy the <strong>third.cc</strong> example script into the scratch directory and use Waf to build just as you did with the <strong>second.cc</strong> example.  If you are in the top-level directory of the repository you would type,</p>
<pre>
cp examples/third.cc scratch/mythird.cc
./waf
./waf --run scratch/mythird
</pre>
<p>Again, since we have set up the UDP echo applications just as we did in the <strong>second.cc</strong> script, you will see similar output.</p>
<pre>
Waf: Entering directory \(ga/home/craigdo/repos/ns-3-allinone/ns-3-dev/build&apos;
Waf: Leaving directory \(ga/home/craigdo/repos/ns-3-allinone/ns-3-dev/build&apos;
&apos;build&apos; finished successfully (0.407s)
Sent 1024 bytes to 10.1.2.4
Received 1024 bytes from 10.1.3.3
Received 1024 bytes from 10.1.2.4
</pre>
<p>Recall that the first message, <strong>Sent 1024 bytes to 10.1.2.4</strong>," is the UDP echo client sending a packet to the server.  In this case, the client is on the wireless network (10.1.3.0).  The second message, "<strong>Received 1024 bytes from 10.1.3.3</strong>," is from the UDP echo server, generated when it receives the echo packet.  The final message, "<strong>Received 1024 bytes from 10.1.2.4</strong>," is from the echo client, indicating that it has received its echo back from the server.</p><p>If you now go and look in the top level directory, you will find four trace files from this simulation, two from node zero and two from node one:</p>
<pre>
third-0-0.pcap  third-0-1.pcap  third-1-0.pcap  third-1-1.pcap
</pre>
<p>The file "third-0-0.pcap" corresponds to the point-to-point device on node zero -- the left side of the "backbone".  The file "third-1-0.pcap" corresponds to the point-to-point device on node one -- the right side of the "backbone".  The file "third-0-1.pcap" will be the promiscuous (monitor mode) trace from the Wifi network and the file "third-1-1.pcap" will be the promiscuous trace from the CSMA network.  Can you verify this by inspecting the code?</p><p>Since the echo client is on the Wifi network, let&apos;s start there.  Let&apos;s take a look at the promiscuous (monitor mode) trace we captured on that network.</p>
<pre>
tcpdump -nn -tt -r third-0-1.pcap
</pre>
<p>You should see some wifi-looking contents you haven&apos;t seen here before:</p>
<pre>
reading from file third-0-1.pcap, link-type IEEE802_11 (802.11)
0.000025 Beacon (ns-3-ssid) [6.0* 9.0 12.0 18.0 24.0 36.0 48.0 54.0 Mbit] IBSS
0.000263 Assoc Request (ns-3-ssid) [6.0 9.0 12.0 18.0 24.0 36.0 48.0 54.0 Mbit]
0.000279 Acknowledgment RA:00:00:00:00:00:09
0.000552 Assoc Request (ns-3-ssid) [6.0 9.0 12.0 18.0 24.0 36.0 48.0 54.0 Mbit]
0.000568 Acknowledgment RA:00:00:00:00:00:07
0.000664 Assoc Response <strong>AID</strong>(0) :: Succesful
0.001001 Assoc Response <strong>AID</strong>(0) :: Succesful
0.001145 Acknowledgment RA:00:00:00:00:00:0a
0.001233 Assoc Response <strong>AID</strong>(0) :: Succesful
0.001377 Acknowledgment RA:00:00:00:00:00:0a
0.001597 Assoc Request (ns-3-ssid) [6.0 9.0 12.0 18.0 24.0 36.0 48.0 54.0 Mbit]
0.001613 Acknowledgment RA:00:00:00:00:00:08
0.001691 Assoc Response <strong>AID</strong>(0) :: Succesful
0.001835 Acknowledgment RA:00:00:00:00:00:0a
0.102400 Beacon (ns-3-ssid) [6.0* 9.0 12.0 18.0 24.0 36.0 48.0 54.0 Mbit] IBSS
0.204800 Beacon (ns-3-ssid) [6.0* 9.0 12.0 18.0 24.0 36.0 48.0 54.0 Mbit] IBSS
0.307200 Beacon (ns-3-ssid) [6.0* 9.0 12.0 18.0 24.0 36.0 48.0 54.0 Mbit] IBSS
</pre>
<p>You can see that the link type is now 802.11 as you would expect.  You can probably understand what is going on and find the IP echo request and response packets in this trace.  We leave it as an exercise to completely parse the trace dump.</p><p>Now, look at the pcap file of the right side of the point-to-point link,</p>
<pre>
tcpdump -nn -tt -r third-0-0.pcap
</pre>
<p>Again, you should see some familiar looking contents:</p>
<pre>
reading from file third-0-0.pcap, link-type PPP (PPP)
2.002160 IP 10.1.3.3.49153 &gt; 10.1.2.4.9: UDP, length 1024
2.009767 IP 10.1.2.4.9 &gt; 10.1.3.3.49153: UDP, length 1024
</pre>
<p>This is the echo packet going from left to right (from Wifi to CSMA) and back again across the point-to-point link.</p><p>Now, look at the pcap file of the right side of the point-to-point link,</p>
<pre>
tcpdump -nn -tt -r third-1-0.pcap
</pre>
<p>Again, you should see some familiar looking contents:</p>
<pre>
reading from file third-1-0.pcap, link-type PPP (PPP)
2.005846 IP 10.1.3.3.49153 &gt; 10.1.2.4.9: UDP, length 1024
2.006081 IP 10.1.2.4.9 &gt; 10.1.3.3.49153: UDP, length 1024
</pre>
<p>This is also the echo packet going from left to right (from Wifi to CSMA) and back again across the point-to-point link with slightly different timings as you might expect.</p><p>The echo server is on the CSMA network, let&apos;s look at the promiscuous trace there:</p>
<pre>
tcpdump -nn -tt -r third-1-1.pcap
</pre>
<p>You should see some familiar looking contents:</p>
<pre>
reading from file third-1-1.pcap, link-type EN10MB (Ethernet)
2.005846 ARP, Request who-has 10.1.2.4 (ff:ff:ff:ff:ff:ff) tell 10.1.2.1, length 50
2.005870 ARP, Reply 10.1.2.4 is-at 00:00:00:00:00:06, length 50
2.005870 IP 10.1.3.3.49153 &gt; 10.1.2.4.9: UDP, length 1024
2.005975 ARP, Request who-has 10.1.2.1 (ff:ff:ff:ff:ff:ff) tell 10.1.2.4, length 50
2.005975 ARP, Reply 10.1.2.1 is-at 00:00:00:00:00:03, length 50
2.006081 IP 10.1.2.4.9 &gt; 10.1.3.3.49153: UDP, length 1024
</pre>
<p>This should be easily understood.  If you&apos;ve forgotten, go back and look at the discussion in <strong>second.cc</strong>.  This is the same sequence.</p><p>Now, we spent a lot of time setting up mobility models for the wireless network and so it would be a shame to finish up without even showing that the STA nodes are actually moving around during the simulation.  Let&apos;s do this by hooking into the <strong>MobilityModel</strong> course change trace source.  This is just a sneak peek into the detailed tracing section which is coming up, but this seems a very nice place to get an example in.</p><p>As mentioned in the "Tweaking ns-3" section, the <em>ns-3</em> tracing system is divided into trace sources and trace sinks, and we provide functions to connect the two.  We will use the mobility model predefined course change trace source to originate the trace events.  We will need to write a trace sink to connect to that source that will display some pretty information for us.  Despite its reputation as being difficult, it&apos;s really quite simple. Just before the main program of the <strong>scratch/mythird.cc</strong> script (i.e., just after the <strong>NS_LOG_COMPONENT_DEFINE</strong> statement), add the following function:</p>
<pre>
void
CourseChange (std::string context, Ptr&lt;const MobilityModel&gt; model)
{
  Vector position = model-&gt;GetPosition ();
  NS_LOG_UNCOND (context &lt;&lt;
    " x = " &lt;&lt; position.x &lt;&lt; ", y = " &lt;&lt; position.y);
}
</pre>
<p>This code just pulls the position information from the mobility model and unconditionally logs the x and y position of the node.  We are going to arrange for this function to be called every time the wireless node with the echo client changes its position.  We do this using the <strong>Config::Connect</strong> function.  Add the following lines of code to the script just before the <strong>Simulator::Run</strong> call.</p>
<pre>
std::ostringstream oss;
oss &lt;&lt;
  "/NodeList/" &lt;&lt; wifiStaNodes.Get (nWifi - 1)-&gt;GetId () &lt;&lt;
  "/$ns3::MobilityModel/CourseChange";

Config::Connect (oss.str (), MakeCallback (&CourseChange));
</pre>
<p>What we do here is to create a string containing the tracing namespace path of the event to which we want to connect.  First, we have to figure out which node it is we want using the <strong>GetId</strong> method as described earlier.  In the case of the default number of CSMA and wireless nodes, this turns out to be node seven and the tracing namespace path to the mobility model would look like,</p>
<pre>
/NodeList/7/$ns3::MobilityModel/CourseChange
</pre>
<p>Based on the discussion in the tracing section, you may infer that this trace path references the seventh node in the global NodeList.  It specifies what is called an aggregated object of type <strong>ns3::MobilityModel</strong>.  The dollar sign prefix implies that the MobilityModel is aggregated to node seven. The last component of the path means that we are hooking into the "CourseChange" event of that model.</p><p>We make a connection between the trace source in node seven with our trace sink by calling <strong>Config::Connect</strong> and passing this namespace path.  Once this is done, every course change event on node seven will be hooked into our trace sink, which will in turn print out the new position.</p><p>If you now run the simulation, you will see the course changes displayed as they happen.</p>
<pre>
Build finished successfully (00:00:01)
/NodeList/7/$ns3::MobilityModel/CourseChange x = 10, y = 0
/NodeList/7/$ns3::MobilityModel/CourseChange x = 9.41539, y = -0.811313
/NodeList/7/$ns3::MobilityModel/CourseChange x = 8.46199, y = -1.11303
/NodeList/7/$ns3::MobilityModel/CourseChange x = 7.52738, y = -1.46869
/NodeList/7/$ns3::MobilityModel/CourseChange x = 6.67099, y = -1.98503
/NodeList/7/$ns3::MobilityModel/CourseChange x = 5.6835, y = -2.14268
/NodeList/7/$ns3::MobilityModel/CourseChange x = 4.70932, y = -1.91689
Sent 1024 bytes to 10.1.2.4
Received 1024 bytes from 10.1.3.3
Received 1024 bytes from 10.1.2.4
/NodeList/7/$ns3::MobilityModel/CourseChange x = 5.53175, y = -2.48576
/NodeList/7/$ns3::MobilityModel/CourseChange x = 4.58021, y = -2.17821
/NodeList/7/$ns3::MobilityModel/CourseChange x = 4.18915, y = -1.25785
/NodeList/7/$ns3::MobilityModel/CourseChange x = 4.7572, y = -0.434856
/NodeList/7/$ns3::MobilityModel/CourseChange x = 4.62404, y = 0.556238
/NodeList/7/$ns3::MobilityModel/CourseChange x = 4.74127, y = 1.54934
/NodeList/7/$ns3::MobilityModel/CourseChange x = 5.73934, y = 1.48729
/NodeList/7/$ns3::MobilityModel/CourseChange x = 6.18521, y = 0.59219
/NodeList/7/$ns3::MobilityModel/CourseChange x = 6.58121, y = 1.51044
/NodeList/7/$ns3::MobilityModel/CourseChange x = 7.27897, y = 2.22677
/NodeList/7/$ns3::MobilityModel/CourseChange x = 6.42888, y = 1.70014
/NodeList/7/$ns3::MobilityModel/CourseChange x = 7.40519, y = 1.91654
/NodeList/7/$ns3::MobilityModel/CourseChange x = 6.51981, y = 1.45166
/NodeList/7/$ns3::MobilityModel/CourseChange x = 7.34588, y = 2.01523
/NodeList/7/$ns3::MobilityModel/CourseChange x = 7.81046, y = 2.90077
/NodeList/7/$ns3::MobilityModel/CourseChange x = 6.89186, y = 3.29596
/NodeList/7/$ns3::MobilityModel/CourseChange x = 7.46617, y = 2.47732
/NodeList/7/$ns3::MobilityModel/CourseChange x = 7.05492, y = 1.56579
/NodeList/7/$ns3::MobilityModel/CourseChange x = 8.00393, y = 1.25054
/NodeList/7/$ns3::MobilityModel/CourseChange x = 7.00968, y = 1.35768
/NodeList/7/$ns3::MobilityModel/CourseChange x = 7.33503, y = 2.30328
/NodeList/7/$ns3::MobilityModel/CourseChange x = 7.18682, y = 3.29223
/NodeList/7/$ns3::MobilityModel/CourseChange x = 7.96865, y = 2.66873
</pre>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TRACING</h2>
        <div class="sectioncontent">
<h3>Background</h3>
<p>As mentioned in the Using the Tracing System section, the whole point of running an <em>ns-3</em> simulation is to generate output for study.  You have two basic strategies to work with in <em>ns-3</em>: using generic pre-defined bulk output mechanisms and parsing their content to extract interesting information; or somehow developing an output mechanism that conveys exactly (and perhaps only) the information wanted.</p><p>Using pre-defined bulk output mechanisms has the advantage of not requiring any changes to <em>ns-3</em>, but it does require programming.  Often, pcap or NS_LOG output messages are gathered during simulation runs and separately run through scripts that use grep, sed or awk to parse the messages and reduce and transform the data to a manageable form.  Programs must be written to do the transformation, so this does not come for free.  Of course, if the information of interest in does not exist in any of the pre-defined output mechanisms, this approach fails.</p><p>If you need to add some tidbit of information to the pre-defined bulk mechanisms, this can certainly be done; and if you use one of the <em>ns-3</em> mechanisms, you may get your code added as a contribution.</p><p><em>ns-3</em> provides another mechanism, called Tracing, that avoids some of the problems inherent in the bulk output mechanisms.  It has several important advantages.  First, you can reduce the amount of data you have to manage by only tracing the events of interest to you (for large simulations, dumping everything to disk for post-processing can create I/O bottlenecks).  Second, if you use this method, you can control the format of the output directly so you avoid the postprocessing step with sed or awk script.  If you desire, your output can be formatted directly into a form acceptable by gnuplot, for example.  You can add hooks in the core which can then be accessed by other users, but which will produce no information unless explicitly asked to do so.  For these reasons, we believe that the <em>ns-3</em> tracing system is the best way to get information out of a simulation and is also therefore one of the most important mechanisms to understand in <em>ns-3</em>.</p>
<h3>Blunt Instruments</h3>
<p>There are many ways to get information out of a program.  The most straightforward way is to just directly print the information to the standard output, as in,</p>
<pre>
#include &lt;iostream&gt;
...
void
SomeFunction (void)
{
  uint32_t x = SOME_INTERESTING_VALUE;
  ...
  std::cout &lt;&lt; "The value of x is " &lt;&lt; x &lt;&lt; std::endl;
  ...
}
</pre>
<p>Nobody is going to prevent you from going deep into the core of <em>ns-3</em> and adding print statements.  This is insanely easy to do and, after all, you have complete control of your own <em>ns-3</em> branch.  This will probably not turn out to be very satisfactory in the long term, though.</p><p>As the number of print statements increases in your programs, the task of dealing with the large number of outputs will become more and more complicated. Eventually, you may feel the need to control what information is being printed in some way; perhaps by turning on and off certain categories of prints, or increasing or decreasing the amount of information you want.  If you continue down this path you may discover that you have re-implemented the <strong>NS_LOG</strong> mechanism.  In order to avoid that, one of the first things you might consider is using <strong>NS_LOG</strong> itself.</p><p>We mentioned above that one way to get information out of <em>ns-3</em> is to parse existing NS_LOG output for interesting information.  If you discover that some tidbit of information you need is not present in existing log output, you could edit the core of <em>ns-3</em> and simply add your interesting information to the output stream.  Now, this is certainly better than adding your own print statements since it follows <em>ns-3</em> coding conventions and could potentially be useful to other people as a patch to the existing core.</p><p>Let&apos;s pick a random example.  If you wanted to add more logging to the <em>ns-3</em> TCP socket (<strong>tcp-socket-base.cc</strong>) you could just add a new message down in the implementation.  Notice that in TcpSocketBase::ReceivedAck() there is no log message for the no ACK case.  You could simply add one, changing the code from:</p>
<pre>
/** Process the newly received ACK */
void
TcpSocketBase::ReceivedAck (Ptr&lt;Packet&gt; packet, const TcpHeader& tcpHeader)
{
  NS_LOG_FUNCTION (this &lt;&lt; tcpHeader);

  // Received ACK. Compare the ACK number against highest unacked seqno
  if (0 == (tcpHeader.GetFlags () & TcpHeader::ACK))
    { // Ignore if no ACK flag
    }
  ...
</pre>
<p>to add a new <strong>NS_LOG_LOGIC</strong> in the appropriate statement:</p>
<pre>
/** Process the newly received ACK */
void
TcpSocketBase::ReceivedAck (Ptr&lt;Packet&gt; packet, const TcpHeader& tcpHeader)
{
  NS_LOG_FUNCTION (this &lt;&lt; tcpHeader);

  // Received ACK. Compare the ACK number against highest unacked seqno
  if (0 == (tcpHeader.GetFlags () & TcpHeader::ACK))
    { // Ignore if no ACK flag
      NS_LOG_LOGIC ("TcpSocketBase " &lt;&lt; this &lt;&lt; " no ACK flag");
    }
  ...
</pre>
<p>This may seem fairly simple and satisfying at first glance, but something to consider is that you will be writing code to add the <strong>NS_LOG</strong> statement and you will also have to write code (as in grep, sed or awk scripts) to parse the log output in order to isolate your information.  This is because even though you have some control over what is output by the logging system, you only have control down to the log component level.</p><p>If you are adding code to an existing module, you will also have to live with the output that every other developer has found interesting.  You may find that in order to get the small amount of information you need, you may have to wade through huge amounts of extraneous messages that are of no interest to you.  You may be forced to save huge log files to disk and process them down to a few lines whenever you want to do anything.</p><p>Since there are no guarantees in <em>ns-3</em> about the stability of <strong>NS_LOG</strong> output, you may also discover that pieces of log output on which you depend disappear or change between releases.  If you depend on the structure of the output, you may find other messages being added or deleted which may affect your parsing code.</p><p>For these reasons, we consider prints to <strong>std::cout</strong> and NS_LOG messages to be quick and dirty ways to get more information out of <em>ns-3</em>.</p><p>It is desirable to have a stable facility using stable APIs that allow one to reach into the core system and only get the information required.  It is desirable to be able to do this without having to change and recompile the core system.  Even better would be a system that notified the user when an item of interest changed or an interesting event happened so the user doesn&apos;t have to actively poke around in the system looking for things.</p><p>The <em>ns-3</em> tracing system is designed to work along those lines and is well-integrated with the Attribute and Config subsystems allowing for relatively simple use scenarios.</p>
<h3>Overview</h3>
<p>The ns-3 tracing system is built on the concepts of independent tracing sources and tracing sinks; along with a uniform mechanism for connecting sources to sinks.</p><p>Trace sources are entities that can signal events that happen in a simulation and provide access to interesting underlying data.  For example, a trace source could indicate when a packet is received by a net device and provide access to the packet contents for interested trace sinks.  A trace source might also indicate when an interesting state change happens in a model.  For example, the congestion window of a TCP model is a prime candidate for a trace source.</p><p>Trace sources are not useful by themselves; they must be connected to other pieces of code that actually do something useful with the information provided by the source. The entities that consume trace information are called trace sinks.  Trace sources are generators of events and trace sinks are consumers.  This explicit division allows for large numbers of trace sources to be scattered around the system in places which model authors believe might be useful.</p><p>There can be zero or more consumers of trace events generated by a trace source. One can think of a trace source as a kind of point-to-multipoint information link. Your code looking for trace events from a particular piece of core code could happily coexist with other code doing something entirely different from the same information.</p><p>Unless a user connects a trace sink to one of these sources, nothing is output.  By using the tracing system, both you and other people at the same trace source are getting exactly what they want and only what they want out of the system.  Neither of you are impacting any other user by changing what information is output by the system.  If you happen to add a trace source, your work as a good open-source citizen may allow other users to provide new utilities that are perhaps very useful overall, without making any changes to the <em>ns-3</em> core.</p>
<h3>A Simple Low-Level Example</h3>
<p>Let&apos;s take a few minutes and walk through a simple tracing example.  We are going to need a little background on Callbacks to understand what is happening in the example, so we have to take a small detour right away.</p>
<h3>Callbacks</h3>
<p>The goal of the Callback system in <em>ns-3</em> is to allow one piece of code to call a function (or method in C++) without any specific inter-module dependency. This ultimately means you need some kind of indirection -- you treat the address of the called function as a variable.  This variable is called a pointer-to-function variable.  The relationship between function and pointer-to-function pointer is really no different that that of object and pointer-to-object.</p><p>In C the canonical example of a pointer-to-function is a pointer-to-function-returning-integer (PFI).  For a PFI taking one int parameter, this could be declared like,</p>
<pre>
int (*pfi)(int arg) = 0;
</pre>
<p>What you get from this is a variable named simply "pfi" that is initialized to the value 0.  If you want to initialize this pointer to something meaningful, you have to have a function with a matching signature.  In this case, you could provide a function that looks like,</p>
<pre>
int MyFunction (int arg) {}
</pre>
<p>If you have this target, you can initialize the variable to point to your function:</p>
<pre>
pfi = MyFunction;
</pre>
<p>You can then call MyFunction indirectly using the more suggestive form of the call,</p>
<pre>
int result = (*pfi) (1234);
</pre>
<p>This is suggestive since it looks like you are dereferencing the function pointer just like you would dereference any pointer.  Typically, however, people take advantage of the fact that the compiler knows what is going on and will just use a shorter form,</p>
<pre>
int result = pfi (1234);
</pre>
<p>This looks like you are calling a function named "pfi," but the compiler is smart enough to know to call through the variable <strong>pfi</strong> indirectly to the function <strong>MyFunction</strong>.</p><p>Conceptually, this is almost exactly how the tracing system will work. Basically, a trace source <em>is</em> a callback.  When a trace sink expresses interest in receiving trace events, it adds a Callback to a list of Callbacks internally held by the trace source.  When an interesting event happens, the trace source invokes its <strong>operator()</strong> providing zero or more parameters. The <strong>operator()</strong> eventually wanders down into the system and does something remarkably like the indirect call you just saw.  It provides zero or more parameters (the call to "pfi" above passed one parameter to the target function <strong>MyFunction</strong>.</p><p>The important difference that the tracing system adds is that for each trace source there is an internal list of Callbacks.  Instead of just making one indirect call, a trace source may invoke any number of Callbacks.  When a trace sink expresses interest in notifications from a trace source, it basically just arranges to add its own function to the callback list.</p><p>If you are interested in more details about how this is actually arranged in <em>ns-3</em>, feel free to peruse the Callback section of the manual.</p>
<h3>Example Code</h3>
<p>We have provided some code to implement what is really the simplest example of tracing that can be assembled.  You can find this code in the tutorial directory as <strong>fourth.cc</strong>.  Let&apos;s walk through it.</p>
<pre>
/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation;
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#include "ns3/object.h"
#include "ns3/uinteger.h"
#include "ns3/traced-value.h"
#include "ns3/trace-source-accessor.h"

#include &lt;iostream&gt;

using namespace ns3;
</pre>
<p>Most of this code should be quite familiar to you.  As mentioned above, the trace system makes heavy use of the Object and Attribute systems, so you will need to include them.  The first two includes above bring in the declarations for those systems explicitly.  You could use the core module header, but this illustrates how simple this all really is.</p><p>The file, <strong>traced-value.h</strong> brings in the required declarations for tracing of data that obeys value semantics.  In general, value semantics just means that you can pass the object around, not an address.  In order to use value semantics at all you have to have an object with an associated copy constructor and assignment operator available.  We extend the requirements to talk about the set of operators that are pre-defined for plain-old-data (POD) types.  Operator=, operator++, operator---, operator+, operator==, etc.</p><p>What this all really means is that you will be able to trace changes to a C++ object made using those operators.</p><p>Since the tracing system is integrated with Attributes, and Attributes work with Objects, there must be an <em>ns-3</em> <strong>Object</strong> for the trace source to live in.  The next code snippet declares and defines a simple Object we can work with.</p>
<pre>
class MyObject : public Object
{
public:
  static TypeId GetTypeId (void)
  {
    static TypeId tid = TypeId ("MyObject")
      .SetParent (Object::GetTypeId ())
      .AddConstructor&lt;MyObject&gt; ()
      .AddTraceSource ("MyInteger",
                       "An integer value to trace.",
                       MakeTraceSourceAccessor (&MyObject::m_myInt))
      ;
    return tid;
  }

  MyObject () {}
  TracedValue&lt;int32_t&gt; m_myInt;
};
</pre>
<p>The two important lines of code, above, with respect to tracing are the <strong>.AddTraceSource</strong> and the <strong>TracedValue</strong> declaration of <strong>m_myInt</strong>.</p><p>The <strong>.AddTraceSource</strong> provides the "hooks" used for connecting the trace source to the outside world through the config system.  The <strong>TracedValue</strong> declaration provides the infrastructure that overloads the operators mentioned above and drives the callback process.</p>
<pre>
void
IntTrace (int32_t oldValue, int32_t newValue)
{
  std::cout &lt;&lt; "Traced " &lt;&lt; oldValue &lt;&lt; " to " &lt;&lt; newValue &lt;&lt; std::endl;
}
</pre>
<p>This is the definition of the trace sink.  It corresponds directly to a callback function.  Once it is connected, this function will be called whenever one of the overloaded operators of the <strong>TracedValue</strong> is executed.</p><p>We have now seen the trace source and the trace sink.  What remains is code to connect the source to the sink.</p>
<pre>
int
main (int argc, char *argv[])
{
  Ptr&lt;MyObject&gt; myObject = CreateObject&lt;MyObject&gt; ();
  myObject-&gt;TraceConnectWithoutContext ("MyInteger", MakeCallback(&IntTrace));

  myObject-&gt;m_myInt = 1234;
}
</pre>
<p>Here we first create the Object in which the trace source lives.</p><p>The next step, the <strong>TraceConnectWithoutContext</strong>, forms the connection between the trace source and the trace sink.  Notice the <strong>MakeCallback</strong> template function.  This function does the magic required to create the underlying <em>ns-3</em> Callback object and associate it with the function <strong>IntTrace</strong>.  TraceConnect makes the association between your provided function and the overloaded <strong>operator()</strong> in the traced variable referred to by the "MyInteger" Attribute.  After this association is made, the trace source will "fire" your provided callback function.</p><p>The code to make all of this happen is, of course, non-trivial, but the essence is that you are arranging for something that looks just like the <strong>pfi()</strong> example above to be called by the trace source.  The declaration of the <strong>TracedValue&lt;int32_t&gt; m_myInt;</strong> in the Object itself performs the magic needed to provide the overloaded operators (++, ---, etc.) that will use the <strong>operator()</strong> to actually invoke the Callback with the desired parameters. The <strong>.AddTraceSource</strong> performs the magic to connect the Callback to the Config system, and <strong>TraceConnectWithoutContext</strong> performs the magic to connect your function to the trace source, which is specified by Attribute name.</p><p>Let&apos;s ignore the bit about context for now.</p><p>Finally, the line,</p>
<pre>
myObject-&gt;m_myInt = 1234;
</pre>
<p>should be interpreted as an invocation of <strong>operator=</strong> on the member variable <strong>m_myInt</strong> with the integer <strong>1234</strong> passed as a parameter.</p><p>It turns out that this operator is defined (by <strong>TracedValue</strong>) to execute a callback that returns void and takes two integer values as parameters --- an old value and a new value for the integer in question.  That is exactly the function signature for the callback function we provided --- <strong>IntTrace</strong>.</p><p>To summarize, a trace source is, in essence, a variable that holds a list of callbacks.  A trace sink is a function used as the target of a callback.  The Attribute and object type information systems are used to provide a way to connect trace sources to trace sinks.  The act of "hitting" a trace source is executing an operator on the trace source which fires callbacks.  This results in the trace sink callbacks registering interest in the source being called with the parameters provided by the source.</p><p>If you now build and run this example,</p>
<pre>
./waf --run fourth
</pre>
<p>you will see the output from the <strong>IntTrace</strong> function execute as soon as the trace source is hit:</p>
<pre>
Traced 0 to 1234
</pre>
<p>When we executed the code, <strong>myObject-&gt;m_myInt = 1234;</strong>, the trace source fired and automatically provided the before and after values to the trace sink. The function <strong>IntTrace</strong> then printed this to the standard output.  No problem.</p>
<h3>Using the Config Subsystem to Connect to Trace Sources</h3>
<p>The <strong>TraceConnectWithoutContext</strong> call shown above in the simple example is actually very rarely used in the system.  More typically, the <strong>Config</strong> subsystem is used to allow selecting a trace source in the system using what is called a <em>config path</em>.  We saw an example of this in the previous section where we hooked the "CourseChange" event when we were playing with <strong>third.cc</strong>.</p><p>Recall that we defined a trace sink to print course change information from the mobility models of our simulation.  It should now be a lot more clear to you what this function is doing.</p>
<pre>
void
CourseChange (std::string context, Ptr&lt;const MobilityModel&gt; model)
{
  Vector position = model-&gt;GetPosition ();
  NS_LOG_UNCOND (context &lt;&lt;
    " x = " &lt;&lt; position.x &lt;&lt; ", y = " &lt;&lt; position.y);
}
</pre>
<p>When we connected the "CourseChange" trace source to the above trace sink, we used what is called a "Config Path" to specify the source when we arranged a connection between the pre-defined trace source and the new trace sink:</p>
<pre>
std::ostringstream oss;
oss &lt;&lt;
  "/NodeList/" &lt;&lt; wifiStaNodes.Get (nWifi - 1)-&gt;GetId () &lt;&lt;
  "/$ns3::MobilityModel/CourseChange";

Config::Connect (oss.str (), MakeCallback (&CourseChange));
</pre>
<p>Let&apos;s try and make some sense of what is sometimes considered relatively mysterious code.  For the purposes of discussion, assume that the node number returned by the <strong>GetId()</strong> is "7".  In this case, the path above turns out to be,</p>
<pre>
"/NodeList/7/$ns3::MobilityModel/CourseChange"
</pre>
<p>The last segment of a config path must be an <strong>Attribute</strong> of an <strong>Object</strong>.  In fact, if you had a pointer to the <strong>Object</strong> that has the "CourseChange" <strong>Attribute</strong> handy, you could write this just like we did in the previous example.  You know by now that we typically store pointers to our nodes in a NodeContainer.  In the <strong>third.cc</strong> example, the Nodes of interest are stored in the <strong>wifiStaNodes</strong> NodeContainer.  In fact, while putting the path together, we used this container to get a Ptr&lt;Node&gt; which we used to call GetId() on.  We could have used this Ptr&lt;Node&gt; directly to call a connect method directly:</p>
<pre>
Ptr&lt;Object&gt; theObject = wifiStaNodes.Get (nWifi - 1);
theObject-&gt;TraceConnectWithoutContext ("CourseChange", MakeCallback (&CourseChange));
</pre>
<p>In the <strong>third.cc</strong> example, we actually want an additional "context" to be delivered along with the Callback parameters (which will be explained below) so we could actually use the following equivalent code,</p>
<pre>
Ptr&lt;Object&gt; theObject = wifiStaNodes.Get (nWifi - 1);
theObject-&gt;TraceConnect ("CourseChange", MakeCallback (&CourseChange));
</pre>
<p>It turns out that the internal code for <strong>Config::ConnectWithoutContext</strong> and <strong>Config::Connect</strong> actually do find a Ptr&lt;Object&gt; and call the appropriate TraceConnect method at the lowest level.</p><p>The <strong>Config</strong> functions take a path that represents a chain of <strong>Object</strong> pointers.  Each segment of a path corresponds to an Object Attribute.  The last segment is the Attribute of interest, and prior segments must be typed to contain or find Objects.  The <strong>Config</strong> code parses and "walks" this path until it gets to the final segment of the path.  It then interprets the last segment as an <strong>Attribute</strong> on the last Object it found while walking the path.  The <strong>Config</strong> functions then call the appropriate <strong>TraceConnect</strong> or <strong>TraceConnectWithoutContext</strong> method on the final Object.  Let&apos;s see what happens in a bit more detail when the above path is walked.</p><p>The leading "/" character in the path refers to a so-called namespace.  One of the predefined namespaces in the config system is "NodeList" which is a list of all of the nodes in the simulation.  Items in the list are referred to by indices into the list, so "/NodeList/7" refers to the eighth node in the list of nodes created during the simulation.  This reference is actually a <strong>Ptr&lt;Node&gt;</strong> and so is a subclass of an <strong>ns3::Object</strong>.</p><p>As described in the Object Model section of the <em>ns-3</em> manual, we support Object Aggregation.  This allows us to form an association between different Objects without any programming.  Each Object in an Aggregation can be reached from the other Objects.</p><p>The next path segment being walked begins with the "$" character.  This indicates to the config system that a <strong>GetObject</strong> call should be made looking for the type that follows.  It turns out that the MobilityHelper used in <strong>third.cc</strong> arranges to Aggregate, or associate, a mobility model to each of the wireless Nodes.  When you add the "$" you are asking for another Object that has presumably been previously aggregated.  You can think of this as switching pointers from the original Ptr&lt;Node&gt; as specified by "/NodeList/7" to its associated mobility model --- which is of type "$ns3::MobilityModel".  If you are familiar with <strong>GetObject</strong>, we have asked the system to do the following:</p>
<pre>
Ptr&lt;MobilityModel&gt; mobilityModel = node-&gt;GetObject&lt;MobilityModel&gt; ()
</pre>
<p>We are now at the last Object in the path, so we turn our attention to the Attributes of that Object.  The <strong>MobilityModel</strong> class defines an Attribute called "CourseChange".  You can see this by looking at the source code in <strong>src/mobility/model/mobility-model.cc</strong> and searching for "CourseChange" in your favorite editor.  You should find,</p>
<pre>
.AddTraceSource ("CourseChange",
                 "The value of the position and/or velocity vector changed",
                 MakeTraceSourceAccessor (&MobilityModel::m_courseChangeTrace))
</pre>
<p>which should look very familiar at this point.</p><p>If you look for the corresponding declaration of the underlying traced variable in <strong>mobility-model.h</strong> you will find</p>
<pre>
TracedCallback&lt;Ptr&lt;const MobilityModel&gt; &gt; m_courseChangeTrace;
</pre>
<p>The type declaration <strong>TracedCallback</strong> identifies <strong>m_courseChangeTrace</strong> as a special list of Callbacks that can be hooked using the Config functions described above.</p><p>The <strong>MobilityModel</strong> class is designed to be a base class providing a common interface for all of the specific subclasses.  If you search down to the end of the file, you will see a method defined called <strong>NotifyCourseChange()</strong>:</p>
<pre>
void
MobilityModel::NotifyCourseChange (void) const
{
  m_courseChangeTrace(this);
}
</pre>
<p>Derived classes will call into this method whenever they do a course change to support tracing.  This method invokes <strong>operator()</strong> on the underlying <strong>m_courseChangeTrace</strong>, which will, in turn, invoke all of the registered Callbacks, calling all of the trace sinks that have registered interest in the trace source by calling a Config function.</p><p>So, in the <strong>third.cc</strong> example we looked at, whenever a course change is made in one of the <strong>RandomWalk2dMobilityModel</strong> instances installed, there will be a <strong>NotifyCourseChange()</strong> call which calls up into the <strong>MobilityModel</strong> base class.  As seen above, this invokes <strong>operator()</strong> on <strong>m_courseChangeTrace</strong>, which in turn, calls any registered trace sinks. In the example, the only code registering an interest was the code that provided the config path.  Therefore, the <strong>CourseChange</strong> function that was hooked from Node number seven will be the only Callback called.</p><p>The final piece of the puzzle is the "context".  Recall that we saw an output looking something like the following from <strong>third.cc</strong>:</p>
<pre>
/NodeList/7/$ns3::MobilityModel/CourseChange x = 7.27897, y = 2.22677
</pre>
<p>The first part of the output is the context.  It is simply the path through which the config code located the trace source.  In the case we have been looking at there can be any number of trace sources in the system corresponding to any number of nodes with mobility models.  There needs to be some way to identify which trace source is actually the one that fired the Callback.  An easy way is to request a trace context when you <strong>Config::Connect</strong>.</p>
<h3>How to Find and Connect Trace Sources, and Discover Callback Signatures</h3>
<p>The first question that inevitably comes up for new users of the Tracing system is, "okay, I know that there must be trace sources in the simulation core, but how do I find out what trace sources are available to me"?</p><p>The second question is, "okay, I found a trace source, how do I figure out the config path to use when I connect to it"?</p><p>The third question is, "okay, I found a trace source, how do I figure out what the return type and formal arguments of my callback function need to be"?</p><p>The fourth question is, "okay, I typed that all in and got this incredibly bizarre error message, what in the world does it mean"?</p>
<h3>What Trace Sources are Available?</h3>
<p>The answer to this question is found in the <em>ns-3</em> Doxygen.  If you go to the project web site, <em>ns-3 project</em>, you will find a link to "Documentation" in the navigation bar.  If you select this link, you will be taken to our documentation page. There is a link to "Latest Release" that will take you to the documentation for the latest stable release of <em>ns-3</em>. If you select the "API Documentation" link, you will be taken to the <em>ns-3</em> API documentation page.</p><p>Expand the "Modules" book in the NS-3 documentation tree by clicking the "+" box.  Now, expand the "C++ Constructs Used by All Modules" book in the tree by clicking its "+" box.  You should now see four extremely useful links:</p><ul>
<li><p>The list of all trace sources</p></li><li><p>The list of all attributes</p></li><li><p>The list of all global values</p></li><li><p>Debugging</p><p>The list of interest to us here is "the list of all trace sources".  Go ahead and select that link.  You will see, perhaps not too surprisingly, a list of all of the trace sources available in the <em>ns-3</em> core.</p><p>As an example, scroll down to <strong>ns3::MobilityModel</strong>.  You will find an entry for</p>
<pre>
CourseChange: The value of the position and/or velocity vector changed
</pre>
<p>You should recognize this as the trace source we used in the <strong>third.cc</strong> example.  Perusing this list will be helpful.</p></li>
</ul>
<h3>What String do I use to Connect?</h3>
<p>The easiest way to do this is to grep around in the <em>ns-3</em> codebase for someone who has already figured it out,  You should always try to copy someone else&apos;s working code before you start to write your own.  Try something like:</p>
<pre>
find . -name &apos;*.cc&apos; | xargs grep CourseChange | grep Connect
</pre>
<p>and you may find your answer along with working code.  For example, in this case, <strong>./ns-3-dev/examples/wireless/mixed-wireless.cc</strong> has something just waiting for you to use:</p>
<pre>
Config::Connect ("/NodeList/*/$ns3::MobilityModel/CourseChange",
  MakeCallback (&CourseChangeCallback));
</pre>
<p>If you cannot find any examples in the distribution, you can find this out from the <em>ns-3</em> Doxygen.  It will probably be simplest just to walk through the "CourseChanged" example.</p><p>Let&apos;s assume that you have just found the "CourseChanged" trace source in "The list of all trace sources" and you want to figure out how to connect to it.  You know that you are using (again, from the <strong>third.cc</strong> example) an <strong>ns3::RandomWalk2dMobilityModel</strong>.  So open the "Class List" book in the NS-3 documentation tree by clicking its "+" box.  You will now see a list of all of the classes in <em>ns-3</em>.  Scroll down until you see the entry for <strong>ns3::RandomWalk2dMobilityModel</strong> and follow that link. You should now be looking at the "ns3::RandomWalk2dMobilityModel Class Reference".</p><p>If you now scroll down to the "Member Function Documentation" section, you will see documentation for the <strong>GetTypeId</strong> function.  You constructed one of these in the simple tracing example above:</p>
<pre>
static TypeId GetTypeId (void)
{
  static TypeId tid = TypeId ("MyObject")
    .SetParent (Object::GetTypeId ())
    .AddConstructor&lt;MyObject&gt; ()
    .AddTraceSource ("MyInteger",
                     "An integer value to trace.",
                     MakeTraceSourceAccessor (&MyObject::m_myInt))
    ;
  return tid;
}
</pre>
<p>As mentioned above, this is the bit of code that connected the Config and Attribute systems to the underlying trace source.  This is also the place where you should start looking for information about the way to connect.</p><p>You are looking at the same information for the RandomWalk2dMobilityModel; and the information you want is now right there in front of you in the Doxygen:</p>
<pre>
This object is accessible through the following paths with Config::Set and Config::Connect:

/NodeList/[i]/$ns3::MobilityModel/$ns3::RandomWalk2dMobilityModel
</pre>
<p>The documentation tells you how to get to the <strong>RandomWalk2dMobilityModel</strong> Object.  Compare the string above with the string we actually used in the example code:</p>
<pre>
"/NodeList/7/$ns3::MobilityModel"
</pre>
<p>The difference is due to the fact that two <strong>GetObject</strong> calls are implied in the string found in the documentation.  The first, for <strong>$ns3::MobilityModel</strong> will query the aggregation for the base class.  The second implied <strong>GetObject</strong> call, for <strong>$ns3::RandomWalk2dMobilityModel</strong>, is used to "cast" the base class to the concrete implementation class.  The documentation shows both of these operations for you.  It turns out that the actual Attribute you are going to be looking for is found in the base class as we have seen.</p><p>Look further down in the <strong>GetTypeId</strong> doxygen.  You will find,</p>
<pre>
No TraceSources defined for this type.
TraceSources defined in parent class ns3::MobilityModel:

CourseChange: The value of the position and/or velocity vector changed
Reimplemented from ns3::MobilityModel
</pre>
<p>This is exactly what you need to know.  The trace source of interest is found in <strong>ns3::MobilityModel</strong> (which you knew anyway).  The interesting thing this bit of Doxygen tells you is that you don&apos;t need that extra cast in the config path above to get to the concrete class, since the trace source is actually in the base class.  Therefore the additional <strong>GetObject</strong> is not required and you simply use the path:</p>
<pre>
/NodeList/[i]/$ns3::MobilityModel
</pre>
<p>which perfectly matches the example path:</p>
<pre>
/NodeList/7/$ns3::MobilityModel
</pre>

<h3>What Return Value and Formal Arguments?</h3>
<p>The easiest way to do this is to grep around in the <em>ns-3</em> codebase for someone who has already figured it out,  You should always try to copy someone else&apos;s working code.  Try something like:</p>
<pre>
find . -name &apos;*.cc&apos; | xargs grep CourseChange | grep Connect
</pre>
<p>and you may find your answer along with working code.  For example, in this case, <strong>./ns-3-dev/examples/wireless/mixed-wireless.cc</strong> has something just waiting for you to use.  You will find</p>
<pre>
Config::Connect ("/NodeList/*/$ns3::MobilityModel/CourseChange",
  MakeCallback (&CourseChangeCallback));
</pre>
<p>as a result of your grep.  The <strong>MakeCallback</strong> should indicate to you that there is a callback function there which you can use.  Sure enough, there is:</p>
<pre>
static void
CourseChangeCallback (std::string path, Ptr&lt;const MobilityModel&gt; model)
{
  ...
}
</pre>

<h3>Take my Word for It</h3>
<p>If there are no examples to work from, this can be, well, challenging to actually figure out from the source code.</p><p>Before embarking on a walkthrough of the code, I&apos;ll be kind and just tell you a simple way to figure this out:  The return value of your callback will always be void.  The formal parameter list for a <strong>TracedCallback</strong> can be found from the template parameter list in the declaration.  Recall that for our current example, this is in <strong>mobility-model.h</strong>, where we have previously found:</p>
<pre>
TracedCallback&lt;Ptr&lt;const MobilityModel&gt; &gt; m_courseChangeTrace;
</pre>
<p>There is a one-to-one correspondence between the template parameter list in the declaration and the formal arguments of the callback function.  Here, there is one template parameter, which is a <strong>Ptr&lt;const MobilityModel&gt;</strong>. This tells you that you need a function that returns void and takes a a <strong>Ptr&lt;const MobilityModel&gt;</strong>.  For example,</p>
<pre>
void
CourseChangeCallback (Ptr&lt;const MobilityModel&gt; model)
{
  ...
}
</pre>
<p>That&apos;s all you need if you want to <strong>Config::ConnectWithoutContext</strong>.  If you want a context, you need to <strong>Config::Connect</strong> and use a Callback function that takes a string context, then the required argument.</p>
<pre>
void
CourseChangeCallback (std::string path, Ptr&lt;const MobilityModel&gt; model)
{
  ...
}
</pre>
<p>If you want to ensure that your <strong>CourseChangeCallback</strong> is only visible in your local file, you can add the keyword <strong>static</strong> and come up with:</p>
<pre>
static void
CourseChangeCallback (std::string path, Ptr&lt;const MobilityModel&gt; model)
{
  ...
}
</pre>
<p>which is exactly what we used in the <strong>third.cc</strong> example.</p>
<h3>The Hard Way</h3>
<p>This section is entirely optional.  It is going to be a bumpy ride, especially for those unfamiliar with the details of templates.  However, if you get through this, you will have a very good handle on a lot of the <em>ns-3</em> low level idioms.</p><p>So, again, let&apos;s figure out what signature of callback function is required for the "CourseChange" Attribute.  This is going to be painful, but you only need to do this once.  After you get through this, you will be able to just look at a <strong>TracedCallback</strong> and understand it.</p><p>The first thing we need to look at is the declaration of the trace source. Recall that this is in <strong>mobility-model.h</strong>, where we have previously found:</p>
<pre>
TracedCallback&lt;Ptr&lt;const MobilityModel&gt; &gt; m_courseChangeTrace;
</pre>
<p>This declaration is for a template.  The template parameter is inside the angle-brackets, so we are really interested in finding out what that <strong>TracedCallback&lt;&gt;</strong> is.  If you have absolutely no idea where this might be found, grep is your friend.</p><p>We are probably going to be interested in some kind of declaration in the <em>ns-3</em> source, so first change into the <strong>src</strong> directory.  Then, we know this declaration is going to have to be in some kind of header file, so just grep for it using:</p>
<pre>
find . -name &apos;*.h&apos; | xargs grep TracedCallback
</pre>
<p>You&apos;ll see 124 lines fly by (I piped this through wc to see how bad it was). Although that may seem like it, that&apos;s not really a lot.  Just pipe the output through more and start scanning through it.  On the first page, you will see some very suspiciously template-looking stuff.</p>
<pre>
TracedCallback&lt;T1,T2,T3,T4,T5,T6,T7,T8&gt;::TracedCallback ()
TracedCallback&lt;T1,T2,T3,T4,T5,T6,T7,T8&gt;::ConnectWithoutContext (c ...
TracedCallback&lt;T1,T2,T3,T4,T5,T6,T7,T8&gt;::Connect (const CallbackB ...
TracedCallback&lt;T1,T2,T3,T4,T5,T6,T7,T8&gt;::DisconnectWithoutContext ...
TracedCallback&lt;T1,T2,T3,T4,T5,T6,T7,T8&gt;::Disconnect (const Callba ...
TracedCallback&lt;T1,T2,T3,T4,T5,T6,T7,T8&gt;::operator() (void) const ...
TracedCallback&lt;T1,T2,T3,T4,T5,T6,T7,T8&gt;::operator() (T1 a1) const ...
TracedCallback&lt;T1,T2,T3,T4,T5,T6,T7,T8&gt;::operator() (T1 a1, T2 a2 ...
TracedCallback&lt;T1,T2,T3,T4,T5,T6,T7,T8&gt;::operator() (T1 a1, T2 a2 ...
TracedCallback&lt;T1,T2,T3,T4,T5,T6,T7,T8&gt;::operator() (T1 a1, T2 a2 ...
TracedCallback&lt;T1,T2,T3,T4,T5,T6,T7,T8&gt;::operator() (T1 a1, T2 a2 ...
TracedCallback&lt;T1,T2,T3,T4,T5,T6,T7,T8&gt;::operator() (T1 a1, T2 a2 ...
TracedCallback&lt;T1,T2,T3,T4,T5,T6,T7,T8&gt;::operator() (T1 a1, T2 a2 ...
</pre>
<p>It turns out that all of this comes from the header file <strong>traced-callback.h</strong> which sounds very promising.  You can then take a look at <strong>mobility-model.h</strong> and see that there is a line which confirms this hunch:</p>
<pre>
#include "ns3/traced-callback.h"
</pre>
<p>Of course, you could have gone at this from the other direction and started by looking at the includes in <strong>mobility-model.h</strong> and noticing the include of <strong>traced-callback.h</strong> and inferring that this must be the file you want.</p><p>In either case, the next step is to take a look at <strong>src/core/model/traced-callback.h</strong> in your favorite editor to see what is happening.</p><p>You will see a comment at the top of the file that should be comforting:</p>
<pre>
An ns3::TracedCallback has almost exactly the same API as a normal ns3::Callback but
instead of forwarding calls to a single function (as an ns3::Callback normally does),
it forwards calls to a chain of ns3::Callback.
</pre>
<p>This should sound very familiar and let you know you are on the right track.</p><p>Just after this comment, you will find,</p>
<pre>
template&lt;typename T1 = empty, typename T2 = empty,
         typename T3 = empty, typename T4 = empty,
         typename T5 = empty, typename T6 = empty,
         typename T7 = empty, typename T8 = empty&gt;
class TracedCallback
{
  ...
</pre>
<p>This tells you that TracedCallback is a templated class.  It has eight possible type parameters with default values.  Go back and compare this with the declaration you are trying to understand:</p>
<pre>
TracedCallback&lt;Ptr&lt;const MobilityModel&gt; &gt; m_courseChangeTrace;
</pre>
<p>The <strong>typename T1</strong> in the templated class declaration corresponds to the <strong>Ptr&lt;const MobilityModel&gt;</strong> in the declaration above.  All of the other type parameters are left as defaults.  Looking at the constructor really doesn&apos;t tell you much.  The one place where you have seen a connection made between your Callback function and the tracing system is in the <strong>Connect</strong> and <strong>ConnectWithoutContext</strong> functions.  If you scroll down, you will see a <strong>ConnectWithoutContext</strong> method here:</p>
<pre>
template&lt;typename T1, typename T2,
         typename T3, typename T4,
         typename T5, typename T6,
         typename T7, typename T8&gt;
void
TracedCallback&lt;T1,T2,T3,T4,T5,T6,T7,T8&gt;::ConnectWithoutContext ...
{
  Callback&lt;void,T1,T2,T3,T4,T5,T6,T7,T8&gt; cb;
  cb.Assign (callback);
  m_callbackList.push_back (cb);
}
</pre>
<p>You are now in the belly of the beast.  When the template is instantiated for the declaration above, the compiler will replace <strong>T1</strong> with <strong>Ptr&lt;const MobilityModel&gt;</strong>.</p>
<pre>
void
TracedCallback&lt;Ptr&lt;const MobilityModel&gt;::ConnectWithoutContext ... cb
{
  Callback&lt;void, Ptr&lt;const MobilityModel&gt; &gt; cb;
  cb.Assign (callback);
  m_callbackList.push_back (cb);
}
</pre>
<p>You can now see the implementation of everything we&apos;ve been talking about.  The code creates a Callback of the right type and assigns your function to it.  This is the equivalent of the <strong>pfi = MyFunction</strong> we discussed at the start of this section.  The code then adds the Callback to the list of Callbacks for this source.  The only thing left is to look at the definition of Callback. Using the same grep trick as we used to find <strong>TracedCallback</strong>, you will be able to find that the file <strong>./core/callback.h</strong> is the one we need to look at.</p><p>If you look down through the file, you will see a lot of probably almost incomprehensible template code.  You will eventually come to some Doxygen for the Callback template class, though.  Fortunately, there is some English:</p>
<pre>
This class template implements the Functor Design Pattern.
It is used to declare the type of a Callback:
 - the first non-optional template argument represents
   the return type of the callback.
 - the second optional template argument represents
   the type of the first argument to the callback.
 - the third optional template argument represents
   the type of the second argument to the callback.
 - the fourth optional template argument represents
   the type of the third argument to the callback.
 - the fifth optional template argument represents
   the type of the fourth argument to the callback.
 - the sixth optional template argument represents
   the type of the fifth argument to the callback.
</pre>
<p>We are trying to figure out what the</p>
<pre>
Callback&lt;void, Ptr&lt;const MobilityModel&gt; &gt; cb;
</pre>
<p>declaration means.  Now we are in a position to understand that the first (non-optional) parameter, <strong>void</strong>, represents the return type of the Callback.  The second (non-optional) parameter, <strong>Ptr&lt;const MobilityModel&gt;</strong> represents the first argument to the callback.</p><p>The Callback in question is your function to receive the trace events.  From this you can infer that you need a function that returns <strong>void</strong> and takes a <strong>Ptr&lt;const MobilityModel&gt;</strong>.  For example,</p>
<pre>
void
CourseChangeCallback (Ptr&lt;const MobilityModel&gt; model)
{
  ...
}
</pre>
<p>That&apos;s all you need if you want to <strong>Config::ConnectWithoutContext</strong>.  If you want a context, you need to <strong>Config::Connect</strong> and use a Callback function that takes a string context.  This is because the <strong>Connect</strong> function will provide the context for you.  You&apos;ll need:</p>
<pre>
void
CourseChangeCallback (std::string path, Ptr&lt;const MobilityModel&gt; model)
{
  ...
}
</pre>
<p>If you want to ensure that your <strong>CourseChangeCallback</strong> is only visible in your local file, you can add the keyword <strong>static</strong> and come up with:</p>
<pre>
static void
CourseChangeCallback (std::string path, Ptr&lt;const MobilityModel&gt; model)
{
  ...
}
</pre>
<p>which is exactly what we used in the <strong>third.cc</strong> example.  Perhaps you should now go back and reread the previous section (Take My Word for It).</p><p>If you are interested in more details regarding the implementation of Callbacks, feel free to take a look at the <em>ns-3</em> manual.  They are one of the most frequently used constructs in the low-level parts of <em>ns-3</em>. It is, in my opinion, a quite elegant thing.</p>
<h3>What About TracedValue?</h3>
<p>Earlier in this section, we presented a simple piece of code that used a <strong>TracedValue&lt;int32_t&gt;</strong> to demonstrate the basics of the tracing code. We just glossed over the way to find the return type and formal arguments for the <strong>TracedValue</strong>.  Rather than go through the whole exercise, we will just point you at the correct file, <strong>src/core/model/traced-value.h</strong> and to the important piece of code:</p>
<pre>
template &lt;typename T&gt;
class TracedValue
{
public:
  ...
  void Set (const T &v) {
    if (m_v != v)
      {
      m_cb (m_v, v);
      m_v = v;
      }
  }
  ...
private:
  T m_v;
  TracedCallback&lt;T,T&gt; m_cb;
};
</pre>
<p>Here you see that the <strong>TracedValue</strong> is templated, of course.  In the simple example case at the start of the section, the typename is int32_t.  This means that the member variable being traced (<strong>m_v</strong> in the private section of the class) will be an <strong>int32_t m_v</strong>.  The <strong>Set</strong> method will take a <strong>const int32_t &v</strong> as a parameter.  You should now be able to understand that the <strong>Set</strong> code will fire the <strong>m_cb</strong> callback with two parameters: the first being the current value of the <strong>TracedValue</strong>; and the second being the new value being set.</p><p>The callback, <strong>m_cb</strong> is declared as a <strong>TracedCallback&lt;T, T&gt;</strong> which will correspond to a <strong>TracedCallback&lt;int32_t, int32_t&gt;</strong> when the class is instantiated.</p><p>Recall that the callback target of a TracedCallback always returns <strong>void</strong>. Further recall that there is a one-to-one correspondence between the template parameter list in the declaration and the formal arguments of the callback function.  Therefore the callback will need to have a function signature that looks like:</p>
<pre>
void
MyCallback (int32_t oldValue, int32_t newValue)
{
  ...
}
</pre>
<p>It probably won&apos;t surprise you that this is exactly what we provided in that simple example we covered so long ago:</p>
<pre>
void
IntTrace (int32_t oldValue, int32_t newValue)
{
  std::cout &lt;&lt; "Traced " &lt;&lt; oldValue &lt;&lt; " to " &lt;&lt; newValue &lt;&lt; std::endl;
}
</pre>

<h3>A Real Example</h3>
<p>Let&apos;s do an example taken from one of the best-known books on TCP around. "TCP/IP Illustrated, Volume 1: The Protocols," by W. Richard Stevens is a classic.  I just flipped the book open and ran across a nice plot of both the congestion window and sequence numbers versus time on page 366.  Stevens calls this, "Figure 21.10. Value of cwnd and send sequence number while data is being transmitted."  Let&apos;s just recreate the cwnd part of that plot in <em>ns-3</em> using the tracing system and <strong>gnuplot</strong>.</p>
<h3>Are There Trace Sources Available?</h3>
<p>The first thing to think about is how we want to get the data out.  What is it that we need to trace?  The first thing to do is to consult "The list of all trace sources" to see what we have to work with.  Recall that this is found in the <em>ns-3</em> Doxygen in the "C++ Constructs Used by All Modules" Module section.  If you scroll through the list, you will eventually find:</p>
<pre>
ns3::TcpNewReno
CongestionWindow: The TCP connection&apos;s congestion window
</pre>
<p>It turns out that the <em>ns-3</em> TCP implementation lives (mostly) in the file <strong>src/internet/model/tcp-socket-base.cc</strong> while congestion control variants are in files such as <strong>src/internet/model/tcp-newreno.cc</strong>. If you don&apos;t know this a priori, you can use the recursive grep trick:</p>
<pre>
find . -name &apos;*.cc&apos; | xargs grep -i tcp
</pre>
<p>You will find page after page of instances of tcp pointing you to that file.</p><p>If you open <strong>src/internet/model/tcp-newreno.cc</strong> in your favorite editor, you will see right up at the top of the file, the following declarations:</p>
<pre>
TypeId
TcpNewReno::GetTypeId ()
{
  static TypeId tid = TypeId("ns3::TcpNewReno")
    .SetParent&lt;TcpSocketBase&gt; ()
    .AddConstructor&lt;TcpNewReno&gt; ()
    .AddTraceSource ("CongestionWindow",
                     "The TCP connection&apos;s congestion window",
                     MakeTraceSourceAccessor (&TcpNewReno::m_cWnd))
    ;
  return tid;
}
</pre>
<p>This should tell you to look for the declaration of <strong>m_cWnd</strong> in the header file <strong>src/internet/model/tcp-newreno.h</strong>.  If you open this file in your favorite editor, you will find:</p>
<pre>
TracedValue&lt;uint32_t&gt; m_cWnd; //Congestion window
</pre>
<p>You should now understand this code completely.  If we have a pointer to the <strong>TcpNewReno</strong>, we can <strong>TraceConnect</strong> to the "CongestionWindow" trace source if we provide an appropriate callback target.  This is the same kind of trace source that we saw in the simple example at the start of this section, except that we are talking about <strong>uint32_t</strong> instead of <strong>int32_t</strong>.</p><p>We now know that we need to provide a callback that returns void and takes two <strong>uint32_t</strong> parameters, the first being the old value and the second being the new value:</p>
<pre>
void
CwndTrace (uint32_t oldValue, uint32_t newValue)
{
  ...
}
</pre>

<h3>What Script to Use?</h3>
<p>It&apos;s always best to try and find working code laying around that you can modify, rather than starting from scratch.  So the first order of business now is to find some code that already hooks the "CongestionWindow" trace source and see if we can modify it.  As usual, grep is your friend:</p>
<pre>
find . -name &apos;*.cc&apos; | xargs grep CongestionWindow
</pre>
<p>This will point out a couple of promising candidates: <strong>examples/tcp/tcp-large-transfer.cc</strong> and <strong>src/test/ns3tcp/ns3tcp-cwnd-test-suite.cc</strong>.</p><p>We haven&apos;t visited any of the test code yet, so let&apos;s take a look there.  You will typically find that test code is fairly minimal, so this is probably a very good bet.  Open <strong>src/test/ns3tcp/ns3tcp-cwnd-test-suite.cc</strong> in your favorite editor and search for "CongestionWindow".  You will find,</p>
<pre>
ns3TcpSocket-&gt;TraceConnectWithoutContext ("CongestionWindow",
  MakeCallback (&Ns3TcpCwndTestCase1::CwndChange, this));
</pre>
<p>This should look very familiar to you.  We mentioned above that if we had a pointer to the <strong>TcpNewReno</strong>, we could <strong>TraceConnect</strong> to the "CongestionWindow" trace source.  That&apos;s exactly what we have here; so it turns out that this line of code does exactly what we want.  Let&apos;s go ahead and extract the code we need from this function (<strong>Ns3TcpCwndTestCase1::DoRun (void)</strong>).  If you look at this function, you will find that it looks just like an <em>ns-3</em> script.  It turns out that is exactly what it is.  It is a script run by the test framework, so we can just pull it out and wrap it in <strong>main</strong> instead of in <strong>DoRun</strong>.  Rather than walk through this, step, by step, we have provided the file that results from porting this test back to a native <em>ns-3</em> script -- <strong>examples/tutorial/fifth.cc</strong>.</p>
<h3>A Common Problem and Solution</h3>
<p>The <strong>fifth.cc</strong> example demonstrates an extremely important rule that you must understand before using any kind of <strong>Attribute</strong>:  you must ensure that the target of a <strong>Config</strong> command exists before trying to use it. This is no different than saying an object must be instantiated before trying to call it.  Although this may seem obvious when stated this way, it does trip up many people trying to use the system for the first time.</p><p>Let&apos;s return to basics for a moment.  There are three basic time periods that exist in any <em>ns-3</em> script.  The first time period is sometimes called "Configuration Time" or "Setup Time," and is in force during the period when the <strong>main</strong> function of your script is running, but before <strong>Simulator::Run</strong> is called.  The second time period  is sometimes called "Simulation Time" and is in force during the time period when <strong>Simulator::Run</strong> is actively executing its events.  After it completes executing the simulation,  <strong>Simulator::Run</strong> will return control back to the <strong>main</strong> function.  When this happens, the script enters what can be called "Teardown Time," which is when the structures and objects created during setup are taken apart and released.</p><p>Perhaps the most common mistake made in trying to use the tracing system is assuming that entities constructed dynamically during simulation time are available during configuration time.  In particular, an <em>ns-3</em> <strong>Socket</strong> is a dynamic object often created by <strong>Applications</strong> to communicate between <strong>Nodes</strong>.  An <em>ns-3</em> <strong>Application</strong> always has a "Start Time" and a "Stop Time" associated with it.  In the vast majority of cases, an <strong>Application</strong> will not attempt to create a dynamic object until its <strong>StartApplication</strong> method is called at some "Start Time".  This is to ensure that the simulation is completely configured before the app tries to do anything (what would happen if it tried to connect to a node that didn&apos;t exist yet during configuration time).  The answer to this issue is to 1) create a simulator event that is run after the dynamic object is created and hook the trace when that event is executed; or 2) create the dynamic object at configuration time, hook it then, and give the object to the system to use during simulation time.  We took the second approach in the <strong>fifth.cc</strong> example.  This decision required us to create the <strong>MyApp</strong> <strong>Application</strong>, the entire purpose of which is to take a <strong>Socket</strong> as a parameter.</p>
<h3>A fifth.cc Walkthrough</h3>
<p>Now, let&apos;s take a look at the example program we constructed by dissecting the congestion window test.  Open <strong>examples/tutorial/fifth.cc</strong> in your favorite editor.  You should see some familiar looking code:</p>
<pre>
/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation;
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Include., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#include &lt;fstream&gt;
#include "ns3/core-module.h"
#include "ns3/network-module.h"
#include "ns3/internet-module.h"
#include "ns3/point-to-point-module.h"
#include "ns3/applications-module.h"

using namespace ns3;

NS_LOG_COMPONENT_DEFINE ("FifthScriptExample");
</pre>
<p>This has all been covered, so we won&apos;t rehash it.  The next lines of source are the network illustration and a comment addressing the problem described above with <strong>Socket</strong>.</p>
<pre>
// ===========================================================================
//
//         node 0                 node 1
//   +----------------+    +----------------+
//   |    ns-3 TCP    |    |    ns-3 TCP    |
//   +----------------+    +----------------+
//   |    10.1.1.1    |    |    10.1.1.2    |
//   +----------------+    +----------------+
//   | point-to-point |    | point-to-point |
//   +----------------+    +----------------+
//           |                     |
//           +---------------------+
//                5 Mbps, 2 ms
//
//
// We want to look at changes in the ns-3 TCP congestion window.  We need
// to crank up a flow and hook the CongestionWindow attribute on the socket
// of the sender.  Normally one would use an on-off application to generate a
// flow, but this has a couple of problems.  First, the socket of the on-off
// application is not created until Application Start time, so we wouldn&apos;t be
// able to hook the socket (now) at configuration time.  Second, even if we
// could arrange a call after start time, the socket is not public so we
// couldn&apos;t get at it.
//
// So, we can cook up a simple version of the on-off application that does what
// we want.  On the plus side we don&apos;t need all of the complexity of the on-off
// application.  On the minus side, we don&apos;t have a helper, so we have to get
// a little more involved in the details, but this is trivial.
//
// So first, we create a socket and do the trace connect on it; then we pass
// this socket into the constructor of our simple application which we then
// install in the source node.
// ===========================================================================
//
</pre>
<p>This should also be self-explanatory.</p><p>The next part is the declaration of the <strong>MyApp</strong> <strong>Application</strong> that we put together to allow the <strong>Socket</strong> to be created at configuration time.</p>
<pre>
class MyApp : public Application
{
public:

  MyApp ();
  virtual ~MyApp();

  void Setup (Ptr&lt;Socket&gt; socket, Address address, uint32_t packetSize,
    uint32_t nPackets, DataRate dataRate);

private:
  virtual void StartApplication (void);
  virtual void StopApplication (void);

  void ScheduleTx (void);
  void SendPacket (void);

  Ptr&lt;Socket&gt;     m_socket;
  Address         m_peer;
  uint32_t        m_packetSize;
  uint32_t        m_nPackets;
  DataRate        m_dataRate;
  EventId         m_sendEvent;
  bool            m_running;
  uint32_t        m_packetsSent;
};
</pre>
<p>You can see that this class inherits from the <em>ns-3</em> <strong>Application</strong> class.  Take a look at <strong>src/network/model/application.h</strong> if you are interested in what is inherited.  The <strong>MyApp</strong> class is obligated to override the <strong>StartApplication</strong> and <strong>StopApplication</strong> methods.  These methods are automatically called when <strong>MyApp</strong> is required to start and stop sending data during the simulation.</p>
<h3>How Applications are Started and Stopped (optional)</h3>
<p>It is worthwhile to spend a bit of time explaining how events actually get started in the system.  This is another fairly deep explanation, and can be ignored if you aren&apos;t planning on venturing down into the guts of the system. It is useful, however, in that the discussion touches on how some very important parts of <em>ns-3</em> work and exposes some important idioms.  If you are planning on implementing new models, you probably want to understand this section.</p><p>The most common way to start pumping events is to start an <strong>Application</strong>. This is done as the result of the following (hopefully) familar lines of an <em>ns-3</em> script:</p>
<pre>
ApplicationContainer apps = ...
apps.Start (Seconds (1.0));
apps.Stop (Seconds (10.0));
</pre>
<p>The application container code (see <strong>src/network/helper/application-container.h</strong> if you are interested) loops through its contained applications and calls,</p>
<pre>
app-&gt;SetStartTime (startTime);
</pre>
<p>as a result of the <strong>apps.Start</strong> call and</p>
<pre>
app-&gt;SetStopTime (stopTime);
</pre>
<p>as a result of the <strong>apps.Stop</strong> call.</p><p>The ultimate result of these calls is that we want to have the simulator automatically make calls into our <strong>Applications</strong> to tell them when to start and stop.  In the case of <strong>MyApp</strong>, it inherits from class <strong>Application</strong> and overrides <strong>StartApplication</strong>, and <strong>StopApplication</strong>.  These are the functions that will be called by the simulator at the appropriate time.  In the case of <strong>MyApp</strong> you will find that <strong>MyApp::StartApplication</strong> does the initial <strong>Bind</strong>, and <strong>Connect</strong> on the socket, and then starts data flowing by calling <strong>MyApp::SendPacket</strong>.  <strong>MyApp::StopApplication</strong> stops generating packets by cancelling any pending send events and closing the socket.</p><p>One of the nice things about <em>ns-3</em> is that you can completely ignore the implementation details of how your <strong>Application</strong> is "automagically" called by the simulator at the correct time.  But since we have already ventured deep into <em>ns-3</em> already, let&apos;s go for it.</p><p>If you look at <strong>src/network/model/application.cc</strong> you will find that the <strong>SetStartTime</strong> method of an <strong>Application</strong> just sets the member variable <strong>m_startTime</strong> and the <strong>SetStopTime</strong> method just sets <strong>m_stopTime</strong>.  From there, without some hints, the trail will probably end.</p><p>The key to picking up the trail again is to know that there is a global list of all of the nodes in the system.  Whenever you create a node in a simulation, a pointer to that node is added to the global <strong>NodeList</strong>.</p><p>Take a look at <strong>src/network/model/node-list.cc</strong> and search for <strong>NodeList::Add</strong>.  The public static implementation calls into a private implementation called <strong>NodeListPriv::Add</strong>.  This is a relatively common idom in <em>ns-3</em>.  So, take a look at <strong>NodeListPriv::Add</strong>.  There you will find,</p>
<pre>
Simulator::ScheduleWithContext (index, TimeStep (0), &Node::Initialize, node);
</pre>
<p>This tells you that whenever a <strong>Node</strong> is created in a simulation, as a side-effect, a call to that node&apos;s <strong>Initialize</strong> method is scheduled for you that happens at time zero.  Don&apos;t read too much into that name, yet. It doesn&apos;t mean that the node is going to start doing anything, it can be interpreted as an informational call into the <strong>Node</strong> telling it that the simulation has started, not a call for action telling the <strong>Node</strong> to start doing something.</p><p>So, <strong>NodeList::Add</strong> indirectly schedules a call to <strong>Node::Initialize</strong> at time zero to advise a new node that the simulation has started.  If you look in <strong>src/network/model/node.h</strong> you will, however, not find a method called <strong>Node::Initialize</strong>.  It turns out that the <strong>Initialize</strong> method is inherited from class <strong>Object</strong>.  All objects in the system can be notified when the simulation starts, and objects of class <strong>Node</strong> are just one kind of those objects.</p><p>Take a look at <strong>src/core/model/object.cc</strong> next and search for <strong>Object::Initialize</strong>. This code is not as straightforward as you might have expected since <em>ns-3</em> <strong>Objects</strong> support aggregation.  The code in <strong>Object::Initialize</strong> then loops through all of the objects that have been aggregated together and calls their <strong>DoInitialize</strong> method.  This is another idiom that is very common in <em>ns-3</em>.  There is a public API method, that stays constant across implementations, that calls a private implementation method that is inherited and implemented by subclasses.  The names are typically something like <strong>MethodName</strong> for the public API and <strong>DoMethodName</strong> for the private API.</p><p>This tells us that we should look for a <strong>Node::DoInitialize</strong> method in <strong>src/network/model/node.cc</strong> for the method that will continue our trail.  If you locate the code, you will find a method that loops through all of the devices in the node and then all of the applications in the node calling <strong>device-&gt;Initialize</strong> and <strong>application-&gt;Initialize</strong> respectively.</p><p>You may already know that classes <strong>Device</strong> and <strong>Application</strong> both inherit from class <strong>Object</strong> and so the next step will be to look at what happens when <strong>Application::DoInitialize</strong> is called.  Take a look at <strong>src/network/model/application.cc</strong> and you will find:</p>
<pre>
void
Application::DoInitialize (void)
{
  m_startEvent = Simulator::Schedule (m_startTime, &Application::StartApplication, this);
  if (m_stopTime != TimeStep (0))
    {
      m_stopEvent = Simulator::Schedule (m_stopTime, &Application::StopApplication, this);
    }
  Object::DoInitialize ();
}
</pre>
<p>Here, we finally come to the end of the trail.  If you have kept it all straight, when you implement an <em>ns-3</em> <strong>Application</strong>, your new application inherits from class <strong>Application</strong>.  You override the <strong>StartApplication</strong> and <strong>StopApplication</strong> methods and provide mechanisms for starting and stopping the flow of data out of your new <strong>Application</strong>.  When a <strong>Node</strong> is created in the simulation, it is added to a global <strong>NodeList</strong>.  The act of adding a node to this <strong>NodeList</strong> causes a simulator event to be scheduled for time zero which calls the <strong>Node::Initialize</strong> method of the newly added <strong>Node</strong> to be called when the simulation starts.  Since a <strong>Node</strong> inherits from <strong>Object</strong>, this calls the <strong>Object::Initialize</strong> method on the <strong>Node</strong> which, in turn, calls the <strong>DoInitialize</strong> methods on all of the <strong>Objects</strong> aggregated to the <strong>Node</strong> (think mobility models).  Since the <strong>Node</strong> <strong>Object</strong> has overridden <strong>DoInitialize</strong>, that method is called when the simulation starts.  The <strong>Node::DoInitialize</strong> method calls the <strong>Initialize</strong> methods of all of the <strong>Applications</strong> on the node.  Since <strong>Applications</strong> are also <strong>Objects</strong>, this causes <strong>Application::DoInitialize</strong> to be called.  When <strong>Application::DoInitialize</strong> is called, it schedules events for the <strong>StartApplication</strong> and <strong>StopApplication</strong> calls on the <strong>Application</strong>. These calls are designed to start and stop the flow of data from the <strong>Application</strong></p><p>This has been another fairly long journey, but it only has to be made once, and you now understand another very deep piece of <em>ns-3</em>.</p>
<h3>The MyApp Application</h3>
<p>The <strong>MyApp</strong> <strong>Application</strong> needs a constructor and a destructor, of course:</p>
<pre>
MyApp::MyApp ()
  : m_socket (0),
    m_peer (),
    m_packetSize (0),
    m_nPackets (0),
    m_dataRate (0),
    m_sendEvent (),
    m_running (false),
    m_packetsSent (0)
{
}

MyApp::~MyApp()
{
  m_socket = 0;
}
</pre>
<p>The existence of the next bit of code is the whole reason why we wrote this <strong>Application</strong> in the first place.</p>
<pre>
void
MyApp::Setup (Ptr&lt;Socket&gt; socket, Address address, uint32_t packetSize,
                     uint32_t nPackets, DataRate dataRate)
{
  m_socket = socket;
  m_peer = address;
  m_packetSize = packetSize;
  m_nPackets = nPackets;
  m_dataRate = dataRate;
}
</pre>
<p>This code should be pretty self-explanatory.  We are just initializing member variables.  The important one from the perspective of tracing is the <strong>Ptr&lt;Socket&gt; socket</strong> which we needed to provide to the application during configuration time.  Recall that we are going to create the <strong>Socket</strong> as a <strong>TcpSocket</strong> (which is implemented by <strong>TcpNewReno</strong>) and hook its "CongestionWindow" trace source before passing it to the <strong>Setup</strong> method.</p>
<pre>
void
MyApp::StartApplication (void)
{
  m_running = true;
  m_packetsSent = 0;
  m_socket-&gt;Bind ();
  m_socket-&gt;Connect (m_peer);
  SendPacket ();
}
</pre>
<p>The above code is the overridden implementation <strong>Application::StartApplication</strong> that will be automatically called by the simulator to start our <strong>Application</strong> running at the appropriate time.  You can see that it does a <strong>Socket</strong> <strong>Bind</strong> operation.  If you are familiar with Berkeley Sockets this shouldn&apos;t be a surprise. It performs the required work on the local side of the connection just as you might expect.  The following <strong>Connect</strong> will do what is required to establish a connection with the TCP at <strong>Address</strong> m_peer.  It should now be clear why we need to defer a lot of this to simulation time, since the <strong>Connect</strong> is going to need a fully functioning network to complete.  After the <strong>Connect</strong>, the <strong>Application</strong> then starts creating simulation events by calling <strong>SendPacket</strong>.</p><p>The next bit of code explains to the <strong>Application</strong> how to stop creating simulation events.</p>
<pre>
void
MyApp::StopApplication (void)
{
  m_running = false;

  if (m_sendEvent.IsRunning ())
    {
      Simulator::Cancel (m_sendEvent);
    }

  if (m_socket)
    {
      m_socket-&gt;Close ();
    }
}
</pre>
<p>Every time a simulation event is scheduled, an <strong>Event</strong> is created.  If the <strong>Event</strong> is pending execution or executing, its method <strong>IsRunning</strong> will return <strong>true</strong>.  In this code, if <strong>IsRunning()</strong> returns true, we <strong>Cancel</strong> the event which removes it from the simulator event queue.  By doing this, we break the chain of events that the <strong>Application</strong> is using to keep sending its <strong>Packets</strong> and the <strong>Application</strong> goes quiet.  After we quiet the <strong>Application</strong> we <strong>Close</strong> the socket which tears down the TCP connection.</p><p>The socket is actually deleted in the destructor when the <strong>m_socket = 0</strong> is executed.  This removes the last reference to the underlying Ptr&lt;Socket&gt; which causes the destructor of that Object to be called.</p><p>Recall that <strong>StartApplication</strong> called <strong>SendPacket</strong> to start the chain of events that describes the <strong>Application</strong> behavior.</p>
<pre>
void
MyApp::SendPacket (void)
{
  Ptr&lt;Packet&gt; packet = Create&lt;Packet&gt; (m_packetSize);
  m_socket-&gt;Send (packet);

  if (++m_packetsSent &lt; m_nPackets)
    {
      ScheduleTx ();
    }
}
</pre>
<p>Here, you see that <strong>SendPacket</strong> does just that.  It creates a <strong>Packet</strong> and then does a <strong>Send</strong> which, if you know Berkeley Sockets, is probably just what you expected to see.</p><p>It is the responsibility of the <strong>Application</strong> to keep scheduling the chain of events, so the next lines call <strong>ScheduleTx</strong> to schedule another transmit event (a <strong>SendPacket</strong>) until the <strong>Application</strong> decides it has sent enough.</p>
<pre>
void
MyApp::ScheduleTx (void)
{
  if (m_running)
    {
      Time tNext (Seconds (m_packetSize * 8 / static_cast&lt;double&gt; (m_dataRate.GetBitRate ())));
      m_sendEvent = Simulator::Schedule (tNext, &MyApp::SendPacket, this);
    }
}
</pre>
<p>Here, you see that <strong>ScheduleTx</strong> does exactly that.  If the <strong>Application</strong> is running (if <strong>StopApplication</strong> has not been called) it will schedule a new event, which calls <strong>SendPacket</strong> again.  The alert reader will spot something that also trips up new users.  The data rate of an <strong>Application</strong> is just that.  It has nothing to do with the data rate of an underlying <strong>Channel</strong>. This is the rate at which the <strong>Application</strong> produces bits.  It does not take into account any overhead for the various protocols or channels that it uses to transport the data.  If you set the data rate of an <strong>Application</strong> to the same data rate as your underlying <strong>Channel</strong> you will eventually get a buffer overflow.</p>
<h3>The Trace Sinks</h3>
<p>The whole point of this exercise is to get trace callbacks from TCP indicating the congestion window has been updated.  The next piece of code implements the corresponding trace sink:</p>
<pre>
static void
CwndChange (uint32_t oldCwnd, uint32_t newCwnd)
{
  NS_LOG_UNCOND (Simulator::Now ().GetSeconds () &lt;&lt; "&#92;t" &lt;&lt; newCwnd);
}
</pre>
<p>This should be very familiar to you now, so we won&apos;t dwell on the details.  This function just logs the current simulation time and the new value of the congestion window every time it is changed.  You can probably imagine that you could load the resulting output into a graphics program (gnuplot or Excel) and immediately see a nice graph of the congestion window behavior over time.</p><p>We added a new trace sink to show where packets are dropped.  We are going to add an error model to this code also, so we wanted to demonstrate this working.</p>
<pre>
static void
RxDrop (Ptr&lt;const Packet&gt; p)
{
  NS_LOG_UNCOND ("RxDrop at " &lt;&lt; Simulator::Now ().GetSeconds ());
}
</pre>
<p>This trace sink will be connected to the "PhyRxDrop" trace source of the point-to-point NetDevice.  This trace source fires when a packet is dropped by the physical layer of a <strong>NetDevice</strong>.  If you take a small detour to the source (<strong>src/point-to-point/model/point-to-point-net-device.cc</strong>) you will see that this trace source refers to <strong>PointToPointNetDevice::m_phyRxDropTrace</strong>. If you then look in <strong>src/point-to-point/model/point-to-point-net-device.h</strong> for this member variable, you will find that it is declared as a <strong>TracedCallback&lt;Ptr&lt;const Packet&gt; &gt;</strong>.  This should tell you that the callback target should be a function that returns void and takes a single parameter which is a <strong>Ptr&lt;const Packet&gt;</strong> -- just what we have above.</p>
<h3>The Main Program</h3>
<p>The following code should be very familiar to you by now:</p>
<pre>
int
main (int argc, char *argv[])
{
  NodeContainer nodes;
  nodes.Create (2);

  PointToPointHelper pointToPoint;
  pointToPoint.SetDeviceAttribute ("DataRate", StringValue ("5Mbps"));
  pointToPoint.SetChannelAttribute ("Delay", StringValue ("2ms"));

  NetDeviceContainer devices;
  devices = pointToPoint.Install (nodes);
</pre>
<p>This creates two nodes with a point-to-point channel between them, just as shown in the illustration at the start of the file.</p><p>The next few lines of code show something new.  If we trace a connection that behaves perfectly, we will end up with a monotonically increasing congestion window.  To see any interesting behavior, we really want to introduce link errors which will drop packets, cause duplicate ACKs and trigger the more interesting behaviors of the congestion window.</p><p><em>ns-3</em> provides <strong>ErrorModel</strong> objects which can be attached to <strong>Channels</strong>.  We are using the <strong>RateErrorModel</strong> which allows us to introduce errors into a <strong>Channel</strong> at a given <em>rate</em>.</p>
<pre>
Ptr&lt;RateErrorModel&gt; em = CreateObject&lt;RateErrorModel&gt; ();
em-&gt;SetAttribute ("ErrorRate", DoubleValue (0.00001));
devices.Get (1)-&gt;SetAttribute ("ReceiveErrorModel", PointerValue (em));
</pre>
<p>The above code instantiates a <strong>RateErrorModel</strong> Object, and we set the "ErrorRate" <strong>Attribute</strong> to the desired value. We then set the resulting instantiated <strong>RateErrorModel</strong> as the error model used by the point-to-point <strong>NetDevice</strong>.  This will give us some retransmissions and make our plot a little more interesting.</p>
<pre>
InternetStackHelper stack;
stack.Install (nodes);

Ipv4AddressHelper address;
address.SetBase ("10.1.1.0", "255.255.255.252");
Ipv4InterfaceContainer interfaces = address.Assign (devices);
</pre>
<p>The above code should be familiar.  It installs internet stacks on our two nodes and creates interfaces and assigns IP addresses for the point-to-point devices.</p><p>Since we are using TCP, we need something on the destination node to receive TCP connections and data.  The <strong>PacketSink</strong> <strong>Application</strong> is commonly used in <em>ns-3</em> for that purpose.</p>
<pre>
uint16_t sinkPort = 8080;
Address sinkAddress (InetSocketAddress(interfaces.GetAddress (1), sinkPort));
PacketSinkHelper packetSinkHelper ("ns3::TcpSocketFactory",
  InetSocketAddress (Ipv4Address::GetAny (), sinkPort));
ApplicationContainer sinkApps = packetSinkHelper.Install (nodes.Get (1));
sinkApps.Start (Seconds (0.));
sinkApps.Stop (Seconds (20.));
</pre>
<p>This should all be familiar, with the exception of,</p>
<pre>
PacketSinkHelper packetSinkHelper ("ns3::TcpSocketFactory",
  InetSocketAddress (Ipv4Address::GetAny (), sinkPort));
</pre>
<p>This code instantiates a <strong>PacketSinkHelper</strong> and tells it to create sockets using the class <strong>ns3::TcpSocketFactory</strong>.  This class implements a design pattern called "object factory" which is a commonly used mechanism for specifying a class used to create objects in an abstract way.  Here, instead of having to create the objects themselves, you provide the <strong>PacketSinkHelper</strong> a string that specifies a <strong>TypeId</strong> string used to create an object which can then be used, in turn, to create instances of the Objects created by the factory.</p><p>The remaining parameter tells the <strong>Application</strong> which address and port it should <strong>Bind</strong> to.</p><p>The next two lines of code will create the socket and connect the trace source.</p>
<pre>
Ptr&lt;Socket&gt; ns3TcpSocket = Socket::CreateSocket (nodes.Get (0),
  TcpSocketFactory::GetTypeId ());
ns3TcpSocket-&gt;TraceConnectWithoutContext ("CongestionWindow",
  MakeCallback (&CwndChange));
</pre>
<p>The first statement calls the static member function <strong>Socket::CreateSocket</strong> and provides a <strong>Node</strong> and an explicit <strong>TypeId</strong> for the object factory used to create the socket.  This is a slightly lower level call than the <strong>PacketSinkHelper</strong> call above, and uses an explicit C++ type instead of one referred to by a string.  Otherwise, it is conceptually the same thing.</p><p>Once the <strong>TcpSocket</strong> is created and attached to the <strong>Node</strong>, we can use <strong>TraceConnectWithoutContext</strong> to connect the CongestionWindow trace source to our trace sink.</p><p>Recall that we coded an <strong>Application</strong> so we could take that <strong>Socket</strong> we just made (during configuration time) and use it in simulation time.  We now have to instantiate that <strong>Application</strong>.  We didn&apos;t go to any trouble to create a helper to manage the <strong>Application</strong> so we are going to have to create and install it "manually".  This is actually quite easy:</p>
<pre>
Ptr&lt;MyApp&gt; app = CreateObject&lt;MyApp&gt; ();
app-&gt;Setup (ns3TcpSocket, sinkAddress, 1040, 1000, DataRate ("1Mbps"));
nodes.Get (0)-&gt;AddApplication (app);
app-&gt;Start (Seconds (1.));
app-&gt;Stop (Seconds (20.));
</pre>
<p>The first line creates an <strong>Object</strong> of type <strong>MyApp</strong> -- our <strong>Application</strong>.  The second line tells the <strong>Application</strong> what <strong>Socket</strong> to use, what address to connect to, how much data to send at each send event, how many send events to generate and the rate at which to produce data from those events.</p><p>Next, we manually add the <strong>MyApp Application</strong> to the source node and explicitly call the <strong>Start</strong> and <strong>Stop</strong> methods on the <strong>Application</strong> to tell it when to start and stop doing its thing.</p><p>We need to actually do the connect from the receiver point-to-point <strong>NetDevice</strong> to our callback now.</p>
<pre>
devices.Get (1)-&gt;TraceConnectWithoutContext("PhyRxDrop", MakeCallback (&RxDrop));
</pre>
<p>It should now be obvious that we are getting a reference to the receiving <strong>Node NetDevice</strong> from its container and connecting the trace source defined by the attribute "PhyRxDrop" on that device to the trace sink <strong>RxDrop</strong>.</p><p>Finally, we tell the simulator to override any <strong>Applications</strong> and just stop processing events at 20 seconds into the simulation.</p>
<pre>
  Simulator::Stop (Seconds(20));
  Simulator::Run ();
  Simulator::Destroy ();

  return 0;
}
</pre>
<p>Recall that as soon as <strong>Simulator::Run</strong> is called, configuration time ends, and simulation time begins.  All of the work we orchestrated by creating the <strong>Application</strong> and teaching it how to connect and send data actually happens during this function call.</p><p>As soon as <strong>Simulator::Run</strong> returns, the simulation is complete and we enter the teardown phase.  In this case, <strong>Simulator::Destroy</strong> takes care of the gory details and we just return a success code after it completes.</p>
<h3>Running fifth.cc</h3>
<p>Since we have provided the file <strong>fifth.cc</strong> for you, if you have built your distribution (in debug mode since it uses NS_LOG -- recall that optimized builds optimize out NS_LOGs) it will be waiting for you to run.</p>
<pre>
./waf --run fifth
Waf: Entering directory \(ga/home/craigdo/repos/ns-3-allinone-dev/ns-3-dev/build
Waf: Leaving directory \(ga/home/craigdo/repos/ns-3-allinone-dev/ns-3-dev/build&apos;
&apos;build&apos; finished successfully (0.684s)
1.20919 1072
1.21511 1608
1.22103 2144
...
1.2471  8040
1.24895 8576
1.2508  9112
RxDrop at 1.25151
...
</pre>
<p>You can probably see immediately a downside of using prints of any kind in your traces.  We get those extraneous waf messages printed all over our interesting information along with those RxDrop messages.  We will remedy that soon, but I&apos;m sure you can&apos;t wait to see the results of all of this work.  Let&apos;s redirect that output to a file called <strong>cwnd.dat</strong>:</p>
<pre>
./waf --run fifth &gt; cwnd.dat 2&gt;&1
</pre>
<p>Now edit up "cwnd.dat" in your favorite editor and remove the waf build status and drop lines, leaving only the traced data (you could also comment out the <strong>TraceConnectWithoutContext("PhyRxDrop", MakeCallback (&RxDrop));</strong> in the script to get rid of the drop prints just as easily.</p><p>You can now run gnuplot (if you have it installed) and tell it to generate some pretty pictures:</p>
<pre>
gnuplot&gt; set terminal png size 640,480
gnuplot&gt; set output "cwnd.png"
gnuplot&gt; plot "cwnd.dat" using 1:2 title &apos;Congestion Window&apos; with linespoints
gnuplot&gt; exit
</pre>
<p>You should now have a graph of the congestion window versus time sitting in the file "cwnd.png" that looks like: [image]</p>
<h3>Using Mid-Level Helpers</h3>
<p>In the previous section, we showed how to hook a trace source and get hopefully interesting information out of a simulation.  Perhaps you will recall that we called logging to the standard output using <strong>std::cout</strong> a "Blunt Instrument" much earlier in this chapter.  We also wrote about how it was a problem having to parse the log output in order to isolate interesting information.  It may have occurred to you that we just spent a lot of time implementing an example that exhibits all of the problems we purport to fix with the <em>ns-3</em> tracing system!  You would be correct.  But, bear with us.  We&apos;re not done yet.</p><p>One of the most important things we want to do is to is to have the ability to easily control the amount of output coming out of the simulation; and we also want to save those data to a file so we can refer back to it later.  We can use the mid-level trace helpers provided in <em>ns-3</em> to do just that and complete the picture.</p><p>We provide a script that writes the cwnd change and drop events developed in the example <strong>fifth.cc</strong> to disk in separate files.  The cwnd changes are stored as a tab-separated ASCII file and the drop events are stored in a pcap file.  The changes to make this happen are quite small.</p>
<h3>A sixth.cc Walkthrough</h3>
<p>Let&apos;s take a look at the changes required to go from <strong>fifth.cc</strong> to <strong>sixth.cc</strong>.  Open <strong>examples/tutorial/fifth.cc</strong> in your favorite editor.  You can see the first change by searching for CwndChange.  You will find that we have changed the signatures for the trace sinks and have added a single line to each sink that writes the traced information to a stream representing a file.</p>
<pre>
static void
CwndChange (Ptr&lt;OutputStreamWrapper&gt; stream, uint32_t oldCwnd, uint32_t newCwnd)
{
  NS_LOG_UNCOND (Simulator::Now ().GetSeconds () &lt;&lt; "&#92;t" &lt;&lt; newCwnd);
  *stream-&gt;GetStream () &lt;&lt; Simulator::Now ().GetSeconds () &lt;&lt; "&#92;t" &lt;&lt; oldCwnd &lt;&lt; "&#92;t" &lt;&lt; newCwnd &lt;&lt; std::endl;
}

static void
RxDrop (Ptr&lt;PcapFileWrapper&gt; file, Ptr&lt;const Packet&gt; p)
{
  NS_LOG_UNCOND ("RxDrop at " &lt;&lt; Simulator::Now ().GetSeconds ());
  file-&gt;Write(Simulator::Now(), p);
}
</pre>
<p>We have added a "stream" parameter to the <strong>CwndChange</strong> trace sink. This is an object that holds (keeps safely alive) a C++ output stream.  It turns out that this is a very simple object, but one that manages lifetime issues for the stream and solves a problem that even experienced C++ users run into.  It turns out that the copy constructor for ostream is marked private.  This means that ostreams do not obey value semantics and cannot be used in any mechanism that requires the stream to be copied.  This includes the <em>ns-3</em> callback system, which as you may recall, requires objects that obey value semantics.  Further notice that we have added the following line in the <strong>CwndChange</strong> trace sink implementation:</p>
<pre>
*stream-&gt;GetStream () &lt;&lt; Simulator::Now ().GetSeconds () &lt;&lt; "&#92;t" &lt;&lt; oldCwnd &lt;&lt; "&#92;t" &lt;&lt; newCwnd &lt;&lt; std::endl;
</pre>
<p>This would be very familiar code if you replaced <strong>*stream-&gt;GetStream ()</strong> with <strong>std::cout</strong>, as in:</p>
<pre>
std::cout &lt;&lt; Simulator::Now ().GetSeconds () &lt;&lt; "&#92;t" &lt;&lt; oldCwnd &lt;&lt; "&#92;t" &lt;&lt; newCwnd &lt;&lt; std::endl;
</pre>
<p>This illustrates that the <strong>Ptr&lt;OutputStreamWrapper&gt;</strong> is really just carrying around a <strong>std::ofstream</strong> for you, and you can use it here like any other output stream.</p><p>A similar situation happens in <strong>RxDrop</strong> except that the object being passed around (a <strong>Ptr&lt;PcapFileWrapper&gt;</strong>) represents a pcap file.  There is a one-liner in the trace sink to write a timestamp and the contents of the packet being dropped to the pcap file:</p>
<pre>
file-&gt;Write(Simulator::Now(), p);
</pre>
<p>Of course, if we have objects representing the two files, we need to create them somewhere and also cause them to be passed to the trace sinks.  If you look in the <strong>main</strong> function, you will find new code to do just that:</p>
<pre>
AsciiTraceHelper asciiTraceHelper;
Ptr&lt;OutputStreamWrapper&gt; stream = asciiTraceHelper.CreateFileStream ("sixth.cwnd");
ns3TcpSocket-&gt;TraceConnectWithoutContext ("CongestionWindow", MakeBoundCallback (&CwndChange, stream));

...

PcapHelper pcapHelper;
Ptr&lt;PcapFileWrapper&gt; file = pcapHelper.CreateFile ("sixth.pcap", std::ios::out, PcapHelper::DLT_PPP);
devices.Get (1)-&gt;TraceConnectWithoutContext("PhyRxDrop", MakeBoundCallback (&RxDrop, file));
</pre>
<p>In the first section of the code snippet above, we are creating the ASCII trace file, creating an object responsible for managing it and using a variant of the callback creation function to arrange for the object to be passed to the sink.  Our ASCII trace helpers provide a rich set of functions to make using text (ASCII) files easy.  We are just going to illustrate the use of the file stream creation function here.</p><p>The <strong>CreateFileStream{}</strong> function is basically going to instantiate a std::ofstream object and create a new file (or truncate an existing file). This ofstream is packaged up in an <em>ns-3</em> object for lifetime management and copy constructor issue resolution.</p><p>We then take this <em>ns-3</em> object representing the file and pass it to <strong>MakeBoundCallback()</strong>.  This function creates a callback just like <strong>MakeCallback()</strong>, but it "binds" a new value to the callback.  This value is added to the callback before it is called.</p><p>Essentially, <strong>MakeBoundCallback(&CwndChange, stream)</strong> causes the trace source to add the additional "stream" parameter to the front of the formal parameter list before invoking the callback.  This changes the required signature of the <strong>CwndChange</strong> sink to match the one shown above, which includes the "extra" parameter <strong>Ptr&lt;OutputStreamWrapper&gt; stream</strong>.</p><p>In the second section of code in the snippet above, we instantiate a <strong>PcapHelper</strong> to do the same thing for our pcap trace file that we did with the <strong>AsciiTraceHelper</strong>. The line of code,</p>
<pre>
Ptr&lt;PcapFileWrapper&gt; file = pcapHelper.CreateFile ("sixth.pcap", "w", PcapHelper::DLT_PPP);
</pre>
<p>creates a pcap file named "sixth.pcap" with file mode "w".   This means that the new file is to truncated if an existing file with that name is found.  The final parameter is the "data link type" of the new pcap file.  These are the same as the pcap library data link types defined in <strong>bpf.h</strong> if you are familar with pcap.  In this case, <strong>DLT_PPP</strong> indicates that the pcap file is going to contain packets prefixed with point to point headers.  This is true since the packets are coming from our point-to-point device driver.  Other common data link types are DLT_EN10MB (10 MB Ethernet) appropriate for csma devices and DLT_IEEE802_11 (IEEE 802.11) appropriate for wifi devices.  These are defined in <strong>src/network/helper/trace-helper.h"</strong> if you are interested in seeing the list.  The entries in the list match those in <strong>bpf.h</strong> but we duplicate them to avoid a pcap source dependence.</p><p>A <em>ns-3</em> object representing the pcap file is returned from <strong>CreateFile</strong> and used in a bound callback exactly as it was in the ascii case.</p><p>An important detour:  It is important to notice that even though both of these objects are declared in very similar ways,</p>
<pre>
Ptr&lt;PcapFileWrapper&gt; file ...
Ptr&lt;OutputStreamWrapper&gt; stream ...
</pre>
<p>The underlying objects are entirely different.  For example, the Ptr&lt;PcapFileWrapper&gt; is a smart pointer to an <em>ns-3</em> Object that is a fairly heaviweight thing that supports <strong>Attributes</strong> and is integrated into the config system.  The Ptr&lt;OutputStreamWrapper&gt;, on the other hand, is a smart pointer to a reference counted object that is a very lightweight thing. Remember to always look at the object you are referencing before making any assumptions about the "powers" that object may have.</p><p>For example, take a look at <strong>src/network/utils/pcap-file-wrapper.h</strong> in the distribution and notice,</p>
<pre>
class PcapFileWrapper : public Object
</pre>
<p>that class <strong>PcapFileWrapper</strong> is an <em>ns-3</em> Object by virtue of its inheritance.  Then look at <strong>src/network/model/output-stream-wrapper.h</strong> and notice,</p>
<pre>
class OutputStreamWrapper : public SimpleRefCount&lt;OutputStreamWrapper&gt;
</pre>
<p>that this object is not an <em>ns-3</em> Object at all, it is "merely" a C++ object that happens to support intrusive reference counting.</p><p>The point here is that just because you read Ptr&lt;something&gt; it does not necessarily mean that "something" is an <em>ns-3</em> Object on which you can hang <em>ns-3</em> <strong>Attributes</strong>, for example.</p><p>Now, back to the example.  If you now build and run this example,</p>
<pre>
./waf --run sixth
</pre>
<p>you will see the same messages appear as when you ran "fifth", but two new files will appear in the top-level directory of your <em>ns-3</em> distribution.</p>
<pre>
sixth.cwnd  sixth.pcap
</pre>
<p>Since "sixth.cwnd" is an ASCII text file, you can view it with <strong>cat</strong> or your favorite file viewer.</p>
<pre>
1.20919 536     1072
1.21511 1072    1608
...
9.30922 8893    8925
9.31754 8925    8957
</pre>
<p>You have a tab separated file with a timestamp, an old congestion window and a new congestion window suitable for directly importing into your plot program. There are no extraneous prints in the file, no parsing or editing is required.</p><p>Since "sixth.pcap" is a pcap file, you can fiew it with <strong>tcpdump</strong>.</p>
<pre>
reading from file ../../sixth.pcap, link-type PPP (PPP)
1.251507 IP 10.1.1.1.49153 &gt; 10.1.1.2.8080: . 17689:18225(536) ack 1 win 65535
1.411478 IP 10.1.1.1.49153 &gt; 10.1.1.2.8080: . 33808:34312(504) ack 1 win 65535
...
7.393557 IP 10.1.1.1.49153 &gt; 10.1.1.2.8080: . 781568:782072(504) ack 1 win 65535
8.141483 IP 10.1.1.1.49153 &gt; 10.1.1.2.8080: . 874632:875168(536) ack 1 win 65535
</pre>
<p>You have a pcap file with the packets that were dropped in the simulation.  There are no other packets present in the file and there is nothing else present to make life difficult.</p><p>It&apos;s been a long journey, but we are now at a point where we can appreciate the <em>ns-3</em> tracing system.  We have pulled important events out of the middle of a TCP implementation and a device driver.  We stored those events directly in files usable with commonly known tools.  We did this without modifying any of the core code involved, and we did this in only 18 lines of code:</p>
<pre>
static void
CwndChange (Ptr&lt;OutputStreamWrapper&gt; stream, uint32_t oldCwnd, uint32_t newCwnd)
{
  NS_LOG_UNCOND (Simulator::Now ().GetSeconds () &lt;&lt; "&#92;t" &lt;&lt; newCwnd);
  *stream-&gt;GetStream () &lt;&lt; Simulator::Now ().GetSeconds () &lt;&lt; "&#92;t" &lt;&lt; oldCwnd &lt;&lt; "&#92;t" &lt;&lt; newCwnd &lt;&lt; std::endl;
}

...

AsciiTraceHelper asciiTraceHelper;
Ptr&lt;OutputStreamWrapper&gt; stream = asciiTraceHelper.CreateFileStream ("sixth.cwnd");
ns3TcpSocket-&gt;TraceConnectWithoutContext ("CongestionWindow", MakeBoundCallback (&CwndChange, stream));

...

static void
RxDrop (Ptr&lt;PcapFileWrapper&gt; file, Ptr&lt;const Packet&gt; p)
{
  NS_LOG_UNCOND ("RxDrop at " &lt;&lt; Simulator::Now ().GetSeconds ());
  file-&gt;Write(Simulator::Now(), p);
}

...

PcapHelper pcapHelper;
Ptr&lt;PcapFileWrapper&gt; file = pcapHelper.CreateFile ("sixth.pcap", "w", PcapHelper::DLT_PPP);
devices.Get (1)-&gt;TraceConnectWithoutContext("PhyRxDrop", MakeBoundCallback (&RxDrop, file));
</pre>

<h3>Using Trace Helpers</h3>
<p>The <em>ns-3</em> trace helpers provide a rich environment for configuring and selecting different trace events and writing them to files.  In previous sections, primarily "Building Topologies," we have seen several varieties of the trace helper methods designed for use inside other (device) helpers.</p><p>Perhaps you will recall seeing some of these variations:</p>
<pre>
pointToPoint.EnablePcapAll ("second");
pointToPoint.EnablePcap ("second", p2pNodes.Get (0)-&gt;GetId (), 0);
csma.EnablePcap ("third", csmaDevices.Get (0), true);
pointToPoint.EnableAsciiAll (ascii.CreateFileStream ("myfirst.tr"));
</pre>
<p>What may not be obvious, though, is that there is a consistent model for all of the trace-related methods found in the system.  We will now take a little time and take a look at the "big picture".</p><p>There are currently two primary use cases of the tracing helpers in <em>ns-3</em>: Device helpers and protocol helpers.  Device helpers look at the problem of specifying which traces should be enabled through a node, device pair.  For example, you may want to specify that pcap tracing should be enabled on a particular device on a specific node.  This follows from the <em>ns-3</em> device conceptual model, and also the conceptual models of the various device helpers. Following naturally from this, the files created follow a &lt;prefix&gt;-&lt;node&gt;-&lt;device&gt; naming convention.</p><p>Protocol helpers look at the problem of specifying which traces should be enabled through a protocol and interface pair.  This follows from the <em>ns-3</em> protocol stack conceptual model, and also the conceptual models of internet stack helpers.  Naturally, the trace files should follow a &lt;prefix&gt;-&lt;protocol&gt;-&lt;interface&gt; naming convention.</p><p>The trace helpers therefore fall naturally into a two-dimensional taxonomy. There are subtleties that prevent all four classes from behaving identically, but we do strive to make them all work as similarly as possible; and whenever possible there are analogs for all methods in all classes.</p>
<pre>
                 | pcap | ascii |
-----------------+------+-------|
Device Helper    |      |       |
-----------------+------+-------|
Protocol Helper  |      |       |
-----------------+------+-------|
</pre>
<p>We use an approach called a <strong>mixin</strong> to add tracing functionality to our helper classes.  A <strong>mixin</strong> is a class that provides functionality to that is inherited by a subclass.  Inheriting from a mixin is not considered a form of specialization but is really a way to collect functionality.</p><p>Let&apos;s take a quick look at all four of these cases and their respective <strong>mixins</strong>.</p>
<h3>Pcap Tracing Device Helpers</h3>
<p>The goal of these helpers is to make it easy to add a consistent pcap trace facility to an <em>ns-3</em> device.  We want all of the various flavors of pcap tracing to work the same across all devices, so the methods of these helpers are inherited by device helpers.  Take a look at <strong>src/network/helper/trace-helper.h</strong> if you want to follow the discussion while looking at real code.</p><p>The class <strong>PcapHelperForDevice</strong> is a <strong>mixin</strong> provides the high level functionality for using pcap tracing in an <em>ns-3</em> device.  Every device must implement a single virtual method inherited from this class.</p>
<pre>
virtual void EnablePcapInternal (std::string prefix, Ptr&lt;NetDevice&gt; nd, bool promiscuous, bool explicitFilename) = 0;
</pre>
<p>The signature of this method reflects the device-centric view of the situation at this level.  All of the public methods inherited from class <strong>PcapUserHelperForDevice</strong> reduce to calling this single device-dependent implementation method.  For example, the lowest level pcap method,</p>
<pre>
void EnablePcap (std::string prefix, Ptr&lt;NetDevice&gt; nd, bool promiscuous = false, bool explicitFilename = false);
</pre>
<p>will call the device implementation of <strong>EnablePcapInternal</strong> directly.  All other public pcap tracing methods build on this implementation to provide additional user-level functionality.  What this means to the user is that all device helpers in the system will have all of the pcap trace methods available; and these methods will all work in the same way across devices if the device implements <strong>EnablePcapInternal</strong> correctly.</p>
<h3>Pcap Tracing Device Helper Methods</h3>

<pre>
void EnablePcap (std::string prefix, Ptr&lt;NetDevice&gt; nd, bool promiscuous = false, bool explicitFilename = false);
void EnablePcap (std::string prefix, std::string ndName, bool promiscuous = false, bool explicitFilename = false);
void EnablePcap (std::string prefix, NetDeviceContainer d, bool promiscuous = false);
void EnablePcap (std::string prefix, NodeContainer n, bool promiscuous = false);
void EnablePcap (std::string prefix, uint32_t nodeid, uint32_t deviceid, bool promiscuous = false);
void EnablePcapAll (std::string prefix, bool promiscuous = false);
</pre>
<p>In each of the methods shown above, there is a default parameter called <strong>promiscuous</strong> that defaults to false.  This parameter indicates that the trace should not be gathered in promiscuous mode.  If you do want your traces to include all traffic seen by the device (and if the device supports a promiscuous mode) simply add a true parameter to any of the calls above.  For example,</p>
<pre>
Ptr&lt;NetDevice&gt; nd;
...
helper.EnablePcap ("prefix", nd, true);
</pre>
<p>will enable promiscuous mode captures on the <strong>NetDevice</strong> specified by <strong>nd</strong>.</p><p>The first two methods also include a default parameter called <strong>explicitFilename</strong> that will be discussed below.</p><p>You are encouraged to peruse the Doxygen for class <strong>PcapHelperForDevice</strong> to find the details of these methods; but to summarize ...</p><p>You can enable pcap tracing on a particular node/net-device pair by providing a <strong>Ptr&lt;NetDevice&gt;</strong> to an <strong>EnablePcap</strong> method.  The <strong>Ptr&lt;Node&gt;</strong> is implicit since the net device must belong to exactly one <strong>Node</strong>. For example,</p>
<pre>
Ptr&lt;NetDevice&gt; nd;
...
helper.EnablePcap ("prefix", nd);
</pre>
<p>You can enable pcap tracing on a particular node/net-device pair by providing a <strong>std::string</strong> representing an object name service string to an <strong>EnablePcap</strong> method.  The <strong>Ptr&lt;NetDevice&gt;</strong> is looked up from the name string.  Again, the <strong>&lt;Node&gt;</strong> is implicit since the named net device must belong to exactly one <strong>Node</strong>.  For example,</p>
<pre>
Names::Add ("server" ...);
Names::Add ("server/eth0" ...);
...
helper.EnablePcap ("prefix", "server/ath0");
</pre>
<p>You can enable pcap tracing on a collection of node/net-device pairs by providing a <strong>NetDeviceContainer</strong>.  For each <strong>NetDevice</strong> in the container the type is checked.  For each device of the proper type (the same type as is managed by the device helper), tracing is enabled.    Again, the <strong>&lt;Node&gt;</strong> is implicit since the found net device must belong to exactly one <strong>Node</strong>. For example,</p>
<pre>
NetDeviceContainer d = ...;
...
helper.EnablePcap ("prefix", d);
</pre>
<p>You can enable pcap tracing on a collection of node/net-device pairs by providing a <strong>NodeContainer</strong>.  For each <strong>Node</strong> in the <strong>NodeContainer</strong> its attached <strong>NetDevices</strong> are iterated.  For each <strong>NetDevice</strong> attached to each node in the container, the type of that device is checked.  For each device of the proper type (the same type as is managed by the device helper), tracing is enabled.</p>
<pre>
NodeContainer n;
...
helper.EnablePcap ("prefix", n);
</pre>
<p>You can enable pcap tracing on the basis of node ID and device ID as well as with explicit <strong>Ptr</strong>.  Each <strong>Node</strong> in the system has an integer node ID and each device connected to a node has an integer device ID.</p>
<pre>
helper.EnablePcap ("prefix", 21, 1);
</pre>
<p>Finally, you can enable pcap tracing for all devices in the system, with the same type as that managed by the device helper.</p>
<pre>
helper.EnablePcapAll ("prefix");
</pre>

<h3>Pcap Tracing Device Helper Filename Selection</h3>
<p>Implicit in the method descriptions above is the construction of a complete filename by the implementation method.  By convention, pcap traces in the <em>ns-3</em> system are of the form "&lt;prefix&gt;-&lt;node id&gt;-&lt;device id&gt;.pcap"</p><p>As previously mentioned, every node in the system will have a system-assigned node id; and every device will have an interface index (also called a device id) relative to its node.  By default, then, a pcap trace file created as a result of enabling tracing on the first device of node 21 using the prefix "prefix" would be "prefix-21-1.pcap".</p><p>You can always use the <em>ns-3</em> object name service to make this more clear. For example, if you use the object name service to assign the name "server" to node 21, the resulting pcap trace file name will automatically become, "prefix-server-1.pcap" and if you also assign the name "eth0" to the device, your pcap file name will automatically pick this up and be called "prefix-server-eth0.pcap".</p><p>Finally, two of the methods shown above,</p>
<pre>
void EnablePcap (std::string prefix, Ptr&lt;NetDevice&gt; nd, bool promiscuous = false, bool explicitFilename = false);
void EnablePcap (std::string prefix, std::string ndName, bool promiscuous = false, bool explicitFilename = false);
</pre>
<p>have a default parameter called <strong>explicitFilename</strong>.  When set to true, this parameter disables the automatic filename completion mechanism and allows you to create an explicit filename.  This option is only available in the methods which enable pcap tracing on a single device.</p><p>For example, in order to arrange for a device helper to create a single promiscuous pcap capture file of a specific name ("my-pcap-file.pcap") on a given device, one could:</p>
<pre>
Ptr&lt;NetDevice&gt; nd;
...
helper.EnablePcap ("my-pcap-file.pcap", nd, true, true);
</pre>
<p>The first <strong>true</strong> parameter enables promiscuous mode traces and the second tells the helper to interpret the <strong>prefix</strong> parameter as a complete filename.</p>
<h3>Ascii Tracing Device Helpers</h3>
<p>The behavior of the ascii trace helper <strong>mixin</strong> is substantially similar to the pcap version.  Take a look at <strong>src/network/helper/trace-helper.h</strong> if you want to follow the discussion while looking at real code.</p><p>The class <strong>AsciiTraceHelperForDevice</strong> adds the high level functionality for using ascii tracing to a device helper class.  As in the pcap case, every device must implement a single virtual method inherited from the ascii trace <strong>mixin</strong>.</p>
<pre>
virtual void EnableAsciiInternal (Ptr&lt;OutputStreamWrapper&gt; stream,
                                  std::string prefix,
                                  Ptr&lt;NetDevice&gt; nd,
                                  bool explicitFilename) = 0;
</pre>
<p>The signature of this method reflects the device-centric view of the situation at this level; and also the fact that the helper may be writing to a shared output stream.  All of the public ascii-trace-related methods inherited from class <strong>AsciiTraceHelperForDevice</strong> reduce to calling this single device- dependent implementation method.  For example, the lowest level ascii trace methods,</p>
<pre>
void EnableAscii (std::string prefix, Ptr&lt;NetDevice&gt; nd, bool explicitFilename = false);
void EnableAscii (Ptr&lt;OutputStreamWrapper&gt; stream, Ptr&lt;NetDevice&gt; nd);
</pre>
<p>will call the device implementation of <strong>EnableAsciiInternal</strong> directly, providing either a valid prefix or stream.  All other public ascii tracing methods will build on these low-level functions to provide additional user-level functionality.  What this means to the user is that all device helpers in the system will have all of the ascii trace methods available; and these methods will all work in the same way across devices if the devices implement <strong>EnablAsciiInternal</strong> correctly.</p>
<h3>Ascii Tracing Device Helper Methods</h3>

<pre>
void EnableAscii (std::string prefix, Ptr&lt;NetDevice&gt; nd, bool explicitFilename = false);
void EnableAscii (Ptr&lt;OutputStreamWrapper&gt; stream, Ptr&lt;NetDevice&gt; nd);

void EnableAscii (std::string prefix, std::string ndName, bool explicitFilename = false);
void EnableAscii (Ptr&lt;OutputStreamWrapper&gt; stream, std::string ndName);

void EnableAscii (std::string prefix, NetDeviceContainer d);
void EnableAscii (Ptr&lt;OutputStreamWrapper&gt; stream, NetDeviceContainer d);

void EnableAscii (std::string prefix, NodeContainer n);
void EnableAscii (Ptr&lt;OutputStreamWrapper&gt; stream, NodeContainer n);

void EnableAsciiAll (std::string prefix);
void EnableAsciiAll (Ptr&lt;OutputStreamWrapper&gt; stream);

void EnableAscii (std::string prefix, uint32_t nodeid, uint32_t deviceid, bool explicitFilename);
void EnableAscii (Ptr&lt;OutputStreamWrapper&gt; stream, uint32_t nodeid, uint32_t deviceid);
</pre>
<p>You are encouraged to peruse the Doxygen for class <strong>AsciiTraceHelperForDevice</strong> to find the details of these methods; but to summarize ...</p><p>There are twice as many methods available for ascii tracing as there were for pcap tracing.  This is because, in addition to the pcap-style model where traces from each unique node/device pair are written to a unique file, we support a model in which trace information for many node/device pairs is written to a common file. This means that the &lt;prefix&gt;-&lt;node&gt;-&lt;device&gt; file name generation mechanism is replaced by a mechanism to refer to a common file; and the number of API methods is doubled to allow all combinations.</p><p>Just as in pcap tracing, you can enable ascii tracing on a particular node/net-device pair by providing a <strong>Ptr&lt;NetDevice&gt;</strong> to an <strong>EnableAscii</strong> method.  The <strong>Ptr&lt;Node&gt;</strong> is implicit since the net device must belong to exactly one <strong>Node</strong>.  For example,</p>
<pre>
Ptr&lt;NetDevice&gt; nd;
...
helper.EnableAscii ("prefix", nd);
</pre>
<p>The first four methods also include a default parameter called <strong>explicitFilename</strong> that operate similar to equivalent parameters in the pcap case.</p><p>In this case, no trace contexts are written to the ascii trace file since they would be redundant.  The system will pick the file name to be created using the same rules as described in the pcap section, except that the file will have the suffix ".tr" instead of ".pcap".</p><p>If you want to enable ascii tracing on more than one net device and have all traces sent to a single file, you can do that as well by using an object to refer to a single file.  We have already seen this in the "cwnd" example above:</p>
<pre>
Ptr&lt;NetDevice&gt; nd1;
Ptr&lt;NetDevice&gt; nd2;
...
Ptr&lt;OutputStreamWrapper&gt; stream = asciiTraceHelper.CreateFileStream ("trace-file-name.tr");
...
helper.EnableAscii (stream, nd1);
helper.EnableAscii (stream, nd2);
</pre>
<p>In this case, trace contexts are written to the ascii trace file since they are required to disambiguate traces from the two devices.  Note that since the user is completely specifying the file name, the string should include the ",tr" for consistency.</p><p>You can enable ascii tracing on a particular node/net-device pair by providing a <strong>std::string</strong> representing an object name service string to an <strong>EnablePcap</strong> method.  The <strong>Ptr&lt;NetDevice&gt;</strong> is looked up from the name string.  Again, the <strong>&lt;Node&gt;</strong> is implicit since the named net device must belong to exactly one <strong>Node</strong>.  For example,</p>
<pre>
Names::Add ("client" ...);
Names::Add ("client/eth0" ...);
Names::Add ("server" ...);
Names::Add ("server/eth0" ...);
...
helper.EnableAscii ("prefix", "client/eth0");
helper.EnableAscii ("prefix", "server/eth0");
</pre>
<p>This would result in two files named "prefix-client-eth0.tr" and "prefix-server-eth0.tr" with traces for each device in the respective trace file.  Since all of the EnableAscii functions are overloaded to take a stream wrapper, you can use that form as well:</p>
<pre>
Names::Add ("client" ...);
Names::Add ("client/eth0" ...);
Names::Add ("server" ...);
Names::Add ("server/eth0" ...);
...
Ptr&lt;OutputStreamWrapper&gt; stream = asciiTraceHelper.CreateFileStream ("trace-file-name.tr");
...
helper.EnableAscii (stream, "client/eth0");
helper.EnableAscii (stream, "server/eth0");
</pre>
<p>This would result in a single trace file called "trace-file-name.tr" that contains all of the trace events for both devices.  The events would be disambiguated by trace context strings.</p><p>You can enable ascii tracing on a collection of node/net-device pairs by providing a <strong>NetDeviceContainer</strong>.  For each <strong>NetDevice</strong> in the container the type is checked.  For each device of the proper type (the same type as is managed by the device helper), tracing is enabled.    Again, the <strong>&lt;Node&gt;</strong> is implicit since the found net device must belong to exactly one <strong>Node</strong>. For example,</p>
<pre>
NetDeviceContainer d = ...;
...
helper.EnableAscii ("prefix", d);
</pre>
<p>This would result in a number of ascii trace files being created, each of which follows the &lt;prefix&gt;-&lt;node id&gt;-&lt;device id&gt;.tr convention.  Combining all of the traces into a single file is accomplished similarly to the examples above:</p>
<pre>
NetDeviceContainer d = ...;
...
Ptr&lt;OutputStreamWrapper&gt; stream = asciiTraceHelper.CreateFileStream ("trace-file-name.tr");
...
helper.EnableAscii (stream, d);
</pre>
<p>You can enable ascii tracing on a collection of node/net-device pairs by providing a <strong>NodeContainer</strong>.  For each <strong>Node</strong> in the <strong>NodeContainer</strong> its attached <strong>NetDevices</strong> are iterated.  For each <strong>NetDevice</strong> attached to each node in the container, the type of that device is checked.  For each device of the proper type (the same type as is managed by the device helper), tracing is enabled.</p>
<pre>
NodeContainer n;
...
helper.EnableAscii ("prefix", n);
</pre>
<p>This would result in a number of ascii trace files being created, each of which follows the &lt;prefix&gt;-&lt;node id&gt;-&lt;device id&gt;.tr convention.  Combining all of the traces into a single file is accomplished similarly to the examples above:</p><p>You can enable pcap tracing on the basis of node ID and device ID as well as with explicit <strong>Ptr</strong>.  Each <strong>Node</strong> in the system has an integer node ID and each device connected to a node has an integer device ID.</p>
<pre>
helper.EnableAscii ("prefix", 21, 1);
</pre>
<p>Of course, the traces can be combined into a single file as shown above.</p><p>Finally, you can enable pcap tracing for all devices in the system, with the same type as that managed by the device helper.</p>
<pre>
helper.EnableAsciiAll ("prefix");
</pre>
<p>This would result in a number of ascii trace files being created, one for every device in the system of the type managed by the helper.  All of these files will follow the &lt;prefix&gt;-&lt;node id&gt;-&lt;device id&gt;.tr convention.  Combining all of the traces into a single file is accomplished similarly to the examples above.</p>
<h3>Ascii Tracing Device Helper Filename Selection</h3>
<p>Implicit in the prefix-style method descriptions above is the construction of the complete filenames by the implementation method.  By convention, ascii traces in the <em>ns-3</em> system are of the form "&lt;prefix&gt;-&lt;node id&gt;-&lt;device id&gt;.tr"</p><p>As previously mentioned, every node in the system will have a system-assigned node id; and every device will have an interface index (also called a device id) relative to its node.  By default, then, an ascii trace file created as a result of enabling tracing on the first device of node 21, using the prefix "prefix", would be "prefix-21-1.tr".</p><p>You can always use the <em>ns-3</em> object name service to make this more clear. For example, if you use the object name service to assign the name "server" to node 21, the resulting ascii trace file name will automatically become, "prefix-server-1.tr" and if you also assign the name "eth0" to the device, your ascii trace file name will automatically pick this up and be called "prefix-server-eth0.tr".</p><p>Several of the methods have a default parameter called <strong>explicitFilename</strong>. When set to true, this parameter disables the automatic filename completion mechanism and allows you to create an explicit filename.  This option is only available in the methods which take a prefix and enable tracing on a single device.</p>
<h3>Pcap Tracing Protocol Helpers</h3>
<p>The goal of these <strong>mixins</strong> is to make it easy to add a consistent pcap trace facility to protocols.  We want all of the various flavors of pcap tracing to work the same across all protocols, so the methods of these helpers are inherited by stack helpers.  Take a look at <strong>src/network/helper/trace-helper.h</strong> if you want to follow the discussion while looking at real code.</p><p>In this section we will be illustrating the methods as applied to the protocol <strong>Ipv4</strong>.  To specify traces in similar protocols, just substitute the appropriate type.  For example, use a <strong>Ptr&lt;Ipv6&gt;</strong> instead of a <strong>Ptr&lt;Ipv4&gt;</strong> and call <strong>EnablePcapIpv6</strong> instead of <strong>EnablePcapIpv4</strong>.</p><p>The class <strong>PcapHelperForIpv4</strong> provides the high level functionality for using pcap tracing in the <strong>Ipv4</strong> protocol.  Each protocol helper enabling these methods must implement a single virtual method inherited from this class.  There will be a separate implementation for <strong>Ipv6</strong>, for example, but the only difference will be in the method names and signatures.  Different method names are required to disambiguate class <strong>Ipv4</strong> from <strong>Ipv6</strong> which are both derived from class <strong>Object</strong>, and methods that share the same signature.</p>
<pre>
virtual void EnablePcapIpv4Internal (std::string prefix,
                                     Ptr&lt;Ipv4&gt; ipv4,
                                     uint32_t interface,
                                     bool explicitFilename) = 0;
</pre>
<p>The signature of this method reflects the protocol and interface-centric view of the situation at this level.  All of the public methods inherited from class <strong>PcapHelperForIpv4</strong> reduce to calling this single device-dependent implementation method.  For example, the lowest level pcap method,</p>
<pre>
void EnablePcapIpv4 (std::string prefix, Ptr&lt;Ipv4&gt; ipv4, uint32_t interface, bool explicitFilename = false);
</pre>
<p>will call the device implementation of <strong>EnablePcapIpv4Internal</strong> directly. All other public pcap tracing methods build on this implementation to provide additional user-level functionality.  What this means to the user is that all protocol helpers in the system will have all of the pcap trace methods available; and these methods will all work in the same way across protocols if the helper implements <strong>EnablePcapIpv4Internal</strong> correctly.</p>
<h3>Pcap Tracing Protocol Helper Methods</h3>
<p>These methods are designed to be in one-to-one correspondence with the <strong>Node</strong>- and <strong>NetDevice</strong>- centric versions of the device versions.  Instead of <strong>Node</strong> and <strong>NetDevice</strong> pair constraints, we use protocol and interface constraints.</p><p>Note that just like in the device version, there are six methods:</p>
<pre>
void EnablePcapIpv4 (std::string prefix, Ptr&lt;Ipv4&gt; ipv4, uint32_t interface, bool explicitFilename = false);
void EnablePcapIpv4 (std::string prefix, std::string ipv4Name, uint32_t interface, bool explicitFilename = false);
void EnablePcapIpv4 (std::string prefix, Ipv4InterfaceContainer c);
void EnablePcapIpv4 (std::string prefix, NodeContainer n);
void EnablePcapIpv4 (std::string prefix, uint32_t nodeid, uint32_t interface, bool explicitFilename);
void EnablePcapIpv4All (std::string prefix);
</pre>
<p>You are encouraged to peruse the Doxygen for class <strong>PcapHelperForIpv4</strong> to find the details of these methods; but to summarize ...</p><p>You can enable pcap tracing on a particular protocol/interface pair by providing a <strong>Ptr&lt;Ipv4&gt;</strong> and <strong>interface</strong> to an <strong>EnablePcap</strong> method.  For example,</p>
<pre>
Ptr&lt;Ipv4&gt; ipv4 = node-&gt;GetObject&lt;Ipv4&gt; ();
...
helper.EnablePcapIpv4 ("prefix", ipv4, 0);
</pre>
<p>You can enable pcap tracing on a particular node/net-device pair by providing a <strong>std::string</strong> representing an object name service string to an <strong>EnablePcap</strong> method.  The <strong>Ptr&lt;Ipv4&gt;</strong> is looked up from the name string.  For example,</p>
<pre>
Names::Add ("serverIPv4" ...);
...
helper.EnablePcapIpv4 ("prefix", "serverIpv4", 1);
</pre>
<p>You can enable pcap tracing on a collection of protocol/interface pairs by providing an <strong>Ipv4InterfaceContainer</strong>.  For each <strong>Ipv4</strong> / interface pair in the container the protocol type is checked.  For each protocol of the proper type (the same type as is managed by the device helper), tracing is enabled for the corresponding interface.  For example,</p>
<pre>
NodeContainer nodes;
...
NetDeviceContainer devices = deviceHelper.Install (nodes);
...
Ipv4AddressHelper ipv4;
ipv4.SetBase ("10.1.1.0", "255.255.255.0");
Ipv4InterfaceContainer interfaces = ipv4.Assign (devices);
...
helper.EnablePcapIpv4 ("prefix", interfaces);
</pre>
<p>You can enable pcap tracing on a collection of protocol/interface pairs by providing a <strong>NodeContainer</strong>.  For each <strong>Node</strong> in the <strong>NodeContainer</strong> the appropriate protocol is found.  For each protocol, its interfaces are enumerated and tracing is enabled on the resulting pairs.  For example,</p>
<pre>
NodeContainer n;
...
helper.EnablePcapIpv4 ("prefix", n);
</pre>
<p>You can enable pcap tracing on the basis of node ID and interface as well.  In this case, the node-id is translated to a <strong>Ptr&lt;Node&gt;</strong> and the appropriate protocol is looked up in the node.  The resulting protocol and interface are used to specify the resulting trace source.</p>
<pre>
helper.EnablePcapIpv4 ("prefix", 21, 1);
</pre>
<p>Finally, you can enable pcap tracing for all interfaces in the system, with associated protocol being the same type as that managed by the device helper.</p>
<pre>
helper.EnablePcapIpv4All ("prefix");
</pre>

<h3>Pcap Tracing Protocol Helper Filename Selection</h3>
<p>Implicit in all of the method descriptions above is the construction of the complete filenames by the implementation method.  By convention, pcap traces taken for devices in the <em>ns-3</em> system are of the form "&lt;prefix&gt;-&lt;node id&gt;-&lt;device id&gt;.pcap".  In the case of protocol traces, there is a one-to-one correspondence between protocols and <strong>Nodes</strong>. This is because protocol <strong>Objects</strong> are aggregated to <strong>Node Objects</strong>. Since there is no global protocol id in the system, we use the corresponding node id in file naming.  Therefore there is a possibility for file name collisions in automatically chosen trace file names.  For this reason, the file name convention is changed for protocol traces.</p><p>As previously mentioned, every node in the system will have a system-assigned node id.  Since there is a one-to-one correspondence between protocol instances and node instances we use the node id.  Each interface has an interface id relative to its protocol.  We use the convention "&lt;prefix&gt;-n&lt;node id&gt;-i&lt;interface id&gt;.pcap" for trace file naming in protocol helpers.</p><p>Therefore, by default, a pcap trace file created as a result of enabling tracing on interface 1 of the Ipv4 protocol of node 21 using the prefix "prefix" would be "prefix-n21-i1.pcap".</p><p>You can always use the <em>ns-3</em> object name service to make this more clear. For example, if you use the object name service to assign the name "serverIpv4" to the Ptr&lt;Ipv4&gt; on node 21, the resulting pcap trace file name will automatically become, "prefix-nserverIpv4-i1.pcap".</p><p>Several of the methods have a default parameter called <strong>explicitFilename</strong>. When set to true, this parameter disables the automatic filename completion mechanism and allows you to create an explicit filename.  This option is only available in the methods which take a prefix and enable tracing on a single device.</p>
<h3>Ascii Tracing Protocol Helpers</h3>
<p>The behavior of the ascii trace helpers is substantially similar to the pcap case.  Take a look at <strong>src/network/helper/trace-helper.h</strong> if you want to follow the discussion while looking at real code.</p><p>In this section we will be illustrating the methods as applied to the protocol <strong>Ipv4</strong>.  To specify traces in similar protocols, just substitute the appropriate type.  For example, use a <strong>Ptr&lt;Ipv6&gt;</strong> instead of a <strong>Ptr&lt;Ipv4&gt;</strong> and call <strong>EnableAsciiIpv6</strong> instead of <strong>EnableAsciiIpv4</strong>.</p><p>The class <strong>AsciiTraceHelperForIpv4</strong> adds the high level functionality for using ascii tracing to a protocol helper.  Each protocol that enables these methods must implement a single virtual method inherited from this class.</p>
<pre>
virtual void EnableAsciiIpv4Internal (Ptr&lt;OutputStreamWrapper&gt; stream,
                                      std::string prefix,
                                      Ptr&lt;Ipv4&gt; ipv4,
                                      uint32_t interface,
                                      bool explicitFilename) = 0;
</pre>
<p>The signature of this method reflects the protocol- and interface-centric view of the situation at this level; and also the fact that the helper may be writing to a shared output stream.  All of the public methods inherited from class <strong>PcapAndAsciiTraceHelperForIpv4</strong> reduce to calling this single device- dependent implementation method.  For example, the lowest level ascii trace methods,</p>
<pre>
void EnableAsciiIpv4 (std::string prefix, Ptr&lt;Ipv4&gt; ipv4, uint32_t interface, bool explicitFilename = false);
void EnableAsciiIpv4 (Ptr&lt;OutputStreamWrapper&gt; stream, Ptr&lt;Ipv4&gt; ipv4, uint32_t interface);
</pre>
<p>will call the device implementation of <strong>EnableAsciiIpv4Internal</strong> directly, providing either the prefix or the stream.  All other public ascii tracing methods will build on these low-level functions to provide additional user-level functionality.  What this means to the user is that all device helpers in the system will have all of the ascii trace methods available; and these methods will all work in the same way across protocols if the protocols implement <strong>EnablAsciiIpv4Internal</strong> correctly.</p>
<h3>Ascii Tracing Protocol Helper Methods</h3>

<pre>
void EnableAsciiIpv4 (std::string prefix, Ptr&lt;Ipv4&gt; ipv4, uint32_t interface, bool explicitFilename = false);
void EnableAsciiIpv4 (Ptr&lt;OutputStreamWrapper&gt; stream, Ptr&lt;Ipv4&gt; ipv4, uint32_t interface);

void EnableAsciiIpv4 (std::string prefix, std::string ipv4Name, uint32_t interface, bool explicitFilename = false);
void EnableAsciiIpv4 (Ptr&lt;OutputStreamWrapper&gt; stream, std::string ipv4Name, uint32_t interface);

void EnableAsciiIpv4 (std::string prefix, Ipv4InterfaceContainer c);
void EnableAsciiIpv4 (Ptr&lt;OutputStreamWrapper&gt; stream, Ipv4InterfaceContainer c);

void EnableAsciiIpv4 (std::string prefix, NodeContainer n);
void EnableAsciiIpv4 (Ptr&lt;OutputStreamWrapper&gt; stream, NodeContainer n);

void EnableAsciiIpv4All (std::string prefix);
void EnableAsciiIpv4All (Ptr&lt;OutputStreamWrapper&gt; stream);

void EnableAsciiIpv4 (std::string prefix, uint32_t nodeid, uint32_t deviceid, bool explicitFilename);
void EnableAsciiIpv4 (Ptr&lt;OutputStreamWrapper&gt; stream, uint32_t nodeid, uint32_t interface);
</pre>
<p>You are encouraged to peruse the Doxygen for class <strong>PcapAndAsciiHelperForIpv4</strong> to find the details of these methods; but to summarize ...</p><p>There are twice as many methods available for ascii tracing as there were for pcap tracing.  This is because, in addition to the pcap-style model where traces from each unique protocol/interface pair are written to a unique file, we support a model in which trace information for many protocol/interface pairs is written to a common file.  This means that the &lt;prefix&gt;-n&lt;node id&gt;-&lt;interface&gt; file name generation mechanism is replaced by a mechanism to refer to a common file; and the number of API methods is doubled to allow all combinations.</p><p>Just as in pcap tracing, you can enable ascii tracing on a particular protocol/interface pair by providing a <strong>Ptr&lt;Ipv4&gt;</strong> and an <strong>interface</strong> to an <strong>EnableAscii</strong> method. For example,</p>
<pre>
Ptr&lt;Ipv4&gt; ipv4;
...
helper.EnableAsciiIpv4 ("prefix", ipv4, 1);
</pre>
<p>In this case, no trace contexts are written to the ascii trace file since they would be redundant.  The system will pick the file name to be created using the same rules as described in the pcap section, except that the file will have the suffix ".tr" instead of ".pcap".</p><p>If you want to enable ascii tracing on more than one interface and have all traces sent to a single file, you can do that as well by using an object to refer to a single file.  We have already something similar to this in the "cwnd" example above:</p>
<pre>
Ptr&lt;Ipv4&gt; protocol1 = node1-&gt;GetObject&lt;Ipv4&gt; ();
Ptr&lt;Ipv4&gt; protocol2 = node2-&gt;GetObject&lt;Ipv4&gt; ();
...
Ptr&lt;OutputStreamWrapper&gt; stream = asciiTraceHelper.CreateFileStream ("trace-file-name.tr");
...
helper.EnableAsciiIpv4 (stream, protocol1, 1);
helper.EnableAsciiIpv4 (stream, protocol2, 1);
</pre>
<p>In this case, trace contexts are written to the ascii trace file since they are required to disambiguate traces from the two interfaces.  Note that since the user is completely specifying the file name, the string should include the ",tr" for consistency.</p><p>You can enable ascii tracing on a particular protocol by providing a <strong>std::string</strong> representing an object name service string to an <strong>EnablePcap</strong> method.  The <strong>Ptr&lt;Ipv4&gt;</strong> is looked up from the name string.  The <strong>&lt;Node&gt;</strong> in the resulting filenames is implicit since there is a one-to-one correspondence between protocol instances and nodes, For example,</p>
<pre>
Names::Add ("node1Ipv4" ...);
Names::Add ("node2Ipv4" ...);
...
helper.EnableAsciiIpv4 ("prefix", "node1Ipv4", 1);
helper.EnableAsciiIpv4 ("prefix", "node2Ipv4", 1);
</pre>
<p>This would result in two files named "prefix-nnode1Ipv4-i1.tr" and "prefix-nnode2Ipv4-i1.tr" with traces for each interface in the respective trace file.  Since all of the EnableAscii functions are overloaded to take a stream wrapper, you can use that form as well:</p>
<pre>
Names::Add ("node1Ipv4" ...);
Names::Add ("node2Ipv4" ...);
...
Ptr&lt;OutputStreamWrapper&gt; stream = asciiTraceHelper.CreateFileStream ("trace-file-name.tr");
...
helper.EnableAsciiIpv4 (stream, "node1Ipv4", 1);
helper.EnableAsciiIpv4 (stream, "node2Ipv4", 1);
</pre>
<p>This would result in a single trace file called "trace-file-name.tr" that contains all of the trace events for both interfaces.  The events would be disambiguated by trace context strings.</p><p>You can enable ascii tracing on a collection of protocol/interface pairs by providing an <strong>Ipv4InterfaceContainer</strong>.  For each protocol of the proper type (the same type as is managed by the device helper), tracing is enabled for the corresponding interface.  Again, the <strong>&lt;Node&gt;</strong> is implicit since there is a one-to-one correspondence between each protocol and its node. For example,</p>
<pre>
NodeContainer nodes;
...
NetDeviceContainer devices = deviceHelper.Install (nodes);
...
Ipv4AddressHelper ipv4;
ipv4.SetBase ("10.1.1.0", "255.255.255.0");
Ipv4InterfaceContainer interfaces = ipv4.Assign (devices);
...
...
helper.EnableAsciiIpv4 ("prefix", interfaces);
</pre>
<p>This would result in a number of ascii trace files being created, each of which follows the &lt;prefix&gt;-n&lt;node id&gt;-i&lt;interface&gt;.tr convention.  Combining all of the traces into a single file is accomplished similarly to the examples above:</p>
<pre>
NodeContainer nodes;
...
NetDeviceContainer devices = deviceHelper.Install (nodes);
...
Ipv4AddressHelper ipv4;
ipv4.SetBase ("10.1.1.0", "255.255.255.0");
Ipv4InterfaceContainer interfaces = ipv4.Assign (devices);
...
Ptr&lt;OutputStreamWrapper&gt; stream = asciiTraceHelper.CreateFileStream ("trace-file-name.tr");
...
helper.EnableAsciiIpv4 (stream, interfaces);
</pre>
<p>You can enable ascii tracing on a collection of protocol/interface pairs by providing a <strong>NodeContainer</strong>.  For each <strong>Node</strong> in the <strong>NodeContainer</strong> the appropriate protocol is found.  For each protocol, its interfaces are enumerated and tracing is enabled on the resulting pairs.  For example,</p>
<pre>
NodeContainer n;
...
helper.EnableAsciiIpv4 ("prefix", n);
</pre>
<p>This would result in a number of ascii trace files being created, each of which follows the &lt;prefix&gt;-&lt;node id&gt;-&lt;device id&gt;.tr convention.  Combining all of the traces into a single file is accomplished similarly to the examples above:</p><p>You can enable pcap tracing on the basis of node ID and device ID as well.  In this case, the node-id is translated to a <strong>Ptr&lt;Node&gt;</strong> and the appropriate protocol is looked up in the node.  The resulting protocol and interface are used to specify the resulting trace source.</p>
<pre>
helper.EnableAsciiIpv4 ("prefix", 21, 1);
</pre>
<p>Of course, the traces can be combined into a single file as shown above.</p><p>Finally, you can enable ascii tracing for all interfaces in the system, with associated protocol being the same type as that managed by the device helper.</p>
<pre>
helper.EnableAsciiIpv4All ("prefix");
</pre>
<p>This would result in a number of ascii trace files being created, one for every interface in the system related to a protocol of the type managed by the helper.  All of these files will follow the &lt;prefix&gt;-n&lt;node id&gt;-i&lt;interface.tr convention.  Combining all of the traces into a single file is accomplished similarly to the examples above.</p>
<h3>Ascii Tracing Protocol Helper Filename Selection</h3>
<p>Implicit in the prefix-style method descriptions above is the construction of the complete filenames by the implementation method.  By convention, ascii traces in the <em>ns-3</em> system are of the form "&lt;prefix&gt;-&lt;node id&gt;-&lt;device id&gt;.tr"</p><p>As previously mentioned, every node in the system will have a system-assigned node id.  Since there is a one-to-one correspondence between protocols and nodes we use to node-id to identify the protocol identity.  Every interface on a given protocol will have an interface index (also called simply an interface) relative to its protocol.  By default, then, an ascii trace file created as a result of enabling tracing on the first device of node 21, using the prefix "prefix", would be "prefix-n21-i1.tr".  Use the prefix to disambiguate multiple protocols per node.</p><p>You can always use the <em>ns-3</em> object name service to make this more clear. For example, if you use the object name service to assign the name "serverIpv4" to the protocol on node 21, and also specify interface one, the resulting ascii trace file name will automatically become, "prefix-nserverIpv4-1.tr".</p><p>Several of the methods have a default parameter called <strong>explicitFilename</strong>. When set to true, this parameter disables the automatic filename completion mechanism and allows you to create an explicit filename.  This option is only available in the methods which take a prefix and enable tracing on a single device.</p>
<h3>Summary</h3>
<p><em>ns-3</em> includes an extremely rich environment allowing users at several levels to customize the kinds of information that can be extracted from simulations.</p><p>There are high-level helper functions that allow users to simply control the collection of pre-defined outputs to a fine granularity.  There are mid-level helper functions to allow more sophisticated users to customize how information is extracted and saved; and there are low-level core functions to allow expert users to alter the system to present new and previously unexported information in a way that will be immediately accessible to users at higher levels.</p><p>This is a very comprehensive system, and we realize that it is a lot to digest, especially for new users or those not intimately familiar with C++ and its idioms.  We do consider the tracing system a very important part of <em>ns-3</em> and so recommend becoming as familiar as possible with it.  It is probably the case that understanding the rest of the <em>ns-3</em> system will be quite simple once you have mastered the tracing system</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONCLUSION</h2>
        <div class="sectioncontent">
<h3>Futures</h3>
<p>This document is intended as a living document.  We hope and expect it to grow over time to cover more and more of the nuts and bolts of <em>ns-3</em>.</p><p>Writing manual and tutorial chapters is not something we all get excited about, but it is very important to the project.  If you are an expert in one of these areas, please consider contributing to <em>ns-3</em> by providing one of these chapters; or any other chapter you may think is important.</p>
<h3>Closing</h3>
<p><em>ns-3</em> is a large and complicated system.  It is impossible to cover all of the things you will need to know in one small tutorial.  Readers who want to learn more are encouraged to read the following additional documentation:</p><ul>
<li><p>The <em>ns-3</em> manual</p></li><li><p>The <em>ns-3</em> model library documentation</p></li><li><p>The <em>ns-3</em> Doxygen (API documentation)</p></li><li><p>The <em>ns-3</em> wiki</p><p>-- The <em>ns-3</em> development team.</p></li>
</ul>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>ns-3 project</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>2010, ns-3 project</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="ns-3-manual.1.html"><span aria-hidden="true">&larr;</span> ns-3-manual.1: Ns-3 manual  this is the ns-3 manual. primary documentation for the ns-3 project is available in five forms: ns-3 doxygen: documentation of the public apis of the simulator tutorial, manual (this document), and model library for the latest release and development tree ns-3 wiki  this document is written in restructuredtext for sphinx and is maintained in the doc/manual directory of ns-3s source code.</a></li>
   <li class="next"><a href="ns6.1.html">ns6.1: A security assessment tool for attack vectors based on icmpv6 neighbor solicitation messages <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>killer: Background job killer</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Background job killer">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="killer (1) manual">
  <meta name="twitter:description" content="Background job killer">
  <meta name="twitter:image" content="https://www.carta.tech/images/killer-killer-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/killer.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="killer (1) manual" />
  <meta property="og:description" content="Background job killer" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/killer-killer-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">killer<small> (1)</small></h1>
        <p class="lead">Background job killer</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/killer.1.html">
      <span itemprop="name">killer: Background job killer</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/killer/">
      <span itemprop="name">killer</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/killer.1.html">
      <span itemprop="name">killer: Background job killer</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>killer [<strong>-h</strong>] [<strong>-V</strong>] [<strong>-n</strong>] [<strong>-d</strong>]</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><em>killer</em> is a perl script that gets rid of background jobs.  Background jobs are defined as processes that belong to users who are not currently logged into the machine.  Jobs can be run in the background (and are expempt from <em>killer</em>'s acctions) if their scheduling priority has been reduced by increasing their <em>nice</em>\|(1) value or if they are being run through <em>condor</em>.  For more details, see the <em>\s-1PACKAGE\s0 main</em> section of this document.</p><p>The following sections describe the <em>perl</em>\|(1) packages that make up the killer program.  I don't expect that the version that works for me will work for everyone.  I think that the ProcessTable and Terminals packages offer enough flexibility that most modifications can be done in the main package.</p><p>Command line options</p>
<dl class='dl-vertical'>
  <dt>
    -h
  </dt>
  <dd>
    <p>Tell me how to get help</p>
  </dd>
  <dt>
    -V
  </dt>
  <dd>
    <p>Display version number</p>
  </dd>
  <dt>
    -n
  </dt>
  <dd>
    <p>Do not kill, just print what would be killed</p>
  </dd>
  <dt>
    -d
  </dt>
  <dd>
    <p>Enable debug output</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PACKAGE ProcessTable</h2>
        <div class="sectioncontent">
<p>Each ProcessTable object contains hashes (or associative arrays) that map various aspects of a job to the process \s-1ID\s0 (\s-1PID\s0).  The following hashes are provided:</p>
<dl class='dl-vertical'>
  <dt>
    pid2user
  </dt>
  <dd>
    <p>Login name associated with the effective \s-1UID\s0 that the process is running as.</p>
  </dd>
  <dt>
    pid2ruser
  </dt>
  <dd>
    <p>Login name associate with the real \s-1UID\s0 that the process is running as.</p>
  </dd>
  <dt>
    pid2uid
  </dt>
  <dd>
    <p>Effective \s-1UID\s0 that the process is running as.</p>
  </dd>
  <dt>
    pid2ruid
  </dt>
  <dd>
    <p>Real \s-1UID\s0 that the process is running as.</p>
  </dd>
  <dt>
    pid2tty
  </dt>
  <dd>
    <p>Terminal associated with the process.</p>
  </dd>
  <dt>
    pid2ppid
  </dt>
  <dd>
    <p>Parent process of the process</p>
  </dd>
  <dt>
    pid2nice
  </dt>
  <dd>
    <p><em>nice</em>\|(1) value of the process.</p>
  </dd>
  <dt>
    pid2comm
  </dt>
  <dd>
    <p>Command name of the process.</p>
  </dd>

</dl>
<p>Additionally, the %remainingprocs hash provides the list of processes that will be killed.</p><p>The intended use of this package calls for <em>readProcessTable</em> to be called to fill in all of the hashes defined above.  Then, processes that meet specific requirements are removed from the %remainingprocs hash.  Those that are not removed are considered to be background processes and may be killed.</p><h3>new</h3>
<p>This function creates a new <em>ProcessTable</em> object.</p><p>Example:</p>
<pre>
    my $ptable = new ProcessTable;
</pre>

<h3>initialize</h3>
<p>This function (re)initializes arrays and any environment variables for external commands.  It generally will not need to be called, as it is invoked by <em>new()</em>.</p><p>Example:</p><p>    # Empty out the process table for reuse     $ptable-&gt;initialize();</p>
<h3>readProcessTable</h3>
<p>This function executes the <em>ps</em>\|(1) command to figure out which processes are running.  Note that it requires a \s-1SYSV\s0 style <em>ps</em>\|(1).</p><p>Example:</p><p>    # Get a list of processes from the OS     $ptable-&gt;readProcessTable();</p>
<h3>cleanForkBombs</h3>
<p>This function looks for a large number of processes owned by one user, and assumes that it is someone that is using <em>fork()</em> for the first time.  An effective way to clean up such a mess is to \*(L"kill -STOP\*(R" each process then \*(L"kill -KILL\*(R" each process.</p><p>Note this function ignores such mistakes by root.  If root is running a <em>fork</em>\|(2) bomb, this script wouldn't run, right?  Also, you should be sure that the number of processes mentioned below (490) is less (equal to would be better, right?) than the maximum number of processes per user.  Also, the \s-1OS\s0 should have a process limit at least a couple hundred higher than any individual.  Otherwise, you will have to use the power switch to get rid of fork bombs.</p><p>Each time a process is sent a signal, it is logged via syslog(3C).</p><p>Example:</p><p>    # Get rid of fork bombs.  Keep track of who did it in @idiots.     my @idiots = $ptable-&gt;cleanForkBombs();</p>
<h3>getUserProcessIds user</h3>
<p>This returns the list of process \s-1ID\s0's where the login associated with the real \s-1UID\s0 of the process matches the argument to the function.</p><p>Example:</p><p>    # Find all processes owned by httpd     my @webservers = $ptable-&gt;getUserProcessIds(&apos;httpd&apos;);</p>
<h3>getUniqueTtys</h3>
<p>This function returns a list of terminals in use.  Note that the format will be the same as given by <em>ps</em>\|(1), which will generally lack the leading \*(L"/dev/\*(R".</p><p>Example:</p><p>    # Get a list of all terminals that processes are attached to     my @ttylist = $ptable-&gt;getUniqueTtys();</p>
<h3>removeProcessId pid</h3>
<p>This function removes pid from the list of processes to be killed.  That is, it gets rid of a process that should be allowed to run.  Most likely this will only be called by other functions in this package.</p><p>Example:</p><p>    # For some reason I know that PID 1234 should be allowed to run     $ptable-&gt;removeProcessId(1234);</p>
<h3>removeProcesses psfield, psvalue</h3>
<p>This function removes processes that possess certain traits.  For example, if you want to get rid of all processes owned by the user \*(L"lp\*(R" or all processes that have /dev/console as their controlling terminal, this is the function for you.</p><p>psfield can be any of the following</p>
<dl class='dl-vertical'>
  <dt>
    pid
  </dt>
  <dd>
    <p>Removes process id given in second argument.</p>
  </dd>
  <dt>
    user
  </dt>
  <dd>
    <p>Removes processes with effective \s-1UID\s0 associated with login name given in second argument.</p>
  </dd>
  <dt>
    ruser
  </dt>
  <dd>
    <p>Removes processes with real \s-1UID\s0 associated with login name given in second argument.</p>
  </dd>
  <dt>
    uid
  </dt>
  <dd>
    <p>Removes processes with effective \s-1UID\s0 given in second argument.</p>
  </dd>
  <dt>
    ruid
  </dt>
  <dd>
    <p>Removes processes with real \s-1UID\s0 given in second argument.</p>
  </dd>
  <dt>
    tty
  </dt>
  <dd>
    <p>Removes processes with controlling terminal given in second argument.  Note that it should \s-1NOT\s0 start with \*(L"/dev/\*(R".</p>
  </dd>
  <dt>
    ppid
  </dt>
  <dd>
    <p>Removes children of process with \s-1PID\s0 given in second argument.</p>
  </dd>
  <dt>
    nice
  </dt>
  <dd>
    <p>Removes children with a nice value equal to the second argument.</p>
  </dd>
  <dt>
    comm
  </dt>
  <dd>
    <p>Removes children with a command name that is the same as the second argument.</p>
  </dd>

</dl>
<p>Examples:</p><p>    # Allow all imapd processes to run     $ptable-&gt;removeProcesses(&apos;comm&apos;, &apos;imapd&apos;);</p><p>    # Be sure not to kill print jobs     $ptable-&gt;removeProcesses(&apos;ruser&apos;, &apos;lp&apos;);</p>
<h3>removeChildren pid</h3>
<p>This function removes all decendents of the given pid.  That is, if the pid argument is 1, it will ensure that nothing is killed.</p><p>Example:</p><p>    # Be sure not to kill off any mail deliveries (assumes you have     # written getSendmailPid()).  (Sendmail changes uid when it does     # local delivery.)     $ptable-&gt;removeChildren(getSendmailPid);</p>
<h3>removeCondorChildren</h3>
<p>Condor is a batch job system that allows migration of jobs between machines (see http://www.cs.wisc.edu/condor/).  This ensures that condor jobs are left alone.</p><p>Example:</p><p>    # Be nice to the people that are running their jobs through condor.     $ptable-&gt;removeCondorChildren();</p>
<h3>findChildProcs pid</h3>
<p>This function finds and returns a list of all of the processess that are descendents of a the \s-1PID\s0 given in the first argument.</p><p>Example:</p><p>    # Find the processes that are decendents of PID 1234     my @procs = $ptable-&gt;findChildProcs(1234);</p>
<h3>getTtys user</h3>
<p>This function returns a list of tty's that are in use by processes owned by a particular user.</p><p>Example:</p><p>    # find all tty&apos;s in use by gerdts.     my @ttylist = getTtys(&apos;gerdts&apos;);</p>
<h3>getUsers</h3>
<p>This function lists all the users that have active processes.</p><p>Example:</p><p>    # Get all users that are logged in     my @lusers = $ptable-&gt;getUsers()</p>
<h3>removeNiceJobs</h3>
<p>This function removes all jobs that have a nice value greater than 9. That is, they have a lower sceduling priority than the default (0).</p><p>Example:</p><p>    # Allow people to run background jobs so long as they yield to     # those with "foreground" jobs     $ptable-&gt;removeNiceJobs();</p>
<h3>printProcess filehandle, pid</h3>
<p>This function displays information about the process, kinda like \*(L"ps | grep\*(R" would.</p><p>Example:</p><p>    # Print info about init to STDERR     $ptable-&gt;printProcess(&#92;*STDERR, 1);</p>
<h3>printProcessTable</h3>

<h3>printProcessTable filehandle</h3>
<p>This function prints info about all the processes discoverd by <em>readProcessTable</em>.  If an argument is given, it should be a file handle to which the output should be printed.</p><p>Examples:</p><p>    # Print the process table to stdout     $ptable-&gt;printProcessTable();</p><p>    # Mail the process table to someone     open MAIL &apos;|/usr/bin/mail someone&apos;;     $ptable-&gt;printProcessTable(&#92;*MAIL);     close(MAIL);</p>
<h3>printRemainingProcesses</h3>

<h3>printRemainingProcesses filehandle</h3>
<p>This function prints info about all the processes discoverd by <em>readProcessTable</em>, but not removed from %remainingprocs. If an argument is given, it should be a file handle to which the output should be printed.</p><p>Examples:</p><p>    # Print the jobs to be killed to stdout     $ptable-&gt;printRemainingProcesses();</p><p>    # Mail the jobs to be killed to someone     open MAIL &apos;|/usr/bin/mail someone&apos;;     $ptable-&gt;printRemainingProcesses(&#92;*MAIL);     close(MAIL);</p>
<h3>getRemainingProcesses</h3>
<p>Returns a list of processes that are likely background jobs.</p><p>Example:</p><p>    # Get a list of the processes that I plan to kill     my @procsToKill = $ptable-&gt;getRemainingProcesses();</p>
<h3>killAll signalNumber</h3>
<p>Sends the specified signal to all the processes listed.  A syslog entry is made for each signal sent.</p><p>Example:</p><p>    # Send all of the remaining processes a TERM signal, then a     # KILL signal     $ptable-&gt;killAll(15);     sleep(10);          # Give them a bit of a chance to clean up     $ptable-&gt;<strong>killAll</strong>(9);</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PACKAGE Terminals</h2>
        <div class="sectioncontent">
<p>The Terminals package provides a means for figuring out how long various users have been idle.</p><h3>new</h3>
<p>This function is used to instantiate a new Terminals object.</p><p>Example:</p><p>    # Get a new Terminals object.     my $term = new Terminals;</p>
<h3>initialize</h3>
<p>This function figures out who is on the system and how long they have been idle for.  It will generally only be called by <em>new()</em>.</p><p>Example:</p><p>    # Refresh the state of the terminals.     $term-&gt;initialize();</p>
<h3>showConsoleUser</h3>
<p>This function returns the login of the person that is physically sitting at the machine.</p><p>Example:</p><p>    # Print out the login of the person on the console     printf "%s is on the console&#92;n", $term-&gt;showConsoleUser();</p>
<h3>initializeTty terminal statparts</h3>
<p>This initializes internal structures for the given terminal.</p>
<h3>getX11IdleTime user</h3>
<p>Figure out how long a user has been idle in X11.  Return the seconds of idle time.</p>
<h3>getIdleTime user</h3>
<p>Figure out how long a user has been idle.  This is accomplished by examining all terminals that the user owns and returns the amount of time since the most recently accessed one was used.  Additionally, if the user is at the console it is possible that he/she is not typing, yet is quite active with the mouse or typing into an application that does not use a terminal.</p><p>Example:</p><p>    # Figure out how long the user on the console has been idle     my $consoleIdle = $term-getIdleTime($term-&gt;showConsoleUser());</p>
<h3>printEverything</h3>
<p>Prints to stdout who is on what terminal and how long they have been idle. Only useful for debugging.</p><p>Example:</p><p>    # Take a look at the contents of structures in my     # Terminals object     $term-&gt;printEverything();</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PACKAGE main</h2>
        <div class="sectioncontent">
<p>The main package is the version used on the Unix workstations at the University of Wisonsin's Computer-Aided Engineering Center (\s-1CAE\s0).  I suspect that folks at places other than \s-1CAE\s0 will want to do things slightly differently.  Feel free to take this as an example of how you can make effective use of the processTable and Terminals packages.</p><h3>Configuration options</h3>
<p>Email address to notify of fork bombs Email address to notify of run-of-the-mill kills Who do email messages claim to be from? Email address to notify when jobs will not die These are the folks that you should never kill off Do not kill processes of users with uid lower than this value. The maximum number of seconds that a user can be idle without being classified as having \*(L"background\*(R" jobs.</p><p>If I am a user really trying to avoid a background job killer, I would likely include a signal handler that would wait for signal 15.  When I saw it, I would fork causing the parent to die and the child would continue on to do my work.</p><p>Assuming that everyone thinks like me, I figure that I will need to make at least two complete passes to clear up the bad users.  The first pass is relatively nice (sends a signal 15, followed a bit later by a signal 9).  A well-written program will take the signal 15 as a sign that it should clean up and then shut down.  When a process gets a signal 9, it has no choice but to die.</p><p>The second pass is not so nice.  It finds all background processes, sends them a signal 23 (\s-1SIGSTOP\s0), then a signal 9 (\s-1SIGKILL\s0).  This pretty much (but not absolutely) guarantees that processes are unable to find a way around the background job killer.</p>
<h3>gatherInfo</h3>
<p>This function gathers information from the Terminals and ProcessTable packages, then based on that information decides which jobs should be allowed to run.  Specifically it does the following:</p><ul>
<li><p>Instantiates new ProcessTable and Terminals objects.  Note that Terminals::new fills in all the necessary structures to catch users that have logged in between calls to <em>gatherinfo</em>.</p></li><li><p>Reads the process table</p></li><li><p>Removes condor processes and condor jobs from the list of processes to be killed.</p></li><li><p>Removes all jobs belonging to all users in the configuration array @validusers from the list of processes to be killed.</p></li><li><p>Removes all <em>nice</em>\|(1) jobs from the list of jobs to be killed.</p></li><li><p>Removes all jobs belonging to users where the user has less than $maxidletime idle time on at least one terminal.  Additionally, jobs associated with ttys that are owned by users that have less than $maxidletime idle time on at least one terminal are preserved.  This makes it so that if luser uses <em>su</em>\|(1) to gain the privileges of boozer, processes owned by boozer will not be killed.</p></li><li><p>Removes all processes of users with uid lower than the $minuid value.</p></li><li><p>Finally, the process table and terminal objects are returned.</p></li>
</ul>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>There is a small window of opportunity for a user that reaches $maxidletime in the middle of this script to get unfair treatment.  This could probably be reconciled by shaving some time off of maxidletime for the second call to main::gatherInfo.</p><p>It is still possible to get around the background job killer by having a lot of proceses that watch each other to be sure that they are still responding (have not yet gotten a signal 23).  As soon as a stopped process is found, the still running process could <em>fork()</em>, thus leaving a background process that is not going to be killed.</p><p>Different operating systems have different notions of nice values.  Some go from -20 to +19.  Some go from 0 to 39.  Solaris and HP-UX (using System V ps command) report nice values between 0 and 39.</p><p>It is bad to assume that all systems that run this have the same number of processes per user.  The script should ask the \s-1OS\s0 how many processes normal (non-root) users can run.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TODO</h2>
        <div class="sectioncontent">
<p>The configuration is quite minimalistic.  It should be made possible to have per-host configuration directives so that you can, for instance, allow certain people to run background jobs on certain hosts.</p><p>People that really care about finding habitual offenders will probably want to have a way to add entries to a database and flag those that pop up too often.</p><p>Thoroughly test on more operating systems.  A very close relative of this code has performed well on about 60 Solaris 2.5.1 machines.  It has been lightly tested on HP-UX 10.20 as well.</p><p>Make mailing to someone optional.  If you have a lot of workstations killing off boring stuff all the time, too much meaningless mail traffic is generated.</p><p>If you plan to run this on a machine that runs special processes like a \s-1POP\s0 or \s-1IMAP\s0 server, it would be handy to be able to check multiple conditions easily.  Perhaps</p><p>    $ptable-&gt;removeProcesses( { comm =&gt; &apos;imapd&apos;,                                 parentComm =&gt; &apos;inetd&apos;,                                 parentUser =&gt; &apos;root&apos; } );</p><p>This would make it so that people don't rename the crack binary imapd to escape the wrath of killer.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LICENSE</h2>
        <div class="sectioncontent">
<p>This program is released under the terms of the General Public License (\s-1GPL\s0) version 2.  The the file \s-1COPYING\s0 with the distribution.  If you have lost your copy, you can get a new one at http://www.gnu.org/copyleft/gpl.html.  In particular remember that this code is distributed for free without warranty.</p><p>If you make use of this code, please send me some email.  While I am open to suggestions to improvement, I by no means guarantee that I will implement them.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO killer&hellip;</h2>
        <div class="sectioncontent">
<p><em>nice</em>\|(1) <em>perl</em>\|(1) <em>ps</em>\|(1) <em>su</em>\|(1) <em>who</em>\|(1) <em>fork</em>\|(2) <em>signal</em>\|(5)</p><p>http://www.cs.wisc.edu/condor/</p><p>http://www.cae.wisc.edu/~gerdts/killer/</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>killer was written by Mike Gerdts, gerdts@cae.wisc.edu.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="killall.1.html"><span aria-hidden="true">&larr;</span> killall.1: Kill processes by name</a></li>
   <li class="next"><a href="killposte.1.html">killposte.1: Delete the names and the postal codes of the cities from the dictionary <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

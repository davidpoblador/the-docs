<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SWISH-RUN: Running swish-e and command line switches</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Running swish-e and command line switches">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="SWISH-RUN (1) manual">
  <meta name="twitter:description" content="Running swish-e and command line switches">
  <meta name="twitter:image" content="https://www.carta.tech/images/swish-e-SWISH-RUN-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/SWISH-RUN.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="SWISH-RUN (1) manual" />
  <meta property="og:description" content="Running swish-e and command line switches" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/swish-e-SWISH-RUN-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">SWISH-RUN<small> (1)</small></h1>
        <p class="lead">Running swish-e and command line switches</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/SWISH-RUN.1.html">
      <span itemprop="name">SWISH-RUN: Running swish-e and command line switches</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/swish-e/">
      <span itemprop="name">swish-e</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/SWISH-RUN.1.html">
      <span itemprop="name">SWISH-RUN: Running swish-e and command line switches</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">OVERVIEW</h2>
        <div class="sectioncontent">
<p>The Swish-e program is controlled by command line arguments (called <em>switches</em>).  Often, it is run manually from a shell (command prompt), or from a program such as a \s-1CGI\s0 script that passes the command line arguments to swish.</p><p>Note: A number of the command line switches may be specified in the Swish-e configuration file specified with the \*(C`-c\*(C' command line argument. Please see SWISH-CONFIG for a complete description of available configuration file directives.</p><p>There are two basic operating modes of Swish-e: indexing and searching. There are command line arguments that are unique to each mode, and others that apply to both (yet may have different meaning depending on the operating mode).  These command line arguments are listed below, grouped by:</p><p>\s-1INDEXING\s0 \*(-- describes the command line arguments used while indexing.</p><p>\s-1SEARCHING\s0 \*(-- lists the command line arguments used while searching.</p><p>\s-1OTHER\s0 \s-1SWITCHES\s0 \*(-- lists switches that don't apply to searching or indexing.</p><p>Beginning with Swish-e version 2.1, you may embed its search engine into your applications.  Please see SWISH-LIBRARY.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INDEXING</h2>
        <div class="sectioncontent">
<p>Swish-e indexing is initiated by passing <em>command line arguments</em> to swish.  The command line arguments used for <em>searching</em> are described in \s-1SEARCHING\s0.  Also, see SWISH-SEARCH for examples of searching with Swish-e.</p><p>Swish-e usage:</p>
<pre>
    swish-e [-i dir file ... ] [-c file] [-f file] [-l] &#92;
            [-v (num)] [-S method(fs|http|prog)] [-N path]
</pre>
<p>The \*(C`-h\*(C' switch (help) will list the available Swish-e command line arguments:</p><p>    swish-e -h</p><p>Typically, most if not all indexing settings are placed in a configuration file (specified with the \*(C`-c\*(C' switch).  Once the configuration file is setup indexing is initiated as:</p><p>    swish-e -c /path/to/config/file</p><p>See SWISH-CONFIG for information on the configuration file.</p><p>Security Note: If the swish binary is named <em>swish-search</em> then swish will not allow any operation that would cause swish to write to the index file.</p><p>When indexing it may be advisable to index to a temporary file, and then after indexing has successfully completed rename the file to the final location.  This is especially important when replacing an index that is currently in use.</p><p>    swish-e -c swish.config -f index.tmp     [check return code from swish or look for err: output]     mv index.tmp index.swish-e</p><p><strong>&#92;$1</strong></p>
<dl class='dl-vertical'>
  <dt>
    -i *directories and/or files* (input file)
  </dt>
  <dd>
    <p>This specifies the directories and/or files to index. Directories will be indexed recursively.  This is typically specified in the configuration file with the <strong>IndexDir</strong> directive instead of on the command line.  Use of this switch overrides the configuration file settings.</p>
  </dd>
  <dt>
    -S [fs|http|prog] (document source/access mode)
  </dt>
  <dd>
    <p>This specifies the method to use for accessing documents to index. Can be either \*(C`fs\*(C' for local indexing via the file system (the default), \*(C`http\*(C' for spidering, or \*(C`prog\*(C' for reading documents from an external program. Located in the \*(C`conf\*(C' directory are example configuration files that demonstrate indexing with the different document source methods. See the SWISH-FAQ for a discussion on the different indexing methods, and the difference between spidering with the http method vs. using the file system method.</p>
<dl class='dl-vertical'>
  <dt>
    fs - file system
  </dt>
  <dd>
    <p>The \*(C`fs\*(C' method simply reads files from a local (or networked) drive.  This is the default method if the \*(C`-S\*(C' switch is not specified. See SWISH-CONFIG for configuration directives specific to the \*(C`fs\*(C' method.</p>
  </dd>
  <dt>
    http - spider a web server
  </dt>
  <dd>
    <p>The \*(C`http\*(C' method is used to spider web servers.  It uses an included helper program called <em>swishspider</em>.  See SWISH-CONFIG for configuration directives specific to the \*(C`http\*(C' method. Security Note: Under Windows swish passes the URLs fetched from remote documents through the shell (swish uses the <em>system()</em> command for running <em>swishspider</em> under Windows), and this may be considered an additional security risk. The \*(C`http\*(C' method is deprecated (or at least not very well appreciated).  Consider using the \*(C`prog\*(C' method described below for spidering.  There's a spider program available in the <em>prog-bin</em> directory for use with the \*(C`prog\*(C' method.  Here's a number of limitation with this method that are solved with the \*(C`prog\*(C' method:</p><ul>
<li><p>swishspider only spiders standard &lt;a href=\*(L"...\*(R"&gt; links.  Frames and other links are not followed.</p></li><li><p>By default, this method of spidering only indexes files that have a content type of \*(L"text/*\*(R" (e.g. text/plain, text/html, text/xml).  You should use \*(C`DefaultContents\*(C' and \*(C`IndexContents\*(C' to map file extensions to parsers used by swish (e.g.  \*(C`IndexContents HTML* .html .htm\*(C'), but this will fail where a document does not have a file extension.</p></li><li><p>Swish-e's \*(C`FileFilter\*(C' directive can be used with the \*(C`http\*(C' access method, although it requires a separate process (in addition to the swsihspider process) for each document filtered.</p></li><li><p>The SWISH::Filter modules can be used with the swishspider program.  SWISH::Filter provides a general purpose filtering system (see SWISH::Filter documentation).  To use SWISH::Filter set \s-1PERL5LIB\s0 to point to the location of the \s-1SWISH\s0 module name space (typically /usr/local/lib/swish-e under Unix).  For example:    export PERL5LIB=/usr/local/lib/swish-e  # bash, bourne shells    setenv PERL5LIB /usr/local/lib/swish-e  # csh, tcsh or under Windows    set PERL5LIB=c:&#92;program files&#92;swish-e2.4&#92;lib&#92;swish-e SWISH::Filter is not enabled by default due to the overhead of loading the modules for every document fetched. The Swish-e distribution includes perl modules in the SWISH::Filters::* namespace to make converting non-text documents into a format that Swish-e can parse easy.  As mentioned above, the helper script <em>swishspider</em> will use these modules if can be found via \s-1PERL5LIB\s0.  These modules only provide an interface to programs that do the conversion.  For example, you will need to download and install the \*(L"catdoc\*(R" program to convert MSWord documents into text for indexing. Please see <em>filters/README</em> to see how to use this filter system.</p></li>
</ul>
  </dd>
  <dt>
    prog - general purpose access method
  </dt>
  <dd>
    <p>The \*(C`prog\*(C' method is new to Swish-e version 2.2.  It's designed as a general purpose method to feed documents to swish from an external program. For example, the external program can read a database (e.g. MySQL), spider a web server, or convert documents from one format to another (e.g. pdf to html).  Or, you can simply use it to read the files of the file system (like \*(C`-S fs\*(C'), yet provide you with full control of what files are indexed. The external program name to run is passed to swish either by the IndexDir directive, or via the \*(C`-i\*(C' option. The program specified should be an absolute path as swish-e will attempt to <em>stat()</em> the program to make sure it exists.  Swish does this to help in error reporting. If the program specified with -i or IndexDir is not an absolute path (i.e. does not include \*(L"/\*(R" ) then swish-e will append the \*(L"libexecdir\*(R" directory defined during configuration.  Typically, libexecdir is set to \*(L"$prefix/lib/swish-e\*(R" (/usr/local/lib/swish-e), but is platform and installation dependent.  Running swish-e -h will report the directory. For example, the -S prog program \*(L"spider.pl\*(R" is a Perl helper program for use with -S prog and is installed in libexecdir.     IndexDir spider.pl     SwishProgParameters default http://localhost/index.html and swish-e will find spider.pl in libexecdir. Additional parameters may be passed to the external program via the SwishProgParameters directive. In the example above swish-e will pass two parameters to spider.pl, \*(L"default\*(R" and \*(L"http://localhost/index.html\*(R". A special name \*(L"stdin\*(R" may be used with \*(C`-i\*(C' or IndexDir which tells swish to read from standard input instead of from an external program.  See example below. The external program prints to standard output (which swish captures) a set of headers followed by the content of the file to index.  The output looks similar to an email message or a \s-1HTTP\s0 document returned by a web server in that it includes name/value pairs of headers, a blank line, and the content. The content length is determined by a content-length header supplied to swish by the program; there is no \*(L"end of record\*(R" character or flag sent between documents. Therefore, it is critical that the content-length header is correct.  This is a common source of errors. One advantage of this method (over using filters, for example) is that the external program is run only once for the entire indexing job, instead of once for every document.  This avoids forking and creating a new process for every document, and makes a huge difference when your external program is something like perl that has a large startup cost. Here's a simple example written in Perl:     #!/usr/local/bin/perl -w     use strict;     # Build a document     my $doc = &lt;&lt;EOF;     &lt;html&gt;     &lt;head&gt;         &lt;title&gt;Document Title&lt;/title&gt;     &lt;/head&gt;         &lt;body&gt;             This is the text.         &lt;/body&gt;     &lt;/html&gt;     EOF     # Prepare the headers for swish     my $path = 'Example.file';     my $size = length $doc;     my $mtime = time;     # Output the document (to swish)     print &lt;&lt;EOF;     Path-Name: $path     Content-Length: $size     Last-Mtime: $mtime     Document-Type: HTML*     EOF         print $doc; The external program passes to swish a header.  The header is separated from the body of the document with a blank line.  The available headers are:</p>
<dl class='dl-vertical'>
  <dt>
    Path-Name:
  </dt>
  <dd>
    <p>This is the name of the file you are indexing. This can be any string, so for example it could be an \s-1ID\s0 of a record in a database, a \s-1URL\s0 or a simple file name. This header is required.</p>
  </dd>
  <dt>
    Content-Length:
  </dt>
  <dd>
    <p>This header specifies the length in bytes of the document that follows the header. This length must be exactly the length of the document \*(-- do not make the mistake of adding an extra line feed at the end of the document. This header is required.</p>
  </dd>
  <dt>
    Last-Mtime:
  </dt>
  <dd>
    <p>Thi parameter is the last modification time of the file, and must be a time stamp (seconds since the Epoch on your platform). This header is not required.</p>
  </dd>
  <dt>
    Document-Type:
  </dt>
  <dd>
    <p>You may override swish's determination of document type (\*(C`Indexcontents\*(C') by using the \*(C`Document-Type:\*(C' header.  The document type is used to select which parser Swish-e uses to parse the document's contents. For example, a spider program might map the content-type returned from a web server to one of the types Swish-e understands.  For example,     my $doc_type = 'HTML*' if $response-&gt;content_type =~ m!text/html!' This header is not required.</p>
  </dd>
  <dt>
    Update-Mode:
  </dt>
  <dd>
    <p>When updating an incremental index this header can be used to select the mode for updating the index.  There are three possible values:     Update     Remove     Index \*(L"Update\*(R" will update the index with the given file if the date of the given file is newer than the date of the file already in the index.  Setting to \*(L"Update\*(R" is the same as using -u on the command line. \*(L"Remove\*(R" mode will remove the file specified by the Path-Name header. Setting \*(L"Remove\*(R" is the same as using -r on the command line. \*(L"Index\*(R" will add the file to the index. \s-1NOTE:\s0 swish-e will not check to see if the file already exists. If this header is not specified, the default is the mode specified on the command line (-u, -r, or none). This option is still experimental and is subject to change in the future. Ask on the Swish-e list before using.</p>
  </dd>

</dl>
<p>The above example program only returns one document and exits, which is not very useful.  Normally, your program would read data from some source, such as files or a database, format as \s-1XML\s0, \s-1HTML\s0, or text, and pass them to swish, one after another.  The \*(C`Content-Length:\*(C' header tells swish where each document ends \*(-- there is not any special \*(L"end of record\*(R" character or marker. To index with the above example you need to make sure that the program is executable (and that the path to perl is correct), and then call swish telling to run in \*(C`prog\*(C' mode, and the name of the program to use for input.     % chmod 755 example.pl     % ./swish-e -S prog -i ./example.pl Programs can and should be tested prior to running swish. For example:     % ./example.pl &gt; test.out A few more useful example programs are provided in the swish-e distribution located in the <em>prog-bin</em> directory.  Some include documentation:     % cd prog-bin     % perldoc spider.pl Others are small examples that include comments:     % cd prog-bin     % less DirTree.pl The <em>spider.pl</em> program can be used as a replacement for the <em>-S http</em> method.  It is far more feature-rich and offers much more control over indexing. If you use the special program name \*(L"stdin\*(R" with \*(C`-i\*(C' or IndexDir then swish-e will read from standard input instead of from a program.  For example:     % ./example.pl --count=1000 /path/to/data | ./swish-e -S prog -i stdin This is basically the same as using a swish-e configuration file of:     SwishProgParameters --count=1000 /path/to/data     IndexDir ./example.pl in a config file and running     % ./swish-e -S prog -c swish.conf This gives an easy way to run swish without a configuration file with a \*(C`-S prog\*(C' program that requires parameters.  It also means you can capture data to a file and then index more once with the same data:     % ./example.pl /path/to/data --count=1000 &gt; docs.txt     % cat docs.txt | ./swish-e -S prog -i stdin -c normal_index     % cat docs.txt | ./swish-e -S prog -i stdin -c fuzzy_index Using \*(L"stdin\*(R" might also be useful for programs that call swish (instead of swish calling the program). (The reason \*(L"stdin\*(R" is used instead of the more common \*(L"-\*(R" dash is due to the rotten way swish parses the command line.  This should be fixed in the future.) The \*(C`prog\*(C' method bypasses some of the configuration parameters available to the file system method \*(-- settings such as \*(C`IndexOnly\*(C', \*(C`FileRules\*(C', \*(C`FileMatch\*(C' and \*(C`FollowSymLinks\*(C' are ignored when using the \*(C`prog\*(C' method.  It's expected that these operations are better accomplished in the external program before passing the document onto swish.  In other words, when using the \*(C`prog\*(C' method, only send the documents to swish that you want indexed. You may use swish's filter feature with the \*(C`prog\*(C' method, but performance will be better if you run filtering programs from within your external program.  See also <em>filters/README</em> for an example how to easily add document converstion and filtering into your Perl-based programs. <strong>Notes when using -S prog on \s-1MS\s0 Windows</strong> Windows does not use the shebang (#!) line of a program to determine the program to run.  So, when running, for example, a perl program you may need to specify the perl.exe binary as the program, and use the \*(C`SwishProgParameters\*(C' to name the file.     IndexDir e:/perl/bin/perl.exe     SwishProgParameters read_database.pl Swish will replace the forward slashes with backslashes before running the command specified with \*(C`IndexDir\*(C'.  Swish uses the <em>popen</em>\|(3) command which passes the command through the shell.</p>
  </dd>

</dl>

  </dd>
  <dt>
    -f *indexfile* (index file)
  </dt>
  <dd>
    <p>If you are indexing, this specifies the file to save the generated index in, and you can only specify one file.  See also <strong>IndexFile</strong> in the configuration file. If you are searching, this specifies the index files (one or more) to search from. The default index file is index.swish-e in the current directory.</p>
  </dd>
  <dt>
    -c *file ...* (configuration files)
  </dt>
  <dd>
    <p>Specify the configuration file(s) to use for indexing.  This file contains many directives that control how Swish-e proceeds. See SWISH-CONFIG for a complete listing of configuration file directives. Example:     swish-e -c docs.conf If you specify a directory to index, an index file, or the verbose option on the command-line, these values will override any specified in the configuration file. You can specify multiple configuration files.  For example, you may have one configuration file that has common site-wide settings, and another for a specific index. Examples:     1) swish-e -c swish-e.conf     2) swish-e -i /usr/local/www -f index.swish-e -v -c swish-e.conf     3) swish-e -c swish-e.conf stopwords.conf</p>
<dl class='dl-vertical'>
  <dt>
    1
  </dt>
  <dd>
    <p>The settings in the configuration file will be used to index a site.</p>
  </dd>
  <dt>
    2
  </dt>
  <dd>
    <p>These command-line options will override anything in the configuration file.</p>
  </dd>
  <dt>
    3
  </dt>
  <dd>
    <p>The variables in swish-e.conf will be read, then the variable in stopwords.conf will be read. Note that if the same variables occur in both files, older values may be written over.</p>
  </dd>

</dl>

  </dd>
  <dt>
    -e (economy mode)
  </dt>
  <dd>
    <p>For large sites indexing may require more \s-1RAM\s0 than is available.  The \*(C`-e\*(C' switch tells swish to use disk space to store data structures while indexing, saving memory.  This option is recommended if swish uses so much \s-1RAM\s0 that the computer begins to swap excessively, and you cannot increase available memory.  The trade-off is slightly longer indexing times, and a busy disk drive.</p>
  </dd>
  <dt>
    -l (symbolic links)
  </dt>
  <dd>
    <p>Specifying this option tells swish to follow symbolic links when indexing. The configuration file value <strong>FollowSymLinks</strong> will override the command-line value. The default is not to follow symlinks.  A small improvement in indexing time my result from enabling FollowSymLinks since swish does not need to stat every directory and file processed to determine if it is a symbolic link.</p>
  </dd>
  <dt>
    -N path (index only newer files)
  </dt>
  <dd>
    <p>The \*(C`-N\*(C' option takes a path to a file, and only files <em>newer</em> than the specified file will be indexed.  This is helpful for creating incremental indexes \*(-- that is, indexes that contain just files added since the last full index was created of all files. Example (bad example)     swish-e -c config.file -N index.swish-e -f index.new This will index as normal, but only files with a modified date newer than <em>index.swish-e</em> will be indexed. This is a bad example because it uses <em>index.swish-e</em> which one might assume was the date of last indexing.  The problem is that files might have been added between the time indexing read the directory and when the <em>index.swish-e</em> file was created \*(-- which can be quite a bit of time for very large indexing jobs. The only solution is to prevent any new file additions while full indexing is running. If this is impossible then it will be slightly better to do this: Full indexing:     touch indexing_time.file     swish-e -c config.file -f index.tmp     mv index.tmp index.full Incremental indexing:     swish-e -c config.file -N indexing_time.file -f index.tmp     mv index.tmp index.incremental Then search with     swish-e -w foo -f index.full index.incremental or merge the indexes     swish-e -M index.full index.incremental index.tmp     mv index.tmp index.swish-e     swish-e -w foo</p>
  </dd>
  <dt>
    -r
  </dt>
  <dd>
    <p><strong>**incremental index format only**</strong> The \*(C`-r\*(C' option puts swish-e into \*(L"removal\*(R" mode. Any input files (given with \*(C`-i\*(C' or the \*(C`IndexDir\*(C' parameter) are removed from an existing index. Example:   swish-e -r -i file.html would remove <em>file.html</em> from the existing index.</p>
  </dd>
  <dt>
    -u
  </dt>
  <dd>
    <p><strong>**incremental index format only**</strong> The \*(C`-u\*(C' option puts swish-e into \*(L"update\*(R" mode. The timestamp of each input file is compared against the corresponding file in the existing index. If swish-e encounters an input file that either does not exist yet in the index or exists with a timestamp older than the input file, the input file is updated in the index. Any words in the input file that have been added or removed are reflected as such in the index. Example:   swish-e -i file.html -u would update the index.swish-e index with the contents of file.html. If file.html was new, it would be added. If file.html already existed in the index, its contents would be updated in the index.</p>
  </dd>
  <dt>
    -v [0|1|2|3] (verbosity level)
  </dt>
  <dd>
    <p>The \*(C`-v\*(C' option can take a numerical value from 0 to 3. Specify 0 for completely silent operation and 3 for detailed reports. If no value is given then 1 is assumed. See also <strong>IndexReport</strong> in the configuration file. Warnings and errors are reported regardless of the verbosity level.  In addition, all error and warnings are written to standard out.  This is for historical reasons (many scripts exist that parse standard out for error messages).</p>
  </dd>
  <dt>
    -W (0|1|2|3) (parser warning level)
  </dt>
  <dd>
    <p>If using the libxml2 parser, the default parser warning level is set at 2. Use the \*(C`-W\*(C' option to override that default. Most often, you might want to turn it off altogether:   swish-e -W0 -i path/to/files would fail silently if the parser encountered any errors.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SEARCHING</h2>
        <div class="sectioncontent">
<p>The following command line arguments are available when searching with Swish-e.  These switches are used to select the index to search, what fields to search, and how and what to print as results.</p><p>This section just lists the available command line arguments and their usage. Please see SWISH-SEARCH for detailed searching instructions.</p><p><strong>Warning</strong>: If using Swish-e via a \s-1CGI\s0 interface, please see \s-1CGI\s0 Danger!</p><p>Security Note: If the swish binary is named <em>swish-search</em> then swish will not allow any operation that would cause swish to write to the index file.</p>
<dl class='dl-vertical'>
  <dt>
    -w *word1 word2 ...*  (query words)
  </dt>
  <dd>
    <p>This performs a case-insensitive search using a number of keywords. If no index file to search is specified (via the \*(C`-f\*(C' switch), swish-e will try to search a file called index.swish-e in the current directory.     swish-e -w word Phrase searching is accomplished by placing the quote delimiter (a double-quote by default) around the search phrase.     swish-e -w 'word or "this phrase"' Search would should be protected from the shell by quotes.  Typically, this is single quotes when running under Unix. Under Windows <em>command.com</em> you may not need to use quotes, but you will need to backslash the quotes used to delimit phrases:     swish-e -w &#92;"a phrase&#92;" The phrase delimiter can be set with the \*(C`-P\*(C' switch. The search may be limited to a <em>MetaName</em>. For example:     swish-e -w meta1=(foo or baz) will only search within the <strong>meta1</strong> tag. Please see SWISH-SEARCH for a description of MetaNames</p>
  </dd>
  <dt>
    -f *file1 file2 ...* (index files)
  </dt>
  <dd>
    <p>Specifies the index file(s) used while searching.  More than one file may be listed, and each file will be searched.  If no \*(C`-f\*(C' switch is specified then the file <em>index.swish-e</em> in the current directory will be used as the index file.</p>
  </dd>
  <dt>
    -m *number* (max results)
  </dt>
  <dd>
    <p>While searching, this specifies the maximum number of results to return. The default is to return all results. This switch is often used in conjunction with the \*(C`-b\*(C' switch to return results one page at a time (strongly recommended for large indexes).</p>
  </dd>
  <dt>
    -b *number* (beginning result)
  </dt>
  <dd>
    <p>Sets the <em>begining</em> search result to return (records are numbered from 1).  This switch can be used with the \*(C`-m\*(C' switch to return results in groups or pages. Example:     swish-e -w 'word' -b 1 -m 20    # first 'page'     swish-e -w 'word' -b 21 -m 20   # second 'page'</p>
  </dd>
  <dt>
    -t HBthec (context searching)
  </dt>
  <dd>
    <p>The \*(C`-t\*(C' option allows you to search for words that exist only in specific \s-1HTML\s0 tags. Each character in the string you specify in the argument to this option represents a different tag in which to search for the word. H means all \s-1HEAD\s0 tags, B stands for \s-1BODY\s0 tags, t is all \s-1TITLE\s0 tags, h is H1 to H6 (header) tags, e is emphasized tags (this may be B, I, \s-1EM\s0, or \s-1STRONG\s0), and c is \s-1HTML\s0 comment tags search only in header (&lt;H*&gt;) tags     swish-e -w word -t h</p>
  </dd>
  <dt>
    -d *string* (delimiter)
  </dt>
  <dd>
    <p>Set the delimiter used when printing results.  By default, Swish-e separates the output fields by a space, and places double-quotes around the document title.  This output may be hard to parse, so it is recommended to use \*(C`-d\*(C' to specify a character or string used as a separator between fields. The string \*(C`dq\*(C' means \*(L"double-quotes\*(R".     swish-e -w word -d ,    # single char     swish-e -w word -d ::   # string     swish-e -w word -d '"'  # double quotes under Unix     swish-e -w word -d &#92;"   # double quotes under Windows     swish-e -w word -d dq   # double quotes The following control characters may also be specified: \*(C`&#92;t &#92;r &#92;n &#92;f\*(C'. Warning: This string is passed directly to <em>sprintf()</em> and therefore exposes a securty hole.  Do not allow user data to set -d format strings directly.</p>
  </dd>
  <dt>
    -P *character*
  </dt>
  <dd>
    <p>Sets the delimiter used for phrase searches.  The default is double quotes \*(C`"\*(C'. Some examples under bash: (be careful about you shell metacharacters)     swish-e -P ^ -w 'title=^words in a phrase^'     swish-e -P &#92;' -w "title='words in a pharse"'</p>
  </dd>
  <dt>
    -p *property1 property2 ...*  (display properties)
  </dt>
  <dd>
    <p>This causes swish to print the listed property in the search results.  The properties are returned in the order they are listed in the \*(C`-p\*(C' argument. Properties are defined by the <strong>ProperNames</strong> directive in the configuration file (see SWISH-CONFIG) and properties must also be defined in <strong>MetaNames</strong>.  Swish stores the text of the meta name as a <em>property</em>, and then will return this text while searching if this option is used. Properties are very useful for returning data included in a source documnet without having to re-read the source document while searching.  For example, this could be used to return a short document description. See also see <strong>Document Summeries</strong> and PropertyNames in SWISH-CONFIG. To return the subject and category properties while indexing.     swish-e -w word -p subject category Properties are returned in double quotes.   If a property contains a double quote it is \s-1HTML\s0 escaped (&quot;). See the \*(C`-x\*(C' switch for a more advanced method of returning a list of properties. \s-1NOTE:\s0 it is necessary to have indexed with the proper PropertyNames directive in the user config file in order to use this option.</p>
  </dd>
  <dt>
    -s *property [asc|desc] ...*  (sort)
  </dt>
  <dd>
    <p>Normally, search results are printed out in order of relevancy, with the most relevant listed first. The \*(C`-s\*(C' sort switch allows you to sort results in order of a specified <em>property</em>, where a <em>property</em> was defined using the <strong>MetaNames</strong> and <strong>PropertyNames</strong> directives during indexing (see SWISH-CONFIG). The string passed can include the strings \*(C`asc\*(C' and \*(C`desc\*(C' to specify the sort order, and more than one property may be specified to sort on more than one key. Examples: sort by title property ascending order     -s title sort descending by title, ascending by name     -s title desc name asc Note: Swish limits sort keys to 100 characters.  This limit can be changed by changing \s-1MAX_SORT_STRING_LEN\s0 in src/config.h and rebuilding swish-e.</p>
  </dd>
  <dt>
    -L limit to a range of property values (Limit)
  </dt>
  <dd>
    <p><strong>This is an experimental feature!</strong> The \*(C`-L\*(C' switch can be used to limit search results to a range of property values Example:     swish-e -w foo -L swishtitle a m finds all documents that contain the word \*(C`foo\*(C', and where the document's title is in the range of \*(C`a\*(C' to \*(C`m\*(C', inclusive. By default, the case of the property is ignored, but this can be changed by using PropertyNamesCompareCase configuation directive. Limiting may be done with user-defined properties, as well. For example, if you indexed documents that contain a created timestamp in a meta tag:     &lt;meta name="created_on" content="982648324"&gt; Then you tell Swish that you have a property called \*(C`created_on\*(C', and that it's a timestamp.     PropertyNamesDate created_on After indexing you will be able to limit documents to a range of timestamps:     -w foo -L created_on  946684800 949363199 will find documents containing the word foo and that have a created_on date from the start of Jan 1, 2000 to the end of Jan 31, 2000. Note: swish currently does not parse dates; Unix timestamps must be used. Two special formats can be used:     -L swishtitle &lt;= m     -L swishtitle &gt;= m Finds titles less than or equal, or grater than or equal to the letter \*(C`m\*(C'. This feature will not work with \*(C`swishrank\*(C' or \*(C`swishdbfile\*(C' properties. This feature takes advantages of the pre-sorted tables built by swish during indexing to make this feature fast while searching. You should see in the indexing output a line such as:    6 properties sorted. That indicates that six pre-sorted tables were built during indexing. By default, all properties are presorted while indexing. What properties are pre-sorted can be controlled by the configuration parameter \*(C`PreSortedIndex\*(C'. Using the \*(C`-L\*(C' switch on a property that was not pre-sorted will still work, but may be <em>much</em> slower during searching. Note that the PropertyNamesSortKeyLength setting is used for sorting properties. Using too small a PropertyNamesSortKeyLength could result in -L selecting the wrong properties due to incomplete sorting. This is an experimental feature, and its use and interface are subject to change.</p>
  </dd>
  <dt>
    -x formatstring (extended output format)
  </dt>
  <dd>
    <p>The \*(C`-x\*(C' switch defines the output format string.  The format string can contain plain text and property names (including swish-defined internal property names) and is used to generate the output for every result.  In addition, the output format of the property name can be controlled with C-like printf format strings.  This feature overrides the cmdline switches \*(C`-d\*(C' and \*(C`-p\*(C', and a warning will be generated if \*(C`-d\*(C' or \*(C`-p\*(C' are used with \*(C`-x\*(C'. Warning: The format string (fmt) is passed directly to <em>sprintf()</em> and therefore exposes a securty hole.  Do not allow user data to set -x format strings directly. For example, to return just the title, one per line, in the search results:     swish-e  -w ...   -x '&lt;swishtitle&gt;&#92;n' ... Note: the \*(C`&#92;n\*(C' may need to be protected from your shell. See also ResultExtFormatName for a way to define <em>named</em> format strings in the swish configuration file. <strong>Format of \*(L"formatstring\*(R":</strong>     "text&lt;propertyname&gt;text&lt;propertyname fmt=propfmtstr&gt;text..." Where <strong>propertyname</strong> is:</p><ul>
<li><p>the name of a user property as specified with the config file directive \*(L"PropertyNames\*(R"</p></li><li><p>the name of a swish Auto property (see below).  These properties are defined automatically by swish \*(-- you do not need to specify them with PropertyNames directive.  (This may change in the future.)</p></li>
</ul><p>propertynames must be placed within "&lt;\*(L" and \*(R"&gt;". <strong>User properties:</strong> Swish-e allows you to specify certain \s-1META\s0 tags within your documents that can be used as <strong>document properties</strong>. The contents of any \s-1META\s0 tag that has been identified as a document property can be returned as part of the search results.  Doucment properties must be defined while indexing using the <strong>PropertyNames</strong> configuration directive (see SWISH-CONFIG). Examples of user-defined PropertyNames:     &lt;keywords&gt;     &lt;author&gt;     &lt;deliveredby&gt;     &lt;reference&gt;     &lt;id&gt; <strong>Auto properties:</strong> Swish defines a number of \*(L"Auto\*(R" properties for each document indexed. These are available for output when using the \*(C`-x\*(C' format.     Name               Type     Contents     --------------     -------  ----------------------------------------------     swishreccount      Integer  Result record counter     swishtitle         String   Document title     swishrank          Integer  Result rank for this hit     swishdocpath       String   URL or filepath to document     swishdocsize       Integer  Document size in bytes     swishlastmodified  Date     Last modified date of document     swishdescription   String   Description of document (see:StoreDescription)     swishdbfile        String   Path of swish database indexfile The Auto properties can also be specified using shortcuts:     Shortcut    Property Name     --------    --------------       %c        swishreccount       %d        swishdescription       %D        swishlastmodified       %I        swishdbfile       %p        swishdocpath       %r        swishrank       %l        swishdocsize       %t        swishtitle For example, these are equivalent:    -x '&lt;swishrank&gt;:&lt;swishdocpath&gt;:&lt;swishtitle&gt;&#92;n'    -x '%r:%p:%t&#92;n' Use a double percent sign \*(L"%%\*(R" to enter a literal percent sign in the output. <strong>Formatstrings of properties:</strong> Properties listed in an \*(C`-x\*(C' format string can include format control strings. These \*(L"propertyformats\*(R" are used to control how the contents of the associated property are printed. Property formats are used like C-language printf formats. The property format is specified by including the attribute \*(L"fmt\*(R" within the property tag. Format strings cannot be used with the \*(L"%\*(R" shortcuts described above. General syntax:     -x '&lt;propertyname fmt="propfmtstr"&gt;' where \*(C`subfmt\*(C' controls the output format of \*(C`propertyname\*(C'. Examples of property format strings:         date type:    &lt;swishlastmodified fmt="%d.%m.%Y"&gt;         string type:  &lt;swishtitle fmt="%-40.35s"&gt;         integer type: &lt;swishreccount fmt=/%8.8d/&gt; Please see the manual pages for <em>strftime</em>\|(3) and <em>sprintf</em>\|(3) for an explanation of format strings.  Note: some versions of strftime do not offer the %s format string (number of seconds since the Epoch), so swish provides a special format string \*(L"%ld\*(R" to display the number of seconds since the Epoch. The first character of a property format string defines the delimiter for the format string. For example,     -x  "&lt;author  fmt=[%20s]&gt; ...&#92;n"     -x  "&lt;author  fmt='%20s'&gt; ...&#92;n"     -x  "&lt;author  fmt=/%20s/&gt; ...&#92;n" <strong>Standard predefined formats:</strong> If you ommit the sub-format, the following formats are used:     String type:       "%s"  (like printf char *)     Integer type:      "%d"  (like printf int)     Float type:        "%f"  (like printf double)     Date type:         "%Y-%m-%d %H:%M:%S" (like strftime) <strong>Text in \*(L"formatstring\*(R" or \*(L"propfmtstr\*(R":</strong> Text will be output as-is in format strings (and property format strings). Special characters can be escaped with a backslash. To get a new line for each result hit, you have to include the Newline-Character \*(L"&#92;n\*(R" at the end of \*(L"fmtstr\*(R".     -x "&lt;swishreccount&gt;|&lt;swishrank&gt;|&lt;swishdocpath&gt;&#92;n"     -x "Count=&lt;swishreccount&gt;, Rank=&lt;swishrank&gt;&#92;n"     -x "Title=&#92;&lt;b&#92;&gt;&lt;swishtitle&gt;&#92;&lt;/b&#92;&gt;"     -x 'Date: &lt;swishlastmodified fmt="%m/%d/%Y"&gt;&#92;n'     -x 'Date in seconds: &lt;swishlastmodified fmt=/%ld/&gt;&#92;n' <strong>Control/Escape charcters:</strong> you can use C-like control escapes in the format string:    known controls:      &#92;a, &#92;b, &#92;f, &#92;n, &#92;r, &#92;t, &#92;v,    digit escapes:       &#92;xhexdigits   &#92;0octaldigits    character escapes:   &#92;anychar Example,     swish -x "%c&#92;t%r&#92;t%p&#92;t&#92;"&lt;swishtitle fmt=/%40s/&gt;&#92;"&#92;n" <strong>Examples of -x format strings:</strong>     -x "%c|%r|%p|%t|%D|%d&#92;n"     -x "%c|%r|%p|%t|&lt;swishdate fmt=/%A, %d. %B %Y/&gt;|%d&#92;n"     -x "&lt;swishrank&gt;&#92;t&lt;swishdocpath&gt;&#92;t&lt;swishtitle&gt;&#92;t&lt;keywords&gt;&#92;n     -x "xml_out: &#92;&lt;title&#92;&gt;&lt;swishtitle&gt;&#92;&gt;&#92;&lt;/title&#92;&gt;&#92;n"     -x "xml_out: &lt;swishtitle fmt='&lt;title&gt;%s&lt;/title&gt;'&gt;&#92;n"</p>
  </dd>
  <dt>
    -H [0|1|2|3|&lt;n&gt;]  (header output verbosity)
  </dt>
  <dd>
    <p>The \*(C`-H n\*(C' switch generates extened <em>header</em> output.  This is most useful when searching more than one index file at a time by specifying more than one index file with the \*(C`-f\*(C' switch. \*(C`-H 2\*(C' will generate a set of headers specific to each index file. This gives access to the settings used to generate each index file. Even when searching a single index file, \*(C`-H n\*(C' will provided additional information about the index file, how it was indexed, and how swish is interperting the query.     -H 0 : print no header information, output only search result entries.     -H 1 : print standard result header (default).     -H 2 : print additional header information for each searched index file.     -H 3 : enhanced header output (e.g. print stopwords).     -H 9 : print diagnostic information in the header of the results (changed from: C&lt;-v 4&gt;)</p>
  </dd>
  <dt>
    -R [0|1] (Ranking Scheme)
  </dt>
  <dd>
    <p><strong>This is an experimental feature!</strong> The default ranking scheme in SWISH-E evaluates each word in a query in terms of its frequency and position in each document. The default scheme is 0. New in version 2.4.3 you may optionally select an experimental ranking scheme that, in addition to document frequency and position, uses Inverse Document Frequency (\s-1IDF\s0), or the relative frequency of each word across all the indexes being searched, and Relative Density, or the normalization of the frequency of a word in relationship to the number of words in the document. <strong>\s-1NOTE:\s0</strong> IgnoreTotalWordCountWhenRanking must be set to <strong>no</strong> or <strong>0</strong> in your index(es) for -R 1 to work. Specify -R 1 to turn on \s-1IDF\s0 ranking. See the \s-1API\s0 documentation for how to set the ranking scheme in your Perl or C program.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OTHER SWITCHES</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    -V (version)
  </dt>
  <dd>
    <p>Print the current version.</p>
  </dd>
  <dt>
    -k *letter* (print out keywords)
  </dt>
  <dd>
    <p>The \*(C`-k\*(C' switch is used for testing and will cause swish to print out all keywords in the index beginning with that letter.  You may enter \*(C`-k '*'\*(C' to generate a list of all words indexed by swish.</p>
  </dd>
  <dt>
    -D *index file*  (debug index)
  </dt>
  <dd>
    <p>The -D option is no longer supported in version 2.2.</p>
  </dd>
  <dt>
    -T *options* (trace/debug swish)
  </dt>
  <dd>
    <p>The -T option is used to print out information that may be helpful when debugging swish-e's operation.  This option replaced the \*(C`-D\*(C' option of previous versions. Running \*(C`-T help\*(C' will print out a list of available *options*</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Merging Index Files</h2>
        <div class="sectioncontent">
<p>In previous versions of Swish-e indexing would require a very large amount of memory and the indexing process could be very slow.  Merging provided a way to index in chunks and then combine the indexes together into a single index.</p><p>Indexing is much faster now and uses much less memory, and with the \*(C`-e\*(C' switch very little memory is needed to index a large site.</p><p>Still, at times it can be useful to merge different index files into one file for searching. This could be because you want to keep separate site indexes and a common one for a global search, or you have separate collections of documents that you wish to search all at one time, but manage separately.</p>
<dl class='dl-vertical'>
  <dt>
    -M *index1 index2 ... indexN out_index
  </dt>
  <dd>
    <p>Merges the indexes specified on the command line \*(-- the last file name entered is the output file. The output index must not exist (otherwise merge will not proceed). Only indexes that were indexed with common settings may be merged. (e.g. don't mix stemming and non-stemming indexes, or indexes with different WordCharacter settings, etc.). Use the \*(C`-e\*(C' switch while merging to reduce memory usage. Merge generates progress messages regardless of the setting of \*(C`-v\*(C'.</p>
  </dd>
  <dt>
    -c *configuration file*
  </dt>
  <dd>
    <p>Specify a configuration file while indexing to add administrative information to the output index file.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Document Info</h2>
        <div class="sectioncontent">
<p>$Id: \s-1SWISH-RUN\s0.pod 1741 2005-05-17 02:22:40Z karman $</p><p>.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="SWISH-LIBRARY.1.html"><span aria-hidden="true">&larr;</span> SWISH-LIBRARY.1: Interface to the swish-e c library</a></li>
   <li class="next"><a href="SWarp.1.html">SWarp.1: Resample and combine fits images <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>mpqc: The massively parallel quantum chemistry program (mpqc)</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The massively parallel quantum chemistry program (mpqc)">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="mpqc (1) manual">
  <meta name="twitter:description" content="The massively parallel quantum chemistry program (mpqc)">
  <meta name="twitter:image" content="https://www.carta.tech/images/mpqc-mpqc-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/mpqc.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="mpqc (1) manual" />
  <meta property="og:description" content="The massively parallel quantum chemistry program (mpqc)" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/mpqc-mpqc-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">mpqc<small> (1)</small></h1>
        <p class="lead">The massively parallel quantum chemistry program (mpqc)</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/mpqc.1.html">
      <span itemprop="name">mpqc: The massively parallel quantum chemistry program (mpqc)</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/mpqc/">
      <span itemprop="name">mpqc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/mpqc.1.html">
      <span itemprop="name">mpqc: The massively parallel quantum chemistry program (mpqc)</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>mpqc</strong> [<strong>options</strong>] [<em>filename</em>]</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>MPQC computes the properties of molecules, <em>ab initio</em>, on a wide variety of computer architectures.</p><p>It can compute closed shell and general restricted openshell HartreeFock energies and gradients, second order openshell perturbation theory (OPT2[2]) and Zaveraged perturbation theory (ZAPT2) energies, and second order closed shell MoellerPlesset perturbation theory energies and gradients. It also includes methods for optimizing molecules in either Cartesian or internal coordinates.</p><p>MPQC is designed using objectoriented programming techniques and implemented in the C++ programming language.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONS</h2>
        <div class="sectioncontent">
<p>MPQC can be given options followed by an optional input file name. If the input file name is not given, it will default to 'mpqc.in'. The following command line options are recognized:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>-o</strong></p>
  </dt>
  <dd>
    <p>Gives the name of the output file. The default is the console.</p>
  </dd>
  <dt>
    <p><strong>-i</strong></p>
  </dt>
  <dd>
    <p>Convert a simple input file to an object oriented input file and write the result to the output. No calculations are done.</p>
  </dd>
  <dt>
    <p><strong>-messagegrp</strong></p>
  </dt>
  <dd>
    <p>A <strong>ParsedKeyVal</strong> specification of a <strong>MessageGrp</strong> object. The default depends on how MPQC was compiled.</p>
  </dd>
  <dt>
    <p><strong>-memorygrp</strong></p>
  </dt>
  <dd>
    <p>A <strong>ParsedKeyVal</strong> specification of a <strong>MemoryGrp</strong> object. The default depends on how MPQC was compiled.</p>
  </dd>
  <dt>
    <p><strong>-threadgrp</strong></p>
  </dt>
  <dd>
    <p>A <strong>ParsedKeyVal</strong> specification of a <strong>ThreadGrp</strong> object. The default depends on how MPQC was compiled.</p>
  </dd>
  <dt>
    <p><strong>-l</strong></p>
  </dt>
  <dd>
    <p>Sets a limit on the number of basis functions. The default is zero, which means an unlimited number of basis functions.</p>
  </dd>
  <dt>
    <p><strong>-W</strong></p>
  </dt>
  <dd>
    <p>Sets the working directory. The default is the current directory.</p>
  </dd>
  <dt>
    <p><strong>-c</strong></p>
  </dt>
  <dd>
    <p>Check the input and exit.</p>
  </dd>
  <dt>
    <p><strong>-v</strong></p>
  </dt>
  <dd>
    <p>Print the version number.</p>
  </dd>
  <dt>
    <p><strong>-w</strong></p>
  </dt>
  <dd>
    <p>Print the warranty information (there is no warranty).</p>
  </dd>
  <dt>
    <p><strong>-d</strong></p>
  </dt>
  <dd>
    <p>If a debugger object was given in the input, start the debugger running as soon as MPQC is started.</p>
  </dd>
  <dt>
    <p><strong>-h</strong></p>
  </dt>
  <dd>
    <p>Print a list of options.</p>
  </dd>
  <dt>
    <p><strong>-f</strong></p>
  </dt>
  <dd>
    <p>The name of an object-oriented input file. The default is mpqc.in. This cannot be used if another input file is specified. This option is deprecated, as both input file formats can be read by given the input file name on the command line without any option flags.</p>
  </dd>

</dl>
<p>Some MPI environments do not pass the command line to slave programs, but supply it when MPI_Init is called. To make MPQC call MPI_Init on start-up, instead of when an <strong>MPIMessageGrp</strong> is created, name the executable mpqc-mpi.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ENVIRONMENTAL VARIABLES</h2>
        <div class="sectioncontent">
<p>MPQC looks at four environmental variables to set up communication and find library files. Machine specific libraries and utilities to run programs in parallel might look at other environment variables as well. The four that apply on all platforms are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>SCLIBDIR</strong></p>
  </dt>
  <dd>
    <p>The name of the library directory.</p>
  </dd>
  <dt>
    <p><strong>MESSAGEGRP</strong></p>
  </dt>
  <dd>
    <p>A <strong>ParsedKeyVal</strong> specification of a <strong>MessageGrp</strong> object. The default depends on how MPQC was compiled. See the <strong>MessageGrp</strong> class documentation for more information.</p>
  </dd>
  <dt>
    <p><strong>MEMORYGRP</strong></p>
  </dt>
  <dd>
    <p>A <strong>ParsedKeyVal</strong> specification of a <strong>MemoryGrp</strong> object. The default depends on how MPQC was compiled and the <strong>MessageGrp</strong> in use.</p>
  </dd>
  <dt>
    <p><strong>THREADGRP</strong></p>
  </dt>
  <dd>
    <p>A <strong>ParsedKeyVal</strong> specification of a <strong>ThreadGrp</strong> object. The default depends on how MPQC was compiled.</p>
  </dd>

</dl>
<p>By default, MPQC tries to find library files first in the lib sub-directory of the installation directory and then the source code directory. If the library files cannot be found, MPQC must be notified of the new location with the environmental variable SCLIBDIR.</p><p>The other three keywords specify objects. This is done by giving a mini <strong>ParsedKeyVal</strong> input in a string. The object is anonymous, that is, no keyword is associated with it. Here is an example:</p>
<pre>
setenv MESSAGEGRP '&lt;<strong>ShmMessageGrp</strong>&gt;:(n = 4)'

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SHARED MEMORY MULTIPROCESSOR WITH SYSV IPC</h2>
        <div class="sectioncontent">
<p>By default, MPQC will run on only one CPU. To specify more, you can give a <strong>ShmMessageGrp</strong> object on the command line. The following would run mpqc in four processes:</p>
<pre>
mpqc -messagegrp '&lt;<strong>ShmMessageGrp</strong>&gt;:(n = 4)' input_file

</pre>
<p>Alternately, the <strong>ShmMessageGrp</strong> object can be given as an environmental variable:</p>
<pre>
setenv MESSAGEGRP '&lt;<strong>ShmMessageGrp</strong>&gt;:(n = 4)'
mpqc input_file

</pre>
<p>If MPQC should unexpectedly die, shared memory segments and semaphores will be left on the machine. These should be promptly cleaned up or other jobs may be prevented from running successfully. To see if you have any of these resources allocated, use the ipcs command. The output will look something like:</p>
<pre>
IPC status from /dev/kmem as of Wed Mar 13 14:42:18 1996
T     ID     KEY    &nbsp;&nbsp;&nbsp;&nbsp;MODE&nbsp;&nbsp;&nbsp;&nbsp;   OWNER    GROUP
Message Queues:
Shared Memory:
m 288800 0x00000000 --rw-------  cljanss     user
Semaphores:
s    390 0x00000000 --ra-------  cljanss     user
s    391 0x00000000 --ra-------  cljanss     user

</pre>
<p>To remove the IPC resources used by cljanss in the above example on IRIX, type:</p>
<pre>
ipcrm -m 288800
ipcrm -s 390
ipcrm -s 391

</pre>
<p>And on Linux, type:</p>
<pre>
ipcrm shm 288800
ipcrm sem 390
ipcrm sem 391

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SHARED MEMORY MULTIPROCESSOR WITH POSIX THREADS</h2>
        <div class="sectioncontent">
<p>By default, MPQC will run with only one thread. To specify more, you can give a <strong>PthreadThreadGrp</strong> object on the command line. MPQC is not parallelized to as large an extent with threads as it is with the more conventional distributed memory model, so you might not get the best performance using this technique. On the other the memory overhead is lower and no interprocess communication is needed.</p><p>The following would run MPQC in four threads:</p>
<pre>
mpqc -threadgrp '&lt;<strong>PthreadThreadGrp</strong>&gt;:(num_threads = 4)' input_file

</pre>
<p>Alternately, the <strong>PthreadThreadGrp</strong> object can be given as an environmental variable:</p>
<pre>
setenv THREADGRP '&lt;<strong>PthreadThreadGrp</strong>&gt;:(n = 4)'
mpqc input_file

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SHARED OR DISTRIBUTED MEMORY MULTIPROCESSOR WITH MPI</h2>
        <div class="sectioncontent">
<p>A <strong>MPIMessageGrp</strong> object is used to run using MPI. The number of nodes used is determined by the MPI run-time and is not specified as input data to <strong>MPIMessageGrp</strong>.</p>
<pre>
mpqc -messagegrp '&lt;<strong>MPIMessageGrp</strong>&gt;:()' input_file

</pre>
<p>Alternately, the <strong>MPIMessageGrp</strong> object can be given as an environmental variable:</p>
<pre>
setenv MESSAGEGRP '&lt;<strong>MPIMessageGrp</strong>&gt;:()'
mpqc input_file

</pre>
<p>Usually, a special command is needed to start MPI jobs; typically it is named mpirun.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUT</h2>
        <div class="sectioncontent">
<p>MPQC supports two input formats. The primary input is an object oriented format which gives users access to all of MPQCs options. The second format allows access to a subset of MPQCs capabilities, but is more intuitive and easier to learn. New users are advised to start with the simplified format. MPQC can be used to convert the simplified format to the full object-oriented format with the -i option.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Simple Input</h2>
        <div class="sectioncontent">
<p>The simple input format consists of keywords followed by a ':' followed by a value. The keywords are case sensitive. The values might be modified by options found in parenthesis. For example, the following input performs an optimization of water using density functional theory with the B3LYP exchange-correlation functional:</p>
<pre>
% B3LYP optimization of water
optimize: yes
method: KS (xc = B3LYP)
basis: 3-21G*
molecule:
    O    0.172   0.000  &nbsp;0.000
    H    0.745   0.000  &nbsp;0.754
    H    0.745   0.000  -0.754

</pre>
<p>Comments begin with a % and continue to the end of the line. Basis set names containing special characters, such as a space or parentheses, must be quoted inside a pair of double quotes. The accepted keywords are:</p>
<dl class='dl-vertical'>
  <dt>
    molecule
  </dt>
  <dd>
    <p> Gives the atoms types and coordinates. The following options can be used</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    bohr
  </dt>
  <dd>
    <p> The coordinates are given in Bohr.</p>
  </dd>
  <dt>
    angstrom
  </dt>
  <dd>
    <p> The coordinates are given in Angstroms.</p>
  </dd>
  <dt>
    charge
  </dt>
  <dd>
    <p> This option can be given after an 'element x y z' quadruple. This will override the charge on the atom. For example, (charge = 0) can be given for the ghost atoms in a counterpoise correction calculation.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    multiplicity
  </dt>
  <dd>
    <p> Gives the multiplicity of the molecule. The default is 1.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    optimize
  </dt>
  <dd>
    <p> If yes, then an optimization will be performed. The default is no. The following options can be given.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    cartesian
  </dt>
  <dd>
    <p> Use Cartesian coordinates.</p>
  </dd>
  <dt>
    internal
  </dt>
  <dd>
    <p> Use internal coordinates.</p>
  </dd>
  <dt>
    redundant
  </dt>
  <dd>
    <p> Use redundant internal coordinates.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    gradient
  </dt>
  <dd>
    <p> If yes, then a gradient calculation will be performed. The default is no.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    frequencies
  </dt>
  <dd>
    <p> If yes, then the frequencies will be obtained. The default is no.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    charge
  </dt>
  <dd>
    <p> Specifies the charge on the molecule. The default is 0.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    method
  </dt>
  <dd>
    <p> Specif ices the method. There is no default and the possible values are:</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    HF
  </dt>
  <dd>
    <p> Hartree-Fock. Unrestricted HF is used if multiplicity &gt; 1</p>
  </dd>
  <dt>
    RHF
  </dt>
  <dd>
    <p> Restricted Hartree-Fock.</p>
  </dd>
  <dt>
    UHF
  </dt>
  <dd>
    <p> Unrestricted Hartree-Fock.</p>
  </dd>
  <dt>
    KS
  </dt>
  <dd>
    <p> Kohn-Sham. Unrestricted KS is used if multiplicity &gt; 1</p>
  </dd>
  <dt>
    RKS
  </dt>
  <dd>
    <p> Restricted Kohn-Sham.</p>
  </dd>
  <dt>
    UKS
  </dt>
  <dd>
    <p> Unrestricted Kohn-Sham.</p>
  </dd>
  <dt>
    MP2
  </dt>
  <dd>
    <p> Second order Moeller-Plesset perturbation theory. Only available for multiplicity = 1.</p>
  </dd>
  <dt>
    ZAPT2
  </dt>
  <dd>
    <p> Z-averaged perturbation theory. Only available for multiplicity &gt; 1. No gradient, optimization, or frequencies are possible.</p>
  </dd>

</dl>
<p>The following options are valid with the KS, RKS, and UKS methods:</p>
<dl class='dl-vertical'>
  <dt>
    grid
  </dt>
  <dd>
    <p> Specifies the grid to be used for numerical integrations. The following values can be given:</p>
  </dd>
  <dt>
    xcoarse
  </dt>
  <dd>
    
  </dd>
  <dt>
    coarse
  </dt>
  <dd>
    
  </dd>
  <dt>
    medium
  </dt>
  <dd>
    
  </dd>
  <dt>
    fine
  </dt>
  <dd>
    
  </dd>
  <dt>
    xfine
  </dt>
  <dd>
    
  </dd>
  <dt>
    ultrafine
  </dt>
  <dd>
    
  </dd>
  <dt>
    xc
  </dt>
  <dd>
    <p> Specifies the exchange-correlation functional. There is no default. See the table in the <strong>StdDenFunctional</strong> class documentation for the possible values.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    basis
  </dt>
  <dd>
    <p> Specifies the basis set. There is no default. See the table in the <strong>GaussianBasisSet</strong> class documentation for the available basis sets.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    restart
  </dt>
  <dd>
    <p> Set to yes to restart an optimization. The default is no.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    checkpoint
  </dt>
  <dd>
    <p> Set to no to not save checkpoint files during an optimization. The default is yes.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    symmetry
  </dt>
  <dd>
    <p> Specif ices the Schoenflies symbol of the point group of the molecule. The default is auto, which will cause to program to find the highest order Abelian subgroup of the molecule.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    docc
  </dt>
  <dd>
    <p> Gives the number of doubly occupied orbitals in each each irreducible representation in a parenthesized list. The symmetry must be specified and not be auto. The method must be restricted.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    socc
  </dt>
  <dd>
    <p> Gives the number of single occupied orbitals in each each irreducible representation in a parenthesized list. The symmetry must be specified and not be auto. The method must be restricted.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    alpha
  </dt>
  <dd>
    <p> Gives the number of alpha occupied orbitals in each each irreducible representation in a parenthesized list. The symmetry must be specified and not be auto. The method must be unrestricted.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    beta
  </dt>
  <dd>
    <p> Gives the number of beta occupied orbitals in each each irreducible representation in a parenthesized list. The symmetry must be specified and not be auto. The method must be unrestricted.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    frozen_docc
  </dt>
  <dd>
    <p> Gives the number of frozen core orbitals. Can be either a single integer or a parenthesized list giving the frozen core orbitals in each irreducible representation. In the latter case the symmetry must be given and not be auto.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    frozen_uocc
  </dt>
  <dd>
    <p> Gives the number of frozen virtual orbitals. Can be either a single integer or a parenthesized list giving the frozen virtual orbitals in each irreducible representation. In the latter case the symmetry must be given and not be auto.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Object-Oriented Input</h2>
        <div class="sectioncontent">
<p>MPQC is an object-oriented program that directly allows the user to specify objects that MPQC then manipulates to obtain energies, properties, etc. This makes the input very flexible, but very complex. However, most calculations should be quite similar to the one of the examples given later in this chapter. The best way to get started is to use one of the example input files and modify it to meet your needs.</p><p>MPQC starts off by creating a <strong>ParsedKeyVal</strong> object that parses the input file specified on the command line. The format of the input file is documented in . It is basically a free format input that associates keywords and logical groupings of keywords with values. The values can be scalars, arrays, or objects.</p><p>The keywords recognized by MPQC begin with the mpqc prefix. That is, they must be nested between an mpqc:( and a ). Alternately, each keyword can be individually prefixed by mpqc:. The primary keywords are given below. Some of the keywords specify objects, in which case the object will require more <strong>ParsedKeyVal</strong> input. These objects are created from the input by using their <strong>ParsedKeyVal</strong> constructors. These constructors are documented with the source code documentation for the class.</p>
<dl class='dl-vertical'>
  <dt>
    mole
  </dt>
  <dd>
    <p> This is the most important keyword for MPQC. It specifies the <strong>MolecularEnergy</strong> object. This is an object that knows how to compute the energy of a molecule. The specializations of <strong>MolecularEnergy</strong> that are most commonly used are CLKS, HSOSKS, UKS, <strong>CLHF</strong>, <strong>HSOSHF</strong>, UHF, and <strong>MBPT2</strong>.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    opt
  </dt>
  <dd>
    <p> This keyword must be specified for optimizations. It specifies an <strong>Optimize</strong> object. Usually, <strong>QNewtonOpt</strong> is best for finding minima and <strong>EFCOpt</strong> is best for transition states.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    freq
  </dt>
  <dd>
    <p> This keyword must be specified to compute frequencies. It specifies a <strong>MolecularFrequencies</strong> object.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    thread
  </dt>
  <dd>
    <p> This specifies an object of type <strong>ThreadGrp</strong> that can be used to advantage on shared-memory multiprocessor machines for certain types of calculations. This keyword can be overridden by giving the <strong>ThreadGrp</strong> in the environment or command line. See the section on running MPQC for more information.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    checkpoint
  </dt>
  <dd>
    <p> The value of this keyword is Boolean. If true, then optimizations will be checkpointed after each iteration. The checkpoint file suffice is .ckpt. The default is to checkpoint.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    savestate
  </dt>
  <dd>
    <p> The value of this keyword is Boolean. If true, then the states of the optimizer and wavefunction objects will be saved after the calculation completes. The output file suffix is .wfn. The default is to save state.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    restart
  </dt>
  <dd>
    <p> The value of this keyword is Boolean. If true, mpqc will attempt to restart the calculation. If the checkpoint file is not found, the calculation will continue as if the value were false. The default is true.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    restart_file
  </dt>
  <dd>
    <p> This gives the name of a file from which restart information is read. If the file name ends in .wfn the <strong>MolecularEnergy</strong> object will be restored. Otherwise, the <strong>Optimize</strong> object will be restored. The default file name is formed by appending .ckpt<strong> to the input file name with the extension removed.</strong></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    do_energy
  </dt>
  <dd>
    <p> The value of this keyword is Boolean. If true a single point energy calculation will be done for the <strong>MolecularEnergy</strong> object given with the mole keyword. The default is true.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    do_gradient
  </dt>
  <dd>
    <p> The value of this keyword is Boolean. If true a single point gradient calculation will be done for the <strong>MolecularEnergy</strong> object given with the mole keyword. The default is false.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    optimize
  </dt>
  <dd>
    <p> The value of this keyword is Boolean. If true and the opt keyword was set to a valid value, then an optimization will be performed. The default is true.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    write_pdb
  </dt>
  <dd>
    <p> The value of this keyword is Boolean. If true a PDB file with the molecular coordinates will be written.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    filename
  </dt>
  <dd>
    <p> The value of this keyword is a string that gives a name from which checkpoint and other filenames are constructed. The default is the basename of the input file.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    print_timings
  </dt>
  <dd>
    <p> If this is true, timing information is printed at the end of the run. The default is true.</p>
  </dd>

</dl>
<p>There are also some utility keywords that tell mpqc some technical details about how to do the calculation:</p>
<dl class='dl-vertical'>
  <dt>
    debug
  </dt>
  <dd>
    <p> This optional keyword gives a <strong>Debugger</strong> object which can used to help find the problem if MPQC encounters a catastrophic error.</p>
  </dd>
  <dt>
    matrixkit
  </dt>
  <dd>
    <p> This optional keyword gives a <strong>SCMatrixKit</strong> specialization which is used to produce matrices of the desired type. The default is a <strong>ReplSCMatrixKit</strong> which replicates matrices on all of the nodes. Other choices are not thoroughly tested.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>This example input does a Hartree-Fock calculation on water. Following is the entire input, followed by a breakdown with descriptions.</p>
<pre>
% This input does a Hartree-Fock calculation on water.
molecule&lt;<strong>Molecule</strong>&gt;: (
  symmetry = C2V
  unit = angstrom
  { atoms geometry } = {
    O     [    &nbsp;0.00000000     0.00000000    &nbsp;0.37000000 ]
    H     [    &nbsp;0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
basis&lt;<strong>GaussianBasisSet</strong>&gt;: (
  name = 'STO-3G'
  molecule = $:molecule
)
mpqc: (
  mole&lt;<strong>CLHF</strong>&gt;: (
    molecule = $:molecule
    basis = $:basis
  )
)

</pre>
<p>We start with a descriptive comment. Comments begin with a %. Everything from the % to the end of the line is ignored.</p>
<pre>
% This input does a Hartree-Fock calculation on water.

</pre>
<p>Now lets set up a <strong>Molecule</strong> object. The name of the object comes first, it is molecule<strong>. Then, in angle brackets, comes the type of the molecule, which is the class </strong><strong>Molecule</strong><strong>. The keyword and class name are followed by a :</strong><strong> and then several pieces of input grouped between a pair of matching parentheses. These parentheses contain the information that will be given to </strong><strong>Molecule</strong><strong> </strong><strong>KeyVal</strong><strong> constructor.</strong></p>
<pre>
molecule&lt;<strong>Molecule</strong>&gt;: (

</pre>
<p>The point group of the molecule is needed. This is done by assigning symmetry to a case insensitive Schoenflies symbol that is used to initialize a <strong>PointGroup</strong> object. An Abelian point group should be used.</p>
<pre>
  symmetry = C2V

</pre>
<p>The default unit for the Cartesian coordinates is Bohr. You can specify other units by assigned unit to a string that will be used to initialize a <strong>Units</strong> object.</p>
<pre>
  unit = angstrom

</pre>
<p>Finally, the atoms and coordinates are given. This can be given in the shorthand table syntax shown below. The headings of the table are the keywords between the first pair of brackets. These are followed by an = and another pair of brackets that contain the data. The first datum is assigned to the first element of the array that corresponds to the first heading, atom. The second datum is assigned to the first element of the array associated with the second heading, geometry, and so on. Here the second datum is actually a vector: the x, y and z coordinates of the first atom.</p>
<pre>
  { atoms                       geometry                   } = {
    O     [    &nbsp;0.00000000     0.00000000    &nbsp;0.37000000 ]
    H     [    &nbsp;0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)

</pre>
<p>Next, a basis set object is given.</p>
<pre>
basis&lt;<strong>GaussianBasisSet</strong>&gt;: (
  name = 'STO-3G'
  molecule = $:molecule
)

</pre>
<p>Now we will give the main body of input. All the subsequent keywords will be grouped in the mpqc section of the input (that is, each keyword will be prefixed with mpqc:).</p>
<pre>
mpqc: (

</pre>
<p>Next we give the mole keyword which provides a specialization of the <strong>MolecularEnergy</strong> class. In this case we will do a closed-shell Hartree-Fock calculation. That is done with an object of type <strong>CLHF</strong>. The keywords that <strong>CLHF</strong> accepts are given with the documentation for the <strong>CLHF</strong> class, usually in the description of the const RefKeyVal&<strong> constructor for the class. Also with the </strong><strong>CLHF</strong><strong> documentation is a list of parent classes. Each of the parent classes may also have input. This input is included with the rest of the input for the child class.</strong></p>
<pre>
  mole&lt;<strong>CLHF</strong>&gt;: (

</pre>
<p>The next line specifies the molecule to be used. There are two things to note, first that this is actually a reference to complete molecule specification elsewhere in the input file. The $ indicates that this is a reference and the keyword following the $ is the actual location of the molecule. The : in front of the keyword means that the keyword is not relative to the current location in the input, but rather relative to the root of the tree of keywords. Thus, this line grabs the molecule that was specified above. The molecule object could have been placed here, but frequently it is necessary that several objects refer to the exact same object and this can only be done using references.</p><p>The second point is that if you look at the documentation for <strong>CLHF</strong>, you will see that it doesn't read molecule<strong> keyword. However, if you follow its parent classes up to </strong><strong>MolecularEnergy</strong><strong>, you'll find that molecule</strong><strong> is indeed read.</strong></p>
<pre>
    molecule = $:molecule

</pre>
<p>Just as we gave molecule, specify the basis set with the basis keyword as follows:</p>
<pre>
    basis = $:basis

</pre>
<p>Now we close off the parentheses we opened above and we are finished.</p>
<pre>
  )
)

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Sample Object-Oriented Input Files</h2>
        <div class="sectioncontent">
<p>The easiest way to get started with mpqc is to start with one of sample inputs that most nearly matches your problem. All of the samples inputs shown here can be found in the directory src/bin/mpqc/samples.</p><h3>Hartree-Fock Energy</h3>
<p>The following input will compute the Hartree-Fock energy of water.</p>
<pre>
% emacs should use -*- <strong>KeyVal</strong> -*- mode
% molecule specification
molecule&lt;<strong>Molecule</strong>&gt;: (
  symmetry = C2V
  unit = angstrom
  { atoms geometry } = {
    O     [    &nbsp;0.00000000     0.00000000    &nbsp;0.37000000 ]
    H     [    &nbsp;0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
% basis set specification
basis&lt;<strong>GaussianBasisSet</strong>&gt;: (
  name = 'STO-3G'
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % method for computing the molecule's energy
  mole&lt;<strong>CLHF</strong>&gt;: (
    molecule = $:molecule
    basis = $:basis
    memory = 16000000
  )
)

</pre>

<h3>MP2 Energy</h3>
<p>The following input will compute the MP2 energy of water.</p>
<pre>
% emacs should use -*- <strong>KeyVal</strong> -*- mode
% molecule specification
molecule&lt;<strong>Molecule</strong>&gt;: (
  symmetry = C2V
  unit = angstrom
  { atoms geometry } = {
    O     [    &nbsp;0.00000000     0.00000000    &nbsp;0.37000000 ]
    H     [    &nbsp;0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
% basis set specification
basis&lt;<strong>GaussianBasisSet</strong>&gt;: (
  name = 'STO-3G'
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % method for computing the molecule's energy
  mole&lt;<strong>MBPT2</strong>&gt;: (
    molecule = $:molecule
    basis = $:basis
    memory = 16000000
    % reference wavefunction
    reference&lt;<strong>CLHF</strong>&gt;: (
      molecule = $:molecule
      basis = $:basis
      memory = 16000000
    )
  )
)

</pre>

<h3>Hartree-Fock Optimization</h3>
<p>The following input will optimize the geometry of water using the quasi-Newton method.</p>
<pre>
% emacs should use -*- <strong>KeyVal</strong> -*- mode
% molecule specification
molecule&lt;<strong>Molecule</strong>&gt;: (
  symmetry = C2V
  unit = angstrom
  { atoms geometry } = {
    O     [    &nbsp;0.00000000     0.00000000    &nbsp;0.37000000 ]
    H     [    &nbsp;0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
% basis set specification
basis&lt;<strong>GaussianBasisSet</strong>&gt;: (
  name = '6-31G*'
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % molecular coordinates for optimization
  coor&lt;<strong>SymmMolecularCoor</strong>&gt;: (
    molecule = $:molecule
    generator&lt;<strong>IntCoorGen</strong>&gt;: (
      molecule = $:molecule
    )
  )
  % method for computing the molecule's energy
  mole&lt;<strong>CLHF</strong>&gt;: (
    molecule = $:molecule
    basis = $:basis
    coor = $..:coor
    memory = 16000000
  )
  % optimizer object for the molecular geometry
  opt&lt;<strong>QNewtonOpt</strong>&gt;: (
    function = $..:mole
    update&lt;<strong>BFGSUpdate</strong>&gt;: ()
    convergence&lt;MolEnergyConvergence&gt;: (
      cartesian = yes
      energy = $..:..:mole
    )
  )
)

</pre>

<h3>Optimization with a Computed Guess Hessian</h3>
<p>The following input will optimize the geometry of water using the quasi-Newton method. The guess Hessian will be computed at a lower level of theory.</p>
<pre>
% emacs should use -*- <strong>KeyVal</strong> -*- mode
% molecule specification
molecule&lt;<strong>Molecule</strong>&gt;: (
  symmetry = C2V
  unit = angstrom
  { atoms geometry } = {
    O     [    &nbsp;0.00000000     0.00000000    &nbsp;0.37000000 ]
    H     [    &nbsp;0.78000000     0.00000000    -0.18000000 ]
    H     [    -0.78000000     0.00000000    -0.18000000 ]
  }
)
% basis set specification
basis&lt;<strong>GaussianBasisSet</strong>&gt;: (
  name = '6-31G*'
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % molecular coordinates for optimization
  coor&lt;<strong>SymmMolecularCoor</strong>&gt;: (
    molecule = $:molecule
    generator&lt;<strong>IntCoorGen</strong>&gt;: (
      molecule = $:molecule
    )
  )
  % method for computing the molecule's energy
  mole&lt;<strong>CLHF</strong>&gt;: (
    molecule = $:molecule
    basis = $:basis
    coor = $..:coor
    memory = 16000000
    guess_hessian&lt;<strong>FinDispMolecularHessian</strong>&gt;: (
      molecule = $:molecule
      only_totally_symmetric = yes
      eliminate_cubic_terms = no
      checkpoint = no
      energy&lt;<strong>CLHF</strong>&gt;: (
        molecule = $:molecule
        memory = 16000000
        basis&lt;<strong>GaussianBasisSet</strong>&gt;: (
          name = '3-21G'
          molecule = $:molecule
        )
      )
    )
  )
  % optimizer object for the molecular geometry
  opt&lt;<strong>QNewtonOpt</strong>&gt;: (
    function = $..:mole
    update&lt;<strong>BFGSUpdate</strong>&gt;: ()
    convergence&lt;MolEnergyConvergence&gt;: (
      cartesian = yes
      energy = $..:..:mole
    )
  )
)

</pre>

<h3>Optimization Using Newton's Method</h3>
<p>The following input will optimize the geometry of water using the Newton's method. The Hessian will be computed at each step in the optimization. However, Hessian recomputation is usually not worth the cost; try using the computed Hessian as a guess Hessian for a quasi-Newton method before resorting to a Newton optimization.</p>
<pre>
% Emacs should use -*- <strong>KeyVal</strong> -*- mode
% molecule specification
molecule&lt;<strong>Molecule</strong>&gt;: (
  symmetry = c2v
  unit = angstrom
  { atoms geometry } = {
     O     [    &nbsp;0.00000000     0.00000000    &nbsp;0.36937294 ]
     H     [    &nbsp;0.78397590     0.00000000    -0.18468647 ]
     H     [    -0.78397590     0.00000000    -0.18468647 ]
  }
)
% basis set specification
basis&lt;<strong>GaussianBasisSet</strong>&gt;: (
  name = '3-21G'
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  restart = no
  % molecular coordinates for optimization
  coor&lt;<strong>SymmMolecularCoor</strong>&gt;: (
    molecule = $:molecule
    generator&lt;<strong>IntCoorGen</strong>&gt;: (
      molecule = $:molecule
    )
  )
  do_energy = no
  do_gradient = no
  % method for computing the molecule's energy
  mole&lt;<strong>CLHF</strong>&gt;: (
    molecule = $:molecule
    basis = $:basis
    memory = 16000000
    coor = $..:coor
    guess_wavefunction&lt;<strong>CLHF</strong>&gt;: (
      molecule = $:molecule
      total_charge = 0
      basis&lt;<strong>GaussianBasisSet</strong>&gt;: (
        molecule = $:molecule
        name = 'STO-3G'
      )
      memory = 16000000
    )
    hessian&lt;<strong>FinDispMolecularHessian</strong>&gt;: (
      only_totally_symmetric = yes
      eliminate_cubic_terms = no
      checkpoint = no
    )
  )
  optimize = yes
  % optimizer object for the molecular geometry
  opt&lt;NewtonOpt&gt;: (
    print_hessian = yes
    max_iterations = 20
    function = $..:mole
    convergence&lt;MolEnergyConvergence&gt;: (
      cartesian = yes
      energy = $..:..:mole
    )
  )
)

</pre>

<h3>Hartree-Fock Frequencies</h3>
<p>The following input will compute Hartree-Fock frequencies by finite displacements. A thermodynamic analysis will also be performed. If optimization input is also provided, then the optimization will be run first, then the frequencies.</p>
<pre>
% emacs should use -*- <strong>KeyVal</strong> -*- mode
% molecule specification
molecule&lt;<strong>Molecule</strong>&gt;: (
  symmetry = C1
  { atoms geometry } = {
    O     [ &nbsp;0.0000000000    0.0000000000   &nbsp;0.8072934188 ]
    H     [ &nbsp;1.4325589285    0.0000000000   -0.3941980761 ]
    H     [ -1.4325589285    0.0000000000   -0.3941980761 ]
  }
)
% basis set specification
basis&lt;<strong>GaussianBasisSet</strong>&gt;: (
  name = 'STO-3G'
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % method for computing the molecule's energy
  mole&lt;<strong>CLHF</strong>&gt;: (
    molecule = $:molecule
    basis = $:basis
    memory = 16000000
  )
% vibrational frequency input
  freq&lt;<strong>MolecularFrequencies</strong>&gt;: (
    molecule = $:molecule
  )
)

</pre>

<h3>Giving Coordinates and a Guess Hessian</h3>
<p>The following example shows several features that are really independent. The variable coordinates are explicitly given, rather than generated automatically. This is especially useful when a guess Hessian is to be provided, as it is here. This Hessian, as given by the user, is not complete and the <strong>QNewtonOpt</strong> object will fill in the missing values using a guess the Hessian provided by the <strong>MolecularEnergy</strong> object. Also, fixed coordinates are given in this sample input.</p>
<pre>
% emacs should use -*- <strong>KeyVal</strong> -*- mode
% molecule specification
molecule&lt;<strong>Molecule</strong>&gt;: (
  symmetry = C1
  { atoms geometry } = {
      H    [ 0.088    2.006   &nbsp;1.438 ]
      O    [ 0.123    3.193   &nbsp;0.000 ]
      H    [ 0.088    2.006   -1.438 ]
      O    [ 4.502    5.955   -0.000 ]
      H    [ 2.917    4.963   -0.000 ]
      H    [ 3.812    7.691   -0.000 ]
  }
)
% basis set specification
basis&lt;<strong>GaussianBasisSet</strong>&gt;: (
  name = 'STO-3G'
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % method for computing the molecule's energy
  mole&lt;<strong>CLHF</strong>&gt;: (
    molecule = $:molecule
    basis = $:basis
    coor = $..:coor
    memory = 16000000
  )
  % molecular coordinates for optimization
  coor&lt;<strong>SymmMolecularCoor</strong>&gt;: (
    molecule = $:molecule
    generator&lt;<strong>IntCoorGen</strong>&gt;: (
      molecule = $:molecule
      extra_bonds = [ 2 5 ]
    )
    % use these instead of generated coordinates
    variable&lt;<strong>SetIntCoor</strong>&gt;: [
      &lt;<strong>StreSimpleCo</strong>&gt;:( atoms = [ 2 5 ] )
      &lt;<strong>BendSimpleCo</strong>&gt;:( atoms = [ 2 5 4 ] )
      &lt;OutSimpleCo&gt;: ( atoms = [ 5 2 1 3 ] )
      &lt;<strong>SumIntCoor</strong>&gt;: (
        coor: [
          &lt;<strong>StreSimpleCo</strong>&gt;:( atoms = [ 1 2 ] )
          &lt;<strong>StreSimpleCo</strong>&gt;:( atoms = [ 2 3 ] )
          ]
        coef = [ 1.0 1.0 ]
        )
      &lt;<strong>SumIntCoor</strong>&gt;: (
        coor: [
          &lt;<strong>StreSimpleCo</strong>&gt;:( atoms = [ 4 5 ] )
          &lt;<strong>StreSimpleCo</strong>&gt;:( atoms = [ 4 6 ] )
          ]
        coef = [ 1.0 1.0 ]
        )
      &lt;<strong>BendSimpleCo</strong>&gt;:( atoms = [ 1 2 3 ] )
      &lt;<strong>BendSimpleCo</strong>&gt;:( atoms = [ 5 4 6 ] )
    ]
    % these are fixed by symmetry anyway,
    fixed&lt;<strong>SetIntCoor</strong>&gt;: [
      &lt;<strong>SumIntCoor</strong>&gt;: (
        coor: [
          &lt;<strong>StreSimpleCo</strong>&gt;:( atoms = [ 1 2 ] )
          &lt;<strong>StreSimpleCo</strong>&gt;:( atoms = [ 2 3 ] )
          ]
        coef = [ 1.0 -1.0 ]
        )
      &lt;<strong>SumIntCoor</strong>&gt;: (
        coor: [
          &lt;<strong>StreSimpleCo</strong>&gt;:( atoms = [ 4 5 ] )
          &lt;<strong>StreSimpleCo</strong>&gt;:( atoms = [ 4 6 ] )
          ]
        coef = [ 1.0 -1.0 ]
        )
      &lt;<strong>TorsSimpleCo</strong>&gt;:( atoms = [ 2 5 4 6] )
      &lt;OutSimpleCo&gt;:( atoms = [ 3 2 6 4 ] )
      &lt;OutSimpleCo&gt;:( atoms = [ 1 2 6 4 ] )
    ]
  )
  % optimizer object for the molecular geometry
  opt&lt;<strong>QNewtonOpt</strong>&gt;: (
    function = $..:mole
    update&lt;<strong>BFGSUpdate</strong>&gt;: ()
    convergence&lt;MolEnergyConvergence&gt;: (
      cartesian = yes
      energy = $..:..:mole
    )
    % give a partial guess hessian in internal coordinates
    % the missing elements will be filled in automatically
    hessian = [
        [ &nbsp;0.0109261670 ]
        [ -0.0004214845    0.0102746106  ]
        [ -0.0008600592    0.0030051330    0.0043149957 ]
        [ &nbsp;0.0             0.0             0.0          ]
        [ &nbsp;0.0             0.0             0.0          ]
        [ &nbsp;0.0             0.0             0.0          ]
        [ &nbsp;0.0             0.0             0.0          ]
     ]
  )
)

</pre>

<h3>Optimization with a Hydrogen Bond</h3>
<p>The automatic internal coordinate generator will fail if it cannot find enough redundant internal coordinates. In this case, the internal coordinate generator must be explicitly created in the input and given extra connectivity information, as is shown below.</p>
<pre>
% emacs should use -*- <strong>KeyVal</strong> -*- mode
% molecule specification
molecule&lt;<strong>Molecule</strong>&gt;: (
  symmetry = C1
  { atoms geometry } = {
      H    [ 0.088    2.006   &nbsp;1.438 ]
      O    [ 0.123    3.193   &nbsp;0.000 ]
      H    [ 0.088    2.006   -1.438 ]
      O    [ 4.502    5.955   -0.000 ]
      H    [ 2.917    4.963   -0.000 ]
      H    [ 3.812    7.691   -0.000 ]
  }
)
% basis set specification
basis&lt;<strong>GaussianBasisSet</strong>&gt;: (
  name = 'STO-3G'
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % method for computing the molecule's energy
  mole&lt;<strong>CLHF</strong>&gt;: (
    molecule = $:molecule
    basis = $:basis
    coor = $..:coor
    memory = 16000000
  )
  % molecular coordinates for optimization
  coor&lt;<strong>SymmMolecularCoor</strong>&gt;: (
    molecule = $:molecule
    % give an internal coordinate generator that knows about the
    % hydrogen bond between atoms 2 and 5
    generator&lt;<strong>IntCoorGen</strong>&gt;: (
      molecule = $:molecule
      extra_bonds = [ 2 5 ]
    )
  )
  % optimizer object for the molecular geometry
  opt&lt;<strong>QNewtonOpt</strong>&gt;: (
    function = $..:mole
    update&lt;<strong>BFGSUpdate</strong>&gt;: ()
    convergence&lt;MolEnergyConvergence&gt;: (
      cartesian = yes
      energy = $..:..:mole
    )
  )
)

</pre>

<h3>Fixed Coordinate Optimization</h3>
<p>This example shows how to selectively fix internal coordinates in an optimization. Any number of linearly independent coordinates can be given. These coordinates must remain linearly independent throughout the optimization, a condition that might not hold since the coordinates can be nonlinear.</p><p>By default, the initial fixed coordinates' values are taken from the cartesian geometry given by the <strong>Molecule</strong> object; however, the molecule will be displaced to the internal coordinate values given with the fixed internal coordinates if have_fixed_values keyword is set to true, as shown in this example. In this case, the initial Cartesian geometry should be reasonably close to the desired initial geometry and all of the variable coordinates will be frozen to their original values during the initial displacement.</p>
<pre>
% emacs should use -*- <strong>KeyVal</strong> -*- mode
% molecule specification
molecule&lt;<strong>Molecule</strong>&gt;: (
  symmetry = CS
  { atoms geometry } = {
    H [ &nbsp;3.04 -0.69 -1.59 ]
    H [ &nbsp;3.04 -0.69 &nbsp;1.59 ]
    N [ &nbsp;2.09 -0.48 -0.00 ]
    C [ -0.58 -0.15 &nbsp;0.00 ]
    H [ -1.17 &nbsp;1.82 &nbsp;0.00 ]
    H [ -1.41 -1.04 -1.64 ]
    H [ -1.41 -1.04 &nbsp;1.64 ]
  }
)
% basis set specification
basis&lt;<strong>GaussianBasisSet</strong>&gt;: (
  name = '4-31G*'
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % molecular coordinates for optimization
  coor&lt;<strong>SymmMolecularCoor</strong>&gt;: (
    molecule = $:molecule
    generator&lt;<strong>IntCoorGen</strong>&gt;: (
      molecule = $:molecule
    )
    have_fixed_values = yes
    fixed&lt;<strong>SetIntCoor</strong>&gt;: [
      &lt;OutSimpleCo&gt;: ( value = -0.1
                       label = 'N-inversion'
                       atoms = [4 3 2 1] )
      ]
  )
  % method for computing the molecule's energy
  mole&lt;<strong>CLHF</strong>&gt;: (
    molecule = $:molecule
    basis = $:basis
    coor = $..:coor
    memory = 16000000
  )
  % optimizer object for the molecular geometry
  opt&lt;<strong>QNewtonOpt</strong>&gt;: (
    max_iterations = 20
    function = $..:mole
    update&lt;<strong>BFGSUpdate</strong>&gt;: ()
    convergence&lt;MolEnergyConvergence&gt;: (
      cartesian = yes
      energy = $..:..:mole
    )
  )
)

</pre>

<h3>Transition State Optimization</h3>
<p>This example shows a transition state optimization of the N-inversion in  using mode following. The initial geometry was obtained by doing a few fixed coordinate optimizations along the inversion coordinate.</p>
<pre>
% emacs should use -*- <strong>KeyVal</strong> -*- mode
% molecule specification
molecule&lt;<strong>Molecule</strong>&gt;: (
  symmetry = CS
  { atoms geometry } = {
    H [ &nbsp;3.045436 -0.697438 -1.596748 ]
    H [ &nbsp;3.045436 -0.697438 &nbsp;1.596748 ]
    N [ &nbsp;2.098157 -0.482779 -0.000000 ]
    C [ -0.582616 -0.151798 &nbsp;0.000000 ]
    H [ -1.171620 &nbsp;1.822306 &nbsp;0.000000 ]
    H [ -1.417337 -1.042238 -1.647529 ]
    H [ -1.417337 -1.042238 &nbsp;1.647529 ]
  }
)
% basis set specification
basis&lt;<strong>GaussianBasisSet</strong>&gt;: (
  name = '4-31G*'
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % molecular coordinates for optimization
  coor&lt;<strong>SymmMolecularCoor</strong>&gt;: (
    molecule = $:molecule
    generator&lt;<strong>IntCoorGen</strong>&gt;: (
      molecule = $:molecule
    )
    followed&lt;OutSimpleCo&gt; = [ 'N-inversion' 4 3 2 1 ]
  )
  % method for computing the molecule's energy
  mole&lt;<strong>CLHF</strong>&gt;: (
    molecule = $:molecule
    basis = $:basis
    coor = $..:coor
    memory = 16000000
  )
  % optimizer object for the molecular geometry
  opt&lt;<strong>EFCOpt</strong>&gt;: (
    transition_state = yes
    mode_following = yes
    max_iterations = 20
    function = $..:mole
    update&lt;<strong>PowellUpdate</strong>&gt;: ()
    convergence&lt;MolEnergyConvergence&gt;: (
      cartesian = yes
      energy = $..:..:mole
    )
  )
)

</pre>

<h3>Transition State Optimization with a Computed Guess Hessian</h3>
<p>This example shows a transition state optimization of the N-inversion in  using mode following. The initial geometry was obtained by doing a few fixed coordinate optimizations along the inversion coordinate. An approximate guess Hessian will be computed, which makes the optimization converge much faster in this case.</p>
<pre>
% emacs should use -*- <strong>KeyVal</strong> -*- mode
% molecule specification
molecule&lt;<strong>Molecule</strong>&gt;: (
  symmetry = CS
  { atoms geometry } = {
    H [ &nbsp;3.045436 -0.697438 -1.596748 ]
    H [ &nbsp;3.045436 -0.697438 &nbsp;1.596748 ]
    N [ &nbsp;2.098157 -0.482779 -0.000000 ]
    C [ -0.582616 -0.151798 &nbsp;0.000000 ]
    H [ -1.171620 &nbsp;1.822306 &nbsp;0.000000 ]
    H [ -1.417337 -1.042238 -1.647529 ]
    H [ -1.417337 -1.042238 &nbsp;1.647529 ]
  }
)
% basis set specification
basis&lt;<strong>GaussianBasisSet</strong>&gt;: (
  name = '4-31G*'
  molecule = $:molecule
)
mpqc: (
  checkpoint = no
  savestate = no
  % molecular coordinates for optimization
  coor&lt;<strong>SymmMolecularCoor</strong>&gt;: (
    molecule = $:molecule
    generator&lt;<strong>IntCoorGen</strong>&gt;: (
      molecule = $:molecule
    )
    followed&lt;OutSimpleCo&gt; = [ 'N-inversion' 4 3 2 1 ]
  )
  % method for computing the molecule's energy
  mole&lt;<strong>CLHF</strong>&gt;: (
    molecule = $:molecule
    basis = $:basis
    coor = $..:coor
    memory = 16000000
    guess_hessian&lt;<strong>FinDispMolecularHessian</strong>&gt;: (
      molecule = $:molecule
      only_totally_symmetric = yes
      eliminate_cubic_terms = no
      checkpoint = no
      energy&lt;<strong>CLHF</strong>&gt;: (
        molecule = $:molecule
        memory = 16000000
        basis&lt;<strong>GaussianBasisSet</strong>&gt;: (
          name = '3-21G'
          molecule = $:molecule
        )
      )
    )
  )
  % optimizer object for the molecular geometry
  opt&lt;<strong>EFCOpt</strong>&gt;: (
    transition_state = yes
    mode_following = yes
    max_iterations = 20
    function = $..:mole
    update&lt;<strong>PowellUpdate</strong>&gt;: ()
    convergence&lt;MolEnergyConvergence&gt;: (
      cartesian = yes
      energy = $..:..:mole
    )
  )
)

</pre>


        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="mppprof.1.html"><span aria-hidden="true">&larr;</span> mppprof.1: Create model printer profile.</a></li>
   <li class="next"><a href="mpqcval.1.html">mpqcval.1: Run the mpqc validation suite  chkmpqcval - check the .out files for correctness <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

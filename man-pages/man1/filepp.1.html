<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>filepp: A generic file preprocessor</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="A generic file preprocessor">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="filepp (1) manual">
  <meta name="twitter:description" content="A generic file preprocessor">
  <meta name="twitter:image" content="https://www.carta.tech/images/filepp-filepp-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/filepp.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="filepp (1) manual" />
  <meta property="og:description" content="A generic file preprocessor" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/filepp-filepp-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">filepp<small> (1)</small></h1>
        <p class="lead">A generic file preprocessor</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/filepp.1.html">
      <span itemprop="name">filepp: A generic file preprocessor</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/filepp/">
      <span itemprop="name">filepp</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/filepp.1.html">
      <span itemprop="name">filepp: A generic file preprocessor</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>filepp</strong> [<em>options</em>] <em>filename(s)</em></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><strong>filepp</strong> is a generic file preprocessor designed to allow the functionality provided by the C preprocessor <strong>cpp</strong>(1) to be used with any file type.  <strong>filepp</strong> is designed to be easily customised and extended.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONS</h2>
        <div class="sectioncontent">
<p><strong>filepp</strong> accepts the following command line options:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>-b</strong></p>
  </dt>
  <dd>
    <p>Suppress blank lines originating from include files (this has no effect on the top-level file).</p>
  </dd>
  <dt>
    <p><strong>-c</strong></p>
  </dt>
  <dd>
    <p>Read input from STDIN instead of a file.  Note: if both <strong>-c</strong> and input files are specified, both are used as inputs in the order given.</p>
  </dd>
  <dt>
    <p><strong>-D</strong><em>macro</em></p>
  </dt>
  <dd>
    <p>Predefine <em>macro</em> to have a definition of  `\|<strong>1</strong>\|'.</p>
  </dd>
  <dt>
    <p><strong>-D</strong><em>macro</em><strong>=</strong><em>defn</em></p>
  </dt>
  <dd>
    <p>Predefine <em>macro</em> to have a definition of <em>defn</em>.</p>
  </dd>
  <dt>
    <p><strong>-d</strong></p>
  </dt>
  <dd>
    <p>Output debugging information.</p>
  </dd>
  <dt>
    <p><strong>-dd</strong></p>
  </dt>
  <dd>
    <p>Output verbose debugging information.  This option shows all normal debugging information, plus the full list of defined macros every time the list changes.</p>
  </dd>
  <dt>
    <p><strong>-dl</strong></p>
  </dt>
  <dd>
    <p>Output light debugging information.  This option shows minimal debugging information.</p>
  </dd>
  <dt>
    <p><strong>-dpre</strong><em>char</em></p>
  </dt>
  <dd>
    <p>Prefix all debugging information with <em>char</em> (can be character or string), can be used to make debugging easier to read.</p>
  </dd>
  <dt>
    <p><strong>-dpost</strong><em>char</em></p>
  </dt>
  <dd>
    <p>Postfix all debugging information with <em>char</em> (can be character or string), this defaults to a newline.  If <em>char</em> does not contain a newline, then no newline will be printed after debugging messages. (Newlines can be put in <em>char</em> using the \_\_NEWLINE\_\_ macro.)</p>
  </dd>
  <dt>
    <p><strong>-ds</strong></p>
  </dt>
  <dd>
    <p>Print debugging info on stdout rather than stderr.</p>
  </dd>
  <dt>
    <p><strong>-e</strong></p>
  </dt>
  <dd>
    <p>Define all environment variables as macros with prefix <strong>envchar</strong>.</p>
  </dd>
  <dt>
    <p><strong>-ec</strong><em> char</em></p>
  </dt>
  <dd>
    <p>Set <strong>envchar</strong> (prefix of environment variables defined as macros) to <em>char</em>, defaults to <strong>$</strong>. (Note: this option only takes effect at the time the environment variables are converted to macros).</p>
  </dd>
  <dt>
    <p><strong>-ecn</strong></p>
  </dt>
  <dd>
    <p>Set <strong>envchar</strong> (prefix of environment variables defined as macros) to nothing (no prefix).</p>
  </dd>
  <dt>
    <p><strong>-h</strong></p>
  </dt>
  <dd>
    <p>Show summary of options.</p>
  </dd>
  <dt>
    <p><strong>-I</strong><em>dir</em></p>
  </dt>
  <dd>
    <p>Append directory <em>dir</em> to the list of directories searched for include files.</p>
  </dd>
  <dt>
    <p><strong>-imacros</strong><em> file</em></p>
  </dt>
  <dd>
    <p>Reads in macros from <em>file</em>, but discards everything else in the file.</p>
  </dd>
  <dt>
    <p><strong>-k</strong></p>
  </dt>
  <dd>
    <p>Turn off parsing of all keywords.  This is useful if you just want to use the macro expansion facilities of <strong>filepp</strong>.  With this option all keywords found will be ignored, <strong>filepp</strong> will just replace any macros specified with the <strong>-D</strong><em>macro</em>=<em>defn</em> option.</p>
  </dd>
  <dt>
    <p><strong>-kc</strong><em> char</em></p>
  </dt>
  <dd>
    <p>Set keyword prefix character to <em>char</em> (can also be a string). All <strong>filepp</strong> keywords are prefixed with the character <strong>#</strong> by default.  This option allows the prefix to be changed to something else.</p>
  </dd>
  <dt>
    <p><strong>-lc</strong><em> char</em></p>
  </dt>
  <dd>
    <p>Set line continuation character to <em>char</em> (can also be a string). When the line continuation character is found with a newline following it, it and the newline are replaced by the line continuation replacement character. Default is <strong>&#92;</strong> (<strong>cpp</strong>(1) style).</p>
  </dd>
  <dt>
    <p><strong>-lec</strong><em> char</em></p>
  </dt>
  <dd>
    <p>Set optional keyword line end character to <em>char</em> (can also be a string). This allows extra characters to be placed at the end of a line containing a keyword.  The extra characters will be ignored.  This is useful if keywords are to be embedded in HTML or C style comments.  For example, to embed keywords in an HTML comment the keyword prefix character could be set to <strong>&lt;--!#</strong> and the optional keyword line end character set to <strong>--&gt;</strong>.  An example keyword would then be:</p><p><strong>&lt;!--#include "header.h" --&gt;</strong></p><p>In the case the optional keyword line end characters <strong>--&gt;</strong> would be ignored.</p>
  </dd>
  <dt>
    <p><strong>-lr</strong><em> char</em></p>
  </dt>
  <dd>
    <p>Set line continuation replacement character to <em>char</em> (can also be a string).  Default is a null string (<strong>cpp</strong>(1) style).</p>
  </dd>
  <dt>
    <p><strong>-lrn</strong></p>
  </dt>
  <dd>
    <p>Set line continuation replacement character to be a newline.</p>
  </dd>
  <dt>
    <p><strong>-m</strong><em> module.pm</em></p>
  </dt>
  <dd>
    <p>Load module <em>module.pm</em>.  <em>module.pm</em> is a <strong>perl</strong>(1) module which can be used to extend or modify the behaviour of <strong>filepp</strong>.  See section <strong>FILEPP MODULES</strong> for details of modules included with filepp and <strong>FILEPP MODULE API</strong> for details on how to write your own modules.</p>
  </dd>
  <dt>
    <p><strong>-M</strong><em>dir</em></p>
  </dt>
  <dd>
    <p>Append directory <em>dir</em> to the list of directories searched for filepp modules.  This list defaults to the directory the filepp modules are installed (if any) plus the default Perl module paths. (Note: this adds the directory to the Perl @INC list.)</p>
  </dd>
  <dt>
    <p><strong>-mp</strong><em> char</em></p>
  </dt>
  <dd>
    <p>Prefix all macros with <em>char</em>.  Macros are defined in the normal way, but will only be replaced when found prefixed with <em>char</em>. For example, filepp macros will behave similar to Bourne shell (<strong>sh</strong>(1)) variables if <em>char</em> is set to <strong>$</strong>.</p>
  </dd>
  <dt>
    <p><strong>-mpnk</strong></p>
  </dt>
  <dd>
    <p>Turns off macro prefixes within keywords.  When using a macro prefix character this option allows macros to be used without the prefix in keyword processing.  For example, if the macro prefix is <strong>$</strong> then and <strong>#if</strong> would be written as:</p><p><strong>#if $MACRO == 1</strong></p><p>Using the <strong>mpnk</strong> option allows the <strong>#if</strong> to be written as:</p><p><strong>#if MACRO == 1</strong></p>
  </dd>
  <dt>
    <p><strong>-o</strong><em> </em><em>name</em><em></em></p>
  </dt>
  <dd>
    <p>Write output to <em>name</em> instead of STDOUT.  If there is only one input file and it has the same name as the output file, the original input file will be backed-up as <em>name~</em>.</p>
  </dd>
  <dt>
    <p><strong>-ov</strong></p>
  </dt>
  <dd>
    <p>Overwrite mode, causes the output file to overwrite the input file. Useful when modifying a large number of files at once, eg:</p><p><strong>filepp</strong> -ov -DTHIS=THAT *</p><p>The original input file(s) will be backed-up as <em>name~</em>.</p>
  </dd>
  <dt>
    <p><strong>-ovc</strong><em> </em><strong>IN</strong><em>=</em><strong>OUT</strong><em></em></p>
  </dt>
  <dd>
    <p>Similar to overwrite mode, the difference is the output filename is input filename with <strong>IN</strong> part converted to <strong>OUT</strong>.  For example, to process a set of files all ending with .in and have the output files all ending in .out do:</p><p><strong>filepp</strong> -ovc .in=.out *.in</p><p>In this case a file called <em>test.in</em> will be processed and the output file will be <em>test.out</em>.  Note: if the input file does not contain <strong>IN</strong> then the output file will have the same name as the input file and the original input file(s) will be backed-up as <em>name~</em>!</p>
  </dd>
  <dt>
    <p><strong>-pb</strong></p>
  </dt>
  <dd>
    <p>Preserve blank lines.  Using this option attempts to keep as many lines in the output file as are in the input file, so all blank lines which normally would not get printed are printed.  Useful when comparing intput file with output.</p>
  </dd>
  <dt>
    <p><strong>-re</strong></p>
  </dt>
  <dd>
    <p>Treat keyword and macro prefix characters and line continuation character as Perl regular expressions instead of normal strings.</p>
  </dd>
  <dt>
    <p><strong>-s</strong></p>
  </dt>
  <dd>
    <p>Run <strong>filepp</strong> in safe mode.  This turns off the <strong>pragma</strong> keyword.</p>
  </dd>
  <dt>
    <p><strong>-U</strong><em>macro</em></p>
  </dt>
  <dd>
    <p>Undefine previously defined <em>macro</em>.</p>
  </dd>
  <dt>
    <p><strong>-u</strong></p>
  </dt>
  <dd>
    <p>Undefine all currently defined macros, including predefined ones.</p>
  </dd>
  <dt>
    <p><strong>-v</strong></p>
  </dt>
  <dd>
    <p>Show version of program.</p>
  </dd>
  <dt>
    <p><strong>-w</strong></p>
  </dt>
  <dd>
    <p>Turn on word boundaries when replacing macros.  When word boundaries are on, macros will only be replaced if the macro appears in the text as a word.  For example, by default <em>macro</em> would be replaced in both cases of the following text:</p><p><em>macro as word, macroNOTaword</em></p><p>but only the first occurrence would be replaced with the <strong>-w</strong> option.</p><p>With this option enabled <strong>filepp</strong> will only replace macros which contain alphanumeric characters.  International (non-ASCII) character sets can be supported using Perl's locale handling.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">KEYWORDS</h2>
        <div class="sectioncontent">
<p><strong>filepp</strong> supports the following keywords:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>#include</strong> &lt;<em>FILE</em>&gt;</p>
  </dt>
  <dd>
    <p>Include a file in the file being processed.  This variant is used for "system" include files.  It searches for a file named <em>FILE</em> in a list of directories specified by you.  Directories are specified with the command option `-I'.  <strong>filepp</strong> does not predefine any system directories in which to search for files.</p>
  </dd>
  <dt>
    <p><strong>#include</strong> <strong>FILE</strong></p>
  </dt>
  <dd>
    <p>Include a file in the file being processed.  This variant is used for include files of your own project.  It searches for a file named <em>FILE</em> first in the current directory, then in the list of directories specified with the command option `-I'.  The current directory is the directory the base input file is in.</p>
  </dd>
  <dt>
    <p><strong>#define</strong> <em>macro</em></p>
  </dt>
  <dd>
    <p>Define the macro <em>macro</em> to have a definition of `1'.  <em>macro</em> can then be used with the keywords <strong>#ifdef</strong> and <strong>#ifndef</strong>.</p>
  </dd>
  <dt>
    <p><strong>#define</strong> <em>macro</em> <em>defn</em></p>
  </dt>
  <dd>
    <p>Define the macro <em>macro</em> to have the value <em>defn</em>. <em>macro</em> can then be used with the keywords <strong>#ifdef</strong> and #ifndef.  Also, all instances of <em>macro</em> following the <strong>#define</strong> statement will be replaced with the string <em>defn</em>. The string <em>defn</em> is taken to be all the characters on the line following <em>macro</em>.</p>
  </dd>
  <dt>
    <p><strong>#define</strong> <em>macro(arg1, arg2, ...)</em> <em>defn</em></p>
  </dt>
  <dd>
    <p>Define the macro <em>macro</em> to have the value <em>defn</em> with arguments <em>(arg1, arg2, ...)</em>.  <em>macro</em> can be used as follows:</p><p><strong>#define</strong> <em>macro(foo)</em> defn with foo in</p><p>Now when replacing occurs:</p><p><em>macro(bar)</em></p><p>will become:</p><p>defn with bar in</p><p>Macros can have any number of comma separated arguments.</p><p>Macros can also have variable numbers of arguments if the final macro ends in ..., for example:</p><p><strong>#define</strong> <em>error(string, args...)</em> fprintf(stderr, string, args);</p><p>Here the first argument given becomes <em>string</em> and all other arguments will become <em>args</em>. If called as: <em>error("%d,%s", i, string)</em> it will give</p><p>fprintf(stderr, "%d,%s", i, string);</p><p>Also, if a macro with a variable number of arguments is passed no arguments for the variable argument, then commas can be optionally removed from the definition by preceding the definition with "##". For example:</p><p><strong>#define</strong> <em>error(string, args...)</em> fprintf(stderr, string, ##args);</p><p>If this is called as: <em>error("empty")</em> then result will be:</p><p>fprintf(stderr, "empty");</p><p>The comma immediately before <em>##args</em> has been removed.</p>
  </dd>
  <dt>
    <p><strong>#if</strong> <em>expr</em></p>
  </dt>
  <dd>
    <p>A conditional statement, <em>expr</em> will be evaluated to true (1) or false (0).  If <em>expr</em> evaluates to true, the text between the <strong>#if</strong> and the next <strong>#else</strong> or <strong>#endif</strong> will be included. If <em>expr</em> evaluates to false, the text between the <strong>#if</strong> and the next <strong>#else</strong> or <strong>#endif</strong> will be ignored.  <em>expr</em> can use all the usual cpp style comparisons (==, !=, &lt;, &gt;, etc.). Multiple comparisons can be combined with and (&&) and or (||).  The <strong>defined</strong> keyword can also be used to check if macros are defined. For example:</p><p><em>#if defined macro && macro == defn</em></p><p>Note: filepp's <strong>#if</strong> does not work in exactly the same way as <strong>cpp</strong>(1)'s <strong>#if</strong>.  <strong>cpp</strong>(1)'s <strong>#if</strong> only does numerical style comparisons.  Filepp's <strong>#if</strong> statement can also compare strings and regular expressions using <strong>perl</strong>(1)'s full range of comaprison operations.  For example, to test if two strings are exactly equal use:</p><p><em>#if "MACRO" eq "string"</em></p><p>To test if strings are not equal use <em>ne</em> instead of <em>eq</em>. Regular expressions can also be tested, for example to test if a macro has any whitespace in it use:</p><p><em>#if "MACRO" =~ /&#92;s/</em></p><p>To test if a macro does not have any whitespace in it <em>=~</em> can be replaced with <em>!~</em>.</p><p>Perl experts: <strong>#if</strong> works by first parsing <em>expr</em> for the <strong>defined</strong> keyword and checking if the macro it refers to is defined, replacing it with 1 if it is and 0 if it isn't.  It then checks <em>expr</em> for any other macros and replaces them with their definition.  Finally it passes <em>expr</em> through Perl's <strong>eval</strong> function, which returns true or false.</p>
  </dd>
  <dt>
    <p><strong>#elif</strong> <em>expr</em></p>
  </dt>
  <dd>
    <p><strong>#elif</strong> stands for "else if".  Like <strong>#else</strong>, it goes in the middle of a <strong>#if</strong>[<strong>n</strong>][<strong>def</strong>]-<strong>#endif</strong> pair and subdivides it; it does not require a matching <strong>#endif</strong> of its own. Like <strong>#if</strong>, the <strong>#elif</strong> directive includes an expression to be tested.</p>
  </dd>
  <dt>
    <p><strong>#ifdef</strong> <em>macro</em></p>
  </dt>
  <dd>
    <p>A conditional statement, if <em>macro</em> has been defined the text between the <strong>#ifdef</strong> and the next <strong>#else</strong> or <strong>#endif</strong> will be included.  If <em>macro</em> has not been defined the text between the <strong>#ifdef</strong> and the next <strong>#else</strong> or <strong>#endif</strong> will be ignored.</p>
  </dd>
  <dt>
    <p><strong>#ifndef</strong> <em>macro</em></p>
  </dt>
  <dd>
    <p>The reverse case of the <strong>#ifdef</strong> conditional.</p>
  </dd>
  <dt>
    <p><strong>#else</strong></p>
  </dt>
  <dd>
    <p>The <strong>#else</strong> directive can be added to a conditional to provide alternative text to be used if the condition is false.</p>
  </dd>
  <dt>
    <p><strong>#endif</strong></p>
  </dt>
  <dd>
    <p>Used to terminate a conditional statement.  Normal processing resumes following the <strong>#endif</strong>.</p>
  </dd>
  <dt>
    <p><strong>#undef</strong> <em>macro</em></p>
  </dt>
  <dd>
    <p>Undefine a previously defined macro.</p>
  </dd>
  <dt>
    <p><strong>#error</strong> <em>mesg</em></p>
  </dt>
  <dd>
    <p>Causes <strong>filepp</strong> to exit with the error message <em>mesg</em>.</p>
  </dd>
  <dt>
    <p><strong>#warning</strong> <em>mesg</em></p>
  </dt>
  <dd>
    <p>Causes <strong>filepp</strong> to issue the warning message <em>mesg</em>.</p>
  </dd>
  <dt>
    <p><strong>#comment</strong> <em>mesg</em></p>
  </dt>
  <dd>
    <p>As <strong>filepp</strong> is supposed to be a generic file preprocessor, it cannot support any known comment styles, therefore it defines its own with this keyword.  All lines starting with <strong>#comment</strong> are treated as comments and removed by <strong>filepp</strong>.</p>
  </dd>
  <dt>
    <p><strong>#pragma</strong> <strong>filepp</strong> <em>function arg1, arg2, ...</em></p>
  </dt>
  <dd>
    <p>The <strong>#pragma</strong> keyword immediately followed by the word <strong>filepp</strong> allows the user to execute a Perl function during parsing.  The word immediately following <strong>filepp</strong> is taken as the name of the function and the remainder of the line is taken to be a comma separated list of arguments to the function.  Any of the <strong>filepp</strong> internal functions (see section <strong>FILEPP MODULE API</strong>) can be called with the <strong>#pragma</strong> keyword.</p><p><em>Warning:</em> There are obvious security risks with allowing arbitrary functions to be run, so the -s (safe mode) command line option has been added which turns the <strong>#pragma</strong> keyword off.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PREDEFINED MACROS</h2>
        <div class="sectioncontent">
<p><strong>filepp</strong> supports a set of predefined macros.  All the predefined macros are of the form <strong>__MACRO__</strong>, where <strong>MACRO</strong> is:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>FILE</strong></p>
  </dt>
  <dd>
    <p>This macro expands to the name of the current input file.</p>
  </dd>
  <dt>
    <p><strong>LINE</strong></p>
  </dt>
  <dd>
    <p>This macro expands to the current input line number.</p>
  </dd>
  <dt>
    <p><strong>DATE</strong></p>
  </dt>
  <dd>
    <p>This macro expands to a string that describes the date on which the preprocessor is being run.  The string contains eleven characters and looks like "Aug 26 2012".</p>
  </dd>
  <dt>
    <p><strong>ISO_DATE</strong></p>
  </dt>
  <dd>
    <p>This macro expands to a string that describes the date on which the preprocessor is being run.  The string is in the format specified by ISO 8601 (YYYY-MM-DD) and looks like "2012-08-26".</p>
  </dd>
  <dt>
    <p><strong>TIME</strong></p>
  </dt>
  <dd>
    <p>This macro expands to a string that describes the time at which the preprocessor is being run.  The string contains eight characters and looks like "19:05:05".</p>
  </dd>
  <dt>
    <p><strong>BASE_FILE</strong></p>
  </dt>
  <dd>
    <p>This macro expands to the name of the main input file.</p>
  </dd>
  <dt>
    <p><strong>INCLUDE_LEVEL</strong></p>
  </dt>
  <dd>
    <p>This macro expands to a decimal integer constant that represents the depth of nesting in include files.  The value of this macro is incremented on every <strong>#include</strong> directive and decremented at every end of file.</p>
  </dd>
  <dt>
    <p><strong>NEWLINE</strong></p>
  </dt>
  <dd>
    <p>This macro expands to a newline.</p>
  </dd>
  <dt>
    <p><strong>TAB</strong></p>
  </dt>
  <dd>
    <p>This macro expands to a tab.</p>
  </dd>
  <dt>
    <p><strong>NULL</strong></p>
  </dt>
  <dd>
    <p>This macro expands to nothing.  It is useful if you want to define something to be nothing.</p>
  </dd>
  <dt>
    <p><strong>VERSION</strong></p>
  </dt>
  <dd>
    <p>This macro expands to a string constant which describes the version number of <strong>filepp</strong>.  The string is a sequence of decimal numbers separated by periods and looks like "1.8.0".</p>
  </dd>
  <dt>
    <p><strong>FILEPP_INPUT</strong></p>
  </dt>
  <dd>
    <p>This macro expands to a string constant which says the file was generated automatically from the current <strong>BASE_FILE</strong> and looks like "Generated automatically from ./filepp.1.in by filepp".</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILEPP MODULES</h2>
        <div class="sectioncontent">
<p>The following modules are included with the main filepp distribution:</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FOR MODULE - for.pm</h2>
        <div class="sectioncontent">
<p>The for module implements a simple for loop. Its file name is <strong>for.pm</strong>.</p><p>The for loop is similar in functionality to that of other programming languages such as Perl or or C.  It has a single variable (a filepp macro) which is assigned a numerical value.  This numerical value changes by a set increment on each iteration through the loop.  The loop termiates when the value no longer passes a comparison test.</p><p>The for module implements the following keywords:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>#for</strong> <em>macro</em> <em>start</em> <em>compare</em> <em>end</em> <em>increment</em></p>
  </dt>
  <dd>
    <p>The <strong>#for</strong> keyword is functionally equivalent to the following Perl or C style loop:</p><p>for(<em>macro</em>=<em>start</em>; <em>macro</em> <em>compare</em> <em>end</em>; <em>macro</em>+=<em>increment</em>)</p><p>The <strong>#for</strong> keyword requires the following space separated parameters:</p><p><em>macro</em> : The name of the macro to which the for loop should assign its numerical value.</p><p><em>start</em> : The value <em>macro</em> should be assigned at the start of the loop.  <em>start</em> should be a numerical value.</p><p><em>compare</em> : The comparison to make between the current value of <em>macro</em> and the value <em>end</em> to determine when the loop should terminate.  Valid values for <em>compare</em> are &lt;, &gt;, &gt;=, &lt;=.</p><p><em>end</em> : the for loop will terminate when the test</p><p> <em> macro compare end </em></p><p>fails.  <em>end</em> should be a numerical value.</p><p><em>increment</em> : The value to increment <em>macro</em> on each iteration of the loop.  At the end of each iteration the value of <em>increment</em> is added to the current value of <em>macro</em>. <em>increment</em> should be a numerical value.</p>
  </dd>
  <dt>
    <p><strong>#endfor</strong></p>
  </dt>
  <dd>
    <p>The <strong>#endfor</strong> keyword is used to signify the end of the loop. Everything within the opening <strong>#for</strong> and the closing <strong>#endfor</strong> will be processed on each iteration of the loop.</p>
  </dd>

</dl>
<p>Example usage:</p><p><strong>#for</strong> COUNTER 10 &gt; 1 -2.5</p>
<pre>
  COUNTER
</pre>
<p><strong>#endfor</strong></p><p>In the above example COUNTER will be defined to have values 10, 7.5, 5 and 2.5 for each successive iteration through the loop.</p><p>Nested loops are also possible, as is changing the value of the macro within the loop.  <em>start</em>, <em>end</em> and <em>increment</em> should all be numerical values, however it is possible to use macros instead provided the macros are defined to have numerical values.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FOREACH MODULE - foreach.pm</h2>
        <div class="sectioncontent">
<p>The foreach module implements a simple foreach loop. Its file name is <strong>foreach.pm</strong>.</p><p>The foreach loop is similar in functionality to that of other programming languages such as Perl.  It takes a list of values separated by a user definable delimiter (',' by default).  It then iterates through all values in the list, defining a macro to be each individual value for each iteration of the loop.  The loop terminates when all values have been used.</p><p>The foreach module implements the following keywords:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>#foreach</strong> <em>macro</em> <em>list</em></p>
  </dt>
  <dd>
    <p>The <strong>#foreach</strong> keyword is functionally equivalent to the following Perl style loop:</p><p>foreach <em>macro</em> (split(/<em>delim</em>/, <em>list</em>))</p><p>The <strong>#foreach</strong> keyword requires the following space separated parameters:</p><p><em>macro</em> : The name of the macro to which the foreach loop should assign the current list value.</p><p><em>list</em> : The list of values, separated by <em>delim</em> (see <strong>#foreachdelim</strong> keyword for how to set <em>delim</em>). <em>list</em> can also be a macro or contain macros.</p><p>The loop will run from the <strong>#foreach</strong> keyword to the next <strong>#endforeach</strong> keyword.</p>
  </dd>
  <dt>
    <p><strong>#endforeach</strong></p>
  </dt>
  <dd>
    <p>The <strong>#endforeach</strong> keyword is used to signify the end of the loop. Everything within the opening <strong>#foreach</strong> and the closing <strong>#endforeach</strong> will be processed on each iteration of the loop.</p>
  </dd>

</dl>
<p>Example usage:</p><p><strong>#foreach</strong> VALUE one, two, three, four</p>
<pre>
  VALUE
</pre>
<p><strong>#endforeach</strong></p><p>In the above example VALUE will be defined to have values one, two, three and four for each successive iteration through the loop.</p><p>Nested loops are also possible.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>#foreachdelim</strong> /<em>delim</em>/</p>
  </dt>
  <dd>
    <p>The <strong>#foreachdelim</strong> keyword is used to set the delimiter used in each list.  The delimiter can be any character, string or regular expression.  The delimiter should be enclosed in forward slashes, in the same style as Perl regular expressions.   The default value for <em>delim</em> is ','.  To set the delimiter to be a single space do:</p><p><strong>#foreachdelim</strong> / /</p><p>To set <em>delim</em> to be any amount of white space do:</p><p><strong>#foreachdelim</strong> /&#92;s\+/</p><p>See the Perl documentation on regular expressions for more advanced uses.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LITERAL MODULE - literal.pm</h2>
        <div class="sectioncontent">
<p>The literal module prevents macros appearing in literal strings from being replaced.  A literal string is defined as having the form:</p><p><em>"literal string with</em> <strong>macro</strong> <em>in"</em></p><p>In the above example, <strong>macro</strong> will not be replaced.</p><p>The behaviour of the literal module can be reveresed by defining the macro <strong>LITERAL_REVERSE</strong> before loading the module, for example:</p><p>filepp -D<strong>LITERAL_REVERSE</strong> -m literal.pm <em>&lt;files&gt;</em></p><p>This has the effect of only replacing macros which appear in strings.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TOUPPER MODULE - toupper.pm</h2>
        <div class="sectioncontent">
<p>The toupper module converts all lowercase letters to uppercase.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TOLOWER MODULE - tolower.pm</h2>
        <div class="sectioncontent">
<p>The tolower module converts all uppercase letters to lowercase.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">C/C++ COMMENT MODULE - c-comment.pm</h2>
        <div class="sectioncontent">
<p>The c-comment module removes all C style:</p><p><em>/* comment */</em></p><p>and C++ style:</p><p><em>// comment</em></p><p>comments from a file.  C and C++ comments are removed after keywords have been processed.  If you wish to remove C and C++ comments before keywords are processed, define the macro <strong>REMOVE_C_COMMENTS_FIRST</strong> before loading the module, eg:</p><p><strong>filepp -DREMOVE_C_COMMENTS_FIRST -m c-comment.pm</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">HASH COMMENT MODULE - hash-comment.pm</h2>
        <div class="sectioncontent">
<p>The hash-comment module removes all comments of the style:</p><p><em># comment</em></p><p>from a file.  This is the commenting style used by Perl, Bourne Shell, C Shell and many other programs and configuration files.  Hash comments are removed after keywords have been processed.  If you wish to remove hash comments before keywords are processed, define the macro <strong>REMOVE_HASH_COMMENTS_FIRST</strong> before loading the module (Note: if you do this and also use # as the keyword character then the keywords will be removed BEFORE they are processed).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FUNCTION MODULE - function.pm</h2>
        <div class="sectioncontent">
<p>The function module allows the user write macros which call Perl functions. Its file name is <strong>function.pm</strong>.</p><p>The function module allows macros of the form:</p><p><em>macro(arg1, arg2, arg3, ...)</em></p><p>to be added to a file.  When the macro is found, it will run a function from a Perl module, with arguments <em>arg1</em>, <em>arg2</em>, <em>arg3</em>, <em>...</em> passed to the function.  The function must return a string.  The returned string will replace the call to the function in the output.  The function can have any number of arguments.  If the function has no arguments it should be called with an empty argument list:</p><p><em>macro()</em></p><p>If the word <em>macro</em> is found in the input file without being followed by a <em>(</em> it will be ignored.</p><p>To use the function module, the user must provide a Perl function which optionally takes in arguments and returns a string.  The function can either be one of filepp's internal functions or one of the user's own provided in a Perl module.  The function can be added in two ways.  The first way is through the <strong>function</strong> keyword:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>#function</strong> <em>macro</em> <em>function</em></p>
  </dt>
  <dd>
    <p><em>macro</em> is the name of the macro which is used to signify a call to the function in the input file and <em>function</em> is the name of the function to be called.</p>
  </dd>

</dl>
<p>The second method of adding a function is to call the Perl function:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>Function::AddFunction(</strong><em>$macro</em><strong>,</strong><em>$function</em>)</p>
  </dt>
  <dd>
    <p>which has the same inputs as the <strong>function</strong> keyword.</p>
  </dd>

</dl>
<p>Functions can be removed either through the keyword:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>#rmfunction</strong> <em>macro</em></p>
  </dt>
  <dd>
    <p>or through the Perl function</p>
  </dd>
  <dt>
    <p><strong>Function::RemoveFunction(</strong><em>$macro</em><strong>)</strong></p>
  </dt>
  <dd>
    
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MATHS MODULE - maths.pm</h2>
        <div class="sectioncontent">
<p>The module provides a set of macros which perform mathematical operations.  When the macros are encoutered in an input file, they are evaluated and the result is returned in the output.</p><p>The maths module includes the following macros:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>add(a, b, c, ...)</strong></p>
  </dt>
  <dd>
    <p>Takes in any number of arguments and returns their sum: (a + b + c + ...)</p>
  </dd>
  <dt>
    <p><strong>sub(a, b)</strong></p>
  </dt>
  <dd>
    <p>Returns a minus b: (a - b)</p>
  </dd>
  <dt>
    <p><strong>mul(a, b, c, ...)</strong></p>
  </dt>
  <dd>
    <p>Takes in any number of arguments and returns their product: (a * b * c * ...)</p>
  </dd>
  <dt>
    <p><strong>div(a, b)</strong></p>
  </dt>
  <dd>
    <p>Returns a over b: (a / b)</p>
  </dd>
  <dt>
    <p><strong>abs(a)</strong></p>
  </dt>
  <dd>
    <p>Returns the absoulte value of a.</p>
  </dd>
  <dt>
    <p><strong>atan2(a, b)</strong></p>
  </dt>
  <dd>
    <p>Returns the arctangent of a/b in the range -pi to pi.</p>
  </dd>
  <dt>
    <p><strong>cos(a)</strong></p>
  </dt>
  <dd>
    <p>Returns the cosine of a in radians.</p>
  </dd>
  <dt>
    <p><strong>exp(a)</strong></p>
  </dt>
  <dd>
    <p>Returns the e to the power of a.</p>
  </dd>
  <dt>
    <p><strong>int(a)</strong></p>
  </dt>
  <dd>
    <p>Returns the integer portion of a.</p>
  </dd>
  <dt>
    <p><strong>log(a)</strong></p>
  </dt>
  <dd>
    <p>Returns the natural logarithm (base e) of a.</p>
  </dd>
  <dt>
    <p><strong>rand(a)</strong></p>
  </dt>
  <dd>
    <p>Returns a random fractional number between the range 0 and a.  If a is omitted, returns a value between 0 and 1.</p>
  </dd>
  <dt>
    <p><strong>sin(a)</strong></p>
  </dt>
  <dd>
    <p>Returns the sine of a in radians.</p>
  </dd>
  <dt>
    <p><strong>sqrt(a)</strong></p>
  </dt>
  <dd>
    <p>Returns the square root of a.</p>
  </dd>
  <dt>
    <p><strong>srand(a)</strong></p>
  </dt>
  <dd>
    <p>Sets the random number seed for rand().</p>
  </dd>

</dl>
<p>The maths module also defines pi as M_PI as e as M_E.</p><p>The maths macros are implemented using the <strong>function.pm</strong> module. Nested macros are allowed, as is passing other macros with numerical defintions as arguments.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FORMAT MODULE - format.pm</h2>
        <div class="sectioncontent">
<p>This module provides a set of macros for formating strings and numbers.</p><p>The format module provides the following macros:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>printf(format, arg1, arg2, ...)</strong></p>
  </dt>
  <dd>
    <p>The <strong>printf</strong> macro behaves in the same way as the Perl/C function printf.  It takes in a format string followed by a list of arguments to print.  See the <a href="../man3/printf.3.html"><strong>printf</strong>(3)</a> man page or Perl documentation for full details of the <strong>printf</strong> function.</p>
  </dd>
  <dt>
    <p><strong>toupper(string)</strong></p>
  </dt>
  <dd>
    <p>Converts input string to upper case.</p>
  </dd>
  <dt>
    <p><strong>toupperfirst(string)</strong></p>
  </dt>
  <dd>
    <p>Converts first character of input string to upper case.</p>
  </dd>
  <dt>
    <p><strong>tolower(string)</strong></p>
  </dt>
  <dd>
    <p>Converts input string to lower case.</p>
  </dd>
  <dt>
    <p><strong>tolowerfirst(string)</strong></p>
  </dt>
  <dd>
    <p>Converts first character of input string to lower case.</p>
  </dd>
  <dt>
    <p><strong>substr(string, offset, length)</strong></p>
  </dt>
  <dd>
    <p>Extracts a substring from input <em>string</em>.  <strong>substr</strong> behaves in the same way as the Perl substr function.  <em>offset</em> is used to specifiy the first character of the string to output (negative for offset from end of string), <em>length</em> is the length of the string to output.  If length is omitted everything from the offset is returned.  For further information on <strong>substr</strong> see the Perl documentation.</p>
  </dd>

</dl>
<p>The format macros are implemented using the <strong>function.pm</strong> module.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BIGDEF MODULE - bigdef.pm</h2>
        <div class="sectioncontent">
<p>The bigdef module allows easy definition of multi-line macros. Its file name is <strong>bigdef.pm</strong>.</p><p>A multi-line macro is a macro which has a definition which spans more than one line.  The normal way to define these is to place a line continuation character at the end of each line in the definition. However, this can be annoying and unreadable for large multi-line macros.  The bigdef module tries to improve on this by providing two keywords:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>#bigdef</strong> <em>macro</em> <em>definition...</em></p>
  </dt>
  <dd>
    <p>The <strong>#bigdef</strong> keyword has the same syntax as <strong>#define</strong>, the only difference being the macro definition is everything following the macro name including all following lines up to the next <strong>#endbigdef</strong> keyword.</p>
  </dd>
  <dt>
    <p><strong>#endbigdef</strong></p>
  </dt>
  <dd>
    <p>Ends a bigdef.  Everything between this keyword and the last preceding <strong>#bigdef</strong> is included in the macro.</p>
  </dd>

</dl>
<p>Any keywords found in the definition will be evaluated as normal AT THE TIME THE MACRO IS DEFINED and any output from these will be included in the definition.</p><p>Note: The difference between bigfunc and bigdef is the time keywords in the definition are evaluated.  Bigdef evaluates them as the macro is DEFINED, bigfunc evaluates them whenever the macro is REPLACED.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BIGFUNC MODULE - bigfunc.pm</h2>
        <div class="sectioncontent">
<p>The bigfunc module allows easy definition of multi-line macros. Its file name is <strong>bigfunc.pm</strong>.</p><p>A multi-line macro is a macro which has a definition which spans more than one line.  The normal way to define these is to place a line continuation character at the end of each line in the definition. However, this can be annoying and unreadable for large multi-line macros.  The bigfunc module tries to improve on this by providing two keywords:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>#bigfunc</strong> <em>macro</em> <em>definition...</em></p>
  </dt>
  <dd>
    <p>The <strong>#bigfunc</strong> keyword has the same syntax as <strong>#define</strong>, the only difference being the macro definition is everything following the macro name including all following lines up to the next <strong>#endbigfunc</strong> keyword.</p>
  </dd>
  <dt>
    <p><strong>#endbigfunc</strong></p>
  </dt>
  <dd>
    <p>Ends a bigfunc.  Everything between this keyword and the last preceding <strong>#bigfunc</strong> is included in the macro.</p>
  </dd>

</dl>
<p>Any keywords found in the definition will be evaluated as normal AT THE TIME THE MACRO IS REPLACED and any output from these will be included in the definition.</p><p>Note: The difference between bigfunc and bigdef is the time keywords in the definition are evaluated.  Bigdef evaluates them as the macro is DEFINED, bigfunc evaluates them whenever the macro is REPLACED.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DEFPLUS MODULE - defplus.pm</h2>
        <div class="sectioncontent">
<p>The defplus module allows extra information to be appended to an existing macro. Its file name is <strong>defplus.pm</strong>.</p><p>The defplus module allows further things to be appended to existing macros. The module implements one keyword:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>#defplus</strong> <em>macro</em> <em>definition...</em></p>
  </dt>
  <dd>
    <p>The <strong>#defplus</strong> keyword has the same syntax as <strong>#define</strong>, the only difference being if the macro is already defined then <em>definition</em> is appended to the existing definition of the macro. If the macro is undefined then <strong>#defplus</strong> behaves in exactly the same way as <strong>#define</strong>.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REGEXP MODULE - regexp.pm</h2>
        <div class="sectioncontent">
<p>The regexp module allows Perl regular expression replacement to be done with filepp. Its file name is <strong>regexp.pm</strong>.</p><p>Perl regular expression replacement allows a regular expression to be searched for and replaced with something else.  Regular expressions are defined as follows:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>#regexp</strong> /<em>regexp</em>/<em>replacement</em>/</p>
  </dt>
  <dd>
    <p>It is very similar to the Perl syntax and the following Perl code will be executed on each line of the input file:</p>
  </dd>
  <dt>
    <p><strong>$line</strong> =~ s/<em>regexp</em>/<em>replacement</em>/g</p>
  </dt>
  <dd>
    <p>For users who don't understand Perl, this means replace all occurrences of <em>regexp</em> in the current line with <em>replacement</em>.</p>
  </dd>

</dl>
<p>A full description of regular expressions and possible replacements is beyond the scope of this man page.  More information can be found in the Perl documentation using the command:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>perldoc</strong> <strong>perlre</strong></p>
  </dt>
  <dd>
    
  </dd>

</dl>
<p>Any number of regular expressions can be defined.  Each regular expression is evaluated once for each line of the input file.  Regular expressions are evaluated in the order they are defined.</p><p>Regular expressions can be undefined in the following way:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>#rmregexp</strong> /<em>regexp</em>/<em>replacement</em>/</p>
  </dt>
  <dd>
    <p>This will remove the specified regular expression.</p>
  </dd>

</dl>
<p>In debugging mode the current list of regular expressions can be viewed using the pragma keyword:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>#pragma</strong> <strong>filepp</strong> <em>ShowRegexp</em></p>
  </dt>
  <dd>
    <p>When not in debugging mode, this will produce no output.</p>
  </dd>

</dl>
<p>A single regular expression can also be defined on the command line using the <em>REGEXP</em> macro, for example:</p><p>filepp -D<em>REGEXP</em>=/<em>regexp</em>/<em>replacement</em>/ -m regexp.pm inputfile</p><p>Note: the <em>REGEXP</em> macro must be defined BEFORE the regexp module is loaded, putting -D<em>REGEXP</em>... after -m regexp.pm will not work. When using the command line approach, if the <em>REGEXP</em> macro is successfully parsed as a regular expression it will be undefined from the normal filepp macro list before processing starts.  Care should obviously be taken when escaping special characters in the shell with command line regexps.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BLC MODULE - blc.pm</h2>
        <div class="sectioncontent">
<p>The Bracket Line Continuation module causes lines to be continued if they have more open brackets: "(" than close brackets: ")" on a line. The line will be continued until an equal number of open and close brackets are found.</p><p>Brackets can be prevented from being counted for line continuation by escaping them with a backslash: "&#92;(" and "&#92;)".  Any brackets found with a preceding backslash will be ignored when deciding if line continuation should be done and then have the backslash removed once the full line has been found.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">C MACROS MODULE - cmacros.pm</h2>
        <div class="sectioncontent">
<p>The cmacros module causes the definition of the following predefined macros to be quoted: <strong>DATE, TIME, VERSION, BASE_FILE, FILE,</strong> (note: predefined macros are written as __MACRO__).</p><p>This makes the macros more "C" like, as the C preprocessor also puts quotes around these macros.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">C MACROS MODULE - cpp.pm</h2>
        <div class="sectioncontent">
<p>The cpp makes filepp behave in a similar manner to a C preprocessor <strong>cpp</strong>(1).</p><p>DISCLAIMER: filepp is not meant to be a drop in replacement for a C preprocessor even with this module.  I would not recommend using filepp as a C preprocessor unless you fully understand how it differs from a real C preprocessor.  The output from filepp with the cpp module will not be the same as a real C preprocessor.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">GRAB MODULE - grab.pm</h2>
        <div class="sectioncontent">
<p>The grab module is used to grab input before processing. Its file name is <strong>grab.pm</strong>.</p><p>The grab module is mainly for use in other modules, such as for.pm and bigfunc.pm.  It grabs all input from a file before any processing is done on it.  This allows other modules to do processing on the original input data before the main processing is done.  For example, the for module will store the original input inside a loop and re-use it each time the loop is processed.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>#grab</strong> <em>macro</em> <em>definition...</em></p>
  </dt>
  <dd>
    <p>The grab module will start grabbing of all input from the grab keyword, onwards.</p>
  </dd>
  <dt>
    <p><strong>#endgrab</strong></p>
  </dt>
  <dd>
    <p>Ends a grab.  Everything between this keyword and the last preceding <strong>#grab</strong> will be grabbed and stored for use in other modules.</p>
  </dd>

</dl>
<p>Grabs can be nested if required.</p><p>When calling grab from another module, use the following functions:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>Grab::StartGrab(</strong><em>$startkeyword</em><strong>,</strong><em>$endkeyword</em>)</p>
  </dt>
  <dd>
    <p><em>$startkeyword</em> is the keyword that StartGrab is called from. <em>$endkeyword</em> is the keyword that grabbing should stop at.</p>
  </dd>
  <dt>
    <p><strong></strong><em>@List</em><strong></strong>=<strong>Grab::GetInput()</strong></p>
  </dt>
  <dd>
    <p>Returns a Perl list containing all input grabbed from when grab was last run.</p>
  </dd>
  <dt>
    <p><strong></strong><em>$line</em><strong></strong>=<strong>Grab::GetInputLine()</strong></p>
  </dt>
  <dd>
    <p>Returns the line number of the input file where grabbing last started.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILEPP MODULE API</h2>
        <div class="sectioncontent">
<p>The behaviour of <strong>filepp</strong> can be modified or extended through the use of modules.  <strong>filepp</strong> modules are in fact <strong>perl</strong>(1) modules, and the rest of this section assumes the reader has a knowledge of Perl.</p><p><strong>filepp</strong> modules are <strong>perl</strong>(1) modules which extend or modify <strong>filepp</strong>'s behaviour by either calling or replacing <strong>filepp</strong>'s internal functions. <strong>filepp</strong> has the Perl package name <strong>Filepp</strong> so its internal functions can be called within modules either as <strong>Filepp::function()</strong> or just <strong>function()</strong>.  Any of <strong>filepp</strong>'s internal functions can be called or replaced from within a <strong>filepp</strong> module, the most useful ones are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>Debug(</strong><em>$string</em><strong>,</strong><em>$number</em>)</p>
  </dt>
  <dd>
    <p>Print <em>$string</em> as debugging information if debugging is enabled.  <em>$number</em> is optional and can be used to set the debugging level at which <em>$string</em> should be printed, lower numbers being higher priority.  Command line option <strong>d</strong> prints all debugging info for 2 and below, option <strong>dd</strong> prints all debugging information for 3 and below and option <strong>dl</strong> prints all debugging information for 1 and below.  If <em>$number</em> is not provided, defaults to 1.</p>
  </dd>
  <dt>
    <p><strong>AddProcessor(</strong><em>$function</em><strong>,</strong><em>$pos</em>,<strong></strong><em>$type</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>Allows the module to add a function named <em>$function</em> to <strong>filepp</strong>'s processing chain.  The processing chain is a set of functions which are run on each line of a file as it is processed.  The default functions in the processing chain are <strong>ParseKeywords</strong> which does keyword parsing and <strong>ReplaceDefines</strong> which does macro replacement. Further functions can be added to the chain, with each function taking a string (the current line) as input and returning the processed string as output.</p><p>By default, or if <em>$pos</em> is set to 0, the processor is added to the end of the processing chain.  If <em>$pos</em> is set to 1 the processor is added to the start of the processing chain.</p><p><em>$type</em> controls what the processor is run on.  There are three options for this, 0 (default): the processor runs on everything passed to the processing chain; 1: the processor runs on full lines only; 2: the processor runs on part lines only (a part line is the text following a keyword such as <strong>if</strong> which needs to be parsed for macros).</p><p>Both <em>$pos</em> and <em>$type</em> are optional parameters.</p>
  </dd>
  <dt>
    <p><strong>AddProcessorAfter(</strong><em>$function</em><strong>,</strong><em>$existing</em>,<strong></strong><em>$type</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>Adds function <em>$function</em> to the processing chain directly after existing processor <em>$existing</em>.  If <em>$existing</em> is not found then <em>$function</em> is added to the end of the processing chain.  Regular expression matching is used to compare <em>$existing</em> with the names of the functions in the processing chain.</p><p><em>$type</em> is optional.</p>
  </dd>
  <dt>
    <p><strong>AddProcessorBefore(</strong><em>$function</em><strong>,</strong><em>$existing</em>,<strong></strong><em>$type</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>Adds function <em>$function</em> to the processing chain directly before existing processor <em>$existing</em>.  If <em>$existing</em> is not found then <em>$function</em> is added to the start of the processing chain.  Regular expression matching is used to compare <em>$existing</em> with the names of the functions in the processing chain.</p><p><em>$type</em> is optional.</p>
  </dd>
  <dt>
    <p><strong>RemoveProcessor(</strong><em>$function</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>Removes the processor function <em>$function</em> from the processing chain.</p>
  </dd>
  <dt>
    <p><strong></strong><em>$string</em><strong></strong>=<strong>ReplaceDefines(</strong><em>$string</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>Replaces all macros in <em>$string</em> with their definitions and returns the processed string.</p>
  </dd>
  <dt>
    <p><strong>AddKeyword(</strong><em>$string</em><strong>,</strong><em>$function</em>)</p>
  </dt>
  <dd>
    <p>Add the keyword named <em>$string</em>.  When the keyword is found in text processing the function named <em>$function</em> will be run with everything following the keyword passed as a single argument.</p>
  </dd>
  <dt>
    <p><strong>RemoveKeyword(</strong><em>$string</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>Removes the keyword named <em>$string</em>.</p>
  </dd>
  <dt>
    <p><strong>RemoveAllKeywords()</strong></p>
  </dt>
  <dd>
    <p>Removes all the keywords currently defined for <strong>filepp</strong> (used for the -k command line option).</p>
  </dd>
  <dt>
    <p><strong>AddIfword(</strong><em>$string</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>Adds keyword named <em>$string</em> to Ifword list.  An Ifword takes in the string following the keyword and optionally parses it, returning a 1 if the string parses to true and 0 for false.  The default Ifwords are <strong>if</strong>, <strong>ifdef</strong> and <strong>ifndef</strong>.</p>
  </dd>
  <dt>
    <p><strong>RemoveIfword(</strong><em>$string</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>Removes keyword named <em>$string</em> from Ifword list (note: this does NOT remove the keyword, use <strong>RemoveKeyword</strong> for that).</p>
  </dd>
  <dt>
    <p><strong>AddElseword(</strong><em>$string</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>Adds keyword named <em>$string</em> to Elseword list.  An Elseword takes in the string following the keyword and optionally parses it, returning a 1 if the string parses to true and 0 for false.  The default Elsewords are <strong>else</strong> and <strong>elif</strong>.</p>
  </dd>
  <dt>
    <p><strong>RemoveElseword(</strong><em>$string</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>Removes keyword named <em>$string</em> from Elseword list.</p>
  </dd>
  <dt>
    <p><strong>AddEndifword(</strong><em>$string</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>Adds keyword named <em>$string</em> to Endifword list.  An Endifword should return a 1 to indicate successful termination of the if block.  If the Endifword returns 0 the Endifword is ignored and filepp assumes the current if block carries on after the Endifword.  The default Endifword is <strong>endif</strong>.</p>
  </dd>
  <dt>
    <p><strong>RemoveEndifword(</strong><em>$string</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>Removes keyword named <em>$string</em> from Endifword list.</p>
  </dd>
  <dt>
    <p><strong>AddIncludePath(</strong><em>$string</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>Adds the include path <em>$string</em> to the list of directories to search for include files (used for the -I command line option).</p>
  </dd>
  <dt>
    <p><strong>AddModulePath(</strong><em>$string</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>Adds the path <em>$string</em> to the list of directories to search for filepp modules (used for the -M command line option).</p>
  </dd>
  <dt>
    <p><strong>AddOpenInputFunc(</strong><em>$function</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>Adds a <em>$function</em> to a list of functions to be run each time a new base input file is opened.</p>
  </dd>
  <dt>
    <p><strong>AddCloseInputFunc(</strong><em>$function</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>Adds a <em>$function</em> to a list of functions to be run each time a new base input file is closed.</p>
  </dd>
  <dt>
    <p><strong>AddOpenOutputFunc(</strong><em>$function</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>Adds a <em>$function</em> to a list of functions to be run each time an output file is opened.</p>
  </dd>
  <dt>
    <p><strong>AddCloseOutputFunc(</strong><em>$function</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>Adds a <em>$function</em> to a list of functions to be run each time an output file is closed.</p>
  </dd>
  <dt>
    <p><strong>AddInputFile(</strong><em>$string</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>Adds another input file to the list of files to be processed (used for adding input files at the command line).</p>
  </dd>
  <dt>
    <p><strong>ChangeOutputFile(</strong><em>$string</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>Closes the current output file and attempts to open a new one named <em>$string</em>.</p>
  </dd>
  <dt>
    <p><strong>SetKeywordchar(</strong><em>$string</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>Set the initial keyword char to <em>$string</em> (used for the -kc command line option).</p>
  </dd>
  <dt>
    <p><strong>SetContchar(</strong><em>$string</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>Set the line continuation char to <em>$string</em> (used for the -lc command line option).</p>
  </dd>
  <dt>
    <p><strong>SetContrepchar(</strong><em>$string</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>Set the line continuation replacement char to <em>$string</em> (used for the -lr command line option).</p>
  </dd>
  <dt>
    <p><strong>SetOptLineEndchar(</strong><em>$string</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>Set the optional keyword line end character to <em>$string</em> (used for the -lec command line option).</p>
  </dd>
  <dt>
    <p><strong>SetBlankSupp(1/0)</strong></p>
  </dt>
  <dd>
    <p>Turns blank-line suppression on/off (1 = suppress, 0 = don't suppress).  When blank-line suppression is on, blank lines in input files will not be copied to the output.  Unlike the corresponding command-line option (-b), this function can also have effect in the top-level file.  The setting of blank-line suppression applies to the current file being processed and all files included in the current file.</p>
  </dd>
  <dt>
    <p><strong>ResetBlankSupp()</strong></p>
  </dt>
  <dd>
    <p>Resets blank-line suppression to the command-line specified value. This only affects the output of blank lines from the current file being processed and all files included in the current file.  In the top-level file, this always turns blank-line suppression off.</p>
  </dd>
  <dt>
    <p><strong>SetEatTrail(</strong><em>$string</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>If <em>$string</em> is a macro, whenever the macro is replaced all blank space between the macro's replacement and the next character on the line will be eaten.  For example, if macro <em>foo</em> is defined to <em>bar</em> and <em>foo</em> has been set to have it's trail eaten, the following:</p><p> eat my foo trail</p><p>is replaced with</p><p> eat my bartrail</p>
  </dd>
  <dt>
    <p><strong>CheckEatTrail(</strong><em>$string</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>Returns 1 if macro <em>$string</em> will have it's tail eaten, 0 otherwise.</p>
  </dd>
  <dt>
    <p><strong>SetEnvchar(</strong><em>$string</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>Set the prefix of environment variables converted to macros (<strong>envchar</strong>) to <em>$string</em> (used for -ec and -ecn command line options).</p>
  </dd>
  <dt>
    <p><strong>DefineEnv()</strong></p>
  </dt>
  <dd>
    <p>Define all environment variables as macros with prefix <strong>envchar</strong> (used for -e command line option).</p>
  </dd>
  <dt>
    <p><strong>SetOutput(1/0)</strong></p>
  </dt>
  <dd>
    <p>Turns writing of parsed input file to output file on/off.  This takes either 1 (output on) or 0 (output off) as input.  When the output is turned off, the only output produced from <strong>filepp</strong> will be that generated by modules.</p>
  </dd>
  <dt>
    <p><strong>SetWordBoundaries(1/0)</strong></p>
  </dt>
  <dd>
    <p>Turns on(1) or <strong>off</strong>(0) word boundary checking when replacing macros (used for the -w command line option).</p>
  </dd>
  <dt>
    <p><strong>SetCharPerlre(1/0)</strong></p>
  </dt>
  <dd>
    <p>Turns on(1) or <strong>off</strong>(0) allowing of keyword prefix char and line continuation char to be Perl regular expressions (used for the -re command line option).</p>
  </dd>
  <dt>
    <p><strong>UndefAll()</strong></p>
  </dt>
  <dd>
    <p>Undefines all currently defined macros, including predefined ones (used for the -u command line option).</p>
  </dd>
  <dt>
    <p><strong>UseModule(</strong><em>$string</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>Loads a <strong>perl</strong>(1) module named <em>$string</em> using the Perl command <strong>require</strong> (used for the -m command line option).</p>
  </dd>
  <dt>
    <p><strong>SetParseLineEnd(</strong><em>$function</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>Sets the function to determine if line continuation should be done on current line to <em>$function</em>.</p>
  </dd>
  <dt>
    <p><strong></strong><em>$string</em><strong></strong>=<strong>GetNextLine()</strong></p>
  </dt>
  <dd>
    <p>Returns the next line (after line continuation has been dealt with) of the input file currently being processed.  Returns NULL for end of file.</p>
  </dd>
  <dt>
    <p><strong>Write(</strong><em>$string</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>Writes <em>$string</em> to the current output file.</p>
  </dd>
  <dt>
    <p><strong>Output(</strong><em>$string</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>Conditionally writes <em>$string</em> to the current output file.  If output is turned on then writes <em>$string</em>.  Output is toggled off/on using SetOutput function.</p>
  </dd>

</dl>
<p>In addition all the standard <strong>filepp</strong> keywords have equivalent functions which optionally take a single argument.  The functions have the same name as the keyword, only with a capital first letter (eg: <strong>#define</strong> <em>string</em> calls the function <strong>Define(</strong><em>string</em><strong>)</strong>).</p><p>A full description of the <strong>Parse</strong> function and all the other <strong>filepp</strong> internal functions is beyond the scope of this man page.  The <strong>filepp</strong> script is well commented and hopefully readable by a Perl programmer, so use the source Luke!</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p><strong>filepp</strong> has no known bugs, only "features".  If you find any "features", please report them to the author.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYING</h2>
        <div class="sectioncontent">
<p>Copyright (C) 2000-2007 Darren Miller</p><p><strong>filepp</strong> is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.</p><p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.</p><p>You should have received a copy of the GNU General Public License along with this program; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO filepp&hellip;</h2>
        <div class="sectioncontent">
<p><strong></strong><strong>cpp</strong><strong>(1),</strong> <strong></strong><strong>perl</strong><strong>(1)</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Darren Miller &lt;darren@cabaret.demon.co.uk&gt;.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="filename.1.html"><span aria-hidden="true">&larr;</span> filename.1: Ame</a></li>
   <li class="next"><a href="fileroot.1.html">fileroot.1: Ame <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>nexp: A framework for crafting network packets and processing responses</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="A framework for crafting network packets and processing responses">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="nexp (1) manual">
  <meta name="twitter:description" content="A framework for crafting network packets and processing responses">
  <meta name="twitter:image" content="https://www.carta.tech/images/netexpect-nexp-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/nexp.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="nexp (1) manual" />
  <meta property="og:description" content="A framework for crafting network packets and processing responses" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/netexpect-nexp-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">nexp<small> (1)</small></h1>
        <p class="lead">A framework for crafting network packets and processing responses</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/nexp.1.html">
      <span itemprop="name">nexp: A framework for crafting network packets and processing responses</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/netexpect/">
      <span itemprop="name">netexpect</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/nexp.1.html">
      <span itemprop="name">nexp: A framework for crafting network packets and processing responses</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>nexp</strong> [<strong>-V</strong>] [<strong>-v</strong>] [<strong>-t</strong>] [<strong>-c</strong>&nbsp;<em>cmd</em>] [<strong>-s</strong>&nbsp;<em>seed</em>] [<strong>-h</strong>] [<em>cmdfile</em>] [<em>args</em>]</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INTRODUCTION</h2>
        <div class="sectioncontent">
<p><strong>Network Expect</strong> (<strong>nexp</strong>) is a framework that allows to easily build tools that can interact with network traffic. Following a script, traffic can be injected into the network, and decisions can be taken, and acted upon, based on received network traffic. An interpreted language provides branching and high-level control structures to direct the interaction with the network.</p><p><strong>Network Expect</strong> was heavily influenced and inspired on the Expect program written by Don Libes, which allows to "talk" to interactive programs in a scripted fashion. Because of this, you will find a lot of similarities between commands in <strong>Network Expect</strong> and commands in Don Libes&apos; Expect. If you are a regular Expect user, it should not be very difficult to start writing <strong>Network Expect</strong> scripts because the basics are the same.</p><p>In Don Libes&apos; Expect, scripts can send data to a process just as if a user were interactively typing commands. Then, the script would read the responses sent by the application and take decisions accordingly. In <strong>Network Expect</strong>&apos;s case, a script could send traffic to a network device and then take decisions based on the received network traffic. The type of things that <strong>Network Expect</strong> can do are usually very low level network operations, which usually require writing a custom application in a language like C.</p><p><strong>Network Expect</strong>&apos;s philosophy is based on the observation that network applications always operate on an action-reaction principle in which something is sent to an application running on a remote host and a response is then expected.</p><p>Some of the things that <strong>Network Expect</strong> can do include:</p><p>Generate arbitrary network traffic and inject it into a network at layer 2 or layer 3.</p><p>A wide range of protocols is supported, including IP version 6 as well as protocol options like IPv4, IPv6 and TCP options, something that other tools may not offer. For example, <strong>Network Expect</strong> supports TCP MD5 signatures (RFC 2385).</p><p>This <strong>Network Expect</strong> functionality is very similar to the functionality provided by several packet crafting and forging open source tools like Nemesis, Packit, hping, Scapy, and others.</p><p>Listen for network traffic and take decisions based on the type of traffic received.</p><p>Open a sniffer trace in PCAP format and replay it after changing some values in the original packet capture.</p><p>Emulate network protocols to see how they interact with other speakers of that protocol. For example, emulating a TCP server to investigate approaches to randomization of TCP Initial Sequence Numbers (ISN) can be easily done in <strong>Network Expect</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">USAGE</h2>
        <div class="sectioncontent">
<p><strong>Network Expect</strong> reads cmdfile for a list of commands to execute. <strong>Network Expect</strong> may also be invoked implicitly on systems which support the #! notation by marking the script executable, and making the first line in your script:</p>
<pre>
#!/usr/bin/nexp -f
</pre>
<p>Of course, the path must accurately describe where <strong>Network Expect</strong> lives; /usr/bin is just an example.</p><p>The <strong>-c</strong> flag prefaces a command to be executed before any in the script. The command should be quoted to prevent being broken up by the shell. This option may be used multiple times. Multiple commands may be executed with a single <strong>-c</strong> by separating them with semicolons. Commands are executed in the order they appear.</p><p><strong>-V</strong> causes <strong>Network Expect</strong> to print its version number and exit.</p><p>The <strong>-s</strong> flag allows to specify a random seed that will cause predicatibility of pseudo-random numbers generated by <strong>Network Expect</strong> during execution of a script. In cases where <strong>Network Expect</strong> is used as a protocol fuzzer, this option is useful to be able to re-generate a specific test case.</p><p><strong>-v</strong> increases the verbosity level. Some commands display additional information when the verbosity level is higher.</p><p>The <strong>-t</strong> flag changes the display format used by commands that display dates or generate strings that represent dates.</p><p>Optional arguments are constructed into a list and stored in the variable named argv. argc is initialized to the length of argv.</p><p>argv0 is defined to be the name of the script (or binary if no script is used). For example, the following prints out the name of the script and the first three arguments:</p>
<pre>
puts "$argv0 [lrange $argv 0 2]"
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NETWORK LISTENERS AND SPEAKERS</h2>
        <div class="sectioncontent">
<p>An integral part of <strong>Network Expect</strong> is the concept of network <em>listeners</em> and network <em>speakers</em>, which are the <strong>Network Expect</strong> equivalent to spawned processes in Don Libes&apos; <strong>Expect</strong> world. In <strong>Expect</strong>, the <strong>send</strong> command sends data to a spawned process, and the <strong>expect</strong> command waits for a specific pattern in the data received from a spawned process.</p><p>In <strong>Network Expect</strong>, the command to send data to the network, called <strong>send_network</strong>, uses a <em>speaker</em> that specifies how the traffic will be injected. <strong>Network Expect</strong> speakers can specify IPv4 or IPv6 sockets, in which case packets will be injected at layer 3 and will be routed by the operating system kernel. <strong>Network Expect</strong> speakers can also specify a physical interface, in which case the packet will be injected at layer 2. A network speaker can also be a PCAP file (also known as a "savefile"), in which case packets will be written to this file instead of injected to the network. Other network speaker types include TCP and UDP sockets, in which case the payload generated by the <strong>send_network</strong> is transported by TCP segments or UDP datagrams built by the operating system kernel.</p><p><strong>Network Expect</strong> listeners, on the other hand, specify where packets will be read from. Listeners can be associated with either a physical interface, or with a PCAP file. In either case an optional PCAP filter and/or Wireshark display filter can be associated with the listener to limit the type of packets the listener will return. When reading from a PCAP file the inter-packet delay between packets can be kept, or packets can be read at full speed.</p><p>Both listeners and speakers are created with the <strong>Network Expect</strong> command <strong>spawn_network</strong>, just as in Don Libes&apos; <strong>Expect</strong> spawned processes are created with the <strong>spawn</strong> command.</p><p>The way to specify network listeners and speakers in commands that require them is the same regardless of the command. Network listeners are always specified using the <em>-i</em> switch (think <em>i</em>nput) followed by the name of the listener, and network speakers are specified using the <em>-o</em> switch (think <em>o</em>utput) followed by the name of the speaker.</p><p>Network isteners and speakers are created using the <strong>spawn_network</strong> command. Just as in Don Libes&apos; <strong>Expect</strong> one cannot choose the spawn ID returned by the <strong>spawn</strong> command, in <strong>Network Expect</strong> it is not possible to choose the name of a network listener or speaker. However, one can assign the network listener or speaker name to a variable and use that variable whenever a network listener or speaker needs to be specified.</p><p>What follows are a few examples of creation of network listeners and speakers:</p>
<pre>
spawn_network -i eth1 icmp and src host 172.16.1.1
</pre>
<p>This command creates a network listener on interface eth1 and assigns the filter "icmp and src host 172.16.1.1", i.e. "listen only for ICMP messages coming from host 172.16.1.1". Since the <em>-o</em> switch has not been specified this command will not create a network speaker.</p>
<pre>
spawn_network -o eth0 -r /tmp/packets.pcap tcp and host 172.16.1.1
</pre>
<p>This command creates a network speaker on interface eth0 and a network listener that will read from the PCAP file "/tmp/packets.pcap" TCP segments to or from the host 172.16.1.1.</p>
<pre>
spawn_network -nolistener -6
</pre>
<p>This will create a network speaker for injecting IPv6 packets at layer 3. Since the <em>-nolistener</em> switch has been specified, this command only creates a network speaker and no listener.</p>
<pre>
spawn_network -nolistener -w /tmp/mypackets.pcap
</pre>
<p>This only creates a speaker that will write packets to the PCAP file "/tmp/mypackets.pcap". Note that when writing packets to a PCAP file, injection implicitley takes place at layer 2, and using an Ethernet header. This must be taken into consideration when specifying the packet to send using the <strong>send_network</strong> command.</p><p><strong>Network Expect</strong> listeners and speakers play a very important role in the operation of <strong>Network Expect</strong> so becoming confortable with them is key to understanding <strong>Network Expect</strong>&apos;s philosophy.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NUMERIC SPECIFICATIONS</h2>
        <div class="sectioncontent">
<p>When defining packets, <strong>Network Expect</strong> allows to specify values for most fields in protocol headers using a syntax that gives great flexibility. This syntax allows to make the value of a field <em>change</em> with each packet that is generated. The syntax is better presented with an example. Suppose that we have an hypothetical protocol field called <em>port</em> that is used to specify a numeric value at packet generation time. The following numeric specifications can be used to specify the actual value</p><p><em>port = &apos;telnet&apos;</em> (fixed): the generated value will always be 23, telnet&apos;s port number.</p><p><em>port = 23</em> (fixed): the generated value will always be 23.</p><p><em>port = 23++</em> (increment): the generated value will be 23 initially, and will be incremented by one with each successive packet.</p><p><em>port = 23--</em> (increment): the generated value will be 23 initially, and will be decremented by one with each successive packet.</p><p><em>port = 23+=5</em> (decrement): the generated value will be 23 initially, and will be incremented by 5 with each successive packet.</p><p><em>port = 23-=5</em> (decrement): the generated value will be 23 initially, and will be decremented by 5 with each successive packet.</p><p><em>port = 23..25</em> (range): the generated value will start with 23, will be incremented by one until it reaches 25, and then will go back to 23.</p><p><em>port = 25..23</em> (range): the generated value will start with 25, will be decremented by one until it reaches 23, and then will go back to 25.</p><p><em>port = &apos;random&apos;</em>: the generated value will be a random number in each successive packet.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COMMANDS</h2>
        <div class="sectioncontent">
<p><strong>Network Expect</strong> uses Tcl (Tool Command Language). Tcl provides control flow (e.g., if, for, break), expression evaluation and several other features such as recursion, procedure definition, etc. Commands used here but not defined (e.g., set, if, exec) are Tcl commands (see <strong>tcl</strong>(3)). <strong>Network Expect</strong> introduces additional commands, described below. Unless otherwise specified, commands return the empty string.</p><p>Commands are listed alphabetically so that they can be quickly located. However, new users may find it easier to start by reading the descriptions of <strong>spawn_network</strong>, <strong>send_network</strong>, <strong>expect_network</strong>, and <strong>send_expect</strong>, in that order.</p><p><strong>barray</strong> <em>new | length | delete | examine | dump | slice | cmp | string &lt;args&gt;</em></p><p>The <strong>barray</strong> command is used to perform management of variables of type <em>barray</em> (byte array.)</p><p><strong>barray new &lt;payload spec&gt;</strong> will create and return a new <em>barray</em> variable.</p><p><strong>barray length &lt;barray variable&gt;</strong> will return the number of bytes that the barray variable uses.</p><p><strong>barray delete &lt;barray variable&gt;</strong> will delete a <em>barray</em> variable.</p><p><strong>barray examine &lt;barray variable&gt; [/&lt;FMT&gt;] [&lt;offset&gt;]</strong> allows to inspect the contents of the specified <em>barray</em> variable, starting at the optional <strong>offset</strong>, and using the format optionally specified with <strong>/FMT</strong>. <strong>/FMT</strong> can include an optional count followed by the display format, &apos;&lt;&apos; or &apos;&gt;&apos; to specify little endian or big endian, and the size of each element to display. Display formats are strings (&apos;s&apos;), octal (&apos;o&apos;), hexadecimal (&apos;x&apos;), signed decimal (&apos;d&apos;), and unsigned decimal (&apos;u&apos;). Sizes are byte (&apos;b&apos;), half-word (&apos;h&apos;), and word (&apos;w&apos;).</p><p><strong>barray dump &lt;barray variable&gt;</strong> produces a hexadecimal dump of the specified <em>barray</em> variable.</p><p><strong>barray slice &lt;barray variable&gt; &lt;slice spec&gt;</strong> returns a slice of the specified <em>barray</em> variable. <strong>slice spec</strong> must be in the format &lt;[start]:[end]&gt; where <strong>start</strong> and <strong>end</strong> are offset into the <em>barray</em> variable. If <strong>start</strong> is ommited the start offset is 0, and if <strong>end</strong> is ommited the end offset is the end of the <em>barray</em> variable.</p><p><strong>barray cmp &lt;barray variable 1&gt; &lt;barray variable 2&gt;</strong> compares two <em>barray</em> variables and returns an integer less than, equal to, or greater than zero if the first <strong>n</strong> bytes of <em>barray variable 1</em> are found, respectively, to be less than, to match, or be greater than the first <strong>n</strong> bytes of <em>barray variable 2</em>. <strong>n</strong> is calculated to be the minimum of the lengths of both <em>barray</em> variables.</p><p><strong>close_network</strong> <em>&lt;listener/speaker name&gt;</em></p><p>This command closes the network listener and/or speaker referenced by <em>&lt;listener/speaker name&gt;</em>. Closing a network listener is not a very important thing to do since the operation just releases system resources used by the listener. However, closing a network speaker is a very important, especially when the speaker is associated with a PCAP file since closing the speaker closes the associated PCAP file.</p><p><strong>expect_network</strong> <em>[-timeout &lt;timeout&gt;]</em> <em>[-i &lt;listener ID&gt;] {condition1} {body1}</em> ... <em>[-i &lt;listener ID&gt;] {conditionN} {bodyN}</em></p><p>The <strong>expect_network</strong> command waits for network traffic from one or more network listeners (specified with the <strong>-i</strong> option) until a condition evaluates to true, until a specified time period has passed, or until an end-of-file is seen (when the listener is associated with a PCAP file.)</p><p>Conditions from the most recent <strong>expect_network_before</strong> command are implicitly used before any other conditions. Conditions from the most recent <strong>expect_network_after</strong> command are implicitly used after any other conditions.</p><p>Conditions are regular Tcl expressions, and bodies are sets of Tcl commands. If the final body is empty, it may be omitted.</p><p>If the arguments to the entire <strong>expect_network</strong> statement require more than one line, all the arguments may be "braced" into one so as to avoid terminating each line with a backslash. In this one case, the usual Tcl substitutions will occur despite the braces.</p><p>If a condition is the keyword <em>eof</em>, the corresponding body is executed upon end-of-file (this is only meaningful when a listener is reading from a PCAP file, not on a live capture from an interface.) If a condition is the keyword <em>timeout</em>, the corresponding body is executed upon timeout. If no <em>timeout</em> keyword is used, an implicit null action is executed upon timeout. The default timeout period is 0.5 seconds but may be set, for example to 30, by the command "set timeout 30". An infinite timeout may be designated by the value -1.</p><p>If a condition is true, then the corresponding body is executed. <strong>expect_network</strong> returns the result of the body (or the empty string if no condition was true.) In the event that multiple conditions match, the one appearing first is used to select a body.</p><p>Each time a new packet arrives, it is decoded and the conditions are evaluated in the order they are listed. When a packet is decoded, the values of the different fields in the packet are made available to Tcl scripts via Tcl variables. Scripts can use these values in an condition for a <strong>expect_network</strong> command.</p><p>In the following example, a listener for ARP requests on interface eth0 is created and then an <strong>expect_network</strong> command is used to wait for actual ARP requests and respond to them with an ARP reply:</p>
<pre>
# Spawn a listener for ARP requests
spawn_network -i eth0 host 192.168.1.1 and {arp[6:2]} == 1

expect_network {1} {
    # Received an ARP request, send ARP reply
    send_network -o eth0 &#92;
        ether(src = $mymac, dst = $arp(sha) )/ &#92;
        arp-reply(tha = $arp(sha), tip = $arp(sip), &#92;
                  sha = $mymac, sip = 192.168.1.1)
    nexp_continue
}

</pre>
<p>The <strong>-timeout</strong> flag causes the current <strong>expect_network</strong> command to use the following value as a timeout instead of using the value of the <em>timeout</em> variable.</p><p>Actions such as <strong>break</strong> and <strong>continue</strong> cause control structures (i.e., <strong>for</strong>, <strong>proc</strong>) to behave in the usual way. The command <strong>nexp_continue</strong> allows <strong>expect_network</strong> itself to continue executing rather than returning as it normally would.</p><p>This is useful for avoiding explicit loops or repeated <strong>expect_network</strong> statements. The following example is part of a fragment to respond to ICMP echo and ARP requests. The <strong>nexp_continue</strong> avoids having to write a second <strong>expect_network</strong> statement (to look for the requests again.)</p>
<pre>
# Spawn a listener for ARP requests
spawn_network -i $interface host $myip and {arp[6:2]} == 1
set arpl $listener_id

# Spawn a listener for ICMP messages sent to us
spawn_network -i $interface icmp and dst host $myip
set icmpl $listener_id

expect_network -i $arpl {1} {
    # Received an ARP request, send ARP reply
    send_network -o $interface &#92;
        ether(src = $mymac, dst = $arp(sha) )/ &#92;
        arp-reply(tha = $arp(sha), tip = $arp(sip), &#92;
                  sha = $mymac, sip = $myip)
    nexp_continue
} -i $icmpl {$icmp(type) == 8} {
    # Received ICMP echo request, send echo reply
    send_network -o ip &#92;
        ip(src = $myip, dst = $ip(src) )/ &#92;
        icmp-echoreply(id = $icmp(id), seq = $icmp(seq) )/ &#92;
	raw($raw)
    nexp_continue
}

</pre>
<p><strong>expect_network_after</strong> <em>[expect_args]</em></p><p>works identically to the <strong>expect_network_before</strong> except that if conditions from both <strong>expect_network</strong> and <strong>expect_network_after</strong> evaluate to true, the <strong>expect_network</strong> conditions is used. See the <strong>expect_network_before</strong> command for more information.</p><p><strong>expect_network_background</strong> <em>[expect_args]</em></p><p>takes the same arguments as <strong>expect_network</strong>, however it returns immediately. Conditions are evaluated whenever a new packet arrives. The expression <em>timeout</em> and <em>default</em> are meaningless to <strong>expect_network_background</strong> and are silently discarded. Otherwise, the <strong>expect_network_background</strong> command uses <strong>expect_network_before</strong> and <strong>expect_network_after</strong> conditions just like <strong>expect_network</strong> does.</p><p>Please note that if a condition of the <strong>expect_network_background</strong> command evaluates to true, the command will not continue to listen for traffic unless the body includes a <strong>nexp_continue</strong> command that forces <strong>expect_network_background</strong> to continue executing.</p><p><strong>expect_network_before</strong> <em>[expect_args]</em></p><p>takes the same arguments as <strong>expect_network</strong>, however it returns immediately. Condition-action pairs from the most recent <strong>expect_network_before</strong> with the same network listener ID are implicitly added to any following <strong>expect_network</strong> commands. If a condition evaluates to true, it is treated as if it had been specified in the <strong>expect_network</strong> command itself, and the associated body is executed in the context of the <strong>expect_network</strong> command. If conditions from both <strong>expect_network_before</strong> and <strong>expect_network</strong> can evaluate to true, the <strong>expect_network_before</strong> condition is used.</p><p>Unless overridden by a <strong>-i</strong> flag, <strong>expect_network_before</strong> conditions are evaluated against the network listener ID defined at the time that the <strong>expect_network_before</strong> command was executed (not when its condition evaluated to true.)</p><p>The <strong>-info</strong> flag causes <strong>expect_network_before</strong> to return the current specifications of what conditions will be evaluated. By default, it reports on the current network listener. An optional network listener ID specification may be given for information on that network listener.</p><p>Instead of a network listener specification, the flag <strong>-all</strong> will cause <strong>-info</strong> to report on all network listeners.</p><p>The output of the <strong>-info</strong> flag can be reused as the argument to <strong>expect_network_before</strong>.</p><p><strong>iflist</strong> <em>[&lt;-refresh&gt;]</em></p><p><strong>iflist</strong> returns a list that contains the name of all interfaces in the system. This list is built when <strong>Network Expect</strong> starts. If the optional argument <strong>-refresh</strong> is specified then the list is refreshed before returning it.</p><p><strong>nexp_continue</strong></p><p>The command <strong>nexp_continue</strong> allows expect itself to continue executing rather than returning as it normally would.</p><p><strong>nexp_version</strong> <em>[[-exit] &lt;version&gt;]</em></p><p>is useful for assuring that the script is compatible with the current version of <strong>Network Expect</strong>.</p><p>With no arguments, the current version of Expect is returned. This version may then be encoded in your script. If you actually know that you are not using features of recent versions, you can specify an earlier version.</p><p>Versions consist of two numbers separated by dots. First is the major number. Scripts written for versions of <strong>Network Expect</strong> with a different major number will almost certainly not work. <strong>nexp_version</strong> returns an error if the major numbers do not match.</p><p>Second is the minor number. Scripts written for a version with a greater minor number than the current version may depend upon some new feature and might not run. <strong>nexp_version</strong> returns an error if the major numbers match, but the script minor number is greater than that of the running <strong>Network Expect</strong>.</p><p>With the -exit flag, Expect prints an error and exits if the version is out of date.</p><p><strong>outif</strong> <em>&lt;target&gt;</em></p><p>The <strong>outif</strong> command returns the outgoing interface that would be used to reach <strong>target</strong>. <strong>target</strong> can be an IP address or host name.</p><p><strong>packet</strong> <em>decode | hash | data | dump | ts | tdelta &lt;args&gt;</em></p><p>The <strong>packet</strong> command allows to manage variables of type <em>packet</em>.</p><p><strong>packet decode &lt;packet variable&gt;</strong> will decode the specified <em>packet</em> variable, just as if the packet was received during the execution of a <strong>expect_network</strong> command.</p><p><strong>packet hash &lt;packet variable&gt;</strong> calculates a hash of the specified <em>packet</em> variable.</p><p><strong>packet data &lt;packet variable&gt;</strong> returns a <em>barray</em> variable that contains all of the packet&apos;s data.</p><p><strong>packet dump &lt;packet variable&gt;</strong> displays an hexadecimal dump (on standard output) of the <em>packet</em>&apos;s data.</p><p><strong>packet ts &lt;packet variable&gt;</strong> will return a <em>timeval</em> variable that corresponds to the timestamp associated with the specified <em>packet</em> variable.</p><p><strong>packet tdelta &lt;packet variable 1&gt; &lt;packet variable 2&gt;</strong> calculates the time delta between the <em>timestamp</em> associated with &lt;packet variable 1&gt; and the <em>timestamp</em> associated with &lt;packet variable 2&gt;.</p><p><strong>pdu</strong> <em>&lt;new | delete | dup | append | count | build | list&gt; &lt;args&gt;</em></p><p>The <strong>pdu</strong> command is used to manage variables of type <em>pdu</em> (Protocol Data Unit.)</p><p><strong>pdu new &lt;PDU definition&gt;</strong> will create and return a new <em>pdu</em> variable. The PDU definition is the same as used in other <strong>Network Expect</strong> commands like <strong>send_network</strong> and <strong>send_expect</strong>.</p><p><strong>pdu delete &lt;pdu variable&gt;</strong> will delete a <em>pdu</em> variable.</p><p><strong>pdu dup &lt;pdu variable&gt;</strong> will duplicate a <em>pdu</em> variable.</p><p><strong>pdu append &lt;pdu variable 1&gt; &lt;pdu variable 2&gt;</strong> will append the <em>pdu</em> variable <em>pdu variable 2</em> to the <em>pdu</em> variable <em>pdu variable 1</em>. The result is <em>pdu variable 1</em>.</p><p><strong>pdu count &lt;pdu variable&gt;</strong> returns the number of packets that would be generated if that PDU were to be sent using the <strong>send_network</strong> command, for example. The number of packets depends on the numeric specifications used in the definition of the PDU.</p><p><strong>pdu build &lt;pdu variable&gt;</strong> builds the specified <em>pdu</em> variable and returns a variable of type <em>packet</em>.</p><p><strong>pdu list</strong> displays the list of PDUs that <strong>Network Expect</strong> knows about, i.e. the PDUs that can be created via certain <strong>Network Expect</strong> commands like <strong>send_network</strong>, <strong>send_expect</strong>, and <strong>pdu new</strong>.</p><p><strong>random</strong> <em>[x:y | number x:y | ip [a.b.c.d/nn | a.b.c.d:e.f.g.h] | mac]</em></p><p>The <strong>random</strong> command can be used to obtain a variety of random objects. Current supported objects are numbers, IPv4 addresses, and MAC addresses. It is possible to obtain a random number or IP address from within a range. In the case of numbers the range is specified using the notation x:y. In the case of IP addresses the range can be specified using the IP address/netmask bits notation, or using the a.b.c.d:e.f.g.h notation. If no object is specified then a random number is returned.</p><p><strong>send_expect</strong> <em>[-i &lt;listener ID&gt;] [-o &lt;speaker ID&gt;] [-timeout &lt;timeout&gt;] [-n &lt;number of tries&gt;] &lt;PDU definition&gt;</em></p><p>This command sends a number of packets to a target or list of targets and then waits for responses. After responses are received, the command matches sent packets with received packets. This command was inspired by the <strong>sr()</strong> family of commands in <strong>Scapy</strong>, the packet manipulation tool by Philippe Biondi.</p><p>The <strong>-i</strong> flag specifies what listener to use to read responses. It is possible to specify multiple listeners by using this option multiple times.</p><p>The <strong>-o</strong> flag specifies what speaker to use when injecting the stimulus.</p><p><strong>-timeout</strong> specifies how long to wait, after all packets have been sent, for answers to the injected stimulus. The timeout is specified in seconds and the default is 1 second.</p><p><strong>-n</strong> specifies how many times to retry sending the stimulus if not all sent packets have a corresponding received answer.</p><p>The definition of the PDU to send is the same as it used in the <strong>send_network</strong> command.</p><p>The <strong>send_expect</strong> command creates three lists: the list of sent packets and the corresponding list of matching answers, and the list of unanswered packets. A script can then use these lists, decode packets, and present some useful information. For example, the following code snippet sends ICMP echo requests to all hosts in a network a displays which hosts replied:</p>
<pre>
set network 192.168.1.1-192.168.1.254

# Spawn a listener. We don&apos;t really have to specify a filter,
# like in "spawn_network {icmp[icmptype] == icmp-echoreply}"
# because the send_expect command will intelligently match
# injected stimulus (ICMP echo requests) with received
# answers (ICMP echo replies). A filter means less work for
# the send_expect command, but other than that it adds nothing.
spawn_network

send_expect -n 2 -4 -D $network -icmp-echo random:random &#92;
    -payload "12345678901234567890" -delay .001

puts "&#92;n[llength $_(received)] hosts sent echo-replies back:&#92;n"

foreach r $_(received) s $_(sent) {
    packet decode r
    puts [format "$pdu(1,tot_len) bytes from $ip(src): ttl=$ip(ttl) time=%.3f ms" [expr [packet tdelta r s]*1000] ]
}

</pre>
<p><strong>send_network</strong> <em>[options] &lt;PDU definition&gt;</em></p><p>This command allows the creation custom TCP/IP packets based on packet definitions provided by the user through command-line arguments passed to the program, through a command file specified in the command-line, or through a mix of these two methods. <strong>send_network</strong> refers to instances of protocols in the TCP/IP protocol suite as <em>protocol data units</em>, or PDUs for short. A protocol data unit always has a header (think of the IP version 4 header, or the TCP header), may or may not have options (think of the TCP options, or IP version 6 extension headers), and may or may not have a payload. Due to the extensive use of encapsulation in the TCP/IP protocol suite, the payload of a PDU can be another payload. For example, an Ethernet frame can have as its payload an IP version 4 packet, which in itself is another PDU. Then this IP version 4 packet can have as its payload a TCP segment, which is another PDU, and so on.</p><p>When defining PDUs that <strong>send_network</strong> will create you start by creating the definitions for PDUs that are closer to the physical layer, and then move up the protocol stack until you reach, in some cases, and if that is what you want, the application layer. To implement this approach through a command-line interface (CLI) you start by entering the lower-level PDUs closer to the beginning of the command-line, or, if you are reading your packet definitions from a file, by entering definitions for lower-level PDUs at the beginning of the file. After you have defined a certain PDU you cannot define another PDU that is lower than the previous in the protocol stack. For example, you cannot define a TCP segment and then create an Ethernet frame as the segment&apos;s payload, just because that does not make sense (defining a TCP segment and then a BGP message does make sense, for example.) For this reason, order does matter in the command-line (or in the file, if defining PDUs in a file) when creating the PDUs.</p><p><strong>sleep</strong> <em>&lt;seconds&gt;</em></p><p>causes the script to sleep for the given number of seconds. <strong>seconds</strong> may be a decimal number. Interrupts are processed while <strong>Network Expect</strong> sleeps.</p><p><strong>spawn_network</strong> <em>[-nolistener]</em> <em>[-fullspeed]</em> <em>[-info]</em> <em>[-i &lt;input interface&gt;]</em> <em>[-o &lt;output interface&gt;]</em> <em>[-r &lt;input PCAP file&gt;]</em> <em>[-p]</em> <em>[-s &lt;snaplen&gt;]</em> <em>[-w &lt;output PCAP file&gt;]</em> <em>[-hexdump]</em> <em>[-stdout]</em> <em>[-4]</em> <em>[-6]</em> <em>[&lt;PCAP filter&gt;]</em></p><p>The <strong>spawn_network</strong> command is used to find information about existing listeners and speakers or to create network speakers and network listeners.</p><p>To find information about existing network listeners and speakers the <strong>spawn_network</strong> command needs to be invoked with only the <strong>-info</strong> option.</p><p>Listeners are created by using the options <strong>-i</strong> or <strong>-r</strong>. <strong>-i</strong> specifies an interface to listen for traffic on, and <strong>-r</strong> specifies the use of a PCAP file for reading instead of reading live traffic from an interface. In both cases, an optional <strong>PCAP filter</strong> can be specified to limit the type of traffic that will be read. If <strong>-i</strong> is not used then <strong>Network Expect</strong> will try to find a suitable interface. <strong>-fullspeed</strong> causes reading from a PCAP file at full speed, without preserving the inter-packet delay present in the savefile. If this option is not specified then the inter-packet delay present in the savefile will not be preserved.</p><p>Speakers are created using one of <strong>-o</strong>, <strong>-w</strong>, <strong>hexdump</strong>, <strong>stdout</strong>, <strong>-4</strong>, or <strong>-6</strong>. <strong>-o</strong> specifies the use of an interface for injecting traffic into the network. This implies the use of layer 2 injection in which the Ethernet header is specified by the user. <strong>-w</strong> specifies that all traffic will be sent to the PCAP file <strong>PCAP file</strong>. This option requires the use of layer 2 injection, i.e. the Ethernet header must be included. <strong>-hexdump</strong> specifies that all packets be sent to standard output in hexadecimal format. <strong>-stdout</strong> causes all packets to be sent to standard output in raw format. The <strong>-4</strong> and <strong>-6</strong> options specify the creation of layer 3 speakers to inject IPv4 and IPv6 traffic respectively. In this case all routing decisions are performed by the kernel.</p><p>The <strong>-p</strong> and <strong>-s</strong> options are only meaningful for listener creation. <strong>-p</strong> specifies that the interface be not put in promiscuous mode when creating a listener that will listen on an interface. <strong>-s</strong> specifies the snapshot length of captured packets. These two options are equivalent to the <a href="../man8/tcpdump.8.html"><strong>tcpdump</strong>(8)</a> options of the same names.</p><p>Note that if no options to create a speaker are specified, i.e. <strong>-o</strong>, <strong>-w</strong>, <strong>hexdump</strong>, <strong>stdout</strong>, <strong>-4</strong>, or <strong>-6</strong>, the default action is to only create a listener. If only a speaker is desired one of the options to create a speaker must be specified and the <strong>-nolistner</strong> option must be used.</p><p>As an example, the follow command creates a listener on interface eth0 for ARP requests for the MAC address of host 192.168.1.1:</p>
<pre>
spawn_network -i eth0 host 192.168.1.1 and {arp[6:2]} == 1

</pre>
<p>Note that curly braces are necessary around "arp[6:2]" because brackets have special meaning in Tcl.</p><p><strong>system</strong> <em>&lt;system command&gt; [&lt;args&gt;]</em></p><p>The <strong>system</strong> command allows to run arbitrary system commands from within a <strong>Network Expect</strong> script.</p><p>Please note that this command does no input validation at all, which means that it is very insecure. For example "system {ls;/bin/sh}" will give you a shell. If nexp is run as roon then the shell will be a root shell.</p><p>The <strong>exec</strong> command in the standard Tcl distribution is a much better alternative to the <strong>Network Expect</strong> <strong>system</strong> command. Please see the Tcl documentation for the <strong>exec</strong> command for additional information.</p><p><strong>timeval</strong> <em>new | delta &lt;args&gt;</em></p><p>The <strong>timeval</strong> command allows to manage variables of type <em>timeval</em>.</p><p><strong>timeval new;</strong> returns a <em>timeval</em> variable that corresponds to the current system time.</p><p><strong>timeval tdelta &lt;timeval variable 1&gt; &lt;timeval variable 2&gt;</strong> calculates the time delta between the <em>timeval variable 2</em> and <em>timeval variable 1</em>.</p><p><strong>txdelta</strong> <em>&lt;speaker ID&gt;</em></p><p>Every time a packet is sent, the time the packet was sent is saved to the network speaker that was used to send that packet. The <strong>txdelta</strong> (short for "transmission delta") command returns the number of seconds that have elapsed since the last packet that was sent via the specified <strong>speaker ID</strong>.</p><p>The following example provides the foundation for a very simple ping program, and shows how the <strong>txdelta</strong> command can be used:</p>
<pre>
for {set id 0; set seq 0} {1} {incr seq} {
    send_network -4 -D $target -icmp-echo $id:$seq -payload "12345678901234567890"

    expect_network -timeout 1 {$icmp(type) == 0 && $icmp(id) == $id} {
        puts [format "$pdu(2,tot_len) bytes from $ip(src): icmp_seq=$seq ttl=$ip(ttl) time=%.3f ms" [expr [txdelta ip]*1000 ] ]
        sleep [expr 1.0 - [txdelta ip] ]
    }
}

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SPECIAL VARIABLES</h2>
        <div class="sectioncontent">
<p>Special variables.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>The examples directory in the <strong>Network Expect</strong> distribution contains plenty of examples that should provide a very good idea of how to use <strong>Network Expect</strong>. A few selected examples have been selected for this manual page.</p><p>The following code snippet performs a TCP three-way handshake. Everything is done by hand, which allows to play with TCP initial sequence numbers (ISNs), window sizes, etc. The code is a bit more complex that necessary because an effort is made to handle error coditions (timeout, remote host not listening on the destination port, strange combination of TCP flags received in response to our initial SYN.)</p>
<pre>
# Some useful constants
set SYN 0x02
set RST 0x04
set ACK 0x10

set retries 3
set isn [random]
set myip 192.168.1.2
set target 192.168.1.1
set sport [random 20000:65535]
set dport 21
set window 4096

# Spawn a listener for TCP segments coming from the FTP server to us
spawn_network -i $interface "tcp and src host $target and dst host $myip and src port $dport and dst port $sport"


# Send TCP SYN
send_network ip(src = $myip, dst = $target)/ &#92;
             tcp(src = $sport, dst = $dport, window = $window, &#92;
                 syn, seq = $isn, ack-seq = 0)

# Wait for response from the server
expect_network {$tcp(flags) == ($SYN | $ACK)} {
    # Got a SYN+ACK so we need to send the final segment of the
    # 3-way HS
    send_network ip(dst = $myip, dst = $target)/ &#92;
                 tcp(dst = $tcp(dstport), dst = $tcp(srcport), &#92;
                     window = $window, ack, seq = $tcp(ack), &#92;
                     ack-seq = [expr $tcp(seq) + 1])
} {$tcp(flags) & $RST} {
    puts "Connection refused"
    exit 1
} {1} {
    # Any other weird combination of TCP flags we respond to
    # with a RST
    send_network ip(src = $myip, dst = $target)/ &#92;
                 tcp(src = $tcp(dstport), dst = $tcp(srcport), &#92;
                     rst)
    exit 1
} timeout {
    # Our SYN got lost in transit or it was filtered - perform
    # exponential backoff and retransmit the SYN...
    if {$retries &gt; 0} {
        incr retries -1
        set timeout [expr $timeout*2]
        puts "SYN timeout, increasing timeout to $timeout"
        send_network ip(src = $myip, dst =  $target)/ &#92;
                     tcp(src = $sport, dst = $dport, &#92;
                         window = $window, syn, seq = $isn, &#92;
                         ack-seq = 0)
        nexp_continue
    } else {
        puts "Connection timed out"
        exit 1
    }
}

# TCP connection has been established. Now do something...

</pre>
<p>This illustrates how to create a phantom host on the network that can respond to ICMP echo requests, and therefore, to ARP requests as well.</p>
<pre>
set interface eth0
set myip 192.168.1.1
set mymac [random mac]

# Spawn a listener for ARP requests
spawn_network -i $interface host $myip and {arp[6:2]} == 1
set arpl $listener_id

# Spawn a listener for ICMP messages sent to us
spawn_network -i $interface icmp and dst host $myip
set icmpl $listener_id

expect_network_background -i $arpl {1} {
    # Received an ARP request, send ARP reply
    send_network -o $interface &#92;
        ether(src = $mymac, dst = $arp(sha) )/ &#92;
        arp-reply(tha = $arp(sha), tip = $arp(sip), &#92;
                  sha = $mymac, sip = $myip)
    nexp_continue
} -i $icmpl {$icmp(type) == 8} {
    # Received ICMP echo request, send echo reply
    send_network -o ip &#92;
        ip(src = $myip, dst = $ip(src) )/ &#92;
        icmp-echoreply(id =  $icmp(id), seq = $icmp(seq) )/ &#92;
        raw($raw)
    nexp_continue
}

</pre>
<p>This example how to create a very simple traceroute program that uses TCP probes to port 80 of the target host. It uses the <strong>send_expect</strong> command.</p>
<pre>
set target "www.example.com"
set ttlrange "1:30"
set interface [outif $target]

# Spawn a listener. We don&apos;t really have to specify a filter because the
# send_expect command will intelligently match injected stimulus with
# received answers.
spawn_network -i $interface

send_expect -tries 2  -delay 0.001 &#92;
    ip(id = random, dst = $target, ttl = $ttlrange)/ &#92;
    tcp(src = random, dst = 80, syn)

foreach r $_(received) s $_(sent) {
    packet decode r
    set source $ip(src)
    set pdu_type $pdu(1,type)

    packet decode s

    puts [format "$ip(ttl) $source %.3f ms $pdu_type" [expr [packet tdelta r s]*1000] ]
}

</pre>
<p>This shows how to perform an ARP scan using regular <strong>send_network</strong> and <strong>expect_network</strong> commands:</p>
<pre>
set interface eth0
set network "$iface($interface,ip)/$iface($interface,netmask)"

set arprequest [pdu new -o $interface
    ether(dst = BROADCAST)/ &#92;
    arp-request(tha = BROADCAST, tip = $network, &#92;
                sha = $iface($interface,hw_addr), &#92;
                sip = $iface($interface,ip) ) ]

# Spawn a listener for ARP replies
spawn_network -i $interface {arp[6:2]} == 2

for {set i 0} {$i &lt; [pdu count arprequest]} {incr i} {
    # Send ARP request
    send_network -count 1 arprequest

    # Read ARP reply
    expect_network -timeout .05 {1} {
        puts "$arp(sip) is at $arp(sha)"
    }
}

</pre>
<p>This example shows how to do an ARP scan but in a more efficient manner using the <strong>send_expect</strong> command:</p>
<pre>
set interface eth0
set network "$iface($interface,ip)/$iface($interface,netmask)"

# Spawn a listener for ARP replies
spawn_network -i $interface {arp[6:2]} == 2

send_expect -o $interface -delay 0.001 -tries 2 &#92;
    ether(dst = BROADCAST)/ &#92;
    arp-request(tha = BROADCAST, tip = $network, &#92;
	        sha = $iface($interface,hw_addr),
                sip = $iface($interface,ip) )

puts "&#92;nFound [llength $_(received)] hosts alive:&#92;n"

foreach r $_(received) {
    packet decode r
    puts "$arp(sip) is at $arp(sha)"
}

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p><strong>Network Expect</strong> does not run very well under the Solaris operating system because in that operating system select() does not seem to work well with packet capture file descriptors (select() returns when there is no data ready to be read.)</p><p><strong>Network Expect</strong> does not work at all in Microsoft Windows because select() does not work at all with packet capture file descriptors (pcap_get_selectable_fd() does not exist under Microsoft Windows.)</p><p>Error-checking is almost non-existant.</p><p>These isn&apos;t input validation for the numeric specifications.</p><p>The parser of PDU definitions (and therefore the number of tokens that the parser handles) has become a big, wild beast. It&apos;s very easy to add new tokens and PDU definitions are elegant and pretty, but the parser is huge. Guess can&apos;t have everything.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">VERSION</h2>
        <div class="sectioncontent">
<p>This man page is correct for version 1.0 of <strong>Network Expect</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO nexp&hellip;</h2>
        <div class="sectioncontent">
<p><strong>nexp-numspec</strong>(1), <strong>nexp-payload</strong>(1), <strong>nexp-ether</strong>(5), <strong>nexp-gre</strong>(5), <strong>nexp-ip</strong>(5), <strong>nexp-mpls</strong>(5), <a href="../man1/expect.1.html"><strong>expect</strong>(1)</a></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p><strong>Network Expect</strong> was written by Eloy Paris &lt;peloy@netexpect.org&gt;. However, <strong>Network Expect</strong> borrows ideas from lots of Open Source tools like Nemesis, Packit, hping, Expect, and Scapy. The <strong>Network Expect</strong> author is indebted to the authors of these tools for their contribution.</p><p>This man page was written by Eloy Paris although it borrows heavily from Expect&apos;s manual page.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="nex.1.html"><span aria-hidden="true">&larr;</span> nex.1: Text editors</a></li>
   <li class="next"><a href="nf2csv.1.html">nf2csv.1: Iptables to csv data <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

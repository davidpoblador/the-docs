<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>dacscheck: Authorization check</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Authorization check">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="dacscheck (1) manual">
  <meta name="twitter:description" content="Authorization check">
  <meta name="twitter:image" content="https://www.carta.tech/images/dacs-dacscheck-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/dacscheck.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="dacscheck (1) manual" />
  <meta property="og:description" content="Authorization check" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/dacs-dacscheck-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">dacscheck<small> (1)</small></h1>
        <p class="lead">Authorization check</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/dacscheck.1.html">
      <span itemprop="name">dacscheck: Authorization check</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/dacs/">
      <span itemprop="name">dacs</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/dacscheck.1.html">
      <span itemprop="name">dacscheck: Authorization check</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>dacscheck</strong> [<strong>-admin</strong>] [<strong>-app&nbsp;</strong><strong></strong><em>appname</em>] [<strong>-context&nbsp;</strong><strong></strong><em>file</em>] [<strong>-D</strong><strong></strong><em>name=value</em>]</p><p>[<strong>-F&nbsp;</strong><strong></strong><em>field_sep</em>] [<strong>-fd&nbsp;</strong><strong></strong><em>domain</em>] [<strong>-fh&nbsp;</strong><strong></strong><em>hostname</em>] [<strong>-fj&nbsp;</strong><strong></strong><em>jurname</em>] [<strong>-fn&nbsp;</strong><strong></strong><em>fedname</em>]</p><p>[<strong>-dump</strong>] [<strong>-groups&nbsp;</strong><strong></strong><em>group_vfs</em>] [<strong>-h</strong>] [<strong>-i&nbsp;</strong><strong></strong><em>ident</em>] [<strong>-il&nbsp;</strong><strong></strong><em>ident</em>]</p><p>[<strong>-ilg&nbsp;</strong><strong></strong><em>ident</em>] [<strong>-ieuid</strong>] [<strong>-ieuidg</strong>] [<strong>-iuid</strong>] [<strong>-iuidg</strong>] [<strong>-lg</strong>] [<strong>-ll&nbsp;</strong><strong></strong><em>log_level</em>] [<strong>-name_compare&nbsp;</strong><strong></strong><em>method</em>] [<strong>-q</strong>]</p><p>[<strong>-redirect</strong>] [<strong>-roles&nbsp;</strong><strong></strong><em>roles_vfs</em>] [<strong>-rules&nbsp;</strong><strong></strong><em>rule_vfs</em>] [<strong>-v</strong>] [<strong>-var&nbsp;</strong><strong></strong><em>name=value</em>]</p><p>[<strong>-vfs&nbsp;</strong><strong></strong><em>vfs_uri</em>] [<strong>--</strong>] <em>object</em></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This program is part of the <strong>DACS</strong> suite. It is a stand-alone program that neither accepts the usual <strong>DACS</strong> command line options (<em>dacsoptions</em>) nor accesses any <strong>DACS</strong> configuration files.</p><p>Put simply, <strong>dacscheck</strong> looks at access control rules to test if a given user is authorized to do something or access something. The command&apos;s exit status gives the result of the test, and unless the <em>-q</em> flag is given, a line is printed to stdout that indicates the result. It provides simplified, general-purpose access to <strong>DACS</strong>&apos;s access control rule evaluation engine, even for programs other than web services, and it lends itself to fine-grained access control decisions.</p><p>More specifically, <strong>dacscheck</strong> checks if a request for object should be granted according to specified access control rules and a given evaluation context. To do its job, <strong>dacscheck</strong> needs to know only a few things:</p><p>where to find the access control rules to apply;</p><p>the name of the object being accessed; and</p><p>optionally, an evaluation context that specifies an identity for which access is being tested and variables that can be referenced by rules.</p><p>The command does not perform any authentication; it assumes that the caller (or the execution environment) has already established the identity for which an access control decision is required. It may be used like any other command: run from the command line or a shell script, executed by a compiled program, or called from a scripting language such as \m[blue]<strong>Perl</strong>\m[]\s-2\u[1]\d\s+2, \m[blue]<strong>PHP</strong>\m[]\s-2\u[2]\d\s+2. \m[blue]<strong>Python</strong>\m[]\s-2\u[3]\d\s+2, \m[blue]<strong>Ruby</strong>\m[]\s-2\u[4]\d\s+2, and \m[blue]<strong>Tcl/Tk</strong>\m[]\s-2\u[5]\d\s+2.</p><p>Some simple examples will illustrate how <strong>dacscheck</strong> can be used.</p><p><strong>Note</strong></p><p>The examples in this document have been simplified for readability; in real use, absolute pathnames should appear, error checking should be performed, and so on. Also, the <strong>dacscheck</strong> program and the rules that it requires must have file permissions set appropriately.</p><p>The first example shows how a shell script might call <strong>dacscheck</strong> to test whether the user running it is allowed to do so. It obtains the user&apos;s identity from the operating system; it assumes that the user has invoked the script from the command line and has therefore already signed in to the system. In the example, <strong>dacscheck</strong> obtains the identity through a system call, but a script might choose to pass the value of the <strong>LOGNAME</strong> or <strong>USER</strong> environment variable.</p><p>The shell script simply asks <strong>dacscheck</strong> if the effective uid (see \m[blue]<a href="../man2/geteuid.2.html"><strong>geteuid</strong>(2)</a></strong>\m[]\s-2\u[6]\d\s+2) is permitted to access /myapp. The exit status of <strong>dacscheck</strong> (<em>$?</em>) gives the result. The pathname /myapp is essentially a label that is used to find the access control rule to apply; in this example it simply represents the name of the program. It could be the program&apos;s filename, but it need not be.</p>
<pre>
#! /bin/sh

dacscheck -q -ieuid -rules /usr/local/myapp/rules /myapp
st="$?"
if test "${st}" != 0
then
  echo "Access is denied"
  exit "${st}"
fi

echo "Access is granted"

# Do some stuff

exit 0
</pre>
<p>The directory /usr/local/myapp/rules might include a file named acl-app.0 that grants access only to bob and alice:</p>
<pre>
&lt;acl_rule status="enabled"&gt;
  &lt;services&gt;
   &lt;service url_pattern="/myapp"/&gt;
  &lt;/services&gt;

  &lt;rule order="allow,deny"&gt;
   &lt;allow&gt;
     user(":bob") or user(":alice")
   &lt;/allow&gt;
  &lt;/rule&gt;
&lt;/acl_rule&gt;
</pre>
<p><strong>Note</strong></p><p>Access control rules are described in \m[blue]<a href="../man5/dacs.acls.5.html"><strong>dacs.acls</strong>(5)</a></strong>\m[]\s-2\u[7]\d\s+2. As with \m[blue]<a href="../man8/dacs_acs.8.html"><strong>dacs_acs</strong>(8)</a></strong>\m[]\s-2\u[8]\d\s+2, these rules must be indexed by \m[blue]<a href="../man1/dacsacl.1.html"><strong>dacsacl</strong>(1)</a></strong>\m[]\s-2\u[9]\d\s+2. For example, in a common use case where a <strong>DACS</strong> configuration file is not being used, the ruleset consulted by <strong>dacscheck</strong> might be indexed using a command like:</p>
<pre>
% dacsacl -un -vfs "[acls]file:///users/bobo/my-rules" -vfs "[dacsacls]:file:///dev/null"
</pre>
<p>If <strong>dacsacl</strong> is successful in the example above, a file named INDEX will be created or updated in the /users/bobo/my-rules directory, where the files containing the rules are also found. Warning messages can usually be ignored provided INDEX looks correct.</p><p>A CGI program can obtain the identity of the user invoking it from the <strong>REMOTE_USER</strong> environment variable and call <strong>dacscheck</strong>, as demonstrated in the following shell script, which uses the same rule as above:</p>
<pre>
#! /bin/sh

if test "${REMOTE_USER}x" = "x"
then
  idarg=""
else
  idarg="-i ${REMOTE_USER}"
fi

echo "Context-Type: text/plain"
echo ""

# Note: append 2&gt;&1 to the end of the next line to capture error messages
dacscheck -q ${idarg} -rules /usr/local/myapp/rules /myapp

st="$?"
if test "${st}" = 0
then
  echo "Access is granted"
else
  echo "Access is denied"
fi

exit 0
</pre>
<p>This example can easily be translated into any scripting language that allows an external program to be called and its exit status examined. Here is a similar example in PHP:</p>
<pre>
$user = $_SERVER["REMOTE_USER"];
putenv("REMOTE_USER=$user");
system("/usr/local/dacs/bin/dacscheck -q -fn DEMO -icgi
     -rules /usr/local/myapp/rules /myapp", $st);
if ($st != 0) {
// Access is denied, bail out
  exit($st);
}

// Access is granted, proceed
</pre>
<p><strong>Note</strong></p><p>Some may question the point of having a program call <strong>dacscheck</strong> to test if the user invoking it is allowed to merely run the program. At first glance it might appear that one could achieve the same result by simply setting file permissions such that only bob and alice can run the program. If that could be done, the coarse-grained testing done by <strong>dacscheck</strong> in the examples would be unnecessary. It turns out that there is more to it than that.</p><p>Setting file permissions to achieve this on a traditional Unix-type system requires creating a new group in /etc/group, something that generally can only be done by a system administrator. Ordinary users must therefore either bother the system administrator each time such a group must be created or modified, or find some other way to achieve the same result (e.g., by encryption, using a special setuid or setgid command that provides password-protected access, or some other clumsy and possibly insecure solution).</p><p>To address this limitation and others, many Unix-type operating systems now include file systems that extend the traditional Unix file permissions with an ACL-based mechanism (e.g., providing the \m[blue]<a href="../man1/getfacl.1.html"><strong>getfacl</strong>(1)</a></strong>\m[]\s-2\u[10]\d\s+2 and \m[blue]<a href="../man1/setfacl.1.html"><strong>setfacl</strong>(1)</a></strong>\m[]\s-2\u[11]\d\s+2 commands, and the \m[blue]<strong>acl</strong>(3)</strong>\m[]\s-2\u[12]\d\s+2 ACL security API).</p><p><strong>dacscheck</strong> provides similar functionality but for <em>arbitrary names</em>, not only for objects in the file system, and with respect to <em>arbitrary identities</em>, not only for those known to the operating system. For example, a CGI script can call <strong>dacscheck</strong> to test access on behalf of a user known to the web server (e.g., via an account created using \m[blue]<a href="../man1/htpasswd.1.html"><strong>htpasswd</strong>(1)</a></strong>\m[]\s-2\u[13]\d\s+2) but not having an account on the underlying system. Therefore, besides being portable across platforms and available on systems without ACL-type file permissions, <strong>dacscheck</strong> is a much more general solution than what most operating systems provide. In contrast to a system-provided ACL-based mechanism, however, <strong>dacscheck</strong> is <em>not</em> invoked transparently (i.e., it is not called automatically by the operating system when a resource such as a file is accessed). Also, with respect to testing whether a user is allowed to run a program, that program will typically perform the test itself and must therefore begin execution.</p><p>For additional information:</p><p>\m[blue]<strong>Using FreeBSD&apos;s ACLs</strong>\m[]\s-2\u[14]\d\s+2, Dru Lavigne, \m[blue]<strong>ONLamp.com</strong>\m[]\s-2\u[15]\d\s+2, 22-Sep-05.</p><p>\m[blue]<strong>POSIX ACLs in Linux</strong>\m[]\s-2\u[16]\d\s+2, Mike Peters, \m[blue]<strong>linux.com</strong>\m[]\s-2\u[17]\d\s+2, 2-Aug-04.</p><p>For Solaris, \m[blue]<strong>Solaris 10 <strong>acl</strong>(2)</strong>\m[]\s-2\u[18]\d\s+2, \m[blue]<strong>Sun Microsystems</strong>\m[]\s-2\u[19]\d\s+2 and \m[blue]<strong>Using Solaris ACLs</strong>\m[]\s-2\u[20]\d\s+2 by the \m[blue]<strong>Dept. of Computer Science, Duke University</strong>\m[]\s-2\u[21]\d\s+2.</p><p>Because the authorization checking performed by <strong>dacscheck</strong> is completely separate from that performed by the operating system for system calls, a <strong>Unix</strong> identity such as root has no special rights or capabilities as far as <strong>dacscheck</strong> is concerned unless rules have been written to grant them. The same applies to the application of <strong>Unix</strong> groups.</p><p>The next example demonstrates how some typical <strong>Perl</strong> code can be improved by <strong>dacscheck</strong>. The code fragment:</p>
<pre>
if ($logged_in_as_root || $logged_in_as_current_admin) {
  # Do something privileged...
}
</pre>
<p>which depends on the two variables being properly initialized depending on the value of <em>$username</em>, can be replaced by this:</p>
<pre>
# Determine if $username has admin privileges
$output = `dacscheck -q -i $username -app myapp /myapp/admin`;
$is_admin = ($? &gt;&gt; 8) == 0;

if ($is_admin) {
  # Do something privileged...
}

# Later...
if ($is_admin) {
  # Do something else privileged...
}
</pre>
<p>The new authorization test depends on the identity that is running the program (<em>$username</em>) and the separate ruleset that determines whether that identity should be granted access to /myapp/admin, which is simply a label for a rule that might look like this:</p>
<pre>
&lt;acl_rule status="enabled"&gt;
  &lt;services&gt;
   &lt;service url_pattern="/myapp/admin"/&gt;
  &lt;/services&gt;

  &lt;rule order="allow,deny"&gt;
   &lt;allow&gt;
     user("%:admin")
   &lt;/allow&gt;
 &lt;/rule&gt;
&lt;/acl_rule&gt;
</pre>
<p>This rule grants access if and only if <em>$username</em> is a member of the <strong>DACS</strong> group named admin or is associated with that <strong>DACS</strong> role. Membership in that group can be changed dynamically, and can even be reduced to zero.</p><p>The important observation is that <em>the conditions that determine whether the user running this Perl code has administrative privileges are defined outside of the program and can be changed without modifying the code and often without even modifying access control rules</em>.</p><p>A few concepts that are used in this document are described elsewhere. Variables, variable namespaces, and expressions that are used in access control rules are discussed in \m[blue]<a href="../man5/dacs.exprs.5.html"><strong>dacs.exprs</strong>(5)</a></strong>\m[]\s-2\u[22]\d\s+2. Naming in <strong>DACS</strong> is discussed in \m[blue]<a href="../man1/dacs.1.html"><strong>dacs</strong>(1)</a></strong>\m[]\s-2\u[23]\d\s+2, and <strong>DACS</strong> groups and roles are covered in \m[blue]<a href="../man5/dacs.groups.5.html"><strong>dacs.groups</strong>(5)</a></strong>\m[]\s-2\u[24]\d\s+2.</p><p><strong>Security</strong></p><p>Clearly <strong>dacscheck</strong>, its caller, and the resources in question must be "isolated" from the user on whose behalf <strong>dacscheck</strong> is being run, otherwise the user could access the resources directly or subvert access control tests. Therefore, <strong>dacscheck</strong> and its caller must either be more privileged than the user on whose behalf it is being run or both programs must run in a secure context. This generally means that both <strong>dacscheck</strong> and its caller should be run in isolation from users (as on a remote server) or as an effective user ID different from the user&apos;s.</p><h3>Advantages</h3>
<p>Programs that perform authorization tests typically contain code like:</p><p>"If the current user has provided a suitable password, then execute the following code, otherwise do not", or</p><p>"If the current user is the administrator, do the following", or</p><p>"If the current user is allowed to perform an update operation, then show these menu items, otherwise do not show them"</p><p>Complicated applications can be littered with these kinds of tests, making them prone to bugs and security problems. Changes to security policies may involve modifications throughout an application or suite of applications. Also, password handling is often incorporated into such programs; because password management can require a significant implementation effort and is difficult to do securely, it seems wise to try to leverage existing implementations.</p><p>Compared to custom-coded solutions, <strong>dacscheck</strong> has many advantages:</p><p>Data-driven policies</p><p>As opposed to specially-written access control logic, data-driven (rule-based) functionality is superior because:</p><p>Access control rules are separate from code, so changes to a set of rules automatically applies to all uses of those rules throughout an application or set of applications; code does not need to be modified if the policy is changed.</p><p>Bug fixes and improvements to rules are automatically available to programs that use <strong>dacscheck</strong>; no recompilation of applications is necessary.</p><p>The person who administers the rules does not have to be the application&apos;s programmer (or even someone who understands the code), so delegating responsibility is much easier. This reduces the amount of programming required when changes are required, reduces code maintenance effort, and decreases the chance of error.</p><p>It is usually easier to understand (and express) a set of rules that describes an access control policy; code that implements the same policy will be more complex and difficult to understand, increasing the chance of error.</p><p>Programming Efficiency</p><p>Applications are simplified and programming time and effort are reduced because existing access control code (i.e., <strong>dacscheck</strong>) is reused.</p><p>Sophisticated rules can be constructed without having to write any code. <strong>DACS</strong> features are available, such as roles and groups, and can be used to construct simpler and more expressive authorization policies than are likely to be hand-coded.</p><p>Portability</p><p>Rules are platform independent, can be stored remotely from the applications that use them, and can potentially be evaluated remotely. <strong>dacscheck</strong> is available for a variety of platforms.</p><p>Increased Sharing</p><p>Rules can be shared and used in different situations and by different programs.</p><p>Flexibility</p><p>Because it does not rely on a web server, it can be used by virtually any CGI-based program.</p><p>With respect to <strong>DACS</strong>, it can be used in circumstances where the \m[blue]<strong>mod_auth_dacs</strong>\m[]\s-2\u[25]\d\s+2 module cannot be used with <strong>Apache</strong>, or where <strong>Apache</strong> cannot be used at all.</p><p>Because it is implemented as an ordinary command, <strong>dacscheck</strong> can be used from the command line or invoked from almost any script or program.</p><p>For CGI-based programs, <strong>dacscheck</strong> can be used without any assistance from a system administrator; e.g., it does not require a web server to be configured to provide authorization for a CGI program because all access control functionality is performed within the program.</p><p>Increased Security</p><p><strong>dacscheck</strong> neither performs authentication nor relies on any particular authentication method, so the authentication method can be changed without affecting the application&apos;s use of <strong>dacscheck</strong>. Any supported means of authentication can be used, not only the typical password-based method.</p><p>While the performance of <strong>dacscheck</strong> ought not to be a factor for many applications, the C/C++ API can be used where it is an issue. This API can be used to incorporate <strong>dacscheck</strong> functionality into compiled programs and extensible languages, such as <strong>Perl</strong>, <strong>Python</strong>, <strong>Tcl/Tk</strong>, and <strong>PHP</strong>.</p>
<h3>Identities</h3>
<p>The identity for which access is to be tested is given to the program or obtained by the program from its execution environment. This identity is converted into <strong>DACS&apos;s</strong> internal representation.</p><p>More than one identity can be specified; the check is made on behalf of the union of all the identities. If the identities bob and alice are specified, for instance, a rule that is satisfied by either identity may grant access.</p><p>If no identity is given, the check is made on behalf of an unauthenticated user.</p><p>An identity can be:</p><p>a login name that <strong>dacscheck</strong> maps to from the real or effective uid of the program (i.e., the user who is running the program);</p><p>a <strong>DACS</strong> user identity (e.g., :carol, DSS:bob, or EXAMPLE-COM::DEMO:alice, see \m[blue]<a href="../man1/dacs.1.html"><strong>dacs</strong>(1)</a></strong>\m[]\s-2\u[26]\d\s+2);</p><p>a simple name (bob is equivalent to :bob); or</p><p>a name expressed in the \m[blue]<strong>concise syntax</strong>\m[]\s-2\u[27]\d\s+2, which gives a username and, optionally, roles and attributes for the identity. Any identity that has expired is not used.</p><p><strong>Notes</strong></p><p><strong>dacscheck</strong> validates the syntax of an identity it is given, converts and expands it to the concise syntax if necessary, and then converts it into its internal representation for credentials. These credentials are destroyed when the program terminates.</p><p>Regardless of how it is specified, each identity must satisfy the syntactic requirements of a <strong>DACS</strong> user identity after this conversion and expansion (see \m[blue]<a href="../man1/dacs.1.html"><strong>dacs</strong>(1)</a></strong>\m[]\s-2\u[26]\d\s+2). If a login name is specified as an identity, for example, it must be valid as a component of a <strong>DACS</strong> user identity; therefore, it cannot contain any invalid characters.</p><p>If no IP address is provided for an identity, it is obtained from the <strong>REMOTE_ADDR</strong> environment variable when available, otherwise a default of 127.0.0.1 is used. The IP address associated with credentials is tested using the <strong>user()</strong> predicate.</p><p>If an identity that is being tested includes a federation name, since the default federation name is unlikely to be correct, it will probably be necessary to tell <strong>dacscheck</strong> which federation name to compare against using the <strong>-fn</strong> flag.</p><p>Here are some examples of identities that may follow the <strong>-i</strong> flag:</p>
<pre>
bob
:bob
DSS:bob
{u = bob}
{u="bob"}
{u="alice",g="admin"}
{u="DSS:bob",g="guest"}
{u="bob",a="a", g="guest"}
</pre>
<p><strong>Note</strong></p><p>This string may need to be quoted appropriately on the command line because the brace characters are significant to some shells; e.g.,</p>
<pre>
<strong>-i</strong> &apos;{u="bob"}&apos;
</pre>
<p><strong>Apache</strong> and other web servers set the environment variable <strong>REMOTE_USER</strong> to the authenticated identity that invoked a web service. Provided its syntax is suitable, this identity can be passed to <strong>dacscheck</strong>. For <strong>DACS</strong>-wrapped web services, <strong>DACS</strong> identities are available in this variable.</p><p>By default, the federation, jurisdiction, and hostnames associated with the rules are derived from the system&apos;s hostname as returned by \m[blue]<strong>gethostname</strong>(3)</strong>\m[]\s-2\u[28]\d\s+2. If that name is unsuitable because it is not a FQDN (i.e., it is not a fully-qualified domain name because it does not contain a period), each of the alias names is examined (using \m[blue]<a href="../man3/gethostbyname.3.html"><strong>gethostbyname</strong>(3)</a></strong>\m[]\s-2\u[29]\d\s+2) until a FQDN is found. The jurisdiction name comes from the left-most component of the selected FQDN and the federation domain and name come from the remaining components. If no FQDN is found, the system&apos;s hostname will be selected as the jurisdiction name and defaults will be used as the federation domain and name (EXAMPLE.COM and EXAMPLE-COM, respectively).</p><p>If the system&apos;s hostname is found to be (or explicitly given as) demo.example.com, for instance, the following variables will be set as indicated during rule evaluation:</p><p><em>${Conf::FEDERATION_NAME}</em> and <em>${DACS::FEDERATION}</em> are both set to EXAMPLE-COM (dots are mapped to dashes to form a valid name)</p><p><em>${Conf::FEDERATION_DOMAIN}</em> is set to EXAMPLE.COM</p><p><em>${Conf::JURISDICTION_NAME}</em> and <em>${DACS::JURISDICTION}</em> are set to the jurisdiction name, DEMO</p><p><em>${DACS::HTTP_HOST}</em> is set to demo.example.com:80</p><p>Often, rules and identities can be expressed such that the names chosen for the federation and jurisdiction are unimportant. When this is not the case, however, and the defaults chosen by <strong>dacscheck</strong> are incorrect, they can be set on the command line. In some circumstances it might be appropriate for the jurisdiction name to be the name of the application, for example.</p><p>Regardless of their origins, federation and jurisdiction names must always be syntactically valid (see \m[blue]<a href="../man1/dacs.1.html"><strong>dacs</strong>(1)</a></strong>\m[]\s-2\u[26]\d\s+2).</p>
<h3>Objects</h3>
<p>While an object will often be an actual thing, such as a file, menu, or variable, it can also be an abstraction, such as an operation. <strong>dacscheck</strong> works with names - in the form of URIs - rather than objects <em>per se</em>. <em>It does not associate any particular meaning with names, it merely uses them to locate an applicable access control rule</em>. Therefore, provided the rule writer and applications that consult the rules agree on the naming scheme, the names that are chosen are largely irrelevant.</p><p>An application assigns names to every object or class of objects that need to be referenced by access control rules. At its simplest, only one name is required (the name of the application, for example). In more complex situations, a wide variety of objects need to be named. The choice of names and the details of the naming hierarchy are up to the particular application, much like the organization of a software package&apos;s run-time file and directory organization depends on the particular package.</p><p>The <em>object</em> argument is the name that is matched against the services specified in access control rules. It can be either a URI or an absolute pathname (one that begins with a slash character), and either can have an optional query string component attached. An absolute pathname <em>path</em> is mapped internally to a URI as file://<em>path</em>; e.g., /myapp is interpreted as file:///myapp (see \m[blue]<strong>RFC 1738</strong>\m[]\s-2\u[30]\d\s+2).</p><p>The various components of the URI that names the object are available as <strong>DACS</strong> variables and environment variables (see below). If a query string is given, it is parsed and the individual arguments are made available to rules through the <em>Args</em> namespace, just as for <strong>DACS</strong>-wrapped web services.</p><p><strong>Note</strong></p><p>Only the <em>path</em> component of the URI is considered when <strong>DACS</strong> matches an object&apos;s name against the url_pattern of an access control rule. At present, the object name is not automatically canonicalized or resolved (see \m[blue]<strong>RFC 3986</strong>\m[]\s-2\u[31]\d\s+2), as is usually done by a web server, so relative path components such as "." and ".." should be avoided.</p>
<h3>Rule Evaluation Context</h3>
<p>Rules are evaluated within an execution context that may affect expression evaluation implicitly or may be examined explicitly through variables.</p><p>Since <strong>dacscheck</strong> does not consult the <strong>DACS</strong> configuration files, the <em>Conf</em> namespace is instantiated with few variables. At present, only the VFS directives are available in it.</p><p>The <em>Args</em> namespace is instantiated if an <em>object</em> argument has a query string component.</p><p>The <em>DACS</em> namespace is instantiated with a few standard variables (such as <em>${DACS::JURISDICTION}</em>) but can also be instantiated in various ways from the command line and from files.</p><p>The <em>Env</em> namespace is instantiated from the environment. Syntactically invalid variable names are silently ignored.</p><p>Many variables normally set by a web server are instantiated by <strong>dacscheck</strong> based on the object name. These variables are available in the <em>Env</em> and <em>DACS</em> namespaces. For example, if the object name is https://example.com:8443/myapp/edit-menu?entry=item1, the following variables will be set as indicated:</p>
<pre>
${Env::HTTPS}=on
${Env::SERVER_NAME}=example.com
${Env::SERVER_ADDR}=142.179.101.118
${Env::HTTP_HOST}=example.com:8443
${Env::SERVER_PORT}=8443
${Env::REQUEST_URI}=/myapp/edit-menu
${Env::DOCUMENT_ROOT}=/
${Env::REQUEST_METHOD}=GET
${Env::SERVER_SOFTWARE}=dacscheck-1.4.8b
${Env::QUERY_STRING}=entry=item1
${Env::ARG_COUNT}=1
${Env::CURRENT_URI}=/myapp/edit-menu?entry=item1
${Env::CURRENT_URI_NO_QUERY}=/myapp/edit-menu
</pre>
<p>Variables of the same name will also be set in the <em>DACS</em> namespace and exported as environment variables. The value of <em>${Args::entry}</em> will be item1. The request method defaults to GET. The variable <em>${Env::REMOTE_USER}</em> (and therefore <em>${DACS::REMOTE_USER}</em> and the environment variable <strong>REMOTE_USER</strong>) will be set based on the first identity specified on the command line; if no identity has been specified, this variable will be undefined.</p>
<h3>An Example Application</h3>
<p>To illustrate how the pieces fit together, let&apos;s consider a hypothetical (yet realistic) calendar application named <strong>cal</strong> that is written in <strong>Perl</strong> and invoked as a CGI program. We&apos;ll allow a user that has been authenticated by the web server to read, create, or update only her own calendars, unless the owner of a calendar gives her permission to perform a read or update operation on the calendar. Each owner can specify which users have access to her own calendar and the type(s) of access allowed.</p><p>This authorization policy can be specified fairly easily. One approach is to use:</p><p>A main rule that delegates responsibility for specifying a security policy for each user&apos;s calendars to that user.</p><p>Per-user, per-calendar rules that say which users can access a calendar and in what way or ways.</p><p>The program&apos;s administrator might collect all of the run-time files for the application in the directory /usr/local/cal and its subdirectories, and organize it as follows:</p><p>/usr/local/cal/rules/{acl-rule.0,acl-rule.1,...}</p><p>General rules for the application</p><p>/usr/local/cal/users/<em>username</em></p><p>Root directory for calendars owned by <em>username</em></p><p>/usr/local/cal/users/<em>username</em>/cal-1/data/*</p><p>Per-calendar data files</p><p>/usr/local/cal/users/<em>username</em>/rules/{acl-cal1.0,acl-cal2.0,...}</p><p>Per-calendar <strong>DACS</strong> access control files</p><p>/usr/local/cal/users/<em>username</em>/groups/*</p><p>Per-user <strong>DACS</strong> group lists, one per file</p><p>Given these naming conventions:</p><p>to test whether it should perform a particular operation, the application would call <strong>dacscheck</strong>, telling it to use the rules it finds in /usr/local/cal/rules.</p><p>the general rules for the application would delegate access control decisions for objects with names that match /users/<em>username</em>/* to access control rules found in the directory /usr/local/cal/users/<em>username</em>/rules. These rules would describe which users, if any, would be permitted to perform a given operation on the calendar.</p><p>the application would use object names of the form /users/<em>username</em>/cal-1?OP=<em>operation</em> as arguments to <strong>dacscheck</strong>. The ruleset for cal-1 would determine whether a given identity is allowed to perform the requested <em>operation</em> on the calendar. For example, alice (the owner) might be granted access regardless of the value of the <em>OP</em> argument, while bob might be granted access only if OP=read, and all others might be denied access. Later, alice might define a set of users that she names family and change the rule to allow any member of that group read and update access.</p><p>Users&apos; access control rules could themselves be under access control. A command line, GUI, or web interface would give the administrator and users the ability to manage rules.</p><p>See the \m[blue]<strong>EXAMPLES</strong>\m[]\s-2\u[32]\d\s+2 section for example rules.</p><p>This is by no means the only way to organize the calendars, and a delegation-based approach isn&apos;t required. The administrator might instead put all of the rules under a common directory, like /usr/local/cal/rules/acl-<em>username</em>.0/{acl-cal1.0,acl-cal2.0,...}, or put them closer to the calendar they are controlling, like /usr/local/cal/users/<em>username</em>/cal-1/acl-cal1.0.</p><p>Instead of testing whether an operation is permitted, rules can be written to return a constraint string that tells the caller what kind (or kinds) of access are permitted. The program&apos;s output line will include the constraint string within quotes.</p>
<h3>Comparing dacscheck with dacs_acs</h3>
<p>\m[blue]<a href="../man8/dacs_acs.8.html"><strong>dacs_acs</strong>(8)</a></strong>\m[]\s-2\u[8]\d\s+2 is the <strong>DACS</strong> component that is called by <strong>Apache</strong> (by the <strong>DACS</strong>\m[blue]<strong>mod_auth_dacs</strong>\m[]\s-2\u[25]\d\s+2 module, actually) to perform access control processing on web service requests. Its operation is normally invisible to web services; <strong>dacs_acs</strong> does all of its work before a web service is even executed or a web page is returned.</p><p><strong>dacscheck</strong> performs a function similar to the <strong>-check_only</strong> mode of operation of <strong>dacs_acs</strong> in that it simply returns an access control decision. There are important differences between the two programs, however.</p><p><strong>dacscheck</strong>:</p><p>is not a CGI program (though it can be called from one);</p><p>does not require \m[blue]<strong>mod_auth_dacs</strong>\m[]\s-2\u[25]\d\s+2;</p><p>does not use any <strong>DACS</strong> configuration files;</p><p>does not directly interact with a web server or any other <strong>DACS</strong> programs; and</p><p>runs at the privilege level of the user invoking it rather than the privilege level of <strong>Apache</strong>.</p><p>While <strong>dacscheck</strong> uses ordinary <strong>DACS</strong> access control rules (\m[blue]<a href="../man5/dacs.acls.5.html"><strong>dacs.acls</strong>(5)</a></strong>\m[]\s-2\u[7]\d\s+2), unlike most <strong>DACS</strong> commands it does not consult any <strong>DACS</strong> configuration files. The evaluation environment for access control rules is <em>similar</em> to that of web service testing, but it is not identical since there need not be a web server in the picture. Other than the attributes related to constraints, attributes such as pass_credentials have no meaning to <strong>dacscheck</strong>.</p><p>Use and configuration of <strong>DACS</strong> by <strong>dacscheck</strong> is greatly simplified because no real federation or jurisdictions are defined; a completely self-contained environment is created so that a single program or set of related programs can perform both course-grained and fine-grained access control tests. No federation or jurisdiction cryptographic keys are used, and no real <strong>DACS</strong> credentials are created. Federation and jurisdiction names are instantiated, but those who write rules will often not need to be aware of them.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONS</h2>
        <div class="sectioncontent">
<p>The arguments are processed as they are examined (left-to-right) and their ordering can be significant; for example, values established by the <strong>-fh</strong> flag may affect options that follow it, such as those that use string interpolation. Exactly one <em>object</em> argument is required.</p><p><strong>-admin</strong></p><p>All identities that follow on the command line are <strong>DACS</strong> identities that satisfy the <strong>dacs_admin()</strong> function. Refer to the ADMIN_IDENTITY configuration directive in \m[blue]<strong>dacs.conf</strong>(5)</strong>\m[]\s-2\u[33]\d\s+2 and the "a" attribute for identities.</p><p><strong>-app </strong><strong></strong><em>appname</em></p><p>Specify an application name to be used to construct default paths (see the <strong>-rules</strong> and <strong>-groups</strong> flags).</p><p><strong>-context</strong> <em>file</em></p><p>Variable definitions for the <em>DACS</em> namespace are read, one per line, in the format <em>name</em>=<em>value</em> (with optional quotes around the <em>value</em>). The <em>name</em> must be syntactically valid. If <em>file</em> is <strong>-</strong>, the standard input is read. For example, if <em>file</em> contains the two lines:</p>
<pre>
FOO=one
BAZ=two
</pre>
<p>then within access control rules <em>${DACS::FOO}</em> will have the value "one" and <em>${DACS::BAZ}</em> will have the value "two". This flag may be repeated, although the standard input can be read only once.</p><p><strong>-D</strong><em>name=value</em></p><p>This is equivalent to <strong>-var</strong><em>name=value</em>.</p><p><strong>-dump</strong></p><p>Perform all initializations, display the evaluation context, and then exit.</p><p><strong>-F</strong> <em>field_sep</em></p><p>When roles are looked up, use the character <em>field_sep</em> as the field separator character instead of the default. For details, refer to the description of the VFS directive in \m[blue]<strong>dacs.conf</strong>(5)</strong>\m[]\s-2\u[34]\d\s+2.</p><p><strong>Note</strong></p><p>Note that only the first occurrence of the character (from left to right) is treated as the separator character.</p><p><strong>-fd</strong> <em>domain</em></p><p>Use <em>domain</em> as the domain name for the federation. It must be syntactically valid.</p><p><strong>-fh</strong> <em>hostname</em></p><p>Use <em>hostname</em>, a fully-qualified domain name, as the system&apos;s hostname and to derive the federation and jurisdiction names. It must be syntactically valid.</p><p><strong>-fj</strong> <em>jurname</em></p><p>Use <em>jurname</em> as the jurisdiction name. It must be syntactically valid.</p><p><strong>-fn</strong> <em>fedname</em></p><p>Use <em>fedname</em> as the federation name. It must be syntactically valid.</p><p><strong>-groups</strong> <em>group_vfs</em></p><p>By default, <strong>dacscheck</strong> expects to find <strong>DACS</strong> group definitions rooted in the directory dacscheck/groups relative to DACS_HOME (e.g., /usr/local/dacs/dacscheck/groups), or if <strong>-app </strong><strong></strong><em>appname</em> is given, rooted in the directory dacscheck/<em>appname</em>/groups relative to DACS_HOME (e.g., /usr/local/dacs/dacscheck/myapp/groups) This flag specifies a different location. It can be an absolute pathname (which will be string interpolated - see \m[blue]<strong>dacs.conf</strong>(5)</strong>\m[]\s-2\u[35]\d\s+2) or a URI in the syntax of the \m[blue]<strong>VFS</strong>\m[]\s-2\u[34]\d\s+2 configuration directive. Examples:</p>
<pre>
-groups "[groups]dacs-fs:/local/groups"
-groups /home/bob/mygroups
</pre>
<p>By default, a reference to the group %FOO:people will be mapped to a file named people.grp within the directory FOO relative to the <strong>DACS</strong> group directory.</p><p><strong>-h</strong></p><p>Prints the usage blurb.</p><p><strong>-i</strong> <em>ident</em></p><p>The given identity is added to the set of identities in effect during checking. This identity does not necessarily have an account on the system. If <em>ident</em> is the empty string, however, the flag has no effect; this is convenient behaviour when the flag is used like <strong>-i ${Env::REMOTE_USER:-""}</strong>, for example, where <strong>REMOTE_USER</strong> may not have been set.</p><p><strong>-icgi</strong></p><p>If the environment variable <strong>REMOTE_USER</strong> is set to a valid simple name or <strong>DACS</strong> identity, it is added to the set of identities in effect during checking. If the variable is not set or is invalid, this flag has no effect.</p><p><strong>-icgig</strong></p><p>Like the <strong>-icgi</strong> flag, except any roles associated with the username will be added.</p><p><strong>-il</strong> <em>ident</em></p><p>The given identity is "local" and must correspond to an account on the system; if the <strong>-groups</strong> flag is in effect, the account&apos;s group membership will be added as roles to <em>ident</em>.</p><p><strong>-ilg</strong> <em>ident</em></p><p>Like the <strong>-ilg</strong> flag, except the account&apos;s group membership will be added as roles to <em>ident</em> regardless of whether the <strong>-groups</strong> flag is in effect.</p><p><strong>-ieuid</strong></p><p>The effective uid of the program is added to the set of identities. If the <strong>-groups</strong> flag is in effect, the account&apos;s group membership will be added as roles to <em>ident</em>.</p><p><strong>-ieuidg</strong></p><p>The effective uid of the program is added to the set of identities. The account&apos;s group membership will be added as roles to <em>ident</em> regardless of whether the <strong>-groups</strong> flag is in effect.</p><p><strong>-iuid</strong></p><p>The real uid of the program is added to the set of identities. If the <strong>-groups</strong> flag is in effect, the account&apos;s group membership will be added as roles to <em>ident</em>.</p><p><strong>-iuidg</strong></p><p>The real uid of the program is added to the set of identities. The account&apos;s group membership will be added as roles to <em>ident</em> regardless of whether the <strong>-groups</strong> flag is in effect.</p><p><strong>-lg</strong></p><p>For each local identity that follows on the command line, use its Unix group membership to the identity&apos;s roles.</p><p><strong>-ll</strong> <em>log_level</em></p><p>Set the debugging output level to <em>log_level</em> (see \m[blue]<a href="../man1/dacs.1.html"><strong>dacs</strong>(1)</a></strong>\m[]\s-2\u[23]\d\s+2). The default level is warn, and the <strong>-v</strong> flag bumps the level to debug or trace.</p><p><strong>-name_compare</strong> <em>method</em></p><p>Exactly like the \m[blue]<strong>NAME_COMPARE</strong>\m[]\s-2\u[36]\d\s+2 directive, set the default method used to compare DACS names in various contexts to <em>method</em>, which may be (case-insensitively) case, nocase, or default.</p><p><strong>-q</strong></p><p>Be quiet, except for error messages; the outcome will not be printed to stdout. The <strong>-v</strong> and <strong>-ll</strong> flags are independent of this.</p><p><strong>-redirect</strong></p><p>If access is denied and the applicable rule calls \m[blue]<strong>redirect()</strong>\m[]\s-2\u[37]\d\s+2 with the BY_SIMPLE_REDIRECT argument, then the specified URL is printed to stdout. This flag enables the <strong>-q</strong> flag.</p><p><strong>-roles</strong> <em>roles_vfs</em></p><p>Roles for each identity that follows on the command line will be looked up using <em>roles_vfs</em>. It can be an absolute pathname (which will be string interpolated - see \m[blue]<strong>dacs.conf</strong>(5)</strong>\m[]\s-2\u[35]\d\s+2) or a URI in the syntax of the \m[blue]<strong>VFS</strong>\m[]\s-2\u[34]\d\s+2 configuration directive. If any roles are found, they will be added to any other roles specified for the user (whether explicitly listed or obtained from Unix group membership). For example, if /usr/local/myapp/roles contains:</p>
<pre>
bobo:users
auggie:admin,users
harley:guest
</pre>
<p>then the command line:</p>
<pre>
% dacscheck -roles /usr/local/myapp/roles -i auggie /myapp/admin
</pre>
<p>will test access for the identity {u="auggie",g="admin,users"}.</p><p><strong>-rules</strong> <em>rule_vfs</em></p><p>By default, <strong>dacscheck</strong> expects to use a ruleset rooted in the directory dacscheck/acls relative to DACS_HOME (e.g., /usr/local/dacs/dacscheck/acls), or if the flag <strong>-app </strong><strong></strong><em>appname</em> is given, rooted in the directory dacscheck/<em>appname</em>/acls relative to DACS_HOME (e.g., /usr/local/dacs/dacscheck/myapp/acls). This flag specifies a different ruleset to be used. It can be an absolute pathname (which will be string interpolated - see \m[blue]<strong>dacs.conf</strong>(5)</strong>\m[]\s-2\u[35]\d\s+2) or a URI in the syntax of the \m[blue]<strong>VFS</strong>\m[]\s-2\u[34]\d\s+2 configuration directive. Examples:</p>
<pre>
-rules "[acls1]dacs-fs:/local/acls"
-rules /usr/local/myrules
</pre>
<p>This flag may be repeated; rulesets will examined in the order in which they are specified on the command line.</p><p><strong>-v</strong></p><p>Increase the level of debugging output. The flag may be repeated.</p><p><strong>-var</strong> <em>name=value</em></p><p>Like the <strong>-context</strong> flag, this adds a variable definition to the <em>DACS</em> namespace. The variable <em>DACS::</em><em></em><em>name</em> will be assigned the string <em>value</em>. The <em>name</em> must be syntactically valid. This flag may be repeated.</p><p><strong>-vfs</strong> <em>vfs_uri</em></p><p>Add <em>vfs_uri</em> as a \m[blue]<strong>VFS</strong>\m[]\s-2\u[34]\d\s+2 configuration directive. This flag may be repeated, with later occurrences having a higher "priority" than earlier ones (just as if they appeared later in dacs.conf; see \m[blue]<strong>dacs.conf</strong>(5)</strong>\m[]\s-2\u[33]\d\s+2).</p><p><strong>--</strong></p><p>This marks the end of the flag arguments.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>To illustrate how <strong>dacscheck</strong> might be used with real applications, here are some examples. The first few continue with the hypothetical calendar application described earlier.</p><p>The file /usr/local/cal/rules/acl-rule.0 might look like:</p>
<pre>
&lt;acl_rule status="enabled"&gt;
 &lt;services&gt;
  &lt;delegate url_pattern="/users/alice/*"
          rule_uri="/usr/local/cal/users/alice/rules/&gt;
  &lt;delegate url_pattern="/users/bob/*"
          rule_uri="/usr/local/cal/users/bob/rules/&gt;
  &lt;service url_pattern="/usr/local/cal/bin/*"/&gt;
 &lt;/services&gt;

 &lt;rule order="allow,deny"&gt;
   &lt;allow&gt;
      user("auth")
   &lt;/allow&gt;
 &lt;/rule&gt;
&lt;/acl_rule&gt;
</pre>
<p>This rule redirects requests for a particular user&apos;s calendar to that user&apos;s access control rules. It also says that access to the application&apos;s binaries is restricted to authenticated users. The application might issue a command such as:</p>
<pre>
% dacscheck -i $REMOTE_USER -rules /usr/local/cal/rules <em>object</em>
</pre>
<p>which will return an exit status of 0 if <strong>REMOTE_USER</strong> is granted access to <em>object</em>; otherwise an exit status of 1 will be returned. A better choice is to use the command:</p>
<pre>
% dacscheck -icgi -rules /usr/local/cal/rules <em>object</em>
</pre>
<p>which will leave the user unauthenticated if <strong>REMOTE_USER</strong> is unset or invalid.</p><p>The file /usr/local/cal/users/alice/rules/acl-cal1.0 contains the rule for user alice&apos;s "Calendar 1" and might look like:</p>
<pre>
&lt;acl_rule status="enabled"&gt;
 &lt;services&gt;
  &lt;service url_pattern="/users/alice/cal-1/*"/&gt;
 &lt;/services&gt;

 &lt;rule order="allow,deny"&gt;
   &lt;precondition&gt;
     &lt;predicate&gt; user(":alice") &lt;/predicate&gt;
   &lt;/precondition&gt;
   &lt;allow&gt;
     <strong>return</strong>(1)
   &lt;/allow&gt;
 &lt;/rule&gt;

 &lt;rule order="allow,deny"&gt;
   &lt;precondition&gt;
     &lt;predicate&gt; ${Args::OP} eq "read" &lt;/predicate&gt;
   &lt;/precondition&gt;
   &lt;allow&gt;
     user(":bob")
   &lt;/allow&gt;
 &lt;/rule&gt;

&lt;/acl_rule&gt;
</pre>
<p>This rule says that alice is allowed full access to the calendar (there is no restriction on the operation), but bob only has read access. <strong>dacscheck</strong> would be called with /users/alice/cal-1?OP=create, /users/alice/cal-1?OP=update, or /users/alice/cal-1?OP=read to test for authorization to perform a create, update, or read operation on the calendar, respectively.</p><p>If alice defines a <strong>DACS</strong> group that she calls family and adds the names julia and auggie to that group, she might modify the rule above by adding the following:</p>
<pre>
&lt;rule order="allow,deny"&gt;
   &lt;precondition&gt;
     &lt;predicate&gt; ${Args::OP} eq "read"
             or ${Args::OP} eq "update"&lt;/predicate&gt;
   &lt;/precondition&gt;
   &lt;allow&gt;
     user("%:alice-family")
   &lt;/allow&gt;
 &lt;/rule&gt;
</pre>
<p>This rule says that any member of the group alice-family is allowed read and update access to this calendar. The command:</p>
<pre>
% dacscheck -i julia /users/alice/cal-1?OP=update
</pre>
<p>would report that access is granted.</p><p>The membership of alice&apos;s group called alice-family might be specified in the file /usr/local/cal/users/alice/groups/family</p>
<pre>
&lt;acl_rule status="enabled"&gt;
 &lt;services&gt;
  &lt;service url_pattern="/users/alice/groups/*"/&gt;
 &lt;/services&gt;

 &lt;rule order="allow,deny"&gt;
   &lt;precondition&gt;
     &lt;predicate&gt; user(":alice") &lt;/predicate&gt;
   &lt;/precondition&gt;
   &lt;allow&gt;
     <strong>return</strong>(1)
   &lt;/allow&gt;
 &lt;/rule&gt;
&lt;/acl_rule&gt;
</pre>
<p>This rule allows only alice to manage the membership of this group, but she is free modify the rule to allow others to manage her groups.</p><p>As a final example for this application, alice&apos;s rules might also be under access control:</p>
<pre>
&lt;acl_rule status="enabled"&gt;
 &lt;services&gt;
  &lt;service url_pattern="/users/alice/groups/*"/&gt;
 &lt;/services&gt;

 &lt;rule order="allow,deny"&gt;
   &lt;precondition&gt;
     &lt;predicate&gt; user(":alice") &lt;/predicate&gt;
   &lt;/precondition&gt;
   &lt;allow&gt;
     <strong>return</strong>(1)
   &lt;/allow&gt;
 &lt;/rule&gt;
&lt;/acl_rule&gt;
</pre>
<p>This rule allows only alice to manage the membership of this group, but she is free modify the rule to allow others to manage her groups.</p><p>A popular open source web log analyzer program, written in Perl, can be invoked as a CGI program. The program includes security provisions whereby it can restrict access to any user authenticated by the web server, by username (using <strong>REMOTE_USER</strong>, as exported by the web server), or based on the user&apos;s IP address (using <strong>REMOTE_ADDR</strong>). The approximately 40 lines of code (plus assorted initializations) that implements this security policy can essentially be replaced by just a few lines of code:</p>
<pre>
my $exit_value = 0;
system "/usr/local/dacs/bin/dacscheck", "-q", "-icgi", "-rules",
   "/usr/local/webstats/acls", "/webstats";
$exit_value  = $? &gt;&gt; 8;
# print "dacscheck returned $exit_value for user &#92;"$remote_user&#92;"&#92;n";
if ($exit_value != 0) {
  # dacscheck denies access; print message and exit
  exit 1;
}

# dacscheck grants access, so continue
</pre>
<p><strong>Tip</strong></p><p>The <strong>DACS</strong> distribution includes a Perl module (/usr/local/dacs/lib/perl/DACScheck.pm) to make <strong>dacscheck</strong> a little easier to use. The example above would be written as:</p>
<pre>
use DACScheck.pm;
dacscheck_rules("/usr/local/webstats/acls");

my $result = dacscheck_cgi("/webstats");
if ($result != 1) {
  # dacscheck denies access; print message and exit
  exit 1;
}

# dacscheck grants access, so continue

</pre>
<p>A simple <strong>DACS</strong> access control rule can be written to duplicate the program&apos;s security functionality (using the <strong>user()</strong> and <strong>from()</strong> predicates, see \m[blue]<a href="../man5/dacs.exprs.5.html"><strong>dacs.exprs</strong>(5)</a></strong>\m[]\s-2\u[22]\d\s+2), but more sophisticated policies can be added easily, all without having to modify the Perl program again.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DIAGNOSTICS</h2>
        <div class="sectioncontent">
<p>The program exits 0 if access is granted and 1 if access is denied. Any other exit status indicates an error occurred.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>A lightweight method of defining <strong>DACS</strong> groups is needed. Once the internal are stable, this program&apos;s functionality will be made available through a C/C++ API, which will permit direct, efficient use by other applications and extensible languages (through <strong>perlxs</strong>(1)</strong>, for example).</p><p>The \m[blue]<strong>DACS_ACS argument</strong>\m[]\s-2\u[38]\d\s+2 is not recognized by <strong>dacscheck</strong>.</p><p>Identities are not considered when roles are looked up; only the username is matched.</p><p>Unlike \m[blue]<a href="../man8/dacs_acs.8.html"><strong>dacs_acs</strong>(8)</a></strong>\m[]\s-2\u[8]\d\s+2, there is no support for automatically setting variables by parsing a message body (a MIME document).</p><p>It might be possible to create a layer between an application and the underlying system so that <strong>dacscheck</strong> can be called transparently, or nearly so.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO dacscheck&hellip;</h2>
        <div class="sectioncontent">
<p>See \m[blue]<a href="../man1/dacs.1.html"><strong>dacs</strong>(1)</a></strong>\m[]\s-2\u[23]\d\s+2, \m[blue]<a href="../man1/dacsacl.1.html"><strong>dacsacl</strong>(1)</a></strong>\m[]\s-2\u[9]\d\s+2, \m[blue]<a href="../man5/dacs.acls.5.html"><strong>dacs.acls</strong>(5)</a></strong>\m[]\s-2\u[7]\d\s+2, \m[blue]<strong>dacs.conf</strong>(5)</strong>\m[]\s-2\u[33]\d\s+2, \m[blue]<a href="../man5/dacs.exprs.5.html"><strong>dacs.exprs</strong>(5)</a></strong>\m[]\s-2\u[22]\d\s+2, \m[blue]<a href="../man5/dacs.groups.5.html"><strong>dacs.groups</strong>(5)</a></strong>\m[]\s-2\u[24]\d\s+2, \m[blue]<a href="../man7/dacs.java.7.html"><strong>dacs.java</strong>(7)</a></strong>\m[]\s-2\u[39]\d\s+2.</p><p>\m[blue]<strong>Rule-based access control</strong>\m[]\s-2\u[40]\d\s+2</p><p>DACScheck.pm</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Distributed Systems Software (\m[blue]<strong>www.dss.ca</strong>\m[]\s-2\u[41]\d\s+2)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYING</h2>
        <div class="sectioncontent">
<p>Copyright2003-2013 Distributed Systems Software. See the \m[blue]<strong>LICENSE</strong>\m[]\s-2\u[42]\d\s+2 file that accompanies the distribution for licensing information.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTES</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
     1.
  </dt>
  <dd>
    <p>Perl</p><p>http://www.perl.org/</p>
  </dd>
  <dt>
     2.
  </dt>
  <dd>
    <p>PHP</p><p>http://www.php.net/</p>
  </dd>
  <dt>
     3.
  </dt>
  <dd>
    <p>Python</p><p>http://www.python.org</p>
  </dd>
  <dt>
     4.
  </dt>
  <dd>
    <p>Ruby</p><p>http://www.ruby-lang.org</p>
  </dd>
  <dt>
     5.
  </dt>
  <dd>
    <p>Tcl/Tk</p><p>http://www.tcl.tk/software/</p>
  </dd>
  <dt>
     6.
  </dt>
  <dd>
    <p><a href="../man2/geteuid.2.html"><strong>geteuid</strong>(2)</a></p><p>http://www.freebsd.org/cgi/man.cgi?query=geteuid&apropos=0&sektion=2&manpath=FreeBSD+9.1-RELEASE&format=html</p>
  </dd>
  <dt>
     7.
  </dt>
  <dd>
    <p><a href="../man5/dacs.acls.5.html"><strong>dacs.acls</strong>(5)</a></p><p>http://dacs.dss.ca/man/dacs.acls.5.html</p>
  </dd>
  <dt>
     8.
  </dt>
  <dd>
    <p><a href="../man8/dacs_acs.8.html"><strong>dacs_acs</strong>(8)</a></p><p>http://dacs.dss.ca/man/dacs_acs.8.html</p>
  </dd>
  <dt>
     9.
  </dt>
  <dd>
    <p><a href="../man1/dacsacl.1.html"><strong>dacsacl</strong>(1)</a></p><p>http://dacs.dss.ca/man/dacsacl.1.html</p>
  </dd>
  <dt>
    10.
  </dt>
  <dd>
    <p><a href="../man1/getfacl.1.html"><strong>getfacl</strong>(1)</a></p><p>http://www.freebsd.org/cgi/man.cgi?query=getfacl&apropos=0&sektion=1&manpath=FreeBSD+9.1-RELEASE&format=html</p>
  </dd>
  <dt>
    11.
  </dt>
  <dd>
    <p><a href="../man1/setfacl.1.html"><strong>setfacl</strong>(1)</a></p><p>http://www.freebsd.org/cgi/man.cgi?query=setfacl&apropos=0&sektion=1&manpath=FreeBSD+9.1-RELEASE&format=html</p>
  </dd>
  <dt>
    12.
  </dt>
  <dd>
    <p><strong>acl</strong>(3)</p><p>http://www.freebsd.org/cgi/man.cgi?query=acl&apropos=0&sektion=3&manpath=FreeBSD+9.1-RELEASE&format=html</p>
  </dd>
  <dt>
    13.
  </dt>
  <dd>
    <p><a href="../man1/htpasswd.1.html"><strong>htpasswd</strong>(1)</a></p><p>http://httpd.apache.org/docs/2.2/programs/htpasswd.html</p>
  </dd>
  <dt>
    14.
  </dt>
  <dd>
    <p>Using FreeBSD's ACLs</p><p>http://www.onlamp.com/pub/a/bsd/2005/09/22/FreeBSD_Basics.html</p>
  </dd>
  <dt>
    15.
  </dt>
  <dd>
    <p>ONLamp.com</p><p>http://www.onlamp.com</p>
  </dd>
  <dt>
    16.
  </dt>
  <dd>
    <p>POSIX ACLs in Linux</p><p>http://www.cs.unc.edu/cgi-bin/howto?howto=linux-posix-acls</p>
  </dd>
  <dt>
    17.
  </dt>
  <dd>
    <p>linux.com</p><p>http://linux.com</p>
  </dd>
  <dt>
    18.
  </dt>
  <dd>
    <p>Solaris 10 <strong>acl</strong>(2)</p><p>http://docs.sun.com/app/docs/doc/816-5167/6mbb2jaf2?a=view</p>
  </dd>
  <dt>
    19.
  </dt>
  <dd>
    <p>Sun Microsystems</p><p>http://www.sun.com</p>
  </dd>
  <dt>
    20.
  </dt>
  <dd>
    <p>Using Solaris ACLs</p><p>http://www.cs.duke.edu/csl/faqs/solaris-acls.php</p>
  </dd>
  <dt>
    21.
  </dt>
  <dd>
    <p>Dept. of Computer Science, Duke University</p><p>http://www.cs.duke.edu</p>
  </dd>
  <dt>
    22.
  </dt>
  <dd>
    <p><a href="../man5/dacs.exprs.5.html"><strong>dacs.exprs</strong>(5)</a></p><p>http://dacs.dss.ca/man/dacs.exprs.5.html</p>
  </dd>
  <dt>
    23.
  </dt>
  <dd>
    <p><a href="../man1/dacs.1.html"><strong>dacs</strong>(1)</a></p><p>http://dacs.dss.ca/man/dacs.1.html</p>
  </dd>
  <dt>
    24.
  </dt>
  <dd>
    <p><a href="../man5/dacs.groups.5.html"><strong>dacs.groups</strong>(5)</a></p><p>http://dacs.dss.ca/man/dacs.groups.5.html</p>
  </dd>
  <dt>
    25.
  </dt>
  <dd>
    <p>mod_auth_dacs</p><p>http://dacs.dss.ca/man/mod_auth_dacs.html</p>
  </dd>
  <dt>
    26.
  </dt>
  <dd>
    <p><a href="../man1/dacs.1.html"><strong>dacs</strong>(1)</a></p><p>http://dacs.dss.ca/man/dacs.1.html#naming</p>
  </dd>
  <dt>
    27.
  </dt>
  <dd>
    <p>concise syntax</p><p>http://dacs.dss.ca/man/dacs.1.html#concise_user_syntax</p>
  </dd>
  <dt>
    28.
  </dt>
  <dd>
    <p><strong>gethostname</strong>(3)</p><p>http://www.freebsd.org/cgi/man.cgi?query=gethostname&apropos=0&sektion=3&manpath=FreeBSD+9.1-RELEASE&format=html</p>
  </dd>
  <dt>
    29.
  </dt>
  <dd>
    <p><a href="../man3/gethostbyname.3.html"><strong>gethostbyname</strong>(3)</a></p><p>http://www.freebsd.org/cgi/man.cgi?query=gethostbyname&apropos=0&sektion=3&manpath=FreeBSD+9.1-RELEASE&format=html</p>
  </dd>
  <dt>
    30.
  </dt>
  <dd>
    <p>RFC 1738</p><p>http://www.rfc-editor.org/rfc/rfc1738.txt</p>
  </dd>
  <dt>
    31.
  </dt>
  <dd>
    <p>RFC 3986</p><p>http://www.rfc-editor.org/rfc/rfc3986.txt</p>
  </dd>
  <dt>
    32.
  </dt>
  <dd>
    <p>EXAMPLES</p><p>http://dacs.dss.ca/man/#EXAMPLES</p>
  </dd>
  <dt>
    33.
  </dt>
  <dd>
    <p><strong>dacs.conf</strong>(5)</p><p>http://dacs.dss.ca/man/dacs.conf.5.html</p>
  </dd>
  <dt>
    34.
  </dt>
  <dd>
    <p><strong>dacs.conf</strong>(5)</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#VFS</p>
  </dd>
  <dt>
    35.
  </dt>
  <dd>
    <p><strong>dacs.conf</strong>(5)</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#interpolation</p>
  </dd>
  <dt>
    36.
  </dt>
  <dd>
    <p>NAME_COMPARE</p><p>http://dacs.dss.ca/man/dacs.conf.5.html#NAME_COMPARE</p>
  </dd>
  <dt>
    37.
  </dt>
  <dd>
    <p>redirect()</p><p>http://dacs.dss.ca/man/dacs.exprs.5.html#redirect</p>
  </dd>
  <dt>
    38.
  </dt>
  <dd>
    <p>DACS_ACS argument</p><p>http://dacs.dss.ca/man/dacs_acs.8.html#dacs_acs_argument</p>
  </dd>
  <dt>
    39.
  </dt>
  <dd>
    <p><a href="../man7/dacs.java.7.html"><strong>dacs.java</strong>(7)</a></p><p>http://dacs.dss.ca/man/dacs.java.7.html</p>
  </dd>
  <dt>
    40.
  </dt>
  <dd>
    <p>Rule-based access control</p><p>http://www-128.ibm.com/developerworks/webservices/library/ws-soa-access.html</p>
  </dd>
  <dt>
    41.
  </dt>
  <dd>
    <p>www.dss.ca</p><p>http://www.dss.ca</p>
  </dd>
  <dt>
    42.
  </dt>
  <dd>
    <p>LICENSE</p><p>http://dacs.dss.ca/man/../misc/LICENSE</p>
  </dd>

</dl>

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="dacsauth.1.html"><span aria-hidden="true">&larr;</span> dacsauth.1: Authentication check</a></li>
   <li class="next"><a href="dacsconf.1.html">dacsconf.1: Display configuration directives <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

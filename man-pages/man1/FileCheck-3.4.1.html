<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>FileCheck-3.4: Flexible pattern matching file verifier</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Flexible pattern matching file verifier">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="FileCheck-3.4 (1) manual">
  <meta name="twitter:description" content="Flexible pattern matching file verifier">
  <meta name="twitter:image" content="https://www.carta.tech/images/llvm-3.4-FileCheck-3.4-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/FileCheck-3.4.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="FileCheck-3.4 (1) manual" />
  <meta property="og:description" content="Flexible pattern matching file verifier" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/llvm-3.4-FileCheck-3.4-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">FileCheck-3.4<small> (1)</small></h1>
        <p class="lead">Flexible pattern matching file verifier</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/FileCheck-3.4.1.html">
      <span itemprop="name">FileCheck-3.4: Flexible pattern matching file verifier</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/llvm-3.4/">
      <span itemprop="name">llvm-3.4</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/FileCheck-3.4.1.html">
      <span itemprop="name">FileCheck-3.4: Flexible pattern matching file verifier</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>FileCheck</strong> <em>match-filename</em> [<em>--check-prefix=XXX</em>] [<em>--strict-whitespace</em>]</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><strong>FileCheck</strong> reads two files (one from standard input, and one specified on the command line) and uses one to verify the other.  This behavior is particularly useful for the testsuite, which wants to verify that the output of some tool (e.g. <strong>llc</strong>) contains the expected information (for example, a movsd from esp or whatever is interesting).  This is similar to using <strong>grep</strong>, but it is optimized for matching multiple different inputs in one file in a specific order.</p><p>The <strong>match-filename</strong> file specifies the file that contains the patterns to match.  The file to verify is read from standard input unless the <em>--input-file</em> option is used.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>-help</strong></p>
  </dt>
  <dd>
    <p>Print a summary of command line options.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p><strong>--check-prefix prefix</strong></p>
  </dt>
  <dd>
    <p>FileCheck searches the contents of <strong>match-filename</strong> for patterns to match.  By default, these patterns are prefixed with "<strong>CHECK:</strong>". If you&apos;d like to use a different prefix (e.g. because the same input file is checking multiple different tool or options), the <em>--check-prefix</em> argument allows you to specify one or more prefixes to match. Multiple prefixes are useful for tests which might change for different run options, but most lines remain the same.</p>
  </dd>
  <dt>
    <p><strong>--input-file filename</strong></p>
  </dt>
  <dd>
    <p>File to check (defaults to stdin).</p>
  </dd>
  <dt>
    <p><strong>--strict-whitespace</strong></p>
  </dt>
  <dd>
    <p>By default, FileCheck canonicalizes input horizontal whitespace (spaces and tabs) which causes it to ignore these differences (a space will match a tab). The <em>--strict-whitespace</em> argument disables this behavior. End-of-line sequences are canonicalized to UNIX-style <strong>&#92;n</strong> in all modes.</p>
  </dd>
  <dt>
    <p><strong>-version</strong></p>
  </dt>
  <dd>
    <p>Show the version number of this program.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXIT STATUS</h2>
        <div class="sectioncontent">
<p>If <strong>FileCheck</strong> verifies that the file matches the expected contents, it exits with 0.  Otherwise, if not, or if an error occurs, it will exit with a non-zero value.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TUTORIAL</h2>
        <div class="sectioncontent">
<p>FileCheck is typically used from LLVM regression tests, being invoked on the RUN line of the test.  A simple example of using FileCheck from a RUN line looks like this:</p>
<pre>
; RUN: llvm-as &lt; %s | llc -march=x86-64 | FileCheck %s
</pre>
<p>This syntax says to pipe the current file ("<strong>%s</strong>") into <strong>llvm-as</strong>, pipe that into <strong>llc</strong>, then pipe the output of <strong>llc</strong> into <strong>FileCheck</strong>.  This means that FileCheck will be verifying its standard input (the llc output) against the filename argument specified (the original <strong>.ll</strong> file specified by "<strong>%s</strong>").  To see how this works, let&apos;s look at the rest of the <strong>.ll</strong> file (after the RUN line):</p>
<pre>
define void @sub1(i32* %p, i32 %v) {
entry:
; CHECK: sub1:
; CHECK: subl
        %0 = tail call i32 @llvm.atomic.load.sub.i32.p0i32(i32* %p, i32 %v)
        ret void
}

define void @inc4(i64* %p) {
entry:
; CHECK: inc4:
; CHECK: incq
        %0 = tail call i64 @llvm.atomic.load.add.i64.p0i64(i64* %p, i64 1)
        ret void
}
</pre>
<p>Here you can see some "<strong>CHECK:</strong>" lines specified in comments.  Now you can see how the file is piped into <strong>llvm-as</strong>, then <strong>llc</strong>, and the machine code output is what we are verifying.  FileCheck checks the machine code output to verify that it matches what the "<strong>CHECK:</strong>" lines specify.</p><p>The syntax of the "<strong>CHECK:</strong>" lines is very simple: they are fixed strings that must occur in order.  FileCheck defaults to ignoring horizontal whitespace differences (e.g. a space is allowed to match a tab) but otherwise, the contents of the "<strong>CHECK:</strong>" line is required to match some thing in the test file exactly.</p><p>One nice thing about FileCheck (compared to grep) is that it allows merging test cases together into logical groups.  For example, because the test above is checking for the "<strong>sub1:</strong>" and "<strong>inc4:</strong>" labels, it will not match unless there is a "<strong>subl</strong>" in between those labels.  If it existed somewhere else in the file, that would not count: "<strong>grep subl</strong>" matches if "<strong>subl</strong>" exists anywhere in the file.</p><h3>The FileCheck -check-prefix option</h3>
<p>The FileCheck <em>-check-prefix</em> option allows multiple test configurations to be driven from one <em>.ll</em> file.  This is useful in many circumstances, for example, testing different architectural variants with <strong>llc</strong>.  Here&apos;s a simple example:</p>
<pre>
; RUN: llvm-as &lt; %s | llc -mtriple=i686-apple-darwin9 -mattr=sse41 &#92;
; RUN:              | FileCheck %s -check-prefix=X32
; RUN: llvm-as &lt; %s | llc -mtriple=x86_64-apple-darwin9 -mattr=sse41 &#92;
; RUN:              | FileCheck %s -check-prefix=X64

define &lt;4 x i32&gt; @pinsrd_1(i32 %s, &lt;4 x i32&gt; %tmp) nounwind {
        %tmp1 = insertelement &lt;4 x i32&gt;; %tmp, i32 %s, i32 1
        ret &lt;4 x i32&gt; %tmp1
; X32: pinsrd_1:
; X32:    pinsrd $1, 4(%esp), %xmm0

; X64: pinsrd_1:
; X64:    pinsrd $1, %edi, %xmm0
}
</pre>
<p>In this case, we&apos;re testing that we get the expected code generation with both 32-bit and 64-bit code generation.</p>
<h3>The CHECK-NEXT: directive</h3>
<p>Sometimes you want to match lines and would like to verify that matches happen on exactly consecutive lines with no other lines in between them.  In this case, you can use "<strong>CHECK:</strong>" and "<strong>CHECK-NEXT:</strong>" directives to specify this.  If you specified a custom check prefix, just use "<strong>&lt;PREFIX&gt;-NEXT:</strong>". For example, something like this works as you&apos;d expect:</p>
<pre>
define void @t2(&lt;2 x double&gt;* %r, &lt;2 x double&gt;* %A, double %B) {
     %tmp3 = load &lt;2 x double&gt;* %A, align 16
     %tmp7 = insertelement &lt;2 x double&gt; undef, double %B, i32 0
     %tmp9 = shufflevector &lt;2 x double&gt; %tmp3,
                            &lt;2 x double&gt; %tmp7,
                            &lt;2 x i32&gt; &lt; i32 0, i32 2 &gt;
     store &lt;2 x double&gt; %tmp9, &lt;2 x double&gt;* %r, align 16
     ret void

; CHECK:          t2:
; CHECK:             movl    8(%esp), %eax
; CHECK-NEXT:        movapd  (%eax), %xmm0
; CHECK-NEXT:        movhpd  12(%esp), %xmm0
; CHECK-NEXT:        movl    4(%esp), %eax
; CHECK-NEXT:        movapd  %xmm0, (%eax)
; CHECK-NEXT:        ret
}
</pre>
<p>"<strong>CHECK-NEXT:</strong>" directives reject the input unless there is exactly one newline between it and the previous directive.  A "<strong>CHECK-NEXT:</strong>" cannot be the first directive in a file.</p>
<h3>The CHECK-NOT: directive</h3>
<p>The "<strong>CHECK-NOT:</strong>" directive is used to verify that a string doesn&apos;t occur between two matches (or before the first match, or after the last match).  For example, to verify that a load is removed by a transformation, a test like this can be used:</p>
<pre>
define i8 @coerce_offset0(i32 %V, i32* %P) {
  store i32 %V, i32* %P

  %P2 = bitcast i32* %P to i8*
  %P3 = getelementptr i8* %P2, i32 2

  %A = load i8* %P3
  ret i8 %A
; CHECK: @coerce_offset0
; CHECK-NOT: load
; CHECK: ret i8
}
</pre>

<h3>The CHECK-DAG: directive</h3>
<p>If it&apos;s necessary to match strings that don&apos;t occur in a strictly sequential order, "<strong>CHECK-DAG:</strong>" could be used to verify them between two matches (or before the first match, or after the last match). For example, clang emits vtable globals in reverse order. Using <strong>CHECK-DAG:</strong>, we can keep the checks in the natural order:</p>
<pre>
// RUN: %clang_cc1 %s -emit-llvm -o - | FileCheck %s

struct Foo { virtual void method(); };
Foo f;  // emit vtable
// CHECK-DAG: @_ZTV3Foo =

struct Bar { virtual void method(); };
Bar b;
// CHECK-DAG: @_ZTV3Bar =
</pre>
<p><strong>CHECK-NOT:</strong> directives could be mixed with <strong>CHECK-DAG:</strong> directives to exclude strings between the surrounding <strong>CHECK-DAG:</strong> directives. As a result, the surrounding <strong>CHECK-DAG:</strong> directives cannot be reordered, i.e. all occurrences matching <strong>CHECK-DAG:</strong> before <strong>CHECK-NOT:</strong> must not fall behind occurrences matching <strong>CHECK-DAG:</strong> after <strong>CHECK-NOT:</strong>. For example,</p>
<pre>
; CHECK-DAG: BEFORE
; CHECK-NOT: NOT
; CHECK-DAG: AFTER
</pre>
<p>This case will reject input strings where <strong>BEFORE</strong> occurs after <strong>AFTER</strong>.</p><p>With captured variables, <strong>CHECK-DAG:</strong> is able to match valid topological orderings of a DAG with edges from the definition of a variable to its use. It&apos;s useful, e.g., when your test cases need to match different output sequences from the instruction scheduler. For example,</p>
<pre>
; CHECK-DAG: add [[REG1:r[0-9]+]], r1, r2
; CHECK-DAG: add [[REG2:r[0-9]+]], r3, r4
; CHECK:     mul r5, [[REG1]], [[REG2]]
</pre>
<p>In this case, any order of that two <strong>add</strong> instructions will be allowed.</p><p>If you are defining <em>and</em> using variables in the same <strong>CHECK-DAG:</strong> block, be aware that the definition rule can match <em>after</em> its use.</p><p>So, for instance, the code below will pass:</p>
<pre>
; CHECK-DAG: vmov.32 [[REG2:d[0-9]+]][0]
; CHECK-DAG: vmov.32 [[REG2]][1]
vmov.32 d0[1]
vmov.32 d0[0]
</pre>
<p>While this other code, will not:</p>
<pre>
; CHECK-DAG: vmov.32 [[REG2:d[0-9]+]][0]
; CHECK-DAG: vmov.32 [[REG2]][1]
vmov.32 d1[1]
vmov.32 d0[0]
</pre>
<p>While this can be very useful, it&apos;s also dangerous, because in the case of register sequence, you must have a strong order (read before write, copy before use, etc). If the definition your test is looking for doesn&apos;t match (because of a bug in the compiler), it may match further away from the use, and mask real bugs away.</p><p>In those cases, to enforce the order, use a non-DAG directive between DAG-blocks.</p>
<h3>The CHECK-LABEL: directive</h3>
<p>Sometimes in a file containing multiple tests divided into logical blocks, one or more <strong>CHECK:</strong> directives may inadvertently succeed by matching lines in a later block. While an error will usually eventually be generated, the check flagged as causing the error may not actually bear any relationship to the actual source of the problem.</p><p>In order to produce better error messages in these cases, the "<strong>CHECK-LABEL:</strong>" directive can be used. It is treated identically to a normal <strong>CHECK</strong> directive except that FileCheck makes an additional assumption that a line matched by the directive cannot also be matched by any other check present in <strong>match-filename</strong>; this is intended to be used for lines containing labels or other unique identifiers. Conceptually, the presence of <strong>CHECK-LABEL</strong> divides the input stream into separate blocks, each of which is processed independently, preventing a <strong>CHECK:</strong> directive in one block matching a line in another block. For example,</p>
<pre>
define %struct.C* @C_ctor_base(%struct.C* %this, i32 %x) {
entry:
; CHECK-LABEL: C_ctor_base:
; CHECK: mov [[SAVETHIS:r[0-9]+]], r0
; CHECK: bl A_ctor_base
; CHECK: mov r0, [[SAVETHIS]]
  %0 = bitcast %struct.C* %this to %struct.A*
  %call = tail call %struct.A* @A_ctor_base(%struct.A* %0)
  %1 = bitcast %struct.C* %this to %struct.B*
  %call2 = tail call %struct.B* @B_ctor_base(%struct.B* %1, i32 %x)
  ret %struct.C* %this
}

define %struct.D* @D_ctor_base(%struct.D* %this, i32 %x) {
entry:
; CHECK-LABEL: D_ctor_base:
</pre>
<p>The use of <strong>CHECK-LABEL:</strong> directives in this case ensures that the three <strong>CHECK:</strong> directives only accept lines corresponding to the body of the <strong>@C_ctor_base</strong> function, even if the patterns match lines found later in the file. Furthermore, if one of these three <strong>CHECK:</strong> directives fail, FileCheck will recover by continuing to the next block, allowing multiple test failures to be detected in a single invocation.</p><p>There is no requirement that <strong>CHECK-LABEL:</strong> directives contain strings that correspond to actual syntactic labels in a source or output language: they must simply uniquely match a single line in the file being verified.</p><p><strong>CHECK-LABEL:</strong> directives cannot contain variable definitions or uses.</p>
<h3>FileCheck Pattern Matching Syntax</h3>
<p>The "<strong>CHECK:</strong>" and "<strong>CHECK-NOT:</strong>" directives both take a pattern to match. For most uses of FileCheck, fixed string matching is perfectly sufficient.  For some things, a more flexible form of matching is desired.  To support this, FileCheck allows you to specify regular expressions in matching strings, surrounded by double braces: <strong>{{yourregex}}</strong>.  Because we want to use fixed string matching for a majority of what we do, FileCheck has been designed to support mixing and matching fixed string matching with regular expressions. This allows you to write things like this:</p>
<pre>
; CHECK: movhpd      {{[0-9]+}}(%esp), {{%xmm[0-7]}}
</pre>
<p>In this case, any offset from the ESP register will be allowed, and any xmm register will be allowed.</p><p>Because regular expressions are enclosed with double braces, they are visually distinct, and you don&apos;t need to use escape characters within the double braces like you would in C.  In the rare case that you want to match double braces explicitly from the input, you can use something ugly like <strong>{{[{][{]}}</strong> as your pattern.</p>
<h3>FileCheck Variables</h3>
<p>It is often useful to match a pattern and then verify that it occurs again later in the file.  For codegen tests, this can be useful to allow any register, but verify that that register is used consistently later.  To do this, <strong>FileCheck</strong> allows named variables to be defined and substituted into patterns.  Here is a simple example:</p>
<pre>
; CHECK: test5:
; CHECK:    notw     [[REGISTER:%[a-z]+]]
; CHECK:    andw     {{.*}}[[REGISTER]]
</pre>
<p>The first check line matches a regex <strong>%[a-z]+</strong> and captures it into the variable <strong>REGISTER</strong>.  The second line verifies that whatever is in <strong>REGISTER</strong> occurs later in the file after an "<strong>andw</strong>".  <strong>FileCheck</strong> variable references are always contained in <strong>[[ ]]</strong> pairs, and their names can be formed with the regex <strong>[a-zA-Z][a-zA-Z0-9]*</strong>.  If a colon follows the name, then it is a definition of the variable; otherwise, it is a use.</p><p><strong>FileCheck</strong> variables can be defined multiple times, and uses always get the latest value.  Variables can also be used later on the same line they were defined on. For example:</p>
<pre>
; CHECK: op [[REG:r[0-9]+]], [[REG]]
</pre>
<p>Can be useful if you want the operands of <strong>op</strong> to be the same register, and don&apos;t care exactly which register it is.</p>
<h3>FileCheck Expressions</h3>
<p>Sometimes there&apos;s a need to verify output which refers line numbers of the match file, e.g. when testing compiler diagnostics.  This introduces a certain fragility of the match file structure, as "<strong>CHECK:</strong>" lines contain absolute line numbers in the same file, which have to be updated whenever line numbers change due to text addition or deletion.</p><p>To support this case, FileCheck allows using <strong>[[@LINE]]</strong>, <strong>[[@LINE+&lt;offset&gt;]]</strong>, <strong>[[@LINE-&lt;offset&gt;]]</strong> expressions in patterns. These expressions expand to a number of the line where a pattern is located (with an optional integer offset).</p><p>This way match patterns can be put near the relevant test lines and include relative line number references, for example:</p>
<pre>
// CHECK: test.cpp:[[@LINE+4]]:6: error: expected &apos;;&apos; after top level declarator
// CHECK-NEXT: {{^int a}}
// CHECK-NEXT: {{^     &#92;^}}
// CHECK-NEXT: {{^     ;}}
int a
</pre>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Maintained by The LLVM Team (http://llvm.org/).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>2003-2013, LLVM Project</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="FeatureLinkerUnlabeledQT.1.html"><span aria-hidden="true">&larr;</span> FeatureLinkerUnlabeledQT.1: Library for lc/ms data management and analysis - tools</a></li>
   <li class="next"><a href="FileCheck-3.5.1.html">FileCheck-3.5.1: Flexible pattern matching file verifier <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

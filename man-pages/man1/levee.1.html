<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>levee: A screen oriented editor.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="A screen oriented editor.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="levee (1) manual">
  <meta name="twitter:description" content="A screen oriented editor.">
  <meta name="twitter:image" content="https://www.carta.tech/images/levee-levee-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/levee.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="levee (1) manual" />
  <meta property="og:description" content="A screen oriented editor." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/levee-levee-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">levee<small> (1)</small></h1>
        <p class="lead">A screen oriented editor.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/levee.1.html">
      <span itemprop="name">levee: A screen oriented editor.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/levee/">
      <span itemprop="name">levee</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/levee.1.html">
      <span itemprop="name">levee: A screen oriented editor.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>levee</strong> [<em>+address</em>] [<em>file </em><strong>...</strong>]</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Levee is a screen oriented  editor based on the  Unix editor "vi".  It provides a terse,  powerful way to enter and edit text (however,  if you want a word-processor,  you're better off with WordStar.)</p><p>Levee is a moded editor.  It operates in 3 modes  -- visual, command, and insert.  Most of the editing work is done is visual mode,  file reading and  writing is  done in  command mode,  and insert mode does what you would expect.</p><p>When you enter Levee,  you may specify  an  address to start editing at.  These addresses  are in the same  format as command mode addresses,  except that a naked + will put  you at the very end of the file.</p><p>Levee is copyright (c) 1982-2008 by David L. Parsons. (see the notice at the end of this document for distribution terms)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COMMAND MODE COMMANDS</h2>
        <div class="sectioncontent">
<p>These commands are used for  editing new files,  writing modified files,  changing options, doing substitutions,  and a subset of  the visual commands.  They take as  input whole lines,  terminated  by  return (to execute),  or  escape (to abort.)</p><p>Command mode is reached by typing ":" or "Q" from visual mode.  If you enter command  mode by typing ":",  Levee will execute  one  command,   then return  to  visual  mode after prompting you  with  "[more]".   If you type anything except a space or return, Levee will accept another command, and so forth.  If,  however, you enter command mode via "Q",  Levee will  remain in  command mode  until  you enter the "visual" command.</p><h3>A NOTE ON COMMAND SYNTAX</h3>
<p>A command may be preceded by an optional line-range.  If you do not provide a line-range,  Levee will use the default line-range shown by the command.  A line-range is one or two address specifications in the following format:</p><p>(<strong>.</strong>|<strong>$</strong>|<strong>'x</strong>|<strong>#</strong>) [ (<strong>+</strong>|<strong>-</strong>) (<strong>/</strong><em>patt</em><strong></strong><strong>/</strong>|<strong>?</strong><em>patt</em><strong>?</strong>|<strong>#</strong>) ]</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>.</strong></p>
  </dt>
  <dd>
    <p>current line.</p>
  </dd>
  <dt>
    <p><strong>$</strong></p>
  </dt>
  <dd>
    <p>last line.</p>
  </dd>
  <dt>
    <p><strong>'x</strong></p>
  </dt>
  <dd>
    <p>the line with mark x on it.</p>
  </dd>
  <dt>
    <p><strong>#</strong></p>
  </dt>
  <dd>
    <p>line #.</p>
  </dd>

</dl>
<p>For example, ".-5,.+5p" will print every line within ten lines of the current line.  "$-5" is the fifth line from the end of the file,  and "/end/+2"  is the second line past the next  occurrence  of  the  pattern "end".  Patterns  may  be regular expressions (see below.)</p><p>Also,  a naked line-range will  set the current  line to the first line in the range  and print all the lines in that range. "1,10" sets the current line to 1,  then prints lines 1 to 10.</p><p>If you specify a non-existent line in a range, the command  will abort and Levee will tell you "bad address".</p>
<h3>Command mode commands</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong>args</strong></p>
  </dt>
  <dd>
    <p>show the current argument list, if one exists. The file that you are currently editing will be framed by '[' and ']'.</p>
  </dd>
  <dt>
    <p><em>(.,.)</em><strong>change</strong></p>
  </dt>
  <dd>
    <p>delete lines, then enter insert mode.</p>
  </dd>
  <dt>
    <p><em>(.,.)</em><strong>delete</strong></p>
  </dt>
  <dd>
    <p>delete lines. Deleted lines are stored in a Yank Buffer for later putback with "put".</p>
  </dd>
  <dt>
    <p><strong>edit[!] [file]</strong></p>
  </dt>
  <dd>
    <p>Discard the current file and start editing a new one. If changes were made to the current file, you must enter "edit!" to force Levee to discard the changes. If you do not specify a filename, Levee will try to reedit the current filename.</p><p>When Levee reads in a new file, it will tell you how many bytes it read in, or [overflow] if the file is larger than the internal buffer (256000 bytes on most platforms; 20k on USCD Pascal.)</p>
  </dd>
  <dt>
    <p><strong>execmode</strong></p>
  </dt>
  <dd>
    <p>Remain in command mode until you use the "visual" command.</p>
  </dd>
  <dt>
    <p><strong>file</strong><em>[name]</em></p>
  </dt>
  <dd>
    <p>Echo what the current filename is, its status, and the current line. If you provide it with a name, it will change the filename to that.</p>
  </dd>
  <dt>
    <p><em>(.)</em><strong>insert</strong></p>
  </dt>
  <dd>
    <p>Insert text above the current line. If you specify a line number, Levee will make that the current line, then insert above it.</p>
  </dd>

</dl>

<h3>Insert mode commands</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong>^W</strong></p>
  </dt>
  <dd>
    <p>back over the last word you entered.</p>
  </dd>
  <dt>
    <p><strong>^H</strong></p>
  </dt>
  <dd>
    <p>back over one character.</p>
  </dd>
  <dt>
    <p><strong>^U</strong></p>
  </dt>
  <dd>
    <p>back over all input on this line.</p>
  </dd>
  <dt>
    <p><strong>^V</strong></p>
  </dt>
  <dd>
    <p>escape the next character typed. (For example, <strong>^V^H</strong> will put a ^H into the file.)</p>
  </dd>
  <dt>
    <p><strong>ESC</strong></p>
  </dt>
  <dd>
    <p>exit insert mode.</p>
  </dd>
  <dt>
    <p><strong>^D</strong></p>
  </dt>
  <dd>
    <p>If at start of line, reduce indentation 'shiftwidth' columns.</p>
  </dd>
  <dt>
    <p><strong>^T</strong></p>
  </dt>
  <dd>
    <p>If at start of line, increase indentation 'shiftwidth' columns.</p>
  </dd>

</dl>
<p>When in insert mode, Levee will not allow you to enter any control characters except return and tab.  Return ends input on this line and opens a new line for input.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>map[!]</strong><em>[key</em><strong>[text]]</strong></p>
  </dt>
  <dd>
    <p>Define/list macros.  There are 3 forms of map:</p>
  </dd>
  <dt>
    <p><em>map.</em></p>
  </dt>
  <dd>
    <p>This lists all the active macros.</p>
  </dd>
  <dt>
    <p><em>map</em>(key).</p>
  </dt>
  <dd>
    <p>This shows the macro associated with (key), if any.</p>
  </dd>
  <dt>
    <p><em>map</em>(key) (text)</p>
  </dt>
  <dd>
    <p>This maps (key) to (text). You may map any key except ":" and escape. In the normal form (map), the macro will be effective in visual mode, but in the alternate form, (map!), the macro will be effective in insert and command modes.</p>
  </dd>

</dl>
<p>For example, if you map!ped return to "hello world", every time you entered a return in command or visual mode, the string "hello world" would pop up.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>next</strong><em>[file</em><strong>...]</strong></p>
  </dt>
  <dd>
    <p>Edit the next file in the arglist, or edit a new arglist. Levee takes its initial arglist off the command line when you execute it. If "autowrite" is set, Levee will write out the changes to the current file before editing the next one.</p>
  </dd>
  <dt>
    <p><em>(.)</em><strong>open</strong></p>
  </dt>
  <dd>
    <p>Insert below the current line. Otherwise just like insert.</p>
  </dd>
  <dt>
    <p><strong>previous</strong></p>
  </dt>
  <dd>
    <p>Edit the previous file in the arglist. Otherwise, like next.</p>
  </dd>
  <dt>
    <p><em>(.,.)</em><strong>print</strong></p>
  </dt>
  <dd>
    <p>Display lines without changing the current line.</p>
  </dd>
  <dt>
    <p><em>(.)</em><strong>put</strong></p>
  </dt>
  <dd>
    <p>Put the contents of the yank buffer back on the line below the current line. If you specify a line, it resets the current line, then puts the yank buffer back. The yank buffer is filled by the delete, change, or yank commands. Put does not destroy the yank buffer, so you may put back text multiple times.</p>
  </dd>
  <dt>
    <p><strong>quit[!]</strong></p>
  </dt>
  <dd>
    <p>Exit Levee. If you want to discard changes, use "quit!"</p>
  </dd>
  <dt>
    <p><em>(.)</em><strong>read</strong><em>[file]</em></p>
  </dt>
  <dd>
    <p>put the contents of 'file' after the current line.</p>
  </dd>
  <dt>
    <p><strong>rm</strong><em>file</em></p>
  </dt>
  <dd>
    <p>Delete 'file' from disk.</p>
  </dd>
  <dt>
    <p><strong>set</strong><em>[option=value]</em></p>
  </dt>
  <dd>
    <p>Set a tunable variable. Levee has a dozen or so user-definable variables which you can twiddle via this command. There are boolean, integer, and string variables that you can set. A string or integer variable is set by "set xxx=yyy", a boolean variable is set via "set xxx" or "set noxxx".</p><p>Here are the settable variables (and abbreviations):</p>
  </dd>
  <dt>
    <p><strong>tabsize</strong><em>(ts)</em></p>
  </dt>
  <dd>
    <p>tab stop.</p>
  </dd>
  <dt>
    <p><strong>shiftwidth</strong><em>(sw)</em></p>
  </dt>
  <dd>
    <p>columns to shift on ^D, ^T, &gt;&gt;, or &lt;&lt;</p>
  </dd>
  <dt>
    <p><strong>scroll</strong></p>
  </dt>
  <dd>
    <p>number of lines to scroll on ^D, ^U</p>
  </dd>
  <dt>
    <p><strong>autoindent</strong><em>(ai)</em></p>
  </dt>
  <dd>
    <p>supply indentation during insert mode.</p>
  </dd>
  <dt>
    <p><strong>autowrite</strong><em>(aw)</em></p>
  </dt>
  <dd>
    <p>write out changes before :next, :prev</p>
  </dd>
  <dt>
    <p><strong>autocopy</strong><em>(ac)</em></p>
  </dt>
  <dd>
    <p>make backup copies before writing changes.</p>
  </dd>
  <dt>
    <p><strong>list</strong></p>
  </dt>
  <dd>
    <p>display tabs as ^I, end of line as $.</p>
  </dd>
  <dt>
    <p><strong>magic</strong></p>
  </dt>
  <dd>
    <p>use regular expressions in searches.</p>
  </dd>
  <dt>
    <p><strong>suffix</strong></p>
  </dt>
  <dd>
    <p>if the filename does not have a . in it, supply the suffix. (this is the only string variable.)</p>
  </dd>
  <dt>
    <p><strong>overwrite</strong><em>(ow)</em></p>
  </dt>
  <dd>
    <p>destroy old file first, then write.</p>
  </dd>
  <dt>
    <p><strong>beautify</strong><em>(be)</em></p>
  </dt>
  <dd>
    <p>When set, Levee will not allow insert of any control character except tab and return unless you escape it with ctrl-V.</p>
  </dd>
  <dt>
    <p><strong>wrapscan</strong></p>
  </dt>
  <dd>
    <p>searches wrap around end of buffer.</p>
  </dd>
  <dt>
    <p><strong>ignorecase</strong><em>(ic)</em></p>
  </dt>
  <dd>
    <p>Ignore the case of alphabetic characters during searches.</p>
  </dd>
  <dt>
    <p><strong>mapslash</strong></p>
  </dt>
  <dd>
    <p>(ST version only) Map "/" in filenames to " If the environment contains `mapslash' when levee is called, this variable will default to true, otherwise it defaults to false. (See the documentation for the Teeny-shell on how the teeny-shell interprets `mapslash')</p>
  </dd>
  <dt>
    <p><strong>lines</strong><em>(li)</em></p>
  </dt>
  <dd>
    <p>(ST version only) How many lines on the display. This is primarily for running levee through the serial port - put set li=xx into your LVRC for a xx line terminal.</p>
  </dd>
  <dt>
    <p><strong>cols</strong><em>(co)</em></p>
  </dt>
  <dd>
    <p>(ST version only) How many columns on the display.  Like the lines variable, it's for running levee through the serial port.</p>
  </dd>

</dl>
<p>You may set multiple variables on one line, as in 'set ws noai'. To see the current settings of these variables, :set -- without any arguments -- will show the current settings.</p><p>At startup, Levee looks in the environment variable LVRC for a list of variables to set (GEMDOS/MS-DOS). LVRC is one line of the form 'option=value ...'. If you have a LVRC defined that is 'ts=4 ow nows', Levee will set tabsize to 4, turn on overwrite, and turn off wrapscan.</p><p>If you are using RMX, Levee looks in the file ":home:r?lvrc" for initialization. If you are using Osy/SWOs, Levee looks in the file "*.lvrc". The format of these files are different from the LVRC variable -- see "source" for more information.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>source</strong><em>file</em></p>
  </dt>
  <dd>
    <p>Take command mode commands from 'file'. These commands can be any legal command, except "visual". If a error happens during execution of 'file', Levee abandons that level of source'ing.</p><p>In Osy/SWOs, there are a few differences in insert mode from within a sourced file. No character has special meaning except a line  containing nothing but a period, which terminates insert mode. For example:</p><p>:commands</p><p>:insert</p><p>blah blah blah blah blah blah</p><p>blah blah blah blah blah blah</p><p>blah blah blah blah blah blah</p><p>:more commands</p><p>If you are running Levee under any other operating system, you cannot do a insert from a :source file.</p>
  </dd>
  <dt>
    <p><strong>(.,.)substitute(delim)patt(delim)repl(delim)[qcpg]</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>(.,.)substitute&</strong></p>
  </dt>
  <dd>
    <p>Search for patt and replace it with repl. Levee will look for patt once on each line and replace it with repl. The delimiter may be any ascii character.</p><p>The pattern is a regular expression, just like a search pattern.</p><p>You may include parts of the pattern in the replacement string; A '&' in the replacement pattern copies in the whole source pattern, so if you do a 'sub/this/& and that/g', every instance of 'this' will be replaced with 'this and that'.  Also, you may pull parts of the pattern out by using the &#92;( and &#92;) argument meta-characters. Arguments gotten by &#92;( & &#92;) are put into the replacement string everywhere you do a &#92;1..&#92;9 [ &#92;1 is the first argument you set up with &#92;( & &#92;) ]. So, if you want to reverse the order of two substrings, you can do 'sub/&#92;(string1&#92;)&#92;(string2&#92;)/&#92;2&#92;1/'.</p><p>substitute& redoes the last substitution.</p><p>Options:</p>
  </dd>
  <dt>
    <p><strong>q,c</strong></p>
  </dt>
  <dd>
    <p>before doing the substitute, display the affected line and wait for you to type a character. If you type 'y', it will do the substitution. 'q' aborts the substitute,  'a'  does the rest of the change without prompting, and 'n' does not do it.</p>
  </dd>
  <dt>
    <p><strong>p</strong></p>
  </dt>
  <dd>
    <p>print the affected lines after the change.</p>
  </dd>
  <dt>
    <p><strong>g</strong></p>
  </dt>
  <dd>
    <p>do the change globally. That is, do it for every occurence  of patt on a  line,  rather than just once.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p><strong>undo</strong></p>
  </dt>
  <dd>
    <p>Undo the last modification to the file (except :edit, :next, :rm, or :write.) You can only undo the last change to a file -- undo counts as a change. :undo followed by :undo does nothing to the file.</p>
  </dd>
  <dt>
    <p><strong>unmap</strong><em>(key)</em></p>
  </dt>
  <dd>
    <p>Undefine a macro (see map).</p>
  </dd>
  <dt>
    <p><strong>visual</strong><em>[list]</em></p>
  </dt>
  <dd>
    <p>If you entered command mode by "Q" or "execmode", return to visual mode.  If you provide an argument list, it also does a `:next' on that list.</p>
  </dd>
  <dt>
    <p><strong>version</strong></p>
  </dt>
  <dd>
    <p>Show which version of levee this is.</p>
  </dd>
  <dt>
    <p><em>(.,.)</em><strong>write </strong><em>[file]</em></p>
  </dt>
  <dd>
    <p>Write lines to a file. If you write the everything to 'file', the filename is set to 'file', and if you do not specify a file, Levee will write to the filename.</p>
  </dd>
  <dt>
    <p><em>(.,.)</em><strong>wq </strong><em>[file]</em></p>
  </dt>
  <dd>
    <p> Write to a file, then quit.</p>
  </dd>
  <dt>
    <p><em>(.,.)</em><strong>yank</strong></p>
  </dt>
  <dd>
    <p>Yank lines from the file into the yank buffer, for later putback with "put".</p>
  </dd>
  <dt>
    <p><strong>xit[!]</strong></p>
  </dt>
  <dd>
    <p>Write changes to the current file, then exit. If there are more files in the arglist, use "xit!"</p>
  </dd>
  <dt>
    <p><strong>![command]</strong></p>
  </dt>
  <dd>
    <p>Execute command.</p><p>Example:</p><p>!ls    =&gt; does a 'ls'.</p><p>This command is available only under GEMDOS, MSDOS, RMX, and Unix.</p>
  </dd>
  <dt>
    <p><strong>($)=</strong></p>
  </dt>
  <dd>
    <p>Give the line number of the addressed line. /end/= gives you the line number of the next line with a 'end' on it.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">VISUAL MODE COMMANDS</h2>
        <div class="sectioncontent">
<p>Visual mode commands move you around  and modify the file. There are movement commands to move the cursor by a variety of objects.</p><p>In the description,  a (#) means a optional  count.  If a command has a optional count,  it will tell you what the count does in parenthesis.  A (*) means that the command can be used in the delete, yank, and change commands.</p><p>Counts are made up by  entering digits.  If you type '45', the count will be set to 45. To cancel a count, type ESC.</p><p>This section discusses 'whitespace' occasionally. Whitespace is tabs, spaces, and end of line.</p><h3>How the display works</h3>
<p>Characters  are  displayed  on  the  screen  as  you would expect,  except that  nonprinting characters are  shown as ^x, and tabs  expand to  spaces ( unless you  set the option list, then they show as ^I.)  When sitting on a control character or tab, the cursor is placed on the FIRST character displayed. If you move the cursor to  any other part of them ( via j or k -- see below), any changes will start at the next character.</p><p>Levee  does  not  display a end of  file marker, but lines past the end of the file are denoted by ~ lines.</p><p>If list is  set,  tabs  display as ^I, and the end of line displays as $.</p><p>If a  line is too long for the screen,  it will  just disappear off the end of the screen.</p><p>Levee will handle any screen resolution and any monospaced font you hand it ( if you are running in low resolution, Levee will give you a 25x40 window, for example.)</p>
<h3>Visual mode commands</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong>^A</strong></p>
  </dt>
  <dd>
    <p>Show a debugging message at the bottom of the screen. This is not at all useful unless you are debugging the editor. Ignore it.</p>
  </dd>
  <dt>
    <p><strong>(#)^D</strong></p>
  </dt>
  <dd>
    <p>Scroll the screen down a half screen. If a count is specified, scroll down the specified number of lines.</p>
  </dd>
  <dt>
    <p><strong>^E</strong></p>
  </dt>
  <dd>
    <p>Scroll down 1 line (shorthand for 1^D )</p>
  </dd>
  <dt>
    <p><strong>^G</strong></p>
  </dt>
  <dd>
    <p>Show file statistics. Exactly like ':file'.</p>
  </dd>
  <dt>
    <p><em>(*)</em><strong>(#)^H</strong></p>
  </dt>
  <dd>
    <p>Move the cursor left one (count) chars.</p>
  </dd>
  <dt>
    <p><strong>^I</strong></p>
  </dt>
  <dd>
    <p>Redraw the screen.</p>
  </dd>
  <dt>
    <p><em>(*)</em><strong>(#)^J</strong></p>
  </dt>
  <dd>
    <p>Move down one (count) lines. When you use ^J and ^K (below) to move up or down lines, the cursor will remain in the same column, even if it is in the middle of a tabstop or past the end of a line.</p>
  </dd>
  <dt>
    <p><em>(*)</em><strong>(#)^K</strong></p>
  </dt>
  <dd>
    <p>Move up one (count) lines.</p>
  </dd>
  <dt>
    <p><em>(*)</em><strong>(#)^L</strong></p>
  </dt>
  <dd>
    <p>Move right one (count) characters.</p>
  </dd>
  <dt>
    <p><em>(*)</em><strong>(#)^M</strong></p>
  </dt>
  <dd>
    <p>Move to the first nonwhite space on the next line. If a count is specified, move to the first nonwhite count lines down.</p>
  </dd>
  <dt>
    <p><strong>(#)^U</strong></p>
  </dt>
  <dd>
    <p>Scroll the screen up a half page. If a count is specified, scroll up count lines.</p>
  </dd>
  <dt>
    <p><strong>^Y</strong></p>
  </dt>
  <dd>
    <p>Scroll the screen up 1 line (shorthand for 1^U.)</p>
  </dd>
  <dt>
    <p><strong>(#)a</strong></p>
  </dt>
  <dd>
    <p>Insert text AFTER the cursor. If you give a count, the insertion will be repeated count times ( 40i-ESC will give you a line of 40 dashes).</p><p>The commands in insert mode are the same for visual and command mode.</p>
  </dd>
  <dt>
    <p><em>(*)</em><strong>(#)b</strong></p>
  </dt>
  <dd>
    <p>Move to the beginning of the last word (the count'th word back). A word is a collection of alphanumeric characters (a-z0-9$_#) or any other nonwhite character (i.e. anything but space, tab, eoln).</p>
  </dd>
  <dt>
    <p><strong>c</strong></p>
  </dt>
  <dd>
    <p>Change a object. Change deletes an object, then enters insert mode without redrawing the screen. When you tell it the object to be changed, Levee puts a '$' on the last character of the object. You cannot change backwards.</p><p>The object may be any visual mode command marked with a '(*) '. For example, 'c4l' will change the next 4 characters on the line to something else. (4cl does the same thing -- 4c4l changes the next 16 characters on this line.)</p><p> 'cc' will change whole lines.</p><p>When changing, deleting, or yanking a object, it will be placed into a yank buffer, where it can be retrieved by the 'p' or 'P' commands.</p>
  </dd>
  <dt>
    <p><strong>(#)d</strong></p>
  </dt>
  <dd>
    <p>Delete an object. Like 'cc', 'dd' affects whole lines.</p>
  </dd>
  <dt>
    <p><em>(*)</em><strong>(#)e</strong></p>
  </dt>
  <dd>
    <p>Move to the end of the current word.</p>
  </dd>
  <dt>
    <p><em>(*)</em><strong>(#)f(x)</strong></p>
  </dt>
  <dd>
    <p>Find the next (count'th) occurance of a character on the current line. For example, if the cursor is sitting on the first character of the line 'abcdef', typing "ff" will put the cursor on the 'f'.</p>
  </dd>
  <dt>
    <p><em>(*)</em><strong>(#)h</strong></p>
  </dt>
  <dd>
    <p>Move left one (count) characters. Exactly like ^H.</p>
  </dd>
  <dt>
    <p><strong>(#)i</strong></p>
  </dt>
  <dd>
    <p>Start inserting characters at the cursor. If you specify a count, the insertion will be duplicated count times.</p>
  </dd>
  <dt>
    <p><em>(*)</em><strong>(#)j</strong></p>
  </dt>
  <dd>
    <p>Move down one (count) lines. Exactly like ^J.</p>
  </dd>
  <dt>
    <p><em>(*)</em><strong>(#)k</strong></p>
  </dt>
  <dd>
    <p>Move up one (count) lines. Exactly like ^K.</p>
  </dd>
  <dt>
    <p>,B (*) (#)l</p>
  </dt>
  <dd>
    <p>Move right one (count) character. Exactly like ^L.</p>
  </dd>
  <dt>
    <p><strong>m(x)</strong></p>
  </dt>
  <dd>
    <p>Set the marker (x). There are 26 markers available (a-z). You may move to a marker by use of the ' or ` commands.</p>
  </dd>
  <dt>
    <p><em>(*)</em><strong>n</strong></p>
  </dt>
  <dd>
    <p>Find the next occurance of a search pattern. When you do a search with a / or ? command, Levee will remember the pattern and the direction you searched in. 'n' will search in the same direction for the pattern, 'N' searches in the opposite direction.</p>
  </dd>
  <dt>
    <p><strong>o</strong></p>
  </dt>
  <dd>
    <p>Open a line below the current line for insertion.</p>
  </dd>
  <dt>
    <p><strong>p</strong></p>
  </dt>
  <dd>
    <p>Put yanked/deleted text back after the cursor. Text is yanked by the delete (d,x,X,D), change (c,C,s,S), and yank (y,Y) commands.</p>
  </dd>
  <dt>
    <p><strong>(#)r(x)</strong></p>
  </dt>
  <dd>
    <p>Replace characters (up to end of line) with (x). '4ra' will change the next 4 characters after the cursor into 'aaaa'.</p>
  </dd>
  <dt>
    <p><strong>(#)s</strong></p>
  </dt>
  <dd>
    <p>change one (count) characters. Shorthand for (#)cl.</p>
  </dd>
  <dt>
    <p><em>(*)</em><strong>(#)t(x)</strong></p>
  </dt>
  <dd>
    <p>Move up to a character on the current line. If you are on the first character of the line 'abcdef' and you type 'tf', you will end up sitting on the 'e'.</p>
  </dd>
  <dt>
    <p><strong>u</strong></p>
  </dt>
  <dd>
    <p>Undo last modification. You can undo ANY modification command except :edit, :next, :rm, or :write. (Just like :undo).</p>
  </dd>
  <dt>
    <p><em>(*)</em><strong>(#)v</strong></p>
  </dt>
  <dd>
    <p>Move back to the very end of the previous (count'th) word. See 'b' for the definition of a word.</p>
  </dd>
  <dt>
    <p><em>(*)</em><strong>(#)w</strong></p>
  </dt>
  <dd>
    <p>Move up to the very beginning of the next (count'th) word.</p>
  </dd>
  <dt>
    <p><strong>(#)x</strong></p>
  </dt>
  <dd>
    <p>Delete one (count) characters forward. Shorthand for (#)dl.</p>
  </dd>
  <dt>
    <p><strong>y</strong></p>
  </dt>
  <dd>
    <p>Yank an object for later use by put. 'yy' yanks whole lines.</p>
  </dd>
  <dt>
    <p><strong>A</strong></p>
  </dt>
  <dd>
    <p>Append text at the end of the line. Shorthand for $a.</p>
  </dd>
  <dt>
    <p><em>(*)</em><strong>(#)B</strong></p>
  </dt>
  <dd>
    <p>Move to the beginning of the current word. Exactly like 'b'.</p><p><strong>NOTE:</strong> this is incorrect. the capitalized word movement commands should, and will in the future, be used for movement by space-delimited words.</p>
  </dd>
  <dt>
    <p><strong>C</strong></p>
  </dt>
  <dd>
    <p>Change to the end of the line. Shorthand for c$.</p>
  </dd>
  <dt>
    <p><strong>D</strong></p>
  </dt>
  <dd>
    <p>Delete to the end of the line. Shorthand for d$.</p>
  </dd>
  <dt>
    <p><em>(*)</em><strong>(#)F(x)</strong></p>
  </dt>
  <dd>
    <p>Move to the first (count'th) previous occurance of a character on the current line. If you are sitting at the end of the line 'abcdef', typing "Fa" will move you back to the 'a' at the start of the line.</p>
  </dd>
  <dt>
    <p><em>(*)</em><strong>(#)G</strong></p>
  </dt>
  <dd>
    <p>Goto line. If you specify a count, Levee will move to that line, and if there is no count, Levee moves to the absolute end of the file.</p><p>To get to the start of the file, type "1G". To the end, just "G".</p>
  </dd>
  <dt>
    <p><em>(*)</em><strong>H</strong></p>
  </dt>
  <dd>
    <p>Move to the first nonwhite character at the top of the screen.</p>
  </dd>
  <dt>
    <p><strong>I</strong></p>
  </dt>
  <dd>
    <p>Insert at the end of the current line. Shorthand for $i.</p>
  </dd>
  <dt>
    <p><strong>(#)J</strong></p>
  </dt>
  <dd>
    <p>Join two (count+1) lines together. Joining appends the second line at the end of the first, putting a space between them. If the first line ends in whitespace, Levee will not put in a space.</p>
  </dd>
  <dt>
    <p><em>(*)</em><strong>L</strong></p>
  </dt>
  <dd>
    <p>Move to the last nonwhite character on the last line of the screen.</p>
  </dd>
  <dt>
    <p><em>(*)</em><strong>M</strong></p>
  </dt>
  <dd>
    <p>Move to the first nonwhite character in the middle of the screen.</p>
  </dd>
  <dt>
    <p><strong>O</strong></p>
  </dt>
  <dd>
    <p>Open a line above the current line. Otherwise works just like 'o'.</p>
  </dd>
  <dt>
    <p><strong>P</strong></p>
  </dt>
  <dd>
    <p>Put back the yank buffer at the cursor. Otherwise works just like 'p'.</p>
  </dd>
  <dt>
    <p><strong>Q</strong></p>
  </dt>
  <dd>
    <p>Enter and remain in command mode. Just like the command :exec. To get back to visual mode, you must enter the command ':visual'.</p>
  </dd>
  <dt>
    <p><strong>R</strong></p>
  </dt>
  <dd>
    <p>Replace mode. A limited subset of insert mode that overwrites characters up to end of line. All of the normal insert mode commands apply. If you overwrite a character, then back over it with ^H,^U, or ^W, it will reappear after you exit Replace mode.</p><p>Escape exits replace mode.</p><p><strong>NOTE:</strong> due to a bug, entering a &lt;return&gt; in Replace mode will drop you back into visual mode with an error. The replacements you have made will remain.</p>
  </dd>
  <dt>
    <p><strong>S</strong></p>
  </dt>
  <dd>
    <p>Change characters backwards. Shorthand for (#)ch.</p>
  </dd>
  <dt>
    <p><em>(*)</em><strong>(#)T(x)</strong></p>
  </dt>
  <dd>
    <p>Move back to character on current line. If you are on the last character of the line 'abcdef', typing "Ta" will move you back to the 'b'.</p>
  </dd>
  <dt>
    <p><em>(*)</em><strong>(#)W</strong></p>
  </dt>
  <dd>
    <p>Move to end of word. Exactly like 'e'.</p>
  </dd>
  <dt>
    <p><strong>(#)X</strong></p>
  </dt>
  <dd>
    <p>Delete characters backwards. Shorthand for (#)dh.</p>
  </dd>
  <dt>
    <p><strong>Y</strong></p>
  </dt>
  <dd>
    <p>Yank to end of line. Shorthand for y$.</p>
  </dd>
  <dt>
    <p><strong>ZZ</strong></p>
  </dt>
  <dd>
    <p>Write changes to current file and exit if last file in arglist. Exactly like :xit.</p>
  </dd>
  <dt>
    <p><em>(*)</em><strong>(#)$</strong></p>
  </dt>
  <dd>
    <p>Move to end of line. If you give a count, move to the end of the (count-1) line down (so 2$ moves you to the end of the next line.).</p>
  </dd>
  <dt>
    <p><strong>0</strong></p>
  </dt>
  <dd>
    <p>Move to the beginning of the current line.  Shorthand for 0|.</p>
  </dd>
  <dt>
    <p><strong>(#)!</strong></p>
  </dt>
  <dd>
    <p>Pipe an object through an external program. Like 'cc', '!!' affects whole lines.</p>
  </dd>
  <dt>
    <p><em>(*)</em><strong>%</strong></p>
  </dt>
  <dd>
    <p>Find matching bracket, parenthesis, or squiggly bracket. If you are not sitting on a '[]{}()', Levee will search forward for one of them on the current line, then match whatever it finds.</p>
  </dd>
  <dt>
    <p><strong>[space]</strong></p>
  </dt>
  <dd>
    <p>Move to the first nonwhite character on the current line.</p>
  </dd>
  <dt>
    <p><strong>&</strong></p>
  </dt>
  <dd>
    <p>Redo last substitution command.</p>
  </dd>
  <dt>
    <p><em>(*)</em><strong>(#){</strong></p>
  </dt>
  <dd>
    <p>Move to the beginning of the count'th paragraph back. A paragraph is delimited by a blank line.</p>
  </dd>
  <dt>
    <p><em>(*)</em><strong>(#)}</strong></p>
  </dt>
  <dd>
    <p>Move to the end of the count'th paragraph forward.</p>
  </dd>
  <dt>
    <p><em>(*)</em><strong>(#)(</strong></p>
  </dt>
  <dd>
    <p>Move to the beginning of the count'th sentence back. A sentence is delimited by a ., a !, or a ? followed by a space, a tab, or end of line.</p>
  </dd>
  <dt>
    <p><em>(*)</em><strong>(#))</strong></p>
  </dt>
  <dd>
    <p>Move to the end of the count'th sentence forward.</p>
  </dd>
  <dt>
    <p><em>(*)</em><strong>(#)-</strong></p>
  </dt>
  <dd>
    <p>Move to the (count'th) previous line, first nonwhite.</p>
  </dd>
  <dt>
    <p><em>(*)</em><strong>(#)+</strong></p>
  </dt>
  <dd>
    <p>Move to the (count'th) next line, first nonwhite.</p>
  </dd>
  <dt>
    <p><strong>(#)~</strong></p>
  </dt>
  <dd>
    <p>Change the case of the next count characters. Upper case becomes lowercase, lowercase becomes uppercase.</p>
  </dd>
  <dt>
    <p><em>(*)</em><strong>`(x)</strong></p>
  </dt>
  <dd>
    <p>Move to the exact position of mark (x). There is a special mark for some of the visual mode move meant commands -- '' will move you to where you were before the last (,),',`,G,/,?,n,N command.</p>
  </dd>
  <dt>
    <p><strong>:</strong></p>
  </dt>
  <dd>
    <p>Execute one command mode command. When the command is done, it will return to visual mode if it produces one line of output, but if it scrolls the screen, Levee will prompt [more] before returning to visual mode. If you type a : in response to the [more] prompt, Levee will remain in command mode for one more command.</p>
  </dd>
  <dt>
    <p><strong>(#)&lt;(#)</strong></p>
  </dt>
  <dd>
    <p>Shift one (count) objects left. If you specify a second count, Levee will shift the object left that many columns -- if you do not, they will be sh shifted shiftwidth columns.</p><p>This is a nondestructive shift. If the shift would carry past the left margin, the objects will be moved up to the left margin but no farther.</p><p>Like the other object movement commands, '&lt;&lt;' will affect whole lines.</p>
  </dd>
  <dt>
    <p><strong>(#)&gt;(#)</strong></p>
  </dt>
  <dd>
    <p>Shift one (count) objects right. Just like &lt;, except it will not shift objects past the right margin of the screen. If you do shift an object past the right margin of the screen, all of its indent will be removed and it will end up by the left margin.</p>
  </dd>
  <dt>
    <p><strong>.</strong></p>
  </dt>
  <dd>
    <p>Repeat last modification command. (except undo)</p>
  </dd>
  <dt>
    <p><em>(*)</em><strong>?</strong></p>
  </dt>
  <dd>
    <p>Search for pattern backwards. Escape aborts the search pattern, and a empty pattern means search for the last pattern again.</p>
  </dd>
  <dt>
    <p><em>(*)</em><strong>/</strong></p>
  </dt>
  <dd>
    <p>Search for pattern forwards. Otherwise like ?.</p>
  </dd>
  <dt>
    <p><strong>(#)|</strong></p>
  </dt>
  <dd>
    <p>Move to specified column. If you don't have a count, move to column 0.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REGULAR EXPRESSIONS</h2>
        <div class="sectioncontent">
<p>Levee gives  special meanings to  some characters during a pattern match.  The character "." will match any one char, the character "*" will match zero or  more occurances of the previous char ( so, a* will match 'a','aa','aaa', etc, or it will match nothing at all). If a pattern begins with "^", it will  only match  at the  beginning of a line,  and patterns ending with a "$" will only match at the end of a line.</p><p>Brackets ('[]') have special meaning as well.  They mean match any one of the characters inside the brackets. '[abc]' will  match  'a', 'b', or 'c'.  You may  specify  a range of characters inside brackets by using a dash (-). '[a-z]' will match any lowercase alphabetic character.  If ^ is the first character  in  the  bracket,  it means match  any  character except those in the brackets.   '[^abc]' will match anything except 'a','b', or 'c'.</p><p>Backslash takes away  special  meaning  for these chars, but '&#92;t' specifies  a  tab,  and &#92;( & &#92;)  delimit  arguments inside a pattern (used only by :substitute.)    The patterns &#92;&lt; and &#92;&gt; have special  meaning,  too;  they match the start and end of alpha-numeric tokens.</p><p>If you  turn off  the editor variable  'magic',  none of the above  characters will  have special  meaning  inside of a pattern (see 'set').</p><p>Some example patterns:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>^end$</strong></p>
  </dt>
  <dd>
    <p>Find a line that is just 'end'.</p>
  </dd>
  <dt>
    <p><strong>[Ee][Nn][Dd]</strong></p>
  </dt>
  <dd>
    <p>Find a 'end', ignoring case.</p>
  </dd>
  <dt>
    <p><strong>[A-Za-z][A-Za-z0-9]*</strong></p>
  </dt>
  <dd>
    <p>Find the next identifier.</p>
  </dd>
  <dt>
    <p><strong>([*].*[*])</strong></p>
  </dt>
  <dd>
    <p>Find the next one-line pascal comment.</p>
  </dd>
  <dt>
    <p><strong>lt;thegt;</strong></p>
  </dt>
  <dd>
    <p>Find the next occurance of `the'.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LIMITATIONS</h2>
        <div class="sectioncontent">
<p>Levee can only edit files up to 256000 characters long. ^M is used as its internal line separator, so inserting ^M will have interesting consequences.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>Probably infinite.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p><strong>David L. Parsons</strong> <em>(orc@pell.chi.il.us)</em></p><p>Testing, suggestions, and impractical design goals by: Jim Bolland. John Tainter. John Plocher.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright (c) 1982-2007 David L Parsons</p><p>All rights reserved.</p><p>Redistribution and use in source and binary forms, without or without modification, are permitted provided that the above copyright notice and this paragraph are duplicated in all such forms and that any documentation, advertising materials, and other materials related to such distribution and use acknowledge that the software was developed by David L Parsons (orc@pell.chi.il.us). My name may not be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="letterize.1.html"><span aria-hidden="true">&larr;</span> letterize.1: Phone-number to letter-mnemonic generator</a></li>
   <li class="next"><a href="flex-lex.1.html">lex.1: The fast lexical analyser generator <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

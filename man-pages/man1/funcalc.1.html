<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>funcalc: Funtools calculator (for binary tables)</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Funtools calculator (for binary tables)">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="funcalc (1) manual">
  <meta name="twitter:description" content="Funtools calculator (for binary tables)">
  <meta name="twitter:image" content="https://www.carta.tech/images/funtools-funcalc-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/funcalc.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="funcalc (1) manual" />
  <meta property="og:description" content="Funtools calculator (for binary tables)" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/funtools-funcalc-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">funcalc<small> (1)</small></h1>
        <p class="lead">Funtools calculator (for binary tables)</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/funcalc.1.html">
      <span itemprop="name">funcalc: Funtools calculator (for binary tables)</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/funtools/">
      <span itemprop="name">funtools</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/funcalc.1.html">
      <span itemprop="name">funcalc: Funtools calculator (for binary tables)</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>funcalc [\-n] [\-a argstr] [\-e expr] [\-f file] [\-l link] [\-p prog] &lt;iname&gt; [oname [columns]]</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONS</h2>
        <div class="sectioncontent">

<pre>
  -a argstr    # user arguments to pass to the compiled program
  -e expr      # funcalc expression
  -f file      # file containing funcalc expression
  -l libs      # libs to add to link command
  -n           # output generated code instead of compiling and executing
  -p prog      # generate named program, no execution
  -u           # die if any variable is undeclared (don't auto-declare)
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><strong>funcalc</strong> is a calculator program that allows arbitrary expressions to be constructed, compiled, and executed on columns in a Funtools table (\s-1FITS\s0 binary table or raw event file). It works by integrating user-supplied expression(s) into a template C program, then compiling and executing the program. <strong>funcalc</strong> expressions are C statements, although some important simplifications (such as automatic declaration of variables) are supported.</p><p><strong>funcalc</strong> expressions can be specified in three ways: on the command line using the <strong>\-e [expression]</strong> switch, in a file using the <strong>\-f [file]</strong> switch, or from stdin (if neither <strong>\-e</strong> nor <strong>\-f</strong> is specified). Of course a file containing <strong>funcalc</strong> expressions can be read from stdin.</p><p>Each invocation of <strong>funcalc</strong> requires an input Funtools table file to be specified as the first command line argument.  The output Funtools table file is the second optional argument. It is needed only if an output \s-1FITS\s0 file is being created (i.e., in cases where the <strong>funcalc</strong> expression only prints values, no output file is needed). If input and output file are both specified, a third optional argument can specify the list of columns to activate (using <em>FunColumnActivate()</em>).  Note that <strong>funcalc</strong> determines whether or not to generate code for writing an output file based on the presence or absence of an output file argument.</p><p>A <strong>funcalc</strong> expression executes on each row of a table and consists of one or more C statements that operate on the columns of that row (possibly using temporary variables).  Within an expression, reference is made to a column of the <strong>current</strong> row using the C struct syntax <strong>cur-</strong>[colname]&gt;, e.g. cur-&gt;x, cur-&gt;pha, etc. Local scalar variables can be defined using C declarations at very the beginning of the expression, or else they can be defined automatically by <strong>funcalc</strong> (to be of type double). Thus, for example, a swap of columns x and y in a table can be performed using either of the following equivalent <strong>funcalc</strong> expressions:</p><p>  double temp;   temp = cur-&gt;x;   cur-&gt;x = cur-&gt;y;   cur-&gt;y = temp;</p><p>or:</p><p>  temp = cur-&gt;x;   cur-&gt;x = cur-&gt;y;   cur-&gt;y = temp;</p><p>When this expression is executed using a command such as:</p><p>  funcalc -f swap.expr itest.ev otest.ev</p><p>the resulting file will have values of the x and y columns swapped.</p><p>By default, the data type of the variable for a column is the same as the data type of the column as stored in the file. This can be changed by appending \*(L":[dtype]\*(R" to the first reference to that column. In the example above, to force x and y to be output as doubles, specify the type 'D' explicitly:</p><p>  temp = cur-&gt;x:D;   cur-&gt;x = cur-&gt;y:D;   cur-&gt;y = temp;</p><p>Data type specifiers follow standard \s-1FITS\s0 table syntax for defining columns using \s-1TFORM:\s0</p><ul>
<li><p>A: \s-1ASCII\s0 characters</p></li><li><p>B: unsigned 8\-bit char</p></li><li><p>I: signed 16\-bit int</p></li><li><p>U: unsigned 16\-bit int (not standard \s-1FITS\s0)</p></li><li><p>J: signed 32\-bit int</p></li><li><p>V: unsigned 32\-bit int (not standard \s-1FITS\s0)</p></li><li><p>E: 32\-bit float</p></li><li><p>D: 64\-bit float</p></li><li><p>X: bits (treated as an array of chars)</p></li>
</ul><p>Note that only the first reference to a column should contain the explicit data type specifier.</p><p>Of course, it is important to handle the data type of the columns correctly.  One of the most frequent cause of error in <strong>funcalc</strong> programming is the implicit use of the wrong data type for a column in expression.  For example, the calculation:</p><p>  dx = (cur-&gt;x - cur-&gt;y)/(cur-&gt;x + cur-&gt;y);</p><p>usually needs to be performed using floating point arithmetic. In cases where the x and y columns are integers, this can be done by reading the columns as doubles using an explicit type specification:</p><p>  dx = (cur-&gt;x:D - cur-&gt;y:D)/(cur-&gt;x + cur-&gt;y);</p><p>Alternatively, it can be done using C type-casting in the expression:</p><p>  dx = ((double)cur-&gt;x - (double)cur-&gt;y)/((double)cur-&gt;x + (double)cur-&gt;y);</p><p>In addition to accessing columns in the current row, reference also can be made to the <strong>previous</strong> row using <strong>prev-</strong>[colname]&gt;, and to the <strong>next</strong> row using <strong>next-</strong>[colname]&gt;.  Note that if <strong>prev-</strong>[colname]&gt; is specified in the <strong>funcalc</strong> expression, the very first row is not processed.  If <strong>next-</strong>[colname]&gt; is specified in the <strong>funcalc</strong> expression, the very last row is not processed. In this way, <strong>prev</strong> and <strong>next</strong> are guaranteed always to point to valid rows.  For example, to print out the values of the current x column and the previous y column, use the C fprintf function in a <strong>funcalc</strong> expression:</p><p>  fprintf(stdout, "%d %d&#92;n", cur-&gt;x, prev-&gt;y);</p><p>New columns can be specified using the same <strong>cur-</strong>[colname]&gt; syntax by appending the column type (and optional tlmin/tlmax/binsiz specifiers), separated by colons. For example, cur-&gt;avg:D will define a new column of type double. Type specifiers are the same those used above to specify new data types for existing columns.</p><p>For example, to create and output a new column that is the average value of the x and y columns, a new \*(L"avg\*(R" column can be defined:</p><p>  cur-&gt;avg:D = (cur-&gt;x + cur-&gt;y)/2.0</p><p>Note that the final ';' is not required for single-line expressions.</p><p>As with \s-1FITS\s0 \s-1TFORM\s0 data type specification, the column data type specifier can be preceded by a numeric count to define an array, e.g., \*(L"10I\*(R" means a vector of 10 short ints, \*(L"2E\*(R" means two single precision floats, etc.  A new column only needs to be defined once in a <strong>funcalc</strong> expression, after which it can be used without re-specifying the type. This includes reference to elements of a column array:</p><p>  cur-&gt;avg[0]:2D = (cur-&gt;x + cur-&gt;y)/2.0;   cur-&gt;avg[1] = (cur-&gt;x - cur-&gt;y)/2.0;</p><p>The 'X' (bits) data type is treated as a char array of dimension (numeric_count/8), i.e., 16X is processed as a 2\-byte char array. Each 8\-bit array element is accessed separately:</p><p>  cur-&gt;stat[0]:16X  = 1;   cur-&gt;stat[1]      = 2;</p><p>Here, a 16\-bit column is created with the \s-1MSB\s0 is set to 1 and the \s-1LSB\s0 set to 2.</p><p>By default, all processed rows are written to the specified output file. If you want to skip writing certain rows, simply execute the C \*(L"continue\*(R" statement at the end of the <strong>funcalc</strong> expression, since the writing of the row is performed immediately after the expression is executed. For example, to skip writing rows whose average is the same as the current x value:</p><p>  cur-&gt;avg[0]:2D = (cur-&gt;x + cur-&gt;y)/2.0;   cur-&gt;avg[1] = (cur-&gt;x - cur-&gt;y)/2.0;   if( cur-&gt;avg[0] == cur-&gt;x )     continue;</p><p>If no output file argument is specified on the <strong>funcalc</strong> command line, no output file is opened and no rows are written. This is useful in expressions that simply print output results instead of generating a new file:</p><p>  fpv = (cur-&gt;av3:D-cur-&gt;av1:D)/(cur-&gt;av1+cur-&gt;av2:D+cur-&gt;av3);   fbv =  cur-&gt;av2/(cur-&gt;av1+cur-&gt;av2+cur-&gt;av3);   fpu = ((double)cur-&gt;au3-cur-&gt;au1)/((double)cur-&gt;au1+cur-&gt;au2+cur-&gt;au3);   fbu =  cur-&gt;au2/(double)(cur-&gt;au1+cur-&gt;au2+cur-&gt;au3);   fprintf(stdout, "%f&#92;t%f&#92;t%f&#92;t%f&#92;n", fpv, fbv, fpu, fbu);</p><p>In the above example, we use both explicit type specification (for \*(L"av\*(R" columns) and type casting (for \*(L"au\*(R" columns) to ensure that all operations are performed in double precision.</p><p>When an output file is specified, the selected input table is processed and output rows are copied to the output file.  Note that the output file can be specified as \*(L"stdout\*(R" in order to write the output rows to the standard output.  If the output file argument is passed, an optional third argument also can be passed to specify which columns to process.</p><p>In a \s-1FITS\s0 binary table, it sometimes is desirable to copy all of the other \s-1FITS\s0 extensions to the output file as well. This can be done by appending a '+' sign to the name of the extension in the input file name. See <strong>funtable</strong> for a related example.</p><p><strong>funcalc</strong> works by integrating the user-specified expression into a template C program called tabcalc.c. The completed program then is compiled and executed. Variable declarations that begin the <strong>funcalc</strong> expression are placed in the local declaration section of the template main program.  All other lines are placed in the template main program's inner processing loop. Other details of program generation are handled automatically. For example, column specifiers are analyzed to build a C struct for processing rows, which is passed to <em>FunColumnSelect()</em> and used in <em>FunTableRowGet()</em>.  If an unknown variable is used in the expression, resulting in a compilation error, the program build is retried after defining the unknown variable to be of type double.</p><p>Normally, <strong>funcalc</strong> expression code is added to <strong>funcalc</strong> row processing loop. It is possible to add code to other parts of the program by placing this code inside special directives of the form:</p><p>  [directive name]     ... code goes here ...   end</p><p>The directives are:</p><ul>
<li><p><strong>global</strong> add code and declarations in global space, before the main routine.</p></li><li><p><strong>local</strong> add declarations (and code) just after the local declarations in main</p></li><li><p><strong>before</strong> add code just before entering the main row processing loop</p></li><li><p><strong>after</strong> add code just after exiting the main row processing loop</p></li>
</ul><p>Thus, the following <strong>funcalc</strong> expression will declare global variables and make subroutine calls just before and just after the main processing loop:</p><p>  global     double v1, v2;     double init(void);     double finish(double v);   end   before     v1  = init();   end   ... process rows, with calculations using v1 ...   after     v2 = finish(v1);     if( v2 &lt; 0.0 ){       fprintf(stderr, "processing failed %g -&gt; %g&#92;n", v1, v2);       <strong>exit</strong>(1);     }   end</p><p>Routines such as <em>init()</em> and <em>finish()</em> above are passed to the generated program for linking using the <strong>\-l [link directives ...]</strong> switch. The string specified by this switch will be added to the link line used to build the program (before the funtools library). For example, assuming that <em>init()</em> and <em>finish()</em> are in the library libmysubs.a in the /opt/special/lib directory, use:</p><p>  funcalc  -l "-L/opt/special/lib -lmysubs" ...</p><p>User arguments can be passed to a compiled funcalc program using a string argument to the \*(L"\-a\*(R" switch.  The string should contain all of the user arguments. For example, to pass the integers 1 and 2, use:</p><p>  funcalc -a "1 2" ...</p><p>The arguments are stored in an internal array and are accessed as strings via the \s-1ARGV\s0(n) macro.  For example, consider the following expression:</p><p>  local     int pmin, pmax;   end</p><p>  before     pmin=atoi(<strong>ARGV</strong>(0));     pmax=atoi(<strong>ARGV</strong>(1));   end</p><p>  if( (cur-&gt;pha &gt;= pmin) && (cur-&gt;pha &lt;= pmax) )     fprintf(stderr, "%d %d %d&#92;n", cur-&gt;x, cur-&gt;y, cur-&gt;pha);</p><p>This expression will print out x, y, and pha values for all rows in which the pha value is between the two user-input values:</p><p>  funcalc -a '1 12' -f foo snr.ev'[cir 512 512 .1]'   512 512 6   512 512 8   512 512 5   512 512 5   512 512 8</p><p>  funcalc -a '5 6' -f foo snr.ev'[cir 512 512 .1]'   512 512 6   512 512 5   512 512 5</p><p>Note that it is the user's responsibility to ensure that the correct number of arguments are passed. The \s-1ARGV\s0(n) macro returns a \s-1NULL\s0 if a requested argument is outside the limits of the actual number of args, usually resulting in a \s-1SEGV\s0 if processed blindly.  To check the argument count, use the \s-1ARGC\s0 macro:</p><p>  local     long int seed=1;     double limit=0.8;   end</p><p>  before     if( ARGC &gt;= 1 ) seed = atol(<strong>ARGV</strong>(0));     if( ARGC &gt;= 2 ) limit = atof(<strong>ARGV</strong>(1));     srand48(seed);   end</p><p>  if ( drand48() &gt; limit ) continue;</p><p>The macro \s-1WRITE_ROW\s0 expands to the <em>FunTableRowPut()</em> call that writes the current row. It can be used to write the row more than once.  In addition, the macro \s-1NROW\s0 expands to the row number currently being processed. Use of these two macros is shown in the following example:</p><p>  if( cur-&gt;pha:I == cur-&gt;pi:I ) continue;   a = cur-&gt;pha;   cur-&gt;pha = cur-&gt;pi;   cur-&gt;pi = a;   cur-&gt;AVG:E  = (cur-&gt;pha+cur-&gt;pi)/2.0;   cur-&gt;NR:I = NROW;   if( NROW &lt; 10 ) WRITE_ROW;</p><p>If the <strong>\-p [prog]</strong> switch is specified, the expression is not executed. Rather, the generated executable is saved with the specified program name for later use.</p><p>If the <strong>\-n</strong> switch is specified, the expression is not executed. Rather, the generated code is written to stdout. This is especially useful if you want to generate a skeleton file and add your own code, or if you need to check compilation errors. Note that the comment at the start of the output gives the compiler command needed to build the program on that platform. (The command can change from platform to platform because of the use of different libraries, compiler switches, etc.)</p><p>As mentioned previously, <strong>funcalc</strong> will declare a scalar variable automatically (as a double) if that variable has been used but not declared.  This facility is implemented using a sed script named funcalc.sed, which processes the compiler output to sense an undeclared variable error.  This script has been seeded with the appropriate error information for gcc, and for cc on Solaris, DecAlpha, and \s-1SGI\s0 platforms. If you find that automatic declaration of scalars is not working on your platform, check this sed script; it might be necessary to add to or edit some of the error messages it senses.</p><p>In order to keep the lexical analysis of <strong>funcalc</strong> expressions (reasonably) simple, we chose to accept some limitations on how accurately C comments, spaces, and new-lines are placed in the generated program. In particular, comments associated with local variables declared at the beginning of an expression (i.e., not in a <strong>local...end</strong> block) will usually end up in the inner loop, not with the local declarations:</p><p>  /* this comment will end up in the wrong place (i.e, inner loop) */   double a; /* also in wrong place */   /* this will be in the the right place (inner loop) */   if( cur-&gt;x:D == cur-&gt;y:D ) continue; /* also in right place */   a = cur-&gt;x;   cur-&gt;x = cur-&gt;y;   cur-&gt;y = a;   cur-&gt;avg:E  = (cur-&gt;x+cur-&gt;y)/2.0;</p><p>Similarly, spaces and new-lines sometimes are omitted or added in a seemingly arbitrary manner. Of course, none of these stylistic blemishes affect the correctness of the generated code.</p><p>Because <strong>funcalc</strong> must analyze the user expression using the data file(s) passed on the command line, the input file(s) must be opened and read twice: once during program generation and once during execution. As a result, it is not possible to use stdin for the input file: <strong>funcalc</strong> cannot be used as a filter. We will consider removing this restriction at a later time.</p><p>Along with C comments, <strong>funcalc</strong> expressions can have one-line internal comments that are not passed on to the generated C program. These internal comment start with the <strong>#</strong> character and continue up to the new\-line:</p><p>  double a; # this is not passed to the generated C file   # nor is this   a = cur-&gt;x;   cur-&gt;x = cur-&gt;y;   cur-&gt;y = a;   /* this comment is passed to the C file */   cur-&gt;avg:E  = (cur-&gt;x+cur-&gt;y)/2.0;</p><p>As previously mentioned, input columns normally are identified by their being used within the inner event loop. There are rare cases where you might want to read a column and process it outside the main loop. For example, qsort might use a column in its sort comparison routine that is not processed inside the inner loop (and therefore not implicitly specified as a column to be read).  To ensure that such a column is read by the event loop, use the <strong>explicit</strong> keyword. The arguments to this keyword specify columns that should be read into the input record structure even though they are not mentioned in the inner loop. For example:</p><p>  explicit pi pha</p><p>will ensure that the pi and pha columns are read for each row, even if they are not processed in the inner event loop. The <strong>explicit</strong> statement can be placed anywhere.</p><p>Finally, note that <strong>funcalc</strong> currently works on expressions involving \s-1FITS\s0 binary tables and raw event files. We will consider adding support for image expressions at a later point, if there is demand for such support from the community.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO funcalc&hellip;</h2>
        <div class="sectioncontent">
<p>See <a href="../man7/funtools.7.html"><strong>funtools</strong>(7)</a> for a list of Funtools help pages</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="fullquottel.1.html"><span aria-hidden="true">&larr;</span> fullquottel.1: Tool for detecting full quotes in mails or postings</a></li>
   <li class="next"><a href="funcen.1.html">funcen.1: Find centroid (for binary tables) <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

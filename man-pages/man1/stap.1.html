<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>stap: Systemtap script translator/driver</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Systemtap script translator/driver">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="stap (1) manual">
  <meta name="twitter:description" content="Systemtap script translator/driver">
  <meta name="twitter:image" content="https://www.carta.tech/images/systemtap-stap-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/stap.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="stap (1) manual" />
  <meta property="og:description" content="Systemtap script translator/driver" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/systemtap-stap-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">stap<small> (1)</small></h1>
        <p class="lead">Systemtap script translator/driver</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/stap.1.html">
      <span itemprop="name">stap: Systemtap script translator/driver</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/systemtap/">
      <span itemprop="name">systemtap</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/stap.1.html">
      <span itemprop="name">stap: Systemtap script translator/driver</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>stap</strong> [ <em>OPTIONS</em> ] <em>FILENAME</em> [ <em>ARGUMENTS</em> ]</p><p><strong>stap</strong> [ <em>OPTIONS</em> ] <strong>-</strong> [ <em>ARGUMENTS</em> ]</p><p><strong>stap</strong> [ <em>OPTIONS</em> ] <strong>-e</strong><em> SCRIPT</em> [ <em>ARGUMENTS</em> ]</p><p><strong>stap</strong> [ <em>OPTIONS</em> ] <strong>-l</strong><em> PROBE</em> [ <em>ARGUMENTS</em> ]</p><p><strong>stap</strong> [ <em>OPTIONS</em> ] <strong>-L</strong><em> PROBE</em> [ <em>ARGUMENTS</em> ]</p><p><strong>stap</strong> [ <em>OPTIONS</em> ] <strong>--dump-probe-types</strong></p><p><strong>stap</strong> [ <em>OPTIONS</em> ] <strong>--dump-probe-aliases</strong></p><p><strong>stap</strong> [ <em>OPTIONS</em> ] <strong>--dump-functions</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The <em>stap</em> program is the front-end to the Systemtap tool.  It accepts probing instructions written in a simple domain-specific language, translates those instructions into C code, compiles this C code, and loads the resulting module into a running Linux kernel or a DynInst user-space mutator, to perform the requested system trace/probe functions.  You can supply the script in a named file (FILENAME), from standard input (use - instead of FILENAME), or from the command line (using -e SCRIPT).  The program runs until it is interrupted by the user, or if the script voluntarily invokes the <em>exit()</em> function, or by sufficient number of soft errors.</p><p>The language, which is described the <em>SCRIPT LANGUAGE</em> section below, is strictly typed, expressive, declaration free, procedural, prototyping-friendly, and inspired by <em>awk</em> and <em>C</em>. It allows source code points or events in the system to be associated with handlers, which are subroutines that are executed synchronously.  It is somewhat similar conceptually to "breakpoint command lists" in the <em>gdb</em> debugger.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONS</h2>
        <div class="sectioncontent">
<p>The systemtap translator supports the following options.  Any other option prints a list of supported options.  Options may be given on the command line, as usual.  If the file $SYSTEMTAP_DIR/rc exist, options are also loaded from there and interpreted first.  ($SYSTEMTAP_DIR defaults to $HOME/.systemtap if unset.)</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>-</strong></p>
  </dt>
  <dd>
    <p>Use standard input instead of a given FILENAME as probe language input, unless -e SCRIPT is given.</p>
  </dd>
  <dt>
    <p><strong>-h --help</strong></p>
  </dt>
  <dd>
    <p>Show help message.</p>
  </dd>
  <dt>
    <p><strong>-V --version</strong></p>
  </dt>
  <dd>
    <p>Show version message.</p>
  </dd>
  <dt>
    <p><strong>-p</strong><em> NUM</em></p>
  </dt>
  <dd>
    <p>Stop after pass NUM.  The passes are numbered 1-5: parse, elaborate, translate, compile, run.  See the <strong>PROCESSING</strong> section for details.</p>
  </dd>
  <dt>
    <p><strong>-v</strong></p>
  </dt>
  <dd>
    <p>Increase verbosity for all passes.  Produce a larger volume of informative (?) output each time option repeated.</p>
  </dd>
  <dt>
    <p><strong>--vp ABCDE</strong></p>
  </dt>
  <dd>
    <p>Increase verbosity on a per-pass basis.  For example, "--vp&nbsp;002" adds 2 units of verbosity to pass 3 only.  The combination "-v&nbsp;--vp&nbsp;00004" adds 1 unit of verbosity for all passes, and 4 more for pass 5.</p>
  </dd>
  <dt>
    <p><strong>-k</strong></p>
  </dt>
  <dd>
    <p>Keep the temporary directory after all processing.  This may be useful in order to examine the generated C code, or to reuse the compiled kernel object.</p>
  </dd>
  <dt>
    <p><strong>-g</strong></p>
  </dt>
  <dd>
    <p>Guru mode.  Enable parsing of unsafe expert-level constructs like embedded C.</p>
  </dd>
  <dt>
    <p><strong>-P</strong></p>
  </dt>
  <dd>
    <p>Prologue-searching mode.  Activate heuristics to work around incorrect debugging information for $context variables.</p>
  </dd>
  <dt>
    <p><strong>-u</strong></p>
  </dt>
  <dd>
    <p>Unoptimized mode.  Disable unused code elision during elaboration.</p>
  </dd>
  <dt>
    <p><strong>-w</strong></p>
  </dt>
  <dd>
    <p>Suppressed warnings mode.  Disables all warning messages.</p>
  </dd>
  <dt>
    <p><strong>-W</strong></p>
  </dt>
  <dd>
    <p>Treat all warnings as errors.</p>
  </dd>
  <dt>
    <p><strong>-b</strong></p>
  </dt>
  <dd>
    <p>Use bulk mode (percpu files) for kernel-to-user data transfer.</p>
  </dd>
  <dt>
    <p><strong>-t</strong></p>
  </dt>
  <dd>
    <p>Collect timing information on the number of times probe executes and average amount of time spent in each probe-point. Also shows the derivation for each probe-point.</p>
  </dd>
  <dt>
    <p><strong>-s</strong><em>NUM</em></p>
  </dt>
  <dd>
    <p>Use NUM megabyte buffers for kernel-to-user data transfer.  On a multiprocessor in bulk mode, this is a per-processor amount.</p>
  </dd>
  <dt>
    <p><strong>-I</strong><em> DIR</em></p>
  </dt>
  <dd>
    <p>Add the given directory to the tapset search directory.  See the description of pass 2 for details.</p>
  </dd>
  <dt>
    <p><strong>-D</strong><em> NAME=VALUE</em></p>
  </dt>
  <dd>
    <p>Add the given C preprocessor directive to the module Makefile.  These can be used to override limit parameters described below.</p>
  </dd>
  <dt>
    <p><strong>-B</strong><em> NAME=VALUE</em></p>
  </dt>
  <dd>
    <p>Add the given make directive to the kernel module build's make invocation. These can be used to add or override kconfig options.</p>
  </dd>
  <dt>
    <p><strong>-a</strong><em> ARCH</em></p>
  </dt>
  <dd>
    <p>Use a cross-compilation mode for the given target architecture.  This requires access to the cross-compiler and the kernel build tree, and goes along with the <strong>-B CROSS_COMPILE=arch-tool-prefix-</strong> and <strong>-r /build/tree</strong> options.</p>
  </dd>
  <dt>
    <p><strong>--modinfo</strong><em> NAME=VALUE</em></p>
  </dt>
  <dd>
    <p>Add the name/value pair as a MODULE_INFO macro call to the generated module. This may be useful to inform or override various module-related checks in the kernel.</p>
  </dd>
  <dt>
    <p><strong>-G</strong><em> NAME=VALUE</em></p>
  </dt>
  <dd>
    <p>Sets the value of global variable NAME to VALUE when staprun is invoked. This applies to scalar variables declared global in the script/tapset.</p>
  </dd>
  <dt>
    <p><strong>-R</strong><em> DIR</em></p>
  </dt>
  <dd>
    <p>Look for the systemtap runtime sources in the given directory.</p>
  </dd>
  <dt>
    <p><strong>-r</strong><em> /DIR</em></p>
  </dt>
  <dd>
    <p>Build for kernel in given build tree. Can also be set with the <em>SYSTEMTAP_RELEASE</em> environment variable.</p>
  </dd>
  <dt>
    <p><strong>-r</strong><em> RELEASE</em></p>
  </dt>
  <dd>
    <p>Build for kernel in build tree <strong>/lib/modules/RELEASE/build</strong>. Can also be set with the <em>SYSTEMTAP_RELEASE</em> environment variable.</p>
  </dd>
  <dt>
    <p><strong>-m</strong><em> MODULE</em></p>
  </dt>
  <dd>
    <p>Use the given name for the generated kernel object module, instead of a unique randomized name.  The generated kernel object module is copied to the current directory.</p>
  </dd>
  <dt>
    <p><strong>-d</strong><em> MODULE</em></p>
  </dt>
  <dd>
    <p>Add symbol/unwind information for the given module into the kernel object module.  This may enable symbolic tracebacks from those modules/programs, even if they do not have an explicit probe placed into them.</p>
  </dd>
  <dt>
    <p><strong>--ldd</strong></p>
  </dt>
  <dd>
    <p>Add symbol/unwind information for all shared libraries suspected by ldd to be necessary for user-space binaries being probe or listed with the -d option.  Caution: this can make the probe modules considerably larger.</p>
  </dd>
  <dt>
    <p><strong>--all-modules</strong></p>
  </dt>
  <dd>
    <p>Equivalent to specifying "-dkernel" and a "-d" for each kernel module that is currently loaded.  Caution: this can make the probe modules considerably larger.</p>
  </dd>
  <dt>
    <p><strong>-o</strong><em> FILE</em></p>
  </dt>
  <dd>
    <p>Send standard output to named file. In bulk mode, percpu files will start with FILE_ (FILE_cpu with -F) followed by the cpu number. This supports <a href="../man3/strftime.3.html"><strong>strftime</strong>(3)</a> formats for FILE.</p>
  </dd>
  <dt>
    <p><strong>-c</strong><em> CMD</em></p>
  </dt>
  <dd>
    <p>Start the probes, run CMD, and exit when CMD finishes.  This also has the effect of setting target() to the pid of the command ran.</p>
  </dd>
  <dt>
    <p><strong>-x</strong><em> PID</em></p>
  </dt>
  <dd>
    <p>Sets target() to PID. This allows scripts to be written that filter on a specific process. Scripts run independent of the PID's lifespan.</p>
  </dd>
  <dt>
    <p><strong>-e</strong><em> SCRIPT</em></p>
  </dt>
  <dd>
    <p>Run the given SCRIPT specified on the command line.</p>
  </dd>
  <dt>
    <p><strong>-E</strong><em> SCRIPT</em></p>
  </dt>
  <dd>
    <p>Run the given SCRIPT specified. This SCRIPT is run in addition to the main script specified, through -e, or as a script file. This option can be repeated to run multiple scripts, and can be used in listing mode (-l/-L).</p>
  </dd>
  <dt>
    <p><strong>-l</strong><em> PROBE</em></p>
  </dt>
  <dd>
    <p>Instead of running a probe script, just list all available probe points matching the given single probe point.  The pattern may include wildcards and aliases, but not comma-separated multiple probe points. The process result code will indicate failure if there are no matches.</p>
  </dd>
  <dt>
    <p><strong>-L</strong><em> PROBE</em></p>
  </dt>
  <dd>
    <p>Similar to "-l", but list probe points and script-level local variables.</p>
  </dd>
  <dt>
    <p><strong>-F</strong></p>
  </dt>
  <dd>
    <p>Without -o option, load module and start probes, then detach from the module leaving the probes running. With -o option, run staprun in background as a daemon and show its pid.</p>
  </dd>
  <dt>
    <p><strong>-S</strong><em> size[,N]</em></p>
  </dt>
  <dd>
    <p>Sets the maximum size of output file and the maximum number of output files. If the size of output file will exceed <strong>size</strong> , systemtap switches output file to the next file. And if the number of output files exceed <strong>N</strong> , systemtap removes the oldest output file. You can omit the second argument.</p>
  </dd>
  <dt>
    <p><strong>--skip-badvars</strong></p>
  </dt>
  <dd>
    <p>Ignore unresolvable or run-time-inaccessible context variables and substitute with 0, without errors.</p>
  </dd>
  <dt>
    <p><strong>--suppress-handler-errors</strong></p>
  </dt>
  <dd>
    <p>Wrap all probe handlers into something like this</p>
<pre>
try { ... } catch { next }
</pre>
<p>block, which causes any runtime errors to be quietly suppressed. Suppressed errors do not count against <strong>MAXERRORS</strong> limits.  In this mode, the <strong>MAXSKIPPED</strong> limits are also suppressed, so that many errors and skipped probes may be accumulated during a script's runtime.  Any overall counts will still be reported at shutdown.</p>
  </dd>
  <dt>
    <p><strong>--compatible</strong><em> VERSION</em></p>
  </dt>
  <dd>
    <p>Suppress recent script language or tapset changes which are incompatible with given older version of systemtap.  This may be useful if a much older systemtap script fails to run.  See the DEPRECATION section for more details.</p>
  </dd>
  <dt>
    <p><strong>--check-version</strong></p>
  </dt>
  <dd>
    <p>This option is used to check if the active script has any constructs that may be systemtap version specific.  See the DEPRECATION section for more details.</p>
  </dd>
  <dt>
    <p><strong>--clean-cache</strong></p>
  </dt>
  <dd>
    <p>This option prunes stale entries from the cache directory.  This is normally done automatically after successful runs, but this option will trigger the cleanup manually and then exit.  See the CACHING section for more details about cache limits.</p>
  </dd>
  <dt>
    <p><strong>--color</strong>[=<em>WHEN</em>], <strong>--colour</strong>[=<em>WHEN</em>]</p>
  </dt>
  <dd>
    <p>This option controls coloring of error messages. WHEN can be either "never", "always", or "auto" (i.e. enable only if at a terminal). If WHEN is missing, then "always" is assumed. If the option is missing, then "auto" is assumed.</p><p>Colors can be modified using the SYSTEMTAP_COLORS environment variable. The format must be of the form <strong>key1=val1:key2=val2:key3=val3</strong> ...etc. Valid keys are "error", "warning", "source", "caret", and "token". Values constitute Select Graphic Rendition (SGR) parameter(s). Consult the documentation of your terminal for the SGRs it supports. As an example, the default colors would be expressed as <strong>error=01;31:warning=00;33:source=00;34:caret=01:token=01</strong>. If SYSTEMTAP_COLORS is absent, the default colors will be used. If it is empty or invalid, coloring is turned off.</p>
  </dd>
  <dt>
    <p><strong>--disable-cache</strong></p>
  </dt>
  <dd>
    <p>This option disables all use of the cache directory.  No files will be either read from or written to the cache.</p>
  </dd>
  <dt>
    <p><strong>--poison-cache</strong></p>
  </dt>
  <dd>
    <p>This option treats files in the cache directory as invalid.  No files will be read from the cache, but resulting files from this run will still be written to the cache.  This is meant as a troubleshooting aid when stap's cached behavior seems to be misbehaving.</p>
  </dd>
  <dt>
    <p><strong>--privilege</strong>[=<em>stapusr</em> | =<em>stapsys</em> | =<em>stapdev</em>]</p>
  </dt>
  <dd>
    <p>This option instructs <em>stap</em> to examine the script looking for constructs which are not allowed for the specified privilege level (see <em>UNPRIVILEGED USERS</em>). Compilation fails if any such constructs are used. If <em>stapusr</em> or <em>stapsys</em> are specified when using a compile server (see <em>--use-server</em>), the server will examine the script and, if compilation succeeds, the server will cryptographically sign the resulting kernel module, certifying that is it safe for use by users at the specified privilege level.</p><p>If <em>--privilege</em> has not been specified, <em>-pN</em> has not been specified with N &lt; 5, and the invoking user is not <em>root</em>, and is not a member of the group <em>stapdev</em>, then <em>stap</em> will automatically add the appropriate <em>--privilege</em> option to the options already specified.</p>
  </dd>
  <dt>
    <p><strong>--unprivileged</strong></p>
  </dt>
  <dd>
    <p>This option is equivalent to <em>--privilege=stapusr</em>.</p>
  </dd>
  <dt>
    <p><strong>--use-server</strong>[=<em>HOSTNAME</em>[<em>:PORT</em>] | =<em>IP_ADDRESS</em>[<em>:PORT</em>] | =<em>CERT_SERIAL</em>]</p>
  </dt>
  <dd>
    <p>Specify compile-server(s) to be used for compilation and/or in conjunction with <em>--list-servers</em> and <em>--trust-servers</em> (see below). If no argument is supplied, then the default in unprivileged mode (see <em>--privilege</em>) is to select compatible servers which are trusted as SSL peers and as module signers and currently online. Otherwise the default is to select compatible servers which are trusted as SSL peers and currently online. <em>--use-server</em> may be specified more than once, in which case a list of servers is accumulated in the order specified. Servers may be specified by host name, ip address, or by certificate serial number (obtained using <em>--list-servers</em>). The latter is most commonly used when adding or revoking trust in a server (see <em>--trust-servers</em> below). If a server is specified by host name or ip address, then an optional port number may be specified. This is useful for accessing servers which are not on the local network or to specify a particular server.</p><p>IP addresses may be IPv4 or IPv6 addresses.</p><p>If a particular IPv6 address is link local and exists on more than one interface, the intended interface may be specified by appending the address with a percent sign (%) followed by the intended interface name. For example, "fe80::5eff:35ff:fe07:55ca%eth0".</p><p>In order to specify a port number with an IPv6 address, it is necessary to enclose the IPv6 address in square brackets ([]) in order to separate the port number from the rest of the address. For example, "[fe80::5eff:35ff:fe07:55ca]:5000" or "[fe80::5eff:35ff:fe07:55ca%eth0]:5000".</p><p>If <em>--use-server</em> has not been specified, <em>-pN</em> has not been specified with N &lt; 5, and the invoking user not <em>root</em>, is not a member of the group <em>stapdev</em>, but is a member of the group <em>stapusr</em>, then <em>stap</em> will automatically add <em>--use-server</em> to the options already specified.</p>
  </dd>
  <dt>
    <p><strong>--use-server-on-error</strong>[=<strong>yes</strong>|=<strong>no</strong>]</p>
  </dt>
  <dd>
    <p>Instructs stap to retry compilation of a script using a compile server if compilation on the local host fails in a manner which suggests that it might succeed using a server. If this option is not specified, the default is <em>no</em>. If no argument is provided, then the default is <em>yes</em>. Compilation will be retried for certain types of errors (e.g. insufficient data or resources) which may not occur during re-compilation by a compile server. Compile servers will be selected automatically for the re-compilation attempt as if <em>--use-server</em> was specified with no arguments.</p>
  </dd>
  <dt>
    <p><strong>--list-servers</strong><em>[=SERVERS]</em></p>
  </dt>
  <dd>
    <p>Display the status of the requested <em>SERVERS</em>, where <em>SERVERS</em> is a comma-separated list of server attributes. The list of attributes is combined to filter the list of servers displayed. Supported attributes are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>all</strong></p>
  </dt>
  <dd>
    <p>specifies all known servers (trusted SSL peers, trusted module signers, online servers).</p>
  </dd>
  <dt>
    <p><strong>specified</strong></p>
  </dt>
  <dd>
    <p>specifies servers specified using <em>--use-server</em>.</p>
  </dd>
  <dt>
    <p><strong>online</strong></p>
  </dt>
  <dd>
    <p>filters the output by retaining information about servers which are currently online.</p>
  </dd>
  <dt>
    <p><strong>trusted</strong></p>
  </dt>
  <dd>
    <p>filters the output by retaining information about servers which are trusted as SSL peers.</p>
  </dd>
  <dt>
    <p><strong>signer</strong></p>
  </dt>
  <dd>
    <p>filters the output by retaining information about servers which are trusted as module signers (see <em>--privilege</em>).</p>
  </dd>
  <dt>
    <p><strong>compatible</strong></p>
  </dt>
  <dd>
    <p>filters the output by retaining information about servers which are compatible with the current kernel release and architecture.</p>
  </dd>

</dl>
<ul>
<li><p>If no argument is provided, then the default is <strong>specified</strong>. If no servers were specified using <em>--use-server</em>, then the default servers for <em>--use-server</em> are listed.</p><p>Note that <em>--list-servers</em> uses the <em>avahi-daemon</em> service to detect online servers. If this service is not available, then <em>--list-servers</em> will fail to detect any <em>online</em> servers. In order for <em>--list-servers</em> to detect servers listening on IPv6 addresses, the <em>avahi-daemon</em> configuration file <em>/etc/avahi/avahi-daemon.conf</em> must contain an active "use-ipv6=yes" line. The service must be restarted after adding this line in order for IPv6 to be enabled.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>--trust-servers</strong><em>[=TRUST_SPEC]</em></p>
  </dt>
  <dd>
    <p>Grant or revoke trust in compile-servers, specified using <em>--use-server</em> as specified by TRUST_SPEC, where TRUST_SPEC is a comma-separated list specifying the trust which is to be granted or revoked. Supported elements are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>ssl</strong></p>
  </dt>
  <dd>
    <p>trust the specified servers as SSL peers.</p>
  </dd>
  <dt>
    <p><strong>signer</strong></p>
  </dt>
  <dd>
    <p>trust the specified servers as module signers (see <em>--privilege</em>). Only root can specify <strong>signer.</strong></p>
  </dd>
  <dt>
    <p><strong>all-users</strong></p>
  </dt>
  <dd>
    <p>grant trust as an ssl peer for all users on the local host. The default is to grant trust as an ssl peer for the current user only. Trust as a module signer is always granted for all users. Only root can specify <strong>all-users</strong>.</p>
  </dd>
  <dt>
    <p><strong>revoke</strong></p>
  </dt>
  <dd>
    <p>revoke the specified trust. The default is to grant it.</p>
  </dd>
  <dt>
    <p><strong>no-prompt</strong></p>
  </dt>
  <dd>
    <p>do not prompt the user for confirmation before carrying out the requested action. The default is to prompt the user for confirmation.</p>
  </dd>

</dl>
<ul>
<li><p>If no argument is provided, then the default is <strong>ssl</strong>. If no servers were specified using <em>--use-server</em>, then no trust will be granted or revoked.</p></li><li><p>Unless <strong>no-prompt</strong> has been specified, the user will be prompted to confirm the trust to be granted or revoked before the operation is performed.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>--dump-probe-types</strong></p>
  </dt>
  <dd>
    <p>Dumps a list of supported probe types and exits. If <em>--privilege=stapusr</em> is also specified, the list will be limited to probe types available to unprivileged users.</p>
  </dd>
  <dt>
    <p><strong>--dump-probe-aliases</strong></p>
  </dt>
  <dd>
    <p>Dumps a list of all probe aliases found in library files and exits.</p>
  </dd>
  <dt>
    <p><strong>--dump-functions</strong></p>
  </dt>
  <dd>
    <p>Dumps a list of all functions found in library files and exits. Also includes their parameters and types. A function of type 'unknown' indicates a function that does not return a value. Note that not all function/parameter types may be resolved (these are also shown by 'unknown'). This features is very memory-intensive and thus may not work properly with <em>--use-server</em> if the target server imposes an rlimit on process memory (i.e. through the <em>~stap-server/.systemtap/rc</em> configuration file, see <a href="../man8/stap-server.8.html"><strong>stap-server</strong>(8)</a>).</p>
  </dd>
  <dt>
    <p><strong>--remote</strong><em> URL</em></p>
  </dt>
  <dd>
    <p>Set the execution target to the given host.  This option may be repeated to target multiple execution targets.  Passes 1-4 are completed locally as normal to build the script, and then pass 5 will copy the module to the target and run it.  Acceptable URL forms include:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>[USER@]HOSTNAME</strong>, <strong>ssh://[USER@]HOSTNAME</strong></p>
  </dt>
  <dd>
    <p>This mode uses ssh, optionally using a username not matching your own. If a custom ssh_config file is in use, add <strong>SendEnv LANG</strong> to retain internationalization functionality.</p>
  </dd>
  <dt>
    <p><strong>libvirt://DOMAIN</strong>, <strong>libvirt://DOMAIN/LIBVIRT_URI</strong></p>
  </dt>
  <dd>
    <p>This mode uses <em>stapvirt</em> to execute the script on a domain managed by libvirt. Optionally, LIBVIRT_URI may be specified to connect to a specific driver and/or a remote host. For example, to connect to the local privileged QEMU driver, use: --remote libvirt://MyDomain/qemu:///system See the page at &lt;http://libvirt.org/uri.html&gt; for supported URIs. Also see <strong>stapvirt</strong>(1) for more information on how to prepare the domain for stap probing.</p>
  </dd>
  <dt>
    <p><strong>unix:PATH</strong></p>
  </dt>
  <dd>
    <p>This mode connects to a UNIX socket. This can be used with a QEMU virtio-serial port for executing scripts inside a running virtual machine.</p>
  </dd>
  <dt>
    <p><strong>direct://</strong></p>
  </dt>
  <dd>
    <p>Special loopback mode to run on the local host.</p>
  </dd>

</dl>
<ul>
<li></li>
</ul>
  </dd>
  <dt>
    <p><strong>--remote-prefix</strong></p>
  </dt>
  <dd>
    <p>Prefix each line of remote output with "N: ", where N is the index of the remote execution target from which the given line originated.</p>
  </dd>
  <dt>
    <p><strong>--download-debuginfo</strong><em>[=OPTION]</em></p>
  </dt>
  <dd>
    <p>Enable, disable or set a timeout for the automatic debuginfo downloading feature offered by abrt as specified by OPTION, where OPTION is one of the following:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>yes</strong></p>
  </dt>
  <dd>
    <p>enable automatic downloading of debuginfo with no timeout. This is the same as not providing an OPTION value to <em>--download-debuginfo</em></p>
  </dd>
  <dt>
    <p><strong>no</strong></p>
  </dt>
  <dd>
    <p>explicitly disable automatic downloading of debuginfo. This is the same as not using the option at all.</p>
  </dd>
  <dt>
    <p><strong>ask</strong></p>
  </dt>
  <dd>
    <p>show abrt output, and ask before continuing download. No timeout will be set.</p>
  </dd>
  <dt>
    <p><strong>&lt;timeout&gt;</strong></p>
  </dt>
  <dd>
    <p>specify a timeout as a positive number to stop the download if it is taking too long.</p>
  </dd>

</dl>
<ul>
<li></li>
</ul>
  </dd>
  <dt>
    <p><strong>--rlimit-as</strong><em>=NUM</em></p>
  </dt>
  <dd>
    <p>Specify the maximum size of the process's virtual memory (address space), in bytes. If nothing is specified, no limits are imposed.</p>
  </dd>
  <dt>
    <p><strong>--rlimit-cpu</strong><em>=NUM</em></p>
  </dt>
  <dd>
    <p>Specify the CPU time limit, in seconds. If nothing is specified, no limits are imposed.</p>
  </dd>
  <dt>
    <p><strong>--rlimit-nproc</strong><em>=NUM</em></p>
  </dt>
  <dd>
    <p>Specify the maximum number of processes that can be created. If nothing is specified, no limits are imposed.</p>
  </dd>
  <dt>
    <p><strong>--rlimit-stack</strong><em>=NUM</em></p>
  </dt>
  <dd>
    <p>Specify the maximum size of the process stack, in bytes. If nothing is specified, no limits are imposed.</p>
  </dd>
  <dt>
    <p><strong>--rlimit-fsize</strong><em>=NUM</em></p>
  </dt>
  <dd>
    <p>Specify the maximum size of files that the process may create, in bytes. If nothing is specified, no limits are imposed.</p>
  </dd>
  <dt>
    <p><strong>--sysroot</strong><em>=DIR</em></p>
  </dt>
  <dd>
    <p>Specify sysroot directory where target files (executables, libraries, etc.) are located.  With <em>-r RELEASE</em>, the sysroot will be searched for the appropriate kernel build directory.  With <em>-r /DIR</em>, however, the sysroot will not be used to find the kernel build.</p>
  </dd>
  <dt>
    <p><strong>--sysenv</strong><em>=VAR=VALUE</em></p>
  </dt>
  <dd>
    <p>Provide an alternate value for an environment variable where the value on a remote system differs.  Path variables (e.g. PATH, LD_LIBRARY_PATH) are assumed to be relative to the directory provided by <em>--sysroot</em>, if provided.</p>
  </dd>
  <dt>
    <p><strong>--suppress-time-limits</strong></p>
  </dt>
  <dd>
    <p>Disable -DSTP_OVERLOAD related options as well as -DMAXACTION and -DMAXTRYLOCK. This option requires guru mode.</p>
  </dd>
  <dt>
    <p><strong>--runtime</strong><em>=MODE</em></p>
  </dt>
  <dd>
    <p>Set the pass-5 runtime mode.  Valid options are <em>kernel</em> (default) and <em>dyninst</em>.  See <strong>ALTERNATE</strong>RUNTIMES below for more information.</p>
  </dd>
  <dt>
    <p><strong>--dyninst</strong></p>
  </dt>
  <dd>
    <p>Shorthand for <em>--runtime=dyninst</em>.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ARGUMENTS</h2>
        <div class="sectioncontent">
<p>Any additional arguments on the command line are passed to the script parser for substitution.  See below.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SCRIPT LANGUAGE</h2>
        <div class="sectioncontent">
<p>The systemtap script language resembles <em>awk</em> and <em>C</em>. There are two main outermost constructs: probes and functions.  Within these, statements and expressions use C-like operator syntax and precedence.</p><h3>GENERAL SYNTAX</h3>
<p>Whitespace is ignored.  Three forms of comments are supported:</p><p><strong>#</strong> ... shell style, to the end of line, except for $# and @#</p><p><strong>//</strong> ... C++ style, to the end of line</p><p><strong>/*</strong> ... C style ... <strong>*/</strong></p><p>Literals are either strings enclosed in double-quotes (passing through the usual C escape codes with backslashes, and with adjacent string literals glued together, also as in C), or integers (in decimal, hexadecimal, or octal, using the same notation as in C).  All strings are limited in length to some reasonable value (a few hundred bytes). Integers are 64-bit signed quantities, although the parser also accepts (and wraps around) values above positive 2**63.</p><p>In addition, script arguments given at the end of the command line may be inserted.  Use <strong>$1 ... $&lt;NN&gt;</strong> for insertion unquoted, <strong>@1 ... @&lt;NN&gt;</strong> for insertion as a string literal.  The number of arguments may be accessed through <strong>$#</strong> (as an unquoted number) or through <strong>@#</strong> (as a quoted number).  These may be used at any place a token may begin, including within the preprocessing stage.  Reference to an argument number beyond what was actually given is an error.</p>
<h3>PREPROCESSING</h3>
<p>A simple conditional preprocessing stage is run as a part of parsing. The general form is similar to the cond<strong> ? </strong>exp1<strong> : </strong>exp2 ternary operator: <strong>%(</strong> CONDITION <strong>%?</strong> TRUE-TOKENS <strong>%)</strong> <strong>%(</strong> CONDITION <strong>%?</strong> TRUE-TOKENS <strong>%:</strong> FALSE-TOKENS <strong>%)</strong> The CONDITION is either an expression whose format is determined by its first keyword, or a string literals comparison or a numeric literals comparison.  It can be also composed of many alternatives and conjunctions of CONDITIONs (meant as in previous sentence) using || and && respectively. However, parentheses are not supported yet, so remembering that conjunction takes precedence over alternative is important.</p><p>If the first part is the identifier <strong>kernel_vr</strong> or <strong>kernel_v</strong> to refer to the kernel version number, with ("2.6.13-1.322FC3smp") or without ("2.6.13") the release code suffix, then the second part is one of the six standard numeric comparison operators <strong>&lt;</strong>, <strong>&lt;=</strong>, <strong>==</strong>, <strong>!=</strong>, <strong>&gt;</strong>, and <strong>&gt;=</strong>, and the third part is a string literal that contains an RPM-style version-release value.  The condition is deemed satisfied if the version of the target kernel (as optionally overridden by the <strong>-r</strong> option) compares to the given version string.  The comparison is performed by the glibc function <strong>strverscmp</strong>. As a special case, if the operator is for simple equality (<strong>==</strong>), or inequality (<strong>!=</strong>), and the third part contains any wildcard characters (<strong>*</strong> or <strong>?</strong> or <strong>[</strong>), then the expression is treated as a wildcard (mis)match as evaluated by <strong>fnmatch</strong>.</p><p>If, on the other hand, the first part is the identifier <strong>arch</strong> to refer to the processor architecture (as named by the kernel build system ARCH/SUBARCH), then the second part is one of the two string comparison operators <strong>==</strong> or <strong>!=</strong>, and the third part is a string literal for matching it.  This comparison is a wildcard (mis)match.</p><p>Similarly, if the first part is an identifier like <strong>CONFIG_something</strong> to refer to a kernel configuration option, then the second part is <strong>==</strong> or <strong>!=</strong>, and the third part is a string literal for matching the value (commonly "y" or "m").  Nonexistent or unset kernel configuration options are represented by the empty string.  This comparison is also a wildcard (mis)match.</p><p>If the first part is the identifier <strong>systemtap_v</strong>, the test refers to the systemtap compatibility version, which may be overridden for old scripts with the <strong>--compatible</strong> flag.  The comparison operator is as is for <strong>kernel_v</strong> and the right operand is a version string.  See also the DEPRECATION section below.</p><p>If the first part is the identifier <strong>systemtap_privilege</strong>, the test refers to the privilege level that the systemtap script is compiled with. Here the second part is <strong>==</strong> or <strong>!=</strong>, and the third part is a string literal, either "stapusr" or "stapsys" or "stapdev".</p><p>If the first part is the identifier <strong>guru_mode</strong>, the test refers to if the systemtap script is compiled with guru_mode. Here the second part is <strong>==</strong> or <strong>!=</strong>, and the third part is a number, either 1 or 0.</p><p>If the first part is the identifier <strong>runtime</strong>, the test refers to the systemtap runtime mode. See <strong>ALTERNATE</strong>RUNTIMES below for more information on runtimes. The second part is one of the two string comparison operators <strong>==</strong> or <strong>!=</strong>, and the third part is a string literal for matching it.  This comparison is a wildcard (mis)match.</p><p>Otherwise, the CONDITION is expected to be a comparison between two string literals or two numeric literals.  In this case, the arguments are the only variables usable.</p><p>The TRUE-TOKENS and FALSE-TOKENS are zero or more general parser tokens (possibly including nested preprocessor conditionals), and are passed into the input stream if the condition is true or false.  For example, the following code induces a parse error unless the target kernel version is newer than 2.6.5: %( kernel_v &lt;= "2.6.5" %? **ERROR** %) # invalid token sequence The following code might adapt to hypothetical kernel version drift: probe kernel.function (</p>
<pre>
  %( kernel_v &lt;= "2.6.12" %? "__mm_do_fault" %:
     %( kernel_vr == "2.6.13*smp" %? "do_page_fault" %:
        UNSUPPORTED %) %)
</pre>
<p>) { /* ... */ }</p><p>%( arch == "ia64" %?</p>
<pre>
   probe syscall.vliw = kernel.function("vliw_widget") {}
</pre>
<p>%)</p>
<h3>PREPROCESSOR MACROS</h3>
<p>The preprocessor also supports a simple macro facility, run as a separate pass before conditional preprocessing.</p><p>Macros are defined using the following construct: @define NAME %( BODY %) @define NAME(PARAM_1, PARAM_2, ...) %( BODY %) Macros, and parameters inside a macro body, are both invoked by prefixing the macro name with an @ symbol: @define foo %( x %) @define add(a,b) %( ((@a)+(@b)) %)</p>
<pre>
   @foo = @add(2,2)
</pre>
<p>Macro expansion is currently performed in a separate pass before conditional compilation. Therefore, both TRUE- and FALSE-tokens in conditional expressions will be macroexpanded regardless of how the condition is evaluated. This can sometimes lead to errors: // The following results in a conflict: %( CONFIG_UTRACE == "y" %?</p>
<pre>
    @define foo %( process.syscall %)
</pre>
<p>%:</p>
<pre>
    @define foo %( **ERROR** %)
</pre>
<p>%)</p><p>// The following works properly as expected: @define foo %(</p>
<pre>
  %( CONFIG_UTRACE == "y" %? process.syscall %: **ERROR** %)
</pre>
<p>%) The first example is incorrect because both @defines are evaluated in a pass prior to the conditional being evaluated.</p><p>Normally, a macro definition is local to the file it occurs in. Thus, defining a macro in a tapset does not make it available to the user of the tapset. Publically available library macros can be defined by including .stpm files on the tapset search path. These files may only contain @define constructs, which become visible across all tapsets and user scripts.</p>
<h3>VARIABLES</h3>
<p>Identifiers for variables and functions are an alphanumeric sequence, and may include <strong>_</strong> and <strong>$</strong> characters.  They may not start with a plain digit, as in C.  Each variable is by default local to the probe or function statement block within which it is mentioned, and therefore its scope and lifetime is limited to a particular probe or function invocation.</p><p>Scalar variables are implicitly typed as either string or integer. Associative arrays also have a string or integer value, and a tuple of strings and/or integers serving as a key.  Here are a few basic expressions. var1 = 5 var2 = "bar" array1 [pid()] = "name"     # single numeric key array2 ["foo",4,i++] += 5   # vector of string/num/num keys if (["hello",5,4] in array2) println ("yes")  # membership test</p><p>The translator performs <em>type inference</em> on all identifiers, including array indexes and function parameters. Inconsistent type-related use of identifiers signals an error.</p><p>Variables may be declared global, so that they are shared amongst all probes and live as long as the entire systemtap session.  There is one namespace for all global variables, regardless of which script file they are found within.  Concurrent access to global variables is automatically protected with locks, see the <strong>SAFETY AND SECURITY</strong> section for more details.  A global declaration may be written at the outermost level anywhere, not within a block of code.  Global variables which are written but never read will be displayed automatically at session shutdown.  The translator will infer for each its value type, and if it is used as an array, its key types.  Optionally, scalar globals may be initialized with a string or number literal.  The following declaration marks variables as global. <strong>global</strong> var1<strong>,</strong> var2<strong>,</strong> var3=4</p><p>Global variables can also be set as module options. One can do this by either using the -G option, or the module must first be compiled using stap -p4. Global variables can then be set on the command line when calling staprun on the module generated by stap -p4. See <a href="../man8/staprun.8.html"><strong>staprun</strong>(8)</a> for more information.</p><p>Arrays are limited in size by the MAXMAPENTRIES variable -- see the <strong>SAFETY AND SECURITY</strong> section for details.  Optionally, global arrays may be declared with a maximum size in brackets, overriding MAXMAPENTRIES for that array only. Note that this doesn't indicate the type of keys for the array, just the size. <strong>global</strong> tiny_array[10]<strong>,</strong> normal_array<strong>,</strong> big_array[50000]</p><p>Arrays may be configured for wrapping using the '%' suffix.  This causes older elements to be overwritten if more elements are inserted than the array can hold. This works for both associative and statistics typed arrays. <strong>global</strong> wrapped_array1%[10]<strong>,</strong> wrapped_array2%</p><p>Many types of probe points provide context variables, which are run-time values, safely extracted from the kernel or userspace program being probed.  These are prefixed with the <strong>$</strong> character.  The CONTEXT VARIABLES section in <em>stapprobes</em>(3stap) lists what is available for each type of probe point.  These context variables become normal string or numeric scalars once they are stored in normal script variables.  See the TYPECASTING section below on how to to turn them back into typed pointers for further processing as context variables.</p>
<h3>STATEMENTS</h3>
<p>Statements enable procedural control flow.  They may occur within functions and probe handlers.  The total number of statements executed in response to any single probe event is limited to some number defined by a macro in the translated C code, and is in the neighbourhood of 1000.</p>
<dl class='dl-vertical'>
  <dt>
    <p>EXP</p>
  </dt>
  <dd>
    <p>Execute the string- or integer-valued expression and throw away the value.</p>
  </dd>
  <dt>
    <p><strong>{</strong> STMT1 STMT2 ... <strong>}</strong></p>
  </dt>
  <dd>
    <p>Execute each statement in sequence in this block.  Note that separators or terminators are generally not necessary between statements.</p>
  </dd>
  <dt>
    <p><strong>;</strong></p>
  </dt>
  <dd>
    <p>Null statement, do nothing.  It is useful as an optional separator between statements to improve syntax-error detection and to handle certain grammar ambiguities.</p>
  </dd>
  <dt>
    <p><strong>if</strong> (EXP) STMT1 [ <strong>else</strong> STMT2 ]</p>
  </dt>
  <dd>
    <p>Compare integer-valued EXP to zero.  Execute the first (non-zero) or second STMT (zero).</p>
  </dd>
  <dt>
    <p><strong>while</strong> (EXP) STMT</p>
  </dt>
  <dd>
    <p>While integer-valued EXP evaluates to non-zero, execute STMT.</p>
  </dd>
  <dt>
    <p><strong>for</strong> (EXP1; EXP2; EXP3) STMT</p>
  </dt>
  <dd>
    <p>Execute EXP1 as initialization.  While EXP2 is non-zero, execute STMT, then the iteration expression EXP3.</p>
  </dd>
  <dt>
    <p><strong>foreach</strong> (VAR <strong>in</strong> ARRAY [ <strong>limit</strong> EXP ]) STMT</p>
  </dt>
  <dd>
    <p>Loop over each element of the named global array, assigning current key to VAR.  The array may not be modified within the statement. By adding a single <strong>+</strong> or <strong>-</strong> operator after the VAR or the ARRAY identifier, the iteration will proceed in a sorted order, by ascending or descending index or value. If the array contains statistics aggregates, adding the desired <strong>@operator</strong> between the ARRAY identifier and the <strong>+</strong> or <strong>-</strong> will specify the sorting aggregate function.  See the STATISTICS section below for the ones available.  Default is <strong>@count</strong>. Using the optional <strong>limit</strong> keyword limits the number of loop iterations to EXP times.  EXP is evaluated once at the beginning of the loop.</p>
  </dd>
  <dt>
    <p><strong>foreach</strong> ([VAR1, VAR2, ...] <strong>in</strong> ARRAY [ <strong>limit</strong> EXP ]) STMT</p>
  </dt>
  <dd>
    <p>Same as above, used when the array is indexed with a tuple of keys. A sorting suffix may be used on at most one VAR or ARRAY identifier.</p>
  </dd>
  <dt>
    <p><strong>foreach</strong> ([VAR1, VAR2, ...] <strong>in</strong> ARRAY [INDEX1, INDEX2, ...] [ <strong>limit</strong> EXP ]) STMT</p>
  </dt>
  <dd>
    <p>Same as above, where iterations are limited to elements in the array where the keys match the index values specified. The symbol * can be used to specify an index and will be treated as a wildcard.</p>
  </dd>
  <dt>
    <p><strong>foreach</strong> (VALUE = VAR <strong>in</strong> ARRAY [ <strong>limit</strong> EXP ]) STMT</p>
  </dt>
  <dd>
    <p>This variant of foreach saves current value into VALUE on each iteration, so it is the same as ARRAY[VAR].  This also works with a tuple of keys.  Sorting suffixes on VALUE have the same effect as on ARRAY.</p>
  </dd>
  <dt>
    <p><strong>foreach</strong> (VALUE = VAR <strong>in</strong> ARRAY [INDEX1, INDEX2, ...] [ <strong>limit</strong> EXP ]) STMT</p>
  </dt>
  <dd>
    <p>Same as above, where iterations are limited to elements in the array where the keys match the index values specified. The symbol * can be used to specify an index and will be treated as a wildcard.</p>
  </dd>
  <dt>
    <p><strong>break</strong>, <strong>continue</strong></p>
  </dt>
  <dd>
    <p>Exit or iterate the innermost nesting loop (<strong>while</strong> or <strong>for</strong> or <strong>foreach</strong>) statement.</p>
  </dd>
  <dt>
    <p><strong>return</strong> EXP</p>
  </dt>
  <dd>
    <p>Return EXP value from enclosing function.  If the function's value is not taken anywhere, then a return statement is not needed, and the function will have a special "unknown" type with no return value.</p>
  </dd>
  <dt>
    <p><strong>next</strong></p>
  </dt>
  <dd>
    <p>Return now from enclosing probe handler.  This is especially useful in probe aliases that apply event filtering predicates.</p>
  </dd>
  <dt>
    <p><strong>try</strong> { STMT1 } <strong>catch</strong> { STMT2 }</p>
  </dt>
  <dd>
    <p>Run the statements in the first block.  Upon any run-time errors, abort STMT1 and start executing STMT2.  Any errors in STMT2 will propagate to outer try/catch blocks, if any.</p>
  </dd>
  <dt>
    <p><strong>try</strong> { STMT1 } <strong>catch</strong>(VAR) { STMT2 }</p>
  </dt>
  <dd>
    <p>Same as above, plus assign the error message to the string scalar variable VAR.</p>
  </dd>
  <dt>
    <p><strong>delete</strong> ARRAY[INDEX1, INDEX2, ...]</p>
  </dt>
  <dd>
    <p>Remove from ARRAY the element specified by the index tuple. If the index tuple contains a * in place of an index, the * is treated as a wildcard and all elements with keys that match the index tuple will be removed from ARRAY. The value will no longer be available, and subsequent iterations will not report the element. It is not an error to delete an element that does not exist.</p>
  </dd>
  <dt>
    <p><strong>delete</strong> ARRAY</p>
  </dt>
  <dd>
    <p>Remove all elements from ARRAY.</p>
  </dd>
  <dt>
    <p><strong>delete</strong> SCALAR</p>
  </dt>
  <dd>
    <p>Removes the value of SCALAR.  Integers and strings are cleared to 0 and "" respectively, while statistics are reset to the initial empty state.</p>
  </dd>

</dl>

<h3>EXPRESSIONS</h3>
<p>Systemtap supports a number of operators that have the same general syntax, semantics, and precedence as in C and awk.  Arithmetic is performed as per typical C rules for signed integers.  Division by zero or overflow is detected and results in an error.</p>
<dl class='dl-vertical'>
  <dt>
    <p>binary numeric operators</p>
  </dt>
  <dd>
    <p><strong>* / % + - &gt;&gt; &lt;&lt; & ^ | && ||</strong></p>
  </dd>
  <dt>
    <p>binary string operators</p>
  </dt>
  <dd>
    <p><strong>.</strong> (string concatenation)</p>
  </dd>
  <dt>
    <p>numeric assignment operators</p>
  </dt>
  <dd>
    <p><strong>= *= /= %= += -= &gt;&gt;= &lt;&lt;= &= ^= |=</strong></p>
  </dd>
  <dt>
    <p>string assignment operators</p>
  </dt>
  <dd>
    <p><strong>= .=</strong></p>
  </dd>
  <dt>
    <p>unary numeric operators</p>
  </dt>
  <dd>
    <p><strong>+ - ! ~ ++ --</strong></p>
  </dd>
  <dt>
    <p>binary numeric, string comparison or regex matching operators</p>
  </dt>
  <dd>
    <p><strong>&lt; &gt; &lt;= &gt;= == != =~ !~</strong></p>
  </dd>
  <dt>
    <p>ternary operator</p>
  </dt>
  <dd>
    <p>cond<strong> ? </strong>exp1<strong> : </strong>exp2</p>
  </dd>
  <dt>
    <p>grouping operator</p>
  </dt>
  <dd>
    <p><strong>(</strong> exp <strong>)</strong></p>
  </dd>
  <dt>
    <p>function call</p>
  </dt>
  <dd>
    <p>fn <strong>(</strong>[ arg1, arg2, ... ]<strong>)</strong></p>
  </dd>
  <dt>
    <p>array membership check</p>
  </dt>
  <dd>
    <p>exp<strong> in </strong>array</p><p><strong>[</strong>exp1<strong>, </strong>exp2<strong>, </strong>...<strong>] in </strong>array</p><p><strong>[</strong>*<strong>, </strong>*<strong>, ... </strong>]<strong>in</strong> array</p>
  </dd>

</dl>

<h3>REGULAR EXPRESSION MATCHING</h3>
<p>The scripting language supports regular expression matching. The basic syntax is as follows: <strong>exp</strong> =~ <strong>regex</strong> <strong>exp</strong> !~ <strong>regex</strong> (The first operand must be an expression evaluating to a string; the second operand must be a string literal containing a syntactically valid regular expression.)</p><p>The regular expression syntax supports most of the features of POSIX Extended Regular Expressions, except for subexpression reuse ("&#92;1") functionality. The ability to capture and extract the contents of the matched string and subexpressions has not yet been implemented.</p>
<h3>PROBES</h3>
<p>The main construct in the scripting language identifies probes. Probes associate abstract events with a statement block ("probe handler") that is to be executed when any of those events occur.  The general syntax is as follows: <strong>probe</strong> PROBEPOINT [<strong>,</strong> PROBEPOINT] <strong>{</strong> [STMT ...] <strong>}</strong> <strong>probe</strong> PROBEPOINT [<strong>,</strong> PROBEPOINT] <strong>if (</strong>CONDITION<strong>) { </strong>[STMT ...]<strong> }</strong></p><p>Events are specified in a special syntax called "probe points".  There are several varieties of probe points defined by the translator, and tapset scripts may define further ones using aliases.  Probe points may be wildcarded, grouped, or listed in preference sequences, or declared optional.  More details on probe point syntax and semantics are listed on the <em>stapprobes</em>(3stap) manual page.</p><p>The probe handler is interpreted relative to the context of each event.  For events associated with kernel code, this context may include <em>variables</em> defined in the <em>source code</em> at that spot.  These "context variables" are presented to the script as variables whose names are prefixed with "$".  They may be accessed only if the kernel's compiler preserved them despite optimization. This is the same constraint that a debugger user faces when working with optimized code.  In addition, the objects must exist in paged-in memory at the moment of the systemtap probe handler's execution, because systemtap must not cause (suppresses) any additional paging. Some probe types have very little context. See the <em>stapprobes</em>(3stap) man pages to see the kinds of context variables available at each kind of probe point.</p><p>Probes may be decorated with an <em>arming condition</em>, consisting of a simple boolean expression on read-only global script variables.  While disarmed (condition evaluates to false), some probe types reduce or eliminate their run-time overheads.  When an arming condition evaluates to true, probes will be <em>soon</em> re-armed, and their probe handlers will start getting called as the events fire.  (Some events may be lost during the arming interval.  If this is unacceptable, do not use arming conditions for those probes.)</p><p>New probe points may be defined using "aliases".  Probe point aliases look similar to probe definitions, but instead of activating a probe at the given point, it just defines a new probe point name as an alias to an existing one. There are two types of alias, i.e. the prologue style and the epilogue style which are identified by "=" and "+=" respectively.</p><p>For prologue style alias, the statement block that follows an alias definition is implicitly added as a prologue to any probe that refers to the alias. While for the epilogue style alias, the statement block that follows an alias definition is implicitly added as an epilogue to any probe that refers to the alias.  For example: probe syscall.read = kernel.function("sys_read") {</p>
<pre>
  fildes = $fd
  if (execname() == "init") next  # skip rest of probe
</pre>
<p>} defines a new probe point <em>syscall.read</em>, which expands to <em>kernel.function("sys_read")</em>, with the given statement as a prologue, which is useful to predefine some variables for the alias user and/or to skip probe processing entirely based on some conditions.  And probe syscall.read += kernel.function("sys_read") {</p>
<pre>
  if (tracethis) println ($fd)
</pre>
<p>} defines a new probe point with the given statement as an epilogue, which is useful to take actions based upon variables set or left over by the the alias user.  Please note that in each case, the statements in the alias handler block are treated ordinarily, so that variables assigned there constitute mere initialization, not a macro substitution.</p><p>An alias is used just like a built-in probe type. probe syscall.read {</p>
<pre>
  printf("reading fd=%d\n", fildes)
  if (fildes &gt; 10) tracethis = 1
</pre>
<p>}</p>
<h3>FUNCTIONS</h3>
<p>Systemtap scripts may define subroutines to factor out common work. Functions take any number of scalar (integer or string) arguments, and must return a single scalar (integer or string).  An example function declaration looks like this: function thisfn (arg1, arg2) {</p>
<pre>
   return arg1 + arg2
</pre>
<p>} Note the general absence of type declarations, which are instead inferred by the translator.  However, if desired, a function definition may include explicit type declarations for its return value and/or its arguments.  This is especially helpful for embedded-C functions.  In the following example, the type inference engine need only infer type type of arg2 (a string). function thatfn:string (arg1:long, arg2) {</p>
<pre>
   return sprint(arg1) . arg2
</pre>
<p>} Functions may call others or themselves recursively, up to a fixed nesting limit.  This limit is defined by a macro in the translated C code and is in the neighbourhood of 10.</p>
<h3>PRINTING</h3>
<p>There are a set of function names that are specially treated by the translator.  They format values for printing to the standard systemtap output stream in a more convenient way.  The <em>sprint*</em> variants return the formatted string instead of printing it.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>print</strong>, <strong>sprint</strong></p>
  </dt>
  <dd>
    <p>Print one or more values of any type, concatenated directly together.</p>
  </dd>
  <dt>
    <p><strong>println</strong>, <strong>sprintln</strong></p>
  </dt>
  <dd>
    <p>Print values like <em>print</em> and <em>sprint</em>, but also append a newline.</p>
  </dd>
  <dt>
    <p><strong>printd</strong>, <strong>sprintd</strong></p>
  </dt>
  <dd>
    <p>Take a string delimiter and two or more values of any type, and print the values with the delimiter interposed.  The delimiter must be a literal string constant.</p>
  </dd>
  <dt>
    <p><strong>printdln</strong>, <strong>sprintdln</strong></p>
  </dt>
  <dd>
    <p>Print values with a delimiter like <em>printd</em> and <em>sprintd</em>, but also append a newline.</p>
  </dd>
  <dt>
    <p><strong>printf</strong>, <strong>sprintf</strong></p>
  </dt>
  <dd>
    <p>Take a formatting string and a number of values of corresponding types, and print them all.  The format must be a literal string constant.</p>
  </dd>

</dl>
<p>The <em>printf</em> formatting directives similar to those of C, except that they are fully type-checked by the translator:</p>
<dl class='dl-vertical'>
  <dt>
    <p>%b</p>
  </dt>
  <dd>
    <p>Writes a binary blob of the value given, instead of ASCII text.  The width specifier determines the number of bytes to write; valid specifiers are %b %1b %2b %4b %8b.  Default (%b) is 8 bytes.</p>
  </dd>
  <dt>
    <p>%c</p>
  </dt>
  <dd>
    <p>Character.</p>
  </dd>
  <dt>
    <p>%d,%i</p>
  </dt>
  <dd>
    <p>Signed decimal.</p>
  </dd>
  <dt>
    <p>%m</p>
  </dt>
  <dd>
    <p>Safely reads kernel memory at the given address, outputs its content.  The optional precision specifier (not field width) determines the number of bytes to read - default is 1 byte.  %10.4m prints 4 bytes of the memory in a 10-character-wide field.</p>
  </dd>
  <dt>
    <p>%M</p>
  </dt>
  <dd>
    <p>Same as %m, but outputs in hexadecimal.  The minimal size of output is double the optional precision specifier - default is 1 byte (2 hex chars).  %10.4M prints 4 bytes of the memory as 8 hexadecimal characters in a 10-character-wide field.</p>
  </dd>
  <dt>
    <p>%o</p>
  </dt>
  <dd>
    <p>Unsigned octal.</p>
  </dd>
  <dt>
    <p>%p</p>
  </dt>
  <dd>
    <p>Unsigned pointer address.</p>
  </dd>
  <dt>
    <p>%s</p>
  </dt>
  <dd>
    <p>String.</p>
  </dd>
  <dt>
    <p>%u</p>
  </dt>
  <dd>
    <p>Unsigned decimal.</p>
  </dd>
  <dt>
    <p>%x</p>
  </dt>
  <dd>
    <p>Unsigned hex value, in all lower-case.</p>
  </dd>
  <dt>
    <p>%X</p>
  </dt>
  <dd>
    <p>Unsigned hex value, in all upper-case.</p>
  </dd>
  <dt>
    <p>%%</p>
  </dt>
  <dd>
    <p>Writes a %.</p>
  </dd>

</dl>
<p>The <em>#</em> flag selects the alternate forms.  For octal, this prefixes a 0.  For hex, this prefixes 0x or 0X, depending on case.  For characters, this escapes non-printing values with either C-like escapes or raw octal.</p><p>Examples: a = "alice", b = "bob", p = 0x1234abcd, i = 123, j = -1, id[a] = 1234, id[b] = 4567 print("hello") 	Prints: hello println(b) 	Prints: bob&#92;n println(a . " is " . sprint(16)) 	Prints: alice is 16 foreach (name in id)  printdln("|", strlen(name), name, id[name]) 	Prints: 5|alice|1234&#92;n3|bob|4567 printf("%c is %s; %x or %X or %p; %d or %u&#92;n",97,a,p,p,p,j,j) 	Prints: a is alice; 1234abcd or 1234ABCD or 0x1234abcd; -1 or 18446744073709551615&#92;n printf("2 bytes of kernel buffer at address %p: %2m", p, p) 	Prints: 2 byte of kernel buffer at address 0x1234abcd: &lt;binary data&gt; printf("%4b", p) 	Prints (these values as binary data): 0x1234abcd printf("%#o %#x %#X&#92;n", 1, 2, 3) 	Prints: 01 0x2 0X3 printf("%#c %#c %#c&#92;n", 0, 9, 42) 	Prints: &#92;000 &#92;t *</p>
<h3>STATISTICS</h3>
<p>It is often desirable to collect statistics in a way that avoids the penalties of repeatedly exclusive locking the global variables those numbers are being put into.  Systemtap provides a solution using a special operator to accumulate values, and several pseudo-functions to extract the statistical aggregates.</p><p>The aggregation operator is <em>&lt;&lt;&lt;</em>, and resembles an assignment, or a C++ output-streaming operation. The left operand specifies a scalar or array-index lvalue, which must be declared global.  The right operand is a numeric expression.  The meaning is intuitive: add the given number to the pile of numbers to compute statistics of.  (The specific list of statistics to gather is given separately, by the extraction functions.) foo &lt;&lt;&lt; 1 stats[pid()] &lt;&lt;&lt; memsize</p><p>The extraction functions are also special.  For each appearance of a distinct extraction function operating on a given identifier, the translator arranges to compute a set of statistics that satisfy it. The statistics system is thereby "on-demand".  Each execution of an extraction function causes the aggregation to be computed for that moment across all processors.</p><p>Here is the set of extractor functions.  The first argument of each is the same style of lvalue used on the left hand side of the accumulate operation.  The <em>@count(v)</em>, <em>@sum(v)</em>, <em>@min(v)</em>, <em>@max(v)</em>, <em>@avg(v)</em> extractor functions compute the number/total/minimum/maximum/average of all accumulated values.  The resulting values are all simple integers.  Arrays containing aggregates may be sorted and iterated. See the <strong>foreach</strong> construct above.</p><p>Histograms are also available, but are more complicated because they have a vector rather than scalar value. <em>@hist_linear(v,start,stop,interval)</em> represents a linear histogram from "start" to "stop" by increments of "interval".  The interval must be positive. Similarly, <em>@hist_log(v)</em> represents a base-2 logarithmic histogram. Printing a histogram with the <em>print</em> family of functions renders a histogram object as a tabular "ASCII art" bar chart. probe timer.profile {</p>
<pre>
  x[1] &lt;&lt;&lt; pid()
  x[2] &lt;&lt;&lt; uid()
  y &lt;&lt;&lt; tid()
</pre>
<p>} global x // an array containing aggregates global y // a scalar probe end {</p>
<pre>
  foreach ([i] in x @count+) {
     printf ("x[%d]: avg %d = sum %d / count %d&#92;n",
             i, @avg(x[i]), @sum(x[i]), @count(x[i]))
     println (@hist_log(x[i]))
  }
  println ("y:")
  println (@hist_log(y))
</pre>
<p>}</p>
<h3>TYPECASTING</h3>
<p>Once a pointer (see the CONTEXT VARIABLES section of <em>stapprobes</em>(3stap)) has been saved into a script integer variable, the translator loses the type information necessary to access members from that pointer.  Using the <em>@cast()</em> operator tells the translator how to interpret the number as a typed pointer. @cast(p, "type_name"[, "module"])-&gt;member</p><p>This will interpret <em>p</em> as a pointer to a struct/union named <em>type_name</em> and dereference the <em>member</em> value.  Further <em>-&gt;subfield</em> expressions may be appended to dereference more levels.</p><p>NOTE: the same dereferencing operator <em>-&gt;</em> is used to refer to both direct containment or pointer indirection. Systemtap automatically determines which.  The optional <em>module</em> tells the translator where to look for information about that type. Multiple modules may be specified as a list with <em>:</em> separators.  If the module is not specified, it will default either to the probe module for dwarf probes, or to "kernel" for functions and all other probes types.</p><p>The translator can create its own module with type information from a header surrounded by angle brackets, in case normal debuginfo is not available.  For kernel headers, prefix it with "kernel" to use the appropriate build system. All other headers are build with default GCC parameters into a user module. Multiple headers may be specified in sequence to resolve a codependency. @cast(tv, "timeval", "&lt;sys/time.h&gt;")-&gt;tv_sec @cast(task, "task_struct", "kernel&lt;linux/sched.h&gt;")-&gt;tgid @cast(task, "task_struct",</p>
<pre>
      "kernel&lt;linux/sched.h&gt;&lt;linux/fs_struct.h&gt;")-&gt;fs-&gt;umask
</pre>
<p>Values acquired by <strong>@cast</strong> may be pretty-printed by the <strong>$</strong> and <strong>$$</strong> suffix operators, the same way as described in the CONTEXT VARIABLES section of the <em>stapprobes</em>(3stap) manual page.</p><p>When in guru mode, the translator will also allow scripts to assign new values to members of typecasted pointers.</p><p>Typecasting is also useful in the case of <em>void*</em> members whose type may be determinable at runtime. probe foo {</p>
<pre>
  if ($var-&gt;type == 1) {
    value = @cast($var-&gt;data, "type1")-&gt;bar
  } else {
    value = @cast($var-&gt;data, "type2")-&gt;baz
  }
  print(value)
</pre>
<p>}</p>
<h3>EMBEDDED C</h3>
<p>When in guru mode, the translator accepts embedded code in the top level of the script.  Such code is enclosed between <em>%{</em> and <em>%}</em> markers, and is transcribed verbatim, without analysis, in some sequence, into the top level of the generated C code.  At the outermost level, this may be useful to add <em>#include</em> instructions, and any auxiliary definitions for use by other embedded code.</p><p>Another place where embedded code is permitted is as a function body. In this case, the script language body is replaced entirely by a piece of C code enclosed again between <em>%{</em> and <em>%}</em> markers. This C code may do anything reasonable and safe.  There are a number of undocumented but complex safety constraints on atomicity, concurrency, resource consumption, and run time limits, so this is an advanced technique.</p><p>The memory locations set aside for input and output values are made available to it using macros <em>STAP_ARG_*</em> and <em>STAP_RETVALUE</em>. Errors may be signalled with STAP_ERROR.  The function may return early with STAP_RETURN.  Here are some examples: function integer_ops (val) %{</p>
<pre>
  STAP_RETVALUE = STAP_ARG_val + 1;
  if (STAP_RETVALUE == 4)
      STAP_ERROR("wrong guess: %d", (int) STAP_RETVALUE);
  if (STAP_RETVALUE == 3)
      <strong>STAP_RETURN</strong>(0);
  STAP_RETVALUE ++;
</pre>
<p>%} function string_ops (val) %{</p>
<pre>
  strlcpy (STAP_RETVALUE, STAP_ARG_val, MAXSTRINGLEN);
  strlcat (STAP_RETVALUE, "one", MAXSTRINGLEN);
  if (strcmp (STAP_RETVALUE, "three-two-one"))
      STAP_RETURN("parameter should be three-two-");
</pre>
<p>%} function no_ops () %{</p>
<pre>
    STAP_RETURN(); /* function inferred with no return value */
</pre>
<p>%} The function argument and return value types have to be inferred by the translator from the call sites in order for this to work. The user should examine C code generated for ordinary script-language functions in order to write compatible embedded-C ones.</p><p>The last place where embedded code is permitted is as an expression rvalue. In this case, the C code enclosed between <em>%{</em> and <em>%}</em> markers is interpreted as an ordinary expression value.  It is assumed to be a normal 64-bit signed number, unless the marker <em>/* string */</em> is included, in which case it's treated as a string. function add_one (val) {</p>
<pre>
  return val + %{ 1 %}
</pre>
<p>} function add_string_two (val) {</p>
<pre>
  return val . %{ /* string */ "two" %}
</pre>
<p>}</p><p>The embedded-C code may contain markers to assert optimization and safety properties.</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>/* pure */</em></p>
  </dt>
  <dd>
    <p>means that the C code has no side effects and may be elided entirely if its value is not used by script code.</p>
  </dd>
  <dt>
    <p><em>/* unprivileged */</em></p>
  </dt>
  <dd>
    <p>means that the C code is so safe that even unprivileged users are permitted to use it.</p>
  </dd>
  <dt>
    <p><em>/* myproc-unprivileged */</em></p>
  </dt>
  <dd>
    <p>means that the C code is so safe that even unprivileged users are permitted to use it, provided that the target of the current probe is within the user's own process.</p>
  </dd>
  <dt>
    <p><em>/* guru */</em></p>
  </dt>
  <dd>
    <p>means that the C code is so unsafe that a systemtap user must specify <em>-g</em> (guru mode) to use this.</p>
  </dd>
  <dt>
    <p><em>/* unmangled */</em></p>
  </dt>
  <dd>
    <p>in an embedded-C function, means that the legacy (pre-1.8) argument access syntax should be made available inside the function. Hence, in addition to <em>STAP_ARG_foo</em> and <em>STAP_RETVALUE</em> one can use <em>THIS-&gt;foo</em> and <em>THIS-&gt;__retvalue</em> respectively inside the function. This is useful for quickly migrating code written for SystemTap version 1.7 and earlier.</p>
  </dd>
  <dt>
    <p><em>/* string */</em></p>
  </dt>
  <dd>
    <p>in embedded-C expressions only, means that the expression has <em>const char *</em> type and should be treated as a string value, instead of the default long numeric.</p>
  </dd>

</dl>

<h3>BUILT-INS</h3>
<p>A set of builtin probe point aliases are provided by the scripts installed in the directory specified in the <a href="../man7/stappaths.7.html"><strong>stappaths</strong>(7)</a> manual page.  The functions are described in the <em>stapprobes</em>(3stap) manual page.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PROCESSING</h2>
        <div class="sectioncontent">
<p>The translator begins pass 1 by parsing the given input script, and all scripts (files named <em>*.stp</em>) found in a tapset directory.  The directories listed with <strong>-I</strong> are processed in sequence, each processed in "guru mode".  For each directory, a number of subdirectories are also searched.  These subdirectories are derived from the selected kernel version (the <strong>-R</strong> option), in order to allow more kernel-version-specific scripts to override less specific ones.  For example, for a kernel version <em>2.6.12-23.FC3</em> the following patterns would be searched, in sequence: <em>2.6.12-23.FC3/*.stp</em>, <em>2.6.12/*.stp</em>, <em>2.6/*.stp</em>, and finally <em>*.stp</em>. Stopping the translator after pass 1 causes it to print the parse trees.</p><p>In pass 2, the translator analyzes the input script to resolve symbols and types.  References to variables, functions, and probe aliases that are unresolved internally are satisfied by searching through the parsed tapset script files.  If any tapset script file is selected because it defines an unresolved symbol, then the entirety of that file is added to the translator's resolution queue.  This process iterates until all symbols are resolved and a subset of tapset script files is selected.</p><p>Next, all probe point descriptions are validated against the wide variety supported by the translator.  Probe points that refer to code locations ("synchronous probe points") require the appropriate kernel debugging information to be installed.  In the associated probe handlers, target-side variables (whose names begin with "$") are found and have their run-time locations decoded.</p><p>Next, all probes and functions are analyzed for optimization opportunities, in order to remove variables, expressions, and functions that have no useful value and no side-effect.  Embedded-C functions are assumed to have side-effects unless they include the magic string <strong>/*</strong>pure<strong>*/</strong>. Since this optimization can hide latent code errors such as type mismatches or invalid $context variables, it sometimes may be useful to disable the optimizations with the <strong>-u</strong> option.</p><p>Finally, all variable, function, parameter, array, and index types are inferred from context (literals and operators).  Stopping the translator after pass 2 causes it to list all the probes, functions, and variables, along with all inferred types.  Any inconsistent or unresolved types cause an error.</p><p>In pass 3, the translator writes C code that represents the actions of all selected script files, and creates a <em>Makefile</em> to build that into a kernel object.  These files are placed into a temporary directory.  Stopping the translator at this point causes it to print the contents of the C file.</p><p>In pass 4, the translator invokes the Linux kernel build system to create the actual kernel object file.  This involves running <em>make</em> in the temporary directory, and requires a kernel module build system (headers, config and Makefiles) to be installed in the usual spot <em>/lib/modules/VERSION/build</em>. Stopping the translator after pass 4 is the last chance before running the kernel object.  This may be useful if you want to archive the file.</p><p>In pass 5, the translator invokes the systemtap auxiliary program <em>staprun</em> program for the given kernel object.  This program arranges to load the module then communicates with it, copying trace data from the kernel into temporary files, until the user sends an interrupt signal. Any run-time error encountered by the probe handlers, such as running out of memory, division by zero, exceeding nesting or runtime limits, results in a soft error indication.  Soft errors in excess of MAXERRORS block of all subsequent probes (except error-handling probes), and terminate the session.  Finally, <em>staprun</em> unloads the module, and cleans up.</p><h3>ABNORMAL TERMINATION</h3>
<p>One should avoid killing the stap process forcibly, for example with SIGKILL, because the stapio process (a child process of the stap process) and the loaded module may be left running on the system.  If this happens, send SIGTERM or SIGINT to any remaining stapio processes, then use rmmod to unload the systemtap module.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>See the <em>stapex</em>(3stap) manual page for a brief collection of samples, or a large set of installed samples under the systemtap documentation/testsuite directories.  See <em>stappaths</em>(7stap) for the likely location of these on the system.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CACHING</h2>
        <div class="sectioncontent">
<p>The systemtap translator caches the pass 3 output (the generated C code) and the pass 4 output (the compiled kernel module) if pass 4 completes successfully.  This cached output is reused if the same script is translated again assuming the same conditions exist (same kernel version, same systemtap version, etc.).  Cached files are stored in the <em>$SYSTEMTAP_DIR/cache</em> directory. The cache can be limited by having the file <em>cache_mb_limit</em> placed in the cache directory (shown above) containing only an ASCII integer representing how many MiB the cache should not exceed. In the absence of this file, a default will be created with the limit set to 256MiB. This is a 'soft' limit in that the cache will be cleaned after a new entry is added if the cache clean interval is exceeded, so the total cache size may temporarily exceed this limit. This interval can be specified by having the file <em>cache_clean_interval_s</em> placed in the cache directory (shown above) containing only an ASCII integer representing the interval in seconds. In the absence of this file, a default will be created with the interval set to 300 s.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SAFETY AND SECURITY</h2>
        <div class="sectioncontent">
<p>Systemtap is an administrative tool.  It exposes kernel internal data structures and potentially private user information.</p><p>To actually run the kernel objects it builds, a user must be one of the following:</p><ul>
<li><p>the root user;</p></li><li><p>a member of the <em>stapdev</em> and <em>stapusr</em> groups;</p></li><li><p>a member of the <em>stapsys</em> and <em>stapusr</em> groups; or</p></li><li><p>a member of the <em>stapusr</em> group.</p></li>
</ul><p>The root user or a user who is a member of both the <em>stapdev</em> and <em>stapusr</em> groups can build and run any systemtap script.</p><p>A user who is a member of both the <em>stapsys</em> and <em>stapusr</em> groups can only use pre-built modules under the following conditions:</p><ul>
<li><p>The module has been signed by a trusted signer. Trusted signers are normally systemtap compile-servers which sign modules when the <em>--privilege</em> option is specified by the client. See the <a href="../man8/stap-server.8.html"><strong>stap-server</strong>(8)</a> manual page for more information.</p></li><li><p>The module was built using the <em>--privilege=stapsys</em> or the <em>--privilege=stapusr</em> options.</p></li>
</ul><p>Members of only the <em>stapusr</em> group can only use pre-built modules under the following conditions:</p><ul>
<li><p>The module is located in the /lib/modules/VERSION/systemtap directory.  This directory must be owned by root and not be world writable.</p></li>
</ul><p>or</p><ul>
<li><p>The module has been signed by a trusted signer. Trusted signers are normally systemtap compile-servers which sign modules when the <em>--privilege</em> option is specified by the client. See the <a href="../man8/stap-server.8.html"><strong>stap-server</strong>(8)</a> manual page for more information.</p></li><li><p>The module was built using the \FI--privilege=stapusr option.</p></li>
</ul><p>The kernel modules generated by <em>stap</em> program are run by the <em>staprun</em> program.  The latter is a part of the Systemtap package, dedicated to module loading and unloading (but only in the white zone), and kernel-to-user data transfer.  Since <em>staprun</em> does not perform any additional security checks on the kernel objects it is given, it would be unwise for a system administrator to add untrusted users to the <em>stapdev</em> or <em>stapusr</em> groups.</p><p>If the current system has SecureBoot turned on in the UEFI firmware, all kernel modules must be signed.  (Some kernels may allow disabling SecureBoot long after booting with a key sequence such as SysRq-X, making it unnecessary to sign modules.)  The systemtap compile server can sign modules with a MOK (Machine Owner Key) that it has in common with a client system. See the following wiki page for more details:</p><p><strong>https://sourceware.org/systemtap/wiki/SecureBoot</strong></p><p>The translator asserts certain safety constraints.  It aims to ensure that no handler routine can run for very long, allocate memory, perform unsafe operations, or in unintentionally interfere with the kernel.  Uses of script global variables are automatically read/write locked as appropriate, to protect against manipulation by concurrent probe handlers.  (Deadlocks are detected with timeouts.  Use the <strong>-t</strong> flag to receive reports of excessive lock contention.)  Use of guru mode constructs such as embedded C can violate these constraints, leading to kernel crash or data corruption.</p><p>The resource use limits are set by macros in the generated C code. These may be overridden with the <strong>-D</strong> flag.  A selection of these is as follows:</p>
<dl class='dl-vertical'>
  <dt>
    <p>MAXNESTING</p>
  </dt>
  <dd>
    <p>Maximum number of nested function calls.  Default determined by script analysis, with a bonus 10 slots added for recursive scripts.</p>
  </dd>
  <dt>
    <p>MAXSTRINGLEN</p>
  </dt>
  <dd>
    <p>Maximum length of strings, default 128.</p>
  </dd>
  <dt>
    <p>MAXTRYLOCK</p>
  </dt>
  <dd>
    <p>Maximum number of iterations to wait for locks on global variables before declaring possible deadlock and skipping the probe, default 1000.</p>
  </dd>
  <dt>
    <p>MAXACTION</p>
  </dt>
  <dd>
    <p>Maximum number of statements to execute during any single probe hit (with interrupts disabled), default 1000. Note that for straight-through probe handlers lacking loops or recursion, due to optimization, this parameter may be interpreted too conservatively.</p>
  </dd>
  <dt>
    <p>MAXACTION_INTERRUPTIBLE</p>
  </dt>
  <dd>
    <p>Maximum number of statements to execute during any single probe hit which is executed with interrupts enabled (such as begin/end probes), default (MAXACTION * 10).</p>
  </dd>
  <dt>
    <p>MAXBACKTRACE</p>
  </dt>
  <dd>
    <p>Maximum number of stack frames that will be be processed by the stap runtime unwinder as produced by the backtrace functions in the [u]context-unwind.stp tapsets, default 20.</p>
  </dd>
  <dt>
    <p>MAXMAPENTRIES</p>
  </dt>
  <dd>
    <p>Default maximum number of rows in any single global array, default 2048. Individual arrays may be declared with a larger or smaller limit instead: global big[10000],little[5] or denoted with <em>%</em> to make them wrap-around automatically.</p>
  </dd>
  <dt>
    <p>MAXERRORS</p>
  </dt>
  <dd>
    <p>Maximum number of soft errors before an exit is triggered, default 0, which means that the first error will exit the script.  Note that with the <strong>--suppress-handler-errors</strong> option, this limit is not enforced.</p>
  </dd>
  <dt>
    <p>MAXSKIPPED</p>
  </dt>
  <dd>
    <p>Maximum number of skipped probes before an exit is triggered, default 100. Running systemtap with -t (timing) mode gives more details about skipped probes.  With the default -DINTERRUPTIBLE=1 setting, probes skipped due to reentrancy are not accumulated against this limit.  Note that with the <strong>--suppress-handler-errors</strong> option, this limit is not enforced.</p>
  </dd>
  <dt>
    <p>MINSTACKSPACE</p>
  </dt>
  <dd>
    <p>Minimum number of free kernel stack bytes required in order to run a probe handler, default 1024.  This number should be large enough for the probe handler's own needs, plus a safety margin.</p>
  </dd>
  <dt>
    <p>MAXUPROBES</p>
  </dt>
  <dd>
    <p>Maximum number of concurrently armed user-space probes (uprobes), default somewhat larger than the number of user-space probe points named in the script. This pool needs to be potentialy large because individual uprobe objects (about 64 bytes each) are allocated for each process for each matching script-level probe.</p>
  </dd>
  <dt>
    <p>STP_MAXMEMORY</p>
  </dt>
  <dd>
    <p>Maximum amount of memory (in kilobytes) that the systemtap module should use, default unlimited.  The memory size includes the size of the module itself, plus any additional allocations.  This only tracks direct allocations by the systemtap runtime.  This does not track indirect allocations (as done by kprobes/uprobes/etc. internals).</p>
  </dd>
  <dt>
    <p>STP_PROCFS_BUFSIZE</p>
  </dt>
  <dd>
    <p>Size of procfs probe read buffers (in bytes).  Defaults to <em>MAXSTRINGLEN</em>. This value can be overridden on a per-procfs file basis using the procfs read probe <em>.maxsize(MAXSIZE)</em> parameter.</p>
  </dd>

</dl>
<p>With scripts that contain probes on any interrupt path, it is possible that those interrupts may occur in the middle of another probe handler.  The probe in the interrupt handler would be skipped in this case to avoid reentrance. To work around this issue, execute stap with the option <strong>-DINTERRUPTIBLE=0</strong> to mask interrupts throughout the probe handler.  This does add some extra overhead to the probes, but it may prevent reentrance for common problem cases.  However, probes in NMI handlers and in the callpath of the stap runtime may still be skipped due to reentrance.</p><p>Multiple scripts can write data into a relay buffer concurrently. A host script provides an interface for accessing its relay buffer to guest scripts. Then, the output of the guests are merged into the output of the host. To run a script as a host, execute stap with <strong>-DRELAYHOST[=name]</strong> option. The <strong>name</strong> identifies your host script among several hosts. While running the host, execute stap with <strong>-DRELAYGUEST[=name]</strong> to add a guest script to the host. Note that you must unload guests before unloading a host. If there are some guests connected to the host, unloading the host will be failed.</p><p>In case something goes wrong with <em>stap</em> or <em>staprun</em> after a probe has already started running, one may safely kill both user processes, and remove the active probe kernel module with <em>rmmod</em>. Any pending trace messages may be lost.</p><p>In addition to the methods outlined above, the generated kernel module also uses overload processing to make sure that probes can't run for too long.  If more than STP_OVERLOAD_THRESHOLD cycles (default 500000000) have been spent in all the probes on a single cpu during the last STP_OVERLOAD_INTERVAL cycles (default 1000000000), the probes have overloaded the system and an exit is triggered.</p><p>By default, overload processing is turned on for all modules.  If you would like to disable overload processing, define STP_NO_OVERLOAD (or its alias STAP_NO_OVERLOAD).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">UNPRIVILEGED USERS</h2>
        <div class="sectioncontent">
<p>Systemtap exposes kernel internal data structures and potentially private user information. Because of this, use of systemtap's full capabilities are restricted to root and to users who are members of the groups stapdev and stapusr.</p><p>However, a restricted set of systemtap's features can be made available to trusted, unprivileged users. These users are members of the group stapusr only, or members of the groups stapusr and stapsys. These users can load systemtap modules which have been compiled and certified by a trusted systemtap compile-server. See the descriptions of the options <em>--privilege</em> and <em>--use-server</em>. See <em>README.unprivileged</em> in the systemtap source code for information about setting up a trusted compile server.</p><p>The restrictions enforced when <em>--privilege=stapsys</em> is specified are designed to prevent unprivileged users from:</p><ul>
<li><p>harming the system maliciously.</p></li>
</ul><p>The restrictions enforced when <em>--privilege=stapusr</em> is specified are designed to prevent unprivileged users from:</p><ul>
<li><p>harming the system maliciously.</p></li><li><p>gaining access to information which would not normally be available to an unprivileged user.</p></li><li><p>disrupting the performance of processes owned by other users of the system. Some overhead to the system in general is unavoidable since the unprivileged  user's probes will be triggered at the appropriate times. What we would like to avoid is targeted interruption of another user's processes which would not normally be possible by an unprivileged user.</p></li>
</ul><h3>PROBE RESTRICTIONS</h3>
<p>A member of the groups stapusr and stapsys may use all probe points.</p><p>A member of only the group stapusr may use only the following probes:</p><ul>
<li><p>begin, begin(n)</p></li><li><p>end, end(n)</p></li><li><p>error(n)</p></li><li><p>never</p></li><li><p>process.*, where the target process is owned by the user.</p></li><li><p>timer.{jiffies,s,sec,ms,msec,us,usec,ns,nsec}(n)*</p></li><li><p>timer.hz(n)</p></li>
</ul>
<h3>SCRIPT LANGUAGE RESTRICTIONS</h3>
<p>The following scripting language features are unavailable to all unprivileged users:</p><ul>
<li><p>any feature enabled by the Guru Mode (-g) option.</p></li><li><p>embedded C code.</p></li>
</ul>
<h3>RUNTIME RESTRICTIONS</h3>
<p>The following runtime restrictions are placed upon all unprivileged users:</p><ul>
<li><p>Only the default runtime code (see <em>-R</em>) may be used.</p></li>
</ul><p>Additional restrictions are placed on members of only the group stapusr:</p><ul>
<li><p>Probing of processes owned by other users is not permitted.</p></li><li><p>Access of kernel memory (read and write) is not permitted.</p></li>
</ul>
<h3>COMMAND LINE OPTION RESTRICTIONS</h3>
<p>Some command line options provide access to features which must not be available to all unprivileged users:</p><ul>
<li><p>-g may not be specified.</p></li><li><p>The following options may not be used by the compile-server client:</p>
<pre>
    -a, -B, -D, -I, -r, -R
</pre>
</li>
</ul>
<h3>ENVIRONMENT RESTRICTIONS</h3>
<p>The following environment variables must not be set for all unprivileged users: SYSTEMTAP_RUNTIME SYSTEMTAP_TAPSET SYSTEMTAP_DEBUGINFO_PATH</p>
<h3>TAPSET RESTRICTIONS</h3>
<p>In general, tapset functions are only available for members of the group stapusr when they do not gather information that an ordinary program running with that user's privileges would be denied access to.</p><p>There are two categories of unprivileged tapset functions. The first category consists of utility functions that are unconditionally available to all users; these include such things as: cpu:long () exit () str_replace:string (prnt_str:string, srch_str:string, rplc_str:string)</p><p>The second category consists of so-called <em>myproc-unprivileged</em> functions that can only gather information within their own processes. Scripts that wish to use these functions must test the result of the tapset function <em>is_myproc</em> and only call these functions if the result is 1. The script will exit immediately if any of these functions are called by an unprivileged user within a probe within a process which is not owned by that user. Examples of <em>myproc-unprivileged</em> functions include: print_usyms (stk:string) user_int:long (addr:long) usymname:string (addr:long)</p><p>A compile error is triggered when any function not in either of the above categories is used by members of only the group stapusr.</p><p>No other built-in tapset functions may be used by members of only the group stapusr.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ALTERNATE RUNTIMES</h2>
        <div class="sectioncontent">
<p>As described above, systemtap's default runtime mode involves building and loading kernel modules, with various security tradeoffs presented.  Systemtap now includes a new prototype backend, selected with <em>--runtime=dyninst</em>, which uses Dyninst to instrument a user's own processes at runtime. This backend does not use kernel modules, and does not require root privileges, but is restricted with respect to the kinds of probes and other constructs that a script may use.</p><p>The <em>dyninst</em> runtime operates in target-attach mode, so it does require a <em>-c COMMAND</em> or <em>-x PID</em> process.  For example: stap --runtime=dyninst -c 'stap -V' &#92;</p>
<pre>
     -e 'probe process.function("main")
         { println("hi from dyninst!") }'
</pre>
<p>It may be necessary to disable a conflicting selinux check with # setsebool allow_execstack 1</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXIT STATUS</h2>
        <div class="sectioncontent">
<p>The systemtap translator generally returns with a success code of 0 if the requested script was processed and executed successfully through the requested pass.  Otherwise, errors may be printed to stderr and a failure code is returned.  Use <em>-v</em> or <em>-vp N</em> to increase (global or per-pass) verbosity to identify the source of the trouble.</p><p>In listings mode (<em>-l</em> and <em>-L</em>), error messages are normally suppressed.  A success code of 0 is returned if at least one matching probe was found.</p><p>A script executing in pass 5 that is interrupted with ^C / SIGINT is considered to be successful.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DEPRECATION</h2>
        <div class="sectioncontent">
<p>Over time, some features of the script language and the tapset library may undergo incompatible changes, so that a script written against an old version of systemtap may no longer run.  In these cases, it may help to run systemtap with the <em>--compatible VERSION</em> flag, specifying the last known working version.  Running systemtap with the <em>--check-version</em> flag will output a warning if any possible incompatible elements have been parsed.  Deprecation historical details may be found in the NEWS file.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILES</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p>Important files and their corresponding paths can be located in the</p>
  </dt>
  <dd>
    <p>stappaths (7) manual page.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO stap&hellip;</h2>
        <div class="sectioncontent">

<pre>
<em>stapprobes</em>(3stap),
<em>function::*</em>(3stap),
<em>probe::*</em>(3stap),
<em>tapset::*</em>(3stap),
<a href="../man7/stappaths.7.html"><strong>stappaths</strong>(7)</a>,
<a href="../man8/staprun.8.html"><strong>staprun</strong>(8)</a>,
<strong>stapdyn</strong>(8),
<strong>systemtap</strong>(8),
<em>stapvars</em>(3stap),
<em>stapex</em>(3stap),
<a href="../man8/stap-server.8.html"><strong>stap-server</strong>(8)</a>,
<a href="../man1/stap-prep.1.html"><strong>stap-prep</strong>(1)</a>,
<strong>awk</strong>(1),
<strong>gdb</strong>(1)

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>Use the Bugzilla link of the project web page or our mailing list. <strong>http://sourceware.org/systemtap/</strong>, <strong>&lt;systemtap@sourceware.org&gt;</strong>.</p><p><em>error::reporting</em>(7stap), <strong>https://sourceware.org/systemtap/wiki/HowToReportBugs</strong></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="stalonetray.1.html"><span aria-hidden="true">&larr;</span> stalonetray.1: Stand-alone system tray (notification area) implementation. this document covers 0.8 version of stalonetray.</a></li>
   <li class="next"><a href="stap-merge.1.html">stap-merge.1: Systemtap per-cpu binary merger <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

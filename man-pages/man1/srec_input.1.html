<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>srec_input: Input file specifications</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Input file specifications">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="srec_input (1) manual">
  <meta name="twitter:description" content="Input file specifications">
  <meta name="twitter:image" content="https://www.carta.tech/images/srecord-srec_input-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/srec_input.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="srec_input (1) manual" />
  <meta property="og:description" content="Input file specifications" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/srecord-srec_input-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">srec_input<small> (1)</small></h1>
        <p class="lead">Input file specifications</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/srec_input.1.html">
      <span itemprop="name">srec_input: Input file specifications</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/srecord/">
      <span itemprop="name">srecord</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/srec_input.1.html">
      <span itemprop="name">srec_input: Input file specifications</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>srec_*</strong> <em>filename</em> [ <em>format</em> ]</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This manual page describes the input file specifications for the <a href="../man1/srec_cat.1.html"><strong>srec_cat</strong>(1)</a>, <a href="../man1/srec_cmp.1.html"><strong>srec_cmp</strong>(1)</a> and <a href="../man1/srec_info.1.html"><strong>srec_info</strong>(1)</a> commands.</p><p>Input files may be qualified in a number of ways: you may specify their format and you may specify filters to apply to them. An input file specification looks like this:</p><p><em>filename</em> [ <em>format</em> ][ -ignore\[hy]checksums ] [ <em>filter</em> ... ]</p><p>The <em>filename</em> may be specified as a file name, or the special name &ldquo;-&rdquo; which is understood to mean the standard input.</p><h3>Grouping with Parentheses</h3>
<p>There are some cases where operator precedence of the filters can be ambiguous.  Input specifications may also be enclosed by <strong>(</strong> parentheses <strong>)</strong> to make grouping explicit.  Remember that the parentheses must be separate words, <em>i.e.</em> surrounded by spaces, and they will need to be quoted to get them past the shell's interpretation of parentheses.</p>
<h3>Those Option Names Sure Are Long</h3>
<p>All options may be abbreviated; the abbreviation is documented as the upper case letters, all lower case letters and underscores (_) are optional. You must use consecutive sequences of optional letters.</p><p>All options are case insensitive, you may type them in upper case or lower case or a combination of both, case is not important.</p><p>For example: the arguments \[lq]-help\[rq], \[lq]-HEL\[rq] and \[lq]-h\[rq] are all interpreted to mean the <strong>-Help</strong> option. The argument \[lq]-hlp\[rq] will not be understood, because consecutive optional characters were not supplied.</p><p>Options and other command line arguments may be mixed arbitrarily on the command line.</p><p>The GNU long option names are understood. Since all option names for <em>\*(n)</em> are long, this means ignoring the extra leading \[lq]-\[rq]. The \[lq]<strong>--</strong><em>option</em><strong>=</strong><em>value</em>\[rq] convention is also understood.</p>
<h3>File Formats</h3>
<p>The <em>format</em> is specified by the argument <em>after</em> the file name. The format defaults to Motorola S\[hy]Record if not specified. The format specifiers are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>-Absolute_Object_Module_Format</strong></p>
  </dt>
  <dd>
    <p>This option says to use the Intel Absolute Object Module Format (AOMF) to read the file.  (See <a href="../man5/srec_aomf.5.html"><strong>srec_aomf</strong>(5)</a> for a description of this file format.)</p>
  </dd>
  <dt>
    <p><strong>-Ascii_Hex</strong></p>
  </dt>
  <dd>
    <p>This option says to use the Ascii\[hy]Hex format to read the file. See <a href="../man5/srec_ascii_hex.5.html"><strong>srec_ascii_hex</strong>(5)</a> for a description of this file format.</p>
  </dd>
  <dt>
    <p><strong>-Atmel_Generic</strong></p>
  </dt>
  <dd>
    <p>This option says to use the Atmel Generic format to read the file. See <strong>srec_atmel_genetic</strong>(5) for a description of this file format.</p>
  </dd>
  <dt>
    <p><strong>-Binary</strong></p>
  </dt>
  <dd>
    <p>This option says the file is a raw binary file, and should be read literally. (This option may also be written -Raw.) See <a href="../man5/srec_binary.5.html"><strong>srec_binary</strong>(5)</a> for more information.</p>
  </dd>
  <dt>
    <p><strong>-B\[hy]Record</strong></p>
  </dt>
  <dd>
    <p>This option says to use the Freescale MC68EZ328 Dragonball bootstrap b\[hy]record format to read the file. See <strong>srec_brecord</strong>(5) for a description of this file format.</p>
  </dd>
  <dt>
    <p><strong>-COsmac</strong></p>
  </dt>
  <dd>
    <p>This option says to use the RCA Cosmac Elf format to read the file. See <a href="../man5/srec_cosmac.5.html"><strong>srec_cosmac</strong>(5)</a> for a description of this file format.</p>
  </dd>
  <dt>
    <p><strong>-Dec_Binary</strong></p>
  </dt>
  <dd>
    <p>This option says to use the DEC Binary (XXDP) format to read the file. See <a href="../man5/srec_dec_binary.5.html"><strong>srec_dec_binary</strong>(5)</a> for a description of this file format.</p>
  </dd>
  <dt>
    <p><strong>-Elektor_Monitor52</strong></p>
  </dt>
  <dd>
    <p>This option says to use the EMON52 format to read the file. See <a href="../man5/srec_emon52.5.html"><strong>srec_emon52</strong>(5)</a> for a description of this file format.</p>
  </dd>
  <dt>
    <p><strong>-FAIrchild</strong></p>
  </dt>
  <dd>
    <p>This option says to use the Fairchild Fairbug format to read the file. See <a href="../man5/srec_fairchild.5.html"><strong>srec_fairchild</strong>(5)</a> for a description of this file format.</p>
  </dd>
  <dt>
    <p><strong>-Fast_Load</strong></p>
  </dt>
  <dd>
    <p>This option says to use the LSI Logic Fast Load format to read the file. See <a href="../man5/srec_fastload.5.html"><strong>srec_fastload</strong>(5)</a> for a description of this file format.</p>
  </dd>
  <dt>
    <p><strong>-Formatted_Binary</strong></p>
  </dt>
  <dd>
    <p>This option says to use the Formatted Binary format to read the file. See <a href="../man5/srec_formatted_binary.5.html"><strong>srec_formatted_binary</strong>(5)</a> for a description of this file format.</p>
  </dd>
  <dt>
    <p><strong>-Four_Packed_Code</strong></p>
  </dt>
  <dd>
    <p>This option says to use the FPC format to read the file. See <a href="../man5/srec_fpc.5.html"><strong>srec_fpc</strong>(5)</a> for a description of this file format.</p>
  </dd>
  <dt>
    <p><strong>-Guess</strong></p>
  </dt>
  <dd>
    <p>This option may be used to ask the command to guess the input format. This is slower than specifying an explicit format, as it may open and scan and close the file a number of times.</p>
  </dd>
  <dt>
    <p><strong>-HEX_Dump</strong></p>
  </dt>
  <dd>
    <p>This option says to try to read a hexadecimal dump file, more or less in the style output by the same option.  This is not an exact reverse mapping, because if there are ASCII equivalents on the right hand side, these may be confused for data bytes.  Also, it doesn't understand white space representing holes in the data in the line.</p>
  </dd>
  <dt>
    <p><strong>-IDT</strong></p>
  </dt>
  <dd>
    <p>This option says to the the IDT/sim binary format to read the file.</p>
  </dd>
  <dt>
    <p><strong>-Intel</strong></p>
  </dt>
  <dd>
    <p>This option says to use the Intel hex format to read the file. See <a href="../man5/srec_intel.5.html"><strong>srec_intel</strong>(5)</a> for a description of this file format.</p>
  </dd>
  <dt>
    <p><strong>-INtel_HeX_16</strong></p>
  </dt>
  <dd>
    <p>This option says to use the Intel hex 16 (INHX16) format to read the file. See <a href="../man5/srec_intel16.5.html"><strong>srec_intel16</strong>(5)</a> for a description of this file format.</p>
  </dd>
  <dt>
    <p><strong>-Memory_Initialization_File</strong></p>
  </dt>
  <dd>
    <p>This option says to use the Memory Initialization File (MIF) format by Altera to read the file. See <em>srec_mif</em> (5) for a description of this file format.</p>
  </dd>
  <dt>
    <p><strong>-Mips_Flash_BigEndian</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>-Mips_Flash_LittleEndian</strong></p>
  </dt>
  <dd>
    <p>This option says to use the MIPS Flash file format to read the file. See <em>srec_mips_flash</em> (5) for a description of this file format.</p>
  </dd>
  <dt>
    <p><strong>-MOS_Technologies</strong></p>
  </dt>
  <dd>
    <p>This option says to use the Mos Technologies format to read the file. See <a href="../man5/srec_mos_tech.5.html"><strong>srec_mos_tech</strong>(5)</a> for a description of this file format.</p>
  </dd>
  <dt>
    <p><strong>-Motorola</strong> [ <em>width</em> ]</p>
  </dt>
  <dd>
    <p>This option says to use the Motorola S\[hy]Record format to read the file. (May be written <strong>-S\[hy]Record</strong> as well.) See <a href="../man5/srec_motorola.5.html"><strong>srec_motorola</strong>(5)</a> for a description of this file format.</p><p>The optional <em>width</em> argument describes the number of bytes which form each address multiple.  For normal uses the default of one (1) byte is appropriate.  Some systems with 16\[hy]bit or 32\[hy]bit targets mutilate the addresses in the file; this option will correct for that. Unlike most other parameters, this one cannot be guessed.</p>
  </dd>
  <dt>
    <p><strong>-MsBin</strong></p>
  </dt>
  <dd>
    <p>This option says to use the Windows CE Binary Image Data Format to read the file.  See <a href="../man5/srec_msbin.5.html"><strong>srec_msbin</strong>(5)</a> for a description of this file format.</p>
  </dd>
  <dt>
    <p><strong>-Needham_Hexadecimal</strong></p>
  </dt>
  <dd>
    <p>This option says to use the Needham Electronics ASCII file format to read the file.  See <a href="../man5/srec_needham.5.html"><strong>srec_needham</strong>(5)</a> for a description of this file format.</p>
  </dd>
  <dt>
    <p><strong>-Ohio_Scientific</strong></p>
  </dt>
  <dd>
    <p>This option says to use the Ohio Scientific format. See <a href="../man5/srec_os65v.5.html"><strong>srec_os65v</strong>(5)</a> for a description of this file format.</p>
  </dd>
  <dt>
    <p><strong>-PPB</strong></p>
  </dt>
  <dd>
    <p>This option says to use the Stag Prom Programmer binary format. See <strong>srec_ppb</strong>(5) for a description of this file format.</p>
  </dd>
  <dt>
    <p><strong>-PPX</strong></p>
  </dt>
  <dd>
    <p>This option says to use the Stag Prom Programmer hexadecimal format. See <strong>srec_ppx</strong>(5) for a description of this file format.</p>
  </dd>
  <dt>
    <p><strong>-SIGnetics</strong></p>
  </dt>
  <dd>
    <p>This option says to use the Signetics format. See <a href="../man5/srec_spasm.5.html"><strong>srec_spasm</strong>(5)</a> for a description of this file format.</p>
  </dd>
  <dt>
    <p><strong>-SPAsm</strong></p>
  </dt>
  <dd>
    <p>This option says to use the SPASM assembler output format (commonly used by PIC programmers). See <a href="../man5/srec_spasm.5.html"><strong>srec_spasm</strong>(5)</a> for a description of this file format.</p>
  </dd>
  <dt>
    <p><strong>-SPAsm_LittleEndian</strong></p>
  </dt>
  <dd>
    <p>This option says to use the SPASM assembler output format (commonly used by PIC programmers).  But with the data the other way around.</p>
  </dd>
  <dt>
    <p><strong>-STewie</strong></p>
  </dt>
  <dd>
    <p>This option says to use the Stewie binary format to read the file. See <a href="../man5/srec_stewie.5.html"><strong>srec_stewie</strong>(5)</a> for a description of this file format.</p>
  </dd>
  <dt>
    <p><strong>-Tektronix</strong></p>
  </dt>
  <dd>
    <p>This option says to use the Tektronix hex format to read the file. See <a href="../man5/srec_tektronix.5.html"><strong>srec_tektronix</strong>(5)</a> for a description of this file format.</p>
  </dd>
  <dt>
    <p><strong>-Tektronix_Extended</strong></p>
  </dt>
  <dd>
    <p>This option says to use the Tektronix extended hex format to read the file. See <a href="../man5/srec_tektronix_extended.5.html"><strong>srec_tektronix_extended</strong>(5)</a> for a description of this file format.</p>
  </dd>
  <dt>
    <p><strong>-Texas_Instruments_Tagged</strong></p>
  </dt>
  <dd>
    <p>This option says to use the Texas Instruments Tagged format to read the file. See <a href="../man5/srec_ti_tagged.5.html"><strong>srec_ti_tagged</strong>(5)</a> for a description of this file format.</p>
  </dd>
  <dt>
    <p><strong>-Texas_Instruments_Tagged_16</strong></p>
  </dt>
  <dd>
    <p>This option says to use the Texas Instruments SDSMAC 320 format to read the file.  See <a href="../man5/srec_ti_tagged_16.5.html"><strong>srec_ti_tagged_16</strong>(5)</a> for a description of this file format.</p>
  </dd>
  <dt>
    <p><strong>-Texas_Instruments_TeXT</strong></p>
  </dt>
  <dd>
    <p>This option says to use the Texas Instruments TXT (MSP430) format to read the file.  See <a href="../man5/srec_ti_txt.5.html"><strong>srec_ti_txt</strong>(5)</a> for a description of this file format.</p>
  </dd>
  <dt>
    <p><strong>-VMem</strong></p>
  </dt>
  <dd>
    <p>This option says to use the Verilog VMEM format to read the file. See <a href="../man5/srec_vmem.5.html"><strong>srec_vmem</strong>(5)</a> for a description of this file format.</p>
  </dd>
  <dt>
    <p><strong>-WILson</strong></p>
  </dt>
  <dd>
    <p>This option says to use the wilson format to read the file. See <a href="../man5/srec_wilson.5.html"><strong>srec_wilson</strong>(5)</a> for a description of this file format.</p>
  </dd>

</dl>

<h3>Ignore Checksums</h3>
<p>The <strong>-IGnore\[hy]Checksums</strong> option may be used to disable checksum validation of input files, for those formats which have checksums at all.  Note that the checksum values are still read in and parsed (so it is still an error if they are missing) but their values are not checked. Used after an input file name, the option affects that file alone; used anywhere else on the command line, it applies to all following files.</p>
<h3>Generators</h3>
<p>It is also possible to generate data, rather than read it from a file. You may use a generator anywhere you could use a file. An input generator specification looks like this:</p><p><strong>-GENerate</strong> <em>address\[hy]range</em> <strong>-</strong><em>data\[hy]source</em></p><p>The <strong>-</strong><em>data\[hy]source</em> may be one of the following:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>-CONSTant</strong> <em>byte\[hy]value</em></p>
  </dt>
  <dd>
    <p>This generator manufactures data with the given byte value of the the given address range. It is an error if the byte\[hy]value is not in the range 0..255.</p><p>For example, to fill memory addresses 100..199 with newlines (0x0A), you could use a command like</p>
<pre>
srec_cat -generate 100 200 -constant 10 -o newlines.srec
</pre>
<p>This can, of course, be combined with data from files.</p>
  </dd>
  <dt>
    <p><strong>-REPeat_Data</strong> <em>byte\[hy]value</em>...</p>
  </dt>
  <dd>
    <p>This generator manufactures data with the given byte values repeating over the the given address range. It is an error if any of the the byte\[hy]values are not in the range 0..255.</p><p>For example, to create a data region with 0xDE in the even bytes and 0xAD in the odd bytes, use a generator like this:</p>
<pre>
srec_cat -generate 0x1000 0x2000 -repeat\[hy]data 0xDE 0xAD
</pre>
<p>The repeat boundaries are aligned with the base of the address range, modulo the number of bytes.</p>
  </dd>
  <dt>
    <p><strong>-REPeat_String</strong> <em>text</em></p>
  </dt>
  <dd>
    <p>This generator is almost identical to -repeat\[hy]data except that the data to be repeated is the text of the given string.</p><p>For example, to fill the holes in an EPROM image <em>eprom.srec</em> with the text &ldquo;Copyright (C) 1812 Tchaikovsky&rdquo;, combine a generator and an -exclude filter, such as the command</p>
<pre>
srec_cat eprom.srec &#92;
    -generate 0 0x100000 &#92;
        -repeat\[hy]string 'Copyright (C) 1812 Tchaikovsky. ' &#92;
        -exclude -within eprom.srec &#92;
    -o eprom.filled.srec
</pre>
<p>The thing to note is that we have two data sources: the <em>eprom.srec</em> file, and generated data over an address range which covers first megabyte of memory but excluding areas covered by the <em>eprom.srec</em> data.</p>
  </dd>
  <dt>
    <p><strong>-Litte_Endian_CONSTant</strong> <em>value</em> <em>width</em></p>
  </dt>
  <dd>
    <p>This generator manufactures data with the given numeric value, of a given byte width, in little\[hy]endian byte order. It is an error if the given value does not fit into the given byte width. It will repeat over and over within the address range range.</p><p>For example, to insert a subversion commit number into 4 bytes at 0x0008..0x000B you would use a command like</p>
<pre>
srec_cat -generate 8 12 -l\[hy]e\[hy]constant $VERSION 4 &#92;
    -o version.srec
</pre>
<p>This generator is a convenience wrapper around the <strong>-REPeat_Data</strong> generator.  It can, of course, be combined with data from files.</p>
  </dd>
  <dt>
    <p><strong>-Big_Endian_CONSTant</strong> <em>value</em> <em>width</em></p>
  </dt>
  <dd>
    <p>As above, but using big\[hy]endian byte ordering.</p>
  </dd>

</dl>
<p>Anything else will result in an error.</p>
<h3>Input Filters</h3>
<p>You may specify zero or more <em>filters</em> to be applied. Filters are applied in the order the user specifies.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>-AND</strong> <em>value</em></p>
  </dt>
  <dd>
    <p>This filter may be used to bit\[hy]wise AND a <em>value</em> to every data byte. This is useful if you need to clear bits. Only existing data is altered, no holes are filled.</p>
  </dd>
  <dt>
    <p><strong>-Big_Endian_Adler_16</strong> <em>address</em></p>
  </dt>
  <dd>
    <p>This filter may be used to insert an \[lq]Adler\[rq] 16\[hy]bit checksum of the data into the data. Two bytes, big\[hy]endian order, are inserted at the address given.  Holes in the input data are ignored.  Bytes are processed in ascending address order (<em>not</em> in the order they appear in the input).</p><p><strong>Note:</strong> If you have holes in your data, you will get a different Adler checksum than if there were no holes.  This is important because the in\[hy]memory EPROM image will not have holes.  You almost always want to use the <strong>-fill</strong> filter before any of the Adler checksum filters. You will receive a warning if the data presented for Adler checksum has holes.</p><p>You should also be aware that the lower and upper bounds of your data may not be the same as the lower and upper bounds of your EPROM.  This is another reason to use the <strong>-fill</strong> filter, because it will establish the data across the full EPROM address range.</p><p>http://en.wikipedia.org/wiki/Adler\[hy]32</p>
  </dd>
  <dt>
    <p><strong>-Big_Endian_Adler_32</strong> <em>address</em></p>
  </dt>
  <dd>
    <p>This filter may be used to insert a Adler 32\[hy]bit checksum of the data into the data.  Four bytes, big\[hy]endian order, are inserted at the address given.  Holes in the input data are ignored.  Bytes are processed in ascending address order (<em>not</em> in the order they appear in the input).</p><p><strong>Note:</strong> If you have holes in your data, you will get a different Adler checksum than if there were no holes.  This is important because the in\[hy]memory EPROM image will not have holes.  You almost always want to use the <strong>-fill</strong> filter before any of the Adler checksum filters. You will receive a warning if the data presented for Adler checksum has holes.</p><p>You should also be aware that the lower and upper bounds of your data may not be the same as the lower and upper bounds of your EPROM.  This is another reason to use the <strong>-fill</strong> filter, because it will establish the data across the full EPROM address range.</p><p>http://en.wikipedia.org/wiki/Adler\[hy]32</p>
  </dd>
  <dt>
    <p><strong>-Big_Endian_Checksum_BitNot</strong> <em>address</em> [ <em>nbytes</em> [  <em>width</em> ]]</p>
  </dt>
  <dd>
    <p>This filter may be used to insert the one's complement checksum of the data into the data, most significant byte first. The data is literally summed; if there are duplicate bytes, this will produce an incorrect result, if there are holes, it will be as if they were filled with zeros. If the data already contains bytes at the checksum location, you need to use an exclude filter, or this will generate errors. You need to apply and crop or fill filters before this filter. The value will be written with the most significant byte first. The number of bytes of resulting checksum defaults to 4. The width (the width in bytes of the values being summed) defaults to 1.</p>
  </dd>
  <dt>
    <p><strong>-Big_Endian_Checksum_Negative</strong> <em>address</em> [ <em>nbytes</em> [  <em>width</em> ]]</p>
  </dt>
  <dd>
    <p>This filter may be used to insert the two's complement (negative) checksum of the data into the data.  Otherwise similar to the above.</p>
  </dd>
  <dt>
    <p><strong>-Big_Endian_Checksum_Positive</strong> <em>address</em> [ <em>nbytes</em> [  <em>width</em> ]]</p>
  </dt>
  <dd>
    <p>This filter may be used to insert the simple checksum of the data into the data.  Otherwise similar to the above.</p>
  </dd>
  <dt>
    <p><strong>-Big_Endian_CRC16</strong> <em>address</em> [ <em>modifier</em>... ]</p>
  </dt>
  <dd>
    <p>This filter may be used to insert an industry standard 16\[hy]bit CRC checksum of the data into the data.  Two bytes, big\[hy]endian order, are inserted at the address given.  Holes in the input data are ignored.  Bytes are processed in ascending address order (<em>not</em> in the order they appear in the input).</p><p>The following additional modifiers are understood:</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>number</em></p>
  </dt>
  <dd>
    <p>Set the polynomial to be used to the given number.</p>
  </dd>
  <dt>
    <p><strong>-Most_To_Least</strong></p>
  </dt>
  <dd>
    <p>The CRC calculation is performed with the most significant bit in each byte processed first, and then proceeding towards the least significant bit.  This is the default.</p>
  </dd>
  <dt>
    <p><strong>-Least_To_Most</strong></p>
  </dt>
  <dd>
    <p>The CRC calculation is performed with the least significant bit in each byte processed first, and then proceeding towards the most significant bit.</p>
  </dd>
  <dt>
    <p><strong>-CCITT</strong></p>
  </dt>
  <dd>
    <p>The CCITT calculation is performed. The initial seed is 0xFFFF. This is the default.</p>
  </dd>
  <dt>
    <p><strong>-XMODEM</strong></p>
  </dt>
  <dd>
    <p>The alternate XMODEM calculation is performed. The initial seed is 0x0000.</p>
  </dd>
  <dt>
    <p><strong>-BROKEN</strong></p>
  </dt>
  <dd>
    <p>A common\[hy]but\[hy]broken calculation is performed (see note 2 below). The initial seed is 0x84CF.</p>
  </dd>
  <dt>
    <p><strong>-AUGment</strong></p>
  </dt>
  <dd>
    <p>The CRC is augmented by sixteen zero bits at the end of the calculation. This is the default.</p>
  </dd>
  <dt>
    <p><strong>-No\[hy]AUGment</strong></p>
  </dt>
  <dd>
    <p>The CRC is not augmented at the end of the calculation. This is less standard conforming, but some implementations do this.</p>
  </dd>

</dl>
<p><strong>Note:</strong> If you have holes in your data, you will get a different CRC than if there were no holes.  This is important because the in\[hy]memory EPROM image will not have holes.  You almost always want to use the <strong>-fill</strong> filter before any of the CRC filters. You will receive a warning if the data presented for CRC has holes.</p><p>You should also be aware that the lower and upper bounds of your data may not be the same as the lower and upper bounds of your EPROM.  This is another reason to use the <strong>-fill</strong> filter, because it will establish the data across the full EPROM address range.</p><p><strong>Note 2:</strong> there are a great many CRC16 implementations out there, see http://www.joegeluso.com/software/articles/ccitt.htm (now gone, reproduced at http://srecord.sourceforge.net/crc16-ccitt.html) and \[lq]A painless guide to CRC error detection algorithms\[rq] http://www.repairfaq.org/filipg/LINK/F_crc_v3.html for more information.  If all else fails, SRecord is open source software: read the SRecord source code.  The CRC16 source code (found in the Wsrecord/crc16.cc file of the distribution tarball) has a great many explanatory comments.</p><p>Please try all twelve combinations of the above options before reporting a bug in the CRC16 calculation.</p>
  </dd>
  <dt>
    <p><strong>-Big_Endian_CRC32</strong> <em>address</em> [ <em>modifier</em>... ]</p>
  </dt>
  <dd>
    <p>This filter may be used to insert an industry standard 32\[hy]bit CRC checksum of the data into the data.  Four bytes, big\[hy]endian order, are inserted at the address given.  Holes in the input data are ignored.  Bytes are processed in ascending address order (<em>not</em> in the order they appear in the input). See also the note about holes, above.</p><p>The following additional modifiers are understood:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>-CCITT</strong></p>
  </dt>
  <dd>
    <p>The CCITT calculation is performed. The initial seed is all one bits. This is the default.</p>
  </dd>
  <dt>
    <p><strong>-XMODEM</strong></p>
  </dt>
  <dd>
    <p>An alternate XMODEM\[hy]style calculation is performed. The initial seed is all zero bits.</p>
  </dd>

</dl>

  </dd>
  <dt>
    <p><strong>-Big_Endian_Exclusive_Length</strong> <em>address</em> [ <em>nbytes</em>  [ <em>width</em> ]]</p>
  </dt>
  <dd>
    <p>The same as the <strong>-Big_Endian_Length</strong> filter, except that the result does <strong>not</strong> include the length itself.</p>
  </dd>
  <dt>
    <p><strong>-Big_Endian_Exclusive_MAXimum</strong> <em>address</em> [ <em>nbytes</em> ]</p>
  </dt>
  <dd>
    <p>The same as the <strong>-Big_Endian_MAXimum</strong> filter, except that the result does <strong>not</strong> include the maximum itself.</p>
  </dd>
  <dt>
    <p><strong>-Big_Endian_Exclusive_MINimum</strong> <em>address</em> [ <em>nbytes</em> ]</p>
  </dt>
  <dd>
    <p>The same as the <strong>-Big_Endian_MINimum</strong> filter, except that the result does <strong>not</strong> include the minimum itself.</p>
  </dd>
  <dt>
    <p><strong>-Big_Endian_Fletcher_16</strong> <em>address</em>  [ <em>sum1</em> <em>sum2</em> [ <em>answer</em> ]]</p>
  </dt>
  <dd>
    <p>This filter may be used to insert an Fletcher 16\[hy]bit checksum of the data into the data. Two bytes, big\[hy]endian order, are inserted at the address given.  Holes in the input data are ignored.  Bytes are processed in ascending address order (<em>not</em> in the order they appear in the input).</p><p><strong>Note:</strong> If you have holes in your data, you will get a different Fletcher checksum than if there were no holes.  This is important because the in\[hy]memory EPROM image will not have holes.  You almost always want to use the <strong>-fill</strong> filter before any of the Fletcher checksum filters. You will receive a warning if the data presented for Fletcher checksum has holes.</p><p>You should also be aware that the lower and upper bounds of your data may not be the same as the lower and upper bounds of your EPROM.  This is another reason to use the <strong>-fill</strong> filter, because it will establish the data across the full EPROM address range.</p><p>http://en.wikipedia.org/wiki/Fletcher%27s_checksum</p><p>It is possible to select seed values for <em>sum1</em> and <em>sum2</em> in the algorithm, by adding seed values on the command line.  They each default to 0xFF if not explicitly stated.  The default values (0) means that an empty EPROM (all 0x00 or all 0xFF) will sum to zero; by changing the seeds, an empty EPROM will always fail.</p><p>The third optional argument is the desired sum, when the checksum itself is summed.  A common value is 0x0000, placed in the last two bytes of an EPROM, so that the Fletcher 16 checksum of the EPROM is exactly 0x0000. No manipulation of the final value is performed if this value if not specified.</p>
  </dd>
  <dt>
    <p><strong>-Big_Endian_Fletcher_32</strong> <em>address</em></p>
  </dt>
  <dd>
    <p>This filter may be used to insert a Fletcher 32\[hy]bit checksum of the data into the data.  Four bytes, big\[hy]endian order, are inserted at the address given.  Holes in the input data are ignored.  Bytes are processed in ascending address order (<em>not</em> in the order they appear in the input).</p><p><strong>Note:</strong> If you have holes in your data, you will get a different Fletcher checksum than if there were no holes.  This is important because the in\[hy]memory EPROM image will not have holes.  You almost always want to use the <strong>-fill</strong> filter before any of the Fletcher checksum filters. You will receive a warning if the data presented for Fletcher checksum has holes.</p><p>You should also be aware that the lower and upper bounds of your data may not be the same as the lower and upper bounds of your EPROM.  This is another reason to use the <strong>-fill</strong> filter, because it will establish the data across the full EPROM address range.</p><p>http://en.wikipedia.org/wiki/Fletcher%27s_checksum</p>
  </dd>
  <dt>
    <p><strong>-Big_Endian_Length</strong> <em>address</em> [ <em>nbytes</em> [ <em>width</em> ]]</p>
  </dt>
  <dd>
    <p>This filter may be used to insert the length of the data (high water minus low water) into the data.  This includes the length itself. If the data already contains bytes at the length location, you need to use an exclude filter, or this will generate errors. The value will be written with the most significant byte first. The number of bytes defaults to 4. The width defaults to 1, and is divided into the actual length, thus you can insert the width in units of words (2) or longs (4).</p>
  </dd>
  <dt>
    <p><strong>-Big_Endian_MAXimum</strong> <em>address</em> [ <em>nbytes</em> ]</p>
  </dt>
  <dd>
    <p>This filter may be used to insert the maximum address of the data (high water  + 1) into the data.  This includes the maximum itself. If the data already contains bytes at the given address, you need to use an exclude filter, or this will generate errors. The value will be written with the most significant byte first. The number of bytes defaults to 4.</p>
  </dd>
  <dt>
    <p><strong>-Big_Endian_MINimum</strong> <em>address</em> [ <em>nbytes</em> ]</p>
  </dt>
  <dd>
    <p>This filter may be used to insert the minimum address of the data (low water) into the data.  This includes the minimum itself. If the data already contains bytes at the given address, you need to use an exclude filter, or this will generate errors. The value will be written with the most significant byte first. The number of bytes defaults to 4.</p>
  </dd>
  <dt>
    <p><strong>-bit_reverse</strong> [ <em>width</em> ]</p>
  </dt>
  <dd>
    <p>This filter may be used to reverse the order of the bits in each data byte. By specifying a width (in bytes) it is possible to reverse the order multi\[hy]byte values; this is implemented using the byte\[hy]swap filter.</p>
  </dd>
  <dt>
    <p><strong>-Byte_Swap</strong> [ <em>width</em> ]</p>
  </dt>
  <dd>
    <p>This filter may be used to swap pairs of odd and even bytes. By specifying a width (in bytes) it is possible to reverse the order of 4 and 8 bytes, the default is 2 bytes.  (Widths in excess of 8 are assumed to be number of bits.) It is not possible to swap non\[hy]power\[hy]of\[hy]two addresses. To change the alignment, use the offset filter before and after.</p>
  </dd>
  <dt>
    <p><strong>-Crop</strong> <em>address\[hy]range</em></p>
  </dt>
  <dd>
    <p>This filter may be used to isolate a section of data, and discard the rest.</p>
  </dd>
  <dt>
    <p><strong>-Exclude</strong> <em>address\[hy]range</em></p>
  </dt>
  <dd>
    <p>This filter may be used to exclude a section of data, and keep the rest. The is the logical complement of the <strong>-Crop</strong> filter.</p>
  </dd>
  <dt>
    <p><strong>-eXclusive\[hy]OR</strong> <em>value</em></p>
  </dt>
  <dd>
    <p>This filter may be used to bit\[hy]wise XOR a <em>value</em> to every data byte. This is useful if you need to invert bits. Only existing data is altered, no holes are filled.</p>
  </dd>
  <dt>
    <p><strong>-Fill</strong> <em>value</em> <em>address\[hy]range</em></p>
  </dt>
  <dd>
    <p>This filter may be used to fill any gaps in the data with bytes equal to <em>value</em>.  The fill will only occur in the address range given.</p>
  </dd>
  <dt>
    <p><strong>-Little_Endian_Adler_16</strong> <em>address</em></p>
  </dt>
  <dd>
    <p>This filter may be used to insert an Adler 16\[hy]bit checksum of the data into the data.  Two bytes, in little\[hy]endian order, are inserted at the address given.  Holes in the input data are ignored.  Bytes are processed in ascending address order (<em>not</em> in the order they appear in the input).</p><p><strong>Note:</strong> If you have holes in your data, you will get a different Adler checksum than if there were no holes.  This is important because the in\[hy]memory EPROM image will not have holes.  You almost always want to use the <strong>-fill</strong> filter before any of the Adler filters. You will receive a warning if the data presented for Adler checksum has holes.</p><p>You should also be aware that the lower and upper bounds of your data may not be the same as the lower and upper bounds of your EPROM.  This is another reason to use the <strong>-fill</strong> filter, because it will establish the data across the full EPROM address range.</p><p>http://en.wikipedia.org/wiki/Adler\[hy]32</p>
  </dd>
  <dt>
    <p><strong>-Little_Endian_Adler_32</strong> <em>address</em></p>
  </dt>
  <dd>
    <p>This filter may be used to insert a Adler 32\[hy]bit checksum of the data into the data.  Four bytes, in little\[hy]endian order, are inserted at the address given.  Holes in the input data are ignored.  Bytes are processed in ascending address order (<em>not</em> in the order they appear in the input).</p><p><strong>Note:</strong> If you have holes in your data, you will get a different Adler checksum than if there were no holes.  This is important because the in\[hy]memory EPROM image will not have holes.  You almost always want to use the <strong>-fill</strong> filter before any of the Adler checksum filters. You will receive a warning if the data presented for Adler checksum has holes.</p><p>You should also be aware that the lower and upper bounds of your data may not be the same as the lower and upper bounds of your EPROM.  This is another reason to use the <strong>-fill</strong> filter, because it will establish the data across the full EPROM address range.</p><p>http://en.wikipedia.org/wiki/Adler\[hy]32</p>
  </dd>
  <dt>
    <p><strong>-Little_Endian_Checksum_BitNot</strong> <em>address</em> [ <em>nbytes</em> [  <em>width</em> ]]</p>
  </dt>
  <dd>
    <p>This filter may be used to insert the one's complement (bitnot) checksum of the data into the data, least significant byte first. Otherwise similar to the above.</p>
  </dd>
  <dt>
    <p><strong>-Little_Endian_Checksum_Negative</strong> <em>address</em> [ <em>nbytes</em> [  <em>width</em> ]]</p>
  </dt>
  <dd>
    <p>This filter may be used to insert the two's complement (negative) checksum of the data into the data.  Otherwise similar to the above.</p>
  </dd>
  <dt>
    <p><strong>-Little_Endian_Checksum_Positive</strong> <em>address</em> [ <em>nbytes</em> [  <em>width</em> ]]</p>
  </dt>
  <dd>
    <p>This filter may be used to insert the simple checksum of the data into the data.  Otherwise similar to the above.</p>
  </dd>
  <dt>
    <p><strong>-Little_Endian_CRC16</strong> <em>address</em> [ <em>modifier</em>... ]</p>
  </dt>
  <dd>
    <p>The same as the <strong>-Big_Endian_CRC16</strong> filter, except little\[hy]endian order.</p>
  </dd>
  <dt>
    <p><strong>-Little_Endian_CRC32</strong> <em>address</em></p>
  </dt>
  <dd>
    <p>The same as the <strong>-Big_Endian_CRC32</strong> filter, except little\[hy]endian order.</p>
  </dd>
  <dt>
    <p><strong>-Little_Endian_Exclusive_Length</strong> <em>address</em> [ <em>nbytes</em>  [ <em>width</em> ]]</p>
  </dt>
  <dd>
    <p>The same as the <strong>-Little_Endian_Length</strong> filter, except that the result does <strong>not</strong> include the length itself.</p>
  </dd>
  <dt>
    <p><strong>-Little_Endian_Exclusive_MAXimum</strong> <em>address</em> [ <em>nbytes</em> ]</p>
  </dt>
  <dd>
    <p>The same as the <strong>-Little_Endian_MAXimum</strong> filter, except that the result does <strong>not</strong> include the maximum itself.</p>
  </dd>
  <dt>
    <p><strong>-Little_Endian_Exclusive_MINimum</strong> <em>address</em> [ <em>nbytes</em> ]</p>
  </dt>
  <dd>
    <p>The same as the <strong>-Little_Endian_MINimum</strong> filter, except that the result does <strong>not</strong> include the minimum itself.</p>
  </dd>
  <dt>
    <p><strong>-Little_Endian_Fletcher_16</strong> <em>address</em></p>
  </dt>
  <dd>
    <p>This filter may be used to insert an Fletcher 16\[hy]bit checksum of the data into the data.  Two bytes, in little\[hy]endian order, are inserted at the address given.  Holes in the input data are ignored.  Bytes are processed in ascending address order (<em>not</em> in the order they appear in the input).</p><p><strong>Note:</strong> If you have holes in your data, you will get a different Fletcher checksum than if there were no holes.  This is important because the in\[hy]memory EPROM image will not have holes.  You almost always want to use the <strong>-fill</strong> filter before any of the Fletcher filters. You will receive a warning if the data presented for Fletcher checksum has holes.</p><p>You should also be aware that the lower and upper bounds of your data may not be the same as the lower and upper bounds of your EPROM.  This is another reason to use the <strong>-fill</strong> filter, because it will establish the data across the full EPROM address range.</p><p>http://en.wikipedia.org/wiki/Fletcher%27s_checksum</p>
  </dd>
  <dt>
    <p><strong>-Little_Endian_Fletcher_32</strong> <em>address</em></p>
  </dt>
  <dd>
    <p>This filter may be used to insert a Fletcher 32\[hy]bit checksum of the data into the data.  Four bytes, in little\[hy]endian order, are inserted at the address given.  Holes in the input data are ignored.  Bytes are processed in ascending address order (<em>not</em> in the order they appear in the input).</p><p><strong>Note:</strong> If you have holes in your data, you will get a different Fletcher checksum than if there were no holes.  This is important because the in\[hy]memory EPROM image will not have holes.  You almost always want to use the <strong>-fill</strong> filter before any of the Fletcher checksum filters. You will receive a warning if the data presented for Fletcher checksum has holes.</p><p>You should also be aware that the lower and upper bounds of your data may not be the same as the lower and upper bounds of your EPROM.  This is another reason to use the <strong>-fill</strong> filter, because it will establish the data across the full EPROM address range.</p><p>http://en.wikipedia.org/wiki/Fletcher%27s_checksum</p>
  </dd>
  <dt>
    <p><strong>-Little_Endian_Length</strong> <em>address</em> [ <em>nbytes</em> [ <em>width</em> ]]</p>
  </dt>
  <dd>
    <p>The same as the <strong>-Big_Endian_Length</strong> filter, except the value will be written with the least significant byte first.</p>
  </dd>
  <dt>
    <p><strong>-Little_Endian_MAXimum</strong> <em>address</em> [ <em>nbytes</em> ]</p>
  </dt>
  <dd>
    <p>The same as the <strong>-Big_Endian_MAXimum</strong> filter, except the value will be written with the least significant byte first.</p>
  </dd>
  <dt>
    <p><strong>-Little_Endian_MINimum</strong> <em>address</em> [ <em>nbytes</em> ]</p>
  </dt>
  <dd>
    <p>The same as the <strong>-Big_Endian_MINimum</strong> filter, except the value will be written with the least significant byte first.</p>
  </dd>
  <dt>
    <p><strong>-Message_Digest_5 </strong><em>address</em><strong></strong></p>
  </dt>
  <dd>
    <p>This filter may be used to insert a 16 byte MD5 hash into the data, at the address given.</p>
  </dd>
  <dt>
    <p><strong>-NOT</strong></p>
  </dt>
  <dd>
    <p>This filter may be used to bit\[hy]wise NOT the value of every data byte. This is useful if you need to invert the data. Only existing data is altered, no holes are filled.</p>
  </dd>
  <dt>
    <p><strong>-OFfset</strong> <em>nbytes</em></p>
  </dt>
  <dd>
    <p>This filter may be used to offset the addresses by the given number of bytes. No data is lost, the addresses will wrap around in 32 bits, if necessary. You may use negative numbers for the offset, if you wish to move data lower in memory.</p><p>Please note: the execution start address is a different concept than the first address in memory of your data.  If you want to change where your monitor will start executing, use the <strong>-execution\[hy]start\[hy]address</strong> option (<a href="../man1/srec_cat.1.html"><strong>srec_cat</strong>(1)</a> only).</p>
  </dd>
  <dt>
    <p><strong>-OR</strong> <em>value</em></p>
  </dt>
  <dd>
    <p>This filter may be used to bit\[hy]wise OR a <em>value</em> to every data byte. This is useful if you need to set bits. Only existing data is altered, no holes are filled.</p>
  </dd>
  <dt>
    <p><strong>-Random_Fill</strong> <em>address\[hy]range</em></p>
  </dt>
  <dd>
    <p>This filter may be used to fill any gaps in the data with random bytes. The fill will only occur in the address range given.</p>
  </dd>
  <dt>
    <p><strong>-Ripe_Message_Digest_160 </strong><em>address</em><strong></strong></p>
  </dt>
  <dd>
    <p>This filter may be used to insert an RMD160 hash into the data.</p>
  </dd>
  <dt>
    <p><strong>-Secure_Hash_Algorithm_1 </strong><em>address</em><strong></strong></p>
  </dt>
  <dd>
    <p>This filter may be used to insert a 20 byte SHA1 hash into the data, at the address given.</p>
  </dd>
  <dt>
    <p><strong>-Secure_Hash_Algorithm_224 </strong><em>address</em><strong></strong></p>
  </dt>
  <dd>
    <p>This filter may be used to insert a 28 byte SHA224 hash into the data, at the address given. See Change Notice 1 for FIPS 180\[hy]2 for the specification.</p>
  </dd>
  <dt>
    <p><strong>-Secure_Hash_Algorithm_256 </strong><em>address</em><strong></strong></p>
  </dt>
  <dd>
    <p>This filter may be used to insert a 32 byte SHA256 hash into the data, at the address given. See FIPS 180\[hy]2 for the specification.</p>
  </dd>
  <dt>
    <p><strong>-Secure_Hash_Algorithm_384 </strong><em>address</em><strong></strong></p>
  </dt>
  <dd>
    <p>This filter may be used to insert a 48 byte SHA384 hash into the data, at the address given. See FIPS 180\[hy]2 for the specification.</p>
  </dd>
  <dt>
    <p><strong>-Secure_Hash_Algorithm_512 </strong><em>address</em><strong></strong></p>
  </dt>
  <dd>
    <p>This filter may be used to insert a 64 byte SHA512 hash into the data, at the address given. See FIPS 180\[hy]2 for the specification.</p>
  </dd>
  <dt>
    <p><strong>-SPlit</strong> <em>multiple</em> [ <em>offset</em> [ <em>width</em> ] ]</p>
  </dt>
  <dd>
    <p>This filter may be used to split the input into a subset of the data, and compress the address range so as to leave no gaps.  This useful for wide data buses and memory striping.  The <em>multiple</em> is the bytes multiple to split over, the <em>offset</em> is the byte offset into this range (defaults to 0), the <em>width</em> is the number of bytes to extract (defaults to 1) within the multiple.  In order to leave no gaps, the output addresses are (<em>width</em> / <em>multiple</em>) times the input addresses.</p>
  </dd>
  <dt>
    <p><strong>-TIGer</strong> <em>address</em></p>
  </dt>
  <dd>
    <p>This filter may be used to insert a 24 byte TIGER/192 hash into the data at the address given.</p>
  </dd>
  <dt>
    <p><strong>-UnFill</strong> <em>value</em> [ <em>min\[hy]run\[hy]length</em> ]</p>
  </dt>
  <dd>
    <p>This filter may be used to create gaps in the data with bytes equal to <em>value</em>.  You can think of it as reversing the effects of the <strong>-Fill</strong> filter.  The gaps will only be created if the are at least <em>min\[hy]run\[hy]length</em> bytes in a row (defaults to 1).</p>
  </dd>
  <dt>
    <p><strong>-Un_SPlit</strong> <em>multiple</em> [ <em>offset</em> [ <em>width</em> ] ]</p>
  </dt>
  <dd>
    <p>This filter may be used to reverse the effects of the split filter. The arguments are identical. Note that the address range is expanded (<em>multiple</em> / <em>width</em>) times, leaving holes between the stripes.</p>
  </dd>
  <dt>
    <p><strong>-WHIrlpool </strong><em>address</em><strong></strong></p>
  </dt>
  <dd>
    <p>This filter may be used to insert a 64 byte WHIRLPOOL hash into the data, at the address given.</p>
  </dd>

</dl>

<h3>Address Ranges</h3>
<p>There are eight ways to specify an address range:</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>minimum</em> <em>maximum</em></p>
  </dt>
  <dd>
    <p>If you specify two number on the command line (decimal, octal and hexadecimal are understood, using the C conventions) this is an explicit address range.  The minimum is inclusive, the maximum is exclusive (one more than the last address).  If the maximum is given as zero then the range extends to the end of the address space.</p>
  </dd>
  <dt>
    <p><strong>-Within</strong> <em>input\[hy]specification</em></p>
  </dt>
  <dd>
    <p>This says to use the specified input file as a mask.  The range includes all the places the specified input has data, and holes where it has holes.  The input specification need not be just a file name, it may be anything any other input specification can be.</p><p>See also the <strong>-over</strong> option for a discussion on operator precedence.</p>
  </dd>
  <dt>
    <p><strong>-OVER</strong> <em>input\[hy]specification</em></p>
  </dt>
  <dd>
    <p>This says to use the specified input file as a mask.  The range extends from the minimum to the maximum address used by the input, without any holes, even if the input has holes.  The input specification need not be just a file name, it may be anything any other input specification can be.</p><p>You may need to enclose <em>input\[hy]specification</em> in parentheses to make sure it can't misinterpret which arguments go with which input specification. This is particularly important when a filter is to follow.  For example</p><p><em>filename</em> -fill 0 -over <em>filename2</em> -swap\[hy]bytes</p><p>groups as</p><p><em>filename</em> -fill 0 -over '(' <em>filename2</em> -swap\[hy]bytes ')'</p><p>when what you actually wanted was</p><p>'(' <em>filename</em> -fill 0 -over <em>filename2</em> ')' -swap\[hy]bytes</p><p>The command line expression parsing tends to be \[lq]greedy\[rq] (or right associative) rather than conservative (or left associative).</p>
  </dd>
  <dt>
    <p><em>address\[hy]range</em> <strong>-RAnge\[hy]PADding</strong> <em>number</em></p>
  </dt>
  <dd>
    <p>It is also possible to pad ranges to be whole aligned multiples of the given number.  For example</p><p><em>input\[hy]file</em> -fill 0xFF -within <em>input\[hy]file</em>  -range\[hy]pad 512</p><p>will fill the <em>input\[hy]file</em> so that it consists of whole 512\[hy]byte blocks, aligned on 512 byte boundaries.  Any large holes in the data will also be multiples of 512 bytes, though they may have been shrunk as blocks before and after are padded.</p><p>This operator has the same precedence as the explicit union operator.</p>
  </dd>
  <dt>
    <p><em>address\[hy]range</em> <strong>-INTERsect</strong> <em>address\[hy]range</em></p>
  </dt>
  <dd>
    <p>You can intersect two address ranges to produce a smaller address range. The intersection operator has higher precedence than the implicit union operator (evaluated left to right).</p>
  </dd>
  <dt>
    <p><em>address\[hy]range</em> <strong>-UNIon</strong> <em>address\[hy]range</em></p>
  </dt>
  <dd>
    <p>You can union two address ranges to produce a larger address range.  The union operator has lower precedence than the intersection operator (evaluated left to right).</p>
  </dd>
  <dt>
    <p><em>address\[hy]range</em> <strong>-DIFference</strong> <em>address\[hy]range</em></p>
  </dt>
  <dd>
    <p>You can difference two address ranges to produce a smaller address range.  The result is the left hand range with all of the right hand range removed.  The difference operator has the same precedence as the implicit union operator (evaluated left to right).</p>
  </dd>
  <dt>
    <p><em>address\[hy]range</em> <em>address\[hy]range</em></p>
  </dt>
  <dd>
    <p>In addition, all of these methods may be used, and used more than once, and the results will be combined (implicit union operator, same precedence as explicit union operator).</p>
  </dd>

</dl>

<h3>Calculated Values</h3>
<p>Most of the places above where a number is expected, you may supply one of the following:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>-</strong> <em>value</em></p>
  </dt>
  <dd>
    <p>The value of this expression is the negative of the expression argument. Note the <strong>space</strong> between the minus sign and its argument: this space is mandatory.</p><p>srec_cat in.srec -offset \[mi] -minimum\[hy]addr in.srec -o out.srec</p><p>This example shows how to move data to the base of memory.</p>
  </dd>
  <dt>
    <p>W( <em>value</em> W)<em></em></p>
  </dt>
  <dd>
    <p>You may use parentheses for grouping. When using parentheses, they must each be a separate command line argument, they can't be within the text of the preceding or following option, and you will need to quote them to get them past the shell, such as W'(' and W')'.</p>
  </dd>
  <dt>
    <p><strong>-MINimum\[hy]Address</strong> <em>input\[hy]specification</em></p>
  </dt>
  <dd>
    <p>This inserts the minimum address of the specified input file. The input specification need not be just a file name, it may be anything any other input specification can be.</p><p>See also the <strong>-over</strong> option for a discussion on operator precedence.</p>
  </dd>
  <dt>
    <p><strong>-MAXimum\[hy]Address</strong> <em>input\[hy]specification</em></p>
  </dt>
  <dd>
    <p>This inserts the maximum address of the specified input file, plus one. The input specification need not be just a file name, it may be anything any other input specification can be.</p><p>See also the <strong>-over</strong> option for a discussion on operator precedence.</p>
  </dd>
  <dt>
    <p><strong>-Length</strong> <em>input\[hy]specification</em></p>
  </dt>
  <dd>
    <p>This inserts the length of the address range in the specified input file, ignoring any holes.  The input specification need not be just a file name, it may be anything any other input specification can be.</p><p>See also the <strong>-over</strong> option for a discussion on operator precedence.</p>
  </dd>

</dl>
<p>For example, the <strong>-OVER</strong> <em>input\[hy]specification</em> option can be thought of as short\[hy]hand for <strong>'(' -min</strong> <em>file</em> <strong>-max</strong> <em>file</em> <strong>')'</strong>, except that it is much easier to type, and also more efficient.</p><p>In addition, calculated values may optionally be rounded in one of three ways:</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>value</em> <strong>-Round_Down</strong> <em>number</em></p>
  </dt>
  <dd>
    <p>The <em>value</em> is rounded down to the the largest integer smaller than or equal to a whole multiple of the <em>number</em>.</p>
  </dd>
  <dt>
    <p><em>value</em> <strong>-Round_Nearest</strong> <em>number</em></p>
  </dt>
  <dd>
    <p>The <em>value</em> is rounded to the the nearest whole multiple of the <em>number</em>.</p>
  </dd>
  <dt>
    <p><em>value</em> <strong>-Round_Up</strong> <em>number</em></p>
  </dt>
  <dd>
    <p>The <em>value</em> is rounded up to the the smallest integer larger than or equal to a whole multiple of the <em>number</em>.</p>
  </dd>

</dl>
<p>When using parentheses, they must each be a separate command line argument, they can't be within the text of the preceding or following option, and you will need to quote them to get them past the shell, as W'(' and W')'.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p><em>\*(n)</em> version \*(v)</p><p>Copyright \*(Y) Peter Miller</p><p>The <em>\*(n)</em> program comes with ABSOLUTELY NO WARRANTY; for details use the '<em>\*(n) -VERSion License</em>' command. This is free software and you are welcome to redistribute it under certain conditions; for details use the '<em>\*(n) -VERSion License</em>' command.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<table class="table table-striped">
<tr>
<th>Peter Miller</th>
<th>E\[hy]Mail:</th>
<th>pmiller@opensource.org.au</th></tr>

<tr>
<td>/&#92</td>
<td>/&#92</td>
<td>*</td></tr>

<tr>
<td>WWW:</td>
<td>http://miller.emu.id.au/pmiller/</td></tr>
</table>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="srec_info.1.html"><span aria-hidden="true">&larr;</span> srec_info.1: Information about eprom load files</a></li>
   <li class="next"><a href="sreformat.1.html">sreformat.1:  <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

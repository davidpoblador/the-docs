<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>dbacl: A digramic bayesian classifier for text recognition.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="A digramic bayesian classifier for text recognition.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="dbacl (1) manual">
  <meta name="twitter:description" content="A digramic bayesian classifier for text recognition.">
  <meta name="twitter:image" content="https://www.carta.tech/images/dbacl-dbacl-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/dbacl.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="dbacl (1) manual" />
  <meta property="og:description" content="A digramic bayesian classifier for text recognition." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/dbacl-dbacl-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">dbacl<small> (1)</small></h1>
        <p class="lead">A digramic bayesian classifier for text recognition.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/dbacl.1.html">
      <span itemprop="name">dbacl: A digramic bayesian classifier for text recognition.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/dbacl/">
      <span itemprop="name">dbacl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/dbacl.1.html">
      <span itemprop="name">dbacl: A digramic bayesian classifier for text recognition.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>dbacl</strong> [-01dvnirmwMNDXW] [-T <em>type</em> ] -l <em>category</em> [-h <em>size</em>] [-H <em>gsize</em>] [-x <em>decim</em>] [-q <em>quality</em>] [-w <em>max_order</em>] [-e <em>deftok</em>] [-o <em>online</em>] [-L <em>measure</em>] [-g <em>regex</em>]... [FILE]... <strong>dbacl</strong> [-vnimNRX] [-h <em>size</em>] [-T <em>type]</em> -c <em>category</em> [-c <em>category</em>]... [-f <em>keep</em>]... [FILE]... <strong>dbacl</strong> -V</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OVERVIEW</h2>
        <div class="sectioncontent">
<p><strong>dbacl</strong> is a Bayesian text and email classifier. When using the <strong>-l</strong> switch, it learns a body of text and produce a file named <em>category</em> which summarizes the text. When using the <strong>-c</strong> switch, it compares an input text stream with any number of <em>category</em> files, and outputs the name of the closest match, or optionally various numerical scores explained below.</p><p>Whereas this manual page is intended as a reference, there are several tutorials and documents you can read to get specialized information. Specific documentation about the design of <strong>dbacl</strong> and the statistical models that it uses can be found in dbacl.ps. For a basic overview of text classification using <strong>dbacl</strong>, see tutorial.html. A companion tutorial geared towards email filtering is email.html. If you have trouble getting dbacl to classify reliably, read is_it_working.html. The USAGE section of this manual page also has some examples.</p>
<dl class='dl-vertical'>
  <dt>
    /usr/share/doc/dbacl/dbacl.ps
  </dt>
  <dd>
    
  </dd>
  <dt>
    /usr/share/doc/dbacl/tutorial.html
  </dt>
  <dd>
    
  </dd>
  <dt>
    /usr/share/doc/dbacl/email.html
  </dt>
  <dd>
    
  </dd>
  <dt>
    /usr/share/doc/dbacl/is_it_working.html
  </dt>
  <dd>
    
  </dd>

</dl>
<p><strong>dbacl</strong> uses a maximum entropy (minimum divergence) language model constructed with respect to a digramic reference measure (unknown tokens are predicted from digrams, i.e. pairs of letters). Practically, this means that a <em>category</em> is constructed from tokens in the training set, while previously unseen tokens can be predicted automatically from their letters. A token here is either a word (fragment) or a combination of words (fragments), selected according to various switches. Learning roughly works by tweaking token probabilities until the training data is least surprising.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXIT STATUS</h2>
        <div class="sectioncontent">
<p>The normal shell exit conventions aren't followed (sorry!). When using the <strong>-l</strong> command form, <strong>dbacl</strong> returns zero on success, nonzero if an error occurs. When using the <strong>-c</strong> form, <strong>dbacl</strong> returns a positive integer corresponding to the <em>category</em> with the highest posterior probability. In case of a tie, the first most probable category is chosen. If an error occurs, <strong>dbacl</strong> returns zero.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>When using the <strong>-l</strong> command form, <strong>dbacl</strong> learns a category when given one or more FILE names, which should contain readable <small>ASCII</small> text. If no FILE is given, <strong>dbacl</strong> learns from STDIN. If FILE is a directory, it is opened and all its files are read, but not its subdirectories. The result is saved in the binary file named <em>category</em>, and completely replaces any previous contents. As a convenience, if the environment variable DBACL_PATH contains a directory, then that is prepended to the file path, unless <em>category</em> starts with a '/' or a '.'.</p><p>The input text for learning is assumed to be unstructured plain text by default. This is not suitable for learning email, because email contains various transport encodings and formatting instructions which can reduce classification effectiveness. You must use the <strong>-T</strong> switch in that case so that <strong>dbacl</strong> knows it should perform decoding and filtering of MIME and HTML as appropriate. Apropriate switch values are "-T email" for RFC2822 email input, "-T html" for HTML input, "-T xml" for generic XML style input and "-T text" is the default plain text format. There are other values of the <strong>-T</strong> switch that also allow fine tuning of the decoding capabilities.</p><p>When using the <strong>-c</strong> command form, <strong>dbacl</strong> attempts to classify the text found in FILE, or STDIN if no FILE is given. Each possible <em>category</em> must be given separately, and should be the file name of a previously learned text corpus. As a convenience, if the variable DBACL_PATH contains a directory, it is prepended to each file path which doesn't start with a '/' or a '.'. The visible output of the classification depends on the combination of extra switches used. If no switch is used, then no output is shown on STDOUT. However, <strong>dbacl</strong> always produces an exit code which can be tested.</p><p>To see an output for a classification, you must use at least one of the <strong>-v</strong>,<strong>-U</strong>,<strong>-n</strong>,<strong>-N</strong>,<strong>-D</strong>,<strong>-d</strong> switches. Sometimes, they can be used in combination to produce a natural variation of their individual outputs. Sometimes, <strong>dbacl</strong> also produces warnings on STDERR if applicable.</p><p>The <strong>-v</strong> switch outputs the name of the best category among all the choices given.</p><p>The <strong>-U</strong> switch outputs the name of the best category followed by a confidence percentage. Normally, this is the switch that you want to use. A percentage of 100% means that <strong>dbacl</strong> is sure of its choice, while a percentage of 0% means that some other category is equally likely. This is not the model probability, but measures how unambiguous the classification is, and can be used to tag unsure classifications (e.g. if the confidence is 25% or less).</p><p>The <strong>-N</strong> switch prints each category name followed by its (posterior) probability, expressed as a percentage. The percentages always sum to 100%. This is intuitive, but only valuable if the document being classified contains a handful of tokens (ten or less). In the common case with many more tokens, the probabilities are always extremely close to 100% and 0%.</p><p>The <strong>-n</strong> switch prints each category name followed by the negative logarithm of its probability. This is equivalent to using the <strong>-N</strong> switch, but much more useful. The smallest number gives the best category. A more convenient form is to use both <strong>-n</strong> and <strong>-v</strong> which prints each category name followed by the cross entropy and the number of tokens analyzed. The cross entropy measures (in bits) the average compression rate which is achievable, under the given category model, per token of input text. If you use all three of <strong>-n</strong>,<strong>-v</strong>,<strong>-X</strong> then an extra value is output for each category, representing a kind of p-value for each category score. This indicates how typical the score is compared to the training documents, but only works if the <strong>-X</strong> switch was used during learning, and only for some types of models (e.g. email). These p-values are uniformly distributed and independent (if the categories are independent), so can be combined using Fisher's chi squared test to obtain composite p-values for groupings of categories.</p><p>The <strong>-v</strong> and <strong>-X</strong> switches together print each category name followed by a detailed decomposition of the category score, factored into ( divergence rate + shannon entropy rate )* token count @ p-value. Again, this only works in some types of models.</p><p>The <strong>-v</strong> and <strong>-U</strong> switches print each category name followed by a decomposition of the category score into ( divergence rate + shannon entropy rate # score variance )* token count.</p><p>The <strong>-D</strong> switch prints out the input text as modified internally by <strong>dbacl</strong> prior to tokenization. For example, if a MIME encoded email document is classified, then this prints the decoded text that will be actually tokenized and classified. This switch is mainly useful for debugging.</p><p>The <strong>-d</strong> switch dumps tokens and scores while they are being read. It is useful for debugging, or if you want to create graphical representations of the classification. A detailed explanation of the output is beyond the scope of this manual page, but is straightforward if you've read dbacl.ps. Possible variations include <strong>-d</strong> together with <strong>-n</strong> or <strong>-N</strong>.</p><p>Classification can be done with one or several categories in principle. When two or more categories are used, the Bayesian posterior probability is used, given the input text, with a uniform prior distribution on categories. For other choices of prior, see the companion utility <a href="../man1/bayesol.1.html"><strong>bayesol</strong>(1)</a>. When a single category is used, classification can be done by comparing the score with a treshold. In practice however, much better results are obtained with several categories.</p><p>Learning and classifying cannot be mixed on the same command invocation, however there are no locking issues and separate <strong>dbacl</strong> processes can operate simultaneously with obvious results, because file operations are designed to be atomic.</p><p>Finally, note that <strong>dbacl</strong> does not manage your document corpora or your computed categories, and in particular it does not allow you to extend an existing category file with new documents. This is unlike various current spam filters, which can learn new emails incrementally. This limitation of <strong>dbacl</strong> is partially due to the nonlinear procedure used in the learning algorithm, and partially a desire for increased flexibility.</p><p>You can simulate the effect of incremental learning by saving your training documents into archives and adding to these archives over time, relearning from scratch periodically. Learning is actually faster if these archives are compressed and decompressed on the fly when needed. By keeping control of your archives, you can never lose the information in your categories, and you can easily experiment with different switches or tokenizations or sets of training documents if you like.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SECONDARY SWITCHES</h2>
        <div class="sectioncontent">
<p>By default, <strong>dbacl</strong> classifies the input text as a whole. However, when using the <strong>-f</strong> option, <strong>dbacl</strong> can be used to filter each input line separately, printing only those lines which match one or more models identified by <em>keep</em> (use the category name or number to refer to a category). This is useful if you want to filter out some lines, but note that if the lines are short, then the error rate can be high.</p><p>The <strong>-e</strong>,<strong>-w</strong>,<strong>-g</strong>,<strong>-j</strong> switches are used for selecting an appropriate tokenization scheme. A token is a word or word fragment or combination of words or fragments. The shape of tokens is important because it forms the basis of the language models used by <strong>dbacl</strong>. The <strong>-e</strong> switch selects a predefined tokenization scheme, which is speedy but limited. The <strong>-w</strong> switch specifies composite tokens derived from the <strong>-e</strong> switch. For example, "-e alnum -w 2" means that tokens should be alphanumeric word fragments combined into overlapping pairs (bigrams). When the <strong>-j</strong> switch is used, all tokens are converted to lowercase, which reduces the number of possible tokens and therefore memory consumption.</p><p>If the <strong>-g</strong> switch is used, you can completely specify what the tokens should look like using a regular expression. Several <strong>-g</strong> switches can be used to construct complex tokenization schemes, and parentheses within each expression can be used to select fragments and combine them into n-grams. The cost of such flexibility is reduced classification and learning speed. When experimenting with tokenization schemes, try using the <strong>-d</strong> or <strong>-D</strong> switches while learning or classifying, as they will print the tokens explicitly so you can see what text fragments are picked up or missed out. For regular exression syntax, see <a href="../man7/regex.7.html"><strong>regex</strong>(7)</a>.</p><p>The <strong>-h</strong> and <strong>-H</strong> switches regulate how much memory <strong>dbacl</strong> may use for learning. Text classification can use a lot of memory, and by default <strong>dbacl</strong> limits itself even at the expense of learning accuracy. In many cases if a limit is reached, a warning message will be printed on STDERR with some advice.</p><p>When relearning the same category several times, a significant speedup can be obtained by using the <strong>-1</strong> switch, as this allows the previously learned probabilities to be read from the category and reused.</p><p>Note that classification accuracy depends foremost on the amount and quality of the training samples, and then only on amount of tweaking.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXIT STATUS</h2>
        <div class="sectioncontent">
<p>When using the <strong>-l</strong> command form, <strong>dbacl</strong> returns zero on success. When using the <strong>-c</strong> form, <strong>dbacl</strong> returns a positive integer (1,2,3...) corresponding to the <em>category</em> with the highest posterior probability. In case of a tie, the first most probable category is chosen. If an error occurs, <strong>dbacl</strong> returns zero.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    -0
  </dt>
  <dd>
    <p>When learning, prevents weight preloading. Normally, <strong>dbacl</strong> checks if the category file already exists, and if so, tries to use the existing weights as a starting point. This can dramatically speed up learning. If the <strong>-0</strong> (zero) switch is set, then <strong>dbacl</strong> behaves as if no category file already exists. This is mainly useful for testing. This switch is now enabled by default, to protect against weight drift which can reduce accuracy over many learning iterations. Use <strong>-1</strong> to force preloading.</p>
  </dd>
  <dt>
    -1
  </dt>
  <dd>
    <p>Force weight preloading if the category file already exists. See discussion of the <strong>-0</strong> switch.</p>
  </dd>
  <dt>
    -a
  </dt>
  <dd>
    <p>Append scores. Every input line is written to STDOUT and the dbacl scores are appended. This is useful for postprocessing with <a href="../man1/bayesol.1.html"><strong>bayesol</strong>(1)</a>. For ease of processing, every original input line is indented by a single space (to distinguish them from the appended scores), and the line with the scores (if <strong>-n</strong> is used) is prefixed with the string "scores ". If a second copy of <strong>dbacl</strong> needs to read this output later, it should be invoked with the <strong>-A</strong> switch.</p>
  </dd>
  <dt>
    -d
  </dt>
  <dd>
    <p>Dump the model parameters to STDOUT. In conjunction with the <strong>-l</strong> option, this produces a human-readable summary of the maximum entropy model. In conjunction with the <strong>-c</strong> option, displays the contribution of each token to the final score. Suppresses all other normal output.</p>
  </dd>
  <dt>
    -e
  </dt>
  <dd>
    <p>Select character class for default (not regex-based) tokenization. By default, tokens are alphabetic strings only. This corresponds to the case when <em>deftok</em> is "alpha". Possible values for <em>deftok</em> are "alpha", "alnum", "graph", "char", "cef" and "adp". The last two are custom tokenizers intended for email messages.  See also <a href="../man3/isalpha.3.html"><strong>isalpha</strong>(3)</a>. The "char" tokenizer picks up single printable characters rather than bigger tokens, and is intended for testing only.</p>
  </dd>
  <dt>
    -f
  </dt>
  <dd>
    <p>Filter each line of input separately, passing to STDOUT only lines which match the <em>category</em> identified as <em>keep</em>. This option should be used repeatedly for each <em>category</em> which must be kept. <em>keep</em> can be either the <em>category</em> file name, or a positive integer representing the required <em>category</em> in the same order it appears on the command line.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Output lines are flushed as soon as they are written. If the input file is a pipe or character device, then an attempt is made to use line buffering mode, otherwise the more efficient block buffering is used.</p>
  </dd>
  <dt>
    -g
  </dt>
  <dd>
    <p>Learn only features described by the extended regular expression <em>regex</em>. This overrides the default feature selection method (see <strong>-w</strong> option) and learns, for each line of input, only tokens constructed from the concatenation of strings which match the tagged subexpressions within the supplied <em>regex</em>. All substrings which match <em>regex</em> within a suffix of each input line are treated as features, even if they overlap on the input line.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>As an optional convenience, <em>regex</em> can include the suffix <em>||xyz</em> which indicates which parenthesized subexpressions should be tagged. In this case, <em>xyz</em> should consist exclusively of digits 1 to 9, numbering exactly those subexpressions which should be tagged. Alternatively, if no parentheses exist within <em>regex</em>, then it is assumed that the whole expression must be captured.</p>
  </dd>
  <dt>
    -h
  </dt>
  <dd>
    <p>Set the size of the hash table to 2^<em>size</em> elements. When using the <strong>-l</strong> option, this refers to the total number of features allowed in the maximum entropy model being learned. When using the <strong>-c</strong> option toghether with the <strong>-M</strong> switch and multinomial type categories, this refers to the maximum number of features taken into account during classification. Without the <strong>-M</strong> switch, this option has no effect.</p>
  </dd>
  <dt>
    -i
  </dt>
  <dd>
    <p>Fully internationalized mode. Forces the use of wide characters internally, which is necessary in some locales. This incurs a noticeable performance penalty.</p>
  </dd>
  <dt>
    -j
  </dt>
  <dd>
    <p>Make features case sensitive. Normally, all features are converted to lower case during processing, which reduces storage requirements and improves statistical estimates for small datasets. With this option, the original capitalization is used for each feature. This can improve classification accuracy.</p>
  </dd>
  <dt>
    -m
  </dt>
  <dd>
    <p>Aggressively maps categories into memory and locks them into RAM to prevent swapping, if possible. This is useful when speed is paramount and memory is plentiful, for example when testing the classifier on large datasets.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Locking may require relaxing user limits with <strong>ulimit</strong>(1). Ask your system administrator. Beware when using the <strong>-m</strong> switch together with the <strong>-o</strong> switch, as only one dbacl process must learn or classify at a time to prevent file corruption. If no learning takes place, then the <strong>-m</strong> switch for classifying is always safe to use. See also the discussion for the <strong>-o</strong> switch.</p>
  </dd>
  <dt>
    -n
  </dt>
  <dd>
    <p>Print scores for each <em>category</em>. Each score is the product of two numbers, the cross entropy and the complexity of the input text under each model. Multiplied together, they represent the log probability that the input resembles the model. To see these numbers separately, use also the <strong>-v</strong> option. In conjunction with the <strong>-f</strong> option, stops filtering but prints each input line prepended with a list of scores for that line.</p>
  </dd>
  <dt>
    -q
  </dt>
  <dd>
    <p>Select <em>quality</em> of learning, where <em>quality</em> can be 1,2,3,4. Higher values take longer to learn, and should be slightly more accurate. The default <em>quality</em> is 1 if the category file doesn't exist or weights cannot be preloaded, and 2 otherwise.</p>
  </dd>
  <dt>
    -o
  </dt>
  <dd>
    <p>When learning, reads/writes partial token counts so they can be reused. Normally, category files are learned from exactly the input data given, and don't contain extraneous information. When this option is in effect, some extra information is saved in the file <em>online</em>, after all input was read. This information can be reread the next time that learning occurs, to continue where the previous dataset left off. If <em>online</em> doesn't exist, it is created. If <em>online</em> exists, it is read before learning, and updated afterwards. The file is approximately 3 times bigger (at least) than the learned <em>category</em>.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>In <strong>dbacl</strong>, file updates are atomic, but if using the <strong>-o</strong> switch, two or more processes should not learn simultaneously, as only one process will write a lasting category and memory dump. The <strong>-m</strong> switch can also speed up online learning, but beware of possible corruption. Only one process should read or write a file. This option is intended primarily for controlled test runs.</p>
  </dd>
  <dt>
    -r
  </dt>
  <dd>
    <p>Learn the digramic reference model only. Skips the learning of extra features in the text corpus.</p>
  </dd>
  <dt>
    -v
  </dt>
  <dd>
    <p>Verbose mode. When learning, print out details of the computation, when classifying, print out the name of the most probable <em>category</em>. In conjunction with the <strong>-n</strong> option, prints the scores as an explicit product of the cross entropy and the complexity.</p>
  </dd>
  <dt>
    -w
  </dt>
  <dd>
    <p>Select default features to be n-grams up to <em>max_order</em>. This is incompatible with the <strong>-g</strong> option, which always takes precedence. If no <strong>-w</strong> or <strong>-g</strong> options are given, <strong>dbacl</strong> assumes <strong>-w</strong> 1. Note that n-grams for n greater than 1 do not straddle line breaks by default. The <strong>-S</strong> switch enables line straddling.</p>
  </dd>
  <dt>
    -x
  </dt>
  <dd>
    <p>Set decimation probability to 1 - 2^(<em>-decim</em>). To reduce memory requirements when learning, some inputs are randomly skipped, and only a few are added to the model. Exact behaviour depends on the applicable <strong>-T</strong> option (default is <strong>-T</strong> "text"). When the type is not "email" (eg "text"), then individual input features are added with probability 2^(<em>-decim</em>). When the type is "email", then full input messages are added with probability 2^(<em>-decim</em>). Within each such message, all features are used.</p>
  </dd>
  <dt>
    -A
  </dt>
  <dd>
    <p>Expect indented input and scores. With this switch, <strong>dbacl</strong> expects input lines to be indented by a single space character (which is then skipped). Lines starting with any other character are ignored. This is the counterpart to the <strong>-a</strong> switch above. When used together with the <strong>-a</strong> switch, <strong>dbacl</strong> outputs the skipped lines as they are, and reinserts the space at the front of each processed input line.</p>
  </dd>
  <dt>
    -D
  </dt>
  <dd>
    <p>Print debug output. Do not use normally, but can be very useful for displaying the list features picked up while learning.</p>
  </dd>
  <dt>
    -H
  </dt>
  <dd>
    <p>Allow hash table to grow up to a maximum of 2^<em>gsize</em> elements during learning. Initial size is given by <strong>-h</strong> option.</p>
  </dd>
  <dt>
    -L
  </dt>
  <dd>
    <p>Select the digramic reference measure for character transitions. The <em>measure</em> can be one of "uniform", "dirichlet" or "maxent". Default is "uniform".</p>
  </dd>
  <dt>
    -M
  </dt>
  <dd>
    <p>Force multinomial calculations. When learning, forces the model features to be treated multinomially. When classifying, corrects entropy scores to reflect multinomial probabilities (only applicable to multinomial type models, if present). Scores will always be lower, because the ordering of features is lost.</p>
  </dd>
  <dt>
    -N
  </dt>
  <dd>
    <p>Print posterior probabilities for each <em>category</em>. This assumes the supplied categories form an exhaustive list of possibilities. In conjunction with the <strong>-f</strong> option, stops filtering but prints each input line prepended with a summary of the posterior distribution for that line.</p>
  </dd>
  <dt>
    -R
  </dt>
  <dd>
    <p>Include an extra category for purely random text. The category is called "random". Only makes sense when using the <strong>-c</strong> option.</p>
  </dd>
  <dt>
    -S
  </dt>
  <dd>
    <p>Enable line straddling. This is useful together with the <strong>-w</strong> option to allow n-grams for n &gt; 1 to ignore line breaks, so a complex token can continue past the end of the line. This is not recommended for email.</p>
  </dd>
  <dt>
    -T
  </dt>
  <dd>
    <p>Specify nonstandard text format. By default, <strong>dbacl</strong> assumes that the input text is a purely <small>ASCII</small> text file. This corresponds to the case when <em>type</em> is "text".</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>There are several types and subtypes which can be used to clean the input text of extraneous tokens before actual learning or classifying takes place. Each (sub)type you wish to use must be indicated with a separate <strong>-T</strong> option on the command line, and automatically implies the corresponding type.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>The "text" type is for unstructured plain text. No cleanup is performed. This is the default if no types are given on the command line.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>The "email" type is for mbox format input files or single RFC822 emails. Headers are recognized and most are skipped. To include extra RFC822 standard headers (except for trace headers), use the "email:headers" subtype. To include trace headers, use the "email:theaders" subtype. To include all headers in the email, use the "email:xheaders" subtype. To skip all headers, except the subject, use "email:noheaders". To scan binary attachments for strings, use the "email:atts" subtype.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>When the "email" type is in effect, HTML markup is automatically removed from text attachments except text/plain attachments. To also remove HTML markup from plain text attachments, use "email:noplain". To prevent HTML markup removal in all text attachments, use "email:plain".</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>The "html" type is for removing HTML markup (between &lt;html&gt; and &lt;/html&gt; tags) and surrounding text. Note that if the "email" type is enabled, then "html" is automatically enabled for compatible message attachments only.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>The "xml" type is like "html", but doesn't honour &lt;html&gt; and &lt;/html&gt;, and doesn't interpret tags (so this should be more properly called "angle markup" removal, and has nothing to do with actual XML semantics).</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>When "html" is enabled, most markup attributes are lost (for values of 'most' close to 'all'). The "html:links" subtype forces link urls to be parsed and learned, which would otherwise be ignored. The "html:alt" subtype forces parsing of alternative text in ALT attributes and various other tags. The "html:scripts" subtype forces parsing of scripts, "html:styles" forces parsing of styles, "html:forms" forces parsing of form values, while "html:comments" forces parsing of HTML comments.</p>
  </dd>
  <dt>
    -U
  </dt>
  <dd>
    <p>Print (U)nambiguity. When used in conjunction with the <strong>-v</strong> switch, prints scores followed by their empirical standard deviations. When used alone, prints the best category, followed by an estimated probability that this category choice is unambiguous. More precisely, the probability measures lack of overlap of CLT confidence intervals for each category score (If there is overlap, then there is ambiguity).</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>This estimated probability can be used as an "unsure" flag, e.g. if the estimated probability is lower than 50%. Formally, a score of 0% means another category is equally likely to apply to the input, and a score of 100% means no other category is likely to apply to the input. Note that this type of confidence is unrelated to the <strong>-X</strong> switch. Also, the probability estimate is usually low if the document is short, or if the message contains many tokens that have never been seen before (only applies to uniform digramic measure).</p>
  </dd>
  <dt>
    -V
  </dt>
  <dd>
    <p>Print the program version number and exit.</p>
  </dd>
  <dt>
    -W
  </dt>
  <dd>
    <p>Like -w, but prevents features from straddling newlines. See the description of <strong>-w</strong>.</p>
  </dd>
  <dt>
    -X
  </dt>
  <dd>
    <p>Print the confidence in the score calculated for each <em>category</em>, when used together with the <strong>-n</strong> or <strong>-N</strong> switch. Prepares the model for confidence scores, when used with the <strong>-l</strong> switch. The confidence is an estimate of the typicality of the score, assuming the null hypothesis that the given category is correct. When used with the <strong>-v</strong> switch alone, factorizes the score as the empirical divergence plus the shannon entropy, multiplied by complexity, in that order. The <strong>-X</strong> switch is not supported in all possible models, and displays a percentage of "0.0" if it can't be calculated. Note that for unknown documents, it is quite common to have confidences close to zero.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">USAGE</h2>
        <div class="sectioncontent">
<p>To create two category files in the current directory from two <small>ASCII</small> text files named Mark_Twain.txt and William_Shakespeare.txt respectively, type:</p><p>% dbacl -l twain Mark_Twain.txt</p><p>% dbacl -l shake William_Shakespeare.txt</p><p>Now you can classify input text, for example:</p><p>% echo "howdy" | dbacl -v -c twain -c shake</p><p>twain</p><p>% echo "to be or not to be" | dbacl -v -c twain -c shake</p><p>shake</p><p>Note that the <strong>-v</strong> option at least is necessary, otherwise <strong>dbacl</strong> does not print anything. The return value is 1 in the first case, 2 in the second.</p><p>% echo "to be or not to be" | dbacl -v -N -c twain -c shake</p><p>twain 22.63% shake 77.37%</p><p>% echo "to be or not to be" | dbacl -v -n -c twain -c shake</p><p>twain  7.04 * 6.0 shake  6.74 * 6.0</p><p>These invocations are equivalent. The numbers 6.74 and 7.04 represent how close the average token is to each category, and 6.0 is the number of tokens observed. If you want to print a simple confidence value together with the best category, replace <strong>-v</strong> with <strong>-U</strong>.</p><p>% echo "to be or not to be" | dbacl -U -c twain -c shake</p><p>shake # 34%</p><p>Note that the true probability of category <em>shake</em> versus category <em>twain</em> is 77.37%, but the calculation is somewhat ambiguous, and 34% is the confidence out of 100% that the calculation is qualitatively correct.</p><p>Suppose a file document.txt contains English text lines interspersed with noise lines. To filter out the noise lines from the English lines, assuming you have an existing category shake say, type:</p><p>% dbacl -c shake -f shake -R document.txt &gt; document.txt_eng</p><p>% dbacl -c shake -f random -R document.txt &gt; document.txt_rnd</p><p>Note that the quality of the results will vary depending on how well the categories shake and random represent each input line. It is sometimes useful to see the posterior probabilities for each line without filtering:</p><p>% dbacl -c shake -f shake -RN document.txt &gt; document.txt_probs</p><p>You can now postprocess the posterior probabilities for each line of text with another script, to replicate an arbitrary Bayesian decision rule of your choice.</p><p>In the special case of exactly two categories, the optimal Bayesian decision procedure can be implemented for documents as follows: let <em>p1</em> be the prior probability that the input text is classified as <em>category1</em>. Consequently, the prior probability of classifying as <em>category2</em> is 1 - <em>p1</em>. Let <em>u12</em> be the cost of misclassifying a <em>category1</em> input text as belonging to <em>category2</em> and vice versa for <em>u21</em>. We assume there is no cost for classifying correctly. Then the following command implements the optimal Bayesian decision: % dbacl -n -c <em>category1</em> -c <em>category2</em> | awk '{ if($2 * <em>p1</em> * <em>u12</em> &gt; $4 * (1 - <em>p1</em>) * <em>u21</em>) { print $1; } else { print $3; } }'</p><p><strong>dbacl</strong> can also be used in conjunction with <strong>procmail</strong>(1) to implement a simple Bayesian email classification system. Assume that incoming mail should be automatically delivered to one of three mail folders located in $MAILDIR and named <em>work</em>, <em>personal</em>, and <em>spam</em>. Initially, these must be created and filled with appropriate sample emails. A <a href="../man1/crontab.1.html"><strong>crontab</strong>(1)</a> file can be used to learn the three categories once a day, e.g.</p><p>CATS=$HOME/.dbacl</p><p>5  0 * * * dbacl -T email -l $CATS/work $MAILDIR/work</p><p>10 0 * * * dbacl -T email -l $CATS/personal $MAILDIR/personal</p><p>15 0 * * * dbacl -T email -l $CATS/spam $MAILDIR/spam</p><p>To automatically deliver each incoming email into the appropriate folder, the following <strong>procmailrc</strong>(5) recipe fragment could be used:</p><p>CATS=$HOME/.dbacl</p><p># run the spam classifier</p><p>:0 c</p><p>YAY=| dbacl -vT email -c $CATS/work -c $CATS/personal -c $CATS/spam</p><p># send to the appropriate mailbox</p><p>:0:</p><p>* ? test -n "$YAY"</p><p>$MAILDIR/$YAY</p><p>:0:</p><p>$DEFAULT</p><p>Sometimes, <strong>dbacl</strong> will send the email to the wrong mailbox. In that case, the misclassified message should be removed from its wrong destination and placed in the correct mailbox. The error will be corrected the next time your messages are learned. If it is left in the wrong category, <strong>dbacl</strong> will learn the wrong corpus statistics.</p><p>The default text features (tokens) read by <strong>dbacl</strong> are purely alphabetic strings, which minimizes memory requirements but can be unrealistic in some cases. To construct models based on alphanumeric tokens, use the <strong>-e</strong> switch. The example below also uses the optional <strong>-D</strong> switch, which prints a list of actual tokens found in the document:</p><p>% dbacl -e alnum -D -l twain Mark_Twain.txt | less</p><p>It is also possible to override the default feature selection method used to learn the category model by means of regular expressions. For example, the following duplicates the default feature selection method in the C locale, while being much slower: % dbacl -l twain -g '^([[:alpha:]]+)' -g '[^[:alpha:]]([[:alpha:]]+)' Mark_Twain.txt</p><p>The category twain which is obtained depends only on single alphabetic words in the text file Mark_Twain.txt (and computed digram statistics for prediction). For a second example, the following command builds a smoothed Markovian (word bigram) model which depends on pairs of consecutive words within each line (but pairs cannot straddle a line break): % dbacl -l twain2 -g '(^|[^[:alpha:]])([[:alpha:]]+)||2' -g '(^|[^[:alpha:]])([[:alpha:]]+)[^[:alpha:]]+([[:alpha:]]+)||23' Mark_Twain.txt</p><p>More general, line based, n-gram models of all orders (up to 7) can be built in a similar way. To construct paragraph based models, you should reformat the input corpora with <strong>awk</strong>(1) or <a href="../man1/sed.1.html"><strong>sed</strong>(1)</a> to obtain one paragraph per line. Line size is limited by available memory, but note that regex performance will degrade quickly for long lines.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PERFORMANCE</h2>
        <div class="sectioncontent">
<p>The underlying assumption of statistical learning is that a relatively small number of training documents can represent a much larger set of input documents. Thus in the long run, learning can grind to a halt without serious impact on classification accuracy. While not true in reality, this assumption is surprisingly accurate for problems such as email filtering. In practice, this means that a well chosen corpus on the order of ten thousand documents is sufficient for highly accurate results for years. Continual learning after such a critical mass results in diminishing returns. Of course, when real world input document patterns change dramatically, the predictive power of the models can be lost. At the other end, a few hundred documents already give acceptable results in most cases.</p><p><strong>dbacl</strong> is heavily optimized for the case of frequent classifications but infrequent batch learning. This is the long run optimum described above. Under ideal conditions, <strong>dbacl</strong> can classify a hundred emails per second on low end hardware (500Mhz Pentium III). Learning speed is not very much slower, but takes effectively much longer for large document collections for various reasons. When using the <strong>-m</strong> switch, data structures are aggressively mapped into memory if possible, reducing overheads for both I/O and memory allocations.</p><p><strong>dbacl</strong> throws away its input as soon as possible, and has no limits on the input document size. Both classification and learning speed are directly proportional to the number of tokens in the input, but learning also needs a nonlinear optimization step which takes time proportional to the number of unique tokens discovered. At time of writing, <strong>dbacl</strong> is one of the fastest open source mail filters given its optimal usage scenario, but uses more memory for learning than other filters.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MULTIPLE PROCESSES AND DATA CORRUPTION</h2>
        <div class="sectioncontent">
<p>When saving category files, <strong>dbacl</strong> first writes out a temporary file in the same location, and renames it afterwards. If a problem or crash occurs during learning, the old category file is therefore left untouched. This ensures that categories can never be corrupted, no matter how many processes try to simultaneously learn or classify, and means that valid categories are available for classification at any time.</p><p>When using the <strong>-m</strong> switch, file contents are memory mapped for speedy reading and writing. This, together with the <strong>-o</strong> switch, is intended mainly for testing purposes, when tens of thousands of messages must be learned and scored in a laboratory to measure <strong>dbacl</strong>'s accuracy. Because no file locking is attempted for performance reasons, corruptions are possible, unless you make sure that only one <strong>dbacl</strong> process reads or writes any file at any given time. This is the only case (-m and -o together) when corruption is possible.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MEMORY USE</h2>
        <div class="sectioncontent">
<p>When classifying a document, <strong>dbacl</strong> loads all indicated categories into RAM, so the total memory needed is approximately the sum of the category file sizes plus a fixed small overhead. The input document is consumed while being read, so its size doesn't matter, but very long lines can take up space. When using the <strong>-m</strong> switch, the categories are read using <a href="../man2/mmap.2.html"><strong>mmap</strong>(2)</a> as available.</p><p>When learning, <strong>dbacl</strong> keeps a large structure in memory which contains many objects which won't be saved into the output category. The size of this structure is proportional to the number of unique tokens read, but not the size of the input documents, since they are discarded while being read. As a rough guide, this structure is 4x-5x the size of the final category file that is produced.</p><p>To prevent unchecked memory growth, <strong>dbacl</strong> allocates by default a fixed smallish amount of memory for tokens. When this space is used up, further tokens are discarded which has the effect of skewing the learned category making it less usable as more tokens are dropped. A warning is printed on STDERR in such a case.</p><p>The <strong>-h</strong> switch lets you fix the initial size of the token space in powers of 2, ie "-h 17" means 2^17 = 131072 possible tokens. If you type "dbacl -V", you can see the number of bytes needed for each token when either learning or classifying. Multiply this number by the maximum number of possible tokens to estimate the memory needed for learning. The <strong>-H</strong> switch lets <strong>dbacl</strong> grow its tables automatically if and when needed, up to a maximum specified. So if you type "-H 21", then the initial size will be doubled repeatedly if necessary, up to approximately two million unique tokens.</p><p>When learning with the <strong>-X</strong> switch, a handful of input documents are also kept in RAM throughout.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ENVIRONMENT</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    DBACL_PATH
  </dt>
  <dd>
    <p>When this variable is set, its value is prepended to every <em>category</em> filename which doesn't start with a '/' or a '.'.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SIGNALS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    INT
  </dt>
  <dd>
    <p>If this signal is caught, <strong>dbacl</strong> simply exits without doing any cleanup or other operations. This signal can often be sent by pressing Ctrl-C on the keyboard. See <a href="../man1/stty.1.html"><strong>stty</strong>(1)</a>.</p>
  </dd>
  <dt>
    HUP, QUIT, TERM
  </dt>
  <dd>
    <p>If one of these signals is caught, <strong>dbacl</strong> stops reading input and continues its operation as if no more input was available. This is a way of quitting gracefully, but note that in learning mode, a category file will be written based on the incomplete input. The QUIT signal can often be sent by pressing Ctrl-&nbsp;on the keyboard. See <a href="../man1/stty.1.html"><strong>stty</strong>(1)</a>.</p>
  </dd>
  <dt>
    USR1
  </dt>
  <dd>
    <p>If this signal is caught, <strong>dbacl</strong> reloads the current categories at the earliest feasible opportunity. This is not normally useful at all, but might be in special cases, such as if the <strong>-f</strong> switch is invoked together with input from a long running pipe.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTES</h2>
        <div class="sectioncontent">
<p><strong>dbacl</strong> generated category files are in binary format, and may or may not be portable to systems using a different byte order architecture (this depends on how <strong>dbacl</strong> was compiled). The <strong>-V</strong> switch prints out whether categories are portable, or else you can just experiment.</p><p><strong>dbacl</strong> does not recognize functionally equivalent regular expressions, and in this case duplicate features will be counted several times.</p><p>With every learned category, the command line options that were used are saved. When classifying, make sure that every relevant category was learned with the same set of options (regexes are allowed to differ), otherwise behaviour is undefined. There is no need to repeat all the switches when classifying.</p><p>If you get many digitization warnings, then you are trying to learn too much data at once, or your model is too complex. <strong>dbacl</strong> is compiled to save memory by digitizing final weights, but you can disable digitization by editing dbacl.h and recompiling.</p><p><strong>dbacl</strong> offers several built-in tokenizers (see <strong>-e</strong> switch) with more to come in future versions, as the author invents them. While the default tokenizer may evolve, no tokenizer should ever be removed, so that you can always simulate previous <strong>dbacl</strong> behaviour subject to bug fixes and architectural changes.</p><p>The confidence estimates obtained through the <strong>-X</strong> switch are underestimates, ie are more conservative than they should be.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>"Ya know, some day scientists are gonna invent something that will outsmart a rabbit." (Robot Rabbit, 1953)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SOURCE</h2>
        <div class="sectioncontent">
<p>The source code for the latest version of this program is available at the following locations:</p><p>http://www.lbreyer.com/gpl.html</p><p>http://dbacl.sourceforge.net</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Laird A. Breyer &lt;laird@lbreyer.com&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO dbacl&hellip;</h2>
        <div class="sectioncontent">
<p><strong>awk</strong>(1), <a href="../man1/bayesol.1.html"><strong>bayesol</strong>(1)</a>, <a href="../man1/crontab.1.html"><strong>crontab</strong>(1)</a>, <a href="../man1/hmine.1.html"><strong>hmine</strong>(1)</a>, <a href="../man1/hypex.1.html"><strong>hypex</strong>(1)</a>, <a href="../man1/less.1.html"><strong>less</strong>(1)</a>, <a href="../man1/mailcross.1.html"><strong>mailcross</strong>(1)</a>, <a href="../man1/mailfoot.1.html"><strong>mailfoot</strong>(1)</a>, <a href="../man1/mailinspect.1.html"><strong>mailinspect</strong>(1)</a>, <a href="../man1/mailtoe.1.html"><strong>mailtoe</strong>(1)</a>, <strong>procmailex</strong>(5), <a href="../man7/regex.7.html"><strong>regex</strong>(7)</a>, <a href="../man1/stty.1.html"><strong>stty</strong>(1)</a>, <a href="../man1/sed.1.html"><strong>sed</strong>(1)</a></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="dba.1.html"><span aria-hidden="true">&larr;</span> dba.1: Dba  characterising shared regulatory regions of genomic dna</a></li>
   <li class="next"><a href="dbadb.1.html">dbadb.1: Manage the db-alle database <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

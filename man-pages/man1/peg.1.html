<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>peg: Parser generators</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Parser generators">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="peg (1) manual">
  <meta name="twitter:description" content="Parser generators">
  <meta name="twitter:image" content="https://www.carta.tech/images/peg-peg-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/peg.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="peg (1) manual" />
  <meta property="og:description" content="Parser generators" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/peg-peg-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">peg<small> (1)</small></h1>
        <p class="lead">Parser generators</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/peg.1.html">
      <span itemprop="name">peg: Parser generators</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/peg/">
      <span itemprop="name">peg</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/peg.1.html">
      <span itemprop="name">peg: Parser generators</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>peg</strong> <strong>[-hvV -ooutput]</strong> <em>[filename ...]</em></p><p><strong>leg</strong> <strong>[-hvV -ooutput]</strong> <em>[filename ...]</em></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><em>peg</em> and <em>leg</em> are tools for generating recursive-descent parsers: programs that perform pattern matching on text.  They process a Parsing Expression Grammar (PEG) [Ford 2004] to produce a program that recognises legal sentences of that grammar. <em>peg</em> processes PEGs written using the original syntax described by Ford; <em>leg</em> processes PEGs written using slightly different syntax and conventions that are intended to make it an attractive replacement for parsers built with <a href="../man1/lex.1.html"><strong>lex</strong>(1)</a> and <strong>yacc</strong>(1). Unlike <em>lex</em> and <em>yacc</em>, <em>peg</em> and <em>leg</em> support unlimited backtracking, provide ordered choice as a means for disambiguation, and can combine scanning (lexical analysis) and parsing (syntactic analysis) into a single activity.</p><p><em>peg</em> reads the specified <em>filename</em>s, or standard input if no <em>filename</em>s are given, for a grammar describing the parser to generate. <em>peg</em> then generates a C source file that defines a function <em>yyparse().</em> This C source file can be included in, or compiled and then linked with, a client program.  Each time the client program calls <em>yyparse</em>() the parser consumes input text according to the parsing rules, starting from the first rule in the grammar. <em>yyparse</em>() returns non-zero if the input could be parsed according to the grammar; it returns zero if the input could not be parsed.</p><p>The prefix 'yy' or 'YY' is prepended to all externally-visible symbols in the generated parser.  This is intended to reduce the risk of namespace pollution in client programs.  (The choice of 'yy' is historical; see <a href="../man1/lex.1.html"><strong>lex</strong>(1)</a> and <strong>yacc</strong>(1), for example.)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONS</h2>
        <div class="sectioncontent">
<p><em>peg</em> and <em>leg</em> provide the following options:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>-h</strong></p>
  </dt>
  <dd>
    <p>prints a summary of available options and then exits.</p>
  </dd>
  <dt>
    <p><strong>-ooutput</strong></p>
  </dt>
  <dd>
    <p>writes the generated parser to the file <strong>output</strong> instead of the standard output.</p>
  </dd>
  <dt>
    <p><strong>-v</strong></p>
  </dt>
  <dd>
    <p>writes verbose information to standard error while working.</p>
  </dd>
  <dt>
    <p><strong>-V</strong></p>
  </dt>
  <dd>
    <p>writes version information to standard error then exits.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">A SIMPLE EXAMPLE</h2>
        <div class="sectioncontent">
<p>The following <em>peg</em> input specifies a grammar with a single rule (called 'start') that is satisfied when the input contains the string "username".</p>
<pre>
    start &lt;- "username"

</pre>
<p>(The quotation marks are <em>not</em> part of the matched text; they serve to indicate a literal string to be matched.)  In other words, <em>yyparse</em>() in the generated C source will return non-zero only if the next eight characters read from the input spell the word "username".  If the input contains anything else, <em>yyparse</em>() returns zero and no input will have been consumed.  (Subsequent calls to <em>yyparse</em>() will also return zero, since the parser is effectively blocked looking for the string "username".)  To ensure progress we can add an alternative clause to the 'start' rule that will match any single character if "username" is not found.</p>
<pre>
    start &lt;- "username"
           / .

</pre>
<p><em>yyparse</em>() now always returns non-zero (except at the very end of the input).  To do something useful we can add actions to the rules.  These actions are performed after a complete match is found (starting from the first rule) and are chosen according to the 'path' taken through the grammar to match the input.  (Linguists would call this path a 'phrase marker'.)</p>
<pre>
    start &lt;- "username"    { printf("%s&#92;n", getlogin()); }
           / &lt; . &gt;         { putchar(yytext[0]); }

</pre>
<p>The first line instructs the parser to print the user's login name whenever it sees "username" in the input.  If that match fails, the second line tells the parser to echo the next character on the input the standard output.  Our parser is now performing useful work: it will copy the input to the output, replacing all occurrences of "username" with the user's account name.</p><p>Note the angle brackets ('&lt;' and '&gt;') that were added to the second alternative.  These have no effect on the meaning of the rule, but serve to delimit the text made available to the following action in the variable <em>yytext</em>.</p><p>If the above grammar is placed in the file <strong>username.peg</strong>, running the command</p>
<pre>
    peg -o username.c username.peg

</pre>
<p>will save the corresponding parser in the file <strong>username.c</strong>. To create a complete program this parser could be included by a C program as follows.</p>
<pre>
    #include &lt;stdio.h&gt;      /* printf(), putchar() */
    #include &lt;unistd.h&gt;     /* getlogin() */

    #include "username.c"   /* yyparse() */

    int main()
    {
      while (yyparse())     /* repeat until EOF */
        ;
      return 0;
    }
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PEG GRAMMARS</h2>
        <div class="sectioncontent">
<p>A grammar consists of a set of named rules.</p>
<pre>
    name &lt;- pattern

</pre>
<p>The <strong>pattern</strong> contains one or more of the following elements.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>name</strong></p>
  </dt>
  <dd>
    <p>The element stands for the entire pattern in the rule with the given <strong>name</strong>.</p>
  </dd>
  <dt>
    <p><strong>&quot;</strong>characters<strong>&quot;</strong></p>
  </dt>
  <dd>
    <p>A character or string enclosed in double quotes is matched literally. The ANSI C escape sequences are recognised within the <em>characters</em>.</p>
  </dd>
  <dt>
    <p><strong>'</strong>characters<strong>'</strong></p>
  </dt>
  <dd>
    <p>A character or string enclosed in single quotes is matched literally, as above.</p>
  </dd>
  <dt>
    <p><strong>[</strong>characters<strong>]</strong></p>
  </dt>
  <dd>
    <p>A set of characters enclosed in square brackets matches any single character from the set, with escape characters recognised as above. If the set begins with an uparrow (^) then the set is negated (the element matches any character <em>not</em> in the set).  Any pair of characters separated with a dash (-) represents the range of characters from the first to the second, inclusive.  A single alphabetic character or underscore is matched by the following set.</p>
<pre>
    [a-zA-Z_]

</pre>
<p>Similarly, the following matches  any single non-digit character.</p>
<pre>
    [^0-9]

</pre>

  </dd>
  <dt>
    <p><strong>.</strong></p>
  </dt>
  <dd>
    <p>A dot matches any character.  Note that the only time this fails is at the end of file, where there is no character to match.</p>
  </dd>
  <dt>
    <p><strong>(</strong><strong>pattern</strong>)</p>
  </dt>
  <dd>
    <p>Parentheses are used for grouping (modifying the precedence of the operators described below).</p>
  </dd>
  <dt>
    <p><strong>{</strong><strong>action</strong>}</p>
  </dt>
  <dd>
    <p>Curly braces surround actions.  The action is arbitrary C source code to be executed at the end of matching.  Any braces within the action must be properly nested.  Any input text that was matched before the action and delimited by angle brackets (see below) is made available within the action as the contents of the character array <em>yytext</em>. The length of (number of characters in) <em>yytext</em> is available in the variable <em>yyleng</em>. (These variable names are historical; see <a href="../man1/lex.1.html"><strong>lex</strong>(1)</a>.)</p>
  </dd>
  <dt>
    <p><strong>&lt;</strong></p>
  </dt>
  <dd>
    <p>An opening angle bracket always matches (consuming no input) and causes the parser to begin accumulating matched text.  This text will be made available to actions in the variable <em>yytext</em>.</p>
  </dd>
  <dt>
    <p><strong>&gt;</strong></p>
  </dt>
  <dd>
    <p>A closing angle bracket always matches (consuming no input) and causes the parser to stop accumulating text for <em>yytext</em>.</p>
  </dd>

</dl>
<p>The above <em>element</em>s can be made optional and/or repeatable with the following suffixes:</p>
<dl class='dl-vertical'>
  <dt>
    <p>element<strong>?</strong></p>
  </dt>
  <dd>
    <p>The element is optional.  If present on the input, it is consumed and the match succeeds.  If not present on the input, no text is consumed and the match succeeds anyway.</p>
  </dd>
  <dt>
    <p>element<strong>+</strong></p>
  </dt>
  <dd>
    <p>The element is repeatable.  If present on the input, one or more occurrences of <em>element</em> are consumed and the match succeeds.  If no occurrences of <em>element</em> are present on the input, the match fails.</p>
  </dd>
  <dt>
    <p>element<strong>*</strong></p>
  </dt>
  <dd>
    <p>The element is optional and repeatable.  If present on the input, one or more occurrences of <em>element</em> are consumed and the match succeeds.  If no occurrences of <em>element</em> are present on the input, the match succeeds anyway.</p>
  </dd>

</dl>
<p>The above elements and suffixes can be converted into predicates (that match arbitrary input text and subsequently succeed or fail <em>without</em> consuming that input) with the following prefixes:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>&</strong><strong>element</strong></p>
  </dt>
  <dd>
    <p>The predicate succeeds only if <em>element</em> can be matched.  Input text scanned while matching <em>element</em> is not consumed from the input and remains available for subsequent matching.</p>
  </dd>
  <dt>
    <p><strong>!</strong><strong>element</strong></p>
  </dt>
  <dd>
    <p>The predicate succeeds only if <em>element</em> cannot be matched.  Input text scanned while matching <em>element</em> is not consumed from the input and remains available for subsequent matching.  A popular idiom is</p>
<pre>
    !.

</pre>
<p>which matches the end of file, after the last character of the input has already been consumed.</p>
  </dd>

</dl>
<p>A special form of the '&' predicate is provided:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>&</strong>{<strong>expression</strong>}</p>
  </dt>
  <dd>
    <p>In this predicate the simple C <em>expression</em> (<strong>not</strong> statement) is evaluated immediately when the parser reaches the predicate.  If the <em>expression</em> yields non-zero (true) the 'match' succeeds and the parser continues with the next element in the pattern.  If the <em>expression</em> yields zero (false) the 'match' fails and the parser backs up to look for an alternative parse of the input.</p>
  </dd>

</dl>
<p>Several elements (with or without prefixes and suffixes) can be combined into a <em>sequence</em> by writing them one after the other.  The entire sequence matches only if each individual element within it matches, from left to right.</p><p>Sequences can be separated into disjoint alternatives by the alternation operator '/'.</p>
<dl class='dl-vertical'>
  <dt>
    <p>sequence-1<strong>/</strong><strong>sequence-2</strong>/<strong></strong>...<strong>/</strong><strong>sequence-N</strong></p>
  </dt>
  <dd>
    <p>Each sequence is tried in turn until one of them matches, at which time matching for the overall pattern succeeds.  If none of the sequences matches then the match of the overall pattern fails.</p>
  </dd>

</dl>
<p>Finally, the pound sign (#) introduces a comment (discarded) that continues until the end of the line.</p><p>To summarise the above, the parser tries to match the input text against a pattern containing literals, names (representing other rules), and various operators (written as prefixes, suffixes, juxtaposition for sequencing and and infix alternation operator) that modify how the elements within the pattern are matched.  Matches are made from left to right, 'descending' into named sub-rules as they are encountered.  If the matching process fails, the parser 'back tracks' ('rewinding' the input appropriately in the process) to find the nearest alternative 'path' through the grammar.  In other words the parser performs a depth-first, left-to-right search for the first successfully-matching path through the rules.  If found, the actions along the successful path are executed (in the order they were encountered).</p><p>Note that predicates are evaluated <em>immediately</em> during the search for a successful match, since they contribute to the success or failure of the search.  Actions, however, are evaluated only after a successful match has been found.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PEG GRAMMAR FOR PEG GRAMMARS</h2>
        <div class="sectioncontent">
<p>The grammar for <em>peg</em> grammars is shown below.  This will both illustrate and formalise the above description.</p>
<pre>
    Grammar         &lt;- Spacing Definition+ EndOfFile

    Definition      &lt;- Identifier LEFTARROW Expression
    Expression      &lt;- Sequence ( SLASH Sequence )*
    Sequence        &lt;- Prefix*
    Prefix          &lt;- AND Action
                     / ( AND | NOT )? Suffix
    Suffix          &lt;- Primary ( QUERY / STAR / PLUS )?
    Primary         &lt;- Identifier !LEFTARROW
                     / OPEN Expression CLOSE
                     / Literal
                     / Class
                     / DOT
                     / Action
                     / BEGIN
                     / END

    Identifier      &lt;- &lt; IdentStart IdentCont* &gt; Spacing
    IdentStart      &lt;- [a-zA-Z_]
    IdentCont       &lt;- IdentStart / [0-9]
    Literal         &lt;- ['] &lt; ( !['] Char  )* &gt; ['] Spacing
                     / ["] &lt; ( !["] Char  )* &gt; ["] Spacing
    Class           &lt;- '[' &lt; ( !']' Range )* &gt; ']' Spacing
    Range           &lt;- Char '-' Char / Char
    Char            &lt;- '&#92;&#92;' [abefnrtv'"&#92;[&#92;]&#92;&#92;]
                     / '&#92;&#92;' [0-3][0-7][0-7]
                     / '&#92;&#92;' [0-7][0-7]?
                     / '&#92;&#92;' '-'
                     / !'&#92;&#92;' .
    LEFTARROW       &lt;- '&lt;-' Spacing
    SLASH           &lt;- '/' Spacing
    AND             &lt;- '&' Spacing
    NOT             &lt;- '!' Spacing
    QUERY           &lt;- '?' Spacing
    STAR            &lt;- '*' Spacing
    PLUS            &lt;- '+' Spacing
    OPEN            &lt;- '(' Spacing
    CLOSE           &lt;- ')' Spacing
    DOT             &lt;- '.' Spacing
    Spacing         &lt;- ( Space / Comment )*
    Comment         &lt;- '#' ( !EndOfLine . )* EndOfLine
    Space           &lt;- ' ' / '&#92;t' / EndOfLine
    EndOfLine       &lt;- '&#92;r&#92;n' / '&#92;n' / '&#92;r'
    EndOfFile       &lt;- !.
    Action          &lt;- '{' &lt; [^}]* &gt; '}' Spacing
    BEGIN           &lt;- '&lt;' Spacing
    END             &lt;- '&gt;' Spacing

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LEG GRAMMARS</h2>
        <div class="sectioncontent">
<p><em>leg</em> is a variant of <em>peg</em> that adds some features of <a href="../man1/lex.1.html"><strong>lex</strong>(1)</a> and <strong>yacc</strong>(1). It differs from <em>peg</em> in the following ways.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>%{</strong><em>text...</em><strong></strong><em>%}</em></p>
  </dt>
  <dd>
    <p>A declaration section can appear anywhere that a rule definition is expected.  The <em>text</em> between the delimiters '%{' and '%}' is copied verbatim to the generated C parser code <em>before</em> the code that implements the parser itself.</p>
  </dd>
  <dt>
    <p><em>name</em><strong>=</strong><em></em><strong>pattern</strong></p>
  </dt>
  <dd>
    <p>The 'assignment' operator replaces the left arrow operator '&lt;-'.</p>
  </dd>
  <dt>
    <p><strong>rule-name</strong></p>
  </dt>
  <dd>
    <p>Hyphens can appear as letters in the names of rules.  Each hyphen is converted into an underscore in the generated C source code.  A single single hyphen '-' is a legal rule name.</p>
<pre>
    -       = [ &#92;t&#92;n&#92;r]*
    number  = [0-9]+                 -
    name    = [a-zA-Z_][a-zA_Z_0-9]* -
    l-paren = '('                    -
    r-paren = ')'                    -

</pre>
<p>This example shows how ignored whitespace can be obvious when reading the grammar and yet unobtrusive when placed liberally at the end of every rule associated with a lexical element.</p>
  </dd>
  <dt>
    <p><em>seq-1</em><strong>|</strong><em></em><strong>seq-2</strong></p>
  </dt>
  <dd>
    <p>The alternation operator is vertical bar '|' rather than forward slash '/'.  The <em>peg</em> rule</p>
<pre>
    name &lt;- sequence-1
          / sequence-2
          / sequence-3

</pre>
<p>is therefore written</p>
<pre>
    name = sequence-1
         | sequence-2
         | sequence-3
         ;

</pre>
<p>in <em>leg</em> (with the final semicolon being optional, as described next).</p>
  </dd>
  <dt>
    <p><em>exp</em><strong></strong><em>~</em><strong></strong><em>{</em><strong>action</strong><em>}</em></p>
  </dt>
  <dd>
    <p>A postfix operator <strong>~</strong><em>{</em><strong>action</strong><em>}</em> can be placed after any expression and will behave like a normal action (arbitrary C code) except that it is invoked only when <em>exp</em> fails.  It binds less tightly than any other operator except alternation and sequencing, and is intended to make error handling and recovery code easier to write. Note that <em>yytext</em> and <em>yyleng</em> are not available inside these actions, but the pointer variable <em>yy</em> is available to give the code access to any user-defined members of the parser state (see "CUSTOMISING THE PARSER" below). Note also that <em>exp</em> is always a single expression; to invoke an error action for any failure within a sequence, parentheses must be used to group the sequence into a single expression.</p>
<pre>
    rule = e1 e2 e3 ~{ error("e[12] ok; e3 has failed"); }
         | ...

    rule = (e1 e2 e3) ~{ error("one of e[123] has failed"); }
         | ...
</pre>

  </dd>
  <dt>
    <p><em>pattern</em><strong>;</strong></p>
  </dt>
  <dd>
    <p>A semicolon punctuator can optionally terminate a <em>pattern</em>.</p>
  </dd>
  <dt>
    <p><strong>%%</strong><em></em><strong>text...</strong></p>
  </dt>
  <dd>
    <p>A double percent '%%' terminates the rules (and declarations) section of the grammar.  All <em>text</em> following '%%' is copied verbatim to the generated C parser code <em>after</em> the parser implementation code.</p>
  </dd>
  <dt>
    <p><strong>$$</strong><em>=</em><strong></strong><em>value</em></p>
  </dt>
  <dd>
    <p>A sub-rule can return a semantic <em>value</em> from an action by assigning it to the pseudo-variable '$$'.  All semantic values must have the same type (which defaults to 'int'). This type can be changed by defining YYSTYPE in a declaration section.</p>
  </dd>
  <dt>
    <p><em>identifier</em><strong>:</strong><em>name</em></p>
  </dt>
  <dd>
    <p>The semantic value returned (by assigning to '$$') from the sub-rule <em>name</em> is associated with the <em>identifier</em> and can be referred to in subsequent actions.</p>
  </dd>

</dl>
<p>The desk calculator example below illustrates the use of '$$' and ':'.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LEG EXAMPLE: A DESK CALCULATOR</h2>
        <div class="sectioncontent">
<p>The extensions in <em>leg</em> described above allow useful parsers and evaluators (including declarations, grammar rules, and supporting C functions such as 'main') to be kept within a single source file.  To illustrate this we show a simple desk calculator supporting the four common arithmetic operators and named variables.  The intermediate results of arithmetic evaluation will be accumulated on an implicit stack by returning them as semantic values from sub-rules.</p>
<pre>
    %{
    #include &lt;stdio.h&gt;     /* printf() */
    #include &lt;stdlib.h&gt;    /* atoi() */
    int vars[26];
    %}

    Stmt    = - e:Expr EOL                  { printf("%d&#92;n", e); }
            | ( !EOL . )* EOL               { printf("error&#92;n"); }

    Expr    = i:ID ASSIGN s:Sum             { $$ = vars[i] = s; }
            | s:Sum                         { $$ = s; }

    Sum     = l:Product
                    ( PLUS  r:Product       { l += r; }
                    | MINUS r:Product       { l -= r; }
                    )*                      { $$ = l; }

    Product = l:Value
                    ( TIMES  r:Value        { l *= r; }
                    | DIVIDE r:Value        { l /= r; }
                    )*                      { $$ = l; }

    Value   = i:NUMBER                      { $$ = atoi(yytext); }
            | i:ID !ASSIGN                  { $$ = vars[i]; }
            | OPEN i:Expr CLOSE             { $$ = i; }

    NUMBER  = &lt; [0-9]+ &gt;    -               { $$ = atoi(yytext); }
    ID      = &lt; [a-z]  &gt;    -               { $$ = yytext[0] - 'a'; }
    ASSIGN  = '='           -
    PLUS    = '+'           -
    MINUS   = '-'           -
    TIMES   = '*'           -
    DIVIDE  = '/'           -
    OPEN    = '('           -
    CLOSE   = ')'           -

    -       = [ &#92;t]*
    EOL     = '&#92;n' | '&#92;r&#92;n' | '&#92;r' | ';'

    %%

    int main()
    {
      while (yyparse())
        ;
      return 0;
    }

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LEG GRAMMAR FOR LEG GRAMMARS</h2>
        <div class="sectioncontent">
<p>The grammar for <em>leg</em> grammars is shown below.  This will both illustrate and formalise the above description.</p>
<pre>
    grammar =       -
                    ( declaration | definition )+
                    trailer? end-of-file

    declaration =   '%{' &lt; ( !'%}' . )* &gt; RPERCENT

    trailer =       '%%' &lt; .* &gt;

    definition =    identifier EQUAL expression SEMICOLON?

    expression =    sequence ( BAR sequence )*

    sequence =      error+

    error =         prefix ( TILDE action )?

    prefix =        AND action
    |               ( AND | NOT )? suffix

    suffix =        primary ( QUERY | STAR | PLUS )?

    primary =       identifier COLON identifier !EQUAL
    |               identifier !EQUAL
    |               OPEN expression CLOSE
    |               literal
    |               class
    |               DOT
    |               action
    |               BEGIN
    |               END

    identifier =    &lt; [-a-zA-Z_][-a-zA-Z_0-9]* &gt; -

    literal =       ['] &lt; ( !['] char )* &gt; ['] -
    |               ["] &lt; ( !["] char )* &gt; ["] -

    class =         '[' &lt; ( !']' range )* &gt; ']' -

    range =         char '-' char | char

    char =          '&#92;&#92;' [abefnrtv'"&#92;[&#92;]&#92;&#92;]
    |               '&#92;&#92;' [0-3][0-7][0-7]
    |               '&#92;&#92;' [0-7][0-7]?
    |               !'&#92;&#92;' .

    action =        '{' &lt; braces* &gt; '}' -

    braces =        '{' braces* '}'
    |               !'}' .

    EQUAL =         '=' -
    COLON =         ':' -
    SEMICOLON =     ';' -
    BAR =           '|' -
    AND =           '&' -
    NOT =           '!' -
    QUERY =         '?' -
    STAR =          '*' -
    PLUS =          '+' -
    OPEN =          '(' -
    CLOSE =         ')' -
    DOT =           '.' -
    BEGIN =         '&lt;' -
    END =           '&gt;' -
    TILDE =         '~' -
    RPERCENT =      '%}' -

    - =             ( space | comment )*
    space =         ' ' | '&#92;t' | end-of-line
    comment =       '#' ( !end-of-line . )* end-of-line
    end-of-line =   '&#92;r&#92;n' | '&#92;n' | '&#92;r'
    end-of-file =   !.

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CUSTOMISING THE PARSER</h2>
        <div class="sectioncontent">
<p>The following symbols can be redefined in declaration sections to modify the generated parser code.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>YYSTYPE</strong></p>
  </dt>
  <dd>
    <p>The semantic value type.  The pseudo-variable '$$' and the identifiers 'bound' to rule results with the colon operator ':' should all be considered as being declared to have this type.  The default value is 'int'.</p>
  </dd>
  <dt>
    <p><strong>YYPARSE</strong></p>
  </dt>
  <dd>
    <p>The name of the main entry point to the parser.  The default value is 'yyparse'.</p>
  </dd>
  <dt>
    <p><strong>YYPARSEFROM</strong></p>
  </dt>
  <dd>
    <p>The name of an alternative entry point to the parser.  This function expects one argument: the function corresponding to the rule from which the search for a match should begin.  The default is 'yyparsefrom'.  Note that yyparse() is defined as</p>
<pre>
    int yyparse() { return yyparsefrom(yy_foo); }

</pre>
<p>where 'foo' is the name of the first rule in the grammar.</p>
  </dd>
  <dt>
    <p><strong>YY_INPUT(</strong><em>buf</em><strong>,</strong><em></em><strong>result</strong><em>,</em><strong></strong><em>max_size</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>This macro is invoked by the parser to obtain more input text. <em>buf</em> points to an area of memory that can hold at most <em>max_size</em> characters.  The macro should copy input text to <em>buf</em> and then assign the integer variable <em>result</em> to indicate the number of characters copied.  If no more input is available, the macro should assign 0 to <em>result</em>. By default, the YY_INPUT macro is defined as follows.</p>
<pre>
    #define YY_INPUT(buf, result, max_size)        &#92;
    {                                              &#92;
      int yyc= getchar();                          &#92;
      result= (EOF == yyc) ? 0 : (*(buf)= yyc, 1); &#92;
    }

</pre>
<p>Note that if YY_CTX_LOCAL is defined (see below) then an additional first argument, containing the parser context, is passed to YY_INPUT.</p>
  </dd>
  <dt>
    <p><strong>YY_DEBUG</strong></p>
  </dt>
  <dd>
    <p>If this symbols is defined then additional code will be included in the parser that prints vast quantities of arcane information to the standard error while the parser is running.</p>
  </dd>
  <dt>
    <p><strong>YY_BEGIN</strong></p>
  </dt>
  <dd>
    <p>This macro is invoked to mark the start of input text that will be made available in actions as 'yytext'.  This corresponds to occurrences of '&lt;' in the grammar.  These are converted into predicates that are expected to succeed.  The default definition</p>
<pre>
    #define YY_BEGIN (yybegin= yypos, 1)

</pre>
<p>therefore saves the current input position and returns 1 ('true') as the result of the predicate.</p>
  </dd>
  <dt>
    <p><strong>YY_END</strong></p>
  </dt>
  <dd>
    <p>This macros corresponds to '&gt;' in the grammar.  Again, it is a predicate so the default definition saves the input position before 'succeeding'.</p>
<pre>
    #define YY_END (yyend= yypos, 1)

</pre>

  </dd>
  <dt>
    <p><strong>YY_PARSE(</strong><em>T</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>This macro declares the parser entry points (yyparse and yyparsefrom) to be of type <em>T</em>. The default definition</p>
<pre>
    #define YY_PARSE(T) T

</pre>
<p>leaves yyparse() and yyparsefrom() with global visibility.  If they should not be externally visible in other source files, this macro can be redefined to declare them 'static'.</p>
<pre>
    #define YY_PARSE(T) static T

</pre>

  </dd>
  <dt>
    <p><strong>YY_CTX_LOCAL</strong></p>
  </dt>
  <dd>
    <p>If this symbol is defined during compilation of a generated parser then global parser state will be kept in a structure of type 'yycontext' which can be declared as a local variable.  This allows multiple instances of parsers to coexist and to be thread-safe. The parsing function <em>yyparse</em>() will be declared to expect a first argument of type 'yycontext *', an instance of the structure holding the global state for the parser. This instance must be allocated and initialised to zero by the client. A trivial but complete example is as follows.</p>
<pre>
    #include &lt;stdio.h&gt;

    #define YY_CTX_LOCAL

    #include "the-generated-parser.peg.c"

    int main()
    {
      yycontext ctx;
      memset(&ctx, 0, sizeof(yycontext));
      while (yyparse(&ctx));
      return 0;
    }

</pre>
<p>Note that if this symbol is undefined then the compiled parser will statically allocate its global state and will be neither reentrant nor thread-safe. Note also that the parser yycontext structure is initialised automatically the first time <em>yyparse</em>() is called; this structure <strong>must</strong> therefore be properly initialised to zero before the first call to <em>yyparse</em>().</p>
  </dd>
  <dt>
    <p><strong>YY_CTX_MEMBERS</strong></p>
  </dt>
  <dd>
    <p>If YY_CTX_LOCAL is defined (see above) then the macro YY_CTX_MEMBERS can be defined to expand to any additional member field declarations that the client would like included in the declaration of the 'yycontext' structure type.  These additional members are otherwise ignored by the generated parser.  The instance of 'yycontext' associated with the currently-active parser is available within actions as the pointer variable <em>yy</em>.</p>
  </dd>
  <dt>
    <p><strong>YY_BUFFER_SIZE</strong></p>
  </dt>
  <dd>
    <p>The initial size of the text buffer, in bytes.  The default is 1024 and the buffer size is doubled whenever required to meet demand during parsing.  An application that typically parses much longer strings could increase this to avoid unnecessary buffer reallocation.</p>
  </dd>
  <dt>
    <p><strong>YY_STACK_SIZE</strong></p>
  </dt>
  <dd>
    <p>The initial size of the variable and action stacks.  The default is 128, which is doubled whenever required to meet demand during parsing. Applications that have deep call stacks with many local variables, or that perform many actions after a single successful match, could increase this to avoid unnecessary buffer reallocation.</p>
  </dd>
  <dt>
    <p><strong>YY_MALLOC(</strong><em>YY</em><strong>,</strong><em></em><strong>SIZE</strong><em>)</em></p>
  </dt>
  <dd>
    <p>The memory allocator for all parser-related storage.  The parameters are the current yycontext structure and the number of bytes to allocate.  The default definition is: malloc(<em>SIZE</em>)</p>
  </dd>
  <dt>
    <p><strong>YY_REALLOC(</strong><em>YY</em><strong>,</strong><em></em><strong>PTR</strong><em>,</em><strong></strong><em>SIZE</em><strong>)</strong></p>
  </dt>
  <dd>
    <p>The memory reallocator for dynamically-grown storage (such as text buffers and variable stacks).  The parameters are the current yycontext structure, the previously-allocated storage, and the number of bytes to which that storage should be grown.  The default definition is: realloc(<em>PTR</em>,<em></em>SIZE<em>)</em></p>
  </dd>
  <dt>
    <p><strong>YY_FREE(</strong><em>YY</em><strong>,</strong><em></em><strong>PTR</strong><em>)</em></p>
  </dt>
  <dd>
    <p>The memory deallocator.  The parameters are the current yycontext structure and the storage to deallocate.  The default definition is: free(<em>PTR</em>)</p>
  </dd>
  <dt>
    <p><strong>YYRELEASE</strong></p>
  </dt>
  <dd>
    <p>The name of the function that releases all resources held by a yycontext structure.  The default value is 'yyrelease'.</p>
  </dd>

</dl>
<p>The following variables can be referred to within actions.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>char *yybuf</strong></p>
  </dt>
  <dd>
    <p>This variable points to the parser's input buffer used to store input text that has not yet been matched.</p>
  </dd>
  <dt>
    <p><strong>int yypos</strong></p>
  </dt>
  <dd>
    <p>This is the offset (in yybuf) of the next character to be matched and consumed.</p>
  </dd>
  <dt>
    <p><strong>char *yytext</strong></p>
  </dt>
  <dd>
    <p>The most recent matched text delimited by '&lt;' and '&gt;' is stored in this variable.</p>
  </dd>
  <dt>
    <p><strong>int yyleng</strong></p>
  </dt>
  <dd>
    <p>This variable indicates the number of characters in 'yytext'.</p>
  </dd>
  <dt>
    <p><strong>yycontext *yy</strong></p>
  </dt>
  <dd>
    <p>This variable points to the instance of 'yycontext' associated with the currently-active parser.</p>
  </dd>

</dl>
<p>Programs that wish to release all the resources associated with a parser can use the following function.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>yyrelease(yycontext</strong><em>*</em><strong>yy</strong><em>)</em></p>
  </dt>
  <dd>
    <p>Returns all parser-allocated storage associated with <em>yy</em> to the system.  The storage will be reallocated on the next call to <em>yyparse</em>().</p>
  </dd>

</dl>
<p>Note that the storage for the yycontext structure itself is never allocated or reclaimed implicitly.  The application must allocate these structures in automatic storage, or use <em>calloc</em>() and <em>free</em>() to manage them explicitly.  The example in the following section demonstrates one approach to resource management.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LEG EXAMPLE: EXTENDING THE PARSER'S CONTEXT</h2>
        <div class="sectioncontent">
<p>The <em>yy</em> variable passed to actions contains the state of the parser plus any additional fields defined by YY_CTX_MEMBERS.  Theses fields can be used to store application-specific information that is global to a particular call of <em>yyparse</em>(). A trivial but complete <em>leg</em> example follows in which the yycontext structure is extended with a <em>count</em> of the number of newline characters seen in the input so far (the grammar otherwise consumes and ignores the entire input).  The caller of <em>yyparse</em>() uses <em>count</em> to print the number of lines of input that were read.</p>
<pre>
    %{
    #define YY_CTX_LOCAL 1
    #define YY_CTX_MEMBERS &#92;
      int count;
    %}

    Char    = ('&#92;n' | '&#92;r&#92;n' | '&#92;r')        { yy-&gt;count++ }
            | .

    %%

    #include &lt;stdio.h&gt;
    #include &lt;string.h&gt;

    int main()
    {
        /* create a local parser context in automatic storage */
        yycontext yy;
        /* the context *must* be initialised to zero before first use*/
        memset(&yy, 0, sizeof(yy));

        while (yyparse(&yy))
            ;
        printf("%d newlines&#92;n", yy.count);

        /* release all resources associated with the context */
        yyrelease(&yy);

        return 0;
    }

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DIAGNOSTICS</h2>
        <div class="sectioncontent">
<p><em>peg</em> and <em>leg</em> warn about the following conditions while converting a grammar into a parser.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>syntax error</strong></p>
  </dt>
  <dd>
    <p>The input grammar was malformed in some way.  The error message will include the text about to be matched (often backed up a huge amount from the actual location of the error) and the line number of the most recently considered character (which is often the real location of the problem).</p>
  </dd>
  <dt>
    <p><strong>rule 'foo' used but not defined</strong></p>
  </dt>
  <dd>
    <p>The grammar referred to a rule named 'foo' but no definition for it was given.  Attempting to use the generated parser will likely result in errors from the linker due to undefined symbols associated with the missing rule.</p>
  </dd>
  <dt>
    <p><strong>rule 'foo' defined but not used</strong></p>
  </dt>
  <dd>
    <p>The grammar defined a rule named 'foo' and then ignored it.  The code associated with the rule is included in the generated parser which will in all other respects be healthy.</p>
  </dd>
  <dt>
    <p><strong>possible infinite left recursion in rule 'foo'</strong></p>
  </dt>
  <dd>
    <p>There exists at least one path through the grammar that leads from the rule 'foo' back to (a recursive invocation of) the same rule without consuming any input.</p>
  </dd>

</dl>
<p>Left recursion, especially that found in standards documents, is often 'direct' and implies trivial repetition.</p>
<pre>
    # (6.7.6)
    direct-abstract-declarator =
        LPAREN abstract-declarator RPAREN
    |   direct-abstract-declarator? LBRACKET assign-expr? RBRACKET
    |   direct-abstract-declarator? LBRACKET STAR RBRACKET
    |   direct-abstract-declarator? LPAREN param-type-list? RPAREN

</pre>
<p>The recursion can easily be eliminated by converting the parts of the pattern following the recursion into a repeatable suffix.</p>
<pre>
    # (6.7.6)
    direct-abstract-declarator =
        direct-abstract-declarator-head?
        direct-abstract-declarator-tail*

    direct-abstract-declarator-head =
        LPAREN abstract-declarator RPAREN

    direct-abstract-declarator-tail =
        LBRACKET assign-expr? RBRACKET
    |   LBRACKET STAR RBRACKET
    |   LPAREN param-type-list? RPAREN

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CAVEATS</h2>
        <div class="sectioncontent">
<p>A parser that accepts empty input will <em>always</em> succeed.  Consider the following example, not atypical of a first attempt to write a PEG-based parser:</p>
<pre>
    Program = Expression*
    Expression = "whatever"
    %%
    int main() {
      while (yyparse())
        puts("success!");
      return 0;
    }

</pre>
<p>This program loops forever, no matter what (if any) input is provided on stdin.  Many fixes are possible, the easiest being to insist that the parser always consumes some non-empty input.  Changing the first line to</p>
<pre>
    Program = Expression+

</pre>
<p>accomplishes this.  If the parser is expected to consume the entire input, then explicitly requiring the end-of-file is also highly recommended:</p>
<pre>
    Program = Expression+ !.

</pre>
<p>This works because the parser will only fail to match ("!" predicate) any character at all ("." expression) when it attempts to read beyond the end of the input.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>You have to type 'man peg' to read the manual page for <a href="../man1/leg.1.html"><strong>leg</strong>(1)</a>.</p><p>The 'yy' and 'YY' prefixes cannot be changed.</p><p>Left recursion is detected in the input grammar but is not handled correctly in the generated parser.</p><p>Diagnostics for errors in the input grammar are obscure and not particularly helpful.</p><p>The operators <strong>!</strong><strong>and</strong> <strong>~</strong> should really be named the other way around.</p><p>Several commonly-used <a href="../man1/lex.1.html"><strong>lex</strong>(1)</a> features (yywrap(), yyin, etc.) are completely absent.</p><p>The generated parser does not contain '#line' directives to direct C compiler errors back to the grammar description when appropriate.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO peg&hellip;</h2>
        <div class="sectioncontent">
<p>D. Val Schorre, <em>META II, a syntax-oriented compiler writing language,</em> 19th ACM National Conference, 1964, pp.&nbsp;41.301--41.311.  Describes a self-implementing parser generator for analytic grammars with no backtracking.</p><p>Alexander Birman, <em>The TMG Recognition Schema,</em> Ph.D. dissertation, Princeton, 1970.  A mathematical treatment of the power and complexity of recursive-descent parsing with backtracking.</p><p>Bryan Ford, <em>Parsing Expression Grammars: A Recognition-Based Syntactic Foundation,</em> ACM SIGPLAN Symposium on Principles of Programming Languages, 2004. Defines PEGs and analyses them in relation to context-free and regular grammars.  Introduces the syntax adopted in <em>peg</em>.</p><p>The standard Unix utilities <a href="../man1/lex.1.html"><strong>lex</strong>(1)</a> and <strong>yacc</strong>(1) which influenced the syntax and features of <em>leg</em>.</p><p>The source code for <em>peg</em> and <em>leg</em> whose grammar parsers are written using themselves.</p><p>The latest version of this software and documentation:</p>
<pre>
    http://piumarta.com/software/peg

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p><em>peg</em>, <em>leg</em> and this manual page were written by Ian Piumarta (first-name at last-name dot com) while investigating the viability of regular and parsing-expression grammars for efficiently extracting type and signature information from C header files.</p><p>Please send bug reports and suggestions for improvements to the author at the above address.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="peel.1.html"><span aria-hidden="true">&larr;</span> peel.1: Cd ripper</a></li>
   <li class="next"><a href="pegasus-analyzer.1.html">pegasus-analyzer.1: Debugs a workflow. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

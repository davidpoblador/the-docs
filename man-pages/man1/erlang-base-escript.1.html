<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>escript: Erlang scripting support</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Erlang scripting support">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="escript (1) manual">
  <meta name="twitter:description" content="Erlang scripting support">
  <meta name="twitter:image" content="https://www.carta.tech/images/erlang-base-escript-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/erlang-base-escript.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="escript (1) manual" />
  <meta property="og:description" content="Erlang scripting support" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/erlang-base-escript-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">escript<small> (1)</small></h1>
        <p class="lead">Erlang scripting support</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/escript.1.html">
      <span itemprop="name">escript: Erlang scripting support</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/erlang-base/">
      <span itemprop="name">erlang-base</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/escript.1.html">
      <span itemprop="name">escript: Erlang scripting support</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><em>escript</em> provides support for running short Erlang programs without having to compile them first and an easy way to retrieve the command line arguments.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">
<p><strong></strong> script-name script-arg1 script-arg2...</p><p><strong></strong> escript escript-flags script-name script-arg1 script-arg2...</p><p><em>escript</em> runs a script written in Erlang.</p><p>Here follows an example.</p>
<pre>
$ chmod u+x factorial
$ cat factorial
#!/usr/bin/env escript
%% -*- erlang -*-
%%! -smp enable -sname factorial -mnesia debug verbose
main([String]) -&gt;
    try
        N = list_to_integer(String),
        F = fac(N),
        io:format("factorial ~w = ~w&#92;n", [N,F])
    catch
        _:_ -&gt;
            usage()
    end;
main(_) -&gt;
    usage().

usage() -&gt;
    io:format("usage: factorial integer&#92;n"),
    <strong>halt</strong>(1).

<strong>fac</strong>(0) -&gt; 1;
fac(N) -&gt; N * fac(N-1).
$ ./factorial 5
factorial 5 = 120
$ ./factorial
usage: factorial integer
$ ./factorial five
usage: factorial integer

</pre>
<p>The header of the Erlang script in the example differs from a normal Erlang module. The first line is intended to be the interpreter line, which invokes <em>escript</em>. However if you invoke the <em>escript</em> like this</p>
<pre>
$ escript factorial 5
</pre>
<p>the contents of the first line does not matter, but it cannot contain Erlang code as it will be ignored.</p><p>The second line in the example, contains an optional directive to the <em>Emacs</em> editor which causes it to enter the major mode for editing Erlang source files. If the directive is present it must be located on the second line.</p><p>If there is a comment selecting the <strong>encoding</strong> it can be located on the second line.</p><p><strong></strong> Note:</p><p>The encoding specified by the above mentioned comment applies to the script itself. The encoding of the I/O-server, however, has to be set explicitly like this:</p>
<pre>
io:setopts([{encoding, unicode}])
</pre>
<p>The default encoding of the I/O-server for <em>standard_io</em> is <em>latin1</em> since the script runs in a non-interactive terminal (see <strong> Using Unicode in Erlang</strong>).</p><p>On the third line (or second line depending on the presence of the Emacs directive), it is possible to give arguments to the emulator, such as</p>
<pre>
%%! -smp enable -sname factorial -mnesia debug verbose
</pre>
<p>Such an argument line must start with <em>%%!</em> and the rest of the line will interpreted as arguments to the emulator.</p><p>If you know the location of the <em>escript</em> executable, the first line can directly give the path to <em>escript</em>. For instance:</p>
<pre>
#!/usr/local/bin/escript
</pre>
<p>As any other kind of scripts, Erlang scripts will not work on Unix platforms if the execution bit for the script file is not set. (Use <em>chmod +x script-name</em> to turn on the execution bit.)</p><p>The rest of the Erlang script file may either contain Erlang <em>source code</em>, an <em>inlined beam file</em> or an <em>inlined archive file</em>.</p><p>An Erlang script file must always contain the function <em>main/1</em>. When the script is run, the <em>main/1</em> function will be called with a list of strings representing the arguments given to the script (not changed or interpreted in any way).</p><p>If the <em>main/1</em> function in the script returns successfully, the exit status for the script will be 0. If an exception is generated during execution, a short message will be printed and the script terminated with exit status 127.</p><p>To return your own non-zero exit code, call <em>halt(ExitCode)</em>; for instance:</p>
<pre>
<strong>halt</strong>(1).
</pre>
<p>Call <strong>escript:script_name()</strong> from your to script to retrieve the pathname of the script (the pathname is usually, but not always, absolute).</p><p>If the file contains source code (as in the example above), it will be processed by the preprocessor <em>epp</em>. This means that you for example may use pre-defined macros (such as <em>?MODULE</em>) as well as include directives like the <em>-include_lib</em> directive. For instance, use</p>
<pre>
-include_lib("kernel/include/file.hrl").
</pre>
<p>to include the record definitions for the records used by the <em>file:read_link_info/1</em> function. You can also select encoding by including a encoding comment here, but if there is a valid encoding comment on the second line it takes precedence.</p><p>The script will be checked for syntactic and semantic correctness before being run. If there are warnings (such as unused variables), they will be printed and the script will still be run. If there are errors, they will be printed and the script will not be run and its exit status will be 127.</p><p>Both the module declaration and the export declaration of the <em>main/1</em> function are optional.</p><p>By default, the script will be interpreted. You can force it to be compiled by including the following line somewhere in the script file:</p>
<pre>
-mode(compile).
</pre>
<p>Execution of interpreted code is slower than compiled code. If much of the execution takes place in interpreted code it may be worthwhile to compile it, even though the compilation itself will take a little while. It is also possible to supply <em>native</em> instead of <em>compile</em>, this will compile the script using the native flag, again depending on the characteristics of the escript this could or could not be worth while.</p><p>As mentioned earlier, it is possible to have a script which contains precompiled <em>beam</em> code. In a precompiled script, the interpretation of the script header is exactly the same as in a script containing source code. That means that you can make a <em>beam</em> file executable by prepending the file with the lines starting with <em>#!</em> and <em>%%!</em> mentioned above. In a precompiled script, the function <em>main/1</em> must be exported.</p><p>As yet another option it is possible to have an entire Erlang archive in the script. In a archive script, the interpretation of the script header is exactly the same as in a script containing source code. That means that you can make an archive file executable by prepending the file with the lines starting with <em>#!</em> and <em>%%!</em> mentioned above. In an archive script, the function <em>main/1</em> must be exported. By default the <em>main/1</em> function in the module with the same name as the basename of the <em>escript</em> file will be invoked. This behavior can be overridden by setting the flag <em>-escript main Module</em> as one of the emulator flags. The <em>Module</em> must be the name of a module which has an exported <em>main/1</em> function. See <strong>code(3erl)</strong> for more information about archives and code loading.</p><p>In many cases it is very convenient to have a header in the escript, especially on Unix platforms. But the header is in fact optional. This means that you directly can "execute" an Erlang module, beam file or archive file without adding any header to them. But then you have to invoke the script like this:</p>
<pre>
$ escript factorial.erl 5
factorial 5 = 120
$ escript factorial.beam 5
factorial 5 = 120
$ escript factorial.zip 5
factorial 5 = 120

</pre>
<p><strong></strong> escript:create(FileOrBin, Sections) -&gt; ok | {ok, binary()} | {error, term()}</p><p>Types:</p><p>FileOrBin = filename() | 'binary'</p><p>Sections = [Header] Body | Body</p><p>Header = shebang | {shebang, Shebang} | comment | {comment, Comment} | {emu_args, EmuArgs}</p><p>Shebang = string() | 'default' | 'undefined'</p><p>Comment = string() | 'default' | 'undefined'</p><p>EmuArgs = string() | 'undefined'</p><p>Body = {source, SourceCode} | {beam, BeamCode} | {archive, ZipArchive} | {archive, ZipFiles, ZipOptions}</p><p>SourceCode = BeamCode = file:filename() | binary()</p><p>ZipArchive = <strong>zip:filename()</strong> | binary()</p><p>ZipFiles = [ZipFile]</p><p>ZipFile = file:filename() | {file:filename(), binary()} | {file:filename(), binary(), file:file_info()}</p><p>ZipOptions = [<strong>zip:create_option()</strong>]</p><p>The <em>create/2</em> function creates an escript from a list of sections. The sections can be given in any order. An escript begins with an optional <em>Header</em> followed by a mandatory <em>Body</em>. If the header is present, it does always begin with a <em>shebang</em>, possibly followed by a <em>comment</em> and <em>emu_args</em>. The <em>shebang</em> defaults to <em>"/usr/bin/env escript"</em>. The comment defaults to <em>"This is an -*- erlang -*- file"</em>. The created escript can either be returned as a binary or written to file.</p><p>As an example of how the function can be used, we create an interpreted escript which uses <em>emu_args</em> to set some emulator flag. In this case it happens to disable the smp_support. We do also extract the different sections from the newly created script:</p>
<pre>
&gt; Source = "%% Demo&#92;nmain(_Args) -&gt;&#92;n io:format(erlang:system_info(smp_support)).&#92;n".
"%% Demo&#92;nmain(_Args) -&gt;&#92;n    io:format(erlang:system_info(smp_support)).&#92;n"
&gt; io:format("~s&#92;n", [Source]).
%% Demo
main(_Args) -&gt;
    io:format(erlang:system_info(smp_support)).

ok
&gt; {ok, Bin} = escript:create(binary, [shebang, comment, {emu_args, "-smp disable"}, {source, list_to_binary(Source)}]).
{ok,&lt;&lt;"#!/usr/bin/env escript&#92;n%% This is an -*- erlang -*- file&#92;n%%!-smp disabl"...&gt;&gt;}
&gt; file:write_file("demo.escript", Bin).
ok
&gt; os:cmd("escript demo.escript").
"false"
&gt; escript:extract("demo.escript", []).
{ok,[{shebang,default}, {comment,default}, {emu_args,"-smp disable"},
     {source,&lt;&lt;"%% Demo&#92;nmain(_Args) -&gt;&#92;n    io:format(erlang:system_info(smp_su"...&gt;&gt;}]}

</pre>
<p>An escript without header can be created like this:</p>
<pre>
&gt; file:write_file("demo.erl", ["%% demo.erl&#92;n-module(demo).&#92;n-export([main/1]).&#92;n&#92;n", Source]).
ok
&gt; {ok, _, BeamCode} = compile:file("demo.erl", [binary, debug_info]).
{ok,demo,
    &lt;&lt;70,79,82,49,0,0,2,208,66,69,65,77,65,116,111,109,0,0,0,
      79,0,0,0,9,4,100,...&gt;&gt;}
&gt; escript:create("demo.beam", [{beam, BeamCode}]).
ok
&gt; escript:extract("demo.beam", []).
{ok,[{shebang,undefined}, {comment,undefined}, {emu_args,undefined},
     {beam,&lt;&lt;70,79,82,49,0,0,3,68,66,69,65,77,65,116,
             111,109,0,0,0,83,0,0,0,9,...&gt;&gt;}]}
&gt; os:cmd("escript demo.beam").
"true"

</pre>
<p>Here we create an archive script containing both Erlang code as well as beam code. Then we iterate over all files in the archive and collect their contents and some info about them.</p>
<pre>
&gt; {ok, SourceCode} = file:read_file("demo.erl").
{ok,&lt;&lt;"%% demo.erl&#92;n-module(demo).&#92;n-export([main/1]).&#92;n&#92;n%% Demo&#92;nmain(_Arg"...&gt;&gt;}
&gt; escript:create("demo.escript", [shebang, {archive, [{"demo.erl", SourceCode}, {"demo.beam", BeamCode}], []}]).
ok
&gt; {ok, [{shebang,default}, {comment,undefined}, {emu_args,undefined}, {archive, ArchiveBin}]} = escript:extract("demo.escript", []).
{ok,[{shebang,default}, {comment,undefined}, {emu_args,undefined},
     {{archive,&lt;&lt;80,75,3,4,20,0,0,0,8,0,118,7,98,60,105,
                152,61,93,107,0,0,0,118,0,...&gt;&gt;}]}
&gt; file:write_file("demo.zip", ArchiveBin).
ok
&gt; zip:foldl(fun(N, I, B, A) -&gt; [{N, I(), B()} | A] end, [], "demo.zip").
{ok,[{"demo.beam",
      {file_info,748,regular,read_write,
                 {{2010,3,2},{0,59,22}},
                 {{2010,3,2},{0,59,22}},
                 {{2010,3,2},{0,59,22}},
                 54,1,0,0,0,0,0},
      &lt;&lt;70,79,82,49,0,0,2,228,66,69,65,77,65,116,111,109,0,0,0,
        83,0,0,...&gt;&gt;},
     {"demo.erl",
      {file_info,118,regular,read_write,
                 {{2010,3,2},{0,59,22}},
                 {{2010,3,2},{0,59,22}},
                 {{2010,3,2},{0,59,22}},
                 54,1,0,0,0,0,0},
      &lt;&lt;"%% demo.erl&#92;n-module(demo).&#92;n-export([main/1]).&#92;n&#92;n%% Demo&#92;nmain(_Arg"...&gt;&gt;}]}
</pre>
<p><strong></strong> escript:extract(File, Options) -&gt; {ok, Sections} | {error, term()}</p><p>Types:</p><p>File = filename()</p><p>Options = [] | [compile_source]</p><p>Sections = Headers Body</p><p>Headers = {shebang, Shebang} {comment, Comment} {emu_args, EmuArgs}</p><p>Shebang = string() | 'default' | 'undefined'</p><p>Comment = string() | 'default' | 'undefined'</p><p>EmuArgs = string() | 'undefined'</p><p>Body = {source, SourceCode} | {source, BeamCode} | {beam, BeamCode} | {archive, ZipArchive}</p><p>SourceCode = BeamCode = ZipArchive = binary()</p><p>The <em>extract/2</em> function parses an escript and extracts its sections. This is the reverse of <em>create/2</em>.</p><p>All sections are returned even if they do not exist in the escript. If a particular section happens to have the same value as the default value, the extracted value is set to the atom <em>default</em>. If a section is missing, the extracted value is set to the atom <em>undefined</em>.</p><p>The <em>compile_source</em> option only affects the result if the escript contains <em>source</em> code. In that case the Erlang code is automatically compiled and <em>{source, BeamCode}</em> is returned instead of <em>{source, SourceCode}</em>.</p>
<pre>
&gt; escript:create("demo.escript", [shebang, {archive, [{"demo.erl", SourceCode}, {"demo.beam", BeamCode}], []}]).
ok
&gt; {ok, [{shebang,default}, {comment,undefined}, {emu_args,undefined}, {archive, ArchiveBin}]} = escript:extract("demo.escript", []).
{ok,[{{archive,&lt;&lt;80,75,3,4,20,0,0,0,8,0,118,7,98,60,105,
                152,61,93,107,0,0,0,118,0,...&gt;&gt;}
     {emu_args,undefined}]}

</pre>
<p><strong></strong> escript:script_name() -&gt; File</p><p>Types:</p><p>File = filename()</p><p>The <em>script_name/0</em> function returns the name of the escript being executed. If the function is invoked outside the context of an escript, the behavior is undefined.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONS ACCEPTED BY ESCRIPT</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>-c: Compile the escript regardless of the value of the mode attribute.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>-d: Debug the escript. Starts the debugger, loads the module containing the <em>main/1</em> function into the debugger, sets a breakpoint in <em>main/1</em> and invokes <em>main/1</em>. If the module is precompiled, it must be explicitly compiled with the <em>debug_info</em> option.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>-i: Interpret the escript regardless of the value of the mode attribute.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>-s: Only perform a syntactic and semantic check of the script file. Warnings and errors (if any) are written to the standard output, but the script will not be run. The exit status will be 0 if there were no errors, and 127 otherwise.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>-n: Compile the escript using the +native flag.</p>
  </dd>

</dl>

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="escputil.1.html"><span aria-hidden="true">&larr;</span> escputil.1: Maintain epson stylus inkjet printers</a></li>
   <li class="next"><a href="erlang-base-hipe-escript.1.html">escript.1: Erlang scripting support <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

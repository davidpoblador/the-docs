<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>git-annex: Manage files with git, without checking their contents in</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Manage files with git, without checking their contents in">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="git-annex (1) manual">
  <meta name="twitter:description" content="Manage files with git, without checking their contents in">
  <meta name="twitter:image" content="https://www.carta.tech/images/git-annex-git-annex-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/git-annex.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="git-annex (1) manual" />
  <meta property="og:description" content="Manage files with git, without checking their contents in" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/git-annex-git-annex-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">git-annex<small> (1)</small></h1>
        <p class="lead">Manage files with git, without checking their contents in</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/git-annex.1.html">
      <span itemprop="name">git-annex: Manage files with git, without checking their contents in</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/git-annex/">
      <span itemprop="name">git-annex</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/git-annex.1.html">
      <span itemprop="name">git-annex: Manage files with git, without checking their contents in</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>git annex command [params ...]</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>git-annex allows managing files with git, without checking the file contents into git. While that may seem paradoxical, it is useful when dealing with files larger than git can currently easily handle, whether due to limitations in memory, checksumming time, or disk space.</p><p>Even without file content tracking, being able to manage files with git, move files around and delete files with versioned directory trees, and use branches and distributed clones, are all very handy reasons to use git. And annexed files can co-exist in the same git repository with regularly versioned files, which is convenient for maintaining documents, Makefiles, etc that are associated with annexed files but that benefit from full revision control.</p><p>When a file is annexed, its content is moved into a key-value store, and a symlink is made that points to the content. These symlinks are checked into git and versioned like regular files. You can move them around, delete them, and so on. Pushing to another git repository will make git-annex there aware of the annexed file, and it can be used to retrieve its content from the key-value store.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p> # git annex get video/hackity_hack_and_kaxxt.mov  get video/_why_hackity_hack_and_kaxxt.mov (not available)</p>
<pre>
   I was unable to access these remotes: server
   Try making some of these repositories available:
   	5863d8c0-d9a9-11df-adb2-af51e6559a49  -- my home file server
    	58d84e8a-d9ae-11df-a1aa-ab9aa8c00826  -- portable USB drive
    	ca20064c-dbb5-11df-b2fe-002170d25c55  -- backup SATA drive
</pre>
<p> failed  # sudo mount /media/usb  # git remote add usbdrive /media/usb  # git annex get video/hackity_hack_and_kaxxt.mov  get video/hackity_hack_and_kaxxt.mov (from usbdrive...) ok</p><p> # git annex add iso  add iso/Debian_5.0.iso ok</p><p> # git annex drop iso/Debian_4.0.iso  drop iso/Debian_4.0.iso ok</p><p> # git annex move iso --to=usbdrive  move iso/Debian_5.0.iso (moving to usbdrive...) ok</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COMMONLY USED COMMANDS</h2>
        <div class="sectioncontent">
<p>Like many git commands, git-annex can be passed a path that is either a file or a directory. In the latter case it acts on all relevant files in the directory. When no path is specified, most git-annex commands default to acting on all relevant files in the current directory (and subdirectories).</p>
<dl class='dl-vertical'>
  <dt>
    <strong>add [path ...]</strong>
  </dt>
  <dd>
    <p>Adds files in the path to the annex. If no path is specified, adds files from the current directory and below.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Files that are already checked into git, or that git has been configured to ignore will be silently skipped. (Use <strong>--force</strong> to add ignored files.)</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Dotfiles are skipped unless explicitly listed, or the --include-dotfiles option is used.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>get [path ...]</strong>
  </dt>
  <dd>
    <p>Makes the content of annexed files available in this repository. This will involve copying them from another repository, or downloading them, or transferring them from some kind of key-value store.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Normally git-annex will choose which repository to copy the content from, but you can override this using the <strong>--from</strong> option.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Rather than specifying a filename, the <strong>--all</strong> option can be used to get all available versions of all files, or the --key=KEY option can be used to get a specified key.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>drop [path ...]</strong>
  </dt>
  <dd>
    <p>Drops the content of annexed files from this repository.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>git-annex will refuse to drop content if it cannot verify it is safe to do so. This can be overridden with the <strong>--force</strong> switch.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>To drop content from a remote, specify <strong>--from</strong>.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>move [path ...]</strong>
  </dt>
  <dd>
    <p>When used with the <strong>--from</strong> option, moves the content of annexed files from the specified repository to the current one.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>When used with the <strong>--to</strong> option, moves the content of annexed files from the current repository to the specified one.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>copy [path ...]</strong>
  </dt>
  <dd>
    <p>When used with the <strong>--from</strong> option, copies the content of annexed files from the specified repository to the current one.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>When used with the <strong>--to</strong> option, copies the content of annexed files from the current repository to the specified one.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>To avoid contacting the remote to check if it has every file when copying --to the repository, specify <strong>--fast</strong></p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>To force checking the remote for every file when copying --from the repository, specify <strong>--force</strong>.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>status [path ...]</strong>
  </dt>
  <dd>
    <p>Similar to <strong>git status --short</strong>, displays the status of the files in the working tree. Shows files that are not checked into git, files that have been deleted, and files that have been modified. Particularly useful in direct mode.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>unlock [path ...]</strong>
  </dt>
  <dd>
    <p>Normally, the content of annexed files is protected from being changed. Unlocking an annexed file allows it to be modified. This replaces the symlink for each specified file with a copy of the file's content. You can then modify it and <strong>git annex add</strong> (or <strong>git commit</strong>) to inject it back into the annex.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>edit [path ...]</strong>
  </dt>
  <dd>
    <p>This is an alias for the unlock command. May be easier to remember, if you think of this as allowing you to edit an annexed file.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>lock [path ...]</strong>
  </dt>
  <dd>
    <p>Use this to undo an unlock command if you don't want to modify the files, or have made modifications you want to discard.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>sync [remote ...]</strong>
  </dt>
  <dd>
    <p>Use this command when you want to synchronize the local repository with one or more of its remotes. You can specify the remotes to sync with by name; the default is to sync with all remotes. Or specify <strong>--fast</strong> to sync with the remotes with the lowest annex-cost value.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>The sync process involves first committing any local changes to files that have previously been added to the repository, then fetching and merging the <strong>synced/master</strong> and the <strong>git-annex</strong> branch from the remote repositories, and finally pushing the changes back to those branches on the remote repositories. You can use standard git commands to do each of those steps by hand, or if you don't want to worry about the details, you can use sync.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Merge conflicts are automatically handled by sync. When two conflicting versions of a file have been committed, both will be added to the tree, under different filenames. For example, file "foo" would be replaced with "foo.somekey" and "foo.otherkey".</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Note that syncing with a remote will not update the remote's working tree with changes made to the local repository. However, those changes are pushed to the remote, so they can be merged into its working tree by running "git annex sync" on the remote.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>With the <strong>--content</strong> option, the contents of annexed files in the work tree will also be uploaded and downloaded from remotes. By default, this tries to get each annexed file that the local repository does not yet have, and then copies each file to every remote that it is syncing with. This behavior can be overridden by configuring the preferred content of a repository. See see PREFERRED CONTENT below.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>merge</strong>
  </dt>
  <dd>
    <p>This performs the same merging (and merge conflict resolution) that is done by the sync command, but without pushing or pulling any data.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>One way to use this is to put <strong>git annex merge</strong> into a repository's post-receive hook. Then any syncs to the repository will update its working copy automatically.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>mirror [path ...]</strong>
  </dt>
  <dd>
    <p>This causes a destination repository to mirror a source repository.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>To use the local repository as the source repository, specify mirror <strong>--to</strong> remote.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>To use a remote as the source repository, specify mirror <strong>--from</strong> remote.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Each specified file in the source repository is mirrored to the destination repository. If a file's content is present in the source repository, it is copied to the destination repository. If a file's content is not present in the source repository, it will be dropped from the destination repository when the numcopies setting allows.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Note that mirror does not sync the git repository, but only the file contents.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Also, --all may be specified to mirror all objects stored in the git annex, not only objects used by currently existing files. However, this bypasses checking the .gitattributes annex.numcopies setting when dropping files.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>addurl [url ...]</strong>
  </dt>
  <dd>
    <p>Downloads each url to its own file, which is added to the annex.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>To avoid immediately downloading the url, specify <strong>--fast</strong>.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>To avoid storing the size of the url's content, and accept whatever is there at a future point, specify <strong>--relaxed</strong>. (Implies <strong>--fast</strong>.)</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Normally the filename is based on the full url, so will look like "www.example.com_dir_subdir_bigfile". For a shorter filename, specify <strong>--pathdepth=N</strong>. For example, <strong>--pathdepth=1</strong> will use "dir/subdir/bigfile", while <strong>--pathdepth=3</strong> will use "bigfile". It can also be negative; <strong>--pathdepth=-2</strong> will use the last two parts of the url.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Or, to directly specify what file the url is added to, specify <strong>--file</strong>. This changes the behavior; now all the specified urls are recorded as alternate locations from which the file can be downloaded. In this mode, addurl can be used both to add new files, or to add urls to existing files.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>When quvi is installed, urls are automatically tested to see if they point to a video hosting site, and the video is downloaded instead.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>rmurl file url</strong>
  </dt>
  <dd>
    <p>Record that the file is no longer available at the url.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>import [path ...]</strong>
  </dt>
  <dd>
    <p>Moves files from somewhere outside the git working copy, and adds them to the annex. Individual files to import can be specified. If a directory is specified, the entire directory is imported.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p> git annex import /media/camera/DCIM/*</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>By default, importing two files with the same contents from two different locations will result in both files being added to the repository. (With all checksumming backends, including the default SHA256E, only one copy of the data will be stored.)</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>To not delete files from the import location, use the <strong>--duplicate</strong> option. This could allow importing the same files repeatedly to different locations in a repository. More likely, it could be used to import the same files to a number of different branches or separate git repositories.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>To only import files whose content has not been seen before by git-annex, use the <strong>--deduplicate</strong> option. Duplicate files will be deleted from the import location.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>To only import files whose content has not been seen before by git-annex, but avoid deleting duplicate files, use the <strong>--skip-duplicates</strong> option.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>The <strong>--clean-duplicates</strong> option does not import any new files, but any files found in the import location that are duplicates of content in the annex are deleted.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>(Note that using <strong>--deduplicate</strong> or <strong>--clean-duplicates</strong> with the WORM backend does not look at file content, but filename and mtime.)</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>importfeed [url ...]</strong>
  </dt>
  <dd>
    <p>Imports the contents of podcast feeds. Only downloads files whose urls have not already been added to the repository before, so you can delete, rename, etc the resulting files and repeated runs won't duplicate them. (Use <strong>--force</strong> to force downloading urls it's seen before.)</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Use <strong>--template</strong> to control where the files are stored. The default template is '${feedtitle}/${itemtitle}${extension}' (Other available variables: feedauthor, itemauthor, itemsummary, itemdescription, itemrights, itemid, itempubdate, title, author)</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>The <strong>--relaxed</strong> and <strong>--fast</strong> options behave the same as they do in addurl.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>When quvi is installed, links in the feed are tested to see if they are on a video hosting site, and the video is downloaded. This allows importing e.g., youtube playlists.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>watch</strong>
  </dt>
  <dd>
    <p>Watches for changes to files in the current directory and its subdirectories, and takes care of automatically adding new files, as well as dealing with deleted, copied, and moved files. With this running as a daemon in the background, you no longer need to manually run git commands when manipulating your files.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>By default, all files in the directory will be added to the repository. (Including dotfiles.) To block some files from being added, use <strong>.gitignore</strong> files.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>By default, all files that are added are added to the annex, the same as when you run <strong>git annex add</strong>. If you configure annex.largefiles, files that it does not match will instead be added with <strong>git add</strong>.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>To not daemonize, run with <strong>--foreground</strong> ; to stop a running daemon, run with <strong>--stop</strong>.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>assistant</strong>
  </dt>
  <dd>
    <p>Like watch, but also automatically syncs changes to other remotes. Typically started at boot, or when you log in.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>With the <strong>--autostart</strong> option, the assistant is started in any repositories it has created. These are listed in <strong>~/.config/git-annex/autostart</strong>.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>webapp</strong>
  </dt>
  <dd>
    <p>Opens a web app, that allows easy setup of a git-annex repository, and control of the git-annex assistant. If the assistant is not already running, it will be started.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>By default, the webapp can only be accessed from localhost, and running it opens a browser window.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>To use the webapp on a remote computer, use the <strong>--listen=address</strong> option to specify the address the web server should listen on (or set annex.listen). This disables running a local web browser, and outputs the url you can use to open the webapp.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>When using the webapp on a remote computer, you'll almost certainly want to enable HTTPS. The webapp will use HTTPS if it finds a .git/annex/privkey.pem and .git/annex/certificate.pem. Here's one way to generate those files, using a self-signed certificate:</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>openssl genrsa -out .git/annex/privkey.pem 4096 openssl req -new -x509 -key .git/annex/privkey.pem &gt; .git/annex/certificate.pem</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REPOSITORY SETUP COMMANDS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <strong>init [description]</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Until a repository (or one of its remotes) has been initialized, git-annex will refuse to operate on it, to avoid accidentally using it in a repository that was not intended to have an annex.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>It's useful, but not mandatory, to initialize each new clone of a repository with its own description. If you don't provide one, one will be generated using the username, hostname and the path.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>describe repository description</strong>
  </dt>
  <dd>
    <p>Changes the description of a repository.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>The repository to describe can be specified by git remote name or by uuid. To change the description of the current repository, use "here".</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>initremote name [param=value ...]</strong>
  </dt>
  <dd>
    <p>Creates a new special remote, and adds it to <strong>.git/config</strong>.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>The remote's configuration is specified by the parameters. Different types of special remotes need different configuration values. The command will prompt for parameters as needed.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>All special remotes support encryption. You can either specify <strong>encryption=none</strong> to disable encryption, or specify <strong>encryption=hybrid keyid=$keyid ...</strong> to specify a GPG key id (or an email address associated with a key).</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>There are actually three schemes that can be used for management of the encryption keys. When using the encryption=hybrid scheme, additional GPG keys can be given access to the encrypted special remote easily (without re-encrypting everything). When using encryption=shared, a shared key is generated and stored in the git repository, allowing anyone who can clone the git repository to access it. Finally, when using encryption=pubkey, content in the special remote is directly encrypted to the specified GPG keys, and additional ones cannot easily be given access.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Note that with encryption enabled, a cryptographic key is created. This requires sufficient entropy. If initremote seems to hang or take a long time while generating the key, you may want to Ctrl-c it and re-run with <strong>--fast</strong>, which causes it to use a lower-quality source of randomness.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Example Amazon S3 remote:</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p> git annex initremote mys3 type=S3 encryption=hybrid keyid=me@example.com datacenter=EU</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>enableremote name [param=value ...]</strong>
  </dt>
  <dd>
    <p>Enables use of an existing special remote in the current repository, which may be a different repository than the one in which it was originally created with the initremote command.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>The name of the remote is the same name used when originally creating that remote with "initremote". Run "git annex enableremote" without any name to get a list of special remote names.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Some special remotes may need parameters to be specified every time. For example, the directory special remote requires a directory= parameter.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>This command can also be used to modify the configuration of an existing special remote, by specifying new values for parameters that were originally set when using initremote. (However, some settings such as the as the encryption scheme cannot be changed once a special remote has been created.)</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>The GPG keys that an encrypted special remote is encrypted with can be changed using the keyid+= and keyid-= parameters. These respectively add and remove keys from the list. However, note that removing a key does NOT necessarily prevent the key's owner from accessing data in the encrypted special remote (which is by design impossible, short of deleting the remote).</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>One use-case of keyid-= is to replace a revoked key with a new key:</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p> git annex enableremote mys3 keyid-=revokedkey keyid+=newkey</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Also, note that for encrypted special remotes using plain public-key encryption (encryption=pubkey), adding or removing a key has NO effect on files that have already been copied to the remote. Hence using keyid+= and keyid-= with such remotes should be used with care, and make little sense except in cases like the revoked key example above.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>numcopies [N]</strong>
  </dt>
  <dd>
    <p>Tells git-annex how many copies it should preserve of files, over all repositories. The default is 1.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Run without a number to get the current value.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>When git-annex is asked to drop a file, it first verifies that the required number of copies can be satisfied among all the other repositories that have a copy of the file.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>This can be overridden on a per-file basis by the annex.numcopies setting in .gitattributes files.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>trust [repository ...]</strong>
  </dt>
  <dd>
    <p>Records that a repository is trusted to not unexpectedly lose content. Use with care.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>To trust the current repository, use "here".</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>untrust [repository ...]</strong>
  </dt>
  <dd>
    <p>Records that a repository is not trusted and could lose content at any time.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>semitrust [repository ...]</strong>
  </dt>
  <dd>
    <p>Returns a repository to the default semi trusted state.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>dead [repository ...]</strong>
  </dt>
  <dd>
    <p>Indicates that the repository has been irretrievably lost. (To undo, use semitrust.)</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>group repository groupname</strong>
  </dt>
  <dd>
    <p>Adds a repository to a group, such as "archival", "enduser", or "transfer". The groupname must be a single word.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Omit the groupname to show the current groups that a repository is in.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>ungroup repository groupname</strong>
  </dt>
  <dd>
    <p>Removes a repository from a group.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>wanted repository [expression]</strong>
  </dt>
  <dd>
    <p>When run with an expression, configures the content that is preferred to be held in the archive. See PREFERRED CONTENT below.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>For example:</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p> git annex wanted . "include=*.mp3 or include=*.ogg"</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Without an expression, displays the current preferred content setting of the repository.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>schedule repository [expression]</strong>
  </dt>
  <dd>
    <p>When run with an expression, configures scheduled jobs to run at a particular time. This can be used to make the assistant periodically run incremental fscks. See SCHEDULED JOBS below.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>vicfg</strong>
  </dt>
  <dd>
    <p>Opens EDITOR on a temp file containing most of the above configuration settings, as well as a few others, and when it exits, stores any changes made back to the git-annex branch.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>direct</strong>
  </dt>
  <dd>
    <p>Switches a repository to use direct mode, where rather than symlinks to files, the files are directly present in the repository.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>As part of the switch to direct mode, any changed files will be committed.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Note that git commands that operate on the work tree are often unsafe to use in direct mode repositories, and can result in data loss or other bad behavior.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>indirect</strong>
  </dt>
  <dd>
    <p>Switches a repository back from direct mode to the default, indirect mode.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>As part of the switch from direct mode, any changed files will be committed.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REPOSITORY MAINTENANCE COMMANDS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <strong>fsck [path ...]</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>With no parameters, this command checks the whole annex for consistency, and warns about or fixes any problems found. This is a good complement to <strong>git fsck</strong>.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>With parameters, only the specified files are checked.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>To check a remote to fsck, specify <strong>--from</strong>.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>To avoid expensive checksum calculations (and expensive transfers when fscking a remote), specify <strong>--fast</strong>.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>To start a new incremental fsck, use the <strong>--incremental</strong> option. Then the next time you fsck, you can instead use the <strong>--more</strong> option to skip over files that have already been checked, and continue where it left off.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>The <strong>--incremental-schedule</strong> option makes a new incremental fsck be started a configurable time after the last incremental fsck was started. Once the current incremental fsck has completely finished, it causes a new one to start.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Maybe you'd like to run a fsck for 5 hours at night, picking up each night where it left off. You'd like this to continue until all files have been fscked. And once it's done, you'd like a new fsck pass to start, but no more often than once a month. Then put this in a nightly cron job:</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p> git annex fsck --incremental-schedule 30d --time-limit 5h</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>To verify data integrity only while disregarding required number of copies, use <strong>--numcopies=1</strong>.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>unused</strong>
  </dt>
  <dd>
    <p>Checks the annex for data that does not correspond to any files present in any tag or branch, and prints a numbered list of the data.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>To only show unused temp and bad files, specify <strong>--fast</strong>.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>To check for annexed data on a remote, specify <strong>--from</strong>.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>After running this command, you can use the <strong>--unused</strong> option to operate on all the unused data that was found. For example, to move all unused data to origin:</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p> git annex unused; git annex move --unused --to origin</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>dropunused [number|range ...]</strong>
  </dt>
  <dd>
    <p>Drops the data corresponding to the numbers, as listed by the last <strong>git annex unused</strong></p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>You can also specify ranges of numbers, such as "1-1000". Or, specify "all" to drop all unused data.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>To drop the data from a remote, specify <strong>--from.</strong></p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>addunused [number|range ...]</strong>
  </dt>
  <dd>
    <p>Adds back files for the content corresponding to the numbers or ranges, as listed by the last <strong>git annex unused</strong>. The files will have names starting with "unused."</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>fix [path ...]</strong>
  </dt>
  <dd>
    <p>Fixes up symlinks that have become broken to again point to annexed content. This is useful to run if you have been moving the symlinks around, but is done automatically when committing a change with git too.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>upgrade</strong>
  </dt>
  <dd>
    <p>Upgrades the repository to current layout.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>forget</strong>
  </dt>
  <dd>
    <p>Causes the git-annex branch to be rewritten, throwing away historical data about past locations of files. The resulting branch will use less space, but <strong>git annex log</strong> will not be able to show where files used to be located.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>To also prune references to repositories that have been marked as dead, specify <strong>--drop-dead</strong>.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>When this rewritten branch is merged into other clones of the repository, <strong>git-annex</strong> will automatically perform the same rewriting to their local <strong>git-annex</strong> branches. So the forgetfulness will automatically propagate out from its starting point until all repositories running git-annex have forgotten their old history. (You may need to force git to push the branch to any git repositories not running git-annex.)</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>repair</strong>
  </dt>
  <dd>
    <p>This can repair many of the problems with git repositories that <strong>git fsck</strong> detects, but does not itself fix. It's useful if a repository has become badly damaged. One way this can happen is if a repository used by git-annex is on a removable drive that gets unplugged at the wrong time.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>This command can actually be used inside git repositories that do not use git-annex at all; when used in a repository using git-annex, it does additional repairs of the git-annex branch.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>It works by deleting any corrupt objects from the git repository, and retrieving all missing objects it can from the remotes of the repository.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>If that is not sufficient to fully recover the repository, it can also reset branches back to commits before the corruption happened, delete branches that are no longer available due to the lost data, and remove any missing files from the index. It will only do this if run with the <strong>--force</strong> option, since that rewrites history and throws out missing data. Note that the <strong>--force</strong> option never touches tags, even if they are no longer usable due to missing data.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>After running this command, you will probably want to run <strong>git fsck</strong> to verify it fixed the repository. Note that fsck may still complain about objects referenced by the reflog, or the stash, if they were unable to be recovered. This command does not try to clean up either the reflog or the stash.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>It is also a good idea to run <strong>git annex fsck --fast</strong> after this command, to make sure that the git-annex branch reflects reality.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">QUERY COMMANDS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <strong>find [path ...]</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Outputs a list of annexed files in the specified path. With no path, finds files in the current directory and its subdirectories.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>By default, only lists annexed files whose content is currently present. This can be changed by specifying matching options. To list all annexed files, present or not, specify <strong>--include "*"</strong>. To list all annexed files whose content is not present, specify <strong>--not --in=here</strong></p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>To output filenames terminated with nulls, for use with xargs -0, specify <strong>--print0</strong>. Or, a custom output formatting can be specified using <strong>--format</strong>. The default output format is the same as <strong>--format='${file}&#92;n'</strong></p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>These variables are available for use in formats: file, key, backend, bytesize, humansize, keyname, hashdirlower, hashdirmixed, mtime (for the mtime field of a WORM key).</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>whereis [path ...]</strong>
  </dt>
  <dd>
    <p>Displays a information about where the contents of files are located.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>list [path ...]</strong>
  </dt>
  <dd>
    <p>Displays a table of remotes that contain the contents of the specified files. This is similar to whereis but a more compact display. Only configured remotes are shown by default; specify --allrepos to list all repositories.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>log [path ...]</strong>
  </dt>
  <dd>
    <p>Displays the location log for the specified file or files, showing each repository they were added to ("+") and removed from ("-").</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>To limit how far back to search for location log changes, the options <strong>--since</strong>, <strong>--after</strong>, <strong>--until</strong>, <strong>--before</strong>, and <strong>--max-count</strong> can be specified. They are passed through to git log. For example, <strong>--since "1 month ago"</strong></p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>To generate output suitable for the gource visualization program, specify <strong>--gource</strong>.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>info [directory|file|remote ...]</strong>
  </dt>
  <dd>
    <p>Displays statistics and other information for the specified item, which can be a directory, or a file, or a remote. When no item is specified, displays statistics and information for the repository as a whole.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>When a directory is specified, the file matching options can be used to select the files in the directory that are included in the statistics.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>To only show the data that can be gathered quickly, use <strong>--fast</strong>.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>For example, suppose you want to run "git annex get .", but would first like to see how much disk space that will use. Then run:</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p> git annex info --fast . --not --in here</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>version</strong>
  </dt>
  <dd>
    <p>Shows the version of git-annex, as well as repository version information.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>map</strong>
  </dt>
  <dd>
    <p>Helps you keep track of your repositories, and the connections between them, by going out and looking at all the ones it can get to, and generating a Graphviz file displaying it all. If the <strong>dot</strong> command is available, it is used to display the file to your screen (using x11 backend). (To disable this display, specify <strong>--fast</strong>)</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>This command only connects to hosts that the host it's run on can directly connect to. It does not try to tunnel through intermediate hosts. So it might not show all connections between the repositories in the network.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Also, if connecting to a host requires a password, you might have to enter it several times as the map is being built.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Note that this subcommand can be used to graph any git repository; it is not limited to git-annex repositories.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METADATA COMMANDS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <strong>metadata [path ...] [-s field=value -s field+=value -s field-=value ...] [-g field]</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>The content of a file can have any number of metadata fields attached to it to describe it. Each metadata field can in turn have any number of values.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>This command can be used to set metadata, or show the currently set metadata.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>To show current metadata, run without any -s parameters. The --json option will enable json output.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>To only get the value(s) of a single field, use -g field. The values will be output one per line, with no other output, so this is suitable for use in a script.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>To set a field's value, removing any old value(s), use -s field=value.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>To add an additional value, use -s field+=value.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>To remove a value, use -s field-=value.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>To set a value, only if the field does not already have a value, use -s field?=value</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>To set a tag, use -t tag, and use -u tag to remove a tag.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>For example, to set some tags on a file and also its author:</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p> git annex metadata annexscreencast.ogv -t video -t screencast -s author+=Alice</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>view [tag ...] [field=value ...] [field=glob ...] [!tag ...] [field!=value ...]</strong>
  </dt>
  <dd>
    <p>Uses metadata to build a view branch of the files in the current branch, and checks out the view branch. Only files in the current branch whose metadata matches all the specified field values and tags will be shown in the view.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Multiple values for a metadata field can be specified, either by using a glob (<strong>field="*"</strong>) or by listing each wanted value. The resulting view will put files in subdirectories according to the value of their fields.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Once within such a view, you can make additional directories, and copy or move files into them. When you commit, the metadata will be updated to correspond to your changes.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>There are fields corresponding to the path to the file. So a file "foo/bar/baz/file" has fields "/=foo", "foo/=bar", and "foo/bar/=baz". These location fields can be used the same as other metadata to construct the view.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>For example, <strong>/=podcasts</strong> will only include files from the podcasts directory in the view, while <strong>podcasts/=*</strong> will preserve the subdirectories of the podcasts directory in the view.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>vpop [N]</strong>
  </dt>
  <dd>
    <p>Switches from the currently active view back to the previous view. Or, from the first view back to original branch.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>The optional number tells how many views to pop.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>vfilter [tag ...] [field=value ...] [!tag ...] [field!=value ...]</strong>
  </dt>
  <dd>
    <p>Filters the current view to only the files that have the specified field values and tags.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>vadd [field=glob ...] [field=value ...] [tag ...]</strong>
  </dt>
  <dd>
    <p>Changes the current view, adding an additional level of directories to categorize the files.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>For example, when the view is by author/tag, <strong>vadd year=*</strong> will change it to year/author/tag.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>So will <strong>vadd year=2014 year=2013</strong>, but limiting the years in view to only those two.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>vcycle</strong>
  </dt>
  <dd>
    <p>When a view involves nested subdirectories, this cycles the order.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>For example, when the view is by year/author/tag, <strong>vcycle</strong> will switch it to author/tag/year.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">UTILITY COMMANDS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <strong>migrate [path ...]</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Changes the specified annexed files to use the default key-value backend (or the one specified with <strong>--backend</strong>). Only files whose content is currently available are migrated.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Note that the content is also still available using the old key after migration. Use <strong>git annex unused</strong> to find and remove the old key.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Normally, nothing will be done to files already using the new backend. However, if a backend changes the information it uses to construct a key, this can also be used to migrate files to use the new key format.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>reinject src dest</strong>
  </dt>
  <dd>
    <p>Moves the src file into the annex as the content of the dest file. This can be useful if you have obtained the content of a file from elsewhere and want to put it in the local annex.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Automatically runs fsck on dest to check that the expected content was provided.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Example:</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p> git annex reinject /tmp/foo.iso foo.iso</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>unannex [path ...]</strong>
  </dt>
  <dd>
    <p>Use this to undo an accidental <strong>git annex add</strong> command. It puts the file back how it was before the add.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Note that for safety, the content of the file remains in the annex, until you use <strong>git annex unused</strong> and <strong>git annex dropunused</strong>.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>This is not the command you should use if you intentionally annexed a file and don't want its contents any more. In that case you should use <strong>git annex drop</strong> instead, and you can also <strong>git rm</strong> the file.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Normally this does a slow copy of the file. In <strong>--fast</strong> mode, it instead makes a hard link from the file to the content in the annex. But use --fast mode with caution, because editing the file will change the content in the annex.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>uninit</strong>
  </dt>
  <dd>
    <p>Use this to stop using git annex. It will unannex every file in the repository, and remove all of git-annex's other data, leaving you with a git repository plus the previously annexed files.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>reinit uuid|description</strong>
  </dt>
  <dd>
    <p>Normally, initializing a repository generates a new, unique identifier (UUID) for that repository. Occasionally it may be useful to reuse a UUID -- for example, if a repository got deleted, and you're setting it back up.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Use this with caution; it can be confusing to have two existing repositories with the same UUID. Also, you will probably want to run a fsck.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PLUMBING COMMANDS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <strong>pre-commit [path ...]</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>This is meant to be called from git's pre-commit hook. <strong>git annex init</strong> automatically creates a pre-commit hook using this.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Fixes up symlinks that are staged as part of a commit, to ensure they point to annexed content. Also handles injecting changes to unlocked files into the annex. When in a view, updates metadata to reflect changes made to files in the view.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>lookupkey [file ...]</strong>
  </dt>
  <dd>
    <p>This plumbing-level command looks up the key used for a file in the index. The key is output to stdout. If there is no key (because the file is not present in the index, or is not a git-annex managed file), nothing is output, and it exits nonzero.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>examinekey [key ...]</strong>
  </dt>
  <dd>
    <p>This plumbing-level command is given a key, and prints information that can be determined purely by looking at the key.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>To specify what information to print, use <strong>--format</strong>. Or use <strong>--json</strong> to get all available information in JSON format.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>The same variables can be used in the format string as can be used in the format string of git annex find (except there is no file option here).</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>For example, the location a key's value is stored (in indirect mode) can be looked up by running:</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p> git annex examinekey --format='.git/annex/objects/${hashdirmixed}${key}/${key}'</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>fromkey key file</strong>
  </dt>
  <dd>
    <p>This plumbing-level command can be used to manually set up a file in the git repository to link to a specified key.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>dropkey [key ...]</strong>
  </dt>
  <dd>
    <p>This plumbing-level command drops the annexed data for the specified keys from this repository.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>This can be used to drop content for arbitrary keys, which do not need to have a file in the git repository pointing at them.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>transferkey</strong>
  </dt>
  <dd>
    <p>This plumbing-level command is used to request a single key be transferred. Either the --from or the --to option can be used to specify the remote to use. A --file option can be used to hint at the file associated with the key.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>transferkeys</strong>
  </dt>
  <dd>
    <p>This plumbing-level command is used by the assistant to transfer data. It is fed instructions about the keys to transfer using an internal stdio protocol, which is intentionally not documented (as it may change at any time).</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>rekey [file key ...]</strong>
  </dt>
  <dd>
    <p>This plumbing-level command is similar to migrate, but you specify both the file, and the new key to use for it.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>With <strong>--force</strong>, even files whose content is not currently available will be rekeyed. Use with caution.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>findref [ref]</strong>
  </dt>
  <dd>
    <p>This is similar to the find command, but instead of finding files in the current work tree, it finds files in the specified git ref.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Most MATCHING OPTIONS can be used with findref, to limit the files it finds. However, the --include and --exclude options will not work.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>resolvemerge</strong>
  </dt>
  <dd>
    <p>Resolves a conflicted merge, by adding both conflicting versions of the file to the tree, using variants of their filename. This is done automatically when using <strong>git annex sync</strong> or <strong>git annex merge</strong>.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Note that only merge conflicts that involve an annexed file are resolved. Merge conflicts between two files that are not annexed will not be automatically resolved.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>remotedaemon</strong>
  </dt>
  <dd>
    <p>Detects when network remotes have received git pushes and fetches from them.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>xmppgit</strong>
  </dt>
  <dd>
    <p>This command is used internally to perform git pulls over XMPP.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TESTING COMMANDS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <strong>test</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>This runs git-annex's built-in test suite.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>There are several parameters, provided by Haskell's tasty test framework. Pass --help for details.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>testremote remote</strong>
  </dt>
  <dd>
    <p>This tests a remote by generating some random objects and sending them to the remote, then redownloading them, removing them from the remote, etc.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>It's safe to run in an existing repository (the repository contents are not altered), although it may perform expensive data transfers.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>To perform a smaller set of tests, use --fast.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>The --size option can be used to tune the size of the generated objects.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Testing a single remote will use the remote's configuration, automatically varying the chunk sizes, and with simple shared encryption enabled and disabled.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>fuzztest</strong>
  </dt>
  <dd>
    <p>Generates random changes to files in the current repository, for use in testing the assistant. This is dangerous, so it will not do anything unless --forced.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <strong>--force</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Force unsafe actions, such as dropping a file's content when no other source of it can be verified to still exist, or adding ignored files. Use with care.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--fast</strong>
  </dt>
  <dd>
    <p>Enable less expensive, but also less thorough versions of some commands. What is avoided depends on the command.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--auto</strong>
  </dt>
  <dd>
    <p>Enable automatic mode. Commands that get, drop, or move file contents will only do so when needed to help satisfy the setting of numcopies, and preferred content configuration.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--all</strong>
  </dt>
  <dd>
    <p>Operate on all data that has been stored in the git annex, including old versions of files. This is the default behavior when running git-annex in a bare repository; in a non-bare repository the normal behavior is to only operate on specified files in the working tree.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--unused</strong>
  </dt>
  <dd>
    <p>Operate on all data that has been determined to be unused by a previous run of <strong>git-annex unused</strong>.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--key=key</strong>
  </dt>
  <dd>
    <p>Operate on only the specified key.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--quiet</strong>
  </dt>
  <dd>
    <p>Avoid the default verbose display of what is done; only show errors and progress displays.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--verbose</strong>
  </dt>
  <dd>
    <p>Enable verbose display.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--json</strong>
  </dt>
  <dd>
    <p>Rather than the normal output, generate JSON. This is intended to be parsed by programs that use git-annex. Each line of output is a JSON object. Note that JSON output is only usable with some git-annex commands, like info, find, whereis, and metadata.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--debug</strong>
  </dt>
  <dd>
    <p>Show debug messages.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--no-debug</strong>
  </dt>
  <dd>
    <p>Disable debug messages.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--from=repository</strong>
  </dt>
  <dd>
    <p>Specifies a repository that content will be retrieved from, or that should otherwise be acted on.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>It should be specified using the name of a configured remote.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--to=repository</strong>
  </dt>
  <dd>
    <p>Specifies a repository that content will be sent to.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>It should be specified using the name of a configured remote.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--numcopies=n</strong>
  </dt>
  <dd>
    <p>Overrides the numcopies setting, forcing git-annex to ensure the specified number of copies exist.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Note that setting numcopies to 0 is very unsafe.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--time-limit=time</strong>
  </dt>
  <dd>
    <p>Limits how long a git-annex command runs. The time can be something like "5h", or "30m" or even "45s" or "10d".</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Note that git-annex may continue running a little past the specified time limit, in order to finish processing a file.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Also, note that if the time limit prevents git-annex from doing all it was asked to, it will exit with a special code, 101.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--trust=repository</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--semitrust=repository</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--untrust=repository</strong>
  </dt>
  <dd>
    <p>Overrides trust settings for a repository. May be specified more than once.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>The repository should be specified using the name of a configured remote, or the UUID or description of a repository.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--trust-glacier-inventory</strong>
  </dt>
  <dd>
    <p>Amazon Glacier inventories take hours to retrieve, and may not represent the current state of a repository. So git-annex does not trust that files that the inventory claims are in Glacier are really there. This switch can be used to allow it to trust the inventory.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Be careful using this, especially if you or someone else might have recently removed a file from Glacier. If you try to drop the only other copy of the file, and this switch is enabled, you could lose data!</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--backend=name</strong>
  </dt>
  <dd>
    <p>Specifies which key-value backend to use. This can be used when adding a file to the annex, or migrating a file. Once files are in the annex, their backend is known and this option is not necessary.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--format=value</strong>
  </dt>
  <dd>
    <p>Specifies a custom output format. The value is a format string, in which '${var}' is expanded to the value of a variable. To right-justify a variable with whitespace, use '${var;width}' ; to left-justify a variable, use '${var;-width}'; to escape unusual characters in a variable, use '${escaped_var}'</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Also, '&#92;n' is a newline, '&#92;000' is a NULL, etc.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--user-agent=value</strong>
  </dt>
  <dd>
    <p>Overrides the User-Agent to use when downloading files from the web.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--notify-finish</strong>
  </dt>
  <dd>
    <p>Caused a desktop notification to be displayed after each successful file download and upload.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>(Only supported on some platforms, e.g. Linux with dbus. A no-op when not supported.)</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--notify-start</strong>
  </dt>
  <dd>
    <p>Caused a desktop notification to be displayed when a file upload or download has started, or when a file is dropped.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>-c name=value</strong>
  </dt>
  <dd>
    <p>Overrides git configuration settings. May be specified multiple times.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MATCHING OPTIONS</h2>
        <div class="sectioncontent">
<p>These options can all be specified multiple times, and can be combined to limit which files git-annex acts on.</p><p>Arbitrarily complicated expressions can be built using these options. For example:</p><p> --exclude '*.mp3' --and --not -( --in=usbdrive --or --in=archive -)</p><p>The above example prevents git-annex from working on mp3 files whose file contents are present at either of two repositories.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>--exclude=glob</strong>
  </dt>
  <dd>
    <p>Skips files matching the glob pattern. The glob is matched relative to the current directory. For example:</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p> --exclude='*.mp3' --exclude='subdir/*'</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Note that this will not match anything when using --all or --unused.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--include=glob</strong>
  </dt>
  <dd>
    <p>Skips files not matching the glob pattern.  (Same as <strong>--not --exclude</strong>.) For example, to include only mp3 and ogg files:</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p> --include='*.mp3' --or --include='*.ogg'</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Note that this will not skip anything when using --all or --unused.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--in=repository</strong>
  </dt>
  <dd>
    <p>Matches only files that git-annex believes have their contents present in a repository. Note that it does not check the repository to verify that it still has the content.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>The repository should be specified using the name of a configured remote, or the UUID or description of a repository. For the current repository, use <strong>--in=here</strong></p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--in=repository@{date}</strong>
  </dt>
  <dd>
    <p>Matches files currently in the work tree whose content was present in the repository on the given date.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>The date is specified in the same syntax documented in <a href="../man7/gitrevisions.7.html"><strong>gitrevisions</strong>(7)</a>. Note that this uses the reflog, so dates far in the past cannot be queried.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>For example, you might need to run <strong>git annex drop .</strong> to temporarily free up disk space. The next day, you can get back the files you dropped using <strong>git annex get . --in=here@{yesterday}</strong></p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--copies=number</strong>
  </dt>
  <dd>
    <p>Matches only files that git-annex believes to have the specified number of copies, or more. Note that it does not check remotes to verify that the copies still exist.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--copies=trustlevel:number</strong>
  </dt>
  <dd>
    <p>Matches only files that git-annex believes have the specified number of copies, on remotes with the specified trust level. For example, <strong>--copies=trusted:2</strong></p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>To match any trust level at or higher than a given level, use 'trustlevel+'. For example, <strong>--copies=semitrusted+:2</strong></p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--copies=groupname:number</strong>
  </dt>
  <dd>
    <p>Matches only files that git-annex believes have the specified number of copies, on remotes in the specified group. For example, <strong>--copies=archive:2</strong></p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--lackingcopies=number</strong>
  </dt>
  <dd>
    <p>Matches only files that git-annex believes need the specified number or more additional copies to be made in order to satisfy their numcopies settings.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--approxlackingcopies=number</strong>
  </dt>
  <dd>
    <p>Like lackingcopies, but does not look at .gitattributes annex.numcopies settings. This makes it significantly faster.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--inbackend=name</strong>
  </dt>
  <dd>
    <p>Matches only files whose content is stored using the specified key-value backend.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--inallgroup=groupname</strong>
  </dt>
  <dd>
    <p>Matches only files that git-annex believes are present in all repositories in the specified group.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--smallerthan=size</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--largerthan=size</strong>
  </dt>
  <dd>
    <p>Matches only files whose content is smaller than, or larger than the specified size.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>The size can be specified with any commonly used units, for example, "0.5 gb" or "100 KiloBytes"</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--metadata field=glob</strong>
  </dt>
  <dd>
    <p>Matches only files that have a metadata field attached with a value that matches the glob. The values of metadata fields are matched case insensitively.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--want-get</strong>
  </dt>
  <dd>
    <p>Matches files that the preferred content settings for the repository make it want to get. Note that this will match even files that are already present, unless limited with e.g., <strong>--not --in .</strong></p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Note that this will not match anything when using --all or --unused.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--want-drop</strong>
  </dt>
  <dd>
    <p>Matches files that the preferred content settings for the repository make it want to drop. Note that this will match even files that have already been dropped, unless limited with e.g., <strong>--in .</strong></p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Note that this will not match anything when using --all or --unused.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--not</strong>
  </dt>
  <dd>
    <p>Inverts the next matching option. For example, to only act on files with less than 3 copies, use <strong>--not --copies=3</strong></p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--and</strong>
  </dt>
  <dd>
    <p>Requires that both the previous and the next matching option matches. The default.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>--or</strong>
  </dt>
  <dd>
    <p>Requires that either the previous, or the next matching option matches.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>-(</strong>
  </dt>
  <dd>
    <p>Opens a group of matching options.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>-)</strong>
  </dt>
  <dd>
    <p>Closes a group of matching options.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PREFERRED CONTENT</h2>
        <div class="sectioncontent">
<p>Each repository has a preferred content setting, which specifies content that the repository wants to have present. These settings can be configured using <strong>git annex vicfg</strong> or <strong>git annex wanted</strong>. They are used by the <strong>--auto</strong> option, and by the git-annex assistant.</p><p>The preferred content settings are similar, but not identical to the matching options specified above, just without the dashes. For example:</p><p> exclude=archive/* and (include=*.mp3 or smallerthan=1mb)</p><p>The main differences are that <strong>exclude=</strong> and <strong>include=</strong> always match relative to the top of the git repository, and that there is no equivilant to <strong>--in</strong>.</p><p>When a repository is in one of the standard predefined groups, like "backup" and "client", setting its preferred content to "standard" will use a built-in preferred content expression developed for that group.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SCHEDULED JOBS</h2>
        <div class="sectioncontent">
<p>The git-annex assistant daemon can be configured to run scheduled jobs. This is similar to cron and anacron (and you can use them if you prefer), but has the advantage of being integrated into git-annex, and so being able to e.g., fsck a repository on a removable drive when the drive gets connected.</p><p>The scheduled jobs can be configured using <strong>git annex vicfg</strong> or <strong>git annex schedule</strong>.</p><p>These actions are available: "fsck self", "fsck UUID" (where UUID is the UUID of a remote to fsck). After the action comes the duration to allow the action to run, and finally the schedule of when to run it.</p><p>To schedule multiple jobs, separate them with "; ".</p><p>Some examples:</p><p> fsck self 30m every day at any time  fsck self 1h every month at 3 AM  fsck self 1h on day 1 of every month at any time  fsck self 1h every week divisible by 2 at any time</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONFIGURATION VIA .git/config</h2>
        <div class="sectioncontent">
<p>Like other git commands, git-annex is configured via <strong>.git/config</strong>. Here are all the supported configuration settings.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>annex.uuid</strong>
  </dt>
  <dd>
    <p>A unique UUID for this repository (automatically set).</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>annex.backends</strong>
  </dt>
  <dd>
    <p>Space-separated list of names of the key-value backends to use. The first listed is used to store new files by default.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>annex.diskreserve</strong>
  </dt>
  <dd>
    <p>Amount of disk space to reserve. Disk space is checked when transferring content to avoid running out, and additional free space can be reserved via this option, to make space for more important content (such as git commit logs). Can be specified with any commonly used units, for example, "0.5 gb", "500M", or "100 KiloBytes"</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>The default reserve is 1 megabyte.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>annex.largefiles</strong>
  </dt>
  <dd>
    <p>Allows configuring which files <strong>git annex add</strong> and the assistant consider to be large enough to need to be added to the annex. By default, all files are added to the annex.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>The value is a preferred content expression. See PREFERRED CONTENT for details.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Example:</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p> annex.largefiles = largerthan=100kb and not (include=*.c or include=*.h)</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>annex.numcopies</strong>
  </dt>
  <dd>
    <p>This is a deprecated setting. You should instead use the <strong>git annex numcopies</strong> command to configure how many copies of files are kept across all repositories.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>This config setting is only looked at when <strong>git annex numcopies</strong> has never been configured.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Note that setting numcopies to 0 is very unsafe.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>annex.genmetadata</strong>
  </dt>
  <dd>
    <p>Set this to <strong>true</strong> to make git-annex automatically generate some metadata when adding files to the repository.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>In particular, it stores year and month metadata, from the file's modification date.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>When importfeed is used, it stores additional metadata from the feed.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>annex.queuesize</strong>
  </dt>
  <dd>
    <p>git-annex builds a queue of git commands, in order to combine similar commands for speed. By default the size of the queue is limited to 10240 commands; this can be used to change the size. If you have plenty of memory and are working with very large numbers of files, increasing the queue size can speed it up.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>annex.bloomcapacity</strong>
  </dt>
  <dd>
    <p>The <strong>git annex unused</strong> command uses a bloom filter to determine what data is no longer used. The default bloom filter is sized to handle up to 500000 keys. If your repository is larger than that, you can adjust this to avoid <strong>git annex unused</strong> not noticing some unused data files. Increasing this will make <strong>git-annex unused</strong> consume more memory; run <strong>git annex info</strong> for memory usage numbers.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>annex.bloomaccuracy</strong>
  </dt>
  <dd>
    <p>Adjusts the accuracy of the bloom filter used by <strong>git annex unused</strong>. The default accuracy is 1000 -- 1 unused file out of 1000 will be missed by <strong>git annex unused</strong>. Increasing the accuracy will make <strong>git annex unused</strong> consume more memory; run <strong>git annex info</strong> for memory usage numbers.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>annex.sshcaching</strong>
  </dt>
  <dd>
    <p>By default, git-annex caches ssh connections using ssh's ControlMaster and ControlPersist settings (if built using a new enough ssh). To disable this, set to <strong>false</strong>.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>annex.alwayscommit</strong>
  </dt>
  <dd>
    <p>By default, git-annex automatically commits data to the git-annex branch after each command is run. If you have a series of commands that you want to make a single commit, you can run the commands with <strong>-c annex.alwayscommit=false</strong>. You can later commit the data by running <strong>git annex merge</strong> (or by automatic merges) or <strong>git annex sync</strong>.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>annex.hardlink</strong>
  </dt>
  <dd>
    <p>Set this to <strong>true</strong> to make file contents be hard linked into the repository when possible, instead of a more expensive copy.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Use with caution -- This can invalidate numcopies counting, since with hard links, fewer copies of a file can exist. So, it is a good idea to mark a repository using this setting as untrusted.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>When a repository is set up using <strong>git clone --shared</strong>, git-annex init will automatically set annex.hardlink and mark the repository as untrusted.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>annex.delayadd</strong>
  </dt>
  <dd>
    <p>Makes the watch and assistant commands delay for the specified number of seconds before adding a newly created file to the annex. Normally this is not needed, because they already wait for all writers of the file to close it. On Mac OSX, when not using direct mode this defaults to 1 second, to work around a bad interaction with software there.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>annex.expireunused</strong>
  </dt>
  <dd>
    <p>Controls what the assistant does about unused file contents that are stored in the repository.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>The default is <strong>false</strong>, which causes all old and unused file contents to be retained, unless the assistant is able to move them to some other repository (such as a backup repository).</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Can be set to a time specification, like "7d" or "1m", and then file contents that have been known to be unused for a week or a month will be deleted.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>annex.fscknudge</strong>
  </dt>
  <dd>
    <p>When set to false, prevents the webapp from reminding you when using repositories that lack consistency checks.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>annex.autoupgrade</strong>
  </dt>
  <dd>
    <p>When set to ask (the default), the webapp will check for new versions and prompt if they should be upgraded to. When set to true, automatically upgrades without prompting (on some supported platforms). When set to false, disables any upgrade checking.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Note that upgrade checking is only done when git-annex is installed from one of the prebuilt images from its website. This does not bypass e.g., a Linux distribution's own upgrade handling code.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>This setting also controls whether to restart the git-annex assistant when the git-annex binary is detected to have changed. That is useful no matter how you installed git-annex.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>annex.autocommit</strong>
  </dt>
  <dd>
    <p>Set to false to prevent the git-annex assistant from automatically committing changes to files in the repository.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>annex.startupscan</strong>
  </dt>
  <dd>
    <p>Set to false to prevent the git-annex assistant from scanning the repository for new and changed files on startup. This will prevent it from noticing changes that were made while it was not running, but can be a useful performance tweak for a large repository.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>annex.listen</strong>
  </dt>
  <dd>
    <p>Configures which address the webapp listens on. The default is localhost. Can be either an IP address, or a hostname that resolves to the desired address.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>annex.debug</strong>
  </dt>
  <dd>
    <p>Set to true to enable debug logging by default.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>annex.version</strong>
  </dt>
  <dd>
    <p>Automatically maintained, and used to automate upgrades between versions.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>annex.direct</strong>
  </dt>
  <dd>
    <p>Set to true when the repository is in direct mode. Should not be set manually; use the "git annex direct" and "git annex indirect" commands instead.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>annex.crippledfilesystem</strong>
  </dt>
  <dd>
    <p>Set to true if the repository is on a crippled filesystem, such as FAT, which does not support symbolic links, or hard links, or unix permissions. This is automatically probed by "git annex init".</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>remote.&lt;name&gt;.annex-cost</strong>
  </dt>
  <dd>
    <p>When determining which repository to transfer annexed files from or to, ones with lower costs are preferred. The default cost is 100 for local repositories, and 200 for remote repositories.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>remote.&lt;name&gt;.annex-cost-command</strong>
  </dt>
  <dd>
    <p>If set, the command is run, and the number it outputs is used as the cost. This allows varying the cost based on e.g., the current network. The cost-command can be any shell command line.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>remote.&lt;name&gt;.annex-start-command</strong>
  </dt>
  <dd>
    <p>A command to run when git-annex begins to use the remote. This can be used to, for example, mount the directory containing the remote.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>The command may be run repeatedly when multiple git-annex processes are running concurrently.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>remote.&lt;name&gt;.annex-stop-command</strong>
  </dt>
  <dd>
    <p>A command to run when git-annex is done using the remote.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>The command will only be run once *all* running git-annex processes are finished using the remote.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>remote.&lt;name&gt;.annex-shell</strong>
  </dt>
  <dd>
    <p>Specify an alternative git-annex-shell executable on the remote instead of looking for "git-annex-shell" on the PATH.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>This is useful if the git-annex-shell program is outside the PATH or has a non-standard name.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>remote.&lt;name&gt;.annex-ignore</strong>
  </dt>
  <dd>
    <p>If set to <strong>true</strong>, prevents git-annex from storing file contents on this remote by default. (You can still request it be used by the <strong>--from</strong> and <strong>--to</strong> options.)</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>This is, for example, useful if the remote is located somewhere without git-annex-shell. (For example, if it's on GitHub). Or, it could be used if the network connection between two repositories is too slow to be used normally.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>This does not prevent git-annex sync (or the git-annex assistant) from syncing the git repository to the remote.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>remote.&lt;name&gt;.annex-sync</strong>
  </dt>
  <dd>
    <p>If set to <strong>false</strong>, prevents git-annex sync (and the git-annex assistant) from syncing with this remote.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>remote.&lt;name&gt;.annex-readonly</strong>
  </dt>
  <dd>
    <p>If set to <strong>true</strong>, prevents git-annex from making changes to a remote. This both prevents git-annex sync from pushing changes, and prevents storing or removing files from read-only remote.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>remote.&lt;name&gt;.annexUrl</strong>
  </dt>
  <dd>
    <p>Can be used to specify a different url than the regular <strong>remote.&lt;name&gt;.url</strong> for git-annex to use when talking with the remote. Similar to the <strong>pushUrl</strong> used by git-push.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>remote.&lt;name&gt;.annex-uuid</strong>
  </dt>
  <dd>
    <p>git-annex caches UUIDs of remote repositories here.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>remote.&lt;name&gt;.annex-trustlevel</strong>
  </dt>
  <dd>
    <p>Configures a local trust level for the remote. This overrides the value configured by the trust and untrust commands. The value can be any of "trusted", "semitrusted" or "untrusted".</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>remote.&lt;name&gt;.annex-availability</strong>
  </dt>
  <dd>
    <p>Can be used to tell git-annex whether a remote is LocallyAvailable or GloballyAvailable. Normally, git-annex determines this automatically.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>remote.&lt;name&gt;.annex-bare</strong>
  </dt>
  <dd>
    <p>Can be used to tell git-annex if a remote is a bare repository or not. Normally, git-annex determines this automatically.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>remote.&lt;name&gt;.annex-ssh-options</strong>
  </dt>
  <dd>
    <p>Options to use when using ssh to talk to this remote.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>remote.&lt;name&gt;.annex-rsync-options</strong>
  </dt>
  <dd>
    <p>Options to use when using rsync to or from this remote. For example, to force ipv6, and limit the bandwidth to 100Kbyte/s, set it to <strong>-6 --bwlimit 100</strong></p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>remote.&lt;name&gt;.annex-rsync-upload-options</strong>
  </dt>
  <dd>
    <p>Options to use when using rsync to upload a file to a remote.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>These options are passed after other applicable rsync options, so can be used to override them. For example, to limit upload bandwidth to 10Kbyte/s, set <strong>--bwlimit 10</strong>.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>remote.&lt;name&gt;.annex-rsync-download-options</strong>
  </dt>
  <dd>
    <p>Options to use when using rsync to download a file from a remote.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>These options are passed after other applicable rsync options, so can be used to override them.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>remote.&lt;name&gt;.annex-rsync-transport</strong>
  </dt>
  <dd>
    <p>The remote shell to use to connect to the rsync remote. Possible values are <strong>ssh</strong> (the default) and <strong>rsh</strong>, together with their arguments, for instance <strong>ssh -p 2222 -c blowfish</strong>; Note that the remote hostname should not appear there, see <a href="../man1/rsync.1.html"><strong>rsync</strong>(1)</a> for details. When the transport used is <strong>ssh</strong>, connections are automatically cached unless <strong>annex.sshcaching</strong> is unset.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>remote.&lt;name&gt;.annex-bup-split-options</strong>
  </dt>
  <dd>
    <p>Options to pass to bup split when storing content in this remote. For example, to limit the bandwidth to 100Kbyte/s, set it to <strong>--bwlimit 100k</strong> (There is no corresponding option for bup join.)</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>remote.&lt;name&gt;.annex-gnupg-options</strong>
  </dt>
  <dd>
    <p>Options to pass to GnuPG for symmetric encryption. For instance, to use the AES cipher with a 256 bits key and disable compression, set it to <strong>--cipher-algo AES256 --compress-algo none</strong>. (These options take precedence over the default GnuPG configuration, which is otherwise used.)</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>annex.ssh-options</strong>, <strong>annex.rsync-options</strong>,
  </dt>
  <dd>
    <p><strong>annex.rsync-upload-options</strong>, <strong>annex.rsync-download-options</strong>, <strong>annex.bup-split-options</strong>, <strong>annex.gnupg-options</strong></p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Default options to use if a remote does not have more specific options as described above.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>annex.web-options</strong>
  </dt>
  <dd>
    <p>Options to pass when running wget or curl. For example, to force ipv4 only, set it to "-4"</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>annex.quvi-options</strong>
  </dt>
  <dd>
    <p>Options to pass to quvi when using it to find the url to download for a video.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>annex.http-headers</strong>
  </dt>
  <dd>
    <p>HTTP headers to send when downloading from the web. Multiple lines of this option can be set, one per header.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>annex.http-headers-command</strong>
  </dt>
  <dd>
    <p>If set, the command is run and each line of its output is used as a HTTP header. This overrides annex.http-headers.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>annex.web-download-command</strong>
  </dt>
  <dd>
    <p>Use to specify a command to run to download a file from the web. (The default is to use wget or curl.)</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>In the command line, %url is replaced with the url to download, and %file is replaced with the file that it should be saved to.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>annex.secure-erase-command</strong>
  </dt>
  <dd>
    <p>This can be set to a command that should be run whenever git-annex removes the content of a file from the repository.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>In the command line, %file is replaced with the file that should be erased.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>For example, to use the wipe command, set it to <strong>wipe -f %file</strong>.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>remote.&lt;name&gt;.rsyncurl</strong>
  </dt>
  <dd>
    <p>Used by rsync special remotes, this configures the location of the rsync repository to use. Normally this is automatically set up by <strong>git annex initremote</strong>, but you can change it if needed.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>remote.&lt;name&gt;.buprepo</strong>
  </dt>
  <dd>
    <p>Used by bup special remotes, this configures the location of the bup repository to use. Normally this is automatically set up by <strong>git annex initremote</strong>, but you can change it if needed.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>remote.&lt;name&gt;.ddarrepo</strong>
  </dt>
  <dd>
    <p>Used by ddar special remotes, this configures the location of the ddar repository to use. Normally this is automatically set up by <strong>git annex initremote</strong>, but you can change it if needed.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>remote.&lt;name&gt;.directory</strong>
  </dt>
  <dd>
    <p>Used by directory special remotes, this configures the location of the directory where annexed files are stored for this remote. Normally this is automatically set up by <strong>git annex initremote</strong>, but you can change it if needed.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>remote.&lt;name&gt;.s3</strong>
  </dt>
  <dd>
    <p>Used to identify Amazon S3 special remotes. Normally this is automatically set up by <strong>git annex initremote</strong>.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>remote.&lt;name&gt;.glacier</strong>
  </dt>
  <dd>
    <p>Used to identify Amazon Glacier special remotes. Normally this is automatically set up by <strong>git annex initremote</strong>.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>remote.&lt;name&gt;.webdav</strong>
  </dt>
  <dd>
    <p>Used to identify webdav special remotes. Normally this is automatically set up by <strong>git annex initremote</strong>.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>remote.&lt;name&gt;.tahoe</strong>
  </dt>
  <dd>
    <p>Used to identify tahoe special remotes. Points to the configuration directory for tahoe.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>remote.&lt;name&gt;.annex-xmppaddress</strong>
  </dt>
  <dd>
    <p>Used to identify the XMPP address of a Jabber buddy. Normally this is set up by the git-annex assistant when pairing over XMPP.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>remote.&lt;name&gt;.gcrypt</strong>
  </dt>
  <dd>
    <p>Used to identify gcrypt special remotes. Normally this is automatically set up by <strong>git annex initremote</strong>.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>It is set to "true" if this is a gcrypt remote. If the gcrypt remote is accessible over ssh and has git-annex-shell available to manage it, it's set to "shell".</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>remote.&lt;name&gt;.hooktype</strong>, <strong>remote.&lt;name&gt;.externaltype</strong>
  </dt>
  <dd>
    <p>Used by hook special remotes and external special remotes to record the type of the remote.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONFIGURATION VIA .gitattributes</h2>
        <div class="sectioncontent">
<p>The key-value backend used when adding a new file to the annex can be configured on a per-file-type basis via <strong>.gitattributes</strong> files. In the file, the <strong>annex.backend</strong> attribute can be set to the name of the backend to use. For example, this here's how to use the WORM backend by default, but the SHA256E backend for ogg files:</p><p> * annex.backend=WORM  *.ogg annex.backend=SHA256E</p><p>The numcopies setting can also be configured on a per-file-type basis via the <strong>annex.numcopies</strong> attribute in <strong>.gitattributes</strong> files. This overrides other numcopies settings. For example, this makes two copies be needed for wav files and 3 copies for flac files:</p><p> *.wav annex.numcopies=2  *.flac annex.numcopies=3</p><p>Note that setting numcopies to 0 is very unsafe.</p><p>These settings are honored by git-annex whenever it's operating on a matching file. However, when using --all, --unused, or --key to specify keys to operate on, git-annex is operating on keys and not files, so will not honor the settings from .gitattributes.</p><p>Also note that when using views, only the toplevel .gitattributes file is preserved in the view, so other settings in other files won't have any effect.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILES</h2>
        <div class="sectioncontent">
<p>These files are used by git-annex:</p><p><strong>.git/annex/objects/</strong> in your git repository contains the annexed file contents that are currently available. Annexed files in your git repository symlink to that content.</p><p><strong>.git/annex/</strong> in your git repository contains other run-time information used by git-annex.</p><p><strong>~/.config/git-annex/autostart</strong> is a list of git repositories to start the git-annex assistant in.</p><p><strong>.git/hooks/pre-commit-annex</strong> in your git repository will be run whenever a commit is made, either by git commit, git-annex sync, or the git-annex assistant.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO git-annex&hellip;</h2>
        <div class="sectioncontent">
<p>Most of git-annex's documentation is available on its web site, &lt;http://git-annex.branchable.com/&gt;</p><p>If git-annex is installed from a package, a copy of its documentation should be included, in, for example, <strong>/usr/share/doc/git-annex/</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Joey Hess &lt;joey@kitenet.net&gt;</p><p>&lt;http://git-annex.branchable.com/&gt;</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="git-am.1.html"><span aria-hidden="true">&larr;</span> git-am.1: Apply a series of patches from a mailbox</a></li>
   <li class="next"><a href="git-annex-shell.1.html">git-annex-shell.1: Restricted login shell for git-annex only ssh access <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ns-3-manual: Ns-3 manual  this is the ns-3 manual. primary documentation for the ns-3 project is available in five forms: ns-3 doxygen: documentation of the public apis of the simulator tutorial, manual (this document), and model library for the latest release and development tree ns-3 wiki  this document is written in restructuredtext for sphinx and is maintained in the doc/manual directory of ns-3s source code.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Ns-3 manual  this is the ns-3 manual. primary documentation for the ns-3 project is available in five forms: ns-3 doxygen: documentation of the public apis of the simulator tutorial, manual (this document), and model library for the latest release and development tree ns-3 wiki  this document is written in restructuredtext for sphinx and is maintained in the doc/manual directory of ns-3s source code.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="ns-3-manual (1) manual">
  <meta name="twitter:description" content="Ns-3 manual  this is the ns-3 manual. primary documentation for the ns-3 project is available in five forms: ns-3 doxygen: documentation of the public apis of the simulator tutorial, manual (this document), and model library for the latest release and development tree ns-3 wiki  this document is written in restructuredtext for sphinx and is maintained in the doc/manual directory of ns-3s source code.">
  <meta name="twitter:image" content="https://www.carta.tech/images/ns3-doc-ns-3-manual-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/ns-3-manual.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="ns-3-manual (1) manual" />
  <meta property="og:description" content="Ns-3 manual  this is the ns-3 manual. primary documentation for the ns-3 project is available in five forms: ns-3 doxygen: documentation of the public apis of the simulator tutorial, manual (this document), and model library for the latest release and development tree ns-3 wiki  this document is written in restructuredtext for sphinx and is maintained in the doc/manual directory of ns-3s source code." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/ns3-doc-ns-3-manual-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">ns-3-manual<small> (1)</small></h1>
        <p class="lead">Ns-3 manual  this is the ns-3 manual. primary documentation for the ns-3 project is available in five forms: ns-3 doxygen: documentation of the public apis of the simulator tutorial, manual (this document), and model library for the latest release and development tree ns-3 wiki  this document is written in restructuredtext for sphinx and is maintained in the doc/manual directory of ns-3s source code.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/ns-3-manual.1.html">
      <span itemprop="name">ns-3-manual: Ns-3 manual  this is the ns-3 manual. primary documentation for the ns-3 project is available in five forms: ns-3 doxygen: documentation of the public apis of the simulator tutorial, manual (this document), and model library for the latest release and development tree ns-3 wiki  this document is written in restructuredtext for sphinx and is maintained in the doc/manual directory of ns-3s source code.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/ns3-doc/">
      <span itemprop="name">ns3-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/ns-3-manual.1.html">
      <span itemprop="name">ns-3-manual: Ns-3 manual  this is the ns-3 manual. primary documentation for the ns-3 project is available in five forms: ns-3 doxygen: documentation of the public apis of the simulator tutorial, manual (this document), and model library for the latest release and development tree ns-3 wiki  this document is written in restructuredtext for sphinx and is maintained in the doc/manual directory of ns-3s source code.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">ORGANIZATION</h2>
        <div class="sectioncontent">
<p>This chapter describes the overall <em>ns-3</em> software organization and the corresponding organization of this manual.</p><p><em>ns-3</em> is a discrete-event network simulator in which the simulation core and models are implemented in C++. <em>ns-3</em> is built as a library which may be statically or dynamically linked to a C++ main program that defines the simulation topology and starts the simulator. <em>ns-3</em> also exports nearly all of its API to Python, allowing Python programs to import an "ns3" module in much the same way as the <em>ns-3</em> library is linked by executables in C++. [image] Software organization of <em>ns-3</em>.UNINDENT</p><p>The source code for <em>ns-3</em> is mostly organized in the <strong>src</strong> directory and can be described by the diagram in <em>software-organization</em>. We will work our way from the bottom up; in general, modules only have dependencies on modules beneath them in the figure.</p><p>We first describe the core of the simulator; those components that are common across all protocol, hardware, and environmental models. The simulation core is implemented in <strong>src/core</strong>. Packets are fundamental objects in a network simulator and are implemented in <strong>src/network</strong>. These two simulation modules by themselves are intended to comprise a generic simulation core that can be used by different kinds of networks, not just Internet-based networks.  The above modules of <em>ns-3</em> are independent of specific network and device models, which are covered in subsequent parts of this manual.</p><p>In addition to the above <em>ns-3</em> core, we introduce, also in the initial portion of the manual, two other modules that supplement the core C++-based API.  <em>ns-3</em> programs may access all of the API directly or may make use of a so-called <em>helper API</em> that provides convenient wrappers or encapsulation of low-level API calls. The fact that <em>ns-3</em> programs can be written to two APIs (or a combination thereof) is a fundamental aspect of the simulator. We also describe how Python is supported in <em>ns-3</em> before moving onto specific models of relevance to network simulation.</p><p>The remainder of the manual is focused on documenting the models and supporting capabilities.  The next part focuses on two fundamental objects in <em>ns-3</em>:  the <strong>Node</strong> and <strong>NetDevice</strong>. Two special NetDevice types are designed to support network emulation use cases, and emulation is described next.  The following chapter is devoted to Internet-related models, including the sockets API used by Internet applications. The next chapter covers applications, and the following chapter describes additional support for simulation, such as animators and statistics.</p><p>The project maintains a separate manual devoted to testing and validation of <em>ns-3</em> code (see the <em>ns-3 Testing and Validation manual</em>).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RANDOM VARIABLES</h2>
        <div class="sectioncontent">
<p><em>ns-3</em> contains a built-in pseudo-random number generator (PRNG). It is important for serious users of the simulator to understand the functionality, configuration, and usage of this PRNG, and to decide whether it is sufficient for his or her research use.</p><h3>Quick Overview</h3>
<p><em>ns-3</em> random numbers are provided via instances of <strong>ns3::RandomVariableStream</strong>.</p><ul>
<li><p>by default, <em>ns-3</em> simulations use a fixed seed; if there is any randomness in the simulation, each run of the program will yield identical results unless the seed and/or run number is changed.</p></li><li><p>in <em>ns-3.3</em> and earlier, <em>ns-3</em> simulations used a random seed by default; this marks a change in policy starting with <em>ns-3.4</em>.</p></li><li><p>in <em>ns-3.14</em> and earlier, <em>ns-3</em> simulations used a different wrapper class called <strong>ns3::RandomVariable</strong>.  As of <em>ns-3.15</em>, this class has been replaced by <strong>ns3::RandomVariableStream</strong>; the underlying pseudo-random number generator has not changed.</p></li><li><p>to obtain randomness across multiple simulation runs, you must either set the seed differently or set the run number differently.  To set a seed, call <strong>ns3::RngSeedManager::SetSeed()</strong> at the beginning of the program; to set a run number with the same seed, call <strong>ns3::RngSeedManager::SetRun()</strong> at the beginning of the program; see <em>seeding-and-independent-replications</em>.</p></li><li><p>each RandomVariableStream used in <em>ns-3</em> has a virtual random number generator associated with it; all random variables use either a fixed or random seed based on the use of the global seed (previous bullet);</p></li><li><p>if you intend to perform multiple runs of the same scenario, with different random numbers, please be sure to read the section on how to perform independent replications: <em>seeding-and-independent-replications</em>.</p><p>Read further for more explanation about the random number facility for <em>ns-3</em>.</p></li>
</ul>
<h3>Background</h3>
<p>Simulations use a lot of random numbers; one study found that most network simulations spend as much as 50% of the CPU generating random numbers.  Simulation users need to be concerned with the quality of the (pseudo) random numbers and the independence between different streams of random numbers.</p><p>Users need to be concerned with a few issues, such as:</p><ul>
<li><p>the seeding of the random number generator and whether a simulation outcome is deterministic or not,</p></li><li><p>how to acquire different streams of random numbers that are independent from one another, and</p></li><li><p>how long it takes for streams to cycle</p><p>We will introduce a few terms here:  a RNG provides a long sequence of (pseudo) random numbers. The length of this sequence is called the <em>cycle length</em> or <em>period</em>, after which the RNG will repeat itself. This sequence can be  partitioned into disjoint <em>streams</em>.  A stream of a RNG is a contiguous subset or block of the RNG sequence. For instance, if the RNG period is of length N, and two streams are provided from this RNG, then the first stream might use the first N/2 values and the second stream might produce the second N/2 values.  An important property here is that the two streams are uncorrelated.  Likewise, each stream can be partitioned disjointedly to a number of uncorrelated <em>substreams</em>.  The underlying RNG hopefully produces a pseudo-random sequence of numbers with a very long cycle length, and partitions this into streams and substreams in an efficient manner.</p><p><em>ns-3</em> uses the same underlying random number generator as does <em>ns-2</em>:  the MRG32k3a generator from Pierre L&apos;Ecuyer.  A detailed description can be found in <em>http://www.iro.umontreal.ca/~lecuyer/myftp/papers/streams00.pdf</em>.  The MRG32k3a generator provides 1.8x10^{19} independent streams of random numbers, each of which consists of 2.3x10^{15} substreams. Each substream has a period (<em>i.e.</em>, the number of random numbers before overlap) of 7.6x10^{22}. The period of the entire generator is 3.1x10^{57}.</p><p>Class <strong>ns3::RandomVariableStream</strong> is the public interface to this underlying random number generator.  When users create new random variables (such as <strong>ns3::UniformRandomVariable</strong>, <strong>ns3::ExponentialRandomVariable</strong>, etc.), they create an object that uses one of the distinct, independent streams of the random number generator. Therefore, each object of type <strong>ns3::RandomVariableStream</strong> has, conceptually, its own "virtual" RNG.  Furthermore, each <strong>ns3::RandomVariableStream</strong> can be configured to use one of the set of substreams drawn from the main stream.</p><p>An alternate implementation would be to allow each RandomVariable to have its own (differently seeded) RNG.  However, we cannot guarantee as strongly that the different sequences would be uncorrelated in such a case; hence, we prefer to use a single RNG and streams and substreams from it.</p></li>
</ul>
<h3>Seeding and independent replications</h3>
<p><em>ns-3</em> simulations can be configured to produce deterministic or random results. If the <em>ns-3</em> simulation is configured to use a fixed, deterministic seed with the same run number, it should give the same output each time it is run.</p><p>By default, <em>ns-3</em> simulations use a fixed seed and run number.  These values are stored in two <strong>ns3::GlobalValue</strong> instances: <strong>g_rngSeed</strong> and <strong>g_rngRun</strong>.</p><p>A typical use case is to run a simulation as a sequence of independent trials, so as to compute statistics on a large number of independent runs.  The user can either change the global seed and rerun the simulation, or can advance the substream state of the RNG, which is referred to as incrementing the run number.</p><p>A class <strong>ns3::RngSeedManager</strong> provides an API to control the seeding and run number behavior.  This seeding and substream state setting must be called before any random variables are created; e.g:</p>
<pre>
RngSeedManager::SetSeed (3);  // Changes seed from default of 1 to 3
RngSeedManager::SetRun (7);  // Changes run number from default of 1 to 7
// Now, create random variables
Ptr&lt;UniformRandomVariable&gt; x = CreateObject&lt;UniformRandomVariable&gt; ();
Ptr&lt;ExponentialRandomVariable&gt; y = CreateObject&lt;ExponentialRandomVarlable&gt; ();
...
</pre>
<p>Which is better, setting a new seed or advancing the substream state?  There is no guarantee that the streams produced by two random seeds will not overlap. The only way to guarantee that two streams do not overlap is to use the substream capability provided by the RNG implementation.  <em>Therefore, use the</em> substream capability to produce multiple independent runs of the same simulation. In other words, the more statistically rigorous way to configure multiple independent replications is to use a fixed seed and to advance the run number.  This implementation allows for a maximum of 2.3x10^{15} independent replications using the substreams.</p><p>For ease of use, it is not necessary to control the seed and run number from within the program; the user can set the <strong>NS_GLOBAL_VALUE</strong> environment variable as follows:</p>
<pre>
NS_GLOBAL_VALUE="RngRun=3" ./waf --run program-name
</pre>
<p>Another way to control this is by passing a command-line argument; since this is an <em>ns-3</em> GlobalValue instance, it is equivalently done such as follows:</p>
<pre>
./waf --command-template="%s --RngRun=3" --run program-name
</pre>
<p>or, if you are running programs directly outside of waf:</p>
<pre>
./build/optimized/scratch/program-name --RngRun=3
</pre>
<p>The above command-line variants make it easy to run lots of different runs from a shell script by just passing a different RngRun index.</p>
<h3>Class RandomVariableStream</h3>
<p>All random variables should derive from class <strong>RandomVariable</strong>. This base class provides a few methods for globally configuring the behavior of the random number generator. Derived classes provide API for drawing random variates from the particular distribution being supported.</p><p>Each RandomVariableStream created in the simulation is given a generator that is a new RNGStream from the underlying PRNG. Used in this manner, the L&apos;Ecuyer implementation allows for a maximum of 1.8x10^19 random variables.  Each random variable in a single replication can produce up to 7.6x10^22 random numbers before overlapping.</p>
<h3>Base class public API</h3>
<p>Below are excerpted a few public methods of class <strong>RandomVariableStream</strong> that access the next value in the substream.:</p>
<pre>
/**
 * &#92;brief Returns a random double from the underlying distribution
 * &#92;return A floating point random value
 */
double GetValue (void) const;

/**
 * &#92;brief Returns a random integer from the underlying distribution
 * &#92;return  Integer cast of ::GetValue()
 */
uint32_t GetInteger (void) const;
</pre>
<p>We have already described the seeding configuration above. Different RandomVariable subclasses may have additional API.</p>
<h3>Types of RandomVariables</h3>
<p>The following types of random variables are provided, and are documented in the <em>ns-3</em> Doxygen or by reading <strong>src/core/model/random-variable-stream.h</strong>.  Users can also create their own custom random variables by deriving from class <strong>RandomVariableStream</strong>.</p><ul>
<li><p>class <strong>UniformRandomVariable</strong></p></li><li><p>class <strong>ConstantRandomVariable</strong></p></li><li><p>class <strong>SequentialRandomVariable</strong></p></li><li><p>class <strong>ExponentialRandomVariable</strong></p></li><li><p>class <strong>ParetoRandomVariable</strong></p></li><li><p>class <strong>WeibullRandomVariable</strong></p></li><li><p>class <strong>NormalRandomVariable</strong></p></li><li><p>class <strong>LogNormalRandomVariable</strong></p></li><li><p>class <strong>GammaRandomVariable</strong></p></li><li><p>class <strong>ErlangRandomVariable</strong></p></li><li><p>class <strong>TriangularRandomVariable</strong></p></li><li><p>class <strong>ZipfRandomVariable</strong></p></li><li><p>class <strong>ZetaRandomVariable</strong></p></li><li><p>class <strong>DeterministicRandomVariable</strong></p></li><li><p>class <strong>EmpiricalRandomVariable</strong></p></li>
</ul>
<h3>Semantics of RandomVariableStream objects</h3>
<p>RandomVariableStream objects derive from <strong>ns3::Object</strong> and are handled by smart pointers.</p><p>RandomVariableStream instances can also be used in <em>ns-3</em> attributes, which means that values can be set for them through the <em>ns-3</em> attribute system. An example is in the propagation models for WifiNetDevice::</p>
<pre>
TypeId
RandomPropagationDelayModel::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::RandomPropagationDelayModel")
    .SetParent&lt;PropagationDelayModel&gt; ()
    .AddConstructor&lt;RandomPropagationDelayModel&gt; ()
    .AddAttribute ("Variable",
                   "The random variable which generates random delays (s).",
                   StringValue ("ns3::UniformRandomVariable"),
                   MakePointerAccessor (&RandomPropagationDelayModel::m_variable),
                   MakePointerChecker&lt;RandomVariableStream&gt; ())
    ;
  return tid;
}
</pre>
<p>Here, the <em>ns-3</em> user can change the default random variable for this delay model (which is a UniformRandomVariable ranging from 0 to 1) through the attribute system.</p>
<h3>Using other PRNG</h3>
<p>There is presently no support for substituting a different underlying random number generator (e.g., the GNU Scientific Library or the Akaroa package).  Patches are welcome.</p>
<h3>Setting the stream number</h3>
<p>The underlying MRG32k3a generator provides 2^64 independent streams. In ns-3, these are assigned sequentially starting from the first stream as new RandomVariableStream instances make their first call to GetValue().</p><p>As a result of how these RandomVariableStream objects are assigned to underlying streams, the assignment is sensitive to perturbations of the simulation configuration.  The consequence is that if any aspect of the simulation configuration is changed, the mapping of RandomVariables to streams may (or may not) change.</p><p>As a concrete example, a user running a comparative study between routing protocols may find that the act of changing one routing protocol for another will notice that the underlying mobility pattern also changed.</p><p>Starting with ns-3.15, some control has been provided to users to allow users to optionally fix the assignment of selected RandomVariableStream objects to underlying streams.  This is the <strong>Stream</strong> attribute, part of the base class RandomVariableStream.</p><p>By partitioning the existing sequence of streams from before:</p>
<pre>
&lt;--------------------------------------------------------------------------&gt;
stream 0                                                     stream (2^64 - 1)
</pre>
<p>into two equal-sized sets:</p>
<pre>
&lt;---------------------------------------------------------------------------&gt;
 ^                             ^^                                    ^
 |                             ||                                    |
stream 0       stream (2^63 - 1) stream 2^63          stream (2^64 - 1)
&lt;- automatically assigned -----&gt;&lt;-------- assigned by user-----------&gt;
</pre>
<p>The first 2^63 streams continue to be automatically assigned, while the last 2^63 are given stream indices starting with zero up to 2^63-1.</p><p>The assignment of streams to a fixed stream number is optional; instances of RandomVariableStream that do not have a stream value assigned will be assigned the next one from the pool of automatic streams.</p><p>To fix a RandomVariableStream to a particular underlying stream, assign its <strong>Stream</strong> attribute to a non-negative integer (the default value of -1 means that a value will be automatically allocated).</p>
<h3>Publishing your results</h3>
<p>When you publish simulation results, a key piece of configuration information that you should always state is how you used the the random number generator.</p><ul>
<li><p>what seeds you used,</p></li><li><p>what RNG you used if not the default,</p></li><li><p>how were independent runs performed,</p></li><li><p>for large simulations, how did you check that you did not cycle.</p><p>It is incumbent on the researcher publishing results to include enough information to allow others to reproduce his or her results. It is also incumbent on the researcher to convince oneself that the random numbers used were statistically valid, and to state in the paper why such confidence is assumed.</p></li>
</ul>
<h3>Summary</h3>
<p>Let&apos;s review what things you should do when creating a simulation.</p><ul>
<li><p>Decide whether you are running with a fixed seed or random seed; a fixed seed is the default,</p></li><li><p>Decide how you are going to manage independent replications, if applicable,</p></li><li><p>Convince yourself that you are not drawing more random values than the cycle length, if you are running a very long simulation, and</p></li><li><p>When you publish, follow the guidelines above about documenting your use of the random number generator.</p></li>
</ul>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EVENTS AND SIMULATOR</h2>
        <div class="sectioncontent">
<p><em>ns-3</em> is a discrete-event network simulator.  Conceptually, the simulator keeps track of a number of events that are scheduled to execute at a specified simulation time.  The job of the simulator is to execute the events in sequential time order.  Once the completion of an event occurs, the simulator will move to the next event (or will exit if there are no more events in the event queue).  If, for example, an event scheduled for simulation time "100 seconds" is executed, and the next event is not scheduled until "200 seconds", the simulator will immediately jump from 100 seconds to 200 seconds (of simulation time) to execute the next event. This is what is meant by "discrete-event" simulator.</p><p>To make this all happen, the simulator needs a few things:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>a simulator object that can access an event queue where events are stored and that can manage the execution of events</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>a scheduler responsible for inserting and removing events from the queue</p>
  </dd>
  <dt>
    3.
  </dt>
  <dd>
    <p>a way to represent simulation time</p>
  </dd>
  <dt>
    4.
  </dt>
  <dd>
    <p>the events themselves</p><p>This chapter of the manual describes these fundamental objects (simulator, scheduler, time, event) and how they are used.</p>
  </dd>

</dl>
<h3>Event</h3>
<p><em>To be completed</em></p>
<h3>Simulator</h3>
<p>The Simulator class is the public entry point to access event scheduling facilities. Once a couple of events have been scheduled to start the simulation, the user can start to execute them by entering the simulator main loop (call Simulator::Run). Once the main loop starts running, it will sequentially execute all scheduled events in order from oldest to most recent until there are either no more events left in the event queue or Simulator::Stop has been called.</p><p>To schedule events for execution by the simulator main loop, the Simulator class provides the Simulator::Schedule* family of functions.</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>Handling event handlers with different signatures</p><p>These functions are declared and implemented as C++ templates to handle automatically the wide variety of C++ event handler signatures used in the wild. For example, to schedule an event to execute 10 seconds in the future, and invoke a C++ method or function with specific arguments, you might write this:</p>
<pre>
void handler (int arg0, int arg1)
{
  std::cout &lt;&lt; "handler called with argument arg0=" &lt;&lt; arg0 &lt;&lt; " and
     arg1=" &lt;&lt; arg1 &lt;&lt; std::endl;
}

Simulator::Schedule(Seconds(10), &handler, 10, 5);
</pre>
<p>Which will output:</p>
<pre>
handler called with argument arg0=10 and arg1=5
</pre>
<p>Of course, these C++ templates can also handle transparently member methods on C++ objects:</p><p><em>To be completed:  member method example</em></p><p>Notes:</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>the ns-3 Schedule methods recognize automatically functions and methods only if they take less than 5 arguments. If you need them to support more arguments, please, file a bug report.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>Readers familiar with the term &apos;fully-bound functors&apos; will recognize the Simulator::Schedule methods as a way to automatically construct such objects.</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>Common scheduling operations</p><p>The Simulator API was designed to make it really simple to schedule most events. It provides three variants to do so (ordered from most commonly used to least commonly used):</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>Schedule methods which allow you to schedule an event in the future by providing the delay between the current simulation time and the expiration date of the target event.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>ScheduleNow methods which allow you to schedule an event for the current simulation time: they will execute _after_ the current event is finished executing but _before_ the simulation time is changed for the next event.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>ScheduleDestroy methods which allow you to hook in the shutdown process of the Simulator to cleanup simulation resources: every &apos;destroy&apos; event is executed when the user calls the Simulator::Destroy method.</p>
  </dd>
  <dt>
    3.
  </dt>
  <dd>
    <p>Maintaining the simulation context</p><p>There are two basic ways to schedule events, with and without <em>context</em>. What does this mean?</p>
<pre>
Simulator::Schedule (Time const &time, MEM mem_ptr, OBJ obj);
</pre>
<p>vs.</p>
<pre>
Simulator::ScheduleWithContext (uint32_t context, Time const &time, MEM mem_ptr, OBJ obj);
</pre>
<p>Readers who invest time and effort in developing or using a non-trivial simulation model will know the value of the ns-3 logging framework to debug simple and complex simulations alike. One of the important features that is provided by this logging framework is the automatic display of the network node id associated with the &apos;currently&apos; running event.</p><p>The node id of the currently executing network node is in fact tracked by the Simulator class. It can be accessed with the Simulator::GetContext method which returns the &apos;context&apos; (a 32-bit integer) associated and stored in the currently-executing event. In some rare cases, when an event is not associated with a specific network node, its &apos;context&apos; is set to 0xffffffff.</p><p>To associate a context to each event, the Schedule, and ScheduleNow methods automatically reuse the context of the currently-executing event as the context of the event scheduled for execution later.</p><p>In some cases, most notably when simulating the transmission of a packet from a node to another, this behavior is undesirable since the expected context of the reception event is that of the receiving node, not the sending node. To avoid this problem, the Simulator class provides a specific schedule method: ScheduleWithContext which allows one to provide explicitly the node id of the receiving node associated with the receive event.</p><p><em>XXX: code example</em></p><p>In some very rare cases, developers might need to modify or understand how the context (node id) of the first event is set to that of its associated node. This is accomplished by the NodeList class: whenever a new node is created, the NodeList class uses ScheduleWithContext to schedule a &apos;initialize&apos; event for this node. The &apos;initialize&apos; event thus executes with a context set to that of the node id and can use the normal variety of Schedule methods. It invokes the Node::Initialize method which propagates the &apos;initialize&apos; event by calling the DoInitialize method for each object associated with the node. The DoInitialize method overridden in some of these objects (most notably in the Application base class) will schedule some events (most notably Application::StartApplication) which will in turn scheduling traffic generation events which will in turn schedule network-level events.</p><p>Notes:</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>Users need to be careful to propagate DoInitialize methods across objects by calling Initialize explicitely on their member objects</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>The context id associated with each ScheduleWithContext method has other uses beyond logging: it is used by an experimental branch of ns-3 to perform parallel simulation on multicore systems using multithreading.</p><p>The Simulator::* functions do not know what the context is: they merely make sure that whatever context you specify with ScheduleWithContext is available when the corresponding event executes with ::GetContext.</p><p>It is up to the models implemented on top of Simulator::* to interpret the context value. In ns-3, the network models interpret the context as the node id of the node which generated an event. This is why it is important to call ScheduleWithContext in ns3::Channel subclasses because we are generating an event from node i to node j and we want to make sure that the event which will run on node j has the right context.</p>
  </dd>

</dl>

<h3>Time</h3>
<p><em>To be completed</em></p>
<h3>Scheduler</h3>
<p><em>To be completed</em></p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CALLBACKS</h2>
        <div class="sectioncontent">
<p>Some new users to <em>ns-3</em> are unfamiliar with an extensively used programming idiom used throughout the code: the <em>ns-3 callback</em>. This chapter provides some motivation on the callback, guidance on how to use it, and details on its implementation.</p><h3>Callbacks Motivation</h3>
<p>Consider that you have two simulation models A and B, and you wish to have them pass information between them during the simulation. One way that you can do that is that you can make A and B each explicitly knowledgeable about the other, so that they can invoke methods on each other:</p>
<pre>
class A {
public:
  void ReceiveInput ( // parameters );
  ...
}

(in another source file:)

class B {
public:
  void DoSomething (void);
  ...

private:
  A* a_instance; // pointer to an A
}

void
B::DoSomething()
{
  // Tell a_instance that something happened
  a_instance-&gt;ReceiveInput ( // parameters);
  ...
}
</pre>
<p>This certainly works, but it has the drawback that it introduces a dependency on A and B to know about the other at compile time (this makes it harder to have independent compilation units in the simulator) and is not generalized; if in a later usage scenario, B needs to talk to a completely different C object, the source code for B needs to be changed to add a <strong>c_instance</strong> and so forth. It is easy to see that this is a brute force mechanism of communication that can lead to programming cruft in the models.</p><p>This is not to say that objects should not know about one another if there is a hard dependency between them, but that often the model can be made more flexible if its interactions are less constrained at compile time.</p><p>This is not an abstract problem for network simulation research, but rather it has been a source of problems in previous simulators, when researchers want to extend or modify the system to do different things (as they are apt to do in research). Consider, for example, a user who wants to add an IPsec security protocol sublayer between TCP and IP:</p>
<pre>
------------                   -----------
|   TCP    |                   |  TCP    |
------------                   -----------
     |           becomes -&gt;        |
-----------                    -----------
|   IP    |                    | IPsec   |
-----------                    -----------
                                   |
                               -----------
                               |   IP    |
                               -----------
</pre>
<p>If the simulator has made assumptions, and hard coded into the code, that IP always talks to a transport protocol above, the user may be forced to hack the system to get the desired interconnections. This is clearly not an optimal way to design a generic simulator.</p>
<h3>Callbacks Background</h3>
<p><strong>NOTE:</strong> Readers familiar with programming callbacks may skip this tutorial section.</p><p>The basic mechanism that allows one to address the problem above is known as a <em>callback</em>. The ultimate goal is to allow one piece of code to call a function (or method in C++) without any specific inter-module dependency.</p><p>This ultimately means you need some kind of indirection -- you treat the address of the called function as a variable.  This variable is called a pointer-to-function variable. The relationship between function and pointer-to-function pointer is really no different that that of object and pointer-to-object.</p><p>In C the canonical example of a pointer-to-function is a pointer-to-function-returning-integer (PFI). For a PFI taking one int parameter, this could be declared like,:</p>
<pre>
int (*pfi)(int arg) = 0;
</pre>
<p>What you get from this is a variable named simply <strong>pfi</strong> that is initialized to the value 0. If you want to initialize this pointer to something meaningful, you have to have a function with a matching signature. In this case:</p>
<pre>
int MyFunction (int arg) {}
</pre>
<p>If you have this target, you can initialize the variable to point to your function like:</p>
<pre>
pfi = MyFunction;
</pre>
<p>You can then call MyFunction indirectly using the more suggestive form of the call:</p>
<pre>
int result = (*pfi) (1234);
</pre>
<p>This is suggestive since it looks like you are dereferencing the function pointer just like you would dereference any pointer. Typically, however, people take advantage of the fact that the compiler knows what is going on and will just use a shorter form:</p>
<pre>
int result = pfi (1234);
</pre>
<p>Notice that the function pointer obeys value semantics, so you can pass it around like any other value. Typically, when you use an asynchronous interface you will pass some entity like this to a function which will perform an action and <em>call back</em> to let you know it completed. It calls back by following the indirection and executing the provided function.</p><p>In C++ you have the added complexity of objects. The analogy with the PFI above means you have a pointer to a member function returning an int (PMI) instead of the pointer to function returning an int (PFI).</p><p>The declaration of the variable providing the indirection looks only slightly different:</p>
<pre>
int (MyClass::*pmi) (int arg) = 0;
</pre>
<p>This declares a variable named <strong>pmi</strong> just as the previous example declared a variable named <strong>pfi</strong>. Since the will be to call a method of an instance of a particular class, one must declare that method in a class:</p>
<pre>
class MyClass {
public:
  int MyMethod (int arg);
};
</pre>
<p>Given this class declaration, one would then initialize that variable like this:</p>
<pre>
pmi = &MyClass::MyMethod;
</pre>
<p>This assigns the address of the code implementing the method to the variable, completing the indirection. In order to call a method, the code needs a <strong>this</strong> pointer. This, in turn, means there must be an object of MyClass to refer to. A simplistic example of this is just calling a method indirectly (think virtual function):</p>
<pre>
int (MyClass::*pmi) (int arg) = 0;  // Declare a PMI
pmi = &MyClass::MyMethod;           // Point at the implementation code

MyClass myClass;                    // Need an instance of the class
(myClass.*pmi) (1234);              // Call the method with an object ptr
</pre>
<p>Just like in the C example, you can use this in an asynchronous call to another module which will <em>call back</em> using a method and an object pointer. The straightforward extension one might consider is to pass a pointer to the object and the PMI variable. The module would just do:</p>
<pre>
(*objectPtr.*pmi) (1234);
</pre>
<p>to execute the callback on the desired object.</p><p>One might ask at this time, <em>what&apos;s the point</em>? The called module will have to understand the concrete type of the calling object in order to properly make the callback. Why not just accept this, pass the correctly typed object pointer and do <strong>object-&gt;Method(1234)</strong> in the code instead of the callback?  This is precisely the problem described above. What is needed is a way to decouple the calling function from the called class completely. This requirement led to the development of the <em>Functor</em>.</p><p>A functor is the outgrowth of something invented in the 1960s called a closure. It is basically just a packaged-up function call, possibly with some state.</p><p>A functor has two parts, a specific part and a generic part, related through inheritance. The calling code (the code that executes the callback) will execute a generic overloaded <strong>operator ()</strong> of a generic functor to cause the callback to be called. The called code (the code that wants to be called back) will have to provide a specialized implementation of the <strong>operator ()</strong> that performs the class-specific work that caused the close-coupling problem above.</p><p>With the specific functor and its overloaded <strong>operator ()</strong> created, the called code then gives the specialized code to the module that will execute the callback (the calling code).</p><p>The calling code will take a generic functor as a parameter, so an implicit cast is done in the function call to convert the specific functor to a generic functor.  This means that the calling module just needs to understand the generic functor type. It is decoupled from the calling code completely.</p><p>The information one needs to make a specific functor is the object pointer and the pointer-to-method address.</p><p>The essence of what needs to happen is that the system declares a generic part of the functor:</p>
<pre>
template &lt;typename T&gt;
class Functor
{
public:
  virtual int operator() (T arg) = 0;
};
</pre>
<p>The caller defines a specific part of the functor that really is just there to implement the specific <strong>operator()</strong> method:</p>
<pre>
template &lt;typename T, typename ARG&gt;
class SpecificFunctor : public Functor&lt;ARG&gt;
{
public:
  SpecificFunctor(T* p, int (T::*_pmi)(ARG arg))
  {
    m_p = p;
    m_pmi = _pmi;
  }

  virtual int operator() (ARG arg)
  {
    (*m_p.*m_pmi)(arg);
  }
private:
  int (T::*m_pmi)(ARG arg);
  T* m_p;
};
</pre>
<p>Here is an example of the usage:</p>
<pre>
class A
{
public:
A (int a0) : a (a0) {}
int Hello (int b0)
{
  std::cout &lt;&lt; "Hello from A, a = " &lt;&lt; a &lt;&lt; " b0 = " &lt;&lt; b0 &lt;&lt; std::endl;
}
int a;
};

int main()
{
  A a(10);
  SpecificFunctor&lt;A, int&gt; sf(&a, &A::Hello);
  sf(5);
}
</pre>
<p><strong>NOTE:</strong> The previous code is not real ns-3 code.  It is simplistic example code used only to illustrate the concepts involved and to help you understand the system more.  Do not expect to find this code anywhere in the ns-3 tree.</p><p>Notice that there are two variables defined in the class above.  The m_p variable is the object pointer and m_pmi is the variable containing the address of the function to execute.</p><p>Notice that when <strong>operator()</strong> is called, it in turn calls the method provided with the object pointer using the C++ PMI syntax.</p><p>To use this, one could then declare some model code that takes a generic functor as a parameter:</p>
<pre>
void LibraryFunction (Functor functor);
</pre>
<p>The code that will talk to the model would build a specific functor and pass it to <strong>LibraryFunction</strong>:</p>
<pre>
MyClass myClass;
SpecificFunctor&lt;MyClass, int&gt; functor (&myclass, MyClass::MyMethod);
</pre>
<p>When <strong>LibraryFunction</strong> is done, it executes the callback using the <strong>operator()</strong> on the generic functor it was passed, and in this particular case, provides the integer argument:</p>
<pre>
void
LibraryFunction (Functor functor)
{
  // Execute the library function
  functor(1234);
}
</pre>
<p>Notice that <strong>LibraryFunction</strong> is completely decoupled from the specific type of the client.  The connection is made through the Functor polymorphism.</p><p>The Callback API in <em>ns-3</em> implements object-oriented callbacks using the functor mechanism.  This callback API, being based on C++ templates, is type-safe; that is, it performs static type checks to enforce proper signature compatibility between callers and callees.  It is therefore more type-safe to use than traditional function pointers, but the syntax may look imposing at first.  This section is designed to walk you through the Callback system so that you can be comfortable using it in <em>ns-3</em>.</p>
<h3>Using the Callback API</h3>
<p>The Callback API is fairly minimal, providing only two services:</p><p>1. callback type declaration: a way to declare a type of callback with a given signature, and,</p><p>2. callback instantiation: a way to instantiate a template-generated forwarding callback which can forward any calls to another C++ class member method or C++ function.</p><p>This is best observed via walking through an example, based on <strong>samples/main-callback.cc</strong>.</p>
<h3>Using the Callback API with static functions</h3>
<p>Consider a function:</p>
<pre>
static double
CbOne (double a, double b)
{
  std::cout &lt;&lt; "invoke cbOne a=" &lt;&lt; a &lt;&lt; ", b=" &lt;&lt; b &lt;&lt; std::endl;
  return a;
}
</pre>
<p>Consider also the following main program snippet:</p>
<pre>
int main (int argc, char *argv[])
{
  // return type: double
  // first arg type: double
  // second arg type: double
  Callback&lt;double, double, double&gt; one;
}
</pre>
<p>This is an example of a C-style callback -- one which does not include or need a <strong>this</strong> pointer.  The function template <strong>Callback</strong> is essentially the declaration of the variable containing the pointer-to-function.  In the example above, we explicitly showed a pointer to a function that returned an integer and took a single integer as a parameter,  The <strong>Callback</strong> template function is a generic version of that -- it is used to declare the type of a callback.</p><p><strong>NOTE:</strong> Readers unfamiliar with C++ templates may consult <em>http://www.cplusplus.com/doc/tutorial/templates/</em>.</p><p>The <strong>Callback</strong> template requires one mandatory argument (the return type of the function to be assigned to this callback) and up to five optional arguments, which each specify the type of the arguments (if your particular callback function has more than five arguments, then this can be handled by extending the callback implementation).</p><p>So in the above example, we have a declared a callback named "one" that will eventually hold a function pointer.  The signature of the function that it will hold must return double and must support two double arguments.  If one tries to pass a function whose signature does not match the declared callback, a compilation error will occur.  Also, if one tries to assign to a callback an incompatible one, compilation will succeed but a run-time NS_FATAL_ERROR will be raised.  The sample program <strong>src/core/examples/main-callback.cc</strong> demonstrates both of these error cases at the end of the <strong>main()</strong> program.</p><p>Now, we need to tie together this callback instance and the actual target function (CbOne).  Notice above that CbOne has the same function signature types as the callback-- this is important.  We can pass in any such properly-typed function to this callback.  Let&apos;s look at this more closely:</p>
<pre>
static double CbOne (double a, double b) {}
          ^           ^          ^
          |        ---|    ------|
          |        |       |
Callback&lt;double, double, double&gt; one;
</pre>
<p>You can only bind a function to a callback if they have the matching signature. The first template argument is the return type, and the additional template arguments are the types of the arguments of the function signature.</p><p>Now, let&apos;s bind our callback "one" to the function that matches its signature:</p>
<pre>
// build callback instance which points to cbOne function
one = MakeCallback (&CbOne);
</pre>
<p>This call to <strong>MakeCallback</strong> is, in essence, creating one of the specialized functors mentioned above.  The variable declared using the <strong>Callback</strong> template function is going to be playing the part of the generic functor.  The assignment <strong>one = MakeCallback (&CbOne)</strong> is the cast that converts the specialized functor known to the callee to a generic functor known to the caller.</p><p>Then, later in the program, if the callback is needed, it can be used as follows:</p>
<pre>
NS_ASSERT (!one.IsNull ());

// invoke cbOne function through callback instance
double retOne;
retOne = one (10.0, 20.0);
</pre>
<p>The check for <strong>IsNull()</strong> ensures that the callback is not null -- that there is a function to call behind this callback.  Then, <strong>one()</strong> executes the generic <strong>operator()</strong> which is really overloaded with a specific implementation of <strong>operator()</strong> and returns the same result as if <strong>CbOne()</strong> had been called directly.</p>
<h3>Using the Callback API with member functions</h3>
<p>Generally, you will not be calling static functions but instead public member functions of an object.  In this case, an extra argument is needed to the MakeCallback function, to tell the system on which object the function should be invoked.  Consider this example, also from main-callback.cc:</p>
<pre>
class MyCb {
public:
  int CbTwo (double a) {
      std::cout &lt;&lt; "invoke cbTwo a=" &lt;&lt; a &lt;&lt; std::endl;
      return -5;
  }
};

int main ()
{
  ...
  // return type: int
  // first arg type: double
  Callback&lt;int, double&gt; two;
  MyCb cb;
  // build callback instance which points to MyCb::cbTwo
  two = MakeCallback (&MyCb::CbTwo, &cb);
  ...
}
</pre>
<p>Here, we pass an additional object pointer to the <strong>MakeCallback&lt;&gt;</strong> function. Recall from the background section above that <strong>Operator()</strong> will use the pointer to member syntax when it executes on an object:</p>
<pre>
virtual int operator() (ARG arg)
{
  (*m_p.*m_pmi)(arg);
}
</pre>
<p>And so we needed to provide the two variables (<strong>m_p</strong> and <strong>m_pmi</strong>) when we made the specific functor.  The line:</p>
<pre>
two = MakeCallback (&MyCb::CbTwo, &cb);
</pre>
<p>does precisely that.  In this case, when <strong>two ()</strong> is invoked:</p>
<pre>
int result = two (1.0);
</pre>
<p>will result in a call tothe <strong>CbTwo</strong> member function (method) on the object pointed to by <strong>&cb</strong>.</p>
<h3>Building Null Callbacks</h3>
<p>It is possible for callbacks to be null; hence it may be wise to check before using them.  There is a special construct for a null callback, which is preferable to simply passing "0" as an argument; it is the <strong>MakeNullCallback&lt;&gt;</strong> construct:</p>
<pre>
two = MakeNullCallback&lt;int, double&gt; ();
NS_ASSERT (two.IsNull ());
</pre>
<p>Invoking a null callback is just like invoking a null function pointer: it will crash at runtime.</p>
<h3>Bound Callbacks</h3>
<p>A very useful extension to the functor concept is that of a Bound Callback. Previously it was mentioned that closures were originally function calls packaged up for later execution.  Notice that in all of the Callback descriptions above, there is no way to package up any parameters for use later -- when the <strong>Callback</strong> is called via <strong>operator()</strong>.  All of the parameters are provided by the calling function.</p><p>What if it is desired to allow the client function (the one that provides the callback) to provide some of the parameters?  <em>Alexandrescu</em> calls the process of allowing a client to specify one of the parameters <em>"binding"</em>.  One of the parameters of <strong>operator()</strong> has been bound (fixed) by the client.</p><p>Some of our pcap tracing code provides a nice example of this.  There is a function that needs to be called whenever a packet is received.  This function calls an object that actually writes the packet to disk in the pcap file format.  The signature of one of these functions will be:</p>
<pre>
static void DefaultSink (Ptr&lt;PcapFileWrapper&gt; file, Ptr&lt;const Packet&gt; p);
</pre>
<p>The static keyword means this is a static function which does not need a <strong>this</strong> pointer, so it will be using C-style callbacks.  We don&apos;t want the calling code to have to know about anything but the Packet.  What we want in the calling code is just a call that looks like:</p>
<pre>
m_promiscSnifferTrace (m_currentPkt);
</pre>
<p>What we want to do is to <em>bind</em> the <strong>Ptr&lt;PcapFileWriter&gt; file</strong> to the specific callback implementation when it is created and arrange for the <strong>operator()</strong> of the Callback to provide that parameter for free.</p><p>We provide the <strong>MakeBoundCallback</strong> template function for that purpose.  It takes the same parameters as the <strong>MakeCallback</strong> template function but also takes the parameters to be bound.  In the case of the example above:</p>
<pre>
MakeBoundCallback (&DefaultSink, file);
</pre>
<p>will create a specific callback implementation that knows to add in the extra bound arguments.  Conceptually, it extends the specific functor described above with one or more bound arguments:</p>
<pre>
template &lt;typename T, typename ARG, typename BOUND_ARG&gt;
class SpecificFunctor : public Functor
 {
 public:
    SpecificFunctor(T* p, int (T::*_pmi)(ARG arg), BOUND_ARG boundArg)
    {
      m_p = p;
      m_pmi = pmi;
      m_boundArg = boundArg;
    }

    virtual int operator() (ARG arg)
    {
      (*m_p.*m_pmi)(m_boundArg, arg);
    }
private:
    void (T::*m_pmi)(ARG arg);
    T* m_p;
    BOUND_ARG m_boundArg;
 };
</pre>
<p>You can see that when the specific functor is created, the bound argument is saved in the functor / callback object itself.  When the <strong>operator()</strong> is invoked with the single parameter, as in:</p>
<pre>
m_promiscSnifferTrace (m_currentPkt);
</pre>
<p>the implementation of <strong>operator()</strong> adds the bound parameter into the actual function call:</p>
<pre>
(*m_p.*m_pmi)(m_boundArg, arg);
</pre>

<h3>Traced Callbacks</h3>
<p><em>Placeholder subsection</em></p>
<h3>Callback locations in ns-3</h3>
<p>Where are callbacks frequently used in <em>ns-3</em>?  Here are some of the more visible ones to typical users:</p><ul>
<li><p>Socket API</p></li><li><p>Layer-2/Layer-3 API</p></li><li><p>Tracing subsystem</p></li><li><p>API between IP and routing subsystems</p></li>
</ul>
<h3>Implementation details</h3>
<p>The code snippets above are simplistic and only designed to illustrate the mechanism itself.  The actual Callback code is quite complicated and very template-intense and a deep understanding of the code is not required.  If interested, expert users may find the following useful.</p><p>The code was originally written based on the techniques described in <em>http://www.codeproject.com/cpp/TTLFunction.asp</em>. It was subsequently rewritten to follow the architecture outlined in <em>Modern C++ Design, Generic Programming and Design Patterns Applied, Alexandrescu, chapter 5, Generalized Functors</em>.</p><p>This code uses:</p><ul>
<li><p>default template parameters to saves users from having to specify empty parameters when the number of parameters is smaller than the maximum supported number</p></li><li><p>the pimpl idiom: the Callback class is passed around by value and delegates the crux of the work to its pimpl pointer.</p></li><li><p>two pimpl implementations which derive from CallbackImpl FunctorCallbackImpl can be used with any functor-type while MemPtrCallbackImpl can be used with pointers to member functions.</p></li><li><p>a reference list implementation to implement the Callback&apos;s value semantics.</p><p>This code most notably departs from the Alexandrescu implementation in that it does not use type lists to specify and pass around the types of the callback arguments. Of course, it also does not use copy-destruction semantics and relies on a reference list rather than autoPtr to hold the pointer.</p></li>
</ul>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OBJECT MODEL</h2>
        <div class="sectioncontent">
<p><em>ns-3</em> is fundamentally a C++ object system. Objects can be declared and instantiated as usual, per C++ rules. <em>ns-3</em> also adds some features to traditional C++ objects, as described below, to provide greater functionality and features. This manual chapter is intended to introduce the reader to the <em>ns-3</em> object model.</p><p>This section describes the C++ class design for <em>ns-3</em> objects. In brief, several design patterns in use include classic object-oriented design (polymorphic interfaces and implementations), separation of interface and implementation, the non-virtual public interface design pattern, an object aggregation facility, and reference counting for memory management. Those familiar with component models such as COM or Bonobo will recognize elements of the design in the <em>ns-3</em> object aggregation model, although the <em>ns-3</em> design is not strictly in accordance with either.</p><h3>Object-oriented behavior</h3>
<p>C++ objects, in general, provide common object-oriented capabilities (abstraction, encapsulation, inheritance, and polymorphism) that are part of classic object-oriented design. <em>ns-3</em> objects make use of these properties; for instance::</p>
<pre>
class Address
{
public:
  Address ();
  Address (uint8_t type, const uint8_t *buffer, uint8_t len);
  Address (const Address & address);
  Address &operator = (const Address &address);
  ...
private:
  uint8_t m_type;
  uint8_t m_len;
  ...
};
</pre>

<h3>Object base classes</h3>
<p>There are three special base classes used in <em>ns-3</em>. Classes that inherit from these base classes can instantiate objects with special properties. These base classes are:</p><ul>
<li><p>class <strong>Object</strong></p></li><li><p>class <strong>ObjectBase</strong></p></li><li><p>class <strong>SimpleRefCount</strong></p><p>It is not required that <em>ns-3</em> objects inherit from these class, but those that do get special properties. Classes deriving from class <strong>Object</strong> get the following properties.</p></li><li><p>the <em>ns-3</em> type and attribute system (see <em>Attributes</em>)</p></li><li><p>an object aggregation system</p></li><li><p>a smart-pointer reference counting system (class Ptr)</p><p>Classes that derive from class <strong>ObjectBase</strong> get the first two properties above, but do not get smart pointers. Classes that derive from class <strong>SimpleRefCount</strong>: get only the smart-pointer reference counting system.</p><p>In practice, class <strong>Object</strong> is the variant of the three above that the <em>ns-3</em> developer will most commonly encounter.</p></li>
</ul>
<h3>Memory management and class Ptr</h3>
<p>Memory management in a C++ program is a complex process, and is often done incorrectly or inconsistently. We have settled on a reference counting design described as follows.</p><p>All objects using reference counting maintain an internal reference count to determine when an object can safely delete itself. Each time that a pointer is obtained to an interface, the object&apos;s reference count is incremented by calling <strong>Ref()</strong>. It is the obligation of the user of the pointer to explicitly <strong>Unref()</strong> the pointer when done. When the reference count falls to zero, the object is deleted.</p><ul>
<li><p>When the client code obtains a pointer from the object itself through object creation, or via GetObject, it does not have to increment the reference count.</p></li><li><p>When client code obtains a pointer from another source (e.g., copying a pointer) it must call <strong>Ref()</strong> to increment the reference count.</p></li><li><p>All users of the object pointer must call <strong>Unref()</strong> to release the reference.</p><p>The burden for calling <strong>Unref()</strong> is somewhat relieved by the use of the reference counting smart pointer class described below.</p><p>Users using a low-level API who wish to explicitly allocate non-reference-counted objects on the heap, using operator new, are responsible for deleting such objects.</p></li>
</ul>
<h3>Reference counting smart pointer (Ptr)</h3>
<p>Calling <strong>Ref()</strong> and <strong>Unref()</strong> all the time would be cumbersome, so <em>ns-3</em> provides a smart pointer class <strong>Ptr</strong> similar to <strong>Boost::intrusive_ptr</strong>. This smart-pointer class assumes that the underlying type provides a pair of <strong>Ref</strong> and <strong>Unref</strong> methods that are expected to increment and decrement the internal refcount of the object instance.</p><p>This implementation allows you to manipulate the smart pointer as if it was a normal pointer: you can compare it with zero, compare it against other pointers, assign zero to it, etc.</p><p>It is possible to extract the raw pointer from this smart pointer with the <strong>GetPointer()</strong> and <strong>PeekPointer()</strong> methods.</p><p>If you want to store a newed object into a smart pointer, we recommend you to use the CreateObject template functions to create the object and store it in a smart pointer to avoid memory leaks. These functions are really small convenience functions and their goal is just to save you a small bit of typing.</p>
<h3>CreateObject and Create</h3>
<p>Objects in C++ may be statically, dynamically, or automatically created.  This holds true for <em>ns-3</em> also, but some objects in the system have some additional frameworks available. Specifically, reference counted objects are usually allocated using a templated Create or CreateObject method, as follows.</p><p>For objects deriving from class <strong>Object</strong>::</p>
<pre>
Ptr&lt;WifiNetDevice&gt; device = CreateObject&lt;WifiNetDevice&gt; ();
</pre>
<p>Please do not create such objects using <strong>operator new</strong>; create them using <strong>CreateObject()</strong> instead.</p><p>For objects deriving from class <strong>SimpleRefCount</strong>, or other objects that support usage of the smart pointer class, a templated helper function is available and recommended to be used::</p>
<pre>
Ptr&lt;B&gt; b = Create&lt;B&gt; ();
</pre>
<p>This is simply a wrapper around operator new that correctly handles the reference counting system.</p><p>In summary, use <strong>Create&lt;B&gt;</strong> if B is not an object but just uses reference counting (e.g. <strong>Packet</strong>), and use <strong>CreateObject&lt;B&gt;</strong> if B derives from <strong>ns3::Object</strong>.</p>
<h3>Aggregation</h3>
<p>The <em>ns-3</em> object aggregation system is motivated in strong part by a recognition that a common use case for <em>ns-2</em> has been the use of inheritance and polymorphism to extend protocol models. For instance, specialized versions of TCP such as RenoTcpAgent derive from (and override functions from) class TcpAgent.</p><p>However, two problems that have arisen in the <em>ns-2</em> model are downcasts and "weak base class." Downcasting refers to the procedure of using a base class pointer to an object and querying it at run time to find out type information, used to explicitly cast the pointer to a subclass pointer so that the subclass API can be used. Weak base class refers to the problems that arise when a class cannot be effectively reused (derived from) because it lacks necessary functionality, leading the developer to have to modify the base class and causing proliferation of base class API calls, some of which may not be semantically correct for all subclasses.</p><p><em>ns-3</em> is using a version of the query interface design pattern to avoid these problems. This design is based on elements of the <em>Component Object Model</em> and <em>GNOME Bonobo</em> although full binary-level compatibility of replaceable components is not supported and we have tried to simplify the syntax and impact on model developers.</p>
<h3>Exmaples</h3>

<h3>Aggregation example</h3>
<p><strong>Node</strong> is a good example of the use of aggregation in <em>ns-3</em>.  Note that there are not derived classes of Nodes in <em>ns-3</em> such as class <strong>InternetNode</strong>.  Instead, components (protocols) are aggregated to a node. Let&apos;s look at how some Ipv4 protocols are added to a node.:</p>
<pre>
static void
AddIpv4Stack(Ptr&lt;Node&gt; node)
{
  Ptr&lt;Ipv4L3Protocol&gt; ipv4 = CreateObject&lt;Ipv4L3Protocol&gt; ();
  ipv4-&gt;SetNode (node);
  node-&gt;AggregateObject (ipv4);
  Ptr&lt;Ipv4Impl&gt; ipv4Impl = CreateObject&lt;Ipv4Impl&gt; ();
  ipv4Impl-&gt;SetIpv4 (ipv4);
  node-&gt;AggregateObject (ipv4Impl);
}
</pre>
<p>Note that the Ipv4 protocols are created using <strong>CreateObject()</strong>. Then, they are aggregated to the node. In this manner, the Node base class does not need to be edited to allow users with a base class Node pointer to access the Ipv4 interface; users may ask the node for a pointer to its Ipv4 interface at runtime. How the user asks the node is described in the next subsection.</p><p>Note that it is a programming error to aggregate more than one object of the same type to an <strong>ns3::Object</strong>. So, for instance, aggregation is not an option for storing all of the active sockets of a node.</p>
<h3>GetObject example</h3>
<p>GetObject is a type-safe way to achieve a safe downcasting and to allow interfaces to be found on an object.</p><p>Consider a node pointer <strong>m_node</strong> that points to a Node object that has an implementation of IPv4 previously aggregated to it. The client code wishes to configure a default route. To do so, it must access an object within the node that has an interface to the IP forwarding configuration. It performs the following::</p>
<pre>
Ptr&lt;Ipv4&gt; ipv4 = m_node-&gt;GetObject&lt;Ipv4&gt; ();
</pre>
<p>If the node in fact does not have an Ipv4 object aggregated to it, then the method will return null. Therefore, it is good practice to check the return value from such a function call. If successful, the user can now use the Ptr to the Ipv4 object that was previously aggregated to the node.</p><p>Another example of how one might use aggregation is to add optional models to objects. For instance, an existing Node object may have an "Energy Model" object aggregated to it at run time (without modifying and recompiling the node class). An existing model (such as a wireless net device) can then later "GetObject" for the energy model and act appropriately if the interface has been either built in to the underlying Node object or aggregated to it at run time.  However, other nodes need not know anything about energy models.</p><p>We hope that this mode of programming will require much less need for developers to modify the base classes.</p>
<h3>Object factories</h3>
<p>A common use case is to create lots of similarly configured objects. One can repeatedly call <strong>CreateObject()</strong> but there is also a factory design pattern in use in the <em>ns-3</em> system. It is heavily used in the "helper" API.</p><p>Class <strong>ObjectFactory</strong> can be used to instantiate objects and to configure the attributes on those objects:</p>
<pre>
void SetTypeId (TypeId tid);
void Set (std::string name, const AttributeValue &value);
Ptr&lt;T&gt; Create (void) const;
</pre>
<p>The first method allows one to use the <em>ns-3</em> TypeId system to specify the type of objects created. The second allows one to set attributes on the objects to be created, and the third allows one to create the objects themselves.</p><p>For example:</p>
<pre>
ObjectFactory factory;
// Make this factory create objects of type FriisPropagationLossModel
factory.SetTypeId ("ns3::FriisPropagationLossModel")
// Make this factory object change a default value of an attribute, for
// subsequently created objects
factory.Set ("SystemLoss", DoubleValue (2.0));
// Create one such object
Ptr&lt;Object&gt; object = factory.Create ();
factory.Set ("SystemLoss", DoubleValue (3.0));
// Create another object with a different SystemLoss
Ptr&lt;Object&gt; object = factory.Create ();
</pre>

<h3>Downcasting</h3>
<p>A question that has arisen several times is, "If I have a base class pointer (Ptr) to an object and I want the derived class pointer, should I downcast (via C++ dynamic cast) to get the derived pointer, or should I use the object aggregation system to <strong>GetObject&lt;&gt; ()</strong> to find a Ptr to the interface to the subclass API?"</p><p>The answer to this is that in many situations, both techniques will work. <em>ns-3</em> provides a templated function for making the syntax of Object dynamic casting much more user friendly::</p>
<pre>
template &lt;typename T1, typename T2&gt;
Ptr&lt;T1&gt;
DynamicCast (Ptr&lt;T2&gt; const&p)
{
  return Ptr&lt;T1&gt; (dynamic_cast&lt;T1 *&gt; (PeekPointer (p)));
}
</pre>
<p>DynamicCast works when the programmer has a base type pointer and is testing against a subclass pointer. GetObject works when looking for different objects aggregated, but also works with subclasses, in the same way as DynamicCast. If unsure, the programmer should use GetObject, as it works in all cases. If the programmer knows the class hierarchy of the object under consideration, it is more direct to just use DynamicCast.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ATTRIBUTES</h2>
        <div class="sectioncontent">
<p>In <em>ns-3</em> simulations, there are two main aspects to configuration:</p><ul>
<li><p>the simulation topology and how objects are connected</p></li><li><p>the values used by the models instantiated in the topology</p><p>This chapter focuses on the second item above: how the many values in use in <em>ns-3</em> are organized, documented, and modifiable by <em>ns-3</em> users. The <em>ns-3</em> attribute system is also the underpinning of how traces and statistics are gathered in the simulator.</p><p>Before delving into details of the attribute value system, it will help to review some basic properties of class <strong>ns3::Object</strong>.</p></li>
</ul><h3>Object Overview</h3>
<p><em>ns-3</em> is fundamentally a C++ object-based system. By this we mean that new C++ classes (types) can be declared, defined, and subclassed as usual.</p><p>Many <em>ns-3</em> objects inherit from the <strong>ns3::Object</strong> base class.  These objects have some additional properties that we exploit for organizing the system and improving the memory management of our objects:</p><ul>
<li><p>a "metadata" system that links the class name to a lot of meta-information about the object, including the base class of the subclass, the set of accessible constructors in the subclass, and the set of "attributes" of the subclass</p></li><li><p>a reference counting smart pointer implementation, for memory management.</p><p><em>ns-3</em> objects that use the attribute system derive from either <strong>ns3::Object</strong> or <strong>ns3::ObjectBase</strong>. Most <em>ns-3</em> objects we will discuss derive from <strong>ns3::Object</strong>, but a few that are outside the smart pointer memory management framework derive from <strong>ns3::ObjectBase</strong>.</p><p>Let&apos;s review a couple of properties of these objects.</p></li>
</ul>
<h3>Smart pointers</h3>
<p>As introduced in the <em>ns-3</em> tutorial, <em>ns-3</em> objects are memory managed by a <em>reference counting smart pointer implementation</em>, class <strong>ns3::Ptr</strong>.</p><p>Smart pointers are used extensively in the <em>ns-3</em> APIs, to avoid passing references to heap-allocated objects that may cause memory leaks. For most basic usage (syntax), treat a smart pointer like a regular pointer::</p>
<pre>
Ptr&lt;WifiNetDevice&gt; nd = ...;
nd-&gt;CallSomeFunction ();
// etc.
</pre>

<h3>CreateObject</h3>
<p>As we discussed above in <em>Memory-management-and-class-Ptr</em>, at the lowest-level API, objects of type <strong>ns3::Object</strong> are not instantiated using <strong>operator new</strong> as usual but instead by a templated function called <strong>CreateObject()</strong>.</p><p>A typical way to create such an object is as follows::</p>
<pre>
Ptr&lt;WifiNetDevice&gt; nd = CreateObject&lt;WifiNetDevice&gt; ();
</pre>
<p>You can think of this as being functionally equivalent to::</p>
<pre>
WifiNetDevice* nd = new WifiNetDevice ();
</pre>
<p>Objects that derive from <strong>ns3::Object</strong> must be allocated on the heap using CreateObject(). Those deriving from <strong>ns3::ObjectBase</strong>, such as <em>ns-3</em> helper functions and packet headers and trailers, can be allocated on the stack.</p><p>In some scripts, you may not see a lot of CreateObject() calls in the code; this is because there are some helper objects in effect that are doing the CreateObject()s for you.</p>
<h3>TypeId</h3>
<p><em>ns-3</em> classes that derive from class ns3::Object can include a metadata class called <strong>TypeId</strong> that records meta-information about the class, for use in the object aggregation and component manager systems:</p><ul>
<li><p>a unique string identifying the class</p></li><li><p>the base class of the subclass, within the metadata system</p></li><li><p>the set of accessible constructors in the subclass</p></li>
</ul>
<h3>Object Summary</h3>
<p>Putting all of these concepts together, let&apos;s look at a specific example: class <strong>ns3::Node</strong>.</p><p>The public header file node.h has a declaration that includes a static GetTypeId function call::</p>
<pre>
class Node : public Object
{
public:
  static TypeId GetTypeId (void);
  ...
</pre>
<p>This is defined in the <strong>node.cc</strong> file as follows::</p>
<pre>
TypeId
Node::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::Node")
    .SetParent&lt;Object&gt; ()
    .AddConstructor&lt;Node&gt; ()
    .AddAttribute ("DeviceList", "The list of devices associated to this Node.",
                   ObjectVectorValue (),
                   MakeObjectVectorAccessor (&Node::m_devices),
                   MakeObjectVectorChecker&lt;NetDevice&gt; ())
    .AddAttribute ("ApplicationList", "The list of applications associated to this Node.",
                   ObjectVectorValue (),
                   MakeObjectVectorAccessor (&Node::m_applications),
                   MakeObjectVectorChecker&lt;Application&gt; ())
    .AddAttribute ("Id", "The id (unique integer) of this Node.",
                   TypeId::ATTR_GET, // allow only getting it.
                   UintegerValue (0),
                   MakeUintegerAccessor (&Node::m_id),
                   MakeUintegerChecker&lt;uint32_t&gt; ())
    ;
  return tid;
}
</pre>
<p>Consider the TypeId of an <em>ns-3</em> <strong>Object</strong> class as an extended form of run time type information (RTTI). The C++ language includes a simple kind of RTTI in order to support <strong>dynamic_cast</strong> and <strong>typeid</strong> operators.</p><p>The "<strong>.SetParent&lt;Object&gt; ()</strong>" call in the declaration above is used in conjunction with our object aggregation mechanisms to allow safe up- and down-casting in inheritance trees during <strong>GetObject</strong>.</p><p>The "<strong>.AddConstructor&lt;Node&gt; ()</strong>" call is used in conjunction with our abstract object factory mechanisms to allow us to construct C++ objects without forcing a user to know the concrete class of the object she is building.</p><p>The three calls to "<strong>.AddAttribute</strong>" associate a given string with a strongly typed value in the class. Notice that you must provide a help string which may be displayed, for example, via command line processors. Each <strong>Attribute</strong> is associated with mechanisms for accessing the underlying member variable in the object (for example, <strong>MakeUintegerAccessor</strong> tells the generic <strong>Attribute</strong> code how to get to the node ID above). There are also "Checker" methods which are used to validate values.</p><p>When users want to create Nodes, they will usually call some form of <strong>CreateObject</strong>,:</p>
<pre>
Ptr&lt;Node&gt; n = CreateObject&lt;Node&gt; ();
</pre>
<p>or more abstractly, using an object factory, you can create a <strong>Node</strong> object without even knowing the concrete C++ type:</p>
<pre>
ObjectFactory factory;
const std::string typeId = "ns3::Node&apos;&apos;;
factory.SetTypeId (typeId);
Ptr&lt;Object&gt; node = factory.Create &lt;Object&gt; ();
</pre>
<p>Both of these methods result in fully initialized attributes being available in the resulting <strong>Object</strong> instances.</p><p>We next discuss how attributes (values associated with member variables or functions of the class) are plumbed into the above TypeId.</p>
<h3>Attribute Overview</h3>
<p>The goal of the attribute system is to organize the access of internal member objects of a simulation. This goal arises because, typically in simulation, users will cut and paste/modify existing simulation scripts, or will use higher-level simulation constructs, but often will be interested in studying or tracing particular internal variables.  For instance, use cases such as:</p><ul>
<li><p>"I want to trace the packets on the wireless interface only on the first access point"</p></li><li><p>"I want to trace the value of the TCP congestion window (every time it changes) on a particular TCP socket"</p></li><li><p>"I want a dump of all values that were used in my simulation."</p><p>Similarly, users may want fine-grained access to internal variables in the simulation, or may want to broadly change the initial value used for a particular parameter in all subsequently created objects. Finally, users may wish to know what variables are settable and retrievable in a simulation configuration. This is not just for direct simulation interaction on the command line; consider also a (future) graphical user interface that would like to be able to provide a feature whereby a user might right-click on an node on the canvas and see a hierarchical, organized list of parameters that are settable on the node and its constituent member objects, and help text and default values for each parameter.</p></li>
</ul>
<h3>Functional overview</h3>
<p>We provide a way for users to access values deep in the system, without having to plumb accessors (pointers) through the system and walk pointer chains to get to them. Consider a class DropTailQueue that has a member variable that is an unsigned integer <strong>m_maxPackets</strong>; this member variable controls the depth of the queue.</p><p>If we look at the declaration of DropTailQueue, we see the following::</p>
<pre>
class DropTailQueue : public Queue {
public:
  static TypeId GetTypeId (void);
  ...

private:
  std::queue&lt;Ptr&lt;Packet&gt; &gt; m_packets;
  uint32_t m_maxPackets;
};
</pre>
<p>Let&apos;s consider things that a user may want to do with the value of m_maxPackets:</p><ul>
<li><p>Set a default value for the system, such that whenever a new DropTailQueue is created, this member is initialized to that default.</p></li><li><p>Set or get the value on an already instantiated queue.</p><p>The above things typically require providing Set() and Get() functions, and some type of global default value.</p><p>In the <em>ns-3</em> attribute system, these value definitions and accessor functions are moved into the TypeId class; e.g.::</p>
<pre>
NS_OBJECT_ENSURE_REGISTERED (DropTailQueue);

TypeId DropTailQueue::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::DropTailQueue")
    .SetParent&lt;Queue&gt; ()
    .AddConstructor&lt;DropTailQueue&gt; ()
    .AddAttribute ("MaxPackets",
                   "The maximum number of packets accepted by this DropTailQueue.",
                   UintegerValue (100),
                   MakeUintegerAccessor (&DropTailQueue::m_maxPackets),
                   MakeUintegerChecker&lt;uint32_t&gt; ())
    ;

  return tid;
}
</pre>
<p>The AddAttribute() method is performing a number of things with this value:</p></li><li><p>Binding the variable m_maxPackets to a string "MaxPackets"</p></li><li><p>Providing a default value (100 packets)</p></li><li><p>Providing some help text defining the value</p></li><li><p>Providing a "checker" (not used in this example) that can be used to set bounds on the allowable range of values</p><p>The key point is that now the value of this variable and its default value are accessible in the attribute namespace, which is based on strings such as "MaxPackets" and TypeId strings. In the next section, we will provide an example script that shows how users may manipulate these values.</p><p>Note that initialization of the attribute relies on the macro <strong>NS_OBJECT_ENSURE_REGISTERED</strong> (DropTailQueue) being called; if you leave this out of your new class implementation, your attributes will not be initialized correctly.</p><p>While we have described how to create attributes, we still haven&apos;t described how to access and manage these values. For instance, there is no <strong>globals.h</strong> header file where these are stored; attributes are stored with their classes. Questions that naturally arise are how do users easily learn about all of the attributes of their models, and how does a user access these attributes, or document their values as part of the record of their simulation?</p></li>
</ul>
<h3>Default values and command-line arguments</h3>
<p>Let&apos;s look at how a user script might access these values. This is based on the script found at <strong>src/point-to-point/examples/main-attribute-value.cc</strong>, with some details stripped out.:</p>
<pre>
//
// This is a basic example of how to use the attribute system to
// set and get a value in the underlying system; namely, an unsigned
// integer of the maximum number of packets in a queue
//

int
main (int argc, char *argv[])
{

  // By default, the MaxPackets attribute has a value of 100 packets
  // (this default can be observed in the function DropTailQueue::GetTypeId)
  //
  // Here, we set it to 80 packets.  We could use one of two value types:
  // a string-based value or a Uinteger value
  Config::SetDefault ("ns3::DropTailQueue::MaxPackets", StringValue ("80"));
  // The below function call is redundant
  Config::SetDefault ("ns3::DropTailQueue::MaxPackets", UintegerValue (80));

  // Allow the user to override any of the defaults and the above
  // SetDefaults() at run-time, via command-line arguments
  CommandLine cmd;
  cmd.Parse (argc, argv);
</pre>
<p>The main thing to notice in the above are the two calls to <strong>Config::SetDefault</strong>.  This is how we set the default value for all subsequently instantiated DropTailQueues.  We illustrate that two types of Value classes, a StringValue and a UintegerValue class, can be used to assign the value to the attribute named by "ns3::DropTailQueue::MaxPackets".</p><p>Now, we will create a few objects using the low-level API; here, our newly created queues will not have a m_maxPackets initialized to 100 packets but to 80 packets, because of what we did above with default values.:</p>
<pre>
Ptr&lt;Node&gt; n0 = CreateObject&lt;Node&gt; ();

Ptr&lt;PointToPointNetDevice&gt; net0 = CreateObject&lt;PointToPointNetDevice&gt; ();
n0-&gt;AddDevice (net0);

Ptr&lt;Queue&gt; q = CreateObject&lt;DropTailQueue&gt; ();
net0-&gt;AddQueue(q);
</pre>
<p>At this point, we have created a single node (Node 0) and a single PointToPointNetDevice (NetDevice 0) and added a DropTailQueue to it.</p><p>Now, we can manipulate the MaxPackets value of the already instantiated DropTailQueue. Here are various ways to do that.</p>
<h3>Pointer-based access</h3>
<p>We assume that a smart pointer (Ptr) to a relevant network device is in hand; in the current example, it is the <strong>net0</strong> pointer.</p><p>One way to change the value is to access a pointer to the underlying queue and modify its attribute.</p><p>First, we observe that we can get a pointer to the (base class) queue via the PointToPointNetDevice attributes, where it is called TxQueue:</p>
<pre>
PointerValue tmp;
net0-&gt;GetAttribute ("TxQueue", tmp);
Ptr&lt;Object&gt; txQueue = tmp.GetObject ();
</pre>
<p>Using the GetObject function, we can perform a safe downcast to a DropTailQueue, where MaxPackets is a member:</p>
<pre>
Ptr&lt;DropTailQueue&gt; dtq = txQueue-&gt;GetObject &lt;DropTailQueue&gt; ();
NS_ASSERT (dtq != 0);
</pre>
<p>Next, we can get the value of an attribute on this queue.  We have introduced wrapper "Value" classes for the underlying data types, similar to Java wrappers around these types, since the attribute system stores values and not disparate types.  Here, the attribute value is assigned to a UintegerValue, and the Get() method on this value produces the (unwrapped) uint32_t.:</p>
<pre>
UintegerValue limit;
dtq-&gt;GetAttribute ("MaxPackets", limit);
NS_LOG_INFO ("1.  dtq limit: " &lt;&lt; limit.Get () &lt;&lt; " packets");
</pre>
<p>Note that the above downcast is not really needed; we could have done the same using the Ptr&lt;Queue&gt; even though the attribute is a member of the subclass:</p>
<pre>
txQueue-&gt;GetAttribute ("MaxPackets", limit);
NS_LOG_INFO ("2.  txQueue limit: " &lt;&lt; limit.Get () &lt;&lt; " packets");
</pre>
<p>Now, let&apos;s set it to another value (60 packets):</p>
<pre>
txQueue-&gt;SetAttribute("MaxPackets", UintegerValue (60));
txQueue-&gt;GetAttribute ("MaxPackets", limit);
NS_LOG_INFO ("3.  txQueue limit changed: " &lt;&lt; limit.Get () &lt;&lt; " packets");
</pre>

<h3>Namespace-based access</h3>
<p>An alternative way to get at the attribute is to use the configuration namespace.  Here, this attribute resides on a known path in this namespace; this approach is useful if one doesn&apos;t have access to the underlying pointers and would like to configure a specific attribute with a single statement.:</p>
<pre>
Config::Set ("/NodeList/0/DeviceList/0/TxQueue/MaxPackets", UintegerValue (25));
txQueue-&gt;GetAttribute ("MaxPackets", limit);
NS_LOG_INFO ("4.  txQueue limit changed through namespace: " &lt;&lt;
    limit.Get () &lt;&lt; " packets");
</pre>
<p>We could have also used wildcards to set this value for all nodes and all net devices (which in this simple example has the same effect as the previous Set()):</p>
<pre>
Config::Set ("/NodeList/*/DeviceList/*/TxQueue/MaxPackets", UintegerValue (15));
txQueue-&gt;GetAttribute ("MaxPackets", limit);
NS_LOG_INFO ("5.  txQueue limit changed through wildcarded namespace: " &lt;&lt;
    limit.Get () &lt;&lt; " packets");
</pre>

<h3>Object Name Service-based access</h3>
<p>Another way to get at the attribute is to use the object name service facility. Here, this attribute is found using a name string. This approach is useful if one doesn&apos;t have access to the underlying pointers and it is difficult to determine the required concrete configuration namespaced path.:</p>
<pre>
Names::Add ("server", serverNode);
Names::Add ("server/eth0", serverDevice);

...

Config::Set ("/Names/server/eth0/TxQueue/MaxPackets", UintegerValue (25));
</pre>
<p><em>Object-names</em> for a fuller treatment of the <em>ns-3</em> configuration namespace.</p>
<h3>Setting through constructors helper classes</h3>
<p>Arbitrary combinations of attributes can be set and fetched from the helper and low-level APIs; either from the constructors themselves::</p>
<pre>
Ptr&lt;Object&gt; p = CreateObject&lt;MyNewObject&gt; ("n1", v1, "n2", v2, ...);
</pre>
<p>or from the higher-level helper APIs, such as::</p>
<pre>
mobility.SetPositionAllocator ("GridPositionAllocator",
                               "MinX", DoubleValue (-100.0),
                               "MinY", DoubleValue (-100.0),
                               "DeltaX", DoubleValue (5.0),
                               "DeltaY", DoubleValue (20.0),
                               "GridWidth", UintegerValue (20),
                               "LayoutType", StringValue ("RowFirst"));
</pre>

<h3>Implementation details</h3>

<h3>Value classes</h3>
<p>Readers will note the new FooValue classes which are subclasses of the AttributeValue base class. These can be thought of as an intermediate class that can be used to convert from raw types to the Values that are used by the attribute system. Recall that this database is holding objects of many types with a single generic type. Conversions to this type can either be done using an intermediate class (IntegerValue, DoubleValue for "floating point") or via strings. Direct implicit conversion of types to Value is not really practical. So in the above, users have a choice of using strings or values::</p>
<pre>
p-&gt;Set ("cwnd", StringValue ("100")); // string-based setter
p-&gt;Set ("cwnd", IntegerValue (100)); // integer-based setter
</pre>
<p>The system provides some macros that help users declare and define new AttributeValue subclasses for new types that they want to introduce into the attribute system:</p><ul>
<li><p>ATTRIBUTE_HELPER_HEADER</p></li><li><p>ATTRIBUTE_HELPER_CPP</p></li>
</ul>
<h3>Initialization order</h3>
<p>Attributes in the system must not depend on the state of any other Attribute in this system. This is because an ordering of Attribute initialization is not specified, nor enforced, by the system. A specific example of this can be seen in automated configuration programs such as <strong>ns3::ConfigStore</strong>. Although a given model may arrange it so that Attributes are initialized in a particular order, another automatic configurator may decide independently to change Attributes in, for example, alphabetic order.</p><p>Because of this non-specific ordering, no Attribute in the system may have any dependence on any other Attribute. As a corollary, Attribute setters must never fail due to the state of another Attribute. No Attribute setter may change (set) any other Attribute value as a result of changing its value.</p><p>This is a very strong restriction and there are cases where Attributes must set consistently to allow correct operation. To this end we do allow for consistency checking <em>when the attribute is used</em> (cf. NS_ASSERT_MSG or NS_ABORT_MSG).</p><p>In general, the attribute code to assign values to the underlying class member variables is executed after an object is constructed. But what if you need the values assigned before the constructor body executes, because you need them in the logic of the constructor? There is a way to do this, used for example in the class <strong>ns3::ConfigStore</strong>: call <strong>ObjectBase::ConstructSelf ()</strong> as follows::</p>
<pre>
ConfigStore::ConfigStore ()
{
  ObjectBase::ConstructSelf (AttributeConstructionList ());
  // continue on with constructor.
}
</pre>
<p>Beware that the object and all its derived classes must also implement a <strong>virtual TypeId GetInstanceTypeId (void) const;</strong> method. Otherwise the <strong>ObjectBase::ConstructSelf ()</strong> will not be able to read the attributes.</p>
<h3>Extending attributes</h3>
<p>The <em>ns-3</em> system will place a number of internal values under the attribute system, but undoubtedly users will want to extend this to pick up ones we have missed, or to add their own classes to this.</p>
<h3>Adding an existing internal variable to the metadata system</h3>
<p>Consider this variable in class TcpSocket::</p>
<pre>
uint32_t m_cWnd;   // Congestion window
</pre>
<p>Suppose that someone working with TCP wanted to get or set the value of that variable using the metadata system. If it were not already provided by <em>ns-3</em>, the user could declare the following addition in the runtime metadata system (to the TypeId declaration for TcpSocket)::</p>
<pre>
.AddAttribute ("Congestion window",
               "Tcp congestion window (bytes)",
               UintegerValue (1),
               MakeUintegerAccessor (&TcpSocket::m_cWnd),
               MakeUintegerChecker&lt;uint16_t&gt; ())
</pre>
<p>Now, the user with a pointer to the TcpSocket can perform operations such as setting and getting the value, without having to add these functions explicitly. Furthermore, access controls can be applied, such as allowing the parameter to be read and not written, or bounds checking on the permissible values can be applied.</p>
<h3>Adding a new TypeId</h3>
<p>Here, we discuss the impact on a user who wants to add a new class to <em>ns-3</em>; what additional things must be done to hook it into this system.</p><p>We&apos;ve already introduced what a TypeId definition looks like::</p>
<pre>
TypeId
RandomWalk2dMobilityModel::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::RandomWalk2dMobilityModel")
    .SetParent&lt;MobilityModel&gt; ()
    .SetGroupName ("Mobility")
    .AddConstructor&lt;RandomWalk2dMobilityModel&gt; ()
    .AddAttribute ("Bounds",
                   "Bounds of the area to cruise.",
                   RectangleValue (Rectangle (0.0, 0.0, 100.0, 100.0)),
                   MakeRectangleAccessor (&RandomWalk2dMobilityModel::m_bounds),
                   MakeRectangleChecker ())
    .AddAttribute ("Time",
                   "Change current direction and speed after moving for this delay.",
                   TimeValue (Seconds (1.0)),
                   MakeTimeAccessor (&RandomWalk2dMobilityModel::m_modeTime),
                   MakeTimeChecker ())
    // etc (more parameters).
    ;
  return tid;
}
</pre>
<p>The declaration for this in the class declaration is one-line public member method::</p>
<pre>
public:
  static TypeId GetTypeId (void);
</pre>
<p>Typical mistakes here involve:</p><ul>
<li><p>Not calling the SetParent method or calling it with the wrong type</p></li><li><p>Not calling the AddConstructor method of calling it with the wrong type</p></li><li><p>Introducing a typographical error in the name of the TypeId in its constructor</p></li><li><p>Not using the fully-qualified c++ typename of the enclosing c++ class as the name of the TypeId</p><p>None of these mistakes can be detected by the <em>ns-3</em> codebase so, users are advised to check carefully multiple times that they got these right.</p></li>
</ul>
<h3>Adding new class type to the attribute system</h3>
<p>From the perspective of the user who writes a new class in the system and wants to hook it in to the attribute system, there is mainly the matter of writing the conversions to/from strings and attribute values.  Most of this can be copy/pasted with macro-ized code.  For instance, consider class declaration for Rectangle in the <strong>src/mobility/model</strong> directory:</p>
<h3>Header file</h3>

<pre>
/**
 * &#92;brief a 2d rectangle
 */
class Rectangle
{
  ...

  double xMin;
  double xMax;
  double yMin;
  double yMax;
};
</pre>
<p>One macro call and two operators, must be added below the class declaration in order to turn a Rectangle into a value usable by the <strong>Attribute</strong> system::</p>
<pre>
std::ostream &operator &lt;&lt; (std::ostream &os, const Rectangle &rectangle);
std::istream &operator &gt;&gt; (std::istream &is, Rectangle &rectangle);

ATTRIBUTE_HELPER_HEADER (Rectangle);
</pre>

<h3>Implementation file</h3>
<p>In the class definition (<strong>.cc</strong> file), the code looks like this::</p>
<pre>
ATTRIBUTE_HELPER_CPP (Rectangle);

std::ostream &
operator &lt;&lt; (std::ostream &os, const Rectangle &rectangle)
{
  os &lt;&lt; rectangle.xMin &lt;&lt; "|" &lt;&lt; rectangle.xMax &lt;&lt; "|" &lt;&lt; rectangle.yMin &lt;&lt; "|"
     &lt;&lt; rectangle.yMax;
  return os;
}
std::istream &
operator &gt;&gt; (std::istream &is, Rectangle &rectangle)
 {
  char c1, c2, c3;
  is &gt;&gt; rectangle.xMin &gt;&gt; c1 &gt;&gt; rectangle.xMax &gt;&gt; c2 &gt;&gt; rectangle.yMin &gt;&gt; c3
     &gt;&gt; rectangle.yMax;
  if (c1 != &apos;|&apos; ||
      c2 != &apos;|&apos; ||
      c3 != &apos;|&apos;)
    {
      is.setstate (std::ios_base::failbit);
    }
  return is;
}
</pre>
<p>These stream operators simply convert from a string representation of the Rectangle ("xMin|xMax|yMin|yMax") to the underlying Rectangle, and the modeler must specify these operators and the string syntactical representation of an instance of the new class.</p>
<h3>ConfigStore</h3>
<p>The ConfigStore is a specialized database for attribute values and default values.  Although it is a separately maintained module in <strong>src/config-store/</strong> directory, we document it here because of its sole dependency on <em>ns-3</em> core module and attributes.</p><p>Values for <em>ns-3</em> attributes can be stored in an ASCII or XML text file and loaded into a future simulation.  This feature is known as the <em>ns-3</em> ConfigStore.  We can explore this system by using an example from <strong>src/config-store/examples/config-store-save.cc</strong>.</p><p>First, all users must include the following statement::</p>
<pre>
#include "ns3/config-store-module.h"
</pre>
<p>Next, this program adds a sample object A to show how the system is extended::</p>
<pre>
class A : public Object
{
public:
  static TypeId GetTypeId (void) {
    static TypeId tid = TypeId ("ns3::A")
      .SetParent&lt;Object&gt; ()
      .AddAttribute ("TestInt16", "help text",
                     IntegerValue (-2),
                     MakeIntegerAccessor (&A::m_int16),
                     MakeIntegerChecker&lt;int16_t&gt; ())
      ;
      return tid;
    }
  int16_t m_int16;
};

NS_OBJECT_ENSURE_REGISTERED (A);
</pre>
<p>Next, we use the Config subsystem to override the defaults in a couple of ways::</p>
<pre>
Config::SetDefault ("ns3::A::TestInt16", IntegerValue (-5));

Ptr&lt;A&gt; a_obj = CreateObject&lt;A&gt; ();
NS_ABORT_MSG_UNLESS (a_obj-&gt;m_int16 == -5, "Cannot set A&apos;s integer attribute via Config::SetDefault");

Ptr&lt;A&gt; a2_obj = CreateObject&lt;A&gt; ();
a2_obj-&gt;SetAttribute ("TestInt16", IntegerValue (-3));
IntegerValue iv;
a2_obj-&gt;GetAttribute ("TestInt16", iv);
NS_ABORT_MSG_UNLESS (iv.Get () == -3, "Cannot set A&apos;s integer attribute via SetAttribute");
</pre>
<p>The next statement is necessary to make sure that (one of) the objects created is rooted in the configuration namespace as an object instance. This normally happens when you aggregate objects to ns3::Node or ns3::Channel but here, since we are working at the core level, we need to create a new root namespace object::</p>
<pre>
Config::RegisterRootNamespaceObject (a2_obj);
</pre>
<p>Next, we want to output the configuration store.  The examples show how to do it in two formats, XML and raw text.  In practice, one should perform this step just before calling <strong>Simulator::Run ()</strong>;  it will allow the configuration to be saved just before running the simulation.</p><p>There are three attributes that govern the behavior of the ConfigStore: "Mode", "Filename", and "FileFormat".  The Mode (default "None") configures whether <em>ns-3</em> should load configuration from a previously saved file (specify "Mode=Load") or save it to a file (specify "Mode=Save").  The Filename (default "") is where the ConfigStore should store its output data.  The FileFormat (default "RawText") governs whether the ConfigStore format is Xml or RawText format.</p><p>The example shows::</p>
<pre>
Config::SetDefault ("ns3::ConfigStore::Filename", StringValue ("output-attributes.xml"));
Config::SetDefault ("ns3::ConfigStore::FileFormat", StringValue ("Xml"));
Config::SetDefault ("ns3::ConfigStore::Mode", StringValue ("Save"));
ConfigStore outputConfig;
outputConfig.ConfigureDefaults ();
outputConfig.ConfigureAttributes ();

// Output config store to txt format
Config::SetDefault ("ns3::ConfigStore::Filename", StringValue ("output-attributes.txt"));
Config::SetDefault ("ns3::ConfigStore::FileFormat", StringValue ("RawText"));
Config::SetDefault ("ns3::ConfigStore::Mode", StringValue ("Save"));
ConfigStore outputConfig2;
outputConfig2.ConfigureDefaults ();
outputConfig2.ConfigureAttributes ();

Simulator::Run ();

Simulator::Destroy ();
</pre>
<p>After running, you can open the output-attributes.txt file and see::</p>
<pre>
default ns3::RealtimeSimulatorImpl::SynchronizationMode "BestEffort"
default ns3::RealtimeSimulatorImpl::HardLimit "+100000000.0ns"
default ns3::PcapFileWrapper::CaptureSize "65535"
default ns3::PacketSocket::RcvBufSize "131072"
default ns3::ErrorModel::IsEnabled "true"
default ns3::RateErrorModel::ErrorUnit "EU_BYTE"
default ns3::RateErrorModel::ErrorRate "0"
default ns3::RateErrorModel::RanVar "Uniform:0:1"
default ns3::DropTailQueue::Mode "Packets"
default ns3::DropTailQueue::MaxPackets "100"
default ns3::DropTailQueue::MaxBytes "6553500"
default ns3::Application::StartTime "+0.0ns"
default ns3::Application::StopTime "+0.0ns"
default ns3::ConfigStore::Mode "Save"
default ns3::ConfigStore::Filename "output-attributes.txt"
default ns3::ConfigStore::FileFormat "RawText"
default ns3::A::TestInt16 "-5"
global RngSeed "1"
global RngRun "1"
global SimulatorImplementationType "ns3::DefaultSimulatorImpl"
global SchedulerType "ns3::MapScheduler"
global ChecksumEnabled "false"
value /$ns3::A/TestInt16 "-3"
</pre>
<p>In the above, all of the default values for attributes for the core module are shown.  Then, all the values for the <em>ns-3</em> global values are recorded.  Finally, the value of the instance of A that was rooted in the configuration namespace is shown.  In a real ns-3 program, many more models, attributes, and defaults would be shown.</p><p>An XML version also exists in <strong>output-attributes.xml</strong>::</p>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;ns3&gt;
 &lt;default name="ns3::RealtimeSimulatorImpl::SynchronizationMode" value="BestEffort"/&gt;
 &lt;default name="ns3::RealtimeSimulatorImpl::HardLimit" value="+100000000.0ns"/&gt;
 &lt;default name="ns3::PcapFileWrapper::CaptureSize" value="65535"/&gt;
 &lt;default name="ns3::PacketSocket::RcvBufSize" value="131072"/&gt;
 &lt;default name="ns3::ErrorModel::IsEnabled" value="true"/&gt;
 &lt;default name="ns3::RateErrorModel::ErrorUnit" value="EU_BYTE"/&gt;
 &lt;default name="ns3::RateErrorModel::ErrorRate" value="0"/&gt;
 &lt;default name="ns3::RateErrorModel::RanVar" value="Uniform:0:1"/&gt;
 &lt;default name="ns3::DropTailQueue::Mode" value="Packets"/&gt;
 &lt;default name="ns3::DropTailQueue::MaxPackets" value="100"/&gt;
 &lt;default name="ns3::DropTailQueue::MaxBytes" value="6553500"/&gt;
 &lt;default name="ns3::Application::StartTime" value="+0.0ns"/&gt;
 &lt;default name="ns3::Application::StopTime" value="+0.0ns"/&gt;
 &lt;default name="ns3::ConfigStore::Mode" value="Save"/&gt;
 &lt;default name="ns3::ConfigStore::Filename" value="output-attributes.xml"/&gt;
 &lt;default name="ns3::ConfigStore::FileFormat" value="Xml"/&gt;
 &lt;default name="ns3::A::TestInt16" value="-5"/&gt;
 &lt;global name="RngSeed" value="1"/&gt;
 &lt;global name="RngRun" value="1"/&gt;
 &lt;global name="SimulatorImplementationType" value="ns3::DefaultSimulatorImpl"/&gt;
 &lt;global name="SchedulerType" value="ns3::MapScheduler"/&gt;
 &lt;global name="ChecksumEnabled" value="false"/&gt;
 &lt;value path="/$ns3::A/TestInt16" value="-3"/&gt;
&lt;/ns3&gt;
</pre>
<p>This file can be archived with your simulation script and output data.</p><p>While it is possible to generate a sample config file and lightly edit it to change a couple of values, there are cases where this process will not work because the same value on the same object can appear multiple times in the same automatically-generated configuration file under different configuration paths.</p><p>As such, the best way to use this class is to use it to generate an initial configuration file, extract from that configuration file only the strictly necessary elements, and move these minimal elements to a new configuration file which can then safely be edited and loaded in a subsequent simulation run.</p><p>When the ConfigStore object is instantiated, its attributes Filename, Mode, and FileFormat must be set, either via command-line or via program statements.</p><p>As a more complicated example, let&apos;s assume that we want to read in a configuration of defaults from an input file named "input-defaults.xml", and write out the resulting attributes to a separate file called "output-attributes.xml".  (Note-- to get this input xml file to begin with, it is sometimes helpful to run the program to generate an output xml file first, then hand-edit that file and re-input it for the next simulation run).:</p>
<pre>
#include "ns3/config-store-module.h"
...
int main (...)
{

  Config::SetDefault ("ns3::ConfigStore::Filename", StringValue ("input-defaults.xml"));
  Config::SetDefault ("ns3::ConfigStore::Mode", StringValue ("Load"));
  Config::SetDefault ("ns3::ConfigStore::FileFormat", StringValue ("Xml"));
  ConfigStore inputConfig;
  inputConfig.ConfigureDefaults ();

  //
  // Allow the user to override any of the defaults and the above Bind() at
  // run-time, via command-line arguments
  //
  CommandLine cmd;
  cmd.Parse (argc, argv);

  // setup topology
  ...

  // Invoke just before entering Simulator::Run ()
  Config::SetDefault ("ns3::ConfigStore::Filename", StringValue ("output-attributes.xml"));
  Config::SetDefault ("ns3::ConfigStore::Mode", StringValue ("Save"));
  ConfigStore outputConfig;
  outputConfig.ConfigureAttributes ();
  Simulator::Run ();
}
</pre>

<h3>GTK-based ConfigStore</h3>
<p>There is a GTK-based front end for the ConfigStore.  This allows users to use a GUI to access and change variables.  Screenshots of this feature are available in the <em>|ns3| Overview</em> presentation.</p><p>To use this feature, one must install libgtk and libgtk-dev; an example Ubuntu installation command is::</p>
<pre>
sudo apt-get install libgtk2.0-0 libgtk2.0-dev
</pre>
<p>To check whether it is configured or not, check the output of the step::</p>
<pre>
./waf configure --enable-examples --enable-tests

---- Summary of optional NS-3 features:
Python Bindings               : enabled
Python API Scanning Support   : enabled
NS-3 Click Integration        : enabled
GtkConfigStore                : not enabled (library &apos;gtk+-2.0 &gt;= 2.12&apos; not found)
</pre>
<p>In the above example, it was not enabled, so it cannot be used until a suitable version is installed and:</p>
<pre>
./waf configure --enable-examples --enable-tests
./waf
</pre>
<p>is rerun.</p><p>Usage is almost the same as the non-GTK-based version, but there are no ConfigStore attributes involved::</p>
<pre>
// Invoke just before entering Simulator::Run ()
GtkConfigStore config;
config.ConfigureDefaults ();
config.ConfigureAttributes ();
</pre>
<p>Now, when you run the script, a GUI should pop up, allowing you to open menus of attributes on different nodes/objects, and then launch the simulation execution when you are done.</p>
<h3>Future work</h3>
<p>There are a couple of possible improvements: * save a unique version number with date and time at start of file * save rng initial seed somewhere. * make each RandomVariable serialize its own initial seed and re-read it later</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OBJECT NAMES</h2>
        <div class="sectioncontent">
<p><em>Placeholder chapter</em></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LOGGING</h2>
        <div class="sectioncontent">
<p>The <em>ns-3</em> logging facility can be used to monitor or debug the progress of simulation programs.  Logging output can be enabled by program statements in your <strong>main()</strong> program or by the use of the <strong>NS_LOG</strong> environment variable.</p><p>Logging statements are not compiled into optimized builds of <em>ns-3</em>.  To use logging, one must build the (default) debug build of <em>ns-3</em>.</p><p>The project makes no guarantee about whether logging output will remain the same over time.  Users are cautioned against building simulation output frameworks on top of logging code, as the output and the way the output is enabled may change over time.</p><h3>Logging overview</h3>
<p><em>ns-3</em> logging statements are typically used to log various program execution events, such as the occurrence of simulation events or the use of a particular function.</p><p>For example, this code snippet is from <strong>Ipv4L3Protocol::IsDestinationAddress()</strong>:</p>
<pre>
if (address == iaddr.GetBroadcast ())
  {
    NS_LOG_LOGIC ("For me (interface broadcast address)");
    return true;
   }
</pre>
<p>If logging has been enabled for the <strong>Ipv4L3Protocol</strong> component at a level of <strong>LOGIC</strong> or above (see below about logging levels), the statement will be printed out; otherwise, it will be suppressed.</p>
<h3>Logging levels</h3>
<p>The following levels are defined; each level will enable the levels above it, with the <strong>ALL</strong> level being most verbose:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p><strong>LOG_NONE</strong>:  the default, no logging</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p><strong>LOG_ERROR</strong>:  serious error messages only</p>
  </dd>
  <dt>
    3.
  </dt>
  <dd>
    <p><strong>LOG_WARN</strong>:  warning messages</p>
  </dd>
  <dt>
    4.
  </dt>
  <dd>
    <p><strong>LOG_DEBUG</strong>:  for use in debugging</p>
  </dd>
  <dt>
    5.
  </dt>
  <dd>
    <p><strong>LOG_FUNCTION</strong>: function tracing</p>
  </dd>
  <dt>
    6.
  </dt>
  <dd>
    <p><strong>LOG_LOGIC</strong>:  control flow tracing within functions</p>
  </dd>
  <dt>
    7.
  </dt>
  <dd>
    <p><strong>LOG_ALL</strong>:  print everything</p><p>A special logging level will cause logging output to unconditionally appear on <strong>std::clog</strong>, regardless of whether the user has explicitly enabled logging. This macro, <strong>NS_LOG_UNCOND()</strong>, can be used like a kind of <strong>printf()</strong> in your code.  An example can be found in <strong>scratch/scratch-simulator.cc</strong>:</p>
<pre>
NS_LOG_UNCOND ("Scratch Simulator");
</pre>

  </dd>

</dl>

<h3>Logging prefixes</h3>
<p>This section still needs documentation; bug 1496 is open on this:</p>
<pre>
$ NS_LOG="*=all|prefix_all" ./waf --run scratch-simulator
Scratch Simulator
ScratchSimulator:main(): [ERROR] error message
ScratchSimulator:main(): [WARN] warn message
ScratchSimulator:main(): [DEBUG] debug message
ScratchSimulator:main(): [INFO] info message
ScratchSimulator:main(function)
ScratchSimulator:main(): [LOGIC] logic message
</pre>

<h3>Enabling logging output</h3>
<p>There are two ways that users typically control logging output.  The first is by setting an <strong>NS_LOG</strong> environment variable; e.g.:</p>
<pre>
NS_LOG="*" ./waf --run first
</pre>
<p>will run the first tutorial program with all logging output.  This can be made more granular by selecting individual components:</p>
<pre>
NS_LOG="Ipv4L3Protocol" ./waf --run first
</pre>
<p>The second way to enable this is to use explicit statements in your program, such as in the first tutorial program:</p>
<pre>
int
main (int argc, char *argv[])
{
  LogComponentEnable ("UdpEchoClientApplication", LOG_LEVEL_INFO);
  LogComponentEnable ("UdpEchoServerApplication", LOG_LEVEL_INFO);
  ...
</pre>
<p>Some helpers have special methods to enable the logging of all components in a module (across different compilation units, but logically grouped together such as the <em>ns-3</em> wifi code:</p>
<pre>
WifiHelper wifiHelper;
wifiHelper.EnableLogComponents ();
</pre>

<h3>How to add logging to your code</h3>
<p>To add logging to your code, please follow the below steps:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>Put <strong>NS_LOG_COMPONENT_DEFINE</strong> macro outside of namespace ns3</p><p>Create a unique string identifier (usually based on the name of the file and/or class defined within the file) and register it with a macro call such as follows:</p>
<pre>
NS_LOG_COMPONENT_DEFINE ("Ipv4L3Protocol");

namespace ns3 {
...
</pre>
<p>The macro was carefully written to permit inclusion either within or outside of namespace <strong>ns3</strong>, and usage will vary across the codebase, but the original intent was to register this <em>outside</em> of namespace <strong>ns3</strong>.</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>Add logging statements to your functions and function bodies.</p><p>There are a couple of guidelines on this:</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>Do <em>not</em> add function logging in operators or explicit copy constructors, since these will cause infinite recursion and stack overflow.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>Use the <strong>NS_LOG_FUNCTION_NOARGS()</strong> variant for static methods <em>only</em>. When a non-static member function has no arguments, it should be logged by <strong>NS_LOG_FUNCTION (this)</strong> macro.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>Make sure that you test that your logging changes do not break the code; running some example programs with all log components turned on (e.g. <strong>NS_LOG="*"</strong>) is one way to test this.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TRACING</h2>
        <div class="sectioncontent">
<p>The tracing subsystem is one of the most important mechanisms to understand in <em>ns-3</em>. In most cases, <em>ns-3</em> users will have a brilliant idea for some new and improved networking feature. In order to verify that this idea works, the researcher will make changes to an existing system and then run experiments to see how the new feature behaves by gathering statistics that capture the behavior of the feature.</p><p>In other words, the whole point of running a simulation is to generate output for further study. In <em>ns-3</em>, the subsystem that enables a researcher to do this is the tracing subsystem.</p><h3>Tracing Motivation</h3>
<p>There are many ways to get information out of a program. The most straightforward way is to just directly print the information to the standard output, as in,</p>
<pre>
#include &lt;iostream&gt;
...
int main ()
{
  ...
  std::cout &lt;&lt; "The value of x is " &lt;&lt; x &lt;&lt; std::endl;
  ...
}
</pre>
<p>This is workable in small environments, but as your simulations get more and more complicated, you end up with more and more prints and the task of parsing and performing computations on the output begins to get harder and harder.</p><p>Another thing to consider is that every time a new tidbit is needed, the software core must be edited and another print introduced. There is no standardized way to control all of this output, so the amount of output tends to grow without bounds. Eventually, the bandwidth required for simply outputting this information begins to limit the running time of the simulation. The output files grow to enormous sizes and parsing them becomes a problem.</p><p><em>ns-3</em> provides a simple mechanism for logging and providing some control over output via <em>Log Components</em>, but the level of control is not very fine grained at all. The logging module is a relatively blunt instrument.</p><p>It is desirable to have a facility that allows one to reach into the core system and only get the information required without having to change and recompile the core system. Even better would be a system that notified the user when an item of interest changed or an interesting event happened.</p><p>The <em>ns-3</em> tracing system is designed to work along those lines and is well-integrated with the Attribute and Config substems allowing for relatively simple use scenarios.</p>
<h3>Overview</h3>
<p>The tracing subsystem relies heavily on the <em>ns-3</em> Callback and Attribute mechanisms. You should read and understand the corresponding sections of the manual before attempting to understand the tracing system.</p><p>The <em>ns-3</em> tracing system is built on the concepts of independent tracing sources and tracing sinks; along with a uniform mechanism for connecting sources to sinks.</p><p>Trace sources are entities that can signal events that happen in a simulation and provide access to interesting underlying data. For example, a trace source could indicate when a packet is received by a net device and provide access to the packet contents for interested trace sinks. A trace source might also indicate when an interesting state change happens in a model. For example, the congestion window of a TCP model is a prime candidate for a trace source.</p><p>Trace sources are not useful by themselves; they must be connected to other pieces of code that actually do something useful with the information provided by the source.  The entities that consume trace information are called trace sinks. Trace sources are generators of events and trace sinks are consumers.</p><p>This explicit division allows for large numbers of trace sources to be scattered around the system in places which model authors believe might be useful. Unless a user connects a trace sink to one of these sources, nothing is output. This arrangement allows relatively unsophisticated users to attach new types of sinks to existing tracing sources, without requiring editing and recompiling the core or models of the simulator.</p><p>There can be zero or more consumers of trace events generated by a trace source. One can think of a trace source as a kind of point-to-multipoint information link.</p><p>The "transport protocol" for this conceptual point-to-multipoint link is an <em>ns-3</em> <strong>Callback</strong>.</p><p>Recall from the Callback Section that callback facility is a way to allow two modules in the system to communicate via function calls while at the same time decoupling the calling function from the called class completely. This is the same requirement as outlined above for the tracing system.</p><p>Basically, a trace source <em>is</em> a callback to which multiple functions may be registered. When a trace sink expresses interest in receiving trace events, it adds a callback to a list of callbacks held by the trace source. When an interesting event happens, the trace source invokes its <strong>operator()</strong> providing zero or more parameters. This tells the source to go through its list of callbacks invoking each one in turn. In this way, the parameter(s) are communicated to the trace sinks, which are just functions.</p>
<h3>The Simplest Example</h3>
<p>It will be useful to go walk a quick example just to reinforce what we&apos;ve said.:</p>
<pre>
#include "ns3/object.h"
#include "ns3/uinteger.h"
#include "ns3/traced-value.h""
#include "ns3/trace-source-accessor.h"

#include &lt;iostream&gt;

using namespace ns3;
</pre>
<p>The first thing to do is include the required files. As mentioned above, the trace system makes heavy use of the Object and Attribute systems. The first two includes bring in the declarations for those systems. The file, <strong>traced-value.h</strong> brings in the required declarations for tracing data that obeys value semantics.</p><p>In general, value semantics just means that you can pass the object around, not an address. In order to use value semantics at all you have to have an object with an associated copy constructor and assignment operator available. We extend the requirements to talk about the set of operators that are pre-defined for plain-old-data (POD) types. Operator=, operator++, operator--, operator+, operator==, etc.</p><p>What this all means is that you will be able to trace changes to an object made using those operators.:</p>
<pre>
class MyObject : public Object
{
public:
  static TypeId GetTypeId (void)
  {
    static TypeId tid = TypeId ("MyObject")
      .SetParent (Object::GetTypeId ())
      .AddConstructor&lt;MyObject&gt; ()
      .AddTraceSource ("MyInteger",
                       "An integer value to trace.",
                       MakeTraceSourceAccessor (&MyObject::m_myInt))
      ;
    return tid;
  }

  MyObject () {}
  TracedValue&lt;uint32_t&gt; m_myInt;
};
</pre>
<p>Since the tracing system is integrated with Attributes, and Attributes work with Objects, there must be an <em>ns-3</em> <strong>Object</strong> for the trace source to live in. The two important lines of code are the <strong>.AddTraceSource</strong> and the <strong>TracedValue</strong> declaration.</p><p>The <strong>.AddTraceSource</strong> provides the "hooks" used for connecting the trace source to the outside world. The <strong>TracedValue</strong> declaration provides the infrastructure that overloads the operators mentioned above and drives the callback process.:</p>
<pre>
void
IntTrace (Int oldValue, Int newValue)
{
  std::cout &lt;&lt; "Traced " &lt;&lt; oldValue &lt;&lt; " to " &lt;&lt; newValue &lt;&lt; std::endl;
}
</pre>
<p>This is the definition of the trace sink. It corresponds directly to a callback function. This function will be called whenever one of the operators of the <strong>TracedValue</strong> is executed.:</p>
<pre>
int
main (int argc, char *argv[])
{
  Ptr&lt;MyObject&gt; myObject = CreateObject&lt;MyObject&gt; ();

  myObject-&gt;TraceConnectWithoutContext ("MyInteger", MakeCallback(&IntTrace));

  myObject-&gt;m_myInt = 1234;
}
</pre>
<p>In this snippet, the first thing that needs to be done is to create the object in which the trace source lives.</p><p>The next step, the <strong>TraceConnectWithoutContext</strong>, forms the connection between the trace source and the trace sink. Notice the <strong>MakeCallback</strong> template function. Recall from the Callback section that this creates the specialized functor responsible for providing the overloaded <strong>operator()</strong> used to "fire" the callback. The overloaded operators (++, --, etc.) will use this <strong>operator()</strong> to actually invoke the callback. The <strong>TraceConnectWithoutContext</strong>, takes a string parameter that provides the name of the Attribute assigned to the trace source. Let&apos;s ignore the bit about context for now since it is not important yet.</p><p>Finally, the line,:</p>
<pre>
myObject-&gt;m_myInt = 1234;
</pre>
<p>should be interpreted as an invocation of <strong>operator=</strong> on the member variable <strong>m_myInt</strong> with the integer 1234 passed as a parameter. It turns out that this operator is defined (by <strong>TracedValue</strong>) to execute a callback that returns void and takes two integer values as parameters -- an old value and a new value for the integer in question. That is exactly the function signature for the callback function we provided -- <strong>IntTrace</strong>.</p><p>To summarize, a trace source is, in essence, a variable that holds a list of callbacks. A trace sink is a function used as the target of a callback. The Attribute and object type information systems are used to provide a way to connect trace sources to trace sinks. The act of "hitting" a trace source is executing an operator on the trace source which fires callbacks. This results in the trace sink callbacks registering interest in the source being called with the parameters provided by the source.</p>
<h3>Using the Config Subsystem to Connect to Trace Sources</h3>
<p>The <strong>TraceConnectWithoutContext</strong> call shown above in the simple example is actually very rarely used in the system. More typically, the <strong>Config</strong> subsystem is used to allow selecting a trace source in the system using what is called a <em>config path</em>.</p><p>For example, one might find something that looks like the following in the system (taken from <strong>examples/tcp-large-transfer.cc</strong>):</p>
<pre>
void CwndTracer (uint32_t oldval, uint32_t newval) {}

...

Config::ConnectWithoutContext (
  "/NodeList/0/$ns3::TcpL4Protocol/SocketList/0/CongestionWindow",
  MakeCallback (&CwndTracer));
</pre>
<p>This should look very familiar. It is the same thing as the previous example, except that a static member function of class <strong>Config</strong> is being called instead of a method on <strong>Object</strong>; and instead of an <strong>Attribute</strong> name, a path is being provided.</p><p>The first thing to do is to read the path backward. The last segment of the path must be an <strong>Attribute</strong> of an <strong>Object</strong>. In fact, if you had a pointer to the <strong>Object</strong> that has the "CongestionWindow" <strong>Attribute</strong> handy (call it <strong>theObject</strong>), you could write this just like the previous example::</p>
<pre>
void CwndTracer (uint32_t oldval, uint32_t newval) {}

...

theObject-&gt;TraceConnectWithoutContext ("CongestionWindow", MakeCallback (&CwndTracer));
</pre>
<p>It turns out that the code for <strong>Config::ConnectWithoutContext</strong> does exactly that. This function takes a path that represents a chain of <strong>Object</strong> pointers and follows them until it gets to the end of the path and interprets the last segment as an <strong>Attribute</strong> on the last object. Let&apos;s walk through what happens.</p><p>The leading "/" character in the path refers to a so-called namespace. One of the predefined namespaces in the config system is "NodeList" which is a list of all of the nodes in the simulation. Items in the list are referred to by indices into the list, so "/NodeList/0" refers to the zeroth node in the list of nodes created by the simulation. This node is actually a <strong>Ptr&lt;Node&gt;</strong> and so is a subclass of an <strong>ns3::Object</strong>.</p><p>As described in the <em>Object-model</em> section, <em>ns-3</em> supports an object aggregation model. The next path segment begins with the "$" character which indicates a <strong>GetObject</strong> call should be made looking for the type that follows. When a node is initialized by an <strong>InternetStackHelper</strong> a number of interfaces are aggregated to the node. One of these is the TCP level four protocol. The runtime type of this protocol object is "ns3::TcpL4Protocol". When the <strong>GetObject</strong> is executed, it returns a pointer to the object of this type.</p><p>The <strong>TcpL4Protocol</strong> class defines an Attribute called "SocketList" which is a list of sockets.  Each socket is actually an <strong>ns3::Object</strong> with its own <strong>Attributes</strong>.  The items in the list of sockets are referred to by index just as in the NodeList, so "SocketList/0" refers to the zeroth socket in the list of sockets on the zeroth node in the NodeList -- the first node constructed in the simulation.</p><p>This socket, the type of which turns out to be an <strong>ns3::TcpSocketImpl</strong> defines an attribute called "CongestionWindow" which is a <strong>TracedValue&lt;uint32_t&gt;</strong>. The <strong>Config::ConnectWithoutContext</strong> now does a,:</p>
<pre>
object-&gt;TraceConnectWithoutContext ("CongestionWindow", MakeCallback (&CwndTracer));
</pre>
<p>using the object pointer from "SocketList/0" which makes the connection between the trace source defined in the socket to the callback -- <strong>CwndTracer</strong>.</p><p>Now, whenever a change is made to the <strong>TracedValue&lt;uint32_t&gt;</strong> representing the congestion window in the TCP socket, the registered callback will be executed and the function <strong>CwndTracer</strong> will be called printing out the old and new values of the TCP congestion window.</p>
<h3>Using the Tracing API</h3>
<p>There are three levels of interaction with the tracing system:</p><ul>
<li><p>Beginning user can easily control which objects are participating in tracing;</p></li><li><p>Intermediate users can extend the tracing system to modify the output format generated or use existing trace sources in different ways, without modifying the core of the simulator;</p></li><li><p>Advanced users can modify the simulator core to add new tracing sources and sinks.</p></li>
</ul>
<h3>Using Trace Helpers</h3>
<p>The <em>ns-3</em> trace helpers provide a rich environment for configuring and selecting different trace events and writing them to files. In previous sections, primarily "Building Topologies," we have seen several varieties of the trace helper methods designed for use inside other (device) helpers.</p><p>Perhaps you will recall seeing some of these variations::</p>
<pre>
pointToPoint.EnablePcapAll ("second");
pointToPoint.EnablePcap ("second", p2pNodes.Get (0)-&gt;GetId (), 0);
csma.EnablePcap ("third", csmaDevices.Get (0), true);
pointToPoint.EnableAsciiAll (ascii.CreateFileStream ("myfirst.tr"));
</pre>
<p>What may not be obvious, though, is that there is a consistent model for all of the trace-related methods found in the system. We will now take a little time and take a look at the "big picture".</p><p>There are currently two primary use cases of the tracing helpers in <em>ns-3</em>: Device helpers and protocol helpers. Device helpers look at the problem of specifying which traces should be enabled through a node, device pair.  For example, you may want to specify that pcap tracing should be enabled on a particular device on a specific node. This follows from the <em>ns-3</em> device conceptual model, and also the conceptual models of the various device helpers. Following naturally from this, the files created follow a &lt;prefix&gt;-&lt;node&gt;-&lt;device&gt; naming convention.</p><p>Protocol helpers look at the problem of specifying which traces should be enabled through a protocol and interface pair. This follows from the <em>ns-3</em> protocol stack conceptual model, and also the conceptual models of internet stack helpers. Naturally, the trace files should follow a &lt;prefix&gt;-&lt;protocol&gt;-&lt;interface&gt; naming convention.</p><p>The trace helpers therefore fall naturally into a two-dimensional taxonomy. There are subtleties that prevent all four classes from behaving identically, but we do strive to make them all work as similarly as possible; and whenever possible there are analogs for all methods in all classes.:</p>
<pre>
                 | pcap | ascii |
-----------------+------+-------|
Device Helper    |      |       |
-----------------+------+-------|
Protocol Helper  |      |       |
-----------------+------+-------|
</pre>
<p>We use an approach called a <strong>mixin</strong> to add tracing functionality to our helper classes. A <strong>mixin</strong> is a class that provides functionality to that is inherited by a subclass. Inheriting from a mixin is not considered a form of specialization but is really a way to collect functionality.</p><p>Let&apos;s take a quick look at all four of these cases and their respective <strong>mixins</strong>.</p>
<h3>Pcap Tracing Device Helpers</h3>
<p>The goal of these helpers is to make it easy to add a consistent pcap trace facility to an <em>ns-3</em> device. We want all of the various flavors of pcap tracing to work the same across all devices, so the methods of these helpers are inherited by device helpers. Take a look at <strong>src/network/helper/trace-helper.h</strong> if you want to follow the discussion while looking at real code.</p><p>The class <strong>PcapHelperForDevice</strong> is a <strong>mixin</strong> provides the high level functionality for using pcap tracing in an <em>ns-3</em> device. Every device must implement a single virtual method inherited from this class.:</p>
<pre>
virtual void EnablePcapInternal (std::string prefix, Ptr&lt;NetDevice&gt; nd, bool promiscuous) = 0;
</pre>
<p>The signature of this method reflects the device-centric view of the situation at this level. All of the public methods inherited from class <strong>PcapUserHelperForDevice</strong> reduce to calling this single device-dependent implementation method. For example, the lowest level pcap method,:</p>
<pre>
void EnablePcap (std::string prefix, Ptr&lt;NetDevice&gt; nd, bool promiscuous = false, bool explicitFilename = false);
</pre>
<p>will call the device implementation of <strong>EnablePcapInternal</strong> directly. All other public pcap tracing methods build on this implementation to provide additional user-level functionality. What this means to the user is that all device helpers in the system will have all of the pcap trace methods available; and these methods will all work in the same way across devices if the device implements <strong>EnablePcapInternal</strong> correctly.</p>
<h3>Pcap Tracing Device Helper Methods</h3>

<pre>
void EnablePcap (std::string prefix, Ptr&lt;NetDevice&gt; nd, bool promiscuous = false, bool explicitFilename = false);
void EnablePcap (std::string prefix, std::string ndName, bool promiscuous = false, bool explicitFilename = false);
void EnablePcap (std::string prefix, NetDeviceContainer d, bool promiscuous = false);
void EnablePcap (std::string prefix, NodeContainer n, bool promiscuous = false);
void EnablePcap (std::string prefix, uint32_t nodeid, uint32_t deviceid, bool promiscuous = false);
void EnablePcapAll (std::string prefix, bool promiscuous = false);
</pre>
<p>In each of the methods shown above, there is a default parameter called <strong>promiscuous</strong> that defaults to false. This parameter indicates that the trace should not be gathered in promiscuous mode. If you do want your traces to include all traffic seen by the device (and if the device supports a promiscuous mode) simply add a true parameter to any of the calls above. For example,:</p>
<pre>
Ptr&lt;NetDevice&gt; nd;
...
helper.EnablePcap ("prefix", nd, true);
</pre>
<p>will enable promiscuous mode captures on the <strong>NetDevice</strong> specified by <strong>nd</strong>.</p><p>The first two methods also include a default parameter called <strong>explicitFilename</strong> that will be discussed below.</p><p>You are encouraged to peruse the Doxygen for class <strong>PcapHelperForDevice</strong> to find the details of these methods; but to summarize ...</p><p>You can enable pcap tracing on a particular node/net-device pair by providing a <strong>Ptr&lt;NetDevice&gt;</strong> to an <strong>EnablePcap</strong> method. The <strong>Ptr&lt;Node&gt;</strong> is implicit since the net device must belong to exactly one <strong>Node</strong>. For example,:</p>
<pre>
Ptr&lt;NetDevice&gt; nd;
...
helper.EnablePcap ("prefix", nd);
</pre>
<p>You can enable pcap tracing on a particular node/net-device pair by providing a <strong>std::string</strong> representing an object name service string to an <strong>EnablePcap</strong> method.  The <strong>Ptr&lt;NetDevice&gt;</strong> is looked up from the name string.  Again, the <strong>&lt;Node&gt;</strong> is implicit since the named net device must belong to exactly one <strong>Node</strong>.  For example,:</p>
<pre>
Names::Add ("server" ...);
Names::Add ("server/eth0" ...);
...
helper.EnablePcap ("prefix", "server/ath0");
</pre>
<p>You can enable pcap tracing on a collection of node/net-device pairs by providing a <strong>NetDeviceContainer</strong>. For each <strong>NetDevice</strong> in the container the type is checked.  For each device of the proper type (the same type as is managed by the device helper), tracing is enabled. Again, the <strong>&lt;Node&gt;</strong> is implicit since the found net device must belong to exactly one <strong>Node</strong>. For example,:</p>
<pre>
NetDeviceContainer d = ...;
...
helper.EnablePcap ("prefix", d);
</pre>
<p>You can enable pcap tracing on a collection of node/net-device pairs by providing a <strong>NodeContainer</strong>. For each <strong>Node</strong> in the <strong>NodeContainer</strong> its attached <strong>NetDevices</strong> are iterated.  For each <strong>NetDevice</strong> attached to each node in the container, the type of that device is checked.  For each device of the proper type (the same type as is managed by the device helper), tracing is enabled.:</p>
<pre>
NodeContainer n;
...
helper.EnablePcap ("prefix", n);
</pre>
<p>You can enable pcap tracing on the basis of node ID and device ID as well as with explicit <strong>Ptr</strong>. Each <strong>Node</strong> in the system has an integer node ID and each device connected to a node has an integer device ID.:</p>
<pre>
helper.EnablePcap ("prefix", 21, 1);
</pre>
<p>Finally, you can enable pcap tracing for all devices in the system, with the same type as that managed by the device helper.:</p>
<pre>
helper.EnablePcapAll ("prefix");
</pre>

<h3>Pcap Tracing Device Helper Filename Selection</h3>
<p>Implicit in the method descriptions above is the construction of a complete filename by the implementation method. By convention, pcap traces in the <em>ns-3</em> system are of the form <strong>&lt;prefix&gt;-&lt;node id&gt;-&lt;device id&gt;.pcap</strong></p><p>As previously mentioned, every node in the system will have a system-assigned node id; and every device will have an interface index (also called a device id) relative to its node. By default, then, a pcap trace file created as a result of enabling tracing on the first device of node 21 using the prefix "prefix" would be <strong>prefix-21-1.pcap</strong>.</p><p>You can always use the <em>ns-3</em> object name service to make this more clear.  For example, if you use the object name service to assign the name "server" to node 21, the resulting pcap trace file name will automatically become, <strong>prefix-server-1.pcap</strong> and if you also assign the name "eth0" to the device, your pcap file name will automatically pick this up and be called <strong>prefix-server-eth0.pcap</strong>.</p><p>Finally, two of the methods shown above,:</p>
<pre>
void EnablePcap (std::string prefix, Ptr&lt;NetDevice&gt; nd, bool promiscuous = false, bool explicitFilename = false);
void EnablePcap (std::string prefix, std::string ndName, bool promiscuous = false, bool explicitFilename = false);
</pre>
<p>have a default parameter called <strong>explicitFilename</strong>. When set to true, this parameter disables the automatic filename completion mechanism and allows you to create an explicit filename. This option is only available in the methods which enable pcap tracing on a single device.</p><p>For example, in order to arrange for a device helper to create a single promiscuous pcap capture file of a specific name (<strong>my-pcap-file.pcap</strong>) on a given device, one could::</p>
<pre>
Ptr&lt;NetDevice&gt; nd;
...
helper.EnablePcap ("my-pcap-file.pcap", nd, true, true);
</pre>
<p>The first <strong>true</strong> parameter enables promiscuous mode traces and the second tells the helper to interpret the <strong>prefix</strong> parameter as a complete filename.</p>
<h3>Ascii Tracing Device Helpers</h3>
<p>The behavior of the ascii trace helper <strong>mixin</strong> is substantially similar to the pcap version. Take a look at <strong>src/network/helper/trace-helper.h</strong> if you want to follow the discussion while looking at real code.</p><p>The class <strong>AsciiTraceHelperForDevice</strong> adds the high level functionality for using ascii tracing to a device helper class. As in the pcap case, every device must implement a single virtual method inherited from the ascii trace <strong>mixin</strong>.:</p>
<pre>
virtual void EnableAsciiInternal (Ptr&lt;OutputStreamWrapper&gt; stream, std::string prefix, Ptr&lt;NetDevice&gt; nd) = 0;
</pre>
<p>The signature of this method reflects the device-centric view of the situation at this level; and also the fact that the helper may be writing to a shared output stream. All of the public ascii-trace-related methods inherited from class <strong>AsciiTraceHelperForDevice</strong> reduce to calling this single device- dependent implementation method. For example, the lowest level ascii trace methods,:</p>
<pre>
void EnableAscii (std::string prefix, Ptr&lt;NetDevice&gt; nd);
void EnableAscii (Ptr&lt;OutputStreamWrapper&gt; stream, Ptr&lt;NetDevice&gt; nd);
</pre>
<p>will call the device implementation of <strong>EnableAsciiInternal</strong> directly, providing either a valid prefix or stream.  All other public ascii tracing methods will build on these low-level functions to provide additional user-level functionality. What this means to the user is that all device helpers in the system will have all of the ascii trace methods available; and these methods will all work in the same way across devices if the devices implement <strong>EnablAsciiInternal</strong> correctly.</p>
<h3>Ascii Tracing Device Helper Methods</h3>

<pre>
void EnableAscii (std::string prefix, Ptr&lt;NetDevice&gt; nd);
void EnableAscii (Ptr&lt;OutputStreamWrapper&gt; stream, Ptr&lt;NetDevice&gt; nd);

void EnableAscii (std::string prefix, std::string ndName);
void EnableAscii (Ptr&lt;OutputStreamWrapper&gt; stream, std::string ndName);

void EnableAscii (std::string prefix, NetDeviceContainer d);
void EnableAscii (Ptr&lt;OutputStreamWrapper&gt; stream, NetDeviceContainer d);

void EnableAscii (std::string prefix, NodeContainer n);
void EnableAscii (Ptr&lt;OutputStreamWrapper&gt; stream, NodeContainer n);

void EnableAscii (std::string prefix, uint32_t nodeid, uint32_t deviceid);
void EnableAscii (Ptr&lt;OutputStreamWrapper&gt; stream, uint32_t nodeid, uint32_t deviceid);

void EnableAsciiAll (std::string prefix);
void EnableAsciiAll (Ptr&lt;OutputStreamWrapper&gt; stream);
</pre>
<p>You are encouraged to peruse the Doxygen for class <strong>TraceHelperForDevice</strong> to find the details of these methods; but to summarize ...</p><p>There are twice as many methods available for ascii tracing as there were for pcap tracing. This is because, in addition to the pcap-style model where traces from each unique node/device pair are written to a unique file, we support a model in which trace information for many node/device pairs is written to a common file.  This means that the &lt;prefix&gt;-&lt;node&gt;-&lt;device&gt; file name generation mechanism is replaced by a mechanism to refer to a common file; and the number of API methods is doubled to allow all combinations.</p><p>Just as in pcap tracing, you can enable ascii tracing on a particular node/net-device pair by providing a <strong>Ptr&lt;NetDevice&gt;</strong> to an <strong>EnableAscii</strong> method. The <strong>Ptr&lt;Node&gt;</strong> is implicit since the net device must belong to exactly one <strong>Node</strong>. For example,:</p>
<pre>
Ptr&lt;NetDevice&gt; nd;
...
helper.EnableAscii ("prefix", nd);
</pre>
<p>In this case, no trace contexts are written to the ascii trace file since they would be redundant. The system will pick the file name to be created using the same rules as described in the pcap section, except that the file will have the suffix ".tr" instead of ".pcap".</p><p>If you want to enable ascii tracing on more than one net device and have all traces sent to a single file, you can do that as well by using an object to refer to a single file::</p>
<pre>
Ptr&lt;NetDevice&gt; nd1;
Ptr&lt;NetDevice&gt; nd2;
...
Ptr&lt;OutputStreamWrapper&gt; stream = asciiTraceHelper.CreateFileStream ("trace-file-name.tr");
...
helper.EnableAscii (stream, nd1);
helper.EnableAscii (stream, nd2);
</pre>
<p>In this case, trace contexts are written to the ascii trace file since they are required to disambiguate traces from the two devices.  Note that since the user is completely specifying the file name, the string should include the ".tr" for consistency.</p><p>You can enable ascii tracing on a particular node/net-device pair by providing a <strong>std::string</strong> representing an object name service string to an <strong>EnablePcap</strong> method.  The <strong>Ptr&lt;NetDevice&gt;</strong> is looked up from the name string.  Again, the <strong>&lt;Node&gt;</strong> is implicit since the named net device must belong to exactly one <strong>Node</strong>.  For example,:</p>
<pre>
Names::Add ("client" ...);
Names::Add ("client/eth0" ...);
Names::Add ("server" ...);
Names::Add ("server/eth0" ...);
...
helper.EnableAscii ("prefix", "client/eth0");
helper.EnableAscii ("prefix", "server/eth0");
</pre>
<p>This would result in two files named <strong>prefix-client-eth0.tr</strong> and <strong>prefix-server-eth0.tr</strong> with traces for each device in the respective trace file. Since all of the EnableAscii functions are overloaded to take a stream wrapper, you can use that form as well::</p>
<pre>
Names::Add ("client" ...);
Names::Add ("client/eth0" ...);
Names::Add ("server" ...);
Names::Add ("server/eth0" ...);
...
Ptr&lt;OutputStreamWrapper&gt; stream = asciiTraceHelper.CreateFileStream ("trace-file-name.tr");
...
helper.EnableAscii (stream, "client/eth0");
helper.EnableAscii (stream, "server/eth0");
</pre>
<p>This would result in a single trace file called <strong>trace-file-name.tr</strong> that contains all of the trace events for both devices. The events would be disambiguated by trace context strings.</p><p>You can enable ascii tracing on a collection of node/net-device pairs by providing a <strong>NetDeviceContainer</strong>. For each <strong>NetDevice</strong> in the container the type is checked. For each device of the proper type (the same type as is managed by the device helper), tracing is enabled. Again, the <strong>&lt;Node&gt;</strong> is implicit since the found net device must belong to exactly one <strong>Node</strong>.  For example,:</p>
<pre>
NetDeviceContainer d = ...;
...
helper.EnableAscii ("prefix", d);
</pre>
<p>This would result in a number of ascii trace files being created, each of which follows the &lt;prefix&gt;-&lt;node id&gt;-&lt;device id&gt;.tr convention. Combining all of the traces into a single file is accomplished similarly to the examples above::</p>
<pre>
NetDeviceContainer d = ...;
...
Ptr&lt;OutputStreamWrapper&gt; stream = asciiTraceHelper.CreateFileStream ("trace-file-name.tr");
...
helper.EnableAscii (stream, d);
</pre>
<p>You can enable ascii tracing on a collection of node/net-device pairs by providing a <strong>NodeContainer</strong>. For each <strong>Node</strong> in the <strong>NodeContainer</strong> its attached <strong>NetDevices</strong> are iterated.  For each <strong>NetDevice</strong> attached to each node in the container, the type of that device is checked.  For each device of the proper type (the same type as is managed by the device helper), tracing is enabled.:</p>
<pre>
NodeContainer n;
...
helper.EnableAscii ("prefix", n);
</pre>
<p>This would result in a number of ascii trace files being created, each of which follows the &lt;prefix&gt;-&lt;node id&gt;-&lt;device id&gt;.tr convention. Combining all of the traces into a single file is accomplished similarly to the examples above:</p><p>You can enable pcap tracing on the basis of node ID and device ID as well as with explicit <strong>Ptr</strong>. Each <strong>Node</strong> in the system has an integer node ID and each device connected to a node has an integer device ID.:</p>
<pre>
helper.EnableAscii ("prefix", 21, 1);
</pre>
<p>Of course, the traces can be combined into a single file as shown above.</p><p>Finally, you can enable pcap tracing for all devices in the system, with the same type as that managed by the device helper.:</p>
<pre>
helper.EnableAsciiAll ("prefix");
</pre>
<p>This would result in a number of ascii trace files being created, one for every device in the system of the type managed by the helper. All of these files will follow the &lt;prefix&gt;-&lt;node id&gt;-&lt;device id&gt;.tr convention. Combining all of the traces into a single file is accomplished similarly to the examples above.</p>
<h3>Ascii Tracing Device Helper Filename Selection</h3>
<p>Implicit in the prefix-style method descriptions above is the construction of the complete filenames by the implementation method. By convention, ascii traces in the <em>ns-3</em> system are of the form <strong>&lt;prefix&gt;-&lt;node id&gt;-&lt;device id&gt;.tr</strong>.</p><p>As previously mentioned, every node in the system will have a system-assigned node id; and every device will have an interface index (also called a device id) relative to its node.  By default, then, an ascii trace file created as a result of enabling tracing on the first device of node 21, using the prefix "prefix", would be <strong>prefix-21-1.tr</strong>.</p><p>You can always use the <em>ns-3</em> object name service to make this more clear.  For example, if you use the object name service to assign the name "server" to node 21, the resulting ascii trace file name will automatically become, <strong>prefix-server-1.tr</strong> and if you also assign the name "eth0" to the device, your ascii trace file name will automatically pick this up and be called <strong>prefix-server-eth0.tr</strong>.</p>
<h3>Pcap Tracing Protocol Helpers</h3>
<p>The goal of these <strong>mixins</strong> is to make it easy to add a consistent pcap trace facility to protocols. We want all of the various flavors of pcap tracing to work the same across all protocols, so the methods of these helpers are inherited by stack helpers. Take a look at <strong>src/network/helper/trace-helper.h</strong> if you want to follow the discussion while looking at real code.</p><p>In this section we will be illustrating the methods as applied to the protocol <strong>Ipv4</strong>.  To specify traces in similar protocols, just substitute the appropriate type.  For example, use a <strong>Ptr&lt;Ipv6&gt;</strong> instead of a <strong>Ptr&lt;Ipv4&gt;</strong> and call <strong>EnablePcapIpv6</strong> instead of <strong>EnablePcapIpv4</strong>.</p><p>The class <strong>PcapHelperForIpv4</strong> provides the high level functionality for using pcap tracing in the <strong>Ipv4</strong> protocol.  Each protocol helper enabling these methods must implement a single virtual method inherited from this class.  There will be a separate implementation for <strong>Ipv6</strong>, for example, but the only difference will be in the method names and signatures.  Different method names are required to disambiguate class <strong>Ipv4</strong> from <strong>Ipv6</strong> which are both derived from class <strong>Object</strong>, and methods that share the same signature.:</p>
<pre>
virtual void EnablePcapIpv4Internal (std::string prefix, Ptr&lt;Ipv4&gt; ipv4, uint32_t interface) = 0;
</pre>
<p>The signature of this method reflects the protocol and interface-centric view of the situation at this level. All of the public methods inherited from class <strong>PcapHelperForIpv4</strong> reduce to calling this single device-dependent implementation method.  For example, the lowest level pcap method,:</p>
<pre>
void EnablePcapIpv4 (std::string prefix, Ptr&lt;Ipv4&gt; ipv4, uint32_t interface);
</pre>
<p>will call the device implementation of <strong>EnablePcapIpv4Internal</strong> directly.  All other public pcap tracing methods build on this implementation to provide additional user-level functionality. What this means to the user is that all protocol helpers in the system will have all of the pcap trace methods available; and these methods will all work in the same way across protocols if the helper implements <strong>EnablePcapIpv4Internal</strong> correctly.</p>
<h3>Pcap Tracing Protocol Helper Methods</h3>
<p>These methods are designed to be in one-to-one correspondence with the <strong>Node</strong>- and <strong>NetDevice</strong>- centric versions of the device versions. Instead of <strong>Node</strong> and <strong>NetDevice</strong> pair constraints, we use protocol and interface constraints.</p><p>Note that just like in the device version, there are six methods::</p>
<pre>
void EnablePcapIpv4 (std::string prefix, Ptr&lt;Ipv4&gt; ipv4, uint32_t interface);
void EnablePcapIpv4 (std::string prefix, std::string ipv4Name, uint32_t interface);
void EnablePcapIpv4 (std::string prefix, Ipv4InterfaceContainer c);
void EnablePcapIpv4 (std::string prefix, NodeContainer n);
void EnablePcapIpv4 (std::string prefix, uint32_t nodeid, uint32_t interface);
void EnablePcapIpv4All (std::string prefix);
</pre>
<p>You are encouraged to peruse the Doxygen for class <strong>PcapHelperForIpv4</strong> to find the details of these methods; but to summarize ...</p><p>You can enable pcap tracing on a particular protocol/interface pair by providing a <strong>Ptr&lt;Ipv4&gt;</strong> and <strong>interface</strong> to an <strong>EnablePcap</strong> method.  For example,:</p>
<pre>
Ptr&lt;Ipv4&gt; ipv4 = node-&gt;GetObject&lt;Ipv4&gt; ();
...
helper.EnablePcapIpv4 ("prefix", ipv4, 0);
</pre>
<p>You can enable pcap tracing on a particular node/net-device pair by providing a <strong>std::string</strong> representing an object name service string to an <strong>EnablePcap</strong> method.  The <strong>Ptr&lt;Ipv4&gt;</strong> is looked up from the name string.  For example,:</p>
<pre>
Names::Add ("serverIPv4" ...);
...
helper.EnablePcapIpv4 ("prefix", "serverIpv4", 1);
</pre>
<p>You can enable pcap tracing on a collection of protocol/interface pairs by providing an <strong>Ipv4InterfaceContainer</strong>. For each <strong>Ipv4</strong> / interface pair in the container the protocol type is checked. For each protocol of the proper type (the same type as is managed by the device helper), tracing is enabled for the corresponding interface.  For example,:</p>
<pre>
NodeContainer nodes;
...
NetDeviceContainer devices = deviceHelper.Install (nodes);
...
Ipv4AddressHelper ipv4;
ipv4.SetBase ("10.1.1.0", "255.255.255.0");
Ipv4InterfaceContainer interfaces = ipv4.Assign (devices);
...
helper.EnablePcapIpv4 ("prefix", interfaces);
</pre>
<p>You can enable pcap tracing on a collection of protocol/interface pairs by providing a <strong>NodeContainer</strong>. For each <strong>Node</strong> in the <strong>NodeContainer</strong> the appropriate protocol is found. For each protocol, its interfaces are enumerated and tracing is enabled on the resulting pairs. For example,:</p>
<pre>
NodeContainer n;
...
helper.EnablePcapIpv4 ("prefix", n);
</pre>
<p>You can enable pcap tracing on the basis of node ID and interface as well. In this case, the node-id is translated to a <strong>Ptr&lt;Node&gt;</strong> and the appropriate protocol is looked up in the node. The resulting protocol and interface are used to specify the resulting trace source.:</p>
<pre>
helper.EnablePcapIpv4 ("prefix", 21, 1);
</pre>
<p>Finally, you can enable pcap tracing for all interfaces in the system, with associated protocol being the same type as that managed by the device helper.:</p>
<pre>
helper.EnablePcapIpv4All ("prefix");
</pre>

<h3>Pcap Tracing Protocol Helper Filename Selection</h3>
<p>Implicit in all of the method descriptions above is the construction of the complete filenames by the implementation method. By convention, pcap traces taken for devices in the <em>ns-3</em> system are of the form <strong>&lt;prefix&gt;-&lt;node</strong> id&gt;-&lt;device id&gt;.pcap. In the case of protocol traces, there is a one-to-one correspondence between protocols and <strong>Nodes</strong>. This is because protocol <strong>Objects</strong> are aggregated to <strong>Node Objects</strong>. Since there is no global protocol id in the system, we use the corresponding node id in file naming. Therefore there is a possibility for file name collisions in automatically chosen trace file names. For this reason, the file name convention is changed for protocol traces.</p><p>As previously mentioned, every node in the system will have a system-assigned node id. Since there is a one-to-one correspondence between protocol instances and node instances we use the node id. Each interface has an interface id relative to its protocol. We use the convention "&lt;prefix&gt;-n&lt;node id&gt;-i&lt;interface id&gt;.pcap" for trace file naming in protocol helpers.</p><p>Therefore, by default, a pcap trace file created as a result of enabling tracing on interface 1 of the Ipv4 protocol of node 21 using the prefix "prefix" would be "prefix-n21-i1.pcap".</p><p>You can always use the <em>ns-3</em> object name service to make this more clear. For example, if you use the object name service to assign the name "serverIpv4" to the Ptr&lt;Ipv4&gt; on node 21, the resulting pcap trace file name will automatically become, "prefix-nserverIpv4-i1.pcap".</p>
<h3>Ascii Tracing Protocol Helpers</h3>
<p>The behavior of the ascii trace helpers is substantially similar to the pcap case.  Take a look at <strong>src/network/helper/trace-helper.h</strong> if you want to follow the discussion while looking at real code.</p><p>In this section we will be illustrating the methods as applied to the protocol <strong>Ipv4</strong>. To specify traces in similar protocols, just substitute the appropriate type. For example, use a <strong>Ptr&lt;Ipv6&gt;</strong> instead of a <strong>Ptr&lt;Ipv4&gt;</strong> and call <strong>EnableAsciiIpv6</strong> instead of <strong>EnableAsciiIpv4</strong>.</p><p>The class <strong>AsciiTraceHelperForIpv4</strong> adds the high level functionality for using ascii tracing to a protocol helper. Each protocol that enables these methods must implement a single virtual method inherited from this class.:</p>
<pre>
virtual void EnableAsciiIpv4Internal (Ptr&lt;OutputStreamWrapper&gt; stream, std::string prefix,
                                      Ptr&lt;Ipv4&gt; ipv4, uint32_t interface) = 0;
</pre>
<p>The signature of this method reflects the protocol- and interface-centric view of the situation at this level; and also the fact that the helper may be writing to a shared output stream.  All of the public methods inherited from class <strong>PcapAndAsciiTraceHelperForIpv4</strong> reduce to calling this single device- dependent implementation method. For example, the lowest level ascii trace methods,:</p>
<pre>
void EnableAsciiIpv4 (std::string prefix, Ptr&lt;Ipv4&gt; ipv4, uint32_t interface);
void EnableAsciiIpv4 (Ptr&lt;OutputStreamWrapper&gt; stream, Ptr&lt;Ipv4&gt; ipv4, uint32_t interface);
</pre>
<p>will call the device implementation of <strong>EnableAsciiIpv4Internal</strong> directly, providing either the prefix or the stream. All other public ascii tracing methods will build on these low-level functions to provide additional user-level functionality. What this means to the user is that all device helpers in the system will have all of the ascii trace methods available; and these methods will all work in the same way across protocols if the protocols implement <strong>EnablAsciiIpv4Internal</strong> correctly.</p>
<h3>Ascii Tracing Device Helper Methods</h3>

<pre>
void EnableAsciiIpv4 (std::string prefix, Ptr&lt;Ipv4&gt; ipv4, uint32_t interface);
void EnableAsciiIpv4 (Ptr&lt;OutputStreamWrapper&gt; stream, Ptr&lt;Ipv4&gt; ipv4, uint32_t interface);

void EnableAsciiIpv4 (std::string prefix, std::string ipv4Name, uint32_t interface);
void EnableAsciiIpv4 (Ptr&lt;OutputStreamWrapper&gt; stream, std::string ipv4Name, uint32_t interface);

void EnableAsciiIpv4 (std::string prefix, Ipv4InterfaceContainer c);
void EnableAsciiIpv4 (Ptr&lt;OutputStreamWrapper&gt; stream, Ipv4InterfaceContainer c);

void EnableAsciiIpv4 (std::string prefix, NodeContainer n);
void EnableAsciiIpv4 (Ptr&lt;OutputStreamWrapper&gt; stream, NodeContainer n);

void EnableAsciiIpv4 (std::string prefix, uint32_t nodeid, uint32_t deviceid);
void EnableAsciiIpv4 (Ptr&lt;OutputStreamWrapper&gt; stream, uint32_t nodeid, uint32_t interface);

void EnableAsciiIpv4All (std::string prefix);
void EnableAsciiIpv4All (Ptr&lt;OutputStreamWrapper&gt; stream);
</pre>
<p>You are encouraged to peruse the Doxygen for class <strong>PcapAndAsciiHelperForIpv4</strong> to find the details of these methods; but to summarize ...</p><p>There are twice as many methods available for ascii tracing as there were for pcap tracing. This is because, in addition to the pcap-style model where traces from each unique protocol/interface pair are written to a unique file, we support a model in which trace information for many protocol/interface pairs is written to a common file. This means that the &lt;prefix&gt;-n&lt;node id&gt;-&lt;interface&gt; file name generation mechanism is replaced by a mechanism to refer to a common file; and the number of API methods is doubled to allow all combinations.</p><p>Just as in pcap tracing, you can enable ascii tracing on a particular protocol/interface pair by providing a <strong>Ptr&lt;Ipv4&gt;</strong> and an <strong>interface</strong> to an <strong>EnableAscii</strong> method.  For example,:</p>
<pre>
Ptr&lt;Ipv4&gt; ipv4;
...
helper.EnableAsciiIpv4 ("prefix", ipv4, 1);
</pre>
<p>In this case, no trace contexts are written to the ascii trace file since they would be redundant. The system will pick the file name to be created using the same rules as described in the pcap section, except that the file will have the suffix ".tr" instead of ".pcap".</p><p>If you want to enable ascii tracing on more than one interface and have all traces sent to a single file, you can do that as well by using an object to refer to a single file. We have already something similar to this in the "cwnd" example above::</p>
<pre>
Ptr&lt;Ipv4&gt; protocol1 = node1-&gt;GetObject&lt;Ipv4&gt; ();
Ptr&lt;Ipv4&gt; protocol2 = node2-&gt;GetObject&lt;Ipv4&gt; ();
...
Ptr&lt;OutputStreamWrapper&gt; stream = asciiTraceHelper.CreateFileStream ("trace-file-name.tr");
...
helper.EnableAsciiIpv4 (stream, protocol1, 1);
helper.EnableAsciiIpv4 (stream, protocol2, 1);
</pre>
<p>In this case, trace contexts are written to the ascii trace file since they are required to disambiguate traces from the two interfaces. Note that since the user is completely specifying the file name, the string should include the ".tr" for consistency.</p><p>You can enable ascii tracing on a particular protocol by providing a <strong>std::string</strong> representing an object name service string to an <strong>EnablePcap</strong> method.  The <strong>Ptr&lt;Ipv4&gt;</strong> is looked up from the name string.  The <strong>&lt;Node&gt;</strong> in the resulting filenames is implicit since there is a one-to-one correspondence between protocol instances and nodes, For example,:</p>
<pre>
Names::Add ("node1Ipv4" ...);
Names::Add ("node2Ipv4" ...);
...
helper.EnableAsciiIpv4 ("prefix", "node1Ipv4", 1);
helper.EnableAsciiIpv4 ("prefix", "node2Ipv4", 1);
</pre>
<p>This would result in two files named "prefix-nnode1Ipv4-i1.tr" and "prefix-nnode2Ipv4-i1.tr" with traces for each interface in the respective trace file. Since all of the EnableAscii functions are overloaded to take a stream wrapper, you can use that form as well::</p>
<pre>
Names::Add ("node1Ipv4" ...);
Names::Add ("node2Ipv4" ...);
...
Ptr&lt;OutputStreamWrapper&gt; stream = asciiTraceHelper.CreateFileStream ("trace-file-name.tr");
...
helper.EnableAsciiIpv4 (stream, "node1Ipv4", 1);
helper.EnableAsciiIpv4 (stream, "node2Ipv4", 1);
</pre>
<p>This would result in a single trace file called "trace-file-name.tr" that contains all of the trace events for both interfaces. The events would be disambiguated by trace context strings.</p><p>You can enable ascii tracing on a collection of protocol/interface pairs by providing an <strong>Ipv4InterfaceContainer</strong>. For each protocol of the proper type (the same type as is managed by the device helper), tracing is enabled for the corresponding interface.  Again, the <strong>&lt;Node&gt;</strong> is implicit since there is a one-to-one correspondence between each protocol and its node. For example,:</p>
<pre>
NodeContainer nodes;
...
NetDeviceContainer devices = deviceHelper.Install (nodes);
...
Ipv4AddressHelper ipv4;
ipv4.SetBase ("10.1.1.0", "255.255.255.0");
Ipv4InterfaceContainer interfaces = ipv4.Assign (devices);
...
...
helper.EnableAsciiIpv4 ("prefix", interfaces);
</pre>
<p>This would result in a number of ascii trace files being created, each of which follows the &lt;prefix&gt;-n&lt;node id&gt;-i&lt;interface&gt;.tr convention. Combining all of the traces into a single file is accomplished similarly to the examples above::</p>
<pre>
NodeContainer nodes;
...
NetDeviceContainer devices = deviceHelper.Install (nodes);
...
Ipv4AddressHelper ipv4;
ipv4.SetBase ("10.1.1.0", "255.255.255.0");
Ipv4InterfaceContainer interfaces = ipv4.Assign (devices);
...
Ptr&lt;OutputStreamWrapper&gt; stream = asciiTraceHelper.CreateFileStream ("trace-file-name.tr");
...
helper.EnableAsciiIpv4 (stream, interfaces);
</pre>
<p>You can enable ascii tracing on a collection of protocol/interface pairs by providing a <strong>NodeContainer</strong>. For each <strong>Node</strong> in the <strong>NodeContainer</strong> the appropriate protocol is found.  For each protocol, its interfaces are enumerated and tracing is enabled on the resulting pairs. For example,:</p>
<pre>
NodeContainer n;
...
helper.EnableAsciiIpv4 ("prefix", n);
</pre>
<p>This would result in a number of ascii trace files being created, each of which follows the &lt;prefix&gt;-&lt;node id&gt;-&lt;device id&gt;.tr convention. Combining all of the traces into a single file is accomplished similarly to the examples above:</p><p>You can enable pcap tracing on the basis of node ID and device ID as well. In this case, the node-id is translated to a <strong>Ptr&lt;Node&gt;</strong> and the appropriate protocol is looked up in the node.  The resulting protocol and interface are used to specify the resulting trace source.:</p>
<pre>
helper.EnableAsciiIpv4 ("prefix", 21, 1);
</pre>
<p>Of course, the traces can be combined into a single file as shown above.</p><p>Finally, you can enable ascii tracing for all interfaces in the system, with associated protocol being the same type as that managed by the device helper.:</p>
<pre>
helper.EnableAsciiIpv4All ("prefix");
</pre>
<p>This would result in a number of ascii trace files being created, one for every interface in the system related to a protocol of the type managed by the helper. All of these files will follow the &lt;prefix&gt;-n&lt;node id&gt;-i&lt;interface.tr convention. Combining all of the traces into a single file is accomplished similarly to the examples above.</p>
<h3>Ascii Tracing Device Helper Filename Selection</h3>
<p>Implicit in the prefix-style method descriptions above is the construction of the complete filenames by the implementation method. By convention, ascii traces in the <em>ns-3</em> system are of the form "&lt;prefix&gt;-&lt;node id&gt;-&lt;device id&gt;.tr."</p><p>As previously mentioned, every node in the system will have a system-assigned node id. Since there is a one-to-one correspondence between protocols and nodes we use to node-id to identify the protocol identity. Every interface on a given protocol will have an interface index (also called simply an interface) relative to its protocol. By default, then, an ascii trace file created as a result of enabling tracing on the first device of node 21, using the prefix "prefix", would be "prefix-n21-i1.tr". Use the prefix to disambiguate multiple protocols per node.</p><p>You can always use the <em>ns-3</em> object name service to make this more clear. For example, if you use the object name service to assign the name "serverIpv4" to the protocol on node 21, and also specify interface one, the resulting ascii trace file name will automatically become, "prefix-nserverIpv4-1.tr".</p>
<h3>Tracing implementation details</h3>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REALTIME</h2>
        <div class="sectioncontent">
<p><em>ns-3</em> has been designed for integration into testbed and virtual machine environments. To integrate with real network stacks and emit/consume packets, a real-time scheduler is needed to try to lock the simulation clock with the hardware clock. We describe here a component of this: the RealTime scheduler.</p><p>The purpose of the realtime scheduler is to cause the progression of the simulation clock to occur synchronously with respect to some external time base. Without the presence of an external time base (wall clock), simulation time jumps instantly from one simulated time to the next.</p><h3>Behavior</h3>
<p>When using a non-realtime scheduler (the default in <em>ns-3</em>), the simulator advances the simulation time to the next scheduled event. During event execution, simulation time is frozen. With the realtime scheduler, the behavior is similar from the perspective of simulation models (i.e., simulation time is frozen during event execution), but between events, the simulator will attempt to keep the simulation clock aligned with the machine clock.</p><p>When an event is finished executing, and the scheduler moves to the next event, the scheduler compares the next event execution time with the machine clock.  If the next event is scheduled for a future time, the simulator sleeps until that realtime is reached and then executes the next event.</p><p>It may happen that, due to the processing inherent in the execution of simulation events, that the simulator cannot keep up with realtime.  In such a case, it is up to the user configuration what to do. There are two <em>ns-3</em> attributes that govern the behavior. The first is <strong>ns3::RealTimeSimulatorImpl::SynchronizationMode</strong>. The two entries possible for this attribute are <strong>BestEffort</strong> (the default) or <strong>HardLimit</strong>. In "BestEffort" mode, the simulator will just try to catch up to realtime by executing events until it reaches a point where the next event is in the (realtime) future, or else the simulation ends. In BestEffort mode, then, it is possible for the simulation to consume more time than the wall clock time. The other option "HardLimit" will cause the simulation to abort if the tolerance threshold is exceeded.  This attribute is <strong>ns3::RealTimeSimulatorImpl::HardLimit</strong> and the default is 0.1 seconds.</p><p>A different mode of operation is one in which simulated time is <strong>not</strong> frozen during an event execution. This mode of realtime simulation was implemented but removed from the <em>ns-3</em> tree because of questions of whether it would be useful. If users are interested in a realtime simulator for which simulation time does not freeze during event execution (i.e., every call to <strong>Simulator::Now()</strong> returns the current wall clock time, not the time at which the event started executing), please contact the ns-developers mailing list.</p>
<h3>Usage</h3>
<p>The usage of the realtime simulator is straightforward, from a scripting perspective.  Users just need to set the attribute <strong>SimulatorImplementationType</strong> to the Realtime simulator, such as follows:</p>
<pre>
GlobalValue::Bind ("SimulatorImplementationType",
  StringValue ("ns3::RealtimeSimulatorImpl"));
</pre>
<p>There is a script in <strong>examples/realtime/realtime-udp-echo.cc</strong> that has an example of how to configure the realtime behavior.  Try:</p>
<pre>
./waf --run realtime-udp-echo
</pre>
<p>Whether the simulator will work in a best effort or hard limit policy fashion is governed by the attributes explained in the previous section.</p>
<h3>Implementation</h3>
<p>The implementation is contained in the following files:</p><ul>
<li><p><strong>src/core/model/realtime-simulator-impl.{cc,h}</strong></p></li><li><p><strong>src/core/model/wall-clock-synchronizer.{cc,h}</strong></p><p>In order to create a realtime scheduler, to a first approximation you just want to cause simulation time jumps to consume real time. We propose doing this using a combination of sleep- and busy- waits. Sleep-waits cause the calling process (thread) to yield the processor for some amount of time. Even though this specified amount of time can be passed to nanosecond resolution, it is actually converted to an OS-specific granularity. In Linux, the granularity is called a Jiffy. Typically this resolution is insufficient for our needs (on the order of a ten milliseconds), so we round down and sleep for some smaller number of Jiffies. The process is then awakened after the specified number of Jiffies has passed. At this time, we have some residual time to wait. This time is generally smaller than the minimum sleep time, so we busy-wait for the remainder of the time. This means that the thread just sits in a for loop consuming cycles until the desired time arrives. After the combination of sleep- and busy-waits, the elapsed realtime (wall) clock should agree with the simulation time of the next event and the simulation proceeds.</p></li>
</ul>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">HELPERS</h2>
        <div class="sectioncontent">
<p>The above chapters introduced you to various <em>ns-3</em> programming concepts such as smart pointers for reference-counted memory management, attributes, namespaces, callbacks, etc. Users who work at this low-level API can interconnect <em>ns-3</em> objects with fine granulariy. However, a simulation program written entirely using the low-level API would be quite long and tedious to code. For this reason, a separate so-called "helper API" has been overlaid on the core <em>ns-3</em> API. If you have read the <em>ns-3</em> tutorial, you will already be familiar with the helper API, since it is the API that new users are typically introduced to first.  In this chapter, we introduce the design philosophy of the helper API and contrast it to the low-level API. If you become a heavy user of <em>ns-3</em>, you will likely move back and forth between these APIs even in the same program.</p><p>The helper API has a few goals:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>the rest of <strong>src/</strong> has no dependencies on the helper API; anything that can be done with the helper API can be coded also at the low-level API</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p><strong>Containers:</strong> Often simulations will need to do a number of identical actions to groups of objects. The helper API makes heavy use of containers of similar objects to which similar or identical operations can be performed.</p>
  </dd>
  <dt>
    3.
  </dt>
  <dd>
    <p>The helper API is not generic; it does not strive to maximize code reuse. So, programming constructs such as polymorphism and templates that achieve code reuse are not as prevalent. For instance, there are separate CsmaNetDevice helpers and PointToPointNetDevice helpers but they do not derive from a common NetDevice base class.</p>
  </dd>
  <dt>
    4.
  </dt>
  <dd>
    <p>The helper API typically works with stack-allocated (vs. heap-allocated) objects. For some programs, <em>ns-3</em> users may not need to worry about any low level Object Create or Ptr handling; they can make do with containers of objects and stack-allocated helpers that operate on them.</p><p>The helper API is really all about making <em>ns-3</em> programs easier to write and read, without taking away the power of the low-level interface. The rest of this chapter provides some examples of the programming conventions of the helper API.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MAKING PLOTS USING THE GNUPLOT CLASS</h2>
        <div class="sectioncontent">
<p>There are 2 common methods to make a plot using <em>ns-3</em> and gnuplot (<em>http://www.gnuplot.info</em>):</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>Create a gnuplot control file using <em>ns-3</em>&apos;s Gnuplot class.</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>Create a gnuplot data file using values generated by <em>ns-3</em>.</p><p>This section is about method 1, i.e. it is about how to make a plot using <em>ns-3</em>&apos;s Gnuplot class.  If you are interested in method 2, see the "A Real Example" subsection under the "Tracing" section in the <em>ns-3</em> <em>Tutorial</em>.</p>
  </dd>

</dl>
<h3>Creating Plots Using the Gnuplot Class</h3>
<p>The following steps must be taken in order to create a plot using <em>ns-3</em>&apos;s Gnuplot class:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>Modify your code so that is uses the Gnuplot class and its functions.</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>Run your code so that it creates a gnuplot control file.</p>
  </dd>
  <dt>
    3.
  </dt>
  <dd>
    <p>Call gnuplot with the name of the gnuplot control file.</p>
  </dd>
  <dt>
    4.
  </dt>
  <dd>
    <p>View the graphics file that was produced in your favorite graphics viewer.</p><p>See the code from the example plots that are discussed below for details on step 1.</p>
  </dd>

</dl>

<h3>An Example Program that Uses the Gnuplot Class</h3>
<p>An example program that uses <em>ns-3</em>&apos;s Gnuplot class can be found here:</p>
<pre>
src/tools/examples/gnuplot-example.cc
</pre>
<p>In order to run this example, do the following:</p>
<pre>
./waf shell
cd build/debug/src/tools/examples
./gnuplot-example
</pre>
<p>This should produce the following gnuplot control files in the directory where the example is located:</p>
<pre>
plot-2d.plt
plot-2d-with-error-bars.plt
plot-3d.plt
</pre>
<p>In order to process these gnuplot control files, do the following:</p>
<pre>
gnuplot plot-2d.plt
gnuplot plot-2d-with-error-bars.plt
gnuplot plot-3d.plt
</pre>
<p>This should produce the following graphics files in the directory where the example is located:</p>
<pre>
plot-2d.png
plot-2d-with-error-bars.png
plot-3d.png
</pre>
<p>You can view these graphics files in your favorite graphics viewer.  If you have gimp installed on your machine, for example, you can do this:</p>
<pre>
gimp plot-2d.png
gimp plot-2d-with-error-bars.png
gimp plot-3d.png
</pre>

<h3>An Example 2-Dimensional Plot</h3>
<p>The following 2-Dimensional plot [image]</p><p>was created using the following code from gnuplot-example.cc:</p>
<pre>
using namespace std;

string fileNameWithNoExtension = "plot-2d";
string graphicsFileName        = fileNameWithNoExtension + ".png";
string plotFileName            = fileNameWithNoExtension + ".plt";
string plotTitle               = "2-D Plot";
string dataTitle               = "2-D Data";

// Instantiate the plot and set its title.
Gnuplot plot (graphicsFileName);
plot.SetTitle (plotTitle);

// Make the graphics file, which the plot file will create when it
// is used with Gnuplot, be a PNG file.
plot.SetTerminal ("png");

// Set the labels for each axis.
plot.SetLegend ("X Values", "Y Values");

// Set the range for the x axis.
plot.AppendExtra ("set xrange [-6:+6]");

// Instantiate the dataset, set its title, and make the points be
// plotted along with connecting lines.
Gnuplot2dDataset dataset;
dataset.SetTitle (dataTitle);
dataset.SetStyle (Gnuplot2dDataset::LINES_POINTS);

double x;
double y;

// Create the 2-D dataset.
for (x = -5.0; x &lt;= +5.0; x += 1.0)
  {
    // Calculate the 2-D curve
    //
    //            2
    //     y  =  x   .
    //
    y = x * x;

    // Add this point.
    dataset.Add (x, y);
  }

// Add the dataset to the plot.
plot.AddDataset (dataset);

// Open the plot file.
ofstream plotFile (plotFileName.c_str());

// Write the plot file.
plot.GenerateOutput (plotFile);

// Close the plot file.
plotFile.close ();
</pre>

<h3>An Example 2-Dimensional Plot with Error Bars</h3>
<p>The following 2-Dimensional plot with error bars in the x and y directions [image]</p><p>was created using the following code from gnuplot-example.cc:</p>
<pre>
using namespace std;

string fileNameWithNoExtension = "plot-2d-with-error-bars";
string graphicsFileName        = fileNameWithNoExtension + ".png";
string plotFileName            = fileNameWithNoExtension + ".plt";
string plotTitle               = "2-D Plot With Error Bars";
string dataTitle               = "2-D Data With Error Bars";

// Instantiate the plot and set its title.
Gnuplot plot (graphicsFileName);
plot.SetTitle (plotTitle);

// Make the graphics file, which the plot file will create when it
// is used with Gnuplot, be a PNG file.
plot.SetTerminal ("png");

// Set the labels for each axis.
plot.SetLegend ("X Values", "Y Values");

// Set the range for the x axis.
plot.AppendExtra ("set xrange [-6:+6]");

// Instantiate the dataset, set its title, and make the points be
// plotted with no connecting lines.
Gnuplot2dDataset dataset;
dataset.SetTitle (dataTitle);
dataset.SetStyle (Gnuplot2dDataset::POINTS);

// Make the dataset have error bars in both the x and y directions.
dataset.SetErrorBars (Gnuplot2dDataset::XY);

double x;
double xErrorDelta;
double y;
double yErrorDelta;

// Create the 2-D dataset.
for (x = -5.0; x &lt;= +5.0; x += 1.0)
  {
    // Calculate the 2-D curve
    //
    //            2
    //     y  =  x   .
    //
    y = x * x;

    // Make the uncertainty in the x direction be constant and make
    // the uncertainty in the y direction be a constant fraction of
    // y&apos;s value.
    xErrorDelta = 0.25;
    yErrorDelta = 0.1 * y;

    // Add this point with uncertainties in both the x and y
    // direction.
    dataset.Add (x, y, xErrorDelta, yErrorDelta);
  }

// Add the dataset to the plot.
plot.AddDataset (dataset);

// Open the plot file.
ofstream plotFile (plotFileName.c_str());

// Write the plot file.
plot.GenerateOutput (plotFile);

// Close the plot file.
plotFile.close ();
</pre>

<h3>An Example 3-Dimensional Plot</h3>
<p>The following 3-Dimensional plot [image]</p><p>was created using the following code from gnuplot-example.cc:</p>
<pre>
using namespace std;

string fileNameWithNoExtension = "plot-3d";
string graphicsFileName        = fileNameWithNoExtension + ".png";
string plotFileName            = fileNameWithNoExtension + ".plt";
string plotTitle               = "3-D Plot";
string dataTitle               = "3-D Data";

// Instantiate the plot and set its title.
Gnuplot plot (graphicsFileName);
plot.SetTitle (plotTitle);

// Make the graphics file, which the plot file will create when it
// is used with Gnuplot, be a PNG file.
plot.SetTerminal ("png");

// Rotate the plot 30 degrees around the x axis and then rotate the
// plot 120 degrees around the new z axis.
plot.AppendExtra ("set view 30, 120, 1.0, 1.0");

// Make the zero for the z-axis be in the x-axis and y-axis plane.
plot.AppendExtra ("set ticslevel 0");

// Set the labels for each axis.
plot.AppendExtra ("set xlabel &apos;X Values&apos;");
plot.AppendExtra ("set ylabel &apos;Y Values&apos;");
plot.AppendExtra ("set zlabel &apos;Z Values&apos;");

// Set the ranges for the x and y axis.
plot.AppendExtra ("set xrange [-5:+5]");
plot.AppendExtra ("set yrange [-5:+5]");

// Instantiate the dataset, set its title, and make the points be
// connected by lines.
Gnuplot3dDataset dataset;
dataset.SetTitle (dataTitle);
dataset.SetStyle ("with lines");

double x;
double y;
double z;

// Create the 3-D dataset.
for (x = -5.0; x &lt;= +5.0; x += 1.0)
  {
  for (y = -5.0; y &lt;= +5.0; y += 1.0)
      {
        // Calculate the 3-D surface
        //
        //            2      2
        //     z  =  x   *  y   .
        //
        z = x * x * y * y;

        // Add this point.
        dataset.Add (x, y, z);
      }

  // The blank line is necessary at the end of each x value&apos;s data
  // points for the 3-D surface grid to work.
  dataset.AddEmptyLine ();
  }

// Add the dataset to the plot.
plot.AddDataset (dataset);

// Open the plot file.
ofstream plotFile (plotFileName.c_str());

// Write the plot file.
plot.GenerateOutput (plotFile);

// Close the plot file.
plotFile.close ();
</pre>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">USING PYTHON TO RUN NS-3</h2>
        <div class="sectioncontent">
<p>Python bindings allow the C++ code in <em>ns-3</em> to be called from Python.</p><p>This chapter shows you how to create a Python script that can run <em>ns-3</em> and also the process of creating Python bindings for a C++ <em>ns-3</em> module.</p><h3>Introduction</h3>
<p>The goal of Python bindings for <em>ns-3</em> are two fold:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>Allow the programmer to write complete simulation scripts in Python (<em>http://www.python.org</em>);</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>Prototype new models (e.g. routing protocols).</p><p>For the time being, the primary focus of the bindings is the first goal, but the second goal will eventually be supported as well. Python bindings for <em>ns-3</em> are being developed using a new tool called PyBindGen (<em>http://code.google.com/p/pybindgen</em>).</p>
  </dd>

</dl>

<h3>An Example Python Script that Runs \fIns-3\fP</h3>
<p>Here is some example code that is written in Python and that runs <em>ns-3</em>, which is written in C++.  This Python example can be found in <strong>examples/tutorial/first.py</strong>:</p>
<pre>
import ns.applications
import ns.core
import ns.internet
import ns.network
import ns.point_to_point

ns.core.LogComponentEnable("UdpEchoClientApplication", ns.core.LOG_LEVEL_INFO)
ns.core.LogComponentEnable("UdpEchoServerApplication", ns.core.LOG_LEVEL_INFO)

nodes = ns.network.NodeContainer()
<strong>nodes.Create</strong>(2)

pointToPoint = ns.point_to_point.PointToPointHelper()
pointToPoint.SetDeviceAttribute("DataRate", ns.core.StringValue("5Mbps"))
pointToPoint.SetChannelAttribute("Delay", ns.core.StringValue("2ms"))

devices = pointToPoint.Install(nodes)

stack = ns.internet.InternetStackHelper()
stack.Install(nodes)

address = ns.internet.Ipv4AddressHelper()
address.SetBase(ns.network.Ipv4Address("10.1.1.0"), ns.network.Ipv4Mask("255.255.255.0"))

interfaces = address.Assign (devices);

echoServer = <strong>ns.applications.UdpEchoServerHelper</strong>(9)

serverApps = echoServer.Install(<strong>nodes.Get</strong>(1))
serverApps.Start(ns.core.Seconds(1.0))
serverApps.Stop(ns.core.Seconds(10.0))

echoClient = ns.applications.UdpEchoClientHelper(<strong>interfaces.GetAddress</strong>(1), 9)
echoClient.SetAttribute("MaxPackets", <strong>ns.core.UintegerValue</strong>(1))
echoClient.SetAttribute("Interval", ns.core.TimeValue(ns.core.Seconds (1.0)))
echoClient.SetAttribute("PacketSize", ns.core.UintegerValue(1024))

clientApps = echoClient.Install(<strong>nodes.Get</strong>(0))
clientApps.Start(ns.core.Seconds(2.0))
clientApps.Stop(ns.core.Seconds(10.0))

ns.core.Simulator.Run()
ns.core.Simulator.Destroy()
</pre>

<h3>Running Python Scripts</h3>
<p>waf contains some options that automatically update the python path to find the ns3 module.  To run example programs, there are two ways to use waf to take care of this.  One is to run a waf shell; e.g.:</p>
<pre>
./waf --shell
python examples/mixed-wireless.py
</pre>
<p>and the other is to use the --pyrun option to waf:</p>
<pre>
./waf --pyrun examples/mixed-wireless.py
</pre>
<p>To run a python script under the C debugger:</p>
<pre>
./waf --shell
gdb --args python examples/mixed-wireless.py
</pre>
<p>To run your own Python script that calls <em>ns-3</em> and that has this path, <strong>/path/to/your/example/my-script.py</strong>, do the following:</p>
<pre>
./waf --shell
python /path/to/your/example/my-script.py
</pre>

<h3>Caveats</h3>
<p>Python bindings for <em>ns-3</em> are a work in progress, and some limitations are known by developers.  Some of these limitations (not all) are listed here.</p>
<h3>Incomplete Coverage</h3>
<p>First of all, keep in mind that not 100% of the API is supported in Python.  Some of the reasons are:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>some of the APIs involve pointers, which require knowledge of what kind of memory passing semantics (who owns what memory). Such knowledge is not part of the function signatures, and is either documented or sometimes not even documented.  Annotations are needed to bind those functions;</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>Sometimes a unusual fundamental data type or C++ construct is used which is not yet supported by PyBindGen;</p>
  </dd>
  <dt>
    3.
  </dt>
  <dd>
    <p>GCC-XML does not report template based classes unless they are instantiated.</p><p>Most of the missing APIs can be wrapped, given enough time, patience, and expertise, and will likely be wrapped if bug reports are submitted.  However, don&apos;t file a bug report saying "bindings are incomplete", because we do not have manpower to complete 100% of the bindings.</p>
  </dd>

</dl>

<h3>Conversion Constructors</h3>
<p>Conversion constructors (<em>http://publib.boulder.ibm.com/infocenter/compbgpl/v9v111/topic/com.ibm.xlcpp9.bg.doc/language_ref/cplr384.htm</em>) are not fully supported yet by PyBindGen, and they always act as explicit constructors when translating an API into Python.  For example, in C++ you can do this:</p>
<pre>
Ipv4AddressHelper ipAddrs;
ipAddrs.SetBase ("192.168.0.0", "255.255.255.0");
ipAddrs.Assign (backboneDevices);
</pre>
<p>In Python, for the time being you have to do:</p>
<pre>
ipAddrs = ns3.Ipv4AddressHelper()
ipAddrs.SetBase(ns3.Ipv4Address("192.168.0.0"), ns3.Ipv4Mask("255.255.255.0"))
ipAddrs.Assign(backboneDevices)
</pre>

<h3>CommandLine</h3>
<p><strong>CommandLine::AddValue()</strong> works differently in Python than it does in <em>ns-3</em>.  In Python, the first parameter is a string that represents the command-line option name.  When the option is set, an attribute with the same name as the option name is set on the <strong>CommandLine()</strong> object.  Example:</p>
<pre>
NUM_NODES_SIDE_DEFAULT = 3

cmd = ns3.CommandLine()

cmd.NumNodesSide = None
cmd.AddValue("NumNodesSide", "Grid side number of nodes (total number of nodes will be this number squared)")

cmd.Parse(argv)

[...]

if cmd.NumNodesSide is None:
    num_nodes_side = NUM_NODES_SIDE_DEFAULT
else:
    num_nodes_side = int(cmd.NumNodesSide)
</pre>

<h3>Tracing</h3>
<p>Callback based tracing is not yet properly supported for Python, as new <em>ns-3</em> API needs to be provided for this to be supported.</p><p>Pcap file writing is supported via the normal API.</p><p>Ascii tracing is supported since <em>ns-3</em>.4 via the normal C++ API translated to Python.  However, ascii tracing requires the creation of an ostream object to pass into the ascii tracing methods.  In Python, the C++ std::ofstream has been minimally wrapped to allow this.  For example:</p>
<pre>
ascii = ns3.ofstream("wifi-ap.tr") # create the file
ns3.YansWifiPhyHelper.EnableAsciiAll(ascii)
ns3.Simulator.Run()
ns3.Simulator.Destroy()
ascii.close() # close the file
</pre>
<p>There is one caveat: you must not allow the file object to be garbage collected while <em>ns-3</em> is still using it.  That means that the &apos;ascii&apos; variable above must not be allowed to go out of scope or else the program will crash.</p>
<h3>Cygwin limitation</h3>
<p>Python bindings do not work on Cygwin.  This is due to a gccxml bug.</p><p>You might get away with it by re-scanning API definitions from within the cygwin environment (./waf --python-scan).  However the most likely solution will probably have to be that we disable python bindings in CygWin.</p><p>If you really care about Python bindings on Windows, try building with mingw and native python instead.  Or else, to build without python bindings, disable python bindings in the configuration stage:</p>
<pre>
./waf configure --disable-python
</pre>

<h3>Working with Python Bindings</h3>
<p>There are currently two kinds of Python bindings in <em>ns-3</em>:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>Monolithic bindings contain API definitions for all of the modules and can be found in a single directory, <strong>bindings/python</strong>.</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>Modular bindings contain API definitions for a single module and can be found in each module&apos;s  <strong>bindings</strong> directory.</p>
  </dd>

</dl>

<h3>Python Bindings Workflow</h3>
<p>The process by which Python bindings are handled is the following:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>Periodically a developer uses a GCC-XML (<em>http://www.gccxml.org</em>) based API scanning script, which saves the scanned API definition as <strong>bindings/python/ns3_module_*.py</strong> files or as Python files in each modules&apos; <strong>bindings</strong> directory.  These files are kept under version control in the main <em>ns-3</em> repository;</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>Other developers clone the repository and use the already scanned API definitions;</p>
  </dd>
  <dt>
    3.
  </dt>
  <dd>
    <p>When configuring <em>ns-3</em>, pybindgen will be automatically downloaded if not already installed.  Released <em>ns-3</em> tarballs will ship a copy of pybindgen.</p><p>If something goes wrong with compiling Python bindings and you just want to ignore them and move on with C++, you can disable Python with:</p>
<pre>
./waf --disable-python
</pre>

  </dd>

</dl>

<h3>Instructions for Handling New Files or Changed API&apos;s</h3>
<p>So you have been changing existing <em>ns-3</em> APIs and Python bindings no longer compile?  Do not despair, you can rescan the bindings to create new bindings that reflect the changes to the <em>ns-3</em> API.</p><p>Depending on if you are using monolithic or modular bindings, see the discussions below to learn how to rescan your Python bindings.</p>
<h3>Monolithic Python Bindings</h3>

<h3>Scanning the Monolithic Python Bindings</h3>
<p>To scan the monolithic Python bindings do the following:</p>
<pre>
./waf --python-scan
</pre>

<h3>Organization of the Monolithic Python Bindings</h3>
<p>The monolithic Python API definitions are organized as follows. For each <em>ns-3</em> module &lt;name&gt;, the file <strong>bindings/python/ns3_module_&lt;name&gt;.py</strong> describes its API.  Each of those files have 3 toplevel functions:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p><strong>def register_types(module)()</strong>: this function takes care of registering new types (e.g. C++ classes, enums) that are defined in tha module;</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p><strong>def register_methods(module)()</strong>: this function calls, for each class &lt;name&gt;, another function register_methods_Ns3&lt;name&gt;(module).  These latter functions add method definitions for each class;</p>
  </dd>
  <dt>
    3.
  </dt>
  <dd>
    <p><strong>def register_functions(module)()</strong>: this function registers <em>ns-3</em> functions that belong to that module.</p>
  </dd>

</dl>

<h3>Modular Python Bindings</h3>

<h3>Overview</h3>
<p>Since ns 3.11, the modular bindings are being added, in parallel to the old monolithic bindings.</p><p>The new python bindings are generated into an &apos;ns&apos; namespace, instead of &apos;ns3&apos; for the old bindings.  Example:</p>
<pre>
from ns.network import Node
n1 = Node()
</pre>
<p>With modular Python bindings:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>There is one separate Python extension module for each <em>ns-3</em> module;</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>Scanning API definitions (apidefs) is done on a per ns- module basis;</p>
  </dd>
  <dt>
    3.
  </dt>
  <dd>
    <p>Each module&apos;s apidefs files are stored in a &apos;bindings&apos; subdirectory of the module directory;</p>
  </dd>

</dl>

<h3>Scanning the Modular Python Bindings</h3>
<p>To scan the modular Python bindings for the core module, for example, do the following:</p>
<pre>
./waf --apiscan=core
</pre>
<p>To scan the modular Python bindings for all of the modules, do the following:</p>
<pre>
./waf --apiscan=all
</pre>

<h3>Creating a New Module</h3>
<p>If you are adding a new module, Python bindings will continue to compile but will not cover the new module.</p><p>To cover a new module, you have to create a <strong>bindings/python/ns3_module_&lt;name&gt;.py</strong> file, similar to the what is described in the previous sections, and register it in the variable <strong>LOCAL_MODULES()</strong> in <strong>bindings/python/ns3modulegen.py</strong></p>
<h3>Adding Modular Bindings To A Existing Module</h3>
<p>To add support for modular bindings to an existing <em>ns-3</em> module, simply add the following line to its wscript build() function:</p>
<pre>
bld.ns3_python_bindings()
</pre>

<h3>Organization of the Modular Python Bindings</h3>
<p>The <strong>src/&lt;module&gt;/bindings</strong> directory may contain the following files, some of them optional:</p><ul>
<li><p><strong>callbacks_list.py</strong>: this is a scanned file, DO NOT TOUCH.  Contains a list of Callback&lt;...&gt; template instances found in the scanned headers;</p></li><li><p><strong>modulegen__gcc_LP64.py</strong>: this is a scanned file, DO NOT TOUCH.  Scanned API definitions for the GCC, LP64 architecture (64-bit)</p></li><li><p><strong>modulegen__gcc_ILP32.py</strong>: this is a scanned file, DO NOT TOUCH.  Scanned API definitions for the GCC, ILP32 architecture (32-bit)</p></li><li><p><strong>modulegen_customizations.py</strong>: you may optionally add this file in order to customize the pybindgen code generation</p></li><li><p><strong>scan-header.h</strong>: you may optionally add this file to customize what header file is scanned for the module.  Basically this file is scanned instead of ns3/&lt;module&gt;-module.h.  Typically, the first statement is #include "ns3/&lt;module&gt;-module.h", plus some other stuff to force template instantiations;</p></li><li><p><strong>module_helpers.cc</strong>: you may add additional files, such as this, to be linked to python extension module, but they have to be registered in the wscript. Look at src/core/wscript for an example of how to do so;</p></li><li><p><strong>&lt;module&gt;.py</strong>: if this file exists, it becomes the "frontend" python module for the ns3 module, and the extension module (.so file) becomes _&lt;module&gt;.so instead of &lt;module&gt;.so.  The &lt;module&gt;.py file has to import all symbols from the module _&lt;module&gt; (this is more tricky than it sounds, see src/core/bindings/core.py for an example), and then can add some additional pure-python definitions.</p></li>
</ul>
<h3>More Information for Developers</h3>
<p>If you are a developer and need more information on <em>ns-3</em>&apos;s Python bindings, please see the Python Bindings wiki page at <em>http://www.nsnam.org/wiki/index.php/NS-3_Python_Bindings</em>.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TESTS</h2>
        <div class="sectioncontent">
<h3>Overview</h3>
<p>This document is concerned with the testing and validation of <em>ns-3</em> software.</p><p>This document provides</p><ul>
<li><p>background about terminology and software testing (Chapter 2);</p></li><li><p>a description of the ns-3 testing framework (Chapter 3);</p></li><li><p>a guide to model developers or new model contributors for how to write tests (Chapter 4);</p><p>In brief, the first three chapters should be read by ns developers and contributors who need to understand how to contribute test code and validated programs, and the remainder of the document provides space for people to report on what aspects of selected models have been validated.</p></li>
</ul>
<h3>Background</h3>
<p><strong>This chapter may be skipped by readers familiar with the basics of</strong> software testing.</p><p>Writing defect-free software is a difficult proposition.  There are many dimensions to the problem and there is much confusion regarding what is meant by different terms in different contexts.  We have found it worthwhile to spend a little time reviewing the subject and defining some terms.</p><p>Software testing may be loosely defined as the process of executing a program with the intent of finding errors.  When one enters a discussion regarding software testing, it quickly becomes apparent that there are many distinct mind-sets with which one can approach the subject.</p><p>For example, one could break the process into broad functional categories like &apos;&apos;correctness testing,&apos;&apos; &apos;&apos;performance testing,&apos;&apos; &apos;&apos;robustness testing&apos;&apos; and &apos;&apos;security testing.&apos;&apos;  Another way to look at the problem is by life-cycle: &apos;&apos;requirements testing,&apos;&apos; &apos;&apos;design testing,&apos;&apos; &apos;&apos;acceptance testing,&apos;&apos; and &apos;&apos;maintenance testing.&apos;&apos;  Yet another view is by the scope of the tested system. In this case one may speak of &apos;&apos;unit testing,&apos;&apos; &apos;&apos;component testing,&apos;&apos; &apos;&apos;integration testing,&apos;&apos; and &apos;&apos;system testing.&apos;&apos;  These terms are also not standardized in any way, and so &apos;&apos;maintenance testing&apos;&apos; and &apos;&apos;regression testing&apos;&apos; may be heard interchangeably.  Additionally, these terms are often misused.</p><p>There are also a number of different philosophical approaches to software testing.  For example, some organizations advocate writing test programs before actually implementing the desired software, yielding &apos;&apos;test-driven development.&apos;&apos;  Some organizations advocate testing from a customer perspective as soon as possible, following a parallel with the agile development process: &apos;&apos;test early and test often.&apos;&apos;  This is sometimes called &apos;&apos;agile testing.&apos;&apos;  It seems that there is at least one approach to testing for every development methodology.</p><p>The <em>ns-3</em> project is not in the business of advocating for any one of these processes, but the project as a whole has requirements that help inform the test process.</p><p>Like all major software products, <em>ns-3</em> has a number of qualities that must be present for the product to succeed.  From a testing perspective, some of these qualities that must be addressed are that <em>ns-3</em> must be &apos;&apos;correct,&apos;&apos; &apos;&apos;robust,&apos;&apos;  &apos;&apos;performant&apos;&apos; and &apos;&apos;maintainable.&apos;&apos;  Ideally there should be metrics for each of these dimensions that are checked by the tests to identify when the product fails to meet its expectations / requirements.</p>
<h3>Correctness</h3>
<p>The essential purpose of testing is to determine that a piece of software behaves &apos;&apos;correctly.&apos;&apos;  For <em>ns-3</em> this means that if we simulate something, the simulation should faithfully represent some physical entity or process to a specified accuracy and precision.</p><p>It turns out that there are two perspectives from which one can view correctness.  Verifying that a particular model is implemented according to its specification is generically called <em>verification</em>.  The process of deciding that the model is correct for its intended use is generically called <em>validation</em>.</p>
<h3>Validation and Verification</h3>
<p>A computer model is a mathematical or logical representation of something. It can represent a vehicle, an elephant (see <em>David Harel's talk about modeling an elephant at SIMUTools 2009</em>, or a networking card.  Models can also represent processes such as global warming, freeway traffic flow or a specification of a networking protocol.  Models can be completely faithful representations of a logical process specification, but they necessarily can never completely simulate a physical object or process.  In most cases, a number of simplifications are made to the model to make simulation computationally tractable.</p><p>Every model has a <em>target system</em> that it is attempting to simulate.  The first step in creating a simulation model is to identify this target system and the level of detail and accuracy that the simulation is desired to reproduce. In the case of a logical process, the target system may be identified as &apos;&apos;TCP as defined by RFC 793.&apos;&apos;  In this case, it will probably be desirable to create a model that completely and faithfully reproduces RFC 793.  In the case of a physical process this will not be possible. If, for example, you would like to simulate a wireless networking card, you may determine that you need,  &apos;&apos;an accurate MAC-level implementation of the 802.11 specification and [...] a not-so-slow PHY-level model of the 802.11a specification.&apos;&apos;</p><p>Once this is done, one can develop an abstract model of the target system.  This is typically an exercise in managing the tradeoffs between complexity, resource requirements and accuracy.  The process of developing an abstract model has been called <em>model qualification</em> in the literature.  In the case of a TCP protocol, this process results in a design for a collection of objects, interactions and behaviors that will fully implement RFC 793 in <em>ns-3</em>. In the case of the wireless card, this process results in a number of tradeoffs to allow the physical layer to be simulated and the design of a network device and channel for ns-3, along with the desired objects, interactions and behaviors.</p><p>This abstract model is then developed into an <em>ns-3</em> model that implements the abstract model as a computer program.  The process of getting the implementation to agree with the abstract model is called <em>model</em> verification in the literature.</p><p>The process so far is open loop. What remains is to make a determination that a given ns-3 model has some connection to some reality -- that a model is an accurate representation of a real system, whether a logical process or a physical entity.</p><p>If one is going to use a simulation model to try and predict how some real system is going to behave, there must be some reason to believe your results -- i.e., can one trust that an inference made from the model translates into a correct prediction for the real system.  The process of getting the ns-3 model behavior to agree with the desired target system behavior as defined by the model qualification process is called <em>model validation</em> in the literature. In the case of a TCP implementation, you may want to compare the behavior of your ns-3 TCP model to some reference implementation in order to validate your model.  In the case of a wireless physical layer simulation, you may want to compare the behavior of your model to that of real hardware in a controlled setting,</p><p>The <em>ns-3</em> testing environment provides tools to allow for both model validation and testing, and encourages the publication of validation results.</p>
<h3>Robustness</h3>
<p>Robustness is the quality of being able to withstand stresses, or changes in environments, inputs or calculations, etc.  A system or design is &apos;&apos;robust&apos;&apos; if it can deal with such changes with minimal loss of functionality.</p><p>This kind of testing is usually done with a particular focus.  For example, the system as a whole can be run on many different system configurations to demonstrate that it can perform correctly in a large number of environments.</p><p>The system can be also be stressed by operating close to or beyond capacity by generating or simulating resource exhaustion of various kinds.  This genre of testing is called &apos;&apos;stress testing.&apos;&apos;</p><p>The system and its components may be exposed to so-called &apos;&apos;clean tests&apos;&apos; that demonstrate a positive result -- that is that the system operates correctly in response to a large variation of expected configurations.</p><p>The system and its components may also be exposed to &apos;&apos;dirty tests&apos;&apos; which provide inputs outside the expected range.  For example, if a module expects a zero-terminated string representation of an integer, a dirty test might provide an unterminated string of random characters to verify that the system does not crash as a result of this unexpected input.  Unfortunately, detecting such &apos;&apos;dirty&apos;&apos; input and taking preventive measures to ensure the system does not fail catastrophically can require a huge amount of development overhead.  In order to reduce development time, a decision was taken early on in the project to minimize the amount of parameter validation and error handling in the <em>ns-3</em> codebase.  For this reason, we do not spend much time on dirty testing -- it would just uncover the results of the design decision we know we took.</p><p>We do want to demonstrate that <em>ns-3</em> software does work across some set of conditions.  We borrow a couple of definitions to narrow this down a bit. The <em>domain of applicability</em> is a set of prescribed conditions for which the model has been tested, compared against reality to the extent possible, and judged  suitable for use.  The <em>range of accuracy</em> is an agreement between the computerized model and reality within a domain of applicability.</p><p>The <em>ns-3</em> testing environment provides tools to allow for setting up and running test environments over multiple systems (buildbot) and provides classes to encourage clean tests to verify the operation of the system over the expected &apos;&apos;domain of applicability&apos;&apos; and &apos;&apos;range of accuracy.&apos;&apos;</p>
<h3>Performant</h3>
<p>Okay, &apos;&apos;performant&apos;&apos; isn&apos;t a real English word.  It is, however, a very concise neologism that is quite often used to describe what we want <em>ns-3</em> to be: powerful and fast enough to get the job done.</p><p>This is really about the broad subject of software performance testing.  One of the key things that is done is to compare two systems to find which performs better (cf benchmarks).  This is used to demonstrate that, for example, <em>ns-3</em> can perform a basic kind of simulation at least as fast as a competing tool, or can be used to identify parts of the system that perform badly.</p><p>In the <em>ns-3</em> test framework, we provide support for timing various kinds of tests.</p>
<h3>Maintainability</h3>
<p>A software product must be maintainable.  This is, again, a very broad statement, but a testing framework can help with the task.  Once a model has been developed, validated and verified, we can repeatedly execute the suite of tests for the entire system to ensure that it remains valid and verified over its lifetime.</p><p>When a feature stops functioning as intended after some kind of change to the system is integrated, it is called generically a <em>regression</em>. Originally the term regression referred to a change that caused a previously fixed bug to reappear, but the term has evolved to describe any kind of change that breaks existing functionality.  There are many kinds of regressions that may occur in practice.</p><p>A <em>local regression</em> is one in which a change affects the changed component directly.  For example, if a component is modified to allocate and free memory but stale pointers are used, the component itself fails.</p><p>A <em>remote regression</em> is one in which a change to one component breaks functionality in another component.  This reflects violation of an implied but possibly unrecognized contract between components.</p><p>An <em>unmasked regression</em> is one that creates a situation where a previously existing bug that had no affect is suddenly exposed in the system.  This may be as simple as exercising a code path for the first time.</p><p>A <em>performance regression</em> is one that causes the performance requirements of the system to be violated.  For example, doing some work in a low level function that may be repeated large numbers of times may suddenly render the system unusable from certain perspectives.</p><p>The <em>ns-3</em> testing framework provides tools for automating the process used to validate and verify the code in nightly test suites to help quickly identify possible regressions.</p>
<h3>Testing framework</h3>
<p>ns-3 consists of a simulation core engine, a set of models, example programs, and tests.  Over time, new contributors contribute models, tests, and examples.  A Python test program <strong>test.py</strong> serves as the test execution manager; <strong>test.py</strong> can run test code and examples to look for regressions, can output the results into a number of forms, and can manage code coverage analysis tools.  On top of this, we layer <em>Buildbots</em> that are automated build robots that perform robustness testing by running the test framework on different systems and with different configuration options.</p>
<h3>BuildBots</h3>
<p>At the highest level of ns-3 testing are the buildbots (build robots). If you are unfamiliar with this system look at <em>http://djmitche.github.com/buildbot/docs/0.7.11/</em>. This is an open-source automated system that allows <em>ns-3</em> to be rebuilt and tested each time something has changed.  By running the buildbots on a number of different systems we can ensure that <em>ns-3</em> builds and executes properly on all of its supported systems.</p><p>Users (and developers) typically will not interact with the buildbot system other than to read its messages regarding test results.  If a failure is detected in one of the automated build and test jobs, the buildbot will send an email to the <em>ns-developers</em> mailing list.  This email will look something like:</p>
<pre>
The Buildbot has detected a new failure of osx-ppc-g++-4.2 on NsNam.
Full details are available at:
 http://ns-regression.ee.washington.edu:8010/builders/osx-ppc-g%2B%2B-4.2/builds/0

Buildbot URL: http://ns-regression.ee.washington.edu:8010/

Buildslave for this Build: darwin-ppc

Build Reason: The web-page &apos;force build&apos; button was pressed by &apos;ww&apos;: ww

Build Source Stamp: HEAD
Blamelist:

BUILD FAILED: failed shell_5 shell_6 shell_7 shell_8 shell_9 shell_10 shell_11 shell_12

sincerely,
-The Buildbot
</pre>
<p>In the full details URL shown in the email, one can search for the keyword <strong>failed</strong> and select the <strong>stdio</strong> link for the corresponding step to see the reason for the failure.</p><p>The buildbot will do its job quietly if there are no errors, and the system will undergo build and test cycles every day to verify that all is well.</p>
<h3>Test.py</h3>
<p>The buildbots use a Python program, <strong>test.py</strong>, that is responsible for running all of the tests and collecting the resulting reports into a human- readable form.  This program is also available for use by users and developers as well.</p><p><strong>test.py</strong> is very flexible in allowing the user to specify the number and kind of tests to run; and also the amount and kind of output to generate.</p><p>Before running <strong>test.py</strong>, make sure that ns3&apos;s examples and tests have been built by doing the following</p>
<pre>
./waf configure --enable-examples --enable-tests
./waf
</pre>
<p>By default, <strong>test.py</strong> will run all available tests and report status back in a very concise form.  Running the command</p>
<pre>
./test.py
</pre>
<p>will result in a number of <strong>PASS</strong>, <strong>FAIL</strong>, <strong>CRASH</strong> or <strong>SKIP</strong> indications followed by the kind of test that was run and its display name.</p>
<pre>
Waf: Entering directory \(ga/home/craigdo/repos/ns-3-allinone-test/ns-3-dev/build&apos;
Waf: Leaving directory \(ga/home/craigdo/repos/ns-3-allinone-test/ns-3-dev/build&apos;
&apos;build&apos; finished successfully (0.939s)
FAIL: TestSuite ns3-wifi-propagation-loss-models
PASS: TestSuite object-name-service
PASS: TestSuite pcap-file-object
PASS: TestSuite ns3-tcp-cwnd
...
PASS: TestSuite ns3-tcp-interoperability
PASS: Example csma-broadcast
PASS: Example csma-multicast
</pre>
<p>This mode is intended to be used by users who are interested in determining if their distribution is working correctly, and by developers who are interested in determining if changes they have made have caused any regressions.</p><p>There are a number of options available to control the behavior of <strong>test.py</strong>. if you run <strong>test.py --help</strong> you should see a command summary like:</p>
<pre>
Usage: test.py [options]

Options:
  -h, --help            show this help message and exit
  -b BUILDPATH, --buildpath=BUILDPATH
                        specify the path where ns-3 was built (defaults to the
                        build directory for the current variant)
  -c KIND, --constrain=KIND
                        constrain the test-runner by kind of test
  -e EXAMPLE, --example=EXAMPLE
                        specify a single example to run (no relative path is
                        needed)
  -g, --grind           run the test suites and examples using valgrind
  -k, --kinds           print the kinds of tests available
  -l, --list            print the list of known tests
  -m, --multiple        report multiple failures from test suites and test
                        cases
  -n, --nowaf           do not run waf before starting testing
  -p PYEXAMPLE, --pyexample=PYEXAMPLE
                        specify a single python example to run (with relative
                        path)
  -r, --retain          retain all temporary files (which are normally
                        deleted)
  -s TEST-SUITE, --suite=TEST-SUITE
                        specify a single test suite to run
  -t TEXT-FILE, --text=TEXT-FILE
                        write detailed test results into TEXT-FILE.txt
  -v, --verbose         print progress and informational messages
  -w HTML-FILE, --web=HTML-FILE, --html=HTML-FILE
                        write detailed test results into HTML-FILE.html
  -x XML-FILE, --xml=XML-FILE
                        write detailed test results into XML-FILE.xml
</pre>
<p>If one specifies an optional output style, one can generate detailed descriptions of the tests and status.  Available styles are <strong>text</strong> and <strong>HTML</strong>. The buildbots will select the HTML option to generate HTML test reports for the nightly builds using</p>
<pre>
./test.py --html=nightly.html
</pre>
<p>In this case, an HTML file named &apos;&apos;nightly.html&apos;&apos; would be created with a pretty summary of the testing done.  A &apos;&apos;human readable&apos;&apos; format is available for users interested in the details.</p>
<pre>
./test.py --text=results.txt
</pre>
<p>In the example above, the test suite checking the <em>ns-3</em> wireless device propagation loss models failed.  By default no further information is provided.</p><p>To further explore the failure, <strong>test.py</strong> allows a single test suite to be specified.  Running the command</p>
<pre>
./test.py --suite=ns3-wifi-propagation-loss-models
</pre>
<p>or equivalently</p>
<pre>
./test.py -s ns3-wifi-propagation-loss-models
</pre>
<p>results in that single test suite being run.</p>
<pre>
FAIL: TestSuite ns3-wifi-propagation-loss-models
</pre>
<p>To find detailed information regarding the failure, one must specify the kind of output desired.  For example, most people will probably be interested in a text file:</p>
<pre>
./test.py --suite=ns3-wifi-propagation-loss-models --text=results.txt
</pre>
<p>This will result in that single test suite being run with the test status written to the file &apos;&apos;results.txt&apos;&apos;.</p><p>You should find something similar to the following in that file:</p>
<pre>
FAIL: Test Suite &apos;&apos;ns3-wifi-propagation-loss-models&apos;&apos; (real 0.02 user 0.01 system 0.00)
PASS: Test Case "Check ... Friis ... model ..." (real 0.01 user 0.00 system 0.00)
FAIL: Test Case "Check ... Log Distance ... model" (real 0.01 user 0.01 system 0.00)
  Details:
    Message:   Got unexpected SNR value
    Condition: [long description of what actually failed]
    Actual:    176.395
    Limit:     176.407 +- 0.0005
    File:      ../src/test/ns3wifi/propagation-loss-models-test-suite.cc
    Line:      360
</pre>
<p>Notice that the Test Suite is composed of two Test Cases.  The first test case checked the Friis propagation loss model and passed.  The second test case failed checking the Log Distance propagation model.  In this case, an SNR of 176.395 was found, and the test expected a value of 176.407 correct to three decimal places.  The file which implemented the failing test is listed as well as the line of code which triggered the failure.</p><p>If you desire, you could just as easily have written an HTML file using the <strong>--html</strong> option as described above.</p><p>Typically a user will run all tests at least once after downloading <em>ns-3</em> to ensure that his or her environment has been built correctly and is generating correct results according to the test suites.  Developers will typically run the test suites before and after making a change to ensure that they have not introduced a regression with their changes.  In this case, developers may not want to run all tests, but only a subset.  For example, the developer might only want to run the unit tests periodically while making changes to a repository.  In this case, <strong>test.py</strong> can be told to constrain the types of tests being run to a particular class of tests.  The following command will result in only the unit tests being run:</p>
<pre>
./test.py --constrain=unit
</pre>
<p>Similarly, the following command will result in only the example smoke tests being run:</p>
<pre>
./test.py --constrain=unit
</pre>
<p>To see a quick list of the legal kinds of constraints, you can ask for them to be listed.  The following command</p>
<pre>
./test.py --kinds
</pre>
<p>will result in the following list being displayed:</p>
<pre>
Waf: Entering directory \(ga/home/craigdo/repos/ns-3-allinone-test/ns-3-dev/build&apos;
Waf: Leaving directory \(ga/home/craigdo/repos/ns-3-allinone-test/ns-3-dev/build&apos;
&apos;build&apos; finished successfully (0.939s)Waf: Entering directory \(ga/home/craigdo/repos/ns-3-allinone-test/ns-3-dev/build&apos;
bvt:         Build Verification Tests (to see if build completed successfully)
core:        Run all TestSuite-based tests (exclude examples)
example:     Examples (to see if example programs run successfully)
performance: Performance Tests (check to see if the system is as fast as expected)
system:      System Tests (spans modules to check integration of modules)
unit:        Unit Tests (within modules to check basic functionality)
</pre>
<p>Any of these kinds of test can be provided as a constraint using the <strong>--constraint</strong> option.</p><p>To see a quick list of all of the test suites available, you can ask for them to be listed.  The following command,</p>
<pre>
./test.py --list
</pre>
<p>will result in a list of the test suite being displayed, similar to:</p>
<pre>
Waf: Entering directory \(ga/home/craigdo/repos/ns-3-allinone-test/ns-3-dev/build&apos;
Waf: Leaving directory \(ga/home/craigdo/repos/ns-3-allinone-test/ns-3-dev/build&apos;
&apos;build&apos; finished successfully (0.939s)
histogram
ns3-wifi-interference
ns3-tcp-cwnd
ns3-tcp-interoperability
sample
devices-mesh-flame
devices-mesh-dot11s
devices-mesh
...
object-name-service
callback
attributes
config
global-value
command-line
basic-random-number
object
</pre>
<p>Any of these listed suites can be selected to be run by itself using the <strong>--suite</strong> option as shown above.</p><p>Similarly to test suites, one can run a single C++ example program using the <strong>--example</strong> option.  Note that the relative path for the example does not need to be included and that the executables built for C++ examples do not have extensions.  Entering</p>
<pre>
./test.py --example=udp-echo
</pre>
<p>results in that single example being run.</p>
<pre>
PASS: Example examples/udp/udp-echo
</pre>
<p>You can specify the directory where ns-3 was built using the <strong>--buildpath</strong> option as follows.</p>
<pre>
./test.py --buildpath=/home/craigdo/repos/ns-3-allinone-test/ns-3-dev/build/debug --example=wifi-simple-adhoc
</pre>
<p>One can run a single Python example program using the <strong>--pyexample</strong> option.  Note that the relative path for the example must be included and that Python examples do need their extensions.  Entering</p>
<pre>
./test.py --pyexample=examples/tutorial/first.py
</pre>
<p>results in that single example being run.</p>
<pre>
PASS: Example examples/tutorial/first.py
</pre>
<p>Because Python examples are not built, you do not need to specify the directory where ns-3 was built to run them.</p><p>Normally when example programs are executed, they write a large amount of trace file data.  This is normally saved to the base directory of the distribution (e.g., /home/user/ns-3-dev).  When <strong>test.py</strong> runs an example, it really is completely unconcerned with the trace files.  It just wants to to determine if the example can be built and run without error.  Since this is the case, the trace files are written into a <strong>/tmp/unchecked-traces</strong> directory.  If you run the above example, you should be able to find the associated <strong>udp-echo.tr</strong> and <strong>udp-echo-n-1.pcap</strong> files there.</p><p>The list of available examples is defined by the contents of the &apos;&apos;examples&apos;&apos; directory in the distribution.  If you select an example for execution using the <strong>--example</strong> option, <strong>test.py</strong> will not make any attempt to decide if the example has been configured or not, it will just try to run it and report the result of the attempt.</p><p>When <strong>test.py</strong> runs, by default it will first ensure that the system has been completely built.  This can be defeated by selecting the <strong>--nowaf</strong> option.</p>
<pre>
./test.py --list --nowaf
</pre>
<p>will result in a list of the currently built test suites being displayed, similar to:</p>
<pre>
ns3-wifi-propagation-loss-models
ns3-tcp-cwnd
ns3-tcp-interoperability
pcap-file-object
object-name-service
random-number-generators
</pre>
<p>Note the absence of the <strong>Waf</strong> build messages.</p><p><strong>test.py</strong> also supports running the test suites and examples under valgrind. Valgrind is a flexible program for debugging and profiling Linux executables.  By default, valgrind runs a tool called memcheck, which performs a range of memory- checking functions, including detecting accesses to uninitialised memory, misuse of allocated memory (double frees, access after free, etc.) and detecting memory leaks.  This can be selected by using the <strong>--grind</strong> option.</p>
<pre>
./test.py --grind
</pre>
<p>As it runs, <strong>test.py</strong> and the programs that it runs indirectly, generate large numbers of temporary files.  Usually, the content of these files is not interesting, however in some cases it can be useful (for debugging purposes) to view these files. <strong>test.py</strong> provides a <strong>--retain</strong> option which will cause these temporary files to be kept after the run is completed.  The files are saved in a directory named <strong>testpy-output</strong> under a subdirectory named according to the current Coordinated Universal Time (also known as Greenwich Mean Time).</p>
<pre>
./test.py --retain
</pre>
<p>Finally, <strong>test.py</strong> provides a <strong>--verbose</strong> option which will print large amounts of information about its progress.  It is not expected that this will be terribly useful unless there is an error.  In this case, you can get access to the standard output and standard error reported by running test suites and examples.  Select verbose in the following way:</p>
<pre>
./test.py --verbose
</pre>
<p>All of these options can be mixed and matched.  For example, to run all of the ns-3 core test suites under valgrind, in verbose mode, while generating an HTML output file, one would do:</p>
<pre>
./test.py --verbose --grind --constrain=core --html=results.html
</pre>

<h3>TestTaxonomy</h3>
<p>As mentioned above, tests are grouped into a number of broadly defined classifications to allow users to selectively run tests to address the different kinds of testing that need to be done.</p><ul>
<li><p>Build Verification Tests</p></li><li><p>Unit Tests</p></li><li><p>System Tests</p></li><li><p>Examples</p></li><li><p>Performance Tests</p></li>
</ul>
<h3>BuildVerificationTests</h3>
<p>These are relatively simple tests that are built along with the distribution and are used to make sure that the build is pretty much working.  Our current unit tests live in the source files of the code they test and are built into the ns-3 modules; and so fit the description of BVTs.  BVTs live in the same source code that is built into the ns-3 code.  Our current tests are examples of this kind of test.</p>
<h3>Unit Tests</h3>
<p>Unit tests are more involved tests that go into detail to make sure that a piece of code works as advertised in isolation.  There is really no reason for this kind of test to be built into an ns-3 module.  It turns out, for example, that the unit tests for the object name service are about the same size as the object name service code itself.  Unit tests are tests that check a single bit of functionality that are not built into the ns-3 code, but live in the same directory as the code it tests.  It is possible that these tests check integration of multiple implementation files in a module as well.  The file src/core/test/names-test-suite.cc is an example of this kind of test.  The file src/network/test/pcap-file-test-suite.cc is another example that uses a known good pcap file as a test vector file.  This file is stored locally in the src/network directory.</p>
<h3>System Tests</h3>
<p>System tests are those that involve more than one module in the system.  We have lots of this kind of test running in our current regression framework, but they are typically overloaded examples.  We provide a new place for this kind of test in the directory <strong>src/test</strong>.  The file src/test/ns3tcp/ns3-interop-test-suite.cc is an example of this kind of test.  It uses NSC TCP to test the ns-3 TCP implementation.  Often there will be test vectors required for this kind of test, and they are stored in the directory where the test lives.  For example, ns3tcp-interop-response-vectors.pcap is a file consisting of a number of TCP headers that are used as the expected responses of the ns-3 TCP under test to a stimulus generated by the NSC TCP which is used as a &apos;&apos;known good&apos;&apos; implementation.</p>
<h3>Examples</h3>
<p>The examples are tested by the framework to make sure they built and will run.  Nothing is checked, and currently the pcap files are just written off into /tmp to be discarded.  If the examples run (don&apos;t crash) they pass this smoke test.</p>
<h3>Performance Tests</h3>
<p>Performance tests are those which exercise a particular part of the system and determine if the tests have executed to completion in a reasonable time.</p>
<h3>Running Tests</h3>
<p>Tests are typically run using the high level <strong>test.py</strong> program. To get a list of the available command-line options, run <strong>test.py --help</strong></p><p>The test program <strong>test.py</strong> will run both tests and those examples that have been added to the list to check.  The difference between tests and examples is as follows.  Tests generally check that specific simulation output or events conforms to expected behavior.  In contrast, the output of examples is not checked, and the test program merely checks the exit status of the example program to make sure that it runs without error.</p><p>Briefly, to run all tests, first one must configure tests during configuration stage, and also (optionally) examples if examples are to be checked:</p>
<pre>
./waf --configure --enable-examples --enable-tests
</pre>
<p>Then, build ns-3, and after it is built, just run <strong>test.py</strong>.  <strong>test.py -h</strong> will show a number of configuration options that modify the behavior of test.py.</p><p>The program <strong>test.py</strong> invokes, for C++ tests and examples, a lower-level C++ program called <strong>test-runner</strong> to actually run the tests.  As discussed below, this <strong>test-runner</strong> can be a helpful way to debug tests.</p>
<h3>Debugging Tests</h3>
<p>The debugging of the test programs is best performed running the low-level test-runner program. The test-runner is the bridge from generic Python code to <em>ns-3</em> code. It is written in C++ and uses the automatic test discovery process in the <em>ns-3</em> code to find and allow execution of all of the various tests.</p><p>The main reason why <strong>test.py</strong> is not suitable for debugging is that it is not allowed for logging to be turned on using the <strong>NS_LOG</strong> environmental variable when test.py runs.  This limitation does not apply to the test-runner executable. Hence, if you want to see logging output from your tests, you have to run them using the test-runner directly.</p><p>In order to execute the test-runner, you run it like any other ns-3 executable -- using <strong>waf</strong>.  To get a list of available options, you can type:</p>
<pre>
./waf --run "test-runner --help"
</pre>
<p>You should see something like the following:</p>
<pre>
Waf: Entering directory \(ga/home/craigdo/repos/ns-3-allinone-test/ns-3-dev/build&apos;
Waf: Leaving directory \(ga/home/craigdo/repos/ns-3-allinone-test/ns-3-dev/build&apos;
&apos;build&apos; finished successfully (0.353s)
--assert:               Tell tests to segfault (like assert) if an error is detected
--basedir=dir:          Set the base directory (where to find src) to &apos;&apos;dir&apos;&apos;
--tempdir=dir:          Set the temporary directory (where to find data files) to &apos;&apos;dir&apos;&apos;
--constrain=test-type:  Constrain checks to test suites of type &apos;&apos;test-type&apos;&apos;
--help:                 Print this message
--kinds:                List all of the available kinds of tests
--list:                 List all of the test suites (optionally constrained by test-type)
--out=file-name:        Set the test status output file to &apos;&apos;file-name&apos;&apos;
--suite=suite-name:     Run the test suite named &apos;&apos;suite-name&apos;&apos;
--verbose:              Turn on messages in the run test suites
</pre>
<p>There are a number of things available to you which will be familiar to you if you have looked at <strong>test.py</strong>.  This should be expected since the test- runner is just an interface between <strong>test.py</strong> and <em>ns-3</em>.  You may notice that example-related commands are missing here.  That is because the examples are really not <em>ns-3</em> tests.  <strong>test.py</strong> runs them as if they were to present a unified testing environment, but they are really completely different and not to be found here.</p><p>The first new option that appears here, but not in test.py is the <strong>--assert</strong> option.  This option is useful when debugging a test case when running under a debugger like <strong>gdb</strong>.  When selected, this option tells the underlying test case to cause a segmentation violation if an error is detected.  This has the nice side-effect of causing program execution to stop (break into the debugger) when an error is detected.  If you are using gdb, you could use this option something like,</p>
<pre>
./waf shell
cd build/debug/utils
gdb test-runner
run --suite=global-value --assert
</pre>
<p>If an error is then found in the global-value test suite, a segfault would be generated and the (source level) debugger would stop at the <strong>NS_TEST_ASSERT_MSG</strong> that detected the error.</p><p>Another new option that appears here is the <strong>--basedir</strong> option.  It turns out that some tests may need to reference the source directory of the <em>ns-3</em> distribution to find local data, so a base directory is always required to run a test.</p><p>If you run a test from test.py, the Python program will provide the basedir option for you.  To run one of the tests directly from the test-runner using <strong>waf</strong>, you will need to specify the test suite to run along with the base directory.  So you could use the shell and do:</p>
<pre>
./waf --run "test-runner --basedir=\(gapwd\(ga --suite=pcap-file-object"
</pre>
<p>Note the &apos;&apos;backward&apos;&apos; quotation marks on the <strong>pwd</strong> command.</p><p>If you are running the test suite out of a debugger, it can be quite painful to remember and constantly type the absolute path of the distribution base directory. Because of this, if you omit the basedir, the test-runner will try to figure one out for you.  It begins in the current working directory and walks up the directory tree looking for a directory file with files named <strong>VERSION</strong> and <strong>LICENSE.</strong>  If it finds one, it assumes that must be the basedir and provides it for you.</p>
<h3>Test output</h3>
<p>Many test suites need to write temporary files (such as pcap files) in the process of running the tests.  The tests then need a temporary directory to write to.  The Python test utility (test.py) will provide a temporary file automatically, but if run stand-alone this temporary directory must be provided. Just as in the basedir case, it can be annoying to continually have to provide a <strong>--tempdir</strong>, so the test runner will figure one out for you if you don&apos;t provide one.  It first looks for environment variables named <strong>TMP</strong> and <strong>TEMP</strong> and uses those.  If neither <strong>TMP</strong> nor <strong>TEMP</strong> are defined it picks <strong>/tmp</strong>.  The code then tacks on an identifier indicating what created the directory (ns-3) then the time (hh.mm.ss) followed by a large random number.  The test runner creates a directory of that name to be used as the temporary directory.  Temporary files then go into a directory that will be named something like</p>
<pre>
/tmp/ns-3.10.25.37.61537845
</pre>
<p>The time is provided as a hint so that you can relatively easily reconstruct what directory was used if you need to go back and look at the files that were placed in that directory.</p><p>Another class of output is test output like pcap traces that are generated to compare to reference output.  The test program will typically delete these after the test suites all run.  To disable the deletion of test output, run <strong>test.py</strong> with the "retain" option:</p>
<pre>
./test.py -r
</pre>
<p>and test output can be found in the <strong>testpy-output/</strong> directory.</p>
<h3>Reporting of test failures</h3>
<p>When you run a test suite using the test-runner it will run the test quietly by default.  The only indication that you will get that the test passed is the <em>absence</em> of a message from <strong>waf</strong> saying that the program returned something other than a zero exit code.  To get some output from the test, you need to specify an output file to which the tests will write their XML status using the <strong>--out</strong> option.  You need to be careful interpreting the results because the test suites will <em>append</em> results onto this file. Try,</p>
<pre>
./waf --run "test-runner --basedir=\(gapwd\(ga --suite=pcap-file-object --out=myfile.xml"
</pre>
<p>If you look at the file <strong>myfile.xml</strong> you should see something like,</p>
<pre>
&lt;TestSuite&gt;
  &lt;SuiteName&gt;pcap-file-object&lt;/SuiteName&gt;
  &lt;TestCase&gt;
    &lt;CaseName&gt;Check to see that PcapFile::Open with mode &apos;&apos;w&apos;&apos; works&lt;/CaseName&gt;
    &lt;CaseResult&gt;PASS&lt;/CaseResult&gt;
    &lt;CaseTime&gt;real 0.00 user 0.00 system 0.00&lt;/CaseTime&gt;
  &lt;/TestCase&gt;
  &lt;TestCase&gt;
    &lt;CaseName&gt;Check to see that PcapFile::Open with mode &apos;&apos;r&apos;&apos; works&lt;/CaseName&gt;
    &lt;CaseResult&gt;PASS&lt;/CaseResult&gt;
    &lt;CaseTime&gt;real 0.00 user 0.00 system 0.00&lt;/CaseTime&gt;
  &lt;/TestCase&gt;
  &lt;TestCase&gt;
    &lt;CaseName&gt;Check to see that PcapFile::Open with mode &apos;&apos;a&apos;&apos; works&lt;/CaseName&gt;
    &lt;CaseResult&gt;PASS&lt;/CaseResult&gt;
    &lt;CaseTime&gt;real 0.00 user 0.00 system 0.00&lt;/CaseTime&gt;
  &lt;/TestCase&gt;
  &lt;TestCase&gt;
    &lt;CaseName&gt;Check to see that PcapFileHeader is managed correctly&lt;/CaseName&gt;
    &lt;CaseResult&gt;PASS&lt;/CaseResult&gt;
    &lt;CaseTime&gt;real 0.00 user 0.00 system 0.00&lt;/CaseTime&gt;
  &lt;/TestCase&gt;
  &lt;TestCase&gt;
    &lt;CaseName&gt;Check to see that PcapRecordHeader is managed correctly&lt;/CaseName&gt;
    &lt;CaseResult&gt;PASS&lt;/CaseResult&gt;
    &lt;CaseTime&gt;real 0.00 user 0.00 system 0.00&lt;/CaseTime&gt;
  &lt;/TestCase&gt;
  &lt;TestCase&gt;
    &lt;CaseName&gt;Check to see that PcapFile can read out a known good pcap file&lt;/CaseName&gt;
    &lt;CaseResult&gt;PASS&lt;/CaseResult&gt;
    &lt;CaseTime&gt;real 0.00 user 0.00 system 0.00&lt;/CaseTime&gt;
  &lt;/TestCase&gt;
  &lt;SuiteResult&gt;PASS&lt;/SuiteResult&gt;
  &lt;SuiteTime&gt;real 0.00 user 0.00 system 0.00&lt;/SuiteTime&gt;
&lt;/TestSuite&gt;
</pre>
<p>If you are familiar with XML this should be fairly self-explanatory.  It is also not a complete XML file since test suites are designed to have their output appended to a master XML status file as described in the <strong>test.py</strong> section.</p>
<h3>Debugging test suite failures</h3>
<p>To debug test crashes, such as:</p>
<pre>
CRASH: TestSuite ns3-wifi-interference
</pre>
<p>You can access the underlying test-runner program via gdb as follows, and then pass the "--basedir=\(gapwd\(ga" argument to run (you can also pass other arguments as needed, but basedir is the minimum needed):</p>
<pre>
./waf --command-template="gdb %s" --run "test-runner"
Waf: Entering directory \(ga/home/tomh/hg/sep09/ns-3-allinone/ns-3-dev-678/build&apos;
Waf: Leaving directory \(ga/home/tomh/hg/sep09/ns-3-allinone/ns-3-dev-678/build&apos;
&apos;build&apos; finished successfully (0.380s)
GNU gdb 6.8-debian
Copyright (C) 2008 Free Software Foundation, Inc.
L cense GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu"...
(gdb) r --basedir=\(gapwd\(ga
Starting program: &lt;..&gt;/build/debug/utils/test-runner --basedir=\(gapwd\(ga
[Thread debugging using libthread_db enabled]
assert failed. file=../src/core/model/type-id.cc, line=138, cond="uid &lt;= m_information.size () && uid != 0"
...
</pre>
<p>Here is another example of how to use valgrind to debug a memory problem such as:</p>
<pre>
VALGR: TestSuite devices-mesh-dot11s-regression

./waf --command-template="valgrind %s --basedir=\(gapwd\(ga --suite=devices-mesh-dot11s-regression" --run test-runner
</pre>

<h3>Class TestRunner</h3>
<p>The executables that run dedicated test programs use a TestRunner class.  This class provides for automatic test registration and listing, as well as a way to execute the individual tests.  Individual test suites use C++ global constructors to add themselves to a collection of test suites managed by the test runner. The test runner is used to list all of the available tests and to select a test to be run.  This is a quite simple class that provides three static methods to provide or Adding and Getting test suites to a collection of tests.  See the doxygen for class <strong>ns3::TestRunner</strong> for details.</p>
<h3>Test Suite</h3>
<p>All <em>ns-3</em> tests are classified into Test Suites and Test Cases.  A test suite is a collection of test cases that completely exercise a given kind of functionality.  As described above, test suites can be classified as,</p><ul>
<li><p>Build Verification Tests</p></li><li><p>Unit Tests</p></li><li><p>System Tests</p></li><li><p>Examples</p></li><li><p>Performance Tests</p><p>This classification is exported from the TestSuite class.  This class is quite simple, existing only as a place to export this type and to accumulate test cases.  From a user perspective, in order to create a new TestSuite in the system one only has to define a new class that inherits from class <strong>TestSuite</strong> and perform these two duties.</p><p>The following code will define a new class that can be run by <strong>test.py</strong> as a &apos;&apos;unit&apos;&apos; test with the display name, <strong>my-test-suite-name</strong>.</p>
<pre>
class MySuite : public TestSuite
{
public:
  MyTestSuite ();
};

MyTestSuite::MyTestSuite ()
  : TestSuite ("my-test-suite-name", UNIT)
{
  AddTestCase (new MyTestCase);
}

MyTestSuite myTestSuite;
</pre>
<p>The base class takes care of all of the registration and reporting required to be a good citizen in the test framework.</p></li>
</ul>
<h3>Test Case</h3>
<p>Individual tests are created using a TestCase class.  Common models for the use of a test case include "one test case per feature", and "one test case per method." Mixtures of these models may be used.</p><p>In order to create a new test case in the system, all one has to do is to inherit from the  <strong>TestCase</strong> base class, override the constructor to give the test case a name and override the <strong>DoRun</strong> method to run the test.</p>
<pre>
class MyTestCase : public TestCase
{
  MyTestCase ();
  virtual void DoRun (void);
};

MyTestCase::MyTestCase ()
  : TestCase ("Check some bit of functionality")
{
}

void
MyTestCase::DoRun (void)
{
  NS_TEST_ASSERT_MSG_EQ (true, true, "Some failure message");
}
</pre>

<h3>Utilities</h3>
<p>There are a number of utilities of various kinds that are also part of the testing framework.  Examples include a generalized pcap file useful for storing test vectors; a generic container useful for transient storage of test vectors during test execution; and tools for generating presentations based on validation and verification testing results.</p><p>These utilities are not documented here, but for example, please see how the TCP tests found in <strong>src/test/ns3tcp/</strong> use pcap files and reference output.</p>
<h3>How to write tests</h3>
<p>A primary goal of the ns-3 project is to help users to improve the validity and credibility of their results.  There are many elements to obtaining valid models and simulations, and testing is a major component.  If you contribute models or examples to ns-3, you may be asked to contribute test code.  Models that you contribute will be used for many years by other people, who probably have no idea upon first glance whether the model is correct.  The test code that you write for your model will help to avoid future regressions in the output and will aid future users in understanding the verification and bounds of applicability of your models.</p><p>There are many ways to verify the correctness of a model&apos;s implementation. In this section, we hope to cover some common cases that can be used as a guide to writing new tests.</p>
<h3>Sample TestSuite skeleton</h3>
<p>When starting from scratch (i.e. not adding a TestCase to an existing TestSuite), these things need to be decided up front:</p><ul>
<li><p>What the test suite will be called</p></li><li><p>What type of test it will be (Build Verification Test, Unit Test, System Test, or Performance Test)</p></li><li><p>Where the test code will live (either in an existing ns-3 module or separately in src/test/ directory).  You will have to edit the wscript file in that directory to compile your new code, if it is a new file.</p><p>A program called <strong>src/create-module.py</strong> is a good starting point. This program can be invoked such as <strong>create-module.py router</strong> for a hypothetical new module called <strong>router</strong>.  Once you do this, you will see a <strong>router</strong> directory, and a <strong>test/router-test-suite.cc</strong> test suite.  This file can be a starting point for your initial test. This is a working test suite, although the actual tests performed are trivial.  Copy it over to your module&apos;s test directory, and do a global substitution of "Router" in that file for something pertaining to the model that you want to test.  You can also edit things such as a more descriptive test case name.</p><p>You also need to add a block into your wscript to get this test to compile:</p>
<pre>
module_test.source = [
    &apos;test/router-test-suite.cc&apos;,
    ]
</pre>
<p>Before you actually start making this do useful things, it may help to try to run the skeleton.  Make sure that ns-3 has been configured with the "--enable-tests" option.  Let&apos;s assume that your new test suite is called "router" such as here:</p>
<pre>
RouterTestSuite::RouterTestSuite ()
  : TestSuite ("router", UNIT)
</pre>
<p>Try this command:</p>
<pre>
./test.py -s router
</pre>
<p>Output such as below should be produced:</p>
<pre>
PASS: TestSuite router
1 of 1 tests passed (1 passed, 0 skipped, 0 failed, 0 crashed, 0 valgrind errors)
</pre>
<p>See src/lte/test/test-lte-antenna.cc for a worked example.</p></li>
</ul>
<h3>Test macros</h3>
<p>There are a number of macros available for checking test program output with expected output.  These macros are defined in <strong>src/core/model/test.h</strong>.</p><p>The main set of macros that are used include the following:</p>
<pre>
NS_TEST_ASSERT_MSG_EQ(actual, limit, msg)
NS_TEST_ASSERT_MSG_NE(actual, limit, msg)
NS_TEST_ASSERT_MSG_LT(actual, limit, msg)
NS_TEST_ASSERT_MSG_GT(actual, limit, msg)
NS_TEST_ASSERT_MSG_EQ_TOL(actual, limit, tol, msg)
</pre>
<p>The first argument <strong>actual</strong> is the value under test, the second value <strong>limit</strong> is the expected value (or the value to test against), and the last argument <strong>msg</strong> is the error message to print out if the test fails.</p><p>The first four macros above test for equality, inequality, less than, or greater than, respectively.  The fifth macro above tests for equality, but within a certain tolerance.  This variant is useful when testing floating point numbers for equality against a limit, where you want to avoid a test failure due to rounding errors.</p><p>Finally, there are variants of the above where the keyword <strong>ASSERT</strong> is replaced by <strong>EXPECT</strong>.  These variants are designed specially for use in methods (especially callbacks) returning void.  Reserve their use for callbacks that you use in your test programs; otherwise, use the <strong>ASSERT</strong> variants.</p>
<h3>How to add an example program to the test suite</h3>
<p>One can "smoke test" that examples compile and run successfully to completion (without memory leaks) using the <strong>examples-to-run.py</strong> script located in your module&apos;s test directory.  Briefly, by including an instance of this file in your test directory, you can cause the test runner to execute the examples listed.  It is usually best to make sure that you select examples that have reasonably short run times so as to not bog down the tests.  See the example in <strong>src/lte/test/</strong> directory.</p>
<h3>Testing for boolean outcomes</h3>

<h3>Testing outcomes when randomness is involved</h3>

<h3>Testing output data against a known distribution</h3>

<h3>Providing non-trivial input vectors of data</h3>

<h3>Storing and referencing non-trivial output data</h3>

<h3>Presenting your output test data</h3>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SUPPORT</h2>
        <div class="sectioncontent">
<h3>Creating a new ns-3 model</h3>
<p>This chapter walks through the design process of an <em>ns-3</em> model.  In many research cases, users will not be satisfied to merely adapt existing models, but may want to extend the core of the simulator in a novel way. We will use the example of adding an ErrorModel to a simple <em>ns-3</em> link as a motivating example of how one might approach this problem and proceed through a design and implementation.</p>
<h3>Design-approach</h3>
<p>Consider how you want it to work; what should it do. Think about these things:</p><ul>
<li><p><em>functionality:</em>  What functionality should it have?  What attributes or configuration is exposed to the user?</p></li><li><p><em>reusability:</em>  How much should others be able to reuse my design?  Can I reuse code from <em>ns-2</em> to get started?  How does a user integrate the model with the rest of another simulation?</p></li><li><p><em>dependencies:</em>  How can I reduce the introduction of outside dependencies on my new code as much as possible (to make it more modular)?  For instance, should I avoid any dependence on IPv4 if I want it to also be used by IPv6? Should I avoid any dependency on IP at all?</p><p>Do not be hesitant to contact the ns-3-users or ns-developers list if you have questions. In particular, it is important to think about the public API of your new model and ask for feedback. It also helps to let others know of your work in case you are interested in collaborators.</p></li>
</ul>
<h3>Example: ErrorModel</h3>
<p>An error model exists in <em>ns-2</em>. It allows packets to be passed to a stateful object that determines, based on a random variable, whether the packet is corrupted.  The caller can then decide what to do with the packet (drop it, etc.).</p><p>The main API of the error model is a function to pass a packet to, and the return value of this function is a boolean that tells the caller whether any corruption occurred.  Note that depending on the error model, the packet data buffer may or may not be corrupted.  Let&apos;s call this function "IsCorrupt()".</p><p>So far, in our design, we have::</p>
<pre>
class ErrorModel
{
public:
 /**
  * &#92;returns true if the Packet is to be considered as errored/corrupted
  * &#92;param pkt Packet to apply error model to
  */
  bool IsCorrupt (Ptr&lt;Packet&gt; pkt);
};
</pre>
<p>Note that we do not pass a const pointer, thereby allowing the function to modify the packet if IsCorrupt() returns true. Not all error models will actually modify the packet; whether or not the packet data buffer is corrupted should be documented.</p><p>We may also want specialized versions of this, such as in <em>ns-2</em>, so although it is not the only design choice for polymorphism, we assume that we will subclass a base class ErrorModel for specialized classes, such as RateErrorModel, ListErrorModel, etc, such as is done in <em>ns-2</em>.</p><p>You may be thinking at this point, "Why not make IsCorrupt() a virtual method?". That is one approach; the other is to make the public non-virtual function indirect through a private virtual function (this in C++ is known as the non virtual interface idiom and is adopted in the <em>ns-3</em> ErrorModel class).</p><p>Next, should this device have any dependencies on IP or other protocols?  We do not want to create dependencies on Internet protocols (the error model should be applicable to non-Internet protocols too), so we&apos;ll keep that in mind later.</p><p>Another consideration is how objects will include this error model.  We envision putting an explicit setter in certain NetDevice implementations, for example.:</p>
<pre>
/**
 * Attach a receive ErrorModel to the PointToPointNetDevice.
 *
 * The PointToPointNetDevice may optionally include an ErrorModel in
 * the packet receive chain.
 *
 * @see ErrorModel
 * @param em Ptr to the ErrorModel.
 */
void PointToPointNetDevice::SetReceiveErrorModel(Ptr&lt;ErrorModel&gt; em);
</pre>
<p>Again, this is not the only choice we have (error models could be aggregated to lots of other objects), but it satisfies our primary use case, which is to allow a user to force errors on otherwise successful packet transmissions, at the NetDevice level.</p><p>After some thinking and looking at existing <em>ns-2</em> code, here is a sample API of a base class and first subclass that could be posted for initial review::</p>
<pre>
class ErrorModel
{
public:
  ErrorModel ();
  virtual ~ErrorModel ();
  bool IsCorrupt (Ptr&lt;Packet&gt; pkt);
  void Reset (void);
  void Enable (void);
  void Disable (void);
  bool IsEnabled (void) const;
private:
  virtual bool DoCorrupt (Ptr&lt;Packet&gt; pkt) = 0;
  virtual void DoReset (void) = 0;
};

enum ErrorUnit
  {
    EU_BIT,
    EU_BYTE,
    EU_PKT
  };

// Determine which packets are errored corresponding to an underlying
// random variable distribution, an error rate, and unit for the rate.
class RateErrorModel : public ErrorModel
{
public:
  RateErrorModel ();
  virtual ~RateErrorModel ();
  enum ErrorUnit GetUnit (void) const;
  void SetUnit (enum ErrorUnit error_unit);
  double GetRate (void) const;
  void SetRate (double rate);
  void SetRandomVariable (const RandomVariable &ranvar);
private:
  virtual bool DoCorrupt (Ptr&lt;Packet&gt; pkt);
  virtual void DoReset (void);
};
</pre>

<h3>Scaffolding</h3>
<p>Let&apos;s say that you are ready to start implementing; you have a fairly clear picture of what you want to build, and you may have solicited some initial review or suggestions from the list.  One way to approach the next step (implementation) is to create scaffolding and fill in the details as the design matures.</p><p>This section walks through many of the steps you should consider to define scaffolding, or a non-functional skeleton of what your model will eventually implement. It is usually good practice to not wait to get these details integrated at the end, but instead to plumb a skeleton of your model into the system early and then add functions later once the API and integration seems about right.</p><p>Note that you will want to modify a few things in the below presentation for your model since if you follow the error model verbatim, the code you produce will collide with the existing error model. The below is just an outline of how ErrorModel was built that you can adapt to other models.</p>
<h3>Review the ns-3 coding style document</h3>
<p>At this point, you may want to pause and read the <em>ns-3</em> coding style document, especially if you are considering to contribute your code back to the project. The coding style document is linked off the main project page: <em>ns-3 coding</em> style.</p>
<h3>Decide where in the source tree the model will reside in</h3>
<p>All of the <em>ns-3</em> model source code is in the directory <strong>src/</strong>.  You will need to choose which subdirectory it resides in. If it is new model code of some sort, it makes sense to put it into the <strong>src/</strong> directory somewhere, particularly for ease of integrating with the build system.</p><p>In the case of the error model, it is very related to the packet class, so it makes sense to implement this in the <strong>src/network/</strong> module where <em>ns-3</em> packets are implemented.</p>
<h3>waf and wscript</h3>
<p><em>ns-3</em> uses the <em>Waf</em> build system. You will want to integrate your new <em>ns-3</em> uses the Waf build system. You will want to integrate your new source files into this system. This requires that you add your files to the <strong>wscript</strong> file found in each directory.</p><p>Let&apos;s start with empty files error-model.h and error-model.cc, and add this to <strong>src/network/wscript</strong>. It is really just a matter of adding the .cc file to the rest of the source files, and the .h file to the list of the header files.</p><p>Now, pop up to the top level directory and type "./test.py".  You shouldn&apos;t have broken anything by this operation.</p>
<h3>include guards</h3>
<p>Next, let&apos;s add some <em>include guards</em> in our header file.:</p>
<pre>
#ifndef ERROR_MODEL_H
#define ERROR_MODEL_H
...
#endif
</pre>

<h3>namespace ns3</h3>
<p><em>ns-3</em> uses the <em>ns-3</em> <em>namespace</em> to isolate its symbols from other namespaces. Typically, a user will next put an <em>ns-3</em> namespace block in both the cc and h file.:</p>
<pre>
namespace ns3 {
...
}
</pre>
<p>At this point, we have some skeletal files in which we can start defining our new classes. The header file looks like this::</p>
<pre>
#ifndef ERROR_MODEL_H
#define ERROR_MODEL_H

namespace ns3 {

} // namespace ns3
#endif
</pre>
<p>while the <strong>error-model.cc</strong> file simply looks like this::</p>
<pre>
#include "error-model.h"

namespace ns3 {

} // namespace ns3
</pre>
<p>These files should compile since they don&apos;t really have any contents.  We&apos;re now ready to start adding classes.</p>
<h3>Initial Implementation</h3>
<p>At this point, we&apos;re still working on some scaffolding, but we can begin to define our classes, with the functionality to be added later.</p>
<h3>use of class Object?</h3>
<p>This is an important design step; whether to use class <strong>Object</strong> as a base class for your new classes.</p><p>As described in the chapter on the <em>ns-3</em> <em>Object-model</em>, classes that inherit from class <strong>Object</strong> get special properties:</p><ul>
<li><p>the <em>ns-3</em> type and attribute system (see <em>Attributes</em>)</p></li><li><p>an object aggregation system</p></li><li><p>a smart-pointer reference counting system (class Ptr)</p><p>Classes that derive from class <strong>ObjectBase</strong>} get the first two properties above, but do not get smart pointers. Classes that derive from class <strong>RefCountBase</strong> get only the smart-pointer reference counting system.</p><p>In practice, class <strong>Object</strong> is the variant of the three above that the <em>ns-3</em> developer will most commonly encounter.</p><p>In our case, we want to make use of the attribute system, and we will be passing instances of this object across the <em>ns-3</em> public API, so class <strong>Object</strong> is appropriate for us.</p></li>
</ul>
<h3>initial classes</h3>
<p>One way to proceed is to start by defining the bare minimum functions and see if they will compile. Let&apos;s review what all is needed to implement when we derive from class Object.:</p>
<pre>
#ifndef ERROR_MODEL_H
#define ERROR_MODEL_H

#include "ns3/object.h"

namespace ns3 {

class ErrorModel : public Object
{
public:
  static TypeId GetTypeId (void);

  ErrorModel ();
  virtual ~ErrorModel ();
};

class RateErrorModel : public ErrorModel
{
public:
  static TypeId GetTypeId (void);

  RateErrorModel ();
  virtual ~RateErrorModel ();
};
#endif
</pre>
<p>A few things to note here. We need to include <strong>object.h</strong>. The convention in <em>ns-3</em> is that if the header file is co-located in the same directory, it may be included without any path prefix. Therefore, if we were implementing ErrorModel in <strong>src/core/model</strong> directory, we could have just said "<strong>#include "object.h"</strong>". But we are in <strong>src/network/model</strong>, so we must include it as "<strong>#include</strong> "ns3/object.h"". Note also that this goes outside the namespace declaration.</p><p>Second, each class must implement a static public member function called <strong>GetTypeId (void)</strong>.</p><p>Third, it is a good idea to implement constructors and destructors rather than to let the compiler generate them, and to make the destructor virtual. In C++, note also that copy assignment operator and copy constructors are auto-generated if they are not defined, so if you do not want those, you should implement those as private members. This aspect of C++ is discussed in Scott Meyers&apos; Effective C++ book. item 45.</p><p>Let&apos;s now look at some corresponding skeletal implementation code in the .cc file.:</p>
<pre>
#include "error-model.h"

namespace ns3 {

NS_OBJECT_ENSURE_REGISTERED (ErrorModel);

TypeId ErrorModel::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::ErrorModel")
    .SetParent&lt;Object&gt; ()
    ;
  return tid;
}

ErrorModel::ErrorModel ()
{
}

ErrorModel::~ErrorModel ()
{
}

NS_OBJECT_ENSURE_REGISTERED (RateErrorModel);

TypeId RateErrorModel::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::RateErrorModel")
    .SetParent&lt;ErrorModel&gt; ()
    .AddConstructor&lt;RateErrorModel&gt; ()
    ;
  return tid;
}

RateErrorModel::RateErrorModel ()
{
}

RateErrorModel::~RateErrorModel ()
{
}
</pre>
<p>What is the <strong>GetTypeId (void)</strong> function? This function does a few things.  It registers a unique string into the TypeId system. It establishes  the hierarchy of objects in the attribute system (via <strong>SetParent</strong>). It also declares that certain objects can be created via the object creation framework (<strong>AddConstructor</strong>).</p><p>The macro <strong>NS_OBJECT_ENSURE_REGISTERED (classname)</strong> is needed also once for every class that defines a new GetTypeId method, and it does the actual registration of the class into the system.  The <em>Object-model</em> chapter discusses this in more detail.</p>
<h3>how to include files from elsewhere</h3>

<h3>log component</h3>
<p><em>Here, write a bit about adding |ns3| logging macros. Note that</em> LOG_COMPONENT_DEFINE is done outside the namespace ns3</p>
<h3>constructor, empty function prototypes</h3>

<h3>key variables (default values, attributes)</h3>

<h3>test program 1</h3>

<h3>Object Framework</h3>

<h3>Adding-a-sample-script</h3>
<p>At this point, one may want to try to take the basic scaffolding defined above and add it into the system. Performing this step now allows one to use a simpler model when plumbing into the system and may also reveal whether any design or API modifications need to be made. Once this is done, we will return to building out the functionality of the ErrorModels themselves.</p>
<h3>Add basic support in the class</h3>

<pre>
point-to-point-net-device.h
  class ErrorModel;

  /**
   * Error model for receive packet events
   */
  Ptr&lt;ErrorModel&gt; m_receiveErrorModel;
</pre>

<h3>Add Accessor</h3>

<pre>
void
PointToPointNetDevice::SetReceiveErrorModel (Ptr&lt;ErrorModel&gt; em)
{
  NS_LOG_FUNCTION (this &lt;&lt; em);
  m_receiveErrorModel = em;
}

   .AddAttribute ("ReceiveErrorModel",
                   "The receiver error model used to simulate packet loss",
                   PointerValue (),
                   MakePointerAccessor (&PointToPointNetDevice::m_receiveErrorModel),
                   MakePointerChecker&lt;ErrorModel&gt; ())
</pre>

<h3>Plumb into the system</h3>

<pre>
void PointToPointNetDevice::Receive (Ptr&lt;Packet&gt; packet)
{
  NS_LOG_FUNCTION (this &lt;&lt; packet);
  uint16_t protocol = 0;

  if (m_receiveErrorModel && m_receiveErrorModel-&gt;IsCorrupt (packet) )
    {
//
// If we have an error model and it indicates that it is time to lose a
// corrupted packet, don&apos;t forward this packet up, let it go.
//
      m_dropTrace (packet);
    }
  else
    {
//
// Hit the receive trace hook, strip off the point-to-point protocol header
// and forward this packet up the protocol stack.
//
      m_rxTrace (packet);
      ProcessHeader(packet, protocol);
      m_rxCallback (this, packet, protocol, GetRemote ());
      if (!m_promiscCallback.IsNull ())
        {           m_promiscCallback (this, packet, protocol, GetRemote (),
                      GetAddress (), NetDevice::PACKET_HOST);
        }
    }
}
</pre>

<h3>Create null functional script</h3>

<pre>
simple-error-model.cc

  // Error model
  // We want to add an error model to node 3&apos;s NetDevice
  // We can obtain a handle to the NetDevice via the channel and node
  // pointers
  Ptr&lt;PointToPointNetDevice&gt; nd3 = PointToPointTopology::GetNetDevice
    (n3, channel2);
  Ptr&lt;ErrorModel&gt; em = Create&lt;ErrorModel&gt; ();
  nd3-&gt;SetReceiveErrorModel (em);


bool
ErrorModel::DoCorrupt (Packet& p)
{
  NS_LOG_FUNCTION;
  NS_LOG_UNCOND("Corrupt!");
  return false;
}
</pre>
<p>At this point, we can run the program with our trivial ErrorModel plumbed into the receive path of the PointToPointNetDevice. It prints out the string "Corrupt!" for each packet received at node n3. Next, we return to the error model to add in a subclass that performs more interesting error modeling.</p>
<h3>Add subclass</h3>
<p>The trivial base class ErrorModel does not do anything interesting, but it provides a useful base class interface (Corrupt () and Reset ()), forwarded to virtual functions that can be subclassed. Let&apos;s next consider what we call a BasicErrorModel which is based on the <em>ns-2</em> ErrorModel class (in <strong>ns-2/queue/errmodel.{cc,h}</strong>).</p><p>What properties do we want this to have, from a user interface perspective? We would like for the user to be able to trivially swap out the type of ErrorModel used in the NetDevice. We would also like the capability to set configurable parameters.</p><p>Here are a few simple requirements we will consider:</p><ul>
<li><p>Ability to set the random variable that governs the losses (default is UniformVariable)</p></li><li><p>Ability to set the unit (bit, byte, packet, time) of granularity over which errors are applied.</p></li><li><p>Ability to set the rate of errors (e.g. 10^-3) corresponding to the above unit of granularity.</p></li><li><p>Ability to enable/disable (default is enabled)</p></li>
</ul>
<h3>How to subclass</h3>
<p>We declare BasicErrorModel to be a subclass of ErrorModel as follows,:</p>
<pre>
class BasicErrorModel : public ErrorModel
{
public:
  static TypeId GetTypeId (void);
  ...
private:
  // Implement base class pure virtual functions
  virtual bool DoCorrupt (Ptr&lt;Packet&gt; p);
  virtual bool DoReset (void);
  ...
}
</pre>
<p>and configure the subclass GetTypeId function by setting a unique TypeId string and setting the Parent to ErrorModel::</p>
<pre>
TypeId RateErrorModel::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::RateErrorModel")
    .SetParent&lt;ErrorModel&gt; ()
    .AddConstructor&lt;RateErrorModel&gt; ()
  ...
</pre>

<h3>Build-core-functions-and-unit-tests</h3>

<h3>assert macros</h3>

<h3>Writing unit tests</h3>

<h3>Adding a New Module to \fIns-3\fP</h3>
<p>When you have created a group of related classes, examples, and tests, they can be combined together into an <em>ns-3</em> module so that they can be used with existing <em>ns-3</em> modules and by other researchers.</p><p>This chapter walks you through the steps necessary to add a new module to <em>ns-3</em>.</p>
<h3>Step 1 - Familiarize yourself with the module layout</h3>
<p>All modules can be found in the <strong>src</strong> directory.  Each module can be found in a directory that has the same name as the module.  For example, the spectrum module can be found here:</p>
<pre>
src/spectrum
</pre>
<p>A prototypical module has the following directory structure and required files:</p>
<pre>
src/
      module-name/
              bindings/
              doc/
              examples/
                      wscript
              helper/
              model/
              test/
                      examples-to-run.py
              wscript
</pre>
<p>Not all directories will be present in each module.</p>
<h3>Step 2 - Create your new module based on the template module</h3>
<p>A python program is provided in the source directory that will create a skeleton for a new module</p>
<pre>
src/create-module.py
</pre>
<p>For the purposes of this discussion we will assume that your new module is called "new-module".  From the <strong>src</strong> directory, do the following to create the new module:</p>
<pre>
./create-module.py new-module
</pre>
<p>Next, cd into <strong>new-module</strong>; you will find this directory layout:</p>
<pre>
examples  helper  model  test  wscript
</pre>
<p>We next walk through how to customize this module.  All <em>ns-3</em> modules depend on the &apos;core&apos; module and usually on other modules.  This dependency is specified in the wscript file. Let&apos;s assume that &apos;new-module&apos; depends on the internet, mobility, and aodv modules.  Then the call to the function that will create this module should look like this before editing:</p>
<pre>
def build(bld):
    module = bld.create_ns3_module(&apos;new-module&apos;, [&apos;core&apos;])
</pre>
<p>and after editing:</p>
<pre>
def build(bld):
    module = bld.create_ns3_module(&apos;new-module&apos;, [&apos;internet&apos;, &apos;mobility&apos;, &apos;aodv&apos;])
</pre>
<p>Your module will most likely have model source files.  Initial skeletons (which will compile successfully) are created in <strong>model/new-module.cc</strong> and <strong>model/new-module.h</strong>.</p><p>If your module will have helper source files, then they will go into the helper/ directory; again, initial skeletons are created in that directory.</p><p>Finally, it is good practice to write tests.  A skeleton test suite and test case is created in the test/ directory.  The below constructor specifies that it will be a unit test named &apos;new-module&apos;:</p>
<pre>
New-moduleTestSuite::New-moduleTestSuite ()
  : TestSuite ("new-module", UNIT)
{
  AddTestCase (new New-moduleTestCase1);
}
</pre>

<h3>Step 3 - Adding to your module&apos;s source files</h3>
<p>If your new module has model and/or helper source files, then they must be specified in your</p>
<pre>
src/new-module/wscript
</pre>
<p>file by modifying it with your text editor.</p><p>As an example, the source files for the spectrum module are specified in</p>
<pre>
src/spectrum/wscript
</pre>
<p>with the following list of source files:</p>
<pre>
module.source = [
    &apos;model/spectrum-model.cc&apos;,
    &apos;model/spectrum-value.cc&apos;,
           .
           .
           .
    &apos;model/microwave-oven-spectrum-value-helper.cc&apos;,
    &apos;helper/spectrum-helper.cc&apos;,
    &apos;helper/adhoc-aloha-noack-ideal-phy-helper.cc&apos;,
    &apos;helper/waveform-generator-helper.cc&apos;,
    &apos;helper/spectrum-analyzer-helper.cc&apos;,
    ]
</pre>

<h3>Step 4 - Specify your module&apos;s header files</h3>
<p>If your new module has model and/or helper header files, then they must be specified in your</p>
<pre>
src/new-module/wscript
</pre>
<p>file by modifying it with your text editor.</p><p>As an example, the header files for the spectrum module are specified in</p>
<pre>
src/spectrum/wscript
</pre>
<p>with the following function call, module name, and list of header files.  Note that the argument for the function new_task_gen() tells waf to install this module&apos;s headers with the other <em>ns-3</em> headers:</p>
<pre>
headers = bld.new_task_gen(features=[&apos;ns3header&apos;])

headers.module = &apos;spectrum&apos;

headers.source = [
    &apos;model/spectrum-model.h&apos;,
    &apos;model/spectrum-value.h&apos;,
           .
           .
           .
    &apos;model/microwave-oven-spectrum-value-helper.h&apos;,
    &apos;helper/spectrum-helper.h&apos;,
    &apos;helper/adhoc-aloha-noack-ideal-phy-helper.h&apos;,
    &apos;helper/waveform-generator-helper.h&apos;,
    &apos;helper/spectrum-analyzer-helper.h&apos;,
    ]
</pre>

<h3>Step 5 - Specify your module&apos;s tests</h3>
<p>If your new module has tests, then they must be specified in your</p>
<pre>
src/new-module/wscript
</pre>
<p>file by modifying it with your text editor.</p><p>As an example, the tests for the spectrum module are specified in</p>
<pre>
src/spectrum/wscript
</pre>
<p>with the following function call and list of test suites:</p>
<pre>
module_test = bld.create_ns3_module_test_library(&apos;spectrum&apos;)

module_test.source = [
    &apos;test/spectrum-interference-test.cc&apos;,
    &apos;test/spectrum-value-test.cc&apos;,
    ]
</pre>

<h3>Step 6 - Specify your module&apos;s examples</h3>
<p>If your new module has examples, then they must be specified in your</p>
<pre>
src/new-module/examples/wscript
</pre>
<p>file by modifying it with your text editor.</p><p>As an example, the examples for the core module are specified in</p>
<pre>
src/core/examples/wscript
</pre>
<p>The core module&apos;s C++ examples are specified using the following function calls and source file names.  Note that the second argument for the function <strong>create_ns3_program()</strong> is the list of modules that the program being created depends on:</p>
<pre>
obj = bld.create_ns3_program(&apos;main-callback&apos;, [&apos;core&apos;])
obj.source = &apos;main-callback.cc&apos;

obj = bld.create_ns3_program(&apos;sample-simulator&apos;, [&apos;core&apos;])
obj.source = &apos;sample-simulator.cc&apos;
</pre>
<p>The core module&apos;s Python examples are specified using the following function call.  Note that the second argument for the function register_ns3_script() is the list of modules that the Python example depends on:</p>
<pre>
bld.register_ns3_script(&apos;sample-simulator.py&apos;, [&apos;core&apos;])
</pre>

<h3>Step 7 - Specify which of your module&apos;s examples should be run as tests</h3>
<p>The test framework can also be instrumented to run example programs to try to catch regressions in the examples.  However, not all examples are suitable for regression tests.  A file called <strong>examples-to-run.py</strong> that exists in each module&apos;s test directory can control the invocation of the examples when the test framework runs.</p><p>As an example, the examples that are run by <strong>test.py</strong> for the core module are specified in</p>
<pre>
src/core/test/examples-to-run.py
</pre>
<p>using the following two lists of C++ and Python examples:</p>
<pre>
# A list of C++ examples to run in order to ensure that they remain
# buildable and runnable over time.  Each tuple in the list contains
#
#     (example_name, do_run, do_valgrind_run).
#
# See test.py for more information.
cpp_examples = [
    ("main-attribute-value", "True", "True"),
    ("main-callback", "True", "True"),
    ("sample-simulator", "True", "True"),
    ("main-ptr", "True", "True"),
    ("main-random-variable", "True", "True"),
    ("sample-random-variable", "True", "True"),
]

# A list of Python examples to run in order to ensure that they remain
# runnable over time.  Each tuple in the list contains
#
#     (example_name, do_run).
#
# See test.py for more information.
python_examples = [
    ("sample-simulator.py", "True"),
]
</pre>
<p>Each tuple in the C++ list of examples to run contains</p>
<pre>
(example_name, do_run, do_valgrind_run)
</pre>
<p>where example_name is the executable to be run, do_run is a condition under which to run the example, and do_valgrind_run is a condition under which to run the example under valgrind.  This is needed because NSC causes illegal instruction crashes with some tests when they are run under valgrind.</p><p>Note that the two conditions are Python statements that can depend on waf configuration variables.  For example,</p>
<pre>
("tcp-nsc-lfn", "NSC_ENABLED == True", "NSC_ENABLED == False"),
</pre>
<p>Each tuple in the Python list of examples to run contains</p>
<pre>
(example_name, do_run)
</pre>
<p>where example_name is the Python script to be run and do_run is a condition under which to run the example.</p><p>Note that the condition is a Python statement that can depend on waf configuration variables.  For example,</p>
<pre>
("realtime-udp-echo.py", "ENABLE_REAL_TIME == False"),
</pre>
<p>If your new module has examples, then you must specify which of them should be run in your</p>
<pre>
src/new-module/test/examples-to-run.py
</pre>
<p>file by modifying it with your text editor.  These examples are run by test.py.</p>
<h3>Step 8 - Build and test your new module</h3>
<p>You can now build and test your module as normal:</p>
<pre>
./waf configure --enable-examples --enable-tests
./waf build
./test.py
</pre>
<p>and look for your new module&apos;s test suite (and example programs, if enabled) in the test output.</p>
<h3>Enabling Subsets of \fIns-3\fP Modules</h3>
<p>As with most software projects, <em>ns-3</em> is ever growing larger in terms of number of modules, lines of code, and memory footprint.  Users, however, may only use a few of those modules at a time.  For this reason, users may want to explicitly enable only the subset of the possible <em>ns-3</em> modules that they actually need for their research.</p><p>This chapter discusses how to enable only the <em>ns-3</em> modules that you are intersted in using.</p>
<h3>How to enable a subset of \fIns-3\fP&apos;s modules</h3>
<p>If shared libraries are being built, then enabling a module will cause at least one library to be built:</p>
<pre>
libns3-modulename.so
</pre>
<p>If the module has a test library and test libraries are being built, then</p>
<pre>
libns3-modulename-test.so
</pre>
<p>will be built, too.  Other modules that the module depends on and their test libraries will also be built.</p><p>By default, all modules are built in <em>ns-3</em>.  There are two ways to enable a subset of these modules:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>Using waf&apos;s --enable-modules option</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>Using the <em>ns-3</em> configuration file</p>
  </dd>

</dl>

<h3>Enable modules using waf&apos;s --enable-modules option</h3>
<p>To enable only the core module with example and tests, for example, try these commands:</p>
<pre>
./waf clean
./waf configure --enable-examples --enable-tests --enable-modules=core
./waf build
cd build/debug/
ls
</pre>
<p>and the following libraries should be present:</p>
<pre>
bindings  libns3-core.so       ns3      scratch  utils
examples  libns3-core-test.so  samples  src
</pre>
<p>Note the <strong>./waf clean</strong> step is done here only to make it more obvious which module libraries were built.  You don&apos;t have to do <strong>./waf clean</strong> in order to enable subsets of modules.</p><p>Running test.py will cause only those tests that depend on module core to be run:</p>
<pre>
24 of 24 tests passed (24 passed, 0 skipped, 0 failed, 0 crashed, 0 valgrind errors)
</pre>
<p>Repeat the above steps for the "network" module instead of the "core" module, and the following will be built, since network depends on core:</p>
<pre>
bindings  libns3-core.so       libns3-network.so       ns3      scratch  utils
examples  libns3-core-test.so  libns3-network-test.so  samples  src
</pre>
<p>Running test.py will cause those tests that depend on only the core and network modules to be run:</p>
<pre>
31 of 31 tests passed (31 passed, 0 skipped, 0 failed, 0 crashed, 0 valgrind errors)
</pre>

<h3>Enable modules using the \fIns-3\fP configuration file</h3>
<p>A configuration file, .ns3rc, has been added to <em>ns-3</em> that allows users to specify which modules are to be included in the build.</p><p>When enabling a subset of <em>ns-3</em> modules, the precedence rules are as follows:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>the --enable-modules configure string overrides any .ns3rc file</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>the .ns3rc file in the top level <em>ns-3</em> directory is next consulted, if present</p>
  </dd>
  <dt>
    3.
  </dt>
  <dd>
    <p>the system searches for ~/.ns3rc if the above two are unspecified</p><p>If none of the above limits the modules to be built, all modules that waf knows about will be built.</p><p>The maintained version of the .ns3rc file in the <em>ns-3</em> source code repository resides in the <strong>utils</strong> directory.  The reason for this is if it were in the top-level directory of the repository, it would be prone to accidental checkins from maintainers that enable the modules they want to use.  Therefore, users need to manually copy the .ns3rc from the <strong>utils</strong> directory to their preferred place (top level directory or their home directory) to enable persistent modular build configuration.</p><p>Assuming that you are in the top level <em>ns-3</em> directory, you can get a copy of the .ns3rc file that is in the <strong>utils</strong> directory as follows:</p>
<pre>
cp utils/.ns3rc .
</pre>
<p>The .ns3rc file should now be in your top level <em>ns-3</em> directory, and it contains the following:</p>
<pre>
#! /usr/bin/env python

# A list of the modules that will be enabled when ns-3 is run.
# Modules that depend on the listed modules will be enabled also.
#
# All modules can be enabled by choosing &apos;all_modules&apos;.
modules_enabled = [&apos;all_modules&apos;]

# Set this equal to true if you want examples to be run.
examples_enabled = False

# Set this equal to true if you want tests to be run.
tests_enabled = False
</pre>
<p>Use your favorite editor to modify the .ns3rc file to only enable the core module with examples and tests like this:</p>
<pre>
#! /usr/bin/env python

# A list of the modules that will be enabled when ns-3 is run.
# Modules that depend on the listed modules will be enabled also.
#
# All modules can be enabled by choosing &apos;all_modules&apos;.
modules_enabled = [&apos;core&apos;]

# Set this equal to true if you want examples to be run.
examples_enabled = True

# Set this equal to true if you want tests to be run.
tests_enabled = True
</pre>
<p>Only the core module will be enabled now if you try these commands:</p>
<pre>
./waf clean
./waf configure
./waf build
cd build/debug/
ls
</pre>
<p>and the following libraries should be present:</p>
<pre>
bindings  libns3-core.so       ns3      scratch  utils
examples  libns3-core-test.so  samples  src
</pre>
<p>Note the <strong>./waf clean</strong> step is done here only to make it more obvious which module libraries were built.  You don&apos;t have to do <strong>./waf clean</strong> in order to enable subsets of modules.</p><p>Running test.py will cause only those tests that depend on module core to be run:</p>
<pre>
24 of 24 tests passed (24 passed, 0 skipped, 0 failed, 0 crashed, 0 valgrind errors)
</pre>
<p>Repeat the above steps for the "network" module instead of the "core" module, and the following will be built, since network depends on core:</p>
<pre>
bindings  libns3-core.so       libns3-network.so       ns3      scratch  utils
examples  libns3-core-test.so  libns3-network-test.so  samples  src
</pre>
<p>Running test.py will cause those tests that depend on only the core and network modules to be run:</p>
<pre>
31 of 31 tests passed (31 passed, 0 skipped, 0 failed, 0 crashed, 0 valgrind errors)
</pre>

  </dd>

</dl>

<h3>Enabling/disabling \fIns-3\fP Tests and Examples</h3>
<p>The <em>ns-3</em> distribution includes many examples and tests that are used to validate the <em>ns-3</em> system.  Users, however, may not always want these examples and tests to be run for their installation of <em>ns-3</em>.</p><p>This chapter discusses how to build <em>ns-3</em> with or without its examples and tests.</p>
<h3>How to enable/disable examples and tests in \fIns-3\fP</h3>
<p>There are 3 ways to enable/disable examples and tests in <em>ns-3</em>:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>Using build.py when <em>ns-3</em> is built for the first time</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>Using waf once <em>ns-3</em> has been built</p>
  </dd>
  <dt>
    3.
  </dt>
  <dd>
    <p>Using the <em>ns-3</em> configuration file once <em>ns-3</em> has been built</p>
  </dd>

</dl>

<h3>Enable/disable examples and tests using build.py</h3>
<p>You can use build.py to enable/disable examples and tests when <em>ns-3</em> is built for the first time.</p><p>By default, examples and tests are not built in <em>ns-3</em>.</p><p>From the ns-3-allinone directory, you can build <em>ns-3</em> without any examples or tests simply by doing:</p>
<pre>
./build.py
</pre>
<p>Running test.py in the top level <em>ns-3</em> directory now will cause no examples or tests to be run:</p>
<pre>
0 of 0 tests passed (0 passed, 0 skipped, 0 failed, 0 crashed, 0 valgrind errors)
</pre>
<p>If you would like build <em>ns-3</em> with examples and tests, then do the following from the ns-3-allinone directory:</p>
<pre>
./build.py --enable-examples --enable-tests
</pre>
<p>Running test.py in the top level <em>ns-3</em> directory will cause all of the examples and tests to be run:</p>
<pre>
170 of 170 tests passed (170 passed, 0 skipped, 0 failed, 0 crashed, 0 valgrind errors)
</pre>

<h3>Enable/disable examples and tests using waf</h3>
<p>You can use waf to enable/disable examples and tests once <em>ns-3</em> has been built.</p><p>By default, examples and tests are not built in <em>ns-3</em>.</p><p>From the top level <em>ns-3</em> directory, you can build <em>ns-3</em> without any examples or tests simply by doing:</p>
<pre>
./waf configure
./waf build
</pre>
<p>Running test.py now will cause no examples or tests to be run:</p>
<pre>
0 of 0 tests passed (0 passed, 0 skipped, 0 failed, 0 crashed, 0 valgrind errors)
</pre>
<p>If you would like build <em>ns-3</em> with examples and tests, then do the following from the top level <em>ns-3</em> directory:</p>
<pre>
./waf configure --enable-examples --enable-tests
./waf build
</pre>
<p>Running test.py will cause all of the examples and tests to be run:</p>
<pre>
170 of 170 tests passed (170 passed, 0 skipped, 0 failed, 0 crashed, 0 valgrind errors)
</pre>

<h3>Enable/disable examples and tests using the \fIns-3\fP configuration file</h3>
<p>A configuration file, .ns3rc, has been added to <em>ns-3</em> that allows users to specify whether examples and tests should be built or not.  You can use this file to enable/disable examples and tests once <em>ns-3</em> has been built.</p><p>When enabling disabling examples and tests, the precedence rules are as follows:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>the --enable-examples/--disable-examples configure strings override any .ns3rc file</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>the --enable-tests/--disable-tests configure strings override any .ns3rc file</p>
  </dd>
  <dt>
    3.
  </dt>
  <dd>
    <p>the .ns3rc file in the top level <em>ns-3</em> directory is next consulted, if present</p>
  </dd>
  <dt>
    4.
  </dt>
  <dd>
    <p>the system searches for ~/.ns3rc if the .ns3rc file was not found in the previous step</p><p>If none of the above exists, then examples and tests will not be built.</p><p>The maintained version of the .ns3rc file in the <em>ns-3</em> source code repository resides in the <strong>utils</strong> directory.  The reason for this is if it were in the top-level directory of the repository, it would be prone to accidental checkins from maintainers that enable the modules they want to use.  Therefore, users need to manually copy the .ns3rc from the <strong>utils</strong> directory to their preferred place (top level directory or their home directory) to enable persistent enabling of examples and tests.</p><p>Assuming that you are in the top level <em>ns-3</em> directory, you can get a copy of the .ns3rc file that is in the <strong>utils</strong> directory as follows:</p>
<pre>
cp utils/.ns3rc .
</pre>
<p>The .ns3rc file should now be in your top level <em>ns-3</em> directory, and it contains the following:</p>
<pre>
#! /usr/bin/env python

# A list of the modules that will be enabled when ns-3 is run.
# Modules that depend on the listed modules will be enabled also.
#
# All modules can be enabled by choosing &apos;all_modules&apos;.
modules_enabled = [&apos;all_modules&apos;]

# Set this equal to true if you want examples to be run.
examples_enabled = False

# Set this equal to true if you want tests to be run.
tests_enabled = False
</pre>
<p>From the top level <em>ns-3</em> directory, you can build <em>ns-3</em> without any examples or tests simply by doing:</p>
<pre>
./waf configure
./waf build
</pre>
<p>Running test.py now will cause no examples or tests to be run:</p>
<pre>
0 of 0 tests passed (0 passed, 0 skipped, 0 failed, 0 crashed, 0 valgrind errors)
</pre>
<p>If you would like build <em>ns-3</em> with examples and tests, use your favorite editor to change the values in the .ns3rc file for examples_enabled and tests_enabled file to be True:</p>
<pre>
#! /usr/bin/env python

# A list of the modules that will be enabled when ns-3 is run.
# Modules that depend on the listed modules will be enabled also.
#
# All modules can be enabled by choosing &apos;all_modules&apos;.
modules_enabled = [&apos;all_modules&apos;]

# Set this equal to true if you want examples to be run.
examples_enabled = True

# Set this equal to true if you want tests to be run.
tests_enabled = True
</pre>
<p>From the top level <em>ns-3</em> directory, you can build <em>ns-3</em> with examples and tests simply by doing:</p>
<pre>
./waf configure
./waf build
</pre>
<p>Running test.py will cause all of the examples and tests to be run:</p>
<pre>
170 of 170 tests passed (170 passed, 0 skipped, 0 failed, 0 crashed, 0 valgrind errors)
</pre>

  </dd>

</dl>

<h3>Troubleshooting</h3>
<p>This chapter posts some information about possibly common errors in building or running <em>ns-3</em> programs.</p><p>Please note that the wiki (<em>http://www.nsnam.org/wiki/index.php/Troubleshooting</em>) may have contributed items.</p>
<h3>Build errors</h3>

<h3>Run-time errors</h3>
<p>Sometimes, errors can occur with a program after a successful build. These are run-time errors, and can commonly occur when memory is corrupted or pointer values are unexpectedly null.</p><p>Here is an example of what might occur::</p>
<pre>
ns-old:~/ns-3-nsc$ ./waf --run tcp-point-to-point
Entering directory \(ga/home/tomh/ns-3-nsc/build&apos;
Compilation finished successfully
Command [&apos;/home/tomh/ns-3-nsc/build/debug/examples/tcp-point-to-point&apos;] exited with code -11
</pre>
<p>The error message says that the program terminated unsuccessfully, but it is not clear from this information what might be wrong. To examine more closely, try running it under the <em>gdb debugger</em>::</p>
<pre>
ns-old:~/ns-3-nsc$ ./waf --run tcp-point-to-point --command-template="gdb %s"
Entering directory \(ga/home/tomh/ns-3-nsc/build&apos;
Compilation finished successfully
GNU gdb Red Hat Linux (6.3.0.0-1.134.fc5rh)
Copyright 2004 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for details.
This GDB was configured as "i386-redhat-linux-gnu"...Using host libthread_db
library "/lib/libthread_db.so.1".

(gdb) run
Starting program: /home/tomh/ns-3-nsc/build/debug/examples/tcp-point-to-point
Reading symbols from shared object read from target memory...done.
Loaded system supplied DSO at 0xf5c000

Program received signal SIGSEGV, Segmentation fault.
0x0804aa12 in main (argc=1, argv=0xbfdfefa4)
    at ../examples/tcp-point-to-point.cc:136
136       Ptr&lt;Socket&gt; localSocket = socketFactory-&gt;CreateSocket ();
(gdb) p localSocket
$1 = {m_ptr = 0x3c5d65}
(gdb) p socketFactory
$2 = {m_ptr = 0x0}
(gdb) quit
The program is running.  Exit anyway? (y or n) y
</pre>
<p>Note first the way the program was invoked-- pass the command to run as an argument to the command template "gdb %s".</p><p>This tells us that there was an attempt to dereference a null pointer socketFactory.</p><p>Let&apos;s look around line 136 of tcp-point-to-point, as gdb suggests::</p>
<pre>
Ptr&lt;SocketFactory&gt; socketFactory = n2-&gt;GetObject&lt;SocketFactory&gt; (Tcp::iid);
Ptr&lt;Socket&gt; localSocket = socketFactory-&gt;CreateSocket ();
localSocket-&gt;Bind ();
</pre>
<p>The culprit here is that the return value of GetObject is not being checked and may be null.</p><p>Sometimes you may need to use the <em>valgrind memory checker</em> for more subtle errors. Again, you invoke the use of valgrind similarly::</p>
<pre>
ns-old:~/ns-3-nsc$ ./waf --run tcp-point-to-point --command-template="valgrind %s"
</pre>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>ns-3 project</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>2010, ns-3 project</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="ns.1.html"><span aria-hidden="true">&larr;</span> ns.1: Network simulator (version 2)</a></li>
   <li class="next"><a href="ns-3-tutorial.1.html">ns-3-tutorial.1: Ns-3 tutorial  this is the ns-3 tutorial. primary documentation for the ns-3 project is available in five forms: ns-3 doxygen: documentation of the public apis of the simulator tutorial (this document), manual, and model library for the latest release and development tree ns-3 wiki  this document is written in restructuredtext for sphinx and is maintained in the doc/tutorial directory of ns-3s source code. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

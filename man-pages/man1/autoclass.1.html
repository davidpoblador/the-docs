<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>autoclass: Automatically discover classes in data</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Automatically discover classes in data">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="autoclass (1) manual">
  <meta name="twitter:description" content="Automatically discover classes in data">
  <meta name="twitter:image" content="https://www.carta.tech/images/autoclass-autoclass-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/autoclass.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="autoclass (1) manual" />
  <meta property="og:description" content="Automatically discover classes in data" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/autoclass-autoclass-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">autoclass<small> (1)</small></h1>
        <p class="lead">Automatically discover classes in data</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/autoclass.1.html">
      <span itemprop="name">autoclass: Automatically discover classes in data</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/autoclass/">
      <span itemprop="name">autoclass</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/autoclass.1.html">
      <span itemprop="name">autoclass: Automatically discover classes in data</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>autoclass -search </strong> <em>data_file header_file model_file s_param_file</em></p><p><strong>autoclass -report </strong> <em>results_file search_file r_params_file</em></p><p><strong>autoclass -predict </strong> <em>results_file search_file results_file</em></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><strong>AutoClass</strong> solves the problem of automatic discovery of classes in data (sometimes called clustering, or unsupervised learning), as distinct from the generation of class descriptions from labeled examples (called supervised learning).  It aims to discover the "natural" classes in the data.  <strong>AutoClass</strong> is applicable to observations of things that can be described by a set of attributes, without referring to other things.  The data values corresponding to each attribute are limited to be either numbers or the elements of a fixed set of symbols.  With numeric data, a measurement error must be provided.</p><p><strong>AutoClass</strong> is looking for the best classification(s) of the data it can find. A classification is composed of:</p>
<dl class='dl-vertical'>
  <dt>
    1)
  </dt>
  <dd>
    <p>A set of classes, each of which is described by a set of class parameters, which specify how the class is distributed along the various attributes.  For example, "height normally distributed with mean 4.67 ft and standard deviation .32 ft",</p>
  </dd>
  <dt>
    2)
  </dt>
  <dd>
    <p>A set of class weights, describing what percentage of cases are likely to be in each class.</p>
  </dd>
  <dt>
    3)
  </dt>
  <dd>
    <p>A probabilistic assignment of cases in the data to these classes. I.e. for each case, the relative probability that it is a member of each class.</p>
  </dd>

</dl>
<p>As a strictly Bayesian system (accept no substitutes!), the quality measure <strong>AutoClass</strong> uses is the total probability that, had you known nothing about your data or its domain, you would have found this set of data generated by this underlying model.  This includes the prior probability that the "world" would have chosen this number of classes, this set of relative class weights, and this set of parameters for each class, and the likelihood that such a set of classes would have generated this set of values for the attributes in the data cases.</p><p>These probabilities are typically very small, in the range of e^-30000, and so are usually expressed in exponential notation.</p><p>When run with the <strong>-search</strong> command, <strong>AutoClass</strong> searches for a classification.  The required arguments are the paths to the four input files, which supply the data, the data format, the desired classification model, and the search parameters, respectively.</p><p>By default, <strong>AutoClass</strong> writes intermediate results in a binary file. With the <strong>-report</strong> command, <strong>AutoClass</strong> generates an ASCII report.  The arguments are the full path names of the .results, .search, and .r-params files.</p><p>When run with the <strong>-predict</strong> command, <strong>AutoClass</strong> predicts the class membership of a "test" data set based on classes found in a "training" data set (see "PREDICTIONS" below).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUT FILES</h2>
        <div class="sectioncontent">
<p>An AutoClass data set resides in two files.  There is a header file (file type "hd2") that describes the specific data format and attribute definitions.  The actual data values are in a data file (file type "db2"). We use two files to allow editing of data descriptions without having to deal with the entire data set.  This makes it easy to experiment with different descriptions of the database without having to reproduce the data set.  Internally, an AutoClass database structure is identified by its header and data files, and the number of data loaded.</p><p>For more detailed information on the formats of these files, see <em>/usr/share/doc/autoclass/preparation-c.text</em>.</p><h3>DATA FILE</h3>
<p>The data file contains a sequence of data objects (datum or case) terminated by the end of the file. The number of values for each data object must be equal to the number of attributes defined in the header file.  Data objects must be groups of tokens delimited by "new-line". Attributes are typed as REAL, DISCRETE, or DUMMY.  Real attribute values are numbers, either integer or floating point.  Discrete attribute values can be strings, symbols, or integers.  A dummy attribute value can be any of these types.  Dummys are read in but otherwise ignored -- they will be set to zeros in the the internal database.  Thus the actual values will not be available for use in report output.  To have these attribute values available, use either type REAL or type DISCRETE, and define their model type as IGNORE in the .model file.  Missing values for any attribute type may be represented by either "?", or other token specified in the header file.  All are translated to a special unique value after being read, so this symbol is effectively reserved for unknown/missing values.</p><p>For example:</p>
<pre>
      white       38.991306 0.54248405  2 2 1
      red         25.254923 0.5010235   9 2 1
      yellow      32.407973 ?           8 2 1
      all_white   28.953982 0.5267696   0 1 1
</pre>

<h3>HEADER FILE</h3>
<p>The header file specifies the data file format, and the definitions of the data attributes.  The header file functional specifications consists of two parts -- the data set format definition specifications, and the attribute descriptors. ";" in column 1 identifies a comment.</p><p>A header file follows this general format:</p>
<pre>
    ;; num_db2_format_defs value (number of format def lines
    ;; that follow), range of n is 1 -&gt; 5
    num_db2_format_defs n
    ;; number_of_attributes token and value required
    number_of_attributes &lt;as required&gt;
    ;; following are optional - default values are specified
    separator_char  ' '
    comment_char    ';'
    unknown_token   '?'
    separator_char  ','

    ;; attribute descriptors
    ;; &lt;zero-based att#&gt;  &lt;att_type&gt;  &lt;att_sub_type&gt;  &lt;att_description&gt;
    ;; &lt;att_param_pairs&gt;

</pre>
<p>Each attribute descriptor is a line of:</p>
<pre>
      Attribute index (zero based, beginning in column 1)
      Attribute type.  See below.
      Attribute subtype.  See below
      Attribute description: symbol (no embedded blanks) or
            string; &lt;= 40 characters
      Specific property and value pairs.
            Currently available combinations:

         type           subtype         property type(s)
         ----           --------        ---------------
         dummy          none/nil        --
         discrete       nominal         range
         real           location        error
         real           scalar          zero_point rel_error

</pre>
<p>The ERROR property should represent your best estimate of the average error expected in the measurement and recording of that real attribute.  Lacking better information, the error can be taken as 1/2 the minimum possible difference between measured values.  It can be argued that real values are often truncated, so that smaller errors may be justified, particularly for generated data.  But AutoClass only sees the recorded values.  So it needs the error in the recorded values, rather than the actual measurement error.  Setting this error much smaller than the minimum expressible difference implies the possibility of values that cannot be expressed in the data.  Worse, it implies that two identical values must represent measurements that were much closer than they might actually have been.  This leads to over-fitting of the classification.</p><p>The REL_ERROR property is used for SCALAR reals when the error is proportional to the measured value.  The ERROR property is not supported.</p><p>AutoClass uses the error as a lower bound on the width of the normal distribution.  So small error estimates tend to give narrower peaks and to increase both the number of classes and the classification probability.  Broad error estimates tend to limit the number of classes.</p><p>The scalar ZERO_POINT property is the smallest value that the measurement process could have produced.  This is often 0.0, or less by some error range.  Similarly, the bounded real's min and max properties are exclusive bounds on the attributes generating process. For a calculated percentage these would be 0-e and 100+e, where e is an error value.  The discrete attribute's range is the number of possible values the attribute can take on.  This range must include unknown as a value when such values occur.</p><p>Header File Example:</p>
<pre>
!#; AutoClass C header file -- extension .hd2
!#; the following chars in column 1 make the line a comment:
!#; '!', '#', ';', ' ', and '&#92;n' (empty line)

;#! num_db2_format_defs &lt;num of def lines -- min 1, max 4&gt;
num_db2_format_defs 2
;; required
number_of_attributes 7
;; optional - default values are specified
;; separator_char  ' '
;; comment_char    ';'
;; unknown_token   '?'
separator_char     ','

;; &lt;zero-based att#&gt;  &lt;att_type&gt;  &lt;att_sub_type&gt;  &lt;att_description&gt;
&lt;att_param_pairs&gt;
0 dummy nil       "True class, range = 1 - 3"
1 real location "X location, m. in range of 25.0 - 40.0" error .25
2 real location "Y location, m. in range of 0.5 - 0.7" error .05
3 real scalar   "Weight, kg. in range of 5.0 - 10.0" zero_point 0.0
rel_error .001
4 discrete nominal  "Truth value, range = 1 - 2" range 2
5 discrete nominal  "Color of foobar, 10 values" range 10
6 discrete nominal  Spectral_color_group range 6
</pre>

<h3>MODEL FILE</h3>
<p>A classification of a data set is made with respect to a model which specifies the form of the probability distribution function for classes in that data set.  Normally the model structure is defined in a model file (file type "model"), containing one or more models.  Internally, a model is defined relative to a particular database.  Thus it is identified by the corresponding database, the model's model file and its sequential position in the file.</p><p>Each model is specified by one or more model group definition lines. Each model group line associates attribute indices with a model term type.</p><p>Here is an example model file:</p>
<pre>
# AutoClass C model file -- extension .model
model_index 0 7
ignore 0
single_normal_cn 3
single_normal_cn 17 18 21
multi_normal_cn 1 2
multi_normal_cn 8 9 10
multi_normal_cn 11 12 13
single_multinomial default
</pre>
<p>Here, the first line is a comment.  The following characters in column 1 make the line a comment: `!', `#', ` ', `;', and `&#92;n' (empty line).</p><p>The tokens "model_index <em>n m</em>" must appear on the first non-comment line, and precede the model term definition lines. <em>n</em> is the zero-based model index, typically 0 where there is only one model -- the majority of search situations.  <em>m</em> is the number of model term definition lines that follow.</p><p>The last seven lines are model group lines.  Each model group line consists of:</p><p>A model term type (one of <strong>single_multinomial</strong>, <strong>single_normal_cm</strong>, <strong>single_normal_cn</strong>, <strong>multi_normal_cn</strong>, or <strong>ignore</strong>). A list of attribute indices (the attribute set list), or the symbol <strong>default</strong>.  Attribute indices are zero-based.  Single model terms may have one or more attribute indices on each line, while multi model terms require two or more attribute indices per line.  An attribute index must not appear more than once in a model list.</p><p>Notes:</p>
<dl class='dl-vertical'>
  <dt>
    1)
  </dt>
  <dd>
    <p>At least one model definition is required (model_index token).</p>
  </dd>
  <dt>
    2)
  </dt>
  <dd>
    <p>There may be multiple entries in a model for any model term type.</p>
  </dd>
  <dt>
    3)
  </dt>
  <dd>
    <p>Model term types currently consist of:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>single_multinomial</strong></p>
  </dt>
  <dd>
    <p>models discrete attributes as multinomials, with missing values.</p>
  </dd>
  <dt>
    <p><strong>single_normal_cn</strong></p>
  </dt>
  <dd>
    <p>models real valued attributes as normals; no missing values.</p>
  </dd>
  <dt>
    <p><strong>single_normal_cm</strong></p>
  </dt>
  <dd>
    <p>models real valued attributes with missing values.</p>
  </dd>
  <dt>
    <p><strong>multi_normal_cn</strong></p>
  </dt>
  <dd>
    <p>is a covariant normal model without missing values.</p>
  </dd>
  <dt>
    <p><strong>ignore</strong></p>
  </dt>
  <dd>
    <p>allows the model to ignore one or more attributes. <strong>ignore</strong> is not a valid default model term type.</p>
  </dd>

</dl>
<p>See the documentation in models-c.text for further information about specific model terms.</p>
  </dd>
  <dt>
    4)
  </dt>
  <dd>
    <p><strong>Single_normal_cn</strong>, <strong>single_normal_cm</strong>, and <strong>multi_normal_cn</strong> modeled data, whose subtype is <strong>scalar</strong> (value distribution is away from 0.0, and is thus not a "normal" distribution) will be log transformed and modeled with the log-normal model.  For data whose subtype is <strong>location</strong> (value distribution is around 0.0), no transform is done, and the normal model is used.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SEARCHING</h2>
        <div class="sectioncontent">
<p>AutoClass, when invoked in the "search" mode will check the validity of the set of data, header, model, and search parameter files.  Errors will stop the search from starting, and warnings will ask the user whether to continue.  A history of the error and warning messages is saved, by default, in the log file.</p><p>Once you have succeeded in describing your data with a header file and model file that passes the AUTOCLASS -SEARCH &lt;...&gt; input checks, you will have entered the search domain where <strong>AutoClass</strong> classifies your data.  (At last!)</p><p>The main function to use in finding a good classification of your data is AUTOCLASS -SEARCH, and using it will take most of the computation time.  Searches are invoked with:</p>
<pre>
autoclass -search &lt;.db2 file path&gt; &lt;.hd2 file path&gt;
	&lt;.model file path&gt; &lt;.s-params file path&gt;

</pre>
<p>All files must be specified as fully qualified relative or absolute pathnames.  File name extensions (file types) for all files are forced to canonical values required by the AutoClass program:</p>
<pre>
        data file   ("ascii")   db2
        data file   ("binary")  db2-bin
        header file             hd2
        model file              model
        search params file      s-params
</pre>
<p>The sample-run (<em>/usr/share/doc/autoclass/examples/</em>) that comes with <strong>AutoClass</strong> shows some sample searches, and browsing these is probably the fastest way to get familiar with how to do searches.  The test data sets located under <em>/usr/share/doc/autoclass/examples/</em> will show you some other header (.hd2), model (.model), and search params (.s-params) file setups.  The remainder of this section describes how to do searches in somewhat more detail.</p><p>The <strong>bold faced</strong> tokens below are generally search params file parameters.  For more information on the s-params file, see <strong>SEARCH</strong> PARAMETERS below, or <em>/usr/share/doc/autoclass/search-c.text.gz</em>.</p><h3>WHAT RESULTS ARE</h3>
<p><strong>AutoClass</strong> is looking for the best classification(s) of the data it can find.  A classification is composed of:</p>
<dl class='dl-vertical'>
  <dt>
    1)
  </dt>
  <dd>
    <p>a set of classes, each of which is described by a set of class parameters, which specify how the class is distributed along the various attributes.  For example, "height normally distributed with mean 4.67 ft and standard deviation .32 ft",</p>
  </dd>
  <dt>
    2)
  </dt>
  <dd>
    <p>a set of class weights, describing what percentage of cases are likely to be in each class.</p>
  </dd>
  <dt>
    3)
  </dt>
  <dd>
    <p>a probabilistic assignment of cases in the data to these classes. I.e. for each case, the relative probability that it is a member of each class.</p>
  </dd>

</dl>
<p>As a strictly Bayesian system (accept no substitutes!), the quality measure <strong>AutoClass</strong> uses is the total probability that, had you known nothing about your data or its domain, you would have found this set of data generated by this underlying model.  This includes the prior probability that the "world" would have chosen this number of classes, this set of relative class weights, and this set of parameters for each class, and the likelihood that such a set of classes would have generated this set of values for the attributes in the data cases.</p><p>These probabilities are typically very small, in the range of e^-30000, and so are usually expressed in exponential notation.</p>
<h3>WHAT RESULTS MEAN</h3>
<p>It is important to remember that all of these probabilities are GIVEN that the real model is in the model family that <strong>AutoClass</strong> has restricted its attention to.  If <strong>AutoClass</strong> is looking for Gaussian classes and the real classes are Poisson, then the fact that <strong>AutoClass</strong> found 5 Gaussian classes may not say much about how many Poisson classes there really are.</p><p>The relative probability between different classifications found can be very large, like e^1000, so the very best classification found is usually overwhelmingly more probable than the rest (and overwhelmingly less probable than any better classifications as yet undiscovered). If <strong>AutoClass</strong> should manage to find two classifications that are within about exp(5-10) of each other (i.e. within 100 to 10,000 times more probable) then you should consider them to be about equally probable, as our computation is usually not more accurate than this (and sometimes much less).</p>
<h3>HOW IT WORKS</h3>
<p><strong>AutoClass</strong> repeatedly creates a random classification and then tries to massage this into a high probability classification though local changes, until it converges to some "local maximum".  It then remembers what it found and starts over again, continuing until you tell it to stop.  Each effort is called a "try", and the computed probability is intended to cover the whole volume in parameter space around this maximum, rather than just the peak.</p><p>The standard approach to massaging is to</p>
<dl class='dl-vertical'>
  <dt>
    1)
  </dt>
  <dd>
    <p>Compute the probabilistic class memberships of cases using the class parameters and the implied relative likelihoods.</p>
  </dd>
  <dt>
    2)
  </dt>
  <dd>
    <p>Using the new class members, compute class statistics (like mean) and revise the class parameters.</p>
  </dd>

</dl>
<p>and repeat till they stop changing.  There are three available convergence algorithms: "converge_search_3" (the default), "converge_search_4" and "converge".  Their specification is controlled by search params file parameter <strong>try_fn_type</strong>.</p>
<h3>WHEN TO STOP</h3>
<p>You can tell AUTOCLASS -SEARCH to stop by: 1) giving a <strong>max_duration</strong> (in seconds) argument at the beginning; 2) giving a <strong>max_n_tries</strong> (an integer) argument at the beginning; or 3) by typing a "q" and &lt;return&gt; after you have seen enough tries.  The <strong>max_duration</strong> and <strong>max_n_tries</strong> arguments are useful if you desire to run AUTOCLASS -SEARCH in batch mode.  If you are restarting AUTOCLASS -SEARCH from a previous search, the value of <strong>max_n_tries</strong> you provide, for instance 3, will tell the program to compute 3 more tries in addition to however many it has already done.  The same incremental behavior is exhibited by <strong>max_duration</strong>.</p><p>Deciding when to stop is a judgment call and it's up to you.  Since the search includes a random component, there's always the chance that if you let it keep going it will find something better.  So you need to trade off how much better it might be with how long it might take to find it.  The search status reports that are printed when a new best classification is found are intended to provide you information to help you make this tradeoff.</p><p>One clear sign that you should probably stop is if most of the classifications found are duplicates of previous ones (flagged by "dup" as they are found).  This should only happen for very small sets of data or when fixing a very small number of classes, like two.</p><p>Our experience is that for moderately large to extremely large data sets (~200 to ~10,000 datum), it is necessary to run <strong>AutoClass</strong> for at least 50 trials.</p>
<h3>WHAT GETS RETURNED</h3>
<p>Just before returning, AUTOCLASS -SEARCH will give short descriptions of the best classifications found.  How many will be described can be controlled with <strong>n_final_summary</strong>.</p><p>By default AUTOCLASS -SEARCH will write out a number of files, both at the end and periodically during the search (in case your system crashes before it finishes).  These files will all have the same name (taken from the search params pathname [&lt;name&gt;.s-params]), and differ only in their file extensions.  If your search runs are very long and there is a possibility that your machine may crash, you can have intermediate "results" files written out.  These can be used to restart your search run with minimum loss of search effort.  See the documentation file <em>/usr/share/doc/autoclass/checkpoint-c.text</em>.</p><p>A ".log" file will hold a listing of most of what was printed to the screen during the run, unless you set <strong>log_file_p</strong> to false to say you want no such foolishness.  Unless <strong>results_file_p</strong> is false, a binary ".results-bin" file (the default) or an ASCII ".results" text file, will hold the best classifications that were returned, and unless <strong>search_file_p</strong> is false, a ".search" file will hold the record of the search tries. <strong>save_compact_p</strong> controls whether the "results" files are saved as binary or ASCII text.</p><p>If the C global variable "G_safe_file_writing_p" is defined as TRUE in "autoclass-c/prog/globals.c", the names of "results" files (those that contain the saved classifications) are modified internally to account for redundant file writing.  If the search params file name is "my_saved_clsfs" you will see the following "results" file names (ignoring directories and pathnames for this example)</p>
<pre>
  <strong>save_compact_p</strong> = true --
  "my_saved_clsfs.results-bin"	- completely written file
  "my_saved_clsfs.results-tmp-bin" - partially written file, renamed
				  when complete

  <strong>save_compact_p</strong> = false --
  "my_saved_clsfs.results"	- completely written file
  "my_saved_clsfs.results-tmp"  - partially written file, renamed
				  when complete
</pre>
<p>If check pointing is being done, these additional names will appear</p>
<pre>
  <strong>save_compact_p</strong> = true --
  "my_saved_clsfs.chkpt-bin"	- completely written checkpoint file
  "my_saved_clsfs.chkpt-tmp-bin" - partially written checkpoint file,
				     renamed when complete
  <strong>save_compact_p</strong> = false --
  "my_saved_clsfs.chkpt"	- completely written checkpoint file
  "my_saved_clsfs.chkpt-tmp"    - partially written checkpoint file,
				     renamed when complete
</pre>

<h3>HOW TO GET STARTED</h3>
<p>The way to invoke AUTOCLASS -SEARCH is:</p>
<pre>
autoclass -search &lt;.db2 file path&gt; &lt;.hd2 file path&gt;
	&lt;.model file path&gt; &lt;.s-params file path&gt;

</pre>
<p>To restart a previous search, specify that <strong>force_new_search_p</strong> has the value false in the search params file, since its default is true.  Specifying false tells AUTOCLASS -SEARCH to try to find a previous compatible search (&lt;...&gt;.results[-bin] & &lt;...&gt;.search) to continue from, and will restart using it if found.  To force a new search instead of restarting an old one, give the parameter <strong>force_new_search_p</strong> the value of true, or use the default.  If there is an existing search (&lt;...&gt;.results[-bin] & &lt;...&gt;.search), the user will be asked to confirm continuation since continuation will discard the existing search.</p><p>If a previous search is continued, the message "RESTARTING SEARCH" will be given instead of the usual "BEGINNING SEARCH".  It is generally better to continue a previous search than to start a new one, unless you are trying a significantly different search method, in which case statistics from the previous search may mislead the current one.</p>
<h3>STATUS REPORTS</h3>
<p>A running commentary on the search will be printed to the screen and to the log file (unless <strong>log_file_p</strong> is false).  Note that the ".log" file will contain a listing of all default search params values, and the values of all params that are overridden.</p><p>After each try a very short report (only a few characters long) is given.  After each new best classification, a longer report is given, but no more often than <strong>min_report_period</strong> (default is 30 seconds).</p>
<h3>SEARCH VARIATIONS</h3>
<p>AUTOCLASS -SEARCH by default uses a certain standard search method or "try function" (<strong>try_fn_type</strong> = "converge_search_3").  Two others are also available: "converge_search_4" and "converge").  They are provided in case your problem is one that may happen to benefit from them.  In general the default method will result in finding better classifications at the expense of a longer search time.  The default was chosen so as to be robust, giving even performance across many problems.  The alternatives to the default may do better on some problems, but may do substantially worse on others.</p><p>"converge_search_3" uses an absolute stopping criterion (<strong>rel_delta_range</strong>, default value of 0.0025) which tests the variation of each class of the delta of the log approximate-marginal-likelihood of the class statistics with-respect-to the class hypothesis (class-&gt;log_a_w_s_h_j) divided by the class weight (class-&gt;w_j) between successive convergence cycles.  Increasing this value loosens the convergence and reduces the number of cycles.  Decreasing this value tightens the convergence and increases the number of cycles. <strong>n_average</strong> (default value of 3) specifies how many successive cycles must meet the stopping criterion before the trial terminates.</p><p>"converge_search_4" uses an absolute stopping criterion (<strong>cs4_delta_range</strong>, default value of 0.0025) which tests the variation of each class of the slope for each class of log approximate-marginal-likelihood of the class statistics with-respect-to the class hypothesis (class-&gt;log_a_w_s_h_j) divided by the class weight (class-&gt;w_j) over <strong>sigma_beta_n_values</strong> (default value 6) convergence cycles.  Increasing the value of <strong>cs4_delta_range</strong> loosens the convergence and reduces the number of cycles.  Decreasing this value tightens the convergence and increases the number of cycles.  Computationally, this try function is more expensive than "converge_search_3", but may prove useful if the computational "noise" is significant compared to the variations in the computed values.  Key calculations are done in double precision floating point, and for the largest data base we have tested so far ( 5,420 cases of 93 attributes), computational noise has not been a problem, although the value of <strong>max_cycles</strong> needed to be increased to 400.</p><p>"converge" uses one of two absolute stopping criterion which test the variation of the classification (clsf) log_marginal (clsf-&gt;log_a_x_h) delta between successive convergence cycles.  The largest of <strong>halt_range</strong> (default value 0.5) and <strong>halt_factor</strong> * <strong>current_clsf_log_marginal</strong>) is used (default value of <strong>halt_factor</strong> is 0.0001).  Increasing these values loosens the convergence and reduces the number of cycles.  Decreasing these values tightens the convergence and increases the number of cycles. <strong>n_average</strong> (default value of 3) specifies how many cycles must meet the stopping criteria before the trial terminates.  This is a very approximate stopping criterion, but will give you some feel for the kind of classifications to expect.  It would be useful for "exploratory" searches of a data base.</p><p>The purpose of <strong>reconverge_type</strong> = "chkpt" is to complete an interrupted classification by continuing from its last checkpoint. The purpose of <strong>reconverge_type</strong> = "results" is to attempt further refinement of the best completed classification using a different value of <strong>try_fn_type</strong> ("converge_search_3", "converge_search_4", "converge").  If <strong>max_n_tries</strong> is greater than 1, then in each case, after the reconvergence has completed, <strong>AutoClass</strong> will perform further search trials based on the parameter values in the &lt;...&gt;.s-params file.</p><p>With the use of <strong>reconverge_type</strong> ( default value ""), you may apply more than one try function to a classification.  Say you generate several exploratory trials using <strong>try_fn_type</strong> = "converge", and quit the search saving .search and .results[-bin] files.  Then you can begin another search with <strong>try_fn_type</strong> = "converge_search_3", <strong>reconverge_type</strong> = "results", and <strong>max_n_tries</strong> = 1.  This will result in the further convergence of the best classification generated with <strong>try_fn_type</strong> = "converge", with <strong>try_fn_type</strong> = "converge_search_3".  When <strong>AutoClass</strong> completes this search try, you will have an additional refined classification.</p><p>A good way to verify that any of the alternate <strong>try_fun_type</strong> are generating a well converged classification is to run <strong>AutoClass</strong> in prediction mode on the same data used for generating the classification.  Then generate and compare the corresponding case or class cross reference files for the original classification and the prediction.  Small differences between these files are to be expected, while large differences indicate incomplete convergence.  Differences between such file pairs should, on average and modulo class deletions, decrease monotonically with further convergence.</p><p>The standard way to create a random classification to begin a try is with the default value of "random" for <strong>start_fn_type</strong>.  At this point there are no alternatives.  Specifying "block" for <strong>start_fn_type</strong> produces repeatable non-random searches.  That is how the &lt;..&gt;.s-params files in the autoclass-c/data/.. sub-directories are specified.  This is how development testing is done.</p><p><strong>max_cycles</strong> controls the maximum number of convergence cycles that will be performed in any one trial by the convergence functions.  Its default value is 200.  The screen output shows a period (".") for each cycle completed. If your search trials run for 200 cycles, then either your data base is very complex (increase the value), or the <strong>try_fn_type</strong> is not adequate for situation (try another of the available ones, and use <strong>converge_print_p</strong> to get more information on what is going on).</p><p>Specifying <strong>converge_print_p</strong> to be true will generate a brief print-out for each cycle which will provide information so that you can modify the default values of <strong>rel_delta_range</strong> & <strong>n_average</strong> for "converge_search_3"; <strong>cs4_delta_range</strong> & <strong>sigma_beta_n_values</strong> for "converge_search_4"; and <strong>halt_range</strong>, <strong>halt_factor</strong>, and <strong>n_average</strong> for "converge".  Their default values are given in the &lt;..&gt;.s-params files in the autoclass-c/data/..  sub-directories.</p>
<h3>HOW MANY CLASSES?</h3>
<p>Each new try begins with a certain number of classes and may end up with a smaller number, as some classes may drop out of the convergence. In general, you want to begin the try with some number of classes that previous tries have indicated look promising, and you want to be sure you are fishing around elsewhere in case you missed something before.</p><p><strong>n_classes_fn_type</strong> = "random_ln_normal" is the default way to make this choice.  It fits a log normal to the number of classes (usually called "j" for short) of the 10 best classifications found so far, and randomly selects from that.  There is currently no alternative.</p><p>To start the game off, the default is to go down <strong>start_j_list</strong> for the first few tries, and then switch to <strong>n_classes_fn_type</strong>. If you believe that the probable number of classes in your data base is say 75, then instead of using the default value of <strong>start_j_list</strong> (2, 3, 5, 7, 10, 15, 25), specify something like 50, 60, 70, 80, 90, 100.</p><p>If one wants to always look for, say, three classes, one can use <strong>fixed_j</strong> and override the above.  Search status reports will describe what the current method for choosing j is.</p>
<h3>DO I HAVE ENOUGH MEMORY AND DISK SPACE?</h3>
<p>Internally, the storage requirements in the current system are of order n_classes_per_clsf * (n_data + n_stored_clsfs * n_attributes * n_attribute_values).  This depends on the number of cases, the number of attributes, the values per attribute (use 2 if a real value), and the number of classifications stored away for comparison to see if others are duplicates -- controlled by <strong>max_n_store</strong> (default value = 10).  The search process does not itself consume significant memory, but storage of the results may do so.</p><p><strong>AutoClass C</strong> is configured to handle a maximum of 999 attributes. If you attempt to run with more than that you will get array bound violations.  In that case, change these configuration parameters in prog/autoclass.h and recompile <strong>AutoClass C</strong>:</p>
<pre>
#define ALL_ATTRIBUTES                  999
#define VERY_LONG_STRING_LENGTH         20000
#define VERY_LONG_TOKEN_LENGTH          500

</pre>
<p>For example, these values will handle several thousand attributes:</p>
<pre>
#define ALL_ATTRIBUTES                  9999
#define VERY_LONG_STRING_LENGTH         50000
#define VERY_LONG_TOKEN_LENGTH          50000

</pre>
<p>Disk space taken up by the "log" file will of course depend on the duration of the search.  <strong>n_save</strong> (default value = 2) determines how many best classifications are saved into the ".results[-bin]" file. <strong>save_compact_p</strong> controls whether the "results" and "checkpoint" files are saved as binary.  Binary files are faster and more compact, but are not portable.  The default value of <strong>save_compact_p</strong> is true, which causes binary files to be written.</p><p>If the time taken to save the "results" files is a problem, consider increasing <strong>min_save_period</strong> (default value = 1800 seconds or 30 minutes).  Files are saved to disk this often if there is anything different to report.</p>
<h3>JUST HOW SLOW IS IT?</h3>
<p>Compute time is of order n_data * n_attributes * n_classes * n_tries * converge_cycles_per_try. The major uncertainties in this are the number of basic back and forth cycles till convergence in each try, and of course the number of tries.  The number of cycles per trial is typically 10-100 for <strong>try_fn_type</strong> "converge", and 10-200+ for "converge_search_3" and "converge_search-4".  The maximum number is specified by <strong>max_n_tries</strong> (default value = 200).  The number of trials is up to you and your available computing resources.</p><p>The running time of very large data sets will be quite uncertain.  We advise that a few small scale test runs be made on your system to determine a baseline.  Specify <strong>n_data</strong> to limit how many data vectors are read.  Given a very large quantity of data, <strong>AutoClass</strong> may find its most probable classifications at upwards of a hundred classes, and this will require that <strong>start_j_list</strong> be specified appropriately (See above section <strong>HOW MANY CLASSES?</strong>).  If you are quite certain that you only want a few classes, you can force <strong>AutoClass</strong> to search with a fixed number of classes specified by <strong>fixed_j</strong>.  You will then need to run separate searches with each different fixed number of classes.</p>
<h3>CHANGING FILENAMES IN A SAVED CLASSIFICATION FILE</h3>
<p><strong>AutoClass</strong> caches the data, header, and model file pathnames in the saved classification structure of the binary (".results-bin") or ASCII (".results") "results" files.  If the "results" and "search" files are moved to a different directory location, the search cannot be successfully restarted if you have used absolute pathnames.  Thus it is advantageous to run invoke <strong>AutoClass</strong> in a parent directory of the data, header, and model files, so that relative pathnames can be used.  Since the pathnames cached will then be relative, the files can be moved to a different host or file system and restarted -- providing the same relative pathname hierarchy exists.</p><p>However, since the ".results" file is ASCII text, those pathnames could be changed with a text editor (<strong>save_compact_p</strong> must be specified as false).</p>
<h3>SEARCH PARAMETERS</h3>
<p>The search is controlled by the ".s-params" file.  In this file, an empty line or a line starting with one of these characters is treated as a comment: "#", "!", or ";".  The parameter name and its value can be separated by an equal sign, a space, or a tab:</p>
<pre>
	n_clsfs 1
	n_clsfs = 1
	n_clsfs&lt;tab&gt;1
</pre>
<p>Spaces are ignored if "=" or "&lt;tab&gt;" are used as separators.  Note there are no trailing semicolons.</p><p>The search parameters, with their default values, are as follows:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>rel_error</strong> = 0.01
  </dt>
  <dd>
    <p>Specifies the relative difference measure used by clsf-DS-%=, when deciding if a new clsf is a duplicate of an old one.</p>
  </dd>
  <dt>
    <strong>start_j_list</strong> = 2, 3, 5, 7, 10, 15, 25
  </dt>
  <dd>
    <p>Initially try these numbers of classes, so as not to narrow the search too quickly.  The state of this list is saved in the &lt;..&gt;.search file and used on restarts, unless an override specification of <strong>start_j_list</strong> is made in the .s-params file for the restart run.  This list should bracket your expected number of classes, and by a wide margin! "start_j_list = -999" specifies an empty list (allowed only on restarts)</p>
  </dd>
  <dt>
    <strong>n_classes_fn_type</strong> = 
  </dt>
  <dd>
    <p>Once <strong>start_j_list</strong> is exhausted, <strong>AutoClass</strong> will call this function to decide how many classes to start with on the next try, based on the 10 best classifications found so far.  Currently only "random_ln_normal" is available.</p>
  </dd>
  <dt>
    <strong>fixed_j</strong> = 0
  </dt>
  <dd>
    <p>When <strong>fixed_j</strong> &gt; 0, overrides <strong>start_j_list</strong> and <strong>n_classes_fn_type,</strong> and <strong>AutoClass</strong> will always use this value for the initial number of classes.</p>
  </dd>
  <dt>
    <strong>min_report_period</strong> = 30
  </dt>
  <dd>
    <p>Wait at least this time (in seconds) since last report until reporting verbosely again.  Should be set longer than the expected run time when checking for repeatability of results.  For repeatable results, also see <strong>force_new_search_p,</strong> <strong>start_fn_type</strong> and <strong>randomize_random_p</strong>. <em>NOTE</em>: At least one of "interactive_p", "max_duration", and "max_n_tries" must be active.  Otherwise <strong>AutoClass</strong> will run indefinitely.  See below.</p>
  </dd>
  <dt>
    <strong>interactive_p</strong> = true
  </dt>
  <dd>
    <p>When false, allows run to continue until otherwise halted. When true, standard input is queried on each cycle for the quit character "q", which, when detected, triggers an immediate halt.</p>
  </dd>
  <dt>
    <strong>max_duration</strong> = 0
  </dt>
  <dd>
    <p>When = 0, allows run to continue until otherwise halted. When &gt; 0, specifies the maximum number of seconds to run.</p>
  </dd>
  <dt>
    <strong>max_n_tries</strong> = 0
  </dt>
  <dd>
    <p>When = 0, allows run to continue until otherwise halted. When &gt; 0, specifies the maximum number of tries to make.</p>
  </dd>
  <dt>
    <strong>n_save</strong> = 2
  </dt>
  <dd>
    <p>Save this many clsfs to disk in the .results[-bin] and .search files. if 0, don't save anything (no .search & .results[-bin] files).</p>
  </dd>
  <dt>
    <strong>log_file_p</strong> = true
  </dt>
  <dd>
    <p>If false, do not write a log file.</p>
  </dd>
  <dt>
    <strong>search_file_p</strong> = true
  </dt>
  <dd>
    <p>If false, do not write a search file.</p>
  </dd>
  <dt>
    <strong>results_file_p</strong> = true
  </dt>
  <dd>
    <p>If false, do not write a results file.</p>
  </dd>
  <dt>
    <strong>min_save_period</strong> = 1800
  </dt>
  <dd>
    <p>CPU crash protection.  This specifies the maximum time, in seconds, that <strong>AutoClass</strong> will run before it saves the current results to disk.  The default time is 30 minutes.</p>
  </dd>
  <dt>
    <strong>max_n_store</strong> = 10
  </dt>
  <dd>
    <p>Specifies the maximum number of classifications stored internally.</p>
  </dd>
  <dt>
    <strong>n_final_summary</strong> = 10
  </dt>
  <dd>
    <p>Specifies the number of trials to be printed out after search ends.</p>
  </dd>
  <dt>
    <strong>start_fn_type</strong> = 
  </dt>
  <dd>
    <p>One of {"random", "block"}.  This specifies the type of class initialization.  For normal search, use "random", which randomly selects instances to be initial class means, and adds appropriate variances. For testing with repeatable search, use "block", which partitions the database into successive blocks of near equal size. For repeatable results, also see <strong>force_new_search_p</strong>, <strong>min_report_period</strong>, and <strong>randomize_random_p</strong>.</p>
  </dd>
  <dt>
    <strong>try_fn_type</strong> = 
  </dt>
  <dd>
    <p>One of {"converge_search_3", "converge_search_4", "converge"}. These specify alternate search stopping criteria. "converge" merely tests the rate of change of the log_marginal classification probability (clsf-&gt;log_a_x_h), without checking rate of change of individual classes(see <strong>halt_range</strong> and <strong>halt_factor</strong>). "converge_search_3" and "converge_search_4" each monitor the ratio class-&gt;log_a_w_s_h_j/class-&gt;w_j for all classes, and continue convergence until all pass the quiescence criteria for <strong>n_average</strong> cycles.  "converge_search_3" tests differences between successive convergence cycles (see <strong>rel_delta_range</strong>).  This provides a reasonable, general purpose stopping criteria. "converge_search_4" averages the ratio over "sigma_beta_n_values" cycles (see <strong>cs4_delta_range</strong>).  This is preferred when converge_search_3 produces many similar classes.</p>
  </dd>
  <dt>
    <strong>initial_cycles_p</strong> = true
  </dt>
  <dd>
    <p>If true, perform base_cycle in initialize_parameters. false is used only for testing.</p>
  </dd>
  <dt>
    <strong>save_compact_p</strong> = true
  </dt>
  <dd>
    <p>true saves classifications as machine dependent binary (.results-bin & .chkpt-bin). false saves as ascii text (.results & .chkpt)</p>
  </dd>
  <dt>
    <strong>read_compact_p</strong> = true
  </dt>
  <dd>
    <p>true reads classifications as machine dependent binary (.results-bin & .chkpt-bin). false reads as ascii text (.results & .chkpt).</p>
  </dd>
  <dt>
    <strong>randomize_random_p</strong> = true
  </dt>
  <dd>
    <p>false seeds lrand48, the pseudo-random number function with 1 to give repeatable test cases.  true uses universal time clock as the seed, giving semi-random searches. For repeatable results, also see <strong>force_new_search_p</strong>, <strong>min_report_period</strong> and <strong>start_fn_type</strong>.</p>
  </dd>
  <dt>
    <strong>n_data</strong> = 0
  </dt>
  <dd>
    <p>With n_data = 0, the entire database is read from .db2. With n_data &gt; 0, only this number of data are read.</p>
  </dd>
  <dt>
    <strong>halt_range</strong> = 0.5
  </dt>
  <dd>
    <p>Passed to try_fn_type "converge".  With the "converge" try_fn_type, convergence is halted when the larger of halt_range and (halt_factor * current_log_marginal) exceeds the difference between successive cycle values of the classification log_marginal (clsf-&gt;log_a_x_h).  Decreasing this value may tighten the convergence and increase the number of cycles.</p>
  </dd>
  <dt>
    <strong>halt_factor</strong> = 0.0001
  </dt>
  <dd>
    <p>Passed to try_fn_type "converge".  With the "converge" try_fn_type, convergence is halted when the larger of halt_range and (halt_factor * current_log_marginal) exceeds the difference between successive cycle values of the classification log_marginal (clsf-&gt;log_a_x_h).  Decreasing this value may tighten the convergence and increase the number of cycles.</p>
  </dd>
  <dt>
    <strong>rel_delta_range</strong> = 0.0025
  </dt>
  <dd>
    <p>Passed to try function "converge_search_3", which monitors the ratio of log approx-marginal-likelihood of class statistics with-respect-to the class hypothesis (class-&gt;log_a_w_s_h_j) divided by the class weight (class-&gt;w_j), for each class. "converge_search_3" halts convergence when the difference between cycles, of this ratio, for every class, has been exceeded by "rel_delta_range" for "n_average" cycles.  Decreasing "rel_delta_range" tightens the convergence and increases the number of cycles.</p>
  </dd>
  <dt>
    <strong>cs4_delta_range</strong> = 0.0025
  </dt>
  <dd>
    <p>Passed to try function "converge_search_4", which monitors the ratio of (class-&gt;log_a_w_s_h_j)/(class-&gt;w_j), for each class, averaged over "sigma_beta_n_values" convergence cycles. "converge_search_4" halts convergence when the maximum difference in average values of this ratio falls below "cs4_delta_range". Decreasing "cs4_delta_range" tightens the convergence and increases the number of cycles.</p>
  </dd>
  <dt>
    <strong>n_average</strong> = 3
  </dt>
  <dd>
    <p>Passed to try functions "converge_search_3" and "converge". The number of cycles for which the convergence criterion must be satisfied for the trial to terminate.</p>
  </dd>
  <dt>
    <strong>sigma_beta_n_values</strong> = 6
  </dt>
  <dd>
    <p>Passed to try_fn_type "converge_search_4".  The number of past values to use in computing sigma^2 (noise) and beta^2 (signal).</p>
  </dd>
  <dt>
    <strong>max_cycles</strong> = 200
  </dt>
  <dd>
    <p>This is the maximum number of cycles permitted for any one convergence of a classification, regardless of any other stopping criteria.  This is very dependent upon your database and choice of model and convergence parameters, but should be about twice the average number of cycles reported in the screen dump and .log file</p>
  </dd>
  <dt>
    <strong>converge_print_p</strong> = false
  </dt>
  <dd>
    <p>If true, the selected try function will print to the screen values useful in specifying non-default values for <strong>halt_range</strong>, <strong>halt_factor</strong>, <strong>rel_delta_range</strong>, <strong>n_average</strong>, <strong>sigma_beta_n_values</strong>, and <strong>range_factor</strong>.</p>
  </dd>
  <dt>
    <strong>force_new_search_p</strong> = true
  </dt>
  <dd>
    <p>If true, will ignore any previous search results, discarding the existing .search and .results[-bin] files after confirmation by the user; if false, will continue the search using the existing .search and .results[-bin] files. For repeatable results, also see <strong>min_report_period</strong>, <strong>start_fn_type</strong> and <strong>randomize_random_p</strong>.</p>
  </dd>
  <dt>
    <strong>checkpoint_p</strong> = false
  </dt>
  <dd>
    <p>If true, checkpoints of the current classification will be written every "min_checkpoint_period" seconds, with file extension .chkpt[-bin]. This is only useful for very large classifications</p>
  </dd>
  <dt>
    <strong>min_checkpoint_period</strong> = 10800
  </dt>
  <dd>
    <p>If checkpoint_p = true, the checkpointed classification will be written this often - in seconds (default = 3 hours)</p>
  </dd>
  <dt>
    <strong>reconverge_type</strong> = 
  </dt>
  <dd>
    <p>Can be either "chkpt" or "results".  If "checkpoint_p" = true and "reconverge_type" = "chkpt", then continue convergence of the classification contained in &lt;...&gt;.chkpt[-bin].  If "checkpoint_p " = false and "reconverge_type" = "results", continue convergence of the best classification contained in &lt;...&gt;.results[-bin].</p>
  </dd>
  <dt>
    <strong>screen_output_p</strong> = true
  </dt>
  <dd>
    <p>If false, no output is directed to the screen.  Assuming log_file_p = true, output will be directed to the log file only.</p>
  </dd>
  <dt>
    <strong>break_on_warnings_p</strong> = true
  </dt>
  <dd>
    <p>The default value asks the user whether or not to continue, when data definition warnings are found.  If specified as false, then <strong>AutoClass</strong> will continue, despite warnings -- the warning will continue to be output to the terminal and the log file.</p>
  </dd>
  <dt>
    <strong>free_storage_p</strong> = true
  </dt>
  <dd>
    <p>The default value tells <strong>AutoClass</strong> to free the majority of its allocated storage.  This is not required, and in the case of the DEC Alpha causes core dump [is this still true?].  If specified as false, <strong>AutoClass</strong> will not attempt to free storage.</p>
  </dd>

</dl>

<h3>HOW TO GET AUTOCLASS C TO PRODUCE REPEATABLE RESULTS</h3>
<p>In some situations, repeatable classifications are required: comparing basic <strong>AutoClass C</strong> integrity on different platforms, porting <strong>AutoClass C</strong> to a new platform, etc.  In order to accomplish this two things are necessary: 1) the same random number generator must be used, and 2) the search parameters must be specified properly.</p><p>Random Number Generator. This implementation of <strong>AutoClass C</strong> uses the Unix srand48/lrand48 random number generator which generates pseudo-random numbers using the well-known linear congruential algorithm and 48-bit integer arithmetic.  lrand48() returns non- negative long integers uniformly distributed over the interval [0, 2**31].</p><p>Search Parameters. The following .s-params file parameters should be specified:</p>
<pre>
force_new_search_p = true
start_fn_type   "block"
randomize_random_p = false
;; specify the number of trials you wish to run
max_n_tries = 50
;; specify a time greater than duration of run
min_report_period = 30000

</pre>
<p>Note that no current best classification reports will be produced. Only a final classification summary will be output.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CHECKPOINTING</h2>
        <div class="sectioncontent">
<p>With very large databases there is a significant probability of a system crash during any one classification try.  Under such circumstances it is advisable to take the time to checkpoint the calculations for possible restart.</p><p>Checkpointing is initiated by specifying "<strong>checkpoint_p</strong> = true" in the ".s-params" file.  This causes the inner convergence step, to save a copy of the classification onto the checkpoint file each time the classification is updated, providing a certain period of time has elapsed.  The file extension is ".chkpt[-bin]".</p><p>Each time a AutoClass completes a cycle, a "." is output to the screen to provide you with information to be used in setting the <strong>min_checkpoint_period</strong> value (default 10800 seconds or 3 hours). There is obviously a trade-off between frequency of checkpointing and the probability that your machine may crash, since the repetitive writing of the checkpoint file will slow the search process.</p><p>Restarting AutoClass Search:</p><p>To recover the classification and continue the search after rebooting and reloading AutoClass, specify <strong>reconverge_type</strong> = "chkpt" in the ".s-params" file (specify <strong>force_new_search_p</strong> as false).</p><p>AutoClass will reload the appropriate database and models, provided there has been no change in their filenames since the time they were loaded for the checkpointed classification run.  The ".s-params" file contains any non-default arguments that were provided to the original call.</p><p>In the beginning of a search, before <strong>start_j_list</strong> has been emptied, it will be necessary to trim the original list to what would have remained in the crashed search.  This can be determined by looking at the ".log" file to determine what values were already used. If the <strong>start_j_list</strong> has been emptied, then an empty <strong>start_j_list</strong> should be specified in the ".s-params" file.  This is done either by</p>
<pre>
        <strong>start_j_list</strong> =
</pre>
<p>or</p>
<pre>
        <strong>start_j_list</strong> = -9999
</pre>
<p>Here is an a set of scripts to demonstrate check-pointing:</p>
<pre>
autoclass -search data/glass/glassc.db2 data/glass/glass-3c.hd2 &#92;
     data/glass/glass-mnc.model data/glass/glassc-chkpt.s-params

Run 1)
  ## glassc-chkpt.s-params
  max_n_tries = 2
  force_new_search_p = true
  ## --------------------
  ;; run to completion

Run 2)
  ## glassc-chkpt.s-params
  force_new_search_p = false
  max_n_tries = 10
  checkpoint_p = true
  min_checkpoint_period = 2
  ## --------------------
  ;; after 1 checkpoint, ctrl-C to simulate cpu crash

Run 3)
  ## glassc-chkpt.s-params
  force_new_search_p = false
  max_n_tries = 1
  checkpoint_p = true
  min_checkpoint_period = 1
  reconverge_type = "chkpt"
  ## --------------------
  ;; checkpointed trial should finish

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OUTPUT FILES</h2>
        <div class="sectioncontent">
<p>The standard reports are</p>
<dl class='dl-vertical'>
  <dt>
    1)
  </dt>
  <dd>
    <p>Attribute influence values: presents the relative influence or significance of the data's attributes both globally (averaged over all classes), and locally (specifically for each class). A heuristic for relative class strength is also listed;</p>
  </dd>
  <dt>
    2)
  </dt>
  <dd>
    <p>Cross-reference by case (datum) number: lists the primary class probability for each datum, ordered by case number.  When report_mode = "data", additional lesser class probabilities (greater than or equal to 0.001) are listed for each datum;</p>
  </dd>
  <dt>
    3)
  </dt>
  <dd>
    <p>Cross-reference by class number: for each class the primary class probability and any lesser class probabilities (greater than or equal to 0.001) are listed for each datum in the class, ordered by case number. It is also possible to list, for each datum, the values of attributes, which you select.</p>
  </dd>

</dl>
<p>The attribute influence values report attempts to provide relative measures of the "influence" of the data attributes on the classes found by the classification.  The normalized class strengths, the normalized attribute influence values summed over all classes, and the individual influence values (I[jkl]) are all only relative measures and should be interpreted with more meaning than rank ordering, but not like anything approaching absolute values.</p><p>The reports are output to files whose names and pathnames are taken from the ".r-params" file pathname.  The report file types (extensions) are:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>influence values report</strong>
  </dt>
  <dd>
    <p>"influ-o-text-<em>n</em>" or "influ-no-text-<em>n</em>"</p>
  </dd>
  <dt>
    <strong>cross-reference by case</strong>
  </dt>
  <dd>
    <p>"case-text-<em>n</em>"</p>
  </dd>
  <dt>
    <strong>cross-reference by class</strong>
  </dt>
  <dd>
    <p>"class-text-<em>n</em>"</p>
  </dd>

</dl>
<p>or, if report_mode is overridden to "data":</p>
<dl class='dl-vertical'>
  <dt>
    <strong>influence values report</strong>
  </dt>
  <dd>
    <p>"influ-o-data-<em>n</em>" or "influ-no-data-<em>n</em>"</p>
  </dd>
  <dt>
    <strong>cross-reference by case</strong>
  </dt>
  <dd>
    <p>"case-data-<em>n</em>"</p>
  </dd>
  <dt>
    <strong>cross-reference by class</strong>
  </dt>
  <dd>
    <p>"class-data-<em>n</em>"</p>
  </dd>

</dl>
<p>where <em>n</em> is the classification number from the "results" file. The first or best classification is numbered 1, the next best 2, etc. The default is to generate reports only for the best classification in the "results" file.  You can produce reports for other saved classifications by using report params keywords <strong>n_clsfs</strong> and <strong>clsf_n_list</strong>.  The "influ-o-text-<em>n</em>" file type is the default (<strong>order_attributes_by_influence_p</strong> = true), and lists each class's attributes in descending order of attribute influence value. If the value of <strong>order_attributes_by_influence_p</strong> is overridden to be false in the &lt;...&gt;.r-params file, then each class's attributes will be listed in ascending order by attribute number.  The extension of the file generated will be "influ-no-text-<em>n</em>".  This method of listing facilitates the visual comparison of attribute values between classes.</p><p>For example, this command:</p>
<pre>
	autoclass -reports sample/imports-85c.results-bin
		sample/imports-85c.search sample/imports-85c.r-params
</pre>
<p>with this line in the ".r-params" file:</p><p>	xref_class_report_att_list = 2, 5, 6</p><p>will generate these output files:</p>
<pre>
	imports-85.influ-o-text-1
	imports-85.case-text-1
	imports-85.class-text-1
</pre>
<p>The <strong>AutoClass C</strong> reports provide the capability to compute sigma class contour values for specified pairs of real valued attributes, when generating the influence values report with the data option (report_mode = "data").  Note that sigma class contours are not generated from discrete type attributes.</p><p>The sigma contours are the two dimensional equivalent of n-sigma error bars in one dimension.  Specifically, for two independent attributes the n-sigma contour is defined as the ellipse where</p><p>((x - xMean) / xSigma)^2 + ((y - yMean) / ySigma)^2 == n</p><p>With covariant attributes, the n-sigma contours are defined identically, in the rotated coordinate system of the distribution's principle axes.  Thus independent attributes give ellipses oriented parallel with the attribute axes, while the axes of sigma contours of covariant attributes are rotated about the center determined by the means.  In either case the sigma contour represents a line where the class probability is constant, irrespective of any other class probabilities.</p><p>With three or more attributes the n-sigma contours become k-dimensional ellipsoidal surfaces.  This code takes advantage of the fact that the parallel projection of an n-dimensional ellipsoid, onto any 2-dim plane, is bounded by an ellipse.  In this simplified case of projecting the single sigma ellipsoid onto the coordinate planes, it is also true that the 2-dim covariances of this ellipse are equal to the corresponding elements of the n-dim ellipsoid's covariances.  The Eigen-system of the 2-dim covariance then gives the variances w.r.t. the principal components of the eclipse, and the rotation that aligns it with the data.  This represents the best way to display a distribution in the marginal plane.</p><p>To get contour values, set the keyword <strong>sigma_contours_att_list</strong> to a list of real valued attribute indices (from .hd2 file), and request an influence values report with the data option.  For example,</p>
<pre>
	report_mode = "data"
	sigma_contours_att_list = 3, 4, 5, 8, 15
</pre>
<h3>OUTPUT REPORT PARAMETERS</h3>
<p>The contents of the output report are controlled by the ".r-params" file.  In this file, an empty line or a line starting with one of these characters is treated as a comment: "#", "!", or ";".  The parameter name and its value can be separated by an equal sign, a space, or a tab:</p>
<pre>
	n_clsfs 1
	n_clsfs = 1
	n_clsfs&lt;tab&gt;1
</pre>
<p>Spaces are ignored if "=" or "&lt;tab&gt;" are used as separators.  Note there are no trailing semicolons.</p><p>The following are the allowed parameters and their default values:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>n_clsfs</strong> = 1
  </dt>
  <dd>
    <p>number of clsfs in the .results file for which to generate reports, starting with the first or "best".</p>
  </dd>
  <dt>
    <strong>clsf_n_list</strong> = 
  </dt>
  <dd>
    <p>if specified, this is a one-based index list of clsfs in the clsf sequence read from the .results file.  It overrides "n_clsfs". For example:</p><p>	clsf_n_list = 1, 2</p><p>will produce the same output as</p><p>	n_clsfs = 2</p><p>but</p><p>	clsf_n_list = 2</p><p>will only output the "second best" classification report.</p>
  </dd>
  <dt>
    <strong>report_type</strong> = 
  </dt>
  <dd>
    <p>type of reports to generate: "all", "influence_values", "xref_case", or "xref_class".</p>
  </dd>
  <dt>
    <strong>report_mode</strong> = 
  </dt>
  <dd>
    <p>mode of reports to generate. "text" is formatted text layout.  "data" is numerical -- suitable for further processing.</p>
  </dd>
  <dt>
    <strong>comment_data_headers_p</strong> = false
  </dt>
  <dd>
    <p>the default value does not insert # in column 1 of most report_mode = "data" header lines.  If specified as true, the comment character will be inserted in most header lines.</p>
  </dd>
  <dt>
    <strong>num_atts_to_list</strong> = 
  </dt>
  <dd>
    <p>if specified, the number of attributes to list in influence values report. if not specified, <em>all</em> attributes will be listed. (e.g. "num_atts_to_list = 5")</p>
  </dd>
  <dt>
    <strong>xref_class_report_att_list</strong> = 
  </dt>
  <dd>
    <p>if specified, a list of attribute numbers (zero-based), whose values will be output in the "xref_class" report along with the case probabilities. if not specified, no attributes values will be output. (e.g. "xref_class_report_att_list = 1, 2, 3")</p>
  </dd>
  <dt>
    <strong>order_attributes_by_influence_p</strong> = true
  </dt>
  <dd>
    <p>The default value lists each class's attributes in descending order of attribute influence value, and uses ".influ-o-text-n" as the influence values report file type.  If specified as false, then each class's attributes will be listed in ascending order by attribute number. The extension of the file generated will be "influ-no-text-n".</p>
  </dd>
  <dt>
    <strong>break_on_warnings_p</strong> = true
  </dt>
  <dd>
    <p>The default value asks the user whether to continue or not when data definition warnings are found.  If specified as false, then <strong>AutoClass</strong> will continue, despite warnings -- the warning will continue to be output to the terminal.</p>
  </dd>
  <dt>
    <strong>free_storage_p</strong> = true
  </dt>
  <dd>
    <p>The default value tells <strong>AutoClass</strong> to free the majority of its allocated storage.  This is not required, and in the case of the DEC Alpha causes a core dump [is this still true?].  If specified as false, <strong>AutoClass</strong> will not attempt to free storage.</p>
  </dd>
  <dt>
    <strong>max_num_xref_class_probs</strong> = 5
  </dt>
  <dd>
    <p>Determines how many lessor class probabilities will be printed for the case and class cross-reference reports.  The default is to print the most probable class probability value and up to 4 lessor class prob- ibilities.  Note this is true for both the "text" and "data" class cross-reference reports, but only true for the "data" case cross- reference report.  The "text" case cross-reference report only has the most probable class probability.</p>
  </dd>
  <dt>
    <strong>sigma_contours_att_list</strong> = 
  </dt>
  <dd>
    <p>If specified, a list of real valued attribute indices (from .hd2 file) will be to compute sigma class contour values, when generating influence values report with the data option (report_mode = "data"). If not specified, there will be no sigma class contour output. (e.g. "sigma_contours_att_list = 3, 4, 5, 8, 15")</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INTERPRETATION OF AUTOCLASS RESULTS</h2>
        <div class="sectioncontent">
<h3>WHAT HAVE YOU GOT?</h3>
<p>Now you have run <strong>AutoClass</strong> on your data set -- what have you got? Typically, the <strong>AutoClass</strong> search procedure finds many classifications, but only saves the few best.  These are now available for inspection and interpretation.  The most important indicator of the relative merits of these alternative classifications is Log total posterior probability value.  Note that since the probability lies between 1 and 0, the corresponding Log probability is negative and ranges from 0 to negative infinity. The difference between these Log probability values raised to the power e gives the relative probability of the alternatives classifications.  So a difference of, say 100, implies one classification is e^100 ~= 10^43 more likely than the other. However, these numbers can be very misleading, since they give the relative probability of alternative classifications under the <strong>AutoClass</strong> <em>assumptions</em>.</p>
<h3>ASSUMPTIONS</h3>
<p>Specifically, the most important <strong>AutoClass</strong> assumptions are the use of normal models for real variables, and the assumption of independence of attributes within a class.  Since these assumptions are often violated in practice, the difference in posterior probability of alternative classifications can be partly due to one classification being closer to satisfying the assumptions than another, rather than to a real difference in classification quality. Another source of uncertainty about the utility of Log probability values is that they do not take into account any specific prior knowledge the user may have about the domain.  This means that it is often worth looking at alternative classifications to see if you can interpret them, but it is worth starting from the most probable first.  Note that if the Log probability value is much greater than that for the one class case, it is saying that there is overwhelming evidence for <em>some</em> structure in the data, and part of this structure has been captured by the <strong>AutoClass</strong> classification.</p>
<h3>INFLUENCE REPORT </h3>
<p>So you have now picked a classification you want to examine, based on its Log probability value; how do you examine it?  The first thing to do is to generate an "influence" report on the classification using the report generation facilities documented in <em>/usr/share/doc/autoclass/reports-c.text</em>.  An influence report is designed to summarize the important information buried in the <strong>AutoClass</strong> data structures.</p><p>The first part of this report gives the heuristic class "strengths". Class "strength" is here defined as the geometric mean probability that any instance "belonging to" class, would have been generated from the class probability model.  It thus provides a heuristic measure of how strongly each class predicts "its" instances.</p><p>The second part is a listing of the overall "influence" of each of the attributes used in the classification.  These give a rough heuristic measure of the relative importance of each attribute in the classification.  Attribute "influence values" are a class probability weighted average of the "influence" of each attribute in the classes, as described below.</p><p>The next part of the report is a summary description of each of the classes.  The classes are arbitrarily numbered from 0 up to n, in order of descending class weight.  A class weight of say 34.1 means that the weighted sum of membership probabilities for class is 34.1.  Note that a class weight of 34 does not necessarily mean that 34 cases belong to that class, since many cases may have only partial membership in that class.  Within each class, attributes or attribute sets are ordered by the "influence" of their model term.</p>
<h3>CROSS ENTROPY </h3>
<p>A commonly used measure of the divergence between two probability distributions is the cross entropy: the sum over all possible values x, of P(x|c...)*log[P(x|c...)/P(x|g...)], where c... and g... define the distributions.  It ranges from zero, for identical distributions, to infinite for distributions placing probability 1 on differing values of an attribute.  With conditionally independent terms in the probability distributions, the cross entropy can be factored to a sum over these terms.  These factors provide a measure of the corresponding modeled attribute's influence in differentiating the two distributions.</p><p>We define the modeled term's "influence" on a class to be the cross entropy term for the class distribution w.r.t. the global class distribution of the single class classification.  "Influence" is thus a measure of how strongly the model term helps differentiate the class from the whole data set.  With independently modeled attributes, the influence can legitimately be ascribed to the attribute itself.  With correlated or covariant attributes sets, the cross entropy factor is a function of the entire set, and we distribute the influence value equally over the modeled attributes.</p>
<h3>ATTRIBUTE INFLUENCE VALUES</h3>
<p>In the "influence" report on each class, the attribute parameters for that class are given in order of highest influence value for the model term attribute sets.  Only the first few attribute sets usually have significant influence values.  If an influence value drops below about 20% of the highest value, then it is probably not significant, but all attribute sets are listed for completeness.  In addition to the influence value for each attribute set, the values of the attribute set parameters in that class are given along with the corresponding "global" values.  The global values are computed directly from the data independent of the classification.  For example, if the class mean of attribute "temperature" is 90 with standard deviation of 2.5, but the global mean is 68 with a standard deviation of 16.3, then this class has selected out cases with much higher than average temperature, and a rather small spread in this high range.  Similarly, for discrete attribute sets, the probability of each outcome in that class is given, along with the corresponding global probability -- ordered by its significance: the absolute value of (log {&lt;local-probability&gt; / &lt;global-probability&gt;}).  The sign of the significance value shows the direction of change from the global class.  This information gives an overview of how each class differs from the average for all the data, in order of the most significant differences.</p>
<h3>CLASS AND CASE REPORTS</h3>
<p>Having gained a description of the classes from the "influence" report, you may want to follow-up to see which classes your favorite cases ended up in.  Conversely, you may want to see which cases belong to a particular class.  For this kind of cross-reference information two complementary reports can be generated.  These are more fully documented in <em>/usr/share/doc/autoclass/reports-c.text</em>. The "class" report, lists all the cases which have significant membership in each class and the degree to which each such case belongs to that class.  Cases whose class membership is less than 90% in the current class have their other class membership listed as well.  The cases within a class are ordered in increasing case number.  The alternative "cases" report states which class (or classes) a case belongs to, and the membership probability in the most probable class.  These two reports allow you to find which cases belong to which classes or the other way around.  If nearly every case has close to 99% membership in a single class, then it means that the classes are well separated, while a high degree of cross-membership indicates that the classes are heavily overlapped.  Highly overlapped classes are an indication that the idea of classification is breaking down and that groups of mutually highly overlapped classes, a kind of meta class, is probably a better way of understanding the data.</p>
<h3>COMPARING CLASS WEIGHTS AND CLASS/CASE REPORT ASSIGNMENTS</h3>
<p>The class weight given as the class probability parameter, is essentially the sum over all data instances, of the normalized probability that the instance is a member of the class.  It is probably an error on our part that we format this number as an integer in the report, rather than emphasizing its real nature.  You will find the actual real value recorded as the w_j parameter in the class_DS structures on any .results[-bin] file.</p><p>The .case and .class reports give probabilities that cases are members of classes.  Any assignment of cases to classes requires some decision rule.  The maximum probability assignment rule is often implicitly assumed, but it cannot be expected that the resulting partition sizes will equal the class weights unless nearly all class membership probabilities are effectively one or zero.  With non-1/0 membership probabilities, matching the class weights requires summing the probabilities.</p><p>In addition, there is the question of completeness of the EM (expectation maximization) convergence.  EM alternates between estimating class parameters and estimating class membership probabilities.  These estimates converge on each other, but never actually meet.  <strong>AutoClass</strong> implements several convergence algorithms with alternate stopping criteria using appropriate parameters in the .s-params file.  Proper setting of these parameters, to get reasonably complete and efficient convergence may require experimentation.</p>
<h3>ALTERNATIVE CLASSIFICATIONS </h3>
<p>In summary, the various reports that can be generated give you a way of viewing the current classification.  It is usually a good idea to look at alternative classifications even though they do not have the minimum Log probability values.  These other classifications usually have classes that correspond closely to strong classes in other classifications, but can differ in the weak classes.  The "strength" of a class within a classification can usually be judged by how dramatically the highest influence value attributes in the class differ from the corresponding global attributes.  If none of the classifications seem quite satisfactory, it is always possible to run <strong>AutoClass</strong> again to generate new classifications.</p>
<h3>WHAT NEXT?</h3>
<p>Finally, the question of what to do after you have found an insightful classification arises.  Usually, classification is a preliminary data analysis step for examining a set of cases (things, examples, etc.) to see if they can be grouped so that members of the group are "similar" to each other.  <strong>AutoClass</strong> gives such a grouping without the user having to define a similarity measure.  The built-in "similarity" measure is the mutual predictiveness of the cases.  The next step is to try to "explain" why some objects are more like others than those in a different group.  Usually, domain knowledge suggests an answer.  For example, a classification of people based on income, buying habits, location, age, etc., may reveal particular social classes that were not obvious before the classification analysis.  To obtain further information about such classes, further information, such as number of cars, what TV shows are watched, etc., would reveal even more information.  Longitudinal studies would give information about how social classes arise and what influences their attitudes -- all of which is going way beyond the initial classification.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PREDICTIONS</h2>
        <div class="sectioncontent">
<p>Classifications can be used to predict class membership for new cases.  So in addition to possibly giving you some insight into the structure behind your data, you can now use <strong>AutoClass</strong> directly to make predictions, and compare <strong>AutoClass</strong> to other learning systems.</p><p>This technique for predicting class probabilities is applicable to all attributes, regardless of data type/sub_type or likelihood model term type.</p><p>In the event that the class membership of a data case does not exceed 0.0099999 for any of the "training" classes, the following message will appear in the screen output for each case:</p>
<pre>
        xref_get_data: case_num xxx =&gt; class 9999
</pre>
<p>Class 9999 members will appear in the "case" and "class" cross-reference reports with a class membership of 1.0.</p><p>Cautionary Points:</p><p>The usual way of using <strong>AutoClass</strong> is to put all of your data in a data_file, describe that data with model and header files, and run "autoclass -search".  Now, instead of one data_file you will have two, a training_data_file and a test_data_file.</p><p>It is most important that both databases have the same <strong>AutoClass</strong> internal representation.  Should this not be true, <strong>AutoClass</strong> will exit, or possibly in in some situations, crash.  The prediction mode is designed to hopefully direct the user into conforming to this requirement.</p><p>Preparation:</p><p>Prediction requires having a training classification and a test database.  The training classification is generated by the running of "autoclass -search" on the training data_file ("data/soybean/soyc.db2"), for example:</p>
<pre>
    autoclass -search data/soybean/soyc.db2 data/soybean/soyc.hd2
        data/soybean/soyc.model data/soybean/soyc.s-params
</pre>
<p>This will produce "soyc.results-bin" and "soyc.search".  Then create a "reports" parameter file, such as "soyc.r-params" (see <em>/usr/share/doc/autoclass/reports-c.text</em>), and run <strong>AutoClass</strong> in "reports" mode, such as:</p>
<pre>
    autoclass -reports data/soybean/soyc.results-bin
        data/soybean/soyc.search data/soybean/soyc.r-params
</pre>
<p>This will generate class and case cross-reference files, and an influence values file.  The file names are based on the ".r-params" file name:</p>
<pre>
        data/soybean/soyc.class-text-1
        data/soybean/soyc.case-text-1
        data/soybean/soyc.influ-text-1
</pre>
<p>These will describe the classes found in the training_data_file. Now this classification can be used to predict the probabilistic class membership of the test_data_file cases ("data/soybean/soyc-predict.db2") in the training_data_file classes.</p>
<pre>
    autoclass -predict data/soybean/soyc-predict.db2
        data/soybean/soyc.results-bin data/soybean/soyc.search
        data/soybean/soyc.r-params
</pre>
<p>This will generate class and case cross-reference files for the test_data_file cases predicting their probabilistic class memberships in the training_data_file classes.  The file names are based on the ".db2" file name:</p>
<pre>
        data/soybean/soyc-predict.class-text-1
        data/soybean/soyc-predict.case-text-1
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO autoclass&hellip;</h2>
        <div class="sectioncontent">
<p><strong>AutoClass</strong> is documented fully here:</p><p><em>/usr/share/doc/autoclass/introduction-c.text</em> Guide to the documentation</p><p><em>/usr/share/doc/autoclass/preparation-c.text</em> How to prepare data for use by AutoClass</p><p><em>/usr/share/doc/autoclass/search-c.text</em> How to run AutoClass to find classifications.</p><p><em>/usr/share/doc/autoclass/reports-c.text</em> How to examine the classification in various ways.</p><p><em>/usr/share/doc/autoclass/interpretation-c.text</em> How to interpret AutoClass results.</p><p><em>/usr/share/doc/autoclass/checkpoint-c.text</em> Protocols for running a checkpointed search.</p><p><em>/usr/share/doc/autoclass/prediction-c.text</em> Use classifications to predict class membership for new cases.</p><p>These provide supporting documentation:</p><p><em>/usr/share/doc/autoclass/classes-c.text</em> What classification is all about, for beginners.</p><p><em>/usr/share/doc/autoclass/models-c.text</em> Brief descriptions of the model term implementations.</p><p>The mathematical theory behind <strong>AutoClass</strong> is explained in these documents:</p><p><em>/usr/share/doc/autoclass/kdd-95.ps</em> Postscript file containing: P. Cheeseman, J. Stutz, "Bayesian Classification (AutoClass): Theory and Results", in "Advances in Knowledge Discovery and Data Mining", Usama M. Fayyad, Gregory Piatetsky-Shapiro, Padhraic Smyth, & Ramasamy Uthurusamy, Eds. The AAAI Press, Menlo Park, expected fall 1995.</p><p><em>/usr/share/doc/autoclass/tr-fia-90-12-7-01.ps</em> Postscript file containing: R. Hanson, J. Stutz, P. Cheeseman, "Bayesian Classification Theory", Technical Report FIA-90-12-7-01, NASA Ames Research Center, Artificial Intelligence Branch, May 1991 (The figures are not included, since they were inserted by "cut-and-paste" methods into the original "camera-ready" copy.)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">

<pre>
Dr. Peter Cheeseman
Principal Investigator - NASA Ames, Computational Sciences Division
cheesem@ptolemy.arc.nasa.gov

John Stutz
Research Programmer - NASA Ames, Computational Sciences Division
stutz@ptolemy.arc.nasa.gov

Will Taylor
Support Programmer - NASA Ames, Computational Sciences Division
taylor@ptolemy.arc.nasa.gov
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO autoclass&hellip;</h2>
        <div class="sectioncontent">
<p><strong>multimix</strong>(1).</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="auto-multiple-choice.1.html"><span aria-hidden="true">&larr;</span> auto-multiple-choice.1: Automated treatment of mcqs</a></li>
   <li class="next"><a href="autoconf-autoconf.1.html">autoconf.1: Generate configuration scripts <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

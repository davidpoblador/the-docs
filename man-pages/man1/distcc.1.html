<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>distcc: Distributed c/c++/objc compiler with distcc-pump extensions</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Distributed c/c++/objc compiler with distcc-pump extensions">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="distcc (1) manual">
  <meta name="twitter:description" content="Distributed c/c++/objc compiler with distcc-pump extensions">
  <meta name="twitter:image" content="https://www.carta.tech/images/distcc-distcc-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/distcc.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="distcc (1) manual" />
  <meta property="og:description" content="Distributed c/c++/objc compiler with distcc-pump extensions" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/distcc-distcc-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">distcc<small> (1)</small></h1>
        <p class="lead">Distributed c/c++/objc compiler with distcc-pump extensions</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/distcc.1.html">
      <span itemprop="name">distcc: Distributed c/c++/objc compiler with distcc-pump extensions</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/distcc/">
      <span itemprop="name">distcc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/distcc.1.html">
      <span itemprop="name">distcc: Distributed c/c++/objc compiler with distcc-pump extensions</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>distcc</strong> <em>&lt;compiler&gt; [COMPILER OPTIONS]</em></p><p><strong>distcc</strong> <em>[COMPILER OPTIONS]</em></p><p><strong>&lt;compiler&gt;</strong> <em>[COMPILER OPTIONS]</em></p><p><strong>distcc</strong> <em>[DISTCC OPTIONS]</em></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>distcc distributes compilation of C code across several machines on a network.  distcc should always generate the same results as a local compile, it is simple to install and use, and it is often much faster than a local compile.</p><p>This version incorporates plain distcc as well as an enhancement called pump mode or distcc-pump.</p><p>For each job, distcc in plain mode sends the complete preprocessed source code and compiler arguments across the network from the client to a compilation server.  In pump mode, distcc sends the source code and recursively included header files (excluding those from the default system header directories), so that both preprocessing and compilation can take place on the compilation servers. This speeds up the delivery of compilations by up to an order of magnitude over plain distcc.</p><p>Compilation is driven by a client machine, which is typically the developer's workstation or laptop.  The distcc client runs on this machine, as does make, the preprocessor (if distcc's pump mode is not used), the linker, and other stages of the build process.  Any number of volunteer machines act as compilation servers and help the client to build the program, by running the <a href="../man1/distccd.1.html"><strong>distccd</strong>(1)</a></strong> daemon, C compiler and assembler as required.</p><p>distcc can run across either TCP sockets (on port 3632 by default), or through a tunnel command such as <strong>ssh</strong>(1).  For TCP connections the volunteers must run the <a href="../man1/distccd.1.html"><strong>distccd</strong>(1)</a> daemon either directly or from inetd. For SSH connections distccd must be installed but should <strong>not</strong> be listening for connections.</p><p>TCP connections should only be used on secure networks because there is no user authentication or protection of source or object code.  SSH connections are typically 25% slower because of processor overhead for encryption, although this can vary greatly depending on CPUs, network and the program being built.</p><p>distcc is intended to be used with GNU Make's <strong>-j</strong> option, which runs several compiler processes concurrently.  distcc spreads the jobs across both local and remote CPUs.  Because distcc is able to distribute most of the work across the network, a higher concurrency level can be used than for local builds.  As a rule of thumb, the <strong>-j</strong> value should be set to about twice the total number of available server CPUs but subject to client limitations.  This setting allows for maximal interleaving of tasks being blocked waiting for disk or network IO. Note that distcc can also work with other build control tools, such as SCons, where similar concurrency settings must be adjusted.</p><p>The <strong>-j</strong> setting, especially for large values of <strong>-j,</strong> must take into account the CPU load on the client.  Additional measures may be needed to curtail the client load. For example, concurrent linking should be severely curtailed using auxiliary locks.  The effect of other build activity, such as Java compilation when building mixed code, should be considered.  The <strong>--localslots_cpp</strong> parameter is by default set to 16. This limits the number of concurrent processes that do preprocessing in plain distcc (non-pump) mode. Therefore, larger <strong>-j</strong> values than 16 may be used without overloading a single-CPU client due to preprocessing.  Such large values may speed up parts of the build that do not involve C compilations, but they may not be useful to distcc efficiency in plain mode.</p><p>In contrast, using pump mode and say 40 servers, a setting of <strong>-j80</strong> or larger may be appropriate even for single-CPU clients.</p><p>It is strongly recommended that you install the same compiler version on all machines participating in a build.  Incompatible compilers may cause mysterious compile or link failures.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">QUICKSTART</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p>1</p>
  </dt>
  <dd>
    <p>For each machine, download distcc, unpack, and install.</p>
  </dd>
  <dt>
    <p>2</p>
  </dt>
  <dd>
    <p>On each of the servers, run <strong>distccd --daemon</strong> with <strong>--allow</strong> options to restrict access.</p>
  </dd>
  <dt>
    <p>3</p>
  </dt>
  <dd>
    <p>Put the names of the servers in your environment:</p><p>$ export DISTCC_HOSTS='localhost red green blue'</p>
  </dd>
  <dt>
    <p>4</p>
  </dt>
  <dd>
    <p>Build!</p><p>$ make -j8 CC=distcc</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">QUICKSTART FOR DISTCC-PUMP MODE</h2>
        <div class="sectioncontent">
<p>Proceed as above, but in Step 3, specify that the remote hosts are to carry the burden of preprocessing and that the files sent over the network should be compressed:</p><p>$ export DISTCC_HOSTS='--randomize localhost red,cpp,lzo green,cpp,lzo blue,cpp,lzo'</p><p>The <strong>--randomize</strong> option enforces a uniform usage of compile servers.  While you will get some benefit from distcc's pump mode with only a few servers, you get increasing benefit with more server CPUs (up to the hundreds!). Wrap your build inside the pump command, here assuming 10 servers:</p><p>$ distcc-pump make -j20 CC=distcc</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">HOW PLAIN (NON-PUMP) DISTCC WORKS</h2>
        <div class="sectioncontent">
<p>distcc only ever runs the compiler and assembler remotely.  With plain distcc, the preprocessor must always run locally because it needs to access various header files on the local machine which may not be present, or may not be the same, on the volunteer.  The linker similarly needs to examine libraries and object files, and so must run locally.</p><p>The compiler and assembler take only a single input file (the preprocessed source) and produce a single output (the object file). distcc ships these two files across the network and can therefore run the compiler/assembler remotely.</p><p>Fortunately, for most programs running the preprocessor is relatively cheap, and the linker is called relatively infrequent, so most of the work can be distributed.</p><p>distcc examines its command line to determine which of these phases are being invoked, and whether the job can be distributed.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">HOW DISTCC-PUMP MODE WORKS</h2>
        <div class="sectioncontent">
<p>In pump mode, distcc runs the preprocessor remotely too.  To do so, the preprocessor must have access to all the files that it would have accessed if had been running locally.  In pump mode, therefore, distcc gathers all of the recursively included headers, except the ones that are default system headers, and sends them along with the source file to the compilation server.</p><p>In distcc-pump mode, the server unpacks the set of all source files in a temporary directory, which contains a directory tree that mirrors the part of the file system that is relevant to preprocessing, including symbolic links.</p><p>The compiler is then run from the path in the temporary directory that corresponds to the current working directory on the client.  To find and transmit the many hundreds of files that are often part of a single compilation, pump mode uses an incremental include analysis algorithm.  The include server is a Python program that implements this algorithm.  The distcc-pump command starts the include server so that throughout the build it can answer include queries by distcc commands.</p><p>The include server uses static analysis of the macro language to deal with conditional compilation and computed includes.  It uses the property that when a given header file has already been analyzed for includes, it is not necessary to do so again if all the include options (-I's) are unchanged (along with other conditions).</p><p>For large builds, header files are included, on average, hundreds of times each. With distcc-pump mode each such file is analyzed only a few times, perhaps just once, instead of being preprocessed hundreds of times.  Also, each source or header file is now compressed only once, because the include server memoizes the compressed files.  As a result, the time used for preparing compilations may drop by up to an order of magnitude over the preprocessing of plain distcc.</p><p>Because distcc in pump mode is able to push out files up to about ten times faster, build speed may increase 3X or more for large builds compared to plain distcc mode.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RESTRICTIONS FOR PUMP MODE</h2>
        <div class="sectioncontent">
<p>Using pump mode requires both client and servers to use release 3.0 or later of distcc and distccd (respectively).</p><p>The incremental include analysis of distc-pump mode rests on the fundamental assumption that source and header files do not change during the build process.  A few complex build systems, such as that for Linux kernel 2.6, do not quite satisfy this requirement.  To overcome such issues, and other corner cases such as absolute filepaths in includes, see the <a href="../man1/include_server.1.html"><strong>include_server</strong>(1)</a></strong> man page.</p><p>Another important assumption is that the include configuration of all machines must be identical.  Thus the headers under the default system path must be the same on all servers and all clients.  If a standard GNU compiler installation is used, then this requirement applies to all libraries whose header files are installed under /usr/include or /usr/local/include/.  Note that installing software packages often lead to additional headers files being placed in subdirectories of either.</p><p>If this assumption does not hold, then it is possible to break builds with distcc-pump mode, or worse, to get wrong results without warning.  Presently this condition is not verified, and it is on our TODO list to address this issue.</p><p>An easy way to guarantee that the include configurations are identical is to use a cross-compiler that defines a default system search path restricted to directories of the compiler installation.</p><p>See the <a href="../man1/include_server.1.html"><strong>include_server</strong>(1)</a> manual for more information on symptoms and causes of violations of distcc-pump mode assumptions.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTION SUMMARY</h2>
        <div class="sectioncontent">
<p>Most options passed to distcc are interpreted as compiler options. The following options are understood by distcc itself. If any of these options are specified, distcc will not invoke the compiler.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--help</strong></p>
  </dt>
  <dd>
    <p>Displays summary instructions.</p>
  </dd>
  <dt>
    <p><strong>--version</strong></p>
  </dt>
  <dd>
    <p>Displays the distcc client version.</p>
  </dd>
  <dt>
    <p><strong>--show-hosts</strong></p>
  </dt>
  <dd>
    <p>Displays the host list that distcc would use. See the Host Specifications section.</p>
  </dd>
  <dt>
    <p><strong>--scan-includes</strong></p>
  </dt>
  <dd>
    <p>Displays the list of files that distcc would send to the remote machine, as computed by the include server.  This is a conservative (over-)approximation of the files that would be read by the C compiler. This option only works in pump mode.  See the "How Distcc-pump Mode Works" section for details on how this is computed.</p><p>The list output by <strong>distcc --scan-includes</strong> will contain one entry per line.  Each line contains a category followed by a path. The category is one of FILE, SYMLINK, DIRECTORY, or SYSTEMDIR:</p><p><strong>FILE</strong> indicates a source file or header file that would be sent to the distcc server host.</p><p><strong>SYMLINK</strong> indicates a symbolic link that would be sent to the distcc server host.</p><p><strong>DIRECTORY</strong> indicates a directory that may be needed in order to compile the source file.  For example, a directory "foo" may be needed because of an include of the form #include "foo/../bar.h". Such directories would be created on the distcc server host.</p><p><strong>SYSTEMDIR</strong> indicates a system include directory, i.e. a directory which is on the compiler's default include path, such as "/usr/include"; such directories are assumed to be present on the distcc server host, and so would not be sent to the distcc server host.</p>
  </dd>
  <dt>
    <p><strong>-j</strong></p>
  </dt>
  <dd>
    <p>Displays distcc's concurrency level, as calculated from the host list; it is the maximum number of outstanding jobs issued by this client to all servers. By default this will be four times the number of hosts in the host list, unless the /LIMIT option was used in the host list. See the Host Specifications section.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INSTALLING DISTCC</h2>
        <div class="sectioncontent">
<p>There are three different ways to call distcc, to suit different circumstances:</p><p>distcc can be installed under the name of the real compiler, to intercept calls to it and run them remotely.  This "masqueraded" compiler has the widest compatibility with existing source trees, and is convenient when you want to use distcc for all compilation.  The fact that distcc is being used is transparent to the makefiles.</p><p>distcc can be prepended to compiler command lines, such as "distcc cc -c hello.c" or CC="distcc gcc".  This is convenient when you want to use distcc for only some compilations or to try it out, but can cause trouble with some makefiles or versions of libtool that assume $CC does not contain a space.</p><p>Finally, distcc can be used directly as a compiler.  "cc" is always used as the name of the real compiler in this "implicit" mode.  This can be convenient for interactive use when "explicit" mode does not work but is not really recommended for new use.</p><p>Remember that you should not use two methods for calling distcc at the same time.  If you are using a masquerade directory, don't change CC and/or CXX, just put the directory early on your PATH.  If you're not using a masquerade directory, you'll need to either change CC and/or CXX, or modify the makefile(s) to call distcc explicitly.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MASQUERADING</h2>
        <div class="sectioncontent">
<p>The basic idea is to create a "masquerade directory" which contains links from the name of the real compiler to the distcc binary.  This directory is inserted early on the PATH, so that calls to the compiler are intercepted and distcc is run instead.  distcc then removes itself from the PATH to find the real compiler.</p><p>For example:</p>
<pre>
# mkdir /usr/lib/distcc/bin
# cd /usr/lib/distcc/bin
# ln -s ../../../bin/distcc gcc
# ln -s ../../../bin/distcc cc
# ln -s ../../../bin/distcc g++
# ln -s ../../../bin/distcc c++
</pre>
<p>Then, to use distcc, a user just needs to put the directory /usr/lib/distcc/bin early in the PATH, and have set a host list in DISTCC_HOSTS or a file.  distcc will handle the rest.</p><p>Note that this masquerade directory must occur on the PATH earlier than the directory that contains the actual compilers of the same names, and that any auxiliary programs that these compilers call (such as as or ld) must also be found on the PATH in a directory after the masquerade directory since distcc calls out to the real compiler with a PATH value that has all directory up to and including the masquerade directory trimmed off.</p><p>It is possible to get a "recursion error" in masquerade mode, which means that distcc is somehow finding itself again, not the real compiler.  This can indicate that you have two masquerade directories on the PATH, possibly because of having two distcc installations in different locations.  It can also indicate that you're trying to mix "masqueraded" and "explicit" operation.</p><p>Recursion errors can be avoided by using shell scripts instead of links. For example, in /usr/lib/distcc/bin create a file cc which contains:</p>
<pre>
#!/bin/sh
distcc /usr/bin/gcc "$@"
</pre>
<p>In this way, we are not dependent on distcc having to locate the real gcc by investigating the PATH variable. Instead, the compiler location is explicitly provided.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">USING DISTCC WITH CCACHE</h2>
        <div class="sectioncontent">
<p>ccache is a program that speeds software builds by caching the results of compilations.  ccache is normally called before distcc, so that results are retrieved from a normal cache.  Some experimentation may be required for idiosyncratic makefiles to make everything work together.</p><p>The most reliable method is to set</p><ul>
<li><p><strong>CCACHE_PREFIX="distcc"</strong></p></li>
</ul><p>This tells ccache to run distcc as a wrapper around the real compiler.  ccache still uses the real compiler to detect compiler upgrades.</p><p>ccache  can then be run using either a masquerade directory <em>or</em> by setting</p><ul>
<li><p><strong>CC="ccache gcc"</strong></p></li>
</ul><p>As of version 2.2, ccache does not cache compilation from preprocessed source and so will never get a cache hit if it is run from distccd or distcc.  It must be run only on the client side and before distcc to be any use.</p><p>distcc's pump mode is not compatible with ccache.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">HOST SPECIFICATIONS</h2>
        <div class="sectioncontent">
<p>A "host list" tells distcc which machines to use for compilation.  In order, distcc looks in the <strong>$DISTCC_HOSTS</strong> environment variable, the user's <strong>$DISTCC_DIR/hosts</strong> file, and the system-wide host file.  If no host list can be found, distcc emits a warning and compiles locally.</p><p>The host list is a simple whitespace separated list of host specifications.  The simplest and most common form is a host names, such as</p><p><strong>localhost red green blue</strong></p><p>distcc prefers hosts towards the start of the list, so machines should be listed in descending order of speed.  In particular, when only a single compilation can be run (such as from a configure script), the first machine listed is used (but see <em>--randomize</em> below).</p><p>Placing <em>localhost</em> at the right point in the list is important to getting good performance.  Because overhead for running jobs locally is low, localhost should normally be first.  However, it is important that the client have enough cycles free to run the local jobs and the distcc client.  If the client is slower than the volunteers, or if there are many volunteers, then the client should be put later in the list or not at all.  As a general rule, if the aggregate CPU speed of the client is less than one fifth of the total, then the client should be left out of the list.</p><p>If you have a large shared build cluster and a single shared hosts file, the above rules would cause the first few machines in the hosts file to be tried first even though they are likely to be busier than machines later in the list.  To avoid this, place the keyword <em>--randomize</em> into the host list.  This will cause the host list to be randomized, which should improve performance slightly for large build clusters.</p><p>There are two special host names <strong>--localslots</strong> and <strong>--localslots_cpp</strong> which are useful for adjusting load on the local machine.  The <strong>--localslots</strong> host specifies how many jobs that cannot be run remotely that can be run concurrently on the local machine, while <strong>--localslots_cpp</strong> controls how many preprocessors will run in parallel on the local machine.  Tuning these values can improve performance.  Linking on large projects can take large amounts of memory.  Running parallel linkers, which cannot be executed remotely,  may force the machine to swap, which reduces performance over just running the jobs in sequence without swapping.   Getting the number of parallel preprocessors just right allows you to use larger parallel factors with make, since the local machine now has some machanism for measuring local resource usage.</p><p>Finally there is the host entry</p><p>Performance depends on the details of the source and makefiles used for the project, and the machine and network speeds.  Experimenting with different settings for the host list and <strong>-j</strong> factor may improve performance.</p><p>The syntax is</p>
<pre>
  DISTCC_HOSTS = HOSTSPEC ...
  HOSTSPEC = LOCAL_HOST | SSH_HOST | TCP_HOST | OLDSTYLE_TCP_HOST
                        | GLOBAL_OPTION
                        | ZEROCONF
  LOCAL_HOST = localhost[/LIMIT]
             | --localslots=&lt;int&gt;
             | --localslots_cpp=&lt;int&gt;
  SSH_HOST = [USER]@HOSTID[/LIMIT][:COMMAND][OPTIONS]
  TCP_HOST = HOSTID[:PORT][/LIMIT][OPTIONS]
  OLDSTYLE_TCP_HOST = HOSTID[/LIMIT][:PORT][OPTIONS]
  HOSTID = HOSTNAME | IPV4 | IPV6
  OPTIONS = ,OPTION[OPTIONS]
  OPTION = lzo | cpp
  GLOBAL_OPTION = --randomize
  ZEROCONF = +zeroconf
</pre>
<p>Here are some individual examples of the syntax:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>localhost</strong></p>
  </dt>
  <dd>
    <p>The literal word "localhost" is interpreted specially to cause compilations to be directly executed, rather than passed to a daemon on the local machine.  If you do want to connect to a daemon on the local machine for testing, then give the machine's IP address or real hostname.  (This will be slower.)</p>
  </dd>
  <dt>
    <p><strong>IPV6</strong></p>
  </dt>
  <dd>
    <p>A literal IPv6 address enclosed in square brackets, such as <strong>[::1]</strong></p>
  </dd>
  <dt>
    <p><strong>IPV4</strong></p>
  </dt>
  <dd>
    <p>A literal IPv4 address, such as <strong>10.0.0.1</strong></p>
  </dd>
  <dt>
    <p><strong>HOSTNAME</strong></p>
  </dt>
  <dd>
    <p>A hostname to be looked up using the resolver.</p>
  </dd>
  <dt>
    <p><strong>:PORT</strong></p>
  </dt>
  <dd>
    <p>Connect to a specified decimal port number, rather than the default of 3632.</p>
  </dd>
  <dt>
    <p><strong>@HOSTID</strong></p>
  </dt>
  <dd>
    <p>Connect to the host over SSH, rather than TCP.  Options for the SSH connection can be set in <strong>~/.ssh/config</strong></p>
  </dd>
  <dt>
    <p><strong>USER@</strong></p>
  </dt>
  <dd>
    <p>Connect to the host over SSH as a specified username.</p>
  </dd>
  <dt>
    <p><strong>:COMMAND</strong></p>
  </dt>
  <dd>
    <p>Connect over SSH, and use a specified path to find the distccd server.  This is normally only needed if for some reason you can't install distccd into a directory on the default PATH for SSH connections.  Use this if you get errors like "distccd: command not found" in SSH mode.</p>
  </dd>
  <dt>
    <p><strong>/LIMIT</strong></p>
  </dt>
  <dd>
    <p>A decimal limit can be added to any host specification to restrict the number of jobs that this client will send to the machine.  The limit defaults to four per host (two for localhost), but may be further restricted by the server.  You should only need to increase this for servers with more than two processors.</p>
  </dd>
  <dt>
    <p><strong>,lzo</strong></p>
  </dt>
  <dd>
    <p>Enables LZO compression for this TCP or SSH host.</p>
  </dd>
  <dt>
    <p><strong>,cpp</strong></p>
  </dt>
  <dd>
    <p>Enables distcc-pump mode for this host.  Note: the build command must be wrapped in the distcc-pump script in order to start the include server.</p>
  </dd>
  <dt>
    <p><strong>--randomize</strong></p>
  </dt>
  <dd>
    <p>Randomize the order of the host list before execution.</p>
  </dd>
  <dt>
    <p><strong>+zeroconf</strong></p>
  </dt>
  <dd>
    <p><strong>This option is only available if distcc was compiled with Avahi support enabled at configure time.</strong> When this special entry is present in the hosts list, distcc will use Avahi Zeroconf DNS Service Discovery (DNS-SD) to locate any available distccd servers on the local network.  This avoids the need to explicitly list the host names or IP addresses of the distcc server machines. The distccd servers must have been started with the "--zeroconf" option to distccd. An important caveat is that in the current implementation, pump mode (",cpp") and compression (",lzo") will never be used for hosts located via zeroconf.</p>
  </dd>

</dl>
<p>Here is an example demonstrating some possibilities:</p>
<pre>
<strong>localhost/2 @bigman/16:/opt/bin/distccd oldmachine:4200/1</strong>
<strong># cartman is down</strong>
<strong>distant/3,lzo</strong>
</pre>
<p>Comments are allowed in host specifications.  Comments start with a hash/pound sign (<strong>#</strong>) and run to the end of the line.</p><p>If a host in the list is not reachable distcc will emit a warning and ignore that host for about one minute.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COMPRESSION</h2>
        <div class="sectioncontent">
<p>The <strong>lzo</strong> host option specifies that LZO compression should be used for data transfer, including preprocessed source, object code and error messages.  Compression is usually economical on networks slower than 100Mbps, but results may vary depending on the network, processors and source tree.</p><p>Enabling compression makes the distcc client and server use more CPU time, but less network traffic.  The added CPU time is insignificant for pump mode.  The compression ratio is typically 4:1 for source and 2:1 for object code.</p><p>Using compression requires both client and server to use at least release 2.9 of distcc.  No server configuration is required: the server always responds with compressed replies to compressed requests.</p><p>Pump mode requires the servers to have the lzo host option on.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SEARCH PATHS</h2>
        <div class="sectioncontent">
<p>If the compiler name is an absolute path, it is passed verbatim to the server and the compiler is run from that directory.  For example:</p><p><strong>distcc /usr/local/bin/gcc-3.1415 -c hello.c</strong></p><p>If the compiler name is not absolute, or not fully qualified, distccd's PATH is searched.  When distcc is run from a masquerade directory, only the base name of the compiler is used.  The client's PATH is used only to run the preprocessor and has no effect on the server's path.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TIMEOUTS</h2>
        <div class="sectioncontent">
<p>Both the distcc client and server impose timeouts on transfer of data across the network.  This is intended to detect hosts which are down or unreachable, and to prevent compiles hanging indefinitely if a server is disconnected while in use.  If a client-side timeout expires, the job will be re-run locally.</p><p>The timeouts are not configurable at present.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DIAGNOSTICS</h2>
        <div class="sectioncontent">
<p>Error messages or warnings from local or remote compilers are passed through to diagnostic output on the client.</p><p>distcc can supply extensive debugging information when the verbose option is used.  This is controlled by the <strong>DISTCC_VERBOSE</strong> environment variable on the client, and the <strong>--verbose</strong> option on the server.  For troubleshooting, examine both the client and server error messages.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXIT CODES</h2>
        <div class="sectioncontent">
<p>The exit code of distcc is normally that of the compiler: zero for successful compilation and non-zero otherwise.</p><p>distcc distinguishes between "genuine" errors such as a syntax error in the source, and "accidental" errors such as a networking problem connecting to a volunteer.  In the case of accidental errors, distcc will retry the compilation locally unless the DISTCC_FALLBACK option has been disabled.</p><p>If the compiler exits with a signal, distcc returns an exit code of 128 plus the signal number.</p><p>distcc internal errors cause an exit code between 100 and 127.  In particular</p>
<dl class='dl-vertical'>
  <dt>
    <p>100</p>
  </dt>
  <dd>
    <p>General distcc failure.</p>
  </dd>
  <dt>
    <p>101</p>
  </dt>
  <dd>
    <p>Bad arguments.</p>
  </dd>
  <dt>
    <p>102</p>
  </dt>
  <dd>
    <p>Bind failed.</p>
  </dd>
  <dt>
    <p>103</p>
  </dt>
  <dd>
    <p>Connect failed.</p>
  </dd>
  <dt>
    <p>104</p>
  </dt>
  <dd>
    <p>Compiler crashed.</p>
  </dd>
  <dt>
    <p>105</p>
  </dt>
  <dd>
    <p>Out of memory.</p>
  </dd>
  <dt>
    <p>106</p>
  </dt>
  <dd>
    <p>Bad Host SPEC</p>
  </dd>
  <dt>
    <p>107</p>
  </dt>
  <dd>
    <p>I/O Error</p>
  </dd>
  <dt>
    <p>108</p>
  </dt>
  <dd>
    <p>Truncated.</p>
  </dd>
  <dt>
    <p>109</p>
  </dt>
  <dd>
    <p>Protocol Error.</p>
  </dd>
  <dt>
    <p>110</p>
  </dt>
  <dd>
    <p>The given compiler was not found on the remote host.  Check that $CC is set appropriately and that it's installed in a directory on the search path for distccd.</p>
  </dd>
  <dt>
    <p>111</p>
  </dt>
  <dd>
    <p>Recursive call to distcc.</p>
  </dd>
  <dt>
    <p>112</p>
  </dt>
  <dd>
    <p>Failed to discard privileges.</p>
  </dd>
  <dt>
    <p>113</p>
  </dt>
  <dd>
    <p>Network access denied.</p>
  </dd>
  <dt>
    <p>114</p>
  </dt>
  <dd>
    <p>In use by another process.</p>
  </dd>
  <dt>
    <p>115</p>
  </dt>
  <dd>
    <p>No such file.</p>
  </dd>
  <dt>
    <p>116</p>
  </dt>
  <dd>
    <p>No hosts defined and fallbacks disabled.</p>
  </dd>
  <dt>
    <p>118</p>
  </dt>
  <dd>
    <p>Timeout.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILES</h2>
        <div class="sectioncontent">
<p>If $DISTCC_HOSTS is not set, distcc reads a host list from either <strong>$DISTCC_DIR/hosts</strong> or a system-wide configuration file set at compile time.  The file locations are shown in the output from <strong>distcc --help</strong></p><p>distcc creates a number of temporary and lock files underneath the temporary directory.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ENVIRONMENT VARIABLES</h2>
        <div class="sectioncontent">
<p>distcc's behaviour is controlled by a number of environment variables. For most cases nothing need be set if the host list is stored in a file.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>DISTCC_HOSTS</strong></p>
  </dt>
  <dd>
    <p>Space-separated list of volunteer host specifications.</p>
  </dd>
  <dt>
    <p><strong>DISTCC_VERBOSE</strong></p>
  </dt>
  <dd>
    <p>If set to 1, distcc produces explanatory messages on the standard error stream or in the log file.  This can be helpful in debugging problems.  Bug reports should include verbose output.</p>
  </dd>
  <dt>
    <p><strong>DISTCC_LOG</strong></p>
  </dt>
  <dd>
    <p>Log file to receive messages from distcc itself, rather than stderr.</p>
  </dd>
  <dt>
    <p><strong>DISTCC_FALLBACK</strong></p>
  </dt>
  <dd>
    <p>By default distcc will compile locally if it fails to distribute a job to the intended machine, or if no host list can be found.  If this variable is set to 0 then fallbacks are disabled and those compilations will simply fail.  Note that this does not affect jobs which must always be local such as linking.</p>
  </dd>
  <dt>
    <p><strong>DISTCC_SAVE_TEMPS</strong></p>
  </dt>
  <dd>
    <p>If set to 1, temporary files are not deleted after use.  Good for debugging, or if your disks are too empty.</p>
  </dd>
  <dt>
    <p><strong>DISTCC_TCP_CORK</strong></p>
  </dt>
  <dd>
    <p>If set to 0, disable use of "TCP corks", even if they're present on this system.  Using corks normally helps pack requests into fewer packets and aids performance.  This should normally be left enabled.</p>
  </dd>
  <dt>
    <p><strong>DISTCC_SSH</strong></p>
  </dt>
  <dd>
    <p>Specifies the command used for opening SSH connections.  Defaults to "ssh" but may be set to a different connection command such as "lsh" or "tsocks-ssh" that accepts a similar command line.  The command is not split into words and is not executed through the shell.</p>
  </dd>
  <dt>
    <p><strong>DISTCC_DIR</strong></p>
  </dt>
  <dd>
    <p>Per-user configuration directory to store lock files and state files. By default <strong>~/.distcc/</strong> is used.</p>
  </dd>
  <dt>
    <p><strong>TMPDIR</strong></p>
  </dt>
  <dd>
    <p>Directory for temporary files such as preprocessor output.  By default /tmp/ is used.</p>
  </dd>
  <dt>
    <p><strong>UNCACHED_ERR_FD</strong></p>
  </dt>
  <dd>
    <p>If set and if DISTCC_LOG is not set, distcc errors are written to the file descriptor identified by this variable.  This variable is intended mainly for automatic use by ccache, which sets it to avoid caching transient errors such as network problems.</p>
  </dd>
  <dt>
    <p><strong>DISTCC_ENABLE_DISCREPANCY_EMAIL</strong></p>
  </dt>
  <dd>
    <p>If set, distcc sends an email when a compilation failed remotely, but succeeded locally.  Built-in heuristics prevent some such discrepancy email from being sent if the problem is that a local file changed between the failing remote compilation and the succeeding local compilation.</p>
  </dd>
  <dt>
    <p><strong>DCC_EMAILLOG_WHOM_TO_BLAME</strong></p>
  </dt>
  <dd>
    <p>The email address for discrepancy email; the default is "distcc-pump-errors".</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CROSS COMPILING</h2>
        <div class="sectioncontent">
<p>Cross compilation means building programs to run on a machine with a different processor, architecture, or operating system to where they were compiled.  distcc supports cross compilation, including teams of mixed-architecture machines, although some changes to the compilation commands may be required.</p><p>The compilation command passed to distcc must be one that will execute properly on every volunteer machine to produce an object file of the appropriate type.  If the machines have different processors, then simply using <strong>distcc cc</strong> will probably not work, because that will normally invoke the volunteer's native compiler.</p><p>Machines with the same CPU but different operating systems may not necessarily generate compatible .o files.</p><p>Several different gcc configurations can be installed side-by-side on any machine.  If you build gcc from source, you should use the <strong>--program-suffix configuration</strong> options to cause it to be installed with a name that encodes the gcc version and the target platform.</p><p>The recommended convention for the gcc name is <em>TARGET-gcc-VERSION</em> such as <strong>i686-linux-gcc-3.2</strong> .  GCC 3.3 will install itself under this name, in addition to <em>TARGET-gcc</em> and, if it's native, <em>gcc-VERSION</em> and <em>gcc</em> .</p><p>The compiler must be installed under the same name on the client and on every volunteer machine.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>If you think you have found a  distcc bug, please see the file <em>reporting-bugs.txt</em> in the documentation directory for information on how to report it.</p><p>Some makefiles have missing or extra dependencies that cause incorrect or slow parallel builds.  Recursive make is inefficient and can leave processors unnecessarily idle for long periods.  (See <em>Recursive Make Considered Harmful</em> by Peter Miller.)  Makefile bugs are the most common cause of trees failing to build under distcc.  Alternatives to Make such as <em>SCons</em> can give much faster builds for some projects.</p><p>Using different versions of gcc can cause confusing build problems because the header files and binary interfaces have changed over time, and some distributors have included incompatible patches without changing the version number.  distcc does not protect against using incompatible versions.  Compiler errors about link problems or declarations in system header files are usually due to mismatched or incorrectly installed compilers.</p><p>gcc's <strong>-MD</strong> option can produce output in the wrong directory if the source and object files are in different directories and the <strong>-MF</strong> option is not used.  There is no perfect solution because of incompatible changes between gcc versions.  Explicitly specifying the dependency output file with <strong>-MF</strong> will fix the problem.</p><p>TCP mode connections should only be used on trusted networks.</p><p>Including slow machines in the list of volunteer hosts can slow the build down.</p><p>When distcc or ccache is used on NFS, the filesystem must be exported with the <strong>no_subtree_check</strong> option to allow reliable renames between directories.</p><p>The compiler can be invoked with a command line <strong>gcc hello.c</strong> to both compile and link.  distcc doesn't split this into separate parts, but rather runs the whole thing locally.</p><p>distcc-pump mode reverts to plain distcc mode for source files that contain includes with absolute paths (either directly or in an included file).</p><p>Due to limitations in gcc, gdb may not be able to automatically find the source files for programs built using distcc in some circumstances.  The gdb <strong>directory</strong> command can be used.  For distcc's plain (non-pump) mode, this is fixed in gcc 3.4 and later.  For pump mode, the fix in gcc 3.4 does not suffice; we've worked around the gcc limitation by rewriting the object files that gcc produces, but this is only done for ELF object files, but not for other object file formats.</p><p>The .o files produced by discc in pump mode will be different from those produced locally: for non-ELF files, the debug information will specify compile directories of the server.  The code itself should be identical.</p><p>For the ELF-format, distcc rewrites the .o files to correct compile directory path information.  While the resulting .o files are not bytewise identical to what would have been produced by compiling on the local client (due to different padding, etc), they should be functionally identical.</p><p>In distcc-pump mode, the include server is unable to handle certain very complicated computed includes as found in parts of the Boost library. The include server will time out and distcc will revert to plain mode.</p><p>In distcc-pump mode, certain assumptions are made that source and header files do not change during the build.  See discussion in section DISTCC DISCREPANCY SYMPTOMS of <strong>include_server</strong>(1().</p><p>Other known bugs may be documented on <em>http://code.google.com/p/distcc/</em></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>distcc was written by Martin Pool &lt;mbp@sourcefrog.net&gt;, with the co-operation of many scholars including Wayne Davison, Frerich Raabe, Dimitri Papadopoulos and others noted in the NEWS file.  Please report bugs to &lt;distcc@lists.samba.org&gt;.  See <a href="../man1/distcc-pump.1.html"><strong>distcc-pump</strong>(1)</a> for the authors of pump mode.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LICENCE</h2>
        <div class="sectioncontent">
<p>You are free to use distcc.  distcc (including this manual) may be copied, modified or distributed only under the terms of the GNU General Public Licence version 2 or later.  distcc comes with absolutely no warrany.  A copy of the GPL is included in the file COPYING.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO distcc&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man1/distccd.1.html"><strong>distccd</strong>(1)</a>, <a href="../man1/distcc-pump.1.html"><strong>distcc-pump</strong>(1)</a>, <a href="../man1/include_server.1.html"><strong>include_server</strong>(1)</a>, <strong>gcc</strong>(1), <a href="../man1/make.1.html"><strong>make</strong>(1)</a>, and  <a href="../man1/ccache.1.html"><strong>ccache</strong>(1)</a>. <em>http://code.google.com/p/distcc/</em> <em>http://ccache.samba.org/</em></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="dissy.1.html"><span aria-hidden="true">&larr;</span> dissy.1: Graphical frontend for objdump</a></li>
   <li class="next"><a href="distcc-pump.1.html">distcc-pump.1: Accelerate remote compilation with distcc <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

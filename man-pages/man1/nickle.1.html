<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>nickle: A desk calculator language</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="A desk calculator language">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="nickle (1) manual">
  <meta name="twitter:description" content="A desk calculator language">
  <meta name="twitter:image" content="https://www.carta.tech/images/nickle-nickle-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/nickle.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="nickle (1) manual" />
  <meta property="og:description" content="A desk calculator language" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/nickle-nickle-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">nickle<small> (1)</small></h1>
        <p class="lead">A desk calculator language</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/nickle.1.html">
      <span itemprop="name">nickle: A desk calculator language</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/nickle/">
      <span itemprop="name">nickle</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/nickle.1.html">
      <span itemprop="name">nickle: A desk calculator language</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>nickle [--help|--usage] [-f file] [-l library] [-e expr] [ script ] [--] [arg ...]</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><em>Nickle</em> is a desk calculator language with powerful programming and scripting capabilities. Nickle supports a variety of datatypes, especially arbitrary precision integers, rationals, and imprecise reals. The input language vaguely resembles C.  Some things in C which do not translate easily are different, some design choices have been made differently, and a very few features are simply missing.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">USAGE</h2>
        <div class="sectioncontent">
<p>An un-flagged argument is treated as a Nickle script, and replaces standard input.  Any remaining arguments following the script are placed in the Nickle string array argv for programmatic inspection.  When invoked without an expression or script argument, Nickle reads from standard input, and writes to standard output.</p><p>Options are as follows:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--help,--usage</strong></p>
  </dt>
  <dd>
    <p>Print a help/usage message and exit.  This is a built-in feature of Nickle's ParseArgs module, and thus will also be true of Nickle scripts that use this library.</p>
  </dd>
  <dt>
    <p><strong>-f,--file </strong><em>file</em></p>
  </dt>
  <dd>
    <p>Load <em>file</em> into Nickle before beginning execution.</p>
  </dd>
  <dt>
    <p><strong>-l,--library </strong><em>library</em></p>
  </dt>
  <dd>
    <p>Load <em>library</em> into Nickle before beginning execution. See below for a description of the library facility.</p>
  </dd>
  <dt>
    <p><strong>-e,--expr </strong><em>expr</em></p>
  </dt>
  <dd>
    <p>Evaluate <em>expr</em> before beginning execution.</p>
  </dd>
  <dt>
    <p><strong>--</strong></p>
  </dt>
  <dd>
    <p>Quit parsing arguments and pass the remainder, unevaluated, to <em>argv</em>.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNTAX</h2>
        <div class="sectioncontent">
<p>To make the input language more useful in an interactive setting, <strong>newline</strong> only terminates statements at ``reasonable'' times.  <strong>Newline</strong> terminates either expressions or single statements typed by the user (with the exception of a few statements which require lookahead: notably if() and twixt(), which have an optional else part). Inside compound statements or function definitions, only a <strong>;</strong> terminates statements.  This approach is convenient and does not appear to cause problems in normal use.</p><p>The syntax of Nickle programs is as follows. In this description, <strong>name</strong> denotes any sequence of letters, digits and _ characters not starting with a digit; <strong>E</strong> denotes any expression; <strong>S</strong> denotes any statement; and <strong>T</strong> denotes any type. The syntax <strong>X,X,...,X</strong> denotes one or more comma-separated Xs, unless otherwise indicated.</p><p><strong>Comments:</strong></p><p>C-style comments are enclosed in /* and */, and shell-style comments are denoted by a leading # at the start of a line.</p><p><strong>Operands:</strong></p>
<dl class='dl-vertical'>
  <dt>
    real number
  </dt>
  <dd>
    <p>Can include exponent, need not include decimal point or sign. Will be treated as exact rationals. If a trailing decimal part contains an opening curly brace, the brace is silently ignored; if it contains a curly-bracketed trailing portion, it is treated as a repeating decimal. `Floating point'' constants are currently represented internally as rationals: for floating constants with a given precision (and an infinite-precision exponent), use the imprecise() builtin function described below.</p>
  </dd>
  <dt>
    octal number
  </dt>
  <dd>
    <p>Start with a 0 (e.g., 014 is the same as 12).</p>
  </dd>
  <dt>
    hexidecimal number
  </dt>
  <dd>
    <p>Start with "0x" (e.g., 0x1a is the same as 26).</p>
  </dd>
  <dt>
    string
  </dt>
  <dd>
    <p>As in C.  String constants are surrounded by double-quotes.  Backslashed characters (including double-quotes) stand for themselves, except "&#92;n" stands for newline, "&#92;r" for carriage return, "&#92;b" for backspace, "&#92;t" for tab and "&#92;f" for formfeed.</p>
  </dd>
  <dt>
    name
  </dt>
  <dd>
    <p>A variable reference.</p>
  </dd>
  <dt>
    name() name(E,E,...,E)
  </dt>
  <dd>
    <p>A function call with zero or more arguments. Functions are fully call-by-value: arrays and structures are copied rather than being referenced as in C.</p>
  </dd>
  <dt>
    desc name  T name = value
  </dt>
  <dd>
    <p>Definition expressions: a new name is made available, with the value of the definition being the value of the initializer in the second form, and uninitialized in the first form.  The descriptor desc is not optional: it consists of any combination of visibility, storage class or type (in that order). See QUALIFIERS immediately below for a description of these qualifiers. A structured value expression is also possible: see VALUES below.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>In addition to being able to initialize a definition with a Nickle value, C-style array, structure, and union definitions are also allowed: For example, the following</p>
<pre>
  int[*,*] name = {{0,1},{2,3}}
  int[2,2] name = {{0...}...}
</pre>
<p>are permitted with the obvious semantics.  This is the context in which the dimensions in a type may be expressions: see the discussion of array types above.  See the discussion of array and structure values for array and structure initializer syntax.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">QUALIFIERS</h2>
        <div class="sectioncontent">
<p>A declaration or definition may be qualified, as in C, to indicate details of programmatic behavior. Unlike in C, these qualifiers, while optional, must appear in the given order.</p><p><strong>Visibility:</strong></p>
<dl class='dl-vertical'>
  <dt>
    public
  </dt>
  <dd>
    <p>Any definition expression (function definition, variable definition, type definition) can be qualified with public to indicate that the name being defined should be visible outside the current namespace, and should be automatically imported.  See Namespaces below for further info.</p>
  </dd>
  <dt>
    protected
  </dt>
  <dd>
    <p>Any definition expression (function definition, variable definition, type definition) can be qualified with protected to indicate that the name being defined should be visible outside the current namespace, but should not be made available by import declarations.  See Namespaces below for further info.</p>
  </dd>

</dl>
<p><strong>Lifetime:</strong></p>
<dl class='dl-vertical'>
  <dt>
    auto
  </dt>
  <dd>
    <p>An auto object is local to a particular block: its lifetime is at least the lifetime of that block. An auto object with an initializer will be re-initialized each time it is evaluated. This is the default lifetime for local objects.</p>
  </dd>
  <dt>
    static
  </dt>
  <dd>
    <p>A static object is local to a particular function definition: its lifetime is at least the lifetime of that definition. A new static object will be created each time its enclosing function definition is evaluated.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>In Nickle, the keyword static has to do only with lifetime (like the use of static inside C functions), not with visibility (which is handled by separate qualifiers as described above, not like the use of static in global scope in C).</p>
  </dd>
  <dt>
    global
  </dt>
  <dd>
    <p>A global object is global to the entire program: its lifetime is the lifetime of the program.  A global object will be created and initialized when its definition is first seen.  This is the default lifetime for global objects.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>The distinction between static and global lifetime in Nickle is not possible in C, because C functions are not first class objects with nested scope.  When deciding which to use in a Nickle program, think about what should happen if a definition is re-evaluated.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPERATORS</h2>
        <div class="sectioncontent">
<p>Here are the basic Nickle operators, grouped in order of decreasing precedence:</p>
<dl class='dl-vertical'>
  <dt>
    A[E,E,...,E]
  </dt>
  <dd>
    <p>Refers to the E'th element of the array expression A, or the E1'th/E2'th/etc element of a multi-dimensional array. Both arrays of arrays ala C and multidimensional arrays ala NAWK are possible.</p>
  </dd>
  <dt>
    struct.tag
  </dt>
  <dd>
    <p>Structure dereference.</p>
  </dd>
  <dt>
    struct-&gt;tag
  </dt>
  <dd>
    <p>Structure pointer dereference ala C.</p>
  </dd>
  <dt>
    =============
  </dt>
  <dd>
    
  </dd>
  <dt>
    ++ --
  </dt>
  <dd>
    <p>Unary increment/decrement. May be either postfix or prefix.</p>
  </dd>
  <dt>
    -
  </dt>
  <dd>
    <p>Unary negate</p>
  </dd>
  <dt>
    ! E
  </dt>
  <dd>
    <p>Logical negation.</p>
  </dd>
  <dt>
    E !
  </dt>
  <dd>
    <p>Factorial.  Requires a non-negative integer argument.</p>
  </dd>
  <dt>
    * E
  </dt>
  <dd>
    <p>Pointer dereference.</p>
  </dd>
  <dt>
    & E
  </dt>
  <dd>
    <p>Reference construction.</p>
  </dd>
  <dt>
    =============
  </dt>
  <dd>
    
  </dd>
  <dt>
    (U) E
  </dt>
  <dd>
    <p>Construct a value of union type with tag U and value E.</p>
  </dd>
  <dt>
    =============
  </dt>
  <dd>
    
  </dd>
  <dt>
    **
  </dt>
  <dd>
    <p>Exponentiation. Both operands may be fractional. The left operand must be non-negative unless the right operand is integer.  The result type is the type of the left operand if the right operand is integer, and real otherwise.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>This is the only known type-unsound feature of Nickle: an expression like 2 ** -3 will statically be of type integer, but dynamically will generate a rational result.  This may cause a runtime type error later on: consider</p>
<pre>
  int x = 2 ** -3;
</pre>

  </dd>
  <dt>
    =============
  </dt>
  <dd>
    
  </dd>
  <dt>
    * / // %
  </dt>
  <dd>
    <p>Times, divide, integer divide, and remainder. The right operand of the last three operators must be nonzero. The result type of the division operator will always be at least rational: the result type of the integer division operator will always be int.  This is a notable departure from C, where integer division is implied by integer operands. Integer division is defined by</p>
<pre>
  x // y == y &gt; 0 ? floor (x / y) : ceil(x / y)
</pre>
<p>The remainder is always non-negative and is defined by: by</p>
<pre>
  x % y = x - (x // y) * y
</pre>

  </dd>
  <dt>
    =============
  </dt>
  <dd>
    
  </dd>
  <dt>
    + -
  </dt>
  <dd>
    <p>Addition and subtraction.</p>
  </dd>
  <dt>
    =============
  </dt>
  <dd>
    
  </dd>
  <dt>
    &lt;&lt; &gt;&gt;
  </dt>
  <dd>
    <p>Bitwise left and right shift with integer operands.  Negative right operands work as expected.  These operators are defined by</p>
<pre>
  x &lt;&lt; y = x * 2 ** y
</pre>

<pre>
  x &gt;&gt; y = x // 2 ** y
</pre>
<p>Another way to look at this is that negative left operands are considered to be in an infinite twos-complement representation (i.e., sign-extended to infinity), with right shift sign-extending its left operand.</p>
  </dd>
  <dt>
    =============
  </dt>
  <dd>
    
  </dd>
  <dt>
    &lt;= &gt;= &lt; &gt;
  </dt>
  <dd>
    <p>Relational operators.</p>
  </dd>
  <dt>
    =============
  </dt>
  <dd>
    
  </dd>
  <dt>
    == !=
  </dt>
  <dd>
    <p>Equality operators.</p>
  </dd>
  <dt>
    =============
  </dt>
  <dd>
    <p>Finally, in order of decreasing precedence:</p>
  </dd>
  <dt>
    &
  </dt>
  <dd>
    <p>Bitwise AND.  Negative operands are considered to be in an infinite twos-complement representation (i.e., sign-extended to infinity).</p>
  </dd>
  <dt>
    ^
  </dt>
  <dd>
    <p>Bitwise XOR.  Negative operands as in bitwise AND.</p>
  </dd>
  <dt>
    |
  </dt>
  <dd>
    <p>Bitwise OR.  Negative operands as in bitwise AND.</p>
  </dd>
  <dt>
    &&
  </dt>
  <dd>
    <p>Short-circuit logical AND.</p>
  </dd>
  <dt>
    ||
  </dt>
  <dd>
    <p>Short-circuit logical OR.</p>
  </dd>
  <dt>
    E ? E : E
  </dt>
  <dd>
    <p>Conditional expression: if first expression is logical true, value is second expression, else third.</p>
  </dd>
  <dt>
    fork E
  </dt>
  <dd>
    <p>Create (and return) a thread.  See Thread below for details.</p>
  </dd>
  <dt>
    = += -= *= /= //= %= **= &lt;&lt;= &gt;&gt;= ^= &= |=
  </dt>
  <dd>
    <p>Assignment operators.  Left-hand-side must be assignable. <strong>x </strong><em>&lt;op&gt;=</em><strong> y</strong> is equivalent to <strong>x </strong><em>=</em><strong> x </strong><em>&lt;op&gt;</em><strong> y</strong></p>
  </dd>
  <dt>
    E , E
  </dt>
  <dd>
    <p>Returns right-hand expression.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TYPES</h2>
        <div class="sectioncontent">
<p>The type declaration syntax of Nickle more strongly resembles the ``left'' variant of the Java syntax than the C syntax. Essentially, a type consists of:</p>
<dl class='dl-vertical'>
  <dt>
    poly integer rational real string continuation void
  </dt>
  <dd>
    <p>A base type of the language.  Type void is actually only usable in certain contexts, notably function returns. It is currently implemented as a ``unit'' type ala ML, and thus has slightly different behavior than in C. Type poly is the supertype of all other types (i.e., it can be used to inhibit static type checking), and is the default type in most situations where a type need not appear.</p>
  </dd>
  <dt>
    file semaphore thread
  </dt>
  <dd>
    <p>Also builtin base types, but integral to the File and Thread ADTs: see below.</p>
  </dd>

</dl>
<p><strong>More About Types:</strong></p><p><em>Nickle</em> supports polymorphic data: As an expresion is evaluated, a data type is chosen to fit the result.  Any Nickle object may be statically typed, in which case bounds violations will be flagged as errors at compile time. Polymorphic variables and functions do not place restrictions on the assigned data type; this is the default type for all objects.</p>
<dl class='dl-vertical'>
  <dt>
    poly
  </dt>
  <dd>
    <p>This describes the union of all datatypes.  A variable with this type can contain any data value.</p>
  </dd>
  <dt>
    int
  </dt>
  <dd>
    <p>Arbitrary precision integers.</p>
  </dd>
  <dt>
    rational
  </dt>
  <dd>
    <p>Arbitrary precision rational numbers.</p>
  </dd>
  <dt>
    real
  </dt>
  <dd>
    <p>Arbitrary exponent precision floating point numbers.  As many computations cannot be carried out exactly as rational numbers, Nickle implements non-precise arithmetic using its own machine-independent representation for floating point numbers.  The builtin function imprecise(n) generates a real number with 256 bits of precision from the number n, while imprecise(n,p) generates a real number with p bits of precision.</p>
  </dd>
  <dt>
    T[]
  </dt>
  <dd>
    <p>An array of type T, of one or more dimensions.  There are no zero-dimensional arrays in Nickle.</p>
  </dd>
  <dt>
    T[*]
  </dt>
  <dd>
    <p>A one-dimensional array of type T.  Unlike in C, the dimension of an array is never part of its type in Nickle.  Further, arrays and pointers are unrelated types in Nickle.</p>
  </dd>
  <dt>
    T[*,*,...,*]
  </dt>
  <dd>
    <p>A two or more dimensional array of type T.  The stars ``*'' are not optional.  As the previous paragraphs make clear, ``T[]'' is not a zero-dimensional array.</p>
  </dd>
  <dt>
    T[E,E,...,E]
  </dt>
  <dd>
    <p>In definition contexts, integer values may be given for each dimension of an array context.  These are strictly for value-creation purposes, and are not part of the type. An array type is determined only by the base type and number of dimensions of the array.</p>
  </dd>
  <dt>
    T0() T0(T,T,...,T)
  </dt>
  <dd>
    <p>A function returning type T0.  A function accepts 0 or more arguments.</p>
  </dd>
  <dt>
    T0() T0(T,T,...,T <strong>...</strong>)
  </dt>
  <dd>
    <p>A function accepting zero or more required arguments, plus an arbitrary number of optional arguments.  The second sequence of three dots (ellipsis) is syntax, not metasyntax: see the description of varargs functions for details.</p>
  </dd>
  <dt>
    *T
  </dt>
  <dd>
    <p>A pointer to a location of type T. Pointer arithmetic in Nickle operates only upon pointers to arrays: the pointer must be of the correct type, and may never stray out of bounds.  A pointer may either point to some location or be null (0).  As in C, the precedence of ``*'' is lower than the precedence of ``[]'' or ``()'': use parenthesis as needed.</p>
  </dd>
  <dt>
    struct {T name; T name; ...}
  </dt>
  <dd>
    <p>A structure with fields of the given name and type. The types T are optional: in their absence, the type of the field is poly.</p>
  </dd>
  <dt>
    union {T name; T name; ...}
  </dt>
  <dd>
    <p>A ``disjoint union'' of the given types.  This is more like the variant record type of Pascal or the datatype of ML than the C union type: the names are tags of the given type, exactly one of which applies to a given value at a given time.</p>
  </dd>
  <dt>
    (T)
  </dt>
  <dd>
    <p>Parentheses for grouping.</p>
  </dd>

</dl>
<p><strong>Typedef:</strong></p><p>As in C, new type names may be created with the typedef statement.  The syntax is</p>
<pre>
  typedef T typename;
</pre>
<p>where T is a Nickle type.  The resulting typename may be used anywhere a type is expected.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">VALUES</h2>
        <div class="sectioncontent">
<p>Values of the base types of Nickle are as expected. See the syntax for constants above.  Values of type file, semaphore, and continuation may currently be created only by calls to builtin functions: no Nickle constants of these types exist.</p><p>As noted in TYPES above, Nickle has several kinds of ``structured value'': arrays, functions, pointers, structures and disjoint unions. All of these have some common properties. When created, all of the component values are uninitialized (unless otherwise specified).  Attempts to use an uninitialized value will result in either a compile-time error or a runtime exception.</p><p><strong>Arrays:</strong></p>
<dl class='dl-vertical'>
  <dt>
    [E]
  </dt>
  <dd>
    <p>creates a (zero-based) array with E elements. E must be non-negative.</p>
  </dd>
  <dt>
    [E]{V,V,...,V}
  </dt>
  <dd>
    <p>Creates an array with E elements, initialized to the Vs.  If there are too few initializers, remaining elements will remain uninitialized.</p>
  </dd>
  <dt>
    [E]{V,V,...,V<em>...</em>}
  </dt>
  <dd>
    <p>The second ellipsis (three dots) is syntax, not metasyntax.  Create an array with E elements.  The first elements in the array will be initialized according to the Vs, with any remaining elements receiving the same value as the last V.  This syntax may be used in the obvious fashion with any of the array initializers below.</p>
  </dd>
  <dt>
    [*]{V,V,...,V}
  </dt>
  <dd>
    <p>Creates an initialized array with exactly as many elements as initializers.  There must be at least one initializer.</p>
  </dd>
  <dt>
    [E,E,...,E] [*,*,...,*]
  </dt>
  <dd>
    <p>Creates multidimensional arrays. Integer expressions  and "*" cannot be mixed: an array's dimensions are entirely either specified or unspecified by the definition.  These arrays may also be created initialized: see next paragraph for initializer syntax.</p>
  </dd>
  <dt>
    (T[E]) (T[E,E,...,E]) (T[E]){E,E,...,E}
  </dt>
  <dd>
    
  </dd>
  <dt>
    (T[E,E,...,E]){{E,...},...,{E,...}}
  </dt>
  <dd>
    <p>Alternate syntax for creating arrays of type T. The initializers, in curly braces, are optional. The number of initializers must be less than or equal to the given number of elements in each dimension. For multidimensional arrays, the extra curly braces per dimension in the initializer are required; this is unlike C, where they are optional.</p>
  </dd>
  <dt>
    (T[*]){E,E,...,E} (T[*,*,...,*]){{E,...},...,{E,...}}
  </dt>
  <dd>
    <p>Creates arrays of type T, with each dimension's size given by the maximum number of initializers in any subarray in that dimension.</p>
  </dd>

</dl>
<p><strong>Pointers:</strong></p>
<dl class='dl-vertical'>
  <dt>
    0
  </dt>
  <dd>
    <p>The null pointer, in contexts where a pointer is required.</p>
  </dd>
  <dt>
    &V &A[E,E,...,E] &S.N
  </dt>
  <dd>
    <p>Creates a pointer to the given variable, array element, or structure member.  The type of the pointer will be *T, where T is the type of the object pointed to.</p>
  </dd>
  <dt>
    *P
  </dt>
  <dd>
    <p>The value pointed to by pointer P.  This can be viewed or modified as in C.</p>
  </dd>

</dl>
<p><strong>Functions:</strong></p>
<dl class='dl-vertical'>
  <dt>
    (T func(){S;S;...S;}) (T func(T name,T name,...T name){S;S;...S;})
  </dt>
  <dd>
    <p>Function expression: denotes a function of zero or more formal parameters with the given types and names, returning the given result type.  The function body is given by the curly-brace-enclosed statement list.  All types are optional, and default to poly.  As noted above, functions are strictly call-by-value: in particular, arrays and structures are copied rather than referenced.</p>
  </dd>
  <dt>
    T function name(T name,T name,...,T name){S;S;...S;}
  </dt>
  <dd>
    <p>Defines a function of zero or more arguments.  Syntactic sugar for</p>
<pre>
  T(T,T,...T) name = (T func(T name,T name,...T name){S;S;...S;});
</pre>

  </dd>
  <dt>
    T function name(T name, T name <strong>...</strong>)
  </dt>
  <dd>
    <p>The ellipsis here is syntax, not metasyntax: if the last formal argument to a function is followed by three dots, the function may be called with more actuals than formals.  All ``extra'' actuals are packaged into the array formal of the given name, and typechecked against the optional type T of the last argument (default poly).</p>
  </dd>

</dl>
<p><strong>Structures:</strong></p>
<dl class='dl-vertical'>
  <dt>
    (struct { T name; T name; ...T name; }){name = E; name = E; ...name=E;}
  </dt>
  <dd>
    <p>Create a value of a structured type. The named fields are initialized to the given values, with the remainder uninitialized.  As indicated, initialization is by label rather than positional as in C.</p>
  </dd>

</dl>
<p><strong>Unions:</strong></p>
<dl class='dl-vertical'>
  <dt>
    (union { T name; T name; ...T name; }.name) E
  </dt>
  <dd>
    <p>Create a value of the given union type, the variant given by .name, and the value given by E. E must be type-compatible with name.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">STATEMENTS</h2>
        <div class="sectioncontent">
<p>The statement syntax very closely resembles that of C.  Some additional syntax has been added to support Nickle's additional functionality.</p>
<dl class='dl-vertical'>
  <dt>
    E;
  </dt>
  <dd>
    <p>Evaluates the expression.</p>
  </dd>
  <dt>
    {S ... S}
  </dt>
  <dd>
    <p>Executes the enclosed statements in order.</p>
  </dd>
  <dt>
    if (E) S
  </dt>
  <dd>
    <p>Basic conditional.</p>
  </dd>
  <dt>
    if (E) S
  </dt>
  <dd>
    <p>Conditional execution.</p>
  </dd>
  <dt>
    else S
  </dt>
  <dd>
    <p>Else is allowed, with the usual syntax and semantics. In particular, an else binds to the most recent applicable if() or twixt().</p>
  </dd>
  <dt>
    while (E) S
  </dt>
  <dd>
    <p>C-style while loop.</p>
  </dd>
  <dt>
    do S while (E);
  </dt>
  <dd>
    <p>C-style do loop.</p>
  </dd>
  <dt>
    for (opt-E; opt-E; opt-E) S
  </dt>
  <dd>
    <p>C-style for loop.</p>
  </dd>
  <dt>
    switch (E) { case E: S-list  case E: S-list ... default: S-list }
  </dt>
  <dd>
    <p>C-style case statement.  The case expressions are not required to be constant expressions, but may be arbitrary.  The first case evaluating to the switch argument is taken, else the default if present, else the switch body is skipped.</p>
  </dd>
  <dt>
    twixt(opt-E; opt-E) S
  </dt>
  <dd>
    
  </dd>
  <dt>
    twixt(opt-E; opt-E) S else S
  </dt>
  <dd>
    <p>If first argument expression evaluates to true, the body of the twixt() and then the second argument expression will be evaluated.  If the first argument expression evaluates to false, the else statement will be executed if present.  Otherwise, the entire twixt() statement will be skipped.</p>
  </dd>

</dl>
<p>The twixt() statement guarantees that all of these events will happen in the specified order regardless of the manner in which the twixt() is entered (from outside) or exited, including exceptions, continuations, and break.  (Compare with Java's ``finally'' clause.)</p>
<dl class='dl-vertical'>
  <dt>
    try S;
  </dt>
  <dd>
    
  </dd>
  <dt>
    try S catch name (T name, ...) { S; ... };
  </dt>
  <dd>
    
  </dd>
  <dt>
    try S catch name (T name, ...) { S; ... } ... ;
  </dt>
  <dd>
    <p>Execute the first statement S.  If an exception is raised during execution, and the name matches the name in a catch block, bind the formal parameters in the catch block to the actual parameters of the exception, and execute the body of the catch block.  There may be multiple catch blocks per try.  Zero catches, while legal, is relatively useless.  After completion of a catch block, execution continues after the try clause. As with else, a catch binds to the most recent applicable try-catch block.</p>
  </dd>
  <dt>
    raise name(name, name, ..., name)
  </dt>
  <dd>
    <p>Raise the named exception with zero or more arguments.</p>
  </dd>
  <dt>
    ;
  </dt>
  <dd>
    <p>The null statement</p>
  </dd>
  <dt>
    break;
  </dt>
  <dd>
    <p>Discontinue execution of the nearest enclosing for/do/while/switch/twixt statement.  The leave expression will be executed as the twixt statement is exited.</p>
  </dd>
  <dt>
    continue;
  </dt>
  <dd>
    <p>Branch directly to the conditional test of the nearest enclosing for/do/while statement.</p>
  </dd>
  <dt>
    return E;
  </dt>
  <dd>
    <p>Return value E from the nearest enclosing function.</p>
  </dd>

</dl>
<p><strong>Namespaces:</strong></p><p>Like Java and C++ Nickle has a notion of <em>namespace</em>, a collection of names with partially restricted visibility.  In Nickle, namespaces are created with the <em>namespace</em> command.</p>
<dl class='dl-vertical'>
  <dt>
    opt-P namespace N { S ... }
  </dt>
  <dd>
    <p>Places all names defined in the statements S into a namespace named N.  The optional qualifier P may be the keyword public, but beware: this merely indicates that the name N itself is visible elsewhere in the current scope, and has nothing to do with the visibility of items inside the namespace.</p>
  </dd>
  <dt>
    extend namespace N { S ... }
  </dt>
  <dd>
    <p>Reopen the given namespace N, and extend it with the names defined as public in the given statements S.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>Names defined inside the namespace are invisible outside the namespace unless they are qualified with the keyword public.  Public names may be referred to using a path notation:</p>
<pre>
  namespace::namespace::...::namespace::name
</pre>
<p>refers to the given name as defined inside the given set of namespaces.  The double-colon syntax is unfortunate, as it is slightly different in meaning than in C++, but all the good symbols were taken, and it is believed to be a feature that the namespace separator is syntactically different than the structure operator. In Java, for example, the phrase</p>
<pre>
  name.name.name
</pre>
<p>is syntactically ambiguous: the middle name may be either a structure or a namespace.</p>
  </dd>
  <dt>
    import N;
  </dt>
  <dd>
    <p>The name N must refer to a namespace: all public names in this namespace are brought into the current scope (scoping out conflicting names).</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUILTINS</h2>
        <div class="sectioncontent">
<p><em>Nickle</em> has a collection of standard functions built in. Some of these are written in C, but many are written in Nickle. Several collections of functions have associated builtin datatypes: their namespaces, together with their types, should be viewed as ADTs.</p><p><strong>Top-Level Builtins:</strong></p>
<dl class='dl-vertical'>
  <dt>
    int printf(string fmt, poly args...)
  </dt>
  <dd>
    <p>Calls File::fprintf(stdout, fmt, args ...) and returns its result.</p>
  </dd>
  <dt>
    string function gets ()
  </dt>
  <dd>
    <p>Calls File::fgets(stdin) and returns its result.</p>
  </dd>
  <dt>
    string function scanf (string fmt, *poly args...)
  </dt>
  <dd>
    <p>Calls File::vfscanf(stdin, fmt, args) and returns its result.</p>
  </dd>
  <dt>
    string function vscanf (string fmt, (*poly)[*] args)
  </dt>
  <dd>
    <p>Calls File::vfscanf(stdin, fmt, args) and returns its result.</p>
  </dd>
  <dt>
    real imprecise(rational value)
  </dt>
  <dd>
    <p>See the discussion of type real above.</p>
  </dd>
  <dt>
    real imprecise(rational value, int prec)
  </dt>
  <dd>
    <p>See the discussion of type real above.</p>
  </dd>
  <dt>
    int string_to_integer(string s)
  </dt>
  <dd>
    
  </dd>
  <dt>
    int atoi(string s)
  </dt>
  <dd>
    <p>The argument s is a signed digit string, and the result is the integer it represents. If the string s is syntactically a hexadecimal, octal, binary, or explicit base-10 constant, treat it as such.</p>
  </dd>
  <dt>
    int string_to_integer(string s, int base)
  </dt>
  <dd>
    
  </dd>
  <dt>
    int atoi(string s, int base)
  </dt>
  <dd>
    <p>Treat s as a string of digits in the given base. A base of 0 acts as with no base argument. Otherwise, base specification syntax in the string is ignored.</p>
  </dd>
  <dt>
    int putchar(int c)
  </dt>
  <dd>
    <p>Place the given character on the standard output using File::putc(c, stdout), and return its result.</p>
  </dd>
  <dt>
    int sleep(int msecs)
  </dt>
  <dd>
    <p>Try to suspend the current thread for at least msecs milliseconds. Return 1 on early return, and 0 otherwise.</p>
  </dd>
  <dt>
    int exit(int status)
  </dt>
  <dd>
    <p>Exit Nickle with the given status code.  Do not return anything.</p>
  </dd>
  <dt>
    int dim(poly[*] a)
  </dt>
  <dd>
    <p>Given a one-dimensional array a, dim() returns the number of elements of a.</p>
  </dd>
  <dt>
    int[] dims(poly[] a)
  </dt>
  <dd>
    <p>Given an arbitrary array a, dims() returns an array of integers giving the size of each dimension of a. Thus, dim(dims(a)) is the number of dimensions of a.</p>
  </dd>
  <dt>
    *poly reference(poly v)
  </dt>
  <dd>
    <p>Given an arbitrary value v, ``box'' that value into storage and return a pointer to the box.</p>
  </dd>
  <dt>
    rational string_to_real(string s)
  </dt>
  <dd>
    
  </dd>
  <dt>
    rational atof(string s)
  </dt>
  <dd>
    <p>Convert the real constant string s into its associated real number.</p>
  </dd>
  <dt>
    number abs(real v)
  </dt>
  <dd>
    <p>Return the absolute value of v.  The result type chosen will match the given context.</p>
  </dd>
  <dt>
    int floor(real v)
  </dt>
  <dd>
    <p>Return the largest integer less than or equal to v. This will fail if v is a real and the precision is too low.</p>
  </dd>
  <dt>
    int ceil(real v)
  </dt>
  <dd>
    <p>Return the smallest integer greater than or equal to v. This will fail if v is a real and the precision is too low.</p>
  </dd>
  <dt>
    int exponent(real v)
  </dt>
  <dd>
    <p>Return the exponent of the imprecise real v.</p>
  </dd>
  <dt>
    rational mantissa(real v)
  </dt>
  <dd>
    <p>Return the mantissa of the imprecise real v, as a rational m with 0 &lt;= m &lt;= 0.5 .</p>
  </dd>
  <dt>
    int numerator(rational v)
  </dt>
  <dd>
    <p>Return the numerator of the rational number v: i.e., if v = n/d in reduced form, return n.</p>
  </dd>
  <dt>
    int denominator(rational v)
  </dt>
  <dd>
    <p>Return the denominator of the rational number v: i.e., if v = n/d in reduced form, return d.</p>
  </dd>
  <dt>
    int precision(real v)
  </dt>
  <dd>
    <p>Return the number of bits of precision of the mantissa of the imprecise real number v.</p>
  </dd>
  <dt>
    int sign(real v)
  </dt>
  <dd>
    <p>Return -1 or 1 as v is negative or nonnegative.</p>
  </dd>
  <dt>
    int bit_width(int v)
  </dt>
  <dd>
    <p>Return the number of bits required to represent abs(v) internally.</p>
  </dd>
  <dt>
    int is_int(poly v)
  </dt>
  <dd>
    <p>Type predicate.</p>
  </dd>
  <dt>
    int is_rational(poly v)
  </dt>
  <dd>
    <p>Numeric type predicates are inclusive: e.g., <strong>is_rational</strong>(1) returns 1.</p>
  </dd>
  <dt>
    int is_number(poly v)
  </dt>
  <dd>
    <p>Type predicate.</p>
  </dd>
  <dt>
    int is_string(poly v)
  </dt>
  <dd>
    <p>Type predicate.</p>
  </dd>
  <dt>
    int is_file(poly v)
  </dt>
  <dd>
    <p>Type predicate.</p>
  </dd>
  <dt>
    int is_thread(poly v)
  </dt>
  <dd>
    <p>Type predicate.</p>
  </dd>
  <dt>
    int is_semaphore(poly v)
  </dt>
  <dd>
    <p>Type predicate.</p>
  </dd>
  <dt>
    int is_continuation(poly v)
  </dt>
  <dd>
    <p>Type predicate.</p>
  </dd>
  <dt>
    int is_array(poly v)
  </dt>
  <dd>
    <p>Type predicate.</p>
  </dd>
  <dt>
    int is_ref(poly v)
  </dt>
  <dd>
    <p>Type predicate: checks for pointer type.  This is arguably a misfeature, and may change.</p>
  </dd>
  <dt>
    int is_struct(poly v)
  </dt>
  <dd>
    <p>Type predicate.</p>
  </dd>
  <dt>
    int is_func(poly v)
  </dt>
  <dd>
    <p>Type predicate.</p>
  </dd>
  <dt>
    int is_void(poly v)
  </dt>
  <dd>
    <p>Type predicate.</p>
  </dd>
  <dt>
    int gcd(int p, int q)
  </dt>
  <dd>
    <p>Return the GCD of p and q.  The result is always positive.</p>
  </dd>
  <dt>
    int xor(int a, int b)
  </dt>
  <dd>
    <p>Return a ^ b .  This is mostly a holdover from before Nickle had an xor operator.</p>
  </dd>
  <dt>
    poly setjmp(continuation *c, poly retval)
  </dt>
  <dd>
    <p>The setjmp() and longjmp() primitives together with the continuation type form an ADT useful for nearly arbitrary transfers of flow-of-control.  The setjmp() and longjmp() builtins are like those of C, except that the restriction that longjmp() always jump upwards is removed(!): a continuation saved via setjmp() never becomes invalid during the program lifetime.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>The setjmp() builtin saves the current location and context into its continuation pointer argument, and then returns its second argument.</p>
  </dd>
  <dt>
    void longjmp(continuation c, poly retval)
  </dt>
  <dd>
    <p>The longjmp() builtin never returns to the call site, but instead returns from the setjmp() that created the continuation, with return value equal to the second argument of longjmp().</p>
  </dd>
  <dt>
    string prompt
  </dt>
  <dd>
    <p>The prompt printed during interactive use when at top-level.  Default "&gt; ". when waiting for the rest of a statement or expression, and when debugging, respectively. Default values are "&gt; ", "+ ", and "- ".</p>
  </dd>
  <dt>
    string prompt2
  </dt>
  <dd>
    <p>The prompt printed during interactive use when waiting for the rest of a statement or expression. Default "+ ".</p>
  </dd>
  <dt>
    string prompt3
  </dt>
  <dd>
    <p>The prompt printed during interactive use when debugging. Default "- ".</p>
  </dd>
  <dt>
    string format
  </dt>
  <dd>
    <p>The printf() format for printing top-level values.  Default "%g".</p>
  </dd>
  <dt>
    string version
  </dt>
  <dd>
    <p>The version number of the Nickle implementation currently being executed.</p>
  </dd>
  <dt>
    string build
  </dt>
  <dd>
    <p>The build date of the Nickle implementation currently being executed, in the form "yyyy/mm/dd", or "?" if the build date is unknown for some reason.</p>
  </dd>
  <dt>
    file stdin
  </dt>
  <dd>
    <p>Bound to the standard input stream.</p>
  </dd>
  <dt>
    file stdout
  </dt>
  <dd>
    <p>Bound to the standard output stream.</p>
  </dd>
  <dt>
    file stderr
  </dt>
  <dd>
    <p>Bound to the standard error stream.</p>
  </dd>

</dl>
<p><strong>Exceptions:</strong></p><p>A few standard exceptions are predeclared and used internally by Nickle.</p>
<dl class='dl-vertical'>
  <dt>
    exception uninitialized_value(string msg)
  </dt>
  <dd>
    <p>Attempt to use an uninitialized value.</p>
  </dd>
  <dt>
    exception invalid_argument(string msg, int arg, poly val)
  </dt>
  <dd>
    <p>The arg-th argument to a builtin function had invalid value val.</p>
  </dd>
  <dt>
    exception readonly_box(string msg, poly val)
  </dt>
  <dd>
    <p>Attempt to change the value of a read-only quantity to val.</p>
  </dd>
  <dt>
    exception invalid_array_bounds(string msg, poly a, poly i)
  </dt>
  <dd>
    <p>Attempt to access array a at index i is out of bounds.</p>
  </dd>
  <dt>
    exception divide_by_zero(string msg, real num, real den)
  </dt>
  <dd>
    <p>Attempt to divide num by den with den == 0.</p>
  </dd>
  <dt>
    exception invalid_struct_member(string msg, poly struct, string name)
  </dt>
  <dd>
    <p>Attempt to refer to member name of the object struct, which does not exist.</p>
  </dd>
  <dt>
    exception invalid_binop_values(string msg, poly arg1, poly arg2)
  </dt>
  <dd>
    <p>Attempt to evaluate a binary operator with args arg1 and arg2, where at least one of these values is invalid.</p>
  </dd>
  <dt>
    exception invalid_unop_values(string msg, poly arg)
  </dt>
  <dd>
    <p>Attempt to evaluate a unary operator with invalid argument arg.</p>
  </dd>

</dl>
<p><strong>Builtin Namespaces:</strong></p>
<dl class='dl-vertical'>
  <dt>
    Math
  </dt>
  <dd>
    <p>The math functions available in the Math namespace are implemented in a fashion intended to be compatible with the C library. Please consult the appropriate manuals for further details.</p>
  </dd>
  <dt>
    real pi
  </dt>
  <dd>
    <p>Imprecise constant giving the value of the circumference/diameter ratio of the circle to the default precision of 256 bits.</p>
  </dd>
  <dt>
    protected real e
  </dt>
  <dd>
    <p>Imprecise constant giving the value of the base of natural logarithms to the default precision of 256 bits. Since e is protected, it must be referenced via Math::e, in order to avoid problems with using the fifth letter of the alphabet at top level.</p>
  </dd>
  <dt>
    real function sqrt(real v)
  </dt>
  <dd>
    <p>Returns the square root of v.</p>
  </dd>
  <dt>
    real function cbrt(real v)
  </dt>
  <dd>
    <p>Returns the cube root of v.</p>
  </dd>
  <dt>
    real function exp(real v)
  </dt>
  <dd>
    <p>Returns e**v.</p>
  </dd>
  <dt>
    real function log(real a)
  </dt>
  <dd>
    <p>Returns v such that e**v == a. Throws an invalid_argument exception if a is non-positive.</p>
  </dd>
  <dt>
    real function log10(real a)
  </dt>
  <dd>
    <p>Returns v such that 10**v == a. Throws an invalid_argument exception if a is non-positive.</p>
  </dd>
  <dt>
    real function log2(real a)
  </dt>
  <dd>
    <p>Returns v such that 2**v == a. Throws an invalid_argument exception if a is non-positive.</p>
  </dd>
  <dt>
    real function pi_value(int prec)
  </dt>
  <dd>
    <p>Returns the ratio of the circumference of a circle to the diameter, with prec bits of precision.</p>
  </dd>
  <dt>
    real function sin(real a)
  </dt>
  <dd>
    <p>Returns the ratio of the opposite side to the hypotenuse of angle a of a right triangle, given in radians.</p>
  </dd>
  <dt>
    real function cos(real a)
  </dt>
  <dd>
    <p>Returns the ratio of the adjacent side to the hypotenuse of angle a of a right triangle, given in radians.</p>
  </dd>
  <dt>
    void function sin_cos(real a, *real sinp, *real cosp)
  </dt>
  <dd>
    <p>Returns with sin(a) and cos(a) stored in the locations pointed to by sinp and cosp respectively.  If either pointer is 0, do not store into that location.  May be slightly faster than calling both trig functions independently.</p>
  </dd>
  <dt>
    real function tan(real a)
  </dt>
  <dd>
    <p>Returns the ratio of the opposite side to the adjacent side of angle a of a right triangle, given in radians. Note that tan(pi/2) is not currently an error: it will return a very large number dependent on the precision of its input.</p>
  </dd>
  <dt>
    real function asin(real v)
  </dt>
  <dd>
    <p>Returns a such that sin(a) == v.</p>
  </dd>
  <dt>
    real function acos(real v)
  </dt>
  <dd>
    <p>Returns a such that cos(a) == v.</p>
  </dd>
  <dt>
    real function atan(real v)
  </dt>
  <dd>
    <p>Returns a such that tan(a) == v.</p>
  </dd>
  <dt>
    real function atan2(real x, y)
  </dt>
  <dd>
    <p>Returns a such that tan(a) == x / y. Deals correctly with y == 0.</p>
  </dd>
  <dt>
    real function pow(real a, real b)
  </dt>
  <dd>
    <p>The implementation of the ** operator.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    File
  </dt>
  <dd>
    <p>The namespace File provides operations on file values.</p>
  </dd>
  <dt>
    int function fprintf(file f, string s, ....)
  </dt>
  <dd>
    <p>Print formatted values to a file, as with UNIX stdio library fprintf(). fprintf() and printf() accept a reasonable sub-set of the stdio library version:  %c, %d, %e, %x, %o, %f, %s, %g work as expected, as does %v to smart-print a value.  Format modifiers may be placed between the percent-sign and the format letter to modify formatting.  There are a lot of known bugs with input and output formatting.</p><p><strong>Format Letters:</strong></p>
<dl class='dl-vertical'>
  <dt>
    %c
  </dt>
  <dd>
    <p>Requires a small integer argument (0..255), and formats as an ASCII character.</p>
  </dd>
  <dt>
    %d
  </dt>
  <dd>
    <p>Requires an integer argument, and formats as an integer.</p>
  </dd>
  <dt>
    %x
  </dt>
  <dd>
    <p>Requires an integer argument, and formats as a base-16 (hexadecimal) integer.</p>
  </dd>
  <dt>
    %o
  </dt>
  <dd>
    <p>Requires an integer argument, and formats as a base-8 (octal) integer.</p>
  </dd>
  <dt>
    %e
  </dt>
  <dd>
    <p>Requires a number argument, and formats in scientific notation.</p>
  </dd>
  <dt>
    %f
  </dt>
  <dd>
    <p>Requires a number argument, and formats in fixed-point notation.</p>
  </dd>
  <dt>
    %s
  </dt>
  <dd>
    <p>Requires a string argument, and emits the string literally.</p>
  </dd>
  <dt>
    %g
  </dt>
  <dd>
    <p>Requires a number, and tries to pick a precise and readable representation to format it.</p>
  </dd>

</dl>
<p><strong>Format Modifiers:</strong></p>
<dl class='dl-vertical'>
  <dt>
    digits
  </dt>
  <dd>
    <p>All format characters will take an integer format modifier indicating the number of blanks in the format field for the data to be formatted.  The value will be printed right-justified in this space.</p>
  </dd>
  <dt>
    digits.digits
  </dt>
  <dd>
    <p>The real formats will take a pair of integer format modifiers indicating the field width and precision (number of chars after decimal point) of the formatted value.  Either integer may be omitted.</p>
  </dd>
  <dt>
    -
  </dt>
  <dd>
    <p>A precision value indicating infinite precision.</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>The next argument to fprintf() is an integer indicating the field width or precision of the formatted value.</p>
  </dd>

</dl>

  </dd>
  <dt>
    file function string_write()
  </dt>
  <dd>
    <p>Return a file which collects written values into a string.</p>
  </dd>
  <dt>
    int function close(file f)
  </dt>
  <dd>
    <p>Close file f and return an indication of success.</p>
  </dd>
  <dt>
    int function flush(file f)
  </dt>
  <dd>
    <p>Flush the buffers of file f and return an indication of success.</p>
  </dd>
  <dt>
    int function getc(file f)
  </dt>
  <dd>
    <p>Get the next character from file f and return it.</p>
  </dd>
  <dt>
    int function end(file f)
  </dt>
  <dd>
    <p>Returns true if file f is at EOF, else false.</p>
  </dd>
  <dt>
    int function error(file f)
  </dt>
  <dd>
    <p>Returns true if an error is pending on file f, else false.</p>
  </dd>
  <dt>
    int function clear_error(file f)
  </dt>
  <dd>
    <p>Clears pending errors on file f, and returns an indication of success.</p>
  </dd>
  <dt>
    file function string_read(string s)
  </dt>
  <dd>
    <p>Returns a virtual file whose contents are the string s.</p>
  </dd>
  <dt>
    string function string_string(file f)
  </dt>
  <dd>
    <p>Return the string previously written into the file f, which should have been created by string_read() or string_write().  Behavior on other files is currently undefined.</p>
  </dd>
  <dt>
    file function open(string path, string mode)
  </dt>
  <dd>
    <p>Open the file at the given path with the given mode string, ala UNIX stdio fopen().  Permissible modes are as in stdio: "r", "w", "x", "r+", "w+" and "x+".</p>
  </dd>
  <dt>
    integer function fputc(integer c, file f)
  </dt>
  <dd>
    <p>Output the character c to the output file f, and return an indication of success.</p>
  </dd>
  <dt>
    integer function ungetc(integer c, file f)
  </dt>
  <dd>
    <p>Push the character c back onto the input file f, and return an indication of success.</p>
  </dd>
  <dt>
    integer function setbuf(file f, integer n)
  </dt>
  <dd>
    <p>Set the size of the buffer associated with file f to n, and return n.</p>
  </dd>
  <dt>
    string function fgets (file f)
  </dt>
  <dd>
    <p>Get a line of input from file f, and return the resulting string.</p>
  </dd>
  <dt>
    file function pipe(string path, string[*] argv, string mode)
  </dt>
  <dd>
    <p>Start up the program at the given path, returning a file which is one end of a "pipe" to the given process. The mode argument can be "r" to read from the pipe or "w" to write to the pipe.  The argv argument is an array of strings giving the arguments to be passed to the program, with argv[0] conventionally being the program name.</p>
  </dd>
  <dt>
    int function print (file f, poly v, string fmt, int base, int width, int prec, string fill)
  </dt>
  <dd>
    <p>Print value v to file f in format fmt with the given base, width, prec, and fill.  Used internally by File::fprintf();</p>
  </dd>
  <dt>
    int function fscanf(file f, string fmt, *poly args...)
  </dt>
  <dd>
    <p>Fill the locations pointed to by the array args with values taken from file f according to string fmt.  The format specifiers are much as in UNIX stdio scanf(): the "%d", "%e", "%f", "%c" and "%s" specifiers are supported with the expected modifiers.</p>
  </dd>
  <dt>
    int function vfscanf (file f, string fmt, (*poly)[*] args)
  </dt>
  <dd>
    <p>Given the file f, the format fmt, and the array of arguments args, fscanf() appropriately.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    Thread
  </dt>
  <dd>
    <p>The namespace Thread supports various operations useful for programming with <em>threads</em>, which provide concurrent flow of control in the shared address space.  There is one piece of special syntax associated with threads.</p>
<dl class='dl-vertical'>
  <dt>
    fork(E)
  </dt>
  <dd>
    <p>Accepts an arbitrary expression, and evaluates it in a new child thread.  The parent thread receives the thread as the value of the fork expression.</p>
  </dd>

</dl>

  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>The remainder of the Thread functions are fairly standard.</p>
  </dd>
  <dt>
    int function kill(thread list...)
  </dt>
  <dd>
    <p>Kills every running thread in the array list.  With no arguments, kills the currently running thread. Returns the number of threads killed.</p>
  </dd>
  <dt>
    int function trace(poly list...)
  </dt>
  <dd>
    <p>Shows the state of every running thread in the array list.  With no arguments, traces the default continuation. Returns the number of threads traced.</p>
  </dd>
  <dt>
    int function cont()
  </dt>
  <dd>
    <p>Continues execution of any interrupted threads, and returns the number of continued threads.</p>
  </dd>
  <dt>
    thread function current()
  </dt>
  <dd>
    <p>Return the current thread.</p>
  </dd>
  <dt>
    int function list()
  </dt>
  <dd>
    <p>Reports the currently running thread to stdout.</p>
  </dd>
  <dt>
    int function get_priority(thread t)
  </dt>
  <dd>
    <p>Reports the priority of the given thread.</p>
  </dd>
  <dt>
    thread function id_to_thread(int id)
  </dt>
  <dd>
    <p>Returns the thread with the given id, if found, and 0 otherwise.</p>
  </dd>
  <dt>
    poly function join(thread t)
  </dt>
  <dd>
    <p>Waits for thread t to terminate, and returns whatever it returns.</p>
  </dd>
  <dt>
    int function set_priority(thread t, int i)
  </dt>
  <dd>
    <p>Attempts to set the priority of thread t to level i, and returns the new priority.  Larger priorities mean more runtime: a task with higher priority will always run instead of a lower priority task.  Threads of equal highest priority will be pre-emptively multitasked.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    Semaphore
  </dt>
  <dd>
    <p>The Semaphore namespace encapsulates operations on the semaphore built-in ADT.  A semaphore is used for thread synchronization.  Each signal() operation on the semaphore awakens the least-recent thread to wait() on that semaphore.  The ``count'' of waiting processes may be set at semaphore creation time.</p>
  </dd>
  <dt>
    semaphore function new(int c)
  </dt>
  <dd>
    <p>Create a new semaphore with an initial count c of waiting processes.  If c is positive, it means that c threads may wait on the semaphore before one blocks.  If c is negative, it sets a count of threads which must be waiting on the semaphore before further waits will not block.</p>
  </dd>
  <dt>
    semaphore function new()
  </dt>
  <dd>
    <p>Call <strong>semaphore</strong>(0) and return its result.</p>
  </dd>
  <dt>
    int signal(semaphore s)
  </dt>
  <dd>
    <p>Increment semaphore s.  If s is non-positive, and some thread is blocked on s, release the least-recently-blocked thread.  Return 1 on success.</p>
  </dd>
  <dt>
    int wait(semaphore s)
  </dt>
  <dd>
    <p>Decrement semaphore s.  If s is negative, block until released. Return 1 on success.</p>
  </dd>
  <dt>
    int test(semaphore s)
  </dt>
  <dd>
    <p>Test whether wait() on semaphore s would cause the current thread to block.  If so, return 0.  Otherwise, attempt to decrement s, and return 1 if successful.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    String
  </dt>
  <dd>
    <p>The String namespace contains a few basic operations on the string ADT.</p>
  </dd>
  <dt>
    int function length(string s)
  </dt>
  <dd>
    <p>Returns the number of characters in s.</p>
  </dd>
  <dt>
    string function new(int c)
  </dt>
  <dd>
    <p>Returns as a string the single character c.</p>
  </dd>
  <dt>
    string function new(int cv[*])
  </dt>
  <dd>
    <p>Returns a string comprised of the characters of cv.</p>
  </dd>
  <dt>
    int function index(string t, string p)
  </dt>
  <dd>
    <p>Returns the integer index of the pattern string p in the target string t, or -1 if p is not a substring of t.</p>
  </dd>
  <dt>
    string function substr(string s, int i, int l)
  </dt>
  <dd>
    <p>Returns the substring of string s starting with the character at offset i (zero-based) and continuing for a total of l characters.  If l is negative, the substring will consist of characters preceding rather than succeeding i.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    PRNG
  </dt>
  <dd>
    <p>The PRNG namespace provides pseudo-random number generation and manipulation.  The core generator is the RC4 stream cipher generator, properly bootstrapped.  This provide a stream of cryptographically-secure pseudo-random bits at reasonable amortized cost. (But beware, initialization is somewhat expensive.)</p>
  </dd>
  <dt>
    void function srandom(int s)
  </dt>
  <dd>
    <p>Initialize the generator, using the (arbitrarily-large) integer as a seed.</p>
  </dd>
  <dt>
    void function dev_srandom(int nbits)
  </dt>
  <dd>
    <p>Initialize the generator, using nbits bits of entropy obtained from some reasonable entropy source.  On UNIX systems, this source is /dev/urandom.  Asking for more initial entropy than the system has may lead either to bootstrapping (as on UNIX) or to hanging, so use cautiously.</p>
  </dd>
  <dt>
    int function randbits(int n)
  </dt>
  <dd>
    <p>Returns an n-<strong>bit</strong> pseudo-random number, in the range <em>0..(2**n)-1</em>.  Useful for things like RSA.</p>
  </dd>
  <dt>
    int function randint(int n)
  </dt>
  <dd>
    <p>Returns a pseudo-random number in the range <em>0..n-1</em>.</p>
  </dd>
  <dt>
    void function shuffle(*(poly[*]) a)
  </dt>
  <dd>
    <p>Performs an efficient in-place true shuffle (c.f. Knuth) of the array a.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    Command
  </dt>
  <dd>
    <p>The Command namespace is used by the top-level commands as described below.  It is also occasionally useful in its own right.</p>
  </dd>
  <dt>
    string library_path
  </dt>
  <dd>
    <p>Contains the current library search path, a colon-separated list of directories to be searched for library files.</p>
  </dd>
  <dt>
    int function undefine(string name)
  </dt>
  <dd>
    <p>Implements the top-level undefine command. Remove the name denoted by string name from the namespace.  This removes all visible definitions of the name.</p>
  </dd>
  <dt>
    int function undefine(string[*] names)
  </dt>
  <dd>
    <p>Remove each of the names in the array names from the namespace.  This removes all visible definitions of each name.</p>
  </dd>
  <dt>
    int function delete(string name)
  </dt>
  <dd>
    <p>Attempt to remove the command with the given string name from the top-level command list, and return 1 if successful.</p>
  </dd>
  <dt>
    int function lex_file(string path)
  </dt>
  <dd>
    <p>Attempt to make the file at the given path the current source of Nickle code, and return 1 if successful.  Note that this effectively ``includes'' the file by pushing it onto a stack of files to be processed.</p>
  </dd>
  <dt>
    int function lex_library(string filename)
  </dt>
  <dd>
    <p>Like lex_file(), but searches the directories given by the <em>library_path</em> variable for the first file with the given filename.</p>
  </dd>
  <dt>
    int function lex_string(string code)
  </dt>
  <dd>
    <p>Attempt to make the Nickle code contained in the string code be the next input.</p>
  </dd>
  <dt>
    int function edit(string[*] names)
  </dt>
  <dd>
    <p>Implements the top-level edit command. The names in the array are a path of namespace names leading to the symbol name, which is last.</p>
  </dd>
  <dt>
    int function new(string name, poly func)
  </dt>
  <dd>
    <p>Binds function func to the top-level command string name: i.e., makes it part of the top-level command vocabulary.</p>
  </dd>
  <dt>
    int function new_names(string name, poly func)
  </dt>
  <dd>
    <p>Binds function func to the top-level command string name: i.e., makes it part of the top-level command vocabulary.  Unlike new(), the string names given to func at the top level are passed unevaluated as an array of string names or as a single string name.</p>
  </dd>
  <dt>
    int function pretty_print(file f, string[*] names)
  </dt>
  <dd>
    <p>Implements the top-level print command.  Each of the passed name strings is looked up and the corresponding code printed to file f.</p>
  </dd>
  <dt>
    int function display(string fmt, poly val)
  </dt>
  <dd>
    <p>Uses printf() to display the value val in format fmt.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    History
  </dt>
  <dd>
    <p>Nickle maintains a top-level value history, useful as an adjunct to command-line editing when calculating.  The History namespace contains functions to access this history.</p>
  </dd>
  <dt>
    int function show(string fmt)
  </dt>
  <dd>
    <p>Implements the history top-level command with no arguments. Show the most recent history values with format fmt.</p>
  </dd>
  <dt>
    int function show(string fmt, int count)
  </dt>
  <dd>
    <p>Implements the history top-level command with one argument. Show the last count history values with format fmt.</p>
  </dd>
  <dt>
    int function show(string fmt, int first, int last)
  </dt>
  <dd>
    <p>Implements the history top-level command with two arguments.</p>
  </dd>
  <dt>
    poly function insert(poly val)
  </dt>
  <dd>
    <p>Insert val in the history list, and return it.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    Environ
  </dt>
  <dd>
    <p>Many operating systems have some notion of ``environment variables.'' The Environ namespace contains functions to manipulate these.</p>
  </dd>
  <dt>
    int function check(string name)
  </dt>
  <dd>
    <p>Returns 1 if the variable with the given name is in the environment, and 0 otherwise.</p>
  </dd>
  <dt>
    string function get(string name)
  </dt>
  <dd>
    <p>Attempts to retrieve and return the value of the environment variable with the given name.  Throws an invalid_argument exception if the variable is not available.</p>
  </dd>
  <dt>
    int function unset(string name)
  </dt>
  <dd>
    <p>Attempts to unset the environment variable with the given name, and returns an indication of success.</p>
  </dd>
  <dt>
    string function set(string name, string value)
  </dt>
  <dd>
    <p>Attempts to set the environment variable with the given name to the given value, and returns an indication of success.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COMMANDS</h2>
        <div class="sectioncontent">
<p>Nickle has a set of commands which may be given at the top level.</p>
<dl class='dl-vertical'>
  <dt>
    quit
  </dt>
  <dd>
    <p>Exit Nickle.</p>
  </dd>
  <dt>
    quit E
  </dt>
  <dd>
    <p>Exit Nickle with integer status code E.</p>
  </dd>
  <dt>
    undefine NAME {,NAME}
  </dt>
  <dd>
    <p>Remove these names from the system.</p>
  </dd>
  <dt>
    load E
  </dt>
  <dd>
    <p>Load a file given by the string name E.</p>
  </dd>
  <dt>
    library E
  </dt>
  <dd>
    <p>Load a library given by the string name E.  See the discussion of the NICKLEPATH environment variable in ENVIRONMENT below, and the discussion of Command::library_path above.</p>
  </dd>
  <dt>
    E # E
  </dt>
  <dd>
    <p>Print expr1 in base expr2 .</p>
  </dd>
  <dt>
    print NAME
  </dt>
  <dd>
    <p>Display a formatted version of the object denoted by NAME. Comments and original formating are lost. If NAME is a variable, print the type as well as the value.</p>
  </dd>
  <dt>
    edit NAME
  </dt>
  <dd>
    <p>Invoke $EDITOR on the named object, and re-incorporate the results of the edit.  This is most useful with functions.</p>
  </dd>
  <dt>
    history
  </dt>
  <dd>
    <p>Display the 10 most recently printed values.  They can be accessed with <strong>$</strong><em>n</em> where <em>n</em> is the number displayed to the right of the value in this list.</p>
  </dd>
  <dt>
    history <em>E</em>
  </dt>
  <dd>
    <p>Display the E most recent history values.</p>
  </dd>
  <dt>
    history <em>E</em>,<em>E</em>
  </dt>
  <dd>
    <p>Display history values from the first integer E through the second.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DEBUGGER</h2>
        <div class="sectioncontent">
<p>When an unhandled exception reaches top level during execution, the user receives a dash prompt, indicating that debug mode is active.  In this mode, the command-line environment is that in which the unhandled exception was raised. In addition a number of debugging commands are available to the user:</p>
<dl class='dl-vertical'>
  <dt>
    trace
  </dt>
  <dd>
    <p>Get a stack backtrace showing the current state, as with the GDB where command.</p>
  </dd>
  <dt>
    up
  </dt>
  <dd>
    <p>Move up the stack (i.e., toward the top-level expression) ala GDB.</p>
  </dd>
  <dt>
    down
  </dt>
  <dd>
    <p>Move down the stack (i.e., toward the current context) ala GDB.</p>
  </dd>
  <dt>
    done
  </dt>
  <dd>
    <p>Leave debugging mode, abandoning execution.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>In addition, the Debug namespace is scoped in in debugging mode.  This is primarily of use in debugging Nickle itself.</p>
  </dd>
  <dt>
    collect()
  </dt>
  <dd>
    <p>Run the garbage collector.</p>
  </dd>
  <dt>
    dump(function)
  </dt>
  <dd>
    <p>Print the compiled byte code for function.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ENVIRONMENT</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    EDITOR
  </dt>
  <dd>
    <p>The editor used by the edit command, described in COMMANDS above.</p>
  </dd>
  <dt>
    NICKLERC
  </dt>
  <dd>
    <p>The location of the user's .nicklerc file, which will be loaded at the beginning of nickle execution if possible.</p>
  </dd>
  <dt>
    HOME
  </dt>
  <dd>
    <p>Used to find the user's .nicklerc if NICKLERC is not set.</p>
  </dd>
  <dt>
    NICKLEPATH
  </dt>
  <dd>
    <p>A colon-separated path whose elements are directories containing Nickle code.  The library command and the -l flag, described above, search this path for a filename matching the given file.  The default library path in the absence of this variable is /usr/share/nickle.</p>
  </dd>
  <dt>
    NICKLESTART
  </dt>
  <dd>
    <p>The filename of the file that should be loaded as a bootstrap on Nickle startup.  The default in the absence of this variable is to load /usr/share/nickle/builtin.5c.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>An example (taken from the <em>bc</em> manual:</p>
<pre>
  real function exponent(real x) {
      real a = 1;
      int b = 1;
      real s = 1;
      int i = 1;
      while (1) {
          a = a * x;
          b = b * i;
          real c = a / b;
          if (abs(c) &lt; 1e-6)
              return s;
          s = s + c;
          i++;
      }
  }

</pre>
<p>defines a function to compute an approximate value of the exponential function e ** x and</p>
<pre>
  for (i = 1; i &lt; 10; i++)
      printf ("%g&#92;n", exponent (i));

</pre>
<p>prints approximate values of the exponential function of the first ten integers.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">VERSION</h2>
        <div class="sectioncontent">
<p>This document describes version 1.99.2 of nickle, as well as some newer features.  It was distributed with version 2.77 of nickle.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>See the discussion of the type of the exponentiation operator ** above.</p><p>Due to a difficult-to-remove grammar ambiguity, it is not possible to use a bare assignment expression in an array initializer: it is confused with a structure initializer.  For example:</p>
<pre>
  &gt; int x = 0;
  &gt; (int[*]){x = 1}
  -&gt;     (int[*]) { x = 1 }
Non array initializer
</pre>
<p>The workaround is to parenthesize the assignment expression:</p>
<pre>
  &gt; (int[*]){(x = 1)}
  [1]{1}
</pre>
<p>Because this is so rare, so hard to fix, and so easy to work around, this bug is unlikely to be fixed anytime soon.</p><p>There are a lot of known bugs with input and output formatting. The obvious stuff works, other stuff does not.</p><p>The semantics of division are unfortunately different from those of C.  This is arguably because C is broken in this area: we cannot currently see any obvious fix. C allows automatic implicit coercion of floating to integral types, but we consider this a misfeature.</p><p>The implementation has not been thoroughly tested.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p><em>Nickle</em> is the work of Keith Packard &lt;keithp@keithp.com&gt; and Bart Massey &lt;bart_massey@iname.com&gt;.</p><p>Nickle is</p><p>Copyright 1988-2006 Keith Packard and Bart Massey.  All Rights Reserved.</p><p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p><p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p><p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p><p>Except as contained in this notice, the names of the authors or their institutions shall not be used in advertising or otherwise to promote the sale, use or other dealings in this Software without prior written authorization from the authors.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="nice.1.html"><span aria-hidden="true">&larr;</span> nice.1: Run a program with modified scheduling priority</a></li>
   <li class="next"><a href="nicotine.1.html">nicotine.1: Client for the soulseek peer-to-peer sharing system <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

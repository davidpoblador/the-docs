<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>httperf: Http performance measurement tool</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Http performance measurement tool">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="httperf (1) manual">
  <meta name="twitter:description" content="Http performance measurement tool">
  <meta name="twitter:image" content="https://www.carta.tech/images/httperf-httperf-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/httperf.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="httperf (1) manual" />
  <meta property="og:description" content="Http performance measurement tool" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/httperf-httperf-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">httperf<small> (1)</small></h1>
        <p class="lead">Http performance measurement tool</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/httperf.1.html">
      <span itemprop="name">httperf: Http performance measurement tool</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/httperf/">
      <span itemprop="name">httperf</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/httperf.1.html">
      <span itemprop="name">httperf: Http performance measurement tool</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>httperf</strong> [<strong>--add-header</strong> <em>S</em>] [<strong>--burst-length</strong> <em>N</em>] [<strong>--client</strong> <em>I</em>/<em>N</em>] [<strong>--close-with-reset</strong>] [<strong>-d</strong>|<strong>--debug</strong> <em>N</em>] [<strong>--failure-status</strong> <em>N</em>] [<strong>-h</strong>|<strong>--help</strong>] [<strong>--hog</strong>] [<strong>--http-version</strong> <em>S</em>] [<strong>--max-connections</strong> <em>N</em>] [<strong>--max-piped-calls</strong> <em>N</em>] [<strong>--method</strong> <em>S</em>] [<strong>--no-host-hdr</strong>] [<strong>--num-calls</strong> <em>N</em>] [<strong>--num-conns</strong> <em>N</em>] [<strong>--period</strong> [<strong>d</strong>|<strong>u</strong>|<strong>e</strong>]<strong></strong><em>T1</em>[<strong>,</strong><em>T2</em>]] [<strong>--port</strong> <em>N</em>] [<strong>--print-reply</strong> [<strong>header</strong>|<strong>body</strong>]<strong>]</strong> [<strong>--print-request</strong> [<strong>header</strong>|<strong>body</strong>]<strong>]</strong> [<strong>--rate</strong> <em>X</em>] [<strong>--recv-buffer</strong> <em>N</em>] [<strong>--retry-on-failure</strong>] [<strong>--send-buffer</strong> <em>N</em>] [<strong>--server</strong> <em>S</em>] [<strong>--server-name</strong> <em>S</em>] [<strong>--session-cookie</strong>] [<strong>--ssl</strong>] [<strong>--ssl-ciphers</strong> <em>L</em>] [<strong>--ssl-no-reuse</strong>] [<strong>--think-timeout</strong> <em>X</em>] [<strong>--timeout</strong> <em>X</em>] [<strong>--uri</strong> <em>S</em>] [<strong>-v</strong>|<strong>--verbose</strong>] [<strong>-V</strong>|<strong>--version</strong>] [<strong>--wlog y</strong>|<strong>n,</strong><em>F</em>] [<strong>--wsess</strong> <em>N</em>,<em>N</em>,<em>X</em>] [<strong>--wsesslog</strong> <em>N</em>,<em>X</em>,<em>F</em>] [<strong>--wset</strong> <em>N</em>,<em>X</em>]</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><strong>httperf</strong> is a tool to measure web server performance.  It speaks the HTTP protocol both in its HTTP/1.0 and HTTP/1.1 flavors and offers a variety of workload generators. While running, it keeps track of a number of performance metrics that are summarized in the form of statistics that are printed at the end of a test run.  The most basic operation of <strong>httperf</strong> is to generate a fixed number of HTTP GET requests and to measure how many replies (responses) came back from the server and at what rate the responses arrived.</p><p><strong>IMPORTANT:</strong> To obtain correct results, it is necessary to run at most one <strong>httperf</strong> process per client machine.  Also, there should be as few background processes as possible both on the client and server machines.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p>httperf --hog --server www</p>
  </dt>
  <dd>
    <p>This command causes <strong>httperf</strong> to create a connection to host www, send a request for the root document (http://www/), receive the reply, close the connection, and then print some performance statistics.</p>
  </dd>
  <dt>
    <p>httperf --hog --server www --num-conn 100 --ra 10 --timeout 5</p>
  </dt>
  <dd>
    <p>Like above, except that a total of 100 connections are created and that connections are created at a fixed rate of 10 per second.  Note that option ``--rate'' has been abbreviated to ``--ra''.</p>
  </dd>
  <dt>
    <p>httperf --hog --server=www --wsess=10,5,2 --rate 1 --timeout 5</p>
  </dt>
  <dd>
    <p>Causes <strong>httperf</strong> to generate a total of 10 sessions at a rate of 1 session per second. Each session consists of 5 calls that are spaced out by 2 seconds.</p>
  </dd>
  <dt>
    <p>httperf --hog --server=www --wsess=10,5,2 --rate=1 --timeout=5 --ssl</p>
  </dt>
  <dd>
    <p>Like above, except that <strong>httperf</strong> contacts server www via SSL at port 443 (the default port for SSL connections).</p>
  </dd>
  <dt>
    <p>httperf --hog --server www --wsess=10,5,2 --rate=1 --timeout=5 --ssl --ssl-ciphers=EXP-RC4-MD5:EXP-RC2-CBC-MD5 --ssl-no-reuse --http-version=1.0</p>
  </dt>
  <dd>
    <p>Like above, except that <strong>httperf</strong> will inform the server that it can only select from two cipher suites (EXP-RC4-MD5 or EXP-RC2-CBC-MD5); furthermore, <strong>httperf</strong> will use HTTP version 1.0 which requires a new TCP connection for each request.  Also, SSL session ids are not reused, so the entire SSL connection establishment process (known as the SSL handshake) occurs for each connection.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONS</h2>
        <div class="sectioncontent">
<p>The operation of <strong>httperf</strong> can be controlled through a number of options.  The tool supports both short (one-character) and long (arbitrary-length) option names.  Short options are prefixed with a single leading dash (-), long options with a double-dash (--).  Multiple short options can be grouped together (e.g., ``<strong>-vV</strong>'' is equivalent to ``<strong>-v -V</strong>'') and long options can be abbreviated so long as they remain unique. Parameters to options can be specified either by following the long option name with an equal sign and the parameter value (e.g., <strong>--burst=10</strong>) or by separating the option name and value with whitespace (e.g., <strong>--burst 10</strong>).</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>--add-header=</strong><em>S</em></p>
  </dt>
  <dd>
    <p>Specifies to include string <em>S</em> as an additional request header.  It is necessary to specify the terminating carriage-return/line-feed sequence explicitly.  This can be done by using the escape sequence ``&#92;n''.  This makes it possible to include multiple request headers.  For example, ``--add-header "Referer: foo&#92;nAuth: secret&#92;n"'' would add two request headers (``Referer'' and ``Auth'') to each request.  Other supported escape sequences are ``&#92;r'' (carriage-return), ``&#92;a'' (line-feed), ``&#92;&#92;'' (backslash), and ``&#92;N'' where N is the code the character to be inserted (in octal).</p>
  </dd>
  <dt>
    <p><strong>--burst-length=</strong><em>N</em></p>
  </dt>
  <dd>
    <p>Specifies the length of bursts.  Each burst consists of <em>N</em> calls to the server.  The exact meaning of this parameter depends on the workload generator.  For regular request-oriented workloads, see the description of option <strong>--wsess</strong>.</p>
  </dd>
  <dt>
    <p><strong>--no-host-hdr</strong></p>
  </dt>
  <dd>
    <p>Specifies that the "Host:" header should not be included when issuing an HTTP request.</p>
  </dd>
  <dt>
    <p><strong>--num-calls</strong>.</p>
  </dt>
  <dd>
    <p>For session-oriented workloads, see the description of option <strong>--wsess</strong>.</p>
  </dd>
  <dt>
    <p><strong>--client=</strong><em>I</em><strong>/</strong><em>N</em></p>
  </dt>
  <dd>
    <p>Specifies that the machine <strong>httperf</strong> is running on is client <em>I</em> out of a total of <em>N</em> clients. <em>I</em> should be in the range from 0 to <em>N</em>-1. Some of the workload generators (e.g., <strong>--wset)</strong> use the client identity as a bias value to ensure that not all clients generate perfectly identical workloads.  When performing a test that involves several client machines, it is generally a good idea to specify this option.</p>
  </dd>
  <dt>
    <p><strong>--close-with-reset</strong></p>
  </dt>
  <dd>
    <p>Requests that <strong>httperf</strong> closes TCP connections by sending a RESET instead of going through the normal TCP connection shutdown handshake.  Turning on this option can have ill effects such as data corruption, stuck TCP control blocks, or wrong results.  For this reason, the option should not be used unless absolutely necessary and even then it should not be used unless its implications are fully understood.</p>
  </dd>
  <dt>
    <p><strong>-d=</strong><em>N</em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--debug=</strong><em>N</em></p>
  </dt>
  <dd>
    <p>Set debug level to <em>N</em>. Larger values of <em>N</em> will result in more output.</p>
  </dd>
  <dt>
    <p><strong>--failure-status=</strong><em>N</em></p>
  </dt>
  <dd>
    <p>Specifies that an HTTP response status code of <em>N</em> should be treated as a failure (i.e., treated as if the request had timed out, for example).  For example, with ``<strong>--failure-status=504</strong>'' responses with an HTTP status of ``504 Gateway Time-out'' would be considered failures.  Caveat: this option is currently supported for session workloads only (see the <strong>--wsess</strong> and <strong>--wsesslog</strong> options).</p>
  </dd>
  <dt>
    <p><strong>-h</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--help</strong></p>
  </dt>
  <dd>
    <p>Prints a summary of available options and their parameters.</p>
  </dd>
  <dt>
    <p><strong>--hog</strong></p>
  </dt>
  <dd>
    <p>This option requests to use up as many TCP ports as necessary. Without this option, <strong>httperf</strong> is typically limited to using ephemeral ports (in the range from 1024 to 5000).  This limited port range can quickly become a bottleneck so it is generally a good idea to specify this option for serious testing.  Also, this option must be specified when measuring NT servers since it avoids a TCP incompatibility between NT and UNIX machines.</p>
  </dd>
  <dt>
    <p><strong>--http-version=</strong><em>S</em></p>
  </dt>
  <dd>
    <p>Specifies the version string that should be included in the requests sent to the server.  By default, version string ``1.1'' is used.  This option can be set to ``1.0'' to force the generation of HTTP/1.0 requests.  Setting this option to any value other than ``1.0'' or ``1.1'' may result in undefined behavior.</p>
  </dd>
  <dt>
    <p><strong>--max-connections=</strong><em>N</em></p>
  </dt>
  <dd>
    <p>Specifies that at most <em>N</em> connections are opened for each session.  This option is meaningful in conjunction with options <strong>--wsess</strong> and <strong>--wsesslog</strong> only.</p>
  </dd>
  <dt>
    <p><strong>--max-piped-calls=</strong><em>N</em></p>
  </dt>
  <dd>
    <p>Specifies that at most <em>N</em> pipelined calls are issued on each connection.  This option is meaningful in conjunction with options <strong>--wsess</strong> and <strong>--wsesslog</strong> only.</p>
  </dd>
  <dt>
    <p><strong>--method=</strong><em>S</em></p>
  </dt>
  <dd>
    <p>Specifies the method that should be used when issuing an HTTP request. If this option is not specified, the GET method is used.  The method <em>S</em> can be an arbitrary string but is usually one of GET, HEAD, PUT, POST, etc.</p>
  </dd>
  <dt>
    <p><strong>--num-calls=</strong><em>N</em></p>
  </dt>
  <dd>
    <p>This option is meaningful for request-oriented workloads only.  It specifies the total number of calls to issue on each connection before closing it.  If <em>N</em> is greater than 1, the server must support persistent connections. The default value for this option is 1.  If <strong>--burst-length</strong> is set to <em>B</em>, then the <em>N</em> calls are issued in bursts of <em>B</em> pipelined calls each.  Thus, the total number of such bursts will be <em>N/B</em> (per connection).</p>
  </dd>
  <dt>
    <p><strong>--num-conns=</strong><em>N</em></p>
  </dt>
  <dd>
    <p>This option is meaningful for request-oriented workloads only.  It specifies the total number of connections to create.  On each connection, calls are issued as specified by options <strong>--num-calls</strong> and <strong>--burst-length</strong>. A test stops as soon as the <em>N</em> connections have either completed or failed.  A connection is considered to have failed if any activity on the connection fails to make forward progress for more than the time specified by the timeout options <strong>--timeout</strong> and <strong>--think-timeout</strong>. The default value for this option is 1.</p>
  </dd>
  <dt>
    <p><strong>--period=</strong><em>[D]T1[,T2]</em></p>
  </dt>
  <dd>
    <p>Specifies the time interval between the creation of connections or sessions. Connections are created by default, sessions if option <strong>--wsess</strong> or <strong>--wsesslog</strong> has been specified. This connection/session ``interarrival time'' can alternatively be specified by the <strong>--rate</strong> option, although more flexibility is available with <strong>--period.</strong> The <em>D</em> parameter specifies the interarrival time distribution. If omitted or set to ``<strong>d</strong>'', a deterministic (i.e., fixed) period is used as specified by parameter <em>T1</em> in units of seconds. If <em>D</em> is set to ``<strong>e</strong>'', an exponential (i.e., Poisson) distribution is used with a mean interarrival time of <em>T1</em>. Finally, if <em>D</em> is set to ``<strong>u</strong>'', a uniform distribution over the interval [<em>T1</em>,<em>T2</em>) is used for the interarrival time. In all cases, a period of 0 results in connections or sessions being generated sequentially (a new connection/session is initiated as soon as the previous one completes).  The default value for this option is 0.  Note that specifying, for example, <strong>--rate=5</strong> is equivalent to specifying <strong>--period=d0.2</strong> or <strong>--period=0.2</strong>. By specifying <strong>--period=u1,3</strong>, the interarrival times will be randomly chosen from the interval between 1 and 3 seconds.  The specific sequence of (pseudo-)random interarrival times are identical from one <strong>httperf</strong> run to another as long as the values for the <strong>--period</strong> and <strong>--client</strong> options are identical.</p>
  </dd>
  <dt>
    <p><strong>--port=</strong><em>N</em></p>
  </dt>
  <dd>
    <p>This option specifies the port number <em>N</em> on which the web server is listening for HTTP requests.  By default, <strong>httperf</strong> uses port number 80.</p>
  </dd>
  <dt>
    <p><strong>--print-reply</strong>[<strong>=</strong>[<strong>header</strong>|<strong>body</strong>]]</p>
  </dt>
  <dd>
    <p>Requests the printing of the reply headers, body, and summary.  The output is directed to standard output.  Reply header lines are prefixed by "RH", reply body lines are prefixed by "RB", and the reply-size summary is prefixed by "RS".  The prefix is followed by a serial number that uniquely identifies the call that the reply line is for and a colon (":") character that marks the beginning of the actual reply line.  To print only reply headers, pass argument <strong>header</strong> to this option.  To print only the reply body, pass argument <strong>body</strong> to this option.</p>
  </dd>
  <dt>
    <p><strong>--print-request</strong>[<strong>=</strong>[<strong>header</strong>|<strong>body</strong>]]</p>
  </dt>
  <dd>
    <p>Requests the printing of the request headers, body (if one is present), and summary.  The output is directed to standard output. Request header lines are prefixed by "SH", request body lines are prefixed by "SB", and the request summary is prefixed by "SS".  The prefix is followed by the call's serial number and a colon (":") character that marks the beginning of the actual reply line.  To print only request headers, pass argument <strong>header</strong> to this option.  To print only the request body, pass argument <strong>body</strong> to this option.</p>
  </dd>
  <dt>
    <p><strong>--rate=</strong><em>X</em></p>
  </dt>
  <dd>
    <p>Specifies the fixed rate at which connections or sessions are created. Connections are created by default, sessions if option <strong>--wsess</strong> or <strong>--wsesslog</strong> has been specified.  In both cases a rate of 0 results in connections or sessions being generated sequentially (a new session/connection is initiated as soon as the previous one completes).  The default value for this option is 0.</p>
  </dd>
  <dt>
    <p><strong>--recv-buffer=</strong><em>N</em></p>
  </dt>
  <dd>
    <p>Specifies the maximum size of the socket receive buffers used to receive HTTP replies.  By default, the limit is 16KB.  A smaller value may help memory-constrained clients whereas a larger value may be necessary when communicating with a server over a high-bandwidth, high-latency connection.</p>
  </dd>
  <dt>
    <p><strong>--retry-on-failure</strong></p>
  </dt>
  <dd>
    <p>This option is meaningful for session workloads only (see the <strong>--wsess</strong> and <strong>--wsesslog</strong> options).  If specified, a call that results in a failure response (as defined by the <strong>--failure-status</strong> option) is retried immediately instead of causing the session to fail.</p>
  </dd>
  <dt>
    <p><strong>--send-buffer=</strong><em>N</em></p>
  </dt>
  <dd>
    <p>Specifies the maximum size of the socket send buffers used to send HTTP requests.  By default, the limit is 4KB.  A smaller value may help memory-constrained clients whereas a larger value may be necessary when generating large requests to a server connected via a high-bandwidth, high-latency connection.</p>
  </dd>
  <dt>
    <p><strong>--server=</strong><em>S</em></p>
  </dt>
  <dd>
    <p>Specifies the IP hostname of the server.  By default, the hostname ``localhost'' is used.  This option should always be specified as it is generally not a good idea to run the client and the server on the same machine.</p>
  </dd>
  <dt>
    <p><strong>--server-name=</strong><em>S</em></p>
  </dt>
  <dd>
    <p>Specifies the (default) server name that appears in the "Host:" header of every request sent by <strong>httperf</strong>. Without this option, the host name (or IP address) specified by option <strong>--server</strong> is used instead.</p>
  </dd>
  <dt>
    <p><strong>--session-cookie</strong></p>
  </dt>
  <dd>
    <p>When this option is turned on, cookie managment is enabled on a per-session basis.  What this means is that if a reply to a request that was generated by session <em>X</em> contains a cookie, then all future requests sent by session <em>X</em> will include this cookie as well.  At present, the cookie manager in <strong>httperf</strong> supports only one cookie per session.  If a second cookie is received, the new cookie overwrites the existing one and a warning message is printed if ``--debug 1'' is on.</p>
  </dd>
  <dt>
    <p><strong>--ssl</strong></p>
  </dt>
  <dd>
    <p>Specifies that all communication between <strong>httperf</strong> and the server should utilize the Secure Sockets Layer (SSL) protocol. This option is available only if <strong>httperf</strong> was compiled with SSL support enabled.</p>
  </dd>
  <dt>
    <p><strong>--ssl-ciphers=</strong><em>L</em></p>
  </dt>
  <dd>
    <p>This option is only meaningful if SSL is in use (see <strong>--ssl</strong> option).  This option specifies the list <em>L</em> of cipher suites that <strong>httperf</strong> may use in negotiating a secure connection with the server.  If the list contains more than one cipher suite, the ciphers must be separated by a colon.  If the server does not accept any of the listed cipher suites, the connection establishment will fail and <strong>httperf</strong> will exit immediately.  If this option is not specified when the <strong>--ssl</strong> option is present then <strong>httperf</strong> will use all of the SSLv3 cipher suites provided by the underlying SSL library.</p>
  </dd>
  <dt>
    <p><strong>--ssl-no-reuse</strong></p>
  </dt>
  <dd>
    <p>This option is only meaningful if SSL and sessions are in use (see <strong>--ssl</strong>, <strong>--wsess</strong>, <strong>--wsesslog</strong>). When an SSL connection is established the client receives a session identifier (session id) from the server.  On subsequent SSL connections, the client normally reuses this session id in order to avoid the expense of repeating the (slow) SSL handshake to establish a new SSL session and obtain another session id (even if the client attempts to re-use a session id, the server may force the client to renegotiate a session).  By default <strong>httperf</strong> reuses the session id across all connections in a session.  If the <strong>--ssl-no-reuse</strong> option is in effect, then <strong>httperf</strong> will not reuse the session id, and the entire SSL handshake will be performed for each new connection in a session.</p>
  </dd>
  <dt>
    <p><strong>--think-timeout=</strong><em>X</em></p>
  </dt>
  <dd>
    <p>Specifies the maximum time that the server may need to initiate sending the reply for a given request.  Note that this timeout value is added to the normal timeout value (see option <strong>--timeout</strong>). When accessing static web content, it is usually not necessary to specify this option.  However, when performing tests with long-running CGI scripts, it may be necessary to use this option to allow for larger response-times.  The default value for this option is zero seconds, meaning that the server has to be able to respond within the normal timeout value.</p>
  </dd>
  <dt>
    <p><strong>--timeout=</strong><em>X</em></p>
  </dt>
  <dd>
    <p>Specifies the amount of time <em>X</em> that <strong>httperf</strong> is willing to wait for a server reaction.  The timeout is specified in seconds and can be a fractional number (e.g., <strong>--timeout 3.5</strong>). This timeout value is used when establishing a TCP connection, when sending a request, when waiting for a reply, and when receiving a reply.  If during any of those activities a request fails to make forward progress within the alloted time, <strong>httperf</strong> considers the request to have died, closes the associated connection or session and increases the <strong>client-timo</strong> error count.  The actual timeout value used when waiting for a reply is the sum of this timeout and the think-timeout (see option <strong>--think-timeout</strong>). By default, the timeout value is infinity.</p>
  </dd>
  <dt>
    <p><strong>--uri=</strong><em>S</em></p>
  </dt>
  <dd>
    <p>Specifies that URI <em>S</em> should be accessed on the server.  For some of the workload generators (e.g., <strong>--wset</strong>), this option specifies the prefix for the URIs being accessed.</p>
  </dd>
  <dt>
    <p><strong>-v</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--verbose</strong></p>
  </dt>
  <dd>
    <p>Puts <strong>httperf</strong> into verbose mode.  In this mode, additional output such as the individual reply rate samples and connection lifetime histogram are printed.</p>
  </dd>
  <dt>
    <p><strong>-V</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>--version</strong></p>
  </dt>
  <dd>
    <p>Prints the version of <strong>httperf</strong>.</p>
  </dd>
  <dt>
    <p><strong>--wlog=</strong><em>B</em><strong>,</strong><em>F</em></p>
  </dt>
  <dd>
    <p>This option can be used to generate a specific sequence of URI accesses.  This is useful to replay the accesses recorded in a server log file, for example.  Parameter <em>F</em> is the name of a file containing the ASCII NUL separated list of URIs that should be accessed.  If parameter <em>B</em> is set to ``<strong>y</strong>'', <strong>httperf</strong> will wrap around to the beginning of the file when reaching the end of the list (so the list of URIs is accessed repeatedly).  With <em>B</em> set to ``<strong>n</strong>'', the test will stop no later than when reaching the end of the URI list.</p>
  </dd>
  <dt>
    <p><strong>--wsess=</strong><em>N1</em><strong>,</strong><em>N2</em><strong>,</strong><em>X</em></p>
  </dt>
  <dd>
    <p>Requests the generation and measurement of sessions instead of individual requests.  A session consists of a sequence of bursts which are spaced out by the user think-time.  Each burst consists of a fixed number <em>L</em> of calls to the server (<em>L</em> is specified by option <strong>--burst-length</strong>). The calls in a burst are issued as follows: at first, a single call is issued.  Once the reply to this first call has been fully received, all remaining calls in the burst are issued concurrently.  The concurrent calls are issued either as pipelined calls on an existing persistent connection or as individual calls on separate connections. Whether a persistent connection is used depends on whether the server responds to the first call with a reply that includes a ``Connection: close'' header line.  If such a line is present, separate connections are used.</p><p>The option specifies the following parameters: <em>N1</em> is the total number of sessions to generate, <em>N2</em> is the number of calls per session, and <em>X</em> is the user think-time (in seconds) that separates consecutive call bursts.  For example, the options ``<strong>--wsess=100,50,10 --burst-len 5</strong>'' would result in 100 sessions with a total of 50 calls each.  Since each burst has a length of 5 calls, a total of 10 call bursts would be generated per session.  The user think-time between call bursts would be 10 seconds.  Note that user think-time <em>X</em> denotes the time between receiving the last reply of the previous call burst and the sending of the first request of the next burst.</p><p>A test involving sessions finishes as soon as the requested number <em>N1</em> of sessions have either failed or completed.  A session is considered to have failed if any operation in a session takes longer than the timeouts specified by options <strong>--timeout</strong> and <strong>--think-timeout</strong>. In addition, a session also fails if the server returns a reply with a status code matching the one specified by option <strong>--failure-status</strong>.</p>
  </dd>
  <dt>
    <p><strong>--wsesslog=</strong><em>N</em><strong>,</strong><em>X</em><strong>,</strong><em>F</em></p>
  </dt>
  <dd>
    <p>This specifies a session workload generator similar to <strong>--wsess</strong> (please read that description first).  With <strong>--wsesslog</strong> though, many aspects of user sessions, including the number and sequence of URI's, request method, think-time and burst-length parameters, can be specified in an input file <em>F.</em> Two other parameters are retained from <strong>--wsess,</strong> namely <em>N,</em> the number of sessions to initiate, and <em>X,</em> the burst-to-burst user think time (note that this becomes a default time since the input file <em>F</em> can also specify user think time on a per-burst basis. A small example input file can most-easily show the settable parameters:</p><p># Comment lines start with a ``#'' as the first</p><p># character.  Lines with only whitespace delimit</p><p># sessions (multiple blank lines do not generate</p><p># ``null'' sessions).  All other lines specify a</p><p># uri-sequence (1 uri per line).  If the first</p><p># character of the line is whitespace (e.g. space</p><p># or tab), the uri is considered to be part of a</p><p># burst that is sent out after the previous</p><p># non-burst uri.</p><p># session 1 definition (this is a comment)</p><p>/foo.html think=2.0</p><p>	/pict1.gif</p><p>	/pict2.gif</p><p>/foo2.html method=POST contents='Post data'</p><p>	/pict3.gif</p><p>	/pict4.gif</p><p># session 2 definition</p><p>/foo3.html method=POST contents="Multiline&#92;ndata"</p><p>/foo4.html method=HEAD</p><p>The above description specifies 2 sessions.  The first session will start with a request for /foo.html.  When the /foo.html response comes back, a burst of 2 requests will follow (/pict1.gif and /pict2.gif). When the last of those responses is received, a two second user think time is inserted before the next request of /foo2.html is issued. This request is sent as a POST.  The posted data can be contained between single- or double-quotes.  Newlines can appear within posted data as ``&#92;n'' or as a ``&#92;&lt;CR&gt;''.  The /foo2.html response is followed by a burst request of /pict3.gif and /pict4.gif, which concludes this session.  The second session is started some time after the first, as specified by the <strong>--rate</strong> or <strong>--period</strong> options.</p><p>The second session consists of 2 requests separated by the default user think time as specified by the <em>X</em> parameter of the <strong>--wsesslog</strong> option.  If the <em>N</em> parameter of <strong>--wsesslog</strong> is greater than the number of sessions defined in input file <em>F</em>, then the defined sessions are used repeatedly until <em>N</em> sessions have been created (i.e., the defined sessions are used in a round-robin fashion).</p><p>One should avoid using <strong>--wsesslog</strong> in conjunction with other <strong>httperf</strong> options that also control session behavior and workload URI's, namely <strong>--burst-length,</strong> <strong>--wsess,</strong> <strong>--wlog,</strong> and <strong>--wset.</strong></p>
  </dd>
  <dt>
    <p><strong>--wset=</strong><em>N</em><strong>,</strong><em>X</em></p>
  </dt>
  <dd>
    <p>This option can be used to walk through a list of URIs at a given rate.  Parameter <em>N</em> specifies the number of distinct URIs that should be generated and <em>X</em> specifies the rate at which new URIs are accessed.  A rate of <strong>0.25</strong> would mean that the same URI would be accessed four times in a row before moving on to the next URI.  This type of access pattern is useful in generating a workload that induces a relatively predictable amount of traffic in the disk I/O subsystem of the server (assuming <em>N</em> and the accessed files are big enough to exceed the server's buffer cache).  The URIs generated are of the form <em>prefix</em>/<em>path</em>.html, where <em>prefix</em> is the URI prefix specified by option <strong>--wset</strong> and <em>path</em> is generated as follows: for the <em>i</em>-th file in the working set, write down <em>i</em> in decimal, prefixing the number with as many zeroes as necessary to get a string that has as many digits as <em>N</em>-1. Then insert a slash character between each digit.  For example, the 103rd file in a working set consisting of 1024 files would result in a path of ``<strong>0/1/0/3</strong>''. Thus, if the URI-prefix is <strong>/wset1024</strong>, then the URI being accessed would be <strong>/wset1024/0/1/0/3.html</strong>. In other words, the files on the server need to be organized as a 10ary tree.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OUTPUT</h2>
        <div class="sectioncontent">
<p>This section describes the statistics output at the end of each test run.  The basic information shown below is printed independent of the selected workload generator.</p><p><strong>Total:</strong> connections 30000 requests 29997 replies 29997 test-duration 299.992 s</p><p><strong>Connection rate:</strong> 100.0 conn/s (10.0 ms/conn, &lt;=14 concurrent connections)</p><p><strong>Connection time [ms]:</strong> min 1.4 avg 3.0 max 163.4 median 1.5 stddev 7.3</p><p><strong>Connection time [ms]:</strong> connect 0.6</p><p><strong>Connection length [replies/conn]:</strong> 1.000</p><p><strong>Request rate:</strong> 100.0 req/s (10.0 ms/req)</p><p><strong>Request size [B]:</strong> 75.0</p><p><strong>Reply rate [replies/s]:</strong> min 98.8 avg 100.0 max 101.2 stddev 0.3 (60 samples)</p><p><strong>Reply time [ms]:</strong> response 2.4 transfer 0.0</p><p><strong>Reply size [B]:</strong> header 242.0 content 1010.0 footer 0.0 (total 1252.0)</p><p><strong>Reply status:</strong> 1xx=0 2xx=29997 3xx=0 4xx=0 5xx=0</p><p><strong>CPU time [s]:</strong> user 94.31 system 205.26 (user 31.4% system 68.4% total 99.9%)</p><p><strong>Net I/O:</strong> 129.6 KB/s (1.1*10^6 bps)</p><p><strong>Errors:</strong> total 3 client-timo 0 socket-timo 0 connrefused 3 connreset 0</p><p><strong>Errors:</strong> fd-unavail 0 addrunavail 0 ftab-full 0 other 0</p><p>There are six groups of statistics: overall results (``Total''), connection related results (``Connection''), results relating to the issuing of HTTP requests (``Request''), results relating to the replies received from the server (``Reply''), miscellaneous results relating to the CPU (``CPU'') and network (``Net I/O'') utilization and, last but not least, a summary of errors encountered (``Errors'').</p>
<dl class='dl-vertical'>
  <dt>
    <p>Total Section</p>
  </dt>
  <dd>
    <p>This section summarizes how many TCP connections were initiated by <strong>httperf</strong>, how many requests it sent out, how many replies it received, and what the total test duration was.  In the example output shown above, 30,000 connections were created, 29,997 requests were sent out and 29,997 replies were received.  The duration of the test was almost exactly 5 minutes (300 seconds).</p>
  </dd>
  <dt>
    <p>Connection Section</p>
  </dt>
  <dd>
    <p>This section conveys information related to TCP connections generated by the tool.  Specifically, the ``Connection rate'' line shows that new connections were initiated at a rate of 100.0 connections per second. This rate corresponds to a period of 10.0 milliseconds per connection.  The last number in this line shows that at most 14 connections were open at any given time.</p><p>The first line labeled ``Connection time'' gives lifetime statistics for successful connections.  The lifetime of a connection is the time between a TCP connection is initiated and the time the connection is closed.  A connection is considered successful if it had at least one call that completed successfully.  In the example output, the line indicates that the minimum (``min'') connection lifetime was 1.4 milliseconds, the average (``avg'') lifetime was 3.0 milliseconds, the maximum (``max'') was 163.4 milliseconds, the median (``median'') lifetime was 1.5 milliseconds, and that the standard deviation of the lifetimes was 7.3 milliseconds.  The median lifetime is computed based on a histogram with one millisecond resolution and a maximum lifetime of 100 seconds.  Thus, the median is accurate to within half a millisecond if at least half of the successful connections have a lifetime of no more than 100 seconds.</p><p>The next statistic in this section is the average time it took to establish a TCP connection.  Only successful TCP connection establishments are counted.  In the example, the second line labeled ``Connection time'' shows that, on average, it took 0.6 milliseconds to establish a connection.</p><p>The final line in this section is labeled ``Connection length.''  It gives the average number of replies received on each connection that received at least one reply (i.e., connections that failed before yielding the first reply are not counted).  This number can be bigger than 1.0 due to persistent connections.</p>
  </dd>
  <dt>
    <p>Request Section</p>
  </dt>
  <dd>
    <p>The line labeled ``Request rate'' gives the rate at which HTTP requests were issued and the period that this rate corresponds to.  In the example above, the request rate was 100.0 requests per second, which corresponds to 10.0 milliseconds per request.  As long as no persistent connections are employed, the results in this section are very similar or identical to results in the connection section. However, when persistent connections are used, several calls can be performed on a single connection in which case the results would be different.</p><p>The line labeled ``Request size'' gives the average size of the HTTP requests in bytes.  In the example above, the average request size was 75 bytes.</p>
  </dd>
  <dt>
    <p>Reply Section</p>
  </dt>
  <dd>
    <p>For simple measurements, this section is often the most interesting one as the line labeled ``Reply rate'' gives various statistics for the reply rate.  In the example above, the minimum (``min'') reply rate was 98.8 replies per second, the average (``avg'') was 100 replies per second, and the maximum (``max'') rate was 101.2 replies per second.  The standard deviation was 0.3 replies per second.  The number enclosed in parentheses shows that 60 reply rate samples were acquired.  At present, <strong>httperf</strong> collects a rate sample once every five seconds.  To obtain a meaningful standard deviation, it is recommended to run tests long enough so at least thirty samples are obtained.  This corresponds to a test duration of at least 150 seconds.</p><p>The line labeled ``Reply Time'' gives information on how long it took for the server to respond and how long it took to receive the reply. In the example, it took on average 2.4 milliseconds between sending the first byte of the request and receiving the first byte of the reply.  The time to ``transfer'', or read, the reply was too short to be measured, so it shows up as zero.  The is typical when the entire reply fits into a single TCP segment.</p><p>The next line, labeled ``Reply size'' contains statistics on the average size of the replies---all numbers are in reported bytes. Specifically, the line lists the average length of reply headers, the content, and footers (HTTP/1.1 uses footers to realize the ``chunked'' transfer encoding).  For convenience, the average total number of bytes in the replies is also given in parentheses.  In the example, the average header length (``header'') was 242 bytes, the average content length (``content'') was 1010 bytes, and there were no footers (``footer'' length is zero).  The total reply length of 1252 bytes on average.</p><p>The final line in this section is a histogram of the major status codes received in the replies from the server.  The major status code is the ``hundreds''-digit of the full HTTP status code.  In the example, all 29,997 replies had a major status code of 2.  It's a good guess that all status codes were ``200 OK'' but the information in the histogram is not detailed enough to allow distinguishing status codes with the same major code.</p>
  </dd>
  <dt>
    <p>Miscellaneous Section</p>
  </dt>
  <dd>
    <p>This section starts with a summary of the CPU utilization on the client machine.  In the example, the line labeled ``CPU time'' shows that 94.31 seconds were spent executing in user mode (``user''), 205.26 seconds were spent executing in system mode (``system'') and that this corresponds to 31.4% user mode execution and 68.4% system execution.  The total utilization was 99.9%, which is expected given that <strong>httperf</strong> is a CPU hog.  A total CPU utilization of significantly less than 100% is a sign that there were competing processes that interfered with the test.</p><p>The line labeled ``Net I/O'' gives the average network throughput in kilobytes per second (where a kilobyte is 1024 bytes) and in megabits per second (where a megabit is 10^6 bits).  In the example, an average network usage of about 129.6 kilobytes per second was sustained.  The number in parentheses shows that this corresponds to about 1.1 megabits per second.  This network bandwidth is computed based on the number of bytes sent and received on the TCP connections.  In other words, it does not account for the network headers or TCP retransmissions that may have occurred.</p>
  </dd>
  <dt>
    <p>Errors Section</p>
  </dt>
  <dd>
    <p>The last section contains statistics on the errors that were encountered during a test.  In the example, the two lines labeled ``Errors'' show that there were a total of three errors and that all three errors were due to the server refusing to accept a connection (``connrefused'').  A description of each error counter follows:</p><p><strong>client-timo:</strong> The number of times a session, connection, or call failed due to a client timeout (as specified by the <strong>--timeout</strong> and <strong>--think-timeout</strong>) options.</p><p><strong>socket-timo:</strong> The number of times a TCP connection failed with a socket-level timeout (ETIMEDOUT).</p><p><strong>connrefused:</strong> The number of times a TCP connection attempt failed with a ``connection refused by server'' error (ECONNREFUSED).</p><p><strong>connreset:</strong> The number of times a TCP connection failed due to a RESET from the server.  Typically, a RESET is received when the client attempts to send data to the server at a time the server has already closed its end of the connection.  NT servers also send RESETs when attempting to establish a new connection when the listen queue is full.</p><p><strong>fd-unavail:</strong> The number of times the <strong>httperf</strong> process was out of file descriptors.  Whenever this count is non-zero, the test results are meaningless because the client was overloaded (see section "CHOOSING TIMEOUT VALUES").</p><p><strong>addrunavail:</strong> The number of times the client was out of TCP port numbers (EADDRNOTAVAIL).  This error should never occur.  If it does, the results should be discarded.</p><p><strong>ftab-full:</strong> The number of times the system's file descriptor table is full. Again, this error should never occur.  If it does, the results should be discarded.</p><p><strong>other:</strong> The number of times some other type of error occurred.  Whenever this counter is non-zero, it is necessary to track down the real cause of the error.  To assist in doing this, <strong>httperf</strong> prints the error code (errno) of the first unknown errors that occurs during a test run.</p>
  </dd>

</dl>
<p>When <strong>--wsess</strong> or <strong>--wsesslog</strong> is specified, <strong>httperf</strong> generates and measures sessions instead of individual calls and additional statistics are printed at the end of a test.  An example output is shown below.</p><p><strong>Session rate [sess/s]:</strong> min 0.00 avg 0.59 max 2.40 stddev 0.37 (240/450)</p><p><strong>Session:</strong> avg 6.45 connections/session</p><p><strong>Session lifetime [s]:</strong> 123.9</p><p><strong>Session failtime [s]:</strong> 58.5</p><p><strong>Session length histogram:</strong> 4 7 4 ... 3 3 240</p><p>The line labeled ``Session rate'' shows the minium, average, and maximum rate at which sessions completed (based on a 5 second sampling interval).  It also shows the standard deviation of the session completion rate.  The numbers in parentheses show how many sessions succeeded and how many sessions were initiated.  In the example above, the minimum, average, and maximum session completion rates were 0.00, 0.59, and 2.40 sessions per second, respectively.  The standard deviation was 0.37 sessions per second and 240 out of 450 sessions completed successfully (210 failed due to errors such as timeouts).</p><p>The next line, labeled ``Session:'' shows the average length of a session measured in connections.  In the example above, an average of 6.45 connections were required to complete a session.</p><p>The line labeled ``Session lifetime'' gives the average time it took to complete a successful session.  In the example above, it took an average of 123.9 seconds.</p><p>The line labeled ``Session failtime'' gives the average time it took before an unsuccessful session failed.  In the example above, it took on average 58.5 seconds for a session to fail.</p><p>Finally, the line labeled ``Session length histogram'' gives a histogram of the number of replies received by each session.  In the example above, 4 sessions ended after receiving no reply at all, 7 ended after receiving one reply, and so on (the ellipsis indicates additional histogram counts that were omitted from this manual for space reasons).  Note that this histogram does not distinguish between successful and failed sessions.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CHOOSING TIMEOUT VALUES</h2>
        <div class="sectioncontent">
<p>Since the machine that <strong>httperf</strong> runs on has only a finite set of resource available, it can not sustain arbitrarily high HTTP loads.  For example, one limiting factor is that there are only roughly 60,000 TCP port numbers that can be in use at any given time.  Since on most UNIX systems it takes one minute for a TCP connection to be fully closed (leave the TIME_WAIT state), the maximum rate a client can sustain is at most 1,000 requests per second.</p><p>The actual sustainable rate is often much lower than that because before running out of TCP ports, the machine is likely to run out of file descriptors (one file descriptor is used up for each open TCP connection).  By default, HP-UX 10.20 allows 1,024 open file descriptors per process.  This means that without extra precautions, <strong>httperf</strong> could potentially very quickly use up all available file descriptors, at which point it could not induce any additional load on the server. To avoid this problem, <strong>httperf</strong> provides option <strong>--timeout</strong> to set a timeout for all communication with the server.  If the server does not respond before the timeout expires, the client considers the corresponding session, connection, or call to be ``dead,'' closes the associated TCP connection, and increases the ``client-timo'' error count.  The only exception to this rule is that after sending an entire request to the server, <strong>httperf</strong> allows the server to take some additional time before it starts sending the reply.  This is to accommodate HTTP requests that take a long time to complete on the server.  This additional time is called the ``server think time'' and can be specified by option <strong>--think-timeout</strong>. By default, this additional think time is zero seconds, so the server would always have to respond within the time alloted by option <strong>--timeout</strong>.</p><p>Timeouts allow <strong>httperf</strong> to sustain high offered loads even when the server is overloaded.  For example, with a timeout of 2 seconds and assuming that 1,000 file-descriptors are available, the offered load could be up to 500 requests per second (in practice, the sustainable load is often somewhat smaller than the theoretical value).  On the downside, timeouts artificially truncate the connection lifetime distribution. Thus, it is recommended to pick a timeout value that is as large as possible yet small enough to allow sustaining the desired offered rate.  A timeout as short as one second may be acceptable, but larger timeouts (5-10 seconds) are preferable.</p><p>It is important to keep in mind that timeouts do not guarantee that a client can sustain a particular offered load---there are many other potential resource bottlenecks.  For example, in some cases the client machine may simply run out of CPU time.  To ensure that a given test really measured the server's capabilities and not the client's, it is a good idea to vary the number of machines participating in a test. If observed performance remains the same as the number of client machines is varied, the test results are likely to be valid.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p><strong>httperf</strong> was developed by David Mosberger and was heavily influenced by an earlier tool written by Tai Jin.  Stephane Eranian contributed the log-file based URI generator.  Dick Carter contributed the <strong>--wsesslog</strong> workload generator, the support behind the <strong>--period</strong> option, and bug fixes.  All four authors are with Hewlett-Packard Research Laboratories.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>Probably many.  Always be sure to double-check results and don't fall prey to measuring client-performance instead of server performance!</p><p>The user-interface definitely could be improved.  A simple workload description language might be more suitable than the dozens of little command-line options the tool has right now.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="httpclient.1.html"><span aria-hidden="true">&larr;</span> httpclient.1: Shell command for performing http requests using ruby httpclient</a></li>
   <li class="next"><a href="httpfs2.1.html">httpfs2.1: Mount a file from a http server into the filesystem <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

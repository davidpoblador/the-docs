<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>htseq-count: Count the number of reads in a sam alignment file that map to gff features  given a file with aligned sequencing reads and a list of genomic features, a common task is to count how many reads map to each feature.  a feature is here an interval (i.e., a range of positions) on a chromosome or a union of such intervals.  in the case of rna-seq, the features are typically genes, where each gene is considered here as the union of all its exons. one may also consider each exon as a feature, e.g., in order to check for alternative splicing. for comparative chip-seq, the features might be binding region from a pre-determined list.  special care must be taken to decide how to deal with reads that overlap more than one feature. the htseq-count script allows to choose between three modes. of course, if none of these fits your needs, you can write your own script with htseq. see the chapter tour for a step-by-step guide on how to do so.  the three overlap resolution modes of htseq-count work as follows. for each position i in the read, a set s(i) is defined as the set of all features overlapping position i. then, consider the set s, which is (with i running through all position within the read) the union of all the sets s(i) for mode union. the intersection of all the sets s(i) for mode intersection-strict. the intersection of all non-empty sets s(i) for mode intersection-nonempty.  if s contains precisely one feature, the read is counted for this feature. if it contains more than one feature, the read is counted as ambiguous (and not counted for any features), and if s is empty, the read is counted as no_feature.  the following figure illustrates the effect of these three modes: [image]</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Count the number of reads in a sam alignment file that map to gff features  given a file with aligned sequencing reads and a list of genomic features, a common task is to count how many reads map to each feature.  a feature is here an interval (i.e., a range of positions) on a chromosome or a union of such intervals.  in the case of rna-seq, the features are typically genes, where each gene is considered here as the union of all its exons. one may also consider each exon as a feature, e.g., in order to check for alternative splicing. for comparative chip-seq, the features might be binding region from a pre-determined list.  special care must be taken to decide how to deal with reads that overlap more than one feature. the htseq-count script allows to choose between three modes. of course, if none of these fits your needs, you can write your own script with htseq. see the chapter tour for a step-by-step guide on how to do so.  the three overlap resolution modes of htseq-count work as follows. for each position i in the read, a set s(i) is defined as the set of all features overlapping position i. then, consider the set s, which is (with i running through all position within the read) the union of all the sets s(i) for mode union. the intersection of all the sets s(i) for mode intersection-strict. the intersection of all non-empty sets s(i) for mode intersection-nonempty.  if s contains precisely one feature, the read is counted for this feature. if it contains more than one feature, the read is counted as ambiguous (and not counted for any features), and if s is empty, the read is counted as no_feature.  the following figure illustrates the effect of these three modes: [image]">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="htseq-count (1) manual">
  <meta name="twitter:description" content="Count the number of reads in a sam alignment file that map to gff features  given a file with aligned sequencing reads and a list of genomic features, a common task is to count how many reads map to each feature.  a feature is here an interval (i.e., a range of positions) on a chromosome or a union of such intervals.  in the case of rna-seq, the features are typically genes, where each gene is considered here as the union of all its exons. one may also consider each exon as a feature, e.g., in order to check for alternative splicing. for comparative chip-seq, the features might be binding region from a pre-determined list.  special care must be taken to decide how to deal with reads that overlap more than one feature. the htseq-count script allows to choose between three modes. of course, if none of these fits your needs, you can write your own script with htseq. see the chapter tour for a step-by-step guide on how to do so.  the three overlap resolution modes of htseq-count work as follows. for each position i in the read, a set s(i) is defined as the set of all features overlapping position i. then, consider the set s, which is (with i running through all position within the read) the union of all the sets s(i) for mode union. the intersection of all the sets s(i) for mode intersection-strict. the intersection of all non-empty sets s(i) for mode intersection-nonempty.  if s contains precisely one feature, the read is counted for this feature. if it contains more than one feature, the read is counted as ambiguous (and not counted for any features), and if s is empty, the read is counted as no_feature.  the following figure illustrates the effect of these three modes: [image]">
  <meta name="twitter:image" content="https://www.carta.tech/images/python-htseq-htseq-count-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/htseq-count.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="htseq-count (1) manual" />
  <meta property="og:description" content="Count the number of reads in a sam alignment file that map to gff features  given a file with aligned sequencing reads and a list of genomic features, a common task is to count how many reads map to each feature.  a feature is here an interval (i.e., a range of positions) on a chromosome or a union of such intervals.  in the case of rna-seq, the features are typically genes, where each gene is considered here as the union of all its exons. one may also consider each exon as a feature, e.g., in order to check for alternative splicing. for comparative chip-seq, the features might be binding region from a pre-determined list.  special care must be taken to decide how to deal with reads that overlap more than one feature. the htseq-count script allows to choose between three modes. of course, if none of these fits your needs, you can write your own script with htseq. see the chapter tour for a step-by-step guide on how to do so.  the three overlap resolution modes of htseq-count work as follows. for each position i in the read, a set s(i) is defined as the set of all features overlapping position i. then, consider the set s, which is (with i running through all position within the read) the union of all the sets s(i) for mode union. the intersection of all the sets s(i) for mode intersection-strict. the intersection of all non-empty sets s(i) for mode intersection-nonempty.  if s contains precisely one feature, the read is counted for this feature. if it contains more than one feature, the read is counted as ambiguous (and not counted for any features), and if s is empty, the read is counted as no_feature.  the following figure illustrates the effect of these three modes: [image]" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/python-htseq-htseq-count-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">htseq-count<small> (1)</small></h1>
        <p class="lead">Count the number of reads in a sam alignment file that map to gff features  given a file with aligned sequencing reads and a list of genomic features, a common task is to count how many reads map to each feature.  a feature is here an interval (i.e., a range of positions) on a chromosome or a union of such intervals.  in the case of rna-seq, the features are typically genes, where each gene is considered here as the union of all its exons. one may also consider each exon as a feature, e.g., in order to check for alternative splicing. for comparative chip-seq, the features might be binding region from a pre-determined list.  special care must be taken to decide how to deal with reads that overlap more than one feature. the htseq-count script allows to choose between three modes. of course, if none of these fits your needs, you can write your own script with htseq. see the chapter tour for a step-by-step guide on how to do so.  the three overlap resolution modes of htseq-count work as follows. for each position i in the read, a set s(i) is defined as the set of all features overlapping position i. then, consider the set s, which is (with i running through all position within the read) the union of all the sets s(i) for mode union. the intersection of all the sets s(i) for mode intersection-strict. the intersection of all non-empty sets s(i) for mode intersection-nonempty.  if s contains precisely one feature, the read is counted for this feature. if it contains more than one feature, the read is counted as ambiguous (and not counted for any features), and if s is empty, the read is counted as no_feature.  the following figure illustrates the effect of these three modes: [image]</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/htseq-count.1.html">
      <span itemprop="name">htseq-count: Count the number of reads in a sam alignment file that map to gff features  given a file with aligned sequencing reads and a list of genomic features, a common task is to count how many reads map to each feature.  a feature is here an interval (i.e., a range of positions) on a chromosome or a union of such intervals.  in the case of rna-seq, the features are typically genes, where each gene is considered here as the union of all its exons. one may also consider each exon as a feature, e.g., in order to check for alternative splicing. for comparative chip-seq, the features might be binding region from a pre-determined list.  special care must be taken to decide how to deal with reads that overlap more than one feature. the htseq-count script allows to choose between three modes. of course, if none of these fits your needs, you can write your own script with htseq. see the chapter tour for a step-by-step guide on how to do so.  the three overlap resolution modes of htseq-count work as follows. for each position i in the read, a set s(i) is defined as the set of all features overlapping position i. then, consider the set s, which is (with i running through all position within the read) the union of all the sets s(i) for mode union. the intersection of all the sets s(i) for mode intersection-strict. the intersection of all non-empty sets s(i) for mode intersection-nonempty.  if s contains precisely one feature, the read is counted for this feature. if it contains more than one feature, the read is counted as ambiguous (and not counted for any features), and if s is empty, the read is counted as no_feature.  the following figure illustrates the effect of these three modes: [image]</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/python-htseq/">
      <span itemprop="name">python-htseq</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/htseq-count.1.html">
      <span itemprop="name">htseq-count: Count the number of reads in a sam alignment file that map to gff features  given a file with aligned sequencing reads and a list of genomic features, a common task is to count how many reads map to each feature.  a feature is here an interval (i.e., a range of positions) on a chromosome or a union of such intervals.  in the case of rna-seq, the features are typically genes, where each gene is considered here as the union of all its exons. one may also consider each exon as a feature, e.g., in order to check for alternative splicing. for comparative chip-seq, the features might be binding region from a pre-determined list.  special care must be taken to decide how to deal with reads that overlap more than one feature. the htseq-count script allows to choose between three modes. of course, if none of these fits your needs, you can write your own script with htseq. see the chapter tour for a step-by-step guide on how to do so.  the three overlap resolution modes of htseq-count work as follows. for each position i in the read, a set s(i) is defined as the set of all features overlapping position i. then, consider the set s, which is (with i running through all position within the read) the union of all the sets s(i) for mode union. the intersection of all the sets s(i) for mode intersection-strict. the intersection of all non-empty sets s(i) for mode intersection-nonempty.  if s contains precisely one feature, the read is counted for this feature. if it contains more than one feature, the read is counted as ambiguous (and not counted for any features), and if s is empty, the read is counted as no_feature.  the following figure illustrates the effect of these three modes: [image]</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">USAGE</h2>
        <div class="sectioncontent">
<p>After you have installed HTSeq (see <em>install</em>), you can run <strong>htseq-count</strong> from the command line:</p>
<pre>
htseq-count [options] &lt;sam_file&gt; &lt;gff_file&gt;
</pre>
<p>If the file <strong>htseq-qa</strong> is not in your path, you can, alternatively, call the script with</p>
<pre>
python -m HTSeq.scripts.count [options] &lt;sam_file&gt; &lt;gff_file&gt;
</pre>
<p>The &lt;sam_file&gt; contains the aligned reads in the SAM format. (Note that the <em>SAMtools</em> contain Perl scripts to convert most alignment formats to SAM.) Make sure to use a splicing-aware aligner such as TopHat. HTSeq-count makes full use of the information in the CIGAR field.</p><p>To read from standard input, use <strong>-</strong> as <strong>&lt;sam_file&gt;</strong>.</p><p>If you have paired-end data, you have to sort the SAM file by read name first.  (If your sorting tool cannot handle big files, try e.g. Ruan Jue&apos;s <em>msort</em>, available from the <em>SOAP</em> web site.)</p><p>The &lt;gff_file&gt; contains the features in the <em>GFF format</em>.</p><p>The script outputs a table with counts for each feature, followed by the special counters, which count reads that were not counted for any feature for various reasons, namely:</p><ul>
<li><p><strong>no_feature</strong>: reads which could not be assigned to any feature (set <em>S</em> as described above was empty).</p></li><li><p><strong>ambiguous</strong>: reads which could have been assigned to more than one feature and hence were not counted for any of these (set <em>S</em> had mroe than one element).</p></li><li><p><strong>too_low_aQual</strong>: reads which were not counted due to the <strong>-a</strong> option, see below</p></li><li><p><strong>not_aligned</strong>: reads in the SAM file without alignment</p></li><li><p><strong>alignment_not_unique</strong>: reads with more than one reported alignment. These reads are recognized from the <strong>NH</strong> optional SAM field tag. (If the aligner does not set this field, multiply aligned reads will be counted multiple times.)</p><p><em>Important:</em> The default for strandedness is <em>yes</em>. If your RNA-Seq data has not been made with a strand-specific protocol, this causes half of the reads to be lost. Hence, make sure to set the option <strong>--stranded=no</strong> unless you have strand-specific data!</p></li>
</ul><h3>Options</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong>-m &lt;mode&gt;, --mode=&lt;mode&gt;</strong></p>
  </dt>
  <dd>
    <p>Mode to handle reads overlapping more than one feature. Possible values for <em>&lt;mode&gt;</em> are <strong>union</strong>, <strong>intersection-strict</strong> and <strong>intersection-nonempty</strong> (default: <strong>union</strong>)</p>
  </dd>
  <dt>
    <p><strong>-s &lt;yes, no or reverse&gt;, --stranded=&lt;yes, no, or reverse&gt;</strong></p>
  </dt>
  <dd>
    <p>whether the data is from a strand-specific assay (default: <strong>yes</strong>)</p><p>For stranded=no, a read is considered overlapping with a feature regardless of whether it is mapped to the same or the opposite strand as the feature. For stranded=yes and single-end reads, the read has to be mapped to the same strand as the feature. For paired-end reads, the first read has to be on the same strand and the second read on the opposite strand. For stranded=reverse, these rules are reversed.</p>
  </dd>
  <dt>
    <p><strong>-a &lt;minaqual&gt;, --a=&lt;minaqual&gt;</strong></p>
  </dt>
  <dd>
    <p>skip all reads with alignment quality lower than the given minimum value (default: 0)</p>
  </dd>
  <dt>
    <p><strong>-t &lt;feature type&gt;, --type=&lt;feature type&gt;</strong></p>
  </dt>
  <dd>
    <p>feature type (3rd column in GFF file) to be used, all features of other type are ignored (default, suitable for RNA-Seq and <em>Ensembl GTF</em> files: <strong>exon</strong>)</p>
  </dd>
  <dt>
    <p><strong>-i &lt;id attribute&gt;, --idattr=&lt;id attribute&gt;</strong></p>
  </dt>
  <dd>
    <p>GFF attribute to be used as feature ID. Several GFF lines with the same feature ID will be considered as parts of the same feature. The feature ID is used to identity the counts in the output table. The default, suitable for RNA-SEq and Ensembl GTF files, is <strong>gene_id</strong>.</p>
  </dd>
  <dt>
    <p><strong>-o &lt;samout&gt;, --samout=&lt;samout&gt;</strong></p>
  </dt>
  <dd>
    <p>write out all SAM alignment records into an output SAM file called &lt;samout&gt;, annotating each line with its assignment to a feature or a special counter (as an optional field with tag &apos;XF&apos;)</p>
  </dd>
  <dt>
    <p><strong>-q, --quiet</strong></p>
  </dt>
  <dd>
    <p>suppress progress report and warnings</p>
  </dd>
  <dt>
    <p><strong>-h, --help</strong></p>
  </dt>
  <dd>
    <p>Show a usage summary and exit</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Simon Anders</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>2010, Simon Anders</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="htsearch.1.html"><span aria-hidden="true">&larr;</span> htsearch.1: Create document index and word database for the ht://dig search engine</a></li>
   <li class="next"><a href="htseq-qa.1.html">htseq-qa.1: Perform simple quality assesment of high-throughput sequencing reads  the python script htseq-qa takes a file with sequencing reads (either raw or aligned reads) and produces a pdf file with useful plots to assess the technical quality of a run. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>swaks: Swiss army knife smtp, the all-purpose smtp transaction tester</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Swiss army knife smtp, the all-purpose smtp transaction tester">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="swaks (1) manual">
  <meta name="twitter:description" content="Swiss army knife smtp, the all-purpose smtp transaction tester">
  <meta name="twitter:image" content="https://www.carta.tech/images/swaks-swaks-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/swaks.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="swaks (1) manual" />
  <meta property="og:description" content="Swiss army knife smtp, the all-purpose smtp transaction tester" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/swaks-swaks-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">swaks<small> (1)</small></h1>
        <p class="lead">Swiss army knife smtp, the all-purpose smtp transaction tester</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/swaks.1.html">
      <span itemprop="name">swaks: Swiss army knife smtp, the all-purpose smtp transaction tester</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/swaks/">
      <span itemprop="name">swaks</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/swaks.1.html">
      <span itemprop="name">swaks: Swiss army knife smtp, the all-purpose smtp transaction tester</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>swaks' primary design goal is to be a flexible, scriptable, transaction-oriented \s-1SMTP\s0 test tool.  It handles \s-1SMTP\s0 features and extensions such as \s-1TLS\s0, authentication, and pipelining; multiple version of the \s-1SMTP\s0 protocol including \s-1SMTP\s0, \s-1ESMTP\s0, and \s-1LMTP\s0; and multiple transport methods including unix-domain sockets, internet-domain sockets, and pipes to spawned processes.  Options can be specified in environment variables, configuration files, and the command line allowing maximum configurability and ease of use for operators and scripters.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">QUICK START</h2>
        <div class="sectioncontent">
<p>Deliver a standard test email to user@example.com on port 25 of test-server.example.net:</p>
<pre>
 swaks --to user@example.com --server test-server.example.net
</pre>
<p>Deliver a standard test email, requiring \s-1CRAM-MD5\s0 authentication as user me@example.com.  An \*(L"X-Test\*(R" header will be added to the email body.  The authentication password will be prompted for.  swaks --to user@example.com --from me@example.com --auth CRAM-MD5 --auth-user me@example.com --header-X-Test "test email"</p><p>Test a virus scanner using \s-1EICAR\s0 in an attachment.  Don't show the message \s-1DATA\s0 part.:  swaks -t user@example.com --attach - --server test-server.example.com --suppress-data &lt;/path/to/eicar.txt</p><p>Test a spam scanner using \s-1GTUBE\s0 in the body of an email, routed via the \s-1MX\s0 records for example.com:  swaks --to user@example.com --body /path/to/gtube/file</p><p>Deliver a standard test email to user@example.com using the \s-1LMTP\s0 protocol via a \s-1UNIX\s0 domain socket file  swaks --to user@example.com --socket /var/lda.sock --protocol LMTP</p><p>Report all the recipients in a text file that are non-verifyiable on a test server:  for E in &#96;cat /path/to/email/file&#96;  do      swaks --to $E --server test-server.example.com --quit-after RCPT --hide-all      [ $? -ne 0 ] && echo $E  done</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TERMS AND CONVENTIONS</h2>
        <div class="sectioncontent">
<p>This document tries to be consistent and specific in its use of the following terms to reduce confusion.</p>
<dl class='dl-vertical'>
  <dt>
    Transaction
  </dt>
  <dd>
    <p>A transaction is the opening of a connection over a transport to a target and using a messaging protocol to attempt to deliver a message.</p>
  </dd>
  <dt>
    Target
  </dt>
  <dd>
    <p>The target of a transaction is the thing that swaks connects to.  This generic term is used throughout the documentation because most other terms improperly imply something about the transport being used.</p>
  </dd>
  <dt>
    Transport
  </dt>
  <dd>
    <p>The transport is the underlying method used to connect to the target.</p>
  </dd>
  <dt>
    Protocol
  </dt>
  <dd>
    <p>The protocol is the application language used to communicate with the target.  This document uses \s-1SMTP\s0 to speak generically of all three supported protocols unless it states that it is speaking of the specific '\s-1SMTP\s0' protocol and excluding the others.</p>
  </dd>
  <dt>
    Message
  </dt>
  <dd>
    <p>\s-1SMTP\s0 protocols exist to transfer messages, a set of bytes in an agreed-upon format that has a sender and a recipient.</p>
  </dd>
  <dt>
    Envelope
  </dt>
  <dd>
    <p>A message's envelope contains the \*(L"true\*(R" sender and receiver of a message.  It can also be referred to as its components, envelope-sender and envelope-recipients.  It is important to note that a messages envelope does not have to match its To: and From: headers.</p>
  </dd>
  <dt>
    \s-1DATA\s0
  </dt>
  <dd>
    <p>The \s-1DATA\s0 portion of an \s-1SMTP\s0 transaction is the actual message that is being transported.  It consists of both the message's headers and its body.  \s-1DATA\s0 and body are sometimes use synonymously, but they are always two distinct things in this document.</p>
  </dd>
  <dt>
    Headers
  </dt>
  <dd>
    <p>A message's headers are defined as all the lines in the message's \s-1DATA\s0 section before the first blank line.  They contain information about the email that will be displayed to the recipient such as To:, From:, Subject:, etc.  In this document headers will always be written with a capitalized first letter and a trailing colon.</p>
  </dd>
  <dt>
    Body
  </dt>
  <dd>
    <p>A message's body is the portion of its \s-1DATA\s0 section following the first blank line.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTION PROCESSING</h2>
        <div class="sectioncontent">
<p>To prevent potential confusion in this document a flag to swaks is always referred to as an \*(L"option\*(R".  If the option takes additional data, that additional data is referred to as an argument to the option.  For example, \*(L"--from fred@example.com\*(R" might be provided to swaks on the command line, with \*(L"--from\*(R" being the option and \*(L"fred@example.com\*(R" being --from's argument.</p><p>Options can be given to swaks in three ways.  They can be specified in a configuration file, in environment variables, and on the command line.  Depending on the specific option and whether or not an argument is given to it, swaks may prompt the user for the argument.</p><p>When swaks evaluates its options, it first looks for a configuration file (either in a default location or specified with --config).  Then it evaluates any options in environment variables.  Finally, it evaluates command line options.  At each round of processing, any options set earlier will be overridden.  Additionally, any option can be prefixed with \*(L"no-\*(R" to cause swaks to forget that the variable had previously been set.  This capability is necessary because many options treat defined-but-no-argument differently than not-defined.</p><p>The exact mechanism and format for using each of the types is listed below.</p>
<dl class='dl-vertical'>
  <dt>
    \s-1CONFIGURATION\s0 \s-1FILE\s0
  </dt>
  <dd>
    <p>A configuration file can be used to set commonly-used or abnormally verbose options.  By default swaks looks in order for $SWAKS_HOME/.swaksrc, $HOME/.swaksrc, and $LOGDIR/.swaksrc.  If one of those is found to exist (and --config has not been used) that file is used as the configuration file. Additionally a configuration file in a non-default location can be specified using --config.  If this is set and not given an argument swaks will not use any configuration file, including any default file.  If --config points to a readable file, it is used as the configuration file, overriding any default that may exist.  If it points to a non-readable file and error will be shown and swaks will exit. A set of \*(L"portable\*(R" defaults can also be created by adding options to the end of the swaks program file.  As distributed, the last line of swaks should be \*(L"_\|_END_\|_\*(R".  Any lines added after _\|_END_\|_ will be treated as the contents of a configuration file.  This allows a set of user preferences to be automatically copied from server to server in a single file. If present and configuration files have not been explicitly turned off, the _\|_END_\|_ config is always read.  Only one other configuration file will ever be used per single invocation of swaks, even if multiple configuration files are specified.  Specifying the --config option with no argument turns off the processing of both the _\|_END_\|_ config and any actual config files. In a configuration file lines beginning with a hash (#) are ignored.  All other lines are assumed to be an option to swaks, with the leading dash or dashes optional.  Everything after a option line's first space is assumed to be the option's argument and is not shell processed.  Therefore quoting is usually unneeded and will be included literally in the argument.  Here is an example of the contents of a configuration file:     # always use this sender, no matter server or logged in user     --from fred@example.com     # I prefer my test emails have a pretty from header.  Note     # the lack of dashes on option and lack of quotes around     # entire argument.     h-From: "Fred Example" &lt;fred@example.com&gt;</p>
  </dd>
  <dt>
    \s-1ENVIRONMENT\s0 \s-1VARIABLES\s0
  </dt>
  <dd>
    <p>Options can be supplied via environment variables.  The variables are in the form $SWAKS_OPT_name, where name is the name of the option that would be specified on the command line.  Because dashes aren't allowed in environment variable names in most unix-ish shells, no leading dashes should be used and any dashes inside the option's name should be replaced with underscores.  The following would create the same options shown in the configuration file example:     $ SWAKS_OPT_from=&apos;fred@example.com&apos;     $ SWAKS_OPT_h_From=&apos;"Fred Example" &lt;fred@example.com&gt;&apos; Setting a variable to an empty value is the same as specifying it on the command line with no argument.  For instance, setting SWAKS_OPT_server="" would cause swaks to prompt the use for the server to which to connect at each invocation. In addition to setting the equivalent of command line options, \s-1SWAKS_HOME\s0 can be set to a directory containing the default .swaksrc to be used.</p>
  </dd>
  <dt>
    \s-1COMMAND\s0 \s-1LINE\s0 \s-1OPTIONS\s0
  </dt>
  <dd>
    <p>The final method of supplying options to swaks is via the command line.  The options behave in a manner consistent with most unix-ish command line programs.  Many options have both a short and long form (for instance -s and --server).  By convention short options are specified with a single dash and long options are specified with a double-dash.  This is only a convention and either prefix will work with either type. The following demonstrates the example shown in the configuration file and environment variable sections:     $ swaks --from fred@example.com --h-From: &apos;"Fred Example" &lt;fred@example.com&gt;&apos;</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TRANSPORTS</h2>
        <div class="sectioncontent">
<p>swaks can connect to a target via unix pipes (\*(L"pipes\*(R"), unix domain sockets (\*(L"unix sockets\*(R"), or internet domain sockets (\*(L"network sockets\*(R").  Connecting via network sockets is the default behavior.  Because of the singular nature of the transport used, each set of options in the following section is mutually exclusive.  Specifying more than one of --server, --pipe, or --socket will result in an error.  Mixing other options between transport types will only result in the irrelevant options being ignored.  Below is a brief description of each type of transport and the options that are specific to that transport type.</p>
<dl class='dl-vertical'>
  <dt>
    \s-1NETWORK\s0 \s-1SOCKETS\s0
  </dt>
  <dd>
    <p>This transport attempts to deliver a message via \s-1TCP/IP\s0, the standard method for delivering \s-1SMTP\s0.  This is the default transport for swaks.  If none of --server, --pipe, or --socket are given then this transport is used and the target server is determined from the recipient's domain (see --server below for more details). This transport requires the IO::Socket module which is part of the standard perl distribution.  If this module is not loadable, attempting to use a this transport will result in an error and program termination. IPv6 is supported when the IO::Socket::INET6 module is present.</p>
<dl class='dl-vertical'>
  <dt>
    -s, --server [target mail server[:port]]
  </dt>
  <dd>
    <p>Explicitly tell swaks to use network sockets and specify the hostname or \s-1IP\s0 address to which to connect, or prompt if no argument is given.  If this option is not given and no other transport option is given, the target mail server is determined from the appropriate \s-1DNS\s0 records for the domain of the recipient email address using the Net::DNS module.  If Net::DNS is not available swaks will attempt to connect to localhost to deliver.  The target port can optionally be set here.  Supported formats for this include \s-1SERVER:PORT\s0 (supporting names and IPv4 addresses); [\s-1SERVER\s0]:PORT and \s-1SERVER/PORT\s0 (supporting names, IPv4 and IPv6 addresses).  See also --copy-routing.</p>
  </dd>
  <dt>
    -p, --port [port]
  </dt>
  <dd>
    <p>Specify which \s-1TCP\s0 port on the target is to be used, or prompt if no argument is listed.  The argument can be a service name (as retrieved by <em>getservbyname</em>\|(3)) or a port number.  The default port is determined by the --protocol option.  See --protocol for more details.</p>
  </dd>
  <dt>
    -li, --local-interface [\s-1IP\s0 or hostname[:port]]
  </dt>
  <dd>
    <p>Use argument as the local interface for the outgoing \s-1SMTP\s0 connection, or prompt user if no argument given.  Argument can be an \s-1IP\s0 address or a hostname.  Default action is to let the operating system choose local interface.  See --server for additional comments on :port format.</p>
  </dd>
  <dt>
    -lp, --local-port [port]
  </dt>
  <dd>
    <p>Specify the outgoing port to originate the transaction from.  If this option is not specified the system will pick an ephemeral port.  Note that regular users cannot specify some ports.</p>
  </dd>
  <dt>
    --copy-routing [domain]
  </dt>
  <dd>
    <p>The argument is interpreted as the domain part of an email address and it is used to find the target server using the same logic that would be used to look up the target server for an recipient email address.  See  --to option for more details on how the target is determined from the email domain.</p>
  </dd>
  <dt>
    -4, -6
  </dt>
  <dd>
    <p>Force IPv4 or IPv6.</p>
  </dd>

</dl>

  </dd>
  <dt>
    \s-1UNIX\s0 \s-1SOCKETS\s0
  </dt>
  <dd>
    <p>This transport method attempts to deliver messages via a unix-domain socket file.  This is useful for testing MTA/MDAs that listen on socket files (for instance, testing \s-1LMTP\s0 delivery to Cyrus).  This transport requires the IO::Socket module which is part of the standard perl distribution.  If this module is not loadable, attempting to use this transport will result in an error and program termination.</p>
<dl class='dl-vertical'>
  <dt>
    --socket [/path/to/socket/file]
  </dt>
  <dd>
    <p>This option takes as its argument a unix-domain socket file.  If swaks is unable to open this socket it will display an error and exit.</p>
  </dd>

</dl>

  </dd>
  <dt>
    \s-1PIPES\s0
  </dt>
  <dd>
    <p>This transport attempts to spawn a process and communicate with it via pipes.  The spawned program must be prepared to behave as a mail server over \s-1STDIN/STDOUT\s0.  Any \s-1MTA\s0 designed to operate from inet/xinet should support this.  In addition some MTAs provide testing modes that can be communicated with via \s-1STDIN/STDOUT\s0.  This transport can be used to automate that testing.  For example, if you implemented \s-1DNSBL\s0 checking with Exim and you wanted to make sure it was working, you could run 'swaks --pipe \*(L"exim -bh 127.0.0.2\*(R"'.  In an ideal world the process you are talking to should behave exactly like an \s-1SMTP\s0 server on stdin and stdout.  Any debugging should be sent to stderr, which will be directed to your terminal.  In the real world swaks can generally handle some debug on the child's stdout, but there are no guarantees on how much it can handle. This transport requires the IPC::Open2 module which is part of the standard perl distribution.  If this module is not loadable, attempting to use this transport will result in an error and program termination.</p>
<dl class='dl-vertical'>
  <dt>
    --pipe [/path/to/command and arguments]
  </dt>
  <dd>
    <p>Provide a process name and arguments to the process.  swaks will attempt to spawn the process and communicate with it via pipes.  If the argument is not an executable swaks will display an error and exit.</p>
  </dd>

</dl>

  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PROTOCOL OPTIONS</h2>
        <div class="sectioncontent">
<p>These options are related to the protocol layer.</p>
<dl class='dl-vertical'>
  <dt>
    -t, --to [email-address[,email-address,...]]
  </dt>
  <dd>
    <p>Tells swaks to use argument(s) as the envelope-recipient for the email, or prompt for recipient if no argument provided.  If multiple recipients are provided and the recipient domain is needed to determine routing the domain of the last recipient provided is used. There is no default value for this option.  If no recipients are provided via any means, user will be prompted to provide one interactively.  The only exception to this is if a --quit-after value is provided which will cause the smtp transaction to be terminated before the recipient is needed.</p>
  </dd>
  <dt>
    -f, --from [email-address]
  </dt>
  <dd>
    <p>Use argument as envelope-sender for email, or prompt user if no argument specified.  The string &lt;&gt; can be supplied to mean the null sender.  If user does not specify a sender address a default value is used.  The domain-part of the default sender is a best guess at the fully-qualified domain name of the local host.  The method of determining the local-part varies.  On Windows, <em>Win32::LoginName()</em> is used.  On unix-ish platforms, the $LOGNAME environment variable is used if it is set.  Otherwise <em>getpwuid</em>\|(3) is used.  See also --force-getpwuid.</p>
  </dd>
  <dt>
    --ehlo, --lhlo, -h, --helo [helo-string]
  </dt>
  <dd>
    <p>String to use as argument to \s-1HELO/EHLO/LHLO\s0 command, or prompt use if no argument is specified.  If this option is not used a best guess at the fully-qualified domain name of the local host is used.  If the Sys::Hostname module, which is part of the base distribution, is not available the user will be prompted for a \s-1HELO\s0 value.  Note that Sys::Hostname has been observed to not be able to find the local hostname in certain circumstances.  This has the same effect as if Sys::Hostname were unavailable.</p>
  </dd>
  <dt>
    -q, --quit-after [stop-point]
  </dt>
  <dd>
    <p>Point at which the transaction should be stopped.  When the requested stopping point is reached in the transaction, and provided that swaks has not errored out prior to reaching it,  swaks will send \*(L"\s-1QUIT\s0\*(R" and attempt to close the connection cleanly.  These are the valid arguments and notes about their meaning.</p>
<dl class='dl-vertical'>
  <dt>
    \s-1CONNECT\s0, \s-1BANNER\s0
  </dt>
  <dd>
    <p>Terminate the session after receiving the greeting banner from the target.</p>
  </dd>
  <dt>
    FIRST-HELO, FIRST-EHLO, FIRST-LHLO
  </dt>
  <dd>
    <p>In a \s-1STARTTLS\s0 (but not tls-on-connect) session, terminate the transaction after the first of two HELOs.  In a non-STARTTLS transaction, behaves the same as \s-1HELO\s0 (see below).</p>
  </dd>
  <dt>
    \s-1XCLIENT\s0
  </dt>
  <dd>
    <p>Quit after \s-1XCLIENT\s0 is sent</p>
  </dd>
  <dt>
    \s-1TLS\s0
  </dt>
  <dd>
    <p>Quit the transaction immediately following \s-1TLS\s0 negotiation.  Note that this happens in different places depending on whether \s-1STARTTLS\s0 or tls-on-connect are used.  This always quits after the point where \s-1TLS\s0 would have been negotiated, regardless of whether it was attempted.</p>
  </dd>
  <dt>
    \s-1HELO\s0, \s-1EHLO\s0, \s-1LHLO\s0
  </dt>
  <dd>
    <p>In a \s-1STARTTLS\s0 or \s-1XCLIENT\s0 session, quit after the second \s-1HELO\s0.  Otherwise quit after the first and only \s-1HELO\s0.</p>
  </dd>
  <dt>
    \s-1AUTH\s0
  </dt>
  <dd>
    <p>Quit after authentication.  This always quits after the point where authentication would have been negotiated, regardless of whether it was attempted.</p>
  </dd>
  <dt>
    \s-1MAIL\s0, \s-1FROM\s0
  </dt>
  <dd>
    <p>Quit after \s-1MAIL\s0 \s-1FROM:\s0 is sent.</p>
  </dd>
  <dt>
    \s-1RCPT\s0, \s-1TO\s0
  </dt>
  <dd>
    <p>Quit after \s-1RCPT\s0 \s-1TO:\s0 is sent.</p>
  </dd>

</dl>

  </dd>
  <dt>
    --timeout [time]
  </dt>
  <dd>
    <p>Use argument as the \s-1SMTP\s0 transaction timeout, or prompt user if no argument given.  Argument can either be a pure digit, which will be interpretted as seconds, or can have a specifier s or m (5s = 5 seconds, 3m = 180 seconds).  As a special case, 0 means don't timeout the transactions.  Default value is 30s.</p>
  </dd>
  <dt>
    --protocol [protocol]
  </dt>
  <dd>
    <p>Specify which protocol to use in the transaction.  Valid options are shown in the table below.  Currently the 'core' protocols are \s-1SMTP\s0, \s-1ESMTP\s0, and \s-1LMTP\s0.  By using variations of these protocol types one can tersely specify default ports, whether authentication should be attempted, and the type of \s-1TLS\s0 connection that should be attempted.  The default protocol is \s-1ESMTP\s0.  This table demonstrates the available arguments to --protocol and the options each sets as a side effect:</p>
<dl class='dl-vertical'>
  <dt>
    \s-1SMTP\s0
  </dt>
  <dd>
    <p>\s-1HELO\s0, \*(L"-p 25\*(R"</p>
  </dd>
  <dt>
    \s-1SSMTP\s0
  </dt>
  <dd>
    <p>\s-1EHLO-\s0&gt;\s-1HELO\s0, \*(L"-tlsc -p 465\*(R"</p>
  </dd>
  <dt>
    \s-1SSMTPA\s0
  </dt>
  <dd>
    <p>\s-1EHLO-\s0&gt;\s-1HELO\s0, \*(L"-a -tlsc -p 465\*(R"</p>
  </dd>
  <dt>
    \s-1SMTPS\s0
  </dt>
  <dd>
    <p>\s-1HELO\s0, \*(L"-tlsc -p 465\*(R"</p>
  </dd>
  <dt>
    \s-1ESMTP\s0
  </dt>
  <dd>
    <p>\s-1EHLO-\s0&gt;\s-1HELO\s0, \*(L"-p 25\*(R"</p>
  </dd>
  <dt>
    \s-1ESMTPA\s0
  </dt>
  <dd>
    <p>\s-1EHLO-\s0&gt;\s-1HELO\s0, \*(L"-a -p 25\*(R"</p>
  </dd>
  <dt>
    \s-1ESMTPS\s0
  </dt>
  <dd>
    <p>\s-1EHLO-\s0&gt;\s-1HELO\s0, \*(L"-tls -p 25\*(R"</p>
  </dd>
  <dt>
    \s-1ESMTPSA\s0
  </dt>
  <dd>
    <p>\s-1EHLO-\s0&gt;\s-1HELO\s0, \*(L"-a -tls -p 25\*(R"</p>
  </dd>
  <dt>
    \s-1LMTP\s0
  </dt>
  <dd>
    <p>\s-1LHLO\s0, \*(L"-p 24\*(R"</p>
  </dd>
  <dt>
    \s-1LMTPA\s0
  </dt>
  <dd>
    <p>\s-1LHLO\s0, \*(L"-a -p 24\*(R"</p>
  </dd>
  <dt>
    \s-1LMTPS\s0
  </dt>
  <dd>
    <p>\s-1LHLO\s0, \*(L"-tls -p 24\*(R"</p>
  </dd>
  <dt>
    \s-1LMTPSA\s0
  </dt>
  <dd>
    <p>\s-1LHLO\s0, \*(L"-a -tls -p 24\*(R"</p>
  </dd>

</dl>

  </dd>
  <dt>
    --pipeline
  </dt>
  <dd>
    <p>If the remote server supports it, attempt \s-1SMTP\s0 \s-1PIPELINING\s0 (\s-1RFC\s0 2920).  This is a younger option, if you experience problems with it please notify the author.  Potential problem areas include servers accepting \s-1DATA\s0 even though there were no valid recipients (swaks should send empty body in that case, not \s-1QUIT\s0) and deadlocks caused by sending packets outside the tcp window size.</p>
  </dd>
  <dt>
    --force-getpwuid
  </dt>
  <dd>
    <p>Tell swaks to use the getpwuid method of finding the default sender local-part instead of trying $LOGNAME first.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TLS / ENCRYPTION</h2>
        <div class="sectioncontent">
<p>These are options related to encrypting the transaction.  These have been tested and confirmed to work with all three transport methods.  The Net::SSLeay module is used to perform encryption when it is requested.  If this module is not loadable swaks will either ignore the \s-1TLS\s0 request or error out, depending on whether the request was optional.  \s-1STARTTLS\s0 is defined as an extension in the \s-1ESMTP\s0 protocol and will be unavailable if --protocol is set to a variation of smtp.  Because it is not defined in the protocol itself, --tls-on-connect is available for any protocol type if the target supports it.</p><p>A local certificate is not required for a \s-1TLS\s0 connection to be negotiated.  However, some servers use client certificate checking to verify that the client is allowed to connect.  swaks can be told to use a specific local certificate through the use of the --tls-cert and --tls-key options.</p>
<dl class='dl-vertical'>
  <dt>
    -tls
  </dt>
  <dd>
    <p>Require connection to use \s-1STARTTLS\s0.  Exit if \s-1TLS\s0 not available for any reason (not advertised, negotiations failed, etc).</p>
  </dd>
  <dt>
    -tlso, --tls-optional
  </dt>
  <dd>
    <p>Attempt to use \s-1STARTTLS\s0 if available, continue with normal transaction if \s-1TLS\s0 was unable to be negotiated for any reason.  Note that this is a semi-useless option as currently implemented because after a negotiation failure the state of the connection is unknown.  In some cases, like a version mismatch, the connection should be left as plaintext.  In others, like a verification failure, the server-side may think that it should continue speaking \s-1TLS\s0 while the client thinks it is plaintext.  There may be an attempt to add more granular state detection in the future, but for now just be aware that odd things may happen with this option if the \s-1TLS\s0 negotiation is attempted and fails.</p>
  </dd>
  <dt>
    -tlsos, --tls-optional-strict
  </dt>
  <dd>
    <p>Attempt to use \s-1STARTTLS\s0 if available.  Proceed with transaction if \s-1TLS\s0 is negotiated successfully or \s-1STARTTLS\s0 not advertised.  If \s-1STARTTLS\s0 is advertised but \s-1TLS\s0 negotiations fail, treat as an error and abort transaction.  Due to the caveat noted above, this is a much more sane option than --tls-optional.</p>
  </dd>
  <dt>
    --tlsc, --tls-on-connect
  </dt>
  <dd>
    <p>Initiate a \s-1TLS\s0 connection immediately on connection.  Following common convention, if this option is specified the default port changes from 25 to 465, though this can still be overridden with the --port option.</p>
  </dd>
  <dt>
    -tlsp, --tls-protocol \s-1SPECIFICATION\s0
  </dt>
  <dd>
    <p>Specify which protocols to use (or not use) when negotiating \s-1TLS\s0.  At the time of this writing, the available protocols are sslv2, sslv3, tlsv1, tlsv1_1, and tlsv1_2.  The availability of these protocols is dependent on your underlying OpenSSL library, so not all of these may be available.  The list of available protocols is shown in the output of --dump (assuming \s-1TLS\s0 is available at all). The specification string is a comma-delimited list of protocols that can be used or not used.  For instance 'tlsv1,tlsv1_1' will only succeed if one of those two protocols is available on both the client and the server.  Conversely, 'no_sslv2,no_sslv3' will attempt to negotiate any protocol except sslv2 and sslv3.  The two forms of specification cannot be mixed.</p>
  </dd>
  <dt>
    -tls-cipher \s-1CIPHER_STRING\s0
  </dt>
  <dd>
    <p>Th argument to this option is passed to the underlying OpenSSL library to set the list of acceptable ciphers to the be used for the connection.  The format of this string is opaque to swaks and is defined in http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT.  An brief example would be --tls-cipher '3DES:+RSA'.</p>
  </dd>
  <dt>
    --tls-verify
  </dt>
  <dd>
    <p>By default swaks does not do any certificate verification.  Setting --tls-verify will cause swaks to attempt to verify the server's certificate.  If this option is set and the server's certificate is not verifiable (either using the system-default \s-1CA\s0 information, or custom \s-1CA\s0 information (see --tls-ca-path)) \s-1TLS\s0 negotiation will not succeed.</p>
  </dd>
  <dt>
    --tls-ca-path [ /path/to/CAfile | /path/to/CAdir/ ]
  </dt>
  <dd>
    <p>By default swaks will use the underlying OpenSSL library's default \s-1CA\s0 information for verifying server certificates.  --tls-ca-path allows you to specify an alternate location.  See http://www.openssl.org/docs/ssl/SSL_CTX_load_verify_locations.html for details of the file/directory contents.</p>
  </dd>
  <dt>
    --tls-cert /path/to/file
  </dt>
  <dd>
    <p>Provide a path to a file containing the local certificate swaks should use if \s-1TLS\s0 is negotiated.  The file path argument is required.  As currently implemented the certificate in the file must be in \s-1PEM\s0 format.  Contact the author if there's a compelling need for \s-1ASN1\s0.  If this option is set, --tls-key is also required.</p>
  </dd>
  <dt>
    --tls-key /path/to/file
  </dt>
  <dd>
    <p>Provide a path to a file containing the local private key swaks should use if \s-1TLS\s0 is negotiated.  The file path argument is required.  As currently implemented the certificate in the file must be in \s-1PEM\s0 format.  Contact the author if there's a compelling need for \s-1ASN1\s0.  If this option is set, --tls-cert is also required.</p>
  </dd>
  <dt>
    --tls-get-peer-cert [/path/to/file]
  </dt>
  <dd>
    <p>Get a copy of the \s-1TLS\s0 peer's certificate.  If no argument is given, it will be displayed to \s-1STDOUT\s0.  If an argument is given it is assumed to be a filesystem path specifying where the certificate should be written.  The saved certificate can then be examined using standard tools such as the openssl command.  If a file is specified its contents will be overwritten.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHENTICATION</h2>
        <div class="sectioncontent">
<p>swaks will attempt to authenticate to the target mail server if instructed to do so.  This section details available authentication types, requirements, options and their interactions, and other fine points in authentication usage.  Because authentication is defined as an extension in the \s-1ESMTP\s0 protocol it will be unavailable if --protocol is set to a variation of smtp.</p><p>All authentication methods require base64 encoding.  If the MIME::Base64 perl module is loadable swaks attempts to use it to perform these encodings.  If MIME::Base64 is not available swaks will use its own onboard base64 routines.  These are slower than the MIME::Base64 routines and less reviewed, though they have been tested thoroughly.  Using the MIME::Base64 module is encouraged.</p><p>If authentication is required (see options below for when it is and isn't required) and the requirements aren't met for the authentication type available, swaks displays an error and exits.  Two ways this can happen include forcing swaks to use a specific authentication type that swaks can't use due to missing requirements, or allowing swaks to use any authentication type, but the server only advertises types swaks can't support.  In the former case swaks errors out at option processing time since it knows up front it won't be able to authenticate.  In the latter case swaks will error out at the authentication stage of the smtp transaction since swaks will not be aware that it will not be able to authenticate until that point.</p><p>Following are the supported authentication types including any individual notes and requirements.</p><p>The following options affect swaks' use of authentication.  These options are all inter-related.  For instance, specifying --auth-user implies --auth and --auth-password.  Specifying --auth-optional implies --auth-user and --auth-password, etc.</p>
<dl class='dl-vertical'>
  <dt>
    -a, --auth [auth-type[,auth-type,...]]
  </dt>
  <dd>
    <p>Require swaks to authenticate.  If no argument is given, any supported auth-types advertised by the server are tried until one succeeds or all fail.  If one or more auth-types are specified as an argument, each that the server also supports is tried in order until one succeeds or all fail.  This option requires swaks to authenticate, so if no common auth-types are found or no credentials succeed, swaks displays an error and exits. The following tables lists the valid auth-types</p>
<dl class='dl-vertical'>
  <dt>
    \s-1LOGIN\s0, \s-1PLAIN\s0
  </dt>
  <dd>
    <p>These basic authentication types are fully supported and tested and have no additional requirements</p>
  </dd>
  <dt>
    \s-1CRAM-MD5\s0
  </dt>
  <dd>
    <p>The \s-1CRAM-MD5\s0 authenticator requires the Digest::MD5 module.  It is fully tested and believed to work against any server that implements it.</p>
  </dd>
  <dt>
    \s-1DIGEST-MD5\s0
  </dt>
  <dd>
    <p>The \s-1DIGEST-MD5\s0 authenticator (\s-1RFC2831\s0) requires the Authen::SASL module.  Version 20100211.0 and earlier used Authen::DigestMD5 which had some protocol level errors which prevented it from working with some servers.  Authen::SASL's \s-1DIGEST-MD5\s0 handling is much more robust. The \s-1DIGEST-MD5\s0 implementation in swaks is fairly immature.  It currently supports only the \*(L"auth\*(R" qop type, for instance.  If you have \s-1DIGEST-MD5\s0 experience and would like to help swaks support \s-1DIGEST-MD5\s0 better, please get in touch with me. The \s-1DIGEST-MD5\s0 protocol's \*(L"realm\*(R" value can be set using the --auth-extra \*(L"realm\*(R" keyword.  If no realm is given, a reasonable default will be used. The \s-1DIGEST-MD5\s0 protocol's \*(L"digest-uri\*(R" values can be set using the --auth-extra option.  For instance, you could create the digest-uri-value of \*(L"lmtp/mail.example.com/example.com\*(R" with the option \*(L"--auth-extra dmd5-serv-type=lmtp,dmd5-host=mail.example.com,dmd5-serv-name=example.com\*(R".  The \*(L"digest-uri-value\*(R" string and its components is defined in \s-1RFC2831\s0.  If none of these values are given, reasonable defaults will be used.</p>
  </dd>
  <dt>
    \s-1CRAM-SHA1\s0
  </dt>
  <dd>
    <p>The \s-1CRAM-SHA1\s0 authenticator requires the Digest::SHA module.  This type has only been tested against a non-standard implementation on an Exim server and may therefore have some implementation deficiencies.</p>
  </dd>
  <dt>
    \s-1NTLM/SPA/MSN\s0
  </dt>
  <dd>
    <p>These authenticators require the Authen::NTLM module.  Note that there are two modules using the Authen::NTLM namespace on \s-1CPAN\s0.  The Mark Bush implementation (Authen/NTLM-1.03.tar.gz) is the version required by swaks.  This type has been tested against Exim, Communigate, and Exchange 2007. In addition to the standard username and password, this authentication type can also recognize a \*(L"domain\*(R".  The domain can be set using the --auth-extra \*(L"domain\*(R" keyword.  Note that this has never been tested with a mail server that doesn't ignore \s-1DOMAIN\s0 so this may be implemented incorrectly.</p>
  </dd>

</dl>

  </dd>
  <dt>
    -ao, --auth-optional [auth-type[,auth-type,...]]
  </dt>
  <dd>
    <p>This option behaves identically to --auth except that it requests authentication rather than requiring it.  If no common auth-types are found or no credentials succeed, swaks proceeds as if authentication had not been requested.</p>
  </dd>
  <dt>
    -aos, --auth-optional-strict [auth-type[,auth-type,...]]
  </dt>
  <dd>
    <p>This option is a compromise between --auth and --auth-optional.  If no common auth-types are found, swaks behaves as if --auth-optional were specified and proceeds with the transaction.  If swaks can't support requested auth-type, the server doesn't advertise any common auth-types, or if no credentials succeed, swaks behaves as if --auth were used and exits with an error.</p>
  </dd>
  <dt>
    -au, --auth-user [username]
  </dt>
  <dd>
    <p>Provide the username to be used for authentication, or prompt the user for it if no argument is provided.  The string &lt;&gt; can be supplied to mean an empty username.</p>
  </dd>
  <dt>
    -ap, --auth-password [password]
  </dt>
  <dd>
    <p>Provide the password to be used for authentication, or prompt the user for it if no argument is provided.  The string &lt;&gt; can be supplied to mean an empty password.</p>
  </dd>
  <dt>
    -ae, --auth-extra [KEYWORD=value[,...]]
  </dt>
  <dd>
    <p>Some of the authentication types allow extra information to be included in the authentication process.  Rather than add a new option for every nook and cranny of each authenticator, the --auth-extra option allows this information to be supplied. The following table lists the currently recognized keywords and the authenticators that use them</p>
<dl class='dl-vertical'>
  <dt>
    realm, domain
  </dt>
  <dd>
    <p>The realm and domain keywords are synonymous.  Using either will set the \*(L"domain\*(R" option in \s-1NTLM/MSN/SPA\s0 and the \*(L"realm\*(R" option in \s-1DIGEST-MD5\s0</p>
  </dd>
  <dt>
    dmd5-serv-type
  </dt>
  <dd>
    <p>The dmd5-serv-type keyword is used by the \s-1DIGEST-MD5\s0 authenticator and is used, in part, to build the digest-uri-value string (see \s-1RFC2831\s0)</p>
  </dd>
  <dt>
    dmd5-host
  </dt>
  <dd>
    <p>The dmd5-host keyword is used by the \s-1DIGEST-MD5\s0 authenticator and is used, in part, to build the digest-uri-value string (see \s-1RFC2831\s0)</p>
  </dd>
  <dt>
    dmd5-serv-name
  </dt>
  <dd>
    <p>The dmd5-serv-name keyword is used by the \s-1DIGEST-MD5\s0 authenticator and is used, in part, to build the digest-uri-value string (see \s-1RFC2831\s0)</p>
  </dd>

</dl>

  </dd>
  <dt>
    -am, --auth-map [auth-alias=auth-type[,...]]
  </dt>
  <dd>
    <p>Provides a way to map alternate names onto base authentication types.  Useful for any sites that use alternate names for common types.  This functionality is actually used internally to map types \s-1SPA\s0 and \s-1MSN\s0 onto the base type \s-1NTLM\s0.  The command line argument to simulate this would be \*(L"--auth-map SPA=NTLM,MSN=NTLM\*(R".  All of the auth-types listed above are valid targets for mapping except \s-1SPA\s0 and \s-1MSN\s0.</p>
  </dd>
  <dt>
    -apt, --auth-plaintext
  </dt>
  <dd>
    <p>Instead of showing \s-1AUTH\s0 strings base64 encoded as they are transmitted, translate them to plaintext before printing on screen.</p>
  </dd>
  <dt>
    -ahp, --auth-hide-password [replacement string]
  </dt>
  <dd>
    <p>If this option is specified, any time a readable password would be printed to the terminal (specifically \s-1AUTH\s0 \s-1PLAIN\s0 and \s-1AUTH\s0 \s-1LOGIN\s0) the password is replaced with a dummy string (or the contents of \*(L"replacement string\*(R" if provided).  The dummy string will be base64 encoded or not contingent on the --auth-plaintext option. Note that --auth-hide-password is similar, but not identical, to the --protect-prompt option.  The former protects passwords from being displayed in the \s-1SMTP\s0 transaction regardless of how they are entered.  The latter protects sensitive strings when the user types them at the terminal, regardless of how the string would be used.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">XCLIENT OPTIONS</h2>
        <div class="sectioncontent">
<p>\s-1XCLIENT\s0 is an \s-1SMTP\s0 extension introduced by the Postfix project.  \s-1XCLIENT\s0 allows a (properly-authorized) client to tell a server to use alternate information, such as \s-1IP\s0 address or hostname, for the client.  This allows much easier paths for testing mail server configurations.  Full details on the protocol are available at http://www.postfix.org/XCLIENT_README.html.</p>
<dl class='dl-vertical'>
  <dt>
    --xclient-addr [\s-1VALUE\s0]
  </dt>
  <dd>
    
  </dd>
  <dt>
    --xclient-name [\s-1VALUE\s0]
  </dt>
  <dd>
    
  </dd>
  <dt>
    --xclient-port [\s-1VALUE\s0]
  </dt>
  <dd>
    
  </dd>
  <dt>
    --xclient-proto [\s-1VALUE\s0]
  </dt>
  <dd>
    
  </dd>
  <dt>
    --xclient-helo [\s-1VALUE\s0]
  </dt>
  <dd>
    
  </dd>
  <dt>
    --xclient-login [\s-1VALUE\s0]
  </dt>
  <dd>
    
  </dd>
  <dt>
    --xclient-reverse-name [\s-1VALUE\s0]
  </dt>
  <dd>
    <p>These options specify \s-1XCLIENT\s0 attrubutes that should be sent to the target server.  If [\s-1VALUE\s0] is not provided, swaks will prompt and read the value on \s-1STDIN\s0.  See http://www.postfix.org/XCLIENT_README.html for official documentation for what the attributes mean and their possible values, including the special \*(L"[\s-1UNAVAILABLE\s0]\*(R" and \*(L"[\s-1TEMPUNAVAIL\s0]\*(R" values. By way of simple example, setting \*(L"--xclient-name foo.example.com --xclient-addr 192.168.1.1\*(R" will cause swaks to send the \s-1SMTP\s0 command \*(L"\s-1XCLIENT\s0 NAME=foo.example.com ADDR=192.168.1.1\*(R". Note that the \*(L"\s-1REVERSE_NAME\s0\*(R" attribute doesn't seem to appear in the official documentation.  There is a mailing list thread that documents it, viewable at http://comments.gmane.org/gmane.mail.postfix.user/192623. These options can all be mixed with each other, and can be mixed with the --xclient option (see below).</p>
  </dd>
  <dt>
    --xclient [\s-1XCLIENT_STRING\s0]
  </dt>
  <dd>
    <p>This is the \*(L"free form\*(R" \s-1XCLIENT\s0 option.  Whatever value is provided for \s-1XCLIENT_STRING\s0 will be sent verbatim as the argument to the \s-1XCLIENT\s0 smtp command.  For example, if \*(L"--xclient 'NAME= ADDR=192.168.1.1 FOO=bar'\*(R" is used, swaks will send the \s-1SMTP\s0 command \*(L"\s-1XCLIENT\s0 NAME= ADDR=192.168.1.1 FOO=bar\*(R".  The primary advantage to this over the more specific options above is that there is no \s-1XCLIENT\s0 syntax validation here.  This allows you to send invalid \s-1XCLIENT\s0 to the target server for testing.  If no \s-1XCLIENT_STRING\s0 is passed on command line, swaks will prompt and read the value on \s-1STDIN\s0. The --xclient option can be mixed freely with the --xclient-* options above.  If \*(L"--xclient-addr 192.168.0.1 --xclient 'FOO=bar NAME=wind'\*(R" is given to swaks, \*(L"\s-1XCLIENT\s0 ADDR=192.168.0.1 FOO=bar NAME=wind\*(R" will be sent to the target server.</p>
  </dd>
  <dt>
    --xclient-optional
  </dt>
  <dd>
    
  </dd>
  <dt>
    --xclient-optional-strict
  </dt>
  <dd>
    <p>In normal operation, setting one of the --xclient* options will cause a successful \s-1XCLIENT\s0 transaction to take place in order to proceed (that is, \s-1XCLIENT\s0 needs to be advertised, all the user-requested attributes need to have been advertised, and the server needs to have accepted swaks' \s-1XCLIENT\s0 request).  These options change that behavior.  --xclient-optional tells swaks to proceed unconditionally past the \s-1XCLIENT\s0 stage of the \s-1SMTP\s0 transaction, regardless of whether it was successful.  --xclient-optional-strict is similar but more granular.  The strict version will continue to \s-1XCLIENT\s0 was not advertised, but will fail if \s-1XCLIENT\s0 was attempted but did not succeed.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DATA OPTIONS</h2>
        <div class="sectioncontent">
<p>These options pertain to the contents for the \s-1DATA\s0 portion of the \s-1SMTP\s0 transaction.</p>
<dl class='dl-vertical'>
  <dt>
    -d, --data [data-portion]
  </dt>
  <dd>
    <p>Use argument as the entire contents of \s-1DATA\s0, or prompt user if no argument specified.  If the argument '-' is provided the data will be read from \s-1STDIN\s0.  If any other argument is provided and it represents the name of an open-able file, the contents of the file will be used.  Any other argument will be itself for the \s-1DATA\s0 contents. The value can be on one single line, with &#92;n (ascii 0x5c, 0x6e) representing where line breaks should be placed.  Leading dots will be quoted.  Closing dot is not required but is allowed.  The default value for this option is \*(L"Date: %DATE%&#92;nTo: %TO_ADDRESS%&#92;nFrom: %FROM_ADDRESS%&#92;nSubject: test %DATE%&#92;nX-Mailer: swaks v$p_version jetmore.org/john/code/swaks/&#92;n%NEW_HEADERS%&#92;n%BODY%&#92;n\*(R". Very basic token parsing is performed on the \s-1DATA\s0 portion.  See --use-old-data-tokens for details about the single-character tokens marked as deprecated.  The following table shows the recognized tokens and their replacement values:</p><p>Replaced with the envelope-sender.  Replaces the deprecated %F token. Replaced with the envelope-recipient(s).  Replaces the deprecated %T token. Replaced with the current time in a format suitable for inclusion in the Date: header.  Note this attempts to use the standard module Time::Local for timezone calculations.  If this module is unavailable the date string will be in \s-1GMT\s0.  Replaces the deprecated %D token. Replaced with the contents of the --add-header option.  If --add-header is not specified this token is simply removed.  Replaces the deprecated %H token. Replaced with the value specified by the --body option.  See --body for default.  Replaces the deprecated %H token.</p>
  </dd>
  <dt>
    --use-old-data-tokens
  </dt>
  <dd>
    <p>In previous versions of swaks the \s-1DATA\s0 tokens as described in the --data option above used single-character tokens (e.g., %F).  These were not a great choice for default tokens, and proved especially troublesome with encoded, non-english languages where these character combinations might be common.  The single-character tokens were replaced with the slightly-less-error-prone versions listed above.  The retention of the old tokens and the inclusion of this option to activate them are intended as a temporary aid to users who have an existing message corpus using the old tokens.  The single-character tokens and the --use-old-data-tokens option should be considered deprecated and likely to be removed in the next release.</p>
  </dd>
  <dt>
    -dab, --dump-as-body
  </dt>
  <dd>
    <p>If --dump-as-body is used and no other option is used to changed the default body of the message, the body is replaced with output similar to the output of what is provided by --dump.  --dump's initial program capability stanza is not displayed, and the \*(L"data\*(R" section is not included.  Additionally, --dump always includes passwords.  By default --dump-as-body does not include passwords, though this can be changed with --dump-as-body-shows-password.</p>
  </dd>
  <dt>
    -dabsp, --dump-as-body-shows-password
  </dt>
  <dd>
    <p>Cause --dump-as-body to include plaintext passwords.  This option is not recommended.  This option implies --dump-as-body.</p>
  </dd>
  <dt>
    --body [body-specification]
  </dt>
  <dd>
    <p>Specify the body of the email.  The default is \*(L"This is a test mailing\*(R".  If no argument to --body is given, prompt to supply one interactively.  If '-' is supplied, the body will be read from standard input.  If any other text is provided and the text represents an open-able file, the content of that file is used as the body.  If it does not represent an open-able file, the text itself is used as the body. If the message is forced to \s-1MIME\s0 format (see --attach) the argument to this option will be included unencoded as the first \s-1MIME\s0 part.  Its content-type will always be text/plain.</p>
  </dd>
  <dt>
    --attach [attachment-specification]
  </dt>
  <dd>
    <p>When one or more --attach option is supplied, the message is changed into a multipart/mixed \s-1MIME\s0 message.  The arguments to --attach are processed the same as --body with regard to stdin, file contents, etc.  --attach can be supplied multiple times to create multiple attachments.  By default each attachment is attached as a application/octet-stream file.  See --attach-type for changing this behavior. If a filename is specified, the \s-1MIME\s0 encoding will include that file name.  See --attach-name for more detail on file naming. It is legal for '-' (\s-1STDIN\s0) to be specified as an argument multiple times (once for --body and multiple times for --attach).  In this case, the same content will be attached each time it is specified.  This is useful for attaching the same content with multiple \s-1MIME\s0 types.</p>
  </dd>
  <dt>
    --attach-type [mime-type]
  </dt>
  <dd>
    <p>By default, content that gets \s-1MIME\s0 attached to a message with the --attach option is encoded as application/octet-stream.  --attach-type changes the mime type for every --attach option which follows it.  It can be specified multiple times.</p>
  </dd>
  <dt>
    --attach-name [name]
  </dt>
  <dd>
    <p>This option sets the filename that will be included in the \s-1MIME\s0 part created for the next --attach option.  If no argument is set for this option, it causes no filename information to be included for the next \s-1MIME\s0 part, even if swaks could generate it from the local file name.</p>
  </dd>
  <dt>
    -ah, --add-header [header]
  </dt>
  <dd>
    <p>This option allows headers to be added to the \s-1DATA\s0.  If %H is present in the \s-1DATA\s0 it is replaced with the argument to this option.  If %H is not present, the argument is inserted between the first two consecutive newlines in the \s-1DATA\s0 (that is, it is inserted at the end of the existing headers). The option can either be specified multiple times or a single time with multiple headers separated by a literal '&#92;n' string.  So, \*(L"--add-header 'Foo: bar' --add-header 'Baz: foo'\*(R" and \*(L"--add-header 'Foo: bar&#92;nBaz: foo'\*(R" end up adding the same two headers.</p>
  </dd>
  <dt>
    --header [header-and-data], --h-Header [data]
  </dt>
  <dd>
    <p>These options allow a way to change headers that already exist in the \s-1DATA\s0.  '--header \*(L"Subject: foo\*(R"' and '--h-Subject foo' are equivalent.  If the header does not already exist in the data then this argument behaves identically to --add-header.  However, if the header already exists it is replaced with the one specified.</p>
  </dd>
  <dt>
    -g
  </dt>
  <dd>
    <p>If specified, swaks will read the \s-1DATA\s0 value for the mail from \s-1STDIN\s0.  This is equivalent to \*(L"--data -\*(R".  If there is a From_ line in the email, it will be removed (but see -nsf option).  Useful for delivering real message (stored in files) instead of using example messages.</p>
  </dd>
  <dt>
    --no-data-fixup, -ndf
  </dt>
  <dd>
    <p>This option forces swaks to do no massaging of the \s-1DATA\s0 portion of the email.  This includes token replacement, From_ stripping, trailing-dot addition, --body/attachment inclusion, and any header additions.  This option is really only useful when used with --data, since the internal default \s-1DATA\s0 portion uses tokens.</p>
  </dd>
  <dt>
    --no-strip-from, -nsf
  </dt>
  <dd>
    <p>Don't strip the From_ line from the \s-1DATA\s0 portion, if present.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OUTPUT OPTIONS</h2>
        <div class="sectioncontent">
<p>By default swaks provides a transcript of its transactions to its caller (\s-1STDOUT/STDERR\s0).  This transcript aims to be as faithful a representation as possible of the transaction though it does modify this output by adding informational prefixes to lines and by providing plaintext versions of \s-1TLS\s0 transactions</p><p>The \*(L"informational prefixes\*(R" are referred to as transaction hints.  These hints are initially composed of those marking lines that are output of swaks itself, either informational or error messages, and those that indicate a line of data actually sent or received in a transaction.  This table indicates the hints and their meanings:</p>
<dl class='dl-vertical'>
  <dt>
    ===
  </dt>
  <dd>
    <p>Indicates an informational line generated by swaks</p>
  </dd>
  <dt>
    ***
  </dt>
  <dd>
    <p>Indicates an error generated within swaks</p>
  </dd>
  <dt>
    -&gt;
  </dt>
  <dd>
    <p>Indicates an expected line sent by swaks to target server</p>
  </dd>
  <dt>
    ~&gt;
  </dt>
  <dd>
    <p>Indicates a TLS-encrypted, expected line sent by swaks to target server</p>
  </dd>
  <dt>
    **&gt;
  </dt>
  <dd>
    <p>Indicates an unexpected line sent by swaks to the target server</p>
  </dd>
  <dt>
    *~&gt;
  </dt>
  <dd>
    <p>Indicates a TLS-encrypted, unexpected line sent by swaks to target server</p>
  </dd>
  <dt>
    &gt;
  </dt>
  <dd>
    <p>Indicates a raw chunk of test sent by swaks to a target server (see --show-raw-text).  There is no concept of \*(L"expected\*(R" or \*(L"unexpected\*(R" at this level.</p>
  </dd>
  <dt>
    &lt;-
  </dt>
  <dd>
    <p>Indicates an expected line sent by target server to swaks</p>
  </dd>
  <dt>
    &lt;~
  </dt>
  <dd>
    <p>Indicates a TLS-encrypted, expected line sent by target server to swaks</p>
  </dd>
  <dt>
    &lt;**
  </dt>
  <dd>
    <p>Indicates an unexpected line sent by target server to swaks</p>
  </dd>
  <dt>
    &lt;~*
  </dt>
  <dd>
    <p>Indicates a TLS-encrypted, unexpected line sent by target server to swaks</p>
  </dd>
  <dt>
    &lt;
  </dt>
  <dd>
    <p>Indicates a raw chunk of text received by swaks from a target server (see --show-raw-text).  There is no concept of \*(L"expected\*(R" or \*(L"unexpected\*(R" at this level.</p>
  </dd>

</dl>
<p>The following options control what and how output is displayed to the caller.</p>
<dl class='dl-vertical'>
  <dt>
    -n, --suppress-data
  </dt>
  <dd>
    <p>Summarizes the \s-1DATA\s0 portion of the \s-1SMTP\s0 transaction instead of printing every line.  This option is very helpful, bordering on required, when using swaks to send certain test emails.  Emails with attachments, for instance, will quickly overwhelm a terminal if the \s-1DATA\s0 is not supressed.</p>
  </dd>
  <dt>
    -stl, --show-time-lapse [i]
  </dt>
  <dd>
    <p>Display time lapse between send/receive pairs.  This option is most useful when Time::HiRes is available, in which case the time lapse will be displayed in thousandths of a second.  If Time::HiRes is unavailable or \*(L"i\*(R" is given as an argument the lapse will be displayed in integer seconds only.</p>
  </dd>
  <dt>
    -nih, --no-info-hints
  </dt>
  <dd>
    <p>Don't display the transaction hint for informational transactions.  This is most useful when needing to copy some portiong of the informational lines, for instance the certificate output from --tls-get-peer-cert.</p>
  </dd>
  <dt>
    -nsh, --no-send-hints
  </dt>
  <dd>
    
  </dd>
  <dt>
    -nrh, --no-receive-hints
  </dt>
  <dd>
    
  </dd>
  <dt>
    -nth, --no-hints
  </dt>
  <dd>
    <p>--no-send-hints and --no-receive-hints supress the transaction prefix from send and receive lines, respectively.  This is often useful when copying some portion of the transaction for use elsewhere (for instance, \*(L"--no-send-hints --hide-receive --hide-informational\*(R" is a useful way to get only the client-side commands for a given transaction).  --no-hints is identical to specifying both --no-send-hints and --no-receive-hints. Don't show transaction hints (useful in conjunction with -hr to create copy/paste-able transactions).</p>
  </dd>
  <dt>
    -raw, --show-raw-text
  </dt>
  <dd>
    <p>This option will print a hex dump of raw data sent and received by swaks.  Each hex dump is the contents of a single read or write on the network.  This should be identical to what is already being displayed (with the exception of the &#92;r characters being removed).  This option is useful in seeing details when servers are sending lots of data in single packets, or breaking up individual lines into multiple packets.  If you really need to go in depth in that area you're probably better with a packet sniffer, but this option is a good first step to seeing odd connection issues.</p>
  </dd>
  <dt>
    --output-file &lt;/path/to/file&gt;
  </dt>
  <dd>
    
  </dd>
  <dt>
    --output-file-stdout &lt;/path/to/file&gt;
  </dt>
  <dd>
    
  </dd>
  <dt>
    --output-file-stderr &lt;/path/to/file&gt;
  </dt>
  <dd>
    <p>These options allow the user to send output to files instead of stdout/stderr.  The first option sends both to the same file.  The arguments of &STDOUT and &STDERR are treated specially, refering to the \*(L"normal\*(R" file handles, so \*(L"--output-file-stderr '&STDOUT'\*(R" would redirect \s-1STDERR\s0 to \s-1STDOUT\s0.</p>
  </dd>
  <dt>
    -pp, --protect-prompt
  </dt>
  <dd>
    <p>Don't echo user input on prompts that are potentially sensitive (right now only authentication password).  See also --auth-hide-password</p>
  </dd>
  <dt>
    -hr, --hide-receive
  </dt>
  <dd>
    <p>Don't display lines sent from the remote server being received by swaks</p>
  </dd>
  <dt>
    -hs, --hide-send
  </dt>
  <dd>
    <p>Don't display lines being sent by swaks to the remote server</p>
  </dd>
  <dt>
    -hi, --hide-informational
  </dt>
  <dd>
    <p>Don't display non-error informational lines from swaks itself.</p>
  </dd>
  <dt>
    -ha, --hide-all
  </dt>
  <dd>
    <p>Do not display any content to the terminal.</p>
  </dd>
  <dt>
    -S, --silent [level]
  </dt>
  <dd>
    <p>Cause swaks to be silent.  If no argument is given or if an argument of \*(L"1\*(R" is given, print no output unless/until an error occurs, after which all output is shown.  If an argument of \*(L"2\*(R" is given, only print errors.  If \*(L"3\*(R" is given, show no output ever.</p>
  </dd>
  <dt>
    --support
  </dt>
  <dd>
    <p>Print capabilities and exit.  Certain features require non-standard perl modules.  This options evaluates whether these modules are present and displays which functionality is available and which isn't, and which modules would need to be added to gain the missing functionality.</p>
  </dd>
  <dt>
    --dump
  </dt>
  <dd>
    <p>This option causes swaks to print the results of option processing, immediately before mail would have been sent.  No mail will be sent when --dump is used.  Note that --dump is considered to be a pure self-diagnosis tool and no effort is made or will ever be made to mask passwords in the --dump output.</p>
  </dd>
  <dt>
    --help
  </dt>
  <dd>
    <p>Display this help information.</p>
  </dd>
  <dt>
    --version
  </dt>
  <dd>
    <p>Display version information.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PORTABILITY</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    \s-1OPERATING\s0 \s-1SYSTEMS\s0
  </dt>
  <dd>
    <p>This program was primarily intended for use on unix-like operating systems, and it should work on any reasonable version thereof.  It has been developed and tested on Solaris, Linux, and Mac \s-1OS\s0 X and is feature complete on all of these. This program is known to demonstrate basic functionality on Windows using ActiveState's Perl.  It has not been fully tested.  Known to work are basic \s-1SMTP\s0 functionality and the \s-1LOGIN\s0, \s-1PLAIN\s0, and \s-1CRAM-MD5\s0 auth types.  Unknown is any \s-1TLS\s0 functionality and the \s-1NTLM/SPA\s0 and \s-1DIGEST-MD5\s0 auth types. Because this program should work anywhere Perl works, I would appreciate knowing about any new operating systems you've thoroughly used swaks on as well as any problems encountered on a new \s-1OS\s0.</p>
  </dd>
  <dt>
    \s-1MAIL\s0 \s-1SERVERS\s0
  </dt>
  <dd>
    <p>This program was almost exclusively developed against Exim mail servers.  It was been used casually by the author, though not thoroughly tested, with Sendmail, Smail, Exchange, Oracle Collaboration Suite, qpsmtpd, and Communigate.  Because all functionality in swaks is based off of known standards it should work with any fairly modern mail server.  If a problem is found, please alert the author at the address below.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXIT CODES</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    0
  </dt>
  <dd>
    <p>no errors occurred</p>
  </dd>
  <dt>
    1
  </dt>
  <dd>
    <p>error parsing command line options</p>
  </dd>
  <dt>
    2
  </dt>
  <dd>
    <p>error connecting to remote server</p>
  </dd>
  <dt>
    3
  </dt>
  <dd>
    <p>unknown connection type</p>
  </dd>
  <dt>
    4
  </dt>
  <dd>
    <p>while running with connection type of \*(L"pipe\*(R", fatal problem writing to or reading from the child process</p>
  </dd>
  <dt>
    5
  </dt>
  <dd>
    <p>while running with connection type of \*(L"pipe\*(R", child process died unexpectedly.  This can mean that the program specified with --pipe doesn't exist.</p>
  </dd>
  <dt>
    6
  </dt>
  <dd>
    <p>Connection closed unexpectedly.  If the close is detected in response to the '\s-1QUIT\s0' swaks sends following an unexpected response, the error code for that unexpected response is used instead.  For instance, if a mail server returns a 550 response to a \s-1MAIL\s0 \s-1FROM:\s0 and then immediately closes the connection, swaks detects that the connection is closed, but uses the more specific exit code 23 to detail the nature of the failure.  If instead the server return a 250 code and then immediately closes the connection, swaks will use the exit code 6 because there is not a more specific exit code.</p>
  </dd>
  <dt>
    10
  </dt>
  <dd>
    <p>error in prerequisites (needed module not available)</p>
  </dd>
  <dt>
    21
  </dt>
  <dd>
    <p>error reading initial banner from server</p>
  </dd>
  <dt>
    22
  </dt>
  <dd>
    <p>error in \s-1HELO\s0 transaction</p>
  </dd>
  <dt>
    23
  </dt>
  <dd>
    <p>error in \s-1MAIL\s0 transaction</p>
  </dd>
  <dt>
    24
  </dt>
  <dd>
    <p>no RCPTs accepted</p>
  </dd>
  <dt>
    25
  </dt>
  <dd>
    <p>server returned error to \s-1DATA\s0 request</p>
  </dd>
  <dt>
    26
  </dt>
  <dd>
    <p>server did not accept mail following data</p>
  </dd>
  <dt>
    27
  </dt>
  <dd>
    <p>server returned error after normal-session quit request</p>
  </dd>
  <dt>
    28
  </dt>
  <dd>
    <p>error in \s-1AUTH\s0 transaction</p>
  </dd>
  <dt>
    29
  </dt>
  <dd>
    <p>error in \s-1TLS\s0 transaction</p>
  </dd>
  <dt>
    32
  </dt>
  <dd>
    <p>error in \s-1EHLO\s0 following \s-1TLS\s0 negotiation</p>
  </dd>
  <dt>
    33
  </dt>
  <dd>
    <p>error in \s-1XCLIENT\s0 transaction</p>
  </dd>
  <dt>
    34
  </dt>
  <dd>
    <p>error in \s-1EHLO\s0 following \s-1XCLIENT\s0</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ABOUT THE NAME</h2>
        <div class="sectioncontent">
<p>The name \*(L"swaks\*(R" is a (sort-of) acronym for \*(L"SWiss Army Knife Smtp\*(R".  It was chosen to be fairly distinct and pronounceable.  While \*(L"swaks\*(R" is unique as the name of a software package, it has some other, non-software meanings.  Please send in other uses of \*(L"swak\*(R" or \*(L"swaks\*(R" for inclusion. SWAK/SWAKs turns up occasionally on the internet with the meaning \*(L"with love\*(R".</p>
<dl class='dl-vertical'>
  <dt>
    bad / poor / ill (Afrikaans)
  </dt>
  <dd>
    <p>Seen it in the headline \*(L"\s-1SA\s0 se bes en swaks gekledes in 2011\*(R", which was translated as \*(L"best and worst dressed\*(R" by native speakers.  Google Translate doesn't like \*(L"swaks gekledes\*(R", but it will translate \*(L"swak\*(R" as \*(L"poor\*(R" and \*(L"swak geklede\*(R" as \*(L"ill-dressed\*(R".</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONTACT</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    proj-swaks@jetmore.net
  </dt>
  <dd>
    <p>Please use this address for general contact, questions, patches, requests, etc.</p>
  </dd>
  <dt>
    updates-swaks@jetmore.net
  </dt>
  <dd>
    <p>If you would like to be put on a list to receive notifications when a new version of swaks is released, please send an email to this address.</p>
  </dd>
  <dt>
    http://www.jetmore.org/john/code/swaks/
  </dt>
  <dd>
    <p>Change logs, this help, and the latest version is found at this link.</p>
  </dd>

</dl>

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="swac-get.1.html"><span aria-hidden="true">&larr;</span> swac-get.1: Audio collections of words (swac) manager</a></li>
   <li class="next"><a href="swami.1.html">swami.1: (sampled waveforms and musical instruments) is an application for editing and managing midi instruments, such as soundfont files. an programming api is also provided for integration with other applications.   more information can be found on the project swami website http://swami.sourceforge.net. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

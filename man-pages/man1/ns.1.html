<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ns: Network simulator (version 2)</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Network simulator (version 2)">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="ns (1) manual">
  <meta name="twitter:description" content="Network simulator (version 2)">
  <meta name="twitter:image" content="https://www.carta.tech/images/ns2-ns-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/ns.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="ns (1) manual" />
  <meta property="og:description" content="Network simulator (version 2)" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/ns2-ns-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">ns<small> (1)</small></h1>
        <p class="lead">Network simulator (version 2)</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/ns.1.html">
      <span itemprop="name">ns: Network simulator (version 2)</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/ns2/">
      <span itemprop="name">ns2</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/ns.1.html">
      <span itemprop="name">ns: Network simulator (version 2)</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>ns</strong> [ <em>file</em> [ <em>arg arg ...</em> ] ]</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><em>ns</em> is an event-driven network simulator. An extensible simulation engine is implemented in C++ that uses MIT's Object Tool Command Language, OTcl (an object oriented version of Tcl) as the command and configuration interface. A previous version of the simulator i.e. ns version 1 used the Tool Command Language, Tcl as the configuration language. The current version still supports simulation scripts written in Tcl meant for the ns version 1 simulator.</p><p>This manual page documents some of the interfaces for ns.  For much more complete documentation, please see "ns Notes and Documentation" [13], available in the distribution and on the web.</p><p>The simulator is invoked via the <em>ns</em> interpreter, an extension of the vanilla <em>otclsh</em> command shell. A simulation is defined by a OTcl script. The scripts use the Simulator Class as the principal interface to the simulation engine. Using the methods defined in this class, a network topology is defined, traffic sources and sinks are configured, the simulation is invoked, and the statistics are collected. By building upon a fully functional language, arbitrary actions can be programmed into the configuration.</p><p>The first step in the simulation is to acquire an instance of the Simulator class. Instances of objects in classes are created and destroyed in ns using the <em>new</em> and <em>delete</em> methods. For example, an instance of the Simulator object is created by the following command:</p>
<pre>
	e.g. set ns [new Simulator]

</pre>
<p>A network topology is realized using three primitive building blocks: nodes, links, and agents. The Simulator class has methods to create/ configure each of these building blocks. Nodes are created with the <em>node</em> Simulator method that automatically assigns an unique address to each node. Links are created between nodes to form a network topology with the <em>simplex-link</em> and <em>duplex-link</em> methods that set up unidirectional and bidirectional links respectively. Agents are the objects that actively drive the simulation. <em>Agents</em> can be thought of as the processes and/or transport entities that run on <em>nodes</em> that may be end hosts or routers. Traffic sources and sinks, dynamic routing modules and the various protocol modules are all examples of agents. Agents are created by instantiating objects in the subclass of class Agent i.e., <em>Agent/type</em> where type specifies the nature of the agent. For example, a TCP agent is created using the command:</p>
<pre>
	set tcp [new Agent/TCP]

</pre>
<p>Once the agents are created, they are attached to nodes with the <em>attach-agent</em> Simulator method. Each agent is automatically assigned a port number unique across all agents on a given node (analogous to a tcp or udp port). Some types of agents may have sources attached to them while others may generate their own data. For example, you can attach ``ftp'' and ``telnet'' sources to ``tcp'' agents but ``constant bit-rate'' agents generate their own data. Applications are attached to agents using the <em>attach-app</em> method.</p><p>Each object has some configuration parameters associated with it that can be modified. Configuration parameters are instance variables of the object. These parameters are initialized during startup to default values that can simply be read from the instance variables of the object. For example, <em>$tcp set window_</em> returns the default window size for the tcp object. The default values for that object can be explicitly overridden by simple assignment either before a simulation begins, or dynamically, while the simulation is in progress. For example the window-size for a particular TCP session can be changed in the following manner.</p>
<pre>
	$tcp set window_ 25

</pre>
<p>The default values for the configuration parameters of all the class objects subsequently created can also be changed by simple assignment. For example, we can say</p>
<pre>
	Agent/TCP set window_ 30

</pre>
<p>to make all future tcp agent creations default to a window size of 30.</p><p>Events are scheduled in ns using the <em>at</em> Simulator method that allows OTcl procedures to be invoked at arbitrary points in simulation time. These OTcl callbacks provide a flexible simulation mechanism -- they can be used to start or stop sources, dump statistics, instantiate link failures, reconfigure the network topology etc. The simulation is started via the <em>run</em> method and continues until there are no more events to be processed. At this time, the original invocation of the <em>run</em> command returns and the Tcl script can exit or invoke another simulation run after possible reconfiguration. Alternatively, the simulation can be prematurely halted by invoking the <em>stop</em> command or by exiting the script with Tcl's standard <em>exit</em> command.</p><p>Packets are forwarded along the shortest path route from a source to a destination, where the distance metric is the sum of costs of the links traversed from the source to the destination. The cost of a link is 1 by default; the distance metric is simply the hop count in this case. The cost of a link can be changed with the <em>cost</em> Simulator method. A static topology model is used as the default in ns in which the states of nodes/links do not change during the course of a simulation. Network Dynamics could be specified using methods described in NETWORK DYNAMICS METHODS section. Also static unicast routing is the default in which the routes are pre-computed over the entire topology once prior to starting the simulation. Methods to enable and configure dynamic unicast and multicast routing are described in the UNICAST ROUTING METHODS and MULTICAST ROUTING METHODS sections respectively.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NS COMMANDS</h2>
        <div class="sectioncontent">
<p>This section describes the basic commands to create the building blocks of the simulation (i.e. the node, link and agent objects) and to run the simulation.</p><p>The first step in running a simulation as stated before is to acquire an instance of the Simulator class that has methods to configure and run the simulation. Throughout this section the object variable name $ns is used to imply a Simulator object.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>$ns node</strong>
  </dt>
  <dd>
    <p>Create a new node object and return a handle to it.</p>
  </dd>
  <dt>
    <strong>$ns all-nodes-list</strong>
  </dt>
  <dd>
    <p>Returns a list of all the node objects defined in the simulation.</p>
  </dd>
  <dt>
    <strong>$ns simplex-link</strong><em> node1 node2 bw delay type</em><strong></strong>
  </dt>
  <dd>
    <p>Create a new unidirectional link between <em>node1</em> and <em>node2</em> with bandwidth <em>bw</em> in bits per second and link propagation delay <em>delay</em> in seconds. <em>node1</em> and <em>node2</em> must have already been created with the <em>node</em> method. <em>bw</em> and <em>delay</em> default to 1.5 Mbits/sec and 100 ms respectively. The defaults can be changed by modifying the relevant configuration parameters of the DelayLink Object (see DELAYLINK OBJECTS section). <em>node1</em> and <em>node2</em> must have already been created with the <em>node</em> method. The queuing discipline of the link is specified by <em>type,</em> which may be <strong>DropTail,</strong> <strong>FQ,</strong> <strong>SFQ,</strong> <strong>DRR,</strong> <strong>RED,</strong> <strong>CBQ,</strong> or <strong>CBQ/WRR.</strong> A DropTail link is a simple FIFO queue which drops the last packet in the queue when the queue overflows. A FQ link is for Fair Queuing (for details see [?]). A SFQ link is for Stochastic Fair Queuing (for details see [?]). A DRR link is for deficit round robin scheduling (for details see [9]). A RED link is a random-early drop queue (for details see [2]). A CBQ link is for class-based queuing using a packet-by-packet round-robin scheduler (for details see [3]). A CBQ/WRR link is for class-based queuing with a weighted round robin scheduler. If multicast routing is used links with interface labels are required. Such links are created by setting Simulator NumberInterfaces_ variable to 1. All the subsequently created links will have interface labels. To disable creation of interfaces simply reset NumberInterfaces_ to 0 (this is the default).</p>
  </dd>
  <dt>
    <strong>$ns duplex-link</strong><em> node1 node2 bw delay type</em><strong></strong>
  </dt>
  <dd>
    <p>Create a new bidirectional link between <em>node1</em> and <em>node2</em> with bandwidth <em>bw</em> in bits per second and link propagation delay <em>delay</em> in seconds. <em>node1</em> and <em>node2</em> must have already been created with the <em>node</em> method. <em>bw</em> and <em>delay</em> default to 1.5 Mbits/sec and 100 ms respectively. The defaults can be changed by modifying the relevant configuration parameters of the DelayLink Object (see DELAYLINK OBJECTS section). The queuing discipline of the link is specified by <em>type,</em> which may be <strong>DropTail,</strong> <strong>FQ</strong> <strong>SFQ,</strong> <strong>DRR,</strong> <strong>RED,</strong> <strong>CBQ,</strong> or <strong>CBQ/WRR.</strong> A DropTail link is a simple FIFO queue which drops the last packet in the queue when the queue overflows. A FQ link is for Fair Queuing (for details see [?]). A SFQ link is for Stochastic Fair Queuing (for details see [?]). A DRR link is for deficit round robin scheduling (for details see [9]). A RED link is a random-early drop queue (for details see [2]). A CBQ link is for class-based queuing using a packet-by-packet round-robin scheduler (for details see [3]). A CBQ/WRR link is for class-based queuing with a weighted round robin scheduler. If multicast routing is used links with interface labels are required. Such links are created by setting Simulator NumberInterfaces_ variable to 1. All the subsequently created links will have interface labels. To disable creation of interfaces simply reset NumberInterfaces_ to 0 (this is the default).</p>
  </dd>
  <dt>
    <strong>$ns link</strong><em> node1 node2</em><strong></strong>
  </dt>
  <dd>
    <p>Returns a reference to the link connecting nodes <em>node1</em> and <em>node2.</em> This is useful for setting link configuration parameters and to invoke tracing methods (see LINK OBJECTS section).</p>
  </dd>
  <dt>
    <strong>$ns queue-limit</strong><em> node1 node2 queue-limit</em><strong></strong>
  </dt>
  <dd>
    <p>Set the maximum number of packets that can be queued on the link in the direction from <em>node1</em> to <em>node2</em> to <em>queue-limit.</em> The link between node1 and node2 should have already been created.</p>
  </dd>
  <dt>
    <strong>$ns delay</strong><em> node1 node2 time-interval</em><strong></strong>
  </dt>
  <dd>
    <p>Set the latency of the link in the direction from <em>node1</em> to <em>node2</em> to <em>time-interval</em> seconds. The link between node1 and node2 should have already been created.</p>
  </dd>
  <dt>
    <strong>$ns cost </strong><em> node1 node2 cost-val</em><strong></strong>
  </dt>
  <dd>
    <p>Assign the cost <em>cost-val</em> to the link between nodes <em>node1</em> and <em>node2.</em> The costs assigned to links are used in unicast route computations. All the links default to a cost of 1.</p>
  </dd>
  <dt>
    <strong>$ns multi-link</strong><em> node-list bw delay type</em><strong></strong>
  </dt>
  <dd>
    <p>Connects the nodes specified in <em>node-list</em> by a mesh of duplex links (to simulate a broadcast LAN) with bandwidth <em>bw</em> in bits per second and link propagation delay <em>delay</em> in seconds. <em>node-list</em> is a list of node object handles that have already been created with the <em>node</em> method. <em>bw</em> and <em>delay</em> default to 1.5 Mbits/sec and 100 ms respectively. The defaults can be changed by modifying the relevant configuration parameters of the DelayLink Object (see DELAYLINK OBJECTS section). The queuing discipline of the link is specified by <em>type,</em> which may be <strong>DropTail,</strong> <strong>FQ</strong> <strong>SFQ,</strong> <strong>DRR,</strong> <strong>RED,</strong> <strong>CBQ,</strong> or <strong>CBQ/WRR.</strong> A DropTail link is a simple FIFO queue which drops the last packet in the queue when the queue overflows. A FQ link is for Fair Queuing (for details see [?]). A SFQ link is for Stochastic Fair Queuing (for details see [?]). A DRR link is for deficit round robin scheduling (for details see [9]). A RED link is a random-early drop queue (for details see [2]). A CBQ link is for class-based queuing using a packet-by-packet round-robin scheduler (for details see [3]). A CBQ/WRR link is for class-based queuing with a weighted round robin scheduler.</p>
  </dd>
  <dt>
    <strong>$ns multi-link-of-interfaces</strong><em> node-list bw delay type</em><strong></strong>
  </dt>
  <dd>
    <p>Connects the nodes specified in <em>node-list</em> by a mesh of duplex links with interfaces (to simulate a broadcast LAN) with bandwidth <em>bw</em> in bits per second and link propagation delay <em>delay</em> in seconds. <em>node-list</em> is a list of node object handles that have already been created with the <em>node</em> method. <em>bw</em> and <em>delay</em> default to 1.5 Mbits/sec and 100 ms respectively. The defaults can be changed by modifying the relevant configuration parameters of the DelayLink Object (see DELAYLINK OBJECTS section). The queuing discipline of the link is specified by <em>type,</em> which may be <strong>DropTail,</strong> <strong>FQ</strong> <strong>SFQ,</strong> <strong>DRR,</strong> <strong>RED,</strong> <strong>CBQ,</strong> or <strong>CBQ/WRR.</strong> A DropTail link is a simple FIFO queue which drops the last packet in the queue when the queue overflows. A FQ link is for Fair Queuing (for details see [?]). A SFQ link is for Stochastic Fair Queuing (for details see [?]). A DRR link is for deficit round robin scheduling (for details see [9]). A RED link is a random-early drop queue (for details see [2]). A CBQ link is for class-based queuing using a packet-by-packet round-robin scheduler (for details see [3]). A CBQ/WRR link is for class-based queuing with a weighted round robin scheduler.</p>
  </dd>
  <dt>
    <strong>new Agent/</strong><em>type</em><strong></strong>
  </dt>
  <dd>
    <p>Create an Agent of type <em>type</em> which may be:</p>
<pre>
  Null                  - Traffic Sink
  LossMonitor           - Traffic Sink that monitors loss parameters
  TCP                   - BSD Tahoe TCP
  TCP/FullTcp           - Full Reno TCP with two-way connections [11]
  TCP/Reno              - BSD Reno TCP
  TCP/Newreno           - a modified version of BSD Reno TCP
  TCP/Vegas             - Vegas TCP (from U. Arizonia via USC)
  TCP/Sack1             - BSD Reno TCP with selective ACKs
  TCP/Fack              - BSD Reno TCP with forward ACKs
  TCPSink               - standard TCP sink
  TCPSink/DelAck        - TCP sink that generates delayed ACKs
  TCPSink/Sack1         - TCP sink that generates selective ACKs
  TCPSink/Sack1/DelAck  - delayed-ack TCP sink with selective ACKs
  UDP                   - UDP Transport
  RTP                   - RTP agent
  Session/RTP           -
  RTCP                  - RTCP agent
  IVS/Source            -
  IVS/Receiver          -
  SRM                   -
</pre>
<p>The methods, configuration parameters and the relevant state variables associated with these objects are discussed in detail in later sections. Note that some agents e.g. TCP or SRM do not generate their own data. Such agents need sources attached to them to generate data (see attach-source and attach-traffic methods in AGENT OBJECTS section).</p>
  </dd>
  <dt>
    <strong>$ns attach-agent </strong><em>node agent</em><strong></strong>
  </dt>
  <dd>
    <p>Attach the agent object <em>agent</em> to <em>node.</em> The <em>agent</em> and <em>node</em> objects should have already been created.</p>
  </dd>
  <dt>
    <strong>$ns detach-agent </strong><em>node agent</em><strong></strong>
  </dt>
  <dd>
    <p>Detach the agent object <em>agent</em> from <em>node.</em></p>
  </dd>
  <dt>
    <strong>$ns connect </strong><em>src dst</em><strong></strong>
  </dt>
  <dd>
    <p>Establish a two-way connection between the agent <em>src</em> and the agent <em>dst.</em> Returns the handle to <em>src</em> agent. A helper method has been defined to facilitate creating and attaching an agent to each of two nodes and establishing a two-way connection between them. (see BUILTINS section).</p>
  </dd>
  <dt>
    <strong>$ns use-scheduler </strong><em>type</em><strong></strong>
  </dt>
  <dd>
    <p>Use an event scheduler of type <em>type</em> in the simulations. <em>type</em> is one of List, Heap, Calendar, RealTime. The List scheduler is the default. A Heap scheduler uses a heap for event queueing. A Calendar scheduler uses a calendar queue to keep track of events. RealTime scheduler is used in emulation mode when the simulator interacts with an external agent.</p>
  </dd>
  <dt>
    <strong>$ns at</strong><em> time procedure</em><strong></strong>
  </dt>
  <dd>
    <p>Evaluate <em>procedure</em> at simulation time <em>time.</em> The procedure could be a globally accessible function (proc) or an object method (instproc). This command can be used to start and stop sources, dynamically reconfigure the simulator, dump statistics at specified intervals, etc. Returns an event id.</p>
  </dd>
  <dt>
    <strong>$ns cancel </strong><em>eid</em><strong></strong>
  </dt>
  <dd>
    <p>Remove the event specified by the event id <em>eid</em> from the event queue.</p>
  </dd>
  <dt>
    <strong>$ns now</strong>
  </dt>
  <dd>
    <p>Return the current simulation time.</p>
  </dd>
  <dt>
    <strong>$ns gen-map</strong>
  </dt>
  <dd>
    <p>Walks through the simulation topology and lists all the objects that have been created and the way they are hooked up to each other. This is useful to debug simulation scripts.</p>
  </dd>
  <dt>
    <strong>ns-version</strong>
  </dt>
  <dd>
    <p>Return a string identifying the version of ns currently running. This method is executed in the global context by the interpreter.</p>
  </dd>
  <dt>
    <strong>ns-random</strong><em> [ seed ]</em><strong></strong>
  </dt>
  <dd>
    <p>If <em>seed</em> is not present, return a pseudo-random integer between 0 and 2^31-1. Otherwise, seed the pseudo-random number generator with <em>seed</em> and return the seed used. If <em>seed</em> is 0, choose an initial seed heuristically (which varies on successive invocations). This method is executed in the global context by the interpreter.</p>
  </dd>

</dl>
<p>Ns has other facilities for random number generation; please see documentation for details [13].</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OBJECT HIERARCHY</h2>
        <div class="sectioncontent">
<p>A brief description of the object hierarchy in <em>ns</em> is presented in this section. This description is not intended to be complete. It has been provided to depict how the methods and configuration parameters associated with the various objects are inherited. For more complete information see "ns notes & documentation" and the automatically generated class library information on the ns web page.</p><p>Objects are associated with configuration parameters that can be dynamically set and queried, and state variables that can be queried (usually modified only when the state variables need to be reset for another simulation run).</p><p>Configuration parameters represent simulation parameters that are usually fixed during the entire simulation (like a link bandwidth), but can be changed dynamically if desired. State variables represent values that are specific to a given object and that object's implementation.</p><p>The following diagram depicts a portion the object hierarchy:</p>
<pre>
    Simulator
          MultiSim
    Node
    Link
          SimpleLink
               CBQLink
          DummyLink
    DelayLink
    Queue
          DropTail
          FQ
          SFQ
          DRR
          RED
          CBQ
          CBQ/WRR
    QueueMonitor
          ED
               Flowmon
               Flow
    rtObject
    RouteLogic
    Agent
          rtProto
               Static
               Session
               DV
               Direct
          Null
          LossMonitor
          TCP
               FullTcp
               Reno
               Newreno
               Sack1
               Fack
          TCPSink
               DelAck
               Sack1
                   DelAck
          UDP
          RTP
          RTCP
          IVS
               Source
               Receiver
          SRM
          Session
               RTP [how is this diff from Agent/CBR/RTP]
    Appplication
          FTP
          Telnet
          Traffic
               Expoo
               Pareto
               CBR
               Trace
    Integrator
    Samples
</pre>
<p>For a complete, automatically generated, object hierarchy, see the link "class hierarchy" (which points to http://www-sop.inria.fr/rodeo/personnel/Antoine.Clerget/ns/) on the ns web pages.  (Thanks to Antoine Clerget for maintaining this!)</p><p>For example, any method that is supported by a <em>TCP</em> agent is also supported by a <em>Reno</em> or a <em>Sack1</em> agent. Default configuration parameters are also inherited. For example, <em>$tcp set window_ 20</em> where $tcp is a TCP agent defines the default TCP window size for both <em>TCP</em> and <em>Reno</em> objects.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OBJECT METHODS</h2>
        <div class="sectioncontent">
<p>The following sections document the methods, configuration parameters and state variables associated with the various objects as well as those to enable Network dynamics, Unicast routing, Multicast routing and Trace and Monitoring support. The object class is specified implicitly by the object variable name in the description. For example, <strong>$tcp</strong> implies the tcp object class and all of its child classes.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NODE OBJECTS</h2>
        <div class="sectioncontent">
<p>[NOTE: This section has not been verified to be up-to-date with the release.]</p>
<dl class='dl-vertical'>
  <dt>
    <strong>$node id</strong>
  </dt>
  <dd>
    <p>Returns the node id.</p>
  </dd>
  <dt>
    <strong>$node neighbors</strong>
  </dt>
  <dd>
    <p>Returns a list of the neighbour node objects.</p>
  </dd>
  <dt>
    <strong>$node attach </strong><em>agent</em><strong></strong>
  </dt>
  <dd>
    <p>Attach an agent of type <em>agent</em> to this node.</p>
  </dd>
  <dt>
    <strong>$node detach </strong><em>agent</em><strong></strong>
  </dt>
  <dd>
    <p>Detach an agent of type <em>agent</em> from this node.</p>
  </dd>
  <dt>
    <strong>$node agent </strong><em>port</em><strong></strong>
  </dt>
  <dd>
    <p>Return a handle to the agent attached to port <em>port</em> on this node.  Returns an empty string if the port is not in use.</p>
  </dd>
  <dt>
    <strong>$node reset</strong>
  </dt>
  <dd>
    <p>Reset all agents attached to this node. This would re-initialize the state variables associated with the various agents at this node.</p>
  </dd>
  <dt>
    <strong>$node rtObject?</strong>
  </dt>
  <dd>
    <p>Returns a handle to rtObject if there exists an instance of the object at that node. Only nodes that take part in a dynamic unicast routing protocol will have this object (see UNICAST ROUTING METHODS and RTOBJECT OBJECTS section).</p>
  </dd>
  <dt>
    <strong>$node join-group </strong><em>agent group</em><strong></strong>
  </dt>
  <dd>
    <p>Add the agent specified by the object handle <em>agent</em> to the multicast host group identified by the address <em>group.</em> This causes the group membership protocol to arrange for the appropriate multicast traffic to reach this agent. Multicast group address should be in the range 0x8000 - 0xFFFF.</p>
  </dd>
  <dt>
    <strong>$node allocaddr</strong>
  </dt>
  <dd>
    <p>Returns multicast group address in ascending order on each invocation starting from 0x8000 and ending at 0xFFFF.</p>
  </dd>
  <dt>
    <strong>$node shape </strong><em>shape</em><strong></strong>
  </dt>
  <dd>
    <p>Set the shape of the node to "<em>shape</em>". When called before the simulator starts to run, it changes the default shape of the node in the nam trace file. The default shape of a node is """circle"""</p>
  </dd>
  <dt>
    <strong>$node color </strong><em>color</em><strong></strong>
  </dt>
  <dd>
    <p>Set the color of the node to <em>color</em>. It can be called anytime to change the current color of the node in nam trace file, if there is one.</p>
  </dd>
  <dt>
    <strong>$node get-attribute </strong><em>name</em><strong></strong>
  </dt>
  <dd>
    <p>Get the specified attribute <em>name</em> of the node. Currently a Node object has two attributes: <em>COLOR</em> and <em>SHAPE</em>. Note: these letters must be capital.</p>
  </dd>
  <dt>
    <strong>$node add-mark </strong><em>name color shape</em><strong></strong>
  </dt>
  <dd>
    <p>Add a mark (in nam trace file) with <em>color</em> and <em>shape</em> around the node. The shape can be """circle""", """hexagon""" and """square""" (case sensitive). The added mark will be identified by <em>name</em>.</p>
  </dd>
  <dt>
    <strong>$node delete-mark </strong><em>name</em><strong></strong>
  </dt>
  <dd>
    <p>Delete the mark with <em>name</em> in the given node.</p>
  </dd>

</dl>
<p>There are no state variables or configuration parameters specific to the node class.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LINK OBJECTS</h2>
        <div class="sectioncontent">
<p>[NOTE: This section has not been verified to be up-to-date with the release.]</p>
<dl class='dl-vertical'>
  <dt>
    <strong>$link trace-dynamics </strong><em>ns fileID</em><strong></strong>
  </dt>
  <dd>
    <p>Trace the dynamics of this link and write the output to <em>fileID</em> filehandle. <em>ns</em> is an instance of the Simulator or MultiSim object that was created to invoke the simulation (see TRACE AND MONITORING METHODS section for the output trace format).</p>
  </dd>
  <dt>
    <strong>$link trace-callback </strong><em>ns cmd</em><strong></strong>
  </dt>
  <dd>
    <p>Trace all packets on the link with the callback <em>cmd</em>. Cmd is invoked for each trace event (enqueue, dequeue, drop) with the text that would be logged as parameters. (See the description of the log file for this information.) A demo of trace callbacks is in the program tcl/ex/callback_demo.tcl in the distribution.</p>
  </dd>
  <dt>
    <strong>$link color </strong><em>color</em><strong></strong>
  </dt>
  <dd>
    <p>Set the color of the Link object. It can be called anytime to change the current color of the link in nam trace file, if there is one.</p>
  </dd>
  <dt>
    <strong>$link get-attribute </strong><em>name</em><strong></strong>
  </dt>
  <dd>
    <p>Get the specified attribute <em>name</em> of the Link. Currently a Link object has three attributes: <em>COLOR</em>, <em>ORIENTATION</em>, and <em>QUEUE_POS</em>.</p>
  </dd>

</dl>
<p>Currently the following two functions should not be directly called. Use <strong>$ns duplex-link-op</strong> instead. Refer to the corresponding section in this man page.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>$link orient </strong><em>ori</em><strong></strong>
  </dt>
  <dd>
    <p>Set the orientation of the link to <em>ori</em>. When called before the simulator starts to run, it changes the default orientation of the link in nam trace file, if there is one. If orientation is unspecified for any link(s), nam will use automatic layout. The default orientation of a Link object is unspecified.</p>
  </dd>
  <dt>
    <strong>$link queuePos </strong><em>pos</em><strong></strong>
  </dt>
  <dd>
    <p>Set the queue position of the link to <em>pos</em>. When called before the simulator starts to run, it changes the default queue placement of the simplex link in nam trace file, if there is one. <em>pos</em> specifies the angle between the horizontal line and the line along which queued packets will be displayed.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SIMPLELINK OBJECTS</h2>
        <div class="sectioncontent">
<p>[NOTE: This section has not been verified to be up-to-date with the release.]</p>
<dl class='dl-vertical'>
  <dt>
    <strong>$link cost </strong><em>cost-val</em><strong></strong>
  </dt>
  <dd>
    <p>Make <em>cost-val</em> the cost of this link.</p>
  </dd>
  <dt>
    <strong>$link cost?</strong>
  </dt>
  <dd>
    <p>Return the cost of this link.</p>
  </dd>

</dl>
<p>Any configuration parameters or state variables?</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DELAYLINK OBJECTS</h2>
        <div class="sectioncontent">
<p>[NOTE: This section has not been verified to be up-to-date with the release.] The DelayLink Objects determine the amount of time required for a packet to traverse a link. This is defined to be size/bw + delay where size is the packet size, bw is the link bandwidth and delay is the link propagation delay. There are no methods or state variables associated with this object.</p><p><strong></strong> Configuration Parameters </p>
<dl class='dl-vertical'>
  <dt>
    <em>bandwidth_</em>
  </dt>
  <dd>
    <p>Link bandwidth in bits per second.</p>
  </dd>
  <dt>
    <em>delay_</em>
  </dt>
  <dd>
    <p>Link propagation delay in seconds.</p>
  </dd>

</dl>
<p>There are no state variables associated with this object.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NETWORK DYNAMICS METHODS</h2>
        <div class="sectioncontent">
<p>This section describes methods to make the links and nodes in the topology go up and down according to various distributions. A dynamic routing protocol should generally be used whenever a simulation is to be done with network dynamics. Note that a static topology model is the default in ns.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>$ns rtmodel </strong><em>model model-params node1 [node2]</em><strong></strong>
  </dt>
  <dd>
    <p>Make the link between <em>node1</em> and <em>node2</em> change between up and down states according to the model <em>model.</em> In case only <em>node1</em> is specified all the links incident on the node would be brought up and down according to the specified <em>model.</em> <em>model-params</em> contains the parameters required for the relevant model and is to be specified as a list i.e. the parameters are to be enclosed in curly brackets. <em>model</em> can be one of <em>Deterministic,</em> <em>Exponential,</em> <em>Manual,</em> <em>Trace.</em> Returns a handle to a model object corresponding to the specified <em>model.</em></p><p>In the Deterministic model <em>model-params</em> is <em>[start-time] up-interval down-interval [finish-time].</em> Starting from <em>start-time</em> the link is made up for <em>up-interval</em> and down for <em>down-interval</em> till <em>finish-time</em> is reached. The default values for start-time, up-interval, down-interval are 0.5s, 2.0s, 1.0s respectively. finish-time defaults to the end of the simulation. The start-time defaults to 0.5s in order to let the routing protocol computation quiesce.</p><p>If the Exponential model is used <em>model-params</em> is of the form <em>up-interval down-interval</em> where the link up-time is an exponential distribution around the mean <em>up-interval</em> and the link down-time is an exponential distribution around the mean <em>down-interval.</em> Default values for <em>up-interval</em> and <em>down-interval</em> are 10s and 1s respectively.</p><p>If the Manual distribution is used <em>model-params</em> is <em>at op</em> where <em>at</em> specifies the time at which the operation <em>op</em> should occur. <em>op</em> is one of <em>up, down.</em> The Manual distribution could be specified alternately using the <em>rtmodel-at</em> method described later in the section.</p><p>If Trace is specified as the <em>model</em> the link/node dynamics is read from a Tracefile. The <em>model-params</em> argument would in this case be the file-handle of the Tracefile that has the dynamics information. The tracefile format is identical to the trace output generated by the trace-dynamics link method (see TRACE AND MONITORING METHODS SECTION).</p>
  </dd>
  <dt>
    <strong>$ns rtmodel-delete </strong><em>model-handle</em><strong></strong>
  </dt>
  <dd>
    <p>Delete the instance of the route model specified by <em>model-handle.</em></p>
  </dd>
  <dt>
    <strong>$ns rtmodel-at </strong><em>at op node1 [node2]</em><strong></strong>
  </dt>
  <dd>
    <p>Used to specify the up and down times of the link between nodes <em>node1</em> and <em>node2.</em> If only <em>node1</em> is given all the links incident on <em>node1</em> will be brought up and down. <em>at</em> is the time at which the operation <em>op</em> that can be either <em>up</em> or <em>down</em> is to be performed on the specified link(s).</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">QUEUE OBJECTS</h2>
        <div class="sectioncontent">
<p>A queue object is a general class of object capable of holding and possibly marking or discarding packets as they travel through the simulated topology.</p><p>Configuration Parameters </p>
<dl class='dl-vertical'>
  <dt>
    <em>limit_</em>
  </dt>
  <dd>
    <p>The queue size in packets.</p>
  </dd>
  <dt>
    <em>blocked_</em>
  </dt>
  <dd>
    <p>Set to false by default, this is true if the queue is blocked (unable to send a packet to its downstream neighbor).</p>
  </dd>
  <dt>
    <em>unblock_on_resume_</em>
  </dt>
  <dd>
    <p>Set to true by default, indicates a queue should unblock itself at the time the last packet packet sent has been transmitted (but not necessarily received).</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DROP-TAIL OBJECTS</h2>
        <div class="sectioncontent">
<p>Drop-tail objects are a subclass of Queue objects that implement simple FIFO queue.  There are no methods that are specific to drop-tail objects.  The only configuration parameter is <em>drop-front_</em>, which when set to true causes the queue to behave as a drop-from-front queueing discipline.  This variable is set to false by default.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FQ OBJECTS</h2>
        <div class="sectioncontent">
<p>FQ objects are a subclass of Queue objects that implement Fair queuing.  There are no methods that are specific to FQ objects.</p><p>Configuration Parameters </p>
<dl class='dl-vertical'>
  <dt>
    <em>secsPerByte_</em>
  </dt>
  <dd>
    
  </dd>

</dl>
<p>There are no state variables associated with this object.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SFQ OBJECTS</h2>
        <div class="sectioncontent">
<p>SFQ objects are a subclass of Queue objects that implement Stochastic Fair queuing.  There are no methods that are specific to SFQ objects.</p><p>Configuration Parameters </p>
<dl class='dl-vertical'>
  <dt>
    <em>maxqueue_</em>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <em>buckets_</em>
  </dt>
  <dd>
    
  </dd>

</dl>
<p>There are no state variables associated with this object.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DRR OBJECTS</h2>
        <div class="sectioncontent">
<p>DRR objects are a subclass of Queue objects that implement deficit round robin scheduling. These objects implement deficit round robin scheduling amongst different flows ( A particular flow is one which has packets with the same node and port id OR packets which have the same node id alone). Also unlike other multi-queue objects, this queue object implements a single shared buffer space for its different flows.</p><p>Configuration Parameters </p>
<dl class='dl-vertical'>
  <dt>
    <em>buckets_</em>
  </dt>
  <dd>
    <p>Indicates the total number of buckets to be used for hashing each of the flows.</p>
  </dd>
  <dt>
    <em>blimit_</em>
  </dt>
  <dd>
    <p>Indicates the shared buffer size in bytes.</p>
  </dd>
  <dt>
    <em>quantum_</em>
  </dt>
  <dd>
    <p>Indicates (in bytes) how much each flow can send during its turn.</p>
  </dd>
  <dt>
    <em>mask_</em>
  </dt>
  <dd>
    <p>mask_, when set to 1, means that a particular flow consists of packets having the same node id (and possibly different port ids), otherwise a flow consists of packets having the same node and port ids.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RED OBJECTS</h2>
        <div class="sectioncontent">
<p>RED objects are a subclass of Queue objects that implement random early-detection gateways.  The object can be configured to either drop or ``mark'' packets. There are no methods that are specific to RED objects.</p><p>Configuration Parameters </p>
<dl class='dl-vertical'>
  <dt>
    <em>bytes_</em>
  </dt>
  <dd>
    <p>Set to "true" to enable ``byte-mode'' RED, where the size of arriving packets affect the likelihood of marking (dropping) packets.</p>
  </dd>
  <dt>
    <em>queue-in-bytes_</em>
  </dt>
  <dd>
    <p>Set to "true" to measure the average queue size in bytes rather than packets. Enabling this option also causes <em>thresh_</em> and <em>maxthresh_</em> to be automatically scaled by <em>mean_pktsize_</em> (see below).</p>
  </dd>
  <dt>
    <em>thresh_</em>
  </dt>
  <dd>
    <p>The minimum threshold for the average queue size in packets.</p>
  </dd>
  <dt>
    <em>maxthresh_</em>
  </dt>
  <dd>
    <p>The maximum threshold for the average queue size in packets.</p>
  </dd>
  <dt>
    <em>mean_pktsize_</em>
  </dt>
  <dd>
    <p>A rough estimate of the average packet size in bytes.  Used in updating the calculated average queue size after an idle period.</p>
  </dd>
  <dt>
    <em>q_weight_</em>
  </dt>
  <dd>
    <p>The queue weight, used in the exponential-weighted moving average for calculating the average queue size.</p>
  </dd>
  <dt>
    <em>wait_</em>
  </dt>
  <dd>
    <p>Set to true to maintain an interval between dropped packets.</p>
  </dd>
  <dt>
    <em>linterm_</em>
  </dt>
  <dd>
    <p>As the average queue size varies between "thresh_" and "maxthresh_", the packet dropping probability varies between 0 and "1/linterm".</p>
  </dd>
  <dt>
    <em>setbit_</em>
  </dt>
  <dd>
    <p>Set to "true" to mark packets by setting the congestion indication bit in packet headers rather than drop packets.</p>
  </dd>
  <dt>
    <em>drop-tail_</em>
  </dt>
  <dd>
    <p>Set to true to use drop-tail rather than random-drop or drop-from-front when the queue overflows or the average queue size exceeds "maxthresh_".  This is the default behavior. For a further explanation of these variables, see [2].</p>
  </dd>
  <dt>
    <em>drop-rand_</em>
  </dt>
  <dd>
    <p>Set to true to use random-drop rather than drop-tail or drop-from-front when the queue overflows or the average queue size exceeds "maxthresh_".</p>
  </dd>
  <dt>
    <em>drop-front_</em>
  </dt>
  <dd>
    <p>Set to true to use drop-from-front rather than drop-tail or random drop when the queue overflows or the average queue size exceeds "maxthresh_".</p>
  </dd>
  <dt>
    <em>ns1-compat_</em>
  </dt>
  <dd>
    <p>Set to true to avoid resetting the count since the last packet drop, after a forced packet is dropped.  This gives compatibility with previous behavior of RED.  The default is set to false.</p>
  </dd>
  <dt>
    gentle_
  </dt>
  <dd>
    <p>Set to true to increase the packet drop rate slowly from max_p to 1 as the average queue size ranges from maxthresh to twice maxthresh. The default is set to false, and max_p increases abruptly from max_p to 1 when the average queue size exceeds maxthresh.</p>
  </dd>

</dl>
<p>State Variables</p><p>None of the state variables of the RED implementation are accessible.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CBQ OBJECTS</h2>
        <div class="sectioncontent">
<p>CBQ objects are a subclass of Queue objects that implement class-based queueing.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>$cbq insert $class</strong>
  </dt>
  <dd>
    <p>Insert traffic class <em>class</em> into the link-sharing structure associated with link object <em>cbq.</em></p>
  </dd>
  <dt>
    <strong>$cbq bind $cbqclass $id1 [$id2]</strong>
  </dt>
  <dd>
    <p>Cause packets containing flow id <em>$id1</em> (or those in the range <em>$id1</em> to <em>$id2</em> inclusive) to be associated with the traffic class <em>$cbqclass.</em></p>
  </dd>
  <dt>
    <strong>$cbq algorithm $alg</strong>
  </dt>
  <dd>
    <p>Select the CBQ internal algorithm. <em>$alg</em> may be set to one of: "ancestor-only", "top-level", or "formal".</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CBQ/WRR OBJECTS</h2>
        <div class="sectioncontent">
<p>CBQ/WRR objects are a subclass of CBQ objects that implement weighted round-robin scheduling among classes of the same priority level.  In contrast, CBQ objects implement packet-by-packet round-robin scheduling among classes of the same priority level. Configuration Parameters </p>
<dl class='dl-vertical'>
  <dt>
    <em>maxpkt_</em>
  </dt>
  <dd>
    <p>The maximum size of a packet in bytes. This is used only by CBQ/WRR objects in computing maximum bandwidth allocations for the weighted round-robin scheduler.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CBQCLASS OBJECTS</h2>
        <div class="sectioncontent">
<p>CBQClass objects implement the traffic classes associated with CBQ objects.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>$cbqclass setparams </strong><em>parent okborrow allot maxidle prio level extradelay</em><strong></strong>
  </dt>
  <dd>
    <p>Sets several of the configuration parameters for the CBQ traffic class (see below).</p>
  </dd>
  <dt>
    <strong>$cbqclass parent [$cbqcl|none]</strong>
  </dt>
  <dd>
    <p>specify the parent of this class in the link-sharing tree. The parent may be specified as ``none'' to indicate this class is a root.</p>
  </dd>
  <dt>
    <strong>$cbqclass newallot $a</strong>
  </dt>
  <dd>
    <p>Change the link allocation of this class to the specified amount (in range 0.0 to 1.0). Note that only the specified class is affected.</p>
  </dd>
  <dt>
    <strong>$cbqclass install-queue $q</strong>
  </dt>
  <dd>
    <p>Install a Queue object into the compound CBQ or CBQ/WRR link structure. When a CBQ object is initially created, it includes no internal queue (only a packet classifier and scheduler).</p>
  </dd>

</dl>
<p>Configuration Parameters </p>
<dl class='dl-vertical'>
  <dt>
    <strong>okborrow_</strong>
  </dt>
  <dd>
    <p>is a boolean indicating the class is permitted to borrow bandwidth from its parent.</p>
  </dd>
  <dt>
    <strong>allot_</strong>
  </dt>
  <dd>
    <p>is the maximum fraction of link bandwidth allocated to the class expressed as a real number between 0.0 and 1.0.</p>
  </dd>
  <dt>
    <strong>maxidle_</strong>
  </dt>
  <dd>
    <p>is the maximum amount of time a class may be required to have its packets queued before they are permitted to be forwarded</p>
  </dd>
  <dt>
    <strong>priority_</strong>
  </dt>
  <dd>
    <p>is the class' priority level with respect to other classes. This value may range from 0 to 10, and more than one class may exist at the same priority. Priority 0 is the highest priority.</p>
  </dd>
  <dt>
    <strong>level_</strong>
  </dt>
  <dd>
    <p>is the level of this class in the link-sharing tree. Leaf nodes in the tree are considered to be at level 1; their parents are at level 2, etc.</p>
  </dd>
  <dt>
    <strong>extradelay_</strong>
  </dt>
  <dd>
    <p>increase the delay experienced by a delayed class by the specified number of seconds.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">QUEUEMONITOR Objects</h2>
        <div class="sectioncontent">
<p>QueueMonitor Objects are used to monitor a set of packet and byte arrival, departure and drop counters. It also includes support for aggregate statistics such as average queue size, etc. [see TRACE AND MONITORING METHODS].</p>
<dl class='dl-vertical'>
  <dt>
    <strong>$queuemonitor reset</strong>
  </dt>
  <dd>
    <p>reset all the cumulative counters described below (arrivals, departures, and drops) to zero. Also, reset the integrators and delay sampler, if defined.</p>
  </dd>
  <dt>
    <strong>$queuemonitor set-delay-samples </strong><em>delaySamp_</em><strong></strong>
  </dt>
  <dd>
    <p>Set up the Samples object <em>delaySamp_</em> to record statistics about queue delays. <em>delaySamp_</em> is a handle to a Samples object i.e the Samples object should have already been created.</p>
  </dd>
  <dt>
    <strong>$queuemonitor get-bytes-integrator</strong>
  </dt>
  <dd>
    <p>Returns an Integrator object that can be used to find the integral of the queue size in bytes. (see Integrator Objects section).</p>
  </dd>
  <dt>
    <strong>$queuemonitor get-pkts-integrator </strong>
  </dt>
  <dd>
    <p>Returns an Integrator object that can be used to find the integral of the queue size in packets. (see Integrator Objects section).</p>
  </dd>
  <dt>
    <strong>$queuemonitor get-delay-samples</strong>
  </dt>
  <dd>
    <p>Returns a Samples object <em>delaySamp_</em> to record statistics about queue delays (see Samples Objects section).</p>
  </dd>

</dl>
<p>There are no configuration parameters specific to this object.</p><p>State Variables</p>
<dl class='dl-vertical'>
  <dt>
    <em>size_</em>
  </dt>
  <dd>
    <p>Instantaneous queue size in bytes.</p>
  </dd>
  <dt>
    <em>pkts_</em>
  </dt>
  <dd>
    <p>Instantaneous queue size in packets.</p>
  </dd>
  <dt>
    <em>parrivals_</em>
  </dt>
  <dd>
    <p>Running total of packets that have arrived.</p>
  </dd>
  <dt>
    <em>barrivals_</em>
  </dt>
  <dd>
    <p>Running total of bytes contained in packets that have arrived.</p>
  </dd>
  <dt>
    <em>pdepartures_</em>
  </dt>
  <dd>
    <p>Running total of packets that have departed (not dropped).</p>
  </dd>
  <dt>
    <em>bdepartures_</em>
  </dt>
  <dd>
    <p>Running total of bytes contained in packets that have departed (not dropped).</p>
  </dd>
  <dt>
    <em>pdrops_</em>
  </dt>
  <dd>
    <p>Total number of packets dropped.</p>
  </dd>
  <dt>
    <em>bdrops_</em>
  </dt>
  <dd>
    <p>Total number of bytes dropped.</p>
  </dd>
  <dt>
    <em>bytesInt_</em>
  </dt>
  <dd>
    <p>Integrator object that computes the integral of the queue size in bytes. The <em>sum_</em> variable of this object has the running sum (integral) of the queue size in bytes.</p>
  </dd>
  <dt>
    <em>pktsInt_</em>
  </dt>
  <dd>
    <p>Integrator object that computes the integral of the queue size in packets. The <em>sum_</em> variable of this object has the running sum (integral) of the queue size in packets.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">QUEUEMONITOR/ED Objects</h2>
        <div class="sectioncontent">
<p>This derived object is capable of differentiating regular packet drops from <em>early</em> drops.  Some queues distinguish regular drops (e.g. drops due to buffer exhaustion) from other drops (e.g. random drops in RED queues). Under some circumstances, it is useful to distinguish these two types of drops.</p><p>State Variables</p>
<dl class='dl-vertical'>
  <dt>
    <em>epdrops_</em>
  </dt>
  <dd>
    <p>The number of packets that have been dropped ``early''.</p>
  </dd>
  <dt>
    <em>ebdrops_</em>
  </dt>
  <dd>
    <p>The number of bytes comprising packets that have been dropped ``early''</p>
  </dd>

</dl>
<p><strong>Note:</strong> because this class is a subclass of QueueMonitor, objects of this type also have fields such as pdrops_ and bdrops_.  These fields describe the <em>total</em> number of dropped packets and bytes, including both early and non-early drops.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">QUEUEMONITOR/ED/FLOWMON Objects</h2>
        <div class="sectioncontent">
<p>These objects may be used in the place of a conventional QueueMonitor object when wishing to collect per-flow counts and statistics in addition to the aggregate counts and statistics provided by the basic QueueMonitor.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>$fmon classifier [$cl]</strong>
  </dt>
  <dd>
    <p>insert (read) the specified classifier into (from) the flow monitor object. This is used to map incoming packets to which flows they are associated with.</p>
  </dd>
  <dt>
    <strong>$fmon dump</strong>
  </dt>
  <dd>
    <p>Dump the current per-flow counters and statistics to the I/O channel specified in a previous attach operation.</p>
  </dd>
  <dt>
    <strong>$fmon flows</strong>
  </dt>
  <dd>
    <p>Return a character string containing the names of all flow objects known by this flow monitor.  Each of these objects are of type QueueMonitor/ED/Flow.</p>
  </dd>
  <dt>
    <strong>$fmon attach $chan</strong>
  </dt>
  <dd>
    <p>Attach a tcl I/O channel to the flow monitor. Flow statistics are written to the channel when the dump operation is executed.</p>
  </dd>

</dl>
<p>Configuration Parameters</p>
<dl class='dl-vertical'>
  <dt>
    <strong>enable_in_</strong>
  </dt>
  <dd>
    <p>Set to true by default, indicates that per-flow arrival state should be kept by the flow monitor. If set to false, only the aggregate arrival information is kept.</p>
  </dd>
  <dt>
    <strong>enable_out_</strong>
  </dt>
  <dd>
    <p>Set to true by default, indicates that per-flow departure state should be kept by the flow monitor. If set to false, only the aggregate departure information is kept.</p>
  </dd>
  <dt>
    <strong>enable_drop_</strong>
  </dt>
  <dd>
    <p>Set to true by default, indicates that per-flow drop state should be kept by the flow monitor. If set to false, only the aggregate drop information is kept.</p>
  </dd>
  <dt>
    <strong>enable_edrop_</strong>
  </dt>
  <dd>
    <p>Set to true by default, indicates that per-flow early drop state should be kept by the flow monitor. If set to false, only the aggregate early drop information is kept.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">QUEUEMONITOR/ED/FLOW Objects</h2>
        <div class="sectioncontent">
<p>These objects contain per-flow counts and statistics managed by a QUEUEMONITOR/ED/FLOWMON object. They are generally created in an OTcl callback procedure when a flow monitor is given a packet it cannot map on to a known flow. Note that the flow monitor's classifier is responsible for mapping packets to flows in some arbitrary way.  Thus, depending on the type of classifier used, not all of the state variables may be relevant (e.g. one may classify packets based only on flow id, in which case the source and destination addresses may not be significant).</p><p>State Variables</p>
<dl class='dl-vertical'>
  <dt>
    <strong>src_</strong>
  </dt>
  <dd>
    <p>The source address of packets belonging to this flow.</p>
  </dd>
  <dt>
    <strong>dst_</strong>
  </dt>
  <dd>
    <p>The destination address of packets belonging to this flow.</p>
  </dd>
  <dt>
    <strong>flowid_</strong>
  </dt>
  <dd>
    <p>The flow id of packets belonging to this flow.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">UNICAST ROUTING METHODS</h2>
        <div class="sectioncontent">
<p>A dynamic unicast routing protocol can be specified to run on a subset of nodes in the topology. Note that a dynamic routing protocol should be generally used whenever a simulation is done with network dynamics.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>$ns rtproto </strong><em>proto node-list</em><strong></strong>
  </dt>
  <dd>
    <p>Specifies the dynamic unicast routing protocol <em>proto</em> to be run on the nodes specified by <em>node-list.</em> Currently <em>proto</em> can be one of Static, Session, DV. Static routing is the default. Session implies that the unicast routes over the entire topology are instantaneously recomputed whenever a link goes up or down. DV implies that a simple distance vector routing protocol is to be simulated. <em>node-list</em> defaults to all the nodes in the topology.</p>
  </dd>
  <dt>
    <strong>$ns compute-routes</strong>
  </dt>
  <dd>
    <p>Compute routes between all the nodes in the topology. This can be used if static routing is done and the routes have to be recomputed as the state of a link has changed. Note that Session routing (see <em>rtproto</em> method above) will recompute routes automatically whenever the state of any link in the topology changes.</p>
  </dd>
  <dt>
    <strong>$ns get-routelogic</strong>
  </dt>
  <dd>
    <p>Returns an handle to a RouteLogic object that has methods for route table lookup etc.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ROUTELOGIC OBJECTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <strong>$routelogic lookup </strong><em>srcid destid</em><strong></strong>
  </dt>
  <dd>
    <p>Returns the id of the node that is the next hop from the node with id <em>srcid</em> to the node with id <em>destid.</em></p>
  </dd>
  <dt>
    <strong>$routelogic dump </strong><em>nodeid</em><strong></strong>
  </dt>
  <dd>
    <p>Dump the routing tables of all nodes whose id is less than <em>nodeid.</em> Node ids are typically assigned to nodes in ascending fashion starting from 0 by their order of creation.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RTOBJECT OBJECTS</h2>
        <div class="sectioncontent">
<p>Every node that takes part in a dynamic unicast routing protocol will have an instance of rtObject (see NODE OBJECTS section for the method to get an handle to this object at a particular node). Note that nodes will not have an instance of this object if Session routing is done as a detailed routing protocol is not being simulated in this case.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>$rtobject dump-routes </strong><em>fileID</em><strong></strong>
  </dt>
  <dd>
    <p>Dump the routing table to the output channel specified by <em>fileID.</em> <em>fileID</em> must be a file handle returned by the Tcl <em>open</em> command and it must have been opened for writing.</p>
  </dd>
  <dt>
    <strong>$rtobject rtProto? </strong><em>proto</em><strong></strong>
  </dt>
  <dd>
    <p>Returns a handle to the routing protocol agent specified by <em>proto</em> if it exists at that node. Returns an empty string otherwise.</p>
  </dd>
  <dt>
    <strong>$rtobject nextHop? </strong><em>destID</em><strong></strong>
  </dt>
  <dd>
    <p>Returns the id of the node that is the next hop to the destination specified by the node id, <em>destID.</em></p>
  </dd>
  <dt>
    <strong>$rtobject rtpref? </strong><em>destID</em><strong></strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>$rtobject metric? </strong><em>destID</em><strong></strong>
  </dt>
  <dd>
    
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MULTICAST ROUTING METHODS</h2>
        <div class="sectioncontent">
<p>Multicast routing is enabled by setting Simulator EnableMcast_ variable to 1 at the beginning of the simulation. Note that this variable must be set before any node, link or agent objects are created in the simulation. Also links must have been created with interface labels (see simplex-link and duplex-link methods in NS COMMANDS section).</p>
<dl class='dl-vertical'>
  <dt>
    <strong>$ns mrtproto </strong><em>proto node-list</em><strong></strong>
  </dt>
  <dd>
    <p>Specifies the multicast routing protocol <em>proto</em> to be run on the nodes specified by <em>node-list.</em> Currently <em>proto</em> can be one of CtrMcast, DM, detailedDM, dynamicDM, pimDM. <em>node-list</em> defaults to all the nodes in the topology. Returns an handle to a protocol-specific object that has methods, configuration parameters specific to that protocol. Note that currently CtrMcastComp object is returned if CtrMcast is used but a null string is returned if DM, detailedDM, dynamicDM or pimDM are used.</p><p>If proto is 'CtrMcast' a Rendezvous Point (RP) rooted shared tree is built for a multicast group. The actual sending of prune, join messages etc. to set up state at the nodes is not simulated. A centralized computation agent is used to compute the fowarding trees and set up multicast forwarding state, (*,G) at the relevant nodes as new receivers join a group. Data packets from the senders to a group are unicast to the RP. Methods are provided in the CtrMcastComp object (see CTRMCASTCOMP OBJECTS section) that is returned by mrtproto to switch to source-specific trees, choose some nodes as candidate RPs etc. When a node/link on a multicast distribution tree goes down, the tree is instanteously recomputed.</p><p>If proto is 'DM' DVMRP-like dense mode is simulated. Parent-child lists are used to reduce the number of links over which the data packets are broadcast. Prune messages are sent by nodes to remove branches from the multicast forwarding tree that do not lead to any group members. The prune timeout value is 0.5s by default (see DM OBJECTS section to change the default). This does not adapt to network changes. There is also currently no support for proper functioning in topologies with LANs.</p><p>If proto is 'detailedDM' a dense mode protocol based on Protocol Independent Multicast - Dense Mode (PIM-DM) is simulated. This is currently the most complete version of the dense mode protocol in the simulator and is recommended for use over the other dense mode protocols. It adapts to network dynamics and functions correctly in topologies with LANs (where LANs are created using the multi-link-of-interfaces method - see NS COMMANDS). In case there are multiple potential forwarders for a LAN, the node with the highest id is chosen as the forwarder (this is done through the Assert mechanism). The default values for the prune timeout, interface deletion timeout (used for LANs) and graft retransmission timeout are 0.5s, 0.1s and 0.05s respectively. (see Prune/Iface/Timer, Deletion/Iface/Timer and GraftRtx/Timer objects respectively to change the default values and for more information about the timers).</p><p>If proto is 'dynamicDM' DVMRP-like dense mode protocol that adapts to network changes is simulated.  'Poison-reverse' information (i.e. the information that a particular neighbouring node uses this node to reach a particular network) is read from the routing tables of neighbouring nodes in order to adapt to network dynamics (DVMRP runs its own unicast routing protocol that exchanges this information). The current implementation does not support proper functioning in topologies with LANs. The prune timeout value is 0.5s by default (see DM OBJECTS section to change the default).</p><p>If proto is 'pimDM' Protocol Independent Multicast - Dense mode is simulated. In this case the data packets are broadcast over all the outgoing links except the incoming link. Prune messages are sent by nodes to remove the branches of the multicast forwarding tree that do not lead to any group members. The current implementation does not adapt to network dynamics and does not support proper functioning in topologies with LANs. The prune timeout value is 0.5s by default (see DM OBJECTS section to change the default).</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CTRMCASTCOMP OBJECTS</h2>
        <div class="sectioncontent">
<p>A handle to the CtrMcastComp object is returned when the protocol is specified as 'CtrMcast' in mrtproto.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>$ctrmcastcomp switch-treetype </strong><em>group-addr</em><strong></strong>
  </dt>
  <dd>
    <p>Switch from the Rendezvous Point rooted shared tree to source-specific trees for the group specified by <em>group-addr.</em> Note that this method cannot be used to switch from source-specific trees back to a shared tree for a multicast group.</p>
  </dd>
  <dt>
    <strong>$ctrmcastcomp set_c_rp </strong><em>node-list</em><strong></strong>
  </dt>
  <dd>
    <p>Make all the nodes specified in <em>node-list</em> as candidate RPs and change the state of all the other nodes to not be candidate RPs. Note that all nodes are candidate RPs by default. Currently the node with the highest node id serves as the RP for all multicast groups. This method should be invoked before any source starts sending packets to the group or any receiver joins the group.</p>
  </dd>
  <dt>
    <strong>$ctrmcastcomp get_rp </strong><em>node group</em><strong></strong>
  </dt>
  <dd>
    <p>Returns the RP for the group as seen by the node <em>node</em> for the multicast group with address <em>group-addr.</em> Note that different nodes may see different RPs for the group if the network is partitioned as the nodes might be in different partitions.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DM OBJECTS</h2>
        <div class="sectioncontent">
<p>DM Objects implement DVMRP style densemode multicast where parent-child lists are used to reduce the number of links over which initial data packets are broadcast. There are no methods or state variables specific to this object.</p><p>Configuration parameters </p>
<dl class='dl-vertical'>
  <dt>
    <em>PruneTimeout</em>
  </dt>
  <dd>
    
  </dd>

</dl>
<p>Timeout value for the prune state at nodes.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PRUNE/IFACE/TIMER OBJECTS</h2>
        <div class="sectioncontent">
<p>The Prune/Iface/Timer objects are used to implement the prune timer for detailedDM. There are no methods or state variables specific to this object.</p><p>Configuration parameters </p>
<dl class='dl-vertical'>
  <dt>
    <em>timeout</em>
  </dt>
  <dd>
    
  </dd>

</dl>
<p>Timeout value for the prune state at nodes.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DELETION/IFACE/TIMER OBJECTS</h2>
        <div class="sectioncontent">
<p>The Deletion/Iface/Timer objects are used to implement the interface deletion timer that are required for correct functioning at nodes that are part of LANs. If a node has a LAN as its incoming interface for packets from a certain source and it does not have any downstream members it sends out a prune message onto the LAN. Any node that has the LAN as its incoming interface for the same source and has downstream members on hearing the prune message sent on the LAN. will send a join message onto the LAN. When the node that is acting as the forwarder for the LAN hears the prune message from the LAN, it does not immediately prune off the LAN as its outgoing interface. Instead it starts an interface deletion timer for the outgoing interface. The forwarder will remove the LAN as its outgoing interface only if it does not receive any join messages from the LAN before its deletion timer expires. There are no methods or state variables specific to this object.</p><p>Configuration parameters </p>
<dl class='dl-vertical'>
  <dt>
    <em>timeout</em>
  </dt>
  <dd>
    
  </dd>

</dl>
<p>Timeout value for the interface deletion timer.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">GRAFTRTX/TIMER OBJECTS</h2>
        <div class="sectioncontent">
<p>The GraftRtx/Timer objects are used to implement the graft retransmission timer at nodes. This is to ensure the reliability of grafts sent upstream by a node.</p><p>Configuration parameters </p>
<dl class='dl-vertical'>
  <dt>
    <em>timeout</em>
  </dt>
  <dd>
    
  </dd>

</dl>
<p>Timeout value for the graft retransmission timer.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AGENT OBJECTS</h2>
        <div class="sectioncontent">
<p>[NOTE: This section has not been verified to be up-to-date with the release.]</p>
<dl class='dl-vertical'>
  <dt>
    <strong>$agent port</strong>
  </dt>
  <dd>
    <p>Return the transport-level port of the agent. Ports are used to identify agents within a node.</p>
  </dd>
  <dt>
    <strong>$agent dst-addr</strong>
  </dt>
  <dd>
    <p>Return the address of the destination node this agent is connected to.</p>
  </dd>
  <dt>
    <strong>$agent dst-port</strong>
  </dt>
  <dd>
    <p>Return the port at the destination node that this agent is connected to.</p>
  </dd>
  <dt>
    <strong>$agent attach-source </strong><em>type</em><strong></strong>
  </dt>
  <dd>
    <p>Install a data source of type <em>type</em> in this agent. <em>type</em> is one of FTP or bursty[???]. See the corresponding object methods for information on configuration parameters. Returns a handle to the source object.</p>
  </dd>
  <dt>
    <strong>$agent attach-traffic </strong><em>traffic-object</em><strong></strong>
  </dt>
  <dd>
    <p>Attach <em>traffic-object</em> to this agent <em>traffic-object</em> is an instance of Traffic/Expoo, Traffic/Pareto or Traffic/Trace. Traffic/Expoo generates traffic based on an Exponential On/Off distribution. Traffic/Pareto generates traffic based on a Pareto On/Off distribution. Traffic/Trace generates traffic from a trace file. The relevant configuration parameters for each of the above objects can be found in the TRAFFIC METHODS section.</p>
  </dd>
  <dt>
    <strong>$agent connect</strong><em> addr port</em><strong></strong>
  </dt>
  <dd>
    <p>Connect this agent to the agent identified by the address <em>addr</em> and port <em>port.</em> This causes packets transmitted from this agent to contain the address and port indicated, so that such packets are routed to the intended agent.  The two agents must be compatible (e.g., a tcp-source/tcp-sink pair as opposed a cbr/tcp-sink pair). Otherwise, the results of the simulation are unpredictable.</p>
  </dd>

</dl>
<p>Configuration Parameters </p>
<dl class='dl-vertical'>
  <dt>
    <em>dst_</em>
  </dt>
  <dd>
    <p>Address of destination that the agent is connected to. Currently 32 bits with the higher 24 bits the destination node ID and the lower 8 bits being the port number.</p>
  </dd>

</dl>
<p>There are no state variables specific to the generic agent class.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NULL OBJECTS</h2>
        <div class="sectioncontent">
<p>[NOTE: This section has not been verified to be up-to-date with the release.] Null objects are a subclass of agent objects that implement a traffic sink. They inherit all of the generic agent object functionality. There are no methods, configuration parameters or state variables specific to this object.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LOSSMONITOR OBJECTS</h2>
        <div class="sectioncontent">
<p>[NOTE: This section has not been verified to be up-to-date with the release.] LossMonitor objects are a subclass of agent objects that implement a traffic sink which also maintains some statistics about the received data e.g., number of bytes received, number of packets lost etc. They inherit all of the generic agent object functionality.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>$lossmonitor clear</strong>
  </dt>
  <dd>
    <p>Resets the expected sequence number to -1.</p>
  </dd>

</dl>
<p>Configuration Parameters </p><p>There are no configuration parameters specific to this object.</p><p>State Variables </p>
<dl class='dl-vertical'>
  <dt>
    <em>nlost_</em>
  </dt>
  <dd>
    <p>Number of packets lost.</p>
  </dd>
  <dt>
    <em>npkts_</em>
  </dt>
  <dd>
    <p>Number of packets received.</p>
  </dd>
  <dt>
    <em>bytes_</em>
  </dt>
  <dd>
    <p>Number of bytes received.</p>
  </dd>
  <dt>
    <em>lastPktTime_</em>
  </dt>
  <dd>
    <p>Time at which the last packet was received.</p>
  </dd>
  <dt>
    <em>expected_</em>
  </dt>
  <dd>
    <p>The expected sequence number of the next packet.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TCP OBJECTS</h2>
        <div class="sectioncontent">
<p>TCP objects are a subclass of agent objects that implement the BSD Tahoe TCP transport protocol as described in [7].  They inherit all of the generic agent functionality.</p><p>To trace TCP parameters, mark each parameter with ``$tcp trace window_'' and then send the output to a trace file with ``$tcp attach [open trace.tr w]''.</p><p>Tcp segments can be sent with the advance and advanaceby commands. When all data is sent, the done method will be invoked (which can be overridden in OTcl).</p>
<dl class='dl-vertical'>
  <dt>
    <strong>$tcp advance n</strong>
  </dt>
  <dd>
    <p>Send up to the nth packets.</p>
  </dd>
  <dt>
    <strong>$tcp advanceby n</strong>
  </dt>
  <dd>
    <p>Send n more packets.</p>
  </dd>
  <dt>
    <strong>$tcp done</strong>
  </dt>
  <dd>
    <p>Functional called when all packets (specified by advance/advanceby/maxpkts_) have been sent.  Can be overriden on a per-object basis. Configuration Parameters </p>
<dl class='dl-vertical'>
  <dt>
    <em>window_</em>
  </dt>
  <dd>
    <p>The upper bound on the advertised window for the TCP connection (in packets).</p>
  </dd>
  <dt>
    <em>maxcwnd_</em>
  </dt>
  <dd>
    <p>The upper bound on the congestion window for the TCP connection. Set to zero to ignore.  (This is the default.) Measured in packets.</p>
  </dd>
  <dt>
    <em>windowInit_</em>
  </dt>
  <dd>
    <p>The initial size of the congestion window on slow-start. (in packets).</p>
  </dd>
  <dt>
    <em>wnd_init_option_</em>
  </dt>
  <dd>
    <p>The algorithm used for determining the initial size of the congestion window.  Set to 1 for a static algorithm using the value in <em>windowInit_</em>.  Set to 2 for a dynamic algorithm using a function of <em>packetSize_</em>.</p>
  </dd>
  <dt>
    <em>syn_</em>
  </dt>
  <dd>
    <p>Set to true to model the initial SYN/ACK exchange in one-way TCP. Set to false as default.</p>
  </dd>
  <dt>
    <em>delay_growth_</em>
  </dt>
  <dd>
    <p>Set to true to delay the initial congestion window until after one packet has been sent and acked. Set to false as default.</p>
  </dd>
  <dt>
    <em>windowOption_</em>
  </dt>
  <dd>
    <p>The algorithm to use for managing the congestion window in linear phase. The standard algorithm is 1 (the default). Other experimental algorithms are documented in the source code.</p>
  </dd>
  <dt>
    <em>windowThresh_</em>
  </dt>
  <dd>
    <p>Gain constant to exponential averaging filter used to compute <em>awnd</em> (see below). For investigations of different window-increase algorithms.</p>
  </dd>
  <dt>
    <em>overhead_</em>
  </dt>
  <dd>
    <p>The range (in seconds) of a uniform random variable used to delay each output packet.  The idea is to insert random delays at the source in order to avoid phase effects, when desired [4]. This has only been implemented for the Tahoe ("tcp") version of tcp, not for tcp-reno.  This is not intended to be a realistic model of CPU processing overhead.</p>
  </dd>
  <dt>
    <em>ecn_</em>
  </dt>
  <dd>
    <p>Set to true to use explicit congestion notification in addition to packet drops to signal congestion. This allows a Fast Retransmit after a quench() due to an ECN (explicit congestion notification) bit.</p>
  </dd>
  <dt>
    <em>packetSize_</em>
  </dt>
  <dd>
    <p>The size in bytes to use for all packets from this source.</p>
  </dd>
  <dt>
    <em>tcpip_base_hdr_size_</em>
  </dt>
  <dd>
    <p>The size in bytes of the base TCP/IP header.</p>
  </dd>
  <dt>
    <em>tcpTick_</em>
  </dt>
  <dd>
    <p>The TCP clock granularity for measuring roundtrip times.  Note that it is set by default to the non-standard value of 100ms. Measured in seconds.</p>
  </dd>
  <dt>
    <em>bugFix_</em>
  </dt>
  <dd>
    <p>Set to true to remove a bug when multiple fast retransmits are allowed for packets dropped in a single window of data.</p>
  </dd>
  <dt>
    <em>maxburst_</em>
  </dt>
  <dd>
    <p>Set to zero to ignore.  Otherwise, the maximum number of packets that the source can send in response to a single incoming ACK.</p>
  </dd>
  <dt>
    <em>slow_start_restart_</em>
  </dt>
  <dd>
    <p>Boolean; set to 1 to slow-start after the connection goes idle. On by default.</p>
  </dd>
  <dt>
    <em>srtt_init_</em>
  </dt>
  <dd>
    <p>Initial value for the smoothed roundtrip time estimate. Default is 0 seconds.</p>
  </dd>
  <dt>
    <em>t_rttvar_</em>
  </dt>
  <dd>
    <p>Initial value for the variance in roundtrip time. Default is 3 seconds.</p>
  </dd>
  <dt>
    <em>rtxcur_init_</em>
  </dt>
  <dd>
    <p>Initial value for the retransmit value. Default is 6 seconds.</p>
  </dd>
  <dt>
    <em>T_SRTT_BITS</em>
  </dt>
  <dd>
    <p>Exponent of weight for updating the smoothed round-trip time t_srtt_. Default is 3, for a weight of 1/2^T_SRTT_BITS or 1/8.</p>
  </dd>
  <dt>
    <em>T_RTTVAR_BITS</em>
  </dt>
  <dd>
    <p>Exponent of weight for updating variance in round-trip time, t_rttvar_. Default is 2, for a weight of 1/2^T_RTTVAR_BITS or 1/4.</p>
  </dd>
  <dt>
    <em>rttvar_exp_</em>
  </dt>
  <dd>
    <p>Exponent of multiple of the mean deviation in calculating the current retransmit value t_rtxcur_. Default is 2, for a multiple of 2^rttvar_exp_ or 4.</p>
  </dd>

</dl>

  </dd>

</dl>
<p>Defined Constants</p>
<dl class='dl-vertical'>
  <dt>
    <em>MWS</em>
  </dt>
  <dd>
    <p>The Maximum Window Size in packets for a TCP connection.  MWS determines the size of an array in tcp-sink.cc. The default for MWS is 1024 packets. For Tahoe TCP, the "window" parameter, representing the receiver's advertised window, should be less than MWS-1.  For Reno TCP, the "window" parameter should be less than (MWS-1)/2.</p>
  </dd>

</dl>
<p>State Variables</p>
<dl class='dl-vertical'>
  <dt>
    <em>dupacks_</em>
  </dt>
  <dd>
    <p>Number of duplicate acks seen since any new data was acknowledged.</p>
  </dd>
  <dt>
    <em>seqno_</em>
  </dt>
  <dd>
    <p>Highest sequence number for data from data source to TCP.</p>
  </dd>
  <dt>
    <em>t_seqno_</em>
  </dt>
  <dd>
    <p>Current transmit sequence number.</p>
  </dd>
  <dt>
    <em>ack_</em>
  </dt>
  <dd>
    <p>Highest acknowledgment seen from receiver.</p>
  </dd>
  <dt>
    <em>cwnd_</em>
  </dt>
  <dd>
    <p>Current value of the congestion window (in packets).</p>
  </dd>
  <dt>
    <em>awnd_</em>
  </dt>
  <dd>
    <p>Current value of a low-pass filtered version of the congestion window. For investigations of different window-increase algorithms.</p>
  </dd>
  <dt>
    <em>ssthresh_</em>
  </dt>
  <dd>
    <p>Current value of the slow-start threshold (in packets).</p>
  </dd>
  <dt>
    <em>rtt_</em>
  </dt>
  <dd>
    <p>Round-trip time estimate. In seconds (expressed in multiples of tcpTick_).</p>
  </dd>
  <dt>
    <em>srtt_</em>
  </dt>
  <dd>
    <p>Smoothed round-trip time estimate. In seconds (in multiples of tcpTick_/8).</p>
  </dd>
  <dt>
    <em>rttvar_</em>
  </dt>
  <dd>
    <p>Round-trip time mean deviation estimate.</p>
  </dd>
  <dt>
    <em>t_rtxcur_</em>
  </dt>
  <dd>
    <p>Current retransmit value. In seconds.</p>
  </dd>
  <dt>
    <em>backoff_</em>
  </dt>
  <dd>
    <p>Round-trip time exponential backoff constant.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TCP/RENO OBJECTS</h2>
        <div class="sectioncontent">
<p>TCP/Reno objects are a subclass of TCP objects that implement the Reno TCP transport protocol as described in [7]. There are no methods, configuration parameters or state variables specific to this object.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TCP/NEWRENO OBJECTS</h2>
        <div class="sectioncontent">
<p>TCP/Newreno objects are a subclass of TCP objects that implement a modified version of the BSD Reno TCP transport protocol.</p><p>There are no methods or state variables specific to this object.</p><p>Configuration Parameters </p>
<dl class='dl-vertical'>
  <dt>
    <em>newreno_changes_</em>
  </dt>
  <dd>
    <p>Set to zero for the default NewReno described in [7].  Set to 1 for additional NewReno algorithms as suggested in [10]; this includes the estimation of the ssthresh parameter during slow-start.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TCP/VEGAS OBJECTS</h2>
        <div class="sectioncontent">
<p>This section of the man page has not yet been written.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TCP/SACK1 OBJECTS</h2>
        <div class="sectioncontent">
<p>TCP/Sack1 objects are a subclass of TCP objects that implement the BSD Reno TCP transport protocol with Selective Acknowledgement Extensions as described in [7].</p><p>They inherit all of the TCP object functionality. There are no methods, configuration parameters or state variables specific to this object.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TCP/FACK OBJECTS</h2>
        <div class="sectioncontent">
<p>TCP/Fack objects are a subclass of TCP objects that implement the BSD Reno TCP transport protocol with Forward Acknowledgement congestion control.</p><p>They inherit all of the TCP object functionality. There are no methods or state variables specific to this object. Configuration Parameters </p>
<dl class='dl-vertical'>
  <dt>
    <em>ss-div4</em>
  </dt>
  <dd>
    <p>Overdamping algorithm. Divides ssthresh by 4 (instead of 2) if congestion is detected within 1/2 RTT of slow-start. (1=Enable, 0=Disable)</p>
  </dd>
  <dt>
    <em>rampdown</em>
  </dt>
  <dd>
    <p>Rampdown data smoothing algorithm. Slowly reduces congestion window rather than instantly halving it. (1=Enable, 0=Disable)</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TCP/FULLTCP OBJECTS</h2>
        <div class="sectioncontent">
<p>This section has not yet been added to the man page. The implementation and the configuration parameters are described in [11].</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TCPSINK OBJECTS</h2>
        <div class="sectioncontent">
<p>TCPSink objects are a subclass of agent objects that implement a receiver for TCP packets. The simulator only implements "one-way" TCP connections, where the TCP source sends data packets and the TCP sink sends ACK packets. TCPSink objects inherit all of the generic agent functionality. There are no methods or state variables specific to the TCPSink object. Configuration Parameters </p>
<dl class='dl-vertical'>
  <dt>
    <em>packetSize_</em>
  </dt>
  <dd>
    <p>The size in bytes to use for all acknowledgment packets.</p>
  </dd>
  <dt>
    <em>maxSackBlocks_</em>
  </dt>
  <dd>
    <p>The maximum number of blocks of data that can be acknowledged in a SACK option.  For a receiver that is also using the time stamp option [RFC 1323], the SACK option specified in RFC 2018 has room to include three SACK blocks. This is only used by the TCPSink/Sack1 subclass. This value may not be increased within any particular TCPSink object after that object has been allocated. (Once a TCPSink object has been allocated, the value of this parameter may be decreased but not increased).</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TCPSINK/DELACK OBJECTS</h2>
        <div class="sectioncontent">
<p>DelAck objects are a subclass of TCPSink that implement a delayed-ACK receiver for TCP packets. They inherit all of the TCPSink object functionality. There are no methods or state variables specific to the DelAck object. Configuration Parameters </p>
<dl class='dl-vertical'>
  <dt>
    <em>interval_</em>
  </dt>
  <dd>
    <p>The amount of time to delay before generating an acknowledgment for a single packet.  If another packet arrives before this time expires, generate an acknowledgment immediately.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TCPSINK/SACK1 OBJECTS</h2>
        <div class="sectioncontent">
<p>TCPSink/Sack1 objects are a subclass of TCPSink that implement a SACK receiver for TCP packets. They inherit all of the TCPSink object functionality. There are no methods, configuration parameters or state variables specific to this object.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TCPSINK/SACK1/DELACK OBJECTS</h2>
        <div class="sectioncontent">
<p>TCPSink/Sack1/DelAck objects are a subclass of TCPSink/Sack1 that implement a delayed-SACK receiver for TCP packets. They inherit all of the TCPSink/Sack1 object functionality. There are no methods or state variables specific to this object. Configuration Parameters </p>
<dl class='dl-vertical'>
  <dt>
    <em>interval_</em>
  </dt>
  <dd>
    <p>The amount of time to delay before generating an acknowledgment for a single packet.  If another packet arrives before this time expires, generate an acknowledgment immediately.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SRM OBJECTS</h2>
        <div class="sectioncontent">
<p>SRM objects are a subclass of agent objects that implement the SRM reliable multicast transport protocol. They inherit all of the generic agent functionalities.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>$srm traffic-source </strong><em>source</em><strong></strong>
  </dt>
  <dd>
    <p>Attach a traffic source, e.g., Application/Traffic/CBR, to the SRM agent.</p>
  </dd>
  <dt>
    <strong>$srm start</strong>
  </dt>
  <dd>
    <p>Join the multicast group, start the SRM agent and its attached traffic source.</p>
  </dd>
  <dt>
    <strong>$srm delete</strong>
  </dt>
  <dd>
    <p>Stop the SRM agent, delete all its status and detach the traffic source.</p>
  </dd>
  <dt>
    <strong>$srm trace </strong><em>trace-file </em><strong></strong>
  </dt>
  <dd>
    <p>Write the traces generated by the SRM agent to <em>trace-file</em>. The traces includes timer settings, request and repair sending and receipts, etc. Two related files that are not built into ns are <em>tcl/mcast/srm-debug.tcl</em> that permits more detailed tracing of the delay computation functions, and <em>tcl/mcast/srm-nam.tcl</em> that separately marks srm control messages from data. The latter is useful to enhance nam visualisation.</p>
  </dd>
  <dt>
    <strong>$srm log </strong><em>log-file </em><strong></strong>
  </dt>
  <dd>
    <p>Write the recovery statistics during each request or repair to <em>log-file</em>. The statistics include start time, duration, message id, total number of duplicate requests and repairs.</p>
  </dd>
  <dt>
    <strong>$srm distance? </strong><em>node </em><strong></strong>
  </dt>
  <dd>
    <p>Return the distance estimate to <em>node</em> in this SRM agent.</p>
  </dd>
  <dt>
    <strong>$srm distances? </strong><em>node </em><strong></strong>
  </dt>
  <dd>
    <p>Returns a list of &lt;group member,  distance&gt; tuples of the distances to all group members that this node is aware of.  The group member is identified as the address of the remote agent. The first tuple is this agent's token. The list can be directly loaded into a Tcl array.</p>
  </dd>

</dl>
<p>Configuration Parameters </p>
<dl class='dl-vertical'>
  <dt>
    <em>packetSize_</em>
  </dt>
  <dd>
    <p>The data packet size in bytes that will be used for repair messages. The default value is 1024.</p>
  </dd>
  <dt>
    <em>requestFunction_</em>
  </dt>
  <dd>
    <p>The algorithm used to produce a retransmission request, e.g., setting request timers. The default value is SRM/request. Other possible request functions are SRM/request/Adaptive, used by the Adaptive SRM code.</p>
  </dd>
  <dt>
    <em>repairFunction_</em>
  </dt>
  <dd>
    <p>The algorithm used to produce a repair, e.g., compute repair timers. The default value is SRM/repair. Other possible request functions are SRM/repair/Adaptive, used by the Adaptive SRM code.</p>
  </dd>
  <dt>
    <em>sessionFunction_</em>
  </dt>
  <dd>
    <p>The algorithm used to generate session messages. Default is SRM/session</p>
  </dd>
  <dt>
    <em>sessionDelay_</em>
  </dt>
  <dd>
    <p>The basic interval of session messages. Slight random variation is added to this interval to avoid global synchronization of session messages. User may want to adjust this variable according to their specific simulation. Measured in seconds; default value is 1.0 seconds.</p>
  </dd>
  <dt>
    <em>C1_, C2_</em>
  </dt>
  <dd>
    <p>The parameters which control the request timer. Refer to [8] for detail. The default value is <em>C1_</em> = <em>C2_</em> = 2.0.</p>
  </dd>
  <dt>
    <em>D1_, D2_</em>
  </dt>
  <dd>
    <p>The parameters which control the repair timer. Refer to [8] for detail. The default value is <em>D1_</em> = <em>D2_</em> = 1.0.</p>
  </dd>
  <dt>
    <em>requestBackoffLimit_</em>
  </dt>
  <dd>
    <p>The maximum number of exponential backoffs. Default value is 5.</p>
  </dd>

</dl>
<p>State Variables</p>
<dl class='dl-vertical'>
  <dt>
    <em>stats_</em>
  </dt>
  <dd>
    <p>An array containing multiple statistics needed by adaptive SRM agent. Including: duplicate requests and repairs in current request/repair period, average number of duplicate requests and repairs, request and repair delay in current request/repair period, average request and repair delay.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SRM/Adaptive OBJECTS</h2>
        <div class="sectioncontent">
<p>SRM/Adaptive objects are a subclass of the SRM objects that implement the adaptive SRM reliable multicast transport protocol. They inherit all of the SRM object functionalities.</p><p>State Variables Refer to the SRM paper by Sally et al ([11]) for more detail.</p>
<dl class='dl-vertical'>
  <dt>
    <em>pdistance_</em>
  </dt>
  <dd>
    <p>This variable is used to pass the distance estimate provided by the remote agent in a request or repair message.</p>
  </dd>
  <dt>
    <em>D1_, D2_</em>
  </dt>
  <dd>
    <p>The same as that in SRM agents, except that they are initialized to log10(group size) when generating the first repair.</p>
  </dd>
  <dt>
    <em>MinC1_, MaxC1_, MinC2_, MaxC2_</em>
  </dt>
  <dd>
    <p>The minimum/maximum values of C1_ and C2_. Default initial values are defined in [8]. These values define the dynamic range of <em>C1_</em> and <em>C2_</em>.</p>
  </dd>
  <dt>
    <em>MinD1_, MaxD1_, MinD2_, MaxD2_</em>
  </dt>
  <dd>
    <p>The minimum/maximum values of D1_ and D2_. Default initial values are defined in [8]. These values define the dynamic range of <em>D1_</em> and <em>D2_</em>.</p>
  </dd>
  <dt>
    <em>AveDups</em>
  </dt>
  <dd>
    <p>Higher bound for average duplicates.</p>
  </dd>
  <dt>
    <em>AveDelay</em>
  </dt>
  <dd>
    <p>Higher bound for average delay.</p>
  </dd>
  <dt>
    <em>eps</em>
  </dt>
  <dd>
    <p><em>AveDups</em> - <em>dups</em> determines the lower bound of the number of duplicates, when we should adjust parameters to decrease delay.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">APPLICATION OBJECTS</h2>
        <div class="sectioncontent">
<p>Application objects generate data for transport agents to send.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FTP APPLICATION OBJECTS</h2>
        <div class="sectioncontent">
<p>Application/FTP objects  produce bulk data for a TCP object to send.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>$ftp start</strong>
  </dt>
  <dd>
    <p>Causes FTP to produce packets indefinitely.</p>
  </dd>
  <dt>
    <strong>$ftp produce </strong><em>n</em><strong></strong>
  </dt>
  <dd>
    <p>Causes the FTP object to produce <em>n</em> packets instantaneously.</p>
  </dd>
  <dt>
    <strong>$ftp stop</strong>
  </dt>
  <dd>
    <p>Causes the attached TCP object to stop sending data.</p>
  </dd>
  <dt>
    <strong>$ftp attach </strong><em>agent</em><strong></strong>
  </dt>
  <dd>
    <p>Attaches an Application/FTP object to <em>agent</em>.</p>
  </dd>
  <dt>
    <strong>$ftp producemore </strong><em>count</em><strong></strong>
  </dt>
  <dd>
    <p>Causes the Application/FTP object to produce <em>count</em> more packets.</p>
  </dd>

</dl>
<p>Configuration Parameters </p>
<dl class='dl-vertical'>
  <dt>
    <em>maxpkts</em>
  </dt>
  <dd>
    <p>The maximum number of packets generated.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TELNET APPLICATION OBJECTS</h2>
        <div class="sectioncontent">
<p>Application/Telnet objects produce individual packets with inter-arrival times as follows.  If <em>interval_</em> is non-zero, then inter-arrival times are chosen from an exponential distribution with average <em>interval_</em>.  If <em>interval_</em> is zero, then inter-arrival times are chosen using the "tcplib" telnet distribution.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>$telnet start</strong>
  </dt>
  <dd>
    <p>Causes the Application/Telnet object to start producing packets.</p>
  </dd>
  <dt>
    <strong>$telnet stop</strong>
  </dt>
  <dd>
    <p>Causes the Application/Telnet object to stop producing packets.</p>
  </dd>
  <dt>
    <strong>$telnet attach </strong><em>agent</em><strong></strong>
  </dt>
  <dd>
    <p>Attaches a Application/Telnet object to <em>agent</em>.</p>
  </dd>

</dl>
<p>Configuration Parameters </p>
<dl class='dl-vertical'>
  <dt>
    <em>interval_</em>
  </dt>
  <dd>
    <p>The average inter-arrival time in seconds for packets generated by the Application/Telnet object.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TRAFFIC OBJECTS</h2>
        <div class="sectioncontent">
<p>Traffic objects create data for a transport protocol to send. A Traffic object is created by instantiating an object of class Application/Traffic/<em>type</em> where <em>type</em> is one of Exponential, Pareto, CBR, Trace.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPONENTIAL TRAFFIC OBJECTS</h2>
        <div class="sectioncontent">
<p>Application/Traffic/Exponential objects generate On/Off traffic.  During "on" periods, packets are generated at a constant burst rate.  During "off" periods, no traffic is generated. Burst times and idle times are taken from exponential distributions. Configuration Parameters </p>
<dl class='dl-vertical'>
  <dt>
    <em>packet_size_</em>
  </dt>
  <dd>
    <p>The packet size in bytes.</p>
  </dd>
  <dt>
    <em>burst_time_</em>
  </dt>
  <dd>
    <p>Burst duration in seconds.</p>
  </dd>
  <dt>
    <em>idle_time_</em>
  </dt>
  <dd>
    <p>Idle time in seconds.</p>
  </dd>
  <dt>
    <em>rate_</em>
  </dt>
  <dd>
    <p>Peak rate in bits per second.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PARETO TRAFFIC OBJECTS</h2>
        <div class="sectioncontent">
<p>Application/Traffic/Pareto objects generate On/Off traffic with burst times and idle times taken from pareto distributions. Configuration Parameters </p>
<dl class='dl-vertical'>
  <dt>
    <em>packet_size_</em>
  </dt>
  <dd>
    <p>The packet size in bytes.</p>
  </dd>
  <dt>
    <em>burst_time_</em>
  </dt>
  <dd>
    <p>Average on time in seconds.</p>
  </dd>
  <dt>
    <em>idle_time_</em>
  </dt>
  <dd>
    <p>Average off time in seconds.</p>
  </dd>
  <dt>
    <em>rate_</em>
  </dt>
  <dd>
    <p>Peak rate in bits per second.</p>
  </dd>
  <dt>
    <em>shape_</em>
  </dt>
  <dd>
    <p>Pareto shape parameter.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CBR (CONSTANT BIT RATE) TRAFFIC OBJECTS</h2>
        <div class="sectioncontent">
<p>Application/Traffic/CBR objects generate packets at a constant rate. Dither can be added to the interarrival times by enabling the "random" flag. Configuration Parameters </p>
<dl class='dl-vertical'>
  <dt>
    <em>rate_</em>
  </dt>
  <dd>
    <p>Peak rate in bits per second.</p>
  </dd>
  <dt>
    <em>packet_size_</em>
  </dt>
  <dd>
    <p>The packet size in bytes.</p>
  </dd>
  <dt>
    <em>random_</em>
  </dt>
  <dd>
    <p>Flag that turns dithering on and off (default is off).</p>
  </dd>
  <dt>
    <em>maxpkts_</em>
  </dt>
  <dd>
    <p>Maximum number of packets to send.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TRACE TRAFFIC OBJECTS</h2>
        <div class="sectioncontent">
<p>Application/Traffic/Trace objects are used to generate traffic from a trace file.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>$trace attach-tracefile </strong><em>tfile</em><strong></strong>
  </dt>
  <dd>
    <p>Attach the Tracefile object <em>tfile</em> to this trace. The Tracefile object specifies the trace file from which the traffic data is to be read (see TRACEFILE OBJECTS section).  Multiple Application/Traffic/Trace objects can be attached to the same Tracefile object.  A random starting place within the Tracefile is chosen for each Application/Traffic/Trace object.</p>
  </dd>

</dl>
<p>There are no configuration parameters for this object.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TRACEFILE OBJECTS</h2>
        <div class="sectioncontent">
<p>Tracefile objects are used to specify the trace file that is to be used for generating traffic (see TRAFFIC/TRACE OBJECTS section). $tracefile is an instance of the Tracefile Object.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>$tracefile filename </strong><em>trace-input</em><strong></strong>
  </dt>
  <dd>
    <p>Set the filename from which the traffic trace data is to be read to <em>trace-input.</em></p>
  </dd>

</dl>
<p>There are no configuration parameters for this object.  A trace file consists of any number of fixed length records.  Each record consists of 2 32 bit fields.  The first indicates the interval until the next packet is generated in microseconds.  The second indicates the length of the next packet in bytes.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TRACE AND MONITORING METHODS</h2>
        <div class="sectioncontent">
<p>[NOTE: This section has not been verified to be up-to-date with the release.] Trace objects are used to generate event level capture logs typically to an output file. Throughout this section $ns refers to a Simulator object, $agent refers to an Agent object.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>$ns create-trace </strong><em>type fileID node1 node2 [option]</em><strong></strong>
  </dt>
  <dd>
    <p>Create a Trace object of type <em>type</em> and attach the filehandle <em>fileID</em> to it to monitor the queues between nodes <em>node1</em> and <em>node2.</em> <em>type</em> can be one of Enque, Deque, Drop. Enque monitors packet arrival at a queue. Deque monitors packet departure at a queue. Drop monitors packet drops at a queue. <em>fileID</em> must be a file handle returned by the Tcl <em>open</em> command and it must have been opened for writing. If <em>option</em> is not specified, the command will instruct the created trace object to generate ns traces. If <em>option</em> is """nam""" the new object will produce nam traces. Returns a handle to the trace object.</p>
  </dd>
  <dt>
    <strong>$ns drop-trace </strong><em>node1 node2 trace</em><strong></strong>
  </dt>
  <dd>
    <p>Remove trace object attached to the link between nodes <em>node1</em> and <em>node2</em> with <em>trace</em> as the object handle.</p>
  </dd>
  <dt>
    <strong>$ns trace-queue </strong><em>node1 node2 fileID</em><strong></strong>
  </dt>
  <dd>
    <p>Enable Enque, Deque and Drop tracing on the link between <em>node1</em> and <em>node2.</em></p>
  </dd>
  <dt>
    <strong>$ns namtrace-queue </strong><em>node1 node2 fileID</em><strong></strong>
  </dt>
  <dd>
    <p>Same function as <strong>$ns trace-queue</strong>, except it produces nam traces.</p>
  </dd>
  <dt>
    <strong>$ns trace-all </strong><em>fileID</em><strong></strong>
  </dt>
  <dd>
    <p>Enable Enque, Deque, Drop Tracing on all the links in the topology created after this method is invoked. Also enables the tracing of network dynamics. <em>fileID</em> must be a file handle returned by the Tcl <em>open</em> command and it must have been opened for writing.</p>
  </dd>
  <dt>
    <strong>$ns namtrace-all </strong><em>fileID</em><strong></strong>
  </dt>
  <dd>
    <p>Same function as <strong>$ns trace-all</strong>, except it will produce all equivalent traces in nam format. In addition, calling this command <em>before</em> the simulator starts to run will generate color configurations (if any) and topology information needed by nam (nodes, links, queues). An example can be found at ns-2/tcl/ex/nam-example.tcl.</p>
  </dd>
  <dt>
    <strong>$ns namtrace-config </strong><em>fileID</em><strong></strong>
  </dt>
  <dd>
    <p>Assign a file to store nam configuration information, e.g., node/link/agents and some Simulator-related traces such as annotations. When you don't want to trace every object. call this function and then use <em>$ns namtrace-queue</em>, <em>rtModel trace</em>, etc., to insert traces individually. Note that you should use the same file for individual traces and nam configuration. An example for this is available at ns-2/tcl/ex/nam-separate-trace.tcl.</p>
  </dd>
  <dt>
    <strong>$ns monitor-queue </strong><em>node1 node2</em><strong></strong>
  </dt>
  <dd>
    <p>Arrange for queue length of link between nodes <em>node1</em> and <em>node2</em> to be tracked. Returns QueueMonitor object that can be queried to learn average queue size etc. [see QueueMonitor Objects section]</p>
  </dd>
  <dt>
    <strong>$ns flush-trace</strong>
  </dt>
  <dd>
    <p>Flush the output channels attached to all the trace objects.</p>
  </dd>
  <dt>
    <strong>$link trace-dynamics </strong><em>ns fileID [option]</em><strong></strong>
  </dt>
  <dd>
    <p>Trace the dynamics of this link and write the output to <em>fileID</em> filehandle. <em>ns</em> is an instance of the Simulator or MultiSim object that was created to invoke the simulation.</p>
  </dd>
  <dt>
    <strong>$ns color </strong><em>id name</em><strong></strong>
  </dt>
  <dd>
    <p>Create a color index, which links the number <em>id</em> to the color name <em>name</em>. All colors created <em>before</em> the simulator starts to run will be written to nam trace file, if there is any.</p>
  </dd>
  <dt>
    <strong>$ns trace-annotate </strong><em>string</em><strong></strong>
  </dt>
  <dd>
    <p>Writes an annotation to ns and nam trace file, if there are any. The string should be enclosed in double quote to make it a single argument.</p>
  </dd>
  <dt>
    <strong>trace_annotate </strong><em>string</em><strong></strong>
  </dt>
  <dd>
    <p>Another version of <strong>$ns trace-annotate</strong>, which is a global function and doesn't require the caller to know ns.</p>
  </dd>
  <dt>
    <strong>$ns duplex-link-op $node1 $node2 $op $args</strong>
  </dt>
  <dd>
    <p>Perform a given operation <em>$op</em> on the given duplex link (<em>$node1</em>, <em>$node2</em>). The following two operations may be used:</p>
<pre>
orient		- Specify the nam orientation of the duplex link. Values can be
		  left, right, up, down, their mixture combined by '-' (e.g.,
		  left-down), and a number specifying the angle between the
		  link and the horizontal line.
queuePos	- Construct a queue of the simplex link (<em>$node1</em>,
		  <em>$node2</em>) in nam, and specify the angle between the
		  horizontal line and the line along which the queued packets
		  will be displayed.
</pre>

  </dd>
  <dt>
    <strong>$ns add-agent-trace </strong><em>agent name [fileID]</em><strong></strong>
  </dt>
  <dd>
    <p>Write a nam trace line, which will create a trace agent for <em>agent</em> when interpreted by nam. The trace agent's name will be <em>name</em>. This nam trace agent is used to show the position of <em>agent</em> and can be used to write nam traces of variables associated with the agent. By default traces will be written to the file assigned by <em>namtrace-all</em>. <em>fileID</em> can be used to write traces to another file.</p>
  </dd>
  <dt>
    <strong>$agent tracevar </strong><em>name</em><strong></strong>
  </dt>
  <dd>
    <p>Label OTcl variable <em>name</em> of <strong>$agent</strong> to be traced. Then whenever the variable <em>name</em> changes value, a nam trace line will be written to nam trace file, if there is one. Note that <em>name</em> must be the same as the variable's real OTcl name.</p>
  </dd>
  <dt>
    <strong>$ns delete-agent-trace </strong><em>agent</em><strong></strong>
  </dt>
  <dd>
    <p>Write a nam trace line, which will delete the nam trace associated with <em>agent</em> when interpreted by nam.</p>
  </dd>
  <dt>
    <strong>$agent add-var-trace </strong><em>name value [type]</em><strong></strong>
  </dt>
  <dd>
    <p>Write a nam trace line, which creates a variable trace with name <em>name</em> and value <em>value</em>, when interpreted by nam. <em>type</em> indicates the type of the variable, e.g., is it a list, array, or a plain variable. Currently only plain variable is supported, for which <em>type</em> = 'v'.</p>
  </dd>

</dl>
<p>The following 2 functions should be called <em>after</em> the simulator starts running. This can be done using <strong>$ns at</strong>.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>$agent delete-var-trace </strong><em>name</em><strong></strong>
  </dt>
  <dd>
    <p>Write a nam trace line, which deletes the variable trace <em>name</em> when interpreted by nam.</p>
  </dd>
  <dt>
    <strong>$agent update-var-trace </strong><em>name value [type]</em><strong></strong>
  </dt>
  <dd>
    <p>Write a nam trace line, which changes the value of traced variable <em>name</em> when interpreted by nam. Unlike <strong>$agent tracevar</strong>, the above 3 functions provide 'manual' variable tracing, in which variable tracing are done by placing <strong>$agent update-var-trace</strong> in OTcl code, while <em>tracevar</em> automatically generates nam traces when the traced variable changes value.</p>
  </dd>

</dl>
<p>The tracefile format is backward compatible with the output files in the ns version 1 simulator so that ns-1 post-processing scripts can still be used. Trace records of traffic for link objects with Enque, Deque or Drop Tracing have the following form:</p>
<pre>
    &lt;code&gt; &lt;time&gt; &lt;hsrc&gt; &lt;hdst&gt; &lt;packet&gt;
</pre>
<p>where</p>
<pre>
&lt;code&gt; := [hd+-r] h=hop d=drop +=enque -=deque r=receive
&lt;time&gt; := simulation time in seconds
&lt;hsrc&gt; := first node address of hop/queuing link
&lt;hdst&gt; := second node address of hop/queuing link
&lt;packet&gt; :=  &lt;type&gt; &lt;size&gt; &lt;flags&gt; &lt;flowID&gt; &lt;src.sport&gt; &lt;dst.dport&gt; &lt;seq&gt; &lt;pktID&gt;
&lt;type&gt; := tcp|telnet|cbr|ack etc.
&lt;size&gt; := packet size in bytes
&lt;flags&gt; := [CP]  C=congestion, P=priority
&lt;flowID&gt; := flow identifier field as defined for IPv6
&lt;src.sport&gt; := transport address (src=node,sport=agent)
&lt;dst.sport&gt; := transport address (dst=node,dport=agent)
&lt;seq&gt; := packet sequence number
&lt;pktID&gt; := unique identifer for every new packet
</pre>
<p>Only those agents interested in providing sequencing will generate sequence numbers and hence this field may not be useful for packets generated by some agents.</p><p>For links that use RED gateways, there are additional trace records as follows:</p>
<pre>
    &lt;code&gt; &lt;time&gt; &lt;value&gt;
</pre>
<p>where</p>
<pre>
&lt;code&gt; := [Qap] Q=queue size, a=average queue size,
	p=packet dropping probability
&lt;time&gt; := simulation time in seconds
&lt;value&gt; := value
</pre>
<p>Trace records for link dynamics are of the form:</p>
<pre>
    &lt;code&gt; &lt;time&gt; &lt;state&gt; &lt;src&gt; &lt;dst&gt;
</pre>
<p>where</p>
<pre>
&lt;code&gt; := [v]
&lt;time&gt; := simulation time in seconds
&lt;state&gt; := [link-up | link-down]
&lt;src&gt; := first node address of link
&lt;dst&gt; := second node address of link
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INTEGRATOR Objects</h2>
        <div class="sectioncontent">
<p>Integrator Objects support the approximate computation of continuous integrals using discrete sums. The running sum(integral) is computed as: sum_ +=  [lasty_ * (x - lastx_)] where (x, y) is the last element entered and (lastx_, lasty_) was the element previous to that added to the sum. lastx_ and lasty_ are updated as new elements are added. The first sample point defaults to (0,0) that can be changed by changing the values of (lastx_,lasty_).</p>
<dl class='dl-vertical'>
  <dt>
    <strong>$integrator newpoint </strong><em>x y</em><strong></strong>
  </dt>
  <dd>
    <p>Add the point (x,y) to the sum. Note that it does not make sense for x to be less than lastx_.</p>
  </dd>

</dl>
<p>There are no configuration parameters specific to this object.</p><p>State Variables</p>
<dl class='dl-vertical'>
  <dt>
    <em>lastx_</em>
  </dt>
  <dd>
    <p>x-coordinate of the last sample point.</p>
  </dd>
  <dt>
    <em>lasty_</em>
  </dt>
  <dd>
    <p>y-coordinate of the last sample point.</p>
  </dd>
  <dt>
    <em>sum_</em>
  </dt>
  <dd>
    <p>Running sum (i.e. the integral) of the sample points.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SAMPLES Objects</h2>
        <div class="sectioncontent">
<p>Samples Objects support the computation of mean and variance statistics for a given sample.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>$samples mean</strong>
  </dt>
  <dd>
    <p>Returns mean of the sample.</p>
  </dd>
  <dt>
    <strong>$samples variance</strong>
  </dt>
  <dd>
    <p>Returns variance of the sample.</p>
  </dd>
  <dt>
    <strong>$samples cnt</strong>
  </dt>
  <dd>
    <p>Returns a count of the sample points considered.</p>
  </dd>
  <dt>
    <strong>$samples reset</strong>
  </dt>
  <dd>
    <p>Reset the Samples object to monitor a fresh set of samples.</p>
  </dd>

</dl>
<p>There are no configuration parameters or state variables specific to this object.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUILTINS</h2>
        <div class="sectioncontent">
<p>[NOTE: This section has not been verified to be up-to-date with the release.] Because <em>OTcl</em> is a full-fledged programming language, it is easy to build high-level simulation constructs from the ns primitives. Several library routines have been built in this way, and are embedded into the ns interpreter as methods of the Simulator class. Throughout this section $ns represents a Simulator object.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>$ns create-connection </strong><em>srcType srcNode dstType dstNode class</em><strong></strong>
  </dt>
  <dd>
    <p>Create a source agent of type <em>srcType</em> at node <em>srcNode</em> and connect it to a destination agent of type <em>dstType</em> at node <em>dstNode.</em> Also, connect the destination agent to the source agent. The traffic class of both agents is set to <em>class.</em> This method returns the source agent.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLE</h2>
        <div class="sectioncontent">

<pre>
    set ns [new Simulator]

    #
    # Create two nodes
    #
    set n0 [$ns node]
    set n1 [$ns node]

    #
    # Create a trace and arrange for all the trace events of the
    # links subsequently created to be dumped to "out.tr"
    #
    set f [open out.tr w]
    $ns trace-all $f

    #
    # Connect the two nodes with a 1.5Mb link with a transmission
    # delay of 10ms using FIFO drop-tail queuing
    #
    $ns duplex-link $n0 $n1 1.5Mb 10ms DropTail

    #
    # Set up BSD Tahoe TCP connections in opposite directions.
    #
    set tcp_src1 [new Agent/TCP]
    set tcp_snk1 [new Agent/TCPSink]
    set tcp_src2 [new Agent/TCP]
    set tcp_snk2 [new Agent/TCPSink]
    $ns attach-agent $n0 $tcp_src1
    $ns attach-agent $n1 $tcp_snk1
    $ns attach-agent $n1 $tcp_src2
    $ns attach-agent $n0 $tcp_snk2
    $ns connect $tcp_src1 $tcp_snk1
    $ns connect $tcp_src2 $tcp_snk2

    #
    # Create ftp sources at the each node
    #
    set ftp1 [$tcp_src1 attach-source FTP]
    set ftp2 [$tcp_src2 attach-source FTP]

    #
    # Start up the first ftp at the time 0 and
    # the second ftp staggered 1 second later
    #

    $ns at 0.0 "$ftp1 start"
    $ns at 1.0 "$ftp2 start"

    #
    # run the simulation for 10 simulated seconds
    #
    $ns at 10.0 "exit 0"
    $ns run
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DEBUGGING</h2>
        <div class="sectioncontent">
<p>To enable debugging when building ns from source:</p>
<pre>
    % ./configure --enable-debug
    % make
</pre>
<p>For more details about ns debugging please see &lt;http://www-mash.cs.berkeley.edu/ns/ns-debugging.html&gt;.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DIFFERENCES FROM NS-1</h2>
        <div class="sectioncontent">
<p>In general, more complex objects in ns-1 have been broken down into simpler components for greater flexibility and composability. Details of differences between ns-1 and ns-2 can be found at &lt;http://www-mash.cs.berkeley.edu/ns/ns.html&gt;.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">HISTORY</h2>
        <div class="sectioncontent">
<p>Work on the LBL Network Simulator began in May 1990 with modifications to S. Keshav's (keshav@research.att.com) REAL network simulator, which he developed for his Ph.D. work at U.C. Berkeley. In Summer 1991, the simulation description language was revamped, and later, the NEST threads model was replaced with an event driven framework and an efficient scheduler.  Among other contributions, Sugih Jamin (jamin@usc.edu) contributed the calendar-queue based scheduling code to this version of the program, which was known as <em>tcpsim.</em> In December 1994, McCanne ported tcpsim to C++ and replaced the yacc-based simulation description language with a Tcl interface, and added preliminary multicast support.  Also at this time, the name changed from <em>tcpsim</em> to the more generic <em>ns.</em> Throughout, Floyd has made modifications to the TCP code and added additional source models for her investigations into RED gateways, resource management, class-based queuing, explicit congestion notification, and traffic phase effects.  Many of the papers discussing these issues are available through URL http://www-nrg.ee.lbl.gov/.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO ns&hellip;</h2>
        <div class="sectioncontent">
<p><strong>Tcl</strong>(1), <strong>tclsh</strong>(1), <a href="../man1/nam.1.html"><strong>nam</strong>(1)</a>, otclsh</p>
<dl class='dl-vertical'>
  <dt>
    <strong>[1]</strong>
  </dt>
  <dd>
    <p>S. Keshav, ``REAL: A Network Simulator''.  UCB CS Tech Report 88/472, December 1988.  See http://minnie.cs.adfa.oz.au/REAL/index.html for more information.</p>
  </dd>
  <dt>
    <strong>[2]</strong>
  </dt>
  <dd>
    <p>Floyd, S. and Jacobson, V.  Random Early Detection gateways for Congestion Avoidance.  IEEE/ACM Transactions on Networking, Vol. 1, No. 4.  August 1993.  pp. 397-413.  Available from http://www-nrg.ee.lbl.gov/floyd/red.html.</p>
  </dd>
  <dt>
    <strong>[3]</strong>
  </dt>
  <dd>
    <p>Floyd, S.  Simulator Tests.  July 1995. URL ftp://ftp.ee.lbl.gov/papers/simtests.ps.Z.</p>
  </dd>
  <dt>
    <strong>[4]</strong>
  </dt>
  <dd>
    <p>Floyd, S., and Jacobson, V. On Traffic Phase Effects in Packet-Switched Gateways. Internetworking: Research and Experience, V.3 N.3, September 1992. pp. 115-156.</p>
  </dd>
  <dt>
    <strong>[5]</strong>
  </dt>
  <dd>
    <p>Floyd, S., and Jacobson, V. Link-sharing and Resource Management Models for Packet Networks. IEEE/ACM Transactions on Networking, Vol. 3 No. 4, August 1995. pp. 365-386.</p>
  </dd>
  <dt>
    <strong>[6]</strong>
  </dt>
  <dd>
    <p>Floyd, S., Notes of Class-Based Queueing: Setting Parameters. URL ftp://ftp.ee.lbl.gov/papers/ params.ps.Z.  September 1995.</p>
  </dd>
  <dt>
    <strong>[7]</strong>
  </dt>
  <dd>
    <p>Fall, K., and Floyd, S.  Comparisons of Tahoe, Reno, and Sack TCP. December 1995.  URL ftp:// ftp.ee.lbl.gov/papers/sacks.ps.Z.</p>
  </dd>
  <dt>
    <strong>[8]</strong>
  </dt>
  <dd>
    <p>David Wetherall and Christopher J. Linblad. Extending Tcl for Dynamic Object-Oriented Programming. In Proceedings of the USENIX Tcl/Tk Workshop, Toronto, Ontario, USENIX. July, 1995. At &lt;http://www.tns.lcs.mit.edu/publications/tcltk95.djw.html&gt;.</p>
  </dd>
  <dt>
    <strong>[9]</strong>
  </dt>
  <dd>
    <p>M. Shreedhar and G. Varghese. Efficient Fair Queueing Using Deficit Round Robin. In Proc. of SIGCOMM, pp. 231-242, 1995.</p>
  </dd>
  <dt>
    <strong>[10]</strong>
  </dt>
  <dd>
    <p>Hoe, J., Improving the Start-up Behavior of a Congestion Control Scheme for TCP. in SIGCOMM 96, August 1996, pp. 270-280. URL http://www.acm.org/sigcomm/sigcomm96/papers/hoe.html.</p>
  </dd>
  <dt>
    <strong>[11]</strong>
  </dt>
  <dd>
    <p>Fall, K., Floyd, S., and Henderson, T., Ns Simulator Tests for Reno FullTCP. URL ftp://ftp.ee.lbl.gov/papers/fulltcp.ps.  July 1997.</p>
  </dd>
  <dt>
    <strong>[12]</strong>
  </dt>
  <dd>
    <p>Floyd, S., Jacobson, V., Liu, C.-G., McCanne, S. and Zhang, L., A Reliable Multicast Framework for Light-weight Sessions and Application Level Framing. To appear in IEEE/ACK Transaction on Networking, November 1996. ftp://ftp.ee.lbl.gov/papers/srm1.ps.gz</p>
  </dd>
  <dt>
    <strong>[13]</strong>
  </dt>
  <dd>
    <p>Fall, K., and Varadhan, K., (eds.), "Ns notes and documentation", work in progress. http://www-mash.cs.berkeley.edu/ns/nsDoc.ps.gz</p>
  </dd>

</dl>
<p>Research using ns is on-going. A list of recent research contributions employing ns can be found at &lt;http://www-mash.cs.berkeley.edu/ns/ns-research.html&gt;.</p><p>Work on ns is on-going. Information about the most recent version is available at &lt;http://www-mash.cs.berkeley.edu/ns/ns.html&gt;.</p><p>A mailing list for ns users and announcements is also available, send mail to ns-users-request@mash.cs.berkeley.edu or ns-announce-request@mash.cs.berkeley.edu to join. Questions should be forwarded to ns-users; ns-announce will be low-traffic announcements only.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p>Steven McCanne (mccanne@ee.lbl.gov), University of California, Berkeley and Lawrence Berkeley National Laboratory, Berkeley, CA, and Sally Floyd (floyd@ee.lbl.gov) Lawrence Berkeley National Laboratory, Berkeley, CA. A complete list of contributors to ns is at &lt;http://www-mash.cs.berkeley.edu/ns/ns-contributors.html&gt;.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>Not all of the functionality supported in ns-1 has been ported to ns-2.</p><p>This manual page is incomplete.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="nrss.1.html"><span aria-hidden="true">&larr;</span> nrss.1: An ncurses rss reader</a></li>
   <li class="next"><a href="ns-3-manual.1.html">ns-3-manual.1: Ns-3 manual  this is the ns-3 manual. primary documentation for the ns-3 project is available in five forms: ns-3 doxygen: documentation of the public apis of the simulator tutorial, manual (this document), and model library for the latest release and development tree ns-3 wiki  this document is written in restructuredtext for sphinx and is maintained in the doc/manual directory of ns-3s source code. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>irsim: An event-driven logic-level simulator for mos circuits</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="An event-driven logic-level simulator for mos circuits">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="irsim (1) manual">
  <meta name="twitter:description" content="An event-driven logic-level simulator for mos circuits">
  <meta name="twitter:image" content="https://www.carta.tech/images/irsim-irsim-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/irsim.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="irsim (1) manual" />
  <meta property="og:description" content="An event-driven logic-level simulator for mos circuits" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/irsim-irsim-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">irsim<small> (1)</small></h1>
        <p class="lead">An event-driven logic-level simulator for mos circuits</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/irsim.1.html">
      <span itemprop="name">irsim: An event-driven logic-level simulator for mos circuits</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/irsim/">
      <span itemprop="name">irsim</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/irsim.1.html">
      <span itemprop="name">irsim: An event-driven logic-level simulator for mos circuits</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>irsim </strong><em>[-s] prm_file sim_file ... [+hist_file] [-cmd_file ...]</em></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>IRSIM is an event-driven logic-level simulator for MOS (both N and P) transistor circuits.  Two simulation models are available:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>switch</strong></p>
  </dt>
  <dd>
    <p>Each transistor is modeled as a voltage-controlled switch.  Useful for initializing or determining the functionality of the network.</p>
  </dd>
  <dt>
    <p><strong>linear</strong></p>
  </dt>
  <dd>
    <p>Each transistor is modeled as a resistor in series with a voltage-controlled switch; each node has a capacitance.  Node values and transition times are computed from the resulting RC network, using Chorng-Yeoung Chu's model.  Chris Terman's original model is not supported any more.</p>
  </dd>

</dl>
<p>If the <strong>-s</strong> switch is specified, 2 or more transistors of the same type connected in series, with no other connections to their common source/drain will be <em>stacked</em> into a compound transistor with multiple gates.</p><p>The <strong>prm_file</strong> is the electrical parameters file that configure the devices to be simulated. It defines the capacitance of the various layers, transistor resistances, threshold voltages, etc... (see <strong>presim</strong>(1)).</p><p>If <em>prm_file</em> does not specify an absolute path then IRSIM will search for the <em>prm_file</em> as follows (in that order):</p><p>	1) <em>./&lt;prm_file&gt;</em> (in the current directory). 	2) <strong>${CAD_ROOT}/irsim/</strong><em>&lt;prm_file&gt;</em><strong></strong> 	3) <strong>${CAD_ROOT}/irsim/</strong><em>&lt;prm_file&gt;</em><strong>.prm</strong><em></em></p><p>The default search directory (nominally /usr/local/lib) can be overriden by setting the environment variable CAD_ROOT to the appropriate directory prior to running IRSIM (i.e. setenv CAD_ROOT /cad/lib).</p><p>IRSIM first processes the files named on the command line, then (assuming the exit command has not been processed) accepts commands from the user, executing each command before reading the next.</p><p>File names NOT beginning with a '-' are assumed to be sim files (see <a href="../man5/sim.5.html"><strong>sim</strong>(5)</a>), note that this version does not require to run the sim files through presim.  These files are read and added to the network database.  There is only a single name space for nodes, so references to node "A" in different network files all refer to the same node.  While this feature allows one to modularize a large circuit into several network files, care must be taken to ensure that no unwanted node merges happen due to an unfortunate clash in names.</p><p>File names prefaced with a '-' are assumed to be command files: text files which contain command lines to be processed in the normal fashion.  These files are processed line by line; when an end-of-file is encountered, processing continues with the next file. After all the command files have been processed, and if an "exit" command has not terminated the simulation run, IRSIM will accept further commands from the user, prompting for each one like so:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>irsim&gt;</strong></p>
  </dt>
  <dd>
    
  </dd>

</dl>
<p>The <strong>hist_file</strong> is the name of a file created with the <em>dumph</em> command (see below).  If it is present, IRSIM will initilize the network to the state saved in that file.  This file is different from the ones created with the "&gt;" command since it saves the state of every node for all times, including any pending events.</p><p>This version supports changes to the network through the <strong>update</strong> command.  Also, the capability to incrementally re-simulate the network up to the current time is provided by the <strong>isim</strong> command.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COMMAND SUMMARY</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <strong>@ </strong><em>filename</em><strong></strong>
  </dt>
  <dd>
    <p>take commands from command file</p>
  </dd>
  <dt>
    <strong>? </strong><em>wnode...</em><strong></strong>
  </dt>
  <dd>
    <p>print info about node's source/drain connections</p>
  </dd>
  <dt>
    <strong>! </strong><em>wnode...</em><strong></strong>
  </dt>
  <dd>
    <p>print info about node's gate connections</p>
  </dd>
  <dt>
    <strong>&lt; </strong><em>filename</em><strong></strong>
  </dt>
  <dd>
    <p>restore network state from file</p>
  </dd>
  <dt>
    <strong>&gt; </strong><em>filename</em><strong></strong>
  </dt>
  <dd>
    <p>write current network state to file</p>
  </dd>
  <dt>
    <strong>&lt;&lt; </strong><em>filename</em><strong></strong>
  </dt>
  <dd>
    <p>same as "&lt;" but restores inputs too</p>
  </dd>
  <dt>
    <strong>| </strong><em>comment...</em><strong></strong>
  </dt>
  <dd>
    <p>comment line</p>
  </dd>
  <dt>
    <strong>activity </strong><em>from [to]</em><strong></strong>
  </dt>
  <dd>
    <p>graph circuit activity in time interval</p>
  </dd>
  <dt>
    <strong>ana </strong><em>wnode...</em><strong></strong>
  </dt>
  <dd>
    <p>display nodes in analyzer window</p>
  </dd>
  <dt>
    <strong>analyzer </strong><em>wnode...</em><strong></strong>
  </dt>
  <dd>
    <p>display nodes in analyzer window</p>
  </dd>
  <dt>
    <strong>assert </strong><em>wnode [m] val</em><strong></strong>
  </dt>
  <dd>
    <p>assert that <em>wnode</em> equals <em>value</em></p>
  </dd>
  <dt>
    <strong>assertWhen nodeT valT node val</strong>
  </dt>
  <dd>
    <p>assert when a condition is met</p>
  </dd>
  <dt>
    <strong>back </strong><em>[time]</em><strong></strong>
  </dt>
  <dd>
    <p>move back to <em>time</em></p>
  </dd>
  <dt>
    <strong>c </strong><em>[n]</em><strong></strong>
  </dt>
  <dd>
    <p>simulate for <em>n</em> clock cycles (default:1)</p>
  </dd>
  <dt>
    <strong>changes </strong><em>from [to]</em><strong></strong>
  </dt>
  <dd>
    <p>print nodes that changed in time interval</p>
  </dd>
  <dt>
    <strong>clock </strong><em>[node [val]]</em><strong></strong>
  </dt>
  <dd>
    <p>define value sequence for clock node</p>
  </dd>
  <dt>
    <strong>clear</strong>
  </dt>
  <dd>
    <p>clear analyzer window (remove signals)</p>
  </dd>
  <dt>
    <strong>d </strong><em>[wnode]...</em><strong></strong>
  </dt>
  <dd>
    <p>print display list or specified node(s)</p>
  </dd>
  <dt>
    <strong>debug </strong><em>[debug_level...]</em><strong></strong>
  </dt>
  <dd>
    <p>set debug level (default: off)</p>
  </dd>
  <dt>
    <strong>decay </strong><em>[n]</em><strong></strong>
  </dt>
  <dd>
    <p>set charge decay time (0 =&gt; no decay)</p>
  </dd>
  <dt>
    <strong>display </strong><em>[arg]...</em><strong></strong>
  </dt>
  <dd>
    <p>control what gets displayed when</p>
  </dd>
  <dt>
    <strong>dumph </strong><em>filename...</em><strong></strong>
  </dt>
  <dd>
    <p>write net history to file</p>
  </dd>
  <dt>
    <strong>hist [on|off]</strong>
  </dt>
  <dd>
    <p>turn history on or off</p>
  </dd>
  <dt>
    <strong>exit </strong><em>[status]</em><strong></strong>
  </dt>
  <dd>
    <p>return to system</p>
  </dd>
  <dt>
    <strong>flush</strong> <em>[time]</em>
  </dt>
  <dd>
    <p>flush out history up to <em>time</em> (default: now)</p>
  </dd>
  <dt>
    <strong>h </strong><em>wnode...</em><strong></strong>
  </dt>
  <dd>
    <p>make node logic high (1) input</p>
  </dd>
  <dt>
    <strong>has_coords</strong>
  </dt>
  <dd>
    <p>print YES if transistor coordinates are available</p>
  </dd>
  <dt>
    <strong>inputs</strong>
  </dt>
  <dd>
    <p>print current list of input nodes</p>
  </dd>
  <dt>
    <strong>ires </strong><em>[n]</em><strong></strong>
  </dt>
  <dd>
    <p>set incremental resolution to <em>n</em> ns</p>
  </dd>
  <dt>
    <strong>isim </strong><em>[filename]</em><strong></strong>
  </dt>
  <dd>
    <p>incrementally resimulate changes form <em>filename</em></p>
  </dd>
  <dt>
    <strong>l </strong><em>wnode...</em><strong></strong>
  </dt>
  <dd>
    <p>make node logic low (0) input</p>
  </dd>
  <dt>
    <strong>logfile </strong><em>[filename]</em><strong></strong>
  </dt>
  <dd>
    <p>start/stop log file</p>
  </dd>
  <dt>
    <strong>model </strong><em>[name]</em><strong></strong>
  </dt>
  <dd>
    <p>set simulation model to <em>name</em></p>
  </dd>
  <dt>
    <strong>p</strong>
  </dt>
  <dd>
    <p>step clock one simulation step (phase)</p>
  </dd>
  <dt>
    <strong>path </strong><em>wnode...</em><strong></strong>
  </dt>
  <dd>
    <p>display critical path for last transition of a node</p>
  </dd>
  <dt>
    <strong>powlogfile </strong><em>[filename]</em><strong></strong>
  </dt>
  <dd>
    <p>start/stop power logfile</p>
  </dd>
  <dt>
    <strong>powtrace </strong><em>-[node]...</em><strong></strong>
  </dt>
  <dd>
    <p>start/stop power tracing  of specified node(s)/vector(s)</p>
  </dd>
  <dt>
    <strong>powstep</strong>
  </dt>
  <dd>
    <p>toggle the display of power estimate for each timestep</p>
  </dd>
  <dt>
    <strong>print </strong><em>comment...</em><strong></strong>
  </dt>
  <dd>
    <p>print specified text</p>
  </dd>
  <dt>
    <strong>printp</strong>
  </dt>
  <dd>
    <p>print a list of all pending events</p>
  </dd>
  <dt>
    <strong>printx</strong>
  </dt>
  <dd>
    <p>print all undefined (X) nodes</p>
  </dd>
  <dt>
    <strong>q</strong>
  </dt>
  <dd>
    <p>terminate input from current stream</p>
  </dd>
  <dt>
    <strong>R </strong><em>[n]</em><strong></strong>
  </dt>
  <dd>
    <p>simulate for <em>n</em> cycles (default:longest sequence)</p>
  </dd>
  <dt>
    <strong>readh </strong><em>filename</em><strong></strong>
  </dt>
  <dd>
    <p>read history from <em>filename</em></p>
  </dd>
  <dt>
    <strong>report</strong><em>[level]</em><strong></strong>
  </dt>
  <dd>
    <p>set/reset reporting of decay events</p>
  </dd>
  <dt>
    <strong>s </strong><em>[n]</em><strong></strong>
  </dt>
  <dd>
    <p>simulate for <em>n</em> ns. (default: stepsize)</p>
  </dd>
  <dt>
    <strong>stepsize </strong><em>[n]</em><strong></strong>
  </dt>
  <dd>
    <p>set simulation step size to <em>n</em> ns.</p>
  </dd>
  <dt>
    <strong>set </strong><em>vector value</em><strong></strong>
  </dt>
  <dd>
    <p>assign <em>value</em> to <em>vector</em></p>
  </dd>
  <dt>
    <strong>setlog</strong><em>[file|off]</em><strong></strong>
  </dt>
  <dd>
    <p>log net changes to file (<em>off</em> -&gt; no log)</p>
  </dd>
  <dt>
    <strong>setpath </strong><em>[path...]</em><strong></strong>
  </dt>
  <dd>
    <p>set search path for cmd files</p>
  </dd>
  <dt>
    <strong>stats</strong>
  </dt>
  <dd>
    <p>print event statistics</p>
  </dd>
  <dt>
    <strong>sumcap</strong>
  </dt>
  <dd>
    <p>print out the sum of the capacitance of all nodes</p>
  </dd>
  <dt>
    <strong>t </strong><em>[-]wnode...</em><strong></strong>
  </dt>
  <dd>
    <p>start/stop tracing of specified nodes</p>
  </dd>
  <dt>
    <strong>tcap</strong>
  </dt>
  <dd>
    <p>print list of shorted transistors</p>
  </dd>
  <dt>
    <strong>time </strong><em>[command]</em><strong></strong>
  </dt>
  <dd>
    <p>print resource utilization summary</p>
  </dd>
  <dt>
    <strong>until wnode [mask] value count</strong>
  </dt>
  <dd>
    <p>delayed assert based on the clock count.</p>
  </dd>
  <dt>
    <strong>u </strong><em>wnode...</em><strong></strong>
  </dt>
  <dd>
    <p>make node undefined (X) input</p>
  </dd>
  <dt>
    <strong>unitdelay </strong><em>[n]</em><strong></strong>
  </dt>
  <dd>
    <p>force transitions to take <em>n</em> ns. (0 disables)</p>
  </dd>
  <dt>
    <strong>update </strong><em>filename</em><strong></strong>
  </dt>
  <dd>
    <p>read net changes from file</p>
  </dd>
  <dt>
    <strong>V </strong><em>[node [value...]]</em><strong></strong>
  </dt>
  <dd>
    <p>define sequence of inputs for a node</p>
  </dd>
  <dt>
    <strong>vector </strong><em>label node...</em><strong></strong>
  </dt>
  <dd>
    <p>define bit vector</p>
  </dd>
  <dt>
    <strong>vsupply </strong><em>voltage</em><strong></strong>
  </dt>
  <dd>
    <p>set supply voltage for calculating power (default 5V)</p>
  </dd>
  <dt>
    <strong>w </strong><em>[-]wnode...</em><strong></strong>
  </dt>
  <dd>
    <p>add/delete nodes from display list</p>
  </dd>
  <dt>
    <strong>wnet </strong><em>[filename]</em><strong></strong>
  </dt>
  <dd>
    <p>write network to file</p>
  </dd>
  <dt>
    <strong>x </strong><em>wnode...</em><strong></strong>
  </dt>
  <dd>
    <p>remove node from input lists</p>
  </dd>
  <dt>
    <strong>Xdisplay </strong><em>[host:n]</em><strong></strong>
  </dt>
  <dd>
    <p>set/show X display (for analyzer)</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>COMMAND DESCRIPTIONS</p>
  </dt>
  <dd>
    
  </dd>

</dl>
<p>Commands have the following simple syntax:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>cmd </strong><em>arg1 arg2 ... argn</em><strong> &lt;newline&gt;</strong><em></em></p>
  </dt>
  <dd>
    
  </dd>

</dl>
<p>where <strong>cmd</strong> specifies the command to be performed and the <em>argi</em> are arguments to that command.  The arguments are separated by spaces (or tabs) and the command is terminated by a <strong>&lt;newline&gt;.</strong></p><p>If <strong>cmd</strong> is not one of the built-in commands documented below, IRSIM appends ".cmd" to the command name and tries to open that file as a command file (see "<strong>@</strong>" command).  Thus the command "foo" has the same effect as "<strong>@</strong> foo.cmd".</p><p>Notation:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>...</strong></p>
  </dt>
  <dd>
    <p>indicates zero or more repetitions</p>
  </dd>
  <dt>
    <p><strong>[ ]</strong></p>
  </dt>
  <dd>
    <p>enclosed arguments are optional</p>
  </dd>
  <dt>
    <p><strong>node</strong></p>
  </dt>
  <dd>
    <p>name of node or vector in network</p>
  </dd>
  <dt>
    <p><strong>wnode</strong></p>
  </dt>
  <dd>
    <p>name of node or vector in network, can include <strong>'*'</strong> wildcard which matches any sequence of zero or more characters.  The pair of characters <strong>'{'</strong> and <strong>'}'</strong> denote iteration over the limits enclosed by it, for example: <strong>name{1:10}</strong> will expand into <em>name1, name2 ... name10.</em> A 3rd optional argument sets the stride, for example: <strong>name{1:10:2}</strong> will expand into <em>name1, name3, ... name7, name9.</em></p>
  </dd>
  <dt>
    <p><strong>| comment...</strong></p>
  </dt>
  <dd>
    <p>Lines beginning with vertical bar are treated as comments and ignored -- useful for comments or temporarily disabling certain commands in a command file.</p>
  </dd>

</dl>
<p>Most commands take one or more node names as arguments.  Whenever a node name is acceptible in a command line, one can also use the name of a bit vector.  In this case, the command will be applied to each node of the vector (the "<strong>t</strong>" and "<strong>d</strong>" treat vectors specially, see below).</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>vector </strong><em>label node...</em><strong></strong></p>
  </dt>
  <dd>
    <p>Define a bit vector named "label" which includes the specified nodes.  If you redefine a bit vector, any special attributes of the old vector (e.g., being on the display or trace list) are lost.  Wild cards are not accepted in the list of node names since you would have no control over the order in which matching nodes would appear in the vector.</p>
  </dd>

</dl>
<p>The simulator performs most commands silently.  To find out what's happened you can use one of the following commands to examine the state of the network and/or the simulator.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>set </strong><em>vector value</em><strong></strong></p>
  </dt>
  <dd>
    <p>Assign <em>value</em> to <em>vector.</em> For example, the following sequence of commands:</p><p>	<strong>vector </strong>BUS bit.1 bit.2 bit.3</p><p>	<strong>set </strong>BUS 01x</p><ul>
<li><p>The first command will define <em>BUS</em> to be a vector composed of nodes <em>bit.1, bit.2,</em> and <em>bit.3.</em> The second command will assign the following values:</p></li>
</ul>
  </dd>

</dl>
<p>		bit.1 = 0 		bit.2 = 1 		bit.3 = X</p><ul>
<li><p>Value can be any sequence of [0,1,h,H,l,L,x,X], and must be of the same length as the bit vector itself.</p></li>
</ul>
<dl class='dl-vertical'>
  <dt>
    <p><strong>d </strong><em>[wnode]...</em><strong></strong></p>
  </dt>
  <dd>
    <p>Display.  Without arguments displays the values all nodes and bit vectors currently on the display list (see <strong>w</strong> command).  With arguments, only displays the nodes or bit vectors specified.  See also the "display" command if you wish to have the display list printed out automatically at the end of certain simulation commands.</p>
  </dd>
  <dt>
    <p><strong>w </strong><em>[-]wnode...</em><strong></strong></p>
  </dt>
  <dd>
    <p>Watch/unwatch one or more nodes.  Whenever a "<strong>d</strong>" command is given, each watched node will displayed like so:</p><ul>
<li><p><strong>node1=0 node2=X ...</strong></p></li>
</ul>
  </dd>

</dl>
<p>To remove a node from the watched list, preface its name with a '-'. If <em>wnode</em> is the name of a bit vector, the values of the nodes which make up the vector will be displayed as follows:</p><ul>
<li><p><strong>label=010100</strong></p></li>
</ul><p>where the first 0 is the value of first node in the list, the first 1 the value of the second node, etc.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>assert </strong><em>wnode [mask] value</em><strong></strong></p>
  </dt>
  <dd>
    <p>Assert that the boolean value of the node or vector <em>wnode</em> is <em>value</em>.  If the comparison fails, an error message is printed. If <em>mask</em> is given then only those bits corresponding to zero bits in <em>mask</em> take part in the comparison, any character other than 0 will skip that bit. The format of the error message is the following:</p>
  </dd>

</dl>
<p>		(tty, 3): assertion failed on 'name' 10X10 (1010X)</p><ul>
<li><p>Where <em>name</em> is the name of the vector, followed by the actual value and the expected value enclosed in parenthesis.  If a <em>mask</em> is specified, then bits that were not compared are printed as '-'.</p></li>
</ul>
<dl class='dl-vertical'>
  <dt>
    <p><strong>until wnode [mask] value count</strong></p>
  </dt>
  <dd>
    <p>Acts just like the assert command except it requires an additional argument &lt;count&gt; which is the max number of clock cycles to run. Instead of just testing the current state, like assert, until tests for true and if false it runs clock cycles until condition becomes true or count runs out.</p>
  </dd>
  <dt>
    <p><strong>ana </strong><em>wnode...</em><strong></strong></p>
  </dt>
  <dd>
    <p>This is a shorthand for the <strong>analyzer</strong> command (described below).</p>
  </dd>
  <dt>
    <p><strong>analyzer </strong><em>wnode...</em><strong></strong></p>
  </dt>
  <dd>
    <p>Add the specified node(s)/vector(s) to the analyzer display list (see <a href="../man3/irsim-analyzer.3.html"><strong>irsim-analyzer</strong>(3)</a> for a detailed explanation).  If the analyzer window does not exist, it will be created.  If no arguments are given and the analyzer window already exists, nothing happens.</p>
  </dd>
  <dt>
    <p><strong>Xdisplay </strong><em>[host:display]</em><strong></strong></p>
  </dt>
  <dd>
    <p>You must be able to connect to an X-server to start the analyzer.  If you haven't set up the <strong>DISPLAY</strong> environment variable properly, the analyzer command may fail. If this is the case you can use the <strong>Xdisplay</strong> command to set it from within the simulator. With no arguments, the name of the current X-server will be printed.</p>
  </dd>
  <dt>
    <p><strong>clear</strong></p>
  </dt>
  <dd>
    <p>Removes all nodes and vectors from the analyzer window.  This command is most useful in command scripts for switching between different signals being displayed on the analyzer.</p>
  </dd>

</dl>
<p>"<strong>?</strong>" and "<strong>!</strong>" allow the user to go both backwards and forwards through the network.  This is a useful debugging aid.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>? </strong><em>wnode...</em><strong></strong></p>
  </dt>
  <dd>
    <p>Prints a synopsis of the named nodes including their current values and the state of all transistors that affect the value of these nodes. This is the most common way of wandering through the network in search of what went wrong.</p><p>The output from the command <em>? out</em> looks like</p><p>out=0 (vl=0.3 vh=0.8) (0.100 pf) is computed from: n-channel phi2=0 out=0 in=0 [1.0e+04, 1.3e+04, 8.7e+03] pulled down by (a=1 b=1)  [1.0e+04, 1.3e+04, 8.8e+03] pulled up [4.0e+04, 7.4e+04, 4.0e+04]</p><p>The first line gives the node's name and current value, its low and high logic thresholds, user-specifed low-to-high and high-to-low propagation delays if present, and its capacitance if nonzero. Succeeding lines list the transistor whose sources or drains connect to this node: the transistor type ("pulled down" is an n-channel transistor connected to gnd, "pulled up" is a depletion pullup or p-channel transistor connected to vdd), the values of the gate, source, and drain nodes, and the modeling resistances.  Simple chains of transistors with the same implant type are collapsed by the <em>-s</em> option into a single transistor with a "compound" gate; compound gates appear as a parenthesized list of nodes (e.g., the pulldown shown above).  The three resistance values -- static, dynamic high, dynamic low -- are given in Kilo-ohms.</p><p>Finally, any pending events for a node are listed after the electrical information.</p>
  </dd>
  <dt>
    <p><strong>! </strong><em>wnode...</em><strong></strong></p>
  </dt>
  <dd>
    <p>For each node in the argument list, print a list of transistors controlled by that node.</p>
  </dd>
  <dt>
    <p><strong>tcap</strong></p>
  </dt>
  <dd>
    <p>Prints a list of all transistors with their source/drain shorted together or whose source/drain are connected to the power supplies.  These transistors will have no effect on the simulation other than their gate capacitance load. Although transistors connected across the power supplies are real design errors, the simulator does not complain about them.</p>
  </dd>

</dl>
<p>Any node can be made an input -- the simulator will not change an input node's value until it is released.  Usually on specific nodes -- inputs to the circuit -- are manipulated using the commands below, but you can fool with a subcircuit by forcing values on internal nodes just as easily.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>h </strong><em>wnode...</em><strong></strong></p>
  </dt>
  <dd>
    <p>Force each node on the argument list to be a high (1) input.  Overrides previous input commands if necessary.</p>
  </dd>
  <dt>
    <p><strong>l </strong><em>wnode...</em><strong></strong></p>
  </dt>
  <dd>
    <p>Like "<strong>h</strong>" except forces nodes to be a low (0) input.</p>
  </dd>
  <dt>
    <p><strong>u </strong><em>wnode...</em><strong></strong></p>
  </dt>
  <dd>
    <p>Like "<strong>h</strong>" except forces nodes to be a undefined (X) input.</p>
  </dd>
  <dt>
    <p><strong>x </strong><em>wnode...</em><strong></strong></p>
  </dt>
  <dd>
    <p>Removes nodes from whatever input list they happen to be on.  The next simulation step will determine the correct node value from the surrounding circuit.  This is the default state of most nodes. Note that this does not force nodes to have an "X" value -- it simply removes them from the input lists.</p>
  </dd>
  <dt>
    <p><strong>inputs</strong></p>
  </dt>
  <dd>
    <p>prints the high, low, and undefined input lists.</p>
  </dd>

</dl>
<p>It is possible to define a sequence of values for a node, and then cycle the circuit as many times as necessary to input each value and simulate the network.  A similar mechanism is used to define the sequence of values each clock node goes through during a single cycle.</p><p>Each value is a list of characters (with no intervening blanks) chosen from the following:</p>
<dl class='dl-vertical'>
  <dt>
    1, h, H
  </dt>
  <dd>
    <p>logic high (1)</p>
  </dd>
  <dt>
    0, l, L
  </dt>
  <dd>
    <p>logic low (0)</p>
  </dd>
  <dt>
    u, U
  </dt>
  <dd>
    <p>undefined (X)</p>
  </dd>
  <dt>
    x, X
  </dt>
  <dd>
    <p>remove node from input lists</p>
  </dd>

</dl>
<p>Presumably the length of the character list is the same as the size of the node/vector to which it will be assigned.  Blanks (spaces and tabs) are used to separate values in a sequence.  The sequence is used one value at a time, left to right.  If more values are needed than supplied by the sequence, IRSIM just restarts the sequence again.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>V </strong><em>[node [value...]]</em><strong></strong></p>
  </dt>
  <dd>
    <p>Define a vector of inputs for a node.  After each cycle of an "R" command, the node is set to the next value specified in the sequence.</p>
  </dd>

</dl>
<p>With no arguments, clears all input sequences (does not affect clock sequences however).  With one argument, "node", clears any input sequences for that node/vector.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>clock </strong><em>[node [value...]]</em><strong></strong></p>
  </dt>
  <dd>
    <p>Define a phase of the clock.  Each cycle, each node specified by a clock command must run through its respective values.  For example,</p>
  </dd>

</dl>
<p>		clock phi1 1 0 0 0 		clock phi2 0 0 1 0</p><p>defines a simple 4-phase clock using nodes <em>phi1</em> and <em>phi2.</em> Alternatively one could have issued the following commands:</p><p>		vector clk phi1 phi2 		clock clk 10 00 01 00</p><p>With no arguments, clears all clock sequences.  With one argument, "node", clears any clock sequences for that node/vector.</p><p>After input values have been established, their effect can be propagated through the network with the following commands.  The basic simulated time unit is 0.1ns; all event times are quantized into basic time units.  A simulation step continues until <em>stepsize</em> ns. have elapsed, and any events scheduled for that interval are processed.  It is possible to build circuits which oscillate -- if the period of oscillation is zero, the simulation command will not return.  If this seems to be the case, you can hit <strong>&lt;ctrl-C&gt;</strong> to return to the command interpreter.  Note that if you do this while input is being taken from a file, the simulator will bring you to the top level interpreter, aborting all pending input from any command files.</p><p>When using the linear model (see the "<strong>model</strong>" command) transition times are estimated using an RC time constant calculated from the surrounding circuit.  When using the switch model, transitions are scheduled with unit delay.  These calculations can be overridden for a node by setting its tplh and tphl parameters which will then be used to determine the time for a transition.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>s </strong><em>[n]</em><strong></strong></p>
  </dt>
  <dd>
    <p>Simulation step.  Propogates new values for the inputs through the network, returns when <em>n</em> (default: <em>stepsize</em>) ns. have passed. If <em>n</em> is specified, it will temporarily override the <em>stepsize</em> value.  Unlike previous versions, this value is NOT remembered as the default value for the <em>stepsize</em> parameter.  If the display mode is "automatic", the current display list is printed out on the completion of this command (see "display" command).</p>
  </dd>
  <dt>
    <p><strong>c </strong><em>[n]</em><strong></strong></p>
  </dt>
  <dd>
    <p>Cycle <em>n</em> times (default: 1) through the clock, as defined by the "<strong>clock</strong>" command.  Each phase of the clock lasts <em>stepsize</em> ns. If the display mode is "<em>automatic</em>", the current display list is printed out on the completion of this command (see "<strong>display</strong>" command).</p>
  </dd>
  <dt>
    <p><strong>p</strong></p>
  </dt>
  <dd>
    <p>Step the clock through one phase (or simulation step).  For example, if the clock is defined as above</p>
  </dd>

</dl>
<p>		clock phi1   1 0 0 0 		clock phi2   0 0 1 0</p><p>then "<strong>p</strong>" will set phi1 to 1 and phi2 to 0, and then propagate the effects for one simulation step.  The next time "<strong>p</strong>" is issued, phi1 and phi2 will both be set to 0, and the effects propagated, and so on. If the "<strong>c</strong>" command is issued after "<strong>p</strong>" has been used, the effect will be to step through the next 4 phases from where the "<strong>p</strong>" command left off.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>R </strong><em>[n]</em><strong></strong></p>
  </dt>
  <dd>
    <p>Run the simulator through <em>n</em> cycles (see the "<strong>c</strong>" command).  If <em>n</em> is not present make the run as long as the longest sequence.  If display mode is automatic (see "<strong>display</strong>" command) the display is printed at the end of each cycle.  Each "<strong>R</strong>" command starts over at the beginning of the sequence defined for each node.</p>
  </dd>
  <dt>
    <p><strong>back </strong><em>time</em><strong></strong></p>
  </dt>
  <dd>
    <p>Move back to the specified time.  This command restores circuit state as of <em>time</em>, effectively undoing any changes in between.  Note that you can not move past any previously flushed out history (see <strong>flush</strong> command below) as the history mechanism is used to restore the network state.  This command can be useful to undo a mistake in the input vectors or to re-simulate the circuit with a different debug level.</p>
  </dd>
  <dt>
    <p><strong>path </strong><em>wnode...</em><strong></strong></p>
  </dt>
  <dd>
    <p>display critical path(s) for last transition of the specified node(s). The critical path transistions are reported using the following format: 		<em>node</em><strong> -&gt; </strong><em>value</em><strong> @ </strong><em>time</em><strong> (</strong><em>delta</em><strong>)</strong><em></em></p><ul>
<li><p>where <em>node</em> is the name of the node, <em>value</em> is the value to which the node transitioned, <em>time</em> is the time at which the transistion occurred, and <em>delta</em> is the delay through the node since the last transition.  For example:</p></li>
</ul>
  </dd>

</dl>
<p>		critical path for last transition of Hit_v1: 			phi1-&gt; 1 @ 2900.0ns , node was an input 			PC_driver-&gt; 0 @ 2900.4ns    (0.4ns) 			PC_b_q1-&gt; 1 @ 2904.0ns    (3.6ns) 			tagDone_b_v1-&gt; 0 @ 2912.8ns    (8.8ns) 			tagDone1_v1-&gt; 1 @ 2915.3ns    (2.5ns) 			tagDone1_b_v1-&gt; 0 @ 2916.0ns    (0.7ns) 			tagDone_v1-&gt; 1 @ 2918.4ns    (2.4ns) 			tagCmp_b_v1-&gt; 0 @ 2922.1ns    (3.7ns) 			tagCmp_v1-&gt; 1 @ 2923.0ns    (0.9ns) 			Vbit_b_v1-&gt; 0 @ 2923.2ns    (0.2ns) 			Hit_v1-&gt; 1 @ 2923.5ns    (0.3ns)</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>activity </strong><em>from_time [to_time]</em><strong></strong></p>
  </dt>
  <dd>
    <p>print histogram showing amount of circuit activity in the specified time inteval.  Actually only shows number of nodes which had their most recent transition in the interval.</p>
  </dd>
  <dt>
    <p><strong>changes </strong><em>from_time [to_time]</em><strong></strong></p>
  </dt>
  <dd>
    <p>print list of nodes which last changed value in the specified time interval.</p>
  </dd>
  <dt>
    <p><strong>printp</strong></p>
  </dt>
  <dd>
    <p>print list of all pending events sorted in time.  The node associated with each event and the scheduled time is printed.</p>
  </dd>
  <dt>
    <p><strong>printx</strong></p>
  </dt>
  <dd>
    <p>print a list of all nodes with undefined (X) values.</p>
  </dd>

</dl>
<p>Using the trace command, it is possible to get more detail about what's happening to a particular node.  Much of what is said below is described in much more detail in "Logic-level Simulation for VLSI Circuits" by Chris Terman, available from Kluwer Academic Press.  When a node is traced, the simulator reports each change in the node's value:</p><ul>
<li><p>	[event #100] node out.1: 0 -&gt; 1 @ 407.6ns</p></li>
</ul><p>The event index is incremented for each event that is processed.  The transition is reported as 	<em>old value</em><strong> -&gt; </strong><em>new value</em><strong> @ </strong><em>report time</em><strong></strong></p><p>Note that since the time the event is processed may differ from the event's report time, the report time for successive events may not be strictly increasing.</p><p>Depending on the debug level (see the "<strong>debug</strong>" command) each calculation of a traced node's value is reported:</p><p>	[event #99] node clk: 0 -&gt; 1 @ 400.2ns 	final_value( Load )  V=[0.00, 0.04]  =&gt; 0 	..compute_tau( Load ) 	{Rmin=2.2K  Rdom=2.2K  Rmax=2.2K}  {Ca=0.06  Cd=0.17} 	tauA=0.1  tauD=0.4 ns 	[event #99: clk-&gt;1] transition for Load: 1 -&gt; 0 (tau=0.5ns, delay=0.6ns)</p><p>In this example, a calculation for node <em>Load</em> is reported.  The calculation was caused by event 99 in which node clk went to 1.  When using the linear model (as in this example) the report shows 	<em>current value</em><strong> -&gt; </strong><em>final value</em><strong></strong></p><p>The second line displays information regarding the final value (or dc) analysis for node "Load"; the minimun and maximum voltages as well as the final logical value (0 in this case).</p><p>The next three lines display timing analysis information used to estimate the delays.  The meaning of the variables displayed can be found Chu's thesis: "Improved Models for Switch-Level Simulation".</p><p>When the <em>final value</em> is reported as "D", the node is not connected to an input and may be scheduled to decay from its current value to X at some later time (see the "<strong>decay</strong><em>" command).</em></p><p>"tau" is the calculated transition time constant, "delta" is when any consequences of the event will be computed; the difference in the two times is how IRSIM accounts for the shape of the transition waveform on subsequent stages (see reference given above for more details).  The middle lines of the report indicate the Thevenin and capacitance parameters of the surrounding networks, i.e., the parameters on which the transition calculations are based.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>debug </strong><em>[ev dc tau taup tw spk][off][all]</em><strong></strong></p>
  </dt>
  <dd>
    <p>Set debugging level.  Useful for debugging simulator and/or circuit at various levels of the computation.  The meaning of the various debug levels is as follows:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>ev</strong>
  </dt>
  <dd>
    <p>display event enqueueing and dequeueing.</p>
  </dd>
  <dt>
    <strong>dc</strong>
  </dt>
  <dd>
    <p>display dc calculation information.</p>
  </dd>
  <dt>
    <strong>tau</strong>
  </dt>
  <dd>
    <p>display time constant (timing) calculation.</p>
  </dd>
  <dt>
    <strong>taup</strong>
  </dt>
  <dd>
    <p>display second time constant (timing) calculation.</p>
  </dd>
  <dt>
    <strong>tw</strong>
  </dt>
  <dd>
    <p>display network parameters for each stage of the tree walk, this applies to <strong>dc, tau</strong>, and <strong>taup</strong>.  This level of debugging detail is usually needed only when debugging the simulator.</p>
  </dd>
  <dt>
    <strong>spk</strong>
  </dt>
  <dd>
    <p>displays spike analysis information.</p>
  </dd>
  <dt>
    <strong>all</strong>
  </dt>
  <dd>
    <p>This is a shorthand for specifying all of the above.</p>
  </dd>
  <dt>
    <strong>off</strong>
  </dt>
  <dd>
    <p>This turns off all debugging information.</p>
  </dd>

</dl>
<ul>
<li><p>If a debug switch is on then during a simulation step, each time a watched node is encounted in some event, that fact is indicated to the user along with some event info.  If a node keeps appearing in this prinout, chances are that its value is oscillating.  Vice versa, if your circuit never settles (ie., it oscillates) , you can use the "<strong>debug</strong>" and "<strong>t</strong>" commands to find the node(s) that are causing the problem.</p><p>Without any arguments, the debug command prints the current debug level.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>t </strong><em>[-]wnode...</em><strong></strong></p>
  </dt>
  <dd>
    <p>set trace flag for node.  Enables the various printouts described above. Prefacing the node name with '-' clear its trace flag. If "wnode" is the name of a vector, whenever any node of that vector changes value, the current time and the values of all traced vectors is printed.  This feature is useful for watching the relative arrival times of values at nodes in an output vector.</p>
  </dd>

</dl>
<p>System interface commands:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>&gt; </strong><em>filename</em><strong></strong></p>
  </dt>
  <dd>
    <p>Write current state of each node into specified file.  Useful for making a breakpoint in your simulation run.  Only stores values so isn't really useful to "dump" a run for later use, i.e., the current input lists, pending events, etc. are NOT saved in the state file.</p>
  </dd>
  <dt>
    <p><strong>&lt; </strong><em>filename</em><strong></strong></p>
  </dt>
  <dd>
    <p>Read from specified file, reinitializing the value of each node as directed.  Note that network must already exist and be identical to the network used to create the dump file with the "&gt;" command.  These state saving commands are really provided so that complicated initializing sequences need only be simulated once.</p>
  </dd>
  <dt>
    <p><strong>&lt;&lt; </strong><em>filename</em><strong></strong></p>
  </dt>
  <dd>
    <p>Same as "<strong>&lt;</strong>" command, except that this command will restore the <em>input</em> status of the nodes as well.  It does not, however, restore pending events.</p>
  </dd>
  <dt>
    <p><strong>dumph </strong><em>[filename]</em><strong></strong></p>
  </dt>
  <dd>
    <p>Write the history of the simulation to the specified file, that is; all transistions since time = 0.  The resulting file is a machine-independent binary file, and contains all the required information to continue simulation at the time the dump takes place.  If the filename isn't specified, it will be constructed by taking the name of the sim_file (from the command line) and appending ".hist" to it.</p>
  </dd>
  <dt>
    <p><strong>readh </strong><em>filename</em><strong></strong></p>
  </dt>
  <dd>
    <p>Read the specified history-dump file into the current network.  This command will restore the state of the circuit to that of the dump file, overwriting the current state.</p>
  </dd>
  <dt>
    <p><strong>flush </strong><em>[time]</em><strong></strong></p>
  </dt>
  <dd>
    <p>If memory consumption due to history maintanance becomes prohibitive, this command can be used to free the memory consumed by the history up to the time specified.  With no arguments, all history up to the current point in the simulation is freed.  Flushing out the history may invalidate an incremental simulation and the portions flushed will no longer appear in the analyzer window.</p>
  </dd>
  <dt>
    <p><strong>setpath </strong><em>[path...]</em><strong></strong></p>
  </dt>
  <dd>
    <p>Set the search-path for command files.  <em>Path</em> should be a sequence of directories to be searched for ".cmd" files, "." meaning the current directory.  For eaxmple: 	<strong>setpath </strong>. /usr/me/rsim/cmds /cad/lib/cmds</p><ul>
<li><p>With no arguments, it will print the current search-path.  Initially this is just ".".</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>print </strong><em>text...</em><strong></strong></p>
  </dt>
  <dd>
    <p>Simply prints the text on the user's console.  Useful for keeping user posted of progress through a long command file.</p>
  </dd>
  <dt>
    <p><strong>logfile </strong><em>[filename]</em><strong></strong></p>
  </dt>
  <dd>
    <p>Create a logfile with the specified name, closing current log file if any; if no argument, just close current logfile.  All output which appears on user's console will also be placed in the logfile.  Output to the logfile is cleverly formatted so that logfiles themselves can serve as command files.</p>
  </dd>
  <dt>
    <p><strong>setlog </strong><em>[filename | off]</em><strong></strong></p>
  </dt>
  <dd>
    <p>Record all net changes, as well as resulting error messages, to the specified file (see "<strong>update</strong>" command).  Net changes are always appended to the log-file, preceding each sequence of changes by the current date.  If the argument is <em>off</em> then net-changes will not be logged.  With no arguments, the name of the current log-file is printed.</p><p>The default is to always record net changes; if no filename is specified (using the "<strong>setlog</strong>" command) the default filename <em>irsim_changes.log</em> will be used.  The log-files are formatted so that log-files may themselves be used as net-change files.</p>
  </dd>
  <dt>
    <p><strong>wnet </strong><em>[filename]</em><strong></strong></p>
  </dt>
  <dd>
    <p>Write the current network to the specified file.  If the filename isn't specified, it will be constructed by taking the name of the sim_file (from the command line) and appending ".inet" to it.  The resulting file can be used in a future simulation run, as if it were a sim file.  The file produced is a machine independent binary file, which is typically about 1/3 the size of the sim file and about 8 times faster to load.</p>
  </dd>
  <dt>
    <p><strong>time </strong><em>[command]</em><strong></strong></p>
  </dt>
  <dd>
    <p>With no argument, a summary of time used by the simulator is printed. If arguments are given the specified command is timed and a time summary is printed when the command completes. The format of the time summary is <em>U</em><strong>u </strong><em>S</em><strong>s </strong><em>E P</em><strong>%</strong><em> M</em><strong>, where:</strong></p>
  </dd>

</dl>
<p>	<em>U</em> =&gt; User time in seconds 	<em>S</em> =&gt; System time in seconds 	<em>E</em> =&gt; Elapsed time, minutes:seconds 	<em>P</em> =&gt; Percentage of CPU time (((U + S)/E) * 100) 	<em>M</em> =&gt; Median text, data, and stack size use</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>q</strong></p>
  </dt>
  <dd>
    <p>Terminate current input stream.  If this is typed at top level, the simulator will exit back to the system; otherwise, input reverts to the previous input stream.</p>
  </dd>
  <dt>
    <p><strong>exit </strong><em>[n]</em><strong></strong></p>
  </dt>
  <dd>
    <p>Exit to system, <em>n</em> is the reported status (default: 0).</p>
  </dd>

</dl>
<p>Simulator parameters are set with the following commands.  With no arguments, each of the commands simply prints the current value of the parameter.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>decay </strong><em>[n]</em><strong></strong></p>
  </dt>
  <dd>
    <p>Set decay parameter to <em>n</em> ns. (default: 0).  If non-zero, it tells the number of ns. it takes for charge on a node to decay to X.  A value of 0 implies no decay at all.  You cannot specify this parameters separately for each node, but this turns out not to be a problem.  See "<strong>report</strong>" command.</p>
  </dd>
  <dt>
    <p><strong>display </strong><em>[-][cmdfile][automatic]</em><strong></strong></p>
  </dt>
  <dd>
    <p>set/reset the display modes, which are</p>
<dl class='dl-vertical'>
  <dt>
    <strong>cmdfile</strong>
  </dt>
  <dd>
    <p>commands executed from command files are displayed to user before executing.  The default is <em>cmdfile = OFF.</em></p>
  </dd>
  <dt>
    <strong>automatic</strong>
  </dt>
  <dd>
    <p>print out current display list (see "<strong>d</strong>" command) after completion of "<strong>s</strong>" or "<strong>c</strong>" command.  The default is <em>automatic = ON.</em></p>
  </dd>

</dl>
<ul>
<li><p>Prefacing the previous commands with a "-" turns off that display option.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>model </strong><em>[name]</em><strong></strong></p>
  </dt>
  <dd>
    <p>Set simulation model to one of the following:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>switch</strong>
  </dt>
  <dd>
    <p>Model transistors as voltage controlled switches.  This model uses interval logic levels, without accounting for transistor resistances, so circuits with fighting transistors may not be accuratelly modelled.  Delays may not reflect the <em>true</em> speed of the circuit as well.</p>
  </dd>
  <dt>
    <strong>linear</strong>
  </dt>
  <dd>
    <p>Model transistors as a resistor in series with a voltage controlled switch. This model uses a single-time-constant computed from the resulting RC network and uses a two-time-constant model to analyze charge sharing and spikes.</p>
  </dd>

</dl>
<ul>
<li><p>The default is the <strong>linear</strong> model. You can change the simulation model at any time -- even with events pending -- as only new calculations are affected. Without arguments, this command prints the current model name.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>report </strong><em>[level]</em><strong></strong></p>
  </dt>
  <dd>
    <p>When level is nonzero, report all nodes which are set to X because of charge decay, regardless on whether they are being traced.  Setting level to zero disables reporting, but not the decay itself (see "<strong>decay</strong>" command).</p>
  </dd>
  <dt>
    <p><strong>stepsize </strong><em>[n]</em><strong></strong></p>
  </dt>
  <dd>
    <p>Specify duration of simulation step or clock phase. <em>n is specified</em> in ns. (nanoseconds).  Floating point numbers with up to 1 digit past the decimal point are allowed.  Further decimals are trucated (i.e. 10.299 == 10.2).</p>
  </dd>
  <dt>
    <p><strong>unitdelay </strong><em>[n]</em><strong></strong></p>
  </dt>
  <dd>
    <p>When nonzero, force all transitions to take <em>n</em> ns.  Setting the parameter to zero disables this feature.  The resolution is the same as for the "<strong>stepsize</strong>" command.</p>
  </dd>
  <dt>
    <p><strong>stats</strong></p>
  </dt>
  <dd>
    <p>Print event statitistics, as follows:</p>
  </dd>

</dl>
<p>		changes = 26077 		punts (cns) = 208 (34) 		punts = 0.79%, cons_punted = 16.35% 		nevents = 28012; evaluations = 27972</p><ul>
<li><p>Where <em>changes</em> is the total number of transistions recorded, <em>punts</em> is the number of punted events, <em>(cns)</em> is the number of consecutive punted events (a punted event that punted another event).  The penultimate line shows the percentage of punted events with respect to the total number of events, and the percentage of consecutive punted events with respect to the number of punted events.  The last line shows the total number of events (nevents) and the number of net evaluations.</p></li>
</ul><p>Incremental simulation commands:</p><p><strong>Irsim</strong> supports incremental changes to the network and resimulation of the resulting network.  This is done incrementally so that only the nodes affected by the changes, either directly or indirectly, are re-evaluated.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>update </strong><em>filename</em><strong></strong></p>
  </dt>
  <dd>
    <p>Read net-change tokens from the specified file.  The following net-change commands are available:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>a</strong>dd
  </dt>
  <dd>
    <p>type gate source drain length width [area]</p>
  </dd>
  <dt>
    <strong>d</strong>elete
  </dt>
  <dd>
    <p>type gate source drain length width [area]</p>
  </dd>
  <dt>
    <strong>m</strong>ove
  </dt>
  <dd>
    <p>type gate source drain length width [area] g s d</p>
  </dd>
  <dt>
    <strong>c</strong>ap
  </dt>
  <dd>
    <p>node value</p>
  </dd>
  <dt>
    <strong>N</strong>
  </dt>
  <dd>
    <p>node metal-area poly-area diff-area diff-perim</p>
  </dd>
  <dt>
    <strong>M</strong>
  </dt>
  <dd>
    <p>node M2A M2P MA MP PA PP DA DP PDA PDP</p>
  </dd>
  <dt>
    <strong>t</strong>hresh
  </dt>
  <dd>
    <p>node low high</p>
  </dd>
  <dt>
    <strong>D</strong>elay
  </dt>
  <dd>
    <p>node tplh tphl</p>
  </dd>

</dl>
<ul>
<li><p>For a detailed dscription of this file see <a href="../man5/netchange.5.html"><strong>netchange</strong>(5)</a>.  Note that this is an experimental interface and is likely to change in the future.</p></li><li><p>Note that this command doesn't resimulate the circuit so that it may leave the network in an inconsistent state.  Usually this command will be followed by an <strong>isim</strong> command (see below), if that is not the case then it's up to the user to initilize the state of the circuit.  This command exists only for historical reasons and will probably disappear in the future.  It's use is discouraged.</p></li>
</ul>
  </dd>
  <dt>
    <p><strong>isim </strong><em>[filename]</em><strong></strong></p>
  </dt>
  <dd>
    <p>Read net-change tokens from the specified file (see <a href="../man5/netchange.5.html"><strong>netchange</strong>(5)</a>) and incrementally resimulate the circuit up to the current simulation time (not supported yet).</p>
  </dd>
  <dt>
    <p><strong>ires </strong><em>n</em><strong></strong></p>
  </dt>
  <dd>
    <p>The incremental algorithm keeps track of nodes deviating from their past behavior as recorded in the network history.  During resimulation, a node is considered to deviate from its history if it's new state is found to be different within <em>n</em> ns of its previous state.  This command allows for changing the incremental resolution.  With no arguments, it will print the current resolution.  The default resolution is 0 ns.</p>
  </dd>
  <dt>
    <p><strong>powlogfile </strong><em>[filename]</em><strong></strong></p>
  </dt>
  <dd>
    <p>Opens <em>filename</em> for writting nodal transition reports. The format of the report is the same you get when you trace a node normaly. With no arguments powlogfile just closes the opened logfile and prints out a power dissipation summary. Nodal transitions in inputs are <strong>not</strong> included in the transition count.</p>
  </dd>
  <dt>
    <p><strong>powtrace </strong><em>[[-]node...]</em><strong></strong></p>
  </dt>
  <dd>
    <p>The syntax of this command is the same as the normal <strong>t</strong> (trace) command. If you want to trace and report power dissipation for all the nodes just use powtrace *. Use powtrace <strong>-node</strong> if you want to exclude some nodes.</p>
  </dd>
  <dt>
    <p><strong>powstep</strong></p>
  </dt>
  <dd>
    <p>Toggles whether dynamic power estimation is displayed after each timestep. The ynamic power displayed will only be for the nodes that have been selected using the <strong>powtrace</strong> command.</p>
  </dd>
  <dt>
    <p><strong>vsupply </strong><em>voltage</em><strong></strong></p>
  </dt>
  <dd>
    <p>Sets the <strong>V</strong> variable for use in the <strong>P=CV^2/(2t)</strong> expression where <strong>C</strong> is capacitance switched, and <strong>t</strong> is the timestep.  The default value for vsupply is 5.0 Volts.</p>
  </dd>
  <dt>
    <p><strong>sumcap</strong></p>
  </dt>
  <dd>
    <p>Gives a sum of <strong>all</strong> nodal capcitances, <strong>not</strong> just those selected with the <strong>powtrace</strong> command.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO irsim&hellip;</h2>
        <div class="sectioncontent">
<p><strong>presim</strong>(1) (now obsolete)</p><p><strong>rsim</strong>(1)</p><p><a href="../man3/irsim-analyzer.3.html"><strong>irsim-analyzer</strong>(3)</a></p><p><a href="../man5/sim.5.html"><strong>sim</strong>(5)</a></p><p><a href="../man5/netchange.5.html"><strong>netchange</strong>(5)</a></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="irsend.1.html"><span aria-hidden="true">&larr;</span> irsend.1: Basic lirc program to send infra-red commands</a></li>
   <li class="next"><a href="irssi.1.html">irssi.1: A modular irc client for unix <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

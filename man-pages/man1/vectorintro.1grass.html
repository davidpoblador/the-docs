<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>vectorintro: Vector data processing  vector data processing</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Vector data processing  vector data processing">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="vectorintro (1grass) manual">
  <meta name="twitter:description" content="Vector data processing  vector data processing">
  <meta name="twitter:image" content="https://www.carta.tech/images/grass-doc-vectorintro-1grass.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1grass/vectorintro.1grass.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="vectorintro (1grass) manual" />
  <meta property="og:description" content="Vector data processing  vector data processing" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/grass-doc-vectorintro-1grass.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">vectorintro<small> (1grass)</small></h1>
        <p class="lead">Vector data processing  vector data processing</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1grass/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1grass/vectorintro.1grass.html">
      <span itemprop="name">vectorintro: Vector data processing  vector data processing</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/grass-doc/">
      <span itemprop="name">grass-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1grass/vectorintro.1grass.html">
      <span itemprop="name">vectorintro: Vector data processing  vector data processing</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">Vector data processing in GRASS GIS</h2>
        <div class="sectioncontent">
<h3>Vector maps in general</h3>
<p>A "vector map" is a data layer consisting of a number of sparse features in geographic space. These might be data points (drill sites), lines (roads), polygons (park boundary), volumes (3D CAD structure), or some combination of all these. Typically each feature in the map will be tied to a set of attribute layers stored in a database (road names, site ID, geologic type, etc.). As a general rule these can exist in 2D or 3D space and are independent of the GIS's computation region.</p>
<h3>Vector data import and export</h3>
<p>The v.in.ogr module offers a common interface for many different vector formats. Additionally, it offers options such as on-the-fly creation of new locations or extension of the default region to match the extent of the imported vector map. For special cases, other import modules are available, e.g. v.in.ascii for input from a text file containing coordinate and attribute data, and v.in.db for input from a database containing coordinate and attribute data. With v.external external maps can be virtually linked into a mapset, only pseudo-topology is generated but the vector geometry is not imported. The <em>v.out.*</em> set of commands exports to various formats. To import and export only attribute tables, use db.in.ogr and db.out.ogr. The naming convention for vector maps requires that map names start with a character, not a number (map name scheme: [A-Za-z][A-Za-z0-9_]*).</p>
<h3>Metadata</h3>
<p>The v.info display general information such as metadata and attribute columns about a vector map including the history how it was generated. Each map generating command stores the command history into the metadata (query with v.info -h mapname). Metadata such as map title, scale, organization etc. can be updated with v.support.</p>
<h3>Vector map operations</h3>
<p>GRASS vector map processing is always performed on the full map. If this is not desired, the input map has to be clipped to the current region beforehand (v.in.region, v.select).</p>
<h3>Vector model and topology</h3>
<p>GRASS is a topological GIS. This means that adjacent geographic components in a single vector map are related. For example in a non-topological GIS if two areas shared a common border that border would be digitized two times and also stored in duplicate. In a topological GIS this border exists once and is shared between two areas.  Topological represenation of vector data helps to produce and maintain vector maps with clean geometry as well as enables certain analyses that can not be conducted with non-topological or spaghetti data. In GRASS topological data are refered to as level 2 data and spaghetti data is referred to as level 1.</p><p>Sometimes topology is not necessary and the additional memory and space requirements are burdensome to a particular task. Therefore two modules allow for working level 1 (non-topological) data within GRASS. The v.in.ascii module allows users to input points without building topology. This is very useful for large files where memory restrictions may cause difficulties. The other module which works with level 1 data is v.surf.rst which enables spatial approximation and topographic analysis from a point or isoline file.</p><p> In GRASS, the following vector object types are defined:</p><ul>
<li><p> point: a point;</p></li><li><p> line: a directed sequence of connected vertices with two endpoints called nodes;</p></li><li><p> boundary: the border line to describe an area;</p></li><li><p> centroid: a point within a closed ring of boundaries;</p></li><li><p> area: the topological composition of a closed ring of boundaries and optionally a centroid;</p></li><li><p> face: a 3D area;</p></li><li><p> kernel: a 3D centroid in a volume (not yet implemented);</p></li><li><p> volume: a 3D corpus, the topological composition of faces and kernel (not yet implemented).</p></li>
</ul><p>Note that all lines and boundaries can be polylines (with vertices in between).</p><p>Area topology also holds information about isles. These isles are located within that area, not touching the boundaries of the outer area. Isles consist of one or more areas and are used internally to maintain correct topology for areas.</p><p>The v.type module can be used to convert between vector types if possible. The v.build module is used to generate topology. It optionally allows the user to extract erroneous vector objects into a separate map. Topological errors can be corrected either manually within v.digit or, to some extent, automatically in v.clean. A dedicated vector editing module is v.edit which supports global and local editing operations. Additionally, new advanced topological operations are available in the wxGUI vector digitizer. Adjacent polygons can be found by v.to.db (see 'sides' option).</p><p>Many operations including extraction, queries, overlay, and export will only act on features which have been assigned a category number. Typically a centroid will hold the attribute data for the area between it and its boundaries. Boundaries are not typically given a category ID as it would be ambiguous as to which area either side of it the attribute data would belong to. An exception might be when the boundary between two crop-fields is the center-line of a road, and the category information is an index to the road name. For everyday use boundaries and centroids can be treated as internal data types and the user can work directly and more simply with the "area" meta-feature type.</p>
<h3>Vector object categories and attribute management</h3>
<p>GRASS vectors can be linked to one or many database management systems (DBMS). The <em>db.*</em> set of commands provides basic SQL support for attribute management, while the <em>v.db.*</em> set of commands operates on a table linked to a vector map.</p><ul>
<li><p><strong>Categories</strong></p><p>Categories are used to categorize vector objects and link attribute(s) to each category. Each vector object can have zero, one or several categories. Category numbers do not have to be unique for each vector object, several vector objects can share the same category.</p><p>Category numbers are stored both within the geometry file for each vector object and within the (optional) attribute table(s) (usually the "cat" column). It is not required that attribute table(s) hold an entry for each category, and attribute table(s) can hold information about categories not present in the vector geometry file. This means that e.g. an attribute table can be populated first and then vector objects can be added to the geometry file with category numbers. Using v.category, category numbers can be printed or maintained.</p></li><li><p><strong>Layers</strong></p><p>Layers are a characteristic of the vector feature (geometries) file. As mentioned above, categories allow the user to give either a unique id to each feature or to group similar features by giving them all the same id. Layers allow several parallel, but different groupings of features in a same map. The practical benefit of this system is that it allows placement of thematically distinct but topologically related objects into a single map, or for linking time series attribute data to a series of locations that did not change over time.</p><p>For example, one can have roads with one layer containing the unique id of each road and another layer with ids for specific routes that one might take, combining several roads by assigning the same id. While this example can also be dealt with in an attribute table, another example of the use of layers that shows their specific advantage is the possibility to identify the same geometrical features as representing different thematic objects. For example, in a map with a series of polygons representing fields in which at the same time the boundaries of these fields have a meaning as linear features, e.g. as paths, one can give a unique id to each field as area in layer 1, and a unique id in layer 2 to those boundary lines that are paths. If the paths will always depend on the field boundaries (and might change if these boundaries change) then keeping them in the same map can be helpful. Trying to reproduce the same functionality through attributes is much more complicated.</p><p>If a vector object has zero categories in a layer, then it does not appear in that layer. In this fashion some vector objects may appear in some layers but not in others. Taking the example of the fields and paths, only some boundaries, but not all, might have a category value in layer 2. With <em>option=report</em>, v.category lists available categories in each layer.</p><p>Optionally, each layer can (but does not have to) be linked to an attribute table. The link is made by the category values of the features in that layer which have to have corresponding entries in the specified key column of the table. Using v.db.connect connections between layers and attribute tables can be listed or maintained.</p><p>In most modules, the first layer (<em>layer=1</em>) is active by default. Using <em>layer=-1</em> one can access all layers.</p></li><li><p><strong>SQL support</strong></p><p>The DBF driver provides only very limited SQL support (as DBF is not an SQL DB) while the other DBMS backends (such as SQLite, PostgreSQL, MySQL etc) provide full SQL support since the SQL commands are sent directly to the DBMI. SQL commands can be directly executed with db.execute, db.select and the other db.* modules.</p></li>
</ul><p>When creating vector maps from scratch, in general an attribute table must be created and the table must be populated with one row per category (using v.to.db). However, this can be performed in a single step using v.db.addtable along with the definition of table column types. Column adding and dropping can be done with v.db.addcol and v.db.dropcol. A table column can be renamed with v.db.renamecol. To drop a table from a map, use v.db.droptable. Values in a table can be updated with v.db.update. Tables can be joined with with v.db.join.</p>
<h3>Editing vector attributes</h3>
<p>To manually edit attributes of a table, the map has to be queried in 'edit mode' using d.what.vect. To bulk process attributes, it is recommended to use SQL (db.execute).</p>
<h3>Geometry operations</h3>
<p>The module v.in.region saves the current region boundary into a vector area. Split vector lines can be changes to polylines by v.build.polylines. Long lines can be split by v.split and v.segment. Buffer and circles can be generated with v.buffer and v.parallel. v.generalize is module for generalization of GRASS vector maps. 2D vector maps can be changed to 3D using v.extrude. If needed, the spatial position of vector points can be perturbed by v.perturb. The v.type command changes between vector types (see list above). Projected vector maps can be reprojected with v.proj. Unprojected maps can be geocoded with v.transform. Triangulation and point-to-polygon conversions can be done with &lt;a href="v.delaunay.html"&gt;v.delaunay, v.hull, and v.voronoi. The v.random command generated random points.</p>
<h3>Vector overlays and selections</h3>
<p>Geometric overlay of vector maps is done with v.patch, v.select, depending on the combination of vector types. Vectors can be extracted with v.extract and reclassified with v.reclass.</p>
<h3>Vector statistics</h3>
<p>Statistics can be generated by v.qcount, v.normal, and v.univar. Distances between vector objects are calculated with v.distance.</p>
<h3>Vector-Raster-DB conversion</h3>
<p>The v.to.db transfers vector information into database tables. With v.to.points, v.to.rast3 conversions are performed.</p>
<h3>Vector queries</h3>
<p>Vector maps can be queried with v.what and v.what.vect.</p>
<h3>Vector-Raster queries</h3>
<p>Raster values can be transferred to vector maps with v.what.rast and v.rast.stats.</p>
<h3>Vector network analysis</h3>
<p>GRASS provides support for vector network analysis. The following algorithms are implemented:</p><ul>
<li><p> Network preparation and maintenance: v.net</p></li><li><p> Shortest path: d.path and v.net.path</p></li><li><p> Allocation of sources (create subnetworks, e.g. police station zones): v.net.alloc</p></li><li><p> Iso-distances (from centers): v.net.iso</p></li><li><p> Minimum Steiner trees (star-like connections, e.g. broadband cable connections): v.net.steiner</p></li><li><p> Traveling salesman (round trip): v.net.salesman</p></li>
</ul><p>--b). Both directions are supported, most network modules provide parameters to assign attribute columns to the forward and backward direction.</p>
<h3>Vector networks: Linear referencing system (LRS)</h3>
<p>LRS uses linear features and distance measured along those features to positionate objects. There are the commands v.lrs.create to create a linear reference system, v.lrs.label to create stationing on the LRS, v.lrs.segment to create points/segments on LRS, and v.lrs.where to find line id and real km+offset for given points in vector map using linear reference system.</p><p>The LRS tutorial explains further details.</p>
<h3>Interpolation and approximation</h3>
<p>Some of the vector modules deal with spatial or volumetric approximation (also called interpolation): v.kernel, v.surf.idw, v.surf.rst, and v.vol.rst.</p>
<h3>Lidar data processing</h3>
<p>Lidar point clouds (first and last return) are imported from text files  with &lt;a href="v.in.ascii.html"&gt;v.in.ascii (use the -b flag to not build topology). Outlier detection is done with v.outlier on both first and last return data. Then, with v.lidar.edgedetection, edges are detected from last return data. The building are generated by v.lidar.growing from detected edges.  The resulting data are post-processed with v.lidar.correction. Finally, the DTM and DSM are generated with v.surf.bspline (DTM: uses the 'v.lidar.correction' output; DSM: uses last return output from outlier detection).</p>
<h3>See also</h3>
<ul>
<li><p>Introduction to GRASS database management</p></li><li><p>Introduction to GRASS raster map processing</p></li><li><p>Introduction to GRASS 3D raster map (voxel) processing</p></li>
</ul><p>full index</p><p>© 2008-2012 GRASS Development Team</p>

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="vector.1grass.html"><span aria-hidden="true">&larr;</span> vector.1grass: None</a></li>
   <li class="next"><a href="wxGUI.Attribute_Table_Manager.1grass.html">wxGUI.Attribute_Table_Manager.1grass: Wxgui.attribute_table_manager <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

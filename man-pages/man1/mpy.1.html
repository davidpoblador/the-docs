<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>mpy: Message passing yorick</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Message passing yorick">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="mpy (1) manual">
  <meta name="twitter:description" content="Message passing yorick">
  <meta name="twitter:image" content="https://www.carta.tech/images/yorick-mpy-common-mpy-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/mpy.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="mpy (1) manual" />
  <meta property="og:description" content="Message passing yorick" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/yorick-mpy-common-mpy-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">mpy<small> (1)</small></h1>
        <p class="lead">Message passing yorick</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/mpy.1.html">
      <span itemprop="name">mpy: Message passing yorick</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/yorick-mpy-common/">
      <span itemprop="name">yorick-mpy-common</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/mpy.1.html">
      <span itemprop="name">mpy: Message passing yorick</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>mpirun -np mp_size <strong>mpy</strong> [ -j <em>pfile1.i</em> [ -j <em>pfile2.i</em> [ ... ]]] [ -i <em>file1.i</em> [ -i <em>file2.i</em> [ ... ]]]</p><p>mpirun -np mp_size <strong>mpy</strong> -batch <em>file.i</em></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><em>Yorick</em> is an interpreted language like Basic or Lisp, but far faster. See <em>yorick</em> (1) to learn more about it.</p><p><em>Mpy</em> is a parallel version of <em>Yorick</em> based on the Message Passing Interface (MPI). The exact syntax for launching a parallel job depends on your MPI environment. It may be necessary to launch a special daemon before calling <em>mirun</em> or an equivalent command.</p><h3>Explanations</h3>
<p>The mpy package interfaces yorick to the MPI parallel programming library.  MPI stands for Message Passing Interface; the idea is to connect multiple instances of yorick that communicate among themselves via messages.  Mpy can either perform simple, highly parallel tasks as pure interpreted programs, or it can start and steer arbitrarily complex compiled packages which are free to use the compiled MPI API. The interpreted API is not intended to be an MPI wrapper; instead it is stripped to the bare minimum.</p><p>This is version 2 of mpy (released in 2010); it is incompatible with version 1 of mpy (released in the mid 1990s), because version 1 had numerous design flaws making it very difficult to write programs free of race conditions, and impossible to scale to millions of processors. However, you can run most version 1 mpy programs under version 2 by doing mp_include,"mpy1.i" before you mp_include any file defining an mpy1 parallel task (that is before any file containg a call to mp_task.)</p>
<h3>Usage notes</h3>
<p>The MPI environment is not really specified by the standard; existing environments are very crude, and strongly favor non-interactive batch jobs.  The number of processes is fixed before MPI begins; each process has a rank, a number from 0 to one less than the number of processes.  You use the rank as an address to send messages, and the process receiving the message can probe to see which ranks have sent messages to it, and of course receive those messages.</p><p>A major problem in writing a message passing program is handling events or messages arriving in an unplanned order.  MPI guarantees only that a sequence of messages send by rank A to rank B will arrive in the order sent.  There is no guarantee about the order of arrival of those messages relative to messages sent to B from a third rank C. In particular, suppose A sends a message to B, then A sends a message to C (or even exchanges several messages with C) which results in C sending a message to B.  The message from C may arrive at B before the message from A.  An MPI program which does not allow for this possibility has a bug called a "race condition".  Race conditions may be extremely subtle, especially when the number of processes is large.</p><p>The basic mpy interpreted interface consists of two variables:</p>
<pre>
  mp_size   = number of proccesses
  mp_rank   = rank of this process
</pre>
<p>and four functions:</p>
<pre>
  mp_send, to, msg;         // send msg to rank "to"
  msg = mp_recv(from);      // receive msg from rank "from"
  ranks = mp_probe(block);  // query senders of pending messages
  mp_exec, string;          // parse and execute string on every rank
</pre>
<p>You call mp_exec on rank 0 to start a parallel task.  When the main program thus created finishes, all ranks other than rank 0 return to an idle loop, waiting for the next mp_exec.  Rank 0 picks up the next input line from stdin (that is, waits for input at its prompt in an interactive session), or terminates all processes if no more input is available in a batch session.</p><p>The mpy package modifies how yorick handles the #include parser directive, and the include and require functions.  Namely, if a parallel task is running (that is, a function started by mp_exec), these all become collective operations.  That is, rank 0 reads the entire file contents, and sends the contents to the other processes as an MPI message (like mp_exec of the file contents).  Every process other than rank 0 is only running during parallel tasks; outside a parallel task when only rank 0 is running (and all other ranks are waiting for the next mp_exec), the #include directive and the include and require functions return to their usual serial operation, affecting only rank 0.</p><p>When mpy starts, it is in parallel mode, so that all the files yorick includes when it starts (the files in Y_SITE/i0) are included as collective operations.  Without this feature, every yorick process would attempt to open and read the startup include files, overloading the file system before mpy ever gets started.  Passing the contents of these files as MPI messages is the only way to ensure there is enough bandwidth for every process to read the contents of a single file.</p><p>The last file included at startup is either the file specified in the -batch option, or the custom.i file.  To avoid problems with code in custom.i which may not be safe for parallel execution, mpy does not look for custom.i, but for custommp.i instead.  The instructions in the -batch file or in custommp.i are executed in serial mode on rank 0 only.  Similarly, mpy overrides the usual process_argv function, so that -i and other command line options are processed only on rank 0 in serial mode.  The intent in all these cases is to make the -batch or custommp.i or -i include files execute only on rank 0, as if you had typed them there interactively.  You are free to call mp_exec from any of these files to start parallel tasks, but the file itself is serial.</p><p>An additional command line option is added to the usual set:</p>
<pre>
  mpy -j somefile.i
</pre>
<p>includes somefile.i in parallel mode on all ranks (again, -i other.i includes other.i only on rank 0 in serial mode).  If there are multiple -j options, the parallel includes happen in command line order.  If -j and -i options are mixed, however, all -j includes happen before any -i includes.</p><p>As a side effect of the complexity of include functions in mpy, the autoload feature is disabled; if your code actually triggers an include by calling an autoloaded function, mpy will halt with an error.  You must explicitly load any functions necessary for a parallel tasks using require function calls themselves inside a parallel task.</p><p>The mp_send function can send any numeric yorick array (types char, short, int, long, float, double, or complex), or a scalar string value.  The process of sending the message via MPI preserves only the number of elements, so mp_recv produces only a scalar value or a 1D array of values, no matter what dimensionality was passed to mp_send.</p><p>The mp_recv function requires you to specify the sender of the message you mean to receive.  It blocks until a message actually arrives from that sender, queuing up any messages from other senders that may arrive beforehand.  The queued messages will be retrieved it the order received when you call mp_recv for the matching sender.  The queuing feature makes it dramatically easier to avoid the simplest types of race condition when you are write interpreted parallel programs.</p><p>The mp_probe function returns the list of all the senders of queued messages (or nil if the queue is empty).  Call <strong>mp_probe</strong>(0) to return immediately, even if the queue is empty.  Call <strong>mp_probe</strong>(1) to block if the queue is empty, returning only when at least one message is available for mp_recv.  Call <strong>mp_probe</strong>(2) to block until a new message arrives, even if some messages are currently available.</p><p>The mp_exec function uses a logarithmic fanout - rank 0 sends to F processes, each of which sends to F more, and so on, until all processes have the message.  Once a process completes all its send operations, it parses and executes the contents of the message.  The fanout algorithm reaches N processes in log to the base F of N steps. The F processes rank 0 sends to are ranks 1, 2, 3, ..., F.  In general, the process with rank r sends to ranks r*F+1, r*F+2, ..., r*F+F (when these are less than N-1 for N processes).  This set is called the "staff" of rank r.  Ranks with r&gt;0 receive the message from rank (r-1)/F, which is called the "boss" of r.  The mp_exec call interoperates with the mp_recv queue; in other words, messages from a rank other than the boss during an mp_exec fanout will be queued for later retrieval by mp_recv.  (Without this feature, any parallel task which used a message pattern other than logarithmic fanout would be susceptible to race conditions.)</p><p>The logarithmic fanout and its inward equivalent are so useful that mpy provides a couple of higher level functions that use the same fanout pattern as mp_exec:</p>
<pre>
  mp_handout, msg;
  total = mp_handin(value);
</pre>
<p>To use mp_handout, rank 0 computes a msg, then all ranks call mp_handout, which sends msg (an output on all ranks other than 0) everywhere by the same fanout as mp_exec.  To use mp_handin, every process computes value, then calls mp_handin, which returns the sum of their own value and all their staff, so that on rank 0 mp_handin returns the sum of the values from every process.</p><p>You can call mp_handin as a function with no arguments to act as a synchronization; when rank 0 continues after such a call, you know that every other rank has reached that point.  All parallel tasks (anything started with mp_exec) must finish with a call to mp_handin, or an equivalent guarantee that all processes have returned to an idle state when the task finishes on rank 0.</p><p>You can retrieve or change the fanout parameter F using the mp_nfan function.  The default value is 16, which should be reasonable even for very large numbers of processes.</p><p>One special parallel task is called mp_connect, which you can use to feed interpreted command lines to any single non-0 rank, while all other ranks sit idle.  Rank 0 sits in a loop reading the keyboard and sending the lines to the "connected" rank, which executes them, and sends an acknowledgment back to rank 0.  You run the mp_disconnect function to complete the parallel task and drop back to rank 0.</p><p>Finally, a note about error recovery.  In the event of an error during a parallel task, mpy attempts to gracefully exit the mp_exec, so that when rank 0 returns, all other ranks are known to be idle, ready for the next mp_exec.  This procedure will hang forever if any one of the processes is in an infinite loop, or otherwise in a state where it will never call mp_send, mp_recv, or mp_probe, because MPI provides no means to send a signal that interrupts all processes.  (This is one of the ways in which the MPI environment is "crude".)  The rank 0 process is left with the rank of the first process that reported a fault, plus a count of the number of processes that faulted for a reason other than being sent a message that another rank had faulted.  The first faulting process can enter dbug mode via mp_connect; use mp_disconnect or dbexit to drop back to serial mode on rank 0.</p>
<h3>Options</h3>

<dl class='dl-vertical'>
  <dt>
    <p>-j<em>&nbsp;file.i</em></p>
  </dt>
  <dd>
    <p>includes the Yorick source file <em>file.i</em> as mpy starts in parallel mode on all ranks.  This is equivalent to the mp_include function after mpy has started.</p>
  </dd>
  <dt>
    <p>-i<em>&nbsp;file.i</em></p>
  </dt>
  <dd>
    <p>includes the Yorick source file <em>file.i</em> as mpy starts, in serial mode.  This is equivalent to the #include directive after mpy has started.</p>
  </dd>
  <dt>
    <p>-batch<em>&nbsp;file.i</em></p>
  </dt>
  <dd>
    <p>includes the Yorick source file <em>file.i</em> as mpy starts, in serial mode.  Your customization file custommp.i, if any, is <em>not</em> read, and mpy is placed in batch mode.  Use the help command on the batch function (help, batch) to find out more about batch mode.  In batch mode, all errors are fatal; normally, mpy will halt execution and wait for more input after an error.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>David H. Munro, Lawrence Livermore National Laboratory</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILES</h2>
        <div class="sectioncontent">
<p>Mpy uses the same files as yorick, except that custom.i is replaced by custommp.i (located in /etc/yorick/mpy/ on Debian based systems) and the Y_SITE/i-start/ directory is ignored.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO mpy&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man1/yorick.1.html"><strong>yorick</strong>(1)</a></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="mpv.1.html"><span aria-hidden="true">&larr;</span> mpv.1: A media player</a></li>
   <li class="next"><a href="mrbc.1.html">mrbc.1: Mruby compiler <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

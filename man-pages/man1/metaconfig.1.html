<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>metaconfig: A configure script generator</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="A configure script generator">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="metaconfig (1) manual">
  <meta name="twitter:description" content="A configure script generator">
  <meta name="twitter:image" content="https://www.carta.tech/images/dist-metaconfig-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/metaconfig.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="metaconfig (1) manual" />
  <meta property="og:description" content="A configure script generator" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/dist-metaconfig-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">metaconfig<small> (1)</small></h1>
        <p class="lead">A configure script generator</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/metaconfig.1.html">
      <span itemprop="name">metaconfig: A configure script generator</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/dist/">
      <span itemprop="name">dist</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/metaconfig.1.html">
      <span itemprop="name">metaconfig: A configure script generator</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>metaconfig</strong> [ -<strong>dhkmostvwGMV</strong> ] [ -<strong>L </strong><em>dir</em> ]</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><em>Metaconfig</em> is a program that generates Configure scripts. If you don't know what a Configure script is, please skip to the <strong>TUTORIAL</strong> section of this manual page. If you want a full (formal) description of the way to use <em>metaconfig</em> and its units, please look at the <strong>REFERENCE</strong> section. The following is a quick introduction and reference for knowledgeable users.</p><p><strong>Metaconfig</strong> operates from set of <em>units</em> which define everything that metaconfig knows about portability. Each unit is self-contained, and does not have to be registered anywhere other than by inclusion in either the public U directory or your private U directory. If the dist package (of which metaconfig is a part) is installed in LIB, then the public U directory is LIB/dist/mcon/U. On this machine, the LIB directory is /usr/share/dist. Your private U directory, if you have one, is in the top level directory of your package. Before you can run <em>metaconfig</em> you must do a several things:</p><ul>
<li><p>Create a .package file in the package's top level directory by running <em>packinit</em>. This program will ask you about your package and remember what you tell it so that all the dist programs can be smart.</p></li><li><p>Consult the Glossary (in LIB/dist/mcon) and write your shell scripts and C programs in terms of the symbols that metaconfig knows how to define. You don't need to tell metaconfig which symbols you used, since metaconfig will figure that out for you.</p></li><li><p>Generate any .SH scripts needed to write Makefiles or shell scripts that will depend on values defined by Configure. There is a program called <em>makeSH</em> that will help you convert a plain script into a script.SH template; some editing will still need to be performed on the resulting .SH file to move the variable configuration part in the top part of the script (see inline comments generated by <em>makeSH</em> within your .SH file).</p></li><li><p>Create a MANIFEST.new file in your top level directory that lists all the files in your package. This file will remain private and will not be part of the final distribution. (As a convenience, the MANIFEST file will be used by <em>metaconfig</em> if there is no MANIFEST.new file yet.) The filename should be the first field on each line. After some whitespace you can add a short comment describing your file. Only source files should be listed in there. The special file <em>patchlevel.h</em> (which is handled and maintained by the patching tools -- see <strong>pat</strong>(1)) should be part of the MANIFEST.new file, but may be silently ignored by some tools. As a rule of thumb, only files maintained by RCS should be listed in there, the <em>patchlevel.h</em> file being one important exception.</p></li><li><p>Optionally, you may wish to create a MANIFEST file, which will be an exported version of your MANIFEST.new. That file must be made part of the release, i.e. listed in both your MANIFEST.new and MANIFEST itself. One of the <em>metaconfig</em> units knows about this file and will force Configure to perform a release check, ensuring all the files listed there are part of the distribution. The MANIFEST and MANIFEST.new files should be distinct, not links.</p></li><li><p>Copy any .U files that you want to modify to your private U directory. Any .U files in your private U directory will be used in preference to the one in the public U directory. For example, one way to force inclusion of any unit is to copy the End.U file to your .U directory and add the name of the unit you want as a dependency on the end of the ?MAKE: line. Certain units can ONLY be forced in this way, namely those of the form Warn_*.U and Chk_*.U. You can also customize certain default Configure variables by copying Myinit.U to your package's private U directory and setting the variables in that unit.</p></li>
</ul><p>Now you are ready to run <em>metaconfig</em>. That will create a <em>Configure</em> file, and optionally a <em>config_h.SH</em> file (if your sources make any use of C symbols). The generated files will automatically be added to your MANIFEST.new if necessary. Do not forget to update your MANIFEST file though.</p><p>In order to create new units, do the following:</p><ul>
<li><p>Copy a similar unit to a new .U file. The name you choose should be the name of a variable generated by the unit, although this is only a convenience for you, not a requirement. It should be 12 or less characters to prevent filename chopping. Actually, it should probably be 10 or less so that those who want to use RCS can have a .U,v on the end without chopping. Metaconfig uses the case of the first letter to determine if any variable is actually produced by this unit, so don't Capitalize your unit name if it is supposed to produce a shell variable.</p></li><li><p>Edit the new .U file to do what you want. The first ?MAKE: line indicates the dependencies; before the final list colon all the variables this unit defines, and after the final colon all the variables (or other units) on which this unit depends. It is very important that these lists be accurate. If a dependency is optional and a default value can be used, you should prefix the dependency with a '+' sign. The corresponding unit will not be loaded to compute the symbol, unless really required by another unit.</p></li><li><p>To the extent possible, parameterize your unit based on shell variable defined on ?INIT: lines. This will move the variable definitions up to the Init.U unit, where they can be overridden by definitions in Myinit.U, which is included after Init.U.</p></li><li><p>Add the definition of any C symbols desired as ?H: lines. A line beginning with ?H:?%&lt;: in the .U file will be added to the eventual config.h file if and only if metaconfig decides that this unit is needed. The %&lt; stands for the unit's name, which happens to be the name of the file too (without .U) if you followed the convention. Always put a comment on each ?H: line in case one of the variable substitutions earlier on the line starts a comment without finishing it. Any shell variable starting with d_ may do this, so beware. If you ommit the ?%&lt;:, then metaconfig will try to intuit the symbol whose definition is needed prior any inclusion in config.h.</p></li><li><p>Add glossary definitions as ?S: lines for shell variables and ?C: lines for C preprocessor variables. See a current unit for examples. It is VERY important to start each entry with a left justified symbol name, and end each entry with a ?C:. or ?S:. line.  The algorithm that translates C preprocessor symbol entries for the Glossary into comments for config.h depends on this.</p></li><li><p>Make sure the order of all your ? lines is right.  The correct order is:</p>
<dl class='dl-vertical'>
  <dt>
    <p>?RCS: and ?X:</p>
  </dt>
  <dd>
    <p>basically just comments</p>
  </dd>
  <dt>
    <p>?MAKE:</p>
  </dt>
  <dd>
    <p>metaconfig dependencies</p>
  </dd>
  <dt>
    <p>?Y:</p>
  </dt>
  <dd>
    <p>unit layout directive</p>
  </dd>
  <dt>
    <p>?S:</p>
  </dt>
  <dd>
    <p>glossary shell definitions</p>
  </dd>
  <dt>
    <p>?C:</p>
  </dt>
  <dd>
    <p>glossary C definitions</p>
  </dd>
  <dt>
    <p>?H:</p>
  </dt>
  <dd>
    <p>config.h definitions</p>
  </dd>
  <dt>
    <p>?M:</p>
  </dt>
  <dd>
    <p>confmagic.h definitions</p>
  </dd>
  <dt>
    <p>?W:</p>
  </dt>
  <dd>
    <p>wanted symbols</p>
  </dd>
  <dt>
    <p>?V:</p>
  </dt>
  <dd>
    <p>visible symbols</p>
  </dd>
  <dt>
    <p>?F:</p>
  </dt>
  <dd>
    <p>files created by this unit</p>
  </dd>
  <dt>
    <p>?T:</p>
  </dt>
  <dd>
    <p>temporary shell symbols used</p>
  </dd>
  <dt>
    <p>?D:</p>
  </dt>
  <dd>
    <p>optional dependencies default value</p>
  </dd>
  <dt>
    <p>?O:</p>
  </dt>
  <dd>
    <p>used to mark obsolete units</p>
  </dd>
  <dt>
    <p>?LINT:</p>
  </dt>
  <dd>
    <p>metalint hints</p>
  </dd>
  <dt>
    <p>?INIT:</p>
  </dt>
  <dd>
    <p>shell symbols initializations</p>
  </dd>

</dl>
</li>
</ul><p>Here is an example to show the ordering of the lines and the various formats allowed:</p>
<pre>
?RCS: $RCS-Id$
?RCS: Copyright information
?RCS: $RCS-Log$
?X:
?X: A contrived example
?X:
?MAKE:d_one two: three +four Five
?MAKE:	-pick add $@ %&lt;
?Y:DEFAULT
?S:d_one:
?S:	First shell symbol, conditionally defines ONE.
?S:.
?S:two:
?S:	Second shell symbol, value for TWO.
?S:.
?C:ONE:
?C:	First C symbol.
?C:.
?C:TWO:
?C:	Second C symbol.
?C:.
?H:#$d_one ONE	/**/
?H:#define TWO "$two"
?H:#$d_one ONE_TWO "$two"
?H:.
?M:flip: HAS_FLIP
?M:#ifndef HAS_FLIP
?M:#define flip(x) flop(x)
?M:#endif
?M:.
?W:%&lt;:one_two
?V:p_one p_two:p_three
?F:file ./ftest !tmp
?T:tmp var
?D:two='undef'
?LINT:change three
?INIT:two_init='2'
: shell code implementing the unit follows
p_one='one'
p_two='two'
p_three=""

</pre>
<p>Let me state it one more time: the above unit definition is a <em>fake</em> one to only show the different possibilities. Such a unit would serve little purpose anyway... Some more advanced features are not described here. Please refer to the <strong>REFERENCE</strong> section for more complete information.</p><ul>
<li><p>Put the unit into the public or private U directory as appropriate.</p></li><li><p>Rerun <em>metaconfig</em>.</p></li><li><p>Send your unit to ram@acri.fr (Raphael Manfredi) for inclusion in the master copy, if you think it's of general interest.</p></li>
</ul><p>In order to add a new program to be located:</p><ul>
<li><p>Edit Loc.U, and add the name of the program both to the ?MAKE: line (between the two colons) and to either loclist or trylist (depending on whether the program is mandatory or not).</p></li><li><p>Rerun metaconfig.</p></li><li><p>Send your unit to me for inclusion in the master copy, if you think it's of general interest.</p></li>
</ul><p>Notes for writing .U files:</p><ul>
<li><p>Always use "rm -f" because there are systems where rm is interactive by default.</p></li><li><p>Do not use "set -- ..." because '--' does not work with every shell. Use "set x ...; shift".</p></li><li><p>Do not use "unset ENV" since unset is not fully portable.  Say "ENV=''" instead.</p></li><li><p>Always use echo " " (with a space) because of Eunice systems.</p></li><li><p>Only use <strong>test</strong> with -r, -w, -f or -d since those are the only portable switches. In particular, avoid "test -x".</p></li><li><p>Use only programs that came with V7, so that you know everyone has them.</p></li><li><p>Use $contains when you want to grep conditionally, since not all greps return a reasonable status. Be sure to redirect the output to /dev/null, by using '&gt;/dev/null 2&gt;&1'.</p></li><li><p>Use "if test" rather than "if [...]" since not every sh knows the latter construct.</p></li><li><p>Use the myread script for inputs so that they can do shell escapes and default evaluation.  The general form is case "$grimble" in '') dflt=452;; *) dflt="$grimble";; esac rp='How many grimbles do you have?' . ./myread grimble="$ans"</p></li><li><p>Use the getfile script when asking for a file pathname in order to have optional ~name expansion and sanity checks. See the Getfile.U unit for a full decription.</p></li><li><p>Always put a 	$startsh at the top of every generated script that is going to be launched or sourced by <em>Configure</em>.</p></li><li><p>Never assume common UNIX-isms like the fact that an object file ends with a <em>.o</em> and that a library name ends with <em>.a</em>. Use the <em>$_o</em> and <em>$_a</em> variables instead (see Unix.U).</p></li><li><p>When doing a compile-link-execute test, always write it like this: $cc $ccflags $ldflags try.c -o try $libs because some systems require that linking flags be specified before the compiled target (with the exception of trailing linking libraries).</p></li><li><p>Issue important messages on file descriptor #4, by using '&gt;&4' to redirect output. Only those messages will appear when the <strong>-s</strong> switch is given to <em>Configure</em> on the command line (silent mode).</p></li><li><p>Always try to determine whether a feature is present in the most specific way--don't say "if bsd" when you can grep libc.  There are many hybrid systems out there, and each feature should stand or fall by itself.</p></li><li><p>Always try to determine whether a feature is present in the most general way, so that other packages can use your unit.</p></li><li><p>When in doubt, set a default and ask.  Don't assume anything.</p></li><li><p>If you think the user is wrong, allow for the fact that he may be right. For instance, he could be running Configure on a different system than he is going to use the final product on.</p></li>
</ul><p>Metaconfig reserves the following names in your directory, and if you use such a name it may get clobbered or have other unforeseen effects:  .MT/* Configure Wanted Obsolete configure config_h.SH confmagic.h U/* MANIFEST.new Additionally, Configure may clobber these names in the directory it is run in: UU/* config.sh config.h</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONS</h2>
        <div class="sectioncontent">
<p>The following options are recognized by <em>metaconfig</em>:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>-d</strong></p>
  </dt>
  <dd>
    <p>Turn on debug mode. Not really useful unless you are debugging <em>metaconfig</em> itself.</p>
  </dd>
  <dt>
    <p><strong>-h</strong></p>
  </dt>
  <dd>
    <p>Print help message and exit.</p>
  </dd>
  <dt>
    <p><strong>-k</strong></p>
  </dt>
  <dd>
    <p>Keep temporary directory, so that you may examine the working files used by <em>metaconfig</em> to build your <em>Configure</em> script. Useful only when debugging the units.</p>
  </dd>
  <dt>
    <p><strong>-m</strong></p>
  </dt>
  <dd>
    <p>Assume lots of memory and swap space. This will speed up symbol lookup in source files by a significant amount of time, at the expense of memory consumption...</p>
  </dd>
  <dt>
    <p><strong>-o</strong></p>
  </dt>
  <dd>
    <p>Map obsolete symbols on new ones. Use this switch if you still have some obsolete symbols in your source code and do not want (or cannot) remove them for now. The obsolete symbols are otherwise ignored, although that will give you a warning from <em>metaconfig</em>.</p>
  </dd>
  <dt>
    <p><strong>-s</strong></p>
  </dt>
  <dd>
    <p>Turn silent mode on.</p>
  </dd>
  <dt>
    <p><strong>-t</strong></p>
  </dt>
  <dd>
    <p>Trace symbols as they are found.</p>
  </dd>
  <dt>
    <p><strong>-v</strong></p>
  </dt>
  <dd>
    <p>Turn verbose mode on.</p>
  </dd>
  <dt>
    <p><strong>-w</strong></p>
  </dt>
  <dd>
    <p>Assume Wanted file is up-to-date. This will skip the time and memory consuming phase of source code scanning, looking for known symbols. Use it only when you know your source file have not changed with respect to the pool of <em>metaconfig</em> symbols used.</p>
  </dd>
  <dt>
    <p><strong>-G</strong></p>
  </dt>
  <dd>
    <p>Also provide a GNU <em>configure</em>-like front end to the generated <em>Configure</em> script, to be included in the distribution as well. This is only a wrapper around the <em>Configure</em> script naturally, but it lets people familiar with the GNU tool to not be lost when facing a new distribution.</p>
  </dd>
  <dt>
    <p><strong>-L</strong><em> dir</em></p>
  </dt>
  <dd>
    <p>Override default library location. Normally only useful for metaconfig maintainers to locally use the units being developed instead of the publicly available ones. The <em>dir</em> specified is the one containing the units <em>U</em> directory.</p>
  </dd>
  <dt>
    <p><strong>-M</strong></p>
  </dt>
  <dd>
    <p>Allow production of a <em>confmagic.h</em> file to automagically remap some well-known symbols to some other alternative, like <em>bcopy</em>() being remapped transparently to <em>memcpy()</em> when not available. This option is turned on automatically when a <em>confmagic.h</em> file exists in the top-level directory. Simply remove that file if you wish to disable this option permanently.</p>
  </dd>
  <dt>
    <p><strong>-V</strong></p>
  </dt>
  <dd>
    <p>Print version number and exit.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TUTORIAL</h2>
        <div class="sectioncontent">
<p>This (long) section is an introduction to <em>metaconfig</em>, in which we will learn all the basics. If you already know how to use <em>metaconfig</em>, you may safely skip to the next section.</p><h3>Overview</h3>
<p>Usually when you want to get some source package to compile on a given platform you have to edit the main Makefile (assuming there is one!), choose a C compiler, make sure you have the proper libraries, and then fire the <em>make</em> command. If the package is reasonably well written, it will compile (without a warning being an option :-). In itself, the last sentence is a real performance, since given the variety of UNIX platforms available today and the diversity of flavours, that means the author of the package has gone into deep trouble to figure out the right choices given some standard trial, guessing and messing around with system includes and types.</p><p>However, despite all his talent, the author cannot possibly know that some system has a broken system call, or that some system structure lacks one otherwise standard field, or simply whether a given include file exists or not. And I'm not considering the implicit assumptions, like the type returned by the <em>malloc()</em> function or the presence of the <em>rename()</em> system call to name a few. But that knowledge is necessary to achieve real portability.</p><p>Now let's not abuse ourselves. Using that information requires greater skills, yet it can lead to more portable programs since it is then written in a system-independant fashion and relies only on the fact that some assumption is true or false on a particular system, each assumption being unrelated with each other. That is to say, we do not say: We're on a BSD system or we are on a USG system. That's too fuzzy anyway nowadays. No, we want to say to the source code: this system does not have the <em>rename()</em> system call and <em>malloc()</em> returns a <em>(void *)</em> value.</p><p>Metaconfig is a tool that will let you do just that, with the additional benefit of not having to hand-edit the Makefile if all goes well. By running <em>metaconfig</em>, you create a shell script named <em>Configure</em>. Lots of efforts have been devoted to the Configure script internals to ensure it will run on 99% of the existing shells available as of this writing. Configure will probe the target system, asking questions when in doubt and gather all the answers in one single shell file, which in turn can be used to automatically generate configured Makefiles and C include files.</p><p>There is only a limited (but quite large) set of symbols available for your shell scripts and C programs. They are all documented in the Glossary file. All you need to do is learn about them and start using them to address portability and configuration problems. Then, by running <em>metaconfig</em>, a suitable Configure script will be generated for your package.</p><p>The Configure script is built out several units (more than 300), each unit being responsible for defining a small number of shell and/or C symbols. Units are assembled together at the final stage, honoring the dependency graph (one unit may need the result of several other units which are then placed before in the script).</p>
<h3>Symbols</h3>
<p>Symbols are the most important thing in the <em>metaconfig</em> world. They are the smallest recognized entity, usually a word, and can be granted a value at the end of the Configure execution. For instance, the C pre-processor symbol <em>HAS_RENAME</em> is a <em>metaconfig</em> symbol that is guranteed to be defined if, and only if, the <em>rename()</em> system call is present. Likewise, the <em>$ranlib</em> shell variable will be set to either ':' or 'ranlib' depending on whether the call to the <em>ranlib</em> program is needed to order a library file. How this works is not important for now, what is important is to understand that those symbols are given a <em>life</em> (i.e. a value) upon <em>Configure</em> execution.</p><p>Using symbols is relatively straightforward. In a C source file, you simply use the symbol value, as a pre-processor directive (for instance an: <em>#ifdef</em> HAS_RENAME) or, if the symbol value is a string, directly as you would use a macro in C. And in a shell file or a Makefile, you may reference a shell symbol directly.</p><p>Actually, I'm lying, because that's not completely as magic as the previous paragraph could sound. In a C file, you need to include the Configure-produced <em>config.h</em> file, and you must wrap your shell script or Makefile in a .SH file and you may reference the shell symbol only in the variable substitution part of that .SH file. More on this later.</p>
<h3>Source Files</h3>
<p>Symbols may only appear in a limited set of source files, because <em>metaconfig</em> will only scan those when looking for known symbols, trying to figure out which units it will need. You may use C symbols in C source files, i.e. files with a <em>.c</em>, <em>.h</em>, <em>.y</em> or <em>.l</em> extension, and shell symbols are looked for only in .SH files.</p><p>In order to get the value of a symbol, a C file needs to include the special <em>config.h</em> file, which is produced by <em>Configure</em> when C symbols are present. And .SH files are run through a shell, producing a new file. However, in the top section of the .SH file, the special <em>config.sh</em> file (also produced by running <em>Configure</em>) is sourced, and variable substitutions apply. Actually, <em>config.h</em> is produced by running the <em>metaconfig</em>-produced <em>config_h.SH</em> file, again using variable substitution. So we're going to look at that a little more closely since this is the heart of the whole <em>configuration</em> scheme...</p>
<h3>Variable Substitution</h3>
<p>There is shell construct called <em>here document</em> which enables a command to take an input specified within the script itself. That input is interpreted by the shell as a double-quoted string or a single quoted string depending on the form of the here document specification.</p><p>To specify a here document, the '&lt;&lt;' token is used, followed by a single identifier. From then on, the remaining script lines form the input for the command, until the here document is found on a line by itself. Shell substitution (including shell variable substitutions) is done unless the identifier is surrounded by single quotes. For instance: var='first' tar='second' echo "--&gt; first here document:" cat &lt;&lt;EOM var='$var' tar='$tar' EOM echo "--&gt; second here document:" cat &lt;&lt;'EOM' echo $var echo $tar EOM echo "--&gt; end." will produce, when run through a shell: --&gt; first here document: var='first' tar='second' --&gt; second here document: echo $var echo $tar --&gt; end. The first here document has its content interpreted whilst the second one is output as-is. Both are useful in a .SH script, as we are about to see.</p>
<h3>Using .SH Scripts</h3>
<p>A .SH script is usually produced by running the <em>MakeSH</em> script other an existing file, transforming <em>file</em> into a <em>file.SH</em>. Let's take a single example. Here is a little script (let's call it <em>intsize</em>) which prints a single message, the size of the <strong>int</strong> datatype in C. Unfortunately, it has the value hardwired in it, thusly: #!/bin/sh intsize='4' echo "On this machine, the int type is $intsize bytes" Let's run <em>makeSH</em> on it by typing '<em>makeSH intsize</em>'. We get a single <em>intsize.SH</em> file that looks like this: case $CONFIG in '') 	if test -f config.sh; then TOP=.; 	elif test -f ../config.sh; then TOP=..; 	elif test -f ../../config.sh; then TOP=../..; 	elif test -f ../../../config.sh; then TOP=../../..; 	elif test -f ../../../../config.sh; then TOP=../../../..; 	else 		echo "Can't find config.sh."; exit 1 	fi 	. $TOP/config.sh 	;; esac : This forces SH files to create target in same directory as SH file. : This is so that make depend always knows where to find SH derivatives. case "$0" in */*) cd `expr X$0 : 'X&#92;(.*&#92;)/'` ;; esac echo "Extracting intsize (with variable substitutions)" : This section of the file will have variable substitutions done on it. : Move anything that needs config subs from !NO!SUBS! section to !GROK!THIS!. : Protect any dollar signs and backticks that you do not want interpreted : by putting a backslash in front.  You may delete these comments. $spitshell &gt;intsize &lt;&lt;!GROK!THIS! $startsh !GROK!THIS!</p><p>: In the following dollars and backticks do not need the extra backslash. $spitshell &gt;&gt;intsize &lt;&lt;'!NO!SUBS!' intsize='4' echo "On this machine, the int type is $intsize bytes" !NO!SUBS! chmod 755 intsize $eunicefix intsize The first part of this script (in the <em>case</em> statement) is trying to locate the <em>config.sh</em> file, in order to source it. The <em>$CONFIG</em> variable is false by default, by true when <em>config.sh</em> has been sourced already (which would be the case if this file was executed from within <em>Configure</em> itself, but let's not confuse the issue here).</p><p>Once the <em>config.sh</em> file has been sources, all the shell symbols defined by <em>Configure</em> are set. We know reach a second case statement, used to change the current directory should a path be used to reach this program (for instance if we said '<em>sh ../scripts/intsize.SH</em>', we would first run '<em>cd ../scripts</em>' before continuing). If you do not understand this, don't worry about it.</p><p>Here comes the intersting stuff. This script uses the <em>$spitshell</em> variable, and it's not something we know about...yet. If you look through the Glossary file, you will see that this is a variable known by <em>metaconfig</em>. If you make this file part of your distribution (by including it in the MANIFEST.new file, we'll come back to that later on) and run <em>metaconfig</em>, then the <em>Configure</em> script will determine a suitable value for this variable and it will be set in <em>config.sh</em>. Same goes for <em>$startsh</em> and the mysterious <em>$eunicefix</em> at the end. On a reasonable system, the relevant part of <em>config.sh</em> would look like this: spitshell='cat' startsh='#!/bin/sh' eunicefix=':' Ah! We're getting there. Now it looks familiar. We're facing a single <em>cat</em> command whose input comes from a variable-interpolated here document and whose output is redirected to <em>intsize</em>. The value will be that of <em>$startsh</em>, i.e. '#!/bin/sh'. Fine so far.</p><p>Then we reach the second here document expansion, to get the remaining of the script. This time, the here document symbol is surrounded by single quotes so the contents will be appended verbatim to the <em>intsize</em> file. So, by running '<em>sh intsize.SH</em>', we get the following output: Extracting intsize (with variable substitutions) and by looking at the produced intsize file, we see: #!/bin/sh intsize='4' echo "On this machine, the int type is $intsize bytes" which is exactly what we had at the beginning. So far, it's a no-operation procedure... But, how marvelous! It so happens (pure coincidence, trust me!), that <em>metaconfig</em> knows about the <em>$intsize</em> shell symbol. By moving the initialization of intsize to the variable-interpolated area of the .SH script and initializing it with the <em>Configure</em>-computed value, and removing the now useless comments added by <em>makeSH</em>, we get: case $CONFIG in '') 	if test -f config.sh; then TOP=.; 	elif test -f ../config.sh; then TOP=..; 	elif test -f ../../config.sh; then TOP=../..; 	elif test -f ../../../config.sh; then TOP=../../..; 	elif test -f ../../../../config.sh; then TOP=../../../..; 	else 		echo "Can't find config.sh."; exit 1 	fi 	. $TOP/config.sh 	;; esac case "$0" in */*) cd `expr X$0 : 'X&#92;(.*&#92;)/'` ;; esac echo "Extracting intsize (with variable substitutions)" $spitshell &gt;intsize &lt;&lt;!GROK!THIS! $startsh intsize='$intsize' !GROK!THIS!</p><p>$spitshell &gt;&gt;intsize &lt;&lt;'!NO!SUBS!' echo "On this machine, the int type is $intsize bytes" !NO!SUBS! chmod 755 intsize $eunicefix intsize Of course, running this script through a shell will again output the same script. But if we run <em>Configure</em> on a machine where an <strong>int</strong> is stored as a 64 bits quantity, <em>config.sh</em> will set <em>intsize</em> to 8 and the <em>intsize</em> script will bear the right value and print: On this machine, the int type is 8 bytes which is correct. Congratulations! We have just configured a shell script!!</p>
<h3>Producing config.h</h3>
<p>We can now have a look at the way <em>config.h</em> is produced out of <em>config_h.SH</em>. We know that running <em>Configure</em> produces a <em>config.sh</em> script (how exactly this is done is not strictly relevant here, but for the curious, it's another here document substitution within <em>Configure</em> itself). The <em>config_h.SH</em> itself is built by <em>metaconfig</em> at the same time <em>Configure</em> is, provided you make use of at least one C symbol within your sources.</p><p>Let's have a look at some random <em>config_h.SH</em> file to see what really happens: case $CONFIG in '') 	if test -f config.sh; then TOP=.; 	elif test -f ../config.sh; then TOP=..; 	elif test -f ../../config.sh; then TOP=../..; 	elif test -f ../../../config.sh; then TOP=../../..; 	elif test -f ../../../../config.sh; then TOP=../../../..; 	else 		echo "Can't find config.sh."; exit 1 	fi 	. $TOP/config.sh 	;; esac case "$0" in */*) cd `expr X$0 : 'X&#92;(.*&#92;)/'` ;; esac echo "Extracting config.h (with variable substitutions)" sed &lt;&lt;!GROK!THIS! &gt;config.h -e 's!^#undef!/\*#define!' -e 's!^#un-def!#undef!' /*  * This file was produced by running the config_h.SH script, which  * gets its values from config.sh, which is generally produced by  * running Configure.  *  * Feel free to modify any of this as the need arises.  Note, however,  * that running config.h.SH again will wipe out any changes you've made.  * For a more permanent change edit config.sh and rerun config.h.SH.  */</p><p>/* Configuration time: $cf_time  * Configured by: $cf_by  * Target system: $myuname  */</p><p>#ifndef _config_h_ #define _config_h_</p><p>/* bcopy:  *	This symbol is maped to memcpy if the bcopy() routine is not  *	available to copy strings.  */ /* HAS_BCOPY:  *	This symbol is defined if the bcopy() routine is available to  *	copy blocks of memory. You should not use this symbol under  *	normal circumstances and use bcopy() directly instead, which  *	will get mapped to memcpy() if bcopy is not available.  */ #$d_bcopy HAS_BCOPY	/**/ #ifndef HAS_BCOPY #ifdef bcopy #un-def bcopy #endif #define bcopy(s,d,l) memcpy((d),(s),(l))		/* mapped to memcpy */ #endif</p><p>/* HAS_DUP2:  *	This symbol, if defined, indicates that the dup2 routine is  *	available to duplicate file descriptors.  */ #$d_dup2 HAS_DUP2	/**/</p><p>/* I_STRING:  *	This symbol, if defined, indicates to the C program that it should  *	include &lt;string.h&gt; (USG systems) instead of &lt;strings.h&gt; (BSD systems).  */ #$i_string I_STRING		/**/</p><p>#endif !GROK!THIS! At the top of the file, we recognize the standard .SH construct that we have already studied in detail. Next comes the extraction of the file itself, via a here document with variable substitutions. However, here we do not use a plain <em>cat</em> but a <em>sed</em> instead, since we need to do some further editing on-the-fly. We'll see why later on, so let's forget about it right now.</p><p>We now reach the leading comment, and the file is tagged with the configuration time, the target system, etc... (those variables coming from the sourced <em>config.sh</em> file have been set up by <em>Configure</em>). That comment header is followed by a '#ifndef' protection to guard against multiple inclusions of this file. Then comes the heart of the file...</p><p>It helps to know that <em>$d_*</em> and <em>$i_*</em> variables are set to either '<em>define</em>' or '<em>undef</em>' by <em>Configure</em>, depending on wether a function or an include file is present on the system or not. That means the: #$d_bcopy HAS_BCOPY /**/ line will be expanded to either: #define HAS_BCOPY /**/ if the $d_bcopy variable is set to 'define' or: #undef HAS_BCOPY /**/ if $d_bcopy was set to 'undef', because the feature was not there. However, that's not what gets written in the <em>config.h</em> file because of the <em>sed</em> filter we have already seen, which will transform the second form into: /*#define HAS_BCOPY /**/ That's a handy form for later editing of <em>config.h</em> because you only need to remove the leading '/*' if you want to override <em>Configure</em>'s choice. Likewise, you may add a single '/*' at the beginning of a '#define' line to avoid the definition of a particular symbol. This is why each symbol definition is protected by a trailing '/**/', to close the leading comment opened by '/*' (comments are not nested in C).</p><p>Now transforming '#undef' into '/*#define' is nice, but if we want to actually write a '#undef', we're stuck... unless we write it as '#un-def' and let <em>sed</em> fix that to '#undef' while producing <em>config.h</em>, which is what is actually done here.</p><p>The same kind of reasoning applies to those two lines: #$d_dup2 HAS_DUP2   /**/ #$i_string I_STRING      /**/ and assuming <em>config.sh</em> defines: d_dup2='define' i_string='undef' we'll get in the produced <em>config.h</em>: #define HAS_DUP2   /**/ /*#define I_STRING      /**/ Clear as running water? Good!</p><p>Now it should be obvious that by including <em>config.h</em> in all your C source files, you get to know what <em>Configure</em> has guessed on your system. In effect, by using those symbols, you are writing configured C code, since <em>metaconfig</em> will know that you need those symbols and will generate a suitable <em>config_h.SH</em> file as well as all the necessary code in <em>Configure</em> to compute a proper value for them (by assigning values to associated shell variables).</p>
<h3>Running Metaconfig</h3>
<p>Let's focus on the <em>metaconfig</em> program for a while to understand how it uses its units and your source code to produce all the needed configuration files. If you intend to write new units, you should have a good understanding of the whole scheme.</p><p>If there is no MANIFEST.new file, <em>metaconfig</em> will try to use the MANIFEST file instead, for convenience.  Everywhere we mention MANIFEST.new, it can be understood as MANIFEST provided there is no MANIFEST.new file found at the root of your package.</p><p>Assuming your MANIFEST.new file is properly set and lists all the source files you wish to configure, and that you have run <em>packint</em> in your root source directory to create a <em>.package</em> file, you may run <em>metaconfig</em> and you'll get the following: $ metaconfig Locating units... Extracting dependency lists from 312 units... Extracting filenames (*.[chyl] and *.SH) from MANIFEST.new... Building a Wanted file... Scanning .[chyl] files for symbols... Scanning .SH files for symbols... Computing optimal dependency graph... Building private make file... Determining loadable units... Updating make file... Determining the correct order for the units... Creating Configure... Done. The first phase looks for all the units files (ending with .U) in the public directory first, then in your private one. If you copy a public file in your private U directory (i.e. a directory named U at the top level of your package), it will override the public version. Once it has a list of all the available units, it parses them and extracts all the ?MAKE: lines to know about the dependencies and the known shell symbols. It also focuses on the ?H: lines to learn about the C symbols and which shell symbols needs to be computed to get a proper value for that C symbol (so we have another level of dependencies here).</p><p>Next, the proper filenames are extracted from the MANIFEST.new files and a <em>Wanted</em> file is built: that file lists all the C symbols and the shell symbols needed for that package. We first scan the C-type files for C symbols, then propagate the dependencies to their associated shell symbols (gathered from ?H: lines). Next .SH files are scanned and finally all the shell symbols are known.</p><p>A temporary Makefile is built and metaconfig tries to <em>make</em> all the shell symbols to see what commands (listed on the second ?MAKE: lines) are executed, and thus which units are really needed. Optional units not otherwise required are removed and a second Makefile is generated. This time, we know about all the units and their respective orders, optional units having been removed and default values computed for their shell symbols. The <em>Configure</em> script can then be generated, along with <em>config_h.SH</em>. We're done.</p>
<h3>Conventions</h3>
<p>Proper conventions needs to be followed to make the whole process sound. There is a case convention for units and a variable naming convention.</p><p>All units should have their first letter lower-cased, unless they are special units. By special, we mean they do not really define new shell variables that can be used by the user in his .SH files, but rather units producing scripts or shell variables that are to be used internally by the <em>Configure</em> script. Typical examples are the <em>Init.U</em> file which is the main variable initialization, or <em>Myread.U</em> which produces the <em>myread</em> script used almost everywhere in <em>Configure</em> when a question is to be asked to the user.</p><p>Non-special units then subdivise in two distinct groups: units defining variables associated to a C symbol and units defining shell variables of their own. The first group is further divided in variables related to include files (their name begin with <em>i_</em>) and variables related to other definitions (name starting with <em>d_</em>). The second group have names standing for itself, for instance <em>cc.U</em> defines the <em>$cc</em> shell variable whose value is the C compiler to be used.</p><p>Special units sometimes reserve themselves some pre-defined variable and return "results" in other well-known variables. For instance, the <em>myread</em> script produced by Myread.U expects the prompt in <em>$rp</em>, the default answer in <em>$dflt</em> and places the user answer in <em>$ans</em>. This is not documented in this manual page: you have to go and look at the unit itself to understand which variables are used and how the unit is to be used.</p>
<h3>Using The Glossary</h3>
<p>The Glossary file is automatically produced by the <em>makegloss</em> script, which extracts the information from ?S:, ?C: and ?MAKE: lines and reformats them into an alphabetically sorted glossary. It is important to read the Glossary to know about the symbols you are allowed to use. However, the Glossary will not tell you how to use them. Usually, that's up to you.</p><p>One day, you will probably write your own units and you will know enough about <em>metaconfig</em> to do so quickly and efficiently. However, never forget to properly document your work in the ?S: and ?C: lines, or other people will not be able to reuse it. Remember about the time where you had only the Glossary and this manual page to get started.</p>
<h3>Conclusion</h3>
<p>Now that you know the <em>metaconfig</em> basics, you should read the <em>DESCRIPTION</em> section, then skip to the <em>REFERENCE</em> section to learn about all the gory details such as the allowed syntax for unit control lines (lines starting with a '?') or the distinct MAKE commands you are allowed to use.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REFERENCE</h2>
        <div class="sectioncontent">
<p>This section documents the internals of <em>metaconfig</em>, basically the unit syntax, the special units you should know about and the hint files.</p><h3>General Unit Syntax</h3>
<p>A metaconfig unit is divided into two distinct parts. The header section (lines starting with '?') and a shell section (code to be included in the <em>Configure</em> script). It is possible to add '?X:' comments anywhere within the unit, but the other '?' lines (also called <em>control lines</em>) have a strict ordering policy.</p><p>If a control line is too long, it is possible to use a continuation by escaping the final new-line with a backslash and continuing on the next line (which should then be indented by spaces or tabs).</p><p>The following is a formal description of each of the control lines. Unless stated otherwise, the order of this presentation is the order to be used within the unit.</p>
<dl class='dl-vertical'>
  <dt>
    <p>?RCS: <em>free text</em></p>
  </dt>
  <dd>
    <p>To be used for RCS comments, at the top of the unit.</p>
  </dd>
  <dt>
    <p>?X: <em>any text</em></p>
  </dt>
  <dd>
    <p>General purpose comments. May appear anywhere in the unit but must be left justfied. For RCS comments, please use the ?RCS: comment form.</p>
  </dd>
  <dt>
    <p>?MAKE:<em>symbol list</em>: <em>dependency list</em> [<em>+optional</em>]</p>
  </dt>
  <dd>
    <p>This is the first dependency line. The first <em>symbol list</em> should list all the symbols built by this unit (i.e. whose value is computed by the shell section of the unit). Symbols should be space separated. If a defined symbol is for internal use only and should  not appear in the generated <em>config.sh</em> file, then it should be preceded by a '+' (not to be confused with optional dependencies defined hereafter). The second part of the list (after the middle ':') is the unit dependency. It should list all the needed special units, as well as all the symbols used by the shell implementation. If a symbol is nedded but its configuration value is not critical, it can be preceded by a '+', in which case it is called a conditional dependency: its corresponding unit will be loaded if, and only if, that symbol is otherwise really wanted; otherwise the default value will be used.</p>
  </dd>
  <dt>
    <p>?MAKE:<em>tab</em> <em>command</em></p>
  </dt>
  <dd>
    <p>There can be one or more command lines following the initial dependency lines. Those commands will be executed when the unit is wanted to load them into <em>Configure</em>. See the paragraph about make commands for more information. Note that the leading <em>tab</em> character is required before the <em>command</em>.</p>
  </dd>
  <dt>
    <p>?Y:<em>layout</em></p>
  </dt>
  <dd>
    <p>Declare a layout directive for this unit. That directive may be one of the strings <em>top</em>, <em>default</em> or <em>bottom</em> (case does not matter, recommended style is to spell them out uppercased). If omitted, <em>default</em> is assumed.</p><p>This directive is only required if you wish to force a unit at the top or the bottom of the generated <em>Configure</em> script, as unit dependencies permit it. Important questions may thus be forced at the beginning. Within the same layout class, units are sorted alphabetically with two special cases for d_* and i_* units, forced respectively at the top and bottom of their classes (but these should belong to the default class).</p><p>It you force at the top a unit whose dependencies require all the other unit to precede it, you achieve nothing interesting. Therefore, that directive should really be used to increase the priority of some interactive units that do not depend on many other user-visible symbols, like path-related questions.</p>
  </dd>
  <dt>
    <p>?S:<em>symbol_name</em> [(<em>obsolete symbol list</em>)]:</p>
  </dt>
  <dd>
    <p>Introduces a shell symbol. This first line names the symbol, optionally followed by a list enclosed between parenthesis and giving the obsolete equivalent. Those obsolete symbols will be remapped to the new <em>symbol_name</em> if the <strong>-o</strong> option is given to <em>metaconfig</em>.</p>
  </dd>
  <dt>
    <p>?S:<em>any text, for Glossary</em></p>
  </dt>
  <dd>
    <p>Basically a comment describing the shell symbol, which will be extracted by <em>makegloss</em> into the Glossary file.</p>
  </dd>
  <dt>
    <p>?S:.</p>
  </dt>
  <dd>
    <p>Closes the shell symbol comment.</p>
  </dd>
  <dt>
    <p>?C:<em>symbol_name</em> [~ <em>alias</em>] [(<em>obsolete symbol list</em>)]:</p>
  </dt>
  <dd>
    <p>Introduces a new C symbol. The <em>alias</em> name is the name under which the C symbol will be controlled, i.e. if the <em>alias</em> symbol is wanted, then that C symbol will be written in the <em>config_h.SH</em> file. Usually, the alias is just '%&lt;' (stands for the unit's name) and there is also a ?W: line mapping a C symbol to the <em>alias</em>. Also the relevant parts of the ?H: lines are explicitly protected by a '?%&lt;' condition. See the symbol aliasing paragraph for more details. The remaining of the line is the optional <em>obsolete symbol list</em>, which lists old equivalents for the new <em>symbol_name</em>.</p>
  </dd>
  <dt>
    <p>?C:<em>any text, for Glossary and config_h.SH</em></p>
  </dt>
  <dd>
    <p>Basically a comment describing the C symbol, which will be extracted by <em>makegloss</em> into the Glossary file and by <em>metaconfig</em> into the <em>config_h.SH</em> file if the symbol is wanted (or if its alias is wanted when symbol aliasing is used).</p>
  </dd>
  <dt>
    <p>?C:.</p>
  </dt>
  <dd>
    <p>Closes the C symbol comment.</p>
  </dd>
  <dt>
    <p>?H:?<em>symbol</em>:<em>config_h.SH stuff</em></p>
  </dt>
  <dd>
    <p>This is the general inclusion request into <em>config_h.SH</em>. The line is only written when the guarding <em>symbol</em> is really wanted. This general form is needed when C symbol aliasing was used. Otherwise, if you use one of the other "standard" forms, the guarding is automatically done by <em>metaconfig</em> itself.</p>
  </dd>
  <dt>
    <p>?H:#<em>$d_var VAR</em> "<em>$var</em>"</p>
  </dt>
  <dd>
    <p>Conditionally defines the <em>VAR</em> C symbol into <em>$var</em> when <em></em> is set to '<em>define</em>'. Implies a '?<em>VAR</em>:' guarding condition, and <em>metaconfig</em> automatically links <em>VAR</em> to its two shell variable dependencies (i.e. both <em>$d_var</em> and <em>$var</em> will be flagged as <em>wanted</em> if <em>VAR</em> is used in C sources).</p>
  </dd>
  <dt>
    <p>?H:#define <em>VAR</em> [<em>optional text</em>]</p>
  </dt>
  <dd>
    <p>Always defines the <em>VAR</em> C symbol to some value. Implies a '?<em>VAR</em>:' guarding condition. An automatic shell dependency is made to the unit itself.</p>
  </dd>
  <dt>
    <p>?H:#define <em>VAR(x,y,z)</em> <em>$var</em></p>
  </dt>
  <dd>
    <p>Always defines the macro <em>VAR</em> to be the value of the <em>$var</em> variable. It is up to the unit to ensure <em>$var</em> holds a  sensible value. An automatic dependency between the C macro <em>VAR</em> and the shell variable is established, and the whole line is guarded by an implicit '?<em>VAR</em>:'.</p>
  </dd>
  <dt>
    <p>?H:#<em>$d_var VAR</em></p>
  </dt>
  <dd>
    <p>Conditionally defines <em>VAR</em> if <em>$d_var</em> is set to '<em>define</em>'. Implies a '?<em>VAR</em>:' guarding condition. An automatic shell dependency is generated towards <em>$d_war</em>.</p>
  </dd>
  <dt>
    <p>?H:#define <em>VAR</em> "<em>$var</em>"</p>
  </dt>
  <dd>
    <p>Assigns a configured value to the <em>VAR</em> C symbol. Implies a '?<em>VAR</em>:' gurading condition. An automatic shell dependency is generated to link <em>VAR</em> and <em>$var</em>.</p>
  </dd>
  <dt>
    <p>?H:.</p>
  </dt>
  <dd>
    <p>Closes the <em>config_h.SH</em> inclusion requests.</p>
  </dd>
  <dt>
    <p>?M:<em>C symbol</em>: <em>C dependencies</em></p>
  </dt>
  <dd>
    <p>Introduces magic definition concerning the C symbol, for <em>confmagic.h</em>, and defines the guarding symbol for the remaining ?M: definitions. This line silently implies '?W:%&lt;:<em>C symbol</em>', i.e. the unit will be loaded into Configure if the C symbol appears within the C sources, whether magic is used or not. The C dependencies are activated when magic is used, in order to force their definition in <em>config_h.SH</em>. However, if magic is <strong>not</strong> used but the C symbol appears in the source without the needed C dependencies, you will be warned every time the Wanted file is built, since it may be a portability issue (and also because the unit is unconditionally loaded into Configure whenever the C symbol is used, regardless of the other ?C: lines from the unit).</p>
  </dd>
  <dt>
    <p>?M:<em>cpp defs</em></p>
  </dt>
  <dd>
    <p>Defines the magic cpp mapping to be introduced in confmagic.h whenever the concerned symbol is used. There is an implicit '?<em>sym</em>' guarding where <em>sym</em> is the symbol name defined by the leading ?M: line.</p>
  </dd>
  <dt>
    <p>?M:.</p>
  </dt>
  <dd>
    <p>Closes the <em>confmagic.h</em> inclusion request.</p>
  </dd>
  <dt>
    <p>?W:<em>shell symbol list</em>:<em>C symbol list</em></p>
  </dt>
  <dd>
    <p>Ties up the destiny of the shell symbols with that of the C symbols: if any of the C symbols listed is wanted, then all the shell symbols are marked as wanted. Useful to force inclusion of a unit (shell symbol list set to '%&lt;') when the presence of some C symbol is detected. The shell symbol list may be left empty, to benefit from the side effect of C symbol location within the builtin pre-processor (symbol being <em>defined</em> for that pre-processor if located in the source). To look for patterns with a space in them, you need to quote the C symbols within simple quotes, as in 'struct timezone'.</p>
  </dd>
  <dt>
    <p>?V:<em>read-only symbols</em>:<em>read-write symbols</em></p>
  </dt>
  <dd>
    <p>This is a <em>metalint</em> hint and should be used only in special units exporting some shell variables. The variables before the middle ':' are exported read-only (changing them will issue a warning), while other symbols may be freely read and changed.</p>
  </dd>
  <dt>
    <p>?F:<em>files created</em></p>
  </dt>
  <dd>
    <p>This line serves two purposes: it is a <em>metalint</em> hint, and also a placeholder for future <em>jmake</em> use. It must list three kind of files: the temporary one which are created for a test, the private UU ones created in the UU directory for later perusal, and the public ones left in the root directory of the package. Temporary files must be listed with a preceding '!' character (meaning "no! they're not re-used later!"), private UU files should be preceded by a './' (meaning: to use them, say <em>./file</em>, not just <em>file</em>), and public ones should be named as-is.</p>
  </dd>
  <dt>
    <p>?T:<em>shell temporaries</em></p>
  </dt>
  <dd>
    <p>Another <em>metalint</em> hint. This line lists all the shell variables used as temporaries within the shell section of this unit.</p>
  </dd>
  <dt>
    <p>?D:<em>symbol</em>='<em>value</em>'</p>
  </dt>
  <dd>
    <p>Initialization value for symbols used as conditional dependencies. If no ?D: line is found, then a null value is used instead. The <em>metalint</em> program will warn you if a symbol is used at least once as a conditional dependency and does not have a proper ?D: initialization. It's a good practice to add those lines even for a null initialization since it emphasizes on the possibly optional nature of a symbol.</p>
  </dd>
  <dt>
    <p>?O:<em>any message you want</em></p>
  </dt>
  <dd>
    <p>This directive indicates that this unit is obsolete as a whole. Whenever usage of any of its symbols is made (or indirect usage via dependencies), the message is output on the screen (on stderr). You can put one ore more lines, in which case each line will be printed, in order.</p>
  </dd>
  <dt>
    <p>?LINT:<em>metalint hints</em></p>
  </dt>
  <dd>
    <p>See the <em>metalint</em> manual page for an explaination of the distinct hints that can be used.</p>
  </dd>
  <dt>
    <p>?INIT:<em>initialization code</em></p>
  </dt>
  <dd>
    <p>The initialization code specified by this line will be loaded at the top of the <em>Configure</em> script provided the unit is needed.</p>
  </dd>

</dl>

<h3>C Symbol Aliasing</h3>
<p>Sometimes it is not possible to rely on <em>metaconfig</em>'s own default selection for <em>config_h.SH</em> comments and C symbol definition. That's where aliasing comes into play. Since it's rather tricky to explain, we'll study an example to understand the underlying mechanism.</p><p>The d_const.U unit tries to determine whether or not your C compiler known about the <em>const</em> keyword. If it doesn't we want to remap that keyword to a null string, in order to let the program compile. Moreover, we want to automatically trigger the test when the <em>const</em> word is used.</p><p>Here are the relevant parts of the d_const.U unit: ?MAKE:d_const: cat cc ccflags Setvar ?MAKE:	-pick add $@ %&lt; ?S:d_const: ?S:	This variable conditionally defines the HASCONST symbol, which ?S:	indicates to the C program that this C compiler knows about the ?S:	const type. ?S:. ?C:HASCONST ~ %&lt;: ?C:	This symbol, if defined, indicates that this C compiler knows about ?C:	the const type. There is no need to actually test for that symbol ?C:	within your programs. The mere use of the "const" keyword will ?C:	trigger the necessary tests. ?C:. ?H:?%&lt;:#$d_const HASCONST	/**/ ?H:?%&lt;:#ifndef HASCONST ?H:?%&lt;:#define const ?H:?%&lt;:#endif ?H:. ?W:%&lt;:const ?LINT:set d_const ?LINT:known const : check for const keyword echo " " echo 'Checking to see if your C compiler knows about "const"...' &gt;&4 /bin/cat &gt;const.c &lt;&lt;'EOCP' main() { 	const char *foo; } EOCP if $cc -c $ccflags const.c &gt;/dev/null 2&gt;&1 ; then 	val="$define" 	echo "Yup, it does." else 	val="$undef" 	echo "Nope, it doesn't." fi set d_const eval $setvar First we notice the use of a ?W: line, which basically says: "This unit is wanted when the <em>const</em> keyword is used in a C file.". In order to conditionally remap <em>const</em> to a null string in <em>config.h</em>, I chose to conditionally define <em>HASCONST</em> via <em>$d_const</em>.</p><p>However, this raises a problem, because the <em>HASCONST</em> symbol is not going to be used in the sources, only the <em>const</em> token is. And the ?H: line defining <em>HASCONST</em> is implicitely guarded by '?HASCONST'. Therefore, we must add the explicit '?%&lt;' constraint to tell <em>metaconfig</em> that those lines should be included in <em>config_h.SH</em> whenever the '%&lt;' symbol gets wanted (%&lt; refers to the unit's name, here <em>d_const</em>).</p><p>That's almost perfect, because the ?W: line will want <em>d_const</em> whenever <em>const</em> is used, then the ?H: lines will get included in the <em>config_h.SH</em> file. However, the leading comment (?C: lines) attached to <em>HASCONST</em> is itself also guarded via <em>HASCONST</em>, i.e. it has an implicit '?HASCONST' constraint. Hence the need for <em>aliasing</em> the <em>HASCONST</em> symbol to '%&lt;'.</p><p>The remaining part of the unit (the shell part) is really straightforward. It simply tries to compile a sample C program using the <em>const</em> keyword. If it can, then it will define <em>$d_const</em> via the <em>$setvar</em> fonction (defined by the <em>Setvar.U</em> unit). See the paragraph about special units for more details.</p>
<h3>Make Commands</h3>
<p>On the ?MAKE: command line, you may write a shell command to be executed as-is or a special <em>-pick</em> command which is trapped by <em>metaconfig</em> and parsed to see what should be done. The leading '-' is only there to prevent <em>make</em> from failing when the command returns a non-zero status -- it's not really needed since we use '<em>make -n</em>' to resolve the dependencies, but I advise you to keep it in case it becomes mandatory in future versions. The syntax of the <em>pick</em> command is: -pick <em>cmd</em> $@ <em>target_file</em> where <em>$@</em> is the standard macro within Makefiles standing for the current target (the name of the unit being built, with the final .U extension stripped). The <em>cmd</em> part is the actual <em>metaconfig</em> command to be run, and the <em>target_file</em> is yet another parameter, whose interpretation depends on the <em>cmd</em> itself. It also has its final .U extension stripped and normally refers to a unit file, unless it start with './' in which case it references one of the <em>metaconfig</em> control files in the '<em>.MT</em> directory.</p><p>The available commands are:</p>
<dl class='dl-vertical'>
  <dt>
    <p>add</p>
  </dt>
  <dd>
    <p>Adds the <em>target_file</em> to <em>Configure</em>.</p>
  </dd>
  <dt>
    <p>add.Config_sh</p>
  </dt>
  <dd>
    <p>Fills in that part of <em>Configure</em> producing the <em>config.sh</em> file. Only used variables are added, conditional ones (from conditional dependencies) are skipped.</p>
  </dd>
  <dt>
    <p>add.Null</p>
  </dt>
  <dd>
    <p>Adds the section initializing all the shell variables used to an empty string.</p>
  </dd>
  <dt>
    <p>c_h_weed</p>
  </dt>
  <dd>
    <p>Produces the <em>config_h.SH</em> file. Only the necessary lines are printed.</p>
  </dd>
  <dt>
    <p>cm_h_weed</p>
  </dt>
  <dd>
    <p>Produces the <em>confmagic.h</em> file. Only the necessary lines are printed. This command is only enabled when the <strong>-M</strong> switch is given, or when a <em>confmagic.h</em> file already exists.</p>
  </dd>
  <dt>
    <p>close.Config_sh</p>
  </dt>
  <dd>
    <p>Adds the final 'EOT' symbol on a line by itself to end the here document construct producing the <em>config.sh</em> file.</p>
  </dd>
  <dt>
    <p>prepend</p>
  </dt>
  <dd>
    <p>Prepends the content of the target to the <em>target_file</em> if that file is not empty.</p>
  </dd>
  <dt>
    <p>weed</p>
  </dt>
  <dd>
    <p>Adds the unit to <em>Configure</em> like the <em>add</em> command, but make some additional tests to remove the '?<em>symbol</em>' and '%<em>symbol</em>' lines from the <em>target_file</em> if the symbol is not wanted or conditionally wanted. The '%' form is only used internally by <em>metaconfig</em> while producing its own .U files in the '<em>.MT</em>' directory.</p>
  </dd>
  <dt>
    <p>wipe</p>
  </dt>
  <dd>
    <p>Same as <em>add</em> really, but performs an additional macro substitution. The available macros are described in the <em>Hardwired Macros</em> paragraph.</p>
  </dd>

</dl>
<p>As a side note, <em>metaconfig</em> generates a <em>-cond</em> command internally to deal with conditional dependencies. You should not use it by yourself, but you will see it if scanning the generated <em>Makefile</em> in the <em>.MT</em> directory.</p>
<h3>Hardwired Macros</h3>
<p>The following macros are recognized by the <em>wipe</em> command and subsituted before inclusion in <em>Configure</em>:</p>
<dl class='dl-vertical'>
  <dt>
    <p>&lt;BASEREV&gt;</p>
  </dt>
  <dd>
    <p>The base revision number of the package, derived from <em>.package</em>.</p>
  </dd>
  <dt>
    <p>&lt;DATE&gt;</p>
  </dt>
  <dd>
    <p>The current date.</p>
  </dd>
  <dt>
    <p>&lt;MAINTLOC&gt;</p>
  </dt>
  <dd>
    <p>The e-mail address of the maintainer of this package, derived from your <em>.package</em>.</p>
  </dd>
  <dt>
    <p>&lt;PACKAGENAME&gt;</p>
  </dt>
  <dd>
    <p>The name of the package, as derived from your <em>.package</em> file.</p>
  </dd>
  <dt>
    <p>&lt;PATCHLEVEL&gt;</p>
  </dt>
  <dd>
    <p>The patch level of the <em>metaconfig</em> program (deprecated in favor of &lt;REVISION&gt;).</p>
  </dd>
  <dt>
    <p>&lt;REVISION&gt;</p>
  </dt>
  <dd>
    <p>The SVN revision level of the <em>metaconfig</em> program.</p>
  </dd>
  <dt>
    <p>&lt;VERSION&gt;</p>
  </dt>
  <dd>
    <p>The version number of the <em>metaconfig</em> program.</p>
  </dd>

</dl>
<p>Those macros are mainly used to identify the <em>metaconfig</em> version that generated a particular <em>Configure</em> script and for which package it was done. The e-mail address of the maintainer is hardwired in the leading instructions that <em>Configure</em> prints when starting.</p><p>Recent <em>metaconfig</em> versions understand a much more general syntax of the form: 	&lt;$variable&gt; which is replaced at Configure-generation time by the value of <em>variable</em> taken from your <em>.package</em> file. Eventually, the old hardwired macro format will disappear, and &lt;$baserev&gt; will replace &lt;BASEREV&gt; in all the supplied units.</p>
<h3>Special Units</h3>
<p>The following special units are used to factorize code and provide higher level functionalities. They either produce a shell script that can be sourced or a shell variable that can be <em>eval</em>'ed. Parameter passing is done via well-know variables, either named or anonymous like $1, $2, etc... (which can be easily set via the shell <em>set</em> operator). When <em>Configure</em> executes, it creates and goes into a <em>UU</em> directory, so every produced script lies in there and does not interfere with the files from your package.</p><p>Here are the sepcial units that you should know about, and the way to use them.</p>
<dl class='dl-vertical'>
  <dt>
    <p>Cppsym.U</p>
  </dt>
  <dd>
    <p>This unit produces a shell script called <em>Cppsym</em>, which can be used to determine whether any symbol in a list is defined by the C preprocessor or C compiler you have specified. It can determine the status of any symbol, though the symbols in <em></em> (attribute list) are more easily determined.</p>
  </dd>
  <dt>
    <p>Csym.U</p>
  </dt>
  <dd>
    <p>This sets the $csym shell variable, used internally by <em>Configure</em> to check whether a given C symbol is defined or not. A typical use is: set symbol result [-fva] [previous] eval $csym That will set the <em>result</em> variable to 'true' if the function [-f], variable [-v] or array [-a] is defined, 'false' otherwise. If a previous value is given and the <strong>-r</strong> switch was provided to <em>Configure</em> (see the <em>Configure Options</em> paragraph), then that value is re-used without questioning.</p><p>The way this computation is done depends on the answer the user gives to the question <em>Configure</em> will ask about whether it should perform an <em>nm</em> extraction or not. If the exctraction was performed, the unit simply looks through the symbol list, otherwise it performs a compile-link test, unless <strong>-r</strong> was given to reuse the previously computed value, naturally...</p>
  </dd>
  <dt>
    <p>End.U</p>
  </dt>
  <dd>
    <p>By copying this unit into your private <em>U</em> directory and appending dependencies on the ?MAKE: line, you can force a given unit to be loaded into <em>Configure</em> even if it is not otherwise wanted. Some units may only be forced into <em>Configure</em> that way.</p>
  </dd>
  <dt>
    <p>Filexp.U</p>
  </dt>
  <dd>
    <p>This unit produces a shell script <em>filexp</em> which will expand filenames beginning with tildes. A typical use is: exp_name=`./filexp $name` to assign the expanded file name in <em>exp_name</em>.</p>
  </dd>
  <dt>
    <p>Findhdr.U</p>
  </dt>
  <dd>
    <p>This unit produces a <em>findhdr</em> script which is used to locate the header files in <em>$usrinc</em> or other stranger places using cpp capabilities. The script is given an include file base name like 'stdio.h' or 'sys/file.h' and it returns the full path of the inlcude file and a zero status if found, or an empty string and a non-zero status if the file could not be located.</p>
  </dd>
  <dt>
    <p>Getfile.U</p>
  </dt>
  <dd>
    <p>This unit produces a bit of shell code that must be sourced in order to get a file name and make some sanity checks. Optionally, a ~name expansion is performed.</p><p>To use this unit, <em>$rp</em> and <em>$dflt</em> must hold the question and the default answer, which will be passed as-is to the <em>myread</em> script (see forthcoming <em>Myread.U</em>). The <em>$fn</em> variable controls the operation and the result is returned into <em>$ans</em>.</p><p>To locate a file or directory, put 'f' or 'd' in <em>f~/</em>. If a '~' appears, then ~name substitution is allowed. If a '/' appears, only absolute pathnames are accepted and ~name subsitutions are always expanded before returning. If '+' is specified, existence checks are skipped. If 'n' appears within <em>$fn</em>, then the user is allowed to answer 'none'.</p><p>Usually, unless you asked for portability, ~name substitution occurs when requested. However, there are some times you wish to bypass portability and force the substitution. You may use the 'e' letter (expand) to do that.</p><p>If the special 'l' (locate) type is used, then the <em>$fn</em> variable must end with a ':', followed by a file basename. If the answer is a directory, the file basename will be appended before testing for file existence. This is useful in locate-style questions like this: dflt='~news/lib' : no need to specify 'd' or 'f' when 'l' is used fn='l~:active' rp='Where is the active file?' . ./getfile active="$ans"</p><p>Additionally, the 'p' (path) letter may be used in conjunction with 'l' to tell <em>getfile</em> that an answer without a '/' in it should be accepted, assuming that it will be in everyone's PATH at the time this value will be needed.</p><p>Also useful is the possibility to specify a list of answers that should be accepted verbatim, bypassing all the checks. This list must be within parenthesis and items must be comma separated, with no interleaving spaces. Don't forget to quote the resulting string since parenthesis are meaningful to the shell. For instance: dflt='/bin/install' fn='/fe~(install,./install)' rp='Use which install program?' . ./getfile install="$ans" would let the user only specify fully qualified paths referring to existing files, but still allow the special "install" and "./install" answers as-is (assuming of course something will deal with them specially later on in the chain since they do not conform with the general expected frame).</p><p>If the answer to the question is 'none', then the existence checks are skipped and the empty string is returned. Note that since <em>getfile</em> calls <em>myread</em> internally, all the features available with <em>myread</em> apply here to.</p><p>If a completely expanded value is needed (for instance in a Makefile), you may use the <em>$ansexp</em> variable which is always set up properly by <em>getfile</em> as the expanded version of <em>$ans</em>. Of course, it will not expand ~name if you did not allow that in the first place in the <em>$fn</em> variable.</p>
  </dd>
  <dt>
    <p>Inhdr.U</p>
  </dt>
  <dd>
    <p>This unit produces the <em>$inhdr</em> shell variable, used internally by <em>Configure</em> to check whether a set of headers exist or not. A typical use is: set header i_header [ header2 i_header2 ... ] eval $inhdr That will print a message, saying whether the header was found or not and set the <em>i_header</em> variable accordingly. If more than one header is specified and the first header is not found, we try the next one, until the list is empty or one is found.</p>
  </dd>
  <dt>
    <p>Inlibc.U</p>
  </dt>
  <dd>
    <p>This unit produces the <em>$inlibc</em> shell variable, used internally by <em>Configure</em> to check whether a given C function is defined or not. A typical use is: set function d_func eval $inlibc That will print a message, saying whether the function was found or not and set <em>$d_func</em> accordingly. Internally, it used the <em>$csym</em> routine.</p>
  </dd>
  <dt>
    <p>Loc.U</p>
  </dt>
  <dd>
    <p>This important unit produces a shell script <em>loc</em> which can be used to find out where in a list of directories a given file lies. The first argument specifies the file to be located, the second argument is what will be returned if the search fails, and the reamining arguments are a list of directories where the file is to be searched. For instance: dflt=`./loc sendmail.cf X /usr/lib /var/lib/sendmail /lib` would set <em>$dflt</em> to <em>X</em> if no <em>sendmail.cf</em> file was found under the listed directories, or something like <em>/usr/lib/sendmail.cf</em> on some systems. See also <em>Getfile.U</em>.</p>
  </dd>
  <dt>
    <p>MailAuthor.U</p>
  </dt>
  <dd>
    <p>This unit needs to be included on the ?MAKE: line of your own private End.U to make it into <em>Configure</em>. It offers the user to register himself to the author, optionally being notified when new patches arrive or receiving them automatically when issued. You need to install <em>mailagent</em> to do this (at least version 3.0).</p>
  </dd>
  <dt>
    <p>MailList.U</p>
  </dt>
  <dd>
    <p>This unit needs to be included on the ?MAKE: line of your own private End.U to make it into <em>Configure</em>. It offers the user to subscribe or unsubscribe to a mailing list where discussion related to the package are taking place. You need to run <em>packinit</em> and answer the mailing list related questions to set up the proper variables in your <em>.package</em> before this unit may become operational.</p>
  </dd>
  <dt>
    <p>Myinit.U</p>
  </dt>
  <dd>
    <p>Copy this unit into your private <em>U</em> directory to add your own default values to some internal variables. This unit is loaded into <em>Configure</em> after all the default initializations have been done.</p>
  </dd>
  <dt>
    <p>Myread.U</p>
  </dt>
  <dd>
    <p>This unit produces the <em>myread</em> shell script that must be sourced in order to do a read. It allows shell escapes, default assignment and parameter evaluation, as documented in the Instruct.U unit. It also allows dynamic setting of the <strong>-d</strong> option, which will be used for the remaining of the script execution.</p><p>To use this unit, <em>$rp</em> must hold the question and <em>$dflt</em> should contain the default answer. The question will be printed by the script itself, and the result is returned in the <em>$ans</em> variable.</p><p>Here is a typical usage: dflt='y' rp='Question?' . ./myread value="$ans" See the unit itself for more information.</p>
  </dd>
  <dt>
    <p>Oldconfig.U</p>
  </dt>
  <dd>
    <p>This unit must be part of your dependency ?MAKE: line when some of your units tries to reuse an old symbol value. This unit is responsible for getting the old answers from <em>config.sh</em> or providing useful hints when running on a given platform for the first time. See the <em>Configure</em> Hints paragraph for more information about hints.</p>
  </dd>
  <dt>
    <p>Prefixit.U</p>
  </dt>
  <dd>
    <p>The purpose of this unit is to detect changes in the installation prefix directory to recompute automatically suitable defaults from previous answers. It relies on the value of the <em>$oldprefix</em> variable which holds the previous prefix directory when it changed, and is empty otherwise. For instance, if the prefix was changed from <em>/opt</em> to <em>/usr/local</em>, then the previous binary installation directory will be changed from <em>/opt/bin</em> to <em>/usr/local/bin</em>, or will remain unchanged if it was, say, <em>/bin</em>.</p><p>You need to call <strong>set</strong> before issuing an <strong>eval</strong> on <em>$prefixit</em>, such as: set dflt var [dir] eval $prefixit which would set <em>$dflt</em> to <em>$var</em> or <em>$prefix/dir</em> depending on whether the prefix remained the same or not. If <em>dir</em> is the string <em>none</em>, a single space value in <em>$dflt</em> is kept as-is, even when the prefix changes. If <em>dir</em> is omitted, then <em>$dflt</em> is set to an empty string if the prefix changed, to <em>$var</em> otherwise.</p>
  </dd>
  <dt>
    <p>Prefixup.U</p>
  </dt>
  <dd>
    <p>The intent of thit unit is similar to that of Prefixit.U, i.e. it helps fixing the default string to accommodate prefix changes. However, the shell variable <em>$prefixup</em>, when evaluated, will only restore ~name expansions, should prefix use such an escape mechanism. Use it as: set dflt eval $prefixup before prompting via <em>getfile</em> for instance. If the prefix does not make use of ~name expanstion, then the above will be a no-op on the <em>y</em> variable, naturally.</p>
  </dd>
  <dt>
    <p>Typedef.U</p>
  </dt>
  <dd>
    <p>This unit produces the <em>$typedef</em> shell variable, used internally by <em>Configure</em> to check whether a typedef exists or not. A typical use is: set typedef val_t default [ includes ] eval $typedef This will set the variable <em>val_t</em> to the value of <em>default</em> if the typedef was not found among the listed include files, or to <em>typedef</em> if found. If no include files are specified, the unit looks in <em>&lt;sys/types.h&gt;</em> only. If you specifiy some includes, only those are looked at.</p>
  </dd>
  <dt>
    <p>Unix.U</p>
  </dt>
  <dd>
    <p>The purpose of this unit is to define some of the most common UNIX-isms via variables which can be altered from the command line or via proper hint files. In particular, <em>$_exe</em>, <em>$_o</em> and <em>$_a</em> are set. All the units should refer to <em>$_o</em> and not to <em>.o</em> directly. The '.' is part of these variables.</p>
  </dd>
  <dt>
    <p>Setvar.U</p>
  </dt>
  <dd>
    <p>This unit produces the <em></em> variable, which is used internally by <em>Configure</em> to set a <em>define</em>/undef value to a given symbol, emitting a warning when it suddenly changes from a previous value. For instance: val="$define" set d_variable eval $setvar If the previous <em>$d_variable</em> value was non-null and <em>$val</em> is different, a "whoa" warning is issued.</p>
  </dd>
  <dt>
    <p>Whoa.U</p>
  </dt>
  <dd>
    <p>This unit produces the <em>whoa</em> script, which emits a warning when the <em>value</em> in variable whose name is <em>$var</em> is not the same as its old previous value held in <em>$was</em>. Upon return, <em>$td</em> and <em>$tu</em> hold the proper value to <em>define</em> or <em>undef</em> the variable. See examples in <em>Inlibc.U</em>.</p>
  </dd>

</dl>

<h3>Builtin Pre-processor</h3>
<p>Each unit to be included in <em>Configure</em> is ran through a built-in pre-processor. Pre-processor statements are introduced by the '@' character ('#' is the shell comment character). It functions merely as the C pre-processor does but allows for shell and perl escapes. Here are the available functions:</p>
<dl class='dl-vertical'>
  <dt>
    <p>@if <em>expression</em></p>
  </dt>
  <dd>
    <p>If <em>expression</em> is true, continue loading code until @end, @elsif or @else.</p>
  </dd>
  <dt>
    <p>@elsif <em>expression</em></p>
  </dt>
  <dd>
    <p>Alternative choice. If <em>expression</em> is true, continue loading code until @end, another @elsif or @else.</p>
  </dd>
  <dt>
    <p>@else</p>
  </dt>
  <dd>
    <p>Default code to be loaded if the @if <em>expression</em> was false and none of the optional @elsif matched. Load until @end.</p>
  </dd>
  <dt>
    <p>@end</p>
  </dt>
  <dd>
    <p>Close the conditional loading statement opened by @if.</p>
  </dd>
  <dt>
    <p>@define <em>symbol</em></p>
  </dt>
  <dd>
    <p>Tells the pre-processor that <em>symbol</em> is defined from now on.</p>
  </dd>

</dl>
<p>The conditional <em>expression</em> can include symbol names (value is true if symbol is wanted or defined via <em>@define</em> or shell/perl escapes. Those atoms can be combined using the traditional boolean operators '!' for negation, '&&' for logical and, and '||' for logical or.</p><p>Text enclosed within single brackets is a shell test, while text between double brakets is a perl test. Namely the expressions: { <em>shell text</em> } {{ <em>perl text</em> }} are translated into: if <em>shell text</em> &gt;/dev/null 2&gt;&1; then exit 0; else exit 1; fi if (<em>perl text</em>) {exit 0;} else {exit 1;} and the exit status is used in the standard way to get a boolean value, i.e. 0 is true and everything else is false. Note that only simple conditions can be expressed in perl, until some complex code can be loaded within <em>metaconfig</em> and executed.</p><p>The built-in pre-processor can be used to finely tune some units (see <em>d_gethname.U</em> for a complex example) depending on the symbols actually used by the program or the files present in the distribution. For instance, the <em>Oldconfig.U</em> uses a test like: @if {test -d ../hints} and <em>Configure</em> will contain hint-dependent code only if there is a <em>hints</em> directory in the package's top level directory. Note that tests are ran from within the '<em>.MT</em>' directory, hence the needed '../' in the test.</p><p>The pre-processor can also be used to avoid putting useless code when a symbol is not defined. Units defining more than one symbol can be protected that way (since the unit is loaded as a whole) by gathering symbol-dependent code within an @if/@end pair. For instance: @if I_TIME || I_SYS_TIME || I_SYS_TIME_KERNEL need_time_h='true' @else need_time_h='false' @end will test whether the source code makes any use of one of the three symbols that control the <em>time.h</em> or <em>sys/time.h</em> inclusion and define the shell symbol accordingly. That gives <em>Configure</em> a feedback on what the sources need and avoid the drawback of having fixed frozen units.</p><p>Via the '?W:' lines, you can get intersting combinations. For instance, the <em>i_time.U</em> unit needs to know whether the C sources make any use of the <em>struct timezone</em> type. Therefore, the line: ?W::timezone is used for its side-effect of defining the symbol <em>timezone</em> for the pre-processor. The unit code can then say: @if timezone for s_timezone in '-DS_TIMEZONE' ''; do @else s_timezone='' @end</p><p>... code using s_timezone ...</p><p>@if timezone done @end and have an extra loop trying two successive values for the <em>s_timezone</em> variable, but only if needed.</p>
<h3>Obsolete Symbols</h3>
<p>Obsolete symbols are preserved to ease the transition with older <em>metaconfig</em> units. Unless the <strong>-o</strong> switch is passed to <em>metaconfig</em> they will be ignored. However, an <em>Obsolete</em> file will be generated, telling you which files are making use of those obsolete symbols and what are the new symbols to be used.</p><p>The lifetime for obsolete symbols is one full revision, i.e. they will be removed when the next base revision is issued (patch upgrades do not count of course). Therefore, it is wise to translate your sources and start using the new symbols as soon as possible.</p>
<h3>Configure Hints</h3>
<p>It may happen that the internal configuration logic makes the wrong choices. For instance, on some platform, the <em>vfork()</em> system call is present but broken, so it should not be used. It is not possible to include that knowledge in the units themselves, because that might be a temporary problem which the vendor will eventually fix, or something that was introduced by a new OS upgrade.</p><p>Anyway, for all those tiny little problems that are too system-specific, <em>metaconfig</em> provides hint files support. To use it, you need to create a <em>hints</em> directory in the package's top level directory, and have it when you run <em>metaconfig</em>. That will load the hint-related part from <em>Oldconfig.U</em>.</p><p>From then on, you may pre-set some of the shell variables <em>Configure</em> uses in an OS-specific .sh file. There is code in <em>Oldconfig.U</em> that tries to guess which hint files are needed by computing a standard name based on the system OS name, the kernel name, the release number, etc... Since this information is likely to change rapidly, I'm not documenting it here. You have to reverse engineer the code from <em>Oldconfig.U</em>.</p><p>When you first release your package, your hints file directory should be empty. If the users of your package complain that they have problem with <em>Configure</em> defaults on a particular system, you have to see whether this is a platform-specific problem or a general one. In the former case, it's time to introduce a new hint file, while in the latter, the corresponding unit should be revised.</p><p>For instance, SGI systems are known to have a broken <em>vfork()</em> system call, as of this writing. And the corresponding hint file name is <em>sgi.sh</em>. So all you need to do is create a <em>hints/sgi.sh</em> file in which you write: d_vfork="$define" which will always remap <em>vfork</em> on <em>fork</em> (see <em>d_vfork.U</em>). When running on SGI systems for the first time, <em>Configure</em> will detect that there is an <em>hints/sgi.sh</em> file, and that we are on an IRIX machine (the kernel name is often /irix), therefore it will propose <em>sgi</em> as a possible hint. If the user accepts it, and since the <em>$d_vfork</em> value is modified via the <em>$setvar</em> call, a <em>whoa!</em> will be emitted to warn that we are about to override the value computed by <em>Configure</em>.</p><p>Note that you don't have to provide <em>all</em> the hints known by <em>Oldconfig.U</em>. If a hint file is missing, it will not be proposed as a possible choice. The heuristic tests ran to compute the possible hint candidates are flaky. If you have new values or different tests, please send them to me...</p>
<h3>Overriding Choices</h3>
<p>If you create a <em>config.over</em> file in the top level directory, <em>Configure</em> will ask you if you wish to load it to override the default values. This is done prior creation of the <em>config.sh</em> file, so it gives you a chance to patch the values stored in there.</p><p>This is distinct from the hints approach in that it is a local file, which the user is free to create for his own usage. You should not provide such a file yourself, but let the user know about this possibility.</p>
<h3>Configure Options</h3>
<p>The <em>Configure</em> script may be called with some options specified on the command line, to slightly modify its behaviour. Here are the allowed options:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>-d</strong></p>
  </dt>
  <dd>
    <p>Use defaults for all answers.</p>
  </dd>
  <dt>
    <p><strong>-e</strong></p>
  </dt>
  <dd>
    <p>Go on without questioning past the production of <em>config.sh</em>.</p>
  </dd>
  <dt>
    <p><strong>-f </strong><em>file</em></p>
  </dt>
  <dd>
    <p>Use the specified file as a default configuration. If this switch is not used, the configuration is taken from <em>config.sh</em>, when present.</p>
  </dd>
  <dt>
    <p><strong>-h</strong></p>
  </dt>
  <dd>
    <p>Print help message and exit.</p>
  </dd>
  <dt>
    <p><strong>-r</strong></p>
  </dt>
  <dd>
    <p>Reuse C symbols value if possible. This will skip the costly <em>nm</em> symbol extraction. If used the first time (with no previous configuration file), <em>Configure</em> will try to compile and link a small program in order to know about the presence of a symbol, or absence thereof.</p>
  </dd>
  <dt>
    <p><strong>-s</strong></p>
  </dt>
  <dd>
    <p>Silent mode. Only strings printed on file descriptor #4 will be seen on the screen (that's the important messages). It's not possible to completely turn off any output, but you may use '<em>Configure -ders &gt;/dev/null 2&gt;&1</em>' to have a full batch run with no output and no user interaction required.</p>
  </dd>
  <dt>
    <p><strong>-D</strong><em> symbol=value</em></p>
  </dt>
  <dd>
    <p>Pre-defines <em>symbol</em> to bear the specified <em>value</em>. It is also possible to use '<strong>-D</strong><em> symbol</em>' which will use a default value of 'define'.</p>
  </dd>
  <dt>
    <p><strong>-E</strong></p>
  </dt>
  <dd>
    <p>Stop at the end of the configuration questions, after having produced a <em>config.sh</em>. This will not perform any '<em>make depend</em>' or .SH files extraction.</p>
  </dd>
  <dt>
    <p><strong>-K</strong></p>
  </dt>
  <dd>
    <p>Knowledgeable user. When you use this option, you know what you are doing and therefore the <em>config.sh</em> file will always be handled as if it was intended to be re-used, even though it might have been generated on an alien system. It also prevents aborting when <em>Configure</em> detects an unusable C compiler or a wrong set of C flags. Further shortcuts might be turned on by this option as well in the future. This option is documented in the <em>Configure</em> usage message, to remind us about its existence, but the given description is hoped to be cryptic enough. :-)</p>
  </dd>
  <dt>
    <p><strong>-O</strong></p>
  </dt>
  <dd>
    <p>Allow values specified via a <strong>-D</strong> or <strong>-U</strong> to override settings from any loaded configuration file. This is not the default behaviour since the overriding will not be propagated to variables derived from those you are presently altering. Naturally, without <strong>-O</strong>, the setting is only done when no configuration file is loaded, which is safe since derivative variables have not been computed yet...</p>
  </dd>
  <dt>
    <p><strong>-S</strong></p>
  </dt>
  <dd>
    <p>Perform variable substitution on all the .SH files. You can combine it with the <strong>-f</strong> switch to propagate any configuration you like.</p>
  </dd>
  <dt>
    <p><strong>-U</strong><em> symbol=</em></p>
  </dt>
  <dd>
    <p>Pre-sets <em>symbol</em> to bear an empty value. It is also possible to use '<strong>-U</strong><em> symbol</em>' which will set <em>symbol</em> to 'undef'.</p>
  </dd>
  <dt>
    <p><strong>-V</strong></p>
  </dt>
  <dd>
    <p>Print the version number of the <em>metaconfig</em> that generated this <em>Configure</em> script and exit.</p>
  </dd>

</dl>

<h3>Running Environment</h3>
<p>Upon starting, <em>Configure</em> creates a local <em>UU</em> directory and runs from there. The directory is removed when Configure ends, but this means you must run the script from a place where you can write, i.e. not from a read-only file system.</p><p>You can run <em>Configure</em> remotely though, as in: 	../package/Configure to configure sources that are not present locally. All the generated files will be put in the directory where you're running the script from. This magic is done thanks to the src.U unit, which is setting the <em>$src</em> and <em>$rsrc</em> variables to point to the package sources. That path is full or relative, depending on whether <em>Configure</em> was invoked via a full or relative path.</p><p>From within the <em>UU</em> subdirectory, you can use <em>$rsrc</em> to access the source files (units referring to source files link hints shall always use this mechanism and not assume the file is present in the parent directory). All the Makefiles should use the $src variable as a pointer to the sources from the top of the build directory (where <em>Configure</em> is run), either directly or via a VPATH setting.</p><p>When running <em>Configure</em> remotely, the .SH files are extracted in the build directory, not in the source tree. However, it requires some kind of a <em>make</em> support to be able to compile things in a build directory whilst the sources lie elsewhere.</p>
<h3>Using Magic Redefinitions</h3>
<p>By making use of the <strong>-M</strong> switch, some magic remappings may take place within a <em>confmagic.h</em> file. That file needs to be included after <em>config.h</em>, of course, but also after all the other needed include files. Namely: #include "config.h" ... ... <em>other inclusions</em> ... ... #include "confmagic.h" Typically, <em>confmagic.h</em> will attempt to remap <em>bcopy()</em> on <em>memcpy()</em> if no <em>bcopy()</em> is available locally, or transform <em>vfork</em> into <em>fork</em> when necessary, hence making it useless to bother about the <em>HAS_VFORK</em> symbol.</p><p>This configuration magic is documented in the Glossary file.</p>
<h3>Unit Templates</h3>
<p>There is a set of unit templates in the <em>metaconfig</em> source directory, which are intended to be used by a (not yet written) program to quickly produce new units for various kind of situations. No documentation for this unfinished project, but I thought I would mention it in the manual page in case you wish to do it yourself and then contribute it...</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p>Larry Wall &lt;lwall@netlabs.com&gt; for version 2.0.</p><p>Harlan Stenn &lt;harlan@mumps.pfcs.com&gt; for important unit extensions.</p><p>Raphael Manfredi &lt;ram@hptnos02.grenoble.hp.com&gt;.</p><p>Many other contributors for the <em>metaconfig</em> units. See the credit file for a list.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILES</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p>LIB/dist/mcon/U/*.U</p>
  </dt>
  <dd>
    <p>Public unit files</p>
  </dd>
  <dt>
    <p>U/*.U</p>
  </dt>
  <dd>
    <p>Private unit files</p>
  </dd>
  <dt>
    <p>LIB/dist/mcon/Glossary</p>
  </dt>
  <dd>
    <p>Glossary file, describing all the metaconfig symbols.</p>
  </dd>
  <dt>
    <p>Obsolete</p>
  </dt>
  <dd>
    <p>Lists all the obsolete symbols used by the sources.</p>
  </dd>
  <dt>
    <p>Wanted</p>
  </dt>
  <dd>
    <p>Lists all the wanted symbols.</p><p>where LIB is /usr/share/dist.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>Units are sometimes included unnecessarily if one of its symbols is accidentally mentioned, e.g. in a comment. Better too many units than too few, however.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO metaconfig&hellip;</h2>
        <div class="sectioncontent">
<p><strong>pat</strong>(1), <a href="../man1/makeSH.1.html"><strong>makeSH</strong>(1)</a>, <strong>makedist</strong>(1), <a href="../man1/metalint.1.html"><strong>metalint</strong>(1)</a></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="metacity-window-demo.1.html"><span aria-hidden="true">&larr;</span> metacity-window-demo.1: Demo of window features</a></li>
   <li class="next"><a href="metaflac.1.html">metaflac.1: Metaflac        program to list, add, remove, or edit metadata in one or more flac files. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

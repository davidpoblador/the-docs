<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>perf_3.16-script-python: Process trace data with a python script</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Process trace data with a python script">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="perf_3.16-script-python (1) manual">
  <meta name="twitter:description" content="Process trace data with a python script">
  <meta name="twitter:image" content="https://www.carta.tech/images/linux-tools-3.16-perf_3.16-script-python-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/perf_3.16-script-python.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="perf_3.16-script-python (1) manual" />
  <meta property="og:description" content="Process trace data with a python script" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/linux-tools-3.16-perf_3.16-script-python-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">perf_3.16-script-python<small> (1)</small></h1>
        <p class="lead">Process trace data with a python script</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/perf_3.16-script-python.1.html">
      <span itemprop="name">perf_3.16-script-python: Process trace data with a python script</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/linux-tools-3.16/">
      <span itemprop="name">linux-tools-3.16</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/perf_3.16-script-python.1.html">
      <span itemprop="name">perf_3.16-script-python: Process trace data with a python script</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
<em>perf script</em> [-s [Python]:script[.py] ]
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This perf script option is used to process perf script data using perf\(cqs built-in Python interpreter. It reads and processes the input file and displays the results of the trace analysis implemented in the given Python script, if any.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">A QUICK EXAMPLE</h2>
        <div class="sectioncontent">
<p>This section shows the process, start to finish, of creating a working Python script that aggregates and extracts useful information from a raw perf script stream. You can avoid reading the rest of this document if an example is enough for you; the rest of the document provides more details on each step and lists the library functions available to script writers.</p><p>This example actually details the steps that were used to create the <em>syscall-counts</em> script you see when you list the available perf script scripts via <em>perf script -l</em>. As such, this script also shows how to integrate your script into the list of general-purpose <em>perf script</em> scripts listed by that command.</p><p>The syscall-counts script is a simple script, but demonstrates all the basic ideas necessary to create a useful script. Here\(cqs an example of its output (syscall names are not yet supported, they will appear as numbers):</p>
<pre>
.ft C
syscall events:

event                                          count
----------------------------------------  -----------
sys_write                                     455067
sys_getdents                                    4072
sys_close                                       3037
sys_swapoff                                     1769
sys_read                                         923
sys_sched_setparam                               826
sys_open                                         331
sys_newfstat                                     326
sys_mmap                                         217
sys_munmap                                       216
sys_futex                                        141
sys_select                                       102
sys_poll                                          84
sys_setitimer                                     12
sys_writev                                         8
15                                                 8
sys_lseek                                          7
sys_rt_sigprocmask                                 6
sys_wait4                                          3
sys_ioctl                                          3
sys_set_robust_list                                1
sys_exit                                           1
56                                                 1
sys_access                                         1
.ft

</pre>
<p>Basically our task is to keep a per-syscall tally that gets updated every time a system call occurs in the system. Our script will do that, but first we need to record the data that will be processed by that script. Theoretically, there are a couple of ways we could do that:</p><p>we could enable every event under the tracing/events/syscalls directory, but this is over 600 syscalls, well beyond the number allowable by perf. These individual syscall events will however be useful if we want to later use the guidance we get from the general-purpose scripts to drill down and get more detail about individual syscalls of interest.</p><p>we can enable the sys_enter and/or sys_exit syscalls found under tracing/events/raw_syscalls. These are called for all syscalls; the <em>id</em> field can be used to distinguish between individual syscall numbers.</p><p>For this script, we only need to know that a syscall was entered; we don\(cqt care how it exited, so we\(cqll use <em>perf record</em> to record only the sys_enter events:</p>
<pre>
.ft C
# perf record -a -e raw_syscalls:sys_enter

^C[ perf record: Woken up 1 times to write data ]
[ perf record: Captured and wrote 56.545 MB perf.data (~2470503 samples) ]
.ft

</pre>
<p>The options basically say to collect data for every syscall event system-wide and multiplex the per-cpu output into a single stream. That single stream will be recorded in a file in the current directory called perf.data.</p><p>Once we have a perf.data file containing our data, we can use the -g <em>perf script</em> option to generate a Python script that will contain a callback handler for each event type found in the perf.data trace stream (for more details, see the STARTER SCRIPTS section).</p>
<pre>
.ft C
# perf script -g python
generated Python script: perf-script.py

The output file created also in the current directory is named
perf-script.py.  Here&apos;s the file in its entirety:

# perf script event handlers, generated by perf script -g python
# Licensed under the terms of the GNU GPL License version 2

# The common_* event handler fields are the most useful fields common to
# all events.  They don&apos;t necessarily correspond to the &apos;common_*&apos; fields
# in the format files.  Those fields not available as handler params can
# be retrieved using Python functions of the form common_*(context).
# See the perf-script-python Documentation for the list of available functions.

import os
import sys

sys.path.append(os.environ[&apos;PERF_EXEC_PATH&apos;] + &#92;
        &apos;/scripts/python/Perf-Trace-Util/lib/Perf/Trace&apos;)

from perf_trace_context import *
from Core import *

def trace_begin():
        print "in trace_begin"

def trace_end():
        print "in trace_end"

def raw_syscalls__sys_enter(event_name, context, common_cpu,
        common_secs, common_nsecs, common_pid, common_comm,
        id, args):
                print_header(event_name, common_cpu, common_secs, common_nsecs,
                        common_pid, common_comm)

                print "id=%d, args=%s&#92;n" % &#92;
                (id, args),

def trace_unhandled(event_name, context, common_cpu, common_secs, common_nsecs,
                common_pid, common_comm):
                print_header(event_name, common_cpu, common_secs, common_nsecs,
                common_pid, common_comm)

def print_header(event_name, cpu, secs, nsecs, pid, comm):
        print "%-20s %5u %05u.%09u %8u %-20s " % &#92;
        (event_name, cpu, secs, nsecs, pid, comm),
.ft

</pre>
<p>At the top is a comment block followed by some import statements and a path append which every perf script script should include.</p><p>Following that are a couple generated functions, trace_begin() and trace_end(), which are called at the beginning and the end of the script respectively (for more details, see the SCRIPT_LAYOUT section below).</p><p>Following those are the <em>event handler</em> functions generated one for every event in the <em>perf record</em> output. The handler functions take the form subsystem<em>event_name, and contain named parameters, one for each field in the event; in this case, there\(cqs only one event, raw_syscalls</em>sys_enter(). (see the EVENT HANDLERS section below for more info on event handlers).</p><p>The final couple of functions are, like the begin and end functions, generated for every script. The first, trace_unhandled(), is called every time the script finds an event in the perf.data file that doesn\(cqt correspond to any event handler in the script. This could mean either that the record step recorded event types that it wasn\(cqt really interested in, or the script was run against a trace file that doesn\(cqt correspond to the script.</p><p>The script generated by -g option simply prints a line for each event found in the trace stream i.e. it basically just dumps the event and its parameter values to stdout. The print_header() function is simply a utility function used for that purpose. Let\(cqs rename the script and run it to see the default output:</p>
<pre>
.ft C
# mv perf-script.py syscall-counts.py
# perf script -s syscall-counts.py

raw_syscalls__sys_enter     1 00840.847582083     7506 perf                  id=1, args=
raw_syscalls__sys_enter     1 00840.847595764     7506 perf                  id=1, args=
raw_syscalls__sys_enter     1 00840.847620860     7506 perf                  id=1, args=
raw_syscalls__sys_enter     1 00840.847710478     6533 npviewer.bin          id=78, args=
raw_syscalls__sys_enter     1 00840.847719204     6533 npviewer.bin          id=142, args=
raw_syscalls__sys_enter     1 00840.847755445     6533 npviewer.bin          id=3, args=
raw_syscalls__sys_enter     1 00840.847775601     6533 npviewer.bin          id=3, args=
raw_syscalls__sys_enter     1 00840.847781820     6533 npviewer.bin          id=3, args=
.
.
.
.ft

</pre>
<p>Of course, for this script, we\(cqre not interested in printing every trace event, but rather aggregating it in a useful way. So we\(cqll get rid of everything to do with printing as well as the trace_begin() and trace_unhandled() functions, which we won\(cqt be using. That leaves us with this minimalistic skeleton:</p>
<pre>
.ft C
import os
import sys

sys.path.append(os.environ[&apos;PERF_EXEC_PATH&apos;] + &#92;
        &apos;/scripts/python/Perf-Trace-Util/lib/Perf/Trace&apos;)

from perf_trace_context import *
from Core import *

def trace_end():
        print "in trace_end"

def raw_syscalls__sys_enter(event_name, context, common_cpu,
        common_secs, common_nsecs, common_pid, common_comm,
        id, args):
.ft

</pre>
<p>In trace_end(), we\(cqll simply print the results, but first we need to generate some results to print. To do that we need to have our sys_enter() handler do the necessary tallying until all events have been counted. A hash table indexed by syscall id is a good way to store that information; every time the sys_enter() handler is called, we simply increment a count associated with that hash entry indexed by that syscall id:</p>
<pre>
.ft C
  syscalls = autodict()

  try:
    syscalls[id] += 1
  except TypeError:
    syscalls[id] = 1
.ft

</pre>
<p>The syscalls <em>autodict</em> object is a special kind of Python dictionary (implemented in Core.py) that implements Perl\(cqs <em>autovivifying</em> hashes in Python i.e. with autovivifying hashes, you can assign nested hash values without having to go to the trouble of creating intermediate levels if they don\(cqt exist e.g syscalls[comm][pid][id] = 1 will create the intermediate hash levels and finally assign the value 1 to the hash entry for <em>id</em> (because the value being assigned isn\(cqt a hash object itself, the initial value is assigned in the TypeError exception. Well, there may be a better way to do this in Python but that\(cqs what works for now).</p><p>Putting that code into the raw_syscalls__sys_enter() handler, we effectively end up with a single-level dictionary keyed on syscall id and having the counts we\(cqve tallied as values.</p><p>The print_syscall_totals() function iterates over the entries in the dictionary and displays a line for each entry containing the syscall name (the dictonary keys contain the syscall ids, which are passed to the Util function syscall_name(), which translates the raw syscall numbers to the corresponding syscall name strings). The output is displayed after all the events in the trace have been processed, by calling the print_syscall_totals() function from the trace_end() handler called at the end of script processing.</p><p>The final script producing the output shown above is shown in its entirety below (syscall_name() helper is not yet available, you can only deal with id\(cqs for now):</p>
<pre>
.ft C
import os
import sys

sys.path.append(os.environ[&apos;PERF_EXEC_PATH&apos;] + &#92;
        &apos;/scripts/python/Perf-Trace-Util/lib/Perf/Trace&apos;)

from perf_trace_context import *
from Core import *
from Util import *

syscalls = autodict()

def trace_end():
        print_syscall_totals()

def raw_syscalls__sys_enter(event_name, context, common_cpu,
        common_secs, common_nsecs, common_pid, common_comm,
        id, args):
        try:
                syscalls[id] += 1
        except TypeError:
                syscalls[id] = 1

def print_syscall_totals():
    if for_comm is not None:
            print "&#92;nsyscall events for %s:&#92;n&#92;n" % (for_comm),
    else:
            print "&#92;nsyscall events:&#92;n&#92;n",

    print "%-40s  %10s&#92;n" % ("event", "count"),
    print "%-40s  %10s&#92;n" % ("----------------------------------------", &#92;
                                 "-----------"),

    for id, val in sorted(syscalls.iteritems(), key = lambda(k, v): (v, k), &#92;
                                  reverse = True):
            print "%-40s  %10d&#92;n" % (syscall_name(id), val),
.ft

</pre>
<p>The script can be run just as before:</p>
<pre>
# perf script -s syscall-counts.py
</pre>
<p>So those are the essential steps in writing and running a script. The process can be generalized to any tracepoint or set of tracepoints you\(cqre interested in - basically find the tracepoint(s) you\(cqre interested in by looking at the list of available events shown by <em>perf list</em> and/or look in /sys/kernel/debug/tracing events for detailed event and field info, record the corresponding trace data using <em>perf record</em>, passing it the list of interesting events, generate a skeleton script using <em>perf script -g python</em> and modify the code to aggregate and display it for your particular needs.</p><p>After you\(cqve done that you may end up with a general-purpose script that you want to keep around and have available for future use. By writing a couple of very simple shell scripts and putting them in the right place, you can have your script listed alongside the other scripts listed by the <em>perf script -l</em> command e.g.:</p>
<pre>
.ft C
root@tropicana:~# perf script -l
List of available trace scripts:
  wakeup-latency                       system-wide min/max/avg wakeup latency
  rw-by-file &lt;comm&gt;                    r/w activity for a program, by file
  rw-by-pid                            system-wide r/w activity
.ft

</pre>
<p>A nice side effect of doing this is that you also then capture the probably lengthy <em>perf record</em> command needed to record the events for the script.</p><p>To have the script appear as a <em>built-in</em> script, you write two simple scripts, one for recording and one for <em>reporting</em>.</p><p>The <em>record</em> script is a shell script with the same base name as your script, but with -record appended. The shell script should be put into the perf/scripts/python/bin directory in the kernel source tree. In that script, you write the <em>perf record</em> command-line needed for your script:</p>
<pre>
.ft C
# cat kernel-source/tools/perf/scripts/python/bin/syscall-counts-record

#!/bin/bash
perf record -a -e raw_syscalls:sys_enter
.ft

</pre>
<p>The <em>report</em> script is also a shell script with the same base name as your script, but with -report appended. It should also be located in the perf/scripts/python/bin directory. In that script, you write the <em>perf script -s</em> command-line needed for running your script:</p>
<pre>
.ft C
# cat kernel-source/tools/perf/scripts/python/bin/syscall-counts-report

#!/bin/bash
# description: system-wide syscall counts
perf script -s ~/libexec/perf-core/scripts/python/syscall-counts.py
.ft

</pre>
<p>Note that the location of the Python script given in the shell script is in the libexec/perf-core/scripts/python directory - this is where the script will be copied by <em>make install</em> when you install perf. For the installation to install your script there, your script needs to be located in the perf/scripts/python directory in the kernel source tree:</p>
<pre>
.ft C
# ls -al kernel-source/tools/perf/scripts/python

root@tropicana:/home/trz/src/tip# ls -al tools/perf/scripts/python
total 32
drwxr-xr-x 4 trz trz 4096 2010-01-26 22:30 .
drwxr-xr-x 4 trz trz 4096 2010-01-26 22:29 ..
drwxr-xr-x 2 trz trz 4096 2010-01-26 22:29 bin
-rw-r--r-- 1 trz trz 2548 2010-01-26 22:29 check-perf-script.py
drwxr-xr-x 3 trz trz 4096 2010-01-26 22:49 Perf-Trace-Util
-rw-r--r-- 1 trz trz 1462 2010-01-26 22:30 syscall-counts.py
.ft

</pre>
<p>Once you\(cqve done that (don\(cqt forget to do a new <em>make install</em>, otherwise your script won\(cqt show up at run-time), <em>perf script -l</em> should show a new entry for your script:</p>
<pre>
.ft C
root@tropicana:~# perf script -l
List of available trace scripts:
  wakeup-latency                       system-wide min/max/avg wakeup latency
  rw-by-file &lt;comm&gt;                    r/w activity for a program, by file
  rw-by-pid                            system-wide r/w activity
  syscall-counts                       system-wide syscall counts
.ft

</pre>
<p>You can now perform the record step via <em>perf script record</em>:</p>
<pre>
# perf script record syscall-counts
</pre>
<p>and display the output using <em>perf script report</em>:</p>
<pre>
# perf script report syscall-counts
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">STARTER SCRIPTS</h2>
        <div class="sectioncontent">
<p>You can quickly get started writing a script for a particular set of trace data by generating a skeleton script using <em>perf script -g python</em> in the same directory as an existing perf.data trace file. That will generate a starter script containing a handler for each of the event types in the trace file; it simply prints every available field for each event in the trace file.</p><p>You can also look at the existing scripts in ~/libexec/perf-core/scripts/python for typical examples showing how to do basic things like aggregate event data, print results, etc. Also, the check-perf-script.py script, while not interesting for its results, attempts to exercise all of the main scripting features.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EVENT HANDLERS</h2>
        <div class="sectioncontent">
<p>When perf script is invoked using a trace script, a user-defined <em>handler function</em> is called for each event in the trace. If there\(cqs no handler function defined for a given event type, the event is ignored (or passed to a <em>trace_handled</em> function, see below) and the next event is processed.</p><p>Most of the event\(cqs field values are passed as arguments to the handler function; some of the less common ones aren\(cqt - those are available as calls back into the perf executable (see below).</p><p>As an example, the following perf record command can be used to record all sched_wakeup events in the system:</p>
<pre>
# perf record -a -e sched:sched_wakeup
</pre>
<p>Traces meant to be processed using a script should be recorded with the above option: -a to enable system-wide collection.</p><p>The format file for the sched_wakep event defines the following fields (see /sys/kernel/debug/tracing/events/sched/sched_wakeup/format):</p>
<pre>
.ft C
 format:
        field:unsigned short common_type;
        field:unsigned char common_flags;
        field:unsigned char common_preempt_count;
        field:int common_pid;

        field:char comm[TASK_COMM_LEN];
        field:pid_t pid;
        field:int prio;
        field:int success;
        field:int target_cpu;
.ft

</pre>
<p>The handler function for this event would be defined as:</p>
<pre>
.ft C
def sched__sched_wakeup(event_name, context, common_cpu, common_secs,
       common_nsecs, common_pid, common_comm,
       comm, pid, prio, success, target_cpu):
       pass
.ft

</pre>
<p>The handler function takes the form subsystem__event_name.</p><p>The common_* arguments in the handler\(cqs argument list are the set of arguments passed to all event handlers; some of the fields correspond to the common_* fields in the format file, but some are synthesized, and some of the common_* fields aren\(cqt common enough to to be passed to every event as arguments but are available as library functions.</p><p>Here\(cqs a brief description of each of the invariant event args:</p>
<pre>
event_name                 the name of the event as text
context                    an opaque &apos;cookie&apos; used in calls back into perf
common_cpu                 the cpu the event occurred on
common_secs                the secs portion of the event timestamp
common_nsecs               the nsecs portion of the event timestamp
common_pid                 the pid of the current task
common_comm                the name of the current process
</pre>
<p>All of the remaining fields in the event\(cqs format file have counterparts as handler function arguments of the same name, as can be seen in the example above.</p><p>The above provides the basics needed to directly access every field of every event in a trace, which covers 90% of what you need to know to write a useful trace script. The sections below cover the rest.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SCRIPT LAYOUT</h2>
        <div class="sectioncontent">
<p>Every perf script Python script should start by setting up a Python module search path and &apos;import\(cqing a few support modules (see module descriptions below):</p>
<pre>
.ft C
 import os
 import sys

 sys.path.append(os.environ[&apos;PERF_EXEC_PATH&apos;] + &#92;
              &apos;/scripts/python/Perf-Trace-Util/lib/Perf/Trace&apos;)

 from perf_trace_context import *
 from Core import *
.ft

</pre>
<p>The rest of the script can contain handler functions and support functions in any order.</p><p>Aside from the event handler functions discussed above, every script can implement a set of optional functions:</p><p><strong>trace_begin</strong>, if defined, is called before any event is processed and gives scripts a chance to do setup tasks:</p>
<pre>
.ft C
def trace_begin:
    pass
.ft

</pre>
<p><strong>trace_end</strong>, if defined, is called after all events have been processed and gives scripts a chance to do end-of-script tasks, such as display results:</p>
<pre>
.ft C
def trace_end:
    pass
.ft

</pre>
<p><strong>trace_unhandled</strong>, if defined, is called after for any event that doesn\(cqt have a handler explicitly defined for it. The standard set of common arguments are passed into it:</p>
<pre>
.ft C
def trace_unhandled(event_name, context, common_cpu, common_secs,
        common_nsecs, common_pid, common_comm):
    pass
.ft

</pre>
<p>The remaining sections provide descriptions of each of the available built-in perf script Python modules and their associated functions.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AVAILABLE MODULES AND FUNCTIONS</h2>
        <div class="sectioncontent">
<p>The following sections describe the functions and variables available via the various perf script Python modules. To use the functions and variables from the given module, add the corresponding <em>from XXXX import</em> line to your perf script script.</p><h3>Core.py Module</h3>
<p>These functions provide some essential functions to user scripts.</p><p>The <strong>flag_str</strong> and <strong>symbol_str</strong> functions provide human-readable strings for flag and symbolic fields. These correspond to the strings and values parsed from the <em>print fmt</em> fields of the event format files:</p>
<pre>
flag_str(event_name, field_name, field_value) - returns the string represention corresponding to field_value for the flag field field_name of event event_name
symbol_str(event_name, field_name, field_value) - returns the string represention corresponding to field_value for the symbolic field field_name of event event_name
</pre>
<p>The <strong>autodict</strong> function returns a special kind of Python dictionary that implements Perl\(cqs <em>autovivifying</em> hashes in Python i.e. with autovivifying hashes, you can assign nested hash values without having to go to the trouble of creating intermediate levels if they don\(cqt exist.</p>
<pre>
autodict() - returns an autovivifying dictionary instance
</pre>

<h3>perf_trace_context Module</h3>
<p>Some of the <em>common</em> fields in the event format file aren\(cqt all that common, but need to be made accessible to user scripts nonetheless.</p><p>perf_trace_context defines a set of functions that can be used to access this data in the context of the current event. Each of these functions expects a context variable, which is the same as the context variable passed into every event handler as the second argument.</p>
<pre>
common_pc(context) - returns common_preempt count for the current event
common_flags(context) - returns common_flags for the current event
common_lock_depth(context) - returns common_lock_depth for the current event
</pre>

<h3>Util.py Module</h3>
<p>Various utility functions for use with perf script:</p>
<pre>
nsecs(secs, nsecs) - returns total nsecs given secs/nsecs pair
nsecs_secs(nsecs) - returns whole secs portion given nsecs
nsecs_nsecs(nsecs) - returns nsecs remainder given nsecs
nsecs_str(nsecs) - returns printable string in the form secs.nsecs
avg(total, n) - returns average given a sum and a total number of values
</pre>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO perf_3.16-script-python&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man1/perf_3.16-script.1.html"><strong>perf_3.16-script</strong>(1)</a></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="perf_3.16-script-perl.1.html"><span aria-hidden="true">&larr;</span> perf_3.16-script-perl.1: Process trace data with a perl script</a></li>
   <li class="next"><a href="perf_3.16-stat.1.html">perf_3.16-stat.1: Run a command and gather performance counter statistics <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

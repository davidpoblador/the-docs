<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>fio: Flexible i/o tester</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Flexible i/o tester">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="fio (1) manual">
  <meta name="twitter:description" content="Flexible i/o tester">
  <meta name="twitter:image" content="https://www.carta.tech/images/fio-fio-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/fio.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="fio (1) manual" />
  <meta property="og:description" content="Flexible i/o tester" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/fio-fio-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">fio<small> (1)</small></h1>
        <p class="lead">Flexible i/o tester</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/fio.1.html">
      <span itemprop="name">fio: Flexible i/o tester</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/fio/">
      <span itemprop="name">fio</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/fio.1.html">
      <span itemprop="name">fio: Flexible i/o tester</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>fio</strong> [<em>options</em>] [<em>jobfile</em>]...</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><strong>fio</strong> is a tool that will spawn a number of threads or processes doing a particular type of I/O action as specified by the user. The typical use of fio is to write a job file matching the I/O load one wants to simulate.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>--debug</strong><em></em>=<em>type</em></p>
  </dt>
  <dd>
    <p>Enable verbose tracing of various fio actions. May be `all' for all types or individual types separated by a comma (eg --debug=io,file). `help' will list all available tracing options.</p>
  </dd>
  <dt>
    <p><strong>--output</strong><em></em>=<em>filename</em></p>
  </dt>
  <dd>
    <p>Write output to <em>filename</em>.</p>
  </dd>
  <dt>
    <p><strong>--runtime</strong><em></em>=<em>runtime</em></p>
  </dt>
  <dd>
    <p>Limit run time to <em>runtime</em> seconds.</p>
  </dd>
  <dt>
    <p><strong>--latency-log</strong></p>
  </dt>
  <dd>
    <p>Generate per-job latency logs.</p>
  </dd>
  <dt>
    <p><strong>--bandwidth-log</strong></p>
  </dt>
  <dd>
    <p>Generate per-job bandwidth logs.</p>
  </dd>
  <dt>
    <p><strong>--minimal</strong></p>
  </dt>
  <dd>
    <p>Print statistics in a terse, semicolon-delimited format.</p>
  </dd>
  <dt>
    <p><strong>--append-terse</strong></p>
  </dt>
  <dd>
    <p>Print statistics in selected mode AND terse, semicolon-delimited format.</p>
  </dd>
  <dt>
    <p><strong>--version</strong></p>
  </dt>
  <dd>
    <p>Display version information and exit.</p>
  </dd>
  <dt>
    <p><strong>--terse-version</strong><em></em>=<em>version</em></p>
  </dt>
  <dd>
    <p>Set terse version output format (Current version 3, or older version 2).</p>
  </dd>
  <dt>
    <p><strong>--help</strong></p>
  </dt>
  <dd>
    <p>Display usage information and exit.</p>
  </dd>
  <dt>
    <p><strong>--cpuclock-test</strong></p>
  </dt>
  <dd>
    <p>Perform test and validation of internal CPU clock</p>
  </dd>
  <dt>
    <p><strong>--crctest[</strong>=<strong>test]</strong></p>
  </dt>
  <dd>
    <p>Test the speed of the builtin checksumming functions. If no argument is given, all of them are tested. Or a comma separated list can be passed, in which case the given ones are tested.</p>
  </dd>
  <dt>
    <p><strong>--cmdhelp</strong><em></em>=<em>command</em></p>
  </dt>
  <dd>
    <p>Print help information for <em>command</em>.  May be `all' for all commands.</p>
  </dd>
  <dt>
    <p><strong>--enghelp</strong><em></em>=<em>ioengine[,command]</em></p>
  </dt>
  <dd>
    <p>List all commands defined by <em>ioengine</em>, or print help for <em>command</em> defined by <em>ioengine</em>.</p>
  </dd>
  <dt>
    <p><strong>--showcmd</strong><em></em>=<em>jobfile</em></p>
  </dt>
  <dd>
    <p>Convert <em>jobfile</em> to a set of command-line options.</p>
  </dd>
  <dt>
    <p><strong>--eta</strong><em></em>=<em>when</em></p>
  </dt>
  <dd>
    <p>Specifies when real-time ETA estimate should be printed.  <em>when</em> may be one of `always', `never' or `auto'.</p>
  </dd>
  <dt>
    <p><strong>--eta-newline</strong><em></em>=<em>time</em></p>
  </dt>
  <dd>
    <p>Force an ETA newline for every `time` period passed.</p>
  </dd>
  <dt>
    <p><strong>--status-interval</strong><em></em>=<em>time</em></p>
  </dt>
  <dd>
    <p>Report full output status every `time` period passed.</p>
  </dd>
  <dt>
    <p><strong>--readonly</strong></p>
  </dt>
  <dd>
    <p>Turn on safety read-only checks, preventing any attempted write.</p>
  </dd>
  <dt>
    <p><strong>--section</strong><em></em>=<em>sec</em></p>
  </dt>
  <dd>
    <p>Only run section <em>sec</em> from job file. This option can be used multiple times to add more sections to run.</p>
  </dd>
  <dt>
    <p><strong>--alloc-size</strong><em></em>=<em>kb</em></p>
  </dt>
  <dd>
    <p>Set the internal smalloc pool size to <em>kb</em> kilobytes.</p>
  </dd>
  <dt>
    <p><strong>--warnings-fatal</strong></p>
  </dt>
  <dd>
    <p>All fio parser warnings are fatal, causing fio to exit with an error.</p>
  </dd>
  <dt>
    <p><strong>--max-jobs</strong><em></em>=<em>nr</em></p>
  </dt>
  <dd>
    <p>Set the maximum allowed number of jobs (threads/processes) to support.</p>
  </dd>
  <dt>
    <p><strong>--server</strong><em></em>=<em>args</em></p>
  </dt>
  <dd>
    <p>Start a backend server, with <em>args</em> specifying what to listen to. See client/server section.</p>
  </dd>
  <dt>
    <p><strong>--daemonize</strong><em></em>=<em>pidfile</em></p>
  </dt>
  <dd>
    <p>Background a fio server, writing the pid to the given pid file.</p>
  </dd>
  <dt>
    <p><strong>--client</strong><em></em>=<em>host</em></p>
  </dt>
  <dd>
    <p>Instead of running the jobs locally, send and run them on the given host.</p>
  </dd>
  <dt>
    <p><strong>--idle-prof</strong><em></em>=<em>option</em></p>
  </dt>
  <dd>
    <p>Report cpu idleness on a system or percpu basis (<em>option</em>=system,percpu) or run unit work calibration only (<em>option</em>=calibrate).</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">JOB FILE FORMAT</h2>
        <div class="sectioncontent">
<p>Job files are in `ini' format. They consist of one or more job definitions, which begin with a job name in square brackets and extend to the next job name.  The job name can be any ASCII string except `global', which has a special meaning.  Following the job name is a sequence of zero or more parameters, one per line, that define the behavior of the job.  Any line starting with a `;' or `#' character is considered a comment and ignored.</p><p>If <em>jobfile</em> is specified as `-', the job file will be read from standard input.</p><h3>Global Section</h3>
<p>The global section contains default parameters for jobs specified in the job file.  A job is only affected by global sections residing above it, and there may be any number of global sections.  Specific job definitions may override any parameter set in global sections.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">JOB PARAMETERS</h2>
        <div class="sectioncontent">
<h3>Types</h3>
<p>Some parameters may take arguments of a specific type.  The types used are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>str</em></p>
  </dt>
  <dd>
    <p>String: a sequence of alphanumeric characters.</p>
  </dd>
  <dt>
    <p><em>int</em></p>
  </dt>
  <dd>
    <p>SI integer: a whole number, possibly containing a suffix denoting the base unit of the value.  Accepted suffixes are `k', 'M', 'G', 'T', and 'P', denoting kilo (1024), mega (1024^2), giga (1024^3), tera (1024^4), and peta (1024^5) respectively. If prefixed with '0x', the value is assumed to be base 16 (hexadecimal). A suffix may include a trailing 'b', for instance 'kb' is identical to 'k'. You can specify a base 10 value by using 'KiB', 'MiB','GiB', etc. This is useful for disk drives where values are often given in base 10 values. Specifying '30GiB' will get you 30*1000^3 bytes. When specifying times the default suffix meaning changes, still denoting the base unit of the value, but accepted suffixes are 'D' (days), 'H' (hours), 'M' (minutes), 'S' Seconds, 'ms' (or msec) milli seconds, 'us' (or 'usec') micro seconds. Time values without a unit specify seconds. The suffixes are not case sensitive.</p>
  </dd>
  <dt>
    <p><em>bool</em></p>
  </dt>
  <dd>
    <p>Boolean: a true or false value. `0' denotes false, `1' denotes true.</p>
  </dd>
  <dt>
    <p><em>irange</em></p>
  </dt>
  <dd>
    <p>Integer range: a range of integers specified in the format <em>lower</em>:<em>upper</em> or <em>lower</em>-<em>upper</em>. <em>lower</em> and <em>upper</em> may contain a suffix as described above.  If an option allows two sets of ranges, they are separated with a `,' or `/' character. For example: `8-8k/8M-4G'.</p>
  </dd>
  <dt>
    <p><em>float_list</em></p>
  </dt>
  <dd>
    <p>List of floating numbers: A list of floating numbers, separated by a ':' character.</p>
  </dd>

</dl>

<h3>Parameter List</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong>name</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>May be used to override the job name.  On the command line, this parameter has the special purpose of signalling the start of a new job.</p>
  </dd>
  <dt>
    <p><strong>description</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>Human-readable description of the job. It is printed when the job is run, but otherwise has no special purpose.</p>
  </dd>
  <dt>
    <p><strong>directory</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>Prefix filenames with this directory.  Used to place files in a location other than `./'. You can specify a number of directories by separating the names with a ':' character. These directories will be assigned equally distributed to job clones creates with <em>numjobs</em> as long as they are using generated filenames. If specific <em>filename(s)</em> are set fio will use the first listed directory, and thereby matching the  <em>filename</em> semantic which generates a file each clone if not specified, but let all clones use the same if set. See <em>filename</em> for considerations regarding escaping certain characters on some platforms.</p>
  </dd>
  <dt>
    <p><strong>filename</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p><strong>fio</strong> normally makes up a file name based on the job name, thread number, and file number. If you want to share files between threads in a job or several jobs, specify a <em>filename</em> for each of them to override the default. If the I/O engine is file-based, you can specify a number of files by separating the names with a `:' character. `-' is a reserved name, meaning stdin or stdout, depending on the read/write direction set. On Windows, disk devices are accessed as &#92;.\PhysicalDrive0 for the first device, &#92;.\PhysicalDrive1 for the second etc. Note: Windows and FreeBSD prevent write access to areas of the disk containing in-use data (e.g. filesystems). If the wanted filename does need to include a colon, then escape that with a '&#92;' character. For instance, if the filename is "/dev/dsk/foo@3,0:c", then you would use filename="/dev/dsk/foo@3,0\c".</p>
  </dd>
  <dt>
    <p><strong>filename_format</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>If sharing multiple files between jobs, it is usually necessary to have fio generate the exact names that you want. By default, fio will name a file based on the default file format specification of <strong>jobname.jobnumber.filenumber</strong>. With this option, that can be customized. Fio will recognize and replace the following keywords in this string:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>$jobname</strong></p>
  </dt>
  <dd>
    <p>The name of the worker thread or process.</p>
  </dd>
  <dt>
    <p><strong>$jobnum</strong></p>
  </dt>
  <dd>
    <p>The incremental number of the worker thread or process.</p>
  </dd>
  <dt>
    <p><strong>$filenum</strong></p>
  </dt>
  <dd>
    <p>The incremental number of the file for that worker thread or process.</p>
  </dd>

</dl>
<p>To have dependent jobs share a set of files, this option can be set to have fio generate filenames that are shared between the two. For instance, if <strong>testfiles.$filenum</strong> is specified, file number 4 for any job will be named <strong>testfiles.4</strong>. The default of <strong>$jobname.$jobnum.$filenum</strong> will be used if no other format specifier is given.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p><strong>lockfile</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>Fio defaults to not locking any files before it does IO to them. If a file or file descriptor is shared, fio can serialize IO to that file to make the end result consistent. This is usual for emulating real workloads that share files. The lock modes are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>none</strong></p>
  </dt>
  <dd>
    <p>No locking. This is the default.</p>
  </dd>
  <dt>
    <p><strong>exclusive</strong></p>
  </dt>
  <dd>
    <p>Only one thread or process may do IO at a time, excluding all others.</p>
  </dd>
  <dt>
    <p><strong>readwrite</strong></p>
  </dt>
  <dd>
    <p>Read-write locking on the file. Many readers may access the file at the same time, but writes get exclusive access.</p>
  </dd>

</dl>

  </dd>

</dl>
<p><strong>opendir</strong><em></em>=<em>str</em> Recursively open any files below directory <em>str</em>.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>readwrite</strong><em></em>=<em>str</em><strong></strong>,<strong> rw</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>Type of I/O pattern.  Accepted values are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>read</strong></p>
  </dt>
  <dd>
    <p>Sequential reads.</p>
  </dd>
  <dt>
    <p><strong>write</strong></p>
  </dt>
  <dd>
    <p>Sequential writes.</p>
  </dd>
  <dt>
    <p><strong>trim</strong></p>
  </dt>
  <dd>
    <p>Sequential trim (Linux block devices only).</p>
  </dd>
  <dt>
    <p><strong>randread</strong></p>
  </dt>
  <dd>
    <p>Random reads.</p>
  </dd>
  <dt>
    <p><strong>randwrite</strong></p>
  </dt>
  <dd>
    <p>Random writes.</p>
  </dd>
  <dt>
    <p><strong>randtrim</strong></p>
  </dt>
  <dd>
    <p>Random trim (Linux block devices only).</p>
  </dd>
  <dt>
    <p><strong>rw, readwrite</strong></p>
  </dt>
  <dd>
    <p>Mixed sequential reads and writes.</p>
  </dd>
  <dt>
    <p><strong>randrw</strong></p>
  </dt>
  <dd>
    <p>Mixed random reads and writes.</p>
  </dd>

</dl>
<p>For mixed I/O, the default split is 50/50. For certain types of io the result may still be skewed a bit, since the speed may be different. It is possible to specify a number of IO's to do before getting a new offset, this is done by appending a `:<em>&lt;nr&gt;</em> to the end of the string given. For a random read, it would look like <strong>rw=randread:8</strong> for passing in an offset modifier with a value of 8. If the postfix is used with a sequential IO pattern, then the value specified will be added to the generated offset for each IO. For instance, using <strong>rw=write:4k</strong> will skip 4k for every write. It turns sequential IO into sequential IO with holes. See the <strong>rw_sequencer</strong> option.</p>
  </dd>
  <dt>
    <p><strong>rw_sequencer</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>If an offset modifier is given by appending a number to the <strong>rw=&lt;str&gt;</strong> line, then this option controls how that number modifies the IO offset being generated. Accepted values are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>sequential</strong></p>
  </dt>
  <dd>
    <p>Generate sequential offset</p>
  </dd>
  <dt>
    <p><strong>identical</strong></p>
  </dt>
  <dd>
    <p>Generate the same offset</p>
  </dd>

</dl>
<p><strong>sequential</strong> is only useful for random IO, where fio would normally generate a new random offset for every IO. If you append eg 8 to randread, you would get a new random offset for every 8 IO's. The result would be a seek for only every 8 IO's, instead of for every IO. Use <strong>rw=randread:8</strong> to specify that. As sequential IO is already sequential, setting <strong>sequential</strong> for that would not result in any differences.  <strong>identical</strong> behaves in a similar fashion, except it sends the same offset 8 number of times before generating a new offset.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p><strong>kb_base</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>The base unit for a kilobyte. The defacto base is 2^10, 1024.  Storage manufacturers like to use 10^3 or 1000 as a base ten unit instead, for obvious reasons. Allowed values are 1024 or 1000, with 1024 being the default.</p>
  </dd>
  <dt>
    <p><strong>unified_rw_reporting</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>Fio normally reports statistics on a per data direction basis, meaning that read, write, and trim are accounted and reported separately. If this option is set fio sums the results and reports them as "mixed" instead.</p>
  </dd>
  <dt>
    <p><strong>randrepeat</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>Seed the random number generator used for random I/O patterns in a predictable way so the pattern is repeatable across runs.  Default: true.</p>
  </dd>
  <dt>
    <p><strong>allrandrepeat</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>Seed all random number generators in a predictable way so results are repeatable across runs.  Default: false.</p>
  </dd>
  <dt>
    <p><strong>randseed</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Seed the random number generators based on this seed value, to be able to control what sequence of output is being generated. If not set, the random sequence depends on the <strong>randrepeat</strong> setting.</p>
  </dd>
  <dt>
    <p><strong>use_os_rand</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>Fio can either use the random generator supplied by the OS to generate random offsets, or it can use its own internal generator (based on Tausworthe). Default is to use the internal generator, which is often of better quality and faster. Default: false.</p>
  </dd>
  <dt>
    <p><strong>fallocate</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>Whether pre-allocation is performed when laying down files. Accepted values are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>none</strong></p>
  </dt>
  <dd>
    <p>Do not pre-allocate space.</p>
  </dd>
  <dt>
    <p><strong>posix</strong></p>
  </dt>
  <dd>
    <p>Pre-allocate via <strong>posix_fallocate</strong>\|(3).</p>
  </dd>
  <dt>
    <p><strong>keep</strong></p>
  </dt>
  <dd>
    <p>Pre-allocate via <strong>fallocate</strong>\|(2) with FALLOC_FL_KEEP_SIZE set.</p>
  </dd>
  <dt>
    <p><strong>0</strong></p>
  </dt>
  <dd>
    <p>Backward-compatible alias for 'none'.</p>
  </dd>
  <dt>
    <p><strong>1</strong></p>
  </dt>
  <dd>
    <p>Backward-compatible alias for 'posix'.</p>
  </dd>

</dl>
<p>May not be available on all supported platforms. 'keep' is only available on Linux. If using ZFS on Solaris this must be set to 'none' because ZFS doesn't support it. Default: 'posix'.</p>
  </dd>
  <dt>
    <p><strong>fadvise_hint</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>Use <strong>posix_fadvise</strong>\|(2) to advise the kernel what I/O patterns are likely to be issued. Default: true.</p>
  </dd>
  <dt>
    <p><strong>size</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Total size of I/O for this job.  <strong>fio</strong> will run until this many bytes have been transferred, unless limited by other options (<strong>runtime</strong>, for instance). Unless <strong>nrfiles</strong> and <strong>filesize</strong> options are given, this amount will be divided between the available files for the job. If not set, fio will use the full size of the given files or devices. If the files do not exist, size must be given. It is also possible to give size as a percentage between 1 and 100. If size=20% is given, fio will use 20% of the full size of the given files or devices.</p>
  </dd>
  <dt>
    <p><strong>io_limit</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Normally fio operates within the region set by <strong>size</strong>, which means that the <strong>size</strong> option sets both the region and size of IO to be performed. Sometimes that is not what you want. With this option, it is possible to define just the amount of IO that fio should do. For instance, if <strong>size</strong> is set to 20G and <strong>io_limit</strong> is set to 5G, fio will perform IO within the first 20G but exit when 5G have been done.</p>
  </dd>
  <dt>
    <p><strong>fill_device</strong><em></em>=<em>bool</em><strong></strong>,<strong> fill_fs</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>Sets size to something really large and waits for ENOSPC (no space left on device) as the terminating condition. Only makes sense with sequential write. For a read workload, the mount point will be filled first then IO started on the result. This option doesn't make sense if operating on a raw device node, since the size of that is already known by the file system. Additionally, writing beyond end-of-device will not return ENOSPC there.</p>
  </dd>
  <dt>
    <p><strong>filesize</strong><em></em>=<em>irange</em></p>
  </dt>
  <dd>
    <p>Individual file sizes. May be a range, in which case <strong>fio</strong> will select sizes for files at random within the given range, limited to <strong>size</strong> in total (if that is given). If <strong>filesize</strong> is not specified, each created file is the same size.</p>
  </dd>
  <dt>
    <p><strong>file_append</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>Perform IO after the end of the file. Normally fio will operate within the size of a file. If this option is set, then fio will append to the file instead. This has identical behavior to setting offset to the size of a file. This option is ignored on non-regular files.</p>
  </dd>
  <dt>
    <p><strong>blocksize</strong><em></em>=<em>int[,int]</em><strong></strong>,<strong> bs</strong><em></em>=<em>int[,int]</em></p>
  </dt>
  <dd>
    <p>Block size for I/O units.  Default: 4k.  Values for reads, writes, and trims can be specified separately in the format <em>read</em>,<em>write</em>,<em>trim</em> either of which may be empty to leave that value at its default. If a trailing comma isn't given, the remainder will inherit the last value set.</p>
  </dd>
  <dt>
    <p><strong>blocksize_range</strong><em></em>=<em>irange[,irange]</em><strong></strong>,<strong> bsrange</strong><em></em>=<em>irange[,irange]</em></p>
  </dt>
  <dd>
    <p>Specify a range of I/O block sizes.  The issued I/O unit will always be a multiple of the minimum size, unless <strong>blocksize_unaligned</strong> is set.  Applies to both reads and writes if only one range is given, but can be specified separately with a comma separating the values. Example: bsrange=1k-4k,2k-8k. Also (see <strong>blocksize</strong>).</p>
  </dd>
  <dt>
    <p><strong>bssplit</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>This option allows even finer grained control of the block sizes issued, not just even splits between them. With this option, you can weight various block sizes for exact control of the issued IO for a job that has mixed block sizes. The format of the option is bssplit=blocksize/percentage, optionally adding as many definitions as needed separated by a colon. Example: bssplit=4k/10:64k/50:32k/40 would issue 50% 64k blocks, 10% 4k blocks and 40% 32k blocks. <strong>bssplit</strong> also supports giving separate splits to reads and writes. The format is identical to what the <strong>bs</strong> option accepts, the read and write parts are separated with a comma.</p>
  </dd>
  <dt>
    <p><strong>blocksize_unaligned</strong>,<strong> bs_unaligned</strong></p>
  </dt>
  <dd>
    <p>If set, any size in <strong>blocksize_range</strong> may be used.  This typically won't work with direct I/O, as that normally requires sector alignment.</p>
  </dd>
  <dt>
    <p><strong>blockalign</strong><em></em>=<em>int[,int]</em><strong></strong>,<strong> ba</strong><em></em>=<em>int[,int]</em></p>
  </dt>
  <dd>
    <p>At what boundary to align random IO offsets. Defaults to the same as 'blocksize' the minimum blocksize given.  Minimum alignment is typically 512b for using direct IO, though it usually depends on the hardware block size. This option is mutually exclusive with using a random map for files, so it will turn off that option.</p>
  </dd>
  <dt>
    <p><strong>bs_is_seq_rand</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>If this option is set, fio will use the normal read,write blocksize settings as sequential,random instead. Any random read or write will use the WRITE blocksize settings, and any sequential read or write will use the READ blocksize setting.</p>
  </dd>
  <dt>
    <p><strong>zero_buffers</strong></p>
  </dt>
  <dd>
    <p>Initialize buffers with all zeros. Default: fill buffers with random data. The resulting IO buffers will not be completely zeroed, unless scramble_buffers is also turned off.</p>
  </dd>
  <dt>
    <p><strong>refill_buffers</strong></p>
  </dt>
  <dd>
    <p>If this option is given, fio will refill the IO buffers on every submit. The default is to only fill it at init time and reuse that data. Only makes sense if zero_buffers isn't specified, naturally. If data verification is enabled, refill_buffers is also automatically enabled.</p>
  </dd>
  <dt>
    <p><strong>scramble_buffers</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>If <strong>refill_buffers</strong> is too costly and the target is using data deduplication, then setting this option will slightly modify the IO buffer contents to defeat normal de-dupe attempts. This is not enough to defeat more clever block compression attempts, but it will stop naive dedupe of blocks. Default: true.</p>
  </dd>
  <dt>
    <p><strong>buffer_compress_percentage</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>If this is set, then fio will attempt to provide IO buffer content (on WRITEs) that compress to the specified level. Fio does this by providing a mix of random data and zeroes. Note that this is per block size unit, for file/disk wide compression level that matches this setting, you'll also want to set <strong>refill_buffers</strong>.</p>
  </dd>
  <dt>
    <p><strong>buffer_compress_chunk</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>See <strong>buffer_compress_percentage</strong>. This setting allows fio to manage how big the ranges of random data and zeroed data is. Without this set, fio will provide <strong>buffer_compress_percentage</strong> of blocksize random data, followed by the remaining zeroed. With this set to some chunk size smaller than the block size, fio can alternate random and zeroed data throughout the IO buffer.</p>
  </dd>
  <dt>
    <p><strong>buffer_pattern</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>If set, fio will fill the IO buffers with this pattern. If not set, the contents of IO buffers is defined by the other options related to buffer contents. The setting can be any pattern of bytes, and can be prefixed with 0x for hex values.</p>
  </dd>
  <dt>
    <p><strong>nrfiles</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Number of files to use for this job.  Default: 1.</p>
  </dd>
  <dt>
    <p><strong>openfiles</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Number of files to keep open at the same time.  Default: <strong>nrfiles</strong>.</p>
  </dd>
  <dt>
    <p><strong>file_service_type</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>Defines how files to service are selected.  The following types are defined:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>random</strong></p>
  </dt>
  <dd>
    <p>Choose a file at random.</p>
  </dd>
  <dt>
    <p><strong>roundrobin</strong></p>
  </dt>
  <dd>
    <p>Round robin over opened files (default).</p>
  </dd>
  <dt>
    <p><strong>sequential</strong></p>
  </dt>
  <dd>
    <p>Do each file in the set sequentially.</p>
  </dd>

</dl>
<p>The number of I/Os to issue before switching to a new file can be specified by appending `:<em>int</em>' to the service type.</p>
  </dd>
  <dt>
    <p><strong>ioengine</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>Defines how the job issues I/O.  The following types are defined:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>sync</strong></p>
  </dt>
  <dd>
    <p>Basic <strong>read</strong>\|(2) or <strong>write</strong>\|(2) I/O.  <strong>fseek</strong>\|(2) is used to position the I/O location.</p>
  </dd>
  <dt>
    <p><strong>psync</strong></p>
  </dt>
  <dd>
    <p>Basic <strong>pread</strong>\|(2) or <strong>pwrite</strong>\|(2) I/O.</p>
  </dd>
  <dt>
    <p><strong>vsync</strong></p>
  </dt>
  <dd>
    <p>Basic <strong>readv</strong>\|(2) or <strong>writev</strong>\|(2) I/O. Will emulate queuing by coalescing adjacent IOs into a single submission.</p>
  </dd>
  <dt>
    <p><strong>pvsync</strong></p>
  </dt>
  <dd>
    <p>Basic <strong>preadv</strong>\|(2) or <strong>pwritev</strong>\|(2) I/O.</p>
  </dd>
  <dt>
    <p><strong>libaio</strong></p>
  </dt>
  <dd>
    <p>Linux native asynchronous I/O. This ioengine defines engine specific options.</p>
  </dd>
  <dt>
    <p><strong>posixaio</strong></p>
  </dt>
  <dd>
    <p>POSIX asynchronous I/O using <strong>aio_read</strong>\|(3) and <strong>aio_write</strong>\|(3).</p>
  </dd>
  <dt>
    <p><strong>solarisaio</strong></p>
  </dt>
  <dd>
    <p>Solaris native asynchronous I/O.</p>
  </dd>
  <dt>
    <p><strong>windowsaio</strong></p>
  </dt>
  <dd>
    <p>Windows native asynchronous I/O.</p>
  </dd>
  <dt>
    <p><strong>mmap</strong></p>
  </dt>
  <dd>
    <p>File is memory mapped with <strong>mmap</strong>\|(2) and data copied using <strong>memcpy</strong>\|(3).</p>
  </dd>
  <dt>
    <p><strong>splice</strong></p>
  </dt>
  <dd>
    <p><strong>splice</strong>\|(2) is used to transfer the data and <strong>vmsplice</strong>\|(2) to transfer data from user-space to the kernel.</p>
  </dd>
  <dt>
    <p><strong>syslet-rw</strong></p>
  </dt>
  <dd>
    <p>Use the syslet system calls to make regular read/write asynchronous.</p>
  </dd>
  <dt>
    <p><strong>sg</strong></p>
  </dt>
  <dd>
    <p>SCSI generic sg v3 I/O. May be either synchronous using the SG_IO ioctl, or if the target is an sg character device, we use <strong>read</strong>\|(2) and <strong>write</strong>\|(2) for asynchronous I/O.</p>
  </dd>
  <dt>
    <p><strong>null</strong></p>
  </dt>
  <dd>
    <p>Doesn't transfer any data, just pretends to.  Mainly used to exercise <strong>fio</strong> itself and for debugging and testing purposes.</p>
  </dd>
  <dt>
    <p><strong>net</strong></p>
  </dt>
  <dd>
    <p>Transfer over the network.  The protocol to be used can be defined with the <strong>protocol</strong> parameter.  Depending on the protocol, <strong>filename</strong>, <strong>hostname</strong>, <strong>port</strong>, or <strong>listen</strong> must be specified. This ioengine defines engine specific options.</p>
  </dd>
  <dt>
    <p><strong>netsplice</strong></p>
  </dt>
  <dd>
    <p>Like <strong>net</strong>, but uses <strong>splice</strong>\|(2) and <strong>vmsplice</strong>\|(2) to map data and send/receive. This ioengine defines engine specific options.</p>
  </dd>
  <dt>
    <p><strong>cpuio</strong></p>
  </dt>
  <dd>
    <p>Doesn't transfer any data, but burns CPU cycles according to <strong>cpuload</strong> and <strong>cpucycles</strong> parameters.</p>
  </dd>
  <dt>
    <p><strong>guasi</strong></p>
  </dt>
  <dd>
    <p>The GUASI I/O engine is the Generic Userspace Asynchronous Syscall Interface approach to asynchronous I/O.</p><p>See &lt;http://www.xmailserver.org/guasi-lib.html&gt;.</p>
  </dd>
  <dt>
    <p><strong>rdma</strong></p>
  </dt>
  <dd>
    <p>The RDMA I/O engine supports both RDMA memory semantics (RDMA_WRITE/RDMA_READ) and channel semantics (Send/Recv) for the InfiniBand, RoCE and iWARP protocols.</p>
  </dd>
  <dt>
    <p><strong>external</strong></p>
  </dt>
  <dd>
    <p>Loads an external I/O engine object file.  Append the engine filename as `:<em>enginepath</em>'.</p>
  </dd>
  <dt>
    <p><strong>falloc</strong></p>
  </dt>
  <dd>
    
<pre>
   IO engine that does regular linux native fallocate call to simulate data
</pre>
<p>transfer as fio ioengine</p>
<pre>
  DDIR_READ  does fallocate(,mode = FALLOC_FL_KEEP_SIZE,)
</pre>

<pre>
  DIR_WRITE does fallocate(,mode = 0)
</pre>

<pre>
  DDIR_TRIM does fallocate(,mode = FALLOC_FL_KEEP_SIZE|FALLOC_FL_PUNCH_HOLE)
</pre>

  </dd>
  <dt>
    <p><strong>e4defrag</strong></p>
  </dt>
  <dd>
    <p>IO engine that does regular EXT4_IOC_MOVE_EXT ioctls to simulate defragment activity request to DDIR_WRITE event</p>
  </dd>
  <dt>
    <p><strong>rbd</strong></p>
  </dt>
  <dd>
    <p>IO engine supporting direct access to Ceph Rados Block Devices (RBD) via librbd without the need to use the kernel rbd driver. This ioengine defines engine specific options.</p>
  </dd>
  <dt>
    <p><strong>gfapi</strong></p>
  </dt>
  <dd>
    <p>Using Glusterfs libgfapi sync interface to direct access to Glusterfs volumes without having to go through FUSE. This ioengine defines engine specific options.</p>
  </dd>
  <dt>
    <p><strong>gfapi_async</strong></p>
  </dt>
  <dd>
    <p>Using Glusterfs libgfapi async interface to direct access to Glusterfs volumes without having to go through FUSE. This ioengine defines engine specific options.</p>
  </dd>

</dl>

  </dd>
  <dt>
    <p><strong>iodepth</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Number of I/O units to keep in flight against the file. Note that increasing iodepth beyond 1 will not affect synchronous ioengines (except for small degress when verify_async is in use). Even async engines may impose OS restrictions causing the desired depth not to be achieved.  This may happen on Linux when using libaio and not setting <strong>direct</strong>=1, since buffered IO is not async on that OS. Keep an eye on the IO depth distribution in the fio output to verify that the achieved depth is as expected. Default: 1.</p>
  </dd>
  <dt>
    <p><strong>iodepth_batch</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Number of I/Os to submit at once.  Default: <strong>iodepth</strong>.</p>
  </dd>
  <dt>
    <p><strong>iodepth_batch_complete</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>This defines how many pieces of IO to retrieve at once. It defaults to 1 which  means that we'll ask for a minimum of 1 IO in the retrieval process from the kernel. The IO retrieval will go on until we hit the limit set by <strong>iodepth_low</strong>. If this variable is set to 0, then fio will always check for completed events before queuing more IO. This helps reduce IO latency, at the cost of more retrieval system calls.</p>
  </dd>
  <dt>
    <p><strong>iodepth_low</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Low watermark indicating when to start filling the queue again.  Default: <strong>iodepth</strong>.</p>
  </dd>
  <dt>
    <p><strong>direct</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>If true, use non-buffered I/O (usually O_DIRECT).  Default: false.</p>
  </dd>
  <dt>
    <p><strong>atomic</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>If value is true, attempt to use atomic direct IO. Atomic writes are guaranteed to be stable once acknowledged by the operating system. Only Linux supports O_ATOMIC right now.</p>
  </dd>
  <dt>
    <p><strong>buffered</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>If true, use buffered I/O.  This is the opposite of the <strong>direct</strong> parameter. Default: true.</p>
  </dd>
  <dt>
    <p><strong>offset</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Offset in the file to start I/O. Data before the offset will not be touched.</p>
  </dd>
  <dt>
    <p><strong>offset_increment</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>If this is provided, then the real offset becomes the offset + offset_increment * thread_number, where the thread number is a counter that starts at 0 and is incremented for each job. This option is useful if there are several jobs which are intended to operate on a file in parallel in disjoint segments, with even spacing between the starting points.</p>
  </dd>
  <dt>
    <p><strong>number_ios</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Fio will normally perform IOs until it has exhausted the size of the region set by <strong>size</strong>, or if it exhaust the allocated time (or hits an error condition). With this setting, the range/size can be set independently of the number of IOs to perform. When fio reaches this number, it will exit normally and report status.</p>
  </dd>
  <dt>
    <p><strong>fsync</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>How many I/Os to perform before issuing an <strong>fsync</strong>\|(2) of dirty data.  If 0, don't sync.  Default: 0.</p>
  </dd>
  <dt>
    <p><strong>fdatasync</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Like <strong>fsync</strong>, but uses <strong>fdatasync</strong>\|(2) instead to only sync the data parts of the file. Default: 0.</p>
  </dd>
  <dt>
    <p><strong>write_barrier</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Make every Nth write a barrier write.</p>
  </dd>
  <dt>
    <p><strong>sync_file_range</strong><em></em>=<em>str:int</em></p>
  </dt>
  <dd>
    <p>Use <strong>sync_file_range</strong>\|(2) for every val number of write operations. Fio will track range of writes that have happened since the last <strong>sync_file_range</strong>\|(2) call. str can currently be one or more of:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>wait_before</strong></p>
  </dt>
  <dd>
    <p>SYNC_FILE_RANGE_WAIT_BEFORE</p>
  </dd>
  <dt>
    <p><strong>write</strong></p>
  </dt>
  <dd>
    <p>SYNC_FILE_RANGE_WRITE</p>
  </dd>
  <dt>
    <p><strong>wait_after</strong></p>
  </dt>
  <dd>
    <p>SYNC_FILE_RANGE_WRITE</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>

</dl>

  </dd>

</dl>
<p>So if you do sync_file_range=wait_before,write:8, fio would use <strong>SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE</strong> for every 8 writes. Also see the <strong>sync_file_range</strong>\|(2) man page.  This option is Linux specific.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>overwrite</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>If writing, setup the file first and do overwrites.  Default: false.</p>
  </dd>
  <dt>
    <p><strong>end_fsync</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>Sync file contents when a write stage has completed.  Default: false.</p>
  </dd>
  <dt>
    <p><strong>fsync_on_close</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>If true, sync file contents on close.  This differs from <strong>end_fsync</strong> in that it will happen on every close, not just at the end of the job.  Default: false.</p>
  </dd>
  <dt>
    <p><strong>rwmixread</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Percentage of a mixed workload that should be reads. Default: 50.</p>
  </dd>
  <dt>
    <p><strong>rwmixwrite</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Percentage of a mixed workload that should be writes.  If <strong>rwmixread</strong> and <strong>rwmixwrite</strong> are given and do not sum to 100%, the latter of the two overrides the first. This may interfere with a given rate setting, if fio is asked to limit reads or writes to a certain rate. If that is the case, then the distribution may be skewed. Default: 50.</p>
  </dd>
  <dt>
    <p><strong>random_distribution</strong><em></em>=<em>str:float</em></p>
  </dt>
  <dd>
    <p>By default, fio will use a completely uniform random distribution when asked to perform random IO. Sometimes it is useful to skew the distribution in specific ways, ensuring that some parts of the data is more hot than others. Fio includes the following distribution models:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>random</strong></p>
  </dt>
  <dd>
    <p>Uniform random distribution</p>
  </dd>
  <dt>
    <p><strong>zipf</strong></p>
  </dt>
  <dd>
    <p>Zipf distribution</p>
  </dd>
  <dt>
    <p><strong>pareto</strong></p>
  </dt>
  <dd>
    <p>Pareto distribution</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>

</dl>

  </dd>

</dl>
<p>When using a zipf or pareto distribution, an input value is also needed to define the access pattern. For zipf, this is the zipf theta. For pareto, it's the pareto power. Fio includes a test program, genzipf, that can be used visualize what the given input values will yield in terms of hit rates. If you wanted to use zipf with a theta of 1.2, you would use random_distribution=zipf:1.2 as the option. If a non-uniform model is used, fio will disable use of the random map.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>percentage_random</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>For a random workload, set how big a percentage should be random. This defaults to 100%, in which case the workload is fully random. It can be set from anywhere from 0 to 100.  Setting it to 0 would make the workload fully sequential. It is possible to set different values for reads, writes, and trim. To do so, simply use a comma separated list. See <strong>blocksize</strong>.</p>
  </dd>
  <dt>
    <p><strong>norandommap</strong></p>
  </dt>
  <dd>
    <p>Normally <strong>fio</strong> will cover every block of the file when doing random I/O. If this parameter is given, a new offset will be chosen without looking at past I/O history.  This parameter is mutually exclusive with <strong>verify</strong>.</p>
  </dd>
  <dt>
    <p><strong>softrandommap</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>See <strong>norandommap</strong>. If fio runs with the random block map enabled and it fails to allocate the map, if this option is set it will continue without a random block map. As coverage will not be as complete as with random maps, this option is disabled by default.</p>
  </dd>
  <dt>
    <p><strong>random_generator</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>Fio supports the following engines for generating IO offsets for random IO:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>tausworthe</strong></p>
  </dt>
  <dd>
    <p>Strong 2^88 cycle random number generator</p>
  </dd>
  <dt>
    <p><strong>lfsr</strong></p>
  </dt>
  <dd>
    <p>Linear feedback shift register generator</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>

</dl>

  </dd>

</dl>
<p>Tausworthe is a strong random number generator, but it requires tracking on the side if we want to ensure that blocks are only read or written once. LFSR guarantees that we never generate the same offset twice, and it's also less computationally expensive. It's not a true random generator, however, though for IO purposes it's typically good enough. LFSR only works with single block sizes, not with workloads that use multiple block sizes. If used with such a workload, fio may read or write some blocks multiple times.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>nice</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Run job with given nice value.  See <strong>nice</strong>\|(2).</p>
  </dd>
  <dt>
    <p><strong>prio</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Set I/O priority value of this job between 0 (highest) and 7 (lowest).  See <strong>ionice</strong>\|(1).</p>
  </dd>
  <dt>
    <p><strong>prioclass</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Set I/O priority class.  See <strong>ionice</strong>\|(1).</p>
  </dd>
  <dt>
    <p><strong>thinktime</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Stall job for given number of microseconds between issuing I/Os.</p>
  </dd>
  <dt>
    <p><strong>thinktime_spin</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Pretend to spend CPU time for given number of microseconds, sleeping the rest of the time specified by <strong>thinktime</strong>.  Only valid if <strong>thinktime</strong> is set.</p>
  </dd>
  <dt>
    <p><strong>thinktime_blocks</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Only valid if thinktime is set - control how many blocks to issue, before waiting <strong>thinktime</strong> microseconds. If not set, defaults to 1 which will make fio wait <strong>thinktime</strong> microseconds after every block. This effectively makes any queue depth setting redundant, since no more than 1 IO will be queued before we have to complete it and do our thinktime. In other words, this setting effectively caps the queue depth if the latter is larger. Default: 1.</p>
  </dd>
  <dt>
    <p><strong>rate</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Cap bandwidth used by this job. The number is in bytes/sec, the normal postfix rules apply. You can use <strong>rate</strong>=500k to limit reads and writes to 500k each, or you can specify read and writes separately. Using <strong>rate</strong>=1m,500k would limit reads to 1MB/sec and writes to 500KB/sec. Capping only reads or writes can be done with <strong>rate</strong>=,500k or <strong>rate</strong>=500k,. The former will only limit writes (to 500KB/sec), the latter will only limit reads.</p>
  </dd>
  <dt>
    <p><strong>ratemin</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Tell <strong>fio</strong> to do whatever it can to maintain at least the given bandwidth. Failing to meet this requirement will cause the job to exit. The same format as <strong>rate</strong> is used for read vs write separation.</p>
  </dd>
  <dt>
    <p><strong>rate_iops</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Cap the bandwidth to this number of IOPS. Basically the same as rate, just specified independently of bandwidth. The same format as <strong>rate</strong> is used for read vs write separation. If <strong>blocksize</strong> is a range, the smallest block size is used as the metric.</p>
  </dd>
  <dt>
    <p><strong>rate_iops_min</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>If this rate of I/O is not met, the job will exit. The same format as <strong>rate</strong> is used for read vs write separation.</p>
  </dd>
  <dt>
    <p><strong>ratecycle</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Average bandwidth for <strong>rate</strong> and <strong>ratemin</strong> over this number of milliseconds.  Default: 1000ms.</p>
  </dd>
  <dt>
    <p><strong>latency_target</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>If set, fio will attempt to find the max performance point that the given workload will run at while maintaining a latency below this target. The values is given in microseconds. See <strong>latency_window</strong> and <strong>latency_percentile</strong>.</p>
  </dd>
  <dt>
    <p><strong>latency_window</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Used with <strong>latency_target</strong> to specify the sample window that the job is run at varying queue depths to test the performance. The value is given in microseconds.</p>
  </dd>
  <dt>
    <p><strong>latency_percentile</strong><em></em>=<em>float</em></p>
  </dt>
  <dd>
    <p>The percentage of IOs that must fall within the criteria specified by <strong>latency_target</strong> and <strong>latency_window</strong>. If not set, this defaults to 100.0, meaning that all IOs must be equal or below to the value set by <strong>latency_target</strong>.</p>
  </dd>
  <dt>
    <p><strong>max_latency</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>If set, fio will exit the job if it exceeds this maximum latency. It will exit with an ETIME error.</p>
  </dd>
  <dt>
    <p><strong>cpumask</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Set CPU affinity for this job. <em>int</em> is a bitmask of allowed CPUs the job may run on.  See <strong>sched_setaffinity</strong>\|(2).</p>
  </dd>
  <dt>
    <p><strong>cpus_allowed</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>Same as <strong>cpumask</strong>, but allows a comma-delimited list of CPU numbers.</p>
  </dd>
  <dt>
    <p><strong>cpus_allowed_policy</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>Set the policy of how fio distributes the CPUs specified by <strong>cpus_allowed</strong> or <strong>cpumask</strong>. Two policies are supported:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>shared</strong></p>
  </dt>
  <dd>
    <p>All jobs will share the CPU set specified.</p>
  </dd>
  <dt>
    <p><strong>split</strong></p>
  </dt>
  <dd>
    <p>Each job will get a unique CPU from the CPU set.</p>
  </dd>

</dl>
<p><strong>shared</strong> is the default behaviour, if the option isn't specified. If <strong>split</strong> is specified, then fio will assign one cpu per job. If not enough CPUs are given for the jobs listed, then fio will roundrobin the CPUs in the set.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p><strong>numa_cpu_nodes</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>Set this job running on specified NUMA nodes' CPUs. The arguments allow comma delimited list of cpu numbers, A-B ranges, or 'all'.</p>
  </dd>
  <dt>
    <p><strong>numa_mem_policy</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>Set this job's memory policy and corresponding NUMA nodes. Format of the arguments:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>&lt;mode&gt;[:&lt;nodelist&gt;]</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>mode</strong></p>
  </dt>
  <dd>
    <p>is one of the following memory policy:</p>
  </dd>
  <dt>
    <p><strong>default, prefer, bind, interleave, local</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>

</dl>
<p>For <strong>default</strong> and <strong>local</strong> memory policy, no <strong>nodelist</strong> is needed to be specified. For <strong>prefer</strong>, only one node is allowed. For <strong>bind</strong> and <strong>interleave</strong>, <strong>nodelist</strong> allows comma delimited list of numbers, A-B ranges, or 'all'.</p>
  </dd>
  <dt>
    <p><strong>startdelay</strong><em></em>=<em>irange</em></p>
  </dt>
  <dd>
    <p>Delay start of job for the specified number of seconds. Supports all time suffixes to allow specification of hours, minutes, seconds and milliseconds - seconds are the default if a unit is ommited. Can be given as a range which causes each thread to choose randomly out of the range.</p>
  </dd>
  <dt>
    <p><strong>runtime</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Terminate processing after the specified number of seconds.</p>
  </dd>
  <dt>
    <p><strong>time_based</strong></p>
  </dt>
  <dd>
    <p>If given, run for the specified <strong>runtime</strong> duration even if the files are completely read or written. The same workload will be repeated as many times as <strong>runtime</strong> allows.</p>
  </dd>
  <dt>
    <p><strong>ramp_time</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>If set, fio will run the specified workload for this amount of time before logging any performance numbers. Useful for letting performance settle before logging results, thus minimizing the runtime required for stable results. Note that the <strong>ramp_time</strong> is considered lead in time for a job, thus it will increase the total runtime if a special timeout or runtime is specified.</p>
  </dd>
  <dt>
    <p><strong>invalidate</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>Invalidate buffer-cache for the file prior to starting I/O.  Default: true.</p>
  </dd>
  <dt>
    <p><strong>sync</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>Use synchronous I/O for buffered writes.  For the majority of I/O engines, this means using O_SYNC.  Default: false.</p>
  </dd>
  <dt>
    <p><strong>iomem</strong><em></em>=<em>str</em><strong></strong>,<strong> mem</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>Allocation method for I/O unit buffer.  Allowed values are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>malloc</strong></p>
  </dt>
  <dd>
    <p>Allocate memory with <strong>malloc</strong>\|(3).</p>
  </dd>
  <dt>
    <p><strong>shm</strong></p>
  </dt>
  <dd>
    <p>Use shared memory buffers allocated through <strong>shmget</strong>\|(2).</p>
  </dd>
  <dt>
    <p><strong>shmhuge</strong></p>
  </dt>
  <dd>
    <p>Same as <strong>shm</strong>, but use huge pages as backing.</p>
  </dd>
  <dt>
    <p><strong>mmap</strong></p>
  </dt>
  <dd>
    <p>Use <strong>mmap</strong>\|(2) for allocation.  Uses anonymous memory unless a filename is given after the option in the format `:<em>file</em>'.</p>
  </dd>
  <dt>
    <p><strong>mmaphuge</strong></p>
  </dt>
  <dd>
    <p>Same as <strong>mmap</strong>, but use huge files as backing.</p>
  </dd>

</dl>
<p>The amount of memory allocated is the maximum allowed <strong>blocksize</strong> for the job multiplied by <strong>iodepth</strong>.  For <strong>shmhuge</strong> or <strong>mmaphuge</strong> to work, the system must have free huge pages allocated.  <strong>mmaphuge</strong> also needs to have hugetlbfs mounted, and <em>file</em> must point there. At least on Linux, huge pages must be manually allocated. See <strong>/proc/sys/vm/nr_hugehages</strong> and the documentation for that. Normally you just need to echo an appropriate number, eg echoing 8 will ensure that the OS has 8 huge pages ready for use.</p>
  </dd>
  <dt>
    <p><strong>iomem_align</strong><em></em>=<em>int</em><strong></strong>,<strong> mem_align</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>This indicates the memory alignment of the IO memory buffers. Note that the given alignment is applied to the first IO unit buffer, if using <strong>iodepth</strong> the alignment of the following buffers are given by the <strong>bs</strong> used. In other words, if using a <strong>bs</strong> that is a multiple of the page sized in the system, all buffers will be aligned to this value. If using a <strong>bs</strong> that is not page aligned, the alignment of subsequent IO memory buffers is the sum of the <strong>iomem_align</strong> and <strong>bs</strong> used.</p>
  </dd>
  <dt>
    <p><strong>hugepage-size</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Defines the size of a huge page.  Must be at least equal to the system setting. Should be a multiple of 1MB. Default: 4MB.</p>
  </dd>
  <dt>
    <p><strong>exitall</strong></p>
  </dt>
  <dd>
    <p>Terminate all jobs when one finishes.  Default: wait for each job to finish.</p>
  </dd>
  <dt>
    <p><strong>bwavgtime</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Average bandwidth calculations over the given time in milliseconds.  Default: 500ms.</p>
  </dd>
  <dt>
    <p><strong>iopsavgtime</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Average IOPS calculations over the given time in milliseconds.  Default: 500ms.</p>
  </dd>
  <dt>
    <p><strong>create_serialize</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>If true, serialize file creation for the jobs.  Default: true.</p>
  </dd>
  <dt>
    <p><strong>create_fsync</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p><strong>fsync</strong>\|(2) data file after creation.  Default: true.</p>
  </dd>
  <dt>
    <p><strong>create_on_open</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>If true, the files are not created until they are opened for IO by the job.</p>
  </dd>
  <dt>
    <p><strong>create_only</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>If true, fio will only run the setup phase of the job. If files need to be laid out or updated on disk, only that will be done. The actual job contents are not executed.</p>
  </dd>
  <dt>
    <p><strong>pre_read</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>If this is given, files will be pre-read into memory before starting the given IO operation. This will also clear the  <strong>invalidate</strong> flag, since it is pointless to pre-read and then drop the cache. This will only work for IO engines that are seekable, since they allow you to read the same data multiple times. Thus it will not work on eg network or splice IO.</p>
  </dd>
  <dt>
    <p><strong>unlink</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>Unlink job files when done.  Default: false.</p>
  </dd>
  <dt>
    <p><strong>loops</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Specifies the number of iterations (runs of the same workload) of this job. Default: 1.</p>
  </dd>
  <dt>
    <p><strong>verify_only</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>Do not perform the specified workload, only verify data still matches previous invocation of this workload. This option allows one to check data multiple times at a later date without overwriting it. This option makes sense only for workloads that write data, and does not support workloads with the <strong>time_based</strong> option set.</p>
  </dd>
  <dt>
    <p><strong>do_verify</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>Run the verify phase after a write phase.  Only valid if <strong>verify</strong> is set. Default: true.</p>
  </dd>
  <dt>
    <p><strong>verify</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>Method of verifying file contents after each iteration of the job.  Allowed values are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>md5 crc16 crc32 crc32c crc32c-intel crc64 crc7 sha256 sha512 sha1 xxhash</strong></p>
  </dt>
  <dd>
    <p>Store appropriate checksum in the header of each block. crc32c-intel is hardware accelerated SSE4.2 driven, falls back to regular crc32c if not supported by the system.</p>
  </dd>
  <dt>
    <p><strong>meta</strong></p>
  </dt>
  <dd>
    <p>Write extra information about each I/O (timestamp, block number, etc.). The block number is verified. See <strong>verify_pattern</strong> as well.</p>
  </dd>
  <dt>
    <p><strong>null</strong></p>
  </dt>
  <dd>
    <p>Pretend to verify.  Used for testing internals.</p>
  </dd>

</dl>
<p>This option can be used for repeated burn-in tests of a system to make sure that the written data is also correctly read back. If the data direction given is a read or random read, fio will assume that it should verify a previously written file. If the data direction includes any form of write, the verify will be of the newly written data.</p>
  </dd>
  <dt>
    <p><strong>verifysort</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>If true, written verify blocks are sorted if <strong>fio</strong> deems it to be faster to read them back in a sorted manner.  Default: true.</p>
  </dd>
  <dt>
    <p><strong>verifysort_nr</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Pre-load and sort verify blocks for a read workload.</p>
  </dd>
  <dt>
    <p><strong>verify_offset</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Swap the verification header with data somewhere else in the block before writing.  It is swapped back before verifying.</p>
  </dd>
  <dt>
    <p><strong>verify_interval</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Write the verification header for this number of bytes, which should divide <strong>blocksize</strong>.  Default: <strong>blocksize</strong>.</p>
  </dd>
  <dt>
    <p><strong>verify_pattern</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>If set, fio will fill the io buffers with this pattern. Fio defaults to filling with totally random bytes, but sometimes it's interesting to fill with a known pattern for io verification purposes. Depending on the width of the pattern, fio will fill 1/2/3/4 bytes of the buffer at the time(it can be either a decimal or a hex number). The verify_pattern if larger than a 32-bit quantity has to be a hex number that starts with either "0x" or "0X". Use with <strong>verify</strong>=meta.</p>
  </dd>
  <dt>
    <p><strong>verify_fatal</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>If true, exit the job on the first observed verification failure.  Default: false.</p>
  </dd>
  <dt>
    <p><strong>verify_dump</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>If set, dump the contents of both the original data block and the data block we read off disk to files. This allows later analysis to inspect just what kind of data corruption occurred. Off by default.</p>
  </dd>
  <dt>
    <p><strong>verify_async</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Fio will normally verify IO inline from the submitting thread. This option takes an integer describing how many async offload threads to create for IO verification instead, causing fio to offload the duty of verifying IO contents to one or more separate threads.  If using this offload option, even sync IO engines can benefit from using an <strong>iodepth</strong> setting higher than 1, as it allows them to have IO in flight while verifies are running.</p>
  </dd>
  <dt>
    <p><strong>verify_async_cpus</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>Tell fio to set the given CPU affinity on the async IO verification threads. See <strong>cpus_allowed</strong> for the format used.</p>
  </dd>
  <dt>
    <p><strong>verify_backlog</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Fio will normally verify the written contents of a job that utilizes verify once that job has completed. In other words, everything is written then everything is read back and verified. You may want to verify continually instead for a variety of reasons. Fio stores the meta data associated with an IO block in memory, so for large verify workloads, quite a bit of memory would be used up holding this meta data. If this option is enabled, fio will write only N blocks before verifying these blocks.</p>
  </dd>
  <dt>
    <p><strong>verify_backlog_batch</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Control how many blocks fio will verify if verify_backlog is set. If not set, will default to the value of <strong>verify_backlog</strong> (meaning the entire queue is read back and verified).  If <strong>verify_backlog_batch</strong> is less than <strong>verify_backlog</strong> then not all blocks will be verified,  if <strong>verify_backlog_batch</strong> is larger than <strong>verify_backlog</strong>,  some blocks will be verified more than once.</p>
  </dd>
  <dt>
    <p><strong>trim_percentage</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Number of verify blocks to discard/trim.</p>
  </dd>
  <dt>
    <p><strong>trim_verify_zero</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>Verify that trim/discarded blocks are returned as zeroes.</p>
  </dd>
  <dt>
    <p><strong>trim_backlog</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Trim after this number of blocks are written.</p>
  </dd>
  <dt>
    <p><strong>trim_backlog_batch</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Trim this number of IO blocks.</p>
  </dd>
  <dt>
    <p><strong>experimental_verify</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>Enable experimental verification.</p>
  </dd>
  <dt>
    <p><strong>stonewall </strong>,<strong> wait_for_previous</strong></p>
  </dt>
  <dd>
    <p>Wait for preceding jobs in the job file to exit before starting this one. <strong>stonewall</strong> implies <strong>new_group</strong>.</p>
  </dd>
  <dt>
    <p><strong>new_group</strong></p>
  </dt>
  <dd>
    <p>Start a new reporting group.  If not given, all jobs in a file will be part of the same reporting group, unless separated by a stonewall.</p>
  </dd>
  <dt>
    <p><strong>numjobs</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Number of clones (processes/threads performing the same workload) of this job. Default: 1.</p>
  </dd>
  <dt>
    <p><strong>group_reporting</strong></p>
  </dt>
  <dd>
    <p>If set, display per-group reports instead of per-job when <strong>numjobs</strong> is specified.</p>
  </dd>
  <dt>
    <p><strong>thread</strong></p>
  </dt>
  <dd>
    <p>Use threads created with <strong>pthread_create</strong>\|(3) instead of processes created with <strong>fork</strong>\|(2).</p>
  </dd>
  <dt>
    <p><strong>zonesize</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Divide file into zones of the specified size in bytes.  See <strong>zoneskip</strong>.</p>
  </dd>
  <dt>
    <p><strong>zonerange</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Give size of an IO zone.  See <strong>zoneskip</strong>.</p>
  </dd>
  <dt>
    <p><strong>zoneskip</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Skip the specified number of bytes when <strong>zonesize</strong> bytes of data have been read.</p>
  </dd>
  <dt>
    <p><strong>write_iolog</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>Write the issued I/O patterns to the specified file.  Specify a separate file for each job, otherwise the iologs will be interspersed and the file may be corrupt.</p>
  </dd>
  <dt>
    <p><strong>read_iolog</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>Replay the I/O patterns contained in the specified file generated by <strong>write_iolog</strong>, or may be a <strong>blktrace</strong> binary file.</p>
  </dd>
  <dt>
    <p><strong>replay_no_stall</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>While replaying I/O patterns using <strong>read_iolog</strong> the default behavior attempts to respect timing information between I/Os.  Enabling <strong>replay_no_stall</strong> causes I/Os to be replayed as fast as possible while still respecting ordering.</p>
  </dd>
  <dt>
    <p><strong>replay_redirect</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>While replaying I/O patterns using <strong>read_iolog</strong> the default behavior is to replay the IOPS onto the major/minor device that each IOP was recorded from.  Setting <strong>replay_redirect</strong> causes all IOPS to be replayed onto the single specified device regardless of the device it was recorded from.</p>
  </dd>
  <dt>
    <p><strong>write_bw_log</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>If given, write a bandwidth log of the jobs in this job file. Can be used to store data of the bandwidth of the jobs in their lifetime. The included fio_generate_plots script uses gnuplot to turn these text files into nice graphs. See <strong>write_lat_log</strong> for behaviour of given filename. For this option, the postfix is _bw.x.log, where x is the index of the job (1..N, where N is the number of jobs)</p>
  </dd>
  <dt>
    <p><strong>write_lat_log</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>Same as <strong>write_bw_log</strong>, but writes I/O completion latencies.  If no filename is given with this option, the default filename of "jobname_type.x.log" is used, where x is the index of the job (1..N, where N is the number of jobs). Even if the filename is given, fio will still append the type of log.</p>
  </dd>
  <dt>
    <p><strong>write_iops_log</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>Same as <strong>write_bw_log</strong>, but writes IOPS. If no filename is given with this option, the default filename of "jobname_type.x.log" is used, where x is the index of the job (1..N, where N is the number of jobs). Even if the filename is given, fio will still append the type of log.</p>
  </dd>
  <dt>
    <p><strong>log_avg_msec</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>By default, fio will log an entry in the iops, latency, or bw log for every IO that completes. When writing to the disk log, that can quickly grow to a very large size. Setting this option makes fio average the each log entry over the specified period of time, reducing the resolution of the log. Defaults to 0.</p>
  </dd>
  <dt>
    <p><strong>log_offset</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>If this is set, the iolog options will include the byte offset for the IO entry as well as the other data values.</p>
  </dd>
  <dt>
    <p><strong>log_compression</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>If this is set, fio will compress the IO logs as it goes, to keep the memory footprint lower. When a log reaches the specified size, that chunk is removed and compressed in the background. Given that IO logs are fairly highly compressible, this yields a nice memory savings for longer runs. The downside is that the compression will consume some background CPU cycles, so it may impact the run. This, however, is also true if the logging ends up consuming most of the system memory. So pick your poison. The IO logs are saved normally at the end of a run, by decompressing the chunks and storing them in the specified log file. This feature depends on the availability of zlib.</p>
  </dd>
  <dt>
    <p><strong>log_store_compressed</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>If set, and <strong>log</strong>_compression is also set, fio will store the log files in a compressed format. They can be decompressed with fio, using the <strong>--inflate-log</strong> command line parameter. The files will be stored with a <strong>.fz</strong> suffix.</p>
  </dd>
  <dt>
    <p><strong>disable_lat</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>Disable measurements of total latency numbers. Useful only for cutting back the number of calls to <strong>gettimeofday</strong>\|(2), as that does impact performance at really high IOPS rates.  Note that to really get rid of a large amount of these calls, this option must be used with disable_slat and disable_bw as well.</p>
  </dd>
  <dt>
    <p><strong>disable_clat</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>Disable measurements of completion latency numbers. See <strong>disable_lat</strong>.</p>
  </dd>
  <dt>
    <p><strong>disable_slat</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>Disable measurements of submission latency numbers. See <strong>disable_lat</strong>.</p>
  </dd>
  <dt>
    <p><strong>disable_bw_measurement</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>Disable measurements of throughput/bandwidth numbers. See <strong>disable_lat</strong>.</p>
  </dd>
  <dt>
    <p><strong>lockmem</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Pin the specified amount of memory with <strong>mlock</strong>\|(2).  Can be used to simulate a smaller amount of memory. The amount specified is per worker.</p>
  </dd>
  <dt>
    <p><strong>exec_prerun</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>Before running the job, execute the specified command with <strong>system</strong>\|(3).</p><p>Output is redirected in a file called <strong>jobname.prerun.txt</strong></p>
  </dd>
  <dt>
    <p><strong>exec_postrun</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>Same as <strong>exec_prerun</strong>, but the command is executed after the job completes.</p><p>Output is redirected in a file called <strong>jobname.postrun.txt</strong></p>
  </dd>
  <dt>
    <p><strong>ioscheduler</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>Attempt to switch the device hosting the file to the specified I/O scheduler.</p>
  </dd>
  <dt>
    <p><strong>disk_util</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>Generate disk utilization statistics if the platform supports it. Default: true.</p>
  </dd>
  <dt>
    <p><strong>clocksource</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>Use the given clocksource as the base of timing. The supported options are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>gettimeofday</strong></p>
  </dt>
  <dd>
    <p><strong>gettimeofday</strong>\|(2)</p>
  </dd>
  <dt>
    <p><strong>clock_gettime</strong></p>
  </dt>
  <dd>
    <p><strong>clock_gettime</strong>\|(2)</p>
  </dd>
  <dt>
    <p><strong>cpu</strong></p>
  </dt>
  <dd>
    <p>Internal CPU clock source</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>

</dl>

  </dd>

</dl>
<p><strong>cpu</strong> is the preferred clocksource if it is reliable, as it is very fast (and fio is heavy on time calls). Fio will automatically use this clocksource if it's supported and considered reliable on the system it is running on, unless another clocksource is specifically set. For x86/x86-64 CPUs, this means supporting TSC Invariant.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>gtod_reduce</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>Enable all of the <strong>gettimeofday</strong>\|(2) reducing options (disable_clat, disable_slat, disable_bw) plus reduce precision of the timeout somewhat to really shrink the <strong>gettimeofday</strong>\|(2) call count. With this option enabled, we only do about 0.4% of the gtod() calls we would have done if all time keeping was enabled.</p>
  </dd>
  <dt>
    <p><strong>gtod_cpu</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Sometimes it's cheaper to dedicate a single thread of execution to just getting the current time. Fio (and databases, for instance) are very intensive on <strong>gettimeofday</strong>\|(2) calls. With this option, you can set one CPU aside for doing nothing but logging current time to a shared memory location. Then the other threads/processes that run IO workloads need only copy that segment, instead of entering the kernel with a <strong>gettimeofday</strong>\|(2) call. The CPU set aside for doing these time calls will be excluded from other uses. Fio will manually clear it from the CPU mask of other jobs.</p>
  </dd>
  <dt>
    <p><strong>ignore_error</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>Sometimes you want to ignore some errors during test in that case you can specify error list for each error type.</p><p>ignore_error=READ_ERR_LIST,WRITE_ERR_LIST,VERIFY_ERR_LIST</p><p>errors for given error type is separated with ':'. Error may be symbol ('ENOSPC', 'ENOMEM') or an integer.</p><p>Example: ignore_error=EAGAIN,ENOSPC:122 .</p><p>This option will ignore EAGAIN from READ, and ENOSPC and 122(EDQUOT) from WRITE.</p>
  </dd>
  <dt>
    <p><strong>error_dump</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>If set dump every error even if it is non fatal, true by default. If disabled only fatal error will be dumped</p>
  </dd>
  <dt>
    <p><strong>profile</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>Select a specific builtin performance test.</p>
  </dd>
  <dt>
    <p><strong>cgroup</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>Add job to this control group. If it doesn't exist, it will be created. The system must have a mounted cgroup blkio mount point for this to work. If your system doesn't have it mounted, you can do so with:</p><p># mount -t cgroup -o blkio none /cgroup</p>
  </dd>
  <dt>
    <p><strong>cgroup_weight</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Set the weight of the cgroup to this value. See the documentation that comes with the kernel, allowed values are in the range of 100..1000.</p>
  </dd>
  <dt>
    <p><strong>cgroup_nodelete</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>Normally fio will delete the cgroups it has created after the job completion. To override this behavior and to leave cgroups around after the job completion, set cgroup_nodelete=1. This can be useful if one wants to inspect various cgroup files after job completion. Default: false</p>
  </dd>
  <dt>
    <p><strong>uid</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Instead of running as the invoking user, set the user ID to this value before the thread/process does any work.</p>
  </dd>
  <dt>
    <p><strong>gid</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Set group ID, see <strong>uid</strong>.</p>
  </dd>
  <dt>
    <p><strong>unit_base</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Base unit for reporting.  Allowed values are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>0</strong></p>
  </dt>
  <dd>
    <p>Use auto-detection (default).</p>
  </dd>
  <dt>
    <p><strong>8</strong></p>
  </dt>
  <dd>
    <p>Byte based.</p>
  </dd>
  <dt>
    <p><strong>1</strong></p>
  </dt>
  <dd>
    <p>Bit based.</p>
  </dd>

</dl>

  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p><strong>flow_id</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>The ID of the flow. If not specified, it defaults to being a global flow. See <strong>flow</strong>.</p>
  </dd>
  <dt>
    <p><strong>flow</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Weight in token-based flow control. If this value is used, then there is a <strong>flow counter</strong> which is used to regulate the proportion of activity between two or more jobs. fio attempts to keep this flow counter near zero. The <strong>flow</strong> parameter stands for how much should be added or subtracted to the flow counter on each iteration of the main I/O loop. That is, if one job has <strong>flow=8</strong> and another job has <strong>flow=-1</strong>, then there will be a roughly 1:8 ratio in how much one runs vs the other.</p>
  </dd>
  <dt>
    <p><strong>flow_watermark</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>The maximum value that the absolute value of the flow counter is allowed to reach before the job must wait for a lower value of the counter.</p>
  </dd>
  <dt>
    <p><strong>flow_sleep</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>The period of time, in microseconds, to wait after the flow watermark has been exceeded before retrying operations</p>
  </dd>
  <dt>
    <p><strong>clat_percentiles</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>Enable the reporting of percentiles of completion latencies.</p>
  </dd>
  <dt>
    <p><strong>percentile_list</strong><em></em>=<em>float_list</em></p>
  </dt>
  <dd>
    <p>Overwrite the default list of percentiles for completion latencies. Each number is a floating number in the range (0,100], and the maximum length of the list is 20. Use ':' to separate the numbers. For example, --percentile_list=99.5:99.9 will cause fio to report the values of completion latency below which 99.5% and 99.9% of the observed latencies fell, respectively.</p>
  </dd>

</dl>

<h3>Ioengine Parameters List</h3>
<p>Some parameters are only valid when a specific ioengine is in use. These are used identically to normal parameters, with the caveat that when used on the command line, they must come after the ioengine.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>(cpu)cpuload</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Attempt to use the specified percentage of CPU cycles.</p>
  </dd>
  <dt>
    <p><strong>(cpu)cpuchunks</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Split the load into cycles of the given time. In microseconds.</p>
  </dd>
  <dt>
    <p><strong>(cpu)exit_on_io_done</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>Detect when IO threads are done, then exit.</p>
  </dd>
  <dt>
    <p><strong>(libaio)userspace_reap</strong></p>
  </dt>
  <dd>
    <p>Normally, with the libaio engine in use, fio will use the io_getevents system call to reap newly returned events. With this flag turned on, the AIO ring will be read directly from user-space to reap events. The reaping mode is only enabled when polling for a minimum of 0 events (eg when iodepth_batch_complete=0).</p>
  </dd>
  <dt>
    <p><strong>(net,netsplice)hostname</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>The host name or IP address to use for TCP or UDP based IO. If the job is a TCP listener or UDP reader, the hostname is not used and must be omitted unless it is a valid UDP multicast address.</p>
  </dd>
  <dt>
    <p><strong>(net,netsplice)port</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>The TCP or UDP port to bind to or connect to.</p>
  </dd>
  <dt>
    <p><strong>(net,netsplice)interface</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>The IP address of the network interface used to send or receive UDP multicast packets.</p>
  </dd>
  <dt>
    <p><strong>(net,netsplice)ttl</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Time-to-live value for outgoing UDP multicast packets. Default: 1</p>
  </dd>
  <dt>
    <p><strong>(net,netsplice)nodelay</strong><em></em>=<em>bool</em></p>
  </dt>
  <dd>
    <p>Set TCP_NODELAY on TCP connections.</p>
  </dd>
  <dt>
    <p><strong>(net,netsplice)protocol</strong><em></em>=<em>str</em><strong></strong>,<strong> proto</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>The network protocol to use. Accepted values are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>tcp</strong></p>
  </dt>
  <dd>
    <p>Transmission control protocol</p>
  </dd>
  <dt>
    <p><strong>tcpv6</strong></p>
  </dt>
  <dd>
    <p>Transmission control protocol V6</p>
  </dd>
  <dt>
    <p><strong>udp</strong></p>
  </dt>
  <dd>
    <p>User datagram protocol</p>
  </dd>
  <dt>
    <p><strong>udpv6</strong></p>
  </dt>
  <dd>
    <p>User datagram protocol V6</p>
  </dd>
  <dt>
    <p><strong>unix</strong></p>
  </dt>
  <dd>
    <p>UNIX domain socket</p>
  </dd>

</dl>
<p>When the protocol is TCP or UDP, the port must also be given, as well as the hostname if the job is a TCP listener or UDP reader. For unix sockets, the normal filename option should be used and the port is invalid.</p>
  </dd>
  <dt>
    <p><strong>(net,netsplice)listen</strong></p>
  </dt>
  <dd>
    <p>For TCP network connections, tell fio to listen for incoming connections rather than initiating an outgoing connection. The hostname must be omitted if this option is used.</p>
  </dd>
  <dt>
    <p><strong>(net,</strong><em>pingpong)</em><strong></strong>=<strong>bool</strong></p>
  </dt>
  <dd>
    <p>Normally a network writer will just continue writing data, and a network reader will just consume packets. If pingpong=1 is set, a writer will send its normal payload to the reader, then wait for the reader to send the same payload back. This allows fio to measure network latencies. The submission and completion latencies then measure local time spent sending or receiving, and the completion latency measures how long it took for the other end to receive and send back. For UDP multicast traffic pingpong=1 should only be set for a single reader when multiple readers are listening to the same address.</p>
  </dd>
  <dt>
    <p><strong>(e4defrag,donorname)</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>File will be used as a block donor (swap extents between files)</p>
  </dd>
  <dt>
    <p><strong>(e4defrag,inplace)</strong><em></em>=<em>int</em></p>
  </dt>
  <dd>
    <p>Configure donor file block allocation strategy</p><p><strong>0(default)</strong><em>:</em> Preallocate donor's file on init</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>1:</strong></p>
  </dt>
  <dd>
    <p>allocate space immediately inside defragment event, and free right after event</p>
  </dd>

</dl>

  </dd>
  <dt>
    <p><strong>(rbd)rbdname</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>Specifies the name of the RBD.</p>
  </dd>
  <dt>
    <p><strong>(rbd)pool</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>Specifies the name of the Ceph pool containing the RBD.</p>
  </dd>
  <dt>
    <p><strong>(rbd)clientname</strong><em></em>=<em>str</em></p>
  </dt>
  <dd>
    <p>Specifies the username (without the 'client.' prefix) used to access the Ceph cluster.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OUTPUT</h2>
        <div class="sectioncontent">
<p>While running, <strong>fio</strong> will display the status of the created jobs.  For example:</p><p>Threads: 1: [_r] [24.8% done] [ 13509/  8334 kb/s] [eta 00h:01m:31s]</p><p>The characters in the first set of brackets denote the current status of each threads.  The possible values are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>P</strong></p>
  </dt>
  <dd>
    <p>Setup but not started.</p>
  </dd>
  <dt>
    <p><strong>C</strong></p>
  </dt>
  <dd>
    <p>Thread created.</p>
  </dd>
  <dt>
    <p><strong>I</strong></p>
  </dt>
  <dd>
    <p>Initialized, waiting.</p>
  </dd>
  <dt>
    <p><strong>R</strong></p>
  </dt>
  <dd>
    <p>Running, doing sequential reads.</p>
  </dd>
  <dt>
    <p><strong>r</strong></p>
  </dt>
  <dd>
    <p>Running, doing random reads.</p>
  </dd>
  <dt>
    <p><strong>W</strong></p>
  </dt>
  <dd>
    <p>Running, doing sequential writes.</p>
  </dd>
  <dt>
    <p><strong>w</strong></p>
  </dt>
  <dd>
    <p>Running, doing random writes.</p>
  </dd>
  <dt>
    <p><strong>M</strong></p>
  </dt>
  <dd>
    <p>Running, doing mixed sequential reads/writes.</p>
  </dd>
  <dt>
    <p><strong>m</strong></p>
  </dt>
  <dd>
    <p>Running, doing mixed random reads/writes.</p>
  </dd>
  <dt>
    <p><strong>F</strong></p>
  </dt>
  <dd>
    <p>Running, currently waiting for <strong>fsync</strong>\|(2).</p>
  </dd>
  <dt>
    <p><strong>V</strong></p>
  </dt>
  <dd>
    <p>Running, verifying written data.</p>
  </dd>
  <dt>
    <p><strong>E</strong></p>
  </dt>
  <dd>
    <p>Exited, not reaped by main thread.</p>
  </dd>
  <dt>
    <p><strong>-</strong></p>
  </dt>
  <dd>
    <p>Exited, thread reaped.</p>
  </dd>

</dl>
<p>The second set of brackets shows the estimated completion percentage of the current group.  The third set shows the read and write I/O rate, respectively. Finally, the estimated run time of the job is displayed.</p><p>When <strong>fio</strong> completes (or is interrupted by Ctrl-C), it will show data for each thread, each group of threads, and each disk, in that order.</p><p>Per-thread statistics first show the threads client number, group-id, and error code.  The remaining figures are as follows:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>io</strong></p>
  </dt>
  <dd>
    <p>Number of megabytes of I/O performed.</p>
  </dd>
  <dt>
    <p><strong>bw</strong></p>
  </dt>
  <dd>
    <p>Average data rate (bandwidth).</p>
  </dd>
  <dt>
    <p><strong>runt</strong></p>
  </dt>
  <dd>
    <p>Threads run time.</p>
  </dd>
  <dt>
    <p><strong>slat</strong></p>
  </dt>
  <dd>
    <p>Submission latency minimum, maximum, average and standard deviation. This is the time it took to submit the I/O.</p>
  </dd>
  <dt>
    <p><strong>clat</strong></p>
  </dt>
  <dd>
    <p>Completion latency minimum, maximum, average and standard deviation.  This is the time between submission and completion.</p>
  </dd>
  <dt>
    <p><strong>bw</strong></p>
  </dt>
  <dd>
    <p>Bandwidth minimum, maximum, percentage of aggregate bandwidth received, average and standard deviation.</p>
  </dd>
  <dt>
    <p><strong>cpu</strong></p>
  </dt>
  <dd>
    <p>CPU usage statistics. Includes user and system time, number of context switches this thread went through and number of major and minor page faults.</p>
  </dd>
  <dt>
    <p><strong>IO depths</strong></p>
  </dt>
  <dd>
    <p>Distribution of I/O depths.  Each depth includes everything less than (or equal) to it, but greater than the previous depth.</p>
  </dd>
  <dt>
    <p><strong>IO issued</strong></p>
  </dt>
  <dd>
    <p>Number of read/write requests issued, and number of short read/write requests.</p>
  </dd>
  <dt>
    <p><strong>IO latencies</strong></p>
  </dt>
  <dd>
    <p>Distribution of I/O completion latencies.  The numbers follow the same pattern as <strong>IO depths</strong>.</p>
  </dd>

</dl>
<p>The group statistics show:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>io</strong></p>
  </dt>
  <dd>
    <p>Number of megabytes I/O performed.</p>
  </dd>
  <dt>
    <p><strong>aggrb</strong></p>
  </dt>
  <dd>
    <p>Aggregate bandwidth of threads in the group.</p>
  </dd>
  <dt>
    <p><strong>minb</strong></p>
  </dt>
  <dd>
    <p>Minimum average bandwidth a thread saw.</p>
  </dd>
  <dt>
    <p><strong>maxb</strong></p>
  </dt>
  <dd>
    <p>Maximum average bandwidth a thread saw.</p>
  </dd>
  <dt>
    <p><strong>mint</strong></p>
  </dt>
  <dd>
    <p>Shortest runtime of threads in the group.</p>
  </dd>
  <dt>
    <p><strong>maxt</strong></p>
  </dt>
  <dd>
    <p>Longest runtime of threads in the group.</p>
  </dd>

</dl>
<p>Finally, disk statistics are printed with reads first:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>ios</strong></p>
  </dt>
  <dd>
    <p>Number of I/Os performed by all groups.</p>
  </dd>
  <dt>
    <p><strong>merge</strong></p>
  </dt>
  <dd>
    <p>Number of merges in the I/O scheduler.</p>
  </dd>
  <dt>
    <p><strong>ticks</strong></p>
  </dt>
  <dd>
    <p>Number of ticks we kept the disk busy.</p>
  </dd>
  <dt>
    <p><strong>io_queue</strong></p>
  </dt>
  <dd>
    <p>Total time spent in the disk queue.</p>
  </dd>
  <dt>
    <p><strong>util</strong></p>
  </dt>
  <dd>
    <p>Disk utilization.</p>
  </dd>

</dl>
<p>It is also possible to get fio to dump the current output while it is running, without terminating the job. To do that, send fio the <strong>USR1</strong> signal.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TERSE OUTPUT</h2>
        <div class="sectioncontent">
<p>If the <strong>--minimal</strong> / <strong>--append-terse</strong> options are given, the results will be printed/appended in a semicolon-delimited format suitable for scripted use. A job description (if provided) follows on a new line.  Note that the first number in the line is the version number. If the output has to be changed for some reason, this number will be incremented by 1 to signify that change.  The fields are:</p><p><strong>terse version, fio version, jobname, groupid, error</strong></p><p>Read status:</p><p><strong>Total I/O </strong>(KB)<strong>, bandwidth </strong>(KB/s)<strong>, IOPS, runtime </strong>(ms)<strong></strong></p><p>Submission latency:</p><p><strong>min, max, mean, standard deviation</strong></p><p>Completion latency:</p><p><strong>min, max, mean, standard deviation</strong></p><p>Completion latency percentiles (20 fields):</p><p><strong>Xth percentile=usec</strong></p><p>Total latency:</p><p><strong>min, max, mean, standard deviation</strong></p><p>Bandwidth:</p><p><strong>min, max, aggregate percentage of total, mean, standard deviation</strong></p><p>Write status:</p><p><strong>Total I/O </strong>(KB)<strong>, bandwidth </strong>(KB/s)<strong>, IOPS, runtime </strong>(ms)<strong></strong></p><p>Submission latency:</p><p><strong>min, max, mean, standard deviation</strong></p><p>Completion latency:</p><p><strong>min, max, mean, standard deviation</strong></p><p>Completion latency percentiles (20 fields):</p><p><strong>Xth percentile=usec</strong></p><p>Total latency:</p><p><strong>min, max, mean, standard deviation</strong></p><p>Bandwidth:</p><p><strong>min, max, aggregate percentage of total, mean, standard deviation</strong></p><p>CPU usage:</p><p><strong>user, system, context switches, major page faults, minor page faults</strong></p><p>IO depth distribution:</p><p><strong>&lt;=1, 2, 4, 8, 16, 32, &gt;=64</strong></p><p>IO latency distribution:</p><p>Microseconds:</p><p><strong>&lt;=2, 4, 10, 20, 50, 100, 250, 500, 750, 1000</strong></p><p>Milliseconds:</p><p><strong>&lt;=2, 4, 10, 20, 50, 100, 250, 500, 750, 1000, 2000, &gt;=2000</strong></p><p>Disk utilization (1 for each disk used):</p><p><strong>name, read ios, write ios, read merges, write merges, read ticks, write ticks, read in-queue time, write in-queue time, disk utilization percentage</strong></p><p>Error Info (dependent on continue_on_error, default off):</p><p><strong>total # errors, first error code</strong></p><p><strong>text description (if provided in config - appears on newline)</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CLIENT / SERVER</h2>
        <div class="sectioncontent">
<p>Normally you would run fio as a stand-alone application on the machine where the IO workload should be generated. However, it is also possible to run the frontend and backend of fio separately. This makes it possible to have a fio server running on the machine(s) where the IO workload should be running, while controlling it from another machine.</p><p>To start the server, you would do:</p><p><strong>fio --server=args</strong></p><p>on that machine, where args defines what fio listens to. The arguments are of the form 'type:hostname or IP:port'. 'type' is either 'ip' (or ip4) for TCP/IP v4, 'ip6' for TCP/IP v6, or 'sock' for a local unix domain socket. 'hostname' is either a hostname or IP address, and 'port' is the port to listen to (only valid for TCP/IP, not a local socket). Some examples:</p><p>1) fio --server</p>
<pre>
   Start a fio server, listening on all interfaces on the default port (8765).
</pre>
<p>2) fio --server=ip:hostname,4444</p>
<pre>
   Start a fio server, listening on IP belonging to hostname and on port 4444.
</pre>
<p>3) fio --server=ip6:::1,4444</p>
<pre>
   Start a fio server, listening on IPv6 localhost ::1 and on port 4444.
</pre>
<p>4) fio --server=,4444</p>
<pre>
   Start a fio server, listening on all interfaces on port 4444.
</pre>
<p>5) fio --server=1.2.3.4</p>
<pre>
   Start a fio server, listening on IP 1.2.3.4 on the default port.
</pre>
<p>6) fio --server=sock:/tmp/fio.sock</p>
<pre>
   Start a fio server, listening on the local socket /tmp/fio.sock.
</pre>
<p>When a server is running, you can connect to it from a client. The client is run with:</p><p>fio --local-args --client=server --remote-args &lt;job file(s)&gt;</p><p>where --local-args are arguments that are local to the client where it is running, 'server' is the connect string, and --remote-args and &lt;job file(s)&gt; are sent to the server. The 'server' string follows the same format as it does on the server side, to allow IP/hostname/socket and port strings. You can connect to multiple clients as well, to do that you could run:</p><p>fio --client=server2 --client=server2 &lt;job file(s)&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p><strong>fio</strong> was written by Jens Axboe &lt;jens.axboe@oracle.com&gt;, now Jens Axboe &lt;jaxboe@fusionio.com&gt;.</p><p>This man page was written by Aaron Carroll &lt;aaronc@cse.unsw.edu.au&gt; based on documentation by Jens Axboe.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REPORTING BUGS</h2>
        <div class="sectioncontent">
<p>Report bugs to the <strong>fio</strong> mailing list &lt;fio@vger.kernel.org&gt;. See <strong>README</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO fio&hellip;</h2>
        <div class="sectioncontent">
<p>For further documentation see <strong>HOWTO</strong> and <strong>README</strong>.</p><p>Sample jobfiles are available in the <strong>examples</strong> directory.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="ucspi-tcp-ipv6-finger@.1.html"><span aria-hidden="true">&larr;</span> finger@.1: Get user information from a host</a></li>
   <li class="next"><a href="fio2gnuplot.1.html">fio2gnuplot.1: Render fio's output files with gnuplot <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

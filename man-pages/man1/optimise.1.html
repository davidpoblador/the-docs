<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>optimise: Yagi-uda project antenna optimiser</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Yagi-uda project antenna optimiser">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="optimise (1) manual">
  <meta name="twitter:description" content="Yagi-uda project antenna optimiser">
  <meta name="twitter:image" content="https://www.carta.tech/images/yagiuda-optimise-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/optimise.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="optimise (1) manual" />
  <meta property="og:description" content="Yagi-uda project antenna optimiser" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/yagiuda-optimise-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">optimise<small> (1)</small></h1>
        <p class="lead">Yagi-uda project antenna optimiser</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/optimise.1.html">
      <span itemprop="name">optimise: Yagi-uda project antenna optimiser</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/yagiuda/">
      <span itemprop="name">yagiuda</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/optimise.1.html">
      <span itemprop="name">optimise: Yagi-uda project antenna optimiser</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>optimise</strong> [ <strong>-dhvwO</strong> ] [ <strong>-a</strong><em>angular_stepsize</em> ] [ <strong>-b</strong><em>boom_extension</em> ] [ <strong>-c</strong><em>cleanliness_of_pattern</em> ] [ <strong>-e</strong><em>elements</em> ] [ <strong>-f</strong><em>FBratio</em> ] [ <strong>-g</strong><em>GA_optimisation_method</em> ] <strong>-l</strong><em>percent</em> ] [ <strong>-m</strong><em>min_offset_from_peak</em> ] [ <strong>-o</strong><em>optimisation_criteria</em> ] [ <strong>-p</strong><em>population</em> ] [ <strong>-r</strong><em>resistance</em> ] [ <strong>-s</strong><em>swr</em> ] [ <strong>-t</strong><em>length_tolerance</em> ] [ <strong>-x</strong><em>reactance</em> ] [ <strong>-A</strong><em>Auto_gain</em> ] [ <strong>-C</strong><em>Currents_similar</em> ] [ <strong>-F</strong><em>weight_FB</em> ] [ <strong>-G</strong><em>weight_gain</em> ] [ <strong>-K</strong><em>keep_for_tries</em> ] [ <strong>-P</strong><em>weight_pattern_cleanliness</em> ] [ <strong>-R</strong><em>weight_resistance</em> ] [ <strong>-S</strong><em>weight_swr</em> ] [ <strong>-T</strong><em>position_tolerance</em> ] [ <strong>-W</strong><em>Weighted_algorithm</em> ] [ <strong>-X</strong><em>weight_reactance</em> [ <strong>-Z</strong><em>Zo</em> ] filename iterations</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The program <strong>optimise</strong> is one of a number of executable programs that forms part of a set of programs, collectively known as the <em>Yagi-Uda project</em> , which were designed for analysis and optimisation of Yagi-Uda antennas. <em>optimise</em> attempts to optimise the performance of a Yagi antenna for one or more parameters that are considered important, such as gain, F/B ratio, VSWR etc. It does this by randomly changing the lengths and positions, of one or more elements, then comparing the performance before and after the change. Any improvements are written to a new file called <em>filename.bes</em> where filename is the name of the antenna description file created by <em>input</em> or <em>first</em></p><p>When Yagi's are designed on paper, or using this program, its possible that they will be almost impossible to build, if their performance depends too critically on the dimensions. To determine if this is the case with a design, we run optimise with just the options 't' and 'T'. These specify the tolerance with which you can build the antenna, expressed as a standard deviation in mm. In this case, instead of trying to optimise a poor design, optimise will calculate the minimum gain, maximum VSWR, and minimum FB ratio of a number of designs, all slightly different from the input file. 99.7% of the components lie within 3 SD of the mean, so if you think you can cut elements to with 1 mm 99.7% of the time, specify t0.33. If you can put them in the boom to within 3 mm 99.7% of the time, specify T1.</p><p>If while <em>optimise</em> is running using the methods that require weights to be attached to the gain, FB, SWR etc, it becomes apparent, the weights are not optimum, its possible to pause the program and re-adjust the weights. If a file with the name of <em>changes</em> is created, the program will pause, then request new weights are entered at the keyboard.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AVAILABILITY</h2>
        <div class="sectioncontent">

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>-d</strong></p>
  </dt>
  <dd>
    <p>Print the default values of all the configureable parameters to stdout. Typing this option with any option that changes a parameter (see below) will display the new value of the parameter, rather than the default.</p>
  </dd>
  <dt>
    <p><strong>-h</strong></p>
  </dt>
  <dd>
    <p>Print a help message.</p>
  </dd>
  <dt>
    <p><strong>-v</strong></p>
  </dt>
  <dd>
    <p>Print verbose status information.</p>
  </dd>
  <dt>
    <p><strong>-w</strong></p>
  </dt>
  <dd>
    <p>Instead of optimising at one fixed frequency (the design frequency), this directs the program to optimise at 3 separate frequencies (lowest, design and highest) then to average data at all 3. This option is better for wideband antenna. Note that the input impedance printed is at the design frequency, *not* averaged over 3 frequencies. Averaging an impedance, is likely to give a very misleading impression. The impedance averaged over 3 frequencies can be 50+i0 Ohms, even if the VSWR is very poor over all 3 frequencies, as the following 3 pieces of data show.</p><p>Z=147 + j 300  SWR= 15.46:1</p><p>Z=2   + j 100  SWR= 125:1</p><p>Z=1   - j 400  SWR= 3250:1</p><p>note in the above three cases, the average impedance is 50 + j 0, but average SWR is 1130:1.</p>
  </dd>
  <dt>
    <p><strong>-O</strong></p>
  </dt>
  <dd>
    <p>Over-optimisation allowed.  By default, the program does not over-optimise a parameter. For example, an SWR of 1.01 is usually considered good enough and any change, as long as the SWR stayed good, typically below 1.1:1, would be allowed, even if the SWR rose. By default, FB's of 27 dB, VSWR's of 1.1 are acceptable. However, by using the <strong>-O</strong> option, you can insist the program always improves things, no matter how good they are.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>-a</strong><em>Angular_stepsize</em></p>
  </dt>
  <dd>
    <p>When optimimising by trying to get a clean pattern, specifies the step size to use when looking for features in the pattern. If its set too small, the program  runs slow. If its set too large, the program may miss features in the pattern, such as a sidelobe. Then the resulting antenna will have poor sidelobe performance, even though you think it will be good. The program attempts to calculate a sensible value, based on 1/10th the approximate 3 dB beamwidth, if you don't set.</p>
  </dd>
  <dt>
    <p><strong>-b</strong><em>boom_extension</em></p>
  </dt>
  <dd>
    <p>Generally speaking, the gain of a Yagi increases with boom length. Hence the optimiser would often give you a Yagi with a much longer boom than the input file. This may not be what you desire due to space restrictions. These long antennas often have high gain, but are very narrow in bandwidth. The default limits the antenna to 10x the original length, which means effectively there is no boom length limitation. You can adjust the percentage by setting <em>boom_extension</em> to whatever you wish. <em>-b30</em> will limit the boom to no more than 30% more than the original length.</p>
  </dd>
  <dt>
    <p><strong>-c</strong><em>cleanliness_of_pattern</em></p>
  </dt>
  <dd>
    <p>Specify the number of dB down on the peak gain to aim to get the pattern. Any antenna pattern cleaner than this will not effect the fitness, nor will it be considered any better when comparing to antenna designs. 20 dB seems reasonable, so the default is 20, but this may of course change if it's deceided too. Check the source code to be certain (see REASONABLE_SIDELOBE in yagi.h).</p>
  </dd>
  <dt>
    <p><strong>-e</strong><em>elements</em></p>
  </dt>
  <dd>
    <p>is an integer which specifies the type of elements that are changed in the optimisation cycle. Possible values are:</p><p>1 - alter only the driven element(s) length (useful to bring to resonance)</p><p>2 - alter only the driven element position. Don't change its length.</p><p>4 - alter only the reflector length. The position is always at x=0.</p><p>8 - alter only the director lengths. Don't change positions.</p><p>16 - alter only the director positions. Don't change lengths.</p><p>32 - randomly adjust one element length, then makes all other the same. Don't change the positions.</p><p>64 - apply a linear taper to the lengths.</p><p>128 - Set the driven element to a resonate length. It may/may-not be altered after the first run, depending on the whether or not '1' is invoked too. Eg -e128 will make it resonate and keep it there forever. However '-e129' will bring to resonance, then alter to maximuse performance. The elements altered is made from a logical AND of the above, so for example to alter everything, except the driven element length, use -e30, since 2+4+8+16=30. The  default is equivalent to <em>-e31</em> , which changes everything possible. Note the reflector position is *never* changed. It's always at x=0.</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>-f</strong><em>FBratio</em></p>
  </dt>
  <dd>
    <p>When optimising an antenna, consider any FB ratio greater than <em>FBratio</em> dB to be equal to <em>FBratio</em> dB. This avoids optimising to a very high FB ratio, which is impracticable, as the bandwidth over which this FB ratio will be maintained is very small and mechanical considerations will prevent you from constructing it with such a high FB ratio anyway. If this was not prevented, you might just happen to get an antenna with 100 dB FB ratio, but poor gain and swr. Since by default all parameters must improve, the optimisation routine will most likely never being able to improve on the 100 dB FB ratio, so no improvement will result. Most people would prefer to get a few extra dB of gain, even if the FB ratio dropped to 30 dB.</p>
  </dd>
  <dt>
    <p><strong>-g</strong><em>GA_optimisation_method</em></p>
  </dt>
  <dd>
    <p>Use a genetic algorithm. With the genetic algorithm, the program does not take any account any of the initial lengths/positions of elements specified in the input file. Rather it works by initialising a number of different antenna, then computing a 'fitness' value for each. The fitness value can depend on the gain, FB, real part of the input impedance, reactive part of the input impedance, VSWR or the level of the sidelobes. The integer after the g tells the optimiser what to consider. -g1  Use gain</p><p>-g2  Use FB</p><p>-g4  Use R</p><p>-g8  Use X</p><p>-g16 Use the SWR</p><p>-g32 Use the level of the sidelobes.</p><p>You can use a logical AND of these, so for example -g49 will use a genetic algorithm, optimising for gain, swr and sidelobe level, since 1(gain)+16(SWR)+32(sidelobe level)=49.</p>
  </dd>
  <dt>
    <p><strong>-l</strong><em>percent</em></p>
  </dt>
  <dd>
    <p>is a parameter (floating point number) which specifies the maximum percentage change in the positions or lengths of an elements at each iteration. If the option is not used, it will be set internally at 10% for the first 25% of the iterations, 1% for the next 25%, 0.1% for the third 25% of the iterations and 0.01% for the last 25% of the iterations. If set to a positive number x (eg optimise -l 0.3 145e10) then the percentage will be set at x% for 25% of iterations, x/10 for the  next 25%, x/100 for the next 25 and x/1000 for the last 25%. If set to a negative number y (eg optimise -l -0.5 145e10) then the paramters will stay fixed at y% (in this example 0.5%) all the time.</p>
  </dd>
  <dt>
    <p><strong>-m</strong><em>min_offset-from_peak</em></p>
  </dt>
  <dd>
    <p>Sets the minimum angle in degrees offset from theta=90 degrees, where the side lobes start and the main lobe finishes. The higher the gain, the smaller it should be. It is set internally if not set on the command line.</p>
  </dd>
  <dt>
    <p><strong>-o</strong><em>optimisation_criteria</em></p>
  </dt>
  <dd>
    <p>1 -  Assume better if the gain has increased.</p><p>2 -  Assume better if the front to back ratio has improved.</p><p>4 -  Assume better if the real part of the input impedance is closer to the value that the program was compiled for, or set using the '-Z' option. This will usually be 50 Ohms, but you may wish to set this to 12.5 Ohms if you use a 4:1 balun. Generally you can get higher gain from a Yagi if you allow the input impedance to fall, but of course feeding it becomes more difficult.</p><p>8 -  Assume better if the magnitude of the reactive component of the input impedance is lower (ie. the antenna is nearer resonance).</p><p>16 - Assume better if the VSWR is lower.</p><p>32 - Assume better if the level of all sidelobes is lower. The <em>optimisation_criteria</em> may be formed from a logical AND of these numbers, so for example choosing <em>-o19</em> will only consider a revised antenna better than the previous, if the SWR, gain and F/B ratio have all simultaneously improved.</p><p>Clearly an antenna which originally had 12 dB gain and 1.01:1 VSWR but then changes to 20 dB gain @ 1.02:1 VSWR, would to most people be better, even though the VSWR has increased. By default, <em>optimise</em> only optimises to sensible maximums, so to not let the optimisation stall prematurely. By running <em>optimise</em> with no arguments, the program will list the limits of acceptability. These might be typically F/B ratio &gt; 27 dB, VSWR &lt; 1.1:1, magnitude of input reactance less than 5 Ohms and the real part of the input impedance within 5 Ohms of Zo. Choosing <em>-o19</em> (1+2+16=19) will optimise for gain (since G=1), FB (since FB=2) and SWR (Since SWR=16), but would consider a higher gain and FB ratio antenna better than a previous one, even if the SWR rose, as long as it stayed below 1.1:1 (or as was set during compilation). The default behaviour (no options) is equivalent to <em>-o37</em> which optimiseas for <strong>gain</strong>(1), the real part of the input <strong>impedance</strong>(4) and sidelobes(32) but this may be changed at any time, so type <em>optimise -d</em> to check the current settings. If you insist on the program optimisang for the very best of all selected parameters, use the -O option too, but be warned the optimisation will probely stick once it gets one parameter really good.</p>
  </dd>
  <dt>
    <p><strong>-p</strong><em>population</em></p>
  </dt>
  <dd>
    <p>This determines the initial population used  with the genetic algorithm.</p>
  </dd>
  <dt>
    <p><strong>-r</strong><em>resistance</em></p>
  </dt>
  <dd>
    <p>When optimising an antenna, consider any input resistance closer to Zo (usually 50 Ohms) than <em>resistance</em> Ohms to be acceptable. This avoids optimising to an input resistance too close to Zo, which is impracticable, as the bandwidth over which the input resistance could be maintained is very small and mechanical considerations will prevent you from constructing the antenna with such an ideal input resistance. If this was not prevented, you might just happen to get an antenna with an input resistance of 50.000001 Ohms, but poor gain, FB and possibly even a poor swr, if the antenna is well away from resonance. Since by default all parameters must improve, the optimisation routine will get most likely never being able to improve on the antenna, whereas we might be happier with a few more dB gain, if the input resistance went to 50.1 Ohms. It should be noted that the default optimisation routine never uses the input resistance directly (only VSWR), so this option cant be used without the '-o' option to optimise for other than the default parameters (gain, VSWR and FB ratio).</p>
  </dd>
  <dt>
    <p><strong>-s</strong><em>swr</em></p>
  </dt>
  <dd>
    <p>When optimising an antenna, consider any SWR less than <em>swr</em> to be equal to <em>swr</em> This avoids optimising to a very low swr, which is impracticable, as the bandwidth over which such a low swr could be maintained would be very small and mechanical considerations will prevent you from constructing such an antenna anyway. If this is was not prevented, you might just happen to get an antenna with an swr of 1.000000000001:1, but poor gain, FB ratio. Since by default all parameters must improve, the optimisation routine will most likely never being able to improve on the antenna, even though in practice you would like to get a few extra dB of gain if the SWR would rise to 1.02:1. The default was equivalent to <em>-s1.1</em> but run <em>optimise -d</em> to display this and any other defaults.</p>
  </dd>
  <dt>
    <p><strong>-t</strong><em>length_tolerance</em></p>
  </dt>
  <dd>
    <p><em>length_tolerance</em> is the standard deviation in mm of the accuracy with which you can cut elements. Since 99.7% of elements will be with 3 standard deviations of the mean length (stats theory says this), set -t0.2 if virtually all (well 99.7%) of elements are within 3x0.2=0.6 mm of the correct length. This option *must* be used with the '-T'  option and can't be used with any other options apart from '-Z', '-v' and '-d'.</p>
  </dd>
  <dt>
    <p><strong>-x</strong><em>reactance</em></p>
  </dt>
  <dd>
    <p>When optimising an antenna, consider any input reactance of less than <em>reactance</em> to be <em>reactance.</em> This avoids over optimising the reactance, at the expense of something else.</p>
  </dd>
  <dt>
    <p><strong>-A</strong><em>auto_gain</em></p>
  </dt>
  <dd>
    <p>When the <em>auto_gain</em> option is used. the program maximes the gain of the antenna (ignoring all other parameters such as SWR, FB ratio etc) by adjusting the length (not position) of one element only. -A-1 will maximuse the gain, by adjusting the length of the reflector, -A0 will maximise the gain by adjusting the length of the driven element. Its generally *not* a good idea to maximise the gain by adjusting the driven element, but the program lets you do it, but using the option -A0. Using -A1 will maximise gain by adjusting the length of the first director, -A2 the second director and so on, up to the last director. You must check carefully that the input impedance in particular does not fall to silly values if you use this option. On a yagi with many elements (&gt; 10 or so), you can pretty safely maximise the 8th or more director, but doing it on the reflector, driven element or early directors often leads to silly input impedances - so beware! Note, no matter how many iterations you specify, this process is only done once.Its unlikely you will be able to do it again, without things going out of hand, but if you must do it, you must re-run 'optimise' again.</p>
  </dd>
  <dt>
    <p><strong>-C</strong><em>currents_similar</em></p>
  </dt>
  <dd>
    <p>If this option is used, where <em>currents_similar</em> is an integer, the program looks to make the currents in the last <em>currents_similar</em> elements as similar as possible. It computes the sum of the squares of the deviations of the absolute values of the element currents from the mean. If this falls, and the criteria specified with the -W option is also satisfied, the antenna is considered better. If <em></em> currents_similar is three less than the number of directors, it tries to make the currents in the the directors (but ignoringing the first 3) all similar. If <em>currents_similar</em> is equal to the number of directors, it tries to make all the directors have similar currents. If <em>currents_similar</em> is one more than the number of directors, it tries to make all the directors and the reflector have similar currents. If <em>currents_similar</em> is equal to the total number of elements, then it fails with an error message.</p>
  </dd>
  <dt>
    <p><strong>-F</strong><em>weight_FB</em></p>
  </dt>
  <dd>
    <p>is the floating point number (default 1.0) specifying the weight to attach to the FB ratio of the antenna when using the '-W' option, which calculates a fitness for the antenna based on one or more parameters (FB, gain, input resistance, input reactance, SWR, cleanliness of antenna pattern). The '-F' option is similar to the options -G, -P, -R, -S, -X (which specify weights for gain, pattern cleanliness, input resistance, SWR and input reactance). When using the -W option the exact algorithm used to compute the fitness (and hence the effect of this parameter) is best checked by looking at the source code (see perform.c). This is one area of constant program improvement/changes/development, so its difficult to say exactly the effect the parameter has. However, increasing the weight of a parameter (using the -F, -G, -R, -S or -X options) will make  the associated parameter have a greater effect on the fitness. However, unless you optimise for a high FB ratio with the -W option, then setting the -F option will have no effect. For example, setting the options -F2.5 -W1 is a complete waste of time. There you have used the -W1 option to optimise only for gain (see -W option section of man page) but have changed the weight of the FB ratio from its default 1.0 to 2.5. If you are not optimising for FB ratio, the weight you attach to it is irrelavent.</p>
  </dd>
  <dt>
    <p><strong>-G</strong><em>weight_gain</em></p>
  </dt>
  <dd>
    <p>is the floating point number (default 1.0) specifying the weight to attach to the gain of the antenna when using the '-W' option, which calculates a fitness for the antenna based on one or more parameters (FB, gain, input resistance, input reactance, SWR, cleanliness of antenna pattern). The '-G' option is similar to the options -F, -P, -R, -S, -X (which specify weights for FB ratio, pattern cleanliness, input resistance, SWR and input reactance). When using the -W option the exact algorithm used to compute the fitness (and hence the effect of this parameter) is best checked by looking at the source code (see perform.c). This is one area of constant program improvement/changes/development, so its difficult to say exactly the effect the parameter has. However, increasing the weight of a parameter (using the -F, -G, -R, -S or -X options) will make  the associated parameter have a greater effect on the fitness. However, unless you optimise for gain with the -W option, then setting the -G option will have no effect. For example, setting the options -G2.5 -W2 is a complete waste of time. There you have used the -W2 option to optimise only for FB ratio (see -W option section of man page) but have changed the weight of the gain from its default 1.0 to 2.5. If you are not optimising for gain, the weight you attach to it is irrelavent.</p>
  </dd>
  <dt>
    <p><strong>-K</strong><em>keep_for_tries</em></p>
  </dt>
  <dd>
    <p><em>keep_for_tries</em> is the number of tries for the optimise to persist using the original data file as the starting point for optimisation. By default it is 1, which means the program immediately looks from a new position once a better one is found. It is theeoretically possible that this might result in a quick, but poor local maximum. If however, <em>keep_for_tries</em> is 1000, it will stay at a position for 1000 iterations after finding the last best result, before considering this to be a global optimum. Then it starts for the new position. In practice, I have found this option to make matters worst in most cases. It was added to avoid the local-minimum problem, but it appears the optimisation surface is pretty smooth, so it just slows the program, without gaining much. Anyway, it can stay as an option, but check the results with/without carefully before using extensively.</p>
  </dd>
  <dt>
    <p><strong>-P</strong><em>pattern_cleanlyiness</em></p>
  </dt>
  <dd>
    <p>is the floating point number (default 1.0) specifying the weight to attach to the cleanness of the antenna pattern when using the '-W' option, which calculates a fitness for the antenna based on one or more parameters (FB, gain, input resistance, input reactance, SWR, cleanliness of antenna pattern). The '-P' option is similar to the options -F, -G, -R, -S, -X (which specify weights for FB ratio, gain, input resistance, SWR and input reactance). When using the -W option the exact algorithm used to compute the fitness (and hence the effect of this parameter) is best checked by looking at the source code (see perform.c). This is one area of constant program improvement/changes/development, so its difficult to say exactly the effect the parameter has. However, increasing the weight of a parameter (using the -F, -G, -R, -S or -X options) will make  the associated parameter have a greater effect on the fitness. However, unless you optimise for a clean antenna pattern with the -W option, then setting the -P option will have no effect. For example, setting the options -P2.5 -W1 is a complete waste of time. There you have used the -W1 option to optimise only for gain (see -W option section of man page) but have changed the weight of the pattern cleanliness from its default 1.0 to 2.5. If you are not optimising for a clean radiation pattern, the weight you attach to it is irrelavent. With appropiate use of the -W option (eg -W49 for gain, SWR and a clean pattern), the computer program finds the level of the most significant sidelobe, wherever it may be outside the main bean. It then optimises to reduce this. The -P option tells it how much weight to put on reducing this sidelobe.</p>
  </dd>
  <dt>
    <p><strong>-R</strong><em>weight_resistance</em></p>
  </dt>
  <dd>
    <p>is the floating point number (default 1.0) specifying the weight to attach to the obtaining an input resistance close to Zo on the antenna when using the '-W' option, which calculates a fitness for the antenna based on one or more parameters (FB, gain, input resistance, input reactance, SWR, cleanliness of antenna pattern). The '-R' option is similar to the options -F, -G, -P, -S, -X (which specify weights for FB, gain, pattern cleanliness, SWR and input reactance). When using the -W option the exact algorithm used to compute the fitness (and hence the effect of this parameter) is best checked by looking at the source code (see perform.c). This is one area of constant program improvement/changes/development, so its difficult to say exactly the effect the parameter has. However, increasing the weight of a parameter (using the -F, -G, -R, -S or -X options) will make  the associated parameter have a greater effect on the fitness. However, unless you optimise for an an input resistance close to Zo, with the -W option, then setting the -R option will have no effect. For example, setting the options -R2.5 -W1 is a complete waste of time. There you have used the -W1 option to optimise only for gain (see -W option section of man page) but have changed the weight of the resistance from its default 1.0 to 2.5. If you are not optimising for an input resistance close to Zo, the weight you attach to it is irrelavent.</p>
  </dd>
  <dt>
    <p><strong>-S</strong><em>weight_swr</em></p>
  </dt>
  <dd>
    <p>is the floating point number (default 1.0) specifying the weight to attach to the SWR of the antenna when using the '-W' option, which calculates a fitness for the antenna based on one or more parameters (FB, gain, input resistance, input reactance, SWR, cleanliness of antenna pattern). The '-S' option is similar to the options -F, -G, -P, -R, -X (which specify weights for FB, gain, pattern cleanliness, input resistance and input reactance). When using the -W option the exact algorithm used to compute the fitness (and hence the effect of this parameter) is best checked by looking at the source code (see perform.c). This is one area of constant program improvement/changes/development, so its difficult to say exactly the effect the parameter has. However, increasing the weight of a parameter (using the -F, -G, -R, -S or -X options) will make  the associated parameter have a greater effect on the fitness. However, unless you optimise for SWR with the -W option, then setting the -S option will have no effect. For example, setting the options -S2.5 -W1 is a complete waste of time. There you have used the -W1 option to optimise only for gain (see -W option section of man page) but have changed the weight of the SWR from its default 1.0 to 2.5. If you are not optimising for SWR, the weight you attach to it is irrelavent.</p>
  </dd>
  <dt>
    <p><strong>-T</strong><em>position_tolerance</em></p>
  </dt>
  <dd>
    <p><em>position_tolerance</em> is the standard deviation in mm of the accuracy with which you can cut elements. Since 99.7% of elements will be with 3 standard deviations of the correct position (stats theory says this), set -T2 if virtually all (well 99.7%) of elements are within 3x2=6 mm of the correct position.This option *must* be used with the '-t'  option and can't be used with any other options apart from '-Z', '-v' and '-d'.</p>
  </dd>
  <dt>
    <p><strong>-W</strong><em>Weighted_algorithm</em></p>
  </dt>
  <dd>
    <p>Try to get an antenna which is better according to a weighted combination of parameters, rather than require them all to improve. The integer specifies what to consider in the weighted parameters.</p><p>W1 Gain.</p><p>W2 FB</p><p>W4 R</p><p>W8 X</p><p>W16 SWR</p><p>W32 SIDE_LOBE</p><p>You can logically AND these together, so for example -W3 will optimise using a weighted combination of gain and FB. -W49, will use a weighted combination of gain, swr and sidelobe leve, since 32+16+1=49.</p>
  </dd>
  <dt>
    <p><strong>-X</strong><em>weight_reactance</em></p>
  </dt>
  <dd>
    <p>is the floating point number (default 1.0) specifying the weight to attach to achieving a low input reactance on the antenna when using the '-W' option, which calculates a fitness for the antenna based on one or more parameters (FB, gain, input resistance, input reactance, SWR, cleanliness of antenna pattern). The '-X' option is similar to the options -F, G, -P, -R and -S (which specify weights for FB ratio, gain, pattern cleanliness, input resistance, and SWR). When using the -W option the exact algorithm used to compute the fitness (and hence the effect of this parameter) is best checked by looking at the source code (see perform.c). This is one area of constant program improvement/changes/development, so its difficult to say exactly the effect the parameter has. However, increasing the weight of a parameter (using the -F, -G, -R, -S or -X options) will make  the associated parameter have a greater effect on the fitness. However, unless you optimise for a low input reactance with the -W option, then setting the -X option will have no effect. For example, setting the options -X2.5 -W1 is a complete waste of time. There you have used the -W1 option to optimise only for gain (see -W option section of man page) but have changed the weight of the reactiance from its default 1.0 to 2.5. If you are not optimising for a low input reactance, the weight you attach to it is irrelavent.</p>
  </dd>
  <dt>
    <p><strong>-Z</strong><em>Zo</em></p>
  </dt>
  <dd>
    <p><em>Zo</em> is the characteristic impedance used when evaluating the VSWR, reflection coefficient and other similar calculations. The optimiser usually tries to bring the input impedance of the antenna to this value. It is set by default to 50 Ohms, so the default is equivalent to <em>-Z50</em> but may be set to any positive number. Set to 12.5 Ohms if you are going to feed the antenna with a 4:1 balun. Generally speaking, the gain of a Yagi can be higher for low input impedances, but of course such antennas are more difficult to feed.</p>
  </dd>
  <dt>
    <p><em>filename</em></p>
  </dt>
  <dd>
    <p>This is the name of the file containing the antenna description. It is expected to be in a format created by either <em>input</em> or <em>first</em> - two other programs in the <em>Yagi-Uda project.</em> This is an ASCII text file.</p>
  </dd>
  <dt>
    <p><em>iterations</em></p>
  </dt>
  <dd>
    <p>is an integer specifying the number of iterations for the optimiser to perform to try to get the best antenna. Time will limit the number you choose. 1000 iterations of a 1ele yagi takes about 5 seconds, a 6ele approximately 60 seconds, an 11 element 350 seconds, a 20 element 1030 seconds, a 33ele 2440 seconds, a 50element 5400 seconds, 100ele 21320 seconds all on an old 25MHz 486 PC with no external cache. When using the <em>-A</em> option the <em>iterations</em> is automatically set internally so only one attempt is made. When using the '-t' and '-T' options, <em>iterations</em> specifies the number of iterations to attempt to get a poorer design, to check the sensitivity of the design to small manufacturing tolerances.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>Here are a number of examples of using <em>optimise.</em></p><p>1) optimise 5ele 1000</p><p>Here the file 5ele will be optimised using the default system for 1000 iterations. The default might typically require gain, FB and SWR to all improve, but this may be changed at any time. In any case, the program tells you what its optimising for. By default the program will only optimise to the selected parameters are good, not over-optimising any one at the detrement of the others.</p><p>2) optimise -b30 -f50 -s2 5ele 1000</p><p>This is similar to above, but the boom can not extend by more than 30% from its  original length, FB ratios above 50 dB are considered acceptable, as are SWR's less than 2:1. The optimised resultant antenna is likely to have better FB ratio, but poorer SWR than in (1) above.</p><p>3) optimise -o1 5ele 1000</p><p>This will simply optimise 5ele for maximum forward gain. The resultant antenna may have a poor FB ratio and is likely to have an unacceptably low input impedance and hence high VSWR. This is not a very sensible method of optimisation.</p><p>4) optimise -W49 -l7 5ele 10000</p><p>This will optimise the file 5ele using for 10000 iterations. It will require that the weighted performance of the antenna in three important parameters (gain, sidelobe level and SWR) improves from one design to the next. One or two parameters can actually get worst from one design to the next, but the weighted performance is better. The positions of the elements or lengths of elements will not change by more than 7% in each iteration.</p><p>5) optimise -g -S30 -G50 -F20 -p1500 5ele 10000</p><p>This will optimise the file 5ele using a genetic algorithm. 1500 antennas will be randomly designed. The performance of each of these will measured using a 'fitness' function, weighted 30% to SWR, 50% to gain and 20% to FB ratio. The probability of breading from a pair of antennas is proportional to the fitness function.</p><p>6) optimise -w atv_antenna 10000</p><p>This will optimise the file atv_antenna for a best average performance over a wide band. The progrram calculates the gain, FB and SWR at three frequencies, then computes an average (mean) performance of the antenna over the band. N iterations will take 3x as long to execute as N iterations on the same antenna without the '-w' option.</p><p>7) optimise -t0.1 -T1  good_design 100</p><p>This will take the file good_design and make 100 different antennas from it, to simulate the effects of building tolerances. Each element is assumed to be cut so that the mean error of all elements is 0 mm, but a standard deviation of 0.1 mm, so 68.4% of element lengths are within 0.1 mm, 95.4% within 0.2 mm and 99.7% with in 0.3 mm. The accuracy of placing elements along the boom is much lower, so here we have specified a standard deviation of 1.0 mm, so 68.6% of elements are placed within 1 mm of the correct position, 95.4% within 2 mm of the correct position etc.  The program will report the *worst* performances achieved. If the performance dips too mush, then you either need to build them better, or get a design that's less critical!</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">STOPPING</h2>
        <div class="sectioncontent">
<p><em>Optimise</em> will stop after the number of iterations specified in the parameter <em>iterations.</em> It will also stop if a file <em>stop</em> exits in the current directory of the executable <em>optimise</em> This file can of course only be created using a multi-tasking operating system such as Unix. It is *not* advisable to stop the program by hitting the DEL key (Unix) or CONTROL-C (DOS), as one of the files may be open at the time, resulting in an empty file. Files are not open for any longer than necessary (they are closed immediately after writing to them), so this is not a likely occurrence, but can still occur.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LIMITATIONS</h2>
        <div class="sectioncontent">
<p>I'm not aware of any limitations, apart from that filenames, including full path, can't exceed 90 characters.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILES</h2>
        <div class="sectioncontent">

<pre>
filename           Antenna description, created by input or first.
filename.up    Update file, listing achievements of optimise.
filename.bes       Best file, containing the best design to date.
changes         File that causes the program to pause to re-adjust weights.
stop            File that stops optimisation process.

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO optimise&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man1/first.1.html"><strong>first</strong>(1)</a>, <a href="../man1/input.1.html"><strong>input</strong>(1)</a>, <a href="../man1/output.1.html"><strong>output</strong>(1)</a>, <a href="../man1/yagi.1.html"><strong>yagi</strong>(1)</a>, <a href="../man5/first.5.html"><strong>first</strong>(5)</a>, <a href="../man5/input.5.html"><strong>input</strong>(5)</a> <a href="../man5/output.5.html"><strong>output</strong>(5)</a> and <a href="../man5/optimise.5.html"><strong>optimise</strong>(5)</a>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PLATFORMS</h2>
        <div class="sectioncontent">
<p>Both DOS and Unix versions have been built. The DOS version as distributed requires a 386 PC with a 387 maths coprocessor.</p><p>Although I have altered the source to make it more compatible with DOS (reduced file name lengths etc), my wish is to build a decent program, rather than fit the program to an outdated operating system. If there is a *good* reason to use code that is incompatible with DOS, this will be done.</p><p>Since <em>optimise</em> takes  a while to optimise an antenna (I've optimised one design for a week), it is obviously more sensible to build this program under a multi-tasking operating system, as otherwise a PC can be tied up for days.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>Bugs should be reported to <strong>david.kirkby@onetel.net</strong>. Bugs tend actually to be fixed if they can be isolated, so it is in your interest to report them in such a way that they can be easily reproduced.</p><p>The program will dump core (crash) if asked to optimise a 1ele beam, without any arguments. This is because a 1ele beam has no parasitic elements and by default the program only changes parasitic elements.</p><p>Some of the options are not checked for sensible values, although most are now checked and report if they are out of range.</p><p>If the user specifies very large manufacturing errors using the '-t' and '-T' options, its possible for elements to overlap or for element lengths to become negative. This will cause numerical errors. Any reasonable values will not cause this.</p><p>On long Yagi's (50 elements) optimise can go a bit silly. It can optimise say a 1296MHz Yagi to get 20 dB at 1296 MHz, but less than 0 dB at only 1 MHz away. Needs some thought!</p><p>The level of the sidelobes is not computed with the GA or some other optimisation types. This will be corrected later.</p><p>All those I don't know about.</p>
<pre>

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p>Dr. David Kirkby G8WRB (david.kirkby@onetel.net). with help with converting to DOS from Dr. Joe Mack NA3T (mack@fcrfv2.ncifcrf.gov)</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="opticalraytracer.1.html"><span aria-hidden="true">&larr;</span> opticalraytracer.1: A virtual lens design workshop</a></li>
   <li class="next"><a href="optimize2bw.1.html">optimize2bw.1: Automatic thresholder of the exactimage toolkit <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

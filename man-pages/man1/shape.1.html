<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>shape: Identify and build program configurations from versions of source objects</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Identify and build program configurations from versions of source objects">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="shape (1) manual">
  <meta name="twitter:description" content="Identify and build program configurations from versions of source objects">
  <meta name="twitter:image" content="https://www.carta.tech/images/shapetools-shape-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/shape.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="shape (1) manual" />
  <meta property="og:description" content="Identify and build program configurations from versions of source objects" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/shapetools-shape-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">shape<small> (1)</small></h1>
        <p class="lead">Identify and build program configurations from versions of source objects</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/shape.1.html">
      <span itemprop="name">shape: Identify and build program configurations from versions of source objects</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/shapetools/">
      <span itemprop="name">shapetools</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/shape.1.html">
      <span itemprop="name">shape: Identify and build program configurations from versions of source objects</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <strong>shape</strong>
  </dt>
  <dd>
    <p>[&nbsp;<strong>-f </strong><em>&lt;description file&gt;</em>&nbsp;]</p><p>[&nbsp;<strong>-R </strong><em>&lt;version selection rule&gt;</em>&nbsp;] [&nbsp;<strong>-V&nbsp;</strong><em>&lt;variant name&gt;</em>&nbsp;]</p><p>[&nbsp;<strong>-echo&nbsp;</strong><em>&lt;macro name&gt;</em>&nbsp;] [&nbsp;<strong>-force&nbsp;</strong><em>&lt;target&gt;</em>&nbsp;] [&nbsp;<strong>-rebuild </strong><em>&lt;target&gt;</em>&nbsp;]</p><p>[&nbsp;<strong>- dDehiknprs</strong>&nbsp;]</p><p>[&nbsp;<strong>-bct</strong>&nbsp;] [&nbsp;<strong>-help</strong>&nbsp;] [&nbsp;<strong>-nomsg</strong>&nbsp;] [&nbsp;<strong>-novclass</strong>&nbsp;] [&nbsp;<strong>-version</strong>&nbsp;] [&nbsp;<strong>-xpoff</strong>&nbsp;] [&nbsp;<strong>-xpon</strong>&nbsp;]</p><p>[&nbsp;<em>target1&nbsp;target2 ...</em>&nbsp;] [&nbsp;<em>macro=value ...</em>&nbsp;] [&nbsp;<em>macro+=value ...</em>&nbsp;]</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Shape allows to transparently compile source objects that are either regular files, or source object <em>versions</em> in the ShapeTools version object base. More generally, shape produces a set of <em>derived objects</em> (``targets'') from appropriately selected versions of corresponding source objects according to a description of the dependencies between the objects. Shape keeps track of the relevant parameters for compilations (source versions, compiler versions, compiler switches etc.) and thus provides a safe and efficient build machinery.</p><p>When shape compiles source objects, it stores the resulting derived objects together with the effective compile parameters in its <em>derived object cache</em>. Before the derivation process for a requested object is actually started, shape attempts to find an existing derived object that matches the requirements for the target, in the derived object cache.  Caching and restoring of objects that are derived from immutable versions allows developers to profit from previous builds by other team members. Overall compile costs in projects are substantially reduced.</p><p>When serving a build request, shape considers a possibly large number of versions that are stored for an object. Which particular version is <em>bound</em> to an object's name in the description file, is determined by <em>version selection rules</em>.</p><p>Shape can manage builds of different variants of a system in parallel. Shape uses the combined potential of dynamic version selection, dynamic macro redefinition, and derived object management to handle variant builds. As most - if not all - of the objects and parameters involved in a build are defined as <em>macros</em>, shape provides a great deal of flexibility by allowing to alter some or all of the macros dynamically, depending on which variant shall be built. The concept of <em>variant definition</em> in shape's description file offers a clear focal point for all definitions that are relevant for a certain variant.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <strong>-f&nbsp;</strong><em>&lt;description file&gt;</em>
  </dt>
  <dd>
    <p><em>shape</em> uses the supplied argument as name of the description file to be used for the build. If no <strong>-f</strong> option is specified, shape tries to find a description file under one of the names ``Shapefile'', ``shapefile'', ``Makefile'', and ``makefile'' (from left to right). If no regular file with one of these names can be found, but versions of respective files are available in the version object base, shape will use the most recent version.  When more than one <strong>-f</strong> <em>&lt;description file&gt;</em> argument pair appears, shape reads each description file in turn.  If the name of the description file is specified as ``-'', shape will read the system description from standard input. It is possible to specify the description file in bound version notation, e.g. <em>Shapefile[2.8]</em> or <em>Shapefile[Release4]</em> (see <a href="../man1/vbind.1.html"><strong>vbind</strong>(1)</a></strong> for details about bound version notation).</p>
  </dd>
  <dt>
    <strong>-R</strong><em> &lt;selection rule name&gt;</em>
  </dt>
  <dd>
    <p>activates the specified selection rule as initial version binding for source objects. If the <strong>-R</strong> option is present, and a selection rule is defined as the first dependency of the first target, shape will use the selection rule passed via the command line, and ignore the first (and only the first) selection rule activation within the description file. The option is useful to override initial default selection rules, specified within the description file, from the command line.</p>
  </dd>
  <dt>
    <strong>-V</strong><em> &lt;variant name&gt;</em>
  </dt>
  <dd>
    <p>activates the variant specified by <em>&lt;variant name&gt;</em>. Several variants can be activated simultaneously from the command line by specifying the <strong>-V</strong> option multiple times. All variant specific definitions will be in effect as soon as shape reads the corresponding variant definition in the description file.</p>
  </dd>
  <dt>
    <strong>-force </strong><em>&lt;target&gt;</em>
  </dt>
  <dd>
    <p>forces shape to build the specified target unconditionally, i.e. even if a suitable, previously build object exists.</p>
  </dd>
  <dt>
    <strong>-echo </strong><em>&lt;macro name&gt;</em>
  </dt>
  <dd>
    <p>the value of the macro <em>&lt;macro name&gt;</em> is written to standard output. This option is useful to extract information from the system description file (e.g. shape -echo SOURCES, or shape -echo SUBSYSTEMS), or to control the effect of variant activations.</p>
  </dd>
  <dt>
    <strong>-rebuild </strong><em>&lt;target&gt;</em>
  </dt>
  <dd>
    <p>attempt a precise rebuild of <em>target</em> according to a <em>bound configuration</em> thread, supplied in a file named <em>&lt;target&gt;.bct</em> (see description of <strong>-bct</strong> switch).</p>
  </dd>
  <dt>
    <strong>-d</strong>
  </dt>
  <dd>
    <p>run shape in debug mode. Print out detailed information about object dependencies and attributes.</p>
  </dd>
  <dt>
    <strong>-D</strong>
  </dt>
  <dd>
    <p>print detailed information about the version binding process, and shape's reasoning regarding (re)builds of targets, or retrievals from the derived object cache.  This switch is useful to find out about the exact reasons, why shape rederives a target (or not).</p>
  </dd>
  <dt>
    <strong>-e</strong>
  </dt>
  <dd>
    <p>macro definitions that are imported from the environment (see description of special macro <em>IMPORT</em>, below) override macro definitions in the description file (by default, macro definitions in the description file have precedence over imports from the environment).</p>
  </dd>
  <dt>
    <strong>-h</strong>
  </dt>
  <dd>
    <p>print usage information on standard output (this is an abbreviation for the <strong>-help</strong> switch, see below).</p>
  </dd>
  <dt>
    <strong>-i</strong>
  </dt>
  <dd>
    <p>ignore error codes returned by commands.</p>
  </dd>
  <dt>
    <strong>-k</strong>
  </dt>
  <dd>
    <p>when a nonzero error status is returned by an invoked command, the work on the current target is abandoned but shape continues with other branches that do not depend on the failed target.</p>
  </dd>
  <dt>
    <strong>-n</strong>
  </dt>
  <dd>
    <p>no execution mode. Shape prints out commands, but does not execute them. Even command lines beginning with @ are printed. If a command contains the $(MAKE) macro reference, however, that line is always executed in order to allow tracing of recursive build processes.</p>
  </dd>
  <dt>
    <strong>-p</strong>
  </dt>
  <dd>
    <p>print out the complete set of macro definitions, target descriptions, and rule definitions, respectively.</p>
  </dd>
  <dt>
    <strong>-r</strong>
  </dt>
  <dd>
    <p>do not use shape's built-in implicit rules. Implicit rules defined in the description file remain in effect.</p>
  </dd>
  <dt>
    <strong>-s</strong>
  </dt>
  <dd>
    <p>run in silent mode. Shape does not print out the commands before executing them.</p>
  </dd>
  <dt>
    <strong>-bct</strong>
  </dt>
  <dd>
    <p>record the build in a <em>bound configuration thread</em> file. A shape configuration thread contains precise definitions of all source versions, their dependencies, the involved tools, and related options that were in effect for a build. The configuration thread for a produced toplevel target (the first target in the description file, or a target requested from the command line) is stored in a file named <em>&lt;target&gt;.bct</em>. Bound configuration threads can be used as input for rebuilds (see option <strong>-rebuild</strong>, above). If the source version context of a bct-build is unsafe, shape will record that fact in the bct, and issue a warning message.</p>
  </dd>
  <dt>
    <strong>-help</strong>
  </dt>
  <dd>
    <p>print usage information on standard output.</p>
  </dd>
  <dt>
    <strong>-nomsg</strong>
  </dt>
  <dd>
    <p>turn off the trace facility <em>msg</em> in version selection rules.</p>
  </dd>
  <dt>
    <strong>-novclass</strong>
  </dt>
  <dd>
    <p>disable checking for incompatibility of activated variants.</p>
  </dd>
  <dt>
    <strong>-version</strong>
  </dt>
  <dd>
    <p>print the version identification of the shape program.</p>
  </dd>
  <dt>
    <strong>-xpoff</strong>
  </dt>
  <dd>
    <p>turn off attribute expansion in source versions retrieved from the object base. By default, attribute expansion is turned on for all source objects that are directly retrieved from the object base, and turned off for source objects that are regular files (see <a href="../man1/retrv.1.html"><strong>retrv</strong>(1)</a></strong> for details about attribute expansion).</p>
  </dd>
  <dt>
    <strong>-xpon</strong>
  </dt>
  <dd>
    <p>turn on attribute expansion for all source objects, even in regular files. By default, attribute expansion is turned off for source objects that are regular files, and turned on for all source objects that are directly retrieved from the object base.</p>
  </dd>
  <dt>
    <em>target</em>
  </dt>
  <dd>
    <p>A list of target names can be passed to shape via the command line. If no target is given on the command line, and the special target .DEFAULT is not defined within the description file, shape tries to produce the first target defined in the description file.</p>
  </dd>
  <dt>
    <em>&lt;macro definition&gt;</em>
  </dt>
  <dd>
    <p>It is possible to define or modify macros in the description file from the command line.  Macros that are defined this way take precedence over all other definitions. Command line macro definitions have either of two forms:</p>
  </dd>

</dl>

<pre>
	<em>NAME=VALUE</em>
and
	<em>NAME+=VALUE</em>
</pre>
<p>with <em>NAME</em> being a word and <em>VALUE</em> an arbitrary string. If <em>VALUE</em> contains white space, make sure to quote it.  The first form of command line macro definitions sets <em>NAME</em> to the substitution <em>VALUE</em>. If <em>VALUE</em> is empty, the macro is reset.  The second form appends <em>VALUE</em> with a leading space character to the <em>current substitution</em> of <em>NAME</em>. The current substitution may be defined in the description file, or by a previous setting on the command line. For details about the semantics of macro definitions and substitutions, see the respective sections below.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION FILES</h2>
        <div class="sectioncontent">
<p>The operation of shape is controlled by a system description file (usually a <em>Makefile</em>) that provides structural information about the system to be managed. Other than <a href="../man1/make.1.html"><strong>make</strong>(1)</a></strong>, shape works on top of <em>AtFS</em> (<em>At</em>tributed <em>F</em>ile <em>S</em>ystem), a repository of versioned objects, rather than plain files. Thus, genuine shape description files (usually called <em>Shapefile</em>) feature version selection rules, and variant definitions in addition to standard Makefile dependency rules.  Shape's description file is an upward compatible extension of <a href="../man1/make.1.html"><strong>make</strong>(1)</a>'s description file, the Makefile.  A useful structuring convention for shape description files is to maintain a Makefile, and a Shapefile in parallel. Only genuine shape constructs (such as version selection rules, or variant definitions) are kept in <em>Shapefile</em>, while the bulk of target rule- and macro definitions is kept in <em>Makefile</em>. The Makefile shall be <em>included</em> in <em>Shapefile</em> (see description of <em>include</em> directive, below).  This structuring convention has the advantage that programs that were developed with the support of the ShapeTools system can be shipped as source distribution to sites that don't use ShapeTools.</p><p>Although shape is largely downward compatible with the original make program, it should be noted that several popular extensions of the original make program, such as GNU Make or Sun Make, provide features <em>not</em> present in shape.  See the section on known incompatibilities below.</p><p>The description file provides an ideal central information base for all sorts of product related definitions.  Shape encourages the development of a set of (project- or organization-specific) conventions for system description, and provides a simple way to extract this information for use by other tools (see <strong>-echo</strong> option, above). The description file syntax not only serves to specify component dependencies that are relevant for build processes, but allows a general, hierarchical definition of product oriented tasks. The concept of recursive dependencies maps directly to a stepwise refinement of task definitions. Such tasks can be fully, partly, or not at all automated as appropriate. Thus, certain activities may be automated and standardized, while other activities are just informally described in order to document them or to reason about them (see <strong>shape_rms</strong>(1)</strong> for examples).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">\fBSyntactical Structure\fP</h2>
        <div class="sectioncontent">
<p>The basic syntactical structure of shape's description file is made up of:</p>
<dl class='dl-vertical'>
  <dt>
    <em>Comments</em>
  </dt>
  <dd>
    <p>Comments begin with a ``#'' character and extend to the end of the line. In Shapefiles, the end of a line is defined as an unescaped newline (``&#92;<em>&lt;newline&gt;</em>''), or the end of the file. The comment character can't be escaped, but can be quoted in single- or double quotes. Comment characters in command lines of target rules are ignored by shape.</p>
  </dd>
  <dt>
    <em>Directives</em>
  </dt>
  <dd>
    <p>Directives are special keywords, known to shape. Directives begin at column 0 of a line and extend to the line end. Currently, the only directive recognized by shape is</p>
  </dd>

</dl>

<pre>
	include<em> &lt;list of file names&gt;</em>
</pre>

<dl class='dl-vertical'>
  <dt>
    <em>Macro Definitions</em>
  </dt>
  <dd>
    <p>Macro definitions have the general form:</p>
  </dd>

</dl>

<pre>
	<em>NAME &lt;macro definition symbol&gt; VALUE</em>
</pre>
<p><em>NAME</em> must be a single word consisting of a sequence of name characters. Name characters are all printable characters except the following:</p><p>$ # : = ; <em>&lt;space&gt;</em> &#92;t &#92;n</p><p>The macro definition symbol is either of ``='', ``+='', or ``:=''. <em>VALUE</em> is an arbitrary string terminated by the end of the line, or a comment. Macro definitions usually begin in the first column of a line, but may be preceded by leading <em>&lt;space&gt;</em> characters. Macro definitions must not contain leading <em>&lt;tab&gt;</em> characters (see section on <em>Macro Definitions</em>, below, for more details).</p>
<dl class='dl-vertical'>
  <dt>
    <em>Macro References</em>
  </dt>
  <dd>
    <p>Macro references have one of the following forms:</p>
  </dd>

</dl>

<pre>
	$(<em>&lt;macro name&gt;</em>)
	${&lt;macro name&gt;}
	$&lt;single character name&gt;
</pre>
<p>The macro substitution operator (``$'') can't be escaped, but can be represented by the substitution ``$$''. Macro substitution occurs anywhere in the description file, except in comments, macro names, left hand sides of version selection rule- and variant definition headers (see next section), and variant class definitions (see section on <em>Macro Substitutions</em>, below, for more details).</p>
<dl class='dl-vertical'>
  <dt>
    <em>Rules</em>
  </dt>
  <dd>
    <p>Rules are made up from a <em>rule header</em>, and an optional <em>rule</em> body. The rule header consists of a <em>left hand side</em>, a <em>rule</em> definition symbol, and an optional <em>right hand side</em>. The left hand side usually begins in column 0 of a line, and may be preceded by leading <em>&lt;space&gt;</em> characters. Left hand sides of rule headers must not contain leading <em>&lt;tab&gt;</em> characters. The optional right hand side of a rule header extends to the end of the line, or the beginning of the rule body. A rule body consists of consecutive lines beginning with a <em>&lt;tab&gt;</em> character. The body of a rule is terminated by the next line not beginning with a <em>&lt;tab&gt;</em> character, or the end of the file.</p><p>Shape recognizes three different kinds of rules, distinguished by their respective rule definition symbols:</p><ul>
<li><p><strong>target rules</strong>. Target rules have a single colon character (``:'') as rule definition symbol. The left hand side of target rule headers is a space-separated list of names. The optional right hand side consists of a space-separated list of names, followed by an optional list of production ingredients (see section on <em>Target Rules</em>, below).</p></li><li><p><strong>version selection rules</strong>. Version selection rules have the rule definition symbol ``:-''. The rule header of version selection rules has a single word on its left hand side, and no right hand side (see section on <em>Version Selection Rules</em>, below).</p></li><li><p><strong>variant definitions</strong>. Although variant definitions are - as the name suggests - <em>definitions</em>, not rules (from a semantical view point), their syntactical representation is that of a rule. Variant definitions have the rule definition symbol ``:+''. The rule header of a variant definition has a single word on its left hand side, and no right hand side (see section on <em>Variant</em> Definitions, below).</p></li>
</ul>
  </dd>
  <dt>
    <em>Variant Class Definitions</em>
  </dt>
  <dd>
    <p>Variant class definitions have the form</p>
  </dd>

</dl>
<p>vclass <em>&lt;name&gt;</em> ::= (<em>variant1, variant2, ...</em>)</p><p>(see section on <em>Variants</em>, below).</p>
<dl class='dl-vertical'>
  <dt>
    <em>Line Continuations</em>
  </dt>
  <dd>
    <p>If the end of an input line is escaped by a backslash (``&#92;'') the next line is considered as a continuation line. The backslash newline character sequence is replaced by a space.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">\fBMacro Definitions\fP</h2>
        <div class="sectioncontent">
<p>Macro definitions associate names with strings that will be substituted wherever the name of the macro is referenced (see next section). Macros are useful for writing maintainable, and somewhat generic description files. Even moderately large projects will find it extremely rewarding to define conventions for naming and usage of certain macros throughout the product description file.</p><p>There are three different kinds of macro definitions:</p><p><em>Simple Macro Definitions</em></p><p>A simple macro definition looks like</p>
<pre>
	<em>NAME =</em> &lt;any string&gt;
</pre>
<p>The string that is associated with the macro name can contain macro references. If a macro is defined multiple times within a description file, the last definition will be effective. Macros defined on the command line take precedence over definitions of the same macro in the description file.</p><p><em>Additive Macro Definitions</em></p><p>This type of macro definition looks like</p>
<pre>
	<em>NAME +=</em> &lt;any string&gt;
</pre>
<p>The string on the right hand side of the definition is appended to any existing value associated with <em>NAME</em>, separated by a space character. Multiple additive macro definitions are concatenated in the order in which they appear in the description file. If an additive macro definition occurs on the command line, the last string value defined in the description file is prepended to the string value defined on the command line. Additive macro definitions in the description file are appended to string values defined on the command line.</p><p><em>Evaluative Macro Definitions</em></p><p>Evaluative macros are defined in the following way:</p>
<pre>
	<em>NAME :=</em> &lt;any string&gt;
</pre>
<p>First, the string value is associated to <em>NAME</em> in the same way as for simple macro definitions. When <em>NAME</em> is substituted for the first time, the right hand side of the definition is evaluated, and the result of this evaluation replaces the original string value associated with <em>NAME</em>. Thus, evaluation of the right hand side occurs exactly once. This is particularly useful if the defining string is a command substitution (see next section).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">\fBMacro Substitutions\fP</h2>
        <div class="sectioncontent">
<p>Macro substitution is the process of substituting a <em>macro</em> reference by the string value associated with a macro name. References to undefined macros are substituted by an empty string. Macro references have either of the forms:</p>
<pre>
	$(<em>NAME</em>)
	${<em>NAME</em>}
	$<em>&lt;any single character&gt;</em>
</pre>
<p>The following are valid macro references:</p>
<pre>
	$(CFLAGS)
	$7
	${SOURCE-FILES}
	$(X)
	$X
</pre>
<p>The last two references have identical substitutions. The macro reference</p>
<pre>
	$$
</pre>
<p>will substitute a single dollar sign.</p><p>Before a macro reference is substituted, the associated string will be evaluated. Evaluation of a string value includes</p><ul>
<li><p>substitution of all macro references in the string value</p></li><li><p>command substitution. Any substring of the string value enclosed in backquotes (```'') will be passed as command to the shell, and be replaced by the command's standard output.</p></li><li><p>string substitution. If a macro reference has the form</p></li>
</ul>
<pre>
	$(<em>NAME</em>:<em>&lt;old&gt;</em>=<em>&lt;new&gt;</em>)
</pre>
<p>the reference will be substituted by the evaluated value of <em>NAME</em>, with all occurrences of the string <em>&lt;old&gt;</em> replaced by the string <em>&lt;new&gt;</em>. This is particularly useful to maintain related lists, such as <em>CSOURCES</em> and <em>OBJECTS</em> for example, automatically:</p>
<pre>
	CSOURCES := `echo *.c`
	OBJECTS := $(CSOURCES:.c=.o)
</pre>
<p>Shape substitutes macro references as late as possible. Macro references occurring in a macro definition are only substituted when the defined macro itself is substituted. Macro references on the dependencies side of target rules are substituted when the rule is evaluated. Macro references on the target side of target rules are substituted immediately after shape has read the description file, i.e. before any production is started. Macro references in include directives are substituted when the directive is executed while shape reads the description file.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">\fBBuilt-in and Special Purpose Macros\fP</h2>
        <div class="sectioncontent">
<p>In order to provide parametrization of shape's built-in implicit rules, a number of predefined macros is supplied by convention. These macros have meaningful initial values that can be altered by the user. There are also several macros that have special meaning for shape.</p>
<pre>
<strong>Macro	Purpose	Initial value	Remark</strong>

@	full name of the current	<em>&lt;dynamic&gt;</em>	special
	target

?	list of target dependencies	<em>&lt;dynamic&gt;</em>	special

&lt;	name of the first target	<em>&lt;dynamic&gt;</em>	special
	dependency

*	prefix shared by target	<em>&lt;dynamic&gt;</em>	special
	and the dependent filenames

#	bound version id of the current	<em>&lt;dynamic&gt;</em>	special
	dependency

$	the character ``$''	$	<em>&lt;special&gt;</em>

+	name of object to be bound	<em>&lt;dynamic&gt;</em>	special
	to a version (selection rules
	only!)

AS	Program for doing assembly	as	conventional

ASFLAGS	Flags for the assembler	<em>&lt;none&gt;</em>	conventional

CC	Program for compiling C	cc	conventional
	programs

CFLAGS	Flags for the C compiler	<em>&lt;none&gt;</em>	conventional

FC	Program for compiling Fortran	f77	conventional
	programs

FFLAGS	Flags for the Fortran compiler	<em>&lt;none&gt;</em>	conventional

HOSTTYPE	Host architecture of the	<em>&lt;none&gt;</em>	special
	computer that runs shape.
	The value of this macro is
	used by shape to construct
	the derivation key attribute
	for derived objects

IMPORT	List of environment variables	<em>&lt;none&gt;</em>	special
	that shall be imported as
	macro definitions

LD	Program to link programs	ld	conventional

LDFLAGS	Flags for the linker	<em>&lt;none&gt;</em>	conventional

LEX	Program to turn Lex grammars	lex	conventional
	into C or Ratfor programs

LFLAGS	Flags for the lexical analyzer	<em>&lt;none&gt;</em>	conventional
	lex

LOGNAME	The name or network-id under 	<em>&lt;dynamic&gt;</em>	special
	which the user who owns the
	shape process is logged on

M2C	Program for compiling Modula2	m2c	conventional
	programs

M2FLAGS	Flags for the Modula2 compiler	<em>&lt;none&gt;</em>	conventional

MAKE	The command line with which 	shape $(MAKEFLAGS)	special
	shape has been invoked.
	This macro is used for
	recursive calls to shape

MAKEFLAGS	Command line flags relevant	<em>&lt;defined from</em>	special
	for recursive calls to shape	<em>command line&gt;</em>

PC	Program for compiling Pascal	pc	conventional
	programs

PFLAGS	Flags for the Pascal compiler	<em>&lt;none&gt;</em>	conventional

RFLAGS	Flags for the Fortran compiler	<em>&lt;none&gt;</em>	conventional
	for Ratfor programs

SHAPEPID	The process id of the	<em>&lt;dynamic&gt;</em>	special
	running shape program

SHAPEVERSION	The version id of the	shape_CM-4.4	special
	shape program	(or above)

SHELL	The command processor for	/bin/sh	special
	the target rule command
	lines. The referenced command
	processor must be able to
	take its commands  from
	standard input (see section
	on <em>Command execution</em>,
	below)

VPATH	Search path extension for	<em>&lt;none&gt;</em>	special
	localizing source components

YACC	Program to turn Yacc grammars	yacc	conventional
	into C programs

YFLAGS	Flags for yacc	<em>&lt;none&gt;</em>	conventional

vpath	Dynamic search path extension	<em>&lt;none&gt;</em>	special
	for variants of source components
</pre>
<p>The function of the special purpose macros <em>HOSTTYPE</em>, <em>IMPORT</em>, <em>MAKE</em>, <em>VPATH</em>, and <em>vpath</em> are described in the sections on OPERATION, and Variants below.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">\fBTarget Rules\fP</h2>
        <div class="sectioncontent">
<p>A target rule defines how, and under what conditions a target is derived from a set of source objects and/or other targets. A target is a name that can refer to a file but need not to do so. Target rules have the following format:</p>
<pre>
	<em>&lt;target&gt;... :</em> [&lt;version binding&gt;] [+<em>&lt;variant&gt;...] [&lt;dependency&gt;...] &#92;</em>
		[:<em> &lt;ingredient&gt;...] [;</em><em> &lt;command&gt;]</em>
		&#92;t<em>[&lt;command&gt;]</em>
		...
</pre>
<p>The header of a target rule (see <em>Syntactical Structure</em>, above) consists of a list of <strong>targets</strong>, terminated by a colon, followed by an optional list of <strong>dependencies</strong>, and an optional list of <strong>production ingredients</strong>, beginning after a second colon character. The rule header is terminated by a newline or a semicolon, and followed by the optional rule body. The rule body consists of <strong>command lines</strong> that are executed when a target needs to be rederived.  The first command line may immediately follow the semicolon that terminates the rule header. Subsequent command lines must begin with a <em>&lt;tab&gt;</em> character. The target rule body is terminated by the first line that doesn't begin with a <em>&lt;tab&gt;</em>, or by the end of the file.</p><p><em>Targets</em></p><p>When multiple targets appear on the left hand side of a rule header, and the derivation process needs to be started, shape will derive all of the targets in a single run.</p><p><em>Dependencies</em></p><p>Shape checks a target's dependencies from left to right. The first dependency is examined whether it is the name of a version selection rule. If it is, shape sets the selection rule active (eclipsing all previous selection rule activations), and proceeds to the next dependency. Next, shape checks whether the dependency is a variant activation. If the dependency starts with a ``+'' character followed by the name of a variant, the variant is activated (see the section on <em>Variants</em>, below). Shape proceeds to check for variant activations until the first dependency that isn't a variant activation is found. Next, shape proceeds through the list of remaining dependencies, and <em>binds</em> (or <em>derives</em>) each of them as necessary, performing a depth first traversal of the dependency graph (see the section on <em>OPERATION</em>, below).</p><p><em>Production Ingredients</em></p><p>After all dependencies have been bound, shape constructs the <em>derivation key</em> for the target. The derivation key is an attribute that defines the complete set of parameters that determine whether a target needs to be rebuild. Besides all bound dependencies, the derivation key contains the <em>production ingredients</em> that were specified in the target rule header. Production ingredients are typically complete definitions of the macros that are referenced in the command lines of the rule's body. Thus, tool versions and switches affecting the operation of a tool can be made part of the derivation parameters of a target. In order to include macro definitions into the derivation key of a target, the special reference</p>
<pre>
	<em>+(NAME1) +(NAME2) ...</em>
</pre>
<p>must occur in place of the production ingredients.</p><p><em>Command Lines</em></p><p>When shape concludes that a target needs to be (re-)derived, the commands in the target rule body are executed. The rule body consists of consecutive lines that are treated as separate commands. Each command line is evaluated as described in the section on <em>Macro</em> Substitution, above, and passed to the command interpreter defined by the macro <em>SHELL</em>. Each command line is executed as a separate process. If complex commands are needed that don't fit on a single line, or if the overhead of repeated process invocations shall be avoided, a logical command line can be extended by escaping the newline with a backslash character (&#92;<em>&lt;newline&gt;</em>), and continuing it on the next physical line.</p><p>Command lines may be preceded by one or two special characters:</p>
<dl class='dl-vertical'>
  <dt>
    -
  </dt>
  <dd>
    <p>shape ignores any nonzero error code returned by a command line for which the first character is a minus sign. The minus sign is not passed to the shell. When a command returns a nonzero return status, shape usually considers the derivation process for the target as failure and terminates, unless the <strong>-i</strong> or <strong>-k</strong> switches, or the <strong>.IGNORE</strong> special target is in effect.</p>
  </dd>
  <dt>
    @
  </dt>
  <dd>
    <p>If the first character of a command is a ``@'', shape does not print the command before executing it. The ``@'' is not passed to the shell.</p>
  </dd>
  <dt>
    \@-
  </dt>
  <dd>
    <p>If the first two non-<em>&lt;tab&gt;</em> characters are ``@-<em>'', shape</em> ignores nonzero return codes, and suppresses the printing of the command line.</p>
  </dd>

</dl>
<p>If shape is invoked in <em>no execution mode</em> (<strong>-n</strong>), the evaluated command lines are printed on standard output, showing what shape <em>would</em> do if invoked without <strong>-n</strong>. Command lines that contain the macro reference <em>$(MAKE)</em> are always executed, even if <strong>-n</strong> is set. This is done to allow simulation of recursive builds that may span over subdirectories. The reference <em>$(MAKE)</em> is substituted by a shape command invocation with all relevant command line switches set.</p><p>Within command lines of the rule body, some parts of the target rule header can be dynamically referenced. When a command line is evaluated, the following substitutions are possible</p>
<pre>
<strong>Reference	Substitution</strong>
$@	full name of the current target
$?	list of dependencies
$&lt;	name of the first dependency
$*	prefix shared by current and the dependent filenames
$#	bound version id of the current dependency
	(implicit rules only)
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">\fBImplicit Rules\fP</h2>
        <div class="sectioncontent">
<p>Shape's target rules come in two different flavors: explicit, and implicit. Implicit rules can be seen as templates that define dependency patterns which apply to most targets of a given kind. For this reason, implicit rules are sometimes called <em>pattern</em> rules. Shape converts make's old-style implicit rules (e.g. .c.o:) to pattern rules while it reads the description file. A typical dependency pattern is, for example, the dependency of files containing linkable object code, e.g. <em>module.o</em> to corresponding files containing source code, e.g. <em>module.c</em>. The derivation process for most of these source/derived pairs is identical. Rather than writing separate rules for all source/derived dependencies of a system, it is possible to write a single, generic rule, called implicit rule. An implicit rule has the following format:</p>
<pre>
	%<em>[.</em><em>&lt;suff1&gt;] %</em><em>[.</em><em>&lt;suff2&gt;] ... : %</em><em>[.</em><em>&lt;suff3&gt;] %</em><em>[.</em><em>&lt;suff4&gt;]... &#92;</em><em></em>
		[: &lt;ingredient&gt;...] [;<em> &lt;command&gt;]</em>
		&#92;t[&lt;command&gt;]
		&#92;t[&lt;command&gt;]
		...
</pre>
<p>While the structure of implicit rules is the same as described above, the names of targets and dependencies are replaced by target patterns, and dependency templates respectively.  The percent character in a target pattern acts as wildcard that is matched against all of a target's name up to the optional trailing suffix. For shape, an object name <em>suffix</em> is the sequence of characters enclosed by the last period character (``.'') within the name, and the <em>&lt;space&gt;</em> character terminating the name. The following example illustrates shape's concept of suffixes:</p>
<pre>
	<strong>Name	Suffix</strong>
	sample.cde	cde
	sample.x.y.c	c
	sample_c
	.sample.c	c
</pre>
<p>The following is an example for an implicit rule that derives linkable object code from corresponding C source files:</p>
<pre>
	%.o : %.c : +(CC) +(CFLAGS)
		&#92;t@echo shape - executing: $(CC) -c $(CFLAGS) $#;
		&#92;t@$(CC) $(CFLAGS) -E %.c |
			sed 's;^&#92;(# [0-9][0-9]* &#92;"&#92;)%.c&#92;(&#92;".*&#92;)$$;e\1$#&#92;2;' &gt; %.i;
		&#92;t@$(CC) -c $(CFLAGS) %.i;
		&#92;t@rm %.i;
</pre>
<p>NOTE: This rule is shape's built-in implicit rule to compile C source files. The cryptic command sequence has the purpose to encode the complete file version id into the object code (e.g. sample.c[3.4] rather than sample.c). This is extremely useful in conjunction with with the <strong>-g</strong> switch of most C compilers, and version sensitive debuggers, such as <strong>vgdb</strong>.</p><p>If a target is derived using implicit rules, the name of the target is matched against the target patterns of the implicit rules. If a rule matches, the matching portion of the target name (the <em>stem</em>, referred to by the ``%'') is consistently substituted for all other occurrences of the wildcard character throughout the rule. Once this is done, the implicit rule is treated like an explicit target rule.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">\fBExplicit Rules\fP</h2>
        <div class="sectioncontent">
<p>Explicit rules associate explicit target names with explicit dependencies.  Explicit rules are most typically used to specify dependencies that cannot be covered by implicit rules, such as deriving an executable program by linking many object code modules. In many cases, explicit rules are used to specify only those target dependencies that are not implied by an implicit rule (such as include dependencies for object files), while the ``natural'' dependencies are assumed as being present. If a description file contains only this sort of explicit dependencies, the omitted implicit dependencies (and an applicable rule body) are automatically added by shape to the total list of target dependencies.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">\fBBuilt-in Implicit Rules\fP</h2>
        <div class="sectioncontent">
<p>Shape provides a number of predefined implicit target rules that cover many common source/target derivations. The following table lists target patterns, and dependency templates for shape's built-in implicit rules.</p>
<pre>
<strong>Target	Dependency	Derivation</strong>
%.a	%.c	Compile archive library from C source
%.c	%.l	Generate C programs from Lex grammar
%.c	%.y	Generate C programs from Yacc grammar
%.o	%.l	Compile object code from Lex grammar
%.o	%.y	Compile object code from Yacc grammar
%.o	%.s	Translate assembler program to object code
%.o	%.r	Compile Ratfor source
%.o	%.F	Compile Fortran source
%.o	%.f	Compile Fortran source
%.sym	%.def	Compile Modula definition modules
%.o	%.mod	Compile Modula implementation modules
%.o	%.p	Compile Pascal source
%.o	%.c	Compile C source
%	%.sh	Make executable program from shell-script
%	%.r	Build executable program from Ratfor source
%	%.F	Build executable program from Fortran source
%	%.f	Build executable program from Fortran source
%	%.p	Build executable program from Pascal source
%	%.mod	Build executable program from Modula source
%	%.c	Build executable program from C source
</pre>
<p>For a complete definition of shape's built-in implicit rules, run shape -p.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">\fBSpecial Purpose Targets\fP</h2>
        <div class="sectioncontent">
<p>Several aspects of shape's operation are controlled by special purpose targets that can be put into the description file. Special purpose targets by convention begin with a period character, and have no associated commands.</p>
<pre>
<strong>Target	Purpose</strong>
</pre>

<dl class='dl-vertical'>
  <dt>
    .DEFAULT:
  </dt>
  <dd>
    <p>commands in the rule body of the <em>.DEFAULT</em> target rule are executed for all targets that cannot be derived by explicit or implicit target rules. If no commands at all shall be executed for a rule but <em>.DEFAULT</em> is needed for other targets, that rule can be given an empty command (either a ``;'' at the end of the rule header, or an empty line beginning with <em>&lt;tab&gt;</em>). If <em>.DEFAULT</em> has dependencies, and no targets are requested from the command line, these dependencies are treated as if they were targets requested from the command line.</p>
  </dd>
  <dt>
    .IGNORE:
  </dt>
  <dd>
    <p>causes shape to ignore non zero return codes of invoked commands. Equivalent to the <strong>-i</strong> switch</p>
  </dd>
  <dt>
    .SILENT:
  </dt>
  <dd>
    <p>silent command execution. The command lines are not printed before execution. Equivalent to the <strong>-s</strong> switch</p>
  </dd>
  <dt>
    .BPOOL:
  </dt>
  <dd>
    <p>only the dependencies associated with this target are stored in the derived object cache</p>
  </dd>
  <dt>
    .NOBPOOL:
  </dt>
  <dd>
    <p>dependencies associated with this target are <em>not</em> stored in the derived object cache.</p>
  </dd>

</dl>
<p>If both, <em>.BPOOL</em>, and <em>.NOBPOOL</em> are defined, only the difference set of both dependency lists will be stored in the derived object cache.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">\fBVersion Selection Rules\fP</h2>
        <div class="sectioncontent">
<p>When shape builds a target, it uses <em>version selection</em> rules to bind a unique version to each name of the prerequisite source objects. Version selection rules consist of a name, and an associated set of <em>predicate lists</em> in the rule body. The format of version selection rules is:</p>
<pre>
	<em>&lt;name&gt; [( </em><em>&lt;arg1&gt;, </em><em>&lt;arg2&gt;,</em><em>...)</em><em>] :-</em>
		&#92;t<em>[&lt;pattern1&gt;,</em>] &lt;pred1&gt; (...), <em>&lt;pred2&gt; (...);</em>
		&#92;t<em>[&lt;pattern2&gt;,</em>] &lt;pred1&gt; (...), <em>&lt;pred2&gt; (...);</em>
		...
		&#92;t.
</pre>
<p>The body of a version selection rule consists of a sequence of <em>alternatives</em>, separated by semicolons. Each of the alternatives is an optional pattern, followed by a comma-separated list of <em>predicates</em>. The selection rule is terminated by a period character. The semicolon-separated sequence of alternatives in a version selection rule constitutes a logical <em>OR</em> expression. The comma-separated list of predicates in an alternative constitutes a logical <em>AND</em> expression.</p><p><em>Version Binding</em></p><p>Version binding is the process of determining exactly one version of a given source object from the set of all available versions. Version binding is said to <em>succeed</em> if one of the rule alternatives succeeds. An alternative succeeds, if it leads to the identification of exactly one version. It is said to <em>fail</em> otherwise.  When shape binds a version to the name of a source object, it tries each alternative with a matching pattern, until the name is unambiguously bound to a version. If the pattern is omitted, the alternative will be tried unconditionally.</p><p>The functioning of version selection rules is one of shape's most important, yet most subtile aspects. In order to provide a basis for an intuitive understanding of the selection rule mechanism, an example is described. The rule <em>most_recent</em>, below, binds:</p><p>-&nbsp;files that were checked out for modification by the shape-invoking user</p><p>- versions of files that were recently modified (\(-&gt; status <em>saved</em>) by the same user</p><p>- the most recently proposed version (\(-&gt; status <em>proposed</em>) of files modified by other users,</p><p>- or the file version from the last release.</p>
<pre>
	LASTRELEASE := `lastrelease`			# "lastrelease" returns the name
				# of the last release
	most_recent :-
		eq (status, busy), exists ($+[locked_by($(LOGNAME)):]);
		ge (status, saved), max (mtime),
	  		max (version), eq (author, $(LOGNAME));
		ge (status, proposed), max (mtime),
	  		max (version);
		eq (__SymbolicName__, $(LASTRELEASE));
		cut ($_rule$: couldn't bind $+ as requested!).

	locked_by (user_id) :-
		max (version), eq (locker, $_user_id$).
</pre>
<p>For a more detailed description of version selection rule syntax, semantics, and the list of built-in predicates, see <a href="../man7/bindrules.7.html"><strong>BindRules</strong>(7)</a></strong>.</p><p><em>Activation of Version Selection Rules</em></p><p>A version selection for a certain target is invoked by specifying the name of the selection rule as first dependency of a target, or by supplying a selection rule name as argument to the <strong>-R</strong> option. If no selection rule is specified explicitly, shape uses its built-in version selection rule that tries to bind a regular file, or the most recent version to the name of an object.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">\fBVariants\fP</h2>
        <div class="sectioncontent">
<p>The term <em>variant</em> refers to the intention to manage a product that must comply with different sets of varying external constraints as a unit. Independently from particular semantics that might be associated with the variant notion, there exists a small number of techniques to implement software variation on a technical level. These techniques are:</p><p><em>physical separation</em> of variant components. This is achieved by maintaining separate copies of components in different directories, or by maintaining variant specific branches in version control systems;</p><p><em>source preprocessing</em> of variant components. With this technique, multiple logical variants of a source component are maintained in a single file that contains preprocessor instructions. Before a particular variant can be accessed, a preprocessor must extract it from the common source. A popular example of this technique is <em>conditional compilation</em>, controlled by the #if<em>, and</em> #ifdef instructions within the domain of C/C++ programming;</p><p><em>composition variation</em> of complex product variants. This technique addresses the case when different variants of a complex product (such as a program) are composed from different sets of components;</p><p><em>derivation variation</em> (or variation of the process) that produces different variants of derived objects from the same set of sources by modifying parameters of the derivation process. A typical example for this case is cross compilation of the same sources for different target platforms, or code instrumentation for various purposes, such as debugging, testing, profiling, or optimization.</p><p>Depending on the particular needs of a project, all of these techniques may be in simultaneous use, and can occur intermixed as appropriate. Shape allows to associate logical variant names with a set of definitions that control all of the above mentioned techniques, making it possible to request builds of particular system variants (and combinations of compatible variants) without the need to worry about how these variants are realized technically.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">\fBVariant Definitions\fP</h2>
        <div class="sectioncontent">
<p>Shape derives its flexibility from using <em>macro substitution</em> in the description file wherever possible. Shape variant definitions are basically groups of macro definitions that take effect when the variant is activated for a build. A variant definition has the following format:</p>
<pre>
	<em>&lt;variant-name&gt; :+</em>
		&#92;t<em>&lt;Macro name1&gt;=</em><em>&lt;Value&gt;</em>
		...
</pre>
<p>When a variant is activated, the macro definitions associated with the variant become effective. Any previous definition of a macro made in the description file, or on the command line is replaced by the variant macro substitution. If a macro is defined in several variants that are activated together, the respective values are concatenated.</p><p><em>Locating physically separate Variant Source Objects</em></p><p>Shape provides a special macro, <em>vpath</em>, that is intended to be used in variant definitions. The <em>vpath</em> macro defines shape's search precedence when source version archives are located. If <em>vpath</em> is non-empty, shape tries to find any referenced source object in the vpath directories first. If several activated variants define vpath, the variant search path is concatenated and searched from right to left, i.e.  the last variant that has been activated has precedence. Only if a referenced source component cannot be found in any of the vpath directories, the current directory is searched. If a source object has been found, it will be bound by the current version selection rule, and be temporarily installed in the build directory. This means that components which are maintained in a vpath subdirectory are temporarily moved up to the main directory. Thus, it is not necessary to make any reference to a vpath subdirectory path in the target rules.</p><p><em>Variant Activation</em></p><p>When a product is configured and built, variants are typically activated by supplying a variant name as argument to the <strong>-V</strong> options.</p><p>Variants can also be activated for a given target by specifying respective, ``+''-prefixed variant names as dependencies (see section on Target Rules, above). Variant activations for a target must occur before any real object dependency on the dependency line, and after the optional version selection rule activation.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">\fBVariant Class Definitions\fP</h2>
        <div class="sectioncontent">
<p>With <em>Variant class definitions</em>, shape offers a construct that allows to define <em>incompatible variants</em>, i.e. variants that cannot be activated simultaneously. Shape variant class definitions have the following format:</p>
<pre>
	vclass<em> &lt;variant-class-name&gt; </em> ::= ( <em>&lt;var1&gt;</em>, <em>&lt;var2&gt; ...)</em>
</pre>
<p>The same variant name can occur in multiple variant class definitions. If a combination of variants is requested with any two variant names that are member of the same variant class, shape will issue an error message, and terminate. Checking of variant classes can be disabled by specifying the <strong>-novclass</strong> switch on the command line.</p><p>NOTE: variant class definitions must occur in the description file <em>before</em> any variant definition referenced in a variant class. Variant classes that are defined after referenced variants cannot enforce mutual exclusion of incompatible variants.</p><p><em>An Example</em></p><p>The following example shall illustrate the use of variant definitions, and variant classes:</p>
<pre>
	vclass compiler ::= (gnu, prop)

	gnu:+
		CC = gcc -Wall
		OPTIMIZE = -O2 -inline-functions
		DEBUG = -g -g3
		PROFILE = -pg -a
		STDC = -ansi

	prop:+
		CC = cc
		OPTIMIZE = +O3
		DEBUG = -g -z +Y
		PROFILE = -G
		STDC = -Aa

	vclass quality ::= (debug, profile, optimize)

	debug:+
		VARCFLAGS = $(DEBUG)

	profile:+
		VARCFLAGS = $(PROFILE)

	optimize:+
		VARCFLAGS = $(OPTIMIZE)

	CFLAGS += $(VARCFLAGS)

</pre>
<p>If a variant requires the modification of macros with predefined meaning, it is sometimes a good idea <em>not</em> to redefine the macro itself in the variant section. In such a case it is possible to augment an existing macro value by using shape's additive macro definition facility, and a macro from the variant definition defined for this purpose (e.g. <em>VARCFLAGS</em> in the example above).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPERATION</h2>
        <div class="sectioncontent">
<p>When invoked, shape first parses the command line. Shape records the names of the variants to be activated from the command line via the <strong>-V</strong> option. Next, shape initializes the built-in, and special macros. Also, shape's built-in derivation rules are initialized.</p><p><em>Reading the Description File</em></p><p>After that, all macro definitions made on the command line are made effective. Shape then locates and opens its description file. If no description file is specified as argument to the <strong>-f</strong> option, shape tries to find one of the files <em>Shapefile</em>, <em>shapefile</em>, <em>Makefile</em>, or <em>makefile</em>. For each of these names, shape tries to find a regular file first, and, if no such file exists, to find the most recent version of that file in a version control archive. If no such version can be found, shape tries the next name.</p><p>When shape reads the description file, it collects all macro definitions, and makes them immediately effective, unless a macro of the same name has been defined on the command line. If the special macro <em>IMPORT</em> is encountered, the listed environment variables are defined as macros. If macros with the same name as an imported environment variable occurs in the description file, it has precedence over the definition from the environment, unless the <strong>-e</strong> switch is in effect.</p><p>When shape reads an <em>include</em> directive, it evaluates the rest of the line (i.e. the characters that immediately follow the directive), and interprets each word as the name of a file to be read. Each of the file names is bound to either a regular file, or the most recent version of the file. Shape opens each of the included files, suspends reading the current description file, and continues to read the contents of the included file(s), before it resumes reading of the original control file. If multiple file names are specified in an include directive, shape reads each of the files in turn, starting with the leftmost, and ending with the rightmost file name. If an included file could not be opened, shape issues a warning.</p><p>While shape reads its description files, version selection rules, and target rules are <em>collected</em>. They are <em>defined</em> only after shape has finished reading the description file. Macro-, variant-, and variant class definitions are made effective as soon as they have been recognized.</p><p><em>The Build Process</em></p><p>After the description file has been read, shape determines which targets have been requested. If targets have been requested from the command line, shape will attempt to build each of them, starting with the leftmost target and proceeding towards the rightmost. If no target has been requested from the command line, shape searches the description file for a target named <em>.DEFAULT</em>. If such a target exists, and there are any dependencies associated with it, shape will attempt to build each of these dependencies, from left to right. If no <em>.DEFAULT</em> target rule has been defined in the description file, shape will attempt to build the <em>first target defined in the</em> description file.</p><p>When shape builds a target, it proceeds as follows:</p>
<dl class='dl-vertical'>
  <dt>
    1)
  </dt>
  <dd>
    <p>determine the names of the source objects for a given target by traversing the dependency graph, using built-in and user supplied target rules. The dependency graph is traversed depth first. The ids of all applied rules are recorded.</p>
  </dd>
  <dt>
    2)
  </dt>
  <dd>
    <p>for each required source object, locate the source version archive in the repository. Locating of source version archives takes the current <em>vpath</em> into account.</p>
  </dd>
  <dt>
    3)
  </dt>
  <dd>
    <p>bind each of the source object's names to an appropriate version as implied by the currently active version selection rule. Record the id of each bound dependency. If a dependency is itself a derived object, use its <em>cache key</em> as id.</p>
  </dd>
  <dt>
    4)
  </dt>
  <dd>
    <p>construct the <em>derivation key</em> for the current target from the target name and the records resulting from steps 1) and 3).</p>
  </dd>
  <dt>
    5)
  </dt>
  <dd>
    <p>search the derived object cache for an object that has a derivation key identical to the key constructed in step 4).</p>
  </dd>
  <dt>
    6a)
  </dt>
  <dd>
    <p>if an appropriate derived object was found, a copy of it is installed in the build directory, rather than deriving it from its sources.</p>
  </dd>
  <dt>
    6b)
  </dt>
  <dd>
    <p>if no appropriate derived object was found, it is created by deriving it from its parts. The resulting derived object is put into the derived object cache, and associated with the derivation key resulting from step 4).</p>
  </dd>

</dl>
<p>Targets with an empty list of dependencies - and thus an empty derivation key - are always (re-) derived.</p><p>When shape determines the dependencies of a requested target, it does so by evaluating either explicit target rules, or by applying - possibly built-in - implicit rules. If explicit target rules specify object dependencies but no derivation script in the rule body, shape will attempt to supply an appropriate default derivation script. When searching for such a default derivation script, shape tries to find an applicable implicit rule for the current target. An implicit rule is considered applicable, if it has the current target in its list of targets (after pattern substitution), and all - explicit, and implied - dependencies exist. If no implicit rule is found to be applicable, shape looks for the <em>.DEFAULT</em> target rule. If such a rule exists, and if it has an associated derivation script in its rule body, this script will be supplied as default derivation script. If neither of the two possibilities leads to a default derivation script, shape gives up.</p><p><em>Derived Object Caching</em></p><p>Before the derivation process for a requested target is started, it is attempted to find a suitable derived object in the derived object cache that matches the required properties. Shape is based on the <em>derivation key</em> concept for target objects. The derivation key is constructed according to the algorithm described above. Relevant parameters that go into the derivation key are the <em>list of</em> dependency ids, the <em>target rule id</em>, the <em>list of production</em> ingredients, the <em>build platform</em> (usually defined by the macro <em>HOSTTYPE</em>; if this macro is not defined, shape takes the host id as build platform), and the <em>attribute expansion status</em> of each source object. When an object has been derived, shape stores it in the derived object cache, and marks it with the derivation key attribute. For a detailed trace of shape's derived object cache handling, and the use of derivation keys, run shape with the <strong>-D</strong> switch.</p><p><em>Command Execution</em></p><p>When a target needs to be (re-) derived, shape executes the commands associated with the target. Before the commands are executed, shape sets up the command execution context. The version objects of the target's dependencies are installed as regular files in the file system. If necessary, shape retrieves source objects from the version control archive. If a file with the object's name already exists in the place where a version is to be installed, shape will temporarily move it to the <em>AtFS</em> subdirectory. After the command script has completed, shape will restore the original state of all affected directories.</p><p>Shape executes a command line by starting the program referenced in the <em>$(SHELL)</em> macro, and opening a pipe to the resulting process. The command line is written to the pipe, and thus sent to the <em>$(SHELL)</em> process' standard input.</p><p>Each of the command lines in a rule body are executed by a separate process. Thus, the execution status of separate commands is not preserved. If multiple commands are needed that rely on the execution status of previous commands, all these commands must occur in a single command line. This is possible with <em>line continuations</em> (see section on <em>Syntactical Structure</em>, above).</p><p>NOTE: many command interpreters use the ``$'' character as special symbol (typically as variable reference). Make sure to pass ``$'' characters in commands to the <em>$(SHELL)</em> process by using the ``$$'' special macro (see section on <em>Macro References</em>, above).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INCOMPATIBILITIES</h2>
        <div class="sectioncontent">
<p>In order to facilitate migration from <a href="../man1/make.1.html"><strong>make</strong>(1)</a></strong>, shape was designed to be upward compatible with Makefiles. Although most of make's description file features are present in shape, there is a number of incompatibilities that may need to be taken care of. There exists also a number of popular extensions of the original make program (e.g. Sun's Make, HP's Make, GNU Make, nmake etc.) that offer various special features that aren't supported by other make extensions, or by shape. When a migration from make to shape is planned, it should be checked whether special extensions or incompatible features are used.</p><p><em>Features not supported by shape</em></p>
<dl class='dl-vertical'>
  <dt>
    <strong>Double colon rules</strong>
  </dt>
  <dd>
    <p>Double colon rules associate the same target with different derivation scripts. This type of rule is useful to support different derivations for a target depending on which dependencies are out of date. Because shape bases its decision whether to derive on the <em>derivation</em> key, rather than mere modification time stamps of files, this sort of rule makes no sense in shape.</p>
  </dd>
  <dt>
    <strong>Archive member targets</strong>
  </dt>
  <dd>
    <p>Archive member targets are objects that live in an archive file (see <strong>ar(1)</strong>) rather than the file system. Within these archives, make bases its decisions on the modification time stamps of source files, and archive entry dates. There is no way for shape to simulate the concept of derivation keys for archive members. Maintenance of archives, however, is easy with shape, because all data for compiled object files is maintained in the derived object cache. If the source for an object that is stored in an archive is modified, shape can rederive this object, and selectively replace the entry in the archive.</p>
  </dd>
  <dt>
    <strong>SCCS stuff</strong>
  </dt>
  <dd>
    <p>In order to provide basic support for team oriented development processes, make allows to retrieve the most recent version of source files from SCCS archives. Because of the awkward naming convention for SCCS version archive files, special support for dealing with these archives had to be built into make. Because shape is tightly integrated with the <em>AtFS</em> version object repository, there is no need for any special SCCS support.</p>
  </dd>
  <dt>
    <strong>Special targets</strong>
  </dt>
  <dd>
    <p>Shape does not recognize the special targets <em>.PRECIOUS:</em>, and <em>.SUFFIXES:</em>. The .PRECIOUS target in Makefiles has the purpose to prevent deletion of expensively derived intermediate targets (by default, make deletes intermediate targets). Because shape stores intermediate targets in the derived object cache, there is no need for the .PRECIOUS feature. To prevent caching of possibly large, useless intermediate targets, use the <em>.NOBPOOL:</em> special target (see section on <em>Special Targets</em>, above). The .SUFFIXES target in Makefiles has the purpose to introduce new suffix types into make's derivation engine, and to determine the order in which implicit rules (<em>suffix rules</em> in make terminology) are applied. In shape, new suffix types can be added dynamically, simply by introducing new implicit rules. Moreover, shape has an intelligent algorithm the determines the applicable implicit rule.</p>
  </dd>

</dl>
<p><em>Features with different semantics</em></p>
<dl class='dl-vertical'>
  <dt>
    <strong>Environment Variables</strong>
  </dt>
  <dd>
    <p>Many make programs import the entire set of environment variables as macro definitions into the build process. This can sometimes produce surprising results. In shape, environment variables are explicitly imported with the <em>IMPORT</em> special macro.</p>
  </dd>
  <dt>
    <strong>? Macro</strong>
  </dt>
  <dd>
    <p>In make's target rules, the special macro reference $? is substituted by the names of those dependency file names that have been updated since the current target has been derived. Because shape bases its decision whether to derive on the concept of <em>derivation</em> key, rather than mere file modification time stamps, the <em>?</em> macro cannot be correctly defined. Instead, shape substitutes the entire list of dependency names - updated or not.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILES</h2>
        <div class="sectioncontent">
<p>Shapefile, shapefile, Makefile, makefile, /tmp/shapeXXXXXX, <em>&lt;target name&gt;</em>.bct</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO shape&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man1/make.1.html"><strong>make</strong>(1)</a></strong>, <strong>save</strong>(1)</strong>, <a href="../man1/retrv.1.html"><strong>retrv</strong>(1)</a></strong>, <a href="../man1/vadm.1.html"><strong>vadm</strong>(1)</a></strong>, vl(1), <a href="../man1/vgdb.1.html"><strong>vgdb</strong>(1)</a>, <a href="../man1/vbind.1.html"><strong>vbind</strong>(1)</a>, <strong>afintro</strong>(3), <a href="../man3/atfstkintro.3.html"><strong>atfstkintro</strong>(3)</a>, <a href="../man3/sttkintro.3.html"><strong>sttkintro</strong>(3)</a>, <a href="../man7/bindrules.7.html"><strong>bindrules</strong>(7)</a></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CAVEATS AND BUGS</h2>
        <div class="sectioncontent">
<p>Macro references containing string substitutions cause a syntax error if used in place of target dependencies. Workaround: use indirect macro substitution.</p><p>There are probably more bugs in shape. Please report any bug findings to <em>shape-cr@cs.tu-berlin.de</em>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FURTHER READING</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <em>Axel Mahler:</em>
  </dt>
  <dd>
    <p>``Using the Shape Toolkit for Cooperative Software Development - A Tutorial'', in the toolkit distribution.</p>
  </dd>
  <dt>
    <em>Axel Mahler </em>and<em> Andreas Lampen</em>:
  </dt>
  <dd>
    <p>``An Integrated Toolset for Engineering Software Configurations'', Sigplan Notices, Vol. 24, No. 2, or Software Engineering Notes, Vol. 13, No. 5, November 1988.</p>
  </dd>
  <dt>
    <em>Andreas Lampen</em> and <em>Axel Mahler</em>:
  </dt>
  <dd>
    <p>``An Object Base for Attributed Software Objects'', Proceedings of the Fall 1988 EUUG Conference.</p>
  </dd>

</dl>
<p>These and other papers are available via anonymous ftp from <em>coma.cs.tu-berlin.de</em> (pub/shapeTools/papers).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p><em>Shape</em> was designed by the shape project team at Technical University Berlin. The program was originally implemented by Wolfgang Obst (1988). Extensive fixes and modifications were introduced by Axel Mahler (1992). Valuable contributions came from Steve Emmerson. In 1993 most parts of shape were re-implemented by Axel Mahler. The version binding was re-implemented by Andreas Lampen. A complete re-implementation of the Shapefile parser was done by Juergen Nickelsen.</p><p>Contact:</p>
<pre>
SHAPE
Technical University Berlin
Sekr. FR 5-6
Franklinstr. 28/29
10587 Berlin

General correspondence: shape@cs.tu-berlin.de
Bug reports and modification requests: shape-cr@cs.tu-berlin.de
</pre>

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="shanty.1.html"><span aria-hidden="true">&larr;</span> shanty.1: Makes a postscript file from an image and some text.</a></li>
   <li class="next"><a href="shape_RMS.1.html">shape_RMS.1: Introduction to the shapetools release management system <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

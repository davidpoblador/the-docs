<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SWISH-FAQ: The swish-e faq. answers to common questions</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The swish-e faq. answers to common questions">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="SWISH-FAQ (1) manual">
  <meta name="twitter:description" content="The swish-e faq. answers to common questions">
  <meta name="twitter:image" content="https://www.carta.tech/images/swish-e-SWISH-FAQ-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/SWISH-FAQ.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="SWISH-FAQ (1) manual" />
  <meta property="og:description" content="The swish-e faq. answers to common questions" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/swish-e-SWISH-FAQ-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">SWISH-FAQ<small> (1)</small></h1>
        <p class="lead">The swish-e faq. answers to common questions</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/SWISH-FAQ.1.html">
      <span itemprop="name">SWISH-FAQ: The swish-e faq. answers to common questions</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/swish-e/">
      <span itemprop="name">swish-e</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/SWISH-FAQ.1.html">
      <span itemprop="name">SWISH-FAQ: The swish-e faq. answers to common questions</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">OVERVIEW</h2>
        <div class="sectioncontent">
<p>List of commonly asked and answered questions.  Please review this document before asking questions on the Swish-e discussion list.</p><p><strong>&#92;$1</strong></p><p><em>What is Swish-e?</em></p><p>Swish-e is <strong>S</strong>imple <strong>W</strong>eb <strong>I</strong>ndexing <strong>S</strong>ystem for <strong>H</strong>umans - <strong>E</strong>nhanced.  With it, you can quickly and easily index directories of files or remote web sites and search the generated indexes for words and phrases.</p><p><em>So, is Swish-e a search engine?</em></p><p>Well, yes.  Probably the most common use of Swish-e is to provide a search engine for web sites.  The Swish-e distribution includes \s-1CGI\s0 scripts that can be used with it to add a <em>search engine</em> for your web site.  The \s-1CGI\s0 scripts can be found in the <em>example</em> directory of the distribution package.  See the <em>\s-1README\s0</em> file for information about the scripts.</p><p>But Swish-e can also be used to index all sorts of data, such as email messages, data stored in a relational database management system, \s-1XML\s0 documents, or documents such as Word and \s-1PDF\s0 documents \*(-- or any combination of those sources at the same time.  Searches can be limited to fields or <em>MetaNames</em> within a document, or limited to areas within an \s-1HTML\s0 document (e.g. body, title).  Programs other than \s-1CGI\s0 applications can use Swish-e, as well.</p><p><em>Should I upgrade if I'm already running a previous version of Swish-e?</em></p><p>A large number of bug fixes, feature additions, and logic corrections were made in version 2.2.  In addition, indexing speed has been drastically improved (reports of indexing times changing from four hours to 5 minutes), and major parts of the indexing and search parsers have been rewritten.  There's better debugging options, enhanced output formats, more document meta data (e.g. last modified date, document summary), options for indexing from external data sources, and faster spidering just to name a few changes.  (See the \s-1CHANGES\s0 file for more information.</p><p>Since so much effort has gone into version 2.2, support for previous versions will probably be limited.</p><p><em>Are there binary distributions available for Swish-e on platform foo?</em></p><p>Foo?  Well, yes there are some binary distributions available.  Please see the Swish-e web site for a list at http://swish-e.org/.</p><p>In general, it is recommended that you build Swish-e from source, if possible.</p><p><em>Do I need to reindex my site each time I upgrade to a new Swish-e version?</em></p><p>At times it might not strictly be necessary, but since you don't really know if anything in the index has changed, it is a good rule to reindex.</p><p><em>What's the advantage of using the libxml2 library for parsing \s-1HTML\s0?</em></p><p>Swish-e may be linked with libxml2, a library for working with \s-1HTML\s0 and \s-1XML\s0 documents.  Swish-e can use libxml2 for parsing \s-1HTML\s0 and \s-1XML\s0 documents.</p><p>The libxml2 parser is a better parser than Swish-e's built-in \s-1HTML\s0 parser.  It offers more features, and it does a much better job at extracting out the text from a web page.  In addition, you can use the \*(C`ParserWarningLevel\*(C' configuration setting to find structural errors in your documents that could (and would with Swish-e's \s-1HTML\s0 parser) cause documents to be indexed incorrectly.</p><p>Libxml2 is not required, but is strongly recommended for parsing \s-1HTML\s0 documents.  It's also recommended for parsing \s-1XML\s0, as it offers many more features than the internal Expat xml.c parser.</p><p>The internal \s-1HTML\s0 parser will have limited support, and does have a number of bugs.  For example, \s-1HTML\s0 entities may not always be correctly converted and properties do not have entities converted.  The internal parser tends to get confused when invalid \s-1HTML\s0 is parsed where the libxml2 parser doesn't get confused as often.  The structure is better detected with the libxml2 parser.</p><p>If you are using the Perl module (the C interface to the Swish-e library) you may wish to build two versions of Swish-e, one with the libxml2 library linked in the binary, and one without, and build the Perl module against the library without the libxml2 code.  This is to save space in the library.  Hopefully, the library will someday soon be split into indexing and searching code (volunteers welcome).</p><p><em>Does Swish-e include a \s-1CGI\s0 interface?</em></p><p>Yes.  Kind of.</p><p>There's two example \s-1CGI\s0 scripts included, swish.cgi and search.cgi. Both are installed at <em>$prefix/lib/swish-e</em>.</p><p>Both require a bit of work to setup and use.  Swish.cgi is probably what most people will want to use as it contains more features.  Search.cgi is for those that want to start with a small script and customize it to fit their needs.</p><p>An example of using swish.cgi is given in the \s-1INSTALL\s0 man page, and it the swish.cgi documentation. Like often is the case, it will be easier to use if you first read the documentation.</p><p>Please use caution about \s-1CGI\s0 scripts found on the Internet for use with Swish-e. Some are not secure.</p><p>The included example \s-1CGI\s0 scripts were designed with security in mind. Regardless, you are encouraged to have your local Perl expert review it (and all other \s-1CGI\s0 scripts you use) before placing it into production. This is just a good policy to follow.</p><p><em>How secure is Swish-e?</em></p><p>We know of no security issues with using Swish-e.  Careful attention has been made with regard to common security problems such as buffer overruns when programming Swish-e.</p><p>The most likely security issue with Swish-e is when it is run via a poorly written \s-1CGI\s0 interface.  This is not limited to \s-1CGI\s0 scripts written in Perl, as it's just as easy to write an insecure \s-1CGI\s0 script in C, Java, \s-1PHP\s0, or Python.  A good source of information is included with the Perl distribution.  Type \*(C`perldoc perlsec\*(C' at your local prompt for more information.  Another must-read document is located at \*(C`http://www.w3.org/Security/faq/wwwsf4.html\*(C'.</p><p>Note that there are many <em>free</em> yet insecure and poorly written \s-1CGI\s0 scripts available \*(-- even some designed for use with Swish-e.  Please carefully review any \s-1CGI\s0 script you use.  Free is not such a good price when you get your server hacked...</p><p><em>Should I run Swish-e as the superuser (root)?</em></p><p>No.  Never.</p><p><em>What files does Swish-e write?</em></p><p>Swish writes the index file, of course.  This is specified with the \*(C`IndexFile\*(C' configuration directive or by the \*(C`-f\*(C' command line switch.</p><p>The index file is actually a collection of files, but all start with the file name specified with the \*(C`IndexFile\*(C' directive or the \*(C`-f\*(C' command line switch.</p><p>For example, the file ending in <em>.prop</em> contains the document properties.</p><p>When creating the index files Swish-e appends the extension <em>.temp</em> to the index file names.  When indexing is complete Swish-e renames the <em>.temp</em> files to the index files specified by \*(C`IndexFile\*(C' or \*(C`-f\*(C'. This is done so that existing indexes remain untouched until it completes indexing.</p><p>Swish-e also writes temporary files in some cases during indexing (e.g. \*(C`-s http\*(C', \*(C`-s prog\*(C' with filters), when merging, and when using \*(C`-e\*(C').  Temporary files are created with the <em>mkstemp</em>\|(3) function (with 0600 permission on unix-like operating systems).</p><p>The temporary files are created in the directory specified by the environment variables \*(C`TMPDIR\*(C' and \*(C`TMP\*(C' in that order.  If those are not set then swish uses the setting the configuration setting TmpDir.  Otherwise, the temporary file will be located in the current directory.</p><p><em>Can I index \s-1PDF\s0 and MS-Word documents?</em></p><p>Yes, you can use a <em>Filter</em> to convert documents while indexing, or you can use a program that \*(L"feeds\*(R" documents to Swish-e that have already been converted.  See \*(C`Indexing\*(C' below.</p><p><em>Can I index documents on a web server?</em></p><p>Yes, Swish-e provides two ways to index (spider) documents on a web server.  See \*(C`Spidering\*(C' below.</p><p>Swish-e can retrieve documents from a file system or from a remote web server.  It can also execute a program that returns documents back to it.  This program can retrieve documents from a database, filter compressed documents files, convert \s-1PDF\s0 files, extract data from mail archives, or spider remote web sites.</p><p><em>Can I implement keywords in my documents?</em></p><p>Yes, Swish-e can associate words with <em>MetaNames</em> while indexing, and you can limit your searches to these MetaNames while searching.</p><p>In your \s-1HTML\s0 files you can put keywords in \s-1HTML\s0 \s-1META\s0 tags or in \s-1XML\s0 blocks.</p><p>\s-1META\s0 tags can have two formats in your source documents:</p>
<pre>
    &lt;META NAME="DC.subject" CONTENT="digital libraries"&gt;
</pre>
<p>And in \s-1XML\s0 format (can also be used in \s-1HTML\s0 documents when using libxml2):</p><p>    &lt;meta2&gt;         Some Content     &lt;/meta2&gt;</p><p>Then, to inform Swish-e about the existence of the meta name in your documents, edit the line in your configuration file:</p><p>    MetaNames DC.subject meta1 meta2</p><p>When searching you can now limit some or all search terms to that MetaName.  For example, to look for documents that contain the word apple and also have either fruit or cooking in the \s-1DC\s0.subject meta tag.</p><p><em>What are document properties?</em></p><p>A document property is typically data that describes the document. For example, properties might include a document's path name, its last modified date, its title, or its size.  Swish-e stores a document's properties in the index file, and they can be reported back in search results.</p><p>Swish-e also uses properties for sorting.  You may sort your results by one or more properties, in ascending or descending order.</p><p>Properties can also be defined within your documents.  \s-1HTML\s0 and \s-1XML\s0 files can specify tags (see previous question) as properties. The <em>contents</em> of these tags can then be returned with search results. These user-defined properties can also be used for sorting search results.</p><p>For example, if you had the following in your documents</p><p>   &lt;meta name="creator" content="accounting department"&gt;</p><p>and \*(C`creator\*(C' is defined as a property (see \*(C`PropertyNames\*(C' in SWISH-CONFIG) Swish-e can return \*(C`accounting department\*(C' with the result for that document.</p><p>    swish-e -w foo -p creator</p><p>Or for sorting:</p><p>    swish-e -w foo -s creator</p><p><em>What's the difference between MetaNames and PropertyNames?</em></p><p>MetaNames allows keywords searches in your documents.  That is, you can use MetaNames to restrict searches to just parts of your documents.</p><p>PropertyNames, on the other hand, define text that can be returned with results, and can be used for sorting.</p><p>Both use <em>meta tags</em> found in your documents (as shown in the above two questions) to define the text you wish to use as a property or meta name.</p><p>You may define a tag as <strong>both</strong> a property and a meta name.  For example:</p><p>   &lt;meta name="creator" content="accounting department"&gt;</p><p>placed in your documents and then using configuration settings of:</p><p>    PropertyNames creator     MetaNames creator</p><p>will allow you to limit your searches to documents created by accounting:</p><p>    swish-e -w 'foo and creator=(accounting)'</p><p>That will find all documents with the word \*(C`foo\*(C' that also have a creator meta tag that contains the word \*(C`accounting\*(C'.  This is using MetaNames.</p><p>And you can also say:</p><p>    swish-e -w foo -p creator</p><p>which will return all documents with the word \*(C`foo\*(C', but the results will also include the contents of the \*(C`creator\*(C' meta tag along with results. This is using properties.</p><p>You can use properties and meta names at the same time, too:</p><p>    swish-e -w creator=(accounting or marketing) -p creator -s creator</p><p>That searches only in the \*(C`creator\*(C' <em>meta name</em> for either of the words \*(C`accounting\*(C' or \*(C`marketing\*(C', prints out the contents of the contents of the \*(C`creator\*(C' <em>property</em>, and sorts the results by the \*(C`creator\*(C' <em>property name</em>.</p><p>(See also the \*(C`-x\*(C' output format switch in SWISH-RUN.)</p><p><em>Can Swish-e index multi-byte characters?</em></p><p>No.  This will require much work to change.  But, Swish-e works with eight-bit characters, so many characters sets can be used.  Note that it does call the ANSI-C <em>tolower()</em> function which does depend on the current locale setting.  See <a href="../man7/locale.7.html"><strong>locale</strong>(7)</a> for more information. <em>How do I pass Swish-e a list of files to index?</em></p><p>Currently, there is not a configuration directive to include a file that contains a list of files to index.  But, there is a directive to include another configuration file.</p><p>    IncludeConfigFile /path/to/other/config</p><p>And in \*(C`/path/to/other/config\*(C' you can say:</p><p>    IndexDir file1 file2 file3 file4 file5 ...     IndexDir file20 file21 file22</p><p>You may also specify more than one configuration file on the command line:</p><p>    ./swish-e -c config_one config_two config_three</p><p>Another option is to create a directory with symbolic links of the files to index, and index just that directory.</p><p><em>How does Swish-e know which parser to use?</em></p><p>Swish can parse \s-1HTML\s0, \s-1XML\s0, and text documents.  The parser is set by associating a file extension with a parser by the \*(C`IndexContents\*(C' directive.  You may set the default parser with the \*(C`DefaultContents\*(C' directive.  If a document is not assigned a parser it will default to the \s-1HTML\s0 parser (\s-1HTML2\s0 if built with libxml2).</p><p>You may use Filters or an external program to convert documents to \s-1HTML\s0, \s-1XML\s0, or text.</p><p><em>Can I reindex and search at the same time?</em></p><p>Yes.  Starting with version 2.2 Swish-e indexes to temporary files, and then renames the files when indexing is complete.  On most systems renames are atomic.  But, since Swish-e also generates more than one file during indexing there will be a very short period of time between renaming the various files when the index is out of sync.</p><p>Settings in <em>src/config.h</em> control some options related to temporary files, and their use during indexing.</p><p><em>Can I index phrases?</em></p><p>Phrases are indexed automatically.  To search for a phrase simply place double quotes around the phrase.</p><p>For example:</p><p>    swish-e -w 'free and "fast search engine"'</p><p><em>How can I prevent phrases from matching across sentences?</em></p><p>Use the BumpPositionCounterCharacters configuration directive.</p><p><em>Swish-e isn't indexing a certain word or phrase.</em></p><p>There are a number of configuration parameters that control what Swish-e considers a \*(L"word\*(R" and it has a debugging feature to help pinpoint any indexing problems.</p><p>Configuration file directives (SWISH-CONFIG) \*(C`WordCharacters\*(C', \*(C`BeginCharacters\*(C', \*(C`EndCharacters\*(C', \*(C`IgnoreFirstChar\*(C', and \*(C`IgnoreLastChar\*(C' are the main settings that Swish-e uses to define a \*(L"word\*(R".  See SWISH-CONFIG and SWISH-RUN for details.</p><p>Swish-e also uses compile-time defaults for many settings.  These are located in <em>src/config.h</em> file.</p><p>Use of the command line arguments \*(C`-k\*(C', \*(C`-v\*(C' and \*(C`-T\*(C' are useful when debugging these problems.  Using \*(C`-T INDEXED_WORDS\*(C' while indexing will display each word as it is indexed.  You should specify one file when using this feature since it can generate a lot of output.</p><p>     ./swish-e -c my.conf -i problem.file -T INDEXED_WORDS</p><p>You may also wish to index a single file that contains words that are or are not indexing as you expect and use -T to output debugging information about the index.  A useful command might be:</p><p>    ./swish-e -f index.swish-e -T INDEX_FULL</p><p>Once you see how Swish-e is parsing and indexing your words, you can adjust the configuration settings mentioned above to control what words are indexed.</p><p>Another useful command might be:</p><p>     ./swish-e -c my.conf -i problem.file -T PARSED_WORDS INDEXED_WORDS</p><p>This will show white-spaced words parsed from the document (\s-1PARSED_WORDS\s0), and how those words are split up into separate words for indexing (\s-1INDEXED_WORDS\s0).</p><p><em>How do I keep Swish-e from indexing numbers?</em></p><p>Swish-e indexes words as defined by the \*(C`WordCharacters\*(C' setting, as described above.  So to avoid indexing numbers you simply remove digits from the \*(C`WordCharacters\*(C' setting.</p><p>There are also some settings in <em>src/config.h</em> that control what \*(L"words\*(R" are indexed.  You can configure swish to never index words that are all digits, vowels, or consonants, or that contain more than some consecutive number of digits, vowels, or consonants.  In general, you won't need to change these settings.</p><p>Also, there's an experimental feature called \*(C`IgnoreNumberChars\*(C' which allows you to define a set of characters that describe a number. If a word is made up of <strong>only</strong> those characters it will not be indexed.</p><p><em>Swish-e crashes and burns on a certain file. What can I do?</em></p><p>This shouldn't happen.  If it does please post to the Swish-e discussion list the details so it can be reproduced by the developers.</p><p>In the mean time, you can use a \*(C`FileRules\*(C' directive to exclude the particular file name, or pathname, or its title.  If there are serious problems in indexing certain types of files, they may not have valid text in them (they may be binary files, for instance). You can use NoContents to exclude that type of file.</p><p>Swish-e will issue a warning if an embedded null character is found in a document.  This warning will be an indication that you are trying to index binary data.  If you need to index binary files try to find a program that will extract out the text (e.g. <em>strings</em>\|(1), <em>catdoc</em>\|(1), <em>pdftotext</em>\|(1)).</p><p><em>How to I prevent indexing of some documents?</em></p><p>When using the file system to index your files you can use the \*(C`FileRules\*(C' directive.  Other than \*(C`FileRules title\*(C', \*(C`FileRules\*(C' only works with the file system (\*(C`-S fs\*(C') indexing method, not with \*(C`-S prog\*(C' or \*(C`-S http\*(C'.</p><p>If you are spidering a site you have control over, use a <em>robots.txt</em> file in your document root.  This is a standard way to excluded files from search engines, and is fully supported by Swish-e.  See http://www.robotstxt.org/</p><p>If spidering a website with the included <em>spider.pl</em> program then add any necessary tests to the spider's configuration file. Type &lt;perldoc spider.pl&gt; in the \*(C`prog-bin\*(C' directory for details or see the spider documentation on the Swish-e website.  Look for the section on callback functions.</p><p>If using the libxml2 library for parsing \s-1HTML\s0 (which you probably are), you may also use the Meta Robots Exclusion in your documents:</p><p>    &lt;meta name="robots" content="noindex"&gt;</p><p>See the obeyRobotsNoIndex directive.</p><p><em>How do I prevent indexing parts of a document?</em></p><p>To prevent Swish-e from indexing a common header, footer, or navigation bar, \s-1AND\s0 you are using libxml2 for parsing \s-1HTML\s0, then you may use a fake \s-1HTML\s0 tag around the text you wish to ignore and use the \*(C`IgnoreMetaTags\*(C' directive.  This will generate an error message if the \*(C`ParserWarningLevel\*(C' is set as it's invalid \s-1HTML\s0.</p><p>\*(C`IgnoreMetaTags\*(C' works with \s-1XML\s0 documents (and \s-1HTML\s0 documents when using libxml2 as the parser), but not with documents parsed by the text (\s-1TXT\s0) parser.</p><p>If you are using the libxml2 parser (\s-1HTML2\s0 and \s-1XML2\s0) then you can use the the following comments in your documents to prevent indexing:</p><p>       &lt;!-- SwishCommand noindex --&gt;        &lt;!-- SwishCommand index --&gt;</p><p>and/or these may be used also:</p><p>       &lt;!-- noindex --&gt;        &lt;!-- index --&gt;</p><p><em>How do I modify the path or \s-1URL\s0 of the indexed documents.</em></p><p>Use the \*(C`ReplaceRules\*(C' configuration directive to rewrite path names and URLs.  If you are using \*(C`-S prog\*(C' input method you may set the path to any string.</p><p><em>How can I index data from a database?</em></p><p>Use the \*(L"prog\*(R" document source method of indexing.  Write a program to extract out the data from your database, and format it as \s-1XML\s0, \s-1HTML\s0, or text.  See the examples in the \*(C`prog-bin\*(C' directory, and the next question.</p><p><em>How do I index my \s-1PDF\s0, Word, and compressed documents?</em></p><p>Swish-e can internally only parse \s-1HTML\s0, \s-1XML\s0 and \s-1TXT\s0 (text) files by default, but can make use of <em>filters</em> that will convert other types of files such as \s-1MS\s0 Word documents, \s-1PDF\s0, or gzipped files into one of the file types that Swish-e understands.</p><p>Please see SWISH-CONFIG and the examples in the <em>filters</em> and <em>filter-bin</em> directory for more information.</p><p>See the next question to learn about the filtering options with Swish-e.</p><p><em>How do I filter documents?</em></p><p>The term \*(L"filter\*(R" in Swish-e means the converstion of a document of one type (one that swish-e cannot index directly) into a type that Swish-e can index, namely \s-1HTML\s0, plain text, or \s-1XML\s0. To add to the confusion, there are a number of ways to accomplish this in Swish-e. So here's a bit of background.</p><p>The FileFilter directive was added to swish first. This feature allows you to specify a program to run for documents that match a given file extension. For example, to filter \s-1PDF\s0 files (files that end in .pdf) you can specify the configuation setting of:</p><p>    FileFilter .pdf pdftotext   "'%p' -"</p><p>which says to run the program \*(L"pdftotext\*(R" passing it the pathname of the file (%p) and a dash (which tells pdftotext to output to stdout).   Then for each .pdf file Swish-e runs this program and reads in the filtered document from the output from the filter program.</p><p>This has the advantage that it is easy to setup \*(-- a single line in the config file is all that is needed to add the filter into Swish-e.  But it also has a number of problems.  For example, if you use a Perl script to do your filtering it can be very slow since the filter script must be run (and thus compiled) for each processed document. This is exacerbated when using the -S http method since the -S http method also uses a Perl script that is run for every \s-1URL\s0 fetched.  Also, when using -S prog method of input (reading input from a program) using FileFilter means that Swish-e must first read the file in from the external program and then write the file out to a temporary file before running the filter.</p><p>With -S prog it makes much more sense to filter the document in the program that is fetching the documents than to have swish-e read the file into memory, write it to a temporary file and then run an external program.</p><p>The Swish-e distribution contains a couple of example -S prog programs.  <em>spider.pl</em> is a reasonably full-featured web spider that offers many more options than the -S http method.  And it is much faster than running -S http, too.</p><p>The spider has a perl configuration file, which means you can add programming logic right into the configuration file without editing the spider program.  One bit of logic that is provided in the spider's configuration file is a \*(L"call-back\*(R" function that allows you to filter the content. In other words, before the spider passes a fetched web document to swish for indexing the spider can call a simple subroutine in the spider's configuration file passing the document and its content type. The subroutine can then look at the content type and decide if the document needs to be filtered.</p><p>For example, when processing a document of type \*(L"application/msword\*(R" the call-back subroutine might call the doc2txt.pm perl module, and a document of type \*(L"appliation/pdf\*(R" could use the pdf2html.pm module.  The <em>prog-bin/SwishSpiderConfig.pl</em> file shows this usage.</p><p>This system works reasonably well, but also means that more work is required to setup the filters.  First, you must explicitly check for specific content types and then call the appropriate Perl module, and second, you have to know how each module must be called and how each returns the possibly modified content.</p><p>In comes SWISH::Filter.</p><p>To make things easier the SWISH::Filter Perl module was created.  The idea of this module is that there is one interface used to filter all types of documents.  So instead of checking for specific types of content you just pass the content type and the document to the SWISH::Filter module and it returns a new content type and document if it was filtered.  The filters that do the actual work are designed with a standard interface and work like filter \*(L"plug-ins\*(R". Adding new filters means just downloading the filter to a directory and no changes are needed to the spider's configuation file.  Download a filter for Postscript and next time you run indexing your Postscript files will be indexed.</p><p>Since the filters are standardized, hopefully when you have the need to filter documents of a specific type there will already be a filter ready for your use.</p><p>Now, note that the perl modules may or may not do the actual conversion of a document. For example, the \s-1PDF\s0 conversion module calls the pdfinfo and pdftotext programs.  Those programs (part of the Xpfd package) must be installed separately from the filters.</p><p>The SwishSpiderConfig.pl examle spider configuration file shows how to use the SWISH::Filter module for filtering. This file is installed at $prefix/share/doc/swish-e/examples/prog-bin, where $prefix is normally /usr/local on unix-type machines.</p><p>The SWISH::Filter method of filtering can also be used with the -S http method of indexing.  By default the <em>swishspider</em> program (the Perl helper script that fetches documents from the web) will attempt to use the SWISH::Filter module if it can be found in Perls library path.  This path is set automatically for spider.pl but not for swishspider (because it would slow down a method that's already slow and spider.pl is recommended over the -S http method).</p><p>Therefore, all that's required to use this system with -S http is setting the @INC array to point to the filter directory.</p><p>For example, if the swish-e distribution was unpacked into ~/swish-e:</p><p>   PERL5LIB=~/swish-e/filters swish-e -c conf -S http</p><p>will allow the -S http method to make use of the SWISH::Filter module.</p><p>Note that if you are not using the SWISH::Filter module you may wish to edit the <em>swishspider</em> program and disable the use of the SWISH::Filter module using this setting:</p><p>    use constant USE_FILTERS  =&gt; 0;  # disable SWISH::Filter</p><p>This prevents the program from attempting to use the SWISH::Filter module for every non-text \s-1URL\s0 that is fetched.  Of course, if you are concerned with indexing speed you should be using the -S prog method with spider.pl instead of -S http.</p><p>If you are not spidering, but you still want to make use of the SWISH::Filter module for filtering you can use the DirTree.pl program (in $prefix/lib/swish-e).  This is a simple program that traverses the file system and uses SWISH::Filter for filtering.</p><p>Here's two examples of how to run a filter program, one using Swish-e's \*(C`FileFilter\*(C' directive, another using a \*(C`prog\*(C' input method program. See the <em>SwishSpiderConfig.pl</em> file for an example of using the SWISH::Filter module.</p><p>These filters simply use the program \*(C`/bin/cat\*(C' as a filter and only indexes .html files.</p><p>First, using the \*(C`FileFilter\*(C' method, here's the entire configuration file (swish.conf):</p><p>    IndexDir .     IndexOnly .html     FileFilter .html "/bin/cat"   "'%p'"</p><p>and index with the command</p><p>    swish-e -c swish.conf -v 1</p><p>Now, the same thing with using the \*(C`-S prog\*(C' document source input method and a Perl program called catfilter.pl.  You can see that's it's much more work than using the \*(C`FileFilter\*(C' method above, but provides a place to do additional processing.  In this example, the \*(C`prog\*(C' method is only slightly faster.  But if you needed a perl script to run as a FileFilter then \*(C`prog\*(C' will be significantly faster.</p><p>    #!/usr/local/bin/perl -w     use strict;     use File::Find;  # for recursing a directory tree</p><p>    $/ = undef;     find(         { wanted =&gt; &#92;&wanted, no_chdir =&gt; 1, },         '.',     );</p><p>    sub wanted {         return if -d;         return unless /&#92;.html$/;</p><p>        my $mtime  = (stat)[9];</p><p>        my $child = open( FH, '-|' );         die "Failed to fork $!" unless defined $child;         exec '/bin/cat', $_ unless $child;</p><p>        my $content = &lt;FH&gt;;         my $size = length $content;</p><p>        print &lt;&lt;EOF;     Content-Length: $size     Last-Mtime: $mtime     Path-Name: $_</p><p>    EOF</p><p>        print &lt;FH&gt;;     }</p><p>And index with the command:</p><p>    swish-e -S prog -i ./catfilter.pl -v 1</p><p>This example will probably not work under Windows due to the '-|' open. A simple piped open may work just as well:</p><p>That is, replace:</p><p>    my $child = open( FH, '-|' );     die "Failed to fork $!" unless defined $child;     exec '/bin/cat', $_ unless $child;</p><p>with this:</p><p>    open( FH, "/bin/cat $_ |" ) or die $!;</p><p>Perl will try to avoid running the command through the shell if meta characters are not passed to the open.  See \*(C`perldoc -f open\*(C' for more information.</p><p><em>Eh, but I just want to know how to index \s-1PDF\s0 documents!</em></p><p>See the examples in the <em>conf</em> directory and the comments in the <em>SwishSpiderConfig.pl</em> file.</p><p>See the previous question for the details on filtering.  The method you decide to use will depend on how fast you want to index, and your comfort level with using Perl modules.</p><p>Regardless of the filtering method you use you will need to install the Xpdf packages available from http://www.foolabs.com/xpdf/.</p><p><em>I'm using Windows and can't get Filters or the prog input method to work!</em></p><p>Both the \*(C`-S prog\*(C' input method and filters use the \*(C`popen()\*(C' system call to run the external program.  If your external program is, for example, a perl script, you have to tell Swish-e to run perl, instead of the script.  Swish-e will convert forward slashes to backslashes when running under Windows.</p><p>For example, you would need to specify the path to perl as (assuming this is where perl is on your system):</p><p>    IndexDir e:/perl/bin/perl.exe</p><p>Or run a filter like:</p><p>    FileFilter .foo e:/perl/bin/perl.exe 'myscript.pl "%p"'</p><p>It's often easier to just install Linux.</p><p><em>How do I index non-English words?</em></p><p>Swish-e indexes 8-bit characters only.  This is the \s-1ISO\s0 8859-1 Latin-1 character set, and includes many non-English letters (and symbols). As long as they are listed in \*(C`WordCharacters\*(C' they will be indexed.</p><p>Actually, you probably can index any 8-bit character set, as long as you don't mix character sets in the same index and don't use libxml2 for parsing (see below).</p><p>The \*(C`TranslateCharacters\*(C' directive (SWISH-CONFIG) can translate characters while indexing and searching.  You may specify the mapping of one character to another character with the \*(C`TranslateCharacters\*(C' directive.</p><p>\*(C`TranslateCharacters :ascii7:\*(C' is a predefined set of characters that will translate eight-bit characters to ascii7 characters.  Using the \*(C`:ascii7:\*(C' rule will, for example, translate \*(L"Ääç\*(R" to \*(L"aac\*(R".  This means: searching \*(L"Çelik\*(R", \*(L"çelik\*(R" or \*(L"celik\*(R" will all match the same word.</p><p>Note: When using libxml2 for parsing, parsed documents are converted internally (within libxml2) to \s-1UTF-8\s0.  This is converted to \s-1ISO\s0 8859-1 Latin-1 when indexing.  In cases where a string can not be converted from \s-1UTF-8\s0 to \s-1ISO\s0 8859-1 (because it contains non 8859-1 characters), the string will be sent to Swish-e in \s-1UTF-8\s0 encoding.  This will results in some words indexed incorrectly.  Setting \*(C`ParserWarningLevel\*(C' to 1 or more will display warnings when \s-1UTF-8\s0 to 8859-1 conversion fails.</p><p><em>Can I add/remove files from an index?</em></p><p>Try building swish-e with the \*(C`--enable-incremental\*(C' option.</p><p>The rest of this \s-1FAQ\s0 applies to the default swish-e format.</p><p>Swish-e currently has no way to add or remove items from its index.  But, Swish-e indexes so quickly that it's often possible to reindex the entire document set when a file needs to be added, modified or removed. If you are spidering a remote site then consider caching documents locally compressed.</p><p>Incremental additions can be handled in a couple of ways, depending on your situation.  It's probably easiest to create one main index every night (or every week), and then create an index of just the new files between main indexing jobs and use the \*(C`-f\*(C' option to pass both indexes to Swish-e while searching.</p><p>You can merge the indexes into one index (instead of using -f), but it's not clear that this has any advantage over searching multiple indexes.</p><p>How does one create the incremental index?</p><p>One method is by using the \*(C`-N\*(C' switch to pass a file path to Swish-e when indexing.  It will only index files that have a last modification date \*(C`newer\*(C' than the file supplied with the \*(C`-N\*(C' switch.</p><p>This option has the disadvantage that Swish-e must process every file in every directory as if they were going to be indexed (the test for \*(C`-N\*(C' is done last right before indexing of the file contents begin and after all other tests on the file have been completed) \*(-- all that just to find a few new files.</p><p>Also, if you use the Swish-e index file as the file passed to \*(C`-N\*(C' there may be files that were added after indexing was started, but before the index file was written.  This could result in a file not being added to the index.</p><p>Another option is to maintain a parallel directory tree that contains symlinks pointing to the main files.  When a new file is added (or changed) to the main directory tree you create a symlink to the real file in the parallel directory tree.  Then just index the symlink directory to generate the incremental index.</p><p>This option has the disadvantage that you need to have a central program that creates the new files that can also create the symlinks. But, indexing is quite fast since Swish-e only has to look at the files that need to be indexed.  When you run full indexing you simply unlink (delete) all the symlinks.</p><p>Both of these methods have issues where files could end up in both indexes, or files being left out of an index.  Use of file locks while indexing, and hash lookups during searches can help prevent these problems.</p><p><em>I run out of memory trying to index my files.</em></p><p>It's true that indexing can take up a lot of memory!  Swish-e is extremely fast at indexing, but that comes at the cost of memory.</p><p>The best answer is install more memory.</p><p>Another option is use the \*(C`-e\*(C' switch.  This will require less memory, but indexing will take longer as not all data will be stored in memory while indexing.  How much less memory and how much more time depends on the documents you are indexing, and the hardware that you are using.</p><p>Here's an example of indexing all .html files in /usr/doc on Linux. This first example is <em>without</em> \*(C`-e\*(C' and used about 84M of memory:</p><p>    270279 unique words indexed.     23841 files indexed.  177640166 total bytes.     Elapsed time: 00:04:45 CPU time: 00:03:19</p><p>This is <em>with</em> \*(C`-e\*(C', and used about 26M or memory:</p><p>    270279 unique words indexed.     23841 files indexed.  177640166 total bytes.     Elapsed time: 00:06:43 CPU time: 00:04:12</p><p>You can also build a number of smaller indexes and then merge together with \*(C`-M\*(C'.  Using \*(C`-e\*(C' while merging will save memory.</p><p>Finally, if you do build a number of smaller indexes, you can specify more than one index when searching by using the \*(C`-f\*(C' switch.  Sorting large results sets by a property will be slower when specifying multiple index files while searching.</p><p><em>\*(L"too many open files\*(R" when indexing with -e option</em></p><p>Some platforms report \*(L"too many open files\*(R" when using the -e economy option. The -e feature uses many temporary files (something like 377) plus the index files and this may exceed your system's limits.</p><p>Depending on your platform you may need to set \*(L"ulimit\*(R" or \*(L"unlimit\*(R".</p><p>For example, under Linux bash shell:</p><p>  $ ulimit -n 1024</p><p>Or under an old Sparc</p><p>  % unlimit openfiles</p><p><em>My system admin says Swish-e uses too much of the \s-1CPU\s0!</em></p><p>That's a good thing!  That expensive \s-1CPU\s0 is supposed to be busy.</p><p>Indexing takes a lot of work \*(-- to make indexing fast much of the work is done in memory which reduces the amount of time Swish-e is waiting on I/O. But, there's two things you can try:</p><p>The \*(C`-e\*(C' option will run Swish-e in economy mode, which uses the disk to store data while indexing.  This makes Swish-e run somewhat slower, but also uses less memory.  Since it is writing to disk more often it will be spending more time waiting on I/O and less time in \s-1CPU\s0.  Maybe.</p><p>The other thing is to simply lower the priority of the job using the <em>nice</em>\|(1) command:</p><p>    /bin/nice -15 swish-e -c search.conf</p><p>If concerned about searching time, make sure you are using the -b and -m switches to only return a page at a time.  If you know that your result sets will be large, and that you wish to return results one page at a time, and that often times many pages of the same query will be requested, you may be smart to request all the documents on the first request, and then cache the results to a temporary file.  The perl module File::Cache makes this very simple to accomplish. <em>How can I index documents on a web server?</em></p><p>If possible, use the file system method \*(C`-S fs\*(C' of indexing to index documents in you web area of the file system.  This avoids the overhead of spidering a web server and is much faster.  (\*(C`-S fs\*(C' is the default method if \*(C`-S\*(C' is not specified).</p><p>If this is impossible (the web server is not local, or documents are dynamically generated), Swish-e provides two methods of spidering. First, it includes the http method of indexing \*(C`-S http\*(C'. A number of special configuration directives are available that control spidering (see \*(L"Directives for the \s-1HTTP\s0 Access Method Only\*(R" in SWISH-CONFIG).  A perl helper script (swishspider) is included in the <em>src</em> directory to assist with spidering web servers. There are example configurations for spidering in the <em>conf</em> directory.</p><p>As of Swish-e 2.2, there's a general purpose \*(L"prog\*(R" document source where a program can feed documents to it for indexing.  A number of example programs can be found in the \*(C`prog-bin\*(C' directory, including a program to spider web servers.  The provided spider.pl program is full-featured and is easily customized.</p><p>The advantage of the \*(L"prog\*(R" document source feature over the \*(L"http\*(R" method is that the program is only executed one time, where the swishspider.pl program used in the \*(L"http\*(R" method is executed once for every document read from the web server.  The forking of Swish-e and compiling of the perl script can be quite expensive, time-wise.</p><p>The other advantage of the \*(C`spider.pl\*(C' program is that it's simple and efficient to add filtering (such as for \s-1PDF\s0 or \s-1MS\s0 Word docs) right into the spider.pl's configuration, and it includes features such as \s-1MD5\s0 checks to prevent duplicate indexing, options to avoid spidering some files, or index but avoid spidering.  And since it's a perl program there's no limit on the features you can add.</p><p><em>Why does swish report \*(L"./swishspider: not found\*(R"?</em></p><p>Does the file <em>swishspider</em> exist where the error message displays?  If not, either set the configuration option SpiderDirectory to point to the directory where the <em>swishspider</em> program is found, or place the <em>swishspider</em> program in the current directory when running swish-e.</p><p>If you are running Windows, make sure \*(L"perl\*(R" is in your path.  Try typing <em>perl</em> from a command prompt.</p><p>If you not running windows, make sure that the shebang line (the first line of the swishspider program that starts with #!) points to the correct location of perl. Typically this will be <em>/usr/bin/perl</em> or <em>/usr/local/bin/perl</em>.  Also, make sure that you have execute and read permissions on <em>swishspider</em>.</p><p>The <em>swishspider</em> perl script is only used with the -S http method of indexing.</p><p><em>I'm using the spider.pl program to spider my web site, but some large files are not indexed.</em></p><p>The \*(C`spider.pl\*(C' program has a default limit of 5MB file size.  This can be changed with the \*(C`max_size\*(C' parameter setting.  See \*(C`perldoc spider.pl\*(C' for more information.</p><p><em>I still don't think all my web pages are being indexed.</em></p><p>The <em>spider.pl</em> program has a number of debugging switches and can be quite verbose in telling you what's happening, and why.  See \*(C`perldoc spider.pl\*(C' for instructions.</p><p><em>Swish is not spidering Javascript links!</em></p><p>Swish cannot follow links generated by Javascript, as they are generated by the browser and are not part of the document.</p><p><em>How do I spider other websites and combine it with my own (filesystem) index?</em></p><p>You can either merge \*(C`-M\*(C' two indexes into a single index, or use \*(C`-f\*(C' to specify more than one index while searching.</p><p>You will have better results with the \*(C`-f\*(C' method. <em>How do I limit searches to just parts of the index?</em></p><p>If you can identify \*(L"parts\*(R" of your index by the path name you have two options.</p><p>The first options is by indexing the document path.  Add this to your configuration:</p><p>    MetaNames swishdocpath</p><p>Now you can search for words or phrases in the path name:</p><p>    swish-e -w 'foo AND swishdocpath=(sales)'</p><p>So that will only find documents with the word \*(L"foo\*(R" and where the file's path contains \*(L"sales\*(R".  That might not works as well as you like, though, as both of these paths will match:</p><p>    /web/sales/products/index.html     /web/accounting/private/sales_we_messed_up.html</p><p>This can be solved by searching with a phrase (assuming \*(L"/\*(R" is not a WordCharacter):</p><p>    swish-e -w 'foo AND swishdocpath=("/web/sales/")'     swish-e -w 'foo AND swishdocpath=("web sales")'  (same thing)</p><p>The second option is a bit more powerful.  With the \*(C`ExtractPath\*(C' directive you can use a regular expression to extract out a sub-set of the path and save it as a separate meta name:</p><p>    MetaNames department     ExtractPath department regex !^/web/([^/]+).+$!$1/</p><p>Which says match a path that starts with \*(L"/web/\*(R" and extract out everything after that up to, but not including the next \*(L"/\*(R" and save it in variable $1, and then match everything from the \*(L"/\*(R" onward.  Then replace the entire matches string with $1.  And that gets indexed as meta name \*(L"department\*(R".</p><p>Now you can search like:</p><p>    swish-e -w 'foo AND department=sales'</p><p>and be sure that you will only match the documents in the /www/sales/* path.  Note that you can map completely different areas of your file system to the same metaname:</p><p>    # flag the marketing specific pages     ExtractPath department regex !^/web/(marketing|sales)/.+$!marketing/     ExtractPath department regex !^/internal/marketing/.+$!marketing/</p><p>    # flag the technical departments pages     ExtractPath department regex !^/web/(tech|bugs)/.+$!tech/</p><p>Finally, if you have something more complicated, use \*(C`-S prog\*(C' and write a perl program or use a filter to set a meta tag when processing each file.</p><p><em>How is ranking calculated?</em></p><p>The \*(C`swishrank\*(C' property value is calculated based on which Ranking Scheme (or algorithm) you have selected. In this discussion, any time the word <strong>fancy</strong> is used, you should consult the actual code for more details. It is open source, after all.</p><p>Things you can do to affect ranking:</p>
<dl class='dl-vertical'>
  <dt>
    MetaNamesRank
  </dt>
  <dd>
    <p>You may configure your index to bias certain metaname values more or less than others. See the \*(C`MetaNamesRank\*(C' configuration option in SWISH-CONFIG.</p>
  </dd>
  <dt>
    IgnoreTotalWordCountWhenRanking
  </dt>
  <dd>
    <p>Set to 1 (default) or 0 in your config file. See SWISH-CONFIG. <strong>\s-1NOTE:\s0</strong> You must set this to 0 to use the \s-1IDF\s0 Ranking Scheme.</p>
  </dd>
  <dt>
    structure
  </dt>
  <dd>
    <p>Each term's position in each \s-1HTML\s0 document is given a structure value based on the context in which the word appears. The structure value is used to artificially inflate the frequency of each term in that particular document. These structural values are defined in <em>config.h</em>:  #define RANK_TITLE             7  #define RANK_HEADER            5  #define RANK_META              3  #define RANK_COMMENTS          1  #define RANK_EMPHASIZED        0 For example, if the word \*(C`foo\*(C' appears in the title of a document, the Scheme will treat that document as if \*(C`foo\*(C' appeared 7 additional times.</p>
  </dd>

</dl>
<p>All Schemes share the following characteristics:</p>
<dl class='dl-vertical'>
  <dt>
    \s-1AND\s0 searches
  </dt>
  <dd>
    <p>The rank value is averaged for all \s-1AND\s0'd terms. Terms within a set of parentheses () are averaged as a single term (this is an acknowledged weakness and is on the \s-1TODO\s0 list).</p>
  </dd>
  <dt>
    \s-1OR\s0 searches
  </dt>
  <dd>
    <p>The rank value is summed and then doubled for each pair of \s-1OR\s0'd terms. This results in higher ranks for documents that have multiple \s-1OR\s0'd terms.</p>
  </dd>
  <dt>
    scaled rank
  </dt>
  <dd>
    <p>After a document's raw rank score is calculated, a final rank score is calculated using a fancy \*(C`log()\*(C' function. All the documents are then scaled against a base score of 1000. The top-ranked document will therefore always have a \*(C`swishrank\*(C' value of 1000.</p>
  </dd>

</dl>
<p>Here is a brief overview of how the different Schemes work. The number in parentheses after the name is the value to invoke that scheme with \*(C`swish-e -R\*(C' or \*(C`RankScheme()\*(C'.</p>
<dl class='dl-vertical'>
  <dt>
    Default (0)
  </dt>
  <dd>
    <p>The default ranking scheme considers the number of times a term appears in a document (frequency), the MetaNamesRank and the structure value. The rank might be summarized as:  DocRank = Sum of ( structure + metabias ) Consider this output with the \s-1DEBUG_RANK\s0 variable set at compile time:  Ranking Scheme: 0  Word entry 0 at position 6 has struct 7  Word entry 1 at position 64 has struct 41  Word entry 2 at position 71 has struct 9  Word entry 3 at position 132 has struct 9  Word entry 4 at position 154 has struct 9  Word entry 5 at position 423 has struct 73  Word entry 6 at position 541 has struct 73  Word entry 7 at position 662 has struct 73  File num: 1104.  Raw Rank: 21.  Frequency: 8 scaled rank: 30445   Structure tally:   struct 0x7 = count of 1 ( HEAD TITLE FILE ) x rank map of 8 = 8   struct 0x9 = count of 3 ( BODY FILE ) x rank map of 1 = 3   struct 0x29 = count of 1 ( HEADING BODY FILE ) x rank map of 6 = 6   struct 0x49 = count of 3 ( EM BODY FILE ) x rank map of 1 = 3 Every word instance starts with a base score of 1. Then for each instance of your word, a running sum is taken of the structural value of that word position plus any bias you've configured. In the example above, the raw rank is \*(C`1 + 8 + 3 + 6 + 3 = 21\*(C'. Consider this line:   struct 0x7 = count of 1 ( HEAD TITLE FILE ) x rank map of 8 = 8 That means there was one instance of our word in the title of the file. It's context was in the &lt;head&gt; tagset, inside the &lt;title&gt;. The &lt;title&gt; is the most specific structure, so it gets the \s-1RANK_TITLE\s0 score: 7. The base rank of 1 plus the structure score of 7 equals 8. If there had been two instances of this word in the title, then the score would have been \*(C`8 + 8 = 16\*(C'.</p>
  </dd>
  <dt>
    \s-1IDF\s0 (1)
  </dt>
  <dd>
    <p>\s-1IDF\s0 is short for Inverse Document Frequency. That's fancy ranking lingo for taking into account the total frequency of a term across the entire index, in addition to the term's frequency in a single document. \s-1IDF\s0 ranking also uses the relative density of a word in a document to judge its relevancy. Words that appear more often in a doc make that doc's rank higher, and longer docs are not weighted higher than shorter docs. The \s-1IDF\s0 Scheme might be summarized as:   DocRank = Sum of ( density * idf * ( structure + metabias ) ) Consider this output from \s-1DEBUG_RANK:\s0  Ranking Scheme: 1  File num: 1104  Word Score: 1  Frequency: 8  Total files: 1451  Total word freq: 108   IDF: 2564  Total words: 1145877   Indexed words in this doc: 562  Average words: 789   Density: 1120    Word Weight: 28716  Word entry 0 at position 6 has struct 7  Word entry 1 at position 64 has struct 41  Word entry 2 at position 71 has struct 9  Word entry 3 at position 132 has struct 9  Word entry 4 at position 154 has struct 9  Word entry 5 at position 423 has struct 73  Word entry 6 at position 541 has struct 73  Word entry 7 at position 662 has struct 73  Rank after IDF weighting: 574321  scaled rank: 132609   Structure tally:   struct 0x7 = count of  1 ( HEAD TITLE FILE ) x rank map of 8 = 8   struct 0x9 = count of  3 ( BODY FILE ) x rank map of 1 = 3   struct 0x29 = count of  1 ( HEADING BODY FILE ) x rank map of 6 = 6   struct 0x49 = count of  3 ( EM BODY FILE ) x rank map of 1 = 3 It is similar to the default Scheme, but notice how the total number of files in the index and the total word frequency (as opposed to the document frequency) are both part of the equation.</p>
  </dd>

</dl>
<p>Ranking is a complicated subject. SWISH-E allows for more Ranking Schemes to be developed and experimented with, using the -R option (from the swish-e command) and the RankScheme (see the \s-1API\s0 documentation). Experiment and share your findings via the discussion list.</p><p><em>How can I limit searches to the title, body, or comment?</em></p><p>Use the \*(C`-t\*(C' switch.</p><p><em>I can't limit searches to title/body/comment.</em></p><p>Or, <em>I can't search with meta names, all the names are indexed as</em> \*(L"plain\*(R".</p><p>Check in the config.h file if #define \s-1INDEXTAGS\s0 is set to 1. If it is, change it to 0, recompile, and index again.  When \s-1INDEXTAGS\s0 is 1, \s-1ALL\s0 the tags are indexed as plain text, that is you index \*(L"title\*(R", \*(L"h1\*(R", and so on, \s-1AND\s0 they loose their indexing meaning.  If \s-1INDEXTAGS\s0 is set to 0, you will still index meta tags and comments, unless you have indicated otherwise in the user config file with the IndexComments directive.</p><p>Also, check for the \*(C`UndefinedMetaTags\*(C' setting in your configuration file.</p><p><em>I've tried running the included \s-1CGI\s0 script and I get a \*(L"Internal Server Error\*(R"</em></p><p>Debugging \s-1CGI\s0 scripts are beyond the scope of this document. Internal Server Error basically means \*(L"check the web server's log for an error message\*(R", as it can mean a bad shebang (#!) line, a missing perl module, \s-1FTP\s0 transfer error, or simply an error in the program. The \s-1CGI\s0 script <em>swish.cgi</em> in the <em>example</em> directory contains some debugging suggestions.  Type \*(C`perldoc swish.cgi\*(C' for information.</p><p>There are also many, many \s-1CGI\s0 FAQs available on the Internet.  A quick web search should offer help.  As a last resort you might ask your webadmin for help...</p><p><em>When I try to view the swish.cgi page I see the contents of the Perl program.</em></p><p>Your web server is not configured to run the program as a \s-1CGI\s0 script. This problem is described in \*(C`perldoc swish.cgi\*(C'.</p><p><em>How do I make Swish-e highlight words in search results?</em></p><p>Short answer:</p><p>Use the supplied swish.cgi or search.cgi scripts located in the <em>example</em> directory.</p><p>Long answer:</p><p>Swish-e can't because it doesn't have access to the source documents when returning results, of course.  But a front-end program of your creation can highlight terms.  Your program can open up the source documents and then use regular expressions to replace search terms with highlighted or bolded words.</p><p>But, that will fail with all but the most simple source documents. For \s-1HTML\s0 documents, for example, you must parse the document into words and tags (and comments).  A word you wish to highlight may span multiple \s-1HTML\s0 tags, or be a word in a \s-1URL\s0 and you wish to highlight the entire link text.</p><p>Perl modules such as HTML::Parser and XML::Parser make word extraction possible.  Next, you need to consider that Swish-e uses settings such as WordCharacters, BeginCharacters, EndCharacters, IgnoreFirstChar, and IgnoreLast, char to define a \*(L"word\*(R".  That is, you can't consider that a string of characters with white space on each side is a word.</p><p>Then things like TranslateCharacters, and \s-1HTML\s0 Entities may transform a source word into something else, as far as Swish-e is concerned.  Finally, searches can be limited by metanames, so you may need to limit your highlighting to only parts of the source document.  Throw phrase searches and stopwords into the equation and you can see that it's not a trivial problem to solve.</p><p>All hope is not lost, thought, as Swish-e does provide some help. Using the \*(C`-H\*(C' option it will return in the headers the current index (or indexes) settings for WordCharacters (and others) required to parse your source documents as it parses them during indexing, and will return a \*(L"Parsed Words:\*(R" header that will show how it parsed the query internally. If you use fuzzy indexing (word stemming, soundex, or metaphone) then you will also need to stem each word in your document before comparing with the \*(L"Parsed Words:\*(R" returned by Swish-e.</p><p>The Swish-e stemming code is available either by using the Swish-e Perl module (\s-1SWISH::API\s0) or the C library (included with the swish-e distribution), or by using the SWISH::Stemmer module available on \s-1CPAN\s0.  Also on \s-1CPAN\s0 is the module Text::DoubleMetaphone.  Using \s-1SWISH::API\s0 probably provides the best stemming support.</p><p><em>Do filters effect the performance during search?</em></p><p>No.  Filters (FileFilter or via \*(L"prog\*(R" method) are only used for building the search index database.  During search requests there will be no filter calls. The Swish-e discussion list is the place to go.  http://swish-e.org/. Please do not email developers directly.  The list is the best place to ask questions.</p><p>Before you post please read <em>\s-1QUESTIONS\s0 \s-1AND\s0 \s-1TROUBLESHOOTING\s0</em> located in the \s-1INSTALL\s0 page.  You should also search the Swish-e discussion list archive which can be found on the swish-e web site.</p><p>In short, be sure to include in the following when asking for help.</p>
<dl class='dl-vertical'>
  <dt>
    * The swish-e version (./swish-e -V)
  </dt>
  <dd>
    
  </dd>
  <dt>
    * What you are indexing (and perhaps a sample), and the number of files
  </dt>
  <dd>
    
  </dd>
  <dt>
    * Your Swish-e configuration file
  </dt>
  <dd>
    
  </dd>
  <dt>
    * Any error messages that Swish-e is reporting
  </dt>
  <dd>
    
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Document Info</h2>
        <div class="sectioncontent">
<p>$Id: \s-1SWISH-FAQ\s0.pod 2147 2008-07-21 02:48:55Z karpet $</p><p>.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="SWISH-CONFIG.1.html"><span aria-hidden="true">&larr;</span> SWISH-CONFIG.1: Configuration file directives</a></li>
   <li class="next"><a href="SWISH-LIBRARY.1.html">SWISH-LIBRARY.1: Interface to the swish-e c library <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

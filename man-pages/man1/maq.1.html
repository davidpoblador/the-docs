<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>maq: Mapping and assembly with qualities</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Mapping and assembly with qualities">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="maq (1) manual">
  <meta name="twitter:description" content="Mapping and assembly with qualities">
  <meta name="twitter:image" content="https://www.carta.tech/images/maq-maq-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/maq.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="maq (1) manual" />
  <meta property="og:description" content="Mapping and assembly with qualities" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/maq-maq-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">maq<small> (1)</small></h1>
        <p class="lead">Mapping and assembly with qualities</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/maq.1.html">
      <span itemprop="name">maq: Mapping and assembly with qualities</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/maq/">
      <span itemprop="name">maq</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/maq.1.html">
      <span itemprop="name">maq: Mapping and assembly with qualities</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>maq</strong> <em>command</em> [<em>options</em>] <em>arguments</em></p><p><strong>maq.pl</strong> <em>command</em> [<em>options</em>] <em>arguments</em></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Maq is a software that builds mapping assemblies from short reads generated by the next-generation sequencing machines. It is particularly designed for Illumina-Solexa 1G Genetic Analyzer, and has a preliminary functionality to handle \s-1AB\s0 SOLiD data.</p><p>With Maq you can:</p><ul>
<li><p>Fast align Illumina/SOLiD reads to the reference genome. With the default options, one million pairs of reads can be mapped to the human genome in about 10 \s-1CPU\s0 hours with less than 1G memory.</p></li><li><p>Accurately measure the error probability of the alignment of each individual read.</p></li><li><p>Call the consensus genotypes, including homozygous and heterozygous polymorphisms, with a Phred probabilistic quality assigned to each base.</p></li><li><p>Find short indels with paired end reads.</p></li><li><p>Accurately find large scale genomic deletions and translocations with paired end reads.</p></li><li><p>Discover potential CNVs by checking read depth.</p></li><li><p>Evaluate the accuracy of raw base qualities from sequencers and help to check the systematic errors.</p></li>
</ul><p>However, Maq can <strong>\s-1NOT\s0</strong>:</p><ul>
<li><p>Do <em>de novo</em> assembly. (Maq can only call the consensus by mapping reads to a known reference.)</p></li><li><p>Map shorts reads against themselves. (Maq can only find complete overlap between reads.)</p></li><li><p>Align capillary reads or 454 reads to the reference. (Maq cannot align reads longer than 63bp.)</p></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MAQ COMMANDS</h2>
        <div class="sectioncontent">
<p><strong>&#92;$1</strong></p>
<dl class='dl-vertical'>
  <dt>
    <strong>fasta2bfa</strong>
  </dt>
  <dd>
    <p><strong>maq</strong> <strong>fasta2bfa</strong> <em>in.ref.fasta</em> <em>out.ref.bfa</em> Convert sequences in \s-1FASTA\s0 format to Maq's \s-1BFA\s0 (binary \s-1FASTA\s0) format.</p>
  </dd>
  <dt>
    <strong>fastq2bfq</strong>
  </dt>
  <dd>
    <p><strong>maq</strong> <strong>fastq2bfq</strong> [<strong>-n</strong> <em>nreads</em>] <em>in.read.fastq</em> <em>out.read.bfq</em>|<em>out.prefix</em> Convert reads in \s-1FASTQ\s0 format to Maq's \s-1BFQ\s0 (binary \s-1FASTQ\s0) format. <strong>\s-1OPTIONS:\s0</strong></p>
<dl class='dl-vertical'>
  <dt>
    <strong>-n</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>number of reads per file [not specified]</p>
  </dd>

</dl>

  </dd>
  <dt>
    <strong>map</strong>
  </dt>
  <dd>
    <p><strong>maq</strong> <strong>map</strong> [<strong>-n</strong> <em>nmis</em>] [<strong>-a</strong> <em>maxins</em>] [<strong>-c</strong>] [<strong>-1</strong> <em>len1</em>] [<strong>-2</strong> <em>len2</em>] [<strong>-d</strong> <em>adap3</em>] [<strong>-m</strong> <em>mutrate</em>] [<strong>-u</strong> <em>unmapped</em>] [-e <em>maxerr</em>] [<strong>-M</strong> c|g] [<strong>-N</strong>] [<strong>-H</strong> <em>allhits</em>] [<strong>-C</strong> <em>maxhits</em>] <em>out.aln.map</em> <em>in.ref.bfa</em> <em>in.read1.bfq</em> [<em>in.read2.bfq</em>] 2&gt; <em>out.map.log</em> Map reads to the reference sequences. <strong>\s-1OPTIONS:\s0</strong></p>
<dl class='dl-vertical'>
  <dt>
    <strong>-n</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>Number of maximum mismatches that can always be found [2]</p>
  </dd>
  <dt>
    <strong>-a</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>Maximum outer distance for a correct read pair [250]</p>
  </dd>
  <dt>
    <strong>-A</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>Maximum outer distance of two \s-1RF\s0 paied read (0 for disable) [0]</p>
  </dd>
  <dt>
    <strong>-c</strong>
  </dt>
  <dd>
    <p>Map reads in the colour space (for SOLiD only)</p>
  </dd>
  <dt>
    <strong>-1</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>Read length for the first read, 0 for auto [0]</p>
  </dd>
  <dt>
    <strong>-2</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>Read length for the second read, 0 for auto [0]</p>
  </dd>
  <dt>
    <strong>-m</strong> <em>\s-1FLOAT\s0</em>
  </dt>
  <dd>
    <p>Mutation rate between the reference sequences and the reads [0.001]</p>
  </dd>
  <dt>
    <strong>-d</strong> <em>\s-1FILE\s0</em>
  </dt>
  <dd>
    <p>Specify a file containing a single line of the 3'-adapter sequence [null]</p>
  </dd>
  <dt>
    <strong>-u</strong> <em>\s-1FILE\s0</em>
  </dt>
  <dd>
    <p>Dump unmapped reads and reads containing more than <em>nmis</em> mismatches to a separate file [null]</p>
  </dd>
  <dt>
    <strong>-e</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>Threshold on the sum of mismatching base qualities [70]</p>
  </dd>
  <dt>
    <strong>-H</strong> <em>\s-1FILE\s0</em>
  </dt>
  <dd>
    <p>Dump multiple/all 01-mismatch hits to <em>\s-1FILE\s0</em> [null]</p>
  </dd>
  <dt>
    <strong>-C</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>Maximum number of hits to output. Unlimited if larger than 512. [250]</p>
  </dd>
  <dt>
    <strong>-M</strong> c|g
  </dt>
  <dd>
    <p>methylation alignment mode. All C (or G) on the forward strand will be changed to T (or A). This option is for testing only.</p>
  </dd>
  <dt>
    <strong>-N</strong>
  </dt>
  <dd>
    <p>store the mismatch position in the output file <em>out.aln.map</em>. When this option is in use, the maximum allowed read length is 55bp.</p>
  </dd>

</dl>
<p><strong>\s-1NOTE:\s0</strong></p><ul>
<li><p>Paired end reads should be prepared in two files, one for each end, with reads are sorted in the same order. This means the k-th read in the first file is mated with the k-th read in the second file. The corresponding read names must be identical up to the tailing `/1' or `/2'. For example, such a pair of read names are allowed: `\s-1EAS1_1_5_100_200/1\s0' and `\s-1EAS1_1_5_100_200/2\s0'. The tailing `/[12]' is usually generated by the GAPipeline to distinguish the two ends in a pair.</p></li><li><p>The output is a compressed binary file. It is affected by the endianness.</p></li><li><p>The best way to run this command is to provide about 1 to 3 million reads as input. More reads consume more memory.</p></li><li><p>Option <strong>-n</strong> controls the sensitivity of the alignment. By default, a hit with up to 2 mismatches can be always found. Higher <strong>-n</strong> finds more hits and also improves the accuracy of mapping qualities. However, this is done at the cost of speed.</p></li><li><p>Alignments with many high-quality mismatches should be discarded as false alignments or possible contaminations. This behaviour is controlled by option <strong>-e</strong>. The <strong>-e</strong> threshold is only calculated approximately because base qualities are divided by 10 at a certain stage of the alignment. The <strong>-Q</strong> option in the <strong>assemble</strong> command precisely set the threshold.</p></li><li><p>A pair of reads are said to be correctly paired if and only if the orientation is <em>\s-1FR\s0</em> and the outer distance of the pair is no larger than <em>maxins</em>. There is no limit on the minimum insert size. This setting is determined by the paired end alignment algorithm used in Maq. Requiring a minimum insert size will lead to some wrong alignments with highly overestimated mapping qualities.</p></li><li><p>Currently, read pairs from Illumina/Solexa long-insert library have \s-1RF\s0 read orientation. The maximum insert size is set by option <strong>-A</strong>. However, long-insert library is also mixed with a small fraction of short-insert read pairs. <strong>-a</strong> should also be set correctly.</p></li><li><p>Sometimes 5'-end or even the entire 3'-adapter sequence may be sequenced. Providing <strong>-d</strong> renders Maq to eliminate the adapter contaminations.</p></li><li><p>Given 2 million reads as input, <strong>maq</strong> usually takes 800MB memory.</p></li>
</ul>
  </dd>
  <dt>
    <strong>mapmerge</strong>
  </dt>
  <dd>
    <p><strong>maq</strong> <strong>mapmerge</strong> <em>out.aln.map</em> <em>in.aln1.map</em> <em>in.aln2.map</em> [...] Merge a batch of read alignments together. <strong>\s-1NOTE:\s0</strong></p><ul>
<li><p>In theory, this command can merge unlimited number of alignments. However, as mapmerge will be reading all the inputs at the same time, it may hit the limit of the maximum number of opening files set by the \s-1OS\s0. At present, this has to be manually solved by endusers.</p></li><li><p>Command <strong>mapmerge</strong> can be used to merge alignment files with different read lengths. All the subsequent analyses do not assume fixed length any more.</p></li>
</ul>
  </dd>
  <dt>
    <strong>rmdup</strong>
  </dt>
  <dd>
    <p><strong>maq</strong> <strong>rmdup</strong> <em>out.rmdup.map</em> <em>in.ori.map</em> Remove pairs with identical outer coordinates. In principle, pairs with identical outer coordinates should happen rarely. However, due to the amplification in sample preparation, this occurs much more frequently than by chance. Practical analyses show that removing duplicates helps to improve the overall accuracy of \s-1SNP\s0 calling.</p>
  </dd>
  <dt>
    <strong>assemble</strong>
  </dt>
  <dd>
    <p><strong>maq</strong> <strong>assemble</strong> [<strong>-sp</strong>] [<strong>-m</strong> <em>maxmis</em>] [<strong>-Q</strong> <em>maxerr</em>] [<strong>-r</strong> <em>hetrate</em>] [<strong>-t</strong> <em>coef</em>] [<strong>-q</strong> <em>minQ</em>] [<strong>-N</strong> <em>nHap</em>] <em>out.cns</em> <em>in.ref.bfa</em> <em>in.aln.map</em> 2&gt; <em>out.cns.log</em> Call the consensus sequences from read mapping. <strong>\s-1OPTIONS:\s0</strong></p>
<dl class='dl-vertical'>
  <dt>
    <strong>-t</strong> <em>\s-1FLOAT\s0</em>
  </dt>
  <dd>
    <p>Error dependency coefficient [0.93]</p>
  </dd>
  <dt>
    <strong>-r</strong> <em>\s-1FLOAT\s0</em>
  </dt>
  <dd>
    <p>Fraction of heterozygotes among all sites [0.001]</p>
  </dd>
  <dt>
    <strong>-s</strong>
  </dt>
  <dd>
    <p>Take single end mapping quality as the final mapping quality; otherwise paired end mapping quality will be used</p>
  </dd>
  <dt>
    <strong>-p</strong>
  </dt>
  <dd>
    <p>Discard paired end reads that are not mapped in correct pairs</p>
  </dd>
  <dt>
    <strong>-m</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>Maximum number of mismatches allowed for a read to be used in consensus calling [7]</p>
  </dd>
  <dt>
    <strong>-Q</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>Maximum allowed sum of quality values of mismatched bases [60]</p>
  </dd>
  <dt>
    <strong>-q</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>Minimum mapping quality allowed for a read to be used in consensus calling [0]</p>
  </dd>
  <dt>
    <strong>-N</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>Number of haplotypes in the pool (&gt;=2) [2]</p>
  </dd>

</dl>
<p><strong>\s-1NOTE:\s0</strong></p><ul>
<li><p>Option <strong>-Q</strong> sets a limit on the maximum sum of mismatching base qualities. Reads containing many high-quality mismatches should be discarded.</p></li><li><p>Option <strong>-N</strong> sets the number of haplotypes in a pool. It is designed for resequencing of samples by pooling multiple strains/individuals together. For diploid genome resequencing, this option equals 2.</p></li>
</ul>
  </dd>
  <dt>
    <strong>glfgen</strong>
  </dt>
  <dd>
    <p><strong>maq</strong> <strong>glfgen</strong> [<strong>-sp</strong>] [<strong>-m</strong> <em>maxmis</em>] [<strong>-Q</strong> <em>maxerr</em>] [<strong>-r</strong> <em>hetrate</em>] [<strong>-t</strong> <em>coef</em>] [<strong>-q</strong> <em>minQ</em>] [<strong>-N</strong> <em>nHap</em>] <em>out.cns</em> <em>in.ref.bfa</em> <em>in.aln.map</em> 2&gt; <em>out.cns.log</em> Calculate log-likelihood for all genotypes and store the results in \s-1GLF\s0 format (Genotyping Likelihood Format). Please check \s-1MAQ\s0 website for detailed descriptions of the file format and the related utilities.</p>
  </dd>
  <dt>
    <strong>indelpe</strong>
  </dt>
  <dd>
    <p><strong>maq</strong> <strong>indelpe</strong> <em>in.ref.bfa</em> <em>in.aln.map</em> &gt; <em>out.indelpe</em> Call consistent indels from paired end reads. The output is \s-1TAB\s0 delimited with each line consisting of chromosome, start position, type of the indel, number of reads across the indel, size of the indel and inserted/deleted nucleotides (separated by colon), number of indels on the reverse strand, number of indels on the forward strand, 5' sequence ahead of the indel, 3' sequence following the indel, number of reads aligned without indels and three additional columns for filters. At the 3rd column, type of the indel, a star indicates the indel is confirmed by reads from both strands, a plus means the indel is hit by at least two reads but from the same strand, a minus shows the indel is only found on one read, and a dot means the indel is too close to another indel and is filtered out. Users are recommended to run through `maq.pl indelpe' to correct the number of reads mapped without indels. For more details, see the `maq.pl indelpe' section.</p>
  </dd>
  <dt>
    <strong>indelsoa</strong>
  </dt>
  <dd>
    <p><strong>maq</strong> <strong>indelsoa</strong> <em>in.ref.bfa</em> <em>in.aln.map</em> &gt; <em>out.indelsoa</em> Call potential homozygous indels and break points by detecting the abnormal alignment pattern around indels and break points. The output is also \s-1TAB\s0 delimited with each line consisting of chromosome, approximate coordinate, length of the abnormal region, number of reads mapped across the position, number of reads on the left-hand side of the position and number of reads on the right-hand side. The last column can be ignored. The output contains many false positives. A recommended filter could be:</p>
<pre>
  awk '$5+$6-$4 &gt;= 3 && $4 &lt;= 1' in.indelsoa
</pre>
<p>Note that this command does not aim to be an accurate indel detector, but mainly helps to avoid some false positives in substitution calling. In addition, it only works well given deep depth (~40X for example); otherwise the false negative rate would be very high.</p>
  </dd>
  <dt>
    <strong>sol2sanger</strong>
  </dt>
  <dd>
    <p><strong>maq</strong> <strong>sol2sanger</strong> <em>in.sol.fastq</em> <em>out.sanger.fastq</em> Convert Solexa \s-1FASTQ\s0 to standard/Sanger \s-1FASTQ\s0 format.</p>
  </dd>
  <dt>
    <strong>bfq2fastq</strong>
  </dt>
  <dd>
    <p><strong>maq</strong> <strong>bfq2fastq</strong> <em>in.read.bfq</em> <em>out.read.fastq</em> Convert Maq's \s-1BFQ\s0 format to standard \s-1FASTQ\s0 format.</p>
  </dd>
  <dt>
    <strong>mapass2maq</strong>
  </dt>
  <dd>
    <p><strong>maq</strong> <strong>mapass2maq</strong> <em>in.mapass2.map</em> <em>out.maq.map</em> Convert obsolete mapass2's map format to Maq's map format. The old format does not contain read names.</p>
  </dd>
  <dt>
    <strong>mapview</strong>
  </dt>
  <dd>
    <p><strong>maq</strong> <strong>mapview</strong> [<strong>-bN</strong>] <em>in.aln.map</em> &gt; <em>out.aln.txt</em> Display the read alignment in plain text. For reads aligned before the Smith-Waterman alignment, each line consists of read name, chromosome, position, strand, insert size from the outer coorniates of a pair, paired flag, mapping quality, single-end mapping quality, alternative mapping quality, number of mismatches of the best hit, sum of qualities of mismatched bases of the best hit, number of 0-mismatch hits of the first 24bp, number of 1-mismatch hits of the first 24bp on the reference, length of the read, read sequence and its quality. Alternative mapping quality always equals to mapping quality if the reads are not paired. If reads are paired, it equals to the smaller mapping quality of the two ends. This alternative mapping quality is actually the mapping quality of an abnormal pair. The fifth column, paired flag, is a bitwise flag. Its lower 4 bits give the orientation: 1 stands for \s-1FF\s0, 2 for \s-1FR\s0, 4 for \s-1RF\s0, and 8 for \s-1RR\s0, where \s-1FR\s0 means that the read with smaller coordinate is on the forward strand, and its mate is on the reverse strand. Only \s-1FR\s0 is allowed for a correct pair. The higher bits of this flag give further information. If the pair meets the paired end requirement, 16 will be set. If the two reads are mapped to different chromosomes, 32 will be set. If one of the two reads cannot be mapped at all, 64 will be set. The flag for a correct pair always equals to 18. For reads aligned by the Smith-Waterman alignment afterwards, the flag is always 130. A line consists of read name, chromosome, position, strand, insert size, flag (always 130), position of the indel on the read (0 if no indel), length of the indels (positive for insertions and negative for deletions), mapping quality of its mate, number of mismatches of the best hit, sum of qualities of mismatched bases of the best hit, two zeros, length of the read, read sequence and its quality. The mate of a 130-flagged read always gets a flag 18. Flag 192 indicates that the read is not mapped but its mate is mapped. For such a read pair, one read has flag 64 and the other has 192. <strong>\s-1OPTIONS:\s0</strong></p>
<dl class='dl-vertical'>
  <dt>
    <strong>-b</strong>
  </dt>
  <dd>
    <p>do not display the read sequence and the quality</p>
  </dd>
  <dt>
    <strong>-N</strong>
  </dt>
  <dd>
    <p>display the positions where mismatches occur. This flag only works with a .map file generated by `maq map -N'.</p>
  </dd>

</dl>

  </dd>
  <dt>
    <strong>mapcheck</strong>
  </dt>
  <dd>
    <p><strong>maq</strong> <strong>mapcheck</strong> [<strong>-s</strong>] [<strong>-m</strong> <em>maxmis</em>] [<strong>-q</strong> <em>minQ</em>] <em>in.ref.bfa</em> <em>in.aln.map</em> &gt; <em>out.mapcheck</em> Read quality check. The mapcheck first reports the composition and the depth of the reference. After that there is a form. The first column indicates the position on a read. Following four columns which show the nucleotide composition, substitution rates between the reference and reads will be given. These rates and the numbers in the following columns are scaled to 999 and rounded to nearest integer. The next group of columns show the distribution of base qualities along the reads at a quality interval of 10. A decay in quality can usually be observed, which means bases at the end of read are less accurate. The last group of columns present the fraction of substitutions for read bases at a quality interval. This measures the accuracy of base quality estimation. Idealy, we expect to see 1 in the 3? column, 10 in the 2? column and 100 in the 1? column. <strong>\s-1OPTIONS:\s0</strong></p>
<dl class='dl-vertical'>
  <dt>
    <strong>-s</strong>
  </dt>
  <dd>
    <p>Take single end mapping quality as the final mapping quality</p>
  </dd>
  <dt>
    <strong>-m</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>Maximum number of mismatahces allowed for a read to be counted [4]</p>
  </dd>
  <dt>
    <strong>-q</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>Minimum mapping quality allowed for a read to be counted [30]</p>
  </dd>

</dl>

  </dd>
  <dt>
    <strong>pileup</strong>
  </dt>
  <dd>
    <p><strong>maq</strong> <strong>pileup</strong> [<strong>-spvP</strong>] [<strong>-m</strong> <em>maxmis</em>] [<strong>-Q</strong> <em>maxerr</em>] [<strong>-q</strong> <em>minQ</em>] [<strong>-l</strong> <em>sitefile</em>] <em>in.ref.bfa</em> <em>in.aln.map</em> &gt; <em>out.pileup</em> Display the alignment in a `pileup' text format. Each line consists of chromosome, position, reference base, depth and the bases on reads that cover this position. If <strong>-v</strong> is added on the command line, base qualities and mapping qualities will be presented in the sixth and seventh columns in order. The fifth column always starts with `@'. In this column, read bases identical to the reference are showed in comma `,' or dot `.', and read bases different from the reference in letters. A comma or a upper case indicates that the base comes from a read aligned on the forward strand, while a dot or a lower case on the reverse strand. This command is for users who want to develop their own \s-1SNP\s0 callers. <strong>\s-1OPTIONS:\s0</strong></p>
<dl class='dl-vertical'>
  <dt>
    <strong>-s</strong>
  </dt>
  <dd>
    <p>Take single end mapping quality as the final mapping quality</p>
  </dd>
  <dt>
    <strong>-p</strong>
  </dt>
  <dd>
    <p>Discard paired end reads that are not mapped as correct pairs</p>
  </dd>
  <dt>
    <strong>-v</strong>
  </dt>
  <dd>
    <p>Output verbose information including base qualities and mapping qualities</p>
  </dd>
  <dt>
    <strong>-m</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>Maximum number of mismatches allowed for a read to be used [7]</p>
  </dd>
  <dt>
    <strong>-Q</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>Maximum allowed number of quality values of mismatches [60]</p>
  </dd>
  <dt>
    <strong>-q</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>Minimum mapping quality allowed for a read to be used [0]</p>
  </dd>
  <dt>
    <strong>-l</strong> <em>\s-1FILE\s0</em>
  </dt>
  <dd>
    <p>File containing the sites at which pileup will be printed out. In this file the first column gives the names of the reference and the second the coordinates. Additional columns will be ignored. [null]</p>
  </dd>
  <dt>
    <strong>-P</strong>
  </dt>
  <dd>
    <p>also output the base position on the read</p>
  </dd>

</dl>

  </dd>
  <dt>
    <strong>cns2fq</strong>
  </dt>
  <dd>
    <p><strong>maq</strong> <strong>cns2fq</strong> [<strong>-Q</strong> <em>minMapQ</em>] [<strong>-n</strong> <em>minNeiQ</em>] [<strong>-d</strong> <em>minDepth</em>] [<strong>-D</strong> <em>maxDepth</em>] <em>in.cns</em> &gt; <em>out.cns.fastq</em> Extract the consensus sequences in \s-1FASTQ\s0 format. In the sequence lines, bases in lower case are essentially repeats or do not have sufficient coverage; bases in upper case indicate regions where SNPs can be reliably called. In the quality lines, \s-1ASCII\s0 of a character minus 33 gives the \s-1PHRED\s0 quality. <strong>\s-1OPTIONS:\s0</strong></p>
<dl class='dl-vertical'>
  <dt>
    <strong>-Q</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>Minimum mapping quality [40]</p>
  </dd>
  <dt>
    <strong>-d</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>Minimum read depth [3]</p>
  </dd>
  <dt>
    <strong>-n</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>Minimum neighbouring quality [20]</p>
  </dd>
  <dt>
    <strong>-D</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>Maximum read dpeth. &gt;=255 for unlimited. [255]</p>
  </dd>

</dl>

  </dd>
  <dt>
    <strong>cns2snp</strong>
  </dt>
  <dd>
    <p><strong>maq</strong> <strong>cns2snp</strong> <em>in.cns</em> &gt; <em>out.snp</em> Extract \s-1SNP\s0 sites. Each line consists of chromosome, position, reference base, consensus base, Phred-like consensus quality, read depth, the average number of hits of reads covering this position, the highest mapping quality of the reads covering the position, the minimum consensus quality in the 3bp flanking regions at each side of the site (6bp in total), the second best call, log likelihood ratio of the second best and the third best call, and the third best call. The 5th column is the key criterion when you judge the reliability of a \s-1SNP\s0. However, as this quality is only calculated assuming site independency, you should also consider other columns to get more accurate \s-1SNP\s0 calls. Script command `<strong>maq.pl</strong> <strong>SNPfilter</strong>' is designed for this (see below). The 7th column implies whether the site falls in a repetitive region. If no read covering the site can be mapped with high mapping quality, the flanking region is possibly repetitive or in the lack of good reads. A \s-1SNP\s0 at such site is usually not reliable. The 8th column roughly gives the copy number of the flanking region in the reference genome. In most cases, this number approaches 1.00, which means the region is about unique. Sometimes you may see non-zero read depth but 0.00 at the 7th column. This indicates that all the reads covering the position have at least two mismatches. Maq only counts the number of 0- and 1-mismatch hits to the reference. This is due to a complex technical issue. The 9th column gives the neighbouring quality. Filtering on this column is also required to get reliable SNPs. This idea is inspired by \s-1NQS\s0, although \s-1NQS\s0 is initially designed for a single read instead of a consensus.</p>
  </dd>
  <dt>
    <strong>cns2view</strong>
  </dt>
  <dd>
    <p><strong>maq</strong> <strong>cns2view</strong> <em>in.cns</em> &gt; <em>out.view</em> Show detailed information at all sites. The output format is identical to <strong>cns2snp</strong> report.</p>
  </dd>
  <dt>
    <strong>cns2ref</strong>
  </dt>
  <dd>
    <p><strong>maq</strong> <strong>cns2ref</strong> <em>in.cns</em> &gt; <em>out.ref.fasta</em> Extract the reference sequence.</p>
  </dd>
  <dt>
    <strong>cns2win</strong>
  </dt>
  <dd>
    <p><strong>maq</strong> <strong>cns2win</strong> [<strong>-w</strong> <em>winsize</em>] [<strong>-c</strong> <em>chr</em>] [<strong>-b</strong> <em>begin</em>] [<strong>-e</strong> <em>end</em>] [<strong>-q</strong> <em>minQ</em>] <em>in.cns</em> &gt; <em>out.win</em> Extract information averaged in a tilling window. The output is \s-1TAB\s0 delimited, which consists of reference name, coordinate divided by 1,000,000, \s-1SNP\s0 rate, het rate, raw read depth, read depth in approximately unique regions, the average number of hits of reads in the window and percent \s-1GC\s0. <strong>\s-1OPTIONS:\s0</strong></p>
<dl class='dl-vertical'>
  <dt>
    <strong>-w</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>Size of a window [1000]</p>
  </dd>
  <dt>
    <strong>-c</strong> <em>\s-1STR\s0</em>
  </dt>
  <dd>
    <p>Destinated reference sequence; otherwise all references will be used [null]</p>
  </dd>
  <dt>
    <strong>-b</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>Start position, 0 for no constraint [0]</p>
  </dd>
  <dt>
    <strong>-e</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>End position, 0 for no constraint [0]</p>
  </dd>
  <dt>
    <strong>-q</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>Minimum consensus quality of the sites to be used [0]</p>
  </dd>

</dl>

  </dd>
  <dt>
    <strong>fakemut</strong>
  </dt>
  <dd>
    <p><strong>maq</strong> <strong>fakemut</strong> [<strong>-r</strong> <em>mutrate</em>] [<strong>-R</strong> <em>indelfrac</em>] <em>in.ref.fasta</em> &gt; <em>out.fakeref.fasta</em> 2&gt; <em>out.fake.snp</em> Randomly introduce substitutions and indels to the reference. Substitutions and sinlge base-pair indels can be added. <strong>\s-1OPTIONS:\s0</strong></p>
<dl class='dl-vertical'>
  <dt>
    <strong>-r</strong> <em>\s-1FLOAT\s0</em>
  </dt>
  <dd>
    <p>Mutation rate [0.001]</p>
  </dd>
  <dt>
    <strong>-R</strong> <em>\s-1FLOAT\s0</em>
  </dt>
  <dd>
    <p>Fraction of mutations to be indels [0.1]</p>
  </dd>

</dl>

  </dd>
  <dt>
    <strong>simutrain</strong>
  </dt>
  <dd>
    <p><strong>maq</strong> <strong>simutrain</strong> <em>out.simupars.dat</em> <em>in.read.fastq</em> Estimate/train parameters for read simulation.</p>
  </dd>
  <dt>
    <strong>simulate</strong>
  </dt>
  <dd>
    <p><strong>maq</strong> <strong>simulate</strong> [<strong>-d</strong> <em>insize</em>] [<strong>-s</strong> <em>stdev</em>] [<strong>-N</strong> <em>nReads</em>] [<strong>-1</strong> <em>readLen1</em>] [<strong>-2</strong> <em>readLen2</em>] [<strong>-r</strong> <em>mutRate</em>] [<strong>-R</strong> <em>indelFrac</em>] [<strong>-h</strong>] <em>out.read1.fastq</em> <em>out.read2.fastq</em> <em>in.ref.fasta</em> <em>in.simupars.dat</em> Simulate paired end reads. File <em>in.simupars.dat</em> determines the read lengths and quality distribution. It is generated from <strong>simutrain</strong>, or can be downloaded from Maq website. In the output read files, a read name consists of the reference sequence name and the outer coordinates of the pair of simulated reads. By default, <strong>simulate</strong> assumes reads come from a diploid sequence which is generated by adding two different sets of mutations, including one base-pair indels, to <em>in.ref.fasta</em>. <strong>\s-1OPTIONS:\s0</strong></p>
<dl class='dl-vertical'>
  <dt>
    <strong>-d</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>mean of the outer distance of insert sizes [170]</p>
  </dd>
  <dt>
    <strong>-s</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>standard deviation of insert sizes [20]</p>
  </dd>
  <dt>
    <strong>-N</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>number of pairs of reads to be generated [1000000]</p>
  </dd>
  <dt>
    <strong>-1</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>length of the first read [set by <em>in.simupars.dat</em>]</p>
  </dd>
  <dt>
    <strong>-2</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>length of the second read [set by <em>in.simupars.dat</em>]</p>
  </dd>
  <dt>
    <strong>-r</strong> <em>\s-1FLOAT\s0</em>
  </dt>
  <dd>
    <p>mutation rate [0.001]</p>
  </dd>
  <dt>
    <strong>-R</strong> <em>\s-1FLOAT\s0</em>
  </dt>
  <dd>
    <p>fraction of 1bp indels [0.1]</p>
  </dd>
  <dt>
    <strong>-h</strong>
  </dt>
  <dd>
    <p>add all mutations to <em>in.ref.fasta</em> and generate reads from the single mutated sequence (haploid mode)</p>
  </dd>

</dl>
<p><strong>\s-1NOTE:\s0</strong></p><ul>
<li><p>Reads generated from this command are independent, which deviates from the truth. Whereas alignment evaluation is less affected by this, evaluation on \s-1SNP\s0 calling should be performed with caution. Error dependency may be one of the major causes of wrong \s-1SNP\s0 calls.</p></li>
</ul>
  </dd>
  <dt>
    <strong>simustat</strong>
  </dt>
  <dd>
    <p><strong>maq</strong> <strong>simustat</strong> <em>in.simu-aln.map</em> &gt; <em>out.simustat</em> Evaluate mapping qualities from simulated reads.</p>
  </dd>
  <dt>
    <strong>fasta2csfa</strong>
  </dt>
  <dd>
    <p><strong>maq</strong> <strong>fasta2csfa</strong> <em>in.nucl-ref.fasta</em> &gt; <em>out.colour-ref.fasta</em> Convert nucleotide \s-1FASTA\s0 to colour-coded \s-1FASTA\s0. Flag <strong>-c</strong> should be then applied to <strong>map</strong> command. In the output, letter `A' stands for color 0, `C' for 1, `G' for 2 and `T' for 3. Each sequence in the output is 1bp shorter than the input.</p>
  </dd>
  <dt>
    <strong>csmap2nt</strong>
  </dt>
  <dd>
    <p><strong>maq</strong> <strong>csmap2nt</strong> <em>out.nt.map</em> <em>in.ref.nt.bfa</em> <em>in.cs.map</em> Convert color alignment to nucleotide alignment. The input <em>in.ref.nt.bfa</em> is the nucleotide binary \s-1FASTA\s0 reference file. It must correspond to the original file from which the color reference is converted. Nucleotide consensus can be called from the resultant alignment.</p>
  </dd>
  <dt>
    <strong>submap</strong>
  </dt>
  <dd>
    <p><strong>maq</strong> <strong>submap</strong> [<strong>-q</strong> <em>minMapQ</em>] [<strong>-Q</strong> <em>maxSumErr</em>] [<strong>-m</strong> <em>maxMM</em>] [<strong>-p</strong>] <em>out.map</em> <em>in.map</em> Filter bad alignments in <em>in.map</em>. Command-line options are described in the `<strong>assemble</strong>' command.</p>
  </dd>
  <dt>
    <strong>eland2maq</strong>
  </dt>
  <dd>
    <p><strong>maq</strong> <strong>eland2maq</strong> [<strong>-q</strong> <em>defqual</em>] <em>out.map</em> <em>in.list</em> <em>in.eland</em> Convert eland alignment to maq's .map format. File <em>in.list</em> consists of the sequence names that appear at the seventh column of the eland alignment file <em>in.eland</em> and the name you expect to see in maq alignment. The following is an example:   cX.fa chrX   c1.fa chr1   c2.fa chr2 If you are aligning reads in several batches using eland, it is important to use the same <em>in.list</em> for the conversion. In addition, maq will load all the alignments and sort them in the memory. If you have concatenate several eland outputs into one huge file, you should separate it into smaller files to prevent maq from eating all your machine memory. This command actually aims to show Eland alignment in Maqview. As no quality information is available, the resultant maq alignment file should not be used to call consensus genotypes.</p>
  </dd>
  <dt>
    <strong>export2maq</strong>
  </dt>
  <dd>
    <p><strong>maq</strong> <strong>export2maq</strong> [<strong>-1</strong> <em>read1len</em>] [<strong>-2</strong> <em>read2len</em>] [<strong>-a</strong> <em>maxdist</em>] [<strong>-n</strong>] <em>out.map</em> <em>in.list</em> <em>in.export</em> Convert Illumina's Export format to Maq's <em>.map</em> format. Export format is a new alignment format since SolexaPipeline-0.3.0 which also calculates mapping qualities like maq. The resultant file can be used to call consensus genotypes as most of necessary information is available for maq to do this accurately. <strong>\s-1OPTIONS:\s0</strong></p>
<dl class='dl-vertical'>
  <dt>
    <strong>-1</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>Length of the first read [0]</p>
  </dd>
  <dt>
    <strong>-2</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>Length of the second read [0]</p>
  </dd>
  <dt>
    <strong>-a</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>Maximum outer distance for a correct read pair [250]</p>
  </dd>
  <dt>
    <strong>-n</strong>
  </dt>
  <dd>
    <p>Retain filtered reads</p>
  </dd>

</dl>

  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MAQ-PERL COMMANDS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <strong>demo</strong>
  </dt>
  <dd>
    <p><strong>maq.pl</strong> <strong>demo</strong> [<strong>-h</strong>] [<strong>-s</strong>] [<strong>-N</strong> <em>nPairs</em>] [<strong>-d</strong> <em>outDir</em>] <em>in.fasta</em> <em>in.simudat</em> Demonstrate the use of <strong>maq</strong> and its companion scripts. This command will simulate reads from a \s-1FASTA\s0 file <em>in.fasta</em>. The sequence length and qualities are determined by <em>in.simudat</em> which is generated from <strong>maq simutrain</strong> or can be downloaded from Maq website. The simulated reads will then be mapped with <strong>maq.pl easyrun</strong>. The alignment accuracy is evaluated by <strong>maq simustat</strong>, the consensus accuracy by <strong>maq</strong> simucns, and the \s-1SNP\s0 accuracy by <strong>maq_eval.pl</strong>. By default, paired end reads will be simulated and a diploid sequence will be generated from the input by adding mutations to either haploid type. The insert size and mutation rate are controlled by <strong>maq</strong> simulate. <strong>\s-1OPTIONS:\s0</strong></p>
<dl class='dl-vertical'>
  <dt>
    <strong>-h</strong>
  </dt>
  <dd>
    <p>simulate a haploid sequence instead of a diploid sequence</p>
  </dd>
  <dt>
    <strong>-s</strong>
  </dt>
  <dd>
    <p>use single-end mode to align reads instead of paired-end mode</p>
  </dd>
  <dt>
    <strong>-N</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>number of pairs of reads to be simulated [1000000]</p>
  </dd>
  <dt>
    <strong>-d</strong> <em>\s-1DIR\s0</em>
  </dt>
  <dd>
    <p>output directory [maqdemo]</p>
  </dd>

</dl>
<p><strong>\s-1NOTE:\s0</strong></p><ul>
<li><p>The output files from <strong>maq_eval.pl</strong> have not been documented, but you may make a good guess at some of these files.</p></li><li><p>This command just demonstrates the use of the maq suite. The accuracy on real data is almost always lower than what you see from pure simulation.</p></li>
</ul>
  </dd>
  <dt>
    <strong>easyrun</strong>
  </dt>
  <dd>
    <p><strong>maq.pl</strong> <strong>easyrun</strong> [<strong>-1</strong> <em>read1Len</em>] [<strong>-d</strong> <em>out.dir</em>] [<strong>-n</strong> <em>nReads</em>] [<strong>-A</strong> <em>3adapter</em>] [<strong>-e</strong> <em>minDep</em>] [<strong>-q</strong> <em>minCnsQ</em>] [<strong>-p</strong>] [<strong>-2</strong> <em>read2Len</em>] [<strong>-a</strong> <em>maxIns</em>] [<strong>-S</strong>] [<strong>-N</strong>] <em>in.ref.fasta</em> <em>in1.fastq</em> [<em>in2.fastq</em>] Analyses pipeline for small genomes. Easyrun command will run most of analyses implemented in <strong>maq</strong>. By default, <strong>easyrun</strong> assumes all the input read sequences files are single-end and independent; when <strong>-p</strong> is specified, two read sequence files are required, one for each end. Several files will be generated in <em>out.dir</em>, among which the following files are the key output:</p>
<dl class='dl-vertical'>
  <dt>
    <em>cns.final.snp</em>
  </dt>
  <dd>
    <p>final \s-1SNP\s0 calls with low quality ones filtered out</p>
  </dd>
  <dt>
    <em>cns.fq</em>
  </dt>
  <dd>
    <p>consensus sequences and qualities in the \s-1FASTQ\s0 format</p>
  </dd>

</dl>
<p><strong>\s-1OPTIONS:\s0</strong></p>
<dl class='dl-vertical'>
  <dt>
    <strong>-d</strong> <em>\s-1DIR\s0</em>
  </dt>
  <dd>
    <p>output directory [easyrun]</p>
  </dd>
  <dt>
    <strong>-n</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>number of reads/pairs in one batch of alignment [2000000]</p>
  </dd>
  <dt>
    <strong>-S</strong>
  </dt>
  <dd>
    <p>apply split-read analysis of short indels (maybe very slow)</p>
  </dd>
  <dt>
    <strong>-N</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>number of haplotypes/strains in the pool (&gt;=2) [2]</p>
  </dd>
  <dt>
    <strong>-A</strong> <em>\s-1FILE\s0</em>
  </dt>
  <dd>
    <p>file for 3'-adapter. The file should contain a single line of sequence [null]</p>
  </dd>
  <dt>
    <strong>-1</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>length of the first read, 0 for auto [0]</p>
  </dd>
  <dt>
    <strong>-e</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>minimum read depth required to call a \s-1SNP\s0 (for SNPfilter) [3]</p>
  </dd>
  <dt>
    <strong>-q</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>minimum consensus quality for SNPs in <em>cns.final.snp</em> [30]</p>
  </dd>
  <dt>
    <strong>-p</strong>
  </dt>
  <dd>
    <p>switch to paired end alignment mode</p>
  </dd>
  <dt>
    <strong>-2</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>length of the second read when <strong>-p</strong> is applied [0]</p>
  </dd>
  <dt>
    <strong>-a</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>maximum insert size when <strong>-p</strong> is applied [250]</p>
  </dd>

</dl>
<p><strong>\s-1NOTES:\s0</strong></p><ul>
<li><p>For \s-1SNP\s0 calling on pooled samples, users should set correct `<strong>-N</strong>' as well as `<strong>-E</strong> 0'.</p></li><li><p>The input file can be maq's binary format. <strong>maq.pl</strong> will automatically detect the file format.</p></li>
</ul>
  </dd>
  <dt>
    <strong>SNPfilter</strong>
  </dt>
  <dd>
    <p><strong>maq.pl</strong> <strong>SNPfilter</strong> [<strong>-d</strong> <em>minDep</em>] [<strong>-D</strong> <em>maxDep</em>] [<strong>-Q</strong> <em>maxMapQ</em>] [<strong>-q</strong> <em>minCnsQ</em>] [<strong>-w</strong> <em>indelWinSize</em>] [<strong>-n</strong> <em>minNeiQ</em>] [<strong>-F</strong> <em>in.indelpe</em>] [<strong>-f</strong> <em>in.indelsoa</em>] [<strong>-s</strong> <em>minScore</em>] [<strong>-m</strong> <em>maxAcross</em>] [<strong>-a</strong>] [<strong>-N</strong> <em>maxWinSNP</em>] [<strong>-W</strong> <em>densWinSize</em>] <em>in.cns2snp.snp</em> &gt; <em>out.filtered.snp</em> Rule out SNPs that are covered by few reads (specified by <strong>-d</strong>), by too many reads (specified by <strong>-D</strong>), near (specified by <strong>-w</strong>) to a potential indel, falling in a possible repetitve region (characterized by <strong>-Q</strong>), or having low-quality neighbouring bases (specified by <strong>-n</strong>). If <em>maxWinSNP</em> or more SNPs appear in any <em>densWinSize</em> window, they will also be filtered out together. <strong>\s-1OPTIONS:\s0</strong></p>
<dl class='dl-vertical'>
  <dt>
    <strong>-d</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>Minimum read depth required to call a \s-1SNP\s0 [3]</p>
  </dd>
  <dt>
    <strong>-D</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>Maximum read depth required to call a \s-1SNP\s0 (&lt;255, otherwise ignored) [256]</p>
  </dd>
  <dt>
    <strong>-Q</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>Required maximum mapping quality of reads covering the \s-1SNP\s0 [40]</p>
  </dd>
  <dt>
    <strong>-q</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>Minimum consensus quality [20]</p>
  </dd>
  <dt>
    <strong>-n</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>Minimum adjacent consensus quality [20]</p>
  </dd>
  <dt>
    <strong>-w</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>Size of the window around the potential indels. SNPs that are close to indels will be suppressed [3]</p>
  </dd>
  <dt>
    <strong>-F</strong> <em>\s-1FILE\s0</em>
  </dt>
  <dd>
    <p>The <strong>indelpe</strong> output [null]</p>
  </dd>
  <dt>
    <strong>-f</strong> <em>\s-1FILE\s0</em>
  </dt>
  <dd>
    <p>The <strong>indelsoa</strong> output [null]</p>
  </dd>
  <dt>
    <strong>-s</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>Minimum score for a soa-indel to be considered [3]</p>
  </dd>
  <dt>
    <strong>-m</strong> <em>\s-1INT\s0</em>
  </dt>
  <dd>
    <p>Maximum number of reads that can be mapped across a soa-indel [1]</p>
  </dd>
  <dt>
    <strong>-a</strong>
  </dt>
  <dd>
    <p>Alternative filter for single end alignment</p>
  </dd>

</dl>

  </dd>
  <dt>
    <strong>indelpe</strong>
  </dt>
  <dd>
    <p><strong>maq.pl</strong> <strong>indelpe</strong> <em>in.indelpe</em> &gt; <em>out.indelpe</em> Correct the number of reads mapped without indels for homopolymer tracts. This command modify the 4th, 10th and the last three columns of <em>in.indelpe</em> and output the result in <em>out.indelpe</em>. After the correction, the following <strong>awk</strong> command gives putative homozygous indels:   awk '($3=="*"||$3=="+") && $6+$7&gt;=3 && ($6+$7)/$4&gt;=0.75' and the following gives heterozygotes:   awk '($3=="*"||$3=="+") && $6+$7&gt;=3 && ($6+$7)/$4&lt;0.75' Please note that this <strong>indelpe</strong> command just implements several heuristic rules. It does not correct for impure homopolymer runs or di-nucleotide/triplet repeats. Consequently, the two awk commands only give approximate hom/het indels.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<ul>
<li><p>Easyrun script:</p>
<pre>
  maq.pl easyrun -d easyrun ref.fasta part1.fastq part2.fastq
</pre>
</li><li><p>Key commands behind easyrun:</p>
<pre>
  maq fasta2bfa ref.fasta ref.bfa;
  maq fastq2bfq part1.fastq part1.bfq;
  maq fastq2bfq part2.fastq part2.bfq;
  maq map part1.map ref.bfa part1.bfq;
  maq map part2.map ref.bfa part2.bfq;
  maq mapmerge aln.map part1.map part2.map;
  maq assemble cns.cns ref.bfa aln.map;
</pre>
</li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LICENSE</h2>
        <div class="sectioncontent">
<p>\s-1GNU\s0 General Public License, version 3 (GPLv3)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AVAILABILITY</h2>
        <div class="sectioncontent">
<p>&lt;http://maq.sourceforge.net&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Heng Li &lt;lh3@sanger.ac.uk&gt;</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="mapview.1.html"><span aria-hidden="true">&larr;</span> mapview.1: Package for sequence alignment of multiple genomes</a></li>
   <li class="next"><a href="maqview.1.html">maqview.1: Maq alignment indexer and viewer <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>gurgitate-mail: An easy-to-use mail filter</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="An easy-to-use mail filter">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="gurgitate-mail (1) manual">
  <meta name="twitter:description" content="An easy-to-use mail filter">
  <meta name="twitter:image" content="https://www.carta.tech/images/gurgitate-mail-gurgitate-mail-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/gurgitate-mail.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="gurgitate-mail (1) manual" />
  <meta property="og:description" content="An easy-to-use mail filter" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/gurgitate-mail-gurgitate-mail-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">gurgitate-mail<small> (1)</small></h1>
        <p class="lead">An easy-to-use mail filter</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/gurgitate-mail.1.html">
      <span itemprop="name">gurgitate-mail: An easy-to-use mail filter</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/gurgitate-mail/">
      <span itemprop="name">gurgitate-mail</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/gurgitate-mail.1.html">
      <span itemprop="name">gurgitate-mail: An easy-to-use mail filter</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>gurgitate-mail</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>\*(C`gurgitate-mail\*(C' is a program which reads your mail and filters it according to the <em>.gurgitate-rules.rb</em> file in your home directory.  The configuration file uses Ruby syntax and is thus quite flexible.</p><p>It's generally invoked either through your <em>.forward</em> file:</p>
<pre>
    "|/path/to/gurgitate-mail"
</pre>
<p>Or through your <em>.procmailrc</em> file:</p><p>    :0:     | /path/to/gurgitate-mail</p><p>Alternatively, if you're the sysadmin at your site, or your sysadmin is friendly, you can use gurgitate-mail as a local delivery agent.  For postfix, put</p><p>    mailbox_command=/opt/bin/gurgitate-mail</p><p>in <em>/etc/postfix/main.cf</em>.  If you use any other \s-1MTA\s0, and configure gurgitate-mail as a local delivery agent, please tell me how!  I want to include this in the documentation.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONFIGURATION FILES</h2>
        <div class="sectioncontent">
<p>There are three configuration files used by gurgitate-mail: two are system-wide, and the third, is the user rules file.</p><p>The two system-wide configuration files are <em>/etc/gurgitate-rules</em> and <em>/etc/gurgitate-rules-default</em>.  These are processed before and after the user rules, respectively.</p><p><em>/etc/gurgitate-rules</em> is used to handle system-wide filtering needs: setting the default mailbox style to Maildir rather than the default MBox, setting the spool directory, things like that.</p><p>The user configuration file is <em></em><strong>$HOME</strong><em>/.gurgitate-rules</em> (or, alternatively, <em></em><strong>$HOME</strong><em>/.gurgitate-rules.rb</em>.  Either work).  You put your own rules here.  If the user configuration file doesn't encounter a \*(L"return\*(R" during processing, then the additional rules contained in <em>/etc/gurgitate-rules-default</em> are run.  If that also doesn't return, then mail messages are saved into the default mail spool location.</p><p>If the \*(C`-f\*(C' option is used on the commandline, then the file specified will be used and the default rules will not. The \*(C`-f\*(C' option can be used more than once:</p><p>    gurgitate-mail -f test-rules -f additional-rules</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONFIGURATION PARAMETERS</h2>
        <div class="sectioncontent">
<p>There are several parameters that you can set to change the way that gurgitate-mail behaves.  You set a config parameter by saying, for instance:</p><p>    sendmail "/usr/sbin/sendmail"</p><p>which sets the \*(L"sendmail\*(R" parameter to \*(L"/usr/sbin/sendmail\*(R".</p>
<dl class='dl-vertical'>
  <dt>
    maildir
  </dt>
  <dd>
    <p>The directory you want to put mail folders into.  This defaults to $HOME/Mail.</p>
  </dd>
  <dt>
    logfile
  </dt>
  <dd>
    <p>Where you went gurgitate-mail's log messages to go to.  The standard location for this is $HOME/.gurgitate.log</p>
  </dd>
  <dt>
    sendmail
  </dt>
  <dd>
    <p>The full path to the sendmail program, used to deliver mail.  This can be any program that takes as its parameters the list of addresses to deliver mail to, and that takes a mail message on standard input.</p>
  </dd>
  <dt>
    homedir
  </dt>
  <dd>
    <p>The full path of your home directory.  This defaults to whatever your actual home directory is.</p>
  </dd>
  <dt>
    spooldir
  </dt>
  <dd>
    <p>The path where the system's mail spools goes to.  This defaults to \*(L"/var/spool/mail\*(R".  On a Maildir system, this should be set to the same as \*(L"homedir\*(R".</p>
  </dd>
  <dt>
    spoolfile
  </dt>
  <dd>
    <p>The mail spool file component of the full path of your mail spool. This is generally your username.  Maildir users should set this to \*(L"Maildir\*(R".</p>
  </dd>
  <dt>
    folderstyle
  </dt>
  <dd>
    <p>The style of folders you prefer.  This can be (at the moment) either MBox or Maildir.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILTER RULES</h2>
        <div class="sectioncontent">
<p>The filter rules are a series of Ruby statements, with the following methods and variables available:</p><p><strong>&#92;$1</strong></p>
<dl class='dl-vertical'>
  <dt>
    from
  </dt>
  <dd>
    <p>This contains the envelope \*(L"from\*(R" address of the email message. (Note that this isn't necessarily the same as the contents of the \*(L"From:\*(R" header)</p>
  </dd>
  <dt>
    headers
  </dt>
  <dd>
    <p>This is an object containing the headers of the message.  There are several methods that come with this object:</p>
  </dd>
  <dt>
    body
  </dt>
  <dd>
    <p>This contains the body of the email message.  As of yet, there's nothing really interesting which you can do with this, apart from assigning to it; you can rewrite the body of an email message this way.  Dealing with attachments is planned for a future release of \*(C`gurgitate-mail\*(C'.</p>
  </dd>
  <dt>
    maildir
  </dt>
  <dd>
    <p>The directory which contains the folders, used by the \*(C`save\*(C' method when you specify a folder as "=<em>folder</em>\*(L" (like Elm). Defaults to \*(R"$HOME/Mail".</p>
  </dd>
  <dt>
    homedir
  </dt>
  <dd>
    <p>Your home directory.  Read-only.</p>
  </dd>
  <dt>
    logfile
  </dt>
  <dd>
    <p>The location of the \*(C`gurgitate-mail\*(C' logfile.  If set to \*(C`nil\*(C', then no logging is done.  Defaults to \*(L"$HOME/.gurgitate.log\*(R".</p>
  </dd>
  <dt>
    sendmail
  </dt>
  <dd>
    <p>The location of the \*(C`sendmail\*(C' program.  Used by the \*(C`forward\*(C' method.  Defaults to \*(L"/usr/lib/sendmail\*(R".</p>
  </dd>
  <dt>
    spoolfile
  </dt>
  <dd>
    <p>The location of the mail spool.  Read-only.</p>
  </dd>
  <dt>
    matches(name(s),regex)
  </dt>
  <dd>
    <p>Returns \*(C`true\*(C' if the header \*(C`name\*(C' matches the regular expression \*(C`regex\*(C'.  If \*(C`name\*(C' is an array of header names, then it returns true if at least one of the headers matches.  Useful for testing whether both \*(L"To:\*(R" and \*(L"Cc:\*(R" headers match.</p>
  </dd>
  <dt>
    from
  </dt>
  <dd>
    <p>Returns the envelope \*(L"from\*(R" address of the email message.  Note that this is the same as the bare \*(L"from\*(R".</p>
  </dd>
  <dt>
    to
  </dt>
  <dd>
    <p>Returns a HeaderBag (a kind of array) with the contents of the \*(L"To\*(R" and the \*(L"Cc\*(R" headers.</p>
  </dd>
  <dt>
    to_s
  </dt>
  <dd>
    <p>As per Ruby convention, returns all the headers as a \*(C`String\*(C' object.</p>
  </dd>
  <dt>
    save(mailbox)
  </dt>
  <dd>
    <p>This saves the message to a mailbox.  You can specify the mailbox as a word with an = sign in front of it, in which case it puts it into \*(C`maildir\*(C'.  If you don't use the =<em>name</em> format, then you need to specify an absolute pathname.  If it can't write the message to the file you request it to, it'll attempt to write it to \*(C`spoolfile\*(C'.</p>
  </dd>
  <dt>
    forward(address)
  </dt>
  <dd>
    <p>This forwards the email message to another email address.</p>
  </dd>
  <dt>
    pipe(program)
  </dt>
  <dd>
    <p>This pipes the message through \*(C`program\*(C'.  \*(C`pipe\*(C' returns the exit code of the program that the message was piped through.</p>
  </dd>
  <dt>
    filter(program)
  </dt>
  <dd>
    <p>This pipes the message through \*(C`program\*(C' and returns a new Gurgitate object containing the filtered mail.  (This is handy for external filters which modify email like, for example, SpamAssassin, which adds a spam-score header.) You can also say     filter(program) do         # code here     end and it yields the newly-created Gurgitate object to the block.</p>
  </dd>
  <dt>
    headers
  </dt>
  <dd>
    <p>This returns the headers as an object of their own.  This object has its own methods:</p>
<dl class='dl-vertical'>
  <dt>
    headers[*headernames]
  </dt>
  <dd>
    <p>This returns a HeaderBag (a subclass of array) containing the headers you asked for.  You can then use the =~ operator on this result to match the \s-1RHS\s0 regex with everything in the HeaderBag. You can change a header's value with \*(C`headers[name]=newvalue\*(C'.</p>
  </dd>
  <dt>
    headers.match(name,regex)
  </dt>
  <dd>
    <p>Matches the header with the name \*(L"name\*(R" against the regex.  This is the same as headers[name] =~ /regex/.</p>
  </dd>
  <dt>
    headers.matches(names,regex)
  </dt>
  <dd>
    <p>Matches the headers with the names \*(L"names\*(R" against the regex. This is the same as headers[*names] =~ /regex/.</p>
  </dd>
  <dt>
    headers.from
  </dt>
  <dd>
    <p>Returns the envelope from.  You can change this with \*(C`headers.from=newaddress\*(C' too.</p>
  </dd>

</dl>

  </dd>
  <dt>
    return
  </dt>
  <dd>
    <p>This tells \*(C`gurgitate-mail\*(C' to stop processing the email message. If you don't use \*(C`return\*(C', then \*(C`gurgitate-mail\*(C' will continue processing the same mail again with the next rule.  If there isn't a \*(C`return\*(C' at the end of <em>gurgitate-rules.rb</em>, then \*(C`gurgitate-mail\*(C' will save the email message in the normal mail spool.</p>
  </dd>
  <dt>
    log(message)
  </dt>
  <dd>
    <p>This writes a log message to the log file.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SIMPLE EXAMPLES</h2>
        <div class="sectioncontent">
<p>Here are some examples of \*(C`gurgitate-mail\*(C' rules, with explanations:</p><p>    if from =~ /ebay.com/ then save("=ebay"); return; end</p><p>Any email from eBay (automatic end-of-auction notifications, for example, and outbid notices) gets filed into the \*(L"ebay\*(R" folder.</p><p>    if from =~ /root@/ then save("=root"); return; end</p><p>Any email from root (at any host) gets filed into a special folder.  Useful for sysadmins monitoring crontab email.</p><p>    if headers.matches(["To","Cc"],"webmaster@") then         save("=webmaster")         return     end</p><p>Any email with a To: or Cc: line of \*(L"sysadmin\*(R" is saved to a \*(L"sysadmin\*(R" folder.  Useful for people with multiple role accounts redirected to their address.</p><p>    if headers["Subject"] =~ /&#92;[SPAM&#92;]/ then         save("=spam")         return     end</p><p>This is a different syntax for matching patterns against headers. You can also match multiple headers in the square brackets.</p><p>    if headers["Subject","Keywords"] =~ /a bad word/ then         save("=swearing")         return     end</p><p>Searches for \*(L"a bad word\*(R" in the Subject and Keywords headers, and if it's there, saves the email in the \*(L"swearing\*(R" folder.</p><p>    if headers.matches(["To","Cc"],"mailing-list@example.com") then         pipe("|rcvstore +mailing-list")         return     end</p><p>Any email to a mailing list is piped through \*(L"rcvstore\*(R" to store it into an \s-1MH\s0 folder.</p><p>That</p><p>    headers.matches(["To","Cc"],/regex/)</p><p>idiom happens often enough that there's a shorthand for it:</p><p>    if to =~ /mailing-list@example.com/ then         pipe("|rcvstore +mailing-list")         return     end</p><p>Pipes the mail to the mailing list through \*(L"rcvstore\*(R".</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ADVANCED EXAMPLES</h2>
        <div class="sectioncontent">
<p>Here are some slightly more clever examples to give you an idea of what you can do with \*(C`gurgitate-mail\*(C'.  Let's suppose you have an email whitelist in a file called <em></em><strong>$HOME</strong><em>/.friends</em>, so you can determine whether some email is likely to be spam or not.</p><p>Then if someone on your whitelist sends you email, then you automatically save that into the \*(L"inbox\*(R" folder:</p><p>    friends=homedir+"/.friends"     if FileTest.exists?(friends) and FileTest.readable?(friends) then         File.new(friends).each do |friend|             if from =~ friend.chomp then                 log "Mail from friend "+friend.chomp                 save("=inbox")                 return             end         end     end</p><p>Okay, if someone sends you email, and it's addressed specifically to you (and gurgitate-mail hasn't caught it in another form already), then it might or might not be spam: put it into a \*(L"grey\*(R" folder:</p><p>    my_addresses= [ /me@example&#92;.com/i,                     /me@example&#92;.org/i,                     /me@example&#92;.net/i];  # I have three email addresses     my_addresses.each do |addr|         if headers.matches(["To","Cc"],addr) then             save("=possibly-not-spam")             return         end     end</p><p>And after that, if it's not from someone you know, and it's not addressed to your email address either, then it's probably save to assume that it's spam:</p><p>    save("=spam")     return</p><p>This can be improved by using a Bayesian filter, though; for example, Eric Raymond's bogofilter program (http://bogofilter.sourceforge.net) can be automatically trained and used with the help of the white/grey/black distinctions. Taking the example above, I'll adjust it by adding in calls to bogofilter:</p><p>    friends=homedir+"/.friends"     if FileTest.exists?(friends) and FileTest.readable?(friends) then         File.new(friends).each do |friend|             if from =~ friend.chomp then                 log "Mail from friend "+friend.chomp                 pipe("bogofilter -h")  # &lt;-- LINE ADDED HERE                 save("=inbox")                 return             end         end     end</p><p>\*(C`bogofilter -h\*(C' trains bogofilter that mail from whitelisted-people is not to be considered spam.  Okay, at the end of the .gurgitate-rules, change</p><p>    save("=spam")     return</p><p>to</p><p>    save("=spam")     pipe("bogofilter -s")     return</p><p>This trains \*(C`bogofilter\*(C' that anything which doesn't pass the rest of the filter should be considered spam.  Now for the interesting bit: Change the bit between these to use \*(L"bogofilter\*(R" to decide whether email is to be considered spam or not:</p><p>    my_addresses= [ /me@example&#92;.com/i,                     /me@example&#92;.org/i,                     /me@example&#92;.net/i];  # I have three email addresses     my_addresses.each do |addr|         if headers.matches(["To","Cc"],addr) then             if pipe("bogofilter")==1             then                 log("bogofilter suspects it might not be spam")                 save("=possibly-not-spam")             else                 log("bogofilter thinks it&apos;s probably spam")                 save("=spam")             end             return         end     end</p><p>\*(C`bogofilter\*(C' has an exit code of \*(L"1\*(R" if it thinks the message is not spam, and \*(L"0\*(R" if it thinks the message is spam.</p><p>Hopefully this should give you an idea of the kinds of things that you can use \*(C`bogofilter\*(C' for.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Dave Brown &lt;gurgitate-mail@dagbrown.com&gt;</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="gupnp-binding-tool.1.html"><span aria-hidden="true">&larr;</span> gupnp-binding-tool.1: Creates c convenience wrappers for upnp services</a></li>
   <li class="next"><a href="gurlchecker.1.html">gurlchecker.1: A graphical web link checker that works on a whole site, a single local page or a browser bookmarks file. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

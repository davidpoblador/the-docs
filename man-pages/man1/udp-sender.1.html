<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>udp-sender: Broadcast file on a lan</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Broadcast file on a lan">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="udp-sender (1) manual">
  <meta name="twitter:description" content="Broadcast file on a lan">
  <meta name="twitter:image" content="https://www.carta.tech/images/udpcast-udp-sender-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/udp-sender.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="udp-sender (1) manual" />
  <meta property="og:description" content="Broadcast file on a lan" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/udpcast-udp-sender-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">udp-sender<small> (1)</small></h1>
        <p class="lead">Broadcast file on a lan</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/udp-sender.1.html">
      <span itemprop="name">udp-sender: Broadcast file on a lan</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/udpcast/">
      <span itemprop="name">udpcast</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/udp-sender.1.html">
      <span itemprop="name">udp-sender: Broadcast file on a lan</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>udp-sender [--file <em>file</em>] [--full-duplex] [--half-duplex] [--pipe <em>pipe</em>] [--portbase <em>portbase</em>] [--blocksize <em>size</em>] [--interface <em>net-interface</em>] [--mcast-data-address <em>data-mcast-address</em>] [--mcast-rdv-address <em>mcast-rdv-address</em>] [--max-bitrate <em>bitrate</em>] [--pointopoint] [--async] [--log <em>file</em>] [--min-slice-size <em>min</em>] [--max-slice-size <em>max</em>] [--slice-size] [--ttl <em>time-to-live</em>] [--fec <em>stripes</em>x<em>redundancy</em>/<em>stripesize</em>] [--print-seed] [--rexmit-hello-interval <em>interval</em>] [--autostart <em>autostart</em>] [--broadcast] [--min-receivers receivers] [--min-wait <em>sec</em>] [--max-wait <em>sec</em>] [--nokbd] [--retries-until-drop <em>n</em>] [--bw-period <em>n</em>] [--rate-governor <em>module.so:key1=value1,key2=value2</em>] [--stat-period <em>n</em>] [--print-uncompressed-position <em>flag</em>]</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>\*(C`Udp-sender\*(C' is used to broadcast a file (for instance a disk image) to multiple \*(C`udp-receivers\*(C' on the local \s-1LAN\s0. In order to do this, it uses Ethernet multicast or broadcast, so that all receivers profit from the same physical datastream. Thus, sending to 10 destinations does not take more time than it would take to send just 2.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONS</h2>
        <div class="sectioncontent">
<h3>Basic options</h3>

<dl class='dl-vertical'>
  <dt>
    --file <em>file</em>
  </dt>
  <dd>
    <p>Reads data to be transmitted from <em>file</em>. If this parameter is not supplied, data to be transmitted is read from stdin instead.</p>
  </dd>
  <dt>
    --pipe <em>command</em>
  </dt>
  <dd>
    <p>Sends data through <em>pipe</em> before transmitting it. This is useful for compressing/decompressing it, or for stripping out unused blocks. The <em>command</em> gets a direct handle on the input file or device, and thus may seek inside it, if needed. \*(C`Udpcast\*(C' itself also keeps a handle on the file, which is used for an informal progress display. The <em>command</em>'s stdout is a pipe to udpcast.</p>
  </dd>
  <dt>
    --autostart <em>n</em>
  </dt>
  <dd>
    <p>Starts transmission after <em>n</em> retransmissions of hello packet, without waiting for a key stroke. Useful for unattended operation, where udp-sender is started from a cron-job for a broadcast/multicast at a scheduled time.</p>
  </dd>

</dl>

<h3>Networking options</h3>
<p>The following networking options should be supplied both on the sender and the receivers:</p>
<dl class='dl-vertical'>
  <dt>
    --portbase <em>portbase</em>
  </dt>
  <dd>
    <p>Default ports to use for udpcast. Two ports are used: <em>portbase</em> and <em>portbase+1</em> . Thus, <em>Portbase</em> must be even. Default is 9000. The same <em>portbase</em> must be specified for both \*(C`udp-sender\*(C' and \*(C`udp-receiver\*(C'.</p>
  </dd>
  <dt>
    --interface <em>interface</em>
  </dt>
  <dd>
    <p>Network interface used to send out the data. Default is \*(C`eth0\*(C'</p>
  </dd>
  <dt>
    --ttl <em>time to live</em>
  </dt>
  <dd>
    <p>Sets the <em>time-to-live</em> parameter for the multicast packets. Should theoretically allow to use UDPCast beyond the local network, but not tested for lack of a multicast router.</p>
  </dd>
  <dt>
    --mcast-rdv-address <em>address</em>
  </dt>
  <dd>
    <p>Uses a non-standard multicast address for the control (rendez-vous) connection. This address is used by the sender and receivers to \*(L"find\*(R" each other. This is <strong>not</strong> the address that is used to transfer the actual data. By default \*(C`mcast-rdv-address\*(C' is the Ethernet broadcast address if \*(C`ttl\*(C' is 1, and 224.0.0.1 otherwise. This setting should not be used except in very special situations, such as when 224.0.0.1 cannot be used for policy reasons.</p>
  </dd>

</dl>
<p>The following networking options should be supplied only on the sender:</p>
<dl class='dl-vertical'>
  <dt>
    --mcast-data-address <em>address</em>
  </dt>
  <dd>
    <p>Uses the given address for multicasting the data. If not specified, the program will automatically derive a multicast address from its own \s-1IP\s0 (by keeping the last 27 bits of the \s-1IP\s0 and then prepending 232).</p>
  </dd>
  <dt>
    --pointopoint
  </dt>
  <dd>
    <p>Point-to-point mode. Only a single receiver is allowed, but the data will be directly send to this receiver (in unicast mode), rather than multicast/broadcast all over the place. If no async mode is chosen, and there happens to be only one receiver, point-to-point is activated automatically.</p>
  </dd>
  <dt>
    --nopointopoint
  </dt>
  <dd>
    <p>Don't use point-to-point, even if there is only one single receiver.</p>
  </dd>
  <dt>
    --full-duplex
  </dt>
  <dd>
    <p>Use this option if you use a full-duplex network. T-base-10 or 100 is full duplex if equipped with a switch. Hub based networks, or T-base-2 networks (coaxial cable) are only <strong>half-duplex</strong> and you should not use this option with these networks, or else you may experience a 10% performance hit. N.B. On high-latency \s-1WAN\s0 links, the full-duplex option can lead to substantial performance improvements, because it allows udp-sender to send more data while it is still waiting for the previous batch to get acknowledged.</p>
  </dd>
  <dt>
    --half-duplex
  </dt>
  <dd>
    <p>Use half duplex mode (needed for Hub based or T-base-2 networks). This is the default behavior in this version of udpcast.</p>
  </dd>
  <dt>
    --broadcast
  </dt>
  <dd>
    <p>Use Ethernet broadcast, rather than multicast. Useful if you have Ethernet cards which don't support multicast. By default, \*(C`udpcast\*(C' uses multicast. This allows sending the data only to those receivers that requested it. Ethernet cards of machines which <em>don't</em> participate in the transmission automatically block out the packets at the hardware level. Moreover, network switches are able to selectively transmit the packets only to those network ports to which receivers are connected. Both features thus allow a much more efficient operation than broadcast. This option should only be supplied on the sender.</p>
  </dd>
  <dt>
    -b blocksize
  </dt>
  <dd>
    <p>Choses the packet size. Default (and also maximum) is 1456.</p>
  </dd>

</dl>

<h3>Unidirectional mode (without return channel)</h3>
<p>The options described below are useful in situations where no \*(L"return channel\*(R" is available, or where such a channel is impractical due to high latency. In an unidirectional setup (i.e. without return channel), the sender only sends data but doesn't expect any reply from the receiver.</p><p>Unidirectional options must be used together, or else the transfer will not work correctly. You may for example use the following command line:</p><p>\*(C`udp-sender --async --max-bitrate 10m --fec 8x8\*(C'</p>
<dl class='dl-vertical'>
  <dt>
    --async
  </dt>
  <dd>
    <p>Asynchronous mode. Do not request confirmations from the receiver. Best used together with forward error correction and bandwidth limitation, or else the receiver will abort the reception as soon as it misses a packet. When the receiver aborts the reception in such a way, it will print a list of packets lost in the slice causing the problem. You can use this list to tune the forward error correction parameters.</p>
  </dd>
  <dt>
    --max-bitrate <em>bitrate</em>
  </dt>
  <dd>
    <p>Limits bandwidth used by udpcast. Useful in asynchronous mode, or else the sender may send too fast for the switch and/or receiver to keep up. Bitrate may be expressed in bits per second (--bitrate 5000000), kilobits per second (\*(C`--bitrate 5000k\*(C') or megabits per second (\*(C`--bitrate 5m\*(C'). This is the raw bitrate, including packet headers, forward error correction, retransmissions, etc. Actual payload bitrate will be lower. Enables forward error correction. The goal of forward error correction is to transmit redundant data, in order to make up for packets lost in transit. Indeed, in unidirectional mode, the receivers have no way of requesting retransmission of lost packets, thus the only way to address packet loss is to include redundant information to begin with. The algorithm is designed in such a way that if <em>r</em> redundant packets are transmitted, that those can be used to compensate for the loss of <em>any</em> r packets in the same \s-1FEC\s0 group (stripe). In order to increase robustness of the \s-1FEC\s0 algorithm against burst packet losses, each <em>slice</em> is divided in <em>interleave</em> stripes. Each stripe has <em>stripesize</em> blocks (if not specified, stripesize is calculated by diving <em>slice-size</em> by <em>interleave</em>). For each stripe, <em>redundancy</em> \s-1FEC\s0 packets are added. Stripes are organized in such a fashion that consecutive packets belong to different stripes. This way, we ensure that burst losses affect different stripes, rather than using all \s-1FEC\s0 packets of a single stripe. Example: \*(C`--fec 8x8/128\*(C'</p>
  </dd>
  <dt>
    --rate-governor <em>module.so:key1=value1,key2=value2</em>
  </dt>
  <dd>
    <p>Applies a dynamically loadable rate governor. <em>module.so</em> is the name of the preloadable module, which is followed by a number of property assignments (<em>key1=value1</em>). The rate governor controls the transmission rate according to various criteria, such as congestion information received from a routing or encapsulating device. See comments in \*(C`/usr/include/udpcast/rateGovernor.h\*(C' and example in \*(C`examples/rateGovernor\*(C' for more details</p>
  </dd>
  <dt>
    --rexmit-hello-interval <em>timeout</em>
  </dt>
  <dd>
    <p>If set, rebroadcasts the \s-1HELLO\s0 packet used for initiating the casting each <em>timeout</em> milliseconds. This option is useful together with <em>asyc mode</em>, because with async mode the receiver won't send a connection request to the sender (and hence won't get a connection reply). In <em>async mode</em>, the receivers get all needed information from the <em>hello</em> packet instead, and are thus particularly dependent on the reception of this packet, making retransmission useful. This option is also useful on networks where packet loss is so high that even with connection requests, sender and receiver would not find each other otherwise.</p>
  </dd>
  <dt>
    --retries-until-drop <em>retries</em>
  </dt>
  <dd>
    <p>How many time to send a \s-1REQACK\s0 until dropping a receiver. Lower retrycounts make \*(C`udp-sender\*(C' faster to react to crashed receivers, but they also increase the probability of false alerts (dropping receivers that are not actually crashed, but merely slow to respond for whatever reason)</p>
  </dd>
  <dt>
    --streaming
  </dt>
  <dd>
    <p>Allows receivers to join an ongoing transmission mid through</p>
  </dd>

</dl>

<h3>Keyboardless mode</h3>
<p>The options below help to run a sender in unattended mode.</p>
<dl class='dl-vertical'>
  <dt>
    --min-receivers <em>n</em>
  </dt>
  <dd>
    <p>Automatically start as soon as a minimal number of receivers have connected.</p>
  </dd>
  <dt>
    --min-wait <em>t</em>
  </dt>
  <dd>
    <p>Even when the necessary amount of receivers <em>do</em> have connected, still wait until <em>t</em> seconds since first receiver connection have passed.</p>
  </dd>
  <dt>
    --max-wait <em>t</em>
  </dt>
  <dd>
    <p>When not enough receivers have connected (but at least one), start anyways when <em>t</em> seconds since first receiver connection have passed.</p>
  </dd>
  <dt>
    --nokbd
  </dt>
  <dd>
    <p>Do not read start signal from keyboard, and do not display any message telling the user to press any key to start.</p>
  </dd>
  <dt>
    --start-timeout <em>sec</em>
  </dt>
  <dd>
    <p>sender aborts at start if it doesn't see a receiver within this many seconds. Furthermore, transmission of data needs to start within this delay. Once transmission is started, the timeout no longer applies.</p>
  </dd>
  <dt>
    --daemon-mode
  </dt>
  <dd>
    <p>Do not exit when done, but instead wait for the next batch of receivers. If this option is given twice, udp-sender puts itself into the background, closes its standard file descriptors, and acts as a real daemon.</p>
  </dd>
  <dt>
    --pid-file <em>file</em>
  </dt>
  <dd>
    <p>Allow to specify a pid file. If given together with \*(C`--daemon-mode\*(C', udp-sender will write its pid into this file. If given together with \*(C`--kill\*(C', the process with the given pid will be killed.</p>
  </dd>
  <dt>
    --kill
  </dt>
  <dd>
    <p>Shuts down the udp-sender identified by the pid file (which also must be specified). Kill does not interrupt an ongoing transmission, but instead waits until it is finished.</p>
  </dd>

</dl>
<p>Example:</p><p>\*(C`udp-sender -f zozo --min-receivers 5 --min-wait 20 --max-wait 80\*(C'</p><ul>
<li><p>If one receiver connects at 18h00.00, and 4 more within the next 5 minutes, start at 18h00.20. (5 receivers connected, but min-wait not yet passed)</p></li><li><p>If one receiver connects at 18h00.00, and 3 more within the next 5 minutes, then a last one at 18h00.25, start right after.</p></li><li><p>If one receiver connects at 18h00.00, then 3 more within the next 15 minutes, then no one, start at 18h01.20. (not enough receivers, but we start anyways after max-wait).</p></li>
</ul>
<h3>Logging and statistics options</h3>
<p>The options instruct \*(C`udp-sender\*(C' to log some additional statistics to a file:</p>
<dl class='dl-vertical'>
  <dt>
    --stat-period <em>seconds</em>
  </dt>
  <dd>
    <p>Every so much milliseconds, print some statistics to stderr: how much bytes sent so far log, position in uncompressed file (if applicable), retransmit count... By default, this is printed every half second.</p>
  </dd>
  <dt>
    --print-uncompressed-position <em>flag</em>
  </dt>
  <dd>
    <p>By default, udp-sender only prints the position in uncompressed file if the 2 following conditions are met:</p><ul>
<li><p>Input is piped via a compressor (\*(C`-p \*(C' option).</p></li><li><p>The primary input is seekable (file or device)</p></li>
</ul><p>With the \*(C`--print-uncompressed-position\*(C', options, you can change this behavior:</p><ul>
<li><p>If flag is 0, uncompressed position will <strong>never</strong> be printed, even if above conditions are met</p></li><li><p>If flag is 1, uncompressed position will <strong>always</strong> be printed, even if above conditions are <strong>not</strong> met</p></li>
</ul>
  </dd>
  <dt>
    --log <em>file</em>
  </dt>
  <dd>
    <p>Logs some stuff into <em>file</em>.</p>
  </dd>
  <dt>
    --no-progress
  </dt>
  <dd>
    <p>Do not display progress statistics.</p>
  </dd>
  <dt>
    --bw-period <em>seconds</em>
  </dt>
  <dd>
    <p>Every so much seconds, log instantenous bandwidth seen during that period. Note: this is different from the bandwidth displayed to stderr of the receiver, which is the average since start of transmission.</p>
  </dd>

</dl>

<h3>Tuning options (sender)</h3>
<p>The following tuning options are all about slice size. Udpcast groups its data in <em>slices</em>, which are a series of blocks (\s-1UDP\s0 packets). These groups are relevant for</p>
<dl class='dl-vertical'>
  <dt>
    *
  </dt>
  <dd>
    <p>data retransmission: after each slice, the server asks the receivers whether they have received all blocks, and if needed retransmits what has been missing</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>forward error correction: each slice has its set of data blocks, and matching \s-1FEC\s0 blocks.</p>
  </dd>
  <dt>
    --min-slice-size <em>size</em>
  </dt>
  <dd>
    <p>minimum slice size (expressed in blocks). Default is 16. When dynamically adjusting slice size (only in non-duplex mode), never use smaller slices than this. Ignored in duplex mode (default).</p>
  </dd>
  <dt>
    --max-slice-size <em>size</em>
  </dt>
  <dd>
    <p>maximum slice size (expressed in blocks). Default is 1024. When dynamically adjusting slice size (only in non-duplex mode), never use larger slices than this. Ignored in duplex mode (default).</p>
  </dd>
  <dt>
    --default-slice-size <em>size</em>
  </dt>
  <dd>
    <p>Slice size used (starting slice size in half-duplex mode).</p>
  </dd>
  <dt>
    --rehello-offset <em>offs</em>
  </dt>
  <dd>
    <p>in streaming mode, how many packets before end of slice the hello packet will be transferred (default 50). Chose larger values if you notice that receivers are excessively slow to pick up running transmission</p>
  </dd>

</dl>

<h3>Tuning the forward error correction</h3>
<p>There are three parameters on which to act:</p>
<dl class='dl-vertical'>
  <dt>
    redundancy
  </dt>
  <dd>
    <p>This influences how much extra packets are included per stripe. The higher this is, the more redundancy there is, which means that the transmission becomes more robust against loss. However, \s-1CPU\s0 time necessary is also proportional to redundancy (a factor to consider on slow \s-1PC\s0's), and of course, a higher redundancy augments the amount of data to be transmitted.</p>
  </dd>
  <dt>
    interleave
  </dt>
  <dd>
    <p>This influences among how many stripes the data is divided. Higher interleave improves robustness against burst loss (for example, 64 packets in a row...). It doesn't increase robustness against randomly spread packet loss. <strong>Note</strong>: interleave bigger than 8 will force a smaller stripesize, due to the fact that slicesize is limited to 1024.</p>
  </dd>
  <dt>
    stripesize
  </dt>
  <dd>
    <p>How many data blocks there are in a stripe. Due to the algorithm used, this cannot be more than 128. Reducing stripe size is an indirect way of augmenting (relative) redundancy, without incurring the \s-1CPU\s0 penalty of larger (absolute) redundancy. However, a larger absolute redundancy is still preferable over a smaller stripesize, because it improves robustness against clustered losses. For instance, if 8/128 is preferable over 4/64, because with 8/128 the 8 \s-1FEC\s0 packets can be used to compensate for the loss of any of the 128 data packets, whereas with 4/64, each group of 4 \s-1FEC\s0 packets can only be used against its own set of 64 data packets. If for instance the first 8 packets were lost, they would be recoverable with 8/128, but not with 4/64.</p>
  </dd>

</dl>
<p>Considering these, change parameters as follows:</p><ul>
<li><p>If you observe long stretches of lost packets, increase interleave</p></li><li><p>If you observe that transfer is slowed down by \s-1CPU\s0 saturation, decrease redundancy and stripesize proportionnally.</p></li><li><p>If you observe big <em>variations</em> in packet loss rate, increase redundancy and stripesize proportionnally.</p></li><li><p>If you just observe high loss, but not necessarily clustered in any special way, increase redundancy or decrease stripesize</p></li><li><p>Be aware that network equipment or the receiver may be dropping packets because of a bandwidth which is too high. Try limiting it using \*(C`max-bitrate\*(C'</p></li><li><p>The receiver may also be dropping packets because it cannot write the data to disk fast enough. Use hdparm to optimize disk access on the receiver. Try playing with the settings in \*(C`/proc/sys/net/core/rmem_default\*(C' and \*(C`/proc/sys/net/core/rmem_max\*(C', i.e. setting them to a higher value.</p></li>
</ul>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO udp-sender&hellip;</h2>
        <div class="sectioncontent">
<p>udp-receiver</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Alain Knaff</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="udp-receiver.1.html"><span aria-hidden="true">&larr;</span> udp-receiver.1: Receive files broadcast by udp-sender</a></li>
   <li class="next"><a href="udptunnel.1.html">udptunnel.1: Tunnel udp packets over a tcp connection <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

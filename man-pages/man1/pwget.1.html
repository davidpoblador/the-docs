<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>pwget: Perl web url fetch program</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Perl web url fetch program">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="pwget (1) manual">
  <meta name="twitter:description" content="Perl web url fetch program">
  <meta name="twitter:image" content="https://www.carta.tech/images/pwget-pwget-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/pwget.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="pwget (1) manual" />
  <meta property="og:description" content="Perl web url fetch program" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/pwget-pwget-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">pwget<small> (1)</small></h1>
        <p class="lead">Perl web url fetch program</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/pwget.1.html">
      <span itemprop="name">pwget: Perl web url fetch program</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/pwget/">
      <span itemprop="name">pwget</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/pwget.1.html">
      <span itemprop="name">pwget: Perl web url fetch program</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
    pwget http://example.com/ [URL ...]
    pwget --config $HOME/config/pwget.conf --Tag linux --Tag emacs ..
    pwget --verbose --overwrite http://example.com/
    pwget --verbose --overwrite --Output ~/dir/ http://example.com/
    pwget --new --overwrite http://example.com/package-1.1.tar.gz
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Automate periodic downloads of files and packages.</p><p>If you retrieve latest versions of certain program blocks periodically, this is the Perl script for you. Run from cron job or once a week to upload newest versions of files around the net. Note:</p><h3>Wget and this program</h3>
<p>At this point you may wonder, where would you need this perl program when <em>wget</em>\|(1) C-program has been the standard for ages. Well, 1) Perl is cross platform and more easily extendable 2) You can record file download criterias to a configuration file and use perl regular epxressions to select downloads 3) the program can anlyze web-pages and \*(L"search\*(R" for the download only links as instructed 4) last but not least, it can track newest packages whose name has changed since last downlaod. There are heuristics to determine the newest file or package according to file name skeleton defined in configuration.</p><p>This program does not replace <em>pwget</em>\|(1) because it does not offer as many options as wget, like recursive downloads and date comparing. Use wget for ad hoc downloads and this utility for files that change (new releases of archives) or which you monitor periodically.</p>
<h3>Short introduction</h3>
<p>This small utility makes it possible to keep a list of URLs in a configuration file and periodically retrieve those pages or files with simple commands. This utility is best suited for small batch jobs to download e.g. most recent versions of software files. If you use an \s-1URL\s0 that is already on disk, be sure to supply option <strong>--overwrite</strong> to allow overwriting existing files.</p><p>While you can run this program from command line to retrieve individual files, program has been designed to use separate configuration file via <strong>--config</strong> option. In the configuration file you can control the downloading with separate directives like \*(C`save:\*(C' which tells to save the file under different name. The simplest way to retrieve the latest version of apackage from a \s-1FTP\s0 site is:</p><p>    pwget --new --overwite --verbose &#92;        http://www.example.com/package-1.00.tar.gz</p><p>Do not worry about the filename \*(C`package-1.00.tar.gz\*(C'. The latest version, say, \*(C`package-3.08.tar.gz\*(C' will be retrieved. The option <strong>--new</strong> instructs to find newer version than the provided \s-1URL\s0.</p><p>If the \s-1URL\s0 ends to slash, then directory list at the remote machine is stored to file:</p><p>    !path!000root-file</p><p>The content of this file can be either index.html or the directory listing depending on the used http or ftp protocol.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <strong>-A, --regexp-content \s-1REGEXP\s0</strong>
  </dt>
  <dd>
    <p>Analyze the content of the file and match \s-1REGEXP\s0. Only if the regexp matches the file content, then download file. This option will make downloads slow, because the file is read into memory as a single line and then a match is searched against the content. For example to download Emacs lisp file (.el) written by Mr. Foo in case insensitive manner:     pwget -v -R &apos;&#92;.el$&apos; -A "(?i)Author: Mr. Foo" &#92;       http://www.emacswiki.org/elisp/index.html</p>
  </dd>
  <dt>
    <strong>-C, --create-paths</strong>
  </dt>
  <dd>
    <p>Create paths that do not exist in \*(C`lcd:\*(C' directives. By default, any \s-1LCD\s0 directive to non-existing directory will interrupt program. With this option, local directories are created as needed making it possible to re-create the exact structure as it is in configuration file.</p>
  </dd>
  <dt>
    <strong>-c, --config \s-1FILE\s0</strong>
  </dt>
  <dd>
    <p>This option can be given multiple times. All configurations are read. Read URLs from configuration file. If no configuration file is given, file pointed by environment variable is read. See \s-1ENVIRONMENT\s0. The configuration file layout is envlained in section \s-1CONFIGURATION\s0 \s-1FILE\s0</p>
  </dd>
  <dt>
    <strong>--chdir \s-1DIRECTORY\s0</strong>
  </dt>
  <dd>
    <p>Do a <em>chdir()</em> to \s-1DIRECTORY\s0 before any \s-1URL\s0 download starts. This is like doing:     cd DIRECTORY     pwget http://example.com/index.html</p>
  </dd>
  <dt>
    <strong>-d, --debug [\s-1LEVEL\s0]</strong>
  </dt>
  <dd>
    <p>Turn on debug with positive \s-1LEVEL\s0 number. Zero means no debug. This option turns on <strong>--verbose</strong> too.</p>
  </dd>
  <dt>
    <strong>-e, --extract</strong>
  </dt>
  <dd>
    <p>Unpack any files after retrieving them. The command to unpack typical archive files are defined in a program. Make sure these programs are along path. Win32 users are encouraged to install the Cygwin utilities where these programs come standard. Refer to section \s-1SEE\s0 \s-1ALSO\s0.   .tar =&gt; tar   .tgz =&gt; tar + gzip   .gz  =&gt; gzip   .bz2 =&gt; bzip2   .zip =&gt; unzip</p>
  </dd>
  <dt>
    <strong>-F, --firewall \s-1FIREWALL\s0</strong>
  </dt>
  <dd>
    <p>Use \s-1FIREWALL\s0 when accessing files via ftp:// protocol.</p>
  </dd>
  <dt>
    <strong>-h, --help</strong>
  </dt>
  <dd>
    <p>Print help page in text.</p>
  </dd>
  <dt>
    <strong>--help-html</strong>
  </dt>
  <dd>
    <p>Print help page in \s-1HTML\s0.</p>
  </dd>
  <dt>
    <strong>--help-man</strong>
  </dt>
  <dd>
    <p>Print help page in Unix manual page format. You want to feed this output to c&lt;nroff -man&gt; in order to read it. Print help page.</p>
  </dd>
  <dt>
    <strong>-m, --mirror \s-1SITE\s0</strong>
  </dt>
  <dd>
    <p>If \s-1URL\s0 points to Sourcefoge download area, use mirror \s-1SITE\s0 for downloading. Alternatively the full full \s-1URL\s0 can include the mirror information. And example:     --mirror kent http://downloads.sourceforge.net/foo/foo-1.0.0.tar.gz</p>
  </dd>
  <dt>
    <strong>-n, --new</strong>
  </dt>
  <dd>
    <p>Get newest file. This applies to datafiles, which do not have extension .asp or .html. When new releases are announced, the version number in filename usually tells which is the current one so getting harcoded file with:     pwget -o -v http://example.com/dir/program-1.3.tar.gz is not usually practical from automation point of view. Adding <strong>--new</strong> option to the command line causes double pass: a) the whole http://example.com/dir/ is examined for all files and b) files matching approximately filename program-1.3.tar.gz are examined, heuristically sorted and file with latest version number is retrieved.</p>
  </dd>
  <dt>
    <strong>--no-lcd</strong>
  </dt>
  <dd>
    <p>Ignore \*(C`lcd:\*(C' directives in configuration file. In the configuration file, any \*(C`lcd:\*(C' directives are obeyed as they are seen. But if you do want to retrieve \s-1URL\s0 to your current directory, be sure to supply this option. Otherwise the file will end to the directory pointer by \*(C`lcd:\*(C'.</p>
  </dd>
  <dt>
    <strong>--no-save</strong>
  </dt>
  <dd>
    <p>Ignore \*(C`save:\*(C' directives in configuration file. If the URLs have \*(C`save:\*(C' options, they are ignored during fetch. You usually want to combine <strong>--no-lcd</strong> with <strong>--no-save</strong></p>
  </dd>
  <dt>
    <strong>--no-extract</strong>
  </dt>
  <dd>
    <p>Ignore \*(C`x:\*(C' directives in configuration file.</p>
  </dd>
  <dt>
    <strong>-O, --output \s-1DIR\s0</strong>
  </dt>
  <dd>
    <p>Before retrieving any files, chdir to \s-1DIR\s0.</p>
  </dd>
  <dt>
    <strong>-o, --overwrite</strong>
  </dt>
  <dd>
    <p>Allow overwriting existing files when retrieving URLs. Combine this with <strong>--skip-version</strong> if you periodically update files.</p>
  </dd>
  <dt>
    <strong>--proxy \s-1PROXY\s0</strong>
  </dt>
  <dd>
    <p>Use \s-1PROXY\s0 server for \s-1HTTP\s0. (See <strong>--Firewall</strong> for \s-1FTP\s0.). The port number is optional in the call:     --proxy http://example.com.proxy.com     --proxy example.com.proxy.com:8080</p>
  </dd>
  <dt>
    <strong>-p, --prefix \s-1PREFIX\s0</strong>
  </dt>
  <dd>
    <p>Add \s-1PREFIX\s0 to all retrieved files.</p>
  </dd>
  <dt>
    <strong>-P, --postfix \s-1POSTFIX\s0 </strong>
  </dt>
  <dd>
    <p>Add \s-1POSTFIX\s0 to all retrieved files.</p>
  </dd>
  <dt>
    <strong>-D, --prefix-date</strong>
  </dt>
  <dd>
    <p>Add iso8601 \*(L":YYYY-MM-DD\*(R" prefix to all retrived files. This is added before possible <strong>--prefix-www</strong> or <strong>--prefix</strong>.</p>
  </dd>
  <dt>
    <strong>-W, --prefix-www</strong>
  </dt>
  <dd>
    <p>Usually the files are stored with the same name as in the \s-1URL\s0 dir, but if you retrieve files that have identical names you can store each page separately so that the file name is prefixed by the site name.     http://example.com/page.html    --&gt; example.com::page.html     http://example2.com/page.html   --&gt; example2.com::page.html</p>
  </dd>
  <dt>
    <strong>-r, --regexp \s-1REGEXP\s0</strong>
  </dt>
  <dd>
    <p>Retrieve file matching at the destination \s-1URL\s0 site. This is like \*(L"Connect to the \s-1URL\s0 and get all files matching \s-1REGEXP\s0\*(R". Here all gzip compressed files are found form \s-1HTTP\s0 server directory:     pwget -v -R "&#92;.gz" http://example.com/archive/</p>
  </dd>
  <dt>
    <strong>-R, --config-regexp \s-1REGEXP\s0</strong>
  </dt>
  <dd>
    <p>Retrieve URLs matching \s-1REGEXP\s0 from configuration file. This cancels <strong>--Tag</strong> options in the command line.</p>
  </dd>
  <dt>
    <strong>-s, --selftest</strong>
  </dt>
  <dd>
    <p>Run some internal tests. For maintainer or developer only.</p>
  </dd>
  <dt>
    <strong>--sleep \s-1SECONDS\s0</strong>
  </dt>
  <dd>
    <p>Sleep \s-1SECONDS\s0 before next \s-1URL\s0 request. When using regexp based downlaods that may return many hits, some sites disallow successive requests in within short period of time. This options makes program sleep for number of \s-1SECONDS\s0 between retrievals to overcome 'Service unavailable'.</p>
  </dd>
  <dt>
    <strong>--stdout</strong>
  </dt>
  <dd>
    <p>Retrieve \s-1URL\s0 and write to stdout.</p>
  </dd>
  <dt>
    <strong>--skip-version</strong>
  </dt>
  <dd>
    <p>Do not download files that have version number and which already exists on disk. Suppose you have these files and you use option <strong>--skip-version</strong>:     package.tar.gz     file-1.1.tar.gz Only file.txt is retrieved, because file-1.1.tar.gz contains version number and the file has not changed since last retrieval. The idea is, that in every release the number in in distribution increases, but there may be distributions which do not contain version number. In regular intervals you may want to load those packages again, but skip versioned files. In short: This option does not make much sense without additional option <strong>--new</strong> If you want to reload versioned file again, add option <strong>--overwrite</strong>.</p>
  </dd>
  <dt>
    <strong>-t, --test, --dry-run</strong>
  </dt>
  <dd>
    <p>Run in test mode.</p>
  </dd>
  <dt>
    <strong>-T, --tag \s-1NAME\s0 [\s-1NAME\s0] ...</strong>
  </dt>
  <dd>
    <p>Search tag \s-1NAME\s0 from the config file and download only entries defined under that tag. Refer to <strong>--config \s-1FILE\s0</strong> option description. You can give Multiple <strong>--Tag</strong> switches. Combining this option with <strong>--regexp</strong> does not make sense and the concequencies are undefined.</p>
  </dd>
  <dt>
    <strong>-v, --verbose [\s-1NUMBER\s0]</strong>
  </dt>
  <dd>
    <p>Print verbose messages.</p>
  </dd>
  <dt>
    <strong>-V, --version</strong>
  </dt>
  <dd>
    <p>Print version information.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>Get files from site:</p><p>    pwget http://www.example.com/dir/package.tar.gz ..</p><p>Display copyright file for package \s-1GNU\s0 make from Debian pages:</p><p>    pwget --stdout --regexp &apos;copyright$&apos; http://packages.debian.org/unstable/make</p><p>Get all mailing list archive files that match \*(L"gz\*(R":</p><p>    pwget --regexp gz  http://example.com/mailing-list/archive/download/</p><p>Read a directory and store it to filename \s-1YYYY-MM-DD::\s0!dir!000root-file.</p><p>    pwget --prefix-date --overwrite --verbose http://www.example.com/dir/</p><p>To update newest version of the package, but only if there is none at disk already. The <strong>--new</strong> option instructs to find newer packages and the filename is only used as a skeleton for files to look for:</p><p>    pwget --overwrite --skip-version --new --verbose &#92;         ftp://ftp.example.com/dir/packet-1.23.tar.gz</p><p>To overwrite file and add a date prefix to the file name:</p><p>    pwget --prefix-date --overwrite --verbose &#92;        http://www.example.com/file.pl</p><p>    --&gt; YYYY-MM-DD::file.pl</p><p>To add date and \s-1WWW\s0 site prefix to the filenames:</p><p>    pwget --prefix-date --prefix-www --overwrite --verbose &#92;        http://www.example.com/file.pl</p><p>    --&gt; YYYY-MM-DD::www.example.com::file.pl</p><p>Get all updated files under cnfiguration file's tag updates:</p><p>    pwget --verbose --overwrite --skip-version --new --Tag updates     pwget -v -o -s -n -T updates</p><p>Get files as they read in the configuration file to the current directory, ignoring any \*(C`lcd:\*(C' and \*(C`save:\*(C' directives:</p><p>    pwget --config $HOME/config/pwget.conf /         --no-lcd --no-save --overwrite --verbose &#92;         http://www.example.com/file.pl</p><p>To check configuration file, run the program with non-matching regexp and it parses the file and checks the \*(C`lcd:\*(C' directives on the way:</p><p>    pwget -v -r dummy-regexp</p><p>    --&gt;</p><p>    pwget.DirectiveLcd: LCD [$EUSR/directory ...]     is not a directory at /users/foo/bin/pwget line 889.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONFIGURATION FILE</h2>
        <div class="sectioncontent">
<h3>Comments</h3>
<p>The configuration file is \s-1NOT\s0 Perl code. Comments start with hash character (#).</p>
<h3>Variables</h3>
<p>At this point, variable expansions happen only in <strong>lcd:</strong>. Do not try to use them anywhere else, like in URLs.</p><p>Path variables for <strong>lcd:</strong> are defined using following notation, spaces are not allowed in \s-1VALUE\s0 part (no directory names with spaces). Varaible names are case sensitive. Variables substitute environment variabales with the same name. Environment variables are immediately available.</p><p>    VARIABLE = /home/my/dir         # define variable     VARIABLE = $dir/some/file       # Use previously defined variable     FTP      = $HOME/ftp            # Use environment variable</p><p>The right hand can refer to previously defined variables or existing environment variables. Repeat, this is not Perl code although it may look like one, but just an allowed syntax in the configuration file. Notice that there is dollar to the right hand&gt; when variable is referred, but no dollar to the left hand side when variable is defined. Here is example of a possible configuration file contant. The tags are hierarchically ordered without a limit.</p><p>Warning: remember to use different variables names in separate include files. All variables are global.</p>
<h3>Include files</h3>
<p>It is possible to include more configuration files with statement</p><p>    INCLUDE &lt;path-to-file-name&gt;</p><p>Variable expansions are possible in the file name. There is no limit how many or how deep include structure is used. Every file is included only once, so it is safe to to have multiple includes to the same file. Every include is read, so put the most importat override includes last:</p><p>    INCLUDE &lt;etc/pwget.conf&gt;             # Global     INCLUDE &lt;$HOME/config/pwget.conf&gt;    # HOME overrides it</p><p>A special \*(C`THIS\*(C' tag means relative path of the current include file, which makes it possible to include several files form the same directory where a initial include file resides</p><p>    # Start of config at /etc/pwget.conf</p><p>    # THIS = /etc, current location     include &lt;THIS/pwget-others.conf&gt;</p><p>    # Refers to directory where current user is: the pwd     include &lt;pwget-others.conf&gt;</p><p>    # end</p>
<h3>Configuraton file example</h3>
<p>The configuration file can contain many &lt;directoves:&gt;, where each directive end to a colon. The usage of each directory is best explained by examining the configuration file below and reading the commentary near each directive.</p><p>    #   $HOME/config/pwget.conf F- Perl pwget configuration file</p><p>    ROOT   = $HOME                      # define variables     CONF   = $HOME/config     UPDATE = $ROOT/updates     DOWNL  = $ROOT/download</p><p>    #   Include more configuration files. It is possible to     #   split a huge file in pieces and have "linux",     #   "win32", "debian", "emacs" configurations in separate     #   and manageable files.</p><p>    INCLUDE &lt;$CONF/pwget-other.conf&gt;     INCLUDE &lt;$CONF/pwget-more.conf&gt;</p><p>    tag1: local-copies tag1: local      # multiple names to this category</p><p>        lcd:  $UPDATE                   # chdir directive</p><p>        #  This is show to user with option --verbose         print: Notice, this site moved YYYY-MM-DD, update your bookmarks</p><p>        file://absolute/dir/file-1.23.tar.gz</p><p>    tag1: external</p><p>      lcd:  $DOWNL</p><p>      tag2: external-http</p><p>        http://www.example.com/page.html         http://www.example.com/page.html save:/dir/dir/page.html</p><p>      tag2: external-ftp</p><p>        ftp://ftp.com/dir/file.txt.gz save:xx-file.txt.gz login:foo pass:passwd x:</p><p>        lcd: $HOME/download/package</p><p>        ftp://ftp.com/dir/package-1.1.tar.gz new:</p><p>      tag2: package-x</p><p>        lcd: $DOWNL/package-x</p><p>        #  Person announces new files in his homepage, download all         #  announced files. Unpack everything (x:) and remove any         #  existing directories (xopt:rm)</p><p>        http://example.com/~foo pregexp:&#92;.tar&#92;.gz$ x: xopt:rm</p><p>    # End of configuration file pwget.conf</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LIST OF DIRECTIVES IN CONFIGURATION FILE</h2>
        <div class="sectioncontent">
<p>All the directives must in the same line where the \s-1URL\s0 is. The programs scans lines and determines all options given in line for the \s-1URL\s0. Directives can be overridden by command line options.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>cnv:CONVERSION</strong>
  </dt>
  <dd>
    <p>Currently only <strong>conv:text</strong> is available. Convert downloaded page to text. This option always needs either <strong>save:</strong> or <strong>rename:</strong>, because only those directives change filename. Here is an example:     http://example.com/dir/file.html cnv:text save:file.txt     http://example.com/dir/ pregexp:&#92;.html cnv:text rename:s/html/txt/ A <strong>text:</strong> shorthand directive can be used instead of <strong>cnv:text</strong>.</p>
  </dd>
  <dt>
    <strong>cregexp:REGEXP</strong>
  </dt>
  <dd>
    <p>Download file only if the content matches \s-1REGEXP\s0. This is same as option <strong>--Regexp-content</strong>. In this example directory listing Emacs lisp packages (.el) are downloaded but only if their content indicates that the Author is Mr. Foo:     http://example.com/index.html cregexp:(?i)author:.*Foo pregexp:&#92;.el$</p>
  </dd>
  <dt>
    <strong>lcd:DIRECTORY</strong>
  </dt>
  <dd>
    <p>Set local download directory to \s-1DIRECTORY\s0 (chdir to it). Any environment variables are substituted in path name. If this tag is found, it replaces setting of <strong>--Output</strong>. If path is not a directory, terminate with error. See also <strong>--Create-paths</strong> and <strong>--no-lcd</strong>.</p>
  </dd>
  <dt>
    <strong>login:LOGIN-NAME</strong>
  </dt>
  <dd>
    <p>Ftp login name. Default value is \*(L"anonymous\*(R".</p>
  </dd>
  <dt>
    <strong>mirror:SITE</strong>
  </dt>
  <dd>
    <p>This is relevant to Sourceforge only which does not allow direct downloads with links. Visit project's Sourceforge homepage and see which mirrors are available for downloading. An example:   http://sourceforge.net/projects/austrumi/files/austrumi/austrumi-1.8.5/austrumi-1.8.5.iso/download new: mirror:kent</p>
  </dd>
  <dt>
    <strong>new:</strong>
  </dt>
  <dd>
    <p>Get newest file. This variable is reset to the value of <strong>--new</strong> after the line has been processed. Newest means, that an \*(C`ls\*(C' command is run in the ftp, and something equivalent in \s-1HTTP\s0 \*(L"ftp directories\*(R", and any files that resemble the filename is examined, sorted and heurestically determined according to version number of file which one is the latest. For example files that have version information in \s-1YYYYMMDD\s0 format will most likely to be retrieved right. Time stamps of the files are not checked. The only requirement is that filename \*(C`must\*(C' follow the universal version numbering standard:     FILE-VERSION.extension      # de facto VERSION is defined as [&#92;d.]+</p><p>    file-19990101.tar.gz        # ok     file-1999.0101.tar.gz       # ok     file-1.2.3.5.tar.gz         # ok</p><p>    file1234.txt                # not recognized. Must have "-"     file-0.23d.tar.gz           # warning, letters are problematic Files that have some alphabetic version indicator at the end of \s-1VERSION\s0 may not be handled correctly. Contact the developer and inform him about the de facto standard so that files can be retrieved more intelligently. <em>\s-1NOTE:\s0</em> In order the <strong>new:</strong> directive to know what kind of files to look for, it needs a file tamplate. You can use a direct link to some filename. Here the location \*(L"http://www.example.com/downloads\*(R" is examined and the filename template used is took as \*(L"file-1.1.tar.gz\*(R" to search for files that might be newer, like \*(L"file-9.1.10.tar.gz\*(R":   http://www.example.com/downloads/file-1.1.tar.gz new: If the filename appeard in a named page, use directive <strong>file:</strong> for template. In this case the \*(L"download.html\*(R" page is examined for files looking like \*(L"file.*tar.gz\*(R" and the latest is searched:   http://www.example.com/project/download.html file:file-1.1.tar.gz new:</p>
  </dd>
  <dt>
    <strong>overwrite:</strong> <strong>o:</strong>
  </dt>
  <dd>
    <p>Same as turning on <strong>--overwrite</strong></p>
  </dd>
  <dt>
    <strong>page:</strong>
  </dt>
  <dd>
    <p>Read web page and apply commands to it. An example: contact the root page and save it:    http://example.com/~foo page: save:foo-homepage.html In order to find the correct information from the page, other directives are usually supplied to guide the searching. 1) Adding directive \*(C`pregexp:ARCHIVE-REGEXP\*(C' matches the A \s-1HREF\s0 links in the page. 2) Adding directive <strong>new:</strong> instructs to find newer \s-1VERSIONS\s0 of the file. 3) Adding directive \*(C`file:DOWNLOAD-FILE\*(C' tells what template to use to construct the downloadable file name. This is needed for the \*(C`new:\*(C' directive. 4) A directive \*(C`vregexp:VERSION-REGEXP\*(C' matches the exact location in the page from where the version information is extracted. The default regexp looks for line that says \*(L"The latest version ... is ... N.N\*(R". The regexp must return submatch 2 for the version number. \s-1AN\s0 \s-1EXAMPLE\s0 Search for newer files from a \s-1HTTP\s0 directory listing. Examine page http://www.example.com/download/dir for model \*(C`package-1.1.tar.gz\*(C' and find a newer file. E.g. \*(C`package-4.7.tar.gz\*(C' would be downloaded.     http://www.example.com/download/dir/package-1.1.tar.gz new: \s-1AN\s0 \s-1EXAMPLE\s0 Search for newer files from the content of the page. The directive <strong>file:</strong> acts as a model for filenames to pay attention to.     http://www.example.com/project/download.html new: pregexp:tar.gz file:package-1.1.tar.gz \s-1AN\s0 \s-1EXAMPLE\s0 Use directive <strong>rename:</strong> to change the filename before soring it on disk. Here, the version number is attached to the actila filename:     file.txt-1.1     file.txt-1.2 The directived needed would be as follows; entries have been broken to separate lines for legibility:     http://example.com/files/     pregexp:&#92;.el-&#92;d     vregexp:(file.el-([&#92;d.]+))     file:file.el-1.1     new:     rename:s/-[&#92;d.]+// This effectively reads: \*(L"See if there is new version of something that looks like file.el-1.1 and save it under name file.el by deleting the extra version number at the end of original filename\*(R". \s-1AN\s0 \s-1EXAMPLE\s0 Contact absolute <strong>page:</strong> at http://www.example.com/package.html and search A \s-1HREF\s0 urls in the page that match <strong>pregexp:</strong>. In addition, do another scan and search the version number in the page from thw position that match <strong>vregexp:</strong> (submatch 2). After all the pieces have been found, use template <strong>file:</strong> to make the retrievable file using the version number found from <strong>vregexp:</strong>. The actual download location is combination of <strong>page:</strong> and A \s-1HREF\s0 <strong>pregexp:</strong> location. The directived needed would be as follows; entries have been broken to separate lines for legibility:     http://www.example.com/~foo/package.html     page:     pregexp: package.tar.gz     vregexp: ((?i)latest.*?version.*?&#92;b([&#92;d][&#92;d.]+).*)     file: package-1.3.tar.gz     new:     x: An example of web page where the above would apply:     &lt;HTML&gt;     &lt;BODY&gt;</p><p>    The latest version of package is &lt;B&gt;2.4.1&lt;/B&gt; It can be     downloaded in several forms:</p><p>        &lt;A HREF="download/files/package.tar.gz"&gt;Tar file&lt;/A&gt;         &lt;A HREF="download/files/package.zip"&gt;ZIP file</p><p>    &lt;/BODY&gt;     &lt;/HTML&gt; For this example, assume that \*(C`package.tar.gz\*(C' is a symbolic link pointing to the latest release file \*(C`package-2.4.1.tar.gz\*(C'. Thus the actual download location would have been \*(C`http://www.example.com/~foo/download/files/package-2.4.1.tar.gz\*(C'. Why not simply download \*(C`package.tar.gz\*(C'? Because then the program can't decide if the version at the page is newer than one stored on disk from the previous download. With version numbers in the file names, the comparison is possible.</p>
  </dd>
  <dt>
    <strong>page:find</strong>
  </dt>
  <dd>
    <p>\s-1FIXME:\s0 This opton is obsolete. do not use. \s-1THIS\s0 \s-1IS\s0 \s-1FOR\s0 \s-1HTTP\s0 only. Use Use directive <strong>regexp:</strong> for \s-1FTP\s0 protocls. This is a more general instruction than the <strong>page:</strong> and <strong>vregexp:</strong> explained above. Instruct to download every \s-1URL\s0 on \s-1HTML\s0 page matching <strong>pregexp:RE</strong>. In typical situation the page maintainer lists his software in the development page. This example would download every tar.gz file in the page. Note, that the \s-1REGEXP\s0 is matched against the A \s-1HREF\s0 link content, not the actual text that is displayed on the page:     http://www.example.com/index.html page:find pregexp:&#92;.tar.gz$ You can also use additional <strong>regexp-no:</strong> directive if you want to exclude files after the <strong>pregexp:</strong> has matched a link.     http://www.example.com/index.html page:find pregexp:&#92;.tar.gz$ regexp-no:desktop</p>
  </dd>
  <dt>
    <strong>pass:PASSWORD</strong>
  </dt>
  <dd>
    <p>For \s-1FTP\s0 logins. Default value is \*(C`nobody@example.com\*(C'.</p>
  </dd>
  <dt>
    <strong>pregexp:RE</strong>
  </dt>
  <dd>
    <p>Search A \s-1HREF\s0 links in page matching a regular expression. The regular expression must be a single word with no whitespace. This is incorrect:     pregexp:(this regexp ) It must be written as:     pregexp:(this&#92;s+regexp&#92;s)</p>
  </dd>
  <dt>
    <strong>print:MESSAGE</strong>
  </dt>
  <dd>
    <p>Print associated message to user requesting matching tag name. This directive must in separate line inside tag.     tag1: linux</p><p>      print: this download site moved 2002-02-02, check your bookmarks.       http://new.site.com/dir/file-1.1.tar.gz new: The \*(C`print:\*(C' directive for tag is shown only if user turns on --verbose mode:     pwget -v -T linux</p>
  </dd>
  <dt>
    <strong>rename:PERL-CODE</strong>
  </dt>
  <dd>
    <p>Rename each file using PERL-CODE. The PERL-CODE must be full perl program with no spaces anywhere. Following variables are available during the <em>eval()</em> of code:     $ARG = current file name     $url = complete url for the file     The code must return $ARG which is used for file name For example, if page contains links to .html files that are in fact text files, following statement would change the file extensions:     http://example.com/dir/ page:find pregexp:&#92;.html rename:s/html/txt/ You can also call function \*(C`MonthToNumber($string)\*(C' if the filename contains written month name, like &lt;2005-February.mbox&gt;.The function will convert the name into number. Many mailing list archives can be donwloaded cleanly this way.     #  This will download SA-Exim Mailing list archives:     http://lists.merlins.org/archives/sa-exim/ pregexp:&#92;.txt$ rename:$ARG=MonthToNumber($ARG) Here is a more complicated example:     http://www.contactor.se/~dast/svnusers/mbox.cgi pregexp:mbox.*&#92;d$ rename:my($y,$m)=($url=~/year=(&#92;d+).*month=(&#92;d+)/);$ARG="$y-$m.mbox" Let's break that one apart. You may spend some time with this example since the possiblilities are limitless.     1. Connect to page        http://www.contactor.se/~dast/svnusers/mbox.cgi</p><p>    2. Search page for URLs matching regexp &apos;mbox.*&#92;d$&apos;. A        found link could match hrefs like this:        http://svn.haxx.se/users/mbox.cgi?year=2004&month=12</p><p>    3. The found link is put to $ARG (same as $_), which can be used        to extract suitable mailbox name with a perl code that is        evaluated. The resulting name must apear in $ARG. Thus the code        effectively extract two items from the link to form a mailbox        name:</p><p>        my ($y, $m) = ( $url =~ /year=(&#92;d+).*month=(&#92;d+)/ )         $ARG = "$y-$m.mbox"</p><p>        =&gt; 2004-12.mbox Just remember, that the perl code that follows \*(C`rename:\*(C' directive <strong>must</strong> must not contain any spaces. It all must be readable as one string.</p>
  </dd>
  <dt>
    <strong>regexp:REGEXP</strong>
  </dt>
  <dd>
    <p>Get all files in ftp directory matching regexp. Directive <strong>save:</strong> is ignored.</p>
  </dd>
  <dt>
    <strong>regexp-no:REGEXP</strong>
  </dt>
  <dd>
    <p>After the \*(C`regexp:\*(C' directive has matched, exclude files that match directive <strong>regexp-no:</strong></p>
  </dd>
  <dt>
    <strong>Regexp:REGEXP</strong>
  </dt>
  <dd>
    <p>This option is for interactive use. Retrieve all files from \s-1HTTP\s0 or \s-1FTP\s0 site which match \s-1REGEXP\s0.</p>
  </dd>
  <dt>
    <strong>save:LOCAL-FILE-NAME</strong>
  </dt>
  <dd>
    <p>Save file under this name to local disk.</p>
  </dd>
  <dt>
    <strong>tagN:NAME</strong>
  </dt>
  <dd>
    <p>Downloads can be grouped under \*(C`tagN\*(C' so that e.g. option <strong>--Tag1</strong> would start downloading files from that point on until next \*(C`tag1\*(C' is found. There are currently unlimited number of tag levels: tag1, tag2 and tag3, so that you can arrange your downlods hierarchially in the configuration file. For example to download all Linux files rhat you monitor, you would give option <strong>--Tag linux</strong>. To download only the \s-1NT\s0 Emacs latest binary, you would give option <strong>--Tag emacs-nt</strong>. Notice that you do not give the \*(C`level\*(C' in the option, program will find it out from the configuration file after the tag name matches. The downloading stops at next tag of the \*(C`same level\*(C'. That is, tag2 stops only at next tag2, or when upper level tag is found (tag1) or or until end of file.     tag1: linux             # All Linux downlods under this category</p><p>        tag2: sunsite    tag2: another-name-for-this-spot</p><p>        #   List of files to download from here</p><p>        tag2: ftp.funet.fi</p><p>        #   List of files to download from here</p><p>    tag1: emacs-binary</p><p>        tag2: emacs-nt</p><p>        tag2: xemacs-nt</p><p>        tag2: emacs</p><p>        tag2: xemacs</p>
  </dd>
  <dt>
    <strong>x:</strong>
  </dt>
  <dd>
    <p>Extract (unpack) file after download. See also option <strong>--unpack</strong> and <strong>--no-extract</strong> The archive file, say .tar.gz will be extracted the file in current download location. (see directive <strong>lcd:</strong>) The unpack procedure checks the contents of the archive to see if the package is correctly formed. The de facto archive format is     package-N.NN.tar.gz In the archive, all files are supposed to be stored under the proper subdirectory with version information:     package-N.NN/doc/README     package-N.NN/doc/INSTALL     package-N.NN/src/Makefile     package-N.NN/src/some-code.java \*(C`IMPORTANT:\*(C' If the archive does not have a subdirectory for all files, a subdirectory is created and all items are unpacked under it. The defualt subdirectory name in constructed from the archive name with currect date stamp in format:     package-YYYY.MMDD If the archive name contains something that looks like a version number, the created directory will be constructed from it, instead of current date.     package-1.43.tar.gz    =&gt;  package-1.43</p>
  </dd>
  <dt>
    <strong>xx:</strong>
  </dt>
  <dd>
    <p>Like directive <strong>x:</strong> but extract the archive \*(C`as is\*(C', without checking content of the archive. If you know that it is ok for the archive not to include any subdirectories, use this option to suppress creation of an artificial root package-YYYY.MMDD.</p>
  </dd>
  <dt>
    <strong>xopt:rm</strong>
  </dt>
  <dd>
    <p>This options tells to remove any previous unpack directory. Sometimes the files in the archive are all read-only and unpacking the archive second time, after some period of time, would display     tar: package-3.9.5/.cvsignore: Could not create file:     Permission denied</p><p>    tar: package-3.9.5/BUGS: Could not create file:     Permission denied This is not a serious error, because the archive was already on disk and tar did not overwrite previous files. It might be good to inform the archive maintainer, that the files have wrong permissions. It is customary to expect that distributed packages have writable flag set for all files.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ERRORS</h2>
        <div class="sectioncontent">
<p>Here is list of possible error messages and how to deal with them. Turning on  <strong>--debug</strong> will help to understand how program has interpreted the configuration file or command line options. Pay close attention to the generated output, because it may reveal that a regexp for a site is too lose or too tight.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>\s-1ERROR\s0 {\s-1URL-HERE\s0} Bad file descriptor</strong>
  </dt>
  <dd>
    <p>This is \*(L"file not found error\*(R". You have written the filename incorrectly. Double check the configuration file's line.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS AND LIMITATIONS</h2>
        <div class="sectioncontent">
<p>\*(C`Sourceforge note\*(C': To download archive files from Sourceforge requires some trickery because of the redirections and load balancers the site uses. The Sourceforge page have also undergone many changes during their existence. Due to these changes there exists an ugly hack in the program to use <em>wget</em>\|(1) to get certain infomation from the site. This could have been implemented in pure Perl, but as of now the developer hasn't had time to remove the <em>wget</em>\|(1) dependency. No doubt, this is an ironic situation to use <em>wget</em>\|(1). You you have Perl skills, go ahead and look at <em>UrlHttGet()</em>. <em>UrlHttGetWget()</em> and sen patches.</p><p>The program was initially designed to read options from one line. It is unfortunately not possible to change the program to read configuration file directives from multiple lines, e.g. by using backslashes (&#92;) to indicate contuatinued line.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ENVIRONMENT</h2>
        <div class="sectioncontent">
<p>Variable \*(C`PWGET_CFG\*(C' can point to the root configuration file. The configuration file is read at startup if it exists.</p><p>    export PWGET_CFG=$HOME/conf/pwget.conf     # /bin/hash syntax     setenv PWGET_CFG $HOME/conf/pwget.conf     # /bin/csh syntax</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXIT STATUS</h2>
        <div class="sectioncontent">
<p>Not defined.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DEPENDENCIES</h2>
        <div class="sectioncontent">
<p>External utilities:</p><p>    <strong>wget</strong>(1)   only needed for Sourceforge.net downloads               see BUGS AND LIMITATIONS</p><p>Non-core Perl modules from \s-1CPAN:\s0</p><p>    LWP::UserAgent     Net::FTP</p><p>The following modules are loaded in run-time only if directive <strong>cnv:text</strong> is used. Otherwise these modules are not loaded:</p><p>    HTML::Parse     HTML::TextFormat     HTML::FormatText</p><p>This module is loaded in run-time only if \s-1HTTPS\s0 scheme is used:</p><p>    Crypt::SSLeay</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO pwget&hellip;</h2>
        <div class="sectioncontent">
<p><em>lwp-download</em>\|(1) <em>lwp-mirror</em>\|(1) <em>lwp-request</em>\|(1) <em>lwp-rget</em>\|(1) <em>wget</em>\|(1)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Jari Aalto</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LICENSE AND COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright (C) 1996-2010 Jari Aalto</p><p>This program is free software; you can redistribute and/or modify program under the terms of \s-1GNU\s0 General Public license either version 2 of the License, or (at your option) any later version.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="pwgen.1.html"><span aria-hidden="true">&larr;</span> pwgen.1: Generate pronounceable passwords</a></li>
   <li class="next"><a href="pwi2xsf.1.html">pwi2xsf.1: Convert the pw.x input file to xsf format <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>weplab: Wireless wep encryption security analyzer</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Wireless wep encryption security analyzer">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="weplab (1) manual">
  <meta name="twitter:description" content="Wireless wep encryption security analyzer">
  <meta name="twitter:image" content="https://www.carta.tech/images/weplab-weplab-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/weplab.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="weplab (1) manual" />
  <meta property="og:description" content="Wireless wep encryption security analyzer" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/weplab-weplab-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">weplab<small> (1)</small></h1>
        <p class="lead">Wireless wep encryption security analyzer</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/weplab.1.html">
      <span itemprop="name">weplab: Wireless wep encryption security analyzer</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/weplab/">
      <span itemprop="name">weplab</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/weplab.1.html">
      <span itemprop="name">weplab: Wireless wep encryption security analyzer</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>weplab</strong> {-a | -r | -b | -y | -c} [options] {<strong>pcap file</strong>}</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>weplab is a tool to review the security of WEP encryption in wireless networks from an educational point of view. Several attacks are available (including advanced statistical attacks) so it can be measured the efectiveness and minimun requirements of each one.</p><p>On the other hand, weplab can also be saw as an advanced Wireless WEP encryption cracker that aims to support a big variety of attacks. At the moment the attacks supported are dictionary based, bruteforce and several kind of statistical based.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p>-a, --analyze</p>
  </dt>
  <dd>
    <p>Analyzes specific file and gathers some statistics about the packets that are stored per detected wlan network.</p>
  </dd>
  <dt>
    <p>-c, --capture</p>
  </dt>
  <dd>
    <p>Uses a wlan interface to capture wep encrypted data packets. Those captured packets will be logged into a file in pcap format and can be used later to crack the key.</p>
  </dd>
  <dt>
    <p>-b, --bruteforce</p>
  </dt>
  <dd>
    <p>Launches a bruteforce attack to break the key. That means that weplab will test all possible keys in order to find the right one.</p><p>Please, that this can take lot of time depending on the key size and your processor speed. Refer to Bruteforce method above in this document for futher information.</p><p>If no BSSID was specified, those packets who belong to the same network as the first one, will be used for the crack.</p>
  </dd>
  <dt>
    <p>-r, --heuristics</p>
  </dt>
  <dd>
    <p>Launches an statistical attack to break the key. This is the fastest method to crack the key if you own enough packets. As an example a 64-bit key can be broken from 100.000 packets, and a 128-bit key from 300.000 packets, within 1-2 hours. With enough packets (lets say 900.000), the cracking time is matter of seconds.</p><p>Several statistical attacks will be used depending on the selected stability level (3 by default). The processor time and number of packets required, highly depends on the parameters used to launch the attack.</p><p>This method is very advanced. You are fully encouraged to understand it reading its section on this document. Although it use to work fine with default options and having, enough packets, its better to understand how it works so you can tweak the procedure using the apropiate parameters.</p><p>If no BSSID was specified, those packets who belong to the same network as the first one, will be used for the crack.</p>
  </dd>
  <dt>
    <p>-y, --dictionary</p>
  </dt>
  <dd>
    <p>Launches a dictionary based attack to break the key.</p><p>Many WEP keys are derived from pass-phrases, entered by the network administrator. When, this happens and you do not have enough packets to launch a statistical attack, it is better to use a dictionary based cracking than a bruteforce aproach.</p><p>On dictionary attack, John the Ripper is used to generate the words that weplab will use to derive the WEP key. So, John the Ripper must be present and executed so its output is piped into weplabs input. In the EXAMPLES section you will find several examples about that.</p><p>If no BSSID was specified, those packets who belong to the same network as the first one, will be used for the crack.</p>
  </dd>
  <dt>
    <p>-k, --key <em>&lt;key_length&gt;</em></p>
  </dt>
  <dd>
    <p>Specify the key length. It can be either 64 or 128-bit</p><p>This option is only usefull within a cracking method, so -y, -r or -b must be used in conjuntion with it.</p><p>Default: 64 bits.</p>
  </dd>
  <dt>
    <p>--keyid <em>&lt;key_id&gt;</em></p>
  </dt>
  <dd>
    <p>Specify the key id for 64-bit keys.</p><p>For 64-bit keys the WEP standard specifies four possible keys, each one with a different keyid (0-3). Usually only keyid 0 is used, but if you hit a network with more keyids you will need to use this option to specify one of them, and launch a separate cracking attack for each one.</p><p>Default: 0</p>
  </dd>
  <dt>
    <p>--fcs</p>
  </dt>
  <dd>
    <p>Specify the presence of a 1 byte FCS tail on all logged packets</p><p>Depending on your driver and how did you set your card into monitor mode , it is possible than logged packets have an aditional tail of 1 byte length.</p><p>Best way to find out if your card/drivers needs this, is trying to break your own network. This way, as you already know the key, if it does not get cracked without FCS, try with it.</p><p>This option is only usefull within a cracking method, so -y, -r or -b must be used in conjuntion with it.</p><p>Default: fcs not present.</p>
  </dd>
  <dt>
    <p>--prismheader</p>
  </dt>
  <dd>
    <p>Specify the presence of an special header called PrismHeader on all logged packets</p><p>Depending on your driver and how did you set your card into monitor mode , it is possible than logged packets have an aditional header of 144 bytes length.</p><p>If you want to know if you need it or not, just analyze the file with weplab. If prismheader is not necessary it will tell you. If it is neccesary, you will see lot of bogus BSSIDs, and no adversice about not using prismehader</p><p>Anyway, cracking your own WEP key is the best method to know if you need it or not.</p><p>This option is only usefull within a cracking method, so -y, -r or -b must be used in conjuntion with it. From weplab 0.1.2 you will also need to specify it with -a in order weplab to show you the right BSSIDs found.</p><p>Default: prismheader not present.</p>
  </dd>
  <dt>
    <p>--bssid <em>&lt;bssid_in_hex&gt;</em></p>
  </dt>
  <dd>
    <p>Only use those packets that belongs to the selected BSSID.</p><p>BSSID must be in the form of AA:BB:CC:DD:EE:FF</p><p>If BSSID is not specified only those packets, that belong to the same BSSID as the first one, will be used</p><p>Use -a with your file if you want to see all detected BSSIDs</p><p>This option is only usefull within a cracking method, so -y, -r or -b must be used in conjuntion with it.</p><p>Default: none</p>
  </dd>
  <dt>
    <p>--caplen <em>&lt;amount&gt;</em></p>
  </dt>
  <dd>
    <p>Specify the amount of bytes that will be logged for each packets.</p><p>In order to launch an attack only a few number of packets (10) must be fully logged. For the statistical attacks, only the first bytes of other packets are needed.</p><p>In order to save diskspace when logging packets for the statistical attack, ony the begining of the packet should be logged</p><p>If you specify 0 here, the whole packet will be logged.</p><p>Please, notice that you will need to capture at least 10 packets behind this amount (fully logged packets), as they will be needed for testing candidate keys within the cracking process.</p><p>Default: 1500</p>
  </dd>
  <dt>
    <p>-i <em>&lt;interface&gt;</em></p>
  </dt>
  <dd>
    <p>Specifies the wireless interface that will be used to capture packets.</p><p>weplab does not set the interface into monitor mode, so you must do it yourself before capturing packets. Read the above to learn how to do it.</p>
  </dd>
  <dt>
    <p>-m, --multiprocess <em>&lt;number&gt;</em></p>
  </dt>
  <dd>
    <p>Specifies the number of threads that will be launched to take advantage of multiprocessors systems. If your microprocessor supports hyperthreading please use the double of number of microprocessors.</p><p>For example, use -m 4 if you own a dual P4 hyperthreading and -m 2 if you own a dual processor P-II machine.</p><p>At the moment this option does only work on bruteforce attack.</p><p>Default: 1</p>
  </dd>
  <dt>
    <p>--ascii</p>
  </dt>
  <dd>
    <p>When launching a bruteforce attack, it is faster to search only ascii bytes if you are sure that the WEP key was generating from a pass phrase using ascii direct-mapping.</p><p>This way, each key byte will only be tested in the range of 00-3F. As the key-space is smaller the attack is faster.</p>
  </dd>
  <dt>
    <p>--perc <em>&lt;probability&gt;</em></p>
  </dt>
  <dd>
    <p>Specify the desired minimun probability for the statistical attack. It means that at least enough candidate key bytes will be tested to fit this probability.</p><p>In order to fully understand this option you are encouraged to read carefully the "Statistical Attacks" caption, above in this document.</p><p>Please note that the higher the minimun probability the slowest the attack. For most cases 50% is fine. You can increase to 60 or 70% if you get the KEY NOT FOUND with 50, but never increase it to 100% because you will be waiting for ever.</p>
  </dd>
  <dt>
    <p>--stability <em>&lt;level&gt;</em></p>
  </dt>
  <dd>
    <p>Specify the predefined set of statistical attacks based on their stability level. Not all the statistical attacks are stable (works fine) your every key. Some of them are more unstable than others. This options allows you to launch only those attacks that meets the specified stability level.</p><p>Level can be from 1 to 5. The highest the more stable. I do not recomment you to go for level 1 because it is too unstable to give you any results. By default level 3 is used. It is a good idea to change into level 2 if you have little unique IV and cracking with level 3 failed.</p><p>In the Statistical Attack caption, you will find a detailed list of the 17 attacks implemented with the stability level of each one.</p>
  </dd>
  <dt>
    <p>--attacks <em>#attack1,#attack2,#attack2</em></p>
  </dt>
  <dd>
    <p>This is the other way to select the statistical attacks that will be launched, without using --stability parameter. Only those attacks, whose number is selected here, will be used in the statistical procedure.</p><p>The number of the attacks go from 1 to 17. Please, refer to the Statistical Attacks section for further information.</p>
  </dd>
  <dt>
    <p>--debugkey <em>&lt;key&gt;</em></p>
  </dt>
  <dd>
    <p>if you want to test how a set of statistical attacks works with a known WEP key, then this parameter will give you the oportunity to get the final result without going trhow all the possible branches.</p><p>Using this option you tell weplab about the WEP key used to encrypt the packets. Only the real branch will be followed and you will get the candidate list for each key byte.</p>
  </dd>
  <dt>
    <p>-V</p>
  </dt>
  <dd>
    <p>Outputs version information and exists.</p>
  </dd>
  <dt>
    <p>-h</p>
  </dt>
  <dd>
    <p>Displays command line parameters help.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INSTALLATION</h2>
        <div class="sectioncontent">
<p>weplab does not need any special installation. It runs in userlevel and only requires the libpcap libraries (&gt;=0.8) to be present. For most functions weplab can be executed by any user, however for packet capture functionality it must be executed by root.</p><p>if you are installing it from source code distribution, the configure script should be able to detect your proccessor type to optimize the code specifically for your platform.</p><p>At least 128 MB of free RAM memmory are required to run FMS statistical attack in weplab, 64 MB of free ram for capturing packets, and nothing special for the other features.</p><p>Weplab is reported to work fine under GNU/Linux for intel, GNU/Linux for PPC and MacOSX.</p><p>Windows version cannot capture packets due to the lack of a opensource method to do it, but its other features works fine. Please read Windows Platform section under Capture Packets caption for futher information about how to deal with this issue under Windows.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CAPTURING PACKETS</h2>
        <div class="sectioncontent">
<p>First you will need to capture 802.11b encrypted packets to crack the wep key. The way weplab cracks the key is using passive attacks to an already captured packet set.</p><p>To capture encrypted packets in a wireless network, your wireless card must be put in monitor mode. The way monitor mode is set is highly dependant on which card do you own, and which drivers are you using.</p><p>Explaining how to set monitor mode in your card is beyond the scope of this document, and sometimes involves patching the kernel or "hacking" the drivers. As an example, the following steps should be done in order to set monitor mode on a prism2 based card using wlan-ng drivers.</p>
<dl class='dl-vertical'>
  <dt>
    <p>Initialization of the card.</p>
  </dt>
  <dd>
    <p>prism2 and wlan-ng</p><p>wlanctl-ng wlan0 lnxreq_ifstate ifstate=enable</p><p>wlanctl-ng wlan0 lnxreq_autojoin ssid=any authtype=opensystem</p><p>orinoco : nothing special</p>
  </dd>
  <dt>
    <p>Enable the interface (wlan0 in the example, just change to eth0 if using orinoco)</p>
  </dt>
  <dd>
    <p>ifconfig wlan0 up</p>
  </dd>
  <dt>
    <p>Setting monitor mode on desired channel (6 in the example).</p>
  </dt>
  <dd>
    <p>prism2 and wlan-ng</p><p>wlanctl-ng wlan0 lnxreq_wlansniff channel=06 keepwepflags=false prismheader=false enable=true (I dont know why, but sometimes this step must be taken twice :) )</p><p>orinoco and iwpriv</p><p>iwpriv eth0 monitor 2 6</p>
  </dd>

</dl>
<p>There are a few things that must be done regardless of the card and drivers used.</p><p>1. The wireless card placed in monitor mode should accept encrypted packets and mark them as encrypted. In the example above, that's the purpose of the option keepwepflags=false in third step.</p><p>2. The interface must be enabled (up)</p><p>3. If your card is appending prism header or fcs "tail" to the packets, weplab needs to be told about it (with --fcs or --prismheader). Determining if this is necessary for your hardware will be explained later.</p><p>Now, to capture encrypted packets you can either use weplab, tcpdump, or a similar sniffer that logs packets in pcap format.</p><p>To do it with weplab, just use -c. Interface must be specified with -i</p><p>weplab --debug 1 -c -i wlan0 ./packets.log</p><p>There is no need to log the entire packet, just the 802.11 header and the IV, but to verify possible canditate keys the whole packet encrypted payload must be present. That's why you must specify two files in weplab when using FMS attack. One file must have just 10 packets with the whole payload, and the other file contains weak packets that don't need to have payload logged.</p><p>So, in order to save disk space it is a good idea to log a few packets for key verification on one file, and then just log the first bytes of all other possible packets, to be used as possible weak packet for FMS attack.</p><p>You can specify maximun captured bytes per packet with --caplen bytes</p><p>weplab -c -i wlan0 --debug 1 ./verification_packets.logweplab -c -i wlan0 --debug 1 --caplen 100 ./weak_packets.log</p><p>Alternately, if your disk space is not so critical and you don't mind wasting a few extra seconds on loading the file later, these two steps can be joined into one.</p><p>weplab -c -i wlan0 --debug 1 --caplen 150 ./packets.log</p><p>Then this file can be used both for verification and weak packets.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ANALYZING PCAP FILE</h2>
        <div class="sectioncontent">
<p>Before trying to crack the key using the already captured packets, it is a good idea to verify the file just to ensure that the packets were logged fine, and there are enough to perform the desired attack.</p><p>weplab --debug 1 -a ./packets.log</p><p>You can try with --prismheader or --fcs, or both.</p><p>weplab --debug 1 -a --fcs ./packets.logweplab --debug 1 -a --prismheader --fcs ./packets.log</p><p>As explained above, prismheader is an special header that some cards and drivers add to all captured packets, and fcs is an special tail added to the captured packets by some drivers. You can determine if your card/drivers needs --fcs or --prismheaders by using the FMS attack together with --debugkey and a set of encrypted packets captured by your card where the wep key is known. This is explained later in the FMS attack section.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">WEP KEY CRACKING.</h2>
        <div class="sectioncontent">
<p>At the moment weplab supports 2 main cracking methods: bruteforce and FMS statistical attack. Before selecting the cracking method, the keysize should be specified. By default the keysize is 64. To crack a 128-bit key, you must specify --key 128</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BRUTEFORCE CRACKING.</h2>
        <div class="sectioncontent">
<p>Bruteforce cracking means testing all possible keys to find the right one. That means that each key byte can take values from 0 to 255. So a quick calculus will reveal that for a 64 bits key the total combinations are 2^40, so at 100.000 c/s cracking the key will take you 4100061318 seconds maximun. 127 days working fulltime.</p><p>With a 128-bit key the total combinations possible are 2^104, so at 100.000 c/s the total maximun amount of time will be 6520836420927105974 YEARS!! I guess you will never try to launch a bruteforce attack to a 128-bit key. Anyway, weplab gives you the possibility to do it ;)</p><p>You will need at least 10 full wep encrypted data captured packets in order to launch a bruteforce attack avoiding false positives.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DICTIONNARY CRACKING</h2>
        <div class="sectioncontent">
<p>Guess what ? Users often use simple words as their WEP key. The dictionnary cracking mode gives you the ability to check if the WEP key isn't a so-simple-to-guess word. Using this mode in addition to John-the-Ripper could produce some usefull results.</p><p>Weplab reads the dictionnary words from STDIN, so if you want statistics, you want be able to press SPACE. However, you'll have statistics printed on STDOUT every 10 seconds.</p><p>Dictionary cracking can use two different modes :</p><p>By default the classical algorithm (MD5 for 128 bits keys or one of 4 keys for 40 bits keys) it is used. This mode is widely used on Access Points to generate keys from a passphrase.</p><p>Alternatively you can select Word to key with the "--attack 2" option if you want weplab to use plaintext keys with NULL bytes appended (if needed) at the end of each word to fit the WEP key size. This second mode is used on my system when I configure the WEP key using "iwconfig eth0 s:silly".</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FMS STATISTICAL ATTACK</h2>
        <div class="sectioncontent">
<p>Wireless networks WEP encryption is based on RC4 algorithm. RC4 has some weaknesses as Fluhrer, Mantin and Shamir described in 2001 with the paper "Weaknesses in the Key Scheduling Algorithm of RC4". The specific implementation of the RC4 algorithm in WEP makes possible its practical use. The initials of the authors gave it the name of FMS statistical cryptoanalysis.</p><p>In order to make this attack possible for breaking the encryption of wireless networks, lots of specific data wep encrypted packets, called weak packets, must be gathered. Soon after the paper was published, two tools appeared that implemented the FMS attack, but the set of weak packets that these tools use is just asmall subset of the total possible weak packets. As a result, the attack was not as practical to launch as it should be.</p><p>In February 2002, h1kari released the paper "Practical Exploitation of RC4 Weaknesses in WEP Environments". This describes the problem with the set of weak packets used by existing tools and suggest several optimization in the attack like attacking other bytes besides the first one. H1kari created a tool called dwepcrack that implements a part of these optimizations, and runs under *BSD. Weplab uses FMS attack supporting the whole set of weak packets for attacking both the first and the second byte of the encrypted payload. Also some bruteforce and smart probabilistic based decisions are implemented within the FMS attack to make it more powerful, especially when you dont have enough packets to launch a straight-forward attack.</p><p>But apart from that, the main purpose of weplab is to be an educational tool to help users understand the existing weaknesses in WEP and how can the be used to break the encryption key. Several command line parameters are implemented with this purpose.</p><p>Also, if you plan to test weplab cracking capacity with your own wireless lan, you can use --debugkey. By using this option you tell weplab what your WEP key is (or at least a part of it), so weplab will skip all other branches when searching candidate key bytes in FMS attack.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NEW STATISTICAL ATTACKS</h2>
        <div class="sectioncontent">
<p>New statistical attacks published on Netstumbler forum by Korek. These new attacks make possible to crack the key with even less than 500k.</p><p>Many thanks to Korek for this information. All the credit goes to you.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>Example 1. Cracking using FMS attack</p><p>You want to test the tool so you collect 1.5M packets from your own wireless LAN. You just want to know if weplab would be able to crack it. You can use first --debugkey. If you are using a 128-bit key the right sintax would be:</p><p>weplab -r./packets.log --debugkey 01:02:03:04:05:06:07:08:09:10:11:12:13 --debug 1 --key 128 ./packets.log</p><p>You should see the statistics and guesses for each byte of the key so you can see the viability of the attack. At the end you should see "key succesfully cracked". If you do not see such message, perhaps your captured packets have the FCS tail so it will be neccesary to issue --fcs</p><p>weplab -r./packets.log --debugkey 01:02:03:04:05:06:07:08:09:10:11:12:13 --fcs --debug 1 --key 128 ./packets.log</p><p>Now can try with just a part of the key in debugkey. If the FMS is possible with these packets, weplab should be able to crack the key using just these bytes.</p><p>weplab -r./packets.log --debugkey 01:02:03:04:05:06 --fcs --debug 1 --key 128 ./packets.log</p><p>If it works you can try reducing the debugkey more. At the end you can try with no debugkey at all, as if it were a real attack.</p><p>You can push ENTER key in any moment to get statistics of the work done.</p><p>Example 2. Cracking using bruteforce</p><p>To crack a 64-bit key using normal bruteforce just issue the following command.</p><p>weplab --debug 1 --key 64 ./packets.log</p><p>If you suspect that the key may be in plain ascii, do this:</p><p>weplab --debug 1 --key 64 --ascii ./packets.log</p><p>You can push ENTER key at any moment to get statistics of the work done.</p><p>Example 3. Capturing packets.</p><p>In order to capture packets you have to put your wireless card in monitor mode in the right channel. Be carefull to configure monitor mode to ignore WEP bit. Once you have your card in monitor mode, you can capture packets using tcpdump or weplab -c -i interface</p><p>weplab -c -i wlan0 --debug 1 --caplen 150 ./packets.log</p><p>You can push ENTER key at any moment to get statistics of the work done.</p><p>Example 4. Analyze an existing pcap file.</p><p>Weplab can also analyze a pcap file to the some statistics. Use -a for this purpose. --prismheader --fcs can also be used.</p><p>weplab -a --debug 1 ./pcap.log</p><p>Example 5. Cracking a 64 WEP key using a dictionnary file with John the Ripper</p><p>john -w:/path/to/my/big/dictionnaryfile -rules -stdout | weplab -y -d 1 --key 64 capt.dump</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">VERSION</h2>
        <div class="sectioncontent">
<p>This man page is correct for version 0.1.3 of weplab</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>weplab was created by Jose Ignacio Sanchez - Topo[LB].</p><p>However other people have made contributions to the project. In the AUTHORS file within the distribution package, you will find them.</p><p>Any new contribution in form of documentation translation, new feature development, bug fixing, and so on, will be welcome</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="weka.1.html"><span aria-hidden="true">&larr;</span> weka.1: Machine learning algorithms for data mining tasks</a></li>
   <li class="next"><a href="westcos-tool.1.html">westcos-tool.1: Utility for manipulating data structures on westcos smart cards <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

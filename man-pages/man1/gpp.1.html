<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>gpp: Generic preprocessor</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Generic preprocessor">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="gpp (1) manual">
  <meta name="twitter:description" content="Generic preprocessor">
  <meta name="twitter:image" content="https://www.carta.tech/images/gpp-gpp-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/gpp.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="gpp (1) manual" />
  <meta property="og:description" content="Generic preprocessor" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/gpp-gpp-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">gpp<small> (1)</small></h1>
        <p class="lead">Generic preprocessor</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/gpp.1.html">
      <span itemprop="name">gpp: Generic preprocessor</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/gpp/">
      <span itemprop="name">gpp</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/gpp.1.html">
      <span itemprop="name">gpp: Generic preprocessor</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  gpp [-{o|O} <em>outfile</em>] [-I<em>/include/path</em>] [-D<em>name=val</em> ...]
      [-z|+z] [-x] [-m] [-C|-T|-H|-X|-P|-U ... [-M ...]]
      [-n|+n] [+c<em>&lt;n&gt;</em> <em>str1</em> <em>str2</em>] [+s<em>&lt;n&gt;</em> <em>str1</em> <em>str2</em> <em>c</em>]
      [-c <em>str1</em>] [--nostdinc] [--nocurinc]
      [--curdirinclast] [--warninglevel <em>n</em>]
      [--includemarker <em>str</em>] [--include <em>file</em>]
      [<em>infile</em>]
</pre>

<pre>
  gpp --help
</pre>

<pre>
  gpp --version
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>GPP is a general-purpose preprocessor with customizable syntax, suitable for a wide range of preprocessing tasks. Its independence from any programming language makes it much more versatile than cpp, while its syntax is lighter and more flexible than that of m4.</p><p>GPP is targeted at all common preprocessing tasks where cpp is not suitable and where no very sophisticated features are needed. In order to be able to process equally efficiently text files or source code in a variety of languages, the syntax used by GPP is fully customizable. The handling of comments and strings is especially advanced.</p><p>Initially, GPP only understands a minimal set of built-in macros, called <em>meta-macros</em>. These meta-macros allow the definition of <em>user macros</em> as well as some basic operations forming the core of the preprocessing system, including conditional tests, arithmetic evaluation, wildcard matching (globbing), and syntax specification. All user macro definitions are global -- <em>i.e.</em>, they remain valid until explicitly removed; meta-macros cannot be redefined. With each user macro definition GPP keeps track of the corresponding syntax specification so that a macro can be safely invoked regardless of any subsequent change in operating mode.</p><p>In addition to macros, GPP understands comments and strings, whose syntax and behavior can be widely customized to fit any particular purpose. Internally comments and strings are the same construction, so everything that applies to comments applies to strings as well.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONS</h2>
        <div class="sectioncontent">
<p>GPP recognizes the following command-line switches and options.  Note that the -nostdinc, -nocurinc, -curdirinclast, -warninglevel, and -includemarker options from version 2.1 and earlier are deprecated and should not be used.  Use the "long option" variants instead (--nostdinc, <em>etc.</em>).</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>-h --help</strong><em></em></p>
  </dt>
  <dd>
    <p>Print a short help message.</p>
  </dd>
  <dt>
    <p><strong>--version</strong><em></em></p>
  </dt>
  <dd>
    <p>Print version information.</p>
  </dd>
  <dt>
    <p><strong>-o </strong><em>outfile</em></p>
  </dt>
  <dd>
    <p>Specify a file to which all output should be sent (by default, everything is sent to standard output).</p>
  </dd>
  <dt>
    <p><strong>-O </strong><em>outfile</em></p>
  </dt>
  <dd>
    <p>Specify a file to which all output should be sent; output is simultanously sent to stdout.</p>
  </dd>
  <dt>
    <p><strong>-I</strong><em>/include/path</em></p>
  </dt>
  <dd>
    <p>Specify a path where the <em>#include</em> meta-macro will look for include files if they are not present in the current directory. The default is /usr/include if no -I option is specified. Multiple -I options may be specified to look in several directories.</p>
  </dd>
  <dt>
    <p><strong>-D</strong><em>name=val</em></p>
  </dt>
  <dd>
    <p>Define the user macro <em>name</em> as equal to <em>val</em>. This is strictly equivalent to using the <em>#define</em> meta-macro, but makes it possible to define macros from the command-line. If <em>val</em> makes references to arguments or other macros, it should conform to the syntax of the mode specified on the command-line. Starting with version 2.1, macro argument naming is allowed on the command-line. The syntax is as follows: -D<em>macro</em>(<em>arg1</em>,...)=<em>definition</em>. The arguments are specified in C-style syntax, without any whitespace, but the definition should still conform to the syntax of the mode specified on the command-line.</p>
  </dd>
  <dt>
    <p><strong>+z</strong><em></em></p>
  </dt>
  <dd>
    <p>Set text mode to Unix mode (LF terminator). Any CR character in the input is systematically discarded. This is the default under Unix systems.</p>
  </dd>
  <dt>
    <p><strong>-z</strong><em></em></p>
  </dt>
  <dd>
    <p>Set text mode to DOS mode (CR-LF terminator). In this mode all CR characters are removed from the input, and all output LF characters are converted to CR-LF. This is the default if GPP is compiled with the WIN_NT option.</p>
  </dd>
  <dt>
    <p><strong>-x</strong><em></em></p>
  </dt>
  <dd>
    <p>Enable the use of the <em>#exec</em> meta-macro. Since <em>#exec</em> includes the output of an arbitrary shell command line, it may cause a potential security threat, and is thus disabled unless this option is specified.</p>
  </dd>
  <dt>
    <p><strong>-m</strong><em></em></p>
  </dt>
  <dd>
    <p>Enable automatic mode switching to the cpp compatibility mode if the name of an included file ends in `.h' or `.c'. This makes it possible to include C header files with only minor modifications.</p>
  </dd>
  <dt>
    <p><strong>-n</strong><em></em></p>
  </dt>
  <dd>
    <p>Prevent newline or whitespace characters from being removed from the input when they occur as the end of a macro call or of a comment. By default, when a newline or whitespace character forms the end of a macro or a comment it is parsed as part of the macro call or comment and therefore removed from output. Use the -n option to keep the last character in the input stream if it was whitespace or a newline. This is activated in cpp and Prolog modes.</p>
  </dd>
  <dt>
    <p><strong>+n</strong><em></em></p>
  </dt>
  <dd>
    <p>The opposite of -n. This is the default in all modes except cpp and Prolog. Note that +n must be placed <em>after</em> -C or -P in order to have any effect.</p>
  </dd>
  <dt>
    <p><strong>-U </strong><em>arg1 ... arg9</em></p>
  </dt>
  <dd>
    <p>User-defined mode. The nine following command-line arguments are taken to be respectively the macro start sequence, the macro end sequence for a call without arguments, the argument start sequence, the argument separator, the argument end sequence, the list of characters to stack for argument balancing, the list of characters to unstack, the string to be used for referring to an argument by number, and finally the quote character (if there is none an empty string should be provided). These settings apply both to user macros and to meta-macros, unless the -M option is used to define other settings for meta-macros. See the section on syntax specification for more details.</p>
  </dd>
  <dt>
    <p><strong>-M </strong><em>arg1 ... arg7</em></p>
  </dt>
  <dd>
    <p>User-defined mode specifications for meta-macros. This option can only be used together with -M. The seven following command-line arguments are taken to be respectively the macro start sequence, the macro end sequence for a call without arguments, the argument start sequence, the argument separator, the argument end sequence, the list of characters to stack for argument balancing, and the list of characters to unstack. See below for more details.</p>
  </dd>
  <dt>
    <p><strong>(default mode)</strong><em></em></p>
  </dt>
  <dd>
    <p>The default mode is a vaguely cpp-like mode, but it does not handle comments, and presents various incompatibilities with cpp. Typical meta-macros and user macros look like this:</p>
<pre>
  #define x y
  macro(arg,...)
</pre>
<p>This mode is equivalent to</p>
<pre>
  -U "" "" "(" "," ")" "(" ")" "#" "&#92;
  -M "#" "&#92;n" " " " " "&#92;n" "(" ")"
</pre>

  </dd>
  <dt>
    <p><strong>-C</strong><em></em></p>
  </dt>
  <dd>
    <p>cpp compatibility mode. This is the mode where GPP's behavior is the closest to that of cpp. Unlike in the default mode, meta-macro expansion occurs only at the beginning of lines, and C comments and strings are understood. This mode is equivalent to</p>
<pre>
  -n -U "" "" "(" "," ")" "(" ")" "#" ""
  -M "&#92;n#&#92;w" "&#92;n" " " " " "&#92;n" "" ""
  +c "/*" "*/" +c "//" "&#92;n" +c "&#92;&#92;&#92;n" ""
  +s " 
</pre>

  </dd>
  <dt>
    <p><strong>-T</strong><em></em></p>
  </dt>
  <dd>
    <p>TeX-like mode. In this mode, typical meta-macros and user macros look like this:</p>
<pre>
  &#92;define{x}{y}
  &#92;macro{arg}{...}
</pre>
<p>No comments are understood. This mode is equivalent to</p>
<pre>
  -U "&#92;
</pre>

  </dd>
  <dt>
    <p><strong>-H</strong><em></em></p>
  </dt>
  <dd>
    <p>HTML-like mode. In this mode, typical meta-macros and user macros look like this:</p>
<pre>
  &lt;#define x|y&gt;
  &lt;#macro arg|...&gt;
</pre>
<p>No comments are understood. This mode is equivalent to</p>
<pre>
  -U "&lt;#" "&gt;" "&#92;B" "|" "&gt;" "&lt;" "&gt;" "#" "&#92;
</pre>

  </dd>
  <dt>
    <p><strong>-X</strong><em></em></p>
  </dt>
  <dd>
    <p>XHTML-like mode. In this mode, typical meta-macros and user macros look like this:</p>
<pre>
  &lt;#define x|y/&gt;
  &lt;#macro arg|.../&gt;
</pre>
<p>No comments are understood. This mode is equivalent to</p>
<pre>
  -U "&lt;#" "/&gt;" "&#92;B" "|" "/&gt;" "&lt;" "&gt;" "#" "&#92;
</pre>

  </dd>
  <dt>
    <p><strong>-P</strong><em></em></p>
  </dt>
  <dd>
    <p>Prolog-compatible cpp-like mode. This mode differs from the cpp compatibility mode by its handling of comments, and is equivalent to</p>
<pre>
  -n -U "" "" "(" "," ")" "(" ")" "#" ""
  -M "&#92;n#&#92;w" "&#92;n" " " " " "&#92;n" "" ""
  +ccss "&#92;!o/*" "*/" +ccss "%" "&#92;n" +ccii "&#92;&#92;&#92;n" ""
  +s " 
</pre>

  </dd>
  <dt>
    <p><strong>+c</strong><em>&lt;n&gt; str1 str2</em></p>
  </dt>
  <dd>
    <p>Specify comments. Any unquoted occurrence of <em>str1</em> will be interpreted as the beginning of a comment. All input up to the first following occurrence of <em>str2</em> will be discarded. This option may be used multiple times to specify different types of comment delimiters. The optional parameter <em>&lt;n&gt;</em> can be specified to alter the behavior of the comment and, <em>e.g.</em>, turn it into a string or make it ignored under certain circumstances, see below.</p>
  </dd>
  <dt>
    <p><strong>-c </strong><em>str1</em></p>
  </dt>
  <dd>
    <p>Un-specify comments or strings. The comment/string specification whose start sequence is <em>str1</em> is removed. This is useful to alter the built-in comment specifications of a standard mode -- <em>e.g.</em>, the cpp compatibility mode.</p>
  </dd>
  <dt>
    <p><strong>+s</strong><em>&lt;n&gt; str1 str2 c</em></p>
  </dt>
  <dd>
    <p>Specify strings. Any unquoted occurrence of <em>str1</em> will be interpreted as the beginning of a string. All input up to the first following occurrence of <em>str2</em> will be output as is without any evaluation. The delimiters themselves are output. If <em>c</em> is non-empty, its first character is used as a <em>string-quote character</em> -- <em>i.e.</em>, a character whose presence immediately before an occurrence of <em>str2</em> prevents it from terminating the string. The optional parameter <em>&lt;n&gt;</em> can be specified to alter the behavior of the string and, <em>e.g.</em>, turn it into a comment, enable macro evaluation inside the string, or make the string specification ignored under certain circumstances. See below.</p>
  </dd>
  <dt>
    <p><strong>-s </strong><em>str1</em></p>
  </dt>
  <dd>
    <p>Un-specify comments or strings. Identical to -c.</p>
  </dd>
  <dt>
    <p><strong>--include </strong><em>file</em></p>
  </dt>
  <dd>
    <p>Process <em>file</em> before <em>infile</em></p>
  </dd>
  <dt>
    <p><strong>--nostdinc</strong><em></em></p>
  </dt>
  <dd>
    <p>Do not look for include files in the standard directory /usr/include.</p>
  </dd>
  <dt>
    <p><strong>--nocurinc</strong><em></em></p>
  </dt>
  <dd>
    <p>Do not look for include files in the current directory.</p>
  </dd>
  <dt>
    <p><strong>--curdirinclast</strong><em></em></p>
  </dt>
  <dd>
    <p>Look for include files in the current directory <em>after</em> the directories specified by <em>-I</em> rather than before them.</p>
  </dd>
  <dt>
    <p><strong>--warninglevel </strong><em>n</em></p>
  </dt>
  <dd>
    <p>Set warning level to <em>n</em> (0, 1 or 2). Default is 2 (most verbose).</p>
  </dd>
  <dt>
    <p><strong>--includemarker </strong><em>str</em></p>
  </dt>
  <dd>
    <p>keep track of <em>#include</em> directives by inserting a marker in the output stream. The format of the marker is determined by <em>str</em>, which must contain three occurrences of the character <em>%</em> (or equivalently <em>?</em>). The first occurrence is replaced with the line number, the second with the file name, and the third with 1, 2 or blank. When this option is specified in default, cpp or Prolog mode, GPP does its best to ensure that line numbers are the same in the output as in the input by inserting blank lines in the place of definitions or comments.</p>
  </dd>
  <dt>
    <p><strong>infile</strong><em></em></p>
  </dt>
  <dd>
    <p>Specify an input file from which GPP reads its input. If no input file is specified, input is read from standard input.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNTAX SPECIFICATION</h2>
        <div class="sectioncontent">
<p>The syntax of a macro call is as follows: it must start with a sequence of characters matching the <em>macro start sequence</em> as specified in the current mode, followed immediately by the name of the macro, which must be a valid <em>identifier</em> -- <em>i.e.</em>, a sequence of letters, digits, or underscores ("_"). The macro name must be followed by a <em>short macro end</em> sequence if the macro has no arguments, or by a sequence of arguments initiated by an <em>argument start sequence</em>. The various arguments are then separated by an <em>argument separator</em>, and the macro ends with a <em>long macro end sequence</em>.</p><p>In all cases, the parameters of the current context -- <em>i.e.</em>, the arguments passed to the body being evaluated -- can be referred to by using an <em>argument reference sequence</em> followed by a digit between 1 and 9. Alternatively, macro parameters may be named (see below). Furthermore, to avoid interference between the GPP syntax and the contents of the input file, a <em>quote character</em> is provided. The quote character can be used to prevent the interpretation of a macro call, comment, or string as anything but plain text. The quote character "protects" the following character, and always gets removed during evaluation. Two consecutive quote characters evaluate as a single quote character.</p><p>Finally, to facilitate proper argument delimitation, certain characters can be "stacked" when they occur in a macro argument, so that the argument separator or macro end sequence are not parsed if the argument body is not balanced. This allows nesting macro calls without using quotes. If an improperly balanced argument is needed, quote characters should be added in front of some stacked characters to make it balanced.</p><p>The macro construction sequences described above can be different for meta-macros and for user macros: this is the case in cpp mode, for example. Note that, since meta-macros can only have up to two arguments, the delimitation rules for the second argument are somewhat sloppier, and unquoted argument separator sequences are allowed in the second argument of a meta-macro.</p><p>Unless one of the standard operating modes is selected, the above syntax sequences can be specified either on the command-line, using the -M and -U options respectively for meta-macros and user macros, or inside an input file via the <em>#mode meta</em> and <em>#mode user</em> meta-macro calls. In both cases the mode description consists of nine parameters for user macro specifications, namely the macro start sequence, the short macro end sequence, the argument start sequence, the argument separator, the long macro end sequence, the string listing characters to stack, the string listing characters to unstack, the argument reference sequence, and finally the quote character. As explained below, these sequences should be supplied using the syntax of C strings; they must start with a non-alphanumeric character, and in the first five strings special matching sequences can be used (see below). If the argument corresponding to the quote character is the empty string, that argument's functionality is disabled. For meta-macro specifications there are only seven parameters, as the argument reference sequence and quote character are shared with the user macro syntax.</p><p>The structure of a comment/string is as follows: it must start with a sequence of characters matching the given <em>comment/string start sequence</em>, and always ends at the first occurrence of the <em>comment/string end</em> sequence, unless it is preceded by an odd number of occurrences of the <em>string-quote character</em> (if such a character has been specified). In certain cases comment/strings can be specified to enable macro evaluation inside the comment/string; in that case, if a quote character has been defined for macros it can be used as well to prevent the comment/string from ending, with the difference that the macro quote character is always removed from output whereas the string-quote character is always output. Also note that under certain circumstances a comment/string specification can be <em>disabled</em>, in which case the comment/string start sequence is simply ignored. Finally, it is possible to specify a <em>string warning character</em> whose presence inside a comment/string will cause GPP to output a warning (this is useful to locate unterminated strings in cpp mode). Note that input files are not allowed to contain unterminated comments/strings.</p><p>A comment/string specification can be declared from within the input file using the <em>#mode comment</em> meta-macro call (or equivalently <em>#mode string</em>), in which case the number of C strings to be given as arguments to describe the comment/string can be anywhere between two and four: the first two arguments (mandatory) are the start sequence and the end sequence, and can make use of the special matching sequences (see below). They may not start with alphanumeric characters. The first character of the third argument, if there is one, is used as the string-quote character (use an empty string to disable the functionality), and the first character of the fourth argument, if there is one, is used as the string-warning character. A specification may also be given from the command-line, in which case there must be two arguments if using the +c option and three if using the +s option.</p><p>The behavior of a comment/string is specified by a three-character modifier string, which may be passed as an optional argument either to the +c/+s command-line options or to the <em>#mode comment</em>/<em>#mode</em> string meta-macros. If no modifier string is specified, the default value is "ccc" for comments and "sss" for strings. The first character corresponds to the behavior inside meta-macro calls (including user-macro definitions since these come inside a <em>#define</em> meta-macro call), the second character corresponds to the behavior inside user-macro parameters, and the third character corresponds to the behavior outside of any macro call. Each of these characters can take the following values:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>i</strong><em></em></p>
  </dt>
  <dd>
    <p>disable the comment/string specification.</p>
  </dd>
  <dt>
    <p><strong>c</strong><em></em></p>
  </dt>
  <dd>
    <p>comment (neither evaluated nor output).</p>
  </dd>
  <dt>
    <p><strong>s</strong><em></em></p>
  </dt>
  <dd>
    <p>string (the string and its delimiter sequences are output as-is).</p>
  </dd>
  <dt>
    <p><strong>q</strong><em></em></p>
  </dt>
  <dd>
    <p>quoted string (the string is output as-is, without the delimiter sequences).</p>
  </dd>
  <dt>
    <p><strong>C</strong><em></em></p>
  </dt>
  <dd>
    <p>evaluated comment (macros are evaluated, but output is discarded).</p>
  </dd>
  <dt>
    <p><strong>S</strong><em></em></p>
  </dt>
  <dd>
    <p>evaluated string (macros are evaluated, delimiters are output).</p>
  </dd>
  <dt>
    <p><strong>Q</strong><em></em></p>
  </dt>
  <dd>
    <p>evaluated quoted string (macros are evaluated, delimiters are not output).</p>
  </dd>

</dl>
<p>Important note: any occurrence of a comment/string start sequence inside another comment/string is always ignored, even if macro evaluation is enabled. In other words, comments/strings cannot be nested. In particular, the `Q' modifier can be a convenient way of defining a syntax for temporarily disabling all comment and string specifications.</p><p>Syntax specification strings should always be provided as C strings, whether they are given as arguments to a <em>#mode</em> meta-macro call or on the command-line of a Unix shell. If command-line arguments are given via another method than a standard Unix shell, then the shell behavior must be emulated -- <em>i.e.</em>, the surrounding "" quotes should be removed, all occurrences of `&#92;&#92;' should be replaced by a single backslash, and similarly ` Sequences like `&#92;n' are recognized by GPP and should be left as is.</p><p>Special sequences matching certain subsets of the character set can be used. They are of the form `&#92;<em>x</em>', where <em>x</em> is one of:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>b</strong><em></em></p>
  </dt>
  <dd>
    <p>matches any sequence of one or more spaces or tab characters (`&#92;b' is identical to `&nbsp;').</p>
  </dd>
  <dt>
    <p><strong>w</strong><em></em></p>
  </dt>
  <dd>
    <p>matches any sequence of zero or more spaces or tab characters.</p>
  </dd>
  <dt>
    <p><strong>B</strong><em></em></p>
  </dt>
  <dd>
    <p>matches any sequence of one or more spaces, tabs or newline characters.</p>
  </dd>
  <dt>
    <p><strong>W</strong><em></em></p>
  </dt>
  <dd>
    <p>matches any sequence of zero or more spaces, tabs or newline characters.</p>
  </dd>
  <dt>
    <p><strong>a</strong><em></em></p>
  </dt>
  <dd>
    <p>an alphabetic character (`a' to `z' and `A' to `Z').</p>
  </dd>
  <dt>
    <p><strong>A</strong><em></em></p>
  </dt>
  <dd>
    <p>an alphabetic character, or a space, tab or newline.</p>
  </dd>
  <dt>
    <p><strong>#</strong><em></em></p>
  </dt>
  <dd>
    <p>a digit (`0' to `9').</p>
  </dd>
  <dt>
    <p><strong>i</strong><em></em></p>
  </dt>
  <dd>
    <p>an identifier character. The set of matched characters is customizable using the <em>#mode charset id</em> command. The default setting matches alphanumeric characters and underscores (`a' to `z', `A' to `Z', `0' to `9' and `_').</p>
  </dd>
  <dt>
    <p><strong>t</strong><em></em></p>
  </dt>
  <dd>
    <p>a tab character.</p>
  </dd>
  <dt>
    <p><strong>n</strong><em></em></p>
  </dt>
  <dd>
    <p>a newline character.</p>
  </dd>
  <dt>
    <p><strong>o</strong><em></em></p>
  </dt>
  <dd>
    <p>an operator character. The set of matched characters is customizable using the <em>#mode charset op</em> command. The default setting matches all characters in "+-*/&#92;^&lt;&gt;=`~:.?@#&!%|", except in Prolog mode where `!', `%' and `|' are not matched.</p>
  </dd>
  <dt>
    <p><strong>O</strong><em></em></p>
  </dt>
  <dd>
    <p>an operator character or a parenthesis character. The set of additional matched characters in comparison with `&#92;o' is customizable using the <em>#mode charset par</em> command. The default setting is to have the characters in "()[]{}" as parentheses.</p>
  </dd>

</dl>
<p>Moreover, all of these matching subsets except `&#92;w' and `&#92;W' can be negated by inserting a `!' -- <em>i.e.</em>, by writing `&#92;!<em>x</em>' instead of `&#92;<em>x</em>'.</p><p>Note an important distinctive feature of <em>start sequences</em>: when the first character of a macro or comment/string start sequence is '&nbsp;' or one of the above special sequences, it is not taken to be part of the sequence itself but is used instead as a context check: for example a start sequence beginning with '&#92;n' matches only at the beginning of a line, but the matching newline character is not taken to be part of the sequence. Similarly a start sequence beginning with '&nbsp;' matches only if some whitespace is present, but the matching whitespace is not considered to be part of the start sequence and is therefore sent to output. If a context check is performed at the very beginning of a file (or more generally of any body to be evaluated), the result is the same as matching with a newline character (this makes it possible for a cpp-mode file to start with a meta-macro call).</p><p>Two special syntax rules were added in version 2.1. First, argument references (#<em>n</em>) are no longer evaluated when they are outside of macro calls and definitions. However, they are no longer allowed to appear (unless protected by quote characters) inside a call to a defined user macro; the current behavior (backwards compatible) is to remove them silently from the input if that happens.</p><p>Second, if the end sequence (either for macros or comments) consists of a single newline character, and if delimitation rules lead to evaluation in a context where the final newline character is absent, GPP silently ignores the missing newline instead of producing an error. The main consequence is that meta-macro calls can now be nested in a simple way in standard, cpp and Prolog modes.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EVALUATION RULES</h2>
        <div class="sectioncontent">
<p>Input is read sequentially and interpreted according to the rules of the current mode. All input text is first matched against the specified comment/string start sequences of the current mode (except those which are disabled by the 'i' modifier), unless the body being evaluated is the contents of a comment/string whose modifier enables macro evaluation. The most recently defined comment/string specifications are checked for first. Important note: comments may not appear between the name of a macro and its arguments (doing so results in undefined behavior).</p><p>Anything that is not a comment/string is then matched against a possible meta-macro call, and if that fails too, against a possible user-macro call. All remaining text undergoes substitution of argument reference sequences by the relevant argument text (empty unless the body being evaluated is the definition of a user macro) and removal of the quote character if there is one.</p><p>Note that meta-macro arguments are passed to the meta-macro prior to any evaluation (although the meta-macro may choose to evaluate them, see meta-macro descriptions below). In the case of the <em>#mode</em> meta-macro, GPP temporarily adds a comment/string specification to enable recognition of C strings ("...") and prevent any evaluation inside them, so no interference of the characters being put in the C string arguments to <em>#mode</em> with the current syntax is to be feared.</p><p>On the other hand, the arguments to a user macro are systematically evaluated, and then passed as context parameters to the macro definition body, which gets evaluated with that environment. The only exception is when the macro definition is empty, in which case its arguments are not evaluated. Note that GPP temporarily switches back to the mode in which the macro was defined in order to evaluate it, so it is perfectly safe to change the operating mode between the time a macro is defined and the time when it is called. Conversely, if a user macro wishes to work with the current mode instead of the one that was used to define it it needs to start with a <em>#mode restore</em> call and end with a <em>#mode save</em> call.</p><p>A user macro may be defined with named arguments (see <em>#define</em> description below). In that case, when the macro definition is being evaluated, each named parameter causes a temporary virtual user-macro definition to be created; such a macro may be called only without arguments and simply returns the text of the corresponding argument.</p><p>Note that, since macros are evaluated when they are called rather than when they are defined, any attempt to call a recursive macro causes undefined behavior except in the very specific case when the macro uses <em>#undef</em> to erase itself after finitely many loop iterations.</p><p>Finally, a special case occurs when a user macro whose definition does not involve any arguments (neither named arguments nor the argument reference sequence) is called in a mode where the short user-macro end sequence is empty (<em>e.g.</em>, cpp or TeX&nbsp;mode). In that case it is assumed to be an <em>alias macro</em>: its arguments are first evaluated in the current mode as usual, but instead of being passed to the macro definition as parameters (which would cause them to be discarded) they are actually appended to the macro definition, using the syntax rules of the mode in which the macro was defined, and the resulting text is evaluated again. It is therefore important to note that, in the case of a macro alias, the arguments actually get evaluated twice in two potentially different modes.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">META-MACROS</h2>
        <div class="sectioncontent">
<p>These macros are always predefined. Their actual calling sequence depends on the current mode; here we use cpp-like notation.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>#define </strong><em>x y</em></p>
  </dt>
  <dd>
    <p>This defines the user macro <em>x</em> as <em>y</em>. <em>y</em> can be any valid GPP input, and may for example refer to other macros. <em>x</em> must be an identifier (<em>i.e.</em>, a sequence of alphanumeric characters and '_'), unless named arguments are specified. If <em>x</em> is already defined, the previous definition is overwritten. If no second argument is given, <em>x</em> will be defined as a macro that outputs nothing. Neither <em>x</em> nor <em>y</em> are evaluated; the macro definition is only evaluated when it is called, not when it is declared.</p><p>It is also possible to name the arguments in a macro definition: in that case, the argument <em>x</em> should be a user-macro call whose arguments are all identifiers. These identifiers become available as user-macros inside the macro definition; these virtual macros must be called without arguments, and evaluate to the corresponding macro parameter.</p>
  </dd>
  <dt>
    <p><strong>#defeval </strong><em>x y</em></p>
  </dt>
  <dd>
    <p>This acts in a similar way to <em>#define</em>, but the second argument <em>y</em> is evaluated immediately. Since user macro definitions are also evaluated each time they are called, this means that the macro <em>y</em> will undergo <em>two</em> successive evaluations. The usefulness of <em>#defeval</em> is considerable as it is the only way to evaluate something more than once, which may be needed to force evaluation of the arguments of a meta-macro that normally doesn't perform any evaluation. However since all argument references evaluated at define-time are understood as the arguments of the body in which the macro is being defined and not as the arguments of the macro itself, usually one has to use the quote character to prevent immediate evaluation of argument references.</p>
  </dd>
  <dt>
    <p><strong>#undef </strong><em>x</em></p>
  </dt>
  <dd>
    <p>This removes any existing definition of the user macro <em>x</em>.</p>
  </dd>
  <dt>
    <p><strong>#ifdef </strong><em>x</em></p>
  </dt>
  <dd>
    <p>This begins a conditional block. Everything that follows is evaluated only if the identifier <em>x</em> is defined, and until either a <em>#else</em> or a <em>#endif</em> statement is reached. Note, however, that the commented text is still scanned thoroughly, so its syntax must be valid. It is in particular legal to have the <em>#else</em> or <em>#endif</em> statement ending the conditional block appear only as the result of a user-macro expansion and not explicitly in the input.</p>
  </dd>
  <dt>
    <p><strong>#ifndef </strong><em>x</em></p>
  </dt>
  <dd>
    <p>This begins a conditional block. Everything that follows is evaluated only if the identifier <em>x</em> is not defined.</p>
  </dd>
  <dt>
    <p><strong>#ifeq </strong><em>x y</em></p>
  </dt>
  <dd>
    <p>This begins a conditional block. Everything that follows is evaluated only if the results of the evaluations of <em>x</em> and <em>y</em> are identical as character strings. Any leading or trailing whitespace is ignored for the comparison. Note that in cpp-mode any unquoted whitespace character is understood as the end of the first argument, so it is necessary to be careful.</p>
  </dd>
  <dt>
    <p><strong>#ifneq </strong><em>x y</em></p>
  </dt>
  <dd>
    <p>This begins a conditional block. Everything that follows is evaluated only if the results of the evaluations of <em>x</em> and <em>y</em> are not identical (even up to leading or trailing whitespace).</p>
  </dd>
  <dt>
    <p><strong>#else</strong><em></em></p>
  </dt>
  <dd>
    <p>This toggles the logical value of the current conditional block. What follows is evaluated if and only if the preceding input was commented out.</p>
  </dd>
  <dt>
    <p><strong>#endif</strong><em></em></p>
  </dt>
  <dd>
    <p>This ends a conditional block started by a <em>#if...</em> meta-macro.</p>
  </dd>
  <dt>
    <p><strong>#include </strong><em>file</em></p>
  </dt>
  <dd>
    <p>This causes GPP to open the specified file and evaluate its contents, inserting the resulting text in the current output. All defined user macros are still available in the included file, and reciprocally all macros defined in the included file will be available in everything that follows. The include file is looked for first in the current directory, and then, if not found, in one of the directories specified by the <em>-I</em> command-line option (or <em>/usr/include</em> if no directory was specified). Note that, for compatibility reasons, it is possible to put the file name between "" or &lt;&gt;.</p><p>The order in which the various directories are searched for include files is affected by the <em>-nostdinc</em>, <em>-nocurinc</em> and <em>-curdirinclast</em> command-line options.</p><p>Upon including a file, GPP immediately saves a copy of the current operating mode onto the mode stack, and restores the operating mode at the end of the included file. The included file may override this behavior by starting with a <em>#mode restore</em> call and ending with a <em>#mode push</em> call. Additionally, when the <em>-m</em> command line option is specified, GPP will automatically switch to the cpp compatibility mode upon including a file whose name ends with either '.c' or '.h'.</p>
  </dd>
  <dt>
    <p><strong>#exec </strong><em>command</em></p>
  </dt>
  <dd>
    <p>This causes GPP to execute the specified command line and include its standard output in the current output. Note that, for security reasons, this meta-macro is disabled unless the <em>-x</em> command line flag was specified. If use of <em>#exec</em> is not allowed, a warning message is printed and the output is left blank. Note that the specified command line is evaluated before being executed, thus allowing the use of macros in the command-line. However, the output of the command is included verbatim and not evaluated. If you need the output to be evaluated, you must use <em>#defeval</em> (see above) to cause a double evaluation.</p>
  </dd>
  <dt>
    <p><strong>#eval </strong><em>expr</em></p>
  </dt>
  <dd>
    <p>The <em>#eval</em> meta-macro attempts to evaluate <em>expr</em> first by expanding macros (normal GPP evaluation) and then by performing arithmetic evaluation and/or wildcard matching.  The syntax and operator precedence for arithmetic expressions are the same as in C; the only missing operators are &lt;&lt;, &gt;&gt;, ?:, and the assignment operators.</p><p>POSIX-style wildcard matching ('globbing') is available only on POSIX implementations and can be invoked with the =~ operator.  In brief, a '?' matches any single character, a '*' matches any string (including the empty string), and '[...]' matches any one of the characters enclosed in brackets.  A '[...]' class is complemented when the first character in the brackets is '!'.  The characters in a '[...]' class can also be specified as a range using the '-' character -- <em>e.g.</em>, '[F-N]' is equivalent to '[FGHIJKLMN]'.</p><p>If unable to assign a numerical value to the result, the returned text is simply the result of macro expansion without any arithmetic evaluation. The only exceptions to this rule are the comparison operators ==, !=, &lt;, &gt;, &lt;=, and &gt;= which, if one of the sides does not evaluate to a number, perform string comparison instead (ignoring trailing and leading spaces).  Additionally, the <em>length(...)</em> arithmetic operator returns the length in characters of its evaluated argument.</p><p>Inside arithmetic expressions, the <em>defined(...)</em> special user macro is also available: it takes only one argument, which is not evaluated, and returns 1 if it is the name of a user macro and 0 otherwise.</p>
  </dd>
  <dt>
    <p><strong>#if </strong><em>expr</em></p>
  </dt>
  <dd>
    <p>This meta-macro invokes the arithmetic/globbing evaluator in the same manner as <em>#eval</em> and compares the result of evaluation with the string "0" in order to begin a conditional block. In particular note that the logical value of <em>expr</em> is always true when it cannot be evaluated to a number.</p>
  </dd>
  <dt>
    <p><strong>#elif </strong><em>expr</em></p>
  </dt>
  <dd>
    <p>This meta-macro can be used to avoid nested <em>#if</em> conditions. <em>#if</em> ... <em>#elif</em> ... <em>#endif</em> is equivalent to <em>#if</em> ... <em>#else</em> <em>#if</em> ... <em>#endif</em> <em>#endif</em>.</p>
  </dd>
  <dt>
    <p><strong>#mode </strong><em>keyword ...</em></p>
  </dt>
  <dd>
    <p>This meta-macro controls GPP's operating mode. See below for a list of <em>#mode</em> commands.</p>
  </dd>
  <dt>
    <p><strong>#line</strong><em></em></p>
  </dt>
  <dd>
    <p>This meta-macro evaluates to the line number of the current input file.</p>
  </dd>
  <dt>
    <p><strong>#file</strong><em></em></p>
  </dt>
  <dd>
    <p>This meta-macro evaluates to the filename of the current input file as it appears on the command line or in the argument to <em>#include</em>. If GPP is reading its input from stdin, then <em>#file</em> evaluates to `stdin'.</p>
  </dd>
  <dt>
    <p><strong>#date </strong><em>fmt</em></p>
  </dt>
  <dd>
    <p>This meta-macro evaluates to the current date and time as formatted by the specified format string <em>fmt</em>.  See the section <em>DATE AND</em> TIME CONVERSION SPECIFIERS below.</p>
  </dd>
  <dt>
    <p><strong>#error </strong><em>msg</em></p>
  </dt>
  <dd>
    <p>This meta-macro causes an error message with the current filename and line number, and with the text <em>msg</em>, to be printed to the standard error device.  Subsequent processing is then aborted.</p>
  </dd>
  <dt>
    <p><strong>#warning </strong><em>msg</em></p>
  </dt>
  <dd>
    <p>This meta-macro causes a warning message with the current filename and line number, and with the text <em>msg</em>, to be printed to the standard error device.  Subsequent processing is then resumed.</p>
  </dd>

</dl>
<p>The key to GPP's flexibility is the <em>#mode</em> meta-macro. Its first argument is always one of a list of available keywords (see below); its second argument is always a sequence of words separated by whitespace. Apart from possibly the first of them, each of these words is always a delimiter or syntax specifier, and should be provided as a C string delimited by double quotes ("&nbsp;"). The various special matching sequences listed in the section on syntax specification are available. Any <em>#mode</em> command is parsed in a mode where "..." is understood to be a C-style string, so it is safe to put any character inside these strings. Also note that the first argument of <em>#mode</em> (the keyword) is never evaluated, while the second argument is evaluated (except of course for the contents of C strings), so that the syntax specification may be obtained as the result of a macro evaluation.</p><p>The available <em>#mode</em> commands are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>#mode save / #mode push</strong><em></em></p>
  </dt>
  <dd>
    <p>Push the current mode specification onto the mode stack.</p>
  </dd>
  <dt>
    <p><strong>#mode restore / #mode pop</strong><em></em></p>
  </dt>
  <dd>
    <p>Pop mode specification from the mode stack.</p>
  </dd>
  <dt>
    <p><strong>#mode standard </strong><em>name</em></p>
  </dt>
  <dd>
    <p>Select one of the standard modes. The only argument must be one of: default (default mode); cpp, C (cpp mode); tex, TeX&nbsp;(tex mode); html, HTML (html mode); xhtml, XHTML (xhtml mode); prolog, Prolog (prolog mode). The mode name must be given directly, not as a C string.</p>
  </dd>
  <dt>
    <p><strong>#mode user </strong><em></em><strong>s1</strong><em> ... </em><strong>s9</strong><em></em></p>
  </dt>
  <dd>
    <p>Specify user macro syntax. The 9 arguments, all of them C strings, are the mode specification for user macros (see the -U command-line option and the section on syntax specification). The meta-macro specification is not affected.</p>
  </dd>
  <dt>
    <p><strong>#mode meta </strong><em>{user | </em><strong>s1</strong><em> ... </em><strong>s7</strong><em>}</em></p>
  </dt>
  <dd>
    <p>Specify meta-macro syntax. Either the only argument is <em>user</em> (not as a string), and the user-macro mode specifications are copied into the meta-macro mode specifications, or there must be seven string arguments, whose significance is the same as for the -M command-line option (see section on syntax specification).</p>
  </dd>
  <dt>
    <p><strong>#mode quote </strong><em>[</em><strong>c</strong><em>]</em></p>
  </dt>
  <dd>
    <p>With no argument or "" as argument, removes the quote character specification and disables the quoting functionality. With one string argument, the first character of the string is taken to be the new quote character. The quote character can be neither alphanumeric nor '_', nor can it be one of the special matching sequences.</p>
  </dd>
  <dt>
    <p><strong>#mode comment </strong><em>[xxx] </em><strong>start</strong><em> </em><strong>end</strong><em> [</em><strong>c</strong><em> [</em><strong>c</strong><em>]]</em></p>
  </dt>
  <dd>
    <p>Add a comment specification. Optionally a first argument consisting of three characters not enclosed in "&nbsp;" can be used to specify a comment/string modifier (see the section on syntax specification). The default modifier is <em>ccc</em>. The first two string arguments are used as comment start and end sequences respectively. The third string argument is optional and can be used to specify a string-quote character. (If it is "", the functionality is disabled.) The fourth string argument is optional and can be used to specify a string delimitation warning character. (If it is "", the functionality is disabled.)</p>
  </dd>
  <dt>
    <p><strong>#mode string </strong><em>[xxx] </em><strong>start</strong><em> </em><strong>end</strong><em> [</em><strong>c</strong><em> [</em><strong>c</strong><em>]]</em></p>
  </dt>
  <dd>
    <p>Add a string specification. Identical to <em>#mode comment</em> except that the default modifier is <em>sss</em>.</p>
  </dd>
  <dt>
    <p><strong>#mode nocomment / #mode nostring </strong><em>[</em><strong>start</strong><em>]</em></p>
  </dt>
  <dd>
    <p>With no argument, remove all comment/string specifications. With one string argument, delete the comment/string specification whose start sequence is the argument.</p>
  </dd>
  <dt>
    <p><strong>#mode preservelf </strong><em>{ on | off | 1 | 0 }</em></p>
  </dt>
  <dd>
    <p>Equivalent to the <em>-n</em> command-line switch. If the argument is <em>on</em> or <em>1</em>, any newline or whitespace character terminating a macro call or a comment/string is left in the input stream for further processing. If the argument is <em>off</em> or <em>0</em> this feature is disabled.</p>
  </dd>
  <dt>
    <p><strong>#mode charset </strong><em>{ id | op | par } </em><strong>string</strong><em></em></p>
  </dt>
  <dd>
    <p>Specify the character sets to be used for matching the &#92;o, &#92;O and &#92;i special sequences. The first argument must be one of <em>id</em> (the set matched by &#92;i), <em>op</em> (the set matched by &#92;o) or <em>par</em> (the set matched by &#92;O in addition to the one matched by &#92;o). <em>"string"</em> is a C string which lists all characters to put in the set. It may contain only the special matching sequences &#92;a, &#92;A, &#92;b, &#92;B, and &#92;# (the other sequences and the negated sequences are not allowed). When a '-' is found inbetween two non-special characters this adds all characters inbetween (e.g. "A-Z" corresponds to all uppercase characters). To have '-' in the matched set, either put it in first or last position or place it next to a &#92;x sequence.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DATE AND TIME CONVERSION SPECIFIERS</h2>
        <div class="sectioncontent">
<p>Ordinary characters placed in the format string are copied to without conversion.  Conversion specifiers are introduced by a `%' character, and are replaced as follows:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>%a</strong><em></em></p>
  </dt>
  <dd>
    <p>The abbreviated weekday name according to the  current locale.</p>
  </dd>
  <dt>
    <p><strong>%A</strong><em></em></p>
  </dt>
  <dd>
    <p>The  full  weekday  name  according  to the current locale.</p>
  </dd>
  <dt>
    <p><strong>%b</strong><em></em></p>
  </dt>
  <dd>
    <p>The abbreviated month name according to the current locale.</p>
  </dd>
  <dt>
    <p><strong>%B</strong><em></em></p>
  </dt>
  <dd>
    <p>The  full  month  name  according  to  the  current locale.</p>
  </dd>
  <dt>
    <p><strong>%c</strong><em></em></p>
  </dt>
  <dd>
    <p>The preferred date and time representation for  the current locale.</p>
  </dd>
  <dt>
    <p><strong>%d</strong><em></em></p>
  </dt>
  <dd>
    <p>The day of the month as a decimal number (range  01 to 31).</p>
  </dd>
  <dt>
    <p><strong>%F</strong><em></em></p>
  </dt>
  <dd>
    <p>Equivalent to %Y-%m-%d (the ISO 8601 date  format).</p>
  </dd>
  <dt>
    <p><strong>%H</strong><em></em></p>
  </dt>
  <dd>
    <p>The  hour as a decimal number using a 24-hour clock (range 00 to 23).</p>
  </dd>
  <dt>
    <p><strong>%I</strong><em></em></p>
  </dt>
  <dd>
    <p>The hour as a decimal number using a 12-hour  clock (range 01 to 12).</p>
  </dd>
  <dt>
    <p><strong>%j</strong><em></em></p>
  </dt>
  <dd>
    <p>The  day of the year as a decimal number (range 001 to 366).</p>
  </dd>
  <dt>
    <p><strong>%m</strong><em></em></p>
  </dt>
  <dd>
    <p>The month as a decimal number (range 01 to 12).</p>
  </dd>
  <dt>
    <p><strong>%M</strong><em></em></p>
  </dt>
  <dd>
    <p>The minute as a decimal number (range 00 to 59).</p>
  </dd>
  <dt>
    <p><strong>%p</strong><em></em></p>
  </dt>
  <dd>
    <p>Either `AM' or `PM' according  to  the  given  time value, or the corresponding strings for the current locale.  Noon is treated as `pm'  and  midnight  as `am'.</p>
  </dd>
  <dt>
    <p><strong>%R</strong><em></em></p>
  </dt>
  <dd>
    <p>The  time  in  24-hour notation (%H:%M).</p>
  </dd>
  <dt>
    <p><strong>%S</strong><em></em></p>
  </dt>
  <dd>
    <p>The second as a decimal number (range 00 to 61).</p>
  </dd>
  <dt>
    <p><strong>%U</strong><em></em></p>
  </dt>
  <dd>
    <p>The week number of the current year  as  a  decimal number,  range  00  to  53, starting with the first Sunday as the first day of week 01.</p>
  </dd>
  <dt>
    <p><strong>%w</strong><em></em></p>
  </dt>
  <dd>
    <p>The  day  of  the  week as a decimal, range 0 to 6, Sunday being 0.</p>
  </dd>
  <dt>
    <p><strong>%W</strong><em></em></p>
  </dt>
  <dd>
    <p>The week number of the current year  as  a  decimal number,  range  00  to  53, starting with the first Monday as the first day of week 01.</p>
  </dd>
  <dt>
    <p><strong>%x</strong><em></em></p>
  </dt>
  <dd>
    <p>The preferred date representation for  the  current locale without the time.</p>
  </dd>
  <dt>
    <p><strong>%X</strong><em></em></p>
  </dt>
  <dd>
    <p>The  preferred  time representation for the current locale without the date.</p>
  </dd>
  <dt>
    <p><strong>%y</strong><em></em></p>
  </dt>
  <dd>
    <p>The year as a  decimal  number  without  a  century (range 00 to 99).</p>
  </dd>
  <dt>
    <p><strong>%Y</strong><em></em></p>
  </dt>
  <dd>
    <p>The year as a decimal number including the century.</p>
  </dd>
  <dt>
    <p><strong>%Z</strong><em></em></p>
  </dt>
  <dd>
    <p>The time zone or name or abbreviation.</p>
  </dd>
  <dt>
    <p><strong>%%</strong><em></em></p>
  </dt>
  <dd>
    <p>A literal `%' character.</p>
  </dd>

</dl>
<p>Depending on the C compiler and library used to compile GPP, there may be more conversion specifiers available.  Consult your compiler's documentation for the <em>strftime()</em> function.  Note, however, that any conversion specifiers not listed above may not be portable across installations of GPP.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>Here is a basic self-explanatory example in standard or cpp mode:</p>
<pre>
  #define FOO This is
  #define BAR a message.
  #define concat #1 #2
  concat(FOO,BAR)
  #ifeq (concat(foo,bar)) (foo bar)
  This is output.
  #else
  This is not output.
  #endif
</pre>
<p>Using argument naming, the <em>concat</em> macro could alternatively be defined as</p>
<pre>
  #define concat(x,y) x y
</pre>
<p>In TeX&nbsp;mode and using argument naming, the same example becomes:</p>
<pre>
  &#92;define{FOO}{This is}
  &#92;define{BAR}{a message.}
  &#92;define{&#92;concat{x}{y}}{&#92;x &#92;y}
  &#92;concat{&#92;FOO}{&#92;BAR}
  &#92;ifeq{&#92;concat{foo}{bar}}{foo bar}
  This is output.
  &#92;else
  This is not output.
  &#92;endif
</pre>
<p>In HTML mode and without argument naming, one gets similarly:</p>
<pre>
  &lt;#define FOO|This is&gt;
  &lt;#define BAR|a message.&gt;
  &lt;#define concat|#1 #2&gt;
  &lt;#concat &lt;#FOO&gt;|&lt;#BAR&gt;&gt;
  &lt;#ifeq &lt;#concat foo|bar&gt;|foo bar&gt;
  This is output.
  &lt;#else&gt;
  This is not output.
  &lt;#endif&gt;
</pre>
<p>The following example (in standard mode) illustrates the use of the quote character:</p>
<pre>
  #define FOO This is &#92;
     a multiline definition.
  #define BLAH(x) My argument is x
  BLAH(urf)
  &#92;BLAH(urf)
</pre>
<p>Note that the multiline definition is also valid in cpp and Prolog modes despite the absence of quote character, because '&#92;' followed by a newline is then interpreted as a comment and discarded.</p><p>In cpp mode, C strings and comments are understood as such, as illustrated by the following example:</p>
<pre>
  #define BLAH foo
  BLAH "BLAH" /* BLAH */
  'It&#92;'s a /*string*/ !'
</pre>
<p>The main difference between Prolog mode and cpp mode is the handling of strings and comments: in Prolog, a '...' string may not begin immediately after a digit, and a /*...*/ comment may not begin immediately after an operator character. Furthermore, comments are not removed from the output unless they occur in a #command.</p><p>The differences between cpp mode and default mode are deeper: in default mode #commands may start anywhere, while in cpp mode they must be at the beginning of a line; the default mode has no knowledge of comments and strings, but has a quote character ('&#92;'), while cpp mode has extensive comment/string specifications but no quote character. Moreover, the arguments to meta-macros need to be correctly parenthesized in default mode, while no such checking is performed in cpp mode.</p><p>This makes it easier to nest meta-macro calls in default mode than in cpp mode. For example, consider the following HTML mode input, which tests for the availability of the <em>#exec</em> command:</p>
<pre>
  &lt;#ifeq &lt;#exec echo blah&gt;|blah
  &gt; #exec allowed &lt;#else&gt; #exec not allowed &lt;#endif&gt;
</pre>
<p>There is no cpp mode equivalent, while in default mode it can be easily translated as</p>
<pre>
  #ifeq (#exec echo blah
  ) (blah
  )
  &#92;#exec allowed
  #else
  &#92;#exec not allowed
  #endif
</pre>
<p>In order to nest meta-macro calls in cpp mode it is necessary to modify the mode description, either by changing the meta-macro call syntax, or more elegantly by defining a silent string and using the fact that the context at the beginning of an evaluated string is a newline character:</p>
<pre>
  #mode string QQQ "$" "$"
  #ifeq $#exec echo blah
  $ $blah
  $
  &#92;#exec allowed
  #else
  &#92;#exec not allowed
  #endif
</pre>
<p>Note, however, that comments/strings cannot be nested ("..." inside $...$ would go undetected), so one needs to be careful about what to include inside such a silent evaluated string. In this example, the loose meta-macro nesting introduced in version 2.1 makes it possible to use the following simpler version:</p>
<pre>
  #ifeq blah #exec echo -n blah
  &#92;#exec allowed
  #else
  &#92;#exec not allowed
  #endif
</pre>
<p>Remember that macros without arguments are actually understood to be aliases when they are called with arguments, as illustrated by the following example (default or cpp mode):</p>
<pre>
  #define DUP(x) x x
  #define FOO and I said: DUP
  FOO(blah)
</pre>
<p>The usefulness of the <em>#defeval</em> meta-macro is shown by the following example in HTML mode:</p>
<pre>
  &lt;#define APPLY|&lt;#defeval TEMP|&lt;&#92;##1 &#92;#1&gt;&gt;&lt;#TEMP #2&gt;&gt;
  &lt;#define &lt;#foo x&gt;|&lt;#x&gt; and &lt;#x&gt;&gt;
  &lt;#APPLY foo|BLAH&gt;
</pre>
<p>The reason why <em>#defeval</em> is needed is that, since everything is evaluated in a single pass, the input that will result in the desired macro call needs to be generated by a first evaluation of the arguments passed to APPLY before being evaluated a second time.</p><p>To translate this example in default mode, one needs to resort to parenthesizing in order to nest the #defeval call inside the definition of APPLY, but need to do so without outputting the parentheses. The easiest solution is</p>
<pre>
  #define BALANCE(x) x
  #define APPLY(f,v) BALANCE(#defeval TEMP f
  TEMP(v))
  #define foo(x) x and x
  APPLY(&#92;foo,BLAH)
</pre>
<p>As explained above the simplest version in cpp mode relies on defining a silent evaluated string to play the role of the BALANCE macro.</p><p>The following example (default or cpp mode) demonstrates arithmetic evaluation:</p>
<pre>
  #define x 4
  The answer is:
  #eval x*x + 2*(16-x) + 1998%x
</pre>

<pre>
  #if defined(x)&&!(3*x+5&gt;17)
  This should be output.
  #endif
</pre>
<p>To finish, here are some examples involving mode switching. The following example is self-explanatory (starting in default mode):</p>
<pre>
  #mode push
  #define f(x) x x
  #mode standard tex
  &#92;f{blah}
  &#92;mode{string}{"$" "$"}
  &#92;mode{comment}{"/*" "*/"}
  $&#92;f{urf}$ /* blah */
  &#92;define{FOO}{bar/* and some more */}
  &#92;mode{pop}
  f($FOO$)
</pre>
<p>A good example where a user-defined mode becomes useful is the GPP source of this document (available with GPP's source code distribution).</p><p>Another interesting application is selectively forcing evaluation of macros in C strings when in cpp mode. For example, consider the following input:</p>
<pre>
  #define blah(x) "and he said: x"
  blah(foo)
</pre>
<p>Obviously one would want the parameter <em>x</em> to be expanded inside the string. There are several ways around this problem:</p>
<pre>
  #mode push
  #mode nostring "   #define blah(x) "and he said: x"
  #mode pop
</pre>

<pre>
  #mode quote "`"
  #define blah(x) `"and he said: x`"
</pre>

<pre>
  #mode string QQQ "$$" "$$"
  #define blah(x) $$"and he said: x"$$
</pre>
<p>The first method is very natural, but has the inconvenience of being lengthy and neutralizing string semantics, so that having an unevaluated instance of 'x' in the string, or an occurrence of '/*', would be impossible without resorting to further contortions.</p><p>The second method is slightly more efficient because the local presence of a quote character makes it easier to control what is evaluated and what isn't, but has the drawback that it is sometimes impossible to find a reasonable quote character without having to either significantly alter the source file or enclose it inside a <em>#mode push/pop</em> construct. For example, any occurrence of '/*' in the string would have to be quoted.</p><p>The last method demonstrates the efficiency of evaluated strings in the context of selective evaluation: since comments/strings cannot be nested, any occurrence of '"' or '/*' inside the '$$' gets output as plain text, as expected inside a string, and only macro evaluation is enabled. Also note that there is much more freedom in the choice of a string delimiter than in the choice of a quote character.</p><p>Starting with version 2.1, meta-macro calls can be nested more efficiently in default, cpp and Prolog modes. This makes it easy to make a user version of a meta-macro, or to increment a counter:</p>
<pre>
  #define myeval #eval #1
</pre>

<pre>
  #define x 1
  #defeval x #eval x+1
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ADVANCED EXAMPLES</h2>
        <div class="sectioncontent">
<p>Here are some examples of advanced constructions using GPP. They tend to be pretty awkward and should be considered as evidence of GPP's limitations.</p><p>The first example is a recursive macro. The main problem is that (since GPP evaluates everything) a recursive macro must be very careful about the way in which recursion is terminated in order to avoid undefined behavior (most of the time GPP will simply crash). In particular, relying on a <em>#if/#else/#endif</em> construct to end recursion is not possible and results in an infinite loop, because GPP scans user macro calls even in the unevaluated branch of the conditional block. A safe way to proceed is for example as follows (we give the example in TeX&nbsp;mode):</p>
<pre>
  &#92;define{countdown}{
    &#92;if{#1}
    #1...
    &#92;define{loop}{&#92;countdown}
    &#92;else
    Done.
    &#92;define{loop}{}
    &#92;endif
    &#92;loop{&#92;eval{#1-1}}
  }
  &#92;countdown{10}
</pre>
<p>Another example, in cpp mode:</p>
<pre>
  #mode string QQQ "$" "$"
  #define triangle(x,y) y &#92;
   $#if length(y)&lt;x$ $#define iter triangle$ $#else$ &#92;
   $#define iter$ $#endif
  $ iter(x,*y)
  triangle(20)
</pre>
<p>The following is an (unfortunately very weak) attempt at implementing functional abstraction in GPP (in standard mode). Understanding this example and why it can't be made much simpler is an exercise left to the curious reader.</p>
<pre>
  #mode string "`" "`" "&#92;
  #define ASIS(x) x
  #define SILENT(x) ASIS()
  #define EVAL(x,f,v) SILENT(
    #mode string QQQ "`" "`" "&#92;
    #defeval TEMP0 x
    #defeval TEMP1 (
      &#92;#define &#92;TEMP2(TEMP0) f
    )
    TEMP1
    )TEMP2(v)
  #define LAMBDA(x,f,v) SILENT(
    #ifneq (v) ()
    #define TEMP3(a,b,c) EVAL(a,b,c)
    #else
    #define TEMP3(a,b,c) &#92;LAMBDA(a,b)
    #endif
    )TEMP3(x,f,v)
  #define EVALAMBDA(x,y) SILENT(
    #defeval TEMP4 x
    #defeval TEMP5 y
    )
  #define APPLY(f,v) SILENT(
    #defeval TEMP6 ASIS(&#92;EVA)f
    TEMP6
    )EVAL(TEMP4,TEMP5,v)
</pre>
<p>This yields the following results:</p>
<pre>
  LAMBDA(z,z+z)
    =&gt; LAMBDA(z,z+z)
</pre>

<pre>
  LAMBDA(z,z+z,2)
    =&gt; 2+2
</pre>

<pre>
  #define f LAMBDA(y,y*y)
  f
    =&gt; LAMBDA(y,y*y)
</pre>

<pre>
  APPLY(f,blah)
    =&gt; blah*blah
</pre>

<pre>
  APPLY(LAMBDA(t,t t),(t t))
    =&gt; (t t) (t t)
</pre>

<pre>
  LAMBDA(x,APPLY(f,(x+x)),urf)
    =&gt; (urf+urf)*(urf+urf)
</pre>

<pre>
  APPLY(APPLY(LAMBDA(x,LAMBDA(y,x*y)),foo),bar)
    =&gt; foo*bar
</pre>

<pre>
  #define test LAMBDA(y,`#ifeq y urf
  y is urf#else
  y is not urf#endif
  `)
  APPLY(test,urf)
    =&gt; urf is urf
</pre>

<pre>
  APPLY(test,foo)
    =&gt; foo is not urf
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO gpp&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man3/strftime.3.html"><strong>strftime</strong>(3)</a>, <a href="../man7/glob.7.html"><strong>glob</strong>(7)</a>, m4(1V), <strong>cpp</strong>(1)</p><p>GPP home page: http://www.nothingisreal.com/gpp/</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>GPP was written by Denis Auroux &lt;auroux@math.mit.edu&gt;. Since version 2.12 it has been maintained by Tristan Miller &lt;psychonaut@nothingisreal.com&gt;.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright (C)&nbsp;1996-2001 Denis Auroux.</p><p>Copyright (C)&nbsp;2003, 2004 Tristan Miller.</p><p>Permission is granted to anyone to make or distribute verbatim copies of this document as received, in any medium, provided that the copyright notice and this permission notice are preserved, thus giving the recipient permission to redistribute in turn.</p><p>Permission is granted to distribute modified versions of this document, or of portions of it, under the above conditions, provided also that they carry prominent notices stating who last changed them.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="gpomme.1.html"><span aria-hidden="true">&larr;</span> gpomme.1: Gtk+ graphical client for use with pommed</a></li>
   <li class="next"><a href="gpr.1.html">gpr.1: A graphical frontend for lpr. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

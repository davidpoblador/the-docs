<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>antlr: Another tool for language recognition</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Another tool for language recognition">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="antlr (1) manual">
  <meta name="twitter:description" content="Another tool for language recognition">
  <meta name="twitter:image" content="https://www.carta.tech/images/pccts-antlr-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/antlr.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="antlr (1) manual" />
  <meta property="og:description" content="Another tool for language recognition" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/pccts-antlr-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">antlr<small> (1)</small></h1>
        <p class="lead">Another tool for language recognition</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/antlr.1.html">
      <span itemprop="name">antlr: Another tool for language recognition</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/pccts/">
      <span itemprop="name">pccts</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/antlr.1.html">
      <span itemprop="name">antlr: Another tool for language recognition</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNTAX</h2>
        <div class="sectioncontent">
<p><strong>antlr</strong> [<em>options</em>] <em>grammar_files</em></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><em>Antlr</em> converts an extended form of context-free grammar into a set of C functions which directly implement an efficient form of deterministic recursive-descent LL(k) parser.  Context-free grammars may be augmented with predicates to allow semantics to influence parsing; this allows a form of context-sensitive parsing.  Selective backtracking is also available to handle non-LL(k) and even non-LALR(k) constructs.  <em>Antlr</em> also produces a definition of a lexer which can be automatically converted into C code for a DFA-based lexer by <em>dlg</em>.  Hence, <em>antlr</em> serves a function much like that of <em>yacc</em>, however, it is notably more flexible and is more integrated with a lexer generator (<em>antlr</em> directly generates <em>dlg</em> code, whereas <em>yacc</em> and <em>lex</em> are given independent descriptions).  Unlike <em>yacc</em> which accepts <strong>LALR</strong>(1) grammars, <em>antlr</em> accepts LL(k) grammars in an extended BNF notation &ndash; which eliminates the need for precedence rules.</p><p>Like <em>yacc</em> grammars, <em>antlr</em> grammars can use automatically-maintained symbol attribute values referenced as dollar variables.  Further, because <em>antlr</em> generates top-down parsers, arbitrary values may be inherited from parent rules (passed like function parameters).  <em>Antlr</em> also has a mechanism for creating and manipulating abstract-syntax-trees.</p><p>There are various other niceties in <em>antlr</em>, including the ability to spread one grammar over multiple files or even multiple grammars in a single file, the ability to generate a version of the grammar with actions stripped out (for documentation purposes), and lots more.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <strong>-ck </strong><em>n</em>
  </dt>
  <dd>
    <p>Use up to <em>n</em> symbols of lookahead when using compressed (linear approximation) lookahead.  This type of lookahead is very cheap to compute and is attempted before full LL(k) lookahead, which is of exponential complexity in the worst case.  In general, the compressed lookahead can be much deeper (e.g, -ck 10) than the full lookahead (which usually must be less than 4).</p>
  </dd>
  <dt>
    <strong>-CC</strong>
  </dt>
  <dd>
    <p>Generate C++ output from both ANTLR and DLG.</p>
  </dd>
  <dt>
    <strong>-cr</strong>
  </dt>
  <dd>
    <p>Generate a cross-reference for all rules.  For each rule, print a list of all other rules that reference it.</p>
  </dd>
  <dt>
    <strong>-e1</strong>
  </dt>
  <dd>
    <p>Ambiguities/errors shown in low detail (default).</p>
  </dd>
  <dt>
    <strong>-e2</strong>
  </dt>
  <dd>
    <p>Ambiguities/errors shown in more detail.</p>
  </dd>
  <dt>
    <strong>-e3</strong>
  </dt>
  <dd>
    <p>Ambiguities/errors shown in excruciating detail.</p>
  </dd>
  <dt>
    <strong>-fe</strong> file
  </dt>
  <dd>
    <p>Rename <strong>err.c</strong> to file.</p>
  </dd>
  <dt>
    <strong>-fh</strong> file
  </dt>
  <dd>
    <p>Rename <strong>stdpccts.h</strong> header (turns on <strong>-gh</strong>) to file.</p>
  </dd>
  <dt>
    <strong>-fl</strong> file
  </dt>
  <dd>
    <p>Rename lexical output, <strong>parser.dlg</strong>, to file.</p>
  </dd>
  <dt>
    <strong>-fm</strong> file
  </dt>
  <dd>
    <p>Rename file with lexical mode definitions, <strong>mode.h</strong>, to file.</p>
  </dd>
  <dt>
    <strong>-fr</strong> file
  </dt>
  <dd>
    <p>Rename file which remaps globally visible symbols, <strong>remap.h</strong>, to file.</p>
  </dd>
  <dt>
    <strong>-ft</strong> file
  </dt>
  <dd>
    <p>Rename <strong>tokens.h</strong> to file.</p>
  </dd>
  <dt>
    <strong>-ga</strong>
  </dt>
  <dd>
    <p>Generate ANSI-compatible code (default case).  This has not been rigorously tested to be ANSI XJ11 C compliant, but it is close.  The normal output of <em>antlr</em> is currently compilable under both K&R, ANSI C, and C++&ndash;this option does nothing because <em>antlr</em> generates a bunch of #ifdef's to do the right thing depending on the language.</p>
  </dd>
  <dt>
    <strong>-gc</strong>
  </dt>
  <dd>
    <p>Indicates that <em>antlr</em> should generate no C code, i.e., only perform analysis on the grammar.</p>
  </dd>
  <dt>
    <strong>-gd</strong>
  </dt>
  <dd>
    <p>C code is inserted in each of the <em>antlr</em> generated parsing functions to provide for user-defined handling of a detailed parse trace.  The inserted code consists of calls to the user-supplied macros or functions called <strong>zzTRACEIN</strong> and <strong>zzTRACEOUT</strong>.  The only argument is a <em>char *</em> pointing to a C-style string which is the grammar rule recognized by the current parsing function.  If no definition is given for the trace functions, upon rule entry and exit, a message will be printed indicating that a particular rule as been entered or exited.</p>
  </dd>
  <dt>
    <strong>-ge</strong>
  </dt>
  <dd>
    <p>Generate an error class for each non-terminal.</p>
  </dd>
  <dt>
    <strong>-gh</strong>
  </dt>
  <dd>
    <p>Generate <strong>stdpccts.h</strong> for non-ANTLR-generated files to include. This file contains all defines needed to describe the type of parser generated by <em>antlr</em> (e.g. how much lookahead is used and whether or not trees are constructed) and contains the <strong>header</strong> action specified by the user.</p>
  </dd>
  <dt>
    <strong>-gk</strong>
  </dt>
  <dd>
    <p>Generate parsers that delay lookahead fetches until needed.  Without this option, <em>antlr</em> generates parsers which always have <em>k</em> tokens of lookahead available.</p>
  </dd>
  <dt>
    <strong>-gl</strong>
  </dt>
  <dd>
    <p>Generate line info about grammar actions in C parser of the form <strong>#&nbsp;</strong><em>line</em><strong>&nbsp;"</strong><em>file</em><strong>"</strong> which makes error messages from the C/C++ compiler make more sense as they will point into the grammar file not the resulting C file.  Debugging is easier as well, because you will step through the grammar not C file.</p>
  </dd>
  <dt>
    <strong>-gs</strong>
  </dt>
  <dd>
    <p>Do not generate sets for token expression lists; instead generate a <strong>||</strong>-separated sequence of <strong>LA(1)==</strong><em>token_number</em>.  The default is to generate sets.</p>
  </dd>
  <dt>
    <strong>-gt</strong>
  </dt>
  <dd>
    <p>Generate code for Abstract-Syntax Trees.</p>
  </dd>
  <dt>
    <strong>-gx</strong>
  </dt>
  <dd>
    <p>Do not create the lexical analyzer files (dlg-related).  This option should be given when the user wishes to provide a customized lexical analyzer.  It may also be used in <em>make</em> scripts to cause only the parser to be rebuilt when a change not affecting the lexical structure is made to the input grammars.</p>
  </dd>
  <dt>
    <strong>-k </strong><em>n</em>
  </dt>
  <dd>
    <p>Set k of LL(k) to <em>n</em>; i.e. set tokens of look-ahead (default==1).</p>
  </dd>
  <dt>
    <strong>-o</strong> dir
  </dt>
  <dd>
    <p>Directory where output files should go (default=".").  This is very nice for keeping the source directory clear of ANTLR and DLG spawn.</p>
  </dd>
  <dt>
    <strong>-p</strong>
  </dt>
  <dd>
    <p>The complete grammar, collected from all input grammar files and stripped of all comments and embedded actions, is listed to <strong>stdout</strong>.  This is intended to aid in viewing the entire grammar as a whole and to eliminate the need to keep actions concisely stated so that the grammar is easier to read.  Hence, it is preferable to embed even complex actions directly in the grammar, rather than to call them as subroutines, since the subroutine call overhead will be saved.</p>
  </dd>
  <dt>
    <strong>-pa</strong>
  </dt>
  <dd>
    <p>This option is the same as <strong>-p</strong> except that the output is annotated with the first sets determined from grammar analysis.</p>
  </dd>
  <dt>
    <strong>-prc on</strong>
  </dt>
  <dd>
    <p>Turn on the computation and hoisting of predicate context.</p>
  </dd>
  <dt>
    <strong>-prc off</strong>
  </dt>
  <dd>
    <p>Turn off the computation and hoisting of predicate context.  This option makes 1.10 behave like the 1.06 release with option <strong>-pr</strong> on.  Context computation is off by default.</p>
  </dd>
  <dt>
    <strong>-rl </strong><em>n</em>
  </dt>
  <dd>
    <p>Limit the maximum number of tree nodes used by grammar analysis to <em>n</em>.  Occasionally, <em>antlr</em> is unable to analyze a grammar submitted by the user.  This rare situation can only occur when the grammar is large and the amount of lookahead is greater than one.  A nonlinear analysis algorithm is used by PCCTS to handle the general case of LL(k) parsing.  The average complexity of analysis, however, is near linear due to some fancy footwork in the implementation which reduces the number of calls to the full LL(k) algorithm.  An error message will be displayed, if this limit is reached, which indicates the grammar construct being analyzed when <em>antlr</em> hit a non-linearity.  Use this option if <em>antlr</em> seems to go out to lunch and your disk start thrashing; try <em>n</em>=10000 to start.  Once the offending construct has been identified, try to remove the ambiguity that <em>antlr</em> was trying to overcome with large lookahead analysis.  The introduction of (...)? backtracking blocks eliminates some of these problems&nbsp;&ndash; <em>antlr</em> does not analyze alternatives that begin with (...)? (it simply backtracks, if necessary, at run time).</p>
  </dd>
  <dt>
    <strong>-w1</strong>
  </dt>
  <dd>
    <p>Set low warning level.  Do not warn if semantic predicates and/or (...)? blocks are assumed to cover ambiguous alternatives.</p>
  </dd>
  <dt>
    <strong>-w2</strong>
  </dt>
  <dd>
    <p>Ambiguous parsing decisions yield warnings even if semantic predicates or (...)? blocks are used.  Warn if predicate context computed and semantic predicates incompletely disambiguate alternative productions.</p>
  </dd>
  <dt>
    <strong>-</strong>
  </dt>
  <dd>
    <p>Read grammar from standard input and generate <strong>stdin.c</strong> as the parser file.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SPECIAL CONSIDERATIONS</h2>
        <div class="sectioncontent">
<p><em>Antlr</em> works...  we think.  There is no implicit guarantee of anything.  We reserve no <strong>legal</strong> rights to the software known as the Purdue Compiler Construction Tool Set (PCCTS) &ndash; PCCTS is in the public domain.  An individual or company may do whatever they wish with source code distributed with PCCTS or the code generated by PCCTS, including the incorporation of PCCTS, or its output, into commercial software.  We encourage users to develop software with PCCTS.  However, we do ask that credit is given to us for developing PCCTS.  By "credit", we mean that if you incorporate our source code into one of your programs (commercial product, research project, or otherwise) that you acknowledge this fact somewhere in the documentation, research report, etc...  If you like PCCTS and have developed a nice tool with the output, please mention that you developed it using PCCTS.  As long as these guidelines are followed, we expect to continue enhancing this system and expect to make other tools available as they are completed.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILES</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    *.c
  </dt>
  <dd>
    <p>output C parser.</p>
  </dd>
  <dt>
    *.cpp
  </dt>
  <dd>
    <p>output C++ parser when C++ mode is used.</p>
  </dd>
  <dt>
    <strong>parser.dlg</strong>
  </dt>
  <dd>
    <p>output <em>dlg</em> lexical analyzer.</p>
  </dd>
  <dt>
    <strong>err.c</strong>
  </dt>
  <dd>
    <p>token string array, error sets and error support routines.  Not used in C++ mode.</p>
  </dd>
  <dt>
    <strong>remap.h</strong>
  </dt>
  <dd>
    <p>file that redefines all globally visible parser symbols.  The use of the #parser directive creates this file.  Not used in C++ mode.</p>
  </dd>
  <dt>
    <strong>stdpccts.h</strong>
  </dt>
  <dd>
    <p>list of definitions needed by C files, not generated by PCCTS, that reference PCCTS objects.  This is not generated by default.  Not used in C++ mode.</p>
  </dd>
  <dt>
    <strong>tokens.h</strong>
  </dt>
  <dd>
    <p>output <em>#defines</em> for tokens used and function prototypes for functions generated for rules.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO antlr&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man1/dlg.1.html"><strong>dlg</strong>(1)</a>, <strong>pccts</strong>(1)</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="antiword.1.html"><span aria-hidden="true">&larr;</span> antiword.1: Show the text and images of ms word documents</a></li>
   <li class="next"><a href="antpm-fit2gpx.1.html">antpm-fit2gpx.1: Console based fit to gpx converter <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

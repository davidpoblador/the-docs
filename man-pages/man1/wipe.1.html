<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>wipe: Securely erase files from magnetic media</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Securely erase files from magnetic media">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="wipe (1) manual">
  <meta name="twitter:description" content="Securely erase files from magnetic media">
  <meta name="twitter:image" content="https://www.carta.tech/images/wipe-wipe-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/wipe.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="wipe (1) manual" />
  <meta property="og:description" content="Securely erase files from magnetic media" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/wipe-wipe-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">wipe<small> (1)</small></h1>
        <p class="lead">Securely erase files from magnetic media</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/wipe.1.html">
      <span itemprop="name">wipe: Securely erase files from magnetic media</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/wipe/">
      <span itemprop="name">wipe</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/wipe.1.html">
      <span itemprop="name">wipe: Securely erase files from magnetic media</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>wipe [options] path1 path2 ... pathn</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CURRENT-VERSION</h2>
        <div class="sectioncontent">
<p>This manual page describes version <strong>0.22</strong> of <strong>wipe</strong> , released November 2010.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Recovery of supposedly erased data from magnetic media is easier than what many people would like to believe. A technique called Magnetic Force Microscopy (MFM) allows any moderately funded opponent to recover the last two or three layers of data written to disk; <strong>wipe</strong> repeatedly overwrites special patterns to the files to be destroyed, using the fsync() call and/or the O_SYNC bit to force disk access. In normal mode, 34 patterns are used (of which 8 are random). These patterns were recommended in an article from Peter Gutmann (pgut001@cs.auckland.ac.nz) entitled "Secure Deletion of Data from Magnetic and Solid-State Memory". A quick mode allows you to use only 4 passes with random patterns, which is of course much less secure.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTE ABOUT JOURNALING FILESYSTEMS AND SOME RECOMMENDATIONS (JUNE 2004)</h2>
        <div class="sectioncontent">
<p>Journaling filesystems (such as Ext3 or ReiserFS) are now being used by default by most Linux distributions.  No secure deletion program that does filesystem-level calls can sanitize files on such filesystems, because sensitive data and metadata can be written to the journal, which cannot be readily accessed.  Per-file secure deletion is better implemented in the operating system.</p><p>Encrypting a whole partition with cryptoloop, for example, does not help very much either, since there is a single key for all the partition.</p><p>Therefore <strong>wipe</strong> is best used to sanitize a harddisk before giving it to untrusted parties (i.e. sending your laptop for repair, or selling your disk).  Wiping size issues have been hopefully fixed (I apologize for the long delay).</p><p>Be aware that harddisks are quite intelligent beasts those days.  They transparently remap defective blocks.  This means that the disk can keep an albeit corrupted (maybe slightly) but inaccessible and unerasable copy of some of your data.  Modern disks are said to have about 100% transparent remapping capacity.  You can have a look at recent discussions on Slashdot.</p><p>I hereby speculate that harddisks can use the spare remapping area to secretly make copies of your data.  Rising totalitarianism makes this almost a certitude.  It is quite straightforward to implement some simple filtering schemes that would copy potentially interesting data.  Better, a harddisk can probably detect that a given file is being wiped, and silently make a copy of it, while wiping the original as instructed.</p><p>Recovering such data is probably easily done with secret IDE/SCSI commands. My guess is that there are agreements between harddisk manufacturers and government agencies.  Well-funded mafia hackers should then be able to find those secret commands too.</p><p>Don't trust your harddisk.  Encrypt all your data.</p><p>Of course this shifts the trust to the computing system, the CPU, and so on.  I guess there are also "traps" in the CPU and, in fact, in every sufficiently advanced mass-marketed chip.  Wealthy nations can find those. Therefore these are mainly used for criminal investigation and "control of public dissent".</p><p>People should better think of their computing devices as facilities lended by the DHS.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">IMPORTANT WARNING -- READ CAREFULLY</h2>
        <div class="sectioncontent">
<p>The author, the maintainers or the contributors of this package can NOT be held responsible in any way if <strong>wipe</strong> destroys something you didn't want it to destroy. Let's make this very clear. I want you to assume that this is a nasty program that will wipe out parts of your files that you didn't want it to wipe. So whatever happens after you launch <strong>wipe</strong> is your entire responsiblity.  In particular, no one guarantees that <strong>wipe</strong> will conform to the specifications given in this manual page.</p><p>Similarly, we cannot guarantee that <strong>wipe</strong> will actually erase data, or that wiped data is not recoverable by advanced means.  So if nasties get your secrets because you sold a wiped harddisk to someone you don't know, well, too bad for you.</p><p>The best way to sanitize a storage medium is to subject it to temperatures exceeding 1500K.  As a cheap alternative, you might use <strong>wipe</strong> at your own risk. Be aware that it is very difficult to assess whether running <strong>wipe</strong> on a given file will actually wipe it -- it depends on an awful lot of factors, such as : the type of file system the file resides on (in particular, whether the file system is a journaling one or not), the type of storage medium used, and the least significant bit of the phase of the moon.</p><p>Wiping over NFS or over a journalling filesystem (ReiserFS etc.) will most probably not work.</p><p>Therefore I strongly recommend to call <strong>wipe</strong> directly on the corresponding block device with the appropriate options. However <em>THIS IS AN EXTREMELY DANGEROUS THING TO DO.</em> Be sure to be sober. Give the right options. In particular : don't wipe a whole harddisk (eg. wipe -kD /dev/hda is bad) since this will destroy your master boot record. Bad idea. Prefer wiping partitions (eg. wipe -kD /dev/hda2) is good, provided, of course, that you have backed up all necessary data.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COMMAND-LINE OPTIONS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>-f (force; disable confirmation query)</strong></p>
  </dt>
  <dd>
    <p>By default <strong>wipe</strong> will ask for confirmation, indicating the number of regular and special files and directories specified on the command line. You must type "yes" for confirmation, "no" for rejection. You can disable the confirmation query with the <strong>-f</strong> (force) option.</p>
  </dd>
  <dt>
    <p><strong>-r (recurse into subdirectories)</strong></p>
  </dt>
  <dd>
    <p>Will allow the removal of the entire directory tree. Symbolic links are not followed.</p>
  </dd>
  <dt>
    <p><strong>-c (chmod if necessary)</strong></p>
  </dt>
  <dd>
    <p>If a file or directory to be wiped has no write permissions set, will do a chmod to set the permission.</p>
  </dd>
  <dt>
    <p><strong>-i (informational, verbose mode)</strong></p>
  </dt>
  <dd>
    <p>This enables reporting to stdout. By default all data is written to stderr.</p>
  </dd>
  <dt>
    <p><strong>-s (silent mode)</strong></p>
  </dt>
  <dd>
    <p>All messages, except the confirmation prompt and error messages, are suppressed.</p>
  </dd>
  <dt>
    <p><strong>-q (quick wipe)</strong></p>
  </dt>
  <dd>
    <p>If this option is used, <strong>wipe</strong> will only make (by default) 4 passes on each file, writing random data. See option <strong>-Q</strong></p>
  </dd>
  <dt>
    <p><strong>-Q &lt;number-of-passes&gt;</strong></p>
  </dt>
  <dd>
    <p>Sets the number of passes for quick wiping. Default is 4.</p>
  </dd>
  <dt>
    <p><strong>-a (abort on error)</strong></p>
  </dt>
  <dd>
    <p>The program will exit with EXIT_FAILURE if a non-fatal error is encountered.</p>
  </dd>
  <dt>
    <p><strong>-R (set random device OR random seed command)</strong></p>
  </dt>
  <dd>
    <p>With this option which requires an argument you can specify an alternate /dev/random device, or a command who's standard output will be hashed using MD5-hashed. The distinction can be made using the -S option.</p>
  </dd>
  <dt>
    <p><strong>-S (random seed method)</strong></p>
  </dt>
  <dd>
    <p>This option takes a single-character argument, which specifies how the random device/random seed argument is to be used. The default random device is /dev/random. It can be set using the -R option.</p>
  </dd>

</dl>
<p>The possible single-character arguments are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>r</strong></p>
  </dt>
  <dd>
    <p>If you want the argument to be treated like a regular file/character device. This will work with /dev/random, and might also work with FIFOs and the like.</p>
  </dd>
  <dt>
    <p><strong>c</strong></p>
  </dt>
  <dd>
    <p>If you want the argument to be executed as a command. The output from the command will be hashed using MD5 to provide the required seed. See the WIPE_SEEDPIPE environment variable for more info.</p>
  </dd>
  <dt>
    <p><strong>p</strong></p>
  </dt>
  <dd>
    <p>If you want wipe to get its seed by hashing environment variables, the current date and time, its process id. etc. (the random device argument will not be used). This is of course the least secure setting.</p>
  </dd>
  <dt>
    <p><strong>-M (select pseudo-random number generator algorythm)</strong></p>
  </dt>
  <dd>
    
  </dd>

</dl>
<p>During the random passes, <strong>wipe</strong> overwrites the target files with a stream of binary data, created by the following choice of algorythms:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>l</strong></p>
  </dt>
  <dd>
    <p>will use (depending on your system) your libc's random() or rand() pseudorandom generator. Note that on most systems, rand() is a linear congruential generator, which is awfully weak. The choice is made at compile-time with the HAVE_RANDOM define (see the Makefile).</p>
  </dd>
  <dt>
    <p><strong>a</strong></p>
  </dt>
  <dd>
    <p>will use the Arcfour stream cipher as a PRNG. Arcfour happens to be compatible with the well-known RC4 cipher. This means that under the same key, Arcfour generates exactly the same stream as RC4...</p>
  </dd>
  <dt>
    <p><strong>r</strong></p>
  </dt>
  <dd>
    <p>will use the fresh RC6 algorythm as a PRNG; RC6 is keyed with the 128-bit seed, and then a null block is repeatedly encrypted to get the pseudo-random stream. I guess this sould be quite secure. Of course RC6 with 20 rounds is slower than random(); the compile-time option WEAK_RC6 allows you to use a 4-round version of RC6, which is faster. In order to be able to use RC6, wipe must be compiled with ENABLE_RC6 defined; see the Makefile for warnings about patent issues.</p><p>In all cases the PRNG is seeded with the data gathered from the random device (see -R and -S options).</p>
  </dd>
  <dt>
    <p><strong>-l &lt;length&gt;</strong></p>
  </dt>
  <dd>
    <p>As there can be some problems in determining the actual size of a block device (as some devices do not even have fixed sizes, such as floppy disks or tapes), you might need to specify the size of the device by hand; &lt;length&gt; is the device capacity expressed as a number of bytes. You can use <strong>K</strong> (Kilo) to specify multiplication by 1024, <strong>M</strong> (Mega) to specify multiplication by 1048576, <strong>G</strong> (Giga) to specify multiplication by 1073741824 and <strong></strong> b (block) to specify multiplication by 512. Thus</p>
  </dd>
  <dt>
    
  </dt>
  <dd>
    <p>	1024 = 2b = 1K</p><p>	20K33 = 20480+33 = 20513</p><p>	114M32K = 114*1024*1024+32*1024.</p>
  </dd>
  <dt>
    <p><strong>-o &lt;offset&gt;</strong></p>
  </dt>
  <dd>
    <p>This allows you to specify an offset inside the file or device to be wiped. The syntax of &lt;offset&gt; is the same as for the <strong>-l</strong> option.</p>
  </dd>
  <dt>
    <p><strong>-e</strong></p>
  </dt>
  <dd>
    <p>Use exact file size: do not round up file size to wipe possible remaining junk on the last block.</p>
  </dd>
  <dt>
    <p><strong>-Z</strong></p>
  </dt>
  <dd>
    <p>Don't try to wipe file sizes by repeatedly halving the file size. Note that this is only attempted on regular files so there is no use if you use <strong>wipe</strong> for cleaning a block or special device.</p>
  </dd>
  <dt>
    <p><strong>-F</strong></p>
  </dt>
  <dd>
    <p>Don't try to wipe file names. Normally, <strong>wipe</strong> tries to cover file names by renaming them; this does NOT guarantee that the physical location holding the old file name gets overwritten.  Furthermore, after renaming a file, the only way to make sure that the name change is physically carried out is to call sync (), which flushes out ALL the disk caches of the system, whereas for ading and writing one can use the O_SYNC bit to get synchronous I/O for one file. As sync () is very slow, calling sync () after every rename () makes filename wiping extremely slow.</p>
  </dd>
  <dt>
    <p><strong>-k</strong></p>
  </dt>
  <dd>
    <p>Keep files: do not unlink the files after they have been overwritten. Useful if you want to wipe a device, while keeping the device special file. This implies <strong>-F.</strong></p>
  </dd>
  <dt>
    <p><strong>-D</strong></p>
  </dt>
  <dd>
    <p>Dereference symlinks: by default, wipe will never follow symlinks. If you specify -D however, wipe will consent to, well, wipe the targets of any symlinks you might happen to name on the command line.  You can't specify both -D and -r (recursive) options, first because of possible cycles in the symlink-enhanced directory graph, I'd have to keep track of visited files to guarantee termination, which, you'll easily admit, is a pain in C, and, second, for fear of having a (surprise!!) block device buried somewhere unexpected.</p>
  </dd>
  <dt>
    <p><strong>-v</strong></p>
  </dt>
  <dd>
    <p>Show version information and quit.</p>
  </dd>
  <dt>
    <p><strong>-h</strong></p>
  </dt>
  <dd>
    <p>Display help.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>wipe -rcf /home/berke/plaintext/</strong></p>
  </dt>
  <dd>
    <p>Wipe every file and every directory (option -r) listed under /home/berke/plaintext/, including /home/berke/plaintext/.</p><p>Regular files will be wiped with 34 passes and their sizes will then be halved a random number of times. Special files (character and block devices, FIFOs...) will not. All directory entries (files, special files and directories) will be renamed 10 times and then unlinked. Things with inappropriate permissions will be chmod()'ed (option -c).  All of this will happen without user confirmation (option -f).</p>
  </dd>
  <dt>
    <p><strong>wipe -kq /dev/hda3</strong></p>
  </dt>
  <dd>
    <p>Assuming /dev/hda3 is the block device corresponding to the third partition of the master drive on the primary IDE interface, it will be wiped in quick mode (option -q) i.e. with four random passes.  The inode won't be renamed or unlinked (option -k). Before starting, it will ask you to type ``yes''.</p>
  </dd>
  <dt>
    <p><strong>wipe -kqD /dev/floppy</strong></p>
  </dt>
  <dd>
    <p>Since <strong>wipe</strong> never follows symlinks unless explicitly told to do so, if you want to wipe /dev/floppy which happens to be a symlink to /dev/fd0u1440 you will have to specify the -D option. Before starting, it will ask you to type ``yes''.</p>
  </dd>
  <dt>
    <p><strong>wipe -rfi &gt;wipe.log /var/log/*</strong></p>
  </dt>
  <dd>
    <p>Here, wipe will recursively (option -r) destroy everything under /var/log, excepting /var/log. It will not attempt to chmod() things. It will however be verbose (option -i). It won't ask you to type ``yes'' because of the -f option.</p>
  </dd>
  <dt>
    <p><strong>wipe -Kq -l 1440k /dev/fd0</strong></p>
  </dt>
  <dd>
    <p>Due to various idiosyncracies of the operating system, it's not always easy to obtain the number of bytes a given device might contain (in fact, that quantity can be variable). This is why you sometimes need to tell <strong>wipe</strong> the amount of bytes to destroy. That's what the -l option is for. Plus, you can use b,K,M and G as multipliers, respectively for 2^9 (512), 2^10 (1024 or a Kilo), 2^20 (a Mega) and 2^30 (a Giga) bytes. You can even combine more than one multiplier !! So that 1M416K = 1474560 bytes.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS/LIMITATIONS</h2>
        <div class="sectioncontent">
<p><strong>Wipe</strong> should work on harddisks and floppy disks; however the internal cache of some harddisks might prevent the necessary writes to be done to the magnetic surface. It would be funny to use it over NFS. Under CFS (Cryptographic File System) the fsync() call has no effect; wipe has not much use under it anyway - use wipe directly on the corresponding encrypted files. Also, under Linux, when using a device mounted thru a loopback device, synchronous I/O does not get propagated cleanly.</p><p>For wiping floppy disks, at least under Linux, there is no way, besides obscure floppy-driver specific ioctl's to determine the block size of the disk. In particular, the BLKGETSIZE ioctl is not implemented in the floppy driver. So, for wiping floppies, you must specify the size of the floppy disk using the -l option, as in the last example. This option is normally not needed for other fixed block devices, like IDE and SCSI devices.</p><p>File name wiping is implemented since version 0.12. I don't know how efficient it is. It first changes the name of the file to a random- generated name of same length, calls sync (), then changes the name to a random-generated name of maximal length.</p><p>File size wiping is implemented by repeatedly truncating the file to half of its size, until it becomes empty; sync () is called between such operations.</p><p>Note that it is still not possible to file creation date and permission bits portably. A wipe utility working at the block device level could be written using the ext2fs library.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR AND LICENCE</h2>
        <div class="sectioncontent">
<p><strong>Wipe</strong> was written by Berke Durak (to find my email address, just type <strong>echo berke1ouvaton2org|tr 12 @.</strong> in a shell).</p><p><strong>Wipe</strong> is released under the conditions of the GNU General Public License.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILES</h2>
        <div class="sectioncontent">
<p><strong>/dev/random</strong> is used by default to seed the pseudo-random number generators.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ENVIRONMENT VARIABLES</h2>
        <div class="sectioncontent">
<p><strong>WIPE_SEEDPIPE</strong> If set, <strong>wipe</strong> will execute the command specified in it (using popen()), and will hash the command's output with the MD5 message-digest algorythm to get a 128-bit seed for its PRNG. For example, on systems lacking a /dev/random device, this variable might be set in /etc/profile to a shell script which contains various commands such as ls, ps, who, last, etc. and which are run asynchronously in order to get an output as less predictable as possible.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO wipe&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man2/open.2.html"><strong>open</strong>(2)</a>, <a href="../man2/fsync.2.html"><strong>fsync</strong>(2)</a>, <strong>sync</strong>(8), <a href="../man2/bdflush.2.html"><strong>bdflush</strong>(2)</a>, <strong>update</strong>(8), <a href="../man3/random.3.html"><strong>random</strong>(3)</a></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="winwrangler.1.html"><span aria-hidden="true">&larr;</span> winwrangler.1: Small desktop daemon to perform advanced window</a></li>
   <li class="next"><a href="wipe.tr-asc.1.html">wipe.tr-asc.1: None <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

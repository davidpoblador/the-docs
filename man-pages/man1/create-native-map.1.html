<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>create-native-map: C/c# mapping creator</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="C/c# mapping creator">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="create-native-map (1) manual">
  <meta name="twitter:description" content="C/c# mapping creator">
  <meta name="twitter:image" content="https://www.carta.tech/images/mono-tools-devel-create-native-map-1.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man1/create-native-map.1.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="create-native-map (1) manual" />
  <meta property="og:description" content="C/c# mapping creator" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/mono-tools-devel-create-native-map-1.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">create-native-map<small> (1)</small></h1>
        <p class="lead">C/c# mapping creator</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/">
      <span itemprop="name">Executable programs or shell commands</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/create-native-map.1.html">
      <span itemprop="name">create-native-map: C/c# mapping creator</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/mono-tools-devel/">
      <span itemprop="name">mono-tools-devel</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man1/create-native-map.1.html">
      <span itemprop="name">create-native-map: C/c# mapping creator</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>create-native-map</strong> [OPTIONS]* ASSEMBLY-FILE-NAME OUPUT-PREFIX</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><em>--autoconf-header=HEADER</em></p>
  </dt>
  <dd>
    <p><em>HEADER</em> is a header file name in the syntax typically used with the C <em>#include</em> statement, e.g. <em>#include &lt;stdio.h&gt;</em> or <em>#include  local.h </em> . An Autoconf-formatted macro is generated from the include name, and a <em>#include</em> directive is wrapped within a <em>#ifdef</em> block for the Autoconf macro within the generated <em>.c</em> file. For example, <em>--autoconf-header=&lt;stdio.h&gt;</em> would generate the code:</p>
<pre>
	#ifndef HAVE_STDIO_H
	#include &lt;stdio.h&gt;
	#endif /* ndef HAVE_STDIO_H */

</pre>

  </dd>
  <dt>
    <p><em>--autoconf-member=MEMBER</em></p>
  </dt>
  <dd>
    <p>Specify that any access to <em>MEMBER</em> should be wrapped within a <em>#ifdef HAVE_MEMBER</em> block. <em>MEMBER</em> can be either a <em>field-name</em> or a <em>class-name</em> . <em>field-name</em> combination. For example, given the C# declaration:</p>
<pre>
	[Mono.Unix.Native.Map ("struct dirent")]
	struct Dirent {
		public long d_off;
	}

</pre>
<p>then <em>--autoconf-member=d_off</em> would generate the code similar to:</p>
<pre>
	int
	ToDirent (struct dirent *from, struct Dirent *to)
	{
	#ifdef HAVE_STRUCT_DIRENT_D_OFF
		to-&gt;d_off = from-&gt;d_off;
	#endif /* ndef HAVE_STRUCT_DIRENT_D_OFF */
	}

</pre>

  </dd>
  <dt>
    <p><em>--exclude-native-symbol=SYMBOL</em></p>
  </dt>
  <dd>
    <p><em>SYMBOL</em> is a <em>[DllImport]</em> -marked method that should <em>not</em> have a prototype generated for it.</p>
  </dd>
  <dt>
    <p><em>--impl-header=HEADER</em></p>
  </dt>
  <dd>
    <p>Insert a <em>#include</em> statement within the generated <em>.c</em> file for <em>HEADER</em> . For example, <em>--impl-header=&lt;stdlib.h&gt;</em> generates</p>
<pre>
	#include &lt;stdlib.h&gt;

</pre>

  </dd>
  <dt>
    <p><em>--impl-macro=MACRO</em></p>
  </dt>
  <dd>
    <p>Insert a <em>#define</em> statement within the generated <em>.c</em> file. <em>MACRO</em> can contain a <em>=</em> to separate the macro name from the macro value. For example, <em>--impl-macro=FOO=42</em> generates</p>
<pre>
	#define FOO 42

</pre>

  </dd>
  <dt>
    <p><em>--library=LIBRARY</em></p>
  </dt>
  <dd>
    <p>Create prototypes for <em>[DllImport]</em> -marked methods which reference the native library <em>LIBRARY</em> into the generated <em>.h</em> file.</p>
  </dd>
  <dt>
    <p><em>--public-header=HEADER</em></p>
  </dt>
  <dd>
    <p>Insert a <em>#include</em> statement within the generated <em>.h</em> file for <em>HEADER</em> . For example, <em>--public-header=&lt;stdlib.h&gt;</em> generates</p>
<pre>
	#include &lt;stdlib.h&gt;

</pre>

  </dd>
  <dt>
    <p><em>--public-macro=MACRO</em></p>
  </dt>
  <dd>
    <p>Insert a <em>#define</em> statement within the generated <em>.h</em> file. <em>MACRO</em> can contain a <em>=</em> to separate the macro name from the macro value. For example, <em>--public-macro=FOO=42</em> generates</p>
<pre>
	#define FOO 42

</pre>

  </dd>
  <dt>
    <p><em>--rename-member=FROM=TO</em></p>
  </dt>
  <dd>
    <p>This is used when <em>FROM</em> is a C macro, and thus must be altered in order to be used sanely.  All generated references to the managed representation will use <em>TO</em> instead of <em>FROM</em> . For example, given the C# declaration:</p>
<pre>
	[Mono.Unix.Native.Map ("struct stat")]
	struct Stat {
		public long st_atime;
	}

</pre>
<p>and the argument <em>--rename-member=st_atime=st_atime_</em> , the generated <em>.h</em> file would contain:</p>
<pre>
	struct Stat {
		gint64 st_atime_;
	};

</pre>
<p>(note the altered field name), while the generated <em>.c</em> file would contain:</p>
<pre>
	ToStat (struct stat *from, struct Stat *to)
	{
		to-&gt;st_atime_ = from-&gt;st_atime;
	}

</pre>

  </dd>
  <dt>
    <p><em>--rename-namespace=FROM=TO</em></p>
  </dt>
  <dd>
    <p>By default, the C "namespace" (symbol prefix) is the C# namespace; types within the C# namespace <em>Mono.Unix.Native</em> would be in the C "namespace" <em>Mono_Unix_Native</em> . Use <em>--rename-namespace</em> to modify the default, e.g. <em>--rename-namespace=Mono.Unix.Native=Mono_Posix</em> .</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><em>create-native-map</em> is a program for a specific scenario: keeping code which is tightly coupled between C and C# in sync with each other, based upon the C# types.</p><p>Platform Invoke is only useful if the managed code knows the exact types and layout of all unmanaged structures it uses.  This is usually the case on Windows, but it is <em>not</em> the case on Unix.  For example, <em>struct stat</em> makes use of types with sizes that will vary from platform to platform (or even based on the compiler macros defined!).  For example, <em>off_t</em> is usually a signed 32-bit integer on ILP32 platforms, but may be a signed 64-bit integer on LP64 platforms, but may also be a 64-bit signed integer on ILP32 platforms if the <em>_FILE_OFFSET_BITS</em> macro has the value 64. In short, everything is flexible within Unix, and managed code can't deal with such flexibility.</p><p>Thus, the niche for <em>create-native-map</em> : assume a fixed ABI that managed code can target, and generate code to "thunk" the managed representations to the corresponding native representations. This needs to be done for <em>everything</em> that can vary between platforms and compiler flags, from enumeration values ( <em>SIGBUS</em> has the value 10 on FreeBSD but 7 on Linux) to structure members (how big is <em>off_t</em> ?).</p><p><em>create-native-map</em> will inspect <em>ASSEMBLY-FILE-NAME</em> and output the following files:</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>OUTPUT-PREFIX.h</em></p>
  </dt>
  <dd>
    <p>Contains enumeration values, class and structure declarations, delegate declarations, and <em>[DllImport]</em> -marked methods (from the library specified by <em>--library</em> ) within the assembly <em>ASSEMBLY-FILE-NAME</em> .</p>
  </dd>
  <dt>
    <p><em>OUTPUT-PREFIX.c</em></p>
  </dt>
  <dd>
    <p>Contains the implementation of enumeration and structure conversion functions.</p>
  </dd>
  <dt>
    <p><em>OUTPUT-PREFIX.cs</em></p>
  </dt>
  <dd>
    <p>Contains a partial class <em>NativeConvert</em> containing enumeration translation methods.</p>
  </dd>
  <dt>
    <p><em>OUTPUT-PREFIX.xml</em></p>
  </dt>
  <dd>
    <p>Generates ECMA XML documentation stubs for the enumeration translation methods in <em>OUTPUT-PREFIX.cs</em> .</p>
  </dd>

</dl>
<p><em>create-native-map</em> primarily looks for <em>MapAttribute</em> -decorated types, and makes use of two <em>MapAttribute</em> properties:</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>NativeType</em></p>
  </dt>
  <dd>
    <p>Contains the corresponding C type.  Only useful if applied to classes, structures, and fields.</p>
  </dd>
  <dt>
    <p><em>SuppressFlags</em></p>
  </dt>
  <dd>
    <p>When specified on an enumeration member of a <em>[Flags]</em> -decorated enumeration type, <em>disables</em> the normal code generator support for bit-masking enumeration types. This is useful when bitmask and non-bitmask information is stored within the same type, and bitmask checking shouldn't be used for the non-bitmask values. Example: <em>Mono.Unix.Native.FilePermissions.S_IFREG</em> , which is not a bitmask value, while most of <em>FilePermissions</em> consists of bitmask values ( <em>FilePermissions.S_IRUSR</em> , <em>FilePermissions.S_IWUSR</em> , etc.).</p>
  </dd>

</dl>
<p>The <em>MapAttribute</em> attribute can be specified on classes, structures, delegates, fields, and enumerations.</p>
<dl class='dl-vertical'>
  <dt>
    <p>Delegates</p>
  </dt>
  <dd>
    <p>Code generation for delegates ignores the <em>MapAttribute.NativeType</em> property, and generates a function pointer <em>typedef</em> that best matches the delegate declaration into the <em>.h</em> file. For example,</p>
<pre>
	namespace Foo {
		[Map]
		delegate string MyCallback (string s);
	}

</pre>
<p>generates the <em>typedef</em> :</p>
<pre>
	typedef char* (*Foo_MyCallback) (const char *s);

</pre>

  </dd>
  <dt>
    <p>Classes and Structures</p>
  </dt>
  <dd>
    <p>A <em>[Map]</em> -decorated class or structure will get a C structure declaration within the <em>.h</em> file:</p>
<pre>
	[Map]
	struct Foo {
		public int i;
	}

</pre>
<p>becomes</p>
<pre>
	struct Foo {
		public int i;
	};

</pre>
<p>If the <em>MapAttribute.NativeType</em> property is set, then conversion functions will be declared within the <em>.h</em> file and created within the <em>.c</em> file:</p>
<pre>
	namespace Foo {
		[Map ("struct stat")]
		struct Stat {
			public uint st_uid;
		}
	}

</pre>
<p>becomes</p>
<pre>
	/* The .h file */
	struct Foo_Stat {
		unsigned int st_uid;
	};
	int
	Foo_FromStat (struct Foo_Stat *from, struct stat *to);
	int
	Foo_ToStat (struct stat *to, sxtruct Foo_Stat *to);

	/* The .c file */
	int
	Foo_FromStat (struct Foo_Stat *from, struct stat *to)
	{
		memset (to, 0, sizeof(*to);
		to-&gt;st_uid = from-&gt;st_uid;
		return 0;
	}

	int
	Foo_ToStat (struct stat *to, sxtruct Foo_Stat *to)
	{
		memset (to, 0, sizeof(*to);
		to-&gt;st_uid = from-&gt;st_uid;
		return 0;
	}

</pre>

  </dd>
  <dt>
    <p>Fields</p>
  </dt>
  <dd>
    <p>If a field (1) has the <em>MapAttribute</em> attribute, and (2) has the <em>MapAttribute.NativeType</em> property set, then the specified native type will be used for overflow checking.  For example:</p>
<pre>
	namespace Foo {
		[Map ("struct stat")]
		struct Stat {
			[Map ("off_t")] public long st_size;
		}
	}

</pre>
<p>generates</p>
<pre>
	/* The .h file */
	struct Foo_Stat {
		gint64 st_size;
	};
	int
	Foo_FromStat (struct Foo_Stat *from, struct stat *to);
	int
	Foo_ToStat (struct stat *to, sxtruct Foo_Stat *to);

	/* The .c file */
	int
	Foo_FromStat (struct Foo_Stat *from, struct stat *to)
	{
		_cnm_return_val_if_overflow (off_t, from-&gt;st_size, -1);

		memset (to, 0, sizeof(*to);
		to-&gt;st_size = from-&gt;st_size;
		return 0;
	}

	int
	Foo_ToStat (struct stat *to, sxtruct Foo_Stat *to)
	{
		_cnm_return_val_if_overflow (gint64, from-&gt;st_size, -1);

		memset (to, 0, sizeof(*to);
		to-&gt;st_size = from-&gt;st_size;
		return 0;
	}

</pre>
<p>This is useful for better error checking within the conversion functions. <em>MapAttribute.NativeType</em> is required for this as there is no other way to know what the native type is (without parsing the system header files...).</p>
  </dd>
  <dt>
    <p>Enumerations</p>
  </dt>
  <dd>
    <p>Generates a C enumeration and macros for each of the members within the enumeration. <em>To</em> and <em>From</em> functions are also declared in the <em>.h</em> file and implemented in the <em>.c</em> file. For example,</p>
<pre>
	namespace Foo {
		[Map]
		enum Errno {
			EINVAL
		}
	}

</pre>
<p>would generate the following in the <em>.h</em> file:</p>
<pre>
	enum Foo_Errno {
		Foo_Errno_EINVAL          = 0,
		#define Foo_Errno_EINVAL    Foo_Errno_EINVAL
	};
	int Foo_FromErrno (int from, int *to);
	int Foo_ToErrno (int from, int *to);

</pre>
<p>and generates the following in the the <em>.c</em> file:</p>
<pre>
	int
	Foo_FromErrno (int from, int *to)
	{
		*to = 0;
		if (from == Foo_Errno_EPERM)
	#ifdef EINVAL
			{*to = EINVAL;}
	#else
			{errno = EINVAL; return -1;}
	#endif
		return 0;
	}

	int
	Foo_ToErrno (int from, int *to)
	{
		*to = 0;
	#ifdef EINVAL
		if (from == EINVAL)
			{*to = Foo_Errno_EPERM; return 0;}
	#endif
		return -1;
	}

</pre>
<p>Different code will be generated if the managed enum is a <em>[Flags]</em> -decorated enumeration (to account for bitwise flags), but this is the basic idea.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MAILING LISTS</h2>
        <div class="sectioncontent">
<p>Visit http://lists.ximian.com/mailman/listinfo/mono-devel-list for details.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">WEB SITE</h2>
        <div class="sectioncontent">
<p>Visit http://www.mono-project.com for details</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="create-microhope-env.1.html"><span aria-hidden="true">&larr;</span> create-microhope-env.1: Program to create a local copy of the development files and of the libraries of microhope for the end user.</a></li>
   <li class="next"><a href="createPYMB.1.html">createPYMB.1: Fcitx pinyin related tools <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

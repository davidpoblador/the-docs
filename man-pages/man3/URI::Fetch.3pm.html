<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>URI::Fetch: Smart uri fetching/caching</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Smart uri fetching/caching">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="URI::Fetch (3pm) manual">
  <meta name="twitter:description" content="Smart uri fetching/caching">
  <meta name="twitter:image" content="https://www.carta.tech/images/liburi-fetch-perl-URI::Fetch-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/URI::Fetch.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="URI::Fetch (3pm) manual" />
  <meta property="og:description" content="Smart uri fetching/caching" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/liburi-fetch-perl-URI::Fetch-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">URI::Fetch<small> (3pm)</small></h1>
        <p class="lead">Smart uri fetching/caching</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/URI::Fetch.3pm.html">
      <span itemprop="name">URI::Fetch: Smart uri fetching/caching</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/liburi-fetch-perl/">
      <span itemprop="name">liburi-fetch-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/URI::Fetch.3pm.html">
      <span itemprop="name">URI::Fetch: Smart uri fetching/caching</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
    use URI::Fetch;

    ## Simple fetch.
    my $res = URI::Fetch-&gt;fetch(&apos;http://example.com/atom.xml&apos;)
        or die URI::Fetch-&gt;errstr;

    ## Fetch using specified ETag and Last-Modified headers.
    $res = URI::Fetch-&gt;fetch(&apos;http://example.com/atom.xml&apos;,
            ETag =&gt; &apos;123-ABC&apos;,
            LastModified =&gt; time - 3600,
    )
        or die URI::Fetch-&gt;errstr;

    ## Fetch using an on-disk cache that URI::Fetch manages for you.
    my $cache = Cache::File-&gt;new( cache_root =&gt; &apos;/tmp/cache&apos; );
    $res = URI::Fetch-&gt;fetch(&apos;http://example.com/atom.xml&apos;,
            Cache =&gt; $cache
    )
        or die URI::Fetch-&gt;errstr;
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><em>URI::Fetch</em> is a smart client for fetching \s-1HTTP\s0 pages, notably syndication feeds (\s-1RSS\s0, Atom, and others), in an intelligent, bandwidth- and time-saving way. That means:</p><ul>
<li><p>\s-1GZIP\s0 support If you have <em>Compress::Zlib</em> installed, <em>URI::Fetch</em> will automatically try to download a compressed version of the content, saving bandwidth (and time).</p></li><li><p><em>Last-Modified</em> and <em>ETag</em> support If you use a local cache (see the <em>Cache</em> parameter to <em>fetch</em>), <em>URI::Fetch</em> will keep track of the <em>Last-Modified</em> and <em>ETag</em> headers from the server, allowing you to only download pages that have been modified since the last time you checked.</p></li><li><p>Proper understanding of \s-1HTTP\s0 error codes Certain \s-1HTTP\s0 error codes are special, particularly when fetching syndication feeds, and well-written clients should pay special attention to them. <em>URI::Fetch</em> can only do so much for you in this regard, but it gives you the tools to be a well-written client. The response from <em>fetch</em> gives you the raw \s-1HTTP\s0 response code, along with special handling of 4 codes:</p><ul>
<li><p>200 (\s-1OK\s0) Signals that the content of a page/feed was retrieved successfully.</p></li><li><p>301 (Moved Permanently) Signals that a page/feed has moved permanently, and that your database of feeds should be updated to reflect the new \s-1URI\s0.</p></li><li><p>304 (Not Modified) Signals that a page/feed has not changed since it was last fetched.</p></li><li><p>410 (Gone) Signals that a page/feed is gone and will never be coming back, so you should stop trying to fetch it.</p></li>
</ul></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">USAGE</h2>
        <div class="sectioncontent">
<p>Fetches a page identified by the \s-1URI\s0 <em></em><strong>$uri</strong><em></em>.</p><p>On success, returns a <em>URI::Fetch::Response</em> object; on failure, returns \*(C`undef\*(C'.</p><p><em></em><strong>%param</strong><em></em> can contain:</p><ul>
<li><p>LastModified</p></li><li><p>ETag <em>LastModified</em> and <em>ETag</em> can be supplied to force the server to only return the full page if it's changed since the last request. If you're writing your own feed client, this is recommended practice, because it limits both your bandwidth use and the server's. If you'd rather not have to store the <em>LastModified</em> time and <em>ETag</em> yourself, see the <em>Cache</em> parameter below (and the \s-1SYNOPSIS\s0 above).</p></li><li><p>Cache If you'd like <em>URI::Fetch</em> to cache responses between requests, provide the <em>Cache</em> parameter with an object supporting the Cache \s-1API\s0 (e.g. <em>Cache::File</em>, <em>Cache::Memory</em>). Specifically, an object that supports \*(C`$cache-&gt;get($key)\*(C' and \*(C`$cache-&gt;set($key, $value, $expires)\*(C'. If supplied, <em>URI::Fetch</em> will store the page content, ETag, and last-modified time of the response in the cache, and will pull the content from the cache on subsequent requests if the page returns a Not-Modified response.</p></li><li><p>UserAgent Optional.  You may provide your own LWP::UserAgent instance.  Look into LWPx::ParanoidUserAgent if you're fetching URLs given to you by possibly malicious parties.</p></li><li><p>NoNetwork Optional.  Controls the interaction between the cache and \s-1HTTP\s0 requests with If-Modified-Since/If-None-Match headers.  Possible behaviors are:</p>
<dl class='dl-vertical'>
  <dt>
    false (default)
  </dt>
  <dd>
    <p>If a page is in the cache, the origin \s-1HTTP\s0 server is always checked for a fresher copy with an If-Modified-Since and/or If-None-Match header. If set to 1, the origin \s-1HTTP\s0 is never contacted, regardless of the page being in cache or not.  If the page is missing from cache, the fetch method will return undef.  If the page is in cache, that page will be returned, no matter how old it is.  Note that setting this option means the URI::Fetch::Response object will never have the http_response member set. The origin \s-1HTTP\s0 server is not contacted <strong>if</strong> the page is in cache <strong>and</strong> the cached page was inserted in the last N seconds.  If the cached copy is older than N seconds, a normal \s-1HTTP\s0 request (full or cache check) is done.</p>
  </dd>

</dl>
</li><li><p>ContentAlterHook Optional.  A subref that gets called with a scalar reference to your content so you can modify the content before it's returned and before it's put in cache. For instance, you may want to only cache the &lt;head&gt; section of an \s-1HTML\s0 document, or you may want to take a feed \s-1URL\s0 and cache only a pre-parsed version of it.  If you modify the scalarref given to your hook and change it into a hashref, scalarref, or some blessed object, that same value will be returned to you later on not-modified responses.</p></li><li><p>CacheEntryGrep Optional.  A subref that gets called with the <em>URI::Fetch::Response</em> object about to be cached (with the contents already possibly transformed by your \*(C`ContentAlterHook\*(C').  If your subref returns true, the page goes into the cache.  If false, it doesn't.</p></li><li><p>Freeze</p></li><li><p>Thaw Optional. Subrefs that get called to serialize and deserialize, respectively, the data that will be cached. The cached data should be assumed to be an arbitrary Perl data structure, containing (potentially) references to arrays, hashes, etc. Freeze should serialize the structure into a scalar; Thaw should deserialize the scalar into a data structure. By default, <em>Storable</em> will be used for freezing and thawing the cached data structure.</p></li><li><p>ForceResponse Optional. A boolean that indicates a <em>URI::Fetch::Response</em> should be returned regardless of the \s-1HTTP\s0 status. By default \*(C`undef\*(C' is returned when a response is not a \*(L"success\*(R" (200 codes) or one of the recognized \s-1HTTP\s0 status codes listed above. The \s-1HTTP\s0 status message can then be retreived using the \*(C`errstr\*(C' method on the class.</p></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LICENSE</h2>
        <div class="sectioncontent">
<p><em>URI::Fetch</em> is free software; you may redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR & COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Except where otherwise noted, <em>URI::Fetch</em> is Copyright 2004 Benjamin Trott, ben+cpan@stupidfool.org. All rights reserved.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="URI::Encode.3pm.html"><span aria-hidden="true">&larr;</span> URI::Encode.3pm: Simple percent encoding/decoding</a></li>
   <li class="next"><a href="URI::Fetch::Response.3pm.html">URI::Fetch::Response.3pm: Feed response for uri::fetch <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

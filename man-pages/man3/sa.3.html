<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>sa: Socket abstraction</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Socket abstraction">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="sa (3) manual">
  <meta name="twitter:description" content="Socket abstraction">
  <meta name="twitter:image" content="https://www.carta.tech/images/libossp-sa-dev-sa-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/sa.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="sa (3) manual" />
  <meta property="og:description" content="Socket abstraction" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libossp-sa-dev-sa-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">sa<small> (3)</small></h1>
        <p class="lead">Socket abstraction</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/sa.3.html">
      <span itemprop="name">sa: Socket abstraction</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libossp-sa-dev/">
      <span itemprop="name">libossp-sa-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/sa.3.html">
      <span itemprop="name">sa: Socket abstraction</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">VERSION</h2>
        <div class="sectioncontent">
<p><strong>\s-1OSSP\s0 sa \s-11.2.5 (02-Oct-2005)\s0</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <strong>Abstract Data Types</strong>:
  </dt>
  <dd>
    <p>sa_rc_t, sa_addr_t, sa_t.</p>
  </dd>
  <dt>
    <strong>Address Object Operations</strong>:
  </dt>
  <dd>
    <p>sa_addr_create, sa_addr_destroy.</p>
  </dd>
  <dt>
    <strong>Address Operations</strong>:
  </dt>
  <dd>
    <p>sa_addr_u2a, sa_addr_s2a, sa_addr_a2u, sa_addr_a2s, sa_addr_match.</p>
  </dd>
  <dt>
    <strong>Socket Object Operations</strong>:
  </dt>
  <dd>
    <p>sa_create, sa_destroy.</p>
  </dd>
  <dt>
    <strong>Socket Parameter Operations</strong>:
  </dt>
  <dd>
    <p>sa_type, sa_timeout, sa_buffer, sa_option, sa_syscall.</p>
  </dd>
  <dt>
    <strong>Socket Connection Operations</strong>:
  </dt>
  <dd>
    <p>sa_bind, sa_connect, sa_listen, sa_accept, sa_getremote, sa_getlocal, sa_shutdown.</p>
  </dd>
  <dt>
    <strong>Socket Input/Output Operations (Stream Communication)</strong>:
  </dt>
  <dd>
    <p>sa_getfd, sa_read, sa_readln, sa_write, sa_writef, sa_flush.</p>
  </dd>
  <dt>
    <strong>Socket Input/Output Operations (Datagram Communication)</strong>:
  </dt>
  <dd>
    <p>sa_recv, sa_send, sa_sendf.</p>
  </dd>
  <dt>
    <strong>Socket Error Handling</strong>:
  </dt>
  <dd>
    <p>sa_error.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><strong>\s-1OSSP\s0 sa</strong> is an abstraction library for the Unix <em>Socket</em> networking application programming interface (\s-1API\s0), featuring stream and datagram oriented communication over <em>Unix Domain</em> and <em>Internet Domain</em> (\s-1TCP\s0 and \s-1UDP\s0) sockets.</p><p>It provides the following key features:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>Stand-Alone, Self-Contained, Embeddable</strong>
  </dt>
  <dd>
    <p>Although there are various Open Source libraries available which provide a similar abstraction approach, they all either lack important features or unfortunately depend on other companion libraries. <strong>\s-1OSSP\s0 sa</strong> fills this gap by providing all important features (see following points) as a stand-alone and fully self-contained library. This way <strong>\s-1OSSP\s0 sa</strong> can be trivially embedded as a sub-library into other libraries. It especially provides additional support for namespace-safe embedding of its \s-1API\s0 in order to avoid symbol conflicts (see \*(C`SA_PREFIX\*(C' in <em>sa.h</em>).</p>
  </dd>
  <dt>
    <strong>Address Abstraction</strong>
  </dt>
  <dd>
    <p>Most of the ugliness in the Unix <em>Socket</em> \s-1API\s0 is the necessity to have to deal with the various address structures (\*(C`struct sockaddr_xx\*(C') which exist because of both the different communication types and addressing schemes. <strong>\s-1OSSP\s0 sa</strong> fully hides this by providing an abstract and opaque address type (\*(C`sa_addr_t\*(C') together with utility functions which allow one to convert from the traditional \*(C`struct sockaddr\*(C' or \s-1URI\s0 specification to the \*(C`sa_addr_t\*(C' and vice versa without having to deal with special cases related to the underlying particular \*(C`struct sockaddr_xx\*(C'. <strong>\s-1OSSP\s0 sa</strong> support <em>Unix Domain</em> and both IPv4 and IPv6 <em>Internet Domain</em> addressing.</p>
  </dd>
  <dt>
    <strong>Type Abstraction</strong>
  </dt>
  <dd>
    <p>Some other subtle details in the Unix <em>Socket</em> \s-1API\s0 make the life hard in practice: \*(C`socklen_t\*(C' and \*(C`ssize_t\*(C'. These two types originally were (and on some platforms still are) plain integers or unsigned integers while \s-1POSIX\s0 later introduced own types for them (and even revised these types after some time again). This is nasty, because for 100% type-correct \s-1API\s0 usage (especially important on 64-bit machines where pointers to different integer types make trouble), every application has to check whether the newer types exists, and if not provide own definitions which map to the still actually used integer type on the underlying platform. <strong>\s-1OSSP\s0 sa</strong> hides most of this in its \s-1API\s0 and for \*(C`socklen_t\*(C' provides a backward-compatibility definition. Instead of \*(C`ssize_t\*(C' it can use \*(C`size_t\*(C' because <strong>\s-1OSSP\s0 sa</strong> does not use traditional Unix return code semantics.</p>
  </dd>
  <dt>
    <strong>I/O Timeouts</strong>
  </dt>
  <dd>
    <p>Each I/O function in <strong>\s-1OSSP\s0 sa</strong> is aware of timeouts (set by <em>sa_timeout</em>\|(3)), i.e., all I/O operations return \*(C`SA_ERR_TMT\*(C' if the timeout expired before the I/O operation was able to succeed. This allows one to easily program less-blocking network services. <strong>\s-1OSSP\s0 sa</strong> internally implements these timeouts either through the \*(C`SO_\*(C'{\*(C`SND\*(C',\*(C`RCV\*(C'}\*(C`TIMEO\*(C' feature on more modern <em>Socket</em> implementations or through traditional <em>select</em>\|(2). This way high performance is achieved on modern platforms while the full functionality still is available on older platforms.</p>
  </dd>
  <dt>
    <strong>I/O Stream Buffering</strong>
  </dt>
  <dd>
    <p>If <strong>\s-1OSSP\s0 sa</strong> is used for stream communication, internally all I/O operations can be performed through input and/or output buffers (set by <em>sa_buffer</em>\|(3)) for achieving higher I/O performance by doing I/O operations on larger aggregated messages and with less required system calls. Additionally if <strong>\s-1OSSP\s0 sa</strong> is used for stream communication, for convenience reasons line-oriented reading (<em>sa_readln</em>\|(3)) and formatted writing (see <em>sa_writef</em>\|(3)) is provided, modelled after \s-1STDIO\s0's <em>fgets</em>\|(3) and <em>fprintf</em>\|(3). Both features fully leverage from the I/O buffering.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DATA TYPES</h2>
        <div class="sectioncontent">
<p><strong>\s-1OSSP\s0 sa</strong> uses three data types in its \s-1API:\s0</p>
<dl class='dl-vertical'>
  <dt>
    <strong>sa_rc_t</strong> (Return Code Type)
  </dt>
  <dd>
    <p>This is an exported enumerated integer type with the following possible values:</p>
<pre>
 SA_OK       Everything Ok
 SA_ERR_ARG  Invalid Argument
 SA_ERR_USE  Invalid Use Or Context
 SA_ERR_MEM  Not Enough Memory
 SA_ERR_MTC  Matching Failed
 SA_ERR_EOF  End Of Communication
 SA_ERR_TMT  Communication Timeout
 SA_ERR_SYS  Operating System Error (see errno)
 SA_ERR_IMP  Implementation Not Available
 SA_ERR_INT  Internal Error
</pre>

  </dd>
  <dt>
    <strong>sa_addr_t</strong> (Socket Address Abstraction Type)
  </dt>
  <dd>
    <p>This is an opaque data type representing a socket address. Only pointers to this abstract data type are used in the \s-1API\s0.</p>
  </dd>
  <dt>
    <strong>sa_t</strong> (Socket Abstraction Type)
  </dt>
  <dd>
    <p>This is an opaque data type representing a socket. Only pointers to this abstract data type are used in the \s-1API\s0.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FUNCTIONS</h2>
        <div class="sectioncontent">
<p><strong>\s-1OSSP\s0 sa</strong> provides a bunch of \s-1API\s0 functions, all modelled after the same prototype:</p><p>\*(C`sa_rc_t\*(C' <strong>sa_</strong><em>name</em>\*(C`(sa_\*(C'[\*(C`addr_\*(C']\*(C`_t *,\*(C' ...\*(C`)\*(C'</p><p>This means, every function returns \*(C`sa_rc_t\*(C' to indicate its success (\*(C`SA_OK\*(C') or failure (\*(C`SA_ERR_\*(C'<em>\s-1XXX\s0</em>) by returning a return code (the corresponding describing text can be determined by passing this return code to <em>sa_error</em>\|(3)). Each function name starts with the common prefix \*(C`sa_\*(C' and receives a \*(C`sa_t\*(C' (or \*(C`sa_addr_t\*(C') object handle on which it operates as its first argument.</p><p><strong>&#92;$1</strong></p><p>This \s-1API\s0 part provides operations for the creation and destruction of address abstraction \*(C`sa_addr_t\*(C'. Create a socket address abstraction object. The object is stored in <em>saa</em> on success. Example: \*(C`sa_addr_t *saa; sa_addr_create(&saa);\*(C' Destroy a socket address abstraction object. The object <em>saa</em> is invalid after this call succeeded. Example: \*(C`sa_addr_destroy(saa);\*(C' This \s-1API\s0 part provides operations for working with the address abstraction \*(C`sa_addr_t\*(C'. Import an address into by converting from an \s-1URI\s0 specification to the corresponding address abstraction. The supported syntax for <em>uri</em> is: "\*(C`unix:\*(C'<em>path</em>" for <em>Unix Domain</em> addresses and "\*(C`inet://\*(C'<em>addr</em>\*(C`:\*(C'<em>port</em>[\*(C`#\*(C'<em>protocol</em>]" for <em>Internet Domain</em> addresses. In the \s-1URI\s0, <em>path</em> can be an absolute or relative filesystem path to an existing or not-existing file. <em>addr</em> can be an IPv4 address in dotted decimal notation ("127.0.0.1\*(L"), an IPv6 address in colon-separated (optionally abbreviated) hexadecimal notation (\*(R"\*(C`::1\*(C'\*(L") or a to-be-resolved hostname (\*(R"\*(C`localhost.example.com\*(C'"). <em>port</em> has to be either a decimal port in the range 1...65535 or a port name ("\*(C`smtp\*(C'"). If <em>port</em> is specified as a name, it is resolved as a \s-1TCP\s0 port by default. To force resolving a <em>port</em> name via a particular protocol, <em>protocol</em> can be specified as either "\*(C`tcp\*(C'\*(L" or \*(R"\*(C`udp\*(C'". The result is stored in <em>saa</em> on success. Example: \*(C`sa_addr_u2a(saa, "inet://192.168.0.1:smtp");\*(C' Import an address by converting from a traditional \*(C`struct sockaddr\*(C' object to the corresponding address abstraction. The accepted addresses for <em>sabuf</em> are: \*(C`struct sockaddr_un\*(C' (\*(C`AF_LOCAL\*(C'), \*(C`struct sockaddr_in\*(C' (\*(C`AF_INET\*(C') and \*(C`struct sockaddr_in6\*(C' (\*(C`AF_INET6\*(C'). The <em>salen</em> is the corresponding \*(C`sizeof(...)\*(C' of the particular underyling structure. The result is stored in <em>saa</em> on success. Example: \*(C`sockaddr_in in; sa_addr_s2a(saa, (struct sockaddr *)&in, (socklen_t)sizeof(in));\*(C' Export an address by converting from the address abstraction to the corresponding \s-1URI\s0 specification. The result is a string of the form "\*(C`unix:\*(C'<em>path</em>" for <em>Unix</em> Domain addresses and "\*(C`inet://\*(C'<em>addr</em>\*(C`:\*(C'<em>port</em>" for <em>Internet</em> Domain addresses. Notice that <em>addr</em> and <em>port</em> are returned in numerical (unresolved) way. Additionally, because usually one cannot map bidirectionally between \s-1TCP\s0 or \s-1UDP\s0 port names and the numerical value, there is no distinction between \s-1TCP\s0 and \s-1UDP\s0 here. The result is stored in <em>uri</em> on success. The caller has to <em>free</em>\|(3) the <em>uri</em> buffer later. Example: \*(C`char *uri; sa_addr_a2u(saa, &uri);\*(C' Export an address by converting from the address abstraction to the corresponding traditional \*(C`struct sockaddr\*(C' object. The result is one of the following particular underlying address structures: \*(C`struct sockaddr_un\*(C' (\*(C`AF_LOCAL\*(C'), \*(C`struct sockaddr_in\*(C' (\*(C`AF_INET\*(C') and \*(C`struct sockaddr_in6\*(C' (\*(C`AF_INET6\*(C'). The result is stored in <em>sabuf</em> and <em>salen</em> on success. The caller has to <em>free</em>\|(3) the <em>sabuf</em> buffer later. Example: \*(C`struct sockaddr sabuf, socklen_t salen; sa_addr_a2s(saa, &sa, &salen);\*(C' Match two address abstractions up to a specified prefix. This compares the addresses <em>saa1</em> and <em>saa2</em> by only taking the prefix part of length <em>prefixlen</em> into account. <em>prefixlen</em> is number of filesystem path characters for <em>Unix Domain</em> addresses and number of bits for <em>Internet Domain</em> addresses. In case of <em>Internet Domain</em> addresses, the addresses are matched in network byte order and the port (counting as an additional bit/item of length 1) is virtually appended to the address for matching. Specifying <em>prefixlen</em> as \*(C`-1\*(C' means matching the whole address (but without the virtually appended port) without having to know how long the underlying address representation (length of path for Unix Domain addresses, 32+1 [IPv4] or 128+1 [IPv6] for Internet Domain addresses) is. Specifying <em>prefixlen</em> as \*(C`-2\*(C' is equal to \*(C`-1\*(C' but additionally the port is matched, too. This especially can be used to implement Access Control Lists (\s-1ACL\s0) without having to fiddle around with the underlying representation. For this, make <em>saa1</em> the to be checked address and <em>saa2</em> plus <em>prefixlen</em> the \s-1ACL\s0 pattern as shown in the following example. Example:  sa_addr_t *srv_sa;  sa_addr_t *clt_saa;  sa_t      *clt_sa;  sa_addr_t *acl_saa;  char      *acl_addr = "192.168.0.0";  int        acl_len  = 24;  ...  sa_addr_u2a(&acl_saa, "inet://%s:0", acl_addr);  ...  while (sa_accept(srv_sa, &clt_saa, &clt_sa) == SA_OK) {      if (sa_addr_match(clt_saa, acl_saa, acl_len) != SA_OK) {          /* connection refused */          ...          sa_addr_destroy(clt_saa);          sa_destroy(clt_sa);          continue;      }      ...  }  ... This \s-1API\s0 part provides operations for the creation and destruction of socket abstraction \*(C`sa_t\*(C'. Create a socket abstraction object. The object is stored in <em>sa</em> on success. Example: \*(C`sa_t *sa; sa_create(&sa);\*(C' Destroy a socket abstraction object. The object <em>sa</em> is invalid after this call succeeded. Example: \*(C`sa_destroy(sa);\*(C' This \s-1API\s0 part provides operations for parameterizing the socket abstraction \*(C`sa_t\*(C'. Assign a particular communication protocol type to the socket abstraction object. A socket can only be assigned a single protocol type at any time. Nevertheless one can switch the type of a socket abstraction object at any time in order to reuse it for a different communication. Just keep in mind that switching the type will stop a still ongoing communication by closing the underlying socket. Possible values for <em>type</em> are \*(C`SA_TYPE_STREAM\*(C' (stream communication) and \*(C`SA_TYPE_DATAGRAM\*(C' (datagram communication). The default communication protocol type is \*(C`SA_TYPE_STREAM\*(C'. Example: \*(C`sa_type(sa, SA_TYPE_STREAM);\*(C' Assign one or more communication timeouts to the socket abstraction object. Possible values for <em>id</em> are: \*(C`SA_TIMEOUT_ACCEPT\*(C' (affecting <em>sa_accept</em>\|(3)), \*(C`SA_TIMEOUT_CONNECT\*(C' (affecting <em>sa_connect</em>\|(3)), \*(C`SA_TIMEOUT_READ\*(C' (affecting <em>sa_read</em>\|(3), <em>sa_readln</em>\|(3) and <em>sa_recv</em>\|(3)) and \*(C`SA_TIMEOUT_WRITE\*(C' (affecting <em>sa_write</em>\|(3), <em>sa_writef</em>\|(3), <em>sa_send</em>\|(3), and <em>sa_sendf</em>\|(3)). Additionally you can set all four timeouts at once by using \*(C`SA_TIMEOUT_ALL\*(C'. The default is that no communication timeouts are used which is equal to <em>sec</em>=0/<em>usec</em>=0. Example: \*(C`sa_timeout(sa, SA_TIMEOUT_ALL, 30, 0);\*(C' Assign I/O communication buffers to the socket abstraction object. Possible values for <em>id</em> are: \*(C`SA_BUFFER_READ\*(C' (affecting <em>sa_read</em>\|(3) and <em>sa_readln</em>\|(3)) and \*(C`SA_BUFFER_WRITE\*(C' (affecting <em>sa_write</em>\|(3) and <em>sa_writef</em>\|(3)). The default is that no communication buffers are used which is equal to <em>size</em>=0. Example: \*(C`sa_buffer(sa, SA_BUFFER_READ, 16384);\*(C' Adjust various options of the socket abstraction object. The adjusted option is controlled by <em>id</em>. The number and type of the expected following argument(s) are dependent on the particular option. Currently the following options are implemented (option arguments in parenthesis): \*(C`SA_OPTION_NAGLE\*(C' (\*(C`int\*(C' <em>yesno</em>) for enabling (<em>yesno</em>=1) or disabling (<em>yesno</em> == 0) Nagle's Algorithm (see \s-1RFC898\s0 and \*(C`TCP_NODELAY\*(C' of <em>setsockopt</em>\|(2)). \*(C`SA_OPTION_LINGER\*(C' (\*(C`int\*(C' <em>amount</em>) for enabling (<em>amount</em> == <em>seconds</em> != 0) or disabling (<em>amount</em> == 0) lingering on close (see \*(C`SO_LINGER\*(C' of <em>setsockopt</em>\|(2)). Notice: using <em>seconds</em> &gt; 0 results in a regular (maximum of <em>seconds</em> lasting) lingering on close while using <em>seconds</em> &lt; 0 results in the special case of a \s-1TCP\s0 \s-1RST\s0 based connection termination on close. \*(C`SA_OPTION_REUSEADDR\*(C' (\*(C`int\*(C' <em>yesno</em>) for enabling (<em>yesno</em> == 1) or disabling (<em>yesno</em> == 0) the reusability of the address on binding via <em>sa_bind</em>\|(3) (see \*(C`SO_REUSEADDR\*(C' of <em>setsockopt</em>\|(2)). \*(C`SA_OPTION_REUSEPORT\*(C' (\*(C`int\*(C' <em>yesno</em>) for enabling (<em>yesno</em> == 1) or disabling (<em>yesno</em> == 0) the reusability of the port on binding via <em>sa_bind</em>\|(3) (see \*(C`SO_REUSEPORT\*(C' of <em>setsockopt</em>\|(2)). \*(C`SA_OPTION_NONBLOCK\*(C' (\*(C`int\*(C' <em>yesno</em>) for enabling (<em>yesno</em> == 1) or disabling (<em>yesno</em> == 0) non-blocking I/O mode (see \*(C`O_NONBLOCK\*(C' of <em>fcntl</em>\|(2)). Example: \*(C`sa_option(sa, SA_OPTION_NONBLOCK, 1);\*(C' Divert I/O communication related system calls to user supplied callback functions. This allows you to override mostly all I/O related system calls <strong>\s-1OSSP\s0</strong> sa internally performs while communicating. This can be used to adapt <strong>\s-1OSSP\s0 sa</strong> to different run-time environments and requirements without having to change the source code. Usually this is used to divert the system calls to the variants of a user-land multithreading facility like <strong>\s-1GNU\s0 Pth</strong>. The function supplied as <em>fptr</em> is required to fulfill the \s-1API\s0 of the replaced system call, i.e., it has to have the same prototype (if <em>fctx</em> is \*(C`NULL\*(C'). If <em>fctx</em> is not \*(C`NULL\*(C', this prototype has to be extended to accept an additional first argument of type \*(C`void *\*(C' which receives the value of <em>fctx</em>. It is up to the callback function whether to pass the call through to the replaced actual system call or not. Possible values for <em>id</em> are (expected prototypes behind <em>fptr</em> are given in parenthesis): <strong>\s-1SA_SYSCALL_CONNECT\s0</strong>: "\*(C`int (*)([void *,] int, const struct sockaddr *, socklen_t)\*(C'", see <em>connect</em>\|(2). <strong>\s-1SA_SYSCALL_ACCEPT\s0</strong>: "\*(C`int (*)([void *,] int, struct sockaddr *, socklen_t *)\*(C'", see <em>accept</em>\|(2). <strong>\s-1SA_SYSCALL_SELECT\s0</strong>: "\*(C`int (*)([void *,] int, fd_set *, fd_set *, fd_set *, struct timeval *)\*(C'", see <em>select</em>\|(2). <strong>\s-1SA_SYSCALL_READ\s0</strong>: "\*(C`ssize_t (*)([void *,] int, void *, size_t)\*(C'", see <em>read</em>\|(2). <strong>\s-1SA_SYSCALL_WRITE\s0</strong>: "\*(C`ssize_t (*)([void *,] int, const void *, size_t)\*(C'", see <em>write</em>\|(2). <strong>\s-1SA_SYSCALL_RECVFROM\s0</strong>: "\*(C`ssize_t (*)([void *,] int, void *, size_t, int, struct sockaddr *, socklen_t *)\*(C'", see <em>recvfrom</em>\|(2). <strong>\s-1SA_SYSCALL_SENDTO\s0</strong>: "\*(C`ssize_t (*)([void *,] int, const void *, size_t, int, const struct sockaddr *, socklen_t)\*(C'", see <em>sendto</em>\|(2). Example:  ssize_t  trace_read(void *ctx, int fd, void *buf, size_t len)  {      FILE *fp = (FILE *)ctx;      ssize_t rv;      int errno_saved;      rv = read(fd, buf, len);      errno_saved = errno;      fprintf(fp, "read(%d, %lx, %d) = %d&#92;n",              fd, (long)buf, len, rv);      errno = errno_saved;      return rv;  }  ...  FILE *trace_fp = ...;  sa_syscall(sa, SA_SC_READ, trace_read, trace_fp);  ... This \s-1API\s0 part provides connection operations for stream-oriented data communication through the socket abstraction \*(C`sa_t\*(C'. Bind socket abstraction object to a local protocol address. This assigns the local protocol address <em>laddr</em>. When a socket is created, it exists in an address family space but has no protocol address assigned. This call requests that <em>laddr</em> be used as the local address. For servers this is the address they later listen on (see <em>sa_listen</em>\|(3)) for incoming connections, for clients this is the address used for outgoing connections (see <em>sa_connect</em>\|(3)). Internally this directly maps to <em>bind</em>\|(2). Example: \*(C`sa_bind(sa, laddr);\*(C' Initiate an outgoing connection on a socket abstraction object. This performs a connect to the remote address <em>raddr</em>. If the socket is of type \*(C`SA_TYPE_DATAGRAM\*(C', this call specifies the peer with which the socket is to be associated; this address is that to which datagrams are to be sent, and the only address from which datagrams are to be received. If the socket is of type \*(C`SA_TYPE_STREAM\*(C', this call attempts to make a connection to the remote socket. Internally this directly maps to <em>connect</em>\|(2). Example: \*(C`sa_connect(sa, raddr);\*(C' Listen for incoming connections on a socket abstraction object. A willingness to accept incoming connections and a queue limit for incoming connections are specified by this call. The <em>backlog</em> argument defines the maximum length the queue of pending connections may grow to. Internally this directly maps to <em>listen</em>\|(2). Example: \*(C`sa_listen(sa, 128);\*(C' Accept incoming connection on a socket abstraction object. This accepts an incoming connection by extracting the first connection request on the queue of pending connections. It creates a new socket abstraction object (returned in <em>csa</em>) and a new socket address abstraction object (returned in <em>caddr</em>) describing the connection. The caller has to destroy these objects later. If no pending connections are present on the queue, it blocks the caller until a connection is present. Example:  sa_addr_t *clt_saa;  sa_t      *clt_sa;  ...  while (sa_accept(srv_sa, &clt_saa, &clt_sa) == SA_OK) {      ...  } Get address abstraction of remote side of communication. This determines the address of the communication peer and creates a new socket address abstraction object (returned in <em>raddr</em>) describing the peer address. The application has to destroy <em>raddr</em> later with <em>sa_addr_destroy</em>\|(3). Internally this maps to <em>getpeername</em>\|(2). Example: \*(C`sa_addr_t *raddr; sa_getremote(sa, &raddr);\*(C' Get address abstraction of local side of communication. This determines the address of the local communication side and creates a new socket address abstraction object (returned in <em>laddr</em>) describing the local address. The application has to destroy <em>laddr</em> later with <em>sa_addr_destroy</em>\|(3). Internally this maps to <em>getsockname</em>\|(2). Example: \*(C`sa_addr_t *laddr; sa_getlocal(sa, &laddr);\*(C' Shut down part of the full-duplex connection. This performs a shut down of the connection described in <em>sa</em>. The flags string can be either "\*(C`r\*(C'\*(L" (indicating the read channel of the communication is shut down only), \*(R"\*(C`w\*(C'\*(L" (indicating the write channel of the communication is shut down only), or \*(R"\*(C`rw\*(C'" (indicating both the read and write channels of the communication are shut down). Internally this directly maps to <em>shutdown</em>\|(2). Example: \*(C`sa_shutdown(sa, "w");\*(C' This \s-1API\s0 part provides I/O operations for stream-oriented data communication through the socket abstraction \*(C`sa_t\*(C'. Get underlying socket filedescriptor. This peeks into the underlying socket filedescriptor <strong>\s-1OSSP\s0 sa</strong> allocated internally for the communication. This can be used for adjusting the socket communication (via <em>fcntl</em>\|(2), <em>setsockopt</em>\|(2), etc) directly. Think twice before using this, then think once more. After all that, think again. With enough thought, the need for directly manipulating the underlying socket can often be eliminated. At least remember that all your direct socket operations fully by-pass <strong>\s-1OSSP\s0 sa</strong> and this way can leads to nasty side-effects. Example: \*(C`int fd; sa_getfd(sa, &fd);\*(C' Read a chunk of data from socket into own buffer. This reads from the socket (optionally through the internal read buffer) up to a maximum of <em>buflen</em> bytes into buffer <em>buf</em>. The actual number of read bytes is stored in <em>bufdone</em>. This internally maps to <em>read</em>\|(2). Example: \*(C`char buf[1024]; size_t n; sa_read(sa, buf, sizeof(buf), &n);\*(C' Read a line of data from socket into own buffer. This reads from the socket (optionally through the internal read buffer) up to a maximum of <em>buflen</em> bytes into buffer <em>buf</em>, but only as long as no line terminating newline character (0x0a) was found. The line terminating newline character is stored in the buffer plus a (not counted) terminating \*(C`NUL\*(C' character ('\*(C`&#92;0\*(C''), too. The actual number of read bytes is stored in <em>bufdone</em>. This internally maps to <em>sa_read</em>\|(3). Keep in mind that for efficiency reasons, line-oriented I/O usually always should be performed with read buffer (see <em>sa_option</em>\|(3) and \*(C`SA_BUFFER_READ\*(C'). Without such a read buffer, the performance is cruel, because single character <em>read</em>\|(2) operations would be performed on the underlying socket. Example: \*(C`char buf[1024]; size_t n; sa_readln(sa, buf, sizeof(buf), &n);\*(C' Write a chunk of data to socket from own buffer. This writes to the socket (optionally through the internal write buffer) <em>buflen</em> bytes from buffer <em>buf</em>. In case of a partial write, the actual number of written bytes is stored in <em>bufdone</em>. This internally maps to <em>write</em>\|(2). Example: \*(C`sa_write(sa, cp, strlen(cp), NULL);\*(C' Write formatted data data to socket. This formats a string according to the <em>printf</em>\|(3)-style format specification <em>fmt</em> and sends the result to the socket (optionally through the internal write buffer). In case of a partial socket write, the not written data of the formatted string is internally discarded. Hence using a write buffer is strongly recommended here (see <em>sa_option</em>\|(3) and \*(C`SA_BUFFER_WRITE\*(C'). This internally maps to <em>sa_write</em>\|(3). The underlying string formatting engine is just a minimal one and for security and independence reasons intentionally not directly based on s[n]<em>printf</em>\|(3). It understands only the following format specifications: "\*(C`%%\*(C'\*(L", \*(R"%c" (\*(C`char\*(C'), "%s" (\*(C`char *\*(C') and "%d" (\*(C`int\*(C') without any precision and padding possibilities. It is intended for minimal formatting only. If you need more sophisticated formatting, you have to format first into an own buffer via s[n]<em>printf</em>\|(3) and then write this to the socket via <em>sa_write</em>\|(3) instead. Example: \*(C`sa_writef(sa, "%s=%d&#92;n", cp, i);\*(C' Flush still pending outgoing data to socket. This writes all still pending outgoing data for the internal write buffer (see <em>sa_option</em>\|(3) and \*(C`SA_BUFFER_WRITE\*(C') to the socket. This internally maps to <em>write</em>\|(2). Example: \*(C`sa_flush(sa);\*(C' This \s-1API\s0 part provides I/O operations for datagram-oriented data communication through the socket abstraction \*(C`sa_t\*(C'. Receive a chunk of data from remote address via socket into own buffer. This receives from the remote address specified in <em>raddr</em> via the socket up to a maximum of <em>buflen</em> bytes into buffer <em>buf</em>. The actual number of received bytes is stored in <em>bufdone</em>. This internally maps to <em>recvfrom</em>\|(2). Example: \*(C`char buf[1024]; size_t n; sa_recv(sa, buf, sizeof(buf), &n, saa);\*(C' Send a chunk of data to remote address via socket from own buffer. This sends to the remote address specified in <em>raddr</em> via the socket <em>buflen</em> bytes from buffer <em>buf</em>. The actual number of sent bytes is stored in <em>bufdone</em>. This internally maps to <em>sendto</em>\|(2). Example: \*(C`sa_send(sa, buf, strlen(buf), NULL, saa);\*(C' Send formatted data data to remote address via socket. This formats a string according to the <em>printf</em>\|(3)-style format specification <em>fmt</em> and sends the result to the socket as a single piece of data chunk. In case of a partial socket write, the not written data of the formatted string is internally discarded. The underlying string formatting engine is just a minimal one and for security and independence reasons intentionally not directly based on s[n]<em>printf</em>\|(3). It understands only the following format specifications: "\*(C`%%\*(C'\*(L", \*(R"%c" (\*(C`char\*(C'), "%s" (\*(C`char *\*(C') and "%d" (\*(C`int\*(C') without any precision and padding possibilities. It is intended for minimal formatting only. If you need more sophisticated formatting, you have to format first into an own buffer via s[n]<em>printf</em>\|(3) and then send this to the remote address via <em>sa_send</em>\|(3) instead. Example: \*(C`sa_sendf(sa, saa, "%s=%d&#92;n", cp, i);\*(C' This \s-1API\s0 part provides error handling operations only. Return the string representation corresponding to the return code value <em>rv</em>. The returned string has to be treated read-only by the application and is not required to be deallocated.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO sa&hellip;</h2>
        <div class="sectioncontent">
<p>R. Gilligan, S. Thomson, J. Bound, W. Stevens: <em>\*(L"Basic Socket Interface Extensions for IPv6\*(R"</em>, <strong>\s-1RFC\s0 2553</strong>, March 1999.</p><p>W. Stevens: <em>\*(L"Advanced Sockets \s-1API\s0 for IPv6\*(R"</em>, <strong>\s-1RFC\s0 2292</strong>, February 1998.</p><p>R. Fielding, L. Masinter, T. Berners-Lee: <em>\*(L"Uniform Resource Identifiers: Generic Syntax\*(R"</em>, <strong>\s-1RFC\s0 2396</strong>, August 1998.</p><p>R. Hinden, S. Deering: <em>\*(L"\s-1IP\s0 Version 6 Addressing Architecture\*(R"</em>, <strong>\s-1RFC\s0 2373</strong>, July 1998.</p><p>R. Hinden, B. Carpenter, L. Masinter: <em>\*(L"Format for Literal IPv6 Addresses in \s-1URL\s0's\*(R"</em>, <strong>\s-1RFC\s0 2732</strong>, December 1999. Stuart Sechrest: <em>\*(L"An Introductory 4.4BSD Interprocess Communication Tutorial\*(R"</em>, FreeBSD 4.4 (/usr/share/doc/psd/20.ipctut/).</p><p>Samuel J. Leffler, Robert S. Fabry, William N. Joy, Phil Lapsley: <em>\*(L"An Advanced 4.4BSD Interprocess Communication Tutorial\*(R"</em>, FreeBSD 4.4 (/usr/share/doc/psd/21.ipc/).</p><p>Craig Metz: <em>\*(L"Protocol Independence Using the Sockets \s-1API\s0\*(R"</em>, http://www.usenix.org/publications/library/proceedings/usenix2000/freenix/metzprotocol.html, \s-1USENIX\s0 Annual Technical Conference, June 2000. <em>socket</em>\|(2), <em>accept</em>\|(2), <em>bind</em>\|(2), <em>connect</em>\|(2), <em>getpeername</em>\|(2), <em>getsockname</em>\|(2), <em>getsockopt</em>\|(2), <em>ioctl</em>\|(2), <em>listen</em>\|(2), <em>read</em>\|(2), <em>recv</em>\|(2), <em>select</em>\|(2), <em>send</em>\|(2), <em>shutdown</em>\|(2), <em>socketpair</em>\|(2), <em>write</em>\|(2), <em>getprotoent</em>\|(3), <em>protocols</em>\|(4).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">HISTORY</h2>
        <div class="sectioncontent">
<p><strong>\s-1OSSP\s0 sa</strong> was invented in August 2001 by Ralf S. Engelschall &lt;rse@engelschall.com&gt; under contract with Cable & Wireless &lt;http://www.cw.com/&gt; for use inside the \s-1OSSP\s0 project. Its creation was prompted by the requirement to implement an \s-1SMTP\s0 logging channel for the <strong>\s-1OSSP\s0 l2</strong> library. Its initial code was derived from a predecessor sub-library originally written for socket address abstraction inside the <strong>\s-1OSSP\s0 lmtp2nntp</strong> tool.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p> Ralf S. Engelschall  rse@engelschall.com  www.engelschall.com</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="s3dw_textbox_scrollup.3.html"><span aria-hidden="true">&larr;</span> s3dw_textbox_scrollup.3: Scroll text up</a></li>
   <li class="next"><a href="sa.hpp.3.html">sa.hpp.3: Src/mlpack/core/optimizers/sa/sa.hpp - <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

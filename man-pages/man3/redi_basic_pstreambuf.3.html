<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>redi_basic_pstreambuf: Class template for stream buffer.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Class template for stream buffer.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="redi_basic_pstreambuf (3) manual">
  <meta name="twitter:description" content="Class template for stream buffer.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libpstreams-dev-redi_basic_pstreambuf-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/redi_basic_pstreambuf.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="redi_basic_pstreambuf (3) manual" />
  <meta property="og:description" content="Class template for stream buffer." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libpstreams-dev-redi_basic_pstreambuf-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">redi_basic_pstreambuf<small> (3)</small></h1>
        <p class="lead">Class template for stream buffer.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/redi_basic_pstreambuf.3.html">
      <span itemprop="name">redi_basic_pstreambuf: Class template for stream buffer.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libpstreams-dev/">
      <span itemprop="name">libpstreams-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/redi_basic_pstreambuf.3.html">
      <span itemprop="name">redi_basic_pstreambuf: Class template for stream buffer.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;pstream.h&gt;</p><p>Inherits basic_streambuf&lt; CharT, Traits &gt;, and <strong>redi::pstreams</strong>.</p><h3>Public Types</h3>
<p>typedef CharT <strong>char_type</strong></p><p>typedef Traits <strong>traits_type</strong></p><p>typedef traits_type::int_type <strong>int_type</strong></p><p>typedef traits_type::off_type <strong>off_type</strong></p><p>typedef traits_type::pos_type <strong>pos_type</strong></p><p>typedef <strong>fd_type</strong> <strong>fd_t</strong></p><p>typedef std::ios_base::openmode <strong>pmode</strong></p><p><em>Type used to specify how to connect to the process. </em> typedef std::vector&lt; std::string &gt; <strong>argv_type</strong></p><p><em>Type used to hold the arguments for a command. </em> typedef int <strong>fd_type</strong></p><p><em>Type used for file descriptors. </em></p>
<h3>Public Member Functions</h3>
<p><strong>basic_pstreambuf</strong> ()</p><p><em>Default constructor. </em> <strong>basic_pstreambuf</strong> (const std::string &command, <strong>pmode</strong> mode)</p><p><em>Constructor that initialises the buffer with </em><em>command</em><em>. </em><em></em> <strong>basic_pstreambuf</strong> (const std::string &file, const <strong>argv_type</strong> &argv, <strong>pmode</strong> mode)</p><p><em>Constructor that initialises the buffer with </em><em>file</em><em> and </em><em>argv</em><em>. </em><em></em> <strong>~basic_pstreambuf</strong> ()</p><p><em>Destructor. </em> <strong>basic_pstreambuf</strong> * <strong>open</strong> (const std::string &command, <strong>pmode</strong> mode)</p><p><em>Initialise the stream buffer with </em><em>command</em><em>. </em><em></em> <strong>basic_pstreambuf</strong> * <strong>open</strong> (const std::string &file, const <strong>argv_type</strong> &argv, <strong>pmode</strong> mode)</p><p><em>Initialise the stream buffer with </em><em>file</em><em> and </em><em>argv</em><em>. </em><em></em> <strong>basic_pstreambuf</strong> * <strong>close</strong> ()</p><p><em>Close the stream buffer and wait for the process to exit. </em> <strong>basic_pstreambuf</strong> * <strong>kill</strong> (int signal=SIGTERM)</p><p><em>Send a signal to the process. </em> <strong>basic_pstreambuf</strong> * <strong>killpg</strong> (int signal=SIGTERM)</p><p><em>Send a signal to the process' process group. </em> void <strong>peof</strong> ()</p><p><em>Close the pipe connected to the process' stdin. </em> bool <strong>read_err</strong> (bool readerr=true)</p><p><em>Change active input source. </em> bool <strong>is_open</strong> () const </p><p><em>Report whether the stream buffer has been initialised. </em> bool <strong>exited</strong> ()</p><p><em>Report whether the process has exited. </em> int <strong>status</strong> () const </p><p><em>Return the exit status of the process. </em> int <strong>error</strong> () const </p><p><em>Return the error number (errno) for the most recent failed operation. </em></p>
<h3>Static Public Attributes</h3>
<p>static const <strong>pmode</strong> <strong>pstdin</strong> = std::ios_base::out</p><p><em>Write to stdin. </em> static const <strong>pmode</strong> <strong>pstdout</strong> = std::ios_base::in</p><p><em>Read from stdout. </em> static const <strong>pmode</strong> <strong>pstderr</strong> = std::ios_base::app</p><p><em>Read from stderr. </em></p>
<h3>Protected Types</h3>
<p>enum <strong>buf_read_src</strong> { <strong>rsrc_out</strong> = 0, <strong>rsrc_err</strong> = 1 }</p><p><em>Enumerated type to indicate whether stdout or stderr is to be read. </em> enum { <strong>bufsz</strong> = 32 }</p><p>enum { <strong>pbsz</strong> = 2 }</p>
<h3>Protected Member Functions</h3>
<p>int_type <strong>overflow</strong> (int_type c)</p><p><em>Transfer characters to the pipe when character buffer overflows. </em> int_type <strong>underflow</strong> ()</p><p><em>Transfer characters from the pipe when the character buffer is empty. </em> int_type <strong>pbackfail</strong> (int_type c=traits_type::eof())</p><p><em>Make a character available to be returned by the next extraction. </em> int <strong>sync</strong> ()</p><p><em>Write any buffered characters to the stream. </em> std::streamsize <strong>xsputn</strong> (const char_type *s, std::streamsize n)</p><p><em>Insert multiple characters into the pipe. </em> std::streamsize <strong>write</strong> (const char_type *s, std::streamsize n)</p><p><em>Insert a sequence of characters into the pipe. </em> std::streamsize <strong>read</strong> (char_type *s, std::streamsize n)</p><p><em>Extract a sequence of characters from the pipe. </em> std::streamsize <strong>showmanyc</strong> ()</p><p><em>Report how many characters can be read from active input without blocking. </em> pid_t <strong>fork</strong> (<strong>pmode</strong> mode)</p><p><em>Initialise pipes and fork process. </em> int <strong>wait</strong> (bool nohang=false)</p><p><em>Wait for the child process to exit. </em> <strong>fd_type</strong> & <strong>wpipe</strong> ()</p><p><em>Return the file descriptor for the output pipe. </em> <strong>fd_type</strong> & <strong>rpipe</strong> ()</p><p><em>Return the file descriptor for the active input pipe. </em> <strong>fd_type</strong> & <strong>rpipe</strong> (<strong>buf_read_src</strong> which)</p><p><em>Return the file descriptor for the specified input pipe. </em> void <strong>create_buffers</strong> (<strong>pmode</strong> mode)</p><p>void <strong>destroy_buffers</strong> (<strong>pmode</strong> mode)</p><p>bool <strong>empty_buffer</strong> ()</p><p><em>Writes buffered characters to the process' stdin pipe. </em> bool <strong>fill_buffer</strong> (bool non_blocking=false)</p><p>char_type * <strong>rbuffer</strong> ()</p><p><em>Return the active input buffer. </em> <strong>buf_read_src</strong> <strong>switch_read_buffer</strong> (<strong>buf_read_src</strong>)</p>
<h3>Related Functions</h3>
<p>(Note that these are not member functions.) void <strong>close_fd</strong> (<strong>pstreams::fd_type</strong> &fd)</p><p><em>Helper function to close a file descriptor. </em> template&lt;int N&gt; void <strong>close_fd_array</strong> (<strong>pstreams::fd_type</strong>(&fds)[N])</p><p><em>Helper function to close an array of file descriptors. </em></p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<h3>template&lt;typename CharT, typename Traits = std::char_traits&lt;CharT&gt;&gt;class redi::basic_pstreambuf&lt; CharT, Traits &gt;</h3>
<p>Class template for stream buffer.</p><p>Provides underlying streambuf functionality for the PStreams classes.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Typedef Documentation</h2>
        <div class="sectioncontent">
<h3>template&lt;typename CharT, typename Traits = std::char_traits&lt;CharT&gt;&gt; typedef \fBfd_type\fP \fBredi::basic_pstreambuf\fP&lt; CharT, Traits &gt;::\fBfd_t\fP</h3>
<p><strong>Deprecated</strong></p><p>use <strong>pstreams::fd_type</strong> instead.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>template&lt;typename C , typename T &gt; \fBredi::basic_pstreambuf\fP&lt; C, T &gt;::\fBbasic_pstreambuf\fP ()\fC [inline]\fP</h3>
<p>Default constructor. Creates an uninitialised stream buffer.</p>
<h3>template&lt;typename C , typename T &gt; \fBredi::basic_pstreambuf\fP&lt; C, T &gt;::\fBbasic_pstreambuf\fP (const std::string &command, \fBpmode\fPmode)\fC [inline]\fP</h3>
<p>Constructor that initialises the buffer with <em>command</em>. Initialises the stream buffer by calling <strong>open()</strong> with the supplied arguments.</p><p><strong>Parameters:</strong></p><p><em>command</em> a string containing a shell command.</p><p><em>mode</em> the I/O mode to use when opening the pipe.</p><p><strong>See Also:</strong></p><p><strong>open()</strong></p><p>References redi::basic_pstreambuf&lt; CharT, Traits &gt;::open().</p>
<h3>template&lt;typename C , typename T &gt; \fBredi::basic_pstreambuf\fP&lt; C, T &gt;::\fBbasic_pstreambuf\fP (const std::string &file, const \fBargv_type\fP &argv, \fBpmode\fPmode)\fC [inline]\fP</h3>
<p>Constructor that initialises the buffer with <em>file</em> and <em>argv</em>. Initialises the stream buffer by calling <strong>open()</strong> with the supplied arguments.</p><p><strong>Parameters:</strong></p><p><em>file</em> a string containing the name of a program to execute.</p><p><em>argv</em> a vector of argument strings passsed to the new program.</p><p><em>mode</em> the I/O mode to use when opening the pipe.</p><p><strong>See Also:</strong></p><p><strong>open()</strong></p><p>References redi::basic_pstreambuf&lt; CharT, Traits &gt;::open().</p>
<h3>template&lt;typename C , typename T &gt; \fBredi::basic_pstreambuf\fP&lt; C, T &gt;::~\fBbasic_pstreambuf\fP ()\fC [inline]\fP</h3>
<p>Destructor. Closes the stream by calling <strong>close()</strong>.</p><p><strong>See Also:</strong></p><p><strong>close()</strong></p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>template&lt;typename C , typename T &gt; \fBbasic_pstreambuf\fP&lt; C, T &gt; * \fBredi::basic_pstreambuf\fP&lt; C, T &gt;::close ()</h3>
<p>Close the stream buffer and wait for the process to exit. Closes all pipes and calls <strong>wait()</strong> to wait for the process to finish. If an error occurs the error code will be set to one of the possible errors for waitpid()<strong>. See your system's documentation for these errors.</strong></p><p><strong>Returns:</strong></p><p>this on successful close or NULL if there is no process to close or if an error occurs.</p>
<h3>template&lt;typename C , typename T &gt; bool \fBredi::basic_pstreambuf\fP&lt; C, T &gt;::empty_buffer ()\fC [protected]\fP</h3>
<p>Writes buffered characters to the process' stdin pipe.</p><p><strong>Returns:</strong></p><p>true if the buffer was emptied, false otherwise.</p>
<h3>template&lt;typename C , typename T &gt; int \fBredi::basic_pstreambuf\fP&lt; C, T &gt;::error () const\fC [inline]\fP</h3>
<p>Return the error number (errno) for the most recent failed operation.</p><p><strong>Returns:</strong></p><p>The error code of the most recently failed operation, or zero.</p>
<h3>template&lt;typename C , typename T &gt; bool \fBredi::basic_pstreambuf\fP&lt; C, T &gt;::exited ()\fC [inline]\fP</h3>
<p>Report whether the process has exited. This function can call <strong>pstreambuf::wait()</strong> and so may change the object's state if the child process has already exited.</p><p><strong>Returns:</strong></p><p>True if the associated process has exited, false otherwise.</p><p><strong>See Also:</strong></p><p><strong>basic_pstreambuf&lt;C,T&gt;::wait()</strong></p>
<h3>template&lt;typename C , typename T &gt; bool \fBredi::basic_pstreambuf\fP&lt; C, T &gt;::fill_buffer (boolnon_blocking = \fCfalse\fP)\fC [protected]\fP</h3>
<p><strong>Returns:</strong></p><p>true if the buffer was filled, false otherwise.</p>
<h3>template&lt;typename C , typename T &gt; pid_t \fBredi::basic_pstreambuf\fP&lt; C, T &gt;::fork (\fBpmode\fPmode)\fC [protected]\fP</h3>
<p>Initialise pipes and fork process. Creates pipes as specified by <em>mode</em> and calls <strong>fork()</strong><strong> to create a new process. If the fork is successful the parent process stores the child's PID and the opened pipes and the child process replaces its standard streams with the opened pipes.</strong></p><p>If an error occurs the error code will be set to one of the possible errors for pipe() or <strong>fork()</strong><strong>. See your system's documentation for these error codes.</strong></p><p><strong>Parameters:</strong></p><p><em>mode</em> an OR of pmodes specifying which of the child's standard streams to connect to.</p><p><strong>Returns:</strong></p><p>On success the PID of the child is returned in the parent's context and zero is returned in the child's context. On error -1 is returned and the error code is set appropriately.</p>
<h3>template&lt;typename C , typename T &gt; bool \fBredi::basic_pstreambuf\fP&lt; C, T &gt;::is_open () const\fC [inline]\fP</h3>
<p>Report whether the stream buffer has been initialised. Unlike <strong>pstreambuf::exited()</strong>, this function will not call <strong>wait()</strong> and so will not change the object's state. This means that once a child process is executed successfully this function will continue to return true even after the process exits (until <strong>wait()</strong> is called.)</p><p><strong>Returns:</strong></p><p>true if a previous call to <strong>open()</strong> succeeded and <strong>wait()</strong> has not been called and determined that the process has exited, false otherwise.</p>
<h3>template&lt;typename C , typename T &gt; \fBbasic_pstreambuf\fP&lt; C, T &gt; * \fBredi::basic_pstreambuf\fP&lt; C, T &gt;::kill (intsignal = \fCSIGTERM\fP)\fC [inline]\fP</h3>
<p>Send a signal to the process. Sends the specified signal to the process. A signal can be used to terminate a child process that would not exit otherwise.</p><p>If an error occurs the error code will be set to one of the possible errors for <strong>kill()</strong><strong>. See your system's documentation for these errors.</strong></p><p><strong>Parameters:</strong></p><p><em>signal</em> A signal to send to the child process.</p><p><strong>Returns:</strong></p><p>this or NULL if <strong>kill()</strong><strong> fails.</strong></p>
<h3>template&lt;typename C , typename T &gt; \fBbasic_pstreambuf\fP&lt; C, T &gt; * \fBredi::basic_pstreambuf\fP&lt; C, T &gt;::killpg (intsignal = \fCSIGTERM\fP)\fC [inline]\fP</h3>
<p>Send a signal to the process' process group. Sends the specified signal to the process group of the child process. A signal can be used to terminate a child process that would not exit otherwise, or to kill the process and its own children.</p><p>If an error occurs the error code will be set to one of the possible errors for getpgid() or <strong>kill()</strong><strong>. See your system's documentation for these errors. If the child is in the current process group then NULL will be returned and the error code set to EPERM.</strong></p><p><strong>Parameters:</strong></p><p><em>signal</em> A signal to send to the child process.</p><p><strong>Returns:</strong></p><p>this on success or NULL on failure.</p>
<h3>template&lt;typename C , typename T &gt; \fBbasic_pstreambuf\fP&lt; C, T &gt; * \fBredi::basic_pstreambuf\fP&lt; C, T &gt;::open (const std::string &command, \fBpmode\fPmode)</h3>
<p>Initialise the stream buffer with <em>command</em>. Starts a new process by passing <em>command</em> to the shell (/bin/sh) and opens pipes to the process with the specified <em>mode</em>.</p><p>If <em>mode</em> contains pstdout<em> the initial read source will be the child process' stdout, otherwise if </em><em>mode</em><em> contains pstderr</em><em> the initial read source will be the child's stderr.</em></p><p>Will duplicate the actions of the shell in searching for an executable file if the specified file name does not contain a slash (/) character.</p><p><strong>Warning:</strong></p><p>There is no way to tell whether the shell command succeeded, this function will always succeed unless resource limits (such as memory usage, or number of processes or open files) are exceeded. This means <strong>is_open()</strong> will return true even if <em>command</em> cannot be executed. Use <strong>pstreambuf::open(const std::string&, const argv_type&, pmode)</strong> if you need to know whether the command failed to execute.</p><p><strong>Parameters:</strong></p><p><em>command</em> a string containing a shell command.</p><p><em>mode</em> a bitwise OR of one or more of out<em>, in</em>, err<em>.</em></p><p><strong>Returns:</strong></p><p>NULL if the shell could not be started or the pipes could not be opened, this otherwise.</p><p><strong>See Also:</strong></p><p><a href="../man3/execl.3.html"><strong>execl</strong>(3)</a></p><p>Referenced by redi::basic_pstreambuf&lt; CharT, Traits &gt;::basic_pstreambuf().</p>
<h3>template&lt;typename C , typename T &gt; \fBbasic_pstreambuf\fP&lt; C, T &gt; * \fBredi::basic_pstreambuf\fP&lt; C, T &gt;::open (const std::string &file, const \fBargv_type\fP &argv, \fBpmode\fPmode)</h3>
<p>Initialise the stream buffer with <em>file</em> and <em>argv</em>. Starts a new process by executing <em>file</em> with the arguments in <em>argv</em> and opens pipes to the process with the specified <em>mode</em>.</p><p>By convention argv[0] should be the file name of the file being executed.</p><p>If <em>mode</em> contains pstdout<em> the initial read source will be the child process' stdout, otherwise if </em><em>mode</em><em> contains pstderr</em><em> the initial read source will be the child's stderr.</em></p><p>Will duplicate the actions of the shell in searching for an executable file if the specified file name does not contain a slash (/) character.</p><p>Iff <em>file</em> is successfully executed then <strong>is_open()</strong> will return true. Otherwise, <strong>pstreambuf::error()</strong> can be used to obtain the value of errno<strong> that was set by </strong><strong>execvp</strong><strong>(3) in the child process.</strong></p><p>The exit status of the new process will be returned by <strong>pstreambuf::status()</strong> after <strong>pstreambuf::exited()</strong> returns true.</p><p><strong>Parameters:</strong></p><p><em>file</em> a string containing the pathname of a program to execute.</p><p><em>argv</em> a vector of argument strings passed to the new program.</p><p><em>mode</em> a bitwise OR of one or more of out<em>, in</em> and err<em>.</em></p><p><strong>Returns:</strong></p><p>NULL if a pipe could not be opened or if the program could not be executed, this otherwise.</p><p><strong>See Also:</strong></p><p><a href="../man3/execvp.3.html"><strong>execvp</strong>(3)</a></p>
<h3>template&lt;typename C , typename T &gt; \fBbasic_pstreambuf\fP&lt; C, T &gt;::int_type \fBredi::basic_pstreambuf\fP&lt; C, T &gt;::overflow (int_typec)\fC [protected]\fP</h3>
<p>Transfer characters to the pipe when character buffer overflows. Called when the internal character buffer is not present or is full, to transfer the buffer contents to the pipe.</p><p><strong>Parameters:</strong></p><p><em>c</em> a character to be written to the pipe.</p><p><strong>Returns:</strong></p><p>traits_type::eof() if an error occurs, otherwise if <em>c</em> is not equal to traits_type::eof()<em> it will be buffered and a value other than traits_type::eof()</em> returned to indicate success.</p>
<h3>template&lt;typename C , typename T &gt; \fBbasic_pstreambuf\fP&lt; C, T &gt;::int_type \fBredi::basic_pstreambuf\fP&lt; C, T &gt;::pbackfail (int_typec = \fCtraits_type::eof()\fP)\fC [protected]\fP</h3>
<p>Make a character available to be returned by the next extraction. Attempts to make <em>c</em> available as the next character to be read by sgetc()<em>.</em></p><p><strong>Parameters:</strong></p><p><em>c</em> a character to make available for extraction.</p><p><strong>Returns:</strong></p><p><em>c</em> if the character can be made available, traits_type::eof()<em> otherwise.</em></p>
<h3>template&lt;typename C , typename T &gt; void \fBredi::basic_pstreambuf\fP&lt; C, T &gt;::peof ()\fC [inline]\fP</h3>
<p>Close the pipe connected to the process' stdin. Closes the output pipe, causing the child process to receive the end-of-file indicator on subsequent reads from its stdin stream.</p>
<h3>template&lt;typename C , typename T &gt; \fBbasic_pstreambuf\fP&lt; C, T &gt;::char_type * \fBredi::basic_pstreambuf\fP&lt; C, T &gt;::rbuffer ()\fC [inline]\fP, \fC [protected]\fP</h3>
<p>Return the active input buffer.</p><p><strong>Returns:</strong></p><p>a pointer to the start of the active input buffer area.</p>
<h3>template&lt;typename C , typename T &gt; std::streamsize \fBredi::basic_pstreambuf\fP&lt; C, T &gt;::read (char_type *s, std::streamsizen)\fC [inline]\fP, \fC [protected]\fP</h3>
<p>Extract a sequence of characters from the pipe. Reads up to <em>n</em> characters from the pipe to the buffer <em>s</em>.</p><p><strong>Parameters:</strong></p><p><em>s</em> character buffer.</p><p><em>n</em> buffer length.</p><p><strong>Returns:</strong></p><p>the number of characters read.</p>
<h3>template&lt;typename C , typename T &gt; bool \fBredi::basic_pstreambuf\fP&lt; C, T &gt;::read_err (boolreaderr = \fCtrue\fP)\fC [inline]\fP</h3>
<p>Change active input source. Toggle the stream used for reading. If <em>readerr</em> is true<em> then the process' stderr</em> output will be used for subsequent extractions, if <em>readerr</em> is false the the process' stdout will be used.</p><p><strong>Parameters:</strong></p><p><em>readerr</em> true<em> to read stderr</em>, false<em> to read stdout</em>.</p><p><strong>Returns:</strong></p><p>true if the requested stream is open and will be used for subsequent extractions, false otherwise.</p><p>Referenced by redi::basic_ipstream&lt; CharT, Traits &gt;::err(), redi::basic_pstream&lt; CharT, Traits &gt;::err(), redi::basic_rpstream&lt; CharT, Traits &gt;::err(), redi::basic_ipstream&lt; CharT, Traits &gt;::out(), redi::basic_pstream&lt; CharT, Traits &gt;::out(), and redi::basic_rpstream&lt; CharT, Traits &gt;::out().</p>
<h3>template&lt;typename C , typename T &gt; \fBpstreams::fd_type\fP & \fBredi::basic_pstreambuf\fP&lt; C, T &gt;::rpipe ()\fC [inline]\fP, \fC [protected]\fP</h3>
<p>Return the file descriptor for the active input pipe.</p><p><strong>Returns:</strong></p><p>a reference to the active input file descriptor</p>
<h3>template&lt;typename C , typename T &gt; \fBpstreams::fd_type\fP & \fBredi::basic_pstreambuf\fP&lt; C, T &gt;::rpipe (\fBbuf_read_src\fPwhich)\fC [inline]\fP, \fC [protected]\fP</h3>
<p>Return the file descriptor for the specified input pipe.</p><p><strong>Returns:</strong></p><p>a reference to the specified input file descriptor</p>
<h3>template&lt;typename C , typename T &gt; int \fBredi::basic_pstreambuf\fP&lt; C, T &gt;::status () const\fC [inline]\fP</h3>
<p>Return the exit status of the process.</p><p><strong>Returns:</strong></p><p>The exit status of the child process, or -1 if <strong>wait()</strong> has not yet been called to wait for the child to exit.</p><p><strong>See Also:</strong></p><p><strong>basic_pstreambuf&lt;C,T&gt;::wait()</strong></p>
<h3>template&lt;typename C , typename T &gt; \fBbasic_pstreambuf\fP&lt; C, T &gt;::int_type \fBredi::basic_pstreambuf\fP&lt; C, T &gt;::underflow ()\fC [protected]\fP</h3>
<p>Transfer characters from the pipe when the character buffer is empty. Called when the internal character buffer is is empty, to re-fill it from the pipe.</p><p><strong>Returns:</strong></p><p>The first available character in the buffer, or traits_type::eof() in case of failure.</p>
<h3>template&lt;typename C , typename T &gt; int \fBredi::basic_pstreambuf\fP&lt; C, T &gt;::wait (boolnohang = \fCfalse\fP)\fC [protected]\fP</h3>
<p>Wait for the child process to exit. Suspends execution and waits for the associated process to exit, or until a signal is delivered whose action is to terminate the current process or to call a signal handling function. If the process has already exited (i.e. it is a 'zombie' process) then <strong>wait()</strong> returns immediately. Waiting for the child process causes all its system resources to be freed.</p><p><strong>error()</strong> will return EINTR if <strong>wait()</strong> is interrupted by a signal.</p><p><strong>Parameters:</strong></p><p><em>nohang</em> true to return immediately if the process has not exited.</p><p><strong>Returns:</strong></p><p>1 if the process has exited and <strong>wait()</strong> has not yet been called. 0 if <em>nohang</em> is true and the process has not exited yet. -1 if no process has been started or if an error occurs, in which case the error can be found using <strong>error()</strong>.</p>
<h3>template&lt;typename C , typename T &gt; \fBpstreams::fd_type\fP & \fBredi::basic_pstreambuf\fP&lt; C, T &gt;::wpipe ()\fC [inline]\fP, \fC [protected]\fP</h3>
<p>Return the file descriptor for the output pipe.</p><p><strong>Returns:</strong></p><p>a reference to the output file descriptor</p>
<h3>template&lt;typename C , typename T &gt; std::streamsize \fBredi::basic_pstreambuf\fP&lt; C, T &gt;::write (const char_type *s, std::streamsizen)\fC [inline]\fP, \fC [protected]\fP</h3>
<p>Insert a sequence of characters into the pipe. Writes up to <em>n</em> characters to the pipe from the buffer <em>s</em>.</p><p><strong>Parameters:</strong></p><p><em>s</em> character buffer.</p><p><em>n</em> buffer length.</p><p><strong>Returns:</strong></p><p>the number of characters written.</p>
<h3>template&lt;typename C , typename T &gt; std::streamsize \fBredi::basic_pstreambuf\fP&lt; C, T &gt;::xsputn (const char_type *s, std::streamsizen)\fC [protected]\fP</h3>
<p>Insert multiple characters into the pipe.</p><p><strong>Parameters:</strong></p><p><em>s</em> character buffer.</p><p><em>n</em> buffer length.</p><p><strong>Returns:</strong></p><p>the number of characters written.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Friends And Related Function Documentation</h2>
        <div class="sectioncontent">
<h3>template&lt;typename CharT, typename Traits = std::char_traits&lt;CharT&gt;&gt; void close_fd (\fBpstreams::fd_type\fP &fd)\fC [related]\fP</h3>
<p>Helper function to close a file descriptor. Inspects <em>fd</em> and calls <strong>close</strong>(3) if it has a non-negative value.</p><p><strong>Parameters:</strong></p><p><em>fd</em> a file descriptor.</p>
<h3>template&lt;int N&gt; void close_fd_array (\fBpstreams::fd_type\fP(&)fds[N])\fC [related]\fP</h3>
<p>Helper function to close an array of file descriptors. Calls <strong>close_fd()</strong><strong> on each member of the array. The length of the array is determined automatically by template argument deduction to avoid errors.</strong></p><p><strong>Parameters:</strong></p><p><em>fds</em> an array of file descriptors.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for PStreams from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="redi_basic_pstream.3.html"><span aria-hidden="true">&larr;</span> redi_basic_pstream.3: Class template for bidirectional pstreams.</a></li>
   <li class="next"><a href="redi_basic_rpstream.3.html">redi_basic_rpstream.3: Class template for restricted pstreams. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

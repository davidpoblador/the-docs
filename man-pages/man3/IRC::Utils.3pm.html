<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>IRC::Utils: Common utilities for irc-related tasks</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Common utilities for irc-related tasks">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="IRC::Utils (3pm) manual">
  <meta name="twitter:description" content="Common utilities for irc-related tasks">
  <meta name="twitter:image" content="https://www.carta.tech/images/libirc-utils-perl-IRC::Utils-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/IRC::Utils.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="IRC::Utils (3pm) manual" />
  <meta property="og:description" content="Common utilities for irc-related tasks" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libirc-utils-perl-IRC::Utils-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">IRC::Utils<small> (3pm)</small></h1>
        <p class="lead">Common utilities for irc-related tasks</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/IRC::Utils.3pm.html">
      <span itemprop="name">IRC::Utils: Common utilities for irc-related tasks</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libirc-utils-perl/">
      <span itemprop="name">libirc-utils-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/IRC::Utils.3pm.html">
      <span itemprop="name">IRC::Utils: Common utilities for irc-related tasks</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
 use strict;
 use warnings;

 use IRC::Utils &apos;:ALL&apos;;

 my $nickname = &apos;^Lame|BOT[moo]&apos;;
 my $uppercase_nick = uc_irc($nickname);
 my $lowercase_nick = lc_irc($nickname);

 print "They&apos;re equivalent&#92;n" if eq_irc($uppercase_nick, $lowercase_nick);

 my $mode_line = &apos;ov+b-i Bob sue stalin*!*@*&apos;;
 my $hashref = parse_mode_line($mode_line);

 my $banmask = &apos;stalin*&apos;;
 my $full_banmask = normalize_mask($banmask);

 if (matches_mask($full_banmask, &apos;stalin!joe@kremlin.ru&apos;)) {
     print "EEK!";
 }

 my $decoded = irc_decode($raw_irc_message);
 print $decoded, "&#92;n";

 if (has_color($message)) {
    print &apos;COLOR CODE ALERT!&#92;n";
 }

 my $results_hashref = matches_mask_array(&#92;@masks, &#92;@items_to_match_against);

 my $nick = parse_user(&apos;stalin!joe@kremlin.ru&apos;);
 my ($nick, $user, $host) = parse_user(&apos;stalin!joe@kremlin.ru&apos;);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The functions in this module take care of many of the tasks you are faced with when working with \s-1IRC\s0. Mode lines, ban masks, message encoding and formatting, etc.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FUNCTIONS</h2>
        <div class="sectioncontent">
<p>Takes one mandatory parameter, a string to convert to \s-1IRC\s0 uppercase, and one optional parameter, the casemapping of the ircd (which can be <strong>'rfc1459'</strong>, <strong>'strict-rfc1459'</strong> or <strong>'ascii'</strong>. Default is <strong>'rfc1459'</strong>). Returns the \s-1IRC\s0 uppercase equivalent of the passed string. Takes one mandatory parameter, a string to convert to \s-1IRC\s0 lowercase, and one optional parameter, the casemapping of the ircd (which can be <strong>'rfc1459'</strong>, <strong>'strict-rfc1459'</strong> or <strong>'ascii'</strong>. Default is <strong>'rfc1459'</strong>). Returns the \s-1IRC\s0 lowercase equivalent of the passed string. Takes two mandatory parameters, \s-1IRC\s0 strings (channels or nicknames) to compare. A third, optional parameter specifies the casemapping. Returns true if the two strings are equivalent, false otherwise</p><p> # long version  lc_irc($one, $map) eq lc_irc($two, $map)</p><p> # short version  eq_irc($one, $two, $map) Takes a list representing an \s-1IRC\s0 mode line. Returns a hashref. Optionally you can also supply an arrayref and a hashref to specify valid channel modes (default: \*(C`[qw(beI k l imnpstaqr)]\*(C') and status modes (default: \*(C`{o =&gt; &apos;@&apos;, h =&gt; &apos;%&apos;, v =&gt; &apos;+&apos;}\*(C'), respectively.</p><p>If the modeline couldn't be parsed the hashref will be empty. On success the following keys will be available in the hashref:</p><p><strong>'modes'</strong>, an arrayref of normalised modes;</p><p><strong>'args'</strong>, an arrayref of applicable arguments to the modes;</p><p>Example:</p><p> my $hashref = parse_mode_line( &apos;ov+b-i&apos;, &apos;Bob&apos;, &apos;sue&apos;, &apos;stalin*!*@*&apos; );</p><p> # $hashref will be:  {     modes =&gt; [ &apos;+o&apos;, &apos;+v&apos;, &apos;+b&apos;, &apos;-i&apos; ],     args  =&gt; [ &apos;Bob&apos;, &apos;sue&apos;, &apos;stalin*!*@*&apos; ],  } Takes one parameter, a string representing an \s-1IRC\s0 mask. Returns a normalised full mask.</p><p>Example:</p><p> $fullbanmask = normalize_mask( &apos;stalin*&apos; );</p><p> # $fullbanmask will be: &apos;stalin*!*@*&apos;; Takes two parameters, a string representing an \s-1IRC\s0 mask and something to match against the \s-1IRC\s0 mask, such as a nick!user@hostname string. Returns a true value if they match, a false value otherwise. Optionally, one may pass the casemapping (see \*(C`uc_irc\*(C'), as this function uses \*(C`uc_irc\*(C' internally. Takes two array references, the first being a list of strings representing \s-1IRC\s0 masks, the second a list of somethings to test against the masks. Returns an empty hashref if there are no matches. Otherwise, the keys will be the masks matched, each value being an arrayref of the strings that matched it. Optionally, one may pass the casemapping (see \*(C`uc_irc\*(C'), as this function uses \*(C`uc_irc\*(C' internally. Takes one argument, a string representing a number of mode changes. Returns a condensed version of the changes.</p><p>  my $mode_line = unparse_mode_line(&apos;+o+o+o-v+v&apos;);   $mode_line is now &apos;+ooo-v+v&apos; Takes two arguments, strings representing a set of \s-1IRC\s0 user modes before and after a change. Returns a string representing what changed.</p><p>  my $mode_change = gen_mode_change(&apos;abcde&apos;, &apos;befmZ&apos;);   $mode_change is now &apos;-acd+fmZ&apos; Takes one parameter, a string representing a user in the form nick!user@hostname. In a scalar context it returns just the nickname. In a list context it returns a list consisting of the nick, user and hostname, respectively. Takes one argument, a channel name to validate. Returns true or false if the channel name is valid or not. You can supply a second argument, an array of characters of allowed channel prefixes. Defaults to \*(C`[&apos;#&apos;, &apos;&&apos;]\*(C'. Takes one argument, a nickname to validate. Returns true or false if the nickname is valid or not. Takes an \s-1IRC\s0 server numerical reply code (e.g. '001') as an argument, and returns the corresponding name (e.g. '\s-1RPL_WELCOME\s0'). Takes an \s-1IRC\s0 server reply name (e.g. '\s-1RPL_WELCOME\s0') as an argument, and returns the corresponding numerical code (e.g. '001'). Takes one parameter, a string of \s-1IRC\s0 text. Returns true if it contains any \s-1IRC\s0 color codes, false otherwise. Useful if you want your bot to kick users for (ab)using colors. :) Takes one parameter, a string of \s-1IRC\s0 text. Returns true if it contains any \s-1IRC\s0 formatting codes, false otherwise. Takes one parameter, a string of \s-1IRC\s0 text. Returns the string stripped of all \s-1IRC\s0 color codes. Takes one parameter, a string of \s-1IRC\s0 text. Returns the string stripped of all \s-1IRC\s0 formatting codes. This function takes a byte string (i.e. an unmodified \s-1IRC\s0 message) and returns a text string. Since the source encoding might have been \s-1UTF-8\s0, you should store it with \s-1UTF-8\s0 or some other Unicode encoding in your file/database/whatever to be safe. For a more detailed discussion, see \*(L"\s-1ENCODING\s0\*(R".</p><p> use IRC::Utils qw(decode_irc);</p><p> sub message_handler {      my ($nick, $channel, $message) = @_;</p><p>     # not wise, $message is a byte string of unknown encoding      print $message, "&#92;n";</p><p>     $message = decode_irc($what);</p><p>     # good, $message is a text string      print $message, "&#92;n";  }</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONSTANTS</h2>
        <div class="sectioncontent">
<p>Use the following constants to add formatting and mIRC color codes to \s-1IRC\s0 messages.</p><p>Normal text:</p><p> NORMAL</p><p>Formatting:</p><p> BOLD  UNDERLINE  REVERSE  ITALIC  FIXED</p><p>Colors:</p><p> WHITE  BLACK  BLUE  GREEN  RED  BROWN  PURPLE  ORANGE  YELLOW  LIGHT_GREEN  TEAL  LIGHT_CYAN  LIGHT_BLUE  PINK  GREY  LIGHT_GREY</p><p>Individual non-color formatting codes can be cancelled with their corresponding constant, but you can also cancel all of them at once with \*(C`NORMAL\*(C'. To cancel the effect of color codes, you must use \*(C`NORMAL\*(C'. which of course has the side effect of cancelling all other formatting codes as well.</p><p> $msg = &apos;This word is &apos;.YELLOW.&apos;yellow&apos;.NORMAL.&apos; while this word is&apos;.BOLD.&apos;bold&apos;.BOLD;  $msg = UNDERLINE.BOLD.&apos;This sentence is both underlined and bold.&apos;.NORMAL;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ENCODING</h2>
        <div class="sectioncontent">
<h3>Messages</h3>
<p>The only encoding requirement the \s-1IRC\s0 protocol places on its messages is that they be 8-bits and ASCII-compatible. This has resulted in most of the Western world settling on ASCII-compatible Latin-1 (usually Microsoft's \s-1CP1252\s0, a Latin-1 variant) as a convention. Recently, popular \s-1IRC\s0 clients (mIRC, xchat, certain irssi configurations) have begun sending a mixture of \s-1CP1252\s0 and \s-1UTF-8\s0 over the wire to allow more characters without breaking backward compatibility (too much). They send \s-1CP1252\s0 encoded messages if the characters fit within that encoding, otherwise falling back to \s-1UTF-8\s0, and likewise autodetecting the encoding (\s-1UTF-8\s0 or \s-1CP1252\s0) of incoming messages. Since writing text with mixed encoding to a file, terminal, or database is not a good idea, you need a way to decode messages from \s-1IRC\s0. \*(C`decode_irc\*(C' will do that.</p>
<h3>Channel names</h3>
<p>The matter is complicated further by the fact that some servers allow non-ASCII characters in channel names. \s-1IRC\s0 modules generally don't explicitly encode or decode any \s-1IRC\s0 traffic, but they do have to concatenate parts of a message (e.g. a channel name and a message) before sending it over the wire. So when you do something like \*(C`privmsg($channel, &apos;\*(ae\*(d-i&apos;)\*(C', where $channel is the unmodified channel name (a byte string) you got from an earlier \s-1IRC\s0 message, the channel name will get double-encoded when concatenated with your message (a non-ASCII text string) if the channel name contains non-ASCII bytes.</p><p>To prevent this, you can't simply decode the channel name and then use it. &apos;#\*(ae\*(d-i&apos; in \s-1CP1252\s0 is not the same channel as &apos;#\*(ae\*(d-i&apos; in \s-1UTF-8\s0, since they are encoded as different sequences of bytes, and the \s-1IRC\s0 server only cares about the byte representation. Therefore, when using a channel name you got from the server (e.g. when replying to message), you should use the original byte string (before it has been decoded with \*(C`decode_irc\*(C'), and encode any other parameters (with \*(C`encode_utf8\*(C') so that your message will be concatenated correctly. At some point, you'll probably want to print the channel name, write it to a log file or use it in a filename, so you'll eventually have to decode it, at which point the \s-1UTF-8\s0 \*(C`#\*(ae\*(d-i\*(C' and \s-1CP1252\s0 \*(C`#\*(ae\*(d-i\*(C' will have to be considered equivalent.</p><p> use Encode qw(encode_utf8 encode);</p><p> sub message_handler {      # these three are all byte strings      my ($nick, $channel, $message) = @_;</p><p>     # bad: if $channel has any non-ASCII bytes, they will get double-encoded      privmsg($channel, &apos;\*(ae\*(d-i&apos;);</p><p>     # bad: if $message has any non-ASCII bytes, they will get double-encoded      privmsg(&apos;#\*(ae\*(d-i&apos;, $message);</p><p>     # good: both are byte strings already, so they will concatenate correctly      privmsg($channel, $message);</p><p>     # good: both are text strings (Latin1 as per Perl&apos;s default), so      # they&apos;ll be concatenated correctly      privmsg(&apos;#\*(ae\*(d-i&apos;, &apos;\*(ae\*(d-i&apos;);</p><p>     # good: similar to the last one, except now they&apos;re using UTF-8, which      # means that the channel is actually not the same as above      use utf8;      privmsg(&apos;#\*(ae\*(d-i&apos;, &apos;\*(ae\*(d-i&apos;);</p><p>     # good: $channel and $msg_bytes are both byte strings      my $msg_bytes = encode_utf8(&apos;\*(ae\*(d-i&apos;);      privmsg($channel, $msg_bytes);</p><p>     # good: $chan_bytes and $message are both byte strings      # here we&apos;re sending a message to the utf8-encoded #\*(ae\*(d-i      my $utf8_bytes = encode_utf8(&apos;#\*(ae\*(d-i&apos;);      privmsg($utf8_bytes, $message);</p><p>     # good: $chan_bytes and $message are both byte strings      # here we&apos;re sending a message to the cp1252-encoded #\*(ae\*(d-i      my $cp1252_bytes = encode(&apos;cp1252&apos;, &apos;#\*(ae\*(d-i&apos;);      privmsg($cp1252_bytes, $message);</p><p>     # bad: $channel is in an undetermined encoding      log_message("Got message from $channel");</p><p>     # good: using the decoded version of $channel      log_message("Got message from ".decode_irc($channel));  }</p><p>See also Encode, perluniintro, perlunitut, perlunicode, and perlunifaq.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Hinrik O\*:rn Sigur\*(d-sson &lt;hinrik.sig@gmail.com&gt; (\*(C`Hinrik\*(C' irc.perl.org, or \*(C`literal\*(C' @ FreeNode).</p><p>Chris \*(C`BinGOs\*(C' Williams &lt;chris@bingosnet.co.uk&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO IRC::Utils&hellip;</h2>
        <div class="sectioncontent">
<p>POE::Component::IRC</p><p>POE::Component::Server::IRC</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="IRC::Formatting::HTML.3pm.html"><span aria-hidden="true">&larr;</span> IRC::Formatting::HTML.3pm: Convert between html and irc formatting</a></li>
   <li class="next"><a href="Icon::FamFamFam::Silk.3pm.html">Icon::FamFamFam::Silk.3pm: Embed these famous icons in your code <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>URI::Find: Find uris in arbitrary text</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Find uris in arbitrary text">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="URI::Find (3pm) manual">
  <meta name="twitter:description" content="Find uris in arbitrary text">
  <meta name="twitter:image" content="https://www.carta.tech/images/liburi-find-perl-URI::Find-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/URI::Find.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="URI::Find (3pm) manual" />
  <meta property="og:description" content="Find uris in arbitrary text" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/liburi-find-perl-URI::Find-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">URI::Find<small> (3pm)</small></h1>
        <p class="lead">Find uris in arbitrary text</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/URI::Find.3pm.html">
      <span itemprop="name">URI::Find: Find uris in arbitrary text</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/liburi-find-perl/">
      <span itemprop="name">liburi-find-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/URI::Find.3pm.html">
      <span itemprop="name">URI::Find: Find uris in arbitrary text</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  require URI::Find;

  my $finder = URI::Find-&gt;new(&#92;&callback);

  $how_many_found = $finder-&gt;find(&#92;$text);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module does one thing: Finds URIs and URLs in plain text.  It finds them quickly and it finds them <strong>all</strong> (or what \s-1URI::URL\s0 considers a \s-1URI\s0 to be.)  It only finds URIs which include a scheme (http:// or the like), for something a bit less strict have a look at URI::Find::Schemeless.</p><p>For a command-line interface, urifind is provided.</p><h3>Public Methods</h3>

<dl class='dl-vertical'>
  <dt>
    <strong>new</strong>
  </dt>
  <dd>
    <p>  my $finder = URI::Find-&gt;new(&#92;&callback); Creates a new URI::Find object. &callback is a function which is called on each \s-1URI\s0 found.  It is passed two arguments, the first is a \s-1URI::URL\s0 object representing the \s-1URI\s0 found.  The second is the original text of the \s-1URI\s0 found.  The return value of the callback will replace the original \s-1URI\s0 in the text.</p>
  </dd>
  <dt>
    <strong>find</strong>
  </dt>
  <dd>
    <p>  my $how_many_found = $finder-&gt;find(&#92;$text); $text is a string to search and possibly modify with your callback. Alternatively, \*(C`find\*(C' can be called with a replacement function for the rest of the text:   use CGI qw(escapeHTML);   # ...   my $how_many_found = $finder-&gt;find(&#92;$text, &#92;&escapeHTML); will not only call the callback function for every \s-1URL\s0 found (and perform the replacement instructions therein), but also run the rest of the text through \*(C`escapeHTML()\*(C'. This makes it easier to turn plain text which contains URLs into \s-1HTML\s0 (see example below).</p>
  </dd>

</dl>

<h3>Protected Methods</h3>
<p>I got a bunch of mail from people asking if I'd add certain features to URI::Find.  Most wanted the search to be less restrictive, do more heuristics, etc...  Since many of the requests were contradictory, I'm letting people create their own custom subclasses to do what they want.</p><p>The following are methods internal to URI::Find which a subclass can override to change the way URI::Find acts.  They are only to be called <strong>inside</strong> a URI::Find subclass.  Users of this module are \s-1NOT\s0 to use these methods.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>uri_re</strong>
  </dt>
  <dd>
    <p>  my $uri_re = $self-&gt;uri_re; Returns the regex for finding absolute, schemed URIs (http://www.foo.com and such).  This, combined with <em>schemeless_uri_re()</em> is what finds candidate URIs. Usually this method does not have to be overridden.</p>
  </dd>
  <dt>
    <strong>schemeless_uri_re</strong>
  </dt>
  <dd>
    <p>  my $schemeless_re = $self-&gt;schemeless_uri_re; Returns the regex for finding schemeless URIs (www.foo.com and such) and other things which might be URIs.  By default this will match nothing (though it used to try to find schemeless URIs which started with \*(C`www\*(C' and \*(C`ftp\*(C'). Many people will want to override this method.  See URI::Find::Schemeless for a subclass does a reasonable job of finding URIs which might be missing the scheme.</p>
  </dd>
  <dt>
    <strong>uric_set</strong>
  </dt>
  <dd>
    <p>  my $uric_set = $self-&gt;uric_set; Returns a set matching the 'uric' set defined in \s-1RFC\s0 2396 suitable for putting into a character set ([]) in a regex. You almost never have to override this.</p>
  </dd>
  <dt>
    <strong>cruft_set</strong>
  </dt>
  <dd>
    <p>  my $cruft_set = $self-&gt;cruft_set; Returns a set of characters which are considered garbage.  Used by <em>decruft()</em>.</p>
  </dd>
  <dt>
    <strong>decruft</strong>
  </dt>
  <dd>
    <p>  my $uri = $self-&gt;decruft($uri); Sometimes garbage characters like periods and parenthesis get accidentally matched along with the \s-1URI\s0.  In order for the \s-1URI\s0 to be properly identified, it must sometimes be \*(L"decrufted\*(R", the garbage characters stripped. This method takes a candidate \s-1URI\s0 and strips off any cruft it finds.</p>
  </dd>
  <dt>
    <strong>recruft</strong>
  </dt>
  <dd>
    <p>  my $uri = $self-&gt;recruft($uri); This method puts back the cruft taken off with <em>decruft()</em>.  This is necessary because the cruft is destructively removed from the string before invoking the user's callback, so it has to be put back afterwards.</p>
  </dd>
  <dt>
    <strong>schemeless_to_schemed</strong>
  </dt>
  <dd>
    <p>  my $schemed_uri = $self-&gt;schemeless_to_schemed($schemeless_uri); This takes a schemeless \s-1URI\s0 and returns an absolute, schemed \s-1URI\s0.  The standard implementation supplies ftp:// for URIs which start with ftp., and http:// otherwise.</p>
  </dd>
  <dt>
    <strong>is_schemed</strong>
  </dt>
  <dd>
    <p>  $obj-&gt;is_schemed($uri); Returns whether or not the given \s-1URI\s0 is schemed or schemeless.  True for schemed, false for schemeless.</p>
  </dd>
  <dt>
    <em>badinvo</em>
  </dt>
  <dd>
    <p>  _\|_PACKAGE_\|_-&gt;badinvo($extra_levels, $msg) This is used to complain about bogus subroutine/method invocations. The args are optional.</p>
  </dd>

</dl>

<h3>Old Functions</h3>
<p>The old <em>find_uri()</em> function is still around and it works, but its deprecated.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>Store a list of all URIs (normalized) in the document.</p><p>  my @uris;   my $finder = URI::Find-&gt;new(sub {       my($uri) = shift;       push @uris, $uri;   });   $finder-&gt;find(&#92;$text);</p><p>Print the original \s-1URI\s0 text found and the normalized representation.</p><p>  my $finder = URI::Find-&gt;new(sub {       my($uri, $orig_uri) = @_;       print "The text &apos;$orig_uri&apos; represents &apos;$uri&apos;&#92;n";       return $orig_uri;   });   $finder-&gt;find(&#92;$text);</p><p>Check each \s-1URI\s0 in document to see if it exists.</p><p>  use LWP::Simple;</p><p>  my $finder = URI::Find-&gt;new(sub {       my($uri, $orig_uri) = @_;       if( head $uri ) {           print "$orig_uri is okay&#92;n";       }       else {           print "$orig_uri cannot be found&#92;n";       }       return $orig_uri;   });   $finder-&gt;find(&#92;$text);</p><p>Turn plain text into \s-1HTML\s0, with each \s-1URI\s0 found wrapped in an \s-1HTML\s0 anchor.</p><p>  use CGI qw(escapeHTML);   use URI::Find;</p><p>  my $finder = URI::Find-&gt;new(sub {       my($uri, $orig_uri) = @_;       return qq|&lt;a href="$uri"&gt;$orig_uri&lt;/a&gt;|;   });   $finder-&gt;find(&#92;$text, &#92;&escapeHTML);   print "&lt;pre&gt;$text&lt;/pre&gt;";</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTES</h2>
        <div class="sectioncontent">
<p>Will not find URLs with Internationalized Domain Names or pretty much any non-ascii stuff in them.  See &lt;http://rt.cpan.org/Ticket/Display.html?id=44226&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Michael G Schwern &lt;schwern@pobox.com&gt; with insight from Uri Gutman, Greg Bacon, Jeff Pinyan, Roderick Schertler and others.</p><p>Roderick Schertler &lt;roderick@argon.org&gt; maintained versions 0.11 to 0.16.</p><p>Darren Chamberlain wrote urifind.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LICENSE</h2>
        <div class="sectioncontent">
<p>Copyright 2000, 2009-2010 by Michael G Schwern &lt;schwern@pobox.com&gt;.</p><p>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p><p>See <em>http://www.perlfoundation.org/artistic_license_1_0</em></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO URI::Find&hellip;</h2>
        <div class="sectioncontent">
<p>urifind, URI::Find::Schemeless, \s-1URI::URL\s0, \s-1URI\s0, \s-1RFC\s0 3986 Appendix C</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="URI::Fetch::Response.3pm.html"><span aria-hidden="true">&larr;</span> URI::Fetch::Response.3pm: Feed response for uri::fetch</a></li>
   <li class="next"><a href="URI::Find::Delimited.3pm.html">URI::Find::Delimited.3pm: Find uris which may be wrapped in enclosing delimiters. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

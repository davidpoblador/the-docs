<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>erl_syntax_lib: Support library for abstract erlang syntax trees.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Support library for abstract erlang syntax trees.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="erl_syntax_lib (3erl) manual">
  <meta name="twitter:description" content="Support library for abstract erlang syntax trees.">
  <meta name="twitter:image" content="https://www.carta.tech/images/erlang-manpages-erl_syntax_lib-3erl.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3erl/erl_syntax_lib.3erl.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="erl_syntax_lib (3erl) manual" />
  <meta property="og:description" content="Support library for abstract erlang syntax trees." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/erlang-manpages-erl_syntax_lib-3erl.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">erl_syntax_lib<small> (3erl)</small></h1>
        <p class="lead">Support library for abstract erlang syntax trees.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/erl_syntax_lib.3erl.html">
      <span itemprop="name">erl_syntax_lib: Support library for abstract erlang syntax trees.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/erlang-manpages/">
      <span itemprop="name">erlang-manpages</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/erl_syntax_lib.3erl.html">
      <span itemprop="name">erl_syntax_lib: Support library for abstract erlang syntax trees.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Support library for abstract Erlang syntax trees.</p><p>This module contains utility functions for working with the abstract data type defined in the module <strong>erl_syntax</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DATA TYPES</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>info_pair() = {key(), term()}</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>key() = attributes | errors | exports | functions | imports | module | records | rules | warnings</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>ordset(T) = ordset(T) (see module //stdlib/ordsets)</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>syntaxTree() = syntaxTree() (see module erl_syntax)</em>:</p><p>An abstract syntax tree. See the <strong>erl_syntax</strong> module for details.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">
<p><strong></strong> analyze_application(Node::syntaxTree()) -&gt; FunctionName | Arity</p><p>Types:</p><p>FunctionName = {atom(), Arity} | {ModuleName, FunctionName}</p><p>Arity = integer()</p><p>ModuleName = atom()</p><p>Returns the name of a called function. The result is a representation of the name of the applied function <em>F/A</em>, if <em>Node</em> represents a function application "<em>&lt;em&gt;F&lt;/em&gt;(&lt;em&gt;X_1&lt;/em&gt;, ..., &lt;em&gt;X_A&lt;/em&gt;)</em>". If the function is not explicitly named (i.e., <em>F</em> is given by some expression), only the arity <em>A</em> is returned.</p><p>The evaluation throws <em>syntax_error</em> if <em>Node</em> does not represent a well-formed application expression.</p><p><em>See also:</em> <strong>analyze_function_name/1</strong>.</p><p><strong></strong> analyze_attribute(Node::syntaxTree()) -&gt; preprocessor | {atom(), atom()}</p><p>Analyzes an attribute node. If <em>Node</em> represents a preprocessor directive, the atom <em>preprocessor</em> is returned. Otherwise, if <em>Node</em> represents a module attribute "<em>-&lt;em&gt;Name&lt;/em&gt;...</em>", a tuple <em>{Name, Info}</em> is returned, where <em>Info</em> depends on <em>Name</em>, as follows:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{module, Info}</em>: where <em>Info = analyze_module_attribute(Node)</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{export, Info}</em>: where <em>Info = analyze_export_attribute(Node)</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{import, Info}</em>: where <em>Info = analyze_import_attribute(Node)</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{file, Info}</em>: where <em>Info = analyze_file_attribute(Node)</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{record, Info}</em>: where <em>Info = analyze_record_attribute(Node)</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{Name, Info}</em>: where <em>{Name, Info} = analyze_wild_attribute(Node)</em>.</p>
  </dd>

</dl>
<p>The evaluation throws <em>syntax_error</em> if <em>Node</em> does not represent a well-formed module attribute.</p><p><em>See also:</em> <strong>analyze_export_attribute/1</strong>, <strong>analyze_file_attribute/1</strong>, <strong>analyze_import_attribute/1</strong>, <strong>analyze_module_attribute/1</strong>, <strong>analyze_record_attribute/1</strong>, <strong>analyze_wild_attribute/1</strong>.</p><p><strong></strong> analyze_export_attribute(Node::syntaxTree()) -&gt; [FunctionName]</p><p>Types:</p><p>FunctionName = atom() | {atom(), integer()} | {ModuleName, FunctionName}</p><p>ModuleName = atom()</p><p>Returns the list of function names declared by an export attribute. We do not guarantee that each name occurs at most once in the list. The order of listing is not defined.</p><p>The evaluation throws <em>syntax_error</em> if <em>Node</em> does not represent a well-formed export attribute.</p><p><em>See also:</em> <strong>analyze_attribute/1</strong>.</p><p><strong></strong> analyze_file_attribute(Node::syntaxTree()) -&gt; {string(), integer()}</p><p>Returns the file name and line number of a <em>file</em> attribute. The result is the pair <em>{File, Line}</em> if <em>Node</em> represents "<em>-file(File, Line).</em>".</p><p>The evaluation throws <em>syntax_error</em> if <em>Node</em> does not represent a well-formed <em>file</em> attribute.</p><p><em>See also:</em> <strong>analyze_attribute/1</strong>.</p><p><strong></strong> analyze_form(Node::syntaxTree()) -&gt; {atom(), term()} | atom()</p><p>Analyzes a "source code form" node. If <em>Node</em> is a "form" type (cf. <em>erl_syntax:is_form/1</em>), the returned value is a tuple <em>{Type, Info}</em> where <em>Type</em> is the node type and <em>Info</em> depends on <em>Type</em>, as follows:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{attribute, Info}</em>: where <em>Info = analyze_attribute(Node)</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{error_marker, Info}</em>: where <em>Info = erl_syntax:error_marker_info(Node)</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{function, Info}</em>: where <em>Info = analyze_function(Node)</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{rule, Info}</em>: where <em>Info = analyze_rule(Node)</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{warning_marker, Info}</em>: where <em>Info = erl_syntax:warning_marker_info(Node)</em>.</p>
  </dd>

</dl>
<p>For other types of forms, only the node type is returned.</p><p>The evaluation throws <em>syntax_error</em> if <em>Node</em> is not well-formed.</p><p><em>See also:</em> <strong>analyze_attribute/1</strong>, <strong>analyze_function/1</strong>, <strong>analyze_rule/1</strong>, <strong>erl_syntax:error_marker_info/1</strong>, <strong>erl_syntax:is_form/1</strong>, <strong>erl_syntax:warning_marker_info/1</strong>.</p><p><strong></strong> analyze_forms(Forms) -&gt; [{Key, term()}]</p><p>Types:</p><p>Forms = syntaxTree() | [syntaxTree()]</p><p>Key = attributes | errors | exports | functions | imports | module | records | rules | warnings</p><p>Analyzes a sequence of "program forms". The given <em>Forms</em> may be a single syntax tree of type <em>form_list</em>, or a list of "program form" syntax trees. The returned value is a list of pairs <em>{Key, Info}</em>, where each value of <em>Key</em> occurs at most once in the list; the absence of a particular key indicates that there is no well-defined value for that key.</p><p>Each entry in the resulting list contains the following corresponding information about the program forms:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{attributes, Attributes}</em>:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>Attributes = [{atom(), term()}]</em></p>
  </dd>

</dl>
<p><em>Attributes</em> is a list of pairs representing the names and corresponding values of all so-called "wild" attributes (as e.g. "<em>-compile(...)</em>") occurring in <em>Forms</em> (cf. <em>analyze_wild_attribute/1</em>). We do not guarantee that each name occurs at most once in the list. The order of listing is not defined.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{errors, Errors}</em>:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>Errors = [term()]</em></p>
  </dd>

</dl>
<p><em>Errors</em> is the list of error descriptors of all <em>error_marker</em> nodes that occur in <em>Forms</em>. The order of listing is not defined.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{exports, Exports}</em>:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>Exports = [FunctionName]</em></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>FunctionName = atom() | {atom(), integer()} | {ModuleName, FunctionName}</em></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>ModuleName = atom()</em></p>
  </dd>

</dl>
<p><em>Exports</em> is a list of representations of those function names that are listed by export declaration attributes in <em>Forms</em> (cf. <em>analyze_export_attribute/1</em>). We do not guarantee that each name occurs at most once in the list. The order of listing is not defined.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{functions, Functions}</em>:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>Functions = [{atom(), integer()}]</em></p>
  </dd>

</dl>
<p><em>Functions</em> is a list of the names of the functions that are defined in <em>Forms</em> (cf. <em>analyze_function/1</em>). We do not guarantee that each name occurs at most once in the list. The order of listing is not defined.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{imports, Imports}</em>:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>Imports = [{Module, Names}]</em></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>Module = atom()</em></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>Names = [FunctionName]</em></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>FunctionName = atom() | {atom(), integer()} | {ModuleName, FunctionName}</em></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>ModuleName = atom()</em></p>
  </dd>

</dl>
<p><em>Imports</em> is a list of pairs representing those module names and corresponding function names that are listed by import declaration attributes in <em>Forms</em> (cf. <em>analyze_import_attribute/1</em>), where each <em>Module</em> occurs at most once in <em>Imports</em>. We do not guarantee that each name occurs at most once in the lists of function names. The order of listing is not defined.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{module, ModuleName}</em>:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>ModuleName = atom()</em></p>
  </dd>

</dl>
<p><em>ModuleName</em> is the name declared by a module attribute in <em>Forms</em>. If no module name is defined in <em>Forms</em>, the result will contain no entry for the <em>module</em> key. If multiple module name declarations should occur, all but the first will be ignored.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{records, Records}</em>:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>Records = [{atom(), Fields}]</em></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>Fields = [{atom(), Default}]</em></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>Default = none | syntaxTree()</em></p>
  </dd>

</dl>
<p><em>Records</em> is a list of pairs representing the names and corresponding field declarations of all record declaration attributes occurring in <em>Forms</em>. For fields declared without a default value, the corresponding value for <em>Default</em> is the atom <em>none</em> (cf. <em>analyze_record_attribute/1</em>). We do not guarantee that each record name occurs at most once in the list. The order of listing is not defined.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{rules, Rules}</em>:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>Rules = [{atom(), integer()}]</em></p>
  </dd>

</dl>
<p><em>Rules</em> is a list of the names of the rules that are defined in <em>Forms</em> (cf. <em>analyze_rule/1</em>). We do not guarantee that each name occurs at most once in the list. The order of listing is not defined.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{warnings, Warnings}</em>:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>Warnings = [term()]</em></p>
  </dd>

</dl>
<p><em>Warnings</em> is the list of error descriptors of all <em>warning_marker</em> nodes that occur in <em>Forms</em>. The order of listing is not defined.</p>
  </dd>

</dl>
<p>The evaluation throws <em>syntax_error</em> if an ill-formed Erlang construct is encountered.</p><p><em>See also:</em> <strong>analyze_export_attribute/1</strong>, <strong>analyze_function/1</strong>, <strong>analyze_import_attribute/1</strong>, <strong>analyze_record_attribute/1</strong>, <strong>analyze_rule/1</strong>, <strong>analyze_wild_attribute/1</strong>, <strong>erl_syntax:error_marker_info/1</strong>, <strong>erl_syntax:warning_marker_info/1</strong>.</p><p><strong></strong> analyze_function(Node::syntaxTree()) -&gt; {atom(), integer()}</p><p>Returns the name and arity of a function definition. The result is a pair <em>{Name, A}</em> if <em>Node</em> represents a function definition "<em>Name(&lt;em&gt;P_1&lt;/em&gt;, ..., &lt;em&gt;P_A&lt;/em&gt;) -&gt; ...</em>".</p><p>The evaluation throws <em>syntax_error</em> if <em>Node</em> does not represent a well-formed function definition.</p><p><em>See also:</em> <strong>analyze_rule/1</strong>.</p><p><strong></strong> analyze_function_name(Node::syntaxTree()) -&gt; FunctionName</p><p>Types:</p><p>FunctionName = atom() | {atom(), integer()} | {ModuleName, FunctionName}</p><p>ModuleName = atom()</p><p>Returns the function name represented by a syntax tree. If <em>Node</em> represents a function name, such as "<em>foo/1</em>" or "<em>bloggs:fred/2</em>", a uniform representation of that name is returned. Different nestings of arity and module name qualifiers in the syntax tree does not affect the result.</p><p>The evaluation throws <em>syntax_error</em> if <em>Node</em> does not represent a well-formed function name.</p><p><strong></strong> analyze_implicit_fun(Node::syntaxTree()) -&gt; FunctionName</p><p>Types:</p><p>FunctionName = atom() | {atom(), integer()} | {ModuleName, FunctionName}</p><p>ModuleName = atom()</p><p>Returns the name of an implicit fun expression "<em>fun &lt;em&gt;F&lt;/em&gt;</em>". The result is a representation of the function name <em>F</em>. (Cf. <em>analyze_function_name/1</em>.)</p><p>The evaluation throws <em>syntax_error</em> if <em>Node</em> does not represent a well-formed implicit fun.</p><p><em>See also:</em> <strong>analyze_function_name/1</strong>.</p><p><strong></strong> analyze_import_attribute(Node::syntaxTree()) -&gt; {atom(), [FunctionName]} | atom()</p><p>Types:</p><p>FunctionName = atom() | {atom(), integer()} | {ModuleName, FunctionName}</p><p>ModuleName = atom()</p><p>Returns the module name and (if present) list of function names declared by an import attribute. The returned value is an atom <em>Module</em> or a pair <em>{Module, Names}</em>, where <em>Names</em> is a list of function names declared as imported from the module named by <em>Module</em>. We do not guarantee that each name occurs at most once in <em>Names</em>. The order of listing is not defined.</p><p>The evaluation throws <em>syntax_error</em> if <em>Node</em> does not represent a well-formed import attribute.</p><p><em>See also:</em> <strong>analyze_attribute/1</strong>.</p><p><strong></strong> analyze_module_attribute(Node::syntaxTree()) -&gt; Name::atom() | {Name::atom(), Variables::[atom()]}</p><p>Returns the module name and possible parameters declared by a module attribute. If the attribute is a plain module declaration such as <em>-module(name)</em>, the result is the module name. If the attribute is a parameterized module declaration, the result is a tuple containing the module name and a list of the parameter variable names.</p><p>The evaluation throws <em>syntax_error</em> if <em>Node</em> does not represent a well-formed module attribute.</p><p><em>See also:</em> <strong>analyze_attribute/1</strong>.</p><p><strong></strong> analyze_record_attribute(Node::syntaxTree()) -&gt; {atom(), Fields}</p><p>Types:</p><p>Fields = [{atom(), none | syntaxTree()}]</p><p>Returns the name and the list of fields of a record declaration attribute. The result is a pair <em>{Name, Fields}</em>, if <em>Node</em> represents "<em>-record(Name, {...}).</em>", where <em>Fields</em> is a list of pairs <em>{Label, Default}</em> for each field "<em>Label</em>" or "<em>Label = &lt;em&gt;Default&lt;/em&gt;</em>" in the declaration, listed in left-to-right order. If the field has no default-value declaration, the value for <em>Default</em> will be the atom <em>none</em>. We do not guarantee that each label occurs at most one in the list.</p><p>The evaluation throws <em>syntax_error</em> if <em>Node</em> does not represent a well-formed record declaration attribute.</p><p><em>See also:</em> <strong>analyze_attribute/1</strong>, <strong>analyze_record_field/1</strong>.</p><p><strong></strong> analyze_record_expr(Node::syntaxTree()) -&gt; {atom(), Info} | atom()</p><p>Types:</p><p>Info = {atom(), [{atom(), Value}]} | {atom(), atom()} | atom()</p><p>Value = none | syntaxTree()</p><p>Returns the record name and field name/names of a record expression. If <em>Node</em> has type <em>record_expr</em>, <em>record_index_expr</em> or <em>record_access</em>, a pair <em>{Type, Info}</em> is returned, otherwise an atom <em>Type</em> is returned. <em>Type</em> is the node type of <em>Node</em>, and <em>Info</em> depends on <em>Type</em>, as follows:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>record_expr</em>:: <em>{atom(), [{atom(), Value}]}</em></p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>record_access</em>:: <em>{atom(), atom()} | atom()</em></p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>record_index_expr</em>:: <em>{atom(), atom()}</em></p>
  </dd>

</dl>
<p>For a <em>record_expr</em> node, <em>Info</em> represents the record name and the list of descriptors for the involved fields, listed in the order they appear. (See <em>analyze_record_field/1</em> for details on the field descriptors). For a <em>record_access</em> node, <em>Info</em> represents the record name and the field name (or if the record name is not included, only the field name; this is allowed only in Mnemosyne-query syntax). For a <em>record_index_expr</em> node, <em>Info</em> represents the record name and the name field name.</p><p>The evaluation throws <em>syntax_error</em> if <em>Node</em> represents a record expression that is not well-formed.</p><p><em>See also:</em> <strong>analyze_record_attribute/1</strong>, <strong>analyze_record_field/1</strong>.</p><p><strong></strong> analyze_record_field(Node::syntaxTree()) -&gt; {atom(), Value}</p><p>Types:</p><p>Value = none | syntaxTree()</p><p>Returns the label and value-expression of a record field specifier. The result is a pair <em>{Label, Value}</em>, if <em>Node</em> represents "<em>Label = &lt;em&gt;Value&lt;/em&gt;</em>" or "<em>Label</em>", where in the first case, <em>Value</em> is a syntax tree, and in the second case <em>Value</em> is <em>none</em>.</p><p>The evaluation throws <em>syntax_error</em> if <em>Node</em> does not represent a well-formed record field specifier.</p><p><em>See also:</em> <strong>analyze_record_attribute/1</strong>, <strong>analyze_record_expr/1</strong>.</p><p><strong></strong> analyze_rule(Node::syntaxTree()) -&gt; {atom(), integer()}</p><p>Returns the name and arity of a Mnemosyne rule. The result is a pair <em>{Name, A}</em> if <em>Node</em> represents a rule "<em>Name(&lt;em&gt;P_1&lt;/em&gt;, ..., &lt;em&gt;P_A&lt;/em&gt;) :- ...</em>".</p><p>The evaluation throws <em>syntax_error</em> if <em>Node</em> does not represent a well-formed Mnemosyne rule.</p><p><em>See also:</em> <strong>analyze_function/1</strong>.</p><p><strong></strong> analyze_wild_attribute(Node::syntaxTree()) -&gt; {atom(), term()}</p><p>Returns the name and value of a "wild" attribute. The result is the pair <em>{Name, Value}</em>, if <em>Node</em> represents "<em>-Name(Value)</em>".</p><p>Note that no checking is done whether <em>Name</em> is a reserved attribute name such as <em>module</em> or <em>export</em>: it is assumed that the attribute is "wild".</p><p>The evaluation throws <em>syntax_error</em> if <em>Node</em> does not represent a well-formed wild attribute.</p><p><em>See also:</em> <strong>analyze_attribute/1</strong>.</p><p><strong></strong> annotate_bindings(Tree::syntaxTree()) -&gt; syntaxTree()</p><p>Adds or updates annotations on nodes in a syntax tree. Equivalent to <em>annotate_bindings(Tree, Bindings)</em> where the top-level environment <em>Bindings</em> is taken from the annotation <em>{env, Bindings}</em> on the root node of <em>Tree</em>. An exception is thrown if no such annotation should exist.</p><p><em>See also:</em> <strong>annotate_bindings/2</strong>.</p><p><strong></strong> annotate_bindings(Tree::syntaxTree(), Bindings::ordset(atom())) -&gt; syntaxTree()</p><p>Adds or updates annotations on nodes in a syntax tree. <em>Bindings</em> specifies the set of bound variables in the environment of the top level node. The following annotations are affected:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{env, Vars}</em>, representing the input environment of the subtree.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{bound, Vars}</em>, representing the variables that are bound in the subtree.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{free, Vars}</em>, representing the free variables in the subtree.</p>
  </dd>

</dl>
<p><em>Bindings</em> and <em>Vars</em> are ordered-set lists (cf. module <em>ordsets</em>) of atoms representing variable names.</p><p><em>See also:</em> <strong>ordsets(3erl)</strong>, <strong>annotate_bindings/1</strong>.</p><p><strong></strong> fold(F::Function, Start::term(), Tree::syntaxTree()) -&gt; term()</p><p>Types:</p><p>Function = (syntaxTree(), term()) -&gt; term()</p><p>Folds a function over all nodes of a syntax tree. The result is the value of <em>Function(X1, Function(X2, ... Function(Xn, Start) ... ))</em>, where <em>[X1, X2, ..., Xn]</em> are the nodes of <em>Tree</em> in a post-order traversal.</p><p><em>See also:</em> <strong>fold_subtrees/3</strong>, <strong>foldl_listlist/3</strong>.</p><p><strong></strong> fold_subtrees(F::Function, Start::term(), Tree::syntaxTree()) -&gt; term()</p><p>Types:</p><p>Function = (syntaxTree(), term()) -&gt; term()</p><p>Folds a function over the immediate subtrees of a syntax tree. This is similar to <em>fold/3</em>, but only on the immediate subtrees of <em>Tree</em>, in left-to-right order; it does not include the root node of <em>Tree</em>.</p><p><em>See also:</em> <strong>fold/3</strong>.</p><p><strong></strong> foldl_listlist(F::Function, Start::term(), Ls::[[term()]]) -&gt; term()</p><p>Types:</p><p>Function = (term(), term()) -&gt; term()</p><p>Like <em>lists:foldl/3</em>, but over a list of lists.</p><p><em>See also:</em> <strong>lists:foldl/3</strong>, <strong>fold/3</strong>.</p><p><strong></strong> function_name_expansions(Names::[Name]) -&gt; [{ShortName, Name}]</p><p>Types:</p><p>Name = ShortName | {atom(), Name}</p><p>ShortName = atom() | {atom(), integer()}</p><p>Creates a mapping from corresponding short names to full function names. Names are represented by nested tuples of atoms and integers (cf. <em>analyze_function_name/1</em>). The result is a list containing a pair <em>{ShortName, Name}</em> for each element <em>Name</em> in the given list, where the corresponding <em>ShortName</em> is the rightmost-innermost part of <em>Name</em>. The list thus represents a finite mapping from unqualified names to the corresponding qualified names.</p><p>Note: the resulting list can contain more than one tuple <em>{ShortName, Name}</em> for the same <em>ShortName</em>, possibly with different values for <em>Name</em>, depending on the given list.</p><p><em>See also:</em> <strong>analyze_function_name/1</strong>.</p><p><strong></strong> is_fail_expr(Tree::syntaxTree()) -&gt; boolean()</p><p>Returns <em>true</em> if <em>Tree</em> represents an expression which never terminates normally. Note that the reverse does not apply. Currently, the detected cases are calls to <em>exit/1</em>, <em>throw/1</em>, <em>erlang:error/1</em> and <em>erlang:error/2</em>.</p><p><em>See also:</em> <strong>erlang:error/1</strong>, <strong>erlang:error/2</strong>, <strong>erlang:exit/1</strong>, <strong>erlang:throw/1</strong>.</p><p><strong></strong> limit(Tree, Depth) -&gt; syntaxTree()</p><p>Equivalent to <em>limit(Tree, Depth, Text)</em> using the text <em>"..."</em> as default replacement.</p><p><em>See also:</em> <strong>limit/3</strong>, <strong>erl_syntax:text/1</strong>.</p><p><strong></strong> limit(Tree::syntaxTree(), Depth::integer(), Node::syntaxTree()) -&gt; syntaxTree()</p><p>Limits a syntax tree to a specified depth. Replaces all non-leaf subtrees in <em>Tree</em> at the given <em>Depth</em> by <em>Node</em>. If <em>Depth</em> is negative, the result is always <em>Node</em>, even if <em>Tree</em> has no subtrees.</p><p>When a group of subtrees (as e.g., the argument list of an <em>application</em> node) is at the specified depth, and there are two or more subtrees in the group, these will be collectively replaced by <em>Node</em> even if they are leaf nodes. Groups of subtrees that are above the specified depth will be limited in size, as if each subsequent tree in the group were one level deeper than the previous. E.g., if <em>Tree</em> represents a list of integers "<em>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</em>", the result of <em>limit(Tree, 5)</em> will represent <em>[1, 2, 3, 4, ...]</em>.</p><p>The resulting syntax tree is typically only useful for pretty-printing or similar visual formatting.</p><p><em>See also:</em> <strong>limit/2</strong>.</p><p><strong></strong> map(F::Function, Tree::syntaxTree()) -&gt; syntaxTree()</p><p>Types:</p><p>Function = (syntaxTree()) -&gt; syntaxTree()</p><p>Applies a function to each node of a syntax tree. The result of each application replaces the corresponding original node. The order of traversal is bottom-up.</p><p><em>See also:</em> <strong>map_subtrees/2</strong>.</p><p><strong></strong> map_subtrees(F::Function, Tree::syntaxTree()) -&gt; syntaxTree()</p><p>Types:</p><p>Function = (Tree) -&gt; Tree1</p><p>Applies a function to each immediate subtree of a syntax tree. The result of each application replaces the corresponding original node.</p><p><em>See also:</em> <strong>map/2</strong>.</p><p><strong></strong> mapfold(F::Function, Start::term(), Tree::syntaxTree()) -&gt; {syntaxTree(), term()}</p><p>Types:</p><p>Function = (syntaxTree(), term()) -&gt; {syntaxTree(), term()}</p><p>Combines map and fold in a single operation. This is similar to <em>map/2</em>, but also propagates an extra value from each application of the <em>Function</em> to the next, while doing a post-order traversal of the tree like <em>fold/3</em>. The value <em>Start</em> is passed to the first function application, and the final result is the result of the last application.</p><p><em>See also:</em> <strong>fold/3</strong>, <strong>map/2</strong>.</p><p><strong></strong> mapfold_subtrees(F::Function, Start::term(), Tree::syntaxTree()) -&gt; {syntaxTree(), term()}</p><p>Types:</p><p>Function = (syntaxTree(), term()) -&gt; {syntaxTree(), term()}</p><p>Does a mapfold operation over the immediate subtrees of a syntax tree. This is similar to <em>mapfold/3</em>, but only on the immediate subtrees of <em>Tree</em>, in left-to-right order; it does not include the root node of <em>Tree</em>.</p><p><em>See also:</em> <strong>mapfold/3</strong>.</p><p><strong></strong> mapfoldl_listlist(F::Function, S::State, Ls::[[term()]]) -&gt; {[[term()]], term()}</p><p>Types:</p><p>Function = (term(), term()) -&gt; {term(), term()}</p><p>Like <em>lists:mapfoldl/3</em>, but over a list of lists. The list of lists in the result has the same structure as the given list of lists.</p><p><strong></strong> new_variable_name(Used::set(atom())) -&gt; atom()</p><p>Returns an atom which is not already in the set <em>Used</em>. This is equivalent to <em>new_variable_name(Function, Used)</em>, where <em>Function</em> maps a given integer <em>N</em> to the atom whose name consists of "<em>V</em>" followed by the numeral for <em>N</em>.</p><p><em>See also:</em> <strong>new_variable_name/2</strong>.</p><p><strong></strong> new_variable_name(F::Function, Used::set(atom())) -&gt; atom()</p><p>Types:</p><p>Function = (integer()) -&gt; atom()</p><p>Returns a user-named atom which is not already in the set <em>Used</em>. The atom is generated by applying the given <em>Function</em> to a generated integer. Integers are generated using an algorithm which tries to keep the names randomly distributed within a reasonably small range relative to the number of elements in the set.</p><p>This function uses the module <em>random</em> to generate new keys. The seed it uses may be initialized by calling <em>random:seed/0</em> or <em>random:seed/3</em> before this function is first called.</p><p><em>See also:</em> <strong>random(3erl)</strong>, <strong>sets(3erl)</strong>, <strong>new_variable_name/1</strong>.</p><p><strong></strong> new_variable_names(N::integer(), Used::set(atom())) -&gt; [atom()]</p><p>Like <em>new_variable_name/1</em>, but generates a list of <em>N</em> new names.</p><p><em>See also:</em> <strong>new_variable_name/1</strong>.</p><p><strong></strong> new_variable_names(N::integer(), F::Function, Used::set(atom())) -&gt; [atom()]</p><p>Types:</p><p>Function = (integer()) -&gt; atom()</p><p>Like <em>new_variable_name/2</em>, but generates a list of <em>N</em> new names.</p><p><em>See also:</em> <strong>new_variable_name/2</strong>.</p><p><strong></strong> strip_comments(Tree::syntaxTree()) -&gt; syntaxTree()</p><p>Removes all comments from all nodes of a syntax tree. All other attributes (such as position information) remain unchanged. Standalone comments in form lists are removed; any other standalone comments are changed into null-comments (no text, no indentation).</p><p><strong></strong> to_comment(Tree) -&gt; syntaxTree()</p><p>Equivalent to <strong>to_comment(Tree, "% ")</strong>.</p><p><strong></strong> to_comment(Tree::syntaxTree(), Prefix::string()) -&gt; syntaxTree()</p><p>Equivalent to <em>to_comment(Tree, Prefix, F)</em> for a default formatting function <em>F</em>. The default <em>F</em> simply calls <em>erl_prettypr:format/1</em>.</p><p><em>See also:</em> <strong>to_comment/3</strong>, <strong>erl_prettypr:format/1</strong>.</p><p><strong></strong> to_comment(Tree::syntaxTree(), Prefix::string(), F::Printer) -&gt; syntaxTree()</p><p>Types:</p><p>Printer = (syntaxTree()) -&gt; string()</p><p>Transforms a syntax tree into an abstract comment. The lines of the comment contain the text for <em>Node</em>, as produced by the given <em>Printer</em> function. Each line of the comment is prefixed by the string <em>Prefix</em> (this does not include the initial "<em>%</em>" character of the comment line).</p><p>For example, the result of <em>to_comment(erl_syntax:abstract([a,b,c]))</em> represents</p>
<pre>
          %% [a,b,c]
</pre>
<p>(cf. <em>to_comment/1</em>).</p><p>Note: the text returned by the formatting function will be split automatically into separate comment lines at each line break. No extra work is needed.</p><p><em>See also:</em> <strong>to_comment/1</strong>, <strong>to_comment/2</strong>.</p><p><strong></strong> variables(Tree::syntaxTree()) -&gt; set(atom())</p><p>Types:</p><p>set(T) (see module //stdlib/sets)</p><p>Returns the names of variables occurring in a syntax tree, The result is a set of variable names represented by atoms. Macro names are not included.</p><p><em>See also:</em> <strong>sets(3erl)</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p>Richard Carlsson <em></em> &lt;carlsson.richard@gmail.com&gt;</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="erl_syntax.3erl.html"><span aria-hidden="true">&larr;</span> erl_syntax.3erl: Abstract erlang syntax trees.</a></li>
   <li class="next"><a href="erl_tar.3erl.html">erl_tar.3erl: Unix 'tar' utility for reading and writing tar archives <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>unicode: Functions for converting unicode characters</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Functions for converting unicode characters">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="unicode (3erl) manual">
  <meta name="twitter:description" content="Functions for converting unicode characters">
  <meta name="twitter:image" content="https://www.carta.tech/images/erlang-manpages-unicode-3erl.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3erl/unicode.3erl.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="unicode (3erl) manual" />
  <meta property="og:description" content="Functions for converting unicode characters" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/erlang-manpages-unicode-3erl.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">unicode<small> (3erl)</small></h1>
        <p class="lead">Functions for converting unicode characters</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/unicode.3erl.html">
      <span itemprop="name">unicode: Functions for converting unicode characters</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/erlang-manpages/">
      <span itemprop="name">erlang-manpages</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/unicode.3erl.html">
      <span itemprop="name">unicode: Functions for converting unicode characters</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module contains functions for converting between different character representations. Basically it converts between ISO-latin-1 characters and Unicode ditto, but it can also convert between different Unicode encodings (like UTF-8, UTF-16 and UTF-32).</p><p>The default Unicode encoding in Erlang is in binaries UTF-8, which is also the format in which built in functions and libraries in OTP expect to find binary Unicode data. In lists, Unicode data is encoded as integers, each integer representing one character and encoded simply as the Unicode codepoint for the character.</p><p>Other Unicode encodings than integers representing codepoints or UTF-8 in binaries are referred to as "external encodings". The ISO-latin-1 encoding is in binaries and lists referred to as latin1-encoding.</p><p>It is recommended to only use external encodings for communication with external entities where this is required. When working inside the Erlang/OTP environment, it is recommended to keep binaries in UTF-8 when representing Unicode characters. Latin1 encoding is supported both for backward compatibility and for communication with external entities not supporting Unicode character sets.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DATA TYPES</h2>
        <div class="sectioncontent">

<pre>
<strong>encoding()</strong> = latin1

           | unicode

           | utf8

           | utf16

           | {utf16, <strong>endian()</strong>}

           | utf32

           | {utf32, <strong>endian()</strong>}

</pre>

<pre>
<strong>endian()</strong> = big | little

</pre>

<pre>
<strong>unicode_binary()</strong> = binary()

</pre>
<p>A <em>binary()</em> with characters encoded in the UTF-8 coding standard.</p>
<pre>
<strong>chardata()</strong> = <strong>charlist()</strong> | <strong>unicode_binary()</strong>

</pre>

<pre>
<strong>charlist()</strong> =

    maybe_improper_list(char() | <strong>unicode_binary()</strong> | <strong>charlist()</strong>,

                        <strong>unicode_binary()</strong> | [])

</pre>

<pre>
<strong>external_unicode_binary()</strong> = binary()

</pre>
<p>A <em>binary()</em> with characters coded in a user specified Unicode encoding other than UTF-8 (UTF-16 or UTF-32).</p>
<pre>
<strong>external_chardata()</strong> = <strong>external_charlist()</strong>

                    | <strong>external_unicode_binary()</strong>

</pre>

<pre>
<strong>external_charlist()</strong> =

    maybe_improper_list(char() |

                        <strong>external_unicode_binary()</strong> |

                        <strong>external_charlist()</strong>,

                        <strong>external_unicode_binary()</strong> | [])

</pre>

<pre>
<strong>latin1_binary()</strong> = binary()

</pre>
<p>A <em>binary()</em> with characters coded in ISO-latin-1.</p>
<pre>
<strong>latin1_char()</strong> = byte()

</pre>
<p>An <em>integer()</em> representing valid latin1 character (0-255).</p>
<pre>
<strong>latin1_chardata()</strong> = <strong>latin1_charlist()</strong> | <strong>latin1_binary()</strong>

</pre>
<p>The same as <em>iodata()</em>.</p>
<pre>
<strong>latin1_charlist()</strong> =

    maybe_improper_list(<strong>latin1_char()</strong> |

                        <strong>latin1_binary()</strong> |

                        <strong>latin1_charlist()</strong>,

                        <strong>latin1_binary()</strong> | [])

</pre>
<p>The same as <em>iolist()</em>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">

<pre>
<strong></strong>
bom_to_encoding(Bin) -&gt; {Encoding, Length}

</pre>
<p>Types:</p><p>Bin = binary()</p><p> A <em>binary()</em> such that <em>byte_size(Bin) &gt;= 4</em>.</p><p>Encoding = latin1</p>
<pre>
         | utf8
</pre>

<pre>
         | {utf16, <strong>endian()</strong>}
</pre>

<pre>
         | {utf32, <strong>endian()</strong>}
</pre>
<p>Length = integer() &gt;= 0</p>
<pre>
<strong>endian()</strong> = big | little
</pre>
<p>Check for a UTF byte order mark (BOM) in the beginning of a binary. If the supplied binary <em>Bin</em> begins with a valid byte order mark for either UTF-8, UTF-16 or UTF-32, the function returns the encoding identified along with the length of the BOM in bytes.</p><p>If no BOM is found, the function returns <em>{latin1,0}</em></p>
<pre>
<strong></strong>
characters_to_list(Data) -&gt; Result

</pre>
<p>Types:</p><p>Data = <strong>latin1_chardata()</strong> | <strong>chardata()</strong> | <strong>external_chardata()</strong></p><p>Result = list()</p>
<pre>
       | {error, list(), RestData}
</pre>

<pre>
       | {incomplete, list(), binary()}
</pre>
<p>RestData = <strong>latin1_chardata()</strong> | <strong>chardata()</strong> | <strong>external_chardata()</strong></p><p>Same as <em>characters_to_list(Data, unicode)</em>.</p>
<pre>
<strong></strong>
characters_to_list(Data, InEncoding) -&gt; Result

</pre>
<p>Types:</p><p>Data = <strong>latin1_chardata()</strong> | <strong>chardata()</strong> | <strong>external_chardata()</strong></p><p>InEncoding = <strong>encoding()</strong></p><p>Result = list()</p>
<pre>
       | {error, list(), RestData}
</pre>

<pre>
       | {incomplete, list(), binary()}
</pre>
<p>RestData = <strong>latin1_chardata()</strong> | <strong>chardata()</strong> | <strong>external_chardata()</strong></p><p>Converts a possibly deep list of integers and binaries into a list of integers representing Unicode characters. The binaries in the input may have characters encoded as latin1 (0 - 255, one character per byte), in which case the <em>InEncoding</em> parameter should be given as <em>latin1</em>, or have characters encoded as one of the UTF-encodings, which is given as the <em>InEncoding</em> parameter. Only when the <em>InEncoding</em> is one of the UTF encodings, integers in the list are allowed to be grater than 255.</p><p>If <em>InEncoding</em> is <em>latin1</em>, the <em>Data</em> parameter corresponds to the <em>iodata()</em> type, but for <em>unicode</em>, the <em>Data</em> parameter can contain integers greater than 255 (Unicode characters beyond the ISO-latin-1 range), which would make it invalid as <em>iodata()</em>.</p><p>The purpose of the function is mainly to be able to convert combinations of Unicode characters into a pure Unicode string in list representation for further processing. For writing the data to an external entity, the reverse function <strong></strong><em>characters_to_binary/3</em> comes in handy.</p><p>The option <em>unicode</em> is an alias for <em>utf8</em>, as this is the preferred encoding for Unicode characters in binaries. <em>utf16</em> is an alias for <em>{utf16,big}</em> and <em>utf32</em> is an alias for <em>{utf32,big}</em>. The <em>big</em> and <em>little</em> atoms denote big or little endian encoding.</p><p>If for some reason, the data cannot be converted, either because of illegal Unicode/latin1 characters in the list, or because of invalid UTF encoding in any binaries, an error tuple is returned. The error tuple contains the tag <em>error</em>, a list representing the characters that could be converted before the error occurred and a representation of the characters including and after the offending integer/bytes. The last part is mostly for debugging as it still constitutes a possibly deep and/or mixed list, not necessarily of the same depth as the original data. The error occurs when traversing the list and whatever is left to decode is simply returned as is.</p><p>However, if the input <em>Data</em> is a pure binary, the third part of the error tuple is guaranteed to be a binary as well.</p><p>Errors occur for the following reasons:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>Integers out of range - If <em>InEncoding</em> is <em>latin1</em>, an error occurs whenever an integer greater than 255 is found in the lists. If <em>InEncoding</em> is of a Unicode type, an error occurs whenever an integer</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>greater than <em>16#10FFFF</em> (the maximum Unicode character),</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>in the range <em>16#D800</em> to <em>16#DFFF</em> (invalid range reserved for UTF-16 surrogate pairs)</p>
  </dd>

</dl>
<p> is found.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>UTF encoding incorrect - If <em>InEncoding</em> is one of the UTF types, the bytes in any binaries have to be valid in that encoding. Errors can occur for various reasons, including "pure" decoding errors (like the upper bits of the bytes being wrong), the bytes are decoded to a too large number, the bytes are decoded to a code-point in the invalid Unicode range, or encoding is "overlong", meaning that a number should have been encoded in fewer bytes. The case of a truncated UTF is handled specially, see the paragraph about incomplete binaries below. If <em>InEncoding</em> is <em>latin1</em>, binaries are always valid as long as they contain whole bytes, as each byte falls into the valid ISO-latin-1 range.</p>
  </dd>

</dl>
<p>A special type of error is when no actual invalid integers or bytes are found, but a trailing <em>binary()</em> consists of too few bytes to decode the last character. This error might occur if bytes are read from a file in chunks or binaries in other ways are split on non UTF character boundaries. In this case an <em>incomplete</em> tuple is returned instead of the <em>error</em> tuple. It consists of the same parts as the <em>error</em> tuple, but the tag is <em>incomplete</em> instead of <em>error</em> and the last element is always guaranteed to be a binary consisting of the first part of a (so far) valid UTF character.</p><p>If one UTF characters is split over two consecutive binaries in the <em>Data</em>, the conversion succeeds. This means that a character can be decoded from a range of binaries as long as the whole range is given as input without errors occurring. Example:</p>
<pre>
     decode_data(Data) -&gt;
         case unicode:characters_to_list(Data,unicode) of
             {incomplete,Encoded, Rest} -&gt;
	           More = get_some_more_data(),
		   Encoded ++ decode_data([Rest, More]);
	     {error,Encoded,Rest} -&gt;
	           handle_error(Encoded,Rest);
             List -&gt;
	           List
         end.

</pre>
<p>Bit-strings that are not whole bytes are however not allowed, so a UTF character has to be split along 8-bit boundaries to ever be decoded.</p><p>If any parameters are of the wrong type, the list structure is invalid (a number as tail) or the binaries do not contain whole bytes (bit-strings), a <em>badarg</em> exception is thrown.</p>
<pre>
<strong></strong>
characters_to_binary(Data) -&gt; Result

</pre>
<p>Types:</p><p>Data = <strong>latin1_chardata()</strong> | <strong>chardata()</strong> | <strong>external_chardata()</strong></p><p>Result = binary()</p>
<pre>
       | {error, binary(), RestData}
</pre>

<pre>
       | {incomplete, binary(), binary()}
</pre>
<p>RestData = <strong>latin1_chardata()</strong> | <strong>chardata()</strong> | <strong>external_chardata()</strong></p><p>Same as <em>characters_to_binary(Data, unicode, unicode)</em>.</p>
<pre>
<strong></strong>
characters_to_binary(Data, InEncoding) -&gt; Result

</pre>
<p>Types:</p><p>Data = <strong>latin1_chardata()</strong> | <strong>chardata()</strong> | <strong>external_chardata()</strong></p><p>InEncoding = <strong>encoding()</strong></p><p>Result = binary()</p>
<pre>
       | {error, binary(), RestData}
</pre>

<pre>
       | {incomplete, binary(), binary()}
</pre>
<p>RestData = <strong>latin1_chardata()</strong> | <strong>chardata()</strong> | <strong>external_chardata()</strong></p><p>Same as <em>characters_to_binary(Data, InEncoding, unicode)</em>.</p>
<pre>
<strong></strong>
characters_to_binary(Data, InEncoding, OutEncoding) -&gt; Result

</pre>
<p>Types:</p><p>Data = <strong>latin1_chardata()</strong> | <strong>chardata()</strong> | <strong>external_chardata()</strong></p><p>InEncoding = OutEncoding = <strong>encoding()</strong></p><p>Result = binary()</p>
<pre>
       | {error, binary(), RestData}
</pre>

<pre>
       | {incomplete, binary(), binary()}
</pre>
<p>RestData = <strong>latin1_chardata()</strong> | <strong>chardata()</strong> | <strong>external_chardata()</strong></p><p>Behaves as <strong></strong><em>characters_to_list/2</em>, but produces an binary instead of a Unicode list. The <em>InEncoding</em> defines how input is to be interpreted if binaries are present in the <em>Data</em>, while <em>OutEncoding</em> defines in what format output is to be generated.</p><p>The option <em>unicode</em> is an alias for <em>utf8</em>, as this is the preferred encoding for Unicode characters in binaries. <em>utf16</em> is an alias for <em>{utf16,big}</em> and <em>utf32</em> is an alias for <em>{utf32,big}</em>. The <em>big</em> and <em>little</em> atoms denote big or little endian encoding.</p><p>Errors and exceptions occur as in <strong></strong><em>characters_to_list/2</em>, but the second element in the <em>error</em> or <em>incomplete</em> tuple will be a <em>binary()</em> and not a <em>list()</em>.</p>
<pre>
<strong></strong>
encoding_to_bom(InEncoding) -&gt; Bin

</pre>
<p>Types:</p><p>Bin = binary()</p><p> A <em>binary()</em> such that <em>byte_size(Bin) &gt;= 4</em>.</p><p>InEncoding = <strong>encoding()</strong></p><p>Create a UTF byte order mark (BOM) as a binary from the supplied <em>InEncoding</em>. The BOM is, if supported at all, expected to be placed first in UTF encoded files or messages.</p><p>The function returns <em>&lt;&lt;&gt;&gt;</em> for the <em>latin1</em> encoding as there is no BOM for ISO-latin-1.</p><p>It can be noted that the BOM for UTF-8 is seldom used, and it is really not a <em>byte order</em> mark. There are obviously no byte order issues with UTF-8, so the BOM is only there to differentiate UTF-8 encoding from other UTF formats.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="ttb.3erl.html"><span aria-hidden="true">&larr;</span> ttb.3erl: A base for building trace tools for distributed systems.</a></li>
   <li class="next"><a href="unix_telnet.3erl.html">unix_telnet.3erl: Callback module for ct_telnet, for connecting to a telnet server on a unix host. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

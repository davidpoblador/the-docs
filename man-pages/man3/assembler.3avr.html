<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>assembler: Avr-libc and assembler programs</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Avr-libc and assembler programs">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="assembler (3avr) manual">
  <meta name="twitter:description" content="Avr-libc and assembler programs">
  <meta name="twitter:image" content="https://www.carta.tech/images/avr-libc-assembler-3avr.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3avr/assembler.3avr.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="assembler (3avr) manual" />
  <meta property="og:description" content="Avr-libc and assembler programs" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/avr-libc-assembler-3avr.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">assembler<small> (3avr)</small></h1>
        <p class="lead">Avr-libc and assembler programs</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3avr/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3avr/assembler.3avr.html">
      <span itemprop="name">assembler: Avr-libc and assembler programs</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/avr-libc/">
      <span itemprop="name">avr-libc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3avr/assembler.3avr.html">
      <span itemprop="name">assembler: Avr-libc and assembler programs</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">Introduction</h2>
        <div class="sectioncontent">
<p>There might be several reasons to write code for AVR microcontrollers using plain assembler source code. Among them are:</p><ul>
<li><p>Code for devices that do not have RAM and are thus not supported by the C compiler.</p></li><li><p>Code for very time-critical applications.</p></li><li><p>Special tweaks that cannot be done in C.</p></li>
</ul><p>Usually, all but the first could probably be done easily using the <strong>inline assembler</strong> facility of the compiler.</p><p>Although avr-libc is primarily targeted to support programming AVR microcontrollers using the C (and C++) language, there's limited support for direct assembler usage as well. The benefits of it are:</p><ul>
<li><p>Use of the C preprocessor and thus the ability to use the same symbolic constants that are available to C programs, as well as a flexible macro concept that can use any valid C identifier as a macro (whereas the assembler's macro concept is basically targeted to use a macro in place of an assembler instruction).</p></li><li><p>Use of the runtime framework like automatically assigning interrupt vectors. For devices that have RAM, <strong>initializing the RAM variables</strong> can also be utilized.</p></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Invoking the compiler</h2>
        <div class="sectioncontent">
<p>For the purpose described in this document, the assembler and linker are usually not invoked manually, but rather using the C compiler frontend (avr-gcc) that in turn will call the assembler and linker as required.</p><p>This approach has the following advantages:</p><ul>
<li><p>There is basically only one program to be called directly, avr-gcc, regardless of the actual source language used.</p></li><li><p>The invokation of the C preprocessor will be automatic, and will include the appropriate options to locate required include files in the filesystem.</p></li><li><p>The invokation of the linker will be automatic, and will include the appropriate options to locate additional libraries as well as the application start-up code (crt<em>XXX</em>.o<em>) and linker script.</em></p></li>
</ul><p>Note that the invokation of the C preprocessor will be automatic when the filename provided for the assembler file ends in .S (the capital letter 's'). This would even apply to operating systems that use case-insensitive filesystems since the actual decision is made based on the case of the filename suffix given on the command-line, not based on the actual filename from the file system.</p><p>Alternatively, the language can explicitly be specified using the -x assembler-with-cpp option.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Example program</h2>
        <div class="sectioncontent">
<p>The following annotated example features a simple 100 kHz square wave generator using an AT90S1200 clocked with a 10.7 MHz crystal. Pin PD6 will be used for the square wave output.</p>
<pre>
#include &lt;avr/io.h&gt;             ; Note [1]

work    =       16              ; Note [2]
tmp     =       17

inttmp  =       19

intsav  =       0

SQUARE  =       PD6             ; Note [3]

                                ; Note [4]:
tmconst= 10700000 / 200000      ; 100 kHz =&gt; 200000 edges/s
fuzz=   8                       ; # clocks in ISR until TCNT0 is set

        .section .text

        .global main                            ; Note [5]
main:
        rcall   ioinit
1:
        rjmp    1b                              ; Note [6]

        .global TIMER0_OVF_vect                 ; Note [7]
TIMER0_OVF_vect:
        ldi     inttmp, 256 - tmconst + fuzz
        out     _SFR_IO_ADDR(TCNT0), inttmp     ; Note [8]

        in      intsav, _SFR_IO_ADDR(SREG)      ; Note [9]

        sbic    _SFR_IO_ADDR(PORTD), SQUARE
        rjmp    1f
        sbi     _SFR_IO_ADDR(PORTD), SQUARE
        rjmp    2f
1:      cbi     _SFR_IO_ADDR(PORTD), SQUARE
2:

        out     _SFR_IO_ADDR(SREG), intsav
        reti

ioinit:
        sbi     _SFR_IO_ADDR(DDRD), SQUARE

        ldi     work, _BV(TOIE0)
        out     _SFR_IO_ADDR(TIMSK), work

        ldi     work, _BV(CS00)         ; tmr0:  CK/1
        out     _SFR_IO_ADDR(TCCR0), work

        ldi     work, 256 - tmconst
        out     _SFR_IO_ADDR(TCNT0), work

        sei

        ret

        .global __vector_default                ; Note [10]
__vector_default:
        reti

        .end
</pre>
<p><strong>Note [1]</strong></p><p>As in C programs, this includes the central processor-specific file containing the IO port definitions for the device. Note that not all include files can be included into assembler sources.</p><p><strong>Note [2]</strong></p><p>Assignment of registers to symbolic names used locally. Another option would be to use a C preprocessor macro instead:</p>
<pre>
#define work 16
</pre>
<p><strong>Note [3]</strong></p><p>Our bit number for the square wave output. Note that the right-hand side consists of a CPP macro which will be substituted by its value (6 in this case) before actually being passed to the assembler.</p><p><strong>Note [4]</strong></p><p>The assembler uses integer operations in the host-defined integer size (32 bits or longer) when evaluating expressions. This is in contrast to the C compiler that uses the C type int by default in order to calculate constant integer expressions.</p><p> In order to get a 100 kHz output, we need to toggle the PD6 line 200000 times per second. Since we use timer 0 without any prescaling options in order to get the desired frequency and accuracy, we already run into serious timing considerations: while accepting and processing the timer overflow interrupt, the timer already continues to count. When pre-loading the TCCNT0 register, we therefore have to account for the number of clock cycles required for interrupt acknowledge and for the instructions to reload TCCNT0 (4 clock cycles for interrupt acknowledge, 2 cycles for the jump from the interrupt vector, 2 cycles for the 2 instructions that reload TCCNT0). This is what the constant fuzz is for.</p><p><strong>Note [5]</strong></p><p>External functions need to be declared to be .global. main is the application entry point that will be jumped to from the ininitalization routine in crts1200.o.</p><p><strong>Note [6]</strong></p><p>The main loop is just a single jump back to itself. Square wave generation itself is completely handled by the timer 0 overflow interrupt service. A sleep instruction (using idle mode) could be used as well, but probably would not conserve much energy anyway since the interrupt service is executed quite frequently.</p><p><strong>Note [7]</strong></p><p>Interrupt functions can get the <strong>usual names</strong> that are also available to C programs. The linker will then put them into the appropriate interrupt vector slots. Note that they must be declared <strong>.global in order to be acceptable for this purpose. This will only work if &lt;</strong><strong>avr/io.h</strong><strong>&gt;</strong><strong> has been included. Note that the assembler or linker have no chance to check the correct spelling of an interrupt function, so it should be double-checked. (When analyzing the resulting object file using avr-objdump</strong><strong> or avr-nm</strong><strong>, a name like __vector_</strong><em>N</em><strong></strong><em> should appear, with </em><em>N</em><em> being a small integer number.)</em></p><p><strong>Note [8]</strong></p><p>As explained in the section about <strong>special function registers</strong>, the actual IO port address should be obtained using the macro _SFR_IO_ADDR<strong>. (The AT90S1200 does not have RAM thus the memory-mapped approach to access the IO registers is not available. It would be slower than using in</strong> / out<strong> instructions anyway.)</strong></p><p> Since the operation to reload TCCNT0 is time-critical, it is even performed before saving SREG. Obviously, this requires that the instructions involved would not change any of the flag bits in SREG.</p><p><strong>Note [9]</strong></p><p>Interrupt routines must not clobber the global CPU state. Thus, it is usually necessary to save at least the state of the flag bits in SREG. (Note that this serves as an example here only since actually, all the following instructions would not modify SREG either, but that's not commonly the case.)</p><p> Also, it must be made sure that registers used inside the interrupt routine do not conflict with those used outside. In the case of a RAM-less device like the AT90S1200, this can only be done by agreeing on a set of registers to be used exclusively inside the interrupt routine; there would not be any other chance to 'save' a register anywhere.</p><p> If the interrupt routine is to be linked together with C modules, care must be taken to follow the <strong>register usage guidelines</strong> imposed by the C compiler. Also, any register modified inside the interrupt sevice needs to be saved, usually on the stack.</p><p><strong>Note [10]</strong></p><p>As explained in <strong>Interrupts</strong>, a global 'catch-all' interrupt handler that gets all unassigned interrupt vectors can be installed using the name __vector_default<strong>. This must be </strong>.global, and obviously, should end in a reti<strong> instruction. (By default, a jump to location 0 would be implied instead.)</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Pseudo-ops and operators</h2>
        <div class="sectioncontent">
<p>The available pseudo-ops in the assembler are described in the GNU assembler (gas) manual. The manual can be found online as part of the current binutils release under http://sources.redhat.com/binutils/.</p><p>As gas comes from a Unix origin, its pseudo-op and overall assembler syntax is slightly different than the one being used by other assemblers. Numeric constants follow the C notation (prefix 0x for hexadecimal constants), expressions use a C-like syntax.</p><p>Some common pseudo-ops include:</p><ul>
<li><p>.byte allocates single byte constants</p></li><li><p>.ascii allocates a non-terminated string of characters</p></li><li><p>.asciz allocates a &#92;0-terminated string of characters (C string)</p></li><li><p>.data switches to the .data section (initialized RAM variables)</p></li><li><p>.text switches to the .text section (code and ROM constants)</p></li><li><p>.set declares a symbol as a constant expression (identical to .equ)</p></li><li><p>.global (or .globl) declares a public symbol that is visible to the linker (e. g. function entry point, global variable)</p></li><li><p>.extern declares a symbol to be externally defined; this is effectively a comment only, as gas treats all undefined symbols it encounters as globally undefined anyway</p></li>
</ul><p>Note that .org is available in gas as well, but is a fairly pointless pseudo-op in an assembler environment that uses relocatable object files, as it is the linker that determines the final position of some object in ROM or RAM.</p><p>Along with the architecture-independent standard operators, there are some AVR-specific operators available which are unfortunately not yet described in the official documentation. The most notable operators are:</p><ul>
<li><p>lo8 Takes the least significant 8 bits of a 16-bit integer</p></li><li><p>hi8 Takes the most significant 8 bits of a 16-bit integer</p></li><li><p>pm Takes a program-memory (ROM) address, and converts it into a RAM address. This implies a division by 2 as the AVR handles ROM addresses as 16-bit words (e.g. in an IJMP or ICALL instruction), and can also handle relocatable symbols on the right-hand side.</p></li>
</ul><p>Example:</p>
<pre>
        ldi     r24, lo8(pm(somefunc))
        ldi     r25, hi8(pm(somefunc))
        call    something

</pre>
<p>This passes the address of function somefunc as the first parameter to function something.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="asmdemo.3avr.html"><span aria-hidden="true">&larr;</span> asmdemo.3avr: For time- or space-critical applications, it can often be desirable to combine c code (for easy maintenance) and assembly code (for maximal speed or minimal code size) together. this demo provides an example of how to do that.  the objective of the demo is to decode radio-controlled model pwm signals, and control an output pwm based on the current input signal's value. the incoming pwm pulses follow a standard encoding scheme where a pulse width of 920 microseconds denotes one end of the scale (represented as 0 % pulse width on output), and 2120 microseconds mark the other end (100 % output pwm). normally, multiple channels would be encoded that way in subsequent pulses, followed by a larger gap, so the entire frame will repeat each 14 through 20 ms, but this is ignored for the purpose of the demo, so only a single input pwm channel is assumed.  the basic challenge is to use the cheapest controller available for the task, an attiny13 that has only a single timer channel. as this timer channel is required to run the outgoing pwm signal generation, the incoming pwm decoding had to be adjusted to the constraints set by the outgoing pwm.  as pwm generation toggles the counting direction of timer 0 between up and down after each 256 timer cycles, the current time cannot be deduced by reading tcnt0 only, but the current counting direction of the timer needs to be considered as well. this requires servicing interrupts whenever the timer hits top (255) and bottom (0) to learn about each change of the counting direction. for pwm generation, it is usually desired to run it at the highest possible speed so filtering the pwm frequency from the modulated output signal is made easy. thus, the pwm timer runs at full cpu speed. this causes the overflow and compare match interrupts to be triggered each 256 cpu clocks, so they must run with the minimal number of processor cycles possible in order to not impose a too high cpu load by these interrupt service routines. this is the main reason to implement the entire interrupt handling in fine-tuned assembly code rather than in c.  in order to verify parts of the algorithm, and the underlying hardware, the demo has been set up in a way so the pin-compatible but more expensive attiny45 (or its siblings attiny25 and attiny85) could be used as well. in that case, no separate assembly code is required, as two timer channels are avaible.</a></li>
   <li class="next"><a href="assert.3avr.html">assert.3avr: Assert.h: diagnostics - <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

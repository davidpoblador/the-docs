<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>crypto: Crypto functions</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Crypto functions">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="crypto (3erl) manual">
  <meta name="twitter:description" content="Crypto functions">
  <meta name="twitter:image" content="https://www.carta.tech/images/erlang-manpages-crypto-3erl.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3erl/crypto.3erl.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="crypto (3erl) manual" />
  <meta property="og:description" content="Crypto functions" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/erlang-manpages-crypto-3erl.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">crypto<small> (3erl)</small></h1>
        <p class="lead">Crypto functions</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/crypto.3erl.html">
      <span itemprop="name">crypto: Crypto functions</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/erlang-manpages/">
      <span itemprop="name">erlang-manpages</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/crypto.3erl.html">
      <span itemprop="name">crypto: Crypto functions</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module provides a set of cryptographic functions.</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>Hash functions -  Secure Hash Standard,  The MD5 Message Digest Algorithm (RFC 1321) and The MD4 Message Digest Algorithm (RFC 1320)</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>Hmac functions -  Keyed-Hashing for Message Authentication (RFC 2104)</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>Block ciphers - DES and AES in Block Cipher Modes -  ECB, CBC, CFB, OFB and CTR</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p> RSA encryption RFC 1321</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>Digital signatures Digital Signature Standard (DSS) and Elliptic Curve Digital Signature Algorithm (ECDSA)</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p> Secure Remote Password Protocol (SRP - RFC 2945)</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DATA TYPES </h2>
        <div class="sectioncontent">

<pre>
key_value()  = integer() | binary()
</pre>
<p>Always <em>binary()</em> when used as return value</p>
<pre>
rsa_public()  = [key_value()] = [E, N]
</pre>
<p>Where E is the public exponent and N is public modulus.</p>
<pre>
rsa_private() = [key_value()] = [E, N, D] | [E, N, D, P1, P2, E1, E2, C]
</pre>
<p>Where E is the public exponent, N is public modulus and D is the private exponent.The longer key format contains redundant information that will make the calculation faster. P1,P2 are first and second prime factors. E1,E2 are first and second exponents. C is the CRT coefficient. Terminology is taken from  RFC 3447.</p>
<pre>
dss_public() = [key_value()] = [P, Q, G, Y]
</pre>
<p>Where P, Q and G are the dss parameters and Y is the public key.</p>
<pre>
dss_private() =  [key_value()] = [P, Q, G, X]
</pre>
<p>Where P, Q and G are the dss parameters and X is the private key.</p>
<pre>
srp_public() = key_value()
</pre>
<p>Where is <em>A</em> or <em>B</em> from SRP design</p>
<pre>
srp_private() = key_value()
</pre>
<p>Where is <em>a</em> or <em>b</em> from SRP design</p><p>Where Verifier is <em>v</em>, Generator is <em>g</em> and Prime is<em> N</em>, DerivedKey is <em>X</em>, and Scrambler is <em>u</em> (optional will be generated if not provided) from SRP design Version = '3' | '6' | '6a'</p>
<pre>
dh_public() = key_value()
</pre>

<pre>
dh_private() = key_value()
</pre>

<pre>
dh_params() = [key_value()] = [P, G]
</pre>

<pre>
ecdh_public() = key_value()
</pre>

<pre>
ecdh_private() = key_value()
</pre>

<pre>
ecdh_params() =  ec_named_curve() | ec_explicit_curve()
</pre>

<pre>
ec_explicit_curve() =
    {ec_field(), Prime :: key_value(), Point :: key_value(), Order :: integer(), CoFactor :: none | integer()}
</pre>

<pre>
ec_field() = {prime_field, Prime :: integer()} |
    {characteristic_two_field, M :: integer(), Basis :: ec_basis()}
</pre>

<pre>
ec_basis() =  {tpbasis, K :: non_neg_integer()} |
    {ppbasis, K1 :: non_neg_integer(), K2 :: non_neg_integer(), K3 :: non_neg_integer()} |
    onbasis
</pre>

<pre>
ec_named_curve() -&gt;
      sect571r1| sect571k1| sect409r1| sect409k1| secp521r1| secp384r1| secp224r1| secp224k1|
      secp192k1| secp160r2| secp128r2| secp128r1| sect233r1| sect233k1| sect193r2| sect193r1|
      sect131r2| sect131r1| sect283r1| sect283k1| sect163r2| secp256k1| secp160k1| secp160r1|
      secp112r2| secp112r1| sect113r2| sect113r1| sect239k1| sect163r1| sect163k1| secp256r1|
      secp192r1|
      brainpoolP160r1| brainpoolP160t1| brainpoolP192r1| brainpoolP192t1| brainpoolP224r1|
      brainpoolP224t1| brainpoolP256r1| brainpoolP256t1| brainpoolP320r1| brainpoolP320t1|
      brainpoolP384r1| brainpoolP384t1| brainpoolP512r1| brainpoolP512t1

</pre>

<pre>
stream_cipher() = rc4 | aes_ctr
</pre>

<pre>
block_cipher() =  aes_cbc128 | aes_cfb8 | aes_cfb128 | aes_ige256 | blowfish_cbc |
     blowfish_cfb64 | des_cbc | des_cfb | des3_cbc | des3_cbf
     | des_ede3 | rc2_cbc
</pre>

<pre>
stream_key() =  aes_key() | rc4_key()
</pre>

<pre>
block_key() =  aes_key() |  blowfish_key() | des_key()| des3_key()
</pre>

<pre>
aes_key() = iodata()
</pre>

<pre>
rc4_key() = iodata()
</pre>

<pre>
blowfish_key() = iodata()
</pre>

<pre>
des_key() = iodata()
</pre>

<pre>
des3_key() = [binary(), binary(), binary()]
</pre>

<pre>
digest_type() =  md5 | sha | sha224 | sha256 | sha384 | sha512
</pre>

<pre>
 hash_algorithms() =  md5 | ripemd160 | sha | sha224 | sha256 | sha384 | sha512
</pre>

<pre>
 cipher_algorithms() = des_cbc | des_cfb |  des3_cbc | des3_cbf | des_ede3 |
     blowfish_cbc | blowfish_cfb64 | aes_cbc128 | aes_cfb8 | aes_cfb128| aes_cbc256 | aes_ige256 | rc2_cbc | aes_ctr| rc4
</pre>

<pre>
 public_key_algorithms() =   rsa |dss | ecdsa | dh | ecdh | ec_gf2m
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">
<p><strong></strong> block_encrypt(Type, Key, Ivec, PlainText) -&gt; CipherText</p><p>Types:</p><p>Type = block_cipher()</p><p>Key = block_key()</p><p>PlainText = iodata()</p><p>IVec = CipherText = binary()</p><p>Encrypt <em>PlainText</em>according to <em>Type</em> block cipher. <em>IVec</em> is an arbitrary initializing vector.</p><p>May throw exception <em>notsup</em> in case the chosen <em>Type</em> is not supported by the underlying OpenSSL implementation.</p><p><strong></strong> block_decrypt(Type, Key, Ivec, CipherText) -&gt; PlainText</p><p>Types:</p><p>Type = block_cipher()</p><p>Key = block_key()</p><p>PlainText = iodata()</p><p>IVec = CipherText = binary()</p><p>Decrypt <em>CipherText</em>according to <em>Type</em> block cipher. <em>IVec</em> is an arbitrary initializing vector.</p><p>May throw exception <em>notsup</em> in case the chosen <em>Type</em> is not supported by the underlying OpenSSL implementation.</p><p><strong></strong> bytes_to_integer(Bin) -&gt; Integer</p><p>Types:</p><p>Bin = binary() - as returned by crypto functions</p><p>Integer = integer()</p><p>Convert binary representation, of an integer, to an Erlang integer.</p><p><strong></strong> compute_key(Type, OthersPublicKey, MyKey, Params) -&gt; SharedSecret</p><p>Types:</p><p> Type = dh | ecdh | srp</p><p>OthersPublicKey = dh_public() | ecdh_public() | srp_public()</p><p>MyKey = dh_private() | ecdh_private() | {srp_public(),srp_private()}</p><p>Params = dh_params() | ecdh_params() | SrpUserParams | SrpHostParams</p><p>SrpUserParams = {user, [DerivedKey::binary(), Prime::binary(), Generator::binary(), Version::atom() | [Scrambler:binary()]]}</p><p>SrpHostParams = {host, [Verifier::binary(), Prime::binary(), Version::atom() | [Scrambler::binary]]}</p><p>SharedSecret = binary()</p><p>Computes the shared secret from the private key and the other party's public key. See also <strong>public_key:compute_key/2</strong></p><p><strong></strong> exor(Data1, Data2) -&gt; Result</p><p>Types:</p><p>Data1, Data2 = iodata()</p><p>Result = binary()</p><p>Performs bit-wise XOR (exclusive or) on the data supplied.</p><p><strong></strong> generate_key(Type, Params) -&gt; {PublicKey, PrivKeyOut}</p><p><strong></strong> generate_key(Type, Params, PrivKeyIn) -&gt; {PublicKey, PrivKeyOut}</p><p>Types:</p><p> Type = dh | ecdh | srp</p><p>Params = dh_params() | ecdh_params() | SrpUserParams | SrpHostParams</p><p>SrpUserParams = {user, [Generator::binary(), Prime::binary(), Version::atom()]}</p><p>SrpHostParams = {host, [Verifier::binary(), Generator::binary(), Prime::binary(), Version::atom()]}</p><p>PublicKey = dh_public() | ecdh_public() | srp_public()</p><p>PrivKeyIn = undefined | dh_private() | srp_private()</p><p>PrivKeyOut = dh_private() | ecdh_private() | srp_private()</p><p>Generates public keys of type <em>Type</em>. See also <strong>public_key:generate_key/1</strong></p><p><strong></strong> hash(Type, Data) -&gt; Digest</p><p>Types:</p><p>Type = md4 | hash_algorithms()</p><p>Data = iodata()</p><p>Digest = binary()</p><p>Computes a message digest of type <em>Type</em> from <em>Data</em>.</p><p>May throw exception <em>notsup</em> in case the chosen <em>Type</em> is not supported by the underlying OpenSSL implementation.</p><p><strong></strong> hash_init(Type) -&gt; Context</p><p>Types:</p><p>Type = md4 | hash_algorithms()</p><p>Initializes the context for streaming hash operations. <em>Type</em> determines which digest to use. The returned context should be used as argument to <strong>hash_update</strong>.</p><p>May throw exception <em>notsup</em> in case the chosen <em>Type</em> is not supported by the underlying OpenSSL implementation.</p><p><strong></strong> hash_update(Context, Data) -&gt; NewContext</p><p>Types:</p><p>Data = iodata()</p><p>Updates the digest represented by <em>Context</em> using the given <em>Data</em>. <em>Context</em> must have been generated using <strong>hash_init</strong> or a previous call to this function. <em>Data</em> can be any length. <em>NewContext</em> must be passed into the next call to <em>hash_update</em> or <strong>hash_final</strong>.</p><p><strong></strong> hash_final(Context) -&gt; Digest</p><p>Types:</p><p>Digest = binary()</p><p>Finalizes the hash operation referenced by <em>Context</em> returned from a previous call to <strong>hash_update</strong>. The size of <em>Digest</em> is determined by the type of hash function used to generate it.</p><p><strong></strong> hmac(Type, Key, Data) -&gt; Mac</p><p><strong></strong> hmac(Type, Key, Data, MacLength) -&gt; Mac</p><p>Types:</p><p>Type = hash_algorithms() - except ripemd160</p><p>Key = iodata()</p><p>Data = iodata()</p><p>MacLength = integer()</p><p>Mac = binary()</p><p>Computes a HMAC of type <em>Type</em> from <em>Data</em> using <em>Key</em> as the authentication key.<em>MacLength</em> will limit the size of the resultant <em>Mac</em>.</p><p><strong></strong> hmac_init(Type, Key) -&gt; Context</p><p>Types:</p><p>Type = hash_algorithms() - except ripemd160</p><p>Key = iodata()</p><p>Context = binary()</p><p>Initializes the context for streaming HMAC operations. <em>Type</em> determines which hash function to use in the HMAC operation. <em>Key</em> is the authentication key. The key can be any length.</p><p><strong></strong> hmac_update(Context, Data) -&gt; NewContext</p><p>Types:</p><p>Context = NewContext = binary()</p><p>Data = iodata()</p><p>Updates the HMAC represented by <em>Context</em> using the given <em>Data</em>. <em>Context</em> must have been generated using an HMAC init function (such as <strong>hmac_init</strong>). <em>Data</em> can be any length. <em>NewContext</em> must be passed into the next call to <em>hmac_update</em> or to one of the functions <strong>hmac_final</strong> and <strong>hmac_final_n</strong></p><p><strong></strong> Warning:</p><p>Do not use a <em>Context</em> as argument in more than one call to hmac_update or hmac_final. The semantics of reusing old contexts in any way is undefined and could even crash the VM in earlier releases. The reason for this limitation is a lack of support in the underlying OpenSSL API.</p><p><strong></strong> hmac_final(Context) -&gt; Mac</p><p>Types:</p><p>Context = Mac = binary()</p><p>Finalizes the HMAC operation referenced by <em>Context</em>. The size of the resultant MAC is determined by the type of hash function used to generate it.</p><p><strong></strong> hmac_final_n(Context, HashLen) -&gt; Mac</p><p>Types:</p><p>Context = Mac = binary()</p><p>HashLen = non_neg_integer()</p><p>Finalizes the HMAC operation referenced by <em>Context</em>. <em>HashLen</em> must be greater than zero. <em>Mac</em> will be a binary with at most <em>HashLen</em> bytes. Note that if HashLen is greater than the actual number of bytes returned from the underlying hash, the returned hash will have fewer than <em>HashLen</em> bytes.</p><p><strong></strong> info_lib() -&gt; [{Name,VerNum,VerStr}]</p><p>Types:</p><p>Name = binary()</p><p>VerNum = integer()</p><p>VerStr = binary()</p><p>Provides the name and version of the libraries used by crypto.</p><p><em>Name</em> is the name of the library. <em>VerNum</em> is the numeric version according to the library's own versioning scheme. <em>VerStr</em> contains a text variant of the version.</p>
<pre>
&gt; info_lib().
[{&lt;&lt;"OpenSSL"&gt;&gt;,9469983,&lt;&lt;"OpenSSL 0.9.8a 11 Oct 2005"&gt;&gt;}]

</pre>
<p><strong></strong> Note:</p><p>From OTP R16 the <em>numeric version</em> represents the version of the OpenSSL <em>header files</em> (<em>openssl/opensslv.h</em>) used when crypto was compiled. The text variant represents the OpenSSL library used at runtime. In earlier OTP versions both numeric and text was taken from the library.</p><p><strong></strong> mod_pow(N, P, M) -&gt; Result</p><p>Types:</p><p>N, P, M = binary() | integer()</p><p>Result = binary() | error</p><p>Computes the function <em>N^P mod M</em>.</p><p><strong></strong> next_iv(Type, Data) -&gt; NextIVec</p><p><strong></strong> next_iv(Type, Data, IVec) -&gt; NextIVec</p><p>Types:</p><p>Type = des_cbc | des3_cbc | aes_cbc | des_cfb</p><p>Data = iodata()</p><p>IVec = NextIVec = binary()</p><p>Returns the initialization vector to be used in the next iteration of encrypt/decrypt of type <em>Type</em>. <em>Data</em> is the encrypted data from the previous iteration step. The <em>IVec</em> argument is only needed for <em>des_cfb</em> as the vector used in the previous iteration step.</p><p><strong></strong> private_decrypt(Type, CipherText, PrivateKey, Padding) -&gt; PlainText</p><p>Types:</p><p>Type = rsa</p><p>CipherText = binary()</p><p>PrivateKey = rsa_private()</p><p>Padding = rsa_pkcs1_padding | rsa_pkcs1_oaep_padding | rsa_no_padding</p><p>PlainText = binary()</p><p>Decrypts the <em>CipherText</em>, encrypted with <strong>public_encrypt/4</strong> (or equivalent function) using the <em>PrivateKey</em>, and returns the plaintext (message digest). This is a low level signature verification operation used for instance by older versions of the SSL protocol. See also <strong>public_key:decrypt_private/[2,3]</strong></p><p><strong></strong> private_encrypt(Type, PlainText, PrivateKey, Padding) -&gt; CipherText</p><p>Types:</p><p>Type = rsa</p><p>PlainText = binary()</p><p> The size of the <em>PlainText</em> must be less than <em>byte_size(N)-11</em> if <em>rsa_pkcs1_padding</em> is used, and <em>byte_size(N)</em> if <em>rsa_no_padding</em> is used, where N is public modulus of the RSA key.</p><p>PrivateKey = rsa_private()</p><p>Padding = rsa_pkcs1_padding | rsa_no_padding</p><p>CipherText = binary()</p><p>Encrypts the <em>PlainText</em> using the <em>PrivateKey</em> and returns the ciphertext. This is a low level signature operation used for instance by older versions of the SSL protocol. See also <strong>public_key:encrypt_private/[2,3]</strong></p><p><strong></strong> public_decrypt(Type, CipherText, PublicKey, Padding) -&gt; PlainText</p><p>Types:</p><p>Type = rsa</p><p>CipherText = binary()</p><p>PublicKey = rsa_public()</p><p>Padding = rsa_pkcs1_padding | rsa_no_padding</p><p>PlainText = binary()</p><p>Decrypts the <em>CipherText</em>, encrypted with <strong>private_encrypt/4</strong>(or equivalent function) using the <em>PrivateKey</em>, and returns the plaintext (message digest). This is a low level signature verification operation used for instance by older versions of the SSL protocol. See also <strong>public_key:decrypt_public/[2,3]</strong></p><p><strong></strong> public_encrypt(Type, PlainText, PublicKey, Padding) -&gt; CipherText</p><p>Types:</p><p>Type = rsa</p><p>PlainText = binary()</p><p> The size of the <em>PlainText</em> must be less than <em>byte_size(N)-11</em> if <em>rsa_pkcs1_padding</em> is used, and <em>byte_size(N)</em> if <em>rsa_no_padding</em> is used, where N is public modulus of the RSA key.</p><p>PublicKey = rsa_public()</p><p>Padding = rsa_pkcs1_padding | rsa_pkcs1_oaep_padding | rsa_no_padding</p><p>CipherText = binary()</p><p>Encrypts the <em>PlainText</em> (message digest) using the <em>PublicKey</em> and returns the <em>CipherText</em>. This is a low level signature operation used for instance by older versions of the SSL protocol. See also <strong>public_key:encrypt_public/[2,3]</strong></p><p><strong></strong> rand_bytes(N) -&gt; binary()</p><p>Types:</p><p>N = integer()</p><p>Generates N bytes randomly uniform 0..255, and returns the result in a binary. Uses the <em>crypto</em> library pseudo-random number generator.</p><p><strong></strong> rand_seed(Seed) -&gt; ok</p><p>Types:</p><p>Seed = binary()</p><p>Set the seed for PRNG to the given binary. This calls the RAND_seed function from openssl. Only use this if the system you are running on does not have enough "randomness" built in. Normally this is when <strong> stong_rand_bytes/1</strong> returns <em>low_entropy</em></p><p><strong></strong> rand_uniform(Lo, Hi) -&gt; N</p><p>Types:</p><p>Lo, Hi, N = integer()</p><p>Generate a random number <em>N, Lo =&lt; N &lt; Hi.</em> Uses the <em>crypto</em> library pseudo-random number generator. <em>Hi</em> must be larger than <em>Lo</em>.</p><p><strong></strong> sign(Algorithm, DigestType, Msg, Key) -&gt; binary()</p><p>Types:</p><p>Algorithm = rsa | dss | ecdsa</p><p>Msg = binary() | {digest,binary()}</p><p>The msg is either the binary "cleartext" data to be signed or it is the hashed value of "cleartext" i.e. the digest (plaintext).</p><p>DigestType = digest_type()</p><p>Key = rsa_private() | dss_private() | [ecdh_private(),ecdh_params()]</p><p>Creates a digital signature.</p><p>Algorithm <em>dss</em> can only be used together with digest type <em>sha</em>. See also <strong>public_key:sign/3</strong></p><p><strong></strong> start() -&gt; ok</p><p>Equivalent to application:start(crypto).</p><p><strong></strong> stop() -&gt; ok</p><p>Equivalent to application:stop(crypto).</p><p><strong></strong> strong_rand_bytes(N) -&gt; binary()</p><p>Types:</p><p>N = integer()</p><p>Generates N bytes randomly uniform 0..255, and returns the result in a binary. Uses a cryptographically secure prng seeded and periodically mixed with operating system provided entropy. By default this is the <em>RAND_bytes</em> method from OpenSSL.</p><p>May throw exception <em>low_entropy</em> in case the random generator failed due to lack of secure "randomness".</p><p><strong></strong> stream_init(Type, Key) -&gt; State</p><p>Types:</p><p>Type = rc4</p><p>State = opaque()</p><p>Key = iodata()</p><p>Initializes the state for use in RC4 stream encryption <strong>stream_encrypt</strong> and <strong>stream_decrypt</strong></p><p><strong></strong> stream_init(Type, Key, IVec) -&gt; State</p><p>Types:</p><p>Type = aes_ctr</p><p>State = opaque()</p><p>Key = iodata()</p><p>IVec = binary()</p><p>Initializes the state for use in streaming AES encryption using Counter mode (CTR). <em>Key</em> is the AES key and must be either 128, 192, or 256 bts long. <em>IVec</em> is an arbitrary initializing vector of 128 bits (16 bytes). This state is for use with <strong>stream_encrypt</strong> and <strong>stream_decrypt</strong>.</p><p><strong></strong> stream_encrypt(State, PlainText) -&gt; { NewState, CipherText}</p><p>Types:</p><p>Text = iodata()</p><p>CipherText = binary()</p><p>Encrypts <em>PlainText</em> according to the stream cipher <em>Type</em> specified in stream_init/3. <em>Text</em> can be any number of bytes. The initial <em>State</em> is created using <strong>stream_init</strong>. <em>NewState</em> must be passed into the next call to <em>stream_encrypt</em>.</p><p><strong></strong> stream_decrypt(State, CipherText) -&gt; { NewState, PlainText }</p><p>Types:</p><p>CipherText = iodata()</p><p>PlainText = binary()</p><p>Decrypts <em>CipherText</em> according to the stream cipher <em>Type</em> specified in stream_init/3. <em>PlainText</em> can be any number of bytes. The initial <em>State</em> is created using <strong>stream_init</strong>. <em>NewState</em> must be passed into the next call to <em>stream_encrypt</em>.</p><p><strong></strong> supports() -&gt; AlgorithmList</p><p>Types:</p><p> AlgorithmList = [{hashs, [hash_algorithms()]}, {ciphers, [cipher_algorithms()]}, {public_keys, [public_key_algorithms()]}</p><p>Can be used to determine which crypto algorithms that are supported by the underlying OpenSSL library</p><p><strong></strong> ec_curves() -&gt; EllipticCurveList</p><p>Types:</p><p>EllipticCurveList = [ec_named_curve()]</p><p>Can be used to determine which named elliptic curves are supported.</p><p><strong></strong> ec_curve(NamedCurve) -&gt; EllipticCurve</p><p>Types:</p><p>NamedCurve = ec_named_curve()</p><p>EllipticCurve = ec_explicit_curve()</p><p>Return the defining parameters of a elliptic curve.</p><p><strong></strong> verify(Algorithm, DigestType, Msg, Signature, Key) -&gt; boolean()</p><p>Types:</p><p> Algorithm = rsa | dss | ecdsa</p><p>Msg = binary() | {digest,binary()}</p><p>The msg is either the binary "cleartext" data or it is the hashed value of "cleartext" i.e. the digest (plaintext).</p><p>DigestType = digest_type()</p><p>Signature = binary()</p><p>Key = rsa_public() | dss_public() | [ecdh_public(),ecdh_params()]</p><p>Verifies a digital signature</p><p>Algorithm <em>dss</em> can only be used together with digest type <em>sha</em>. See also <strong>public_key:verify/4</strong></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="crashdump.3erl.html"><span aria-hidden="true">&larr;</span> crashdump.3erl: A wxwidgets based tool for browsing erlang</a></li>
   <li class="next"><a href="ct.3erl.html">ct.3erl: Main user interface for the common test framework. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>HTML::Encoding: Determine the encoding of html/xml/xhtml documents</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Determine the encoding of html/xml/xhtml documents">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="HTML::Encoding (3pm) manual">
  <meta name="twitter:description" content="Determine the encoding of html/xml/xhtml documents">
  <meta name="twitter:image" content="https://www.carta.tech/images/libhtml-encoding-perl-HTML::Encoding-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/HTML::Encoding.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="HTML::Encoding (3pm) manual" />
  <meta property="og:description" content="Determine the encoding of html/xml/xhtml documents" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libhtml-encoding-perl-HTML::Encoding-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">HTML::Encoding<small> (3pm)</small></h1>
        <p class="lead">Determine the encoding of html/xml/xhtml documents</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/HTML::Encoding.3pm.html">
      <span itemprop="name">HTML::Encoding: Determine the encoding of html/xml/xhtml documents</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libhtml-encoding-perl/">
      <span itemprop="name">libhtml-encoding-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/HTML::Encoding.3pm.html">
      <span itemprop="name">HTML::Encoding: Determine the encoding of html/xml/xhtml documents</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  use HTML::Encoding &apos;encoding_from_http_message&apos;;
  use LWP::UserAgent;
  use Encode;

  my $resp = LWP::UserAgent-&gt;new-&gt;get(&apos;http://www.example.org&apos;);
  my $enco = encoding_from_http_message($resp);
  my $utf8 = decode($enco =&gt; $resp-&gt;content);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">WARNING</h2>
        <div class="sectioncontent">
<p>The interface and implementation are guranteed to change before this module reaches version 1.00! Please send feedback to the author of this module.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>HTML::Encoding helps to determine the encoding of \s-1HTML\s0 and \s-1XML/XHTML\s0 documents...</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DEFAULT ENCODINGS</h2>
        <div class="sectioncontent">
<p>Most routines need to know some suspected character encodings which can be provided through the \*(C`encodings\*(C' option. This option always defaults to the $HTML::Encoding::DEFAULT_ENCODINGS array reference which means the following encodings are considered by default:</p><p>  * ISO-8859-1   * UTF-16LE   * UTF-16BE   * UTF-32LE   * UTF-32BE   * UTF-8</p><p>If you change the values or pass custom values to the routines note that Encode must support them in order for this module to work correctly.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ENCODING SOURCES</h2>
        <div class="sectioncontent">
<p>\*(C`encoding_from_xml_document\*(C', \*(C`encoding_from_html_document\*(C', and \*(C`encoding_from_http_message\*(C' return in list context the encoding source and the encoding name, possible encoding sources are</p><p>  * protocol         (Content-Type: text/html;charset=encoding)   * bom              (leading U+FEFF)   * xml              (&lt;?xml version=&apos;1.0&apos; encoding=&apos;encoding&apos;?&gt;)   * meta             (&lt;meta http-equiv=...)   * default          (default fallback value)   * protocol_default (protocol default)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ROUTINES</h2>
        <div class="sectioncontent">
<p>Routines exported by this module at user option. By default, nothing is exported.</p>
<dl class='dl-vertical'>
  <dt>
    encoding_from_content_type($content_type)
  </dt>
  <dd>
    <p>Takes a byte string and uses HTTP::Headers::Util to extract the charset parameter from the \*(C`Content-Type\*(C' header value and returns its value or \*(C`undef\*(C' (or an empty list in list context) if there is no such value. Only the first component will be examined (\s-1HTTP/1\s0.1 only allows for one component), any backslash escapes in strings will be unescaped, all leading and trailing quote marks and white-space characters will be removed, all white-space will be collapsed to a single space, empty charset values will be ignored and no case folding is performed. Examples:   +-----------------------------------------+-----------+   | encoding_from_content_type(...)         | returns   |   +-----------------------------------------+-----------+   | "text/html"                             | undef     |   | "text/html,text/plain;charset=utf-8"    | undef     |   | "text/html;charset="                    | undef     |   | "text/html;charset=&#92;"&#92;&#92;u&#92;&#92;t&#92;&#92;f&#92;&#92;-&#92;&#92;8&#92;"" | &apos;utf-8&apos;   |   | "text/html;charset=utf&#92;&#92;-8"             | &apos;utf&#92;&#92;-8&apos; |   | "text/html;charset=&apos;utf-8&apos;"             | &apos;utf-8&apos;   |   | "text/html;charset=&#92;" UTF-8 &#92;""         | &apos;UTF-8&apos;   |   +-----------------------------------------+-----------+ If you pass a string with the \s-1UTF-8\s0 flag turned on the string will be converted to bytes before it is passed to HTTP::Headers::Util. The return value will thus never have the \s-1UTF-8\s0 flag turned on (this might change in future versions). Takes a sequence of octets and attempts to read a byte order mark at the beginning of the octet sequence. It will go through the list of $options{encodings} or the list of default encodings if no encodings are specified and match the beginning of the string against any byte order mark octet sequence found. The result can be ambiguous, for example qq(&#92;xFF&#92;xFE&#92;x00&#92;x00) could be both, a complete \s-1BOM\s0 in \s-1UTF-32LE\s0 or a \s-1UTF-16LE\s0 \s-1BOM\s0 followed by a U+0000 character. It is also possible that $octets starts with something that looks like a byte order mark but actually is not. encoding_from_byte_order_mark sorts the list of possible encodings by the length of their \s-1BOM\s0 octet sequence and returns in scalar context only the encoding with the longest match, and all encodings ordered by length of their \s-1BOM\s0 octet sequence in list context. Examples:   +-------------------------+------------+-----------------------+   | Input                   | Encodings  | Result                |   +-------------------------+------------+-----------------------+   | "&#92;xFF&#92;xFE&#92;x00&#92;x00"      | default    | qw(UTF-32LE)          |   | "&#92;xFF&#92;xFE&#92;x00&#92;x00"      | default    | qw(UTF-32LE UTF-16LE) |   | "&#92;xEF&#92;xBB&#92;xBF"          | default    | qw(UTF-8)             |   | "Hello World!"          | default    | undef                 |   | "&#92;xDD&#92;x73&#92;x66&#92;x73"      | default    | undef                 |   | "&#92;xDD&#92;x73&#92;x66&#92;x73"      | UTF-EBCDIC | qw(UTF-EBCDIC)        |   | "&#92;x2B&#92;x2F&#92;x76&#92;x38&#92;x2D"  | default    | undef                 |   | "&#92;x2B&#92;x2F&#92;x76&#92;x38&#92;x2D"  | UTF-7      | qw(UTF-7)             |   +-------------------------+------------+-----------------------+ Note however that for \s-1UTF-7\s0 it is in theory possible that the U+FEFF combines with other characters in which case such detection would fail, for example consider:   +--------------------------------------+-----------+-----------+   | Input                                | Encodings | Result    |   +--------------------------------------+-----------+-----------+   | "&#92;x2B&#92;x2F&#92;x76&#92;x38&#92;x41&#92;x39&#92;x67&#92;x2D"   | default   | undef     |   | "&#92;x2B&#92;x2F&#92;x76&#92;x38&#92;x41&#92;x39&#92;x67&#92;x2D"   | UTF-7     | undef     |   +--------------------------------------+-----------+-----------+ This might change in future versions, although this is not very relevant for most applications as there should never be need to use \s-1UTF-7\s0 in the encoding list for existing documents. If no \s-1BOM\s0 can be found it returns \*(C`undef\*(C' in scalar context and an empty list in list context. This routine should not be used with strings with the \s-1UTF-8\s0 flag turned on.</p>
  </dd>
  <dt>
    encoding_from_xml_declaration($declaration)
  </dt>
  <dd>
    <p>Attempts to extract the value of the encoding pseudo-attribute in an \s-1XML\s0 declaration or text declaration in the character string $declaration. If there does not appear to be such a value it returns nothing. This would typically be used with the return values of xml_declaration_from_octets. Normalizes whitespaces like encoding_from_content_type. Examples:   +-------------------------------------------+---------+   | encoding_from_xml_declaration(...)        | Result  |   +-------------------------------------------+---------+   | "&lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt;"  | &apos;utf-8&apos; |   | "&lt;?xml encoding=&apos;utf-8&apos;?&gt;"                | &apos;utf-8&apos; |   | "&lt;?xml encoding=&#92;"utf-8&#92;"?&gt;"              | &apos;utf-8&apos; |   | "&lt;?xml foo=&apos;bar&apos; encoding=&apos;utf-8&apos;?&gt;"      | &apos;utf-8&apos; |   | "&lt;?xml encoding=&apos;a&apos; encoding=&apos;b&apos;?&gt;"       | &apos;a&apos;     |   | "&lt;?xml encoding=&apos; a    b &apos;?&gt;"             | &apos;a b&apos;   |   | "&lt;?xml-stylesheet encoding=&apos;utf-8&apos;?&gt;"     | undef   |   | " &lt;?xml encoding=&apos;utf-8&apos;?&gt;"               | undef   |   | "&lt;?xml encoding =&#92;x{2028}&apos;utf-8&apos;?&gt;"       | &apos;utf-8&apos; |   | "&lt;?xml version=&apos;1.0&apos; encoding=utf-8?&gt;"    | undef   |   | "&lt;?xml x=&apos;encoding=&#92;"a&#92;"&apos; encoding=&apos;b&apos;?&gt;" | &apos;a&apos;     |   +-------------------------------------------+---------+ Note that <em>encoding_from_xml_declaration()</em> determines the encoding even if the \s-1XML\s0 declaration is not well-formed or violates other requirements of the relevant \s-1XML\s0 specification as long as it can find an encoding pseudo-attribute in the provided string. This means \s-1XML\s0 processors must apply further checks to determine whether the entity is well-formed, etc. Attempts to find a \*(L"&gt;\*(R" character in the byte string $octets using the encodings in $encodings and upon success attempts to find a preceding \*(L"&lt;\*(R" character. Returns all the strings found this way in the order of number of successful matches in list context and the best match in scalar context. Should probably be combined with the only user of this routine, encoding_from_xml_declaration... You can modify the list of suspected encodings using $options{encodings}; Assuming that documents start with \*(L"&lt;\*(R" optionally preceded by whitespace characters, encoding_from_first_chars attempts to determine an encoding by matching $octets against something like /^[@{$options{whitespace}}]*&lt;/ in the various suspected $options{encodings}. This is useful to distinguish e.g. \s-1UTF-16LE\s0 from \s-1UTF-8\s0 if the byte string does not start with a byte order mark nor an \s-1XML\s0 declaration (e.g. if the document is a \s-1HTML\s0 document) to get at least a base encoding which can be used to decode enough of the document to find &lt;meta&gt; elements using encoding_from_meta_element. $options{whitespace} defaults to qw/CR \s-1LF\s0 \s-1SP\s0 \s-1TB/\s0. Returns nothing if unsuccessful. Returns the matching encodings in order of the number of octets matched in list context and the best match in scalar context. Examples:   +---------------+----------+---------------------+   | String        | Encoding | Result              |   +---------------+----------+---------------------+   | &apos;&lt;!DOCTYPE &apos;  | UTF-16LE | UTF-16LE            |   | &apos; &lt;!DOCTYPE &apos; | UTF-16LE | UTF-16LE            |   | &apos;...&apos;         | UTF-16LE | undef               |   | &apos;...&lt;&apos;        | UTF-16LE | undef               |   | &apos;&lt;&apos;           | UTF-8    | ISO-8859-1 or UTF-8 |   | "&lt;!--&#92;xF6--&gt;" | UTF-8    | ISO-8859-1 or UTF-8 |   +---------------+----------+---------------------+ Attempts to find &lt;meta&gt; elements in the document using HTML::Parser. It will attempt to decode chunks of the byte string using $encname to characters before passing the data to HTML::Parser. An optional %options hash can be provided which will be passed to the HTML::Parser constructor. It will stop processing the document if it encounters   * &lt;/head&gt;   * encoding errors   * the end of the input   * ... (see todo) If relevant &lt;meta&gt; elements, i.e. something like   &lt;meta http-equiv=Content-Type content=&apos;...&apos;&gt; are found, uses encoding_from_content_type to extract the charset parameter. It returns all such encodings it could find in document order in list context or the first encoding in scalar context (it will currently look for others regardless of calling context) or nothing if that fails for some reason. Note that there are many edge cases where this does not yield in \*(L"proper\*(R" results depending on the capabilities of the HTML::Parser version and the options you pass for it, for example,   &lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" [     &lt;!ENTITY content_type "text/html;charset=utf-8"&gt;   ]&gt;   &lt;meta http-equiv="Content-Type" content="&content_type;"&gt;   &lt;title&gt;&lt;/title&gt;   &lt;p&gt;...&lt;/p&gt; This would likely not detect the \*(C`utf-8\*(C' value if HTML::Parser does not resolve the entity. This should however only be a concern for documents specifically crafted to break the encoding detection. Uses encoding_from_byte_order_mark to detect the encoding using a byte order mark in the byte string and returns the return value of that routine if it succeeds. Uses xml_declaration_from_octets and encoding_from_xml_declaration and returns the encoding for which the latter routine found most matches in scalar context, and all encodings ordered by number of occurences in list context. It does not return a value of neither byte order mark not inbound declarations declare a character encoding. Examples:   +----------------------------+----------+-----------+----------+   | Input                      | Encoding | Encodings | Result   |   +----------------------------+----------+-----------+----------+   | "&lt;?xml?&gt;"                  | UTF-16   | default   | UTF-16BE |   | "&lt;?xml?&gt;"                  | UTF-16LE | default   | undef    |   | "&lt;?xml encoding=&apos;utf-8&apos;?&gt;" | UTF-16LE | default   | utf-8    |   | "&lt;?xml encoding=&apos;utf-8&apos;?&gt;" | UTF-16   | default   | UTF-16BE |   | "&lt;?xml encoding=&apos;cp37&apos;?&gt;"  | CP37     | default   | undef    |   | "&lt;?xml encoding=&apos;cp37&apos;?&gt;"  | CP37     | CP37      | cp37     |   +----------------------------+----------+-----------+----------+ Lacking a return value from this routine and higher-level protocol information (such as protocol encoding defaults) processors would be required to assume that the document is \s-1UTF-8\s0 encoded. Note however that the return value depends on the set of suspected encodings you pass to it. For example, by default, \s-1EBCDIC\s0 encodings would not be considered and thus for   &lt;?xml version=&apos;1.0&apos; encoding=&apos;cp37&apos;?&gt; this routine would return the undefined value. You can modify the list of suspected encodings using $options{encodings}. Uses encoding_from_xml_document and encoding_from_meta_element to determine the encoding of \s-1HTML\s0 documents. If $options{xhtml} is set to a false value uses encoding_from_byte_order_mark and encoding_from_meta_element to determine the encoding. The xhtml option is on by default. The $options{encodings} can be used to modify the suspected encodings and $options{parser_options} can be used to modify the HTML::Parser options in encoding_from_meta_element (see the relevant documentation). Returns nothing if no declaration could be found, the winning declaration in scalar context and a list of encoding source and encoding name in list context, see \s-1ENCODING\s0 \s-1SOURCES\s0. ... Other problems arise from differences between \s-1HTML\s0 and \s-1XHTML\s0 syntax and encoding detection rules, for example, the input could be   Content-Type: text/html</p><p>  &lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt;   &lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"   "http://www.w3.org/TR/html4/strict.dtd"&gt;   &lt;meta http-equiv = "Content-Type"            content = "text/html;charset=iso-8859-2"&gt;   &lt;title&gt;&lt;/title&gt;   &lt;p&gt;...&lt;/p&gt; This is a perfectly legal \s-1HTML\s0 4.01 document and implementations might be expected to consider the document \s-1ISO-8859-2\s0 encoded as \s-1XML\s0 rules for encoding detection do not apply to \s-1HTML\s0 documents. This module attempts to avoid making decisions which rules apply for a specific document and would thus by default return 'utf-8' for this input. On the other hand, if the input omits the encoding declaration,   Content-Type: text/html</p><p>  &lt;?xml version=&apos;1.0&apos;?&gt;   &lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"   "http://www.w3.org/TR/html4/strict.dtd"&gt;   &lt;meta http-equiv = "Content-Type"            content = "text/html;charset=iso-8859-2"&gt;   &lt;title&gt;&lt;/title&gt;   &lt;p&gt;...&lt;/p&gt; It would return 'iso-8859-2'. Similar problems would arise from other differences between \s-1HTML\s0 and \s-1XHTML\s0, for example consider   Content-Type: text/html</p><p>  &lt;?foo &gt;   &lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;   &lt;html ...   ?&gt;   ...   &lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"&gt;   ... If this is processed using \s-1HTML\s0 rules, the first &gt; will end the processing instruction and the \s-1XHTML\s0 document type declaration would be the relevant declaration for the document, if it is processed using \s-1XHTML\s0 rules, the ?&gt; will end the processing instruction and the \s-1HTML\s0 document type declaration would be the relevant declaration. \s-1IOW\s0, an application would need to assume a certain character encoding (family) to process enough of the document to determine whether it is \s-1XHTML\s0 or \s-1HTML\s0 and the result of this detection would depend on which processing rules are assumed in order to process it. It is thus in essence not possible to write a \*(L"perfect\*(R" detection algorithm, which is why this routine attempts to avoid making any decisions on this matter. Determines the encoding of \s-1HTML\s0 / \s-1XML\s0 / \s-1XHTML\s0 documents enclosed in \s-1HTTP\s0 message. $message is an object compatible to HTTP::Message, e.g. a HTTP::Response object. %options is a hash with the following possible entries:</p>
<dl class='dl-vertical'>
  <dt>
    encodings
  </dt>
  <dd>
    <p>array references of suspected character encodings, defaults to $HTML::Encoding::DEFAULT_ENCODINGS.</p>
  </dd>
  <dt>
    is_html
  </dt>
  <dd>
    <p>Regular expression matched against the content_type of the message to determine whether to use \s-1HTML\s0 rules for the entity body, defaults to \*(C`qr{^text/html$}i\*(C'.</p>
  </dd>
  <dt>
    is_xml
  </dt>
  <dd>
    <p>Regular expression matched against the content_type of the message to determine whether to use \s-1XML\s0 rules for the entity body, defaults to \*(C`qr{^.+/(?:.+&#92;+)?xml$}i\*(C'.</p>
  </dd>
  <dt>
    is_text_xml
  </dt>
  <dd>
    <p>Regular expression matched against the content_type of the message to determine whether to use text/html rules for the message, defaults to \*(C`qr{^text/(?:.+&#92;+)?xml$}i\*(C'. This will only be checked if is_xml matches aswell.</p>
  </dd>
  <dt>
    html_default
  </dt>
  <dd>
    <p>Default encoding for documents determined (by is_html) as \s-1HTML\s0, defaults to \*(C`ISO-8859-1\*(C'.</p>
  </dd>
  <dt>
    xml_default
  </dt>
  <dd>
    <p>Default encoding for documents determined (by is_xml) as \s-1XML\s0, defaults to \*(C`UTF-8\*(C'.</p>
  </dd>
  <dt>
    text_xml_default
  </dt>
  <dd>
    <p>Default encoding for documents determined (by is_text_xml) as text/xml, defaults to \*(C`undef\*(C' in which case the default is ignored. This should be set to \*(C`US-ASCII\*(C' if desired as this module is by default inconsistent with \s-1RFC\s0 3023 which requires that for text/xml documents without a charset parameter in the \s-1HTTP\s0 header \*(C`US-ASCII\*(C' is assumed. This requirement is inconsistent with \s-1RFC\s0 2616 (\s-1HTTP/1\s0.1) which requires to assume \*(C`ISO-8859-1\*(C', has been widely ignored and is thus disabled by default.</p>
  </dd>
  <dt>
    xhtml
  </dt>
  <dd>
    <p>Whether the routine should look for an encoding declaration in the \s-1XML\s0 declaration of the document (if any), defaults to 1.</p>
  </dd>
  <dt>
    default
  </dt>
  <dd>
    <p>Whether the relevant default value should be returned when no other information can be determined, defaults to 1.</p>
  </dd>

</dl>
<p>This is furhter possibly inconsistent with \s-1XML\s0 \s-1MIME\s0 types that differ in other ways from application/xml, for example if the \s-1MIME\s0 Type does not allow for a charset parameter in which case applications might be expected to ignore the charset parameter if erroneously provided.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EBCDIC SUPPORT</h2>
        <div class="sectioncontent">
<p>By default, this module does not support \s-1EBCDIC\s0 encodings. To enable support for \s-1EBCDIC\s0 encodings you can either change the $HTML::Encodings::DEFAULT_ENCODINGS array reference or pass the encodings to the routines you use using the encodings option, for example</p><p>  my @try = qw/UTF-8 UTF-16LE cp500 posix-bc .../;   my $enc = encoding_from_xml_document($doc, encodings =&gt; &#92;@try);</p><p>Note that there are some subtle differences between various \s-1EBCDIC\s0 encodings, for example \*(C`!\*(C' is mapped to 0x5A in \*(C`posix-bc\*(C' and to 0x4F in \*(C`cp500\*(C'; these differences might affect processing in yet undetermined ways.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TODO</h2>
        <div class="sectioncontent">
<p>  * bundle with test suite   * optimize some routines to give up once successful   * avoid transcoding for HTML::Parser if e.g. ISO-8859-1   * consider adding a "HTML5" modus of operation?</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO HTML::Encoding&hellip;</h2>
        <div class="sectioncontent">
<p>  * http://www.w3.org/TR/REC-xml/#charencoding   * http://www.w3.org/TR/REC-xml/#sec-guessing   * http://www.w3.org/TR/xml11/#charencoding   * http://www.w3.org/TR/xml11/#sec-guessing   * http://www.w3.org/TR/html4/charset.html#h-5.2.2   * http://www.w3.org/TR/xhtml1/#C_9   * http://www.ietf.org/rfc/rfc2616.txt   * http://www.ietf.org/rfc/rfc2854.txt   * http://www.ietf.org/rfc/rfc3023.txt   * perlunicode   * Encode   * HTML::Parser</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR / COPYRIGHT / LICENSE</h2>
        <div class="sectioncontent">
<p>  Copyright (c) 2004-2008 Bjoern Hoehrmann &lt;bjoern@hoehrmann.de&gt;.   This module is licensed under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="HTML::Embedded::Turtle.3pm.html"><span aria-hidden="true">&larr;</span> HTML::Embedded::Turtle.3pm: Embedding rdf in html the crazy way</a></li>
   <li class="next"><a href="HTML::Entities::Numbered.3pm.html">HTML::Entities::Numbered.3pm: Conversion of numbered html entities <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>porting: Porting from iar to avr gcc</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Porting from iar to avr gcc">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="porting (3avr) manual">
  <meta name="twitter:description" content="Porting from iar to avr gcc">
  <meta name="twitter:image" content="https://www.carta.tech/images/avr-libc-porting-3avr.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3avr/porting.3avr.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="porting (3avr) manual" />
  <meta property="og:description" content="Porting from iar to avr gcc" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/avr-libc-porting-3avr.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">porting<small> (3avr)</small></h1>
        <p class="lead">Porting from iar to avr gcc</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3avr/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3avr/porting.3avr.html">
      <span itemprop="name">porting: Porting from iar to avr gcc</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/avr-libc/">
      <span itemprop="name">avr-libc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3avr/porting.3avr.html">
      <span itemprop="name">porting: Porting from iar to avr gcc</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">Introduction</h2>
        <div class="sectioncontent">
<p>C language was designed to be a portable language. There two main types of porting activities: porting an application to a different platform (OS and/or processor), and porting to a different compiler. Porting to a different compiler can be exacerbated when the application is an embedded system. For example, the C language Standard, strangely, does not specify a standard for declaring and defining Interrupt Service Routines (ISRs). Different compilers have different ways of defining registers, some of which use non-standard language constructs.</p><p>This chapter describes some methods and pointers on porting an AVR application built with the IAR compiler to the GNU toolchain (AVR GCC). Note that this may not be an exhaustive list.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Registers</h2>
        <div class="sectioncontent">
<p>IO header files contain identifiers for all the register names and bit names for a particular processor. IAR has individual header files for each processor and they must be included when registers are being used in the code. For example:</p>
<pre>
#include &lt;iom169.h&gt;
</pre>
<p><strong>Note:</strong></p><p>IAR does not always use the same register names or bit names that are used in the AVR datasheet.</p><p>AVR GCC also has individual IO header files for each processor. However, the actual processor type is specified as a command line flag to the compiler. (Using the -mmcu=<em>processor</em><em> flag.) This is usually done in the Makefile. This allows you to specify only a single header file for any processor type:</em></p>
<pre>
#include &lt;avr/io.h&gt;
</pre>
<p><strong>Note:</strong></p><p>The forward slash in the &lt;<strong>avr/io.h</strong>&gt; file name that is used to separate subdirectories can be used on Windows distributions of the toolchain and is the recommended method of including this file.</p><p>The compiler knows the processor type and through the single header file above, it can pull in and include the correct individual IO header file. This has the advantage that you only have to specify one generic header file, and you can easily port your application to another processor type without having to change every file to include the new IO header file.</p><p>The AVR toolchain tries to adhere to the exact names of the registers and names of the bits found in the AVR datasheet. There may be some descrepencies between the register names found in the IAR IO header files and the AVR GCC IO header files.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Interrupt Service Routines (ISRs)</h2>
        <div class="sectioncontent">
<p>As mentioned above, the C language Standard, strangely, does not specify a standard way of declaring and defining an ISR. Hence, every compiler seems to have their own special way of doing so.</p><p>IAR declares an ISR like so:</p>
<pre>
#pragma vector=TIMER0_OVF_vect
__interrupt void MotorPWMBottom()
{
    // code
}
</pre>
<p>In AVR GCC, you declare an ISR like so:</p>
<pre>
ISR(PCINT1_vect)
{
    //code
}

</pre>
<p>AVR GCC uses the ISR macro to define an ISR. This macro requries the header file:</p>
<pre>
#include &lt;avr/interrupt.h&gt;
</pre>
<p>The names of the various interrupt vectors are found in the individual processor IO header files that you must include with &lt;<strong>avr/io.h</strong>&gt;<strong>.</strong></p><p><strong>Note:</strong></p><p>The names of the interrupt vectors in AVR GCC has been changed to match the names of the vectors in IAR. This significantly helps in porting applications from IAR to AVR GCC.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Intrinsic Routines</h2>
        <div class="sectioncontent">
<p>IAR has a number of intrinsic routine such as</p><p>__enable_interrupts() __disable_interrupts() __watchdog_reset()</p><p>These intrinsic functions compile to specific AVR opcodes (SEI, CLI, WDR).</p><p>There are equivalent macros that are used in AVR GCC, however they are not located in a single include file.</p><p>AVR GCC has <strong>sei()</strong><strong> for __enable_interrupts()</strong>, and <strong>cli()</strong><strong> for __disable_interrupts()</strong>. Both of these macros are located in &lt;avr/interrupts.h&gt;<strong>.</strong></p><p>AVR GCC has the macro <strong>wdt_reset()</strong><strong> in place of __watchdog_reset()</strong>. However, there is a whole Watchdog Timer API available in AVR GCC that can be found in &lt;<strong>avr/wdt.h</strong>&gt;<strong>.</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Flash Variables</h2>
        <div class="sectioncontent">
<p>The C language was not designed for Harvard architecture processors with separate memory spaces. This means that there are various non-standard ways to define a variable whose data resides in the Program Memory (Flash).</p><p>IAR uses a non-standard keyword to declare a variable in Program Memory:</p>
<pre>
__flash int mydata[] = ....
</pre>
<p>AVR GCC uses Variable Attributes to achieve the same effect:</p>
<pre>
int mydata[] __attribute__((progmem))
</pre>
<p><strong>Note:</strong></p><p>See the GCC User Manual for more information about Variable Attributes.</p><p>avr-libc provides a convenience macro for the Variable Attribute:</p>
<pre>
#include &lt;avr/pgmspace.h&gt;
.
.
.
int mydata[] PROGMEM = ....
</pre>
<p><strong>Note:</strong></p><p>The PROGMEM macro expands to the Variable Attribute of progmem. This macro requires that you include &lt;<strong>avr/pgmspace.h</strong>&gt;<strong>. This is the canonical method for defining a variable in Program Space.</strong></p><p>To read back flash data, use the pgm_read_*() macros defined in &lt;<strong>avr/pgmspace.h</strong>&gt;<strong>. All Program Memory handling macros are defined there.</strong></p><p>There is also a way to create a method to define variables in Program Memory that is common between the two compilers (IAR and AVR GCC). Create a header file that has these definitions:</p>
<pre>
#if defined(__ICCAVR__) // IAR C Compiler
#define FLASH_DECLARE(x) __flash x
#endif
#if defined(__GNUC__) // GNU Compiler
#define FLASH_DECLARE(x) x __attribute__((__progmem__))
#endif
</pre>
<p>This code snippet checks for the IAR compiler or for the GCC compiler and defines a macro FLASH_DECLARE(x) that will declare a variable in Program Memory using the appropriate method based on the compiler that is being used. Then you would used it like so:</p>
<pre>
FLASH_DECLARE(int mydata[] = ...);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Non-Returning main()</h2>
        <div class="sectioncontent">
<p>To declare main() to be a non-returning function in IAR, it is done like this:</p>
<pre>
__C_task void main(void)
{
    // code
}

</pre>
<p>To do the equivalent in AVR GCC, do this:</p>
<pre>
void main(void) __attribute__((noreturn));

void main(void)
{
    //...
}
</pre>
<p><strong>Note:</strong></p><p>See the GCC User Manual for more information on Function Attributes.</p><p>In AVR GCC, a prototype for main() is required so you can declare the function attribute to specify that the main() function is of type 'noreturn'. Then, define main() as normal. Note that the return type for main() is now void.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Locking Registers</h2>
        <div class="sectioncontent">
<p>The IAR compiler allows a user to lock general registers from r15 and down by using compiler options and this keyword syntax:</p>
<pre>
__regvar __no_init volatile unsigned int filteredTimeSinceCommutation @14;
</pre>
<p>This line locks r14 for use only when explicitly referenced in your code thorugh the var name 'filteredTimeSinceCommutation'. This means that the compiler cannot dispose of it at its own will.</p><p>To do this in AVR GCC, do this:</p>
<pre>
register unsigned char counter asm("r3");
</pre>
<p>Typically, it should be possible to use r2 through r15 that way.</p><p><strong>Note:</strong></p><p>Do not reserve r0 or r1 as these are used internally by the compiler for a temporary register and for a zero value.</p><p>Locking registers is not recommended in AVR GCC as it removes this register from the control of the compiler, which may make code generation worse. Use at your own risk.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="pgmspace.h.3avr.html"><span aria-hidden="true">&larr;</span> pgmspace.h.3avr: Pgmspace.h -</a></li>
   <li class="next"><a href="pow.3avr.html">pow.3avr: Math.h: mathematics - <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

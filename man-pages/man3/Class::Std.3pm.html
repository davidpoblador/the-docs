<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Class::Std: Support for creating standard "inside-out" classes</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Support for creating standard "inside-out" classes">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Class::Std (3pm) manual">
  <meta name="twitter:description" content="Support for creating standard "inside-out" classes">
  <meta name="twitter:image" content="https://www.carta.tech/images/libclass-std-perl-Class::Std-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Class::Std.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Class::Std (3pm) manual" />
  <meta property="og:description" content="Support for creating standard "inside-out" classes" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libclass-std-perl-Class::Std-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Class::Std<small> (3pm)</small></h1>
        <p class="lead">Support for creating standard "inside-out" classes</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Class::Std.3pm.html">
      <span itemprop="name">Class::Std: Support for creating standard "inside-out" classes</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libclass-std-perl/">
      <span itemprop="name">libclass-std-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Class::Std.3pm.html">
      <span itemprop="name">Class::Std: Support for creating standard "inside-out" classes</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">VERSION</h2>
        <div class="sectioncontent">
<p>This document describes Class::Std version 0.011</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
    package MyClass;
    use Class::Std;

    # Create storage for object attributes...
    my %name : ATTR;
    my %rank : ATTR;
    my %snum : ATTR;

    my %public_data : ATTR;

    # Handle initialization of objects of this class...
    sub BUILD {
        my ($self, $obj_ID, $arg_ref) = @_;

        $name{$obj_ID} = check_name( $arg_ref-&gt;{name} );
        $rank{$obj_ID} = check_rank( $arg_ref-&gt;{rank} );
        $snum{$obj_ID} = _gen_uniq_serial_num();
    }

    # Handle cleanup of objects of this class...
    sub DEMOLISH {
        my ($self, $obj_ID) = @_;

        _recycle_serial_num( $snum{$obj_ID} );
    }

    # Handle unknown method calls...
    sub AUTOMETHOD {
        my ($self, $obj_ID, @other_args) = @_;

        # Return any public data...
        if ( m/&#92;A get_(.*)/ ) {  # Method name passed in $_
            my $get_what = $1;
            return sub {
                return $public_data{$obj_ID}{$get_what};
            }
        }

        warn "Can&apos;t call $method_name on ", ref $self, " object";

        return;   # The call is declined by not returning a sub ref
    }
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module provides tools that help to implement the \*(L"inside out object\*(R" class structure in a convenient and standard way.</p><p><em>Portions of the following code and documentation from \*(L"Perl Best Practices\*(R"</em> copyright (c) 2005 by O'Reilly Media, Inc. and reprinted with permission.</p><h3>Introduction</h3>
<p>Most programmers who use Perl's object-oriented features construct their objects by blessing a hash. But, in doing so, they undermine the robustness of the \s-1OO\s0 approach. Hash-based objects are unencapsulated: their entries are open for the world to access and modify.</p><p>Objects without effective encapsulation are vulnerable. Instead of politely respecting their public interface, some clever client coder inevitably will realize that it's marginally faster to interact directly with the underlying implementation, pulling out attribute values directly from the hash of an object:</p><p>    for my $file ( get_file_objs() ) {         print $file-&gt;{name}, "&#92;n";     }</p><p>instead of using the official interface:</p><p>    for my $file ( get_file_objs() ) {         print $file-&gt;get_name(), "&#92;n";     }</p><p>From the moment someone does that, your class is no longer cleanly decoupled from the code that uses it. You can't be sure that any bugs in your class are actually caused by the internals of your class, and not the result of some kind of monkeying by the client code. And to make matters worse, now you can't ever change those internals without the risk of breaking some other part of the system.</p><p>There is a simple, convenient, and utterly secure way to prevent client code from accessing the internals of the objects you provide. Happily, that approach also guards against misspelling attribute names (a common error in hash-based classes), as well as being just as fast as\*(--and often more memory-efficient than\*(--ordinary hash-based objects.</p><p>That approach is referred to by various names\*(--flyweight scalars, warehoused attributes, inverted indices\*(--but most commonly it's known as: inside-out objects. Consider the following class definitions:</p><p>    package File::Hierarchy;     {         # Objects of this class have the following attributes...         my %root_of;   # The root directory of the file hierarchy         my %files_of;  # Array storing object for each file in root directory</p><p>        # Constructor takes path of file system root directory...         sub new {             my ($class, $root) = @_;</p><p>            # Bless a scalar to instantiate the new object...             my $new_object = bless &#92;do{my $anon_scalar}, $class;</p><p>            # Initialize the object&apos;s "root" attribute...             $root_of{ident $new_object} = $root;</p><p>            return $new_object;         }</p><p>        # Retrieve files from root directory...         sub get_files {             my ($self) = @_;</p><p>            # Load up the "files" attribute, if necessary...             if (!exists $files_of{ident $self}) {                 $files_of{ident $self}                     = File::System-&gt;list_files($root_of{ident $self});             }</p><p>            # Flatten the "files" attribute&apos;s array to produce a file list...             return @{ $files_of{ident $self} };         }     }</p><p>    package File::Hierarchy::File;     {         # Objects of this class have the following attributes...         my %name_of;  # the name of the file</p><p>        # Constructor takes name of file...         sub new {             my ($class, $filename) = @_;</p><p>            # Bless a scalar to instantiate the new object...             my $new_object = bless &#92;do{my $anon_scalar}, $class;</p><p>            # Initialize the object&apos;s "name" attribute...             $name_of{ident $new_object} = $filename;</p><p>            return $new_object;         }</p><p>        # Retrieve name of file...         sub get_name {             my ($self) = @_;</p><p>            return $name_of{ident $self};         }     }</p><p>Unlike a hash-based class, each of these inside-out class is specified inside a surrounding code block:</p><p>    package File::Hierarchy;     {         # [Class specification here]     }</p><p>    package File::Hierarchy::File;     {         # [Class specification here]     }</p><p>That block is vital, because it creates a limited scope, to which any lexical variables that are declared as part of the class will automatically be restricted.</p><p>The next difference between the two versions of the classes is that each attribute of <em>all</em> the objects in the class is now stored in a separate single hash:</p><p>    # Objects of this class have the following attributes...</p><p>    my %root_of;   # The root directory of the file hierarchy     my %files_of;  # Array storing object for each file in root directory</p><p>This is 90 degrees to the usual hash-based approach. In hash-based classes, all the attributes of one object are stored in a single hash; in inside-out classes, one attribute from all objects is stored in a single hash. Diagrammatically:</p><p>    Hash-based:                      Attribute 1      Attribute 2</p><p>     Object A    { attr1 =&gt; $valA1,  attr2 =&gt; $val2 }</p><p>     Object B    { attr1 =&gt; $valB1,  attr2 =&gt; $val2 }</p><p>     Object C    { attr1 =&gt; $valB1,  attr2 =&gt; $val2 }</p><p>    Inside-out:                       Object A           Object B          Object C</p><p>    Attribute 1  { 19817 =&gt; $valA1,  172616 =&gt; $valB1,  67142 =&gt; $valC1 }</p><p>    Attribute 2  { 19817 =&gt; $valA2,  172616 =&gt; $valB2,  67142 =&gt; $valC3 }</p><p>    Attribute 3  { 19817 =&gt; $valA3,  172616 =&gt; $valB3,  67142 =&gt; $valC3 }</p><p>So the attributes belonging to each object are distributed across a set of predeclared hashes, rather than being squashed together into one anonymous hash.</p><p>This is a significant improvement. By telling Perl what attributes you expect to use, you enable the compiler to check\*(--via use strict\*(--that you do indeed use only those attributes.</p><p>That's because of the third difference in the two approaches. Each attribute of a hash-based object is stored in an entry in the object's hash: \*(C`$self-&gt;{name}\*(C'. In other words, the name of a hash-based attribute is symbolic: specified by the string value of a hash key. In contrast, each attribute of an inside-out object is stored in an entry of the attribute's hash: $name_of{ident $self}. So the name of an inside-out attribute isn't symbolic; it's a hard-coded variable name.</p><p>With hash-based objects, if an attribute name is accidentally misspelled in some method:</p><p>    sub set_name {         my ($self, $new_name) = @_;</p><p>        $self-&gt;{naem} = $new_name;             # Oops!</p><p>        return;     }</p><p>then the $self hash will obligingly\*(--and silently!--create a new entry in the hash, with the key &apos;naem&apos;, then assign the new name to it. But since every other method in the class correctly refers to the attribute as \*(C`$self-\*(C'{name}&gt;, assigning the new value to \*(C`$self-\*(C'{naem}&gt; effectively makes that assigned value \*(L"vanish\*(R".</p><p>With inside-out objects, however, an object's \*(L"name\*(R" attribute is stored as an entry in the class's lexical %name_of hash. If the attribute name is misspelled then you're attempting to refer to an entirely different hash: %naem_of. Like so:</p><p>    sub set_name {         my ($self, $new_name) = @_;</p><p>        $naem_of{ident $self} = $new_name;     # Kaboom!</p><p>        return;     }</p><p>But, since there's no such hash declared in the scope, use strict will complain (with extreme prejudice):</p><p>    Global symbol "%naem_of" requires explicit package name at Hierarchy.pm line 86</p><p>Not only is that consistency check now automatic, it's also performed at compile time.</p><p>The next difference is even more important and beneficial. Instead of blessing an empty anonymous hash as the new object:</p><p>    my $new_object = bless {}, $class;</p><p>the inside-out constructor blesses an empty anonymous scalar:</p><p>    my $new_object = bless &#92;do{my $anon_scalar}, $class;</p><p>That odd-looking \*(C`&#92;do{my $anon_scalar}\*(C' construct is needed because there's no built-in syntax in Perl for creating a reference to an anonymous scalar; you have to roll-your-own.</p><p>The anonymous scalar is immediately passed to bless, which anoints it as an object of the appropriate class. The resulting object reference is then stored in $new_object.</p><p>Once the object exists, it's used to create a unique key (\*(C`ident $new_object\*(C') under which each attribute that belongs to the object will be stored (e.g. $root_of{ident $new_object} or $name_of{ident $self}). The \*(C`ident()\*(C' utility that produces this unique key is provided by the Class::Std module and is identical in effect to the \*(C`refaddr()\*(C' function in the standard Scalar::Util module.</p><p>To recap: every inside-out object is a blessed scalar, and has\*(--intrinsic to it\*(--a unique identifying integer. That integer can be obtained from the object reference itself, and then used to access a unique entry for the object in each of the class's attribute hashes.</p><p>This means that every inside-out object is nothing more than an unintialized scalar. When your constructor passes a new inside-out object back to the client code, all that comes back is an empty scalar, which makes it impossible for that client code to gain direct access to the object's internal state.</p><p>Of the several popular methods of reliably enforcing encapsulation in Perl, inside-out objects are also by far the cheapest. The run-time performance of inside-out classes is effectively identical to that of regular hash-based classes. In particular, in both schemes, every attribute access requires only a single hash look-up. The only appreciable difference in speed occurs when an inside-out object is destroyed.</p><p>Hash-based classes usually don't even have destructors. When the object's reference count decrements to zero, the hash is automatically reclaimed, and any data structures stored inside the hash are likewise cleaned up. This works so well that many \s-1OO\s0 Perl programmers find they never need to write a \*(C`DESTROY()\*(C' method; Perl's built-in garbage collection handles everything just fine. In fact, the only time a destructor is needed is when objects have to manage resources outside that are not actually located inside the object, resources that need to be separately deallocated.</p><p>But the whole point of an inside-out object is that its attributes are stored in allocated hashes that are not actually located inside the object. That's precisely how it achieves secure encapsulation: by not sending the attributes out into the client code.</p><p>Unfortunately, that means when an inside-out object is eventually garbage collected, the only storage that is reclaimed is the single blessed scalar implementing the object. The object's attributes are entirely unaffected by the object's deallocation, because the attributes are not inside the object, nor are they referred to by it in any way.</p><p>Instead, the attributes are referred to by the various attribute hashes in which they're stored. And since those hashes will continue to exist until the end of the program, the defunct object's orphaned attributes will likewise continue to exist, safely nestled inside their respective hashes, but now untended by any object. In other words, when an inside- out object dies, its associated attribute hashes leak memory.</p><p>The solution is simple. Every inside-out class has to provide a destructor that \*(L"manually\*(R" cleans up the attributes of the object being destructed:</p><p>    package File::Hierarchy;     {         # Objects of this class have the following attributes...         my %root_of;   # The root directory of the file hierarchy         my %files_of;  # Array storing object for each file in root directory</p><p>        # Constructor takes path of file system root directory...         sub new {             # As before         }</p><p>        # Retrieve files from root directory...         sub get_files {             # As before         }</p><p>        # Clean up attributes when object is destroyed...         sub DESTROY {             my ($self) = @_;</p><p>            delete $root_of{ident $self};             delete $files_of{ident $self};         }     }</p><p>The obligation to provide a destructor like this in every inside-out class can be mildly irritating, but it is still a very small price to pay for the considerable benefits that the inside-out approach otherwise provides for free. And the irritation can easily be eliminated by using the appropriate class construction tools. See below.</p>
<h3>Automating Inside-Out Classes</h3>
<p>Perhaps the most annoying part about building classes in Perl (no matter how the objects are implemented) is that the basic structure of every class is more or less identical. For example, the implementation of the \*(C`File::Hierarchy::File\*(C' class used in \*(C`File::Hierarchy\*(C' looks like this:</p><p>    package File::Hierarchy::File;     {         # Objects of this class have the following attributes...         my %name_of;  # the name of the file</p><p>        # Constructor takes name of file...         sub new {             my ($class, $filename) = @_;</p><p>            # Bless a scalar to instantiate the new object...             my $new_object = bless &#92;do{my $anon_scalar}, $class;</p><p>            # Initialize the object&apos;s "name" attribute...             $name_of{ident $new_object} = $filename;</p><p>            return $new_object;         }</p><p>        # Retrieve name of file...         sub get_name {             my ($self) = @_;</p><p>            return $name_of{ident $self};         }</p><p>        # Clean up attributes when object is destroyed...         sub DESTROY {             my ($self) = @_;</p><p>            delete $name_of{ident $self};         }     }</p><p>Apart from the actual names of the attributes, and their accessor methods, that's exactly the same structure, and even the same code, as in the \*(C`File::Hierarchy\*(C' class.</p><p>Indeed, the standard infrastructure of <em>every</em> inside-out class looks exactly the same. So it makes sense not to have to rewrite that standard infrastructure code in every separate class.</p><p>That's precisely what is module does: it implements the necessary infrastructure for inside-out objects. See below.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INTERFACE</h2>
        <div class="sectioncontent">
<h3>Exported subroutines</h3>
<p>Class::Std always exports a subroutine called \*(C`ident()\*(C'. This subroutine returns a unique integer \s-1ID\s0 for any object passed to it.</p>
<h3>Non-exported subroutines</h3>
<p>This subroutine sets up all the infrastructure to support your Class::Std- based class. It is usually called automatically in a \*(C`CHECK\*(C' block, or (if the \*(C`CHECK\*(C' block fails to run \*(-- under \*(C`mod_perl\*(C' or \*(C`require Class::Std\*(C' or \*(C`eval "..."\*(C') during the first constructor call made to a Class::Std-based object. In rare circumstances, you may need to call this subroutine directly yourself. Specifically, if you set up cumulative, restricted, private, or automethodical class methods (see below), and call any of them before you create any objects, then you need to call \*(C`Class::Std::initialize()\*(C' first.</p>
<h3>Methods created automatically</h3>
<p>The following subroutines are installed in any class that uses the Class::Std module. Every class that loads the Class::Std module automatically has a \*(C`new()\*(C' constructor, which returns an inside-out object (i.e. a blessed scalar).     $obj = MyClass-&gt;new(); The constructor can be passed a single argument to initialize the object. This argument must be a hash reference.     $obj = MyClass-&gt;new({ name=&gt;&apos;Foo&apos;, location=&gt;&apos;bar&apos; }); See the subsequent descriptions of the \*(C`BUILD()\*(C' and \*(C`START()\*(C' methods and \*(C`:ATTR()\*(C' trait, for an explanation of how the contents of this optional hash can be used to initialize the object. It is almost always an error to implement your own \*(C`new()\*(C' in any class that uses Class::Std. You almost certainly want to write a \*(C`BUILD()\*(C' or \*(C`START()\*(C' method instead. See below. Every class that loads the Class::Std module automatically has a \*(C`DESTROY()\*(C' destructor, which automatically cleans up any attributes declared with the \*(C`:ATTR()\*(C' trait (see below). It is almost always an error to write your own \*(C`DESTROY()\*(C' in any class that uses Class::Std. You almost certainly want to write your own \*(C`DEMOLISH()\*(C' instead. See below. Every class that loads the Class::Std module automatically has an \*(C`AUTOLOAD()\*(C' method, which implements the \*(C`AUTOMETHOD()\*(C' mechanism described below. It is almost always an error to write your own \*(C`AUTOLOAD()\*(C' in any class that uses Class::Std. You almost certainly want to write your own \*(C`AUTOMETHOD()\*(C' instead. This method returns a string that represents the internal state (i.e. the attribute values) of the object on which it's called. Only those attributes which are marked with an \*(C`:ATTR\*(C' (see below) are reported. Attribute names are reported only if they can be ascertained from an \*(C`:init_arg\*(C', \*(C`:get\*(C', or \*(C`:set\*(C' option within the \*(C`:ATTR()\*(C'. Note that \*(C`_DUMP()\*(C' is not designed to support full serialization/deserialization of objects. See the separate Class::Std::Storable module (on \s-1CPAN\s0) for that.</p>
<h3>Methods that can be supplied by the developer</h3>
<p>The following subroutines can be specified as standard methods of a Class::Std class. When the \*(C`new()\*(C' constructor of a Class::Std class is called, it automatically calls every method named \*(C`BUILD()\*(C' in <em>all</em> the classes in the new object's hierarchy. That is, when the constructor is called, it walks the class's inheritance tree (from base classes downwards) and calls every \*(C`BUILD()\*(C' method it finds along the way. This means that, to initialize any class, you merely need to provide a \*(C`BUILD()\*(C' method for that class. You don't have to worry about ensuring that any ancestral \*(C`BUILD()\*(C' methods also get called; the constructor will take care of that. Each \*(C`BUILD()\*(C' method is called with three arguments: the invocant object, the identifier number of that object, and a reference to (a customized version of) the hash of arguments that was originally passed to the constructor:     sub BUILD {         my ($self, $ident, $args_ref) = @_;         ...     } The argument hash is a \*(L"customized version\*(R" because the module automatically does some fancy footwork to ensure that the arguments are the ones appropriate to the class itself. That's because there's a potential for collisions when Class::Std classes are used in a hierarchy. One of the great advantages of using inside-out classes instead of hash-based classes is that an inside-out base class and an inside-out derived class can then each have an attribute of exactly the same name, which are stored in separate lexical hashes in separate scopes. In a hash-based object that's impossible, because the single hash can't have two attributes with the same key. But that very advantage also presents something of a problem when constructor arguments are themselves passed by hash. If two or more classes in the name hierarchy do happen to have attributes of the same name, the constructor will need two or more initializers with the name key. Which a single hash can't provide. The solution is to allow initializer values to be partitioned into distinct sets, each uniquely named, and which are then passed to the appropriate base class. The easiest way to accomplish that is to pass in a hash of hashes, where each top level key is the name of one of the base classes, and the corresponding value is a hash of initializers specifically for that base class. For example:     package Client;     use Class::Std::Utils;     {         my %client_num_of :ATTR;  # Every client has a basic ID number         my %name_of       :ATTR;</p><p>        sub BUILD {             my ($self, $ident, $arg_ref) = @_;</p><p>            $client_num_of{$ident} = $arg_ref-&gt;{&apos;Client&apos;}{client_num};             $name_of{$ident}       = $arg_ref-&gt;{&apos;Client&apos;}{client_name};         }     }</p><p>    package Client::Corporate;     use base qw( Client );     use Class::Std::Utils;     {         my %client_num_of;     # Corporate clients have an additional ID number         my %corporation_of;         my %position_of;</p><p>        sub BUILD {             my ($self, $ident, $arg_ref) = @_;</p><p>            $client_num_of{$ident}                 = $arg_ref-&gt;{&apos;Client::Corporate&apos;}{client_num};             $corporation_of{$ident}                 = $arg_ref-&gt;{&apos;Client::Corporate&apos;}{corp_name};             $position_of{$ident}                 = $arg_ref-&gt;{&apos;Client::Corporate&apos;}{position};         }     }</p><p>    # and later...</p><p>    my $new_client         = Client::Corporate-&gt;new( {             &apos;Client&apos; =&gt; {                 client_num  =&gt; &apos;124C1&apos;,                 client_name =&gt; &apos;Humperdinck&apos;,             },             &apos;Client::Corporate&apos; =&gt; {                 client_num  =&gt; &apos;F_1692&apos;,                 corp_name   =&gt; &apos;Florin&apos;,                 position    =&gt; &apos;CEO&apos;,             },         }); Now each class's \*(C`BUILD()\*(C' method picks out only the initializer sub-hash whose key is that class's own name. Since every class name is different, the top-level keys of this multi-level initializer hash are guaranteed to be unique. And since no single class can have two identically named attributes, the keys of each second-level hash will be unique as well. If two classes in the hierarchy both need an initializer of the same name (e.g. 'client_num'), those two hash entries will now be in separate sub-hashes, so they will never clash. Class::Std provides an even more sophisticated variation on this functionality, which is generally much more convenient for the users of classes. Classes that use Class::Std infrastructure allow both general and class-specific initializers in the initialization hash. Clients only need to specify classes for those initializers whose names actually are ambiguous. Any other arguments can just be passed directly in the top-level hash:     my $new_client         = Client::Corporate-&gt;new( {             client_name =&gt; &apos;Humperdinck&apos;,             corp_name   =&gt; &apos;Florin&apos;,             position    =&gt; &apos;CEO&apos;,</p><p>            &apos;Client&apos;            =&gt; { client_num  =&gt; &apos;124C1&apos;  },             &apos;Client::Corporate&apos; =&gt; { client_num  =&gt; &apos;F_1692&apos; },         }); Class::Std also makes it easy for each class's \*(C`BUILD()\*(C' to access these class-specific initializer values. Before each \*(C`BUILD()\*(C' is invoked, the nested hash whose key is the same as the class name is flattened back into the initializer hash itself. That is, \*(C`Client::BUILD()\*(C' is passed the hash:     {         client_name =&gt; &apos;Humperdinck&apos;,         corp_name   =&gt; &apos;Florin&apos;,         position    =&gt; &apos;CEO&apos;,         client_num  =&gt; &apos;124C1&apos;,   # Flattened from &apos;Client&apos; nested subhash</p><p>        &apos;Client&apos;            =&gt; { client_num  =&gt; &apos;124C1&apos;  },         &apos;Client::Corporate&apos; =&gt; { client_num  =&gt; &apos;F_1692&apos; },     } whereas \*(C`Client::Corporate::BUILD()\*(C' is passed the hash:     {         client_name =&gt; &apos;Humperdinck&apos;,         corp_name   =&gt; &apos;Florin&apos;,         position    =&gt; &apos;CEO&apos;,         client_num  =&gt; &apos;F_1692&apos;,   # Flattened from &apos;Client::Corporate&apos; subhash</p><p>        &apos;Client&apos;            =&gt; { client_num  =&gt; &apos;124C1&apos;  },         &apos;Client::Corporate&apos; =&gt; { client_num  =&gt; &apos;F_1692&apos; },     } This means that the \*(C`BUILD()\*(C' method for each class can just assume that the correct class-specific initializer values will available at the top level of the hash. For example:         sub Client::BUILD {             my ($self, $ident, $arg_ref) = @_;</p><p>            $client_num_of{$ident} = $arg_ref-&gt;{client_num};    # &apos;124C1&apos;             $name_of{$ident}       = $arg_ref-&gt;{client_name};         }</p><p>        sub Client::Corporate::BUILD {             my ($self, $ident, $arg_ref) = @_;</p><p>            $client_num_of{$ident}  = $arg_ref-&gt;{client_num};   # &apos;F_1692&apos;             $corporation_of{$ident} = $arg_ref-&gt;{corp_name};             $position_of{$ident}    = $arg_ref-&gt;{position};         } Both classes use the \*(C`$arg_ref-&gt;{client_num}\*(C' initializer value, but Class::Std automatically arranges for that value to be the right one for each class. Also see the \*(C`:ATTR()\*(C' marker (described below) for a simpler way of initializing attributes. Once all the \*(C`BUILD()\*(C' methods of a class have been called and any initialization values or defaults have been subsequently applied to uninitialized attributes, Class::Std arranges for any \*(C`START()\*(C' methods in the class's hierarchy to be called befre the constructor finishes. That is, after the build and default initialization processes are complete, the constructor walks down the class's inheritance tree a second time and calls every \*(C`START()\*(C' method it finds along the way. As with \*(C`BUILD()\*(C', each \*(C`START()\*(C' method is called with three arguments: the invocant object, the identifier number of that object, and a reference to (a customized version of) the hash of arguments that was originally passed to the constructor. The main difference between a \*(C`BUILD()\*(C' method and a \*(C`START()\*(C' method is that a \*(C`BUILD()\*(C' method runs before any attribute of the class is auto-initialized or default-initialized, whereas a \*(C`START()\*(C' method runs after all the attributes of the class (including attributes in derived classes) have been initialized in some way. So if you want to pre-empt the initialization process, write a \*(C`BUILD()\*(C'. But if you want to do something with the newly created and fully initialized object, write a \*(C`START()\*(C' instead. Of course, any class can define <em>both</em> a \*(C`BUILD()\*(C' and a \*(C`START()\*(C' method, if that happens to be appropriate. The \*(C`DESTROY()\*(C' method that is automatically provided by Class::Std ensures that all the marked attributes (see the \*(C`:ATTR()\*(C' marker below) of an object, from all the classes in its inheritance hierarchy, are automatically cleaned up. But, if a class requires other destructor behaviours (e.g. closing filehandles, decrementing allocation counts, etc.) then you may need to specify those explicitly. Whenever an object of a Class::Std class is destroyed, the \*(C`DESTROY()\*(C' method supplied by Class::Std automatically calls every method named \*(C`DEMOLISH()\*(C' in <em>all</em> the classes in the new object's hierarchy. That is, when the destructor is called, it walks the class's inheritance tree (from derived classes upwards) and calls every \*(C`DEMOLISH()\*(C' method it finds along the way. This means that, to clean up any class, you merely need to provide a \*(C`DEMOLISH()\*(C' method for that class. You don't have to worry about ensuring that any ancestral \*(C`DEMOLISH()\*(C' methods also get called; the destructor will take care of that. Each \*(C`DEMOLISH()\*(C' method is called with two arguments: the invocant object, and the identifier number of that object. For example:     sub DEMOLISH {         my ($self, $ident) = @_;</p><p>        $filehandle_of{$ident}-&gt;flush();         $filehandle_of{$ident}-&gt;close();     } Note that the attributes of the object are cleaned up <em>after</em> the \*(C`DEMOLISH()\*(C' method is complete, so they may still be used within that method. There is a significant problem with Perl's built-in \*(C`AUTOLOAD\*(C' mechanism: there's no way for a particular \*(C`AUTOLOAD()\*(C' to say \*(L"no\*(R". If two or more classes in a class hierarchy have separate \*(C`AUTOLOAD()\*(C' methods, then the one belonging to the left-most-depth-first class in the inheritance tree will always be invoked in preference to any others. If it can't handle a particular call, the call will probably fail catastrophically. This means that derived classes can't always be used in place of base classes (a feature known as \*(L"Liskov substitutability\*(R") because their inherited autoloading behaviour may be pre-empted by some other unrelated base class on their left in the hierarchy. Class::Std provides a mechanism that solves this problem: the \*(C`AUTOMETHOD\*(C' method. An \s-1<em>AUTOMETHOD\s0()</em> is expected to return either a handler subroutine that implements the requested method functionality, or else an \*(C`undef\*(C' to indicate that it doesn't know how to handle the request. Class::Std then coordinates every \*(C`AUTOMETHOD()\*(C' in an object's hierarchy, trying each one in turn until one of them produces a suitable handler. The advantage of this approach is that the first \*(C`AUTOMETHOD()\*(C' that's invoked doesn't have to disenfranchise every other \*(C`AUTOMETHOD()\*(C' in the hierarchy. If the first one can't handle a particular method call, it simply declines it and Class::Std tries the next candidate instead. Using \*(C`AUTOMETHOD()\*(C' instead of \*(C`AUTOLOAD()\*(C' makes a class cleaner, more robust, and less disruptive in class hierarchies. For example:     package Phonebook;     use Class::Std;     {         my %entries_of : ATTR;</p><p>        # Any method call is someone&apos;s name:         # so store their phone number or get it...         sub AUTOMETHOD {             my ($self, $ident, $number) = @_;</p><p>            my $subname = $_;   # Requested subroutine name is passed via $_</p><p>            # Return failure if not a get_&lt;name&gt; or set_&lt;name&gt;             # (Next AUTOMETHOD() in hierarchy will then be tried instead)...             my ($mode, $name) = $subname =~ m/&#92;A ([gs]et)_(.*) &#92;z/xms                 or return;</p><p>            # If get_&lt;name&gt;, return a handler that just returns the old number...             return sub { return $entries_of{$ident}-&gt;{$name}; }                 if $mode eq &apos;get&apos;;</p><p>            # Otherwise, set_&lt;name&gt;, so return a handler that             # updates the entry and then returns the old number...             return sub {                 $entries_of{$ident}-&gt;{$name} = $number;                 return;             };         }     }</p><p>    # and later...</p><p>    my $lbb = Phonebook-&gt;new();</p><p>    $lbb-&gt;set_Jenny(867_5309);     $lbb-&gt;set_Glenn(736_5000);</p><p>    print $lbb-&gt;get_Jenny(), "&#92;n";     print $lbb-&gt;get_Glenn(), "&#92;n"; Note that, unlike \*(C`AUTOLOAD()\*(C', an \*(C`AUTOMETHOD()\*(C' is called with both the invocant and the invocant's unique \*(C`ident\*(C' number, followed by the actual arguments that were passed to the method. Note too that the name of the method being called is passed as $_ instead of $AUTOLOAD, and does <em>not</em> have the class name prepended to it, so you don't have to strip that name off the front like almost everyone almost always does in their \*(C`AUTOLOAD()\*(C'. If your \*(C`AUTOMETHOD()\*(C' also needs to access the $_ from the caller's scope, that's still available as $CALLER::_.</p>
<h3>Variable traits that can be ascribed</h3>
<p>The following markers can be added to the definition of any hash used as an attribute storage within a Class::Std class This marker can be used to indicate that a lexical hash is being used to store one particular attribute of all the objects of the class. That is:     package File::Hierarchy;     {         my %root_of  :ATTR;         my %files_of :ATTR;</p><p>        # etc.     }</p><p>    package File::Hierarchy::File;     {         my %name_of;  :ATTR;</p><p>        # etc.     } Adding the \*(C`:ATTR\*(C' marker to an attribute hash ensures that the corresponding attribute belonging to each object of the class is automatically cleaned up when the object is destroyed. The \*(C`:ATTR\*(C' marker can also be given a number of options which automate other attribute-related behaviours. Each of these options consists of a key/value pair, which may be specified in either Perl 5 \*(L"fat comma\*(R" syntax ( \*(C`key&nbsp;=&gt;&nbsp;&apos;value&apos;\*(C' ) or in one of the Perl 6 option syntaxes ( \*(C`:key&lt;value&gt;\*(C' or \*(C`:key(&apos;value&apos;)\*(C' or \*(C`:keyXvalueX\*(C'). Note that, due to a limitation in Perl itself, the complete \*(C`:ATTR\*(C' marker, including its options must appear on a single line. interpolate variables into the option values</p><p>This option tells Class::Std which key in the constructor's initializer hash holds the value with which the marked attribute should be initialized. That is, instead of writing:     my %rank_of :ATTR;</p><p>    sub BUILD {         my ($self, $ident, $arg_ref) = @_;</p><p>        $rank_of{$ident} = $arg_ref-&gt;{rank};     } you can achieve the same initialization, by having Class::Std <em>automatically</em> pull that entry out of the hash and store it in the right attribute:     my %rank_of :ATTR( :init_arg&lt;rank&gt; );</p><p>    # No BUILD() method required If a marked attribute is not initialized (either directly within a \*(C`BUILD()\*(C', or automatically via an \*(C`:init_arg\*(C' option), the constructor supplied by Class::Std checks to see if a default value was specified for that attribute. If so, that value is assigned to the attribute. So you could replace:     my %seen_of :ATTR;</p><p>    sub BUILD {         my ($self, $ident, $arg_ref) = @_;</p><p>        $seen_of{$ident} = 0;  # Not seen yet     } with:     my %seen_of :ATTR( :<strong>default</strong>(0) );</p><p>    # No BUILD() required Note that only literal strings and numbers can be used as default values. A common mistake is to write:     my %seen_of :ATTR( :default($some_variable) ); But variables like this aren't interpolated into \*(C`:ATTR\*(C' markers (this is a limitation of Perl, not Class::Std). If your attribute needs something more complex, you will have to default initialize it in a \*(C`START()\*(C' method:     my %seen_of :ATTR;</p><p>    sub START {         my ($self, $id, $args_ref) = @_;</p><p>        if (!defined $seen_of{$id}) {             $seen_of{$id} = $some_variable;         }     } If the \*(C`:get\*(C' option is specified, a read accessor is created for the corresponding attribute. The name of the accessor is \*(C`get_\*(C' followed by whatever name is specified as the value of the \*(C`:get\*(C' option. For example, instead of:     my %current_count_of :ATTR;</p><p>    sub get_count {         my ($self) = @_;</p><p>        return $current_count_of{ident($self)};     } you can just write:     my %count_of :ATTR( :get&lt;count&gt; ); Note that there is no way to prevent Class::Std adding the initial \*(C`get_\*(C' to each accessor name it creates. That's what \*(L"standard\*(R" means. See Chapter 15 of <em>Perl Best Practices</em> (O'Reilly, 2005) for a full discussion on why accessors should be named this way. If the \*(C`:set\*(C' option is specified, a write accessor is created for the corresponding attribute. The name of the accessor is \*(C`set_\*(C' followed by whatever name is specified as the value of the \*(C`:set\*(C' option. For example, instead of:     my %current_count_of :ATTR;</p><p>    sub set_count {         my ($self, $new_value) = @_;</p><p>        croak "Missing new value in call to &apos;set_count&apos; method"             unless @_ == 2;</p><p>        $current_count_of{ident($self)} = $new_value;     } you can just write:     my %count_of :ATTR( :set&lt;count&gt; ); Note that there is no way to prevent Class::Std adding the initial \*(C`set_\*(C' to each accessor name it creates. Nor is there any way to create a combined \*(L"getter/setter\*(R" accessor. See Chapter 15 of <em>Perl Best</em> Practices (O'Reilly, 2005) for a full discussion on why accessors should be named and implemented this way. Specifying the \*(C`:name\*(C' option is merely a convenient shorthand for specifying all three of \*(C`:get\*(C', \*(C`:set\*(C', and \*(C`:init_arg\*(C'.</p><p>You can, of course, specify two or more arguments in a single \*(C`:ATTR()\*(C' specification:     my %rank_of : ATTR( :init_arg&lt;starting_rank&gt;  :get&lt;rank&gt;  :set&lt;rank&gt; );</p><p>This is just another name for the \*(C`:ATTR\*(C' marker (see above). The plural form is convenient when you want to specify a series of attribute hashes in the same statement:     my (         %name_of,         %rank_of,         %snum_of,         %age_of,         %unit_of,         %assignment_of,         %medals_of,     ) : ATTRS;</p>
<h3>Method traits that can be ascribed</h3>
<p>The following markers can be added to the definition of any subroutine used as a method within a Class::Std class Occasionally, it is useful to be able to create subroutines that can only be accessed within a class's own hierarchy (that is, by derived classes). And sometimes it's even more useful to be able to create methods that can only be called within a class itself. Typically these types of methods are <em>utility</em> methods: subroutines that provide some internal service for a class, or a class hierarchy. Class::Std supports the creation of these kinds of methods by providing two special markers: \*(C`:RESTRICTED()\*(C' and \*(C`:PRIVATE()\*(C'. Methods marked \*(C`:RESTRICTED()\*(C' are modified at the end of the compilation phase so that they throw an exception when called from outside a class's hierarchy. Methods marked \*(C`:PRIVATE()\*(C' are modified so that they throw an exception when called from outside the class in which they're declared. For example:     package DogTag;     use Class::Std;     {         my %ID_of   : ATTR;         my %rank_of : ATTR;</p><p>        my $ID_num = 0;</p><p>        sub _allocate_next_ID : RESTRICTED {             my ($self) = @_;             $ID_of{ident $self} = $ID_num++;             return;         }</p><p>        sub _check_rank : PRIVATE {             my ($rank) = @_;             return $rank if $VALID_RANK{$rank};             croak "Unknown rank ($rank) specified";         }</p><p>        sub BUILD {             my ($self, $ident, $arg_ref) = @_;</p><p>            $self-&gt;_allocate_next_ID();             $rank_of{$ident} = _check_rank($arg_ref-&gt;{rank});         }     } Of course, this code would run exactly the same without the \*(C`:RESTRICTED()\*(C' and \*(C`:PRIVATE()\*(C' markers, but they ensure that any attempt to call the two subroutines inappropriately:     package main;</p><p>    my $dogtag = DogTag-&gt;new({ rank =&gt; &apos;PFC&apos; });</p><p>    $dogtag-&gt;_allocate_next_ID(); is suitably punished:     Can&apos;t call restricted method DogTag::_allocate_next_ID() from class main One of the most important advantages of using the \*(C`BUILD()\*(C' and \*(C`DEMOLISH()\*(C' mechanisms supplied by Class::Std is that those methods don't require nested calls to their ancestral methods, via the \*(C`SUPER\*(C' pseudo-class. The constructor and destructor provided by Class::Std take care of the necessary redispatching automatically. Each \*(C`BUILD()\*(C' method can focus solely on its own responsibilities; it doesn't have to also help orchestrate the cumulative constructor effects across the class hierarchy by remembering to call \*(C`$self-&gt;SUPER::BUILD()\*(C'. Moreover, calls via \*(C`SUPER\*(C' can only ever call the method of exactly one ancestral class, which is not sufficient under multiple inheritance. Class::Std provides a different way of creating methods whose effects accumulate through a class hierarchy, in the same way as those of \*(C`BUILD()\*(C' and \*(C`DEMOLISH()\*(C' do. Specifically, the module allows you to define your own \*(L"cumulative methods\*(R". An ordinary non-cumulative method hides any method of the same name inherited from any base class, so when a non-cumulative method is called, only the most-derived version of it is ever invoked. In contrast, a cumulative method doesn't hide ancestral methods of the same name; it assimilates them. When a cumulative method is called, the most-derived version of it is invoked, then any parental versions, then any grandparental versions, etc. etc, until every cumulative method of the same name throughout the entire hierarchy has been called. For example, you could define a cumulative \*(C`describe()\*(C' method to the various classes in a simple class hierarchy like so:     package Wax::Floor;     use Class::Std;     {         my %name_of    :ATTR( init_arg =&gt; &apos;name&apos;   );         my %patent_of  :ATTR( init_arg =&gt; &apos;patent&apos; );</p><p>        sub describe :CUMULATIVE {             my ($self) = @_;</p><p>            print "The floor wax $name_of{ident $self} ",                   "(patent: $patent_of{ident $self})&#92;n";</p><p>            return;         }     }</p><p>    package Topping::Dessert;     use Class::Std;     {         my %name_of     :ATTR( init_arg =&gt; &apos;name&apos;    );         my %flavour_of  :ATTR( init_arg =&gt; &apos;flavour&apos; );</p><p>        sub describe :CUMULATIVE {             my ($self) = @_;</p><p>            print "The dessert topping $name_of{ident $self} ",                   "with that great $flavour_of{ident $self} taste!&#92;n";</p><p>            return;         }     }</p><p>    package Shimmer;     use base qw( Wax::Floor  Topping::Dessert );     use Class::Std;     {         my %name_of    :ATTR( init_arg =&gt; &apos;name&apos;   );         my %patent_of  :ATTR( init_arg =&gt; &apos;patent&apos; );</p><p>        sub describe :CUMULATIVE {             my ($self) = @_;</p><p>            print "New $name_of{ident $self} ",                   "(patent: $patent_of{ident $self})&#92;n",                   "Combining...&#92;n";</p><p>            return;         }     } Because the various \*(C`describe()\*(C' methods are marked as being cumulative, a subsequent call to:     my $product         = Shimmer-&gt;new({               name    =&gt; &apos;Shimmer&apos;,               patent  =&gt; 1562516251,               flavour =&gt; &apos;Vanilla&apos;,           });</p><p>    $product-&gt;describe(); will work its way up through the classes of Shimmer's inheritance tree (in the same order as a destructor call would), calling each \*(C`describe()\*(C' method it finds along the way. So the single call to \*(C`describe()\*(C' would invoke the corresponding method in each class, producing:     New Shimmer (patent: 1562516251)     Combining...     The floor wax Shimmer (patent: 1562516251)     The dessert topping Shimmer with that great Vanilla taste! Note that the accumulation of \*(C`describe()\*(C' methods is hierarchical, and dynamic in nature. That is, each class only sees those cumulative methods that are defined in its own package or in one of its ancestors. So calling the same \*(C`describe()\*(C' on a base class object:     my $wax         = Wax::Floor-&gt;new({ name=&gt;&apos;Shimmer &apos;, patent=&gt;1562516251 });</p><p>    $wax-&gt;describe(); only invokes the corresponding cumulative methods from that point on up the hierarchy, and hence only prints:     The floor wax Shimmer (patent: 1562516251) Cumulative methods also accumulate their return values. In a list context, they return a (flattened) list that accumulates the lists returned by each individual method invoked. In a scalar context, a set of cumulative methods returns an object that, in a string context, concatenates individual scalar returns to produce a single string. When used as an array reference that same scalar-context-return object acts like an array of the list context values. When used as a hash reference, the object acts like a hash whose keys are the classnames from the object's hierarchy, and whose corresponding values are the return values of the cumulative method from that class. For example, if the classes each have a cumulative method that returns their list of sales features:     package Wax::Floor;     use Class::Std;     {         sub feature_list :CUMULATIVE {             return (&apos;Long-lasting&apos;, &apos;Non-toxic&apos;, &apos;Polymer-based&apos;);         }     }</p><p>    package Topping::Dessert;     use Class::Std;     {         sub feature_list :CUMULATIVE {             return (&apos;Low-carb&apos;, &apos;Non-dairy&apos;, &apos;Sugar-free&apos;);         }     }</p><p>    package Shimmer;     use Class::Std;     use base qw( Wax::Floor  Topping::Dessert );     {         sub feature_list :CUMULATIVE {             return (&apos;Multi-purpose&apos;, &apos;Time-saving&apos;, &apos;Easy-to-use&apos;);         }     } then calling <em>feature_list()</em> in a list context:     my @features = Shimmer-&gt;feature_list();     print "Shimmer is the @features alternative!&#92;n"; would produce a concatenated list of features, which could then be interpolated into a suitable sales-pitch:     Shimmer is the Multi-purpose Time-saving Easy-to-use     Long-lasting Non-toxic Polymer-based Low-carb Non-dairy     Sugar-free alternative! It's also possible to specify a set of cumulative methods that start at the base class(es) of the hierarchy and work downwards, the way \s-1<em>BUILD\s0()</em> does. To get that effect, you simply mark each method with :CUMULATIVE(\s-1BASE\s0 \s-1FIRST\s0), instead of just :CUMULATIVE. For example:     package Wax::Floor;     use Class::Std;     {         sub active_ingredients :CUMULATIVE(BASE FIRST) {             return "&#92;tparadichlorobenzene, cyanoacrylate, peanuts&#92;n";         }     }</p><p>    package Topping::Dessert;     use Class::Std;     {         sub active_ingredients :CUMULATIVE(BASE FIRST) {             return "&#92;tsodium hypochlorite, isobutyl ketone, ethylene glycol&#92;n";         }     }</p><p>    package Shimmer;     use Class::Std;     use base qw( Wax::Floor  Topping::Dessert );</p><p>    {         sub active_ingredients :CUMULATIVE(BASE FIRST) {             return "&#92;taromatic hydrocarbons, xylene, methyl mercaptan&#92;n";         }     } So a scalar-context call to <em>active_ingredients()</em>:     my $ingredients = Shimmer-&gt;active_ingredients();     print "May contain trace amounts of:&#92;n$ingredients"; would start in the base classes and work downwards, concatenating base- class ingredients before those of the derived class, to produce:     May contain trace amounts of:         paradichlorobenzene, cyanoacrylate, peanuts         sodium hypochlorite, isobutyl ketone, ethylene glycol         aromatic hydrocarbons, xylene, methyl mercaptan Or, you could treat the return value as a hash:     print Data::Dumper::Dumper &#92;%{$ingredients}; and see which ingredients came from where:     $VAR1 = {        &apos;Shimmer&apos;             =&gt; &apos;aromatic hydrocarbons, xylene, methyl mercaptan&apos;,</p><p>       &apos;Topping::Dessert&apos;             =&gt; &apos;sodium hypochlorite, isobutyl ketone, ethylene glycol&apos;,</p><p>        &apos;Wax::Floor&apos;             =&gt; &apos;Wax: paradichlorobenzene,  hydrogen peroxide, cyanoacrylate&apos;,     }; Note that you can't specify both \*(C`:CUMULATIVE\*(C' and \*(C`:CUMULATIVE(BASE FIRST)\*(C' on methods of the same name in the same hierarchy. The resulting set of methods would have no well-defined invocation order, so Class::Std throws a compile-time exception instead. If you define a method and add the \*(C`:STRINGIFY\*(C' marker then that method is used whenever an object of the corresponding class needs to be coerced to a string. In other words, instead of:     # Convert object to a string...     sub as_str {         ...     }</p><p>    # Convert object to a string automatically in string contexts...     use overload (         q{""}    =&gt; &apos;as_str&apos;,         fallback =&gt; 1,     ); you can just write:     # Convert object to a string (automatically in string contexts)...     sub as_str : STRINGIFY {         ...     } If you define a method and add the \*(C`:NUMERIFY\*(C' marker then that method is used whenever an object of the corresponding class needs to be coerced to a number. In other words, instead of:     # Convert object to a number...     sub as_num {         ...     }</p><p>    # Convert object to a string automatically in string contexts...     use overload (         q{0+}    =&gt; &apos;as_num&apos;,         fallback =&gt; 1,     ); you can just write:     # Convert object to a number (automatically in numeric contexts)...     sub as_num : NUMERIFY {         ...     } If you define a method and add the \*(C`:BOOLIFY\*(C' marker then that method is used whenever an object of the corresponding class needs to be coerced to a boolean value. In other words, instead of:     # Convert object to a boolean...     sub as_bool {         ...     }</p><p>    # Convert object to a boolean automatically in boolean contexts...     use overload (         q{bool}    =&gt; &apos;as_bool&apos;,         fallback =&gt; 1,     ); you can just write:     # Convert object to a boolean (automatically in boolean contexts)...     sub as_bool : BOOLIFY {         ...     } If a method is defined with one of these markers, then it is automatically called whenever an object of that class is treated as a reference of the corresponding type. For example, instead of:     sub as_hash {         my ($self) = @_;</p><p>        return {             age      =&gt; $age_of{ident $self},             shoesize =&gt; $shoe_of{ident $self},         };     }</p><p>    use overload (         &apos;%{}&apos;    =&gt; &apos;as_hash&apos;,         fallback =&gt; 1,     ); you can just write:     sub as_hash : HASHIFY {         my ($self) = @_;</p><p>        return {             age      =&gt; $age_of{ident $self},             shoesize =&gt; $shoe_of{ident $self},         };     } Likewise for methods that allow an object to be treated as a scalar reference (\*(C`:SCALARIFY\*(C'), a array reference (\*(C`:ARRAYIFY\*(C'), a subroutine reference (\*(C`:CODIFY\*(C'), or a typeglob reference (\*(C`:GLOBIFY\*(C').</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DIAGNOSTICS</h2>
        <div class="sectioncontent">
<p>You tried to call the <em>Class::Std::new()</em> constructor on a class that isn't built using Class::Std. Did you forget to write \*(C`use Class::Std\*(C' after the package declaration? The constructors created by Class::Std require all initializer values to be passed in a hash, but you passed something that wasn't a hash. Put your constructor arguments in a hash. You specified that one or more attributes had initializer values (using the \*(C`init\*(C' argument inside the attribute's \*(C`ATTR\*(C' marker), but then failed to pass in the corresponding initialization value. Often this happens because the initialization value <em>was</em> passed, but the key specifying the attribute name was misspelled.</p>
<dl class='dl-vertical'>
  <dt>
    Can't make anonymous subroutine cumulative
  </dt>
  <dd>
    <p>You attempted to use the \*(C`:CUMULATIVE\*(C' marker on an anonymous subroutine. But that marker can only be applied to the named methods of a class. Convert the anonymous subroutine to a named subroutine, or find some other way to make it interoperate with other methods. You defined a \*(C`:CUMULATIVE\*(C' and a \*(C`:CUMULATIVE(BASE FIRST)\*(C' method of the same name in two classes within the same hierarchy. Since methods can only be called going strictly up through the hierarchy or going strictly down through the hierarchy, specifying both directions is obviously a mistake. Either rename one of the methods, or decide whether they should accumulate upwards or downwards.</p>
  </dd>
  <dt>
    Missing new value in call to 'set_%s' method
  </dt>
  <dd>
    <p>You called an attribute setter method without providing a new value for the attribute. Often this happens because you passed an array that happened to be empty. Make sure you pass an actual value. You attempted to call a method on an object but no such method is defined anywhere in the object's class hierarchy. Did you misspell the method name, or perhaps misunderstand which class the object belongs to? A method was declared with a \*(C`:RESTRICTED\*(C' or \*(C`:PRIVATE\*(C', like so:     sub foo :RESTRICTED;     sub bar :PRIVATE; But the actual subroutine was not defined by the end of the compilation phase, when the module needed it so it could be rewritten to restrict or privatize it. The specified method was declared with a \*(C`:RESTRICTED\*(C' marker but subsequently called from outside its class hierarchy. Did you call the wrong method, or the right method from the wrong place? The specified method was declared with a \*(C`:PRIVATE\*(C' marker but subsequently called from outside its own class. Did you call the wrong method, or the right method from the wrong place? Your code is okay, but it uncovered a bug in the Class::Std module. \*(L"\s-1BUGS\s0 \s-1AND\s0 \s-1LIMITATIONS\s0\*(R" explains how to report the problem.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONFIGURATION AND ENVIRONMENT</h2>
        <div class="sectioncontent">
<p>Class::Std requires no configuration files or environment variables.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DEPENDENCIES</h2>
        <div class="sectioncontent">
<p>Class::Std depends on the following modules:</p><ul>
<li><p>version</p></li><li><p>Scalar::Util</p></li><li><p>Data::Dumper</p></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INCOMPATIBILITIES</h2>
        <div class="sectioncontent">
<p>Incompatible with the Attribute::Handlers module, since both define meta-attributes named :ATTR.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS AND LIMITATIONS</h2>
        <div class="sectioncontent">
<ul>
<li><p>Does not handle threading (including \*(C`fork()\*(C' under Windows).</p></li><li><p>\*(C`:ATTR\*(C' declarations must all be on the same line (due to a limitation in Perl itself).</p></li><li><p>\*(C`:ATTR\*(C' declarations cannot include variables, since these are not interpolated into the declaration (a limitation in Perl itself).</p></li>
</ul><p>Please report any bugs or feature requests to \*(C`bug-class-std@rt.cpan.org\*(C', or through the web interface at &lt;http://rt.cpan.org&gt;.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ALTERNATIVES</h2>
        <div class="sectioncontent">
<p>Inside-out objects are gaining in popularity and there are now many other modules that implement frameworks for building inside-out classes. These include:</p>
<dl class='dl-vertical'>
  <dt>
    Object::InsideOut
  </dt>
  <dd>
    <p>Array-based objects, with support for threading. Many excellent features (especially thread-safety), but slightly less secure than Class::Std, due to non-encapsulation of attribute data addressing.</p>
  </dd>
  <dt>
    Class::InsideOut
  </dt>
  <dd>
    <p>A minimalist approach to building inside-out classes.</p>
  </dd>
  <dt>
    Lexical::Attributes
  </dt>
  <dd>
    <p>Uses source filters to provide a near-Perl 6 approach to declaring inside-out classes.</p>
  </dd>
  <dt>
    Class::Std::Storable
  </dt>
  <dd>
    <p>Adds serialization/deserialization to Class::Std.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Damian Conway  \*(C`&lt;DCONWAY@cpan.org&gt;\*(C'</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LICENCE AND COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright (c) 2005, Damian Conway \*(C`&lt;DCONWAY@cpan.org&gt;\*(C'. All rights reserved.</p><p>Portions of the documentation from \*(L"Perl Best Practices\*(R" copyright (c) 2005 by O'Reilly Media, Inc. and reprinted with permission.</p><p>This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DISCLAIMER OF WARRANTY</h2>
        <div class="sectioncontent">
<p>\s-1BECAUSE\s0 \s-1THIS\s0 \s-1SOFTWARE\s0 \s-1IS\s0 \s-1LICENSED\s0 \s-1FREE\s0 \s-1OF\s0 \s-1CHARGE\s0, \s-1THERE\s0 \s-1IS\s0 \s-1NO\s0 \s-1WARRANTY\s0 \s-1FOR\s0 \s-1THE\s0 \s-1SOFTWARE\s0, \s-1TO\s0 \s-1THE\s0 \s-1EXTENT\s0 \s-1PERMITTED\s0 \s-1BY\s0 \s-1APPLICABLE\s0 \s-1LAW\s0. \s-1EXCEPT\s0 \s-1WHEN\s0 \s-1OTHERWISE\s0 \s-1STATED\s0 \s-1IN\s0 \s-1WRITING\s0 \s-1THE\s0 \s-1COPYRIGHT\s0 \s-1HOLDERS\s0 \s-1AND/OR\s0 \s-1OTHER\s0 \s-1PARTIES\s0 \s-1PROVIDE\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \*(L"\s-1AS\s0 \s-1IS\s0\*(R" \s-1WITHOUT\s0 \s-1WARRANTY\s0 \s-1OF\s0 \s-1ANY\s0 \s-1KIND\s0, \s-1EITHER\s0 \s-1EXPRESSED\s0 \s-1OR\s0 \s-1IMPLIED\s0, \s-1INCLUDING\s0, \s-1BUT\s0 \s-1NOT\s0 \s-1LIMITED\s0 \s-1TO\s0, \s-1THE\s0 \s-1IMPLIED\s0 \s-1WARRANTIES\s0 \s-1OF\s0 \s-1MERCHANTABILITY\s0 \s-1AND\s0 \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0. \s-1THE\s0 \s-1ENTIRE\s0 \s-1RISK\s0 \s-1AS\s0 \s-1TO\s0 \s-1THE\s0 \s-1QUALITY\s0 \s-1AND\s0 \s-1PERFORMANCE\s0 \s-1OF\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1IS\s0 \s-1WITH\s0 \s-1YOU\s0. \s-1SHOULD\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1PROVE\s0 \s-1DEFECTIVE\s0, \s-1YOU\s0 \s-1ASSUME\s0 \s-1THE\s0 \s-1COST\s0 \s-1OF\s0 \s-1ALL\s0 \s-1NECESSARY\s0 \s-1SERVICING\s0, \s-1REPAIR\s0, \s-1OR\s0 \s-1CORRECTION\s0.</p><p>\s-1IN\s0 \s-1NO\s0 \s-1EVENT\s0 \s-1UNLESS\s0 \s-1REQUIRED\s0 \s-1BY\s0 \s-1APPLICABLE\s0 \s-1LAW\s0 \s-1OR\s0 \s-1AGREED\s0 \s-1TO\s0 \s-1IN\s0 \s-1WRITING\s0 \s-1WILL\s0 \s-1ANY\s0 \s-1COPYRIGHT\s0 \s-1HOLDER\s0, \s-1OR\s0 \s-1ANY\s0 \s-1OTHER\s0 \s-1PARTY\s0 \s-1WHO\s0 \s-1MAY\s0 \s-1MODIFY\s0 \s-1AND/OR\s0 \s-1REDISTRIBUTE\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1AS\s0 \s-1PERMITTED\s0 \s-1BY\s0 \s-1THE\s0 \s-1ABOVE\s0 \s-1LICENCE\s0, \s-1BE\s0 \s-1LIABLE\s0 \s-1TO\s0 \s-1YOU\s0 \s-1FOR\s0 \s-1DAMAGES\s0, \s-1INCLUDING\s0 \s-1ANY\s0 \s-1GENERAL\s0, \s-1SPECIAL\s0, \s-1INCIDENTAL\s0, \s-1OR\s0 \s-1CONSEQUENTIAL\s0 \s-1DAMAGES\s0 \s-1ARISING\s0 \s-1OUT\s0 \s-1OF\s0 \s-1THE\s0 \s-1USE\s0 \s-1OR\s0 \s-1INABILITY\s0 \s-1TO\s0 \s-1USE\s0 \s-1THE\s0 \s-1SOFTWARE\s0 (\s-1INCLUDING\s0 \s-1BUT\s0 \s-1NOT\s0 \s-1LIMITED\s0 \s-1TO\s0 \s-1LOSS\s0 \s-1OF\s0 \s-1DATA\s0 \s-1OR\s0 \s-1DATA\s0 \s-1BEING\s0 \s-1RENDERED\s0 \s-1INACCURATE\s0 \s-1OR\s0 \s-1LOSSES\s0 \s-1SUSTAINED\s0 \s-1BY\s0 \s-1YOU\s0 \s-1OR\s0 \s-1THIRD\s0 \s-1PARTIES\s0 \s-1OR\s0 A \s-1FAILURE\s0 \s-1OF\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1TO\s0 \s-1OPERATE\s0 \s-1WITH\s0 \s-1ANY\s0 \s-1OTHER\s0 \s-1SOFTWARE\s0), \s-1EVEN\s0 \s-1IF\s0 \s-1SUCH\s0 \s-1HOLDER\s0 \s-1OR\s0 \s-1OTHER\s0 \s-1PARTY\s0 \s-1HAS\s0 \s-1BEEN\s0 \s-1ADVISED\s0 \s-1OF\s0 \s-1THE\s0 \s-1POSSIBILITY\s0 \s-1OF\s0 \s-1SUCH\s0 \s-1DAMAGES\s0.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Class::Spiffy.3pm.html"><span aria-hidden="true">&larr;</span> Class::Spiffy.3pm: Spiffy framework with no source filtering</a></li>
   <li class="next"><a href="Class::Std::Fast.3pm.html">Class::Std::Fast.3pm: Faster but less secure than class::std <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

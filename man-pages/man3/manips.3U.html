<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>manips: Manipulator subclasses for defining common direct-manipulation semantics</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Manipulator subclasses for defining common direct-manipulation semantics">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="manips (3U) manual">
  <meta name="twitter:description" content="Manipulator subclasses for defining common direct-manipulation semantics">
  <meta name="twitter:image" content="https://www.carta.tech/images/ivtools-dev-manips-3U.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3U/manips.3U.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="manips (3U) manual" />
  <meta property="og:description" content="Manipulator subclasses for defining common direct-manipulation semantics" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/ivtools-dev-manips-3U.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">manips<small> (3U)</small></h1>
        <p class="lead">Manipulator subclasses for defining common direct-manipulation semantics</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3U/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3U/manips.3U.html">
      <span itemprop="name">manips: Manipulator subclasses for defining common direct-manipulation semantics</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/ivtools-dev/">
      <span itemprop="name">ivtools-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3U/manips.3U.html">
      <span itemprop="name">manips: Manipulator subclasses for defining common direct-manipulation semantics</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>#include &lt;Unidraw/manips.h&gt;</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Manipulator is an abstract base class for objects that encapsulate the mechanics of direct manipulation.  Subclasses support different manipulation semantics.  The DragManip subclass implements a downclick-drag-upclick style of interaction, with optional constraints on motion (for example, horizontal or vertical only).  ConnectManip is a DragManip subclass that adds a gravitational bias towards connector views.  VertexManip is a DragManip that supports multiple downclick-and-drag interactions terminated by a distinguished downclick.  TextManip provides a text editing interface.  Finally, ManipGroup composes manipulator instances so that their interaction may proceed concurrently.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DRAGMANIP PUBLIC OPERATIONS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>DragManip(</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    Viewer*, Rubberband*, Transformer* = nil, Tool* = nil,</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    DragConstraint = None</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>DragManip(</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    Viewer*, Rubberband*, Transformer*, Tool*,</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    DragConstraint, Coord, Coord</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>)</strong></p>
  </dt>
  <dd>
    <p>A DragManip uses a rubberband to animate the manipulation.  The constructor takes the rubberband as a parameter along with the viewer in which it should appear, a transformer reflecting the transformation that component views undergo in the viewer, the tool that created the manipulator, and a DragConstraint that effectively restricts mouse motion in one or more ways.  By default, motion is constrained when the Shift key is held down.  The second constructor adds two Coord parameters.  The DragManip will use these values to override the event coordinates when Grasp is first called.</p>
  </dd>
  <dt>
    <p><strong>virtual void Grasp(Event&)</strong></p>
  </dt>
  <dd>
    <p>DragManip redefines Grasp operation to call the rubberband's Track operation, supplying the coordinates in the event.  Grasp calls Constrain (described below) on the event prior to passing the coordinate information.  The rubberband will not be drawn until Grasp is called.</p>
  </dd>
  <dt>
    <p><strong>virtual boolean Manipulating(Event&)</strong></p>
  </dt>
  <dd>
    <p>If the event is a MotionEvent, Manipulating calls Track with the event's coordinates and returns <em>true</em>.  Manipulating simply returns <em>false</em> if the event is an UpEvent.  Like DragManip::Grasp, this operation calls Constrain on the event prior to passing the coordinate information.</p>
  </dd>
  <dt>
    <p><strong>virtual void Effect(Event&)</strong></p>
  </dt>
  <dd>
    <p>Effect simply erases the rubberband by calling its Erase operation.</p>
  </dd>
  <dt>
    <p><strong>virtual void SetViewer(Viewer*)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void SetRubberband(Rubberband*)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void SetTransformer(Transformer*)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void SetTool(Tool*)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void SetConstraint(DragConstraint)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual Viewer* GetViewer()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual Rubberband* GetRubberband()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual Transformer* GetTransformer()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual Tool* GetTool()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual DragConstraint GetConstraint()</strong></p>
  </dt>
  <dd>
    <p>Set and get the various parameters supplied to the DragManip in its constructor.</p>
  </dd>
  <dt>
    <p><strong>const Event& GraspEvent()</strong></p>
  </dt>
  <dd>
    <p>Return the event supplied to the last call to Grasp.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DRAGMANIP PROTECTED OPERATIONS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>void Init(</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    Viewer*, Rubberband*, Transformer*, Tool*, DragConstraint</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>)</strong></p>
  </dt>
  <dd>
    <p>Assign the various constructor values common to both DragManip constructors.</p>
  </dd>
  <dt>
    <p><strong>virtual void Constrain(Event&)</strong></p>
  </dt>
  <dd>
    <p>Constrain the event to reflect the DragConstraint.  The event coordinates are constrained when the event indicates that the shift key is held down for all DragConstraint values except Gravity, which constrains the coordinates unconditionally with the viewer's Constrain operation.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONNECTMANIP PUBLIC OPERATIONS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>ConnectManip(</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    Viewer*, Rubberband*, Transformer* = nil, Tool* = nil</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>)</strong></p>
  </dt>
  <dd>
    <p>ConnectManip supports the same type of interaction as DragManip, except the rubberband tracking is affected by a graviational bias towards connector views.  Whenever the user drags near a connector view, the tracking coordinates are suddenly constrained to coincide with the center of the connector view.  The rubberband will not change its appearance thereafter until the user drags beyond the gravity threshold, which corresponds to SLOP (see globals(3U)) units beyond the nearest point on the connector view.</p>
  </dd>
  <dt>
    <p><strong>virtual boolean Manipulating(Event&)</strong></p>
  </dt>
  <dd>
    <p>ConnectManip redefines Manipulating to support the gravitational effect.</p>
  </dd>
  <dt>
    <p><strong>ConnectorView* GetTarget()</strong></p>
  </dt>
  <dd>
    <p>Return the connector view that has captured the rubberband, if any.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">VERTEXMANIP PUBLIC OPERATIONS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>VertexManip(</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    Viewer*, GrowingVertices*, Transformer* = nil,</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    Tool* = nil, DragConstraint = None</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>)</strong></p>
  </dt>
  <dd>
    <p>VertexManip is like DragManip but supports multiple drags and clicks in one manipulation.  The VertexManip constructor restricts the rubberband to be an instance of GrowingVertices.</p>
  </dd>
  <dt>
    <p><strong>virtual boolean Manipulating(Event&)</strong></p>
  </dt>
  <dd>
    <p>This operation is similar to DragManip's, except it calls AppendVertex on the GrowingVertices rubberband on each down-click and returns <em>false</em> if and only if the middle button is pressed.</p>
  </dd>
  <dt>
    <p><strong>GrowingVertices* GetGrowingVertices()</strong></p>
  </dt>
  <dd>
    <p>Return the GrowingVertices instance.  Use this operation as an alternative to GetRubberband when that operation isn't specific enough.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TEXTMANIP PUBLIC OPERATIONS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>TextManip(Viewer*, Painter*, Coord tabwidth, Tool* = nil)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>TextManip(</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    Viewer*, Painter*, Coord lineheight, Coord tabwidth,</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    Tool* = nil</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>)</strong></p>
  </dt>
  <dd>
    <p>Create a TextManip, supplying (at minimum) a viewer, a painter with which to draw (usually reflecting graphics attributes defined by the enclosing editor object), and the width of a tab character.  Tab characters in the text will position the following character at an integral multiple of <em>tabwidth</em> from the beginning of the line. The distance between baselines in the text can be specified with the second constructor; this value corresponds to the font height by default.  These constructors create text manipulators containing no text initially; the lower left corner of the first line of text (including the descender) will be positioned at the coordinates in the event passed to the Grasp operation.</p>
  </dd>
  <dt>
    <p><strong>TextManip(</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    Viewer*, const char* buf, int bufsize, Coord x, Coord y,</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    Painter*, Coord tabwidth, Tool* = nil</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>TextManip(</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    Viewer*, const char* buf, int bufsize, Coord x, Coord y,</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    Painter*, Coord lineheight, Coord tabwidth, Tool* = nil</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>)</strong></p>
  </dt>
  <dd>
    <p>Create text manipulators initialized with text by passing a buffer of text and its size.  A copy of the buffer is used internally.  The <em>x</em> and <em>y</em> parameters specify the position of the lower left corner of the first line of text (including the descender).  These coordinates will override the coordinates specified by the event passed to Grasp.</p>
  </dd>
  <dt>
    <p><strong>virtual void Grasp(Event&)</strong></p>
  </dt>
  <dd>
    <p>Positions and draws the text.  If the position-specifing constructors were used to create the instance, then the manipulator will use the event coordinates to set the insertion point's position in the text.</p>
  </dd>
  <dt>
    <p><strong>virtual boolean Manipulating(Event&)</strong></p>
  </dt>
  <dd>
    <p>Handle keystrokes and/or mouse motion events to support basic text editing.  Motion events are interpreted to support text selection; selected text is displayed in reverse colors.  The Manipulating operation returns <em>false</em> if a downclick is detected outside the text or if HandleKey (described below) returns <em>false</em>.</p>
  </dd>
  <dt>
    <p><strong>virtual void Effect(Event&)</strong></p>
  </dt>
  <dd>
    <p>Effect damages the viewer area that TextManip corrupted during editing.</p>
  </dd>
  <dt>
    <p><strong>virtual Painter* GetPainter()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual Coord GetLineHeight()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual Coord GetTabWidth()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual const char* GetText(int&)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void GetPosition(Coord&, Coord&)</strong></p>
  </dt>
  <dd>
    <p>Return various parameters specified in the constructor.  GetText returns a pointer to the internal buffer containing the text; the reference parameter returns the buffer's size.</p>
  </dd>
  <dt>
    <p><strong>const Event& GraspEvent()</strong></p>
  </dt>
  <dd>
    <p>Return the event supplied to the last call to Grasp.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TEXTMANIP PROTECTED OPERATIONS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>virtual boolean HandleKey(Event&)</strong></p>
  </dt>
  <dd>
    <p>This operation defines TextManip's default key bindings as described below.  Unless otherwise noted below, this function returns <em>true</em>.</p><p><strong>(^P)</strong> backward line</p><p><strong>(^N)</strong> forward line</p><p><strong>(^B)</strong> backward character</p><p><strong>(^F)</strong> forward character</p><p><strong>(ESC)</strong> terminate text entry, causing HandleKey to return <em>false</em></p><p><strong>(^A)</strong> beginning of line</p><p><strong>(^E)</strong> end of line</p><p><strong>(^D)</strong> delete character</p><p><strong>(DEL) (^H)</strong> delete backward character</p>
  </dd>
  <dt>
    <p><strong>int Dot()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>int Mark()</strong></p>
  </dt>
  <dd>
    <p>The current selection is bounded by two indices into the text buffer. By convention these indices are called dot and mark.  Dot is the position at which text will be inserted and deleted.  Mark locates the end of the selection that moves as the selection is modified.  When the selection is empty (an insertion point), dot and mark are equal.</p>
  </dd>
  <dt>
    <p><strong>void InsertText(const char* string, int count)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void InsertCharacter(char)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void DeleteText(int count)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void DeleteCharacter(int)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void DeleteLine()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void DeleteSelection()</strong></p>
  </dt>
  <dd>
    <p>Edit the text buffer at the current selection.  InsertText inserts count characters from string after dot.  The selection becomes an insertion point following the newly inserted text.  InsertCharacter replaces the selected characters with a single character. DeleteText deletes count characters at dot.  If count is positive, the characters following dot are deleted; if count is negative the characters before dot are deleted.  The selection becomes an insertion point in the place of the deleted text.  DeleteSelection deletes the text between dot and mark, changing the selection to an insertion point. DeleteCharacter is identical to DeleteText if the dot and mark are not the same; otherwise it is identical to DeleteSelection. DeleteCharacter provides a convenient way to express the behavior of the backspace and delete operations.  Finally, DeleteLine deletes the line of text containing mark.  The selection becomes an insertion point at mark.</p>
  </dd>
  <dt>
    <p><strong>void BackwardCharacter(int count)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void ForwardCharacter(int count)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void BackwardLine(int count)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void ForwardLine(int count)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void BackwardWord(int count)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void ForwardWord(int count)</strong></p>
  </dt>
  <dd>
    <p>Move the current selection forward or backward by the specified number of the specified units.  The default movement is one unit.  The selection is not moved before the beginning of after the end of the text.</p>
  </dd>
  <dt>
    <p><strong>void BeginningOfLine()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void EndOfLine()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void BeginningOfWord()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void EndOfWord()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void BeginningOfSelection()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void EndOfSelection()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void BeginningOfText()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void EndOfText()</strong></p>
  </dt>
  <dd>
    <p>Move the current selection forwards or backwards to the specified feature of the text.</p>
  </dd>
  <dt>
    <p><strong>void Select(int dot)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void Select(int dot, int mark)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void SelectMore(int mark)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void SelectAll()</strong></p>
  </dt>
  <dd>
    <p>Modify the current selection in terms of text indices.  With a single parameter, Select moves both dot and mark to the specified index. With two parameters, dot and mark can be controlled independently. SelectMore leaves dot unchanged and moves mark.  SelectAll sets dot to the end of the text and mark to the beginning.</p>
  </dd>
  <dt>
    <p><strong>int Locate(Coord x, Coord y)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>boolean Contains(Coord, Coord)</strong></p>
  </dt>
  <dd>
    <p>Locate returns the text index most closely matching the point (<em>x</em>, <em>y</em>).  Contains returns whether the text contains the point (<em>x</em>, <em>y</em>).</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MANIPGROUP PUBLIC OPERATIONS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>ManipGroup(Viewer* = nil, Tool* = nil)</strong></p>
  </dt>
  <dd>
    <p>Create a ManipGroup, optionally supplying a viewer and a tool.</p>
  </dd>
  <dt>
    <p><strong>virtual void Grasp(Event&)</strong></p>
  </dt>
  <dd>
    <p>The Grasp operation simply calls Grasp on each child in insertion order.</p>
  </dd>
  <dt>
    <p><strong>virtual boolean Manipulating(Event&)</strong></p>
  </dt>
  <dd>
    <p>Manipulating calls the corresponding operation on each child, skipping those children that have returned <em>false</em> in previous calls (up to the last Grasp).  This function returns <em>false</em> when all children have done so.</p>
  </dd>
  <dt>
    <p><strong>virtual void Effect(Event&)</strong></p>
  </dt>
  <dd>
    <p>ManipGroup's Effect operation calls Effect on each child.</p>
  </dd>
  <dt>
    <p><strong>virtual void SetViewer(Viewer*)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void SetTool(Tool*)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual Viewer* GetViewer()</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual Tool* GetTool()</strong></p>
  </dt>
  <dd>
    <p>Set and get the ManipGroup's viewer and tool.  The set operations set the ManipGroup's values for these parameters and call the corresponding operations on their children.  The get operations simply return the ManipGroup's values.</p>
  </dd>
  <dt>
    <p><strong>virtual void First(Iterator&)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void Last(Iterator&)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void Next(Iterator&)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual void Prev(Iterator&)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>virtual boolean Done(Iterator)</strong></p>
  </dt>
  <dd>
    <p>Operations for iterating over the ManipGroup's children, if any. First and Last initialize an iterator to point to the beginning and end of the list of children, respectively.  Next increments the iterator to point to the following child, while Prev decrements the iterator to point to the preceding child.  Done returns whether or not the iterator points beyond the first or last child in the list.</p>
  </dd>
  <dt>
    <p><strong>Manipulator* GetManip(Iterator)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void SetManip(Manipulator*, Iterator&)</strong></p>
  </dt>
  <dd>
    <p>GetManip returns the child manipulator to which an iterator points. SetManip initializes an iterator to point to a particular child; it initializes the iterator to point to a nil instance if the given Manipulator is not a child of the ManipGroup.</p>
  </dd>
  <dt>
    <p><strong>void Append(</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    Manipulator*,</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    Manipulator* = nil, Manipulator* = nil, Manipulator* = nil</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void Prepend(</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    Manipulator*,</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>    Manipulator* = nil, Manipulator* = nil, Manipulator* = nil</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void InsertBefore(Iterator, Manipulator*)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void InsertAfter(Iterator, Manipulator*)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void Remove(Manipulator*)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>void Remove(Iterator&)</strong></p>
  </dt>
  <dd>
    <p>Operations for modifying the ManipGroup's list of children.  Append and Prepend add up to four child manipulators, in order, to the end and the beginning of the list, respectively.  InsertAfter and InsertBefore insert a child after and before the manipulator pointed to by the iterator, respectively.  The Remove operations remove a child from the list (without deleting it).  You can remove a child by referring to it explicitly or by specifying an iterator.  If an iterator is supplied, the Remove operation will advance it to point to the following child as a side effect.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MANIPGROUP PROTECTED OPERATIONS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>UList* Elem(Iterator)</strong></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong>Manipulator* Manip(UList*)</strong></p>
  </dt>
  <dd>
    <p>ManipGroup stores its children on a UList, which is accessible via the <em>_kids</em> protected member.  The Selection's iteration operations store the UList containing the current child in their iterator.  Elem is a convenience function for returning the UList to which an iterator points, and Manip extracts the child that a UList element contains.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO manips&hellip;</h2>
        <div class="sectioncontent">
<p>Connector(3U), Event(3I), Iterator(3U), Manipulator(3U), Painter(3I), Rubband(3I), Tool(3U), Transformer(3I), UList(3U), Viewer(3U), globals(3U)</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="lines.3U.html"><span aria-hidden="true">&larr;</span> lines.3U: Structured graphics classes for points, lines, and open polygons</a></li>
   <li class="next"><a href="polygons.3U.html">polygons.3U: Structured graphics classes for rectangles and polygons <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

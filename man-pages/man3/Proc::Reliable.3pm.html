<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Proc::Reliable: Run external processes reliably with many options.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Run external processes reliably with many options.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Proc::Reliable (3pm) manual">
  <meta name="twitter:description" content="Run external processes reliably with many options.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libproc-reliable-perl-Proc::Reliable-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Proc::Reliable.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Proc::Reliable (3pm) manual" />
  <meta property="og:description" content="Run external processes reliably with many options." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libproc-reliable-perl-Proc::Reliable-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Proc::Reliable<small> (3pm)</small></h1>
        <p class="lead">Run external processes reliably with many options.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Proc::Reliable.3pm.html">
      <span itemprop="name">Proc::Reliable: Run external processes reliably with many options.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libproc-reliable-perl/">
      <span itemprop="name">libproc-reliable-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Proc::Reliable.3pm.html">
      <span itemprop="name">Proc::Reliable: Run external processes reliably with many options.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>use Proc::Reliable;</p><p>Create a new process object</p>
<pre>
   $myproc = Proc::Reliable-&gt;new();
</pre>
<p>Run a subprocess and collect its output</p><p>   $output = $myproc-&gt;run("/bin/ls -l");</p><p>Check for problems</p><p>   if($myproc-&gt;status()) {      print("problem!&#92;n");    }</p><p>Run another subprocess, keeping stdout and stderr separated. Also, send the subprocess some data on stdin.</p><p>   $msg = "Hello World&#92;n");    $p-&gt;<strong>want_single_list</strong>(0);    $stdout = $p-&gt;run("/usr/bin/fastmail - foo@bar.com", $msg);    if($p-&gt;status()) {      print("problem: ", $p-&gt;stderr(), "&#92;n");    }</p><p>Another way to get output</p><p>   ($stdout, $stderr, $status, $msg) = $p-&gt;run("/bin/ls -l");</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONS</h2>
        <div class="sectioncontent">
<p>Run Modes</p><p> $p-&gt;run("shell-command-line");  # Launch a shell process  $p-&gt;run("cmdline", "data");     # Launch a shell process with stdin data  $p-&gt;run(["cmd", "arg1", ...]);  # Bypass shell processing of arguments  $p-&gt;run(sub { ... });           # Launch a perl subroutine  $p-&gt;run(&#92;&subroutine);          # Launch a perl subroutine</p><p>Option settings below represent defaults</p><p> $p-&gt;<strong>num_tries</strong>(1);           # execute the program only once  $p-&gt;time_per_try(60);       # time per try 60 sec  $p-&gt;maxtime(60);            # set overall timeout  $p-&gt;<strong>time_btw_tries</strong>(5);      # time between tries 5 sec  $p-&gt;want_single_list();     # return STDOUT and STDERR together  $p-&gt;accept_no_error();      # Re-try if any STDERR output  $p-&gt;pattern_stdout($pat);   # require STDOUT to match regex $pat  $p-&gt;pattern_stderr($pat);   # require STDERR to match regex $pat  $p-&gt;<strong>allow_shell</strong>(1);         # allowed to use shell for operation  $p-&gt;child_exit_time(1.0);   # timeout for child to exit after it closes stdout  $p-&gt;sigterm_exit_time(0.5); # timeout for child to exit after sigterm  $p-&gt;sigkill_exit_time(0.5); # timeout for child to exit after sigkill  $p-&gt;<strong>input_chunking</strong>(0);      # feed stdin data line-by-line to subprocess  $p-&gt;<strong>stdin_error_ok</strong>(0);      # ok if child exits without reading all stdin  $p-&gt;stdout_cb(undef);       # callback function for line-by-line stdout  $p-&gt;stderr_cb(undef);       # callback function for line-by-line stderr</p><p>Getting output</p><p> $out = $p-&gt;stdout();        # stdout produced by last run()  $err = $p-&gt;stderr();        # stderr produced by last run()  $stat = $p-&gt;status();       # exit code produced by last run()  $msg = $p-&gt;msg();           # module messages produced by last run()</p><p>Debug</p><p>Proc::Reliable::debug($level);         # Turn debug on</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OVERVIEW</h2>
        <div class="sectioncontent">
<p>Proc::Reliable is a class for simple, reliable and configurable subprocess execution in perl.  In particular, it is especially useful for managing the execution of 'problem' programs which are likely to fail, hang, or otherwise behave in an unruly manner.</p><p>Proc::Reliable includes all the functionality of the backticks operator and <em>system()</em> functions, plus many common uses of <em>fork()</em> and <em>exec()</em>, <em>open2()</em> and <em>open3()</em>. Proc::Reliable incorporates a number of options, including sending data to the subprocess on \s-1STDIN\s0, collecting \s-1STDOUT\s0 and \s-1STDERR\s0 separately or together, killing hung processes, timouts and automatic retries.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>A new process object is created by</p><p>   $myproc = Proc::Reliable-&gt;new();</p><p>The default will run a subprocess only once with a 60-second timeout. Either shell-like command lines or references to perl subroutines can be specified for launching a process in background.  A simple list process, for example, can be started via the shell as</p><p>   $out = $myproc-&gt;run("ls");</p><p>To separate stdout, stderr, and exit status:</p><p>   ($out, $err, $status, $msg) = $myproc-&gt;run("ls");</p><p>The output data is also stored within the $myproc object for later retrieval.  You can also run a perl subroutine in a subprocess, with</p><p>   $myproc-&gt;run(sub { return &lt;*&gt;; });</p><p>The <em>run</em> Method will try to run the named process.  If the process times out (after <em>time_per_try</em> seconds) or has an error defined as unacceptable and you would like to re-run it, you can use the <em>num_tries</em> option.  Use the <em>time_btw_tries</em> option to set the number of seconds between runs.  This can repeat until <em>maxtime</em> seconds have elapsed.</p><p>When using <em>num_tries</em>, the user can specify what constitutes an unacceptable error of \s-1STDOUT\s0 or \s-1STDERR\s0 output \*(-- i.e. demanding a retry. One common shorthand is to have the <em>run</em> method retry if there is any return from \s-1STDERR\s0.</p><p>   $myproc-&gt;accept_no_error();    # Re-try if any STDERR    $myproc-&gt;pattern_stdout($pat); # require STDOUT to match regex $pat    $myproc-&gt;pattern_stderr($pat); # require STDERR to match regex $pat</p><p>Subprocess completion is detected when the process closes all filehandles. The process must then exit before child_exit_time expires, or it will be killed.  If the subprocess does not exit, it is sent a \s-1TERM\s0 signal unless sigterm_exit_time is 0.  then if it does not exit before sigterm_exit_time expires, it is sent a \s-1KILL\s0 signal unless sigkill_exit_time is 0.  then if it does not exit before sigkill_exit_time expires an error is generated. waiting is done in 0.01 second increments.</p><p>Proc::Reliable is not MT-Safe due to signals usage.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">
<p>The following methods are available:</p>
<dl class='dl-vertical'>
  <dt>
    new (Constructor)
  </dt>
  <dd>
    <p>Create a new instance of this class by writing either     $proc = new Proc::Reliable;   or   $proc = Proc::Reliable-&gt;new(); The <em>new</em> method accepts any valid configuration options:     $proc = Proc::Reliable-&gt;new(&apos;maxtime&apos; =&gt; 200, &apos;num_tries&apos; =&gt; 3);</p>
  </dd>
  <dt>
    run
  </dt>
  <dd>
    <p>Run a new process and collect the standard output and standard error via separate pipes.   $out = $proc-&gt;run("program-name");  ($out, $err, $status, $msg) = $proc-&gt;run("program-name"); by default with a single return value, stdout and stderr are combined to a single stream and returned.  with 4 return values, stdout and stderr are separated, and the program exit status is also returned. $msg contains messages from Proc::Reliable when errors occur. Set <em>want_single_list</em>\|(1) to force stdout and stderr to be combined, and <em>want_single_list</em>\|(0) to force them separated.  The results from <em>run()</em> are stored as member data also:   $proc-&gt;<strong>want_single_list</strong>(0);   $proc-&gt;run("program");   if($proc-&gt;status) {     print($proc-&gt;stderr);     exit;   }   else {     print($proc-&gt;stdout);   } Program exit status is returned in the same format as <em>exec()</em>: bits 0-7 set if program exited from a signal, bits 8-15 are the exit status on a normal program exit. You can also set up callbacks to run a function of your choice as each line of stdout and stderr is produced by the child process using the stdout_cb and stderr_cb options. There are a number of other options. You can also feed the forked program data on stdin via a second argument to <em>run()</em>:  $myinput = "hello&#92;ntest&#92;n";  $output = $proc-&gt;run("program-name", $myinput); The first option to <em>run()</em> supports three forms: 1) string containing command string to execute.  this incurs shell parsing. 2) arrayref containing split command string to execute.  this bypasses shell parsing. 3) coderef to perl function. The first two options are executed via <em>exec()</em>, so the specifics of incurring shell parsing are the same. The second option to <em>run()</em> supports two forms: 1) string containing data to feed on stdin 2) stringref pointing to data to feed on stdin You can start execution of an independent Perl function (like \*(L"eval\*(R" except with timeout, retries, etc.).  Simply provide the function reference like  $output = $proc-&gt;run(&#92;&perl_function); or supply an unnamed subroutine:  $output = $proc-&gt;run( sub { <a href="../man1/sleep.1.html"><strong>sleep</strong>(1)</a> } ); The <em>run</em> Method returns after the the function finishes, one way or another.</p>
  </dd>
  <dt>
    debug
  </dt>
  <dd>
    <p>Switches debug messages on and off \*(-- <em>Proc::Reliable::debug</em>\|(1) switches them on, <em>Proc::Reliable::debug</em>\|(0) keeps Proc::Reliable quiet.</p>
  </dd>
  <dt>
    maxtime
  </dt>
  <dd>
    <p>Return or set the maximum time in seconds per <em>run</em> method call. Default is 300 seconds (i.e. 5 minutes).</p>
  </dd>
  <dt>
    num_tries
  </dt>
  <dd>
    <p>Return or set the maximum number of tries the <em>run</em> method will attempt an operation if there are unallowed errors.  Default is 5.</p>
  </dd>
  <dt>
    time_per_try
  </dt>
  <dd>
    <p>Return or set the maximum time in seconds for each attempt which <em>run</em> makes of an operation.  Multiple tries in case of error can go longer than this.  Default is 30 seconds.</p>
  </dd>
  <dt>
    time_btw_tries
  </dt>
  <dd>
    <p>Return or set the time in seconds between attempted operations in case of unacceptable error.  Default is 5 seconds.</p>
  </dd>
  <dt>
    child_exit_time
  </dt>
  <dd>
    <p>When the subprocess closes stdout, it is assumed to have completed normal operation.  It is expected to exit within the amount of time specified.  If it does not exit, it will be killed (with \s-1SIGTERM\s0). This option can be disabled by setting to '0'. Values are in seconds, with a resolution of 0.01.</p>
  </dd>
  <dt>
    sigterm_exit_time
  </dt>
  <dd>
    <p>If the <em>time_per_try</em> or <em>max_time</em> has been exceeded, or if <em>child_exit_time</em> action has not succeeded, the subprocess will be killed with \s-1SIGTERM\s0.  This option specifies the amount of time to allow the process to exit after closing stdout. This option can be disabled by setting to '0'. Values are in seconds, with a resolution of 0.01.</p>
  </dd>
  <dt>
    sigkill_exit_time
  </dt>
  <dd>
    <p>Similar to <em>sigterm_exit_time</em>, but a \s-1SIGKILL\s0 is sent instead of a \s-1SIGTERM\s0.  When both options are enabled, the \s-1SIGTERM\s0 is sent first and \s-1SIGKILL\s0 is then sent after the specified time only if the subprocess is still alive. This option can be disabled by setting to '0'. Values are in seconds, with a resolution of 0.01.</p>
  </dd>
  <dt>
    input_chunking
  </dt>
  <dd>
    <p>If data is being written to the subprocess on stdin, this option will cause the module to <em>split()</em> the input data at linefeeds, and only feed the subprocess a line at a time.  This option typically would be used when the subprocess is an application with a command prompt and does not work properly when all the data is fed on stdin at once. The module will feed the subprocess one line of data on stdin, and will then wait until some data is produced by the subprocess on stdout or stderr.  It will then feed the next line of data on stdin.</p>
  </dd>
  <dt>
    stdout_cb
  </dt>
  <dd>
    <p>Set up a callback function to get stdout data from the child line-by-line. The function you supply will be called whenever the child prints a line onto stdout.  This is the only way to get output from the child while it is still running, the normal method will give you all the output at once after the child exits.</p>
  </dd>
  <dt>
    stderr_cb
  </dt>
  <dd>
    <p>Similar to stdout_cb for stderr data.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REQUIREMENTS</h2>
        <div class="sectioncontent">
<p>I recommend using at least perl 5.003.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p>Proc::Reliable by Dan Goldwater &lt;dgold at zblob dot com&gt;</p><p>Based on Proc::Short, written by John Hanju Kim &lt;jhkim@fnal.gov&gt;.</p><p>Contributions by Stephen Cope and Jason Robertson.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright 2001 by Dan Goldwater, all rights reserved. Copyright 1999 by John Hanju Kim, all rights reserved.</p><p>This program is free software, you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Proc::PID::File.3pm.html"><span aria-hidden="true">&larr;</span> Proc::PID::File.3pm: A module to manage process id files</a></li>
   <li class="next"><a href="Proc::Simple.3pm.html">Proc::Simple.3pm: Launch and control background processes <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

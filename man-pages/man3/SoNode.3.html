<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SoNode: The sonode class is the base class for nodes used in scene graphs.  coin is a retained mode 3d visualization library (built on top of the immediate mode opengl library). 'retained mode' means that instead of passing commands to draw graphics primitives directly to the renderer, you build up data structures which are rendered by the library on demand.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The sonode class is the base class for nodes used in scene graphs.  coin is a retained mode 3d visualization library (built on top of the immediate mode opengl library). 'retained mode' means that instead of passing commands to draw graphics primitives directly to the renderer, you build up data structures which are rendered by the library on demand.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="SoNode (3) manual">
  <meta name="twitter:description" content="The sonode class is the base class for nodes used in scene graphs.  coin is a retained mode 3d visualization library (built on top of the immediate mode opengl library). 'retained mode' means that instead of passing commands to draw graphics primitives directly to the renderer, you build up data structures which are rendered by the library on demand.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcoin80-doc-SoNode-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/SoNode.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="SoNode (3) manual" />
  <meta property="og:description" content="The sonode class is the base class for nodes used in scene graphs.  coin is a retained mode 3d visualization library (built on top of the immediate mode opengl library). 'retained mode' means that instead of passing commands to draw graphics primitives directly to the renderer, you build up data structures which are rendered by the library on demand." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcoin80-doc-SoNode-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">SoNode<small> (3)</small></h1>
        <p class="lead">The sonode class is the base class for nodes used in scene graphs.  coin is a retained mode 3d visualization library (built on top of the immediate mode opengl library). 'retained mode' means that instead of passing commands to draw graphics primitives directly to the renderer, you build up data structures which are rendered by the library on demand.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoNode.3.html">
      <span itemprop="name">SoNode: The sonode class is the base class for nodes used in scene graphs.  coin is a retained mode 3d visualization library (built on top of the immediate mode opengl library). 'retained mode' means that instead of passing commands to draw graphics primitives directly to the renderer, you build up data structures which are rendered by the library on demand.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcoin80-doc/">
      <span itemprop="name">libcoin80-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoNode.3.html">
      <span itemprop="name">SoNode: The sonode class is the base class for nodes used in scene graphs.  coin is a retained mode 3d visualization library (built on top of the immediate mode opengl library). 'retained mode' means that instead of passing commands to draw graphics primitives directly to the renderer, you build up data structures which are rendered by the library on demand.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;Inventor/nodes/SoNode.h&gt;</p><p>Inherits <strong>SoFieldContainer</strong>.</p><p>Inherited by <strong>SoBaseColor</strong>, <strong>SoBaseKit</strong>, <strong>SoBumpMap</strong>, <strong>SoBumpMapCoordinate</strong>, <strong>SoBumpMapTransform</strong>, <strong>SoCacheHint</strong>, <strong>SoCallback</strong>, <strong>SoCamera</strong>, <strong>SoClipPlane</strong>, <strong>SoColorIndex</strong>, <strong>SoComplexity</strong>, <strong>SoCoordinate3</strong>, <strong>SoCoordinate4</strong>, <strong>SoDepthBuffer</strong>, <strong>SoDrawStyle</strong>, <strong>SoEnvironment</strong>, <strong>SoEventCallback</strong>, <strong>SoFile</strong>, <strong>SoFont</strong>, <strong>SoGeoCoordinate</strong>, <strong>SoGeoOrigin</strong>, <strong>SoGroup</strong>, <strong>SoInfo</strong>, <strong>SoLabel</strong>, <strong>SoLight</strong>, <strong>SoLightModel</strong>, <strong>SoListener</strong>, <strong>SoMaterial</strong>, <strong>SoMaterialBinding</strong>, <strong>SoNodeEngine</strong>, <strong>SoNodeKitListPart</strong>, <strong>SoNormal</strong>, <strong>SoNormalBinding</strong>, <strong>SoPackedColor</strong>, <strong>SoPickStyle</strong>, <strong>SoPolygonOffset</strong>, <strong>SoProfile</strong>, <strong>SoProfileCoordinate2</strong>, <strong>SoProfileCoordinate3</strong>, <strong>SoProfilerStats</strong>, <strong>SoProto</strong>, <strong>SoProtoInstance</strong>, <strong>SoSceneTexture2</strong>, <strong>SoSceneTextureCubeMap</strong>, <strong>SoShaderObject</strong>, <strong>SoShaderParameter</strong>, <strong>SoShaderProgram</strong>, <strong>SoShadowCulling</strong>, <strong>SoShadowStyle</strong>, <strong>SoShape</strong>, <strong>SoShapeHints</strong>, SoTexture, <strong>SoTexture2Transform</strong>, <strong>SoTexture3Transform</strong>, <strong>SoTextureCombine</strong>, <strong>SoTextureCoordinate2</strong>, <strong>SoTextureCoordinate3</strong>, <strong>SoTextureCoordinateBinding</strong>, <strong>SoTextureCoordinateCube</strong>, <strong>SoTextureCoordinateCylinder</strong>, <strong>SoTextureCoordinateFunction</strong>, <strong>SoTextureCoordinateSphere</strong>, <strong>SoTextureMatrixTransform</strong>, <strong>SoTextureScalePolicy</strong>, <strong>SoTextureUnit</strong>, <strong>SoTransformation</strong>, <strong>SoTransparencyType</strong>, <strong>SoVertexAttribute</strong>, <strong>SoVertexAttributeBinding</strong>, <strong>SoVertexProperty</strong>, <strong>SoVRMLAppearance</strong>, <strong>SoVRMLAudioClip</strong>, <strong>SoVRMLBackground</strong>, <strong>SoVRMLColor</strong>, <strong>SoVRMLCoordinate</strong>, <strong>SoVRMLFog</strong>, <strong>SoVRMLFontStyle</strong>, <strong>SoVRMLInline</strong>, <strong>SoVRMLLight</strong>, <strong>SoVRMLMaterial</strong>, <strong>SoVRMLNavigationInfo</strong>, <strong>SoVRMLNormal</strong>, <strong>SoVRMLProximitySensor</strong>, <strong>SoVRMLScript</strong>, <strong>SoVRMLSensor</strong>, <strong>SoVRMLShape</strong>, <strong>SoVRMLSound</strong>, <strong>SoVRMLTexture</strong>, <strong>SoVRMLTextureCoordinate</strong>, <strong>SoVRMLTextureTransform</strong>, <strong>SoVRMLTouchSensor</strong>, <strong>SoVRMLViewpoint</strong>, <strong>SoVRMLVisibilitySensor</strong>, <strong>SoVRMLWorldInfo</strong>, and <strong>SoWWWInline</strong>.</p><h3>Public Types</h3>
<p>enum <strong>NodeType</strong> { <strong>INVENTOR</strong> = 0x0000, <strong>VRML1</strong> = 0x0001, <strong>VRML2</strong> = 0x0002, <strong>INVENTOR_1</strong> = 0x0004, <strong>INVENTOR_2_0</strong> = 0x0008, <strong>INVENTOR_2_1</strong> = 0x0010, <strong>INVENTOR_2_5</strong> = 0x0020, <strong>INVENTOR_2_6</strong> = 0x0040, <strong>COIN_1_0</strong> = 0x0080, <strong>COIN_2_0</strong> = 0x0100, <strong>EXTENSION</strong> = 0x0200, <strong>COIN_2_2</strong> = 0x0400, <strong>COIN_2_3</strong> = 0x0800, <strong>COIN_2_4</strong> = 0x1000, <strong>INVENTOR_5_0</strong> = 0x2000, <strong>COIN_2_5</strong> = 0x4000, <strong>COIN_3_0</strong> = 0x8000, <strong>INVENTOR_6_0</strong> = 0x10000, <strong>COIN_4_0</strong> = 0x20000 }</p>
<h3>Public Member Functions</h3>
<p>void <strong>setOverride</strong> (const SbBool state)</p><p>SbBool <strong>isOverride</strong> (void) const </p><p>void <strong>setNodeType</strong> (const <strong>NodeType</strong> type)</p><p><strong>NodeType</strong> <strong>getNodeType</strong> (void) const </p><p>virtual <strong>SoNode</strong> * <strong>copy</strong> (SbBool copyconnections=FALSE) const </p><p>virtual SbBool <strong>affectsState</strong> (void) const </p><p>virtual void <strong>doAction</strong> (<strong>SoAction</strong> *action)</p><p>virtual void <strong>GLRender</strong> (<strong>SoGLRenderAction</strong> *action)</p><p>virtual void <strong>GLRenderBelowPath</strong> (<strong>SoGLRenderAction</strong> *action)</p><p>virtual void <strong>GLRenderInPath</strong> (<strong>SoGLRenderAction</strong> *action)</p><p>virtual void <strong>GLRenderOffPath</strong> (<strong>SoGLRenderAction</strong> *action)</p><p>virtual void <strong>callback</strong> (<strong>SoCallbackAction</strong> *action)</p><p>virtual void <strong>getBoundingBox</strong> (<strong>SoGetBoundingBoxAction</strong> *action)</p><p>virtual void <strong>getMatrix</strong> (<strong>SoGetMatrixAction</strong> *action)</p><p>virtual void <strong>handleEvent</strong> (<strong>SoHandleEventAction</strong> *action)</p><p>virtual void <strong>pick</strong> (<strong>SoPickAction</strong> *action)</p><p>virtual void <strong>rayPick</strong> (<strong>SoRayPickAction</strong> *action)</p><p>virtual void <strong>search</strong> (<strong>SoSearchAction</strong> *action)</p><p>virtual void <strong>write</strong> (<strong>SoWriteAction</strong> *action)</p><p>virtual void <strong>audioRender</strong> (<strong>SoAudioRenderAction</strong> *action)</p><p>virtual void <strong>getPrimitiveCount</strong> (<strong>SoGetPrimitiveCountAction</strong> *action)</p><p>virtual void <strong>grabEventsSetup</strong> (void)</p><p>virtual void <strong>grabEventsCleanup</strong> (void)</p><p>virtual void <strong>startNotify</strong> (void)</p><p>virtual void <strong>notify</strong> (<strong>SoNotList</strong> *l)</p><p>uint32_t <strong>getNodeId</strong> (void) const </p><p>virtual <strong>SoChildList</strong> * <strong>getChildren</strong> (void) const </p><p>virtual void <strong>writeInstance</strong> (<strong>SoOutput</strong> *out)</p><p>virtual <strong>SoNode</strong> * <strong>addToCopyDict</strong> (void) const </p><p>virtual void <strong>copyContents</strong> (const <strong>SoFieldContainer</strong> *from, SbBool copyconnections)</p><p>virtual <strong>SoFieldContainer</strong> * <strong>copyThroughConnection</strong> (void) const </p>
<h3>Static Public Member Functions</h3>
<p>static uint32_t <strong>getCompatibilityTypes</strong> (const <strong>SoType</strong> &nodetype)</p><p>static <strong>SoType</strong> <strong>getClassTypeId</strong> (void)</p><p>static <strong>SoNode</strong> * <strong>getByName</strong> (const <strong>SbName</strong> &name)</p><p>static int <strong>getByName</strong> (const <strong>SbName</strong> &name, <strong>SoNodeList</strong> &l)</p><p>static void <strong>initClass</strong> (void)</p><p>static void <strong>initClasses</strong> (void)</p><p>static uint32_t <strong>getNextNodeId</strong> (void)</p><p>static int <strong>getActionMethodIndex</strong> (const <strong>SoType</strong> type)</p><p>static void <strong>getBoundingBoxS</strong> (<strong>SoAction</strong> *action, <strong>SoNode</strong> *node)</p><p>static void <strong>GLRenderS</strong> (<strong>SoAction</strong> *action, <strong>SoNode</strong> *node)</p><p>static void <strong>callbackS</strong> (<strong>SoAction</strong> *action, <strong>SoNode</strong> *node)</p><p>static void <strong>getMatrixS</strong> (<strong>SoAction</strong> *action, <strong>SoNode</strong> *node)</p><p>static void <strong>handleEventS</strong> (<strong>SoAction</strong> *action, <strong>SoNode</strong> *node)</p><p>static void <strong>pickS</strong> (<strong>SoAction</strong> *action, <strong>SoNode</strong> *node)</p><p>static void <strong>rayPickS</strong> (<strong>SoAction</strong> *action, <strong>SoNode</strong> *node)</p><p>static void <strong>searchS</strong> (<strong>SoAction</strong> *action, <strong>SoNode</strong> *node)</p><p>static void <strong>writeS</strong> (<strong>SoAction</strong> *action, <strong>SoNode</strong> *node)</p><p>static void <strong>audioRenderS</strong> (<strong>SoAction</strong> *action, <strong>SoNode</strong> *node)</p><p>static void <strong>getPrimitiveCountS</strong> (<strong>SoAction</strong> *action, <strong>SoNode</strong> *node)</p>
<h3>Protected Member Functions</h3>
<p><strong>SoNode</strong> (void)</p><p>virtual <strong>~SoNode</strong> ()</p><p>virtual SbBool <strong>readInstance</strong> (<strong>SoInput</strong> *in, unsigned short flags)</p>
<h3>Static Protected Member Functions</h3>
<p>static const <strong>SoFieldData</strong> ** <strong>getFieldDataPtr</strong> (void)</p><p>static void <strong>setNextActionMethodIndex</strong> (int index)</p><p>static int <strong>getNextActionMethodIndex</strong> (void)</p><p>static void <strong>incNextActionMethodIndex</strong> (void)</p><p>static void <strong>setCompatibilityTypes</strong> (const <strong>SoType</strong> &nodetype, const uint32_t bitmask)</p>
<h3>Protected Attributes</h3>
<p>uint32_t <strong>uniqueId</strong></p>
<h3>Static Protected Attributes</h3>
<p>static uint32_t <strong>nextUniqueId</strong> = 1</p><p>static int <strong>nextActionMethodIndex</strong> = 0</p>
<h3>Additional Inherited Members</h3>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>The <strong>SoNode</strong> class is the base class for nodes used in scene graphs.</p><p>Coin is a <em>retained</em> <em>mode</em> 3D visualization library (built on top of the <em>immediate</em> <em>mode</em> OpenGL library). 'Retained mode' means that instead of passing commands to draw graphics primitives directly to the renderer, you build up data structures which are rendered by the library <em>on</em> <em>demand</em>.</p><p>The node classes are the main 'primitive' for building these data structures. In Coin, you build tree hierarchies made up of different node types: group nodes (for the tree structure layout of the other nodes), appearance nodes (for setting up materials, textures, etc), shape nodes (for the actual geometry), and nodes for lighting and camera positioning.</p><p>One common issue with newcomers to the API is that you should not and can not use the C++ delete operator on nodes -- the destructor is protected. This is because node instances are using a common technique for memory resource handling called 'reference counting'. Nodes are deleted (actually, they delete themselves) when their <strong>unref()</strong> method is called and the reference count goes to zero.</p><p>One important side-effect of this is that SoNode-derived classes should <em>not</em> be statically allocated, neither in static module memory nor on function's stack-frames. SoNode-derived classes must <em>always</em> be allocated dynamically from the memory heap with the new<em> operator (or else the scheme with self-destruction upon de-referencing to 0 would not work).</em></p><p>Usually application programmers won't manually <strong>ref()</strong> and <strong>unref()</strong> nodes a lot, because you pass the nodes directly to <strong>SoGroup::addChild()</strong> or So*Viewer::setSceneGraph() or something similar. These functions will <strong>ref()</strong> the nodes they are passed, and <strong>unref()</strong> them when they are finished with them.</p><p>Make sure you do <strong>ref()</strong> nodes that you keep pointers to so they aren't accidentally deleted prematurely due to an <strong>unref()</strong> call from within the library itself. If you haven't manually called <strong>ref()</strong> on a top-level root node, it will then be deleted automatically. This code shows how to do it:</p>
<pre>
SoSeparator * root = new SoSeparator; // root's refcount starts out at zero
root-&gt;addChild(foo_node); // foo_node refcount is increased by 1
root-&gt;addChild(bar_node); // bar_node refcount +1

// increase refcount before passing it to setScenegraph(), to avoid
// premature destruction
root-&gt;ref();

myviewer-&gt;setSceneGraph(root); // root's refcount +1, is now 2

// [misc visualization and processing]

// myviewer will let go of it's reference to the root node, thereby
// decreasing it's referencecount by 1
myviewer-&gt;setSceneGraph(NULL);

// root's refcount goes from +1 to 0, and it will self-destruct controllably
root-&gt;unref();
// avoid dangling pointer, in case "root" is attempted used again
// (not really necessary, but good for smoking out bugs early)
root = NULL;
</pre>
<p>For full information and tutorial-style introductions to all API issues, see the 'Inventor Mentor: Programming Object-Oriented 3D Graphics with Open Inventor' (ISBN 0-201-62495-8). It has detailed explanations on all the basic principles involved.</p><p>See specifically the section 'References and Deletion' in Chapter 3 to learn about the reference counting techniques.</p><p>Often when using the Coin library, one is interested in making extensions to it. Of particular interest is setting up extension nodes, which are then traversed, rendered and otherwise used by the rest of the library as any internal node.</p><p>The Coin header file <strong>Inventor/nodes/SoSubNode.h</strong> includes a set of convenience macros for quick and easy construction of extension nodes. Here's a complete snippet of code which shows how to set up a skeleton framework for an extension node class:</p>
<pre>
#include &lt;Inventor/nodes/SoWWWInline.h&gt;


class MyWWWInline : public SoWWWInline {
  SO_NODE_HEADER(MyWWWInline);

public:
  static void initClass(void);
  MyWWWInline(void);

protected:
  virtual ~MyWWWInline();
};


SO_NODE_SOURCE(MyWWWInline);

MyWWWInline::MyWWWInline(void)
{
  SO_NODE_CONSTRUCTOR(MyWWWInline);
}

MyWWWInline::~MyWWWInline()
{
}

void
MyWWWInline::initClass(void)
{
  SO_NODE_INIT_CLASS(MyWWWInline, SoWWWInline, "SoWWWInline");
}


int
main(int argc, char ** argv)
{
  SoDB::init();
  MyWWWInline::initClass();

  // [...]

  return 0;
}
</pre>
<p>You can then override for instance the <strong>GLRender()</strong> method to have your new class render OpenGL geometry different from it's superclass.</p><p>For extending the Coin library with your own classes, we strongly recommend that you make yourself acquainted with the excellent «The Inventor Toolmaker» book (ISBN 0-201-62493-1), which describes the tasks involved in detail. This book was written by the original SGI Inventor designers and explains many of the underlying design ideas, aswell as having lots of hands-on examples on how to extend the Coin toolkit in ways that are true to the fundamental design ideas. («The Inventor Toolmaker» is also available at SGI's online library, at no cost. See Download The Inventor Toolmaker.) Reading the sourcecode of the built-in classes in Coin should also provide very helpful.</p><p>For information about dynamic loading of extension nodes, see the documentation of <strong>SoType::fromName()</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Enumeration Documentation</h2>
        <div class="sectioncontent">
<h3>enum \fBSoNode::NodeType\fP</h3>
<p>Used to store node type.</p><p><strong>Enumerator</strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><em>INVENTOR </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Specifies Inventor node type.</p>
  </dd>
  <dt>
    <p><strong></strong><em>VRML1 </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Node is VRML V1.0 compatible.</p>
  </dd>
  <dt>
    <p><strong></strong><em>VRML2 </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Node is from the VRML V2.0 specification.</p>
  </dd>
  <dt>
    <p><strong></strong><em>INVENTOR_1 </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Node was part of SGI Inventor version 1.</p>
  </dd>
  <dt>
    <p><strong></strong><em>INVENTOR_2_0 </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Node was part of SGI Inventor version 2.0.</p>
  </dd>
  <dt>
    <p><strong></strong><em>INVENTOR_2_1 </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Node was introduced with SGI / TGS Inventor version 2.1.</p>
  </dd>
  <dt>
    <p><strong></strong><em>INVENTOR_2_5 </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Node was introduced with TGS Inventor version 2.5.</p>
  </dd>
  <dt>
    <p><strong></strong><em>INVENTOR_2_6 </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Node was introduced with TGS Inventor version 2.6.</p>
  </dd>
  <dt>
    <p><strong></strong><em>COIN_1_0 </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Node was part of Coin version 1.</p>
  </dd>
  <dt>
    <p><strong></strong><em>COIN_2_0 </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Node was introduced with Coin 2.0.</p>
  </dd>
  <dt>
    <p><strong></strong><em>EXTENSION </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Node is a client code extension.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>SoNode::SoNode (void)\fC [protected]\fP</h3>
<p>Default constructor, initializes node instance.</p>
<h3>SoNode::~SoNode ()\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Destructor.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>void SoNode::setOverride (const SbBoolstate)</h3>
<p>Set the override flag.</p><p>If this flag is TRUE, the field values of this node will override the field values of other nodes of the same type during scene graph traversal.</p><p>A common applicaton for 'override nodes' is to place them at the top of the tree as a convenient way to force e.g. a common drawstyle on the complete tree.</p><p>The override flag does not exist in the Inventor file format. This flag is in other words not persistent, and must be programmatically set. The rationale for this flag is for viewers to be able to control rendering style of the 3D models, so it would look stupid if some parts of certain models suddenly didn't adhere to the viewer mode.</p>
<h3>SbBool SoNode::isOverride (void) const</h3>
<p>Return status of override flag.</p><p><strong>See also:</strong></p><p><strong>setOverride()</strong></p>
<h3>uint32_t SoNode::getCompatibilityTypes (const \fBSoType\fP &nodetype)\fC [static]\fP</h3>
<p>Get the node compatibility mask for node type <em>nodetype</em>. The return value will be a bit mask of <strong>SoNode::NodeType</strong> flags, containing one or several flags.</p><p>This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2.1 API.</p><p><strong>Since:</strong></p><p>Coin 2.0</p>
<h3>void SoNode::setNodeType (const \fBNodeType\fPtype)</h3>
<p>Sets the node type for this node to <em>type</em>. Since some nodes should be handled differently in VRML1 vs. Inventor, this should be used to get correct behavior for those cases. The default node type is INVENTOR.</p><p>This method is an extension versus the Open Inventor API.</p><p><strong>See also:</strong></p><p><strong>getNodeType()</strong></p>
<h3>\fBSoNode::NodeType\fP SoNode::getNodeType (void) const</h3>
<p>Returns the node type set for this node.</p><p>This method is an extension versus the Open Inventor API.</p><p><strong>See also:</strong></p><p><strong>setNodeType()</strong></p>
<h3>\fBSoNode\fP * SoNode::copy (SbBoolcopyconnections = \fCFALSE\fP) const\fC [virtual]\fP</h3>
<p>Make a duplicate of this node and return a pointer to the duplicate.</p><p>If this node is a group node, children are also copied and we return a pointer to the root of a full copy of the subgraph rooted here.</p><p>If <em>copyconnections</em> is TRUE<em>, we also copy the connections to fields within this node (and ditto for any children and children's children etc).</em></p><p>Note that this function has been made virtual in Coin, which is not the case in the original Open Inventor API. We may change this method back into being non-virtual again for major Coin versions after this, as it was made virtual more or less by mistake. So please don't write application code that depends on <strong>SoNode::copy()</strong> being virtual.</p><p>The reason this method should not be virtual is because this is <em>not</em> the function the application programmer should override in extension nodes if she needs some special behavior during a copy operation (like copying the value of internal data not exposed as fields).</p><p>For that purpose, override the <strong>copyContents()</strong> method. Your overridden <strong>copyContents()</strong> method should then <em>both</em> copy internal data aswell as calling the parent superclass' <strong>copyContents()</strong> method for automatically handling of fields and other common data.</p>
<h3>SbBool SoNode::affectsState (void) const\fC [virtual]\fP</h3>
<p>Returns TRUE if the node could have any effect on the state during traversal.</p><p>If it returns FALSE, no data in the traversal-state will change from the pre-traversal state to the post-traversal state. The <strong>SoSeparator</strong> node will for instance return FALSE<strong>, as it pushes and pops the state before and after traversal of its children. All </strong><strong>SoShape</strong><strong> nodes will also return FALSE</strong><strong>, as just pushing out geometry data to the rendering engine won't affect the actual rendering state.</strong></p><p>The default method returns TRUE, on a 'better safe than sorry' philosophy.</p><p>Reimplemented in <strong>SoSeparator</strong>, <strong>SoNodeKitListPart</strong>, <strong>SoShape</strong>, <strong>SoVRMLShape</strong>, <strong>SoVRMLSwitch</strong>, <strong>SoArray</strong>, <strong>SoVRMLProximitySensor</strong>, <strong>SoVRMLTouchSensor</strong>, <strong>SoSwitch</strong>, <strong>SoVRMLLOD</strong>, <strong>SoSceneKit</strong>, <strong>SoVRMLParent</strong>, and <strong>SoMultipleCopy</strong>.</p>
<h3>void SoNode::doAction (\fBSoAction\fP *action)\fC [virtual]\fP</h3>
<p>This function performs the typical operation of a node for any action.</p><p>Reimplemented in <strong>SoSceneTexture2</strong>, <strong>SoCamera</strong>, <strong>SoWWWInline</strong>, <strong>SoVRMLInline</strong>, <strong>SoBaseKit</strong>, <strong>SoTextureCombine</strong>, <strong>SoSceneTextureCubeMap</strong>, <strong>SoVRMLFontStyle</strong>, <strong>SoTextureCubeMap</strong>, <strong>SoShapeHints</strong>, <strong>SoTexture2</strong>, <strong>SoVRMLSwitch</strong>, <strong>SoTexture3</strong>, <strong>SoVRMLVertexShape</strong>, <strong>SoVertexProperty</strong>, <strong>SoNodeKitListPart</strong>, <strong>SoVRMLTransform</strong>, <strong>SoVRMLLOD</strong>, <strong>SoUnits</strong>, <strong>SoVRMLGroup</strong>, <strong>SoTransform</strong>, <strong>SoFontStyle</strong>, <strong>SoVRMLShape</strong>, <strong>SoMaterialBinding</strong>, <strong>SoNormalBinding</strong>, <strong>SoTransparencyType</strong>, <strong>SoVRMLParent</strong>, <strong>SoArray</strong>, <strong>SoBumpMap</strong>, <strong>SoDrawStyle</strong>, <strong>SoClipPlaneManip</strong>, <strong>SoDirectionalLightManip</strong>, <strong>SoVRMLImageTexture</strong>, <strong>SoVRMLProximitySensor</strong>, <strong>SoSpotLightManip</strong>, <strong>SoSeparator</strong>, <strong>SoPointLightManip</strong>, <strong>SoTransformManip</strong>, <strong>SoGroup</strong>, <strong>SoPolygonOffset</strong>, <strong>SoRotationXYZ</strong>, <strong>SoVertexAttribute</strong>, <strong>SoProfile</strong>, <strong>SoTextureCoordinateBinding</strong>, <strong>SoVRMLScript</strong>, <strong>SoAntiSquish</strong>, <strong>SoComplexity</strong>, <strong>SoMaterial</strong>, <strong>SoPickStyle</strong>, <strong>SoSwitch</strong>, <strong>SoTexture3Transform</strong>, <strong>SoVRMLMaterial</strong>, <strong>SoGeoCoordinate</strong>, <strong>SoVertexAttributeBinding</strong>, <strong>SoCacheHint</strong>, <strong>SoGeoLocation</strong>, <strong>SoLOD</strong>, <strong>SoResetTransform</strong>, <strong>SoTextureCoordinatePlane</strong>, <strong>SoTextureUnit</strong>, <strong>SoVRMLBillboard</strong>, <strong>SoVRMLTextureTransform</strong>, <strong>SoBumpMapTransform</strong>, <strong>SoLightModel</strong>, <strong>SoSurroundScale</strong>, <strong>SoTexture2Transform</strong>, <strong>SoVRMLAppearance</strong>, <strong>SoGeoOrigin</strong>, <strong>SoLevelOfDetail</strong>, <strong>SoFile</strong>, <strong>SoTextureCoordinateObject</strong>, <strong>SoMultipleCopy</strong>, <strong>SoNormal</strong>, <strong>SoPathSwitch</strong>, <strong>SoVRMLColor</strong>, <strong>SoVRMLCoordinate</strong>, <strong>SoVRMLNormal</strong>, <strong>SoVRMLPixelTexture</strong>, <strong>SoVRMLTextureCoordinate</strong>, <strong>SoVRMLVertexLine</strong>, <strong>SoVRMLVertexPoint</strong>, <strong>SoBaseColor</strong>, <strong>SoClipPlane</strong>, <strong>SoCoordinate3</strong>, <strong>SoCoordinate4</strong>, <strong>SoFont</strong>, <strong>SoPackedColor</strong>, <strong>SoTextureCoordinate3</strong>, <strong>SoTextureCoordinateReflectionMap</strong>, <strong>SoCallback</strong>, <strong>SoMatrixTransform</strong>, <strong>SoRotation</strong>, <strong>SoScale</strong>, <strong>SoTextureCoordinate2</strong>, <strong>SoTextureCoordinateNormalMap</strong>, <strong>SoTranslation</strong>, <strong>SoBumpMapCoordinate</strong>, <strong>SoProfileCoordinate2</strong>, <strong>SoProfileCoordinate3</strong>, <strong>SoTextureMatrixTransform</strong>, <strong>SoTransformSeparator</strong>, <strong>SoTextureCoordinateDefault</strong>, <strong>SoTextureCoordinateEnvironment</strong>, <strong>SoTextureCoordinateCube</strong>, <strong>SoTextureCoordinateCylinder</strong>, and <strong>SoTextureCoordinateSphere</strong>.</p>
<h3>void SoNode::GLRender (\fBSoGLRenderAction\fP *action)\fC [virtual]\fP</h3>
<p>Action method for the <strong>SoGLRenderAction</strong>.</p><p>This is called during rendering traversals. Nodes influencing the rendering state in any way or who wants to throw geometry primitives at OpenGL overrides this method.</p><p>Reimplemented in <strong>SoCamera</strong>, <strong>SoSceneTexture2</strong>, <strong>SoWWWInline</strong>, <strong>SoVRMLInline</strong>, <strong>SoBaseKit</strong>, <strong>SoMarkerSet</strong>, <strong>SoTextureCombine</strong>, <strong>SoSceneTextureCubeMap</strong>, <strong>SoVRMLFontStyle</strong>, <strong>SoTextureCubeMap</strong>, <strong>SoTabPlaneDragger</strong>, <strong>SoProfilerStats</strong>, <strong>SoVRMLSwitch</strong>, <strong>SoShapeHints</strong>, <strong>SoTexture2</strong>, <strong>SoTexture3</strong>, <strong>SoDragger</strong>, <strong>SoVRMLVertexShape</strong>, <strong>SoText3</strong>, <strong>SoVertexProperty</strong>, <strong>SoNodeKitListPart</strong>, <strong>SoImage</strong>, <strong>SoUnits</strong>, <strong>SoVRMLElevationGrid</strong>, <strong>SoVRMLLOD</strong>, <strong>SoVRMLGroup</strong>, <strong>SoShaderObject</strong>, <strong>SoShape</strong>, <strong>SoTransform</strong>, <strong>SoVRMLMovieTexture</strong>, <strong>SoFontStyle</strong>, <strong>SoVRMLShape</strong>, <strong>SoArray</strong>, <strong>SoCylinder</strong>, <strong>SoDepthBuffer</strong>, <strong>SoGeometryShader</strong>, <strong>SoMaterialBinding</strong>, <strong>SoNormalBinding</strong>, <strong>SoTransparencyType</strong>, <strong>SoClipPlaneManip</strong>, <strong>SoDirectionalLightManip</strong>, <strong>SoAntiSquish</strong>, <strong>SoBumpMap</strong>, <strong>SoDrawStyle</strong>, <strong>SoSpotLightManip</strong>, <strong>SoVRMLBackground</strong>, <strong>SoVRMLImageTexture</strong>, <strong>SoVRMLProximitySensor</strong>, <strong>SoVRMLText</strong>, <strong>SoPointLightManip</strong>, <strong>SoTransformManip</strong>, <strong>SoAsciiText</strong>, <strong>SoCone</strong>, <strong>SoIndexedNurbsSurface</strong>, <strong>SoPolygonOffset</strong>, <strong>SoSeparator</strong>, <strong>SoSurroundScale</strong>, <strong>SoVRMLExtrusion</strong>, <strong>SoComplexity</strong>, <strong>SoGroup</strong>, <strong>SoProfile</strong>, <strong>SoRotationXYZ</strong>, <strong>SoShaderProgram</strong>, <strong>SoTextureCoordinateBinding</strong>, <strong>SoVertexAttribute</strong>, <strong>SoVRMLScript</strong>, <strong>SoSwitch</strong>, <strong>SoVRMLViewpoint</strong>, <strong>SoMaterial</strong>, <strong>SoNurbsSurface</strong>, <strong>SoText2</strong>, <strong>SoTexture3Transform</strong>, <strong>SoVRMLIndexedFaceSet</strong>, <strong>SoGeoCoordinate</strong>, <strong>SoVRMLMaterial</strong>, <strong>SoVRMLNavigationInfo</strong>, <strong>SoEnvironment</strong>, <strong>SoGeoLocation</strong>, <strong>SoLOD</strong>, <strong>SoResetTransform</strong>, <strong>SoTextureScalePolicy</strong>, <strong>SoTextureUnit</strong>, <strong>SoVertexAttributeBinding</strong>, <strong>SoVRMLBillboard</strong>, <strong>SoVRMLTextureTransform</strong>, <strong>SoVRMLVisibilitySensor</strong>, <strong>SoShadowStyle</strong>, <strong>SoBumpMapTransform</strong>, <strong>SoCacheHint</strong>, <strong>SoTexture2Transform</strong>, <strong>SoTextureCoordinatePlane</strong>, <strong>SoVRMLAppearance</strong>, <strong>SoVRMLCollision</strong>, <strong>SoVRMLFog</strong>, <strong>SoGeoOrigin</strong>, <strong>SoIndexedNurbsCurve</strong>, <strong>SoLevelOfDetail</strong>, <strong>SoLightModel</strong>, <strong>SoVRMLSpotLight</strong>, <strong>SoShadowCulling</strong>, <strong>SoFile</strong>, <strong>SoVRMLCylinder</strong>, <strong>SoCube</strong>, <strong>SoMultipleCopy</strong>, <strong>SoNurbsCurve</strong>, <strong>SoSpotLight</strong>, <strong>SoTextureCoordinateObject</strong>, <strong>SoVRMLCone</strong>, <strong>SoVRMLLight</strong>, <strong>SoVRMLTextureCoordinate</strong>, <strong>SoFont</strong>, <strong>SoIndexedFaceSet</strong>, <strong>SoIndexedLineSet</strong>, <strong>SoIndexedTriangleStripSet</strong>, <strong>SoNormal</strong>, <strong>SoPathSwitch</strong>, <strong>SoVRMLColor</strong>, <strong>SoVRMLCoordinate</strong>, <strong>SoVRMLIndexedLineSet</strong>, <strong>SoVRMLNormal</strong>, <strong>SoVRMLPixelTexture</strong>, <strong>SoVRMLPointLight</strong>, <strong>SoVRMLVertexLine</strong>, <strong>SoVRMLVertexPoint</strong>, <strong>SoBaseColor</strong>, <strong>SoCallback</strong>, <strong>SoClipPlane</strong>, <strong>SoCoordinate3</strong>, <strong>SoCoordinate4</strong>, <strong>SoFaceSet</strong>, <strong>SoIndexedMarkerSet</strong>, <strong>SoMatrixTransform</strong>, <strong>SoPackedColor</strong>, <strong>SoScale</strong>, <strong>SoTextureCoordinate3</strong>, <strong>SoTextureCoordinateReflectionMap</strong>, <strong>SoTranslation</strong>, <strong>SoIndexedPointSet</strong>, <strong>SoLineSet</strong>, <strong>SoQuadMesh</strong>, <strong>SoRotation</strong>, <strong>SoTextureCoordinate2</strong>, <strong>SoTextureCoordinateNormalMap</strong>, <strong>SoTextureMatrixTransform</strong>, <strong>SoTransformSeparator</strong>, <strong>SoShadowDirectionalLight</strong>, <strong>SoShadowSpotLight</strong>, <strong>SoBumpMapCoordinate</strong>, <strong>SoDirectionalLight</strong>, <strong>SoPointLight</strong>, <strong>SoPointSet</strong>, <strong>SoProfileCoordinate2</strong>, <strong>SoProfileCoordinate3</strong>, <strong>SoSphere</strong>, <strong>SoTriangleStripSet</strong>, <strong>SoVRMLBox</strong>, <strong>SoVRMLDirectionalLight</strong>, <strong>SoVRMLSphere</strong>, <strong>SoVRMLTexture</strong>, <strong>SoColorIndex</strong>, <strong>SoTextureCoordinateDefault</strong>, <strong>SoTextureCoordinateEnvironment</strong>, <strong>SoVRMLPointSet</strong>, <strong>SoAnnotation</strong>, <strong>SoTextureCoordinateCube</strong>, <strong>SoTextureCoordinateCylinder</strong>, and <strong>SoTextureCoordinateSphere</strong>.</p>
<h3>void SoNode::GLRenderBelowPath (\fBSoGLRenderAction\fP *action)\fC [virtual]\fP</h3>
<p>Implements the SoAction::BELOW_PATH traversal method for the rendering action.</p><p>Reimplemented in <strong>SoExtSelection</strong>, <strong>SoVRMLGroup</strong>, <strong>SoVRMLLOD</strong>, <strong>SoVRMLTransform</strong>, <strong>SoShadowGroup</strong>, <strong>SoLocateHighlight</strong>, <strong>SoSeparator</strong>, <strong>SoVRMLBillboard</strong>, <strong>SoLOD</strong>, <strong>SoGeoSeparator</strong>, and <strong>SoAnnotation</strong>.</p>
<h3>void SoNode::GLRenderInPath (\fBSoGLRenderAction\fP *action)\fC [virtual]\fP</h3>
<p>Implements the SoAction::IN_PATH traversal method for the rendering action.</p><p>Reimplemented in <strong>SoVRMLGroup</strong>, <strong>SoVRMLLOD</strong>, <strong>SoVRMLTransform</strong>, <strong>SoShadowGroup</strong>, <strong>SoLocateHighlight</strong>, <strong>SoSeparator</strong>, <strong>SoVRMLBillboard</strong>, <strong>SoLOD</strong>, <strong>SoGeoSeparator</strong>, and <strong>SoAnnotation</strong>.</p>
<h3>void SoNode::GLRenderOffPath (\fBSoGLRenderAction\fP *action)\fC [virtual]\fP</h3>
<p>Implements the SoAction::OFF_PATH traversal method for the rendering action.</p><p>Reimplemented in <strong>SoVRMLGroup</strong>, <strong>SoVRMLLOD</strong>, <strong>SoSeparator</strong>, <strong>SoVRMLBillboard</strong>, <strong>SoLOD</strong>, and <strong>SoAnnotation</strong>.</p>
<h3>void SoNode::callback (\fBSoCallbackAction\fP *action)\fC [virtual]\fP</h3>
<p>Action method for <strong>SoCallbackAction</strong>.</p><p>Simply updates the state according to how the node behaves for the render action, so the application programmer can use the <strong>SoCallbackAction</strong> for extracting information about the scene graph.</p><p>Reimplemented in <strong>SoSceneTexture2</strong>, <strong>SoCamera</strong>, <strong>SoWWWInline</strong>, <strong>SoVRMLInline</strong>, <strong>SoBaseKit</strong>, <strong>SoTextureCombine</strong>, <strong>SoSceneTextureCubeMap</strong>, <strong>SoProfilerStats</strong>, <strong>SoTextureCubeMap</strong>, <strong>SoVRMLFontStyle</strong>, <strong>SoShapeHints</strong>, <strong>SoTexture2</strong>, <strong>SoTexture3</strong>, <strong>SoVRMLSwitch</strong>, <strong>SoVRMLVertexShape</strong>, <strong>SoVertexProperty</strong>, <strong>SoDragger</strong>, <strong>SoNodeKitListPart</strong>, <strong>SoVRMLTransform</strong>, <strong>SoShape</strong>, <strong>SoVRMLLOD</strong>, <strong>SoTransform</strong>, <strong>SoUnits</strong>, <strong>SoVRMLGroup</strong>, <strong>SoFontStyle</strong>, <strong>SoMaterialBinding</strong>, <strong>SoNormalBinding</strong>, <strong>SoSeparator</strong>, <strong>SoTransparencyType</strong>, <strong>SoVRMLShape</strong>, <strong>SoBumpMap</strong>, <strong>SoDrawStyle</strong>, <strong>SoArray</strong>, <strong>SoVRMLImageTexture</strong>, <strong>SoVRMLProximitySensor</strong>, <strong>SoClipPlaneManip</strong>, <strong>SoDirectionalLightManip</strong>, <strong>SoAntiSquish</strong>, <strong>SoSpotLightManip</strong>, <strong>SoGroup</strong>, <strong>SoRotationXYZ</strong>, <strong>SoPointLightManip</strong>, <strong>SoTransformManip</strong>, <strong>SoPolygonOffset</strong>, <strong>SoSurroundScale</strong>, <strong>SoMaterial</strong>, <strong>SoProfile</strong>, <strong>SoTextureCoordinateBinding</strong>, <strong>SoVRMLScript</strong>, <strong>SoComplexity</strong>, <strong>SoPickStyle</strong>, <strong>SoSwitch</strong>, <strong>SoVRMLMaterial</strong>, <strong>SoEnvironment</strong>, <strong>SoPathSwitch</strong>, <strong>SoTexture3Transform</strong>, <strong>SoTextureCoordinatePlane</strong>, <strong>SoVertexAttributeBinding</strong>, <strong>SoCacheHint</strong>, <strong>SoGeoCoordinate</strong>, <strong>SoGeoLocation</strong>, <strong>SoGeoSeparator</strong>, <strong>SoLightModel</strong>, <strong>SoLOD</strong>, <strong>SoResetTransform</strong>, <strong>SoTextureUnit</strong>, <strong>SoVRMLBillboard</strong>, <strong>SoVRMLTextureTransform</strong>, <strong>SoBumpMapTransform</strong>, <strong>SoTexture2Transform</strong>, <strong>SoTextureCoordinateObject</strong>, <strong>SoVRMLAppearance</strong>, <strong>SoGeoOrigin</strong>, <strong>SoLevelOfDetail</strong>, <strong>SoVRMLCoordinate</strong>, <strong>SoVRMLVertexLine</strong>, <strong>SoVRMLVertexPoint</strong>, <strong>SoCoordinate4</strong>, <strong>SoFile</strong>, <strong>SoFont</strong>, <strong>SoNormal</strong>, <strong>SoTextureCoordinateReflectionMap</strong>, <strong>SoVRMLColor</strong>, <strong>SoVRMLNormal</strong>, <strong>SoVRMLPixelTexture</strong>, <strong>SoBaseColor</strong>, <strong>SoClipPlane</strong>, <strong>SoCoordinate3</strong>, <strong>SoMultipleCopy</strong>, <strong>SoPackedColor</strong>, <strong>SoTextureCoordinate3</strong>, <strong>SoTextureCoordinateNormalMap</strong>, <strong>SoVRMLTextureCoordinate</strong>, <strong>SoLight</strong>, <strong>SoRotation</strong>, <strong>SoTextureCoordinate2</strong>, <strong>SoBumpMapCoordinate</strong>, <strong>SoCallback</strong>, <strong>SoMatrixTransform</strong>, <strong>SoProfileCoordinate2</strong>, <strong>SoProfileCoordinate3</strong>, <strong>SoScale</strong>, <strong>SoTextureCoordinateEnvironment</strong>, <strong>SoTranslation</strong>, <strong>SoTextureCoordinateDefault</strong>, <strong>SoTextureMatrixTransform</strong>, <strong>SoTransformSeparator</strong>, <strong>SoTextureCoordinateCube</strong>, <strong>SoTextureCoordinateCylinder</strong>, and <strong>SoTextureCoordinateSphere</strong>.</p>
<h3>void SoNode::getBoundingBox (\fBSoGetBoundingBoxAction\fP *action)\fC [virtual]\fP</h3>
<p>Action method for the <strong>SoGetBoundingBoxAction</strong>.</p><p>Calculates bounding box and center coordinates for node and modifies the values of the <em>action</em> to encompass the bounding box for this node and to shift the center point for the scene more towards the one for this node.</p><p>Nodes influencing how geometry nodes calculates their bounding box also overrides this method to change the relevant state variables.</p><p>Reimplemented in <strong>SoDragger</strong>, <strong>SoCamera</strong>, <strong>SoWWWInline</strong>, <strong>SoVRMLInline</strong>, <strong>SoCenterballDragger</strong>, <strong>SoBaseKit</strong>, <strong>SoVRMLFontStyle</strong>, <strong>SoProfilerStats</strong>, <strong>SoVRMLSwitch</strong>, <strong>SoShapeHints</strong>, <strong>SoVRMLVertexShape</strong>, <strong>SoVertexProperty</strong>, <strong>SoNodeKitListPart</strong>, <strong>SoVRMLLOD</strong>, <strong>SoVRMLTransform</strong>, <strong>SoVRMLGroup</strong>, <strong>SoTransform</strong>, <strong>SoUnits</strong>, <strong>SoVRMLShape</strong>, <strong>SoArray</strong>, <strong>SoSeparator</strong>, <strong>SoShape</strong>, <strong>SoFontStyle</strong>, <strong>SoVRMLProximitySensor</strong>, <strong>SoClipPlaneManip</strong>, <strong>SoDirectionalLightManip</strong>, <strong>SoAntiSquish</strong>, <strong>SoSpotLightManip</strong>, <strong>SoPointLightManip</strong>, <strong>SoTransformManip</strong>, <strong>SoGroup</strong>, <strong>SoRotationXYZ</strong>, <strong>SoSurroundScale</strong>, <strong>SoLOD</strong>, <strong>SoProfile</strong>, <strong>SoSwitch</strong>, <strong>SoVRMLScript</strong>, <strong>SoComplexity</strong>, <strong>SoGeoCoordinate</strong>, <strong>SoGeoSeparator</strong>, <strong>SoTextureUnit</strong>, <strong>SoCacheHint</strong>, <strong>SoGeoLocation</strong>, <strong>SoIndexedNurbsCurve</strong>, <strong>SoResetTransform</strong>, <strong>SoVRMLBillboard</strong>, <strong>SoLevelOfDetail</strong>, <strong>SoGeoOrigin</strong>, <strong>SoNurbsCurve</strong>, <strong>SoFile</strong>, <strong>SoMultipleCopy</strong>, <strong>SoPathSwitch</strong>, <strong>SoVRMLIndexedLineSet</strong>, <strong>SoBlinker</strong>, <strong>SoCoordinate3</strong>, <strong>SoIndexedLineSet</strong>, <strong>SoVRMLCoordinate</strong>, <strong>SoVRMLVertexLine</strong>, <strong>SoVRMLVertexPoint</strong>, <strong>SoCallback</strong>, <strong>SoCoordinate4</strong>, <strong>SoMatrixTransform</strong>, <strong>SoProfileCoordinate2</strong>, <strong>SoProfileCoordinate3</strong>, <strong>SoRotation</strong>, <strong>SoScale</strong>, <strong>SoTransformSeparator</strong>, <strong>SoTranslation</strong>, <strong>SoFont</strong>, <strong>SoIndexedPointSet</strong>, <strong>SoLineSet</strong>, <strong>SoPointSet</strong>, and <strong>SoVRMLPointSet</strong>.</p>
<h3>void SoNode::getMatrix (\fBSoGetMatrixAction\fP *action)\fC [virtual]\fP</h3>
<p>Action method for <strong>SoGetMatrixAction</strong>.</p><p>Updates <em>action</em> by accumulating with the transformation matrix of this node (if any).</p><p>Reimplemented in <strong>SoWWWInline</strong>, <strong>SoVRMLInline</strong>, <strong>SoCenterballDragger</strong>, <strong>SoBaseKit</strong>, <strong>SoProfilerStats</strong>, <strong>SoVRMLSwitch</strong>, <strong>SoDragger</strong>, <strong>SoNodeKitListPart</strong>, <strong>SoVRMLTransform</strong>, <strong>SoVRMLGroup</strong>, <strong>SoTransform</strong>, <strong>SoUnits</strong>, <strong>SoArray</strong>, <strong>SoSeparator</strong>, <strong>SoClipPlaneManip</strong>, <strong>SoDirectionalLightManip</strong>, <strong>SoAntiSquish</strong>, <strong>SoSpotLightManip</strong>, <strong>SoPointLightManip</strong>, <strong>SoTransformManip</strong>, <strong>SoGroup</strong>, <strong>SoRotationXYZ</strong>, <strong>SoSurroundScale</strong>, <strong>SoSwitch</strong>, <strong>SoGeoSeparator</strong>, <strong>SoTexture3Transform</strong>, <strong>SoTextureUnit</strong>, <strong>SoGeoLocation</strong>, <strong>SoResetTransform</strong>, <strong>SoVRMLBillboard</strong>, <strong>SoVRMLTextureTransform</strong>, <strong>SoBumpMapTransform</strong>, <strong>SoGeoOrigin</strong>, <strong>SoMultipleCopy</strong>, <strong>SoTexture2Transform</strong>, <strong>SoFile</strong>, <strong>SoPathSwitch</strong>, <strong>SoCallback</strong>, <strong>SoMatrixTransform</strong>, <strong>SoRotation</strong>, <strong>SoScale</strong>, <strong>SoTransformSeparator</strong>, <strong>SoTranslation</strong>, and <strong>SoTextureMatrixTransform</strong>.</p>
<h3>void SoNode::handleEvent (\fBSoHandleEventAction\fP *action)\fC [virtual]\fP</h3>
<p>Action method for <strong>SoHandleEventAction</strong>.</p><p>Inspects the event data from <em>action</em>, and processes it if it is something which this node should react to.</p><p>Nodes influencing relevant state variables for how event handling is done also overrides this method.</p><p>Reimplemented in <strong>SoDragger</strong>, <strong>SoCamera</strong>, <strong>SoExtSelection</strong>, <strong>SoSelection</strong>, <strong>SoWWWInline</strong>, <strong>SoVRMLInline</strong>, <strong>SoBaseKit</strong>, <strong>SoVRMLSwitch</strong>, <strong>SoEventCallback</strong>, <strong>SoProfilerStats</strong>, <strong>SoNodeKitListPart</strong>, <strong>SoSeparator</strong>, <strong>SoArray</strong>, <strong>SoClipPlaneManip</strong>, <strong>SoDirectionalLightManip</strong>, <strong>SoWWWAnchor</strong>, <strong>SoSpotLightManip</strong>, <strong>SoPointLightManip</strong>, <strong>SoTransformManip</strong>, <strong>SoGroup</strong>, <strong>SoVRMLScript</strong>, <strong>SoLocateHighlight</strong>, <strong>SoSwitch</strong>, <strong>SoVRMLAnchor</strong>, <strong>SoVRMLTimeSensor</strong>, <strong>SoVRMLTouchSensor</strong>, <strong>SoFile</strong>, <strong>SoMultipleCopy</strong>, <strong>SoPathSwitch</strong>, <strong>SoCallback</strong>, and <strong>SoVRMLDragSensor</strong>.</p>
<h3>void SoNode::pick (\fBSoPickAction\fP *action)\fC [virtual]\fP</h3>
<p>Action method for <strong>SoPickAction</strong>.</p><p>Does common processing for <strong>SoPickAction</strong> <em>action</em> instances.</p><p>Reimplemented in <strong>SoWWWInline</strong>, <strong>SoVRMLInline</strong>, <strong>SoTextureCombine</strong>, <strong>SoProfilerStats</strong>, <strong>SoVRMLFontStyle</strong>, <strong>SoShapeHints</strong>, <strong>SoVRMLSwitch</strong>, <strong>SoVRMLVertexShape</strong>, <strong>SoNodeKitListPart</strong>, <strong>SoVertexProperty</strong>, <strong>SoUnits</strong>, <strong>SoTransform</strong>, <strong>SoFontStyle</strong>, <strong>SoClipPlaneManip</strong>, <strong>SoDirectionalLightManip</strong>, <strong>SoSpotLightManip</strong>, <strong>SoAntiSquish</strong>, <strong>SoMaterialBinding</strong>, <strong>SoNormalBinding</strong>, <strong>SoPointLightManip</strong>, <strong>SoTransformManip</strong>, <strong>SoArray</strong>, <strong>SoGroup</strong>, <strong>SoRotationXYZ</strong>, <strong>SoSurroundScale</strong>, <strong>SoProfile</strong>, <strong>SoVRMLScript</strong>, <strong>SoComplexity</strong>, <strong>SoTextureCoordinateBinding</strong>, <strong>SoSwitch</strong>, <strong>SoTexture3Transform</strong>, <strong>SoGeoCoordinate</strong>, <strong>SoGeoLocation</strong>, <strong>SoPickStyle</strong>, <strong>SoResetTransform</strong>, <strong>SoVRMLBillboard</strong>, <strong>SoCacheHint</strong>, <strong>SoVertexAttributeBinding</strong>, <strong>SoVRMLTextureTransform</strong>, <strong>SoBumpMapTransform</strong>, <strong>SoFile</strong>, <strong>SoGeoOrigin</strong>, <strong>SoTexture2Transform</strong>, <strong>SoTextureUnit</strong>, <strong>SoTextureCoordinatePlane</strong>, <strong>SoCallback</strong>, <strong>SoVRMLCoordinate</strong>, <strong>SoVRMLVertexLine</strong>, <strong>SoVRMLVertexPoint</strong>, <strong>SoCoordinate3</strong>, <strong>SoCoordinate4</strong>, <strong>SoFont</strong>, <strong>SoMatrixTransform</strong>, <strong>SoMultipleCopy</strong>, <strong>SoNormal</strong>, <strong>SoRotation</strong>, <strong>SoScale</strong>, <strong>SoTextureCoordinateObject</strong>, <strong>SoTranslation</strong>, <strong>SoVRMLNormal</strong>, <strong>SoVRMLTextureCoordinate</strong>, <strong>SoClipPlane</strong>, <strong>SoPathSwitch</strong>, <strong>SoTextureCoordinate3</strong>, <strong>SoTextureCoordinate2</strong>, <strong>SoTextureCoordinateReflectionMap</strong>, <strong>SoTextureMatrixTransform</strong>, <strong>SoBumpMapCoordinate</strong>, <strong>SoProfileCoordinate2</strong>, <strong>SoProfileCoordinate3</strong>, <strong>SoTextureCoordinateNormalMap</strong>, <strong>SoTransformSeparator</strong>, <strong>SoTextureCoordinateDefault</strong>, <strong>SoTextureCoordinateEnvironment</strong>, <strong>SoTextureCoordinateCube</strong>, <strong>SoTextureCoordinateCylinder</strong>, and <strong>SoTextureCoordinateSphere</strong>.</p>
<h3>void SoNode::rayPick (\fBSoRayPickAction\fP *action)\fC [virtual]\fP</h3>
<p>Action method for <strong>SoRayPickAction</strong>.</p><p>Checks the ray specification of the <em>action</em> and tests for intersection with the data of the node.</p><p>Nodes influencing relevant state variables for how picking is done also overrides this method.</p><p>Reimplemented in <strong>SoCamera</strong>, <strong>SoSceneTexture2</strong>, <strong>SoBaseKit</strong>, <strong>SoSceneTextureCubeMap</strong>, <strong>SoTextureCubeMap</strong>, <strong>SoProfilerStats</strong>, <strong>SoTexture2</strong>, <strong>SoDragger</strong>, <strong>SoImage</strong>, <strong>SoVRMLTransform</strong>, <strong>SoVRMLGroup</strong>, <strong>SoVRMLElevationGrid</strong>, <strong>SoVRMLLOD</strong>, <strong>SoSeparator</strong>, <strong>SoShape</strong>, <strong>SoVRMLShape</strong>, <strong>SoBumpMap</strong>, <strong>SoVRMLImageTexture</strong>, <strong>SoVRMLProximitySensor</strong>, <strong>SoCone</strong>, <strong>SoCylinder</strong>, <strong>SoIndexedNurbsSurface</strong>, <strong>SoGeoSeparator</strong>, <strong>SoLOD</strong>, <strong>SoNurbsSurface</strong>, <strong>SoText2</strong>, <strong>SoIndexedNurbsCurve</strong>, <strong>SoLevelOfDetail</strong>, <strong>SoVRMLCylinder</strong>, <strong>SoCube</strong>, <strong>SoNurbsCurve</strong>, <strong>SoVRMLCone</strong>, <strong>SoVRMLPixelTexture</strong>, <strong>SoSphere</strong>, <strong>SoVRMLBox</strong>, and <strong>SoVRMLSphere</strong>.</p>
<h3>void SoNode::search (\fBSoSearchAction\fP *action)\fC [virtual]\fP</h3>
<p>Action method for <strong>SoSearchAction</strong>.</p><p>Compares the search criteria from the <em>action</em> to see if this node is a match. Searching is done by matching up <em>all</em> criteria set up in the <strong>SoSearchAction</strong> -- if <em>any</em> of the requested criteria is a miss, the search is not deemed successful for the node.</p><p><strong>See also:</strong></p><p><strong>SoSearchAction</strong></p><p>Reimplemented in <strong>SoWWWInline</strong>, <strong>SoVRMLInline</strong>, <strong>SoBaseKit</strong>, <strong>SoProfilerStats</strong>, <strong>SoVRMLSwitch</strong>, <strong>SoDragger</strong>, <strong>SoNodeKitListPart</strong>, <strong>SoVRMLGroup</strong>, <strong>SoVRMLLOD</strong>, <strong>SoSeparator</strong>, <strong>SoArray</strong>, <strong>SoShaderObject</strong>, <strong>SoVRMLShape</strong>, <strong>SoClipPlaneManip</strong>, <strong>SoDirectionalLightManip</strong>, <strong>SoSpotLightManip</strong>, <strong>SoPointLightManip</strong>, <strong>SoTransformManip</strong>, <strong>SoGroup</strong>, <strong>SoSwitch</strong>, <strong>SoVRMLParent</strong>, <strong>SoShaderProgram</strong>, <strong>SoFile</strong>, <strong>SoVRMLBillboard</strong>, <strong>SoMultipleCopy</strong>, <strong>SoPathSwitch</strong>, <strong>SoVRMLAppearance</strong>, <strong>SoCallback</strong>, and <strong>SoVRMLGeometry</strong>.</p>
<h3>void SoNode::write (\fBSoWriteAction\fP *action)\fC [virtual]\fP</h3>
<p>Action method for <strong>SoWriteAction</strong>.</p><p>Writes out a node object, and any connected nodes, engines etc, if necessary.</p><p>Reimplemented in <strong>SoSceneTexture2</strong>, <strong>SoBaseKit</strong>, <strong>SoProfilerStats</strong>, <strong>SoVRMLSwitch</strong>, <strong>SoDragger</strong>, <strong>SoProto</strong>, <strong>SoVRMLGroup</strong>, <strong>SoVRMLLOD</strong>, <strong>SoVRMLShape</strong>, <strong>SoProtoInstance</strong>, <strong>SoGroup</strong>, <strong>SoSwitch</strong>, <strong>SoVRMLParent</strong>, <strong>SoVRMLScript</strong>, <strong>SoVertexShape</strong>, <strong>SoVertexAttribute</strong>, <strong>SoVRMLTimeSensor</strong>, <strong>SoPendulum</strong>, <strong>SoShuttle</strong>, <strong>SoCallback</strong>, and <strong>SoBlinker</strong>.</p>
<h3>void SoNode::audioRender (\fBSoAudioRenderAction\fP *action)\fC [virtual]\fP</h3>
<p>Action method for <strong>SoAudioRenderAction</strong>.</p><p>Does common processing for <strong>SoAudioRenderAction</strong> <em>action</em> instances.</p><p>Reimplemented in <strong>SoCamera</strong>, <strong>SoWWWInline</strong>, <strong>SoVRMLSwitch</strong>, <strong>SoProfilerStats</strong>, <strong>SoVRMLSound</strong>, <strong>SoVRMLGroup</strong>, <strong>SoVRMLLOD</strong>, <strong>SoVRMLTransform</strong>, <strong>SoSeparator</strong>, <strong>SoArray</strong>, <strong>SoGroup</strong>, <strong>SoSwitch</strong>, <strong>SoLOD</strong>, <strong>SoFile</strong>, <strong>SoMultipleCopy</strong>, <strong>SoPathSwitch</strong>, <strong>SoLevelOfDetail</strong>, <strong>SoListener</strong>, and <strong>SoTransformSeparator</strong>.</p>
<h3>void SoNode::getPrimitiveCount (\fBSoGetPrimitiveCountAction\fP *action)\fC [virtual]\fP</h3>
<p>Action method for the <strong>SoGetPrimitiveCountAction</strong>.</p><p>Calculates the number of triangle, line segment and point primitives for the node and adds these to the counters of the <em>action</em>.</p><p>Nodes influencing how geometry nodes calculates their primitive count also overrides this method to change the relevant state variables.</p><p>Reimplemented in <strong>SoCamera</strong>, <strong>SoWWWInline</strong>, <strong>SoVRMLInline</strong>, <strong>SoBaseKit</strong>, <strong>SoMarkerSet</strong>, <strong>SoVRMLFontStyle</strong>, <strong>SoProfilerStats</strong>, <strong>SoDragger</strong>, <strong>SoNodeKitListPart</strong>, <strong>SoVertexProperty</strong>, <strong>SoVRMLGroup</strong>, <strong>SoVRMLLOD</strong>, <strong>SoImage</strong>, <strong>SoText3</strong>, <strong>SoVRMLTransform</strong>, <strong>SoUnits</strong>, <strong>SoShape</strong>, <strong>SoTransform</strong>, <strong>SoVRMLElevationGrid</strong>, <strong>SoSeparator</strong>, <strong>SoVRMLShape</strong>, <strong>SoArray</strong>, <strong>SoFontStyle</strong>, <strong>SoGroup</strong>, <strong>SoMaterialBinding</strong>, <strong>SoNormalBinding</strong>, <strong>SoSwitch</strong>, <strong>SoVRMLParent</strong>, <strong>SoRotationXYZ</strong>, <strong>SoCone</strong>, <strong>SoCylinder</strong>, <strong>SoIndexedNurbsSurface</strong>, <strong>SoProfile</strong>, <strong>SoVRMLText</strong>, <strong>SoAsciiText</strong>, <strong>SoComplexity</strong>, <strong>SoLOD</strong>, <strong>SoVRMLExtrusion</strong>, <strong>SoGeoSeparator</strong>, <strong>SoGeoCoordinate</strong>, <strong>SoGeoLocation</strong>, <strong>SoNurbsSurface</strong>, <strong>SoResetTransform</strong>, <strong>SoText2</strong>, <strong>SoVertexAttributeBinding</strong>, <strong>SoVRMLIndexedFaceSet</strong>, <strong>SoFile</strong>, <strong>SoGeoOrigin</strong>, <strong>SoMultipleCopy</strong>, <strong>SoPathSwitch</strong>, <strong>SoCallback</strong>, <strong>SoIndexedNurbsCurve</strong>, <strong>SoVRMLCylinder</strong>, <strong>SoVRMLVertexPoint</strong>, <strong>SoCoordinate3</strong>, <strong>SoCoordinate4</strong>, <strong>SoCube</strong>, <strong>SoFont</strong>, <strong>SoMatrixTransform</strong>, <strong>SoNormal</strong>, <strong>SoNurbsCurve</strong>, <strong>SoRotation</strong>, <strong>SoScale</strong>, <strong>SoTranslation</strong>, <strong>SoVRMLCone</strong>, <strong>SoVRMLNormal</strong>, <strong>SoVRMLTextureCoordinate</strong>, <strong>SoIndexedLineSet</strong>, <strong>SoTransformSeparator</strong>, <strong>SoFaceSet</strong>, <strong>SoIndexedFaceSet</strong>, <strong>SoIndexedTriangleStripSet</strong>, <strong>SoProfileCoordinate2</strong>, <strong>SoProfileCoordinate3</strong>, <strong>SoVRMLIndexedLineSet</strong>, <strong>SoIndexedPointSet</strong>, <strong>SoLineSet</strong>, <strong>SoPointSet</strong>, <strong>SoQuadMesh</strong>, <strong>SoSphere</strong>, <strong>SoVRMLBox</strong>, <strong>SoVRMLSphere</strong>, and <strong>SoTriangleStripSet</strong>.</p>
<h3>void SoNode::grabEventsSetup (void)\fC [virtual]\fP</h3>
<p>Called from <strong>SoHandleEventAction::setGrabber()</strong> to notify a node when it becomes the node where all events are sent.</p><p>Reimplemented in <strong>SoDragger</strong>.</p>
<h3>void SoNode::grabEventsCleanup (void)\fC [virtual]\fP</h3>
<p>Called from <strong>SoHandleEventAction</strong> to notify a node when it looses status as the node where events are sent.</p><p>Reimplemented in <strong>SoDragger</strong>.</p>
<h3>void SoNode::startNotify (void)\fC [virtual]\fP</h3>
<p>This is the method which starts the notification sequence after changes.</p><p>At the end of a notification sequence, all 'immediate' sensors (i.e. sensors set up with a zero priority) are triggered.</p><p>Reimplemented from <strong>SoBase</strong>.</p>
<h3>void SoNode::notify (\fBSoNotList\fP *l)\fC [virtual]\fP</h3>
<p>Notifies all auditors for this instance when changes are made.</p><p>Reimplemented from <strong>SoFieldContainer</strong>.</p><p>Reimplemented in <strong>SoSceneTexture2</strong>, <strong>SoVRMLSwitch</strong>, <strong>SoVRMLLOD</strong>, <strong>SoProfilerStats</strong>, <strong>SoSceneTextureCubeMap</strong>, <strong>SoTextureCubeMap</strong>, <strong>SoText3</strong>, <strong>SoTexture2</strong>, <strong>SoImage</strong>, <strong>SoTexture3</strong>, <strong>SoVRMLGroup</strong>, <strong>SoVertexProperty</strong>, <strong>SoVRMLParent</strong>, <strong>SoVRMLTransform</strong>, <strong>SoVRMLVertexShape</strong>, <strong>SoShadowGroup</strong>, <strong>SoVRMLElevationGrid</strong>, <strong>SoAsciiText</strong>, <strong>SoVRMLShape</strong>, <strong>SoSeparator</strong>, <strong>SoVRMLScript</strong>, <strong>SoBumpMap</strong>, <strong>SoVRMLProximitySensor</strong>, <strong>SoVRMLExtrusion</strong>, <strong>SoSwitch</strong>, <strong>SoVRMLBillboard</strong>, <strong>SoVRMLText</strong>, <strong>SoLOD</strong>, <strong>SoMaterial</strong>, <strong>SoShape</strong>, <strong>SoVertexAttribute</strong>, <strong>SoVRMLTouchSensor</strong>, <strong>SoLevelOfDetail</strong>, <strong>SoVRMLAppearance</strong>, <strong>SoVRMLIndexedLine</strong>, <strong>SoVRMLPixelTexture</strong>, <strong>SoVRMLIndexedLineSet</strong>, <strong>SoBlinker</strong>, <strong>SoIndexedLineSet</strong>, <strong>SoPackedColor</strong>, <strong>SoVertexShape</strong>, <strong>SoVRMLCollision</strong>, <strong>SoVRMLTimeSensor</strong>, <strong>SoVRMLVertexPoint</strong>, <strong>SoVRMLGeometry</strong>, <strong>SoVRMLVertexLine</strong>, <strong>SoNodeEngine</strong>, <strong>SoVRMLIndexedShape</strong>, and <strong>SoIndexedPointSet</strong>.</p>
<h3>uint32_t SoNode::getNodeId (void) const</h3>
<p>This returns the node's current unique identification number. It is unlikely that application programmers will ever need use this method fom client application code, unless working with extensions to the core library (and probably not even then).</p><p>The id number is only valid for as long as the node is kept unchanged -- upon <em>any</em> kind of change the internal id will be updated (in the <strong>notify()</strong> method), and the old id number forgotten.</p><p>The technique described above plays an important role in the way internal scenegraph caches are set up and invalidated.</p><p><strong>See also:</strong></p><p><strong>SoNode::getNextNodeId()</strong></p>
<h3>\fBSoChildList\fP * SoNode::getChildren (void) const\fC [virtual]\fP</h3>
<p>Returns list of children for this node.</p><p>Reimplemented in <strong>SoVRMLInline</strong>, <strong>SoBaseKit</strong>, <strong>SoVRMLSwitch</strong>, <strong>SoVRMLLOD</strong>, <strong>SoWWWInline</strong>, <strong>SoNodeKitListPart</strong>, <strong>SoVRMLShape</strong>, <strong>SoClipPlaneManip</strong>, <strong>SoDirectionalLightManip</strong>, <strong>SoGroup</strong>, <strong>SoSpotLightManip</strong>, <strong>SoPointLightManip</strong>, <strong>SoTransformManip</strong>, <strong>SoVRMLText</strong>, <strong>SoFile</strong>, <strong>SoVRMLParent</strong>, <strong>SoVRMLAppearance</strong>, and <strong>SoVRMLGeometry</strong>.</p>
<h3>void SoNode::writeInstance (\fBSoOutput\fP *out)\fC [virtual]\fP</h3>
<p>Writes all the fields contained in this instance to the output stream within <em>out</em>.</p><p>This method is solely called from the write methods of fields.</p><p>Either from <strong>SoField</strong> if the write is done because of a field-to-field connection, or from one of the fields which may actually write <strong>SoFieldContainer</strong> instances, i.e. <strong>SoSFNode</strong>, <strong>SoMFNode</strong>, <strong>SoSFEngine</strong>, <strong>SoMFEngine</strong>, <strong>SoSFPath</strong> and <strong>SoMFPath</strong>.</p><p>This method, in addition to the ordinary <strong>write()</strong> method of <strong>SoNode</strong>, needs to be present since the fields don't have a write action instance in their writeValue() method, and <strong>writeInstance()</strong> will create a new <strong>SoWriteAction</strong> and call continueToApply() on it.</p><p>Reimplemented from <strong>SoFieldContainer</strong>.</p><p>Reimplemented in <strong>SoNodeEngine</strong>.</p>
<h3>\fBSoNode\fP * SoNode::addToCopyDict (void) const\fC [virtual]\fP</h3>
<p>Add a copy of this node and (recursively) all children to the copy dictionary of <strong>SoFieldContainer</strong> if this has not already been done.</p><p>Used internally during copy operations.</p><p>Reimplemented in <strong>SoBaseKit</strong>.</p>
<h3>void SoNode::copyContents (const \fBSoFieldContainer\fP *from, SbBoolcopyconnections)\fC [virtual]\fP</h3>
<p>Makes a deep copy of all data of <em>from</em> into this instance, <em>except</em> external scenegraph references if <em>copyconnections</em> is FALSE<em>.</em></p><p>This is the method that should be overridden by extension node / engine / dragger / whatever subclasses which needs to account for internal data that are not handled automatically.</p><p>For copying nodes from application code, you should not invoke this function directly, but rather call the <strong>SoNode::copy()</strong> function:</p>
<pre>
SoNode * mynewnode = templatenode-&gt;copy();
</pre>
<p>The same also goes for engines.</p><p>Make sure that when you override the <strong>copyContents()</strong> method in your extension class that you also make it call upwards to it's parent superclass in the inheritance hierarchy, as <strong>copyContents()</strong> in for instance <strong>SoNode</strong> and <strong>SoFieldContainer</strong> does important work. It should go something like this:</p>
<pre>
void
MyCoinExtensionNode::copyContents(const SoFieldContainer * from,
                                  SbBool copyconnections)
{
  // let parent superclasses do their thing (copy fields, copy
  // instance name, etc etc)
  SoNode::copyContents(from, copyconnections);

  // [..then copy internal data..]
}
</pre>
<p>Reimplemented from <strong>SoFieldContainer</strong>.</p><p>Reimplemented in <strong>SoWWWInline</strong>, <strong>SoBaseKit</strong>, <strong>SoVRMLSwitch</strong>, <strong>SoVRMLLOD</strong>, <strong>SoInteractionKit</strong>, <strong>SoNodeKitListPart</strong>, <strong>SoVRMLParent</strong>, <strong>SoClipPlaneManip</strong>, <strong>SoGroup</strong>, <strong>SoDirectionalLightManip</strong>, <strong>SoSpotLightManip</strong>, <strong>SoVRMLShape</strong>, <strong>SoPointLightManip</strong>, <strong>SoTransformManip</strong>, <strong>SoVRMLScript</strong>, <strong>SoRotateSphericalDragger</strong>, <strong>SoRotateCylindricalDragger</strong>, <strong>SoFile</strong>, <strong>SoCallback</strong>, <strong>SoVertexAttribute</strong>, <strong>SoVRMLAppearance</strong>, and <strong>SoVRMLGeometry</strong>.</p>
<h3>\fBSoFieldContainer\fP * SoNode::copyThroughConnection (void) const\fC [virtual]\fP</h3>
<p>Return copy of this instance.</p><p>Note: default implementation just returns this pointer, <strong>SoNode</strong> and <strong>SoEngine</strong> overrides this method to return the pointer to the actual copy.</p><p>Reimplemented from <strong>SoFieldContainer</strong>.</p>
<h3>\fBSoNode\fP * SoNode::getByName (const \fBSbName\fP &name)\fC [static]\fP</h3>
<p>Returns the last node that was registered under <em>name</em>.</p><p><strong>See also:</strong></p><p><strong>SoBase::setName()</strong></p>
<h3>int SoNode::getByName (const \fBSbName\fP &name, \fBSoNodeList\fP &l)\fC [static]\fP</h3>
<p>Finds all nodes with <em>name</em> and appends them to the <em>l</em> nodelist. Returns the number of nodes with the specified name.</p><p><strong>See also:</strong></p><p><strong>SoBase::setName()</strong></p>
<h3>void SoNode::initClasses (void)\fC [static]\fP</h3>
<p>Initialize all the node classes of Coin.</p>
<h3>uint32_t SoNode::getNextNodeId (void)\fC [static]\fP</h3>
<p>Return the next unique identification number to be assigned upon node construction or change. It is unlikely that application programmers will ever need use this method from client application code, unless working with extensions to the core library (and probably not even then).</p><p><strong>See also:</strong></p><p><strong>SoNode::getNodeId</strong></p>
<h3>int SoNode::getActionMethodIndex (const \fBSoType\fPtype)\fC [static]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>void SoNode::getBoundingBoxS (\fBSoAction\fP *action, \fBSoNode\fP *node)\fC [static]\fP</h3>
<p>This is a static 'helper' method registered with the action, and used for calling the <strong>SoNode::getBoundingBox()</strong> virtual method which does the <em>real</em> work.</p>
<h3>void SoNode::GLRenderS (\fBSoAction\fP *action, \fBSoNode\fP *node)\fC [static]\fP</h3>
<p>This is a static 'helper' method registered with the action, and used for calling the <strong>SoNode::GLRender()</strong> virtual method which does the <em>real</em> work.</p>
<h3>void SoNode::callbackS (\fBSoAction\fP *action, \fBSoNode\fP *node)\fC [static]\fP</h3>
<p>This is a static 'helper' method registered with the action, and used for calling the <strong>SoNode::callback()</strong> virtual method which does the <em>real</em> work.</p>
<h3>void SoNode::getMatrixS (\fBSoAction\fP *action, \fBSoNode\fP *node)\fC [static]\fP</h3>
<p>This is a static 'helper' method registered with the action, and used for calling the <strong>SoNode::getMatrix()</strong> virtual method which does the <em>real</em> work.</p>
<h3>void SoNode::handleEventS (\fBSoAction\fP *action, \fBSoNode\fP *node)\fC [static]\fP</h3>
<p>This is a static 'helper' method registered with the action, and used for calling the <strong>SoNode::handleEvent()</strong> virtual method which does the <em>real</em> work.</p>
<h3>void SoNode::pickS (\fBSoAction\fP *action, \fBSoNode\fP *node)\fC [static]\fP</h3>
<p>This is a static 'helper' method registered with the action, and used for calling the <strong>SoNode::pick()</strong> virtual method which does the <em>real</em> work.</p>
<h3>void SoNode::rayPickS (\fBSoAction\fP *action, \fBSoNode\fP *node)\fC [static]\fP</h3>
<p>This is a static 'helper' method registered with the action, and used for calling the <strong>SoNode::rayPick()</strong> virtual method which does the <em>real</em> work.</p>
<h3>void SoNode::searchS (\fBSoAction\fP *action, \fBSoNode\fP *node)\fC [static]\fP</h3>
<p>This is a static 'helper' method registered with the action, and used for calling the <strong>SoNode::search()</strong> virtual method which does the <em>real</em> work.</p>
<h3>void SoNode::writeS (\fBSoAction\fP *action, \fBSoNode\fP *node)\fC [static]\fP</h3>
<p>This is a static 'helper' method registered with the action, and used for calling the <strong>SoNode::write()</strong> virtual method which does the <em>real</em> work.</p>
<h3>void SoNode::audioRenderS (\fBSoAction\fP *action, \fBSoNode\fP *node)\fC [static]\fP</h3>
<p>This is a static 'helper' method registered with the action, and used for calling the <strong>SoNode::audioRender()</strong> virtual method which does the <em>real</em> work.</p>
<h3>void SoNode::getPrimitiveCountS (\fBSoAction\fP *action, \fBSoNode\fP *node)\fC [static]\fP</h3>
<p>This is a static 'helper' method registered with the action, and used for calling the <strong>SoNode::getPrimitiveCount()</strong> virtual method which does the <em>real</em> work.</p>
<h3>SbBool SoNode::readInstance (\fBSoInput\fP *in, unsigned shortflags)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>This method is mainly intended for internal use during file import operations.</p><p>It reads a definition of an instance from the input stream <em>in</em>. The input stream state points to the start of a serialized / persistant representation of an instance of this class type.</p><p>TRUE or FALSE is returned, depending on if the instantiation and configuration of the new object of this class type went ok or not. The import process should be robust and handle corrupted input streams by returning FALSE.</p><p><em>flags</em> is used internally during binary import when reading user extension nodes, group nodes or engines.</p><p>Reimplemented from <strong>SoFieldContainer</strong>.</p><p>Reimplemented in <strong>SoBaseKit</strong>, <strong>SoWWWInline</strong>, <strong>SoVRMLSwitch</strong>, <strong>SoVRMLLOD</strong>, <strong>SoInteractionKit</strong>, <strong>SoTextureCubeMap</strong>, <strong>SoNodeKitListPart</strong>, <strong>SoSeparator</strong>, <strong>SoTexture2</strong>, <strong>SoImage</strong>, <strong>SoVRMLParent</strong>, <strong>SoTexture3</strong>, <strong>SoShaderObject</strong>, <strong>SoProto</strong>, <strong>SoFile</strong>, <strong>SoGroup</strong>, <strong>SoVRMLImageTexture</strong>, <strong>SoProtoInstance</strong>, <strong>SoNormalBinding</strong>, <strong>SoBumpMap</strong>, <strong>SoVertexAttribute</strong>, <strong>SoTextureCoordinateBinding</strong>, <strong>SoVRMLBackground</strong>, <strong>SoNodeEngine</strong>, and <strong>SoVRMLPixelTexture</strong>.</p>
<h3>const \fBSoFieldData\fP ** SoNode::getFieldDataPtr (void)\fC [static]\fP, \fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>void SoNode::setNextActionMethodIndex (intindex)\fC [static]\fP, \fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p><p>Only in TGS Inventor on Win32 -- to avoid needing to export the nextActionMethodIndex member, see <strong>SoNode.h</strong> for more info.</p>
<h3>int SoNode::getNextActionMethodIndex (void)\fC [static]\fP, \fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p><p>Only in TGS Inventor on Win32 -- to avoid needing to export the nextActionMethodIndex member, see <strong>SoNode.h</strong> for more info.</p>
<h3>void SoNode::incNextActionMethodIndex (void)\fC [static]\fP, \fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p><p>Only in TGS Inventor on Win32 -- to avoid needing to export the nextActionMethodIndex member, see <strong>SoNode.h</strong> for more info.</p>
<h3>void SoNode::setCompatibilityTypes (const \fBSoType\fP &nodetype, const uint32_tbitmask)\fC [static]\fP, \fC [protected]\fP</h3>
<p>Set the node compatibility mask for node type <em>nodetype</em>. The mask specifies for which file formats the node is supported.</p><p>This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2.1 API.</p><p><strong>See also:</strong></p><p>getCompatibilityMode()</p><p><strong>Since:</strong></p><p>Coin 2.0</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Data Documentation</h2>
        <div class="sectioncontent">
<h3>uint32_t SoNode::uniqueId\fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>uint32_t SoNode::nextUniqueId = 1\fC [static]\fP, \fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>int SoNode::nextActionMethodIndex = 0\fC [static]\fP, \fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for Coin from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="SoMultipleCopy.3.html"><span aria-hidden="true">&larr;</span> SoMultipleCopy.3: The somultiplecopy class redraws it's children multiple times at different transformations.  the somultiplecopy group node duplicates it's children nodes / subgraphs without using additional memory resources.</a></li>
   <li class="next"><a href="SoNodeEngine.3.html">SoNodeEngine.3: Sonodeengine is the base class for coin node engines.  node engines have the same functionality as normal engines, except that they inherit sonode, which makes it possible to insert node engines in the scene graph. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>XMLTV: Perl extension to read and write tv listings in xmltv format</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Perl extension to read and write tv listings in xmltv format">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="XMLTV (3pm) manual">
  <meta name="twitter:description" content="Perl extension to read and write tv listings in xmltv format">
  <meta name="twitter:image" content="https://www.carta.tech/images/libxmltv-perl-XMLTV-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/XMLTV.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="XMLTV (3pm) manual" />
  <meta property="og:description" content="Perl extension to read and write tv listings in xmltv format" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libxmltv-perl-XMLTV-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">XMLTV<small> (3pm)</small></h1>
        <p class="lead">Perl extension to read and write tv listings in xmltv format</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/XMLTV.3pm.html">
      <span itemprop="name">XMLTV: Perl extension to read and write tv listings in xmltv format</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libxmltv-perl/">
      <span itemprop="name">libxmltv-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/XMLTV.3pm.html">
      <span itemprop="name">XMLTV: Perl extension to read and write tv listings in xmltv format</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  use XMLTV;
  my $data = XMLTV::parsefile(&apos;tv.xml&apos;);
  my ($encoding, $credits, $ch, $progs) = @$data;
  my $langs = [ &apos;en&apos;, &apos;fr&apos; ];
  print &apos;source of listings is: &apos;, $credits-&gt;{&apos;source-info-name&apos;}, "&#92;n"
      if defined $credits-&gt;{&apos;source-info-name&apos;};
  foreach (values %$ch) {
      my ($text, $lang) = @{XMLTV::best_name($langs, $_-&gt;{&apos;display-name&apos;})};
      print "channel $_-&gt;{id} has name $text&#92;n";
      print "...in language $lang&#92;n" if defined $lang;
  }
  foreach (@$progs) {
      print "programme on channel $_-&gt;{channel} at time $_-&gt;{start}&#92;n";
      next if not defined $_-&gt;{desc};
      foreach (@{$_-&gt;{desc}}) {
          my ($text, $lang) = @$_;
          print "has description $text&#92;n";
          print "...in language $lang&#92;n" if defined $lang;
      }
  }
</pre>
<p>The value of $data will be something a bit like:</p><p>  [ &apos;UTF-8&apos;,     { &apos;source-info-name&apos; =&gt; &apos;Ananova&apos;, &apos;generator-info-name&apos; =&gt; &apos;XMLTV&apos; },     { &apos;radio-4.bbc.co.uk&apos; =&gt; { &apos;display-name&apos; =&gt; [ [ &apos;en&apos;,  &apos;BBC Radio 4&apos; ],                                                    [ &apos;en&apos;,  &apos;Radio 4&apos;     ],                                                    [ undef, &apos;4&apos;           ] ],                                &apos;id&apos; =&gt; &apos;radio-4.bbc.co.uk&apos; },       ... },     [ { start =&gt; &apos;200111121800&apos;, title =&gt; [ [ &apos;Simpsons&apos;, &apos;en&apos; ] ],         channel =&gt; &apos;radio-4.bbc.co.uk&apos; },       ... ] ]</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module provides an interface to read and write files in \s-1XMLTV\s0 format (a \s-1TV\s0 listings format defined by xmltv.dtd).  In general element names in the \s-1XML\s0 correspond to hash keys in the Perl data structure. You can think of this module as a bit like <strong>XML::Simple</strong>, but specialized to the \s-1XMLTV\s0 file format.</p><p>The Perl data structure corresponding to an \s-1XMLTV\s0 file has four elements.  The first gives the character encoding used for text data, typically \s-1UTF-8\s0 or \s-1ISO-8859-1\s0.  (The encoding value could also be undef meaning 'unknown', when the library can't work out what it is.)  The second element gives the attributes of the root &lt;tv&gt; element, which give information about the source of the \s-1TV\s0 listings. The third element is a list of channels, each list element being a hash corresponding to one &lt;channel&gt; element.  The fourth element is similarly a list of programmes.  More details about the data structure are given later.  The easiest way to find out what it looks like is to load some small \s-1XMLTV\s0 files and use <strong>Data::Dumper</strong> to print out the resulting structure.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">USAGE</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    parse(document)
  </dt>
  <dd>
    <p>Takes an \s-1XMLTV\s0 document (a string) and returns the Perl data structure.  It is assumed that the document is valid \s-1XMLTV\s0; if not the routine may <em>die()</em> with an error (although the current implementation just warns and continues for most small errors). The first element of the listref returned, the encoding, may vary according to the encoding of the input document, the versions of perl and \*(C`XML::Parser\*(C' installed, the configuration of the \s-1XMLTV\s0 library and other factors including, but not limited to, the phase of the moon.  With luck it should always be either the encoding of the input file or \s-1UTF-8\s0. Attributes and elements in the \s-1XML\s0 file whose names begin with 'x-' are skipped silently.  You can use these to include information which is not currently handled by the \s-1XMLTV\s0 format, or by this module.</p>
  </dd>
  <dt>
    parsefiles(filename...)
  </dt>
  <dd>
    <p>Like \*(C`parse()\*(C' but takes one or more filenames instead of a string document.  The data returned is the merging of those file contents: the programmes will be concatenated in their original order, the channels just put together in arbitrary order (ordering of channels should not matter). It is necessary that each file have the same character encoding, if not, an exception is thrown.  Ideally the credits information would also be the same between all the files, since there is no obvious way to merge it - but if the credits information differs from one file to the next, one file is picked arbitrarily to provide credits and a warning is printed.  If two files give differing channel definitions for the same \s-1XMLTV\s0 channel id, then one is picked arbitrarily and a warning is printed. In the simple case, with just one file, you needn't worry about mismatching of encodings, credits or channels. The deprecated function \*(C`parsefile()\*(C' is a wrapper allowing just one filename.</p>
  </dd>
  <dt>
    parse_callback(document, encoding_callback, credits_callback, channel_callback, programme_callback)
  </dt>
  <dd>
    <p>An alternative interface.  Whereas \*(C`parse()\*(C' reads the whole document and then returns a finished data structure, with this routine you specify a subroutine to be called as each &lt;channel&gt; element is read and another for each &lt;programme&gt; element. The first argument is the document to parse.  The remaining arguments are code references, one for each part of the document. The callback for encoding will be called once with a string giving the encoding.  In present releases of this module, it is also possible for the value to be undefined meaning 'unknown', but it's hoped that future releases will always be able to figure out the encoding used. The callback for credits will be called once with a hash reference. For channels and programmes, the appropriate function will be called zero or more times depending on how many channels / programmes are found in the file. The four subroutines will be called in order, that is, the encoding and credits will be done before the channel handler is called and all the channels will be dealt with before the first programme handler is called. If any of the code references is undef, nothing is called for that part of the file. For backwards compatibility, if the value for 'encoding callback' is not a code reference but a scalar reference, then the encoding found will be stored in that scalar.  Similarly if the 'credits callback' is a scalar reference, the scalar it points to will be set to point to the hash of credits.  This style of interface is deprecated: new code should just use four callbacks. For example:     my $document = &apos;&lt;tv&gt;...&lt;/tv&gt;&apos;;</p><p>    my $encoding;     sub encoding_cb( $ ) { $encoding = shift }</p><p>    my $credits;     sub credits_cb( $ ) { $credits = shift }</p><p>    # The callback for each channel populates this hash.     my %channels;     sub channel_cb( $ ) {         my $c = shift;         $channels{$c-&gt;{id}} = $c;     }</p><p>    # The callback for each programme.  We know that channels are     # always read before programmes, so the %channels hash will be     # fully populated.     #     sub programme_cb( $ ) {         my $p = shift;         print "got programme: $p-&gt;{title}-&gt;[0]-&gt;[0]&#92;n";         my $c = $channels{$p-&gt;{channel}};         print &apos;channel name is: &apos;, $c-&gt;{&apos;display-name&apos;}-&gt;[0]-&gt;[0], "&#92;n";     }</p><p>    # Let&apos;s go.     XMLTV::parse_callback($document, &#92;&encoding_cb, &#92;&credits_cb,                           &#92;&channel_cb, &#92;&programme_cb);</p>
  </dd>
  <dt>
    parsefiles_callback(encoding_callback, credits_callback, channel_callback, programme_callback, filenames...)
  </dt>
  <dd>
    <p>As \*(C`parse_callback()\*(C' but takes one or more filenames to open, merging their contents in the same manner as \*(C`parsefiles()\*(C'.  Note that the reading is still gradual - you get the channels and programmes one at a time, as they are read. Note that the same &lt;channel&gt; may be present in more than one file, so the channel callback will get called more than once.  It's your responsibility to weed out duplicate channel elements (since writing them out again requires that each have a unique id). For compatibility, there is an alias \*(C`parsefile_callback()\*(C' which is the same but takes only a single filename, <strong>before</strong> the callback arguments.  This is deprecated.</p>
  </dd>
  <dt>
    write_data(data, options...)
  </dt>
  <dd>
    <p>Takes a data structure and writes it as \s-1XML\s0 to standard output.  Any extra arguments are passed on to XML::Writer's constructor, for example     my $f = new IO::File &apos;&gt;out.xml&apos;; die if not $f;     write_data($data, OUTPUT =&gt; $f); The encoding used for the output is given by the first element of the data. Normally, there will be a warning for any Perl data which is not understood and cannot be written as \s-1XMLTV\s0, such as strange keys in hashes.  But as an exception, any hash key beginning with an underscore will be skipped over silently.  You can store 'internal use only' data this way. If a programme or channel hash contains a key beginning with 'debug', this key and its value will be written out as a comment inside the &lt;programme&gt; or &lt;channel&gt; element.  This lets you include small debugging messages in the \s-1XML\s0 output.</p>
  </dd>
  <dt>
    best_name(languages, pairs [, comparator])
  </dt>
  <dd>
    <p>The \s-1XMLTV\s0 format contains many places where human-readable text is given an optional 'lang' attribute, to allow mixed languages.  This is represented in Perl as a pair [ text, lang ], although the second element may be missing or undef if the language is unknown.  When several alernatives for an element (such as &lt;title&gt;) can be given, the representation is a list of [ text, lang ] pairs.  Given such a list, what is the best text to use?  It depends on the user's preferred language. This function takes a list of acceptable languages and a list of [string, language] pairs, and finds the best one to use.  This means first finding the appropriate language and then picking the 'best' string in that language. The best is normally defined as the first one found in a usable language, since the \s-1XMLTV\s0 format puts the most canonical versions first.  But you can pass in your own comparison function, for example if you want to choose the shortest piece of text that is in an acceptable language. The acceptable languages should be a reference to a list of language codes looking like 'ru', or like 'de_DE'.  The text pairs should be a reference to a list of pairs [ string, language ].  (As a special case if this list is empty or undef, that means no text is present, and the result is undef.)  The third argument if present should be a cmp-style function that compares two strings of text and returns 1 if the first argument is better, -1 if the second better, 0 if they're equally good. Returns: [s, l] pair, where s is the best of the strings to use and l is its language.  This pair is 'live' - it is one of those from the list passed in.  So you can use \*(C`best_name()\*(C' to find the best pair from a list and then modify the content of that pair. (This routine depends on the \*(C`Lingua::Preferred\*(C' module being installed; if that module is missing then the first available language is always chosen.) Example:     my $langs = [ &apos;de&apos;, &apos;fr&apos; ]; # German or French, please</p><p>    # Say we found the following under $p-&gt;{title} for a programme $p.     my $pairs = [ [ &apos;La CitE des enfants perdus&apos;, &apos;fr&apos; ],                   [ &apos;The City of Lost Children&apos;, &apos;en_US&apos; ] ];</p><p>    my $best = best_name($langs, $pairs);     print "chose title $best-&gt;[0]&#92;n";</p>
  </dd>
  <dt>
    <em>list_channel_keys()</em>, <em>list_programme_keys()</em>
  </dt>
  <dd>
    <p>Some users of this module may wish to enquire at runtime about which keys a programme or channel hash can contain.  The data in the hash comes from the attributes and subelements of the corresponding element in the \s-1XML\s0.  The values of attributes are simply stored as strings, while subelements are processed with a handler which may return a complex data structure.  These subroutines returns a hash mapping key to handler name and multiplicity.  This lets you know what data types can be expected under each key.  For keys which come from attributes rather than subelements, the handler is set to 'scalar', just as for subelements which give a simple string.  See \*(L"\s-1DATA\s0 \s-1STRUCTURE\s0\*(R" for details on what the different handler names mean. It is not possible to find out which keys are mandatory and which optional, only a list of all those which might possibly be present. An example use of these routines is the tv_grep program, which creates its allowed command line arguments from the names of programme subelements.</p>
  </dd>
  <dt>
    catfiles(w_args, filename...)
  </dt>
  <dd>
    <p>Concatenate several listings files, writing the output to somewhere specified by \*(C`w_args\*(C'.  Programmes are catenated together, channels are merged, for credits we just take the first and warn if the others differ. The first argument is a hash reference giving information to pass to \*(C`XMLTV::Writer\*(C''s constructor.  But do not specify encoding, this will be taken from the input files.  Currently \*(C`catfiles()\*(C' will fail work if the input files have different encodings.</p>
  </dd>
  <dt>
    cat(data, ...)
  </dt>
  <dd>
    <p>Concatenate (and merge) listings data.  Programmes are catenated together, channels are merged, for credits we just take the first and warn if the others differ (except that the 'date' of the result is the latest date of all the inputs). Whereas \*(C`catfiles()\*(C' reads and writes files, this function takes already-parsed listings data and returns some more listings data.  It is much more memory-hungry.</p>
  </dd>
  <dt>
    cat_noprogrammes
  </dt>
  <dd>
    <p>Like \*(C`cat()\*(C' but ignores the programme data and just returns encoding, credits and channels.  This is in case for scalability reasons you want to handle programmes individually, but still merge the smaller data.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DATA STRUCTURE</h2>
        <div class="sectioncontent">
<p>For completeness, we describe more precisely how channels and programmes are represented in Perl.  Each element of the channels list is a hashref corresponding to one &lt;channel&gt; element, and likewise for programmes.  The possible keys of a channel (programme) hash are the names of attributes or subelements of &lt;channel&gt; (&lt;programme&gt;).</p><p>The values for attributes are not processed in any way; an attribute \*(C`fred="jim"\*(C' in the \s-1XML\s0 will become a hash element with key &apos;fred&apos;, value &apos;jim&apos;.</p><p>But for subelements, there is further processing needed to turn the \s-1XML\s0 content of a subelement into Perl data.  What is done depends on what type of data is stored under that subelement.  Also, if a certain element can appear several times then the hash key for that element points to a list of values rather than just one.</p><p>The conversion of a subelement's content to and from Perl data is done by a handler.  The most common handler is <em>with-lang</em>, used for human-readable text content plus an optional 'lang' attribute.  There are other handlers for other data structures in the file format. Often two subelements will share the same handler, since they hold the same type of data.  The handlers defined are as follows; note that many of them will silently strip leading and trailing whitespace in element content.  Look at the \s-1DTD\s0 itself for an explanation of the whole file format.</p><p>Unless specified otherwise, it is not allowed for an element expected to contain text to have empty content, nor for the text to contain newline characters.</p>
<dl class='dl-vertical'>
  <dt>
    <em>credits</em>
  </dt>
  <dd>
    <p>Turns a list of credits (for director, actor, writer, etc.) into a hash mapping 'role' to a list of names.  The names in each role are kept in the same order.</p>
  </dd>
  <dt>
    <em>scalar</em>
  </dt>
  <dd>
    <p>Reads and writes a simple string as the content of the \s-1XML\s0 element.</p>
  </dd>
  <dt>
    <em>length</em>
  </dt>
  <dd>
    <p>Converts the content of a &lt;length&gt; element into a number of seconds (so &lt;length units=\*(L"minutes\*(R"&gt;5&lt;/minutes&gt; would be returned as 300).  On writing out again tries to convert a number of seconds to a time in minutes or hours if that would look better.</p>
  </dd>
  <dt>
    <em>episode-num</em>
  </dt>
  <dd>
    <p>The representation in Perl of \s-1XMLTV\s0's odd episode numbers is as a pair of [ content, system ].  As specified by the \s-1DTD\s0, if the system is not given in the file then 'onscreen' is assumed.  Whitespace in the 'xmltv_ns' system is unimportant, so on reading it is normalized to a single space on either side of each dot.</p>
  </dd>
  <dt>
    <em>video</em>
  </dt>
  <dd>
    <p>The &lt;video&gt; section is converted to a hash.  The &lt;present&gt; subelement corresponds to the key 'present' of this hash, 'yes' and 'no' are converted to Booleans.  The same applies to &lt;colour&gt;.  The content of the &lt;aspect&gt; subelement is stored under the key 'aspect'.  These keys can be missing in the hash just as the subelements can be missing in the \s-1XML\s0.</p>
  </dd>
  <dt>
    <em>audio</em>
  </dt>
  <dd>
    <p>This is similar to <em>video</em>.  &lt;present&gt; is a Boolean value, while the content of &lt;stereo&gt; is stored unchanged.</p>
  </dd>
  <dt>
    <em>previously-shown</em>
  </dt>
  <dd>
    <p>The 'start' and 'channel' attributes are converted to keys in a hash.</p>
  </dd>
  <dt>
    <em>presence</em>
  </dt>
  <dd>
    <p>The content of the element is ignored: it signfies something by its very presence.  So the conversion from \s-1XML\s0 to Perl is a constant true value whenever the element is found; the conversion from Perl to \s-1XML\s0 is to write out the element if true, don't write anything if false.</p>
  </dd>
  <dt>
    <em>subtitles</em>
  </dt>
  <dd>
    <p>The 'type' attribute and the 'language' subelement (both optional) become keys in a hash.  But see <em>language</em> for what to pass as the value of that element.</p>
  </dd>
  <dt>
    <em>rating</em>
  </dt>
  <dd>
    <p>The rating is represented as a tuple of [ rating, system, icons ]. The last element is itself a listref of structures returned by the <em>icon</em> handler.</p>
  </dd>
  <dt>
    <em>star-rating</em>
  </dt>
  <dd>
    <p>In \s-1XML\s0 this is a string 'X/Y' plus a list of icons.  In Perl represented as a pair [ rating, icons ] similar to <em>rating</em>. Multiple star ratings are now supported. For backward compatability, you may specify a single [rating,icon] or the preferred double array [[rating,system,icon],[rating2,system2,icon2]] (like 'ratings')</p>
  </dd>
  <dt>
    <em>icon</em>
  </dt>
  <dd>
    <p>An icon in \s-1XMLTV\s0 files is like the &lt;img&gt; element in \s-1HTML\s0.  It is represented in Perl as a hashref with 'src' and optionally 'width' and 'height' keys.</p>
  </dd>
  <dt>
    <em>with-lang</em>
  </dt>
  <dd>
    <p>In \s-1XML\s0 something like title can be either &lt;title&gt;Foo&lt;/title&gt; or &lt;title lang=\*(L"en\*(R"&gt;Foo&lt;/title&gt;.  In Perl these are stored as [ 'Foo' ] and [ 'Foo', 'en' ].  For the former [ 'Foo', undef ] would also be okay. This handler also has two modifiers which may be added to the name after '/'.  <em>/e</em> means that empty text is allowed, and will be returned as the empty tuple [], to mean that the element is present but has no text.  When writing with <em>/e</em>, undef will also be understood as present-but-empty.  You cannot however specify a language if the text is empty. The modifier <em>/m</em> means that the text is allowed to span multiple lines. So for example <em>with-lang/em</em> is a handler for text with language, where the text may be empty and may contain newlines.  Note that the <em>with-lang-or-empty</em> of earlier releases has been replaced by <em>with-lang/e</em>.</p>
  </dd>

</dl>
<p>Now, which handlers are used for which subelements (keys) of channels and programmes?  And what is the multiplicity (should you expect a single value or a list of values)?</p><p>The following tables map subelements of &lt;channel&gt; and of &lt;programme&gt; to the handlers used to read and write them.  Many elements have their own handler with the same name, and most of the others use <em>with-lang</em>.  The third column specifies the multiplicity of the element: <strong>*</strong> (any number) will give a list of values in Perl, <strong>+</strong> (one or more) will give a nonempty list, <strong>?</strong> (maybe one) will give a scalar, and <strong>1</strong> (exactly one) will give a scalar which is not undef.</p><h3>Handlers for &lt;channel&gt;</h3>

<dl class='dl-vertical'>
  <dt>
    display-name, <em>with-lang</em>, <strong>+</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    icon, <em>icon</em>, <strong>*</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    url, <em>scalar</em>, <strong>*</strong>
  </dt>
  <dd>
    
  </dd>

</dl>

<h3>Handlers for &lt;programme&gt;</h3>

<dl class='dl-vertical'>
  <dt>
    title, <em>with-lang</em>, <strong>+</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    sub-title, <em>with-lang</em>, <strong>*</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    desc, <em>with-lang/m</em>, <strong>*</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    credits, <em>credits</em>, <strong>?</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    date, <em>scalar</em>, <strong>?</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    category, <em>with-lang</em>, <strong>*</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    language, <em>with-lang</em>, <strong>?</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    orig-language, <em>with-lang</em>, <strong>?</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    length, <em>length</em>, <strong>?</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    icon, <em>icon</em>, <strong>*</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    url, <em>scalar</em>, <strong>*</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    country, <em>with-lang</em>, <strong>*</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    episode-num, <em>episode-num</em>, <strong>*</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    video, <em>video</em>, <strong>?</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    audio, <em>audio</em>, <strong>?</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    previously-shown, <em>previously-shown</em>, <strong>?</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    premiere, <em>with-lang/em</em>, <strong>?</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    last-chance, <em>with-lang/em</em>, <strong>?</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    new, <em>presence</em>, <strong>?</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    subtitles, <em>subtitles</em>, <strong>*</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    rating, <em>rating</em>, <strong>*</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    star-rating, <em>star-rating</em>, <strong>*</strong>
  </dt>
  <dd>
    
  </dd>

</dl>
<p>At present, no parsing or validation on dates is done because dates may be partially specified in \s-1XMLTV\s0.  For example '2001' means that the year is known but not the month, day or time of day.  Maybe in the future dates will be automatically converted to and from <strong>Date::Manip</strong> objects.  For now they just use the <em>scalar</em> handler. Similar remarks apply to URLs.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">WRITING</h2>
        <div class="sectioncontent">
<p>When reading a file you have the choice of using \*(C`parse()\*(C' to gulp the whole file and return a data structure, or using \*(C`parse_callback()\*(C' to get the programmes one at a time, although channels and other data are still read all at once.</p><p>There is a similar choice when writing data: the \*(C`write_data()\*(C' routine prints a whole \s-1XMLTV\s0 document at once, but if you want to write an \s-1XMLTV\s0 document incrementally you can manually create an \*(C`XMLTV::Writer\*(C' object and call methods on it.  Synopsis:</p><p>  use XMLTV;   my $w = new XMLTV::Writer();   $w-&gt;comment("Hello from XML::Writer&apos;s comment() method");   $w-&gt;start({ &apos;generator-info-name&apos; =&gt; &apos;Example code in pod&apos; });   my %ch = (id =&gt; &apos;test-channel&apos;, &apos;display-name&apos; =&gt; [ [ &apos;Test&apos;, &apos;en&apos; ] ]);   $w-&gt;write_channel(&#92;%ch);   my %prog = (channel =&gt; &apos;test-channel&apos;, start =&gt; &apos;200203161500&apos;,               title =&gt; [ [ &apos;News&apos;, &apos;en&apos; ] ]);   $w-&gt;write_programme(&#92;%prog);   $w-&gt;end();</p><p>XMLTV::Writer inherits from XML::Writer, and provides the following extra or overridden methods:</p>
<dl class='dl-vertical'>
  <dt>
    <em>new()</em>, the constructor
  </dt>
  <dd>
    <p>Creates an XMLTV::Writer object and starts writing an \s-1XMLTV\s0 file, printing the \s-1DOCTYPE\s0 line.  Arguments are passed on to XML::Writer's constructor, except for the following: the 'encoding' key if present gives the \s-1XML\s0 character encoding. For example:   my $w = new XMLTV::Writer(encoding =&gt; &apos;ISO-8859-1&apos;); If encoding is not specified, XML::Writer's default is used (currently \s-1UTF-8\s0). XMLTW::Writer can also filter out specific days from the data. This is useful if the datasource provides data for periods of time that does not match the days that the user has asked for. The filtering is controlled with the days, offset and cutoff arguments:   my $w = new XMLTV::Writer(       offset =&gt; 1,       days =&gt; 2,       cutoff =&gt; "050000" ); In this example, XMLTV::Writer will discard all entries that do not have starttimes larger than or equal to 05:00 tomorrow and less than 05:00 two days after tomorrow. The time offset is stripped off the starttime before the comparison is made.</p>
  </dd>
  <dt>
    <em>start()</em>
  </dt>
  <dd>
    <p>Write the start of the &lt;tv&gt; element.  Parameter is a hashref which gives the attributes of this element.</p>
  </dd>
  <dt>
    <em>write_channels()</em>
  </dt>
  <dd>
    <p>Write several channels at once.  Parameter is a reference to a hash mapping channel id to channel details.  They will be written sorted by id, which is reasonable since the order of channels in an \s-1XMLTV\s0 file isn't significant.</p>
  </dd>
  <dt>
    <em>write_channel()</em>
  </dt>
  <dd>
    <p>Write a single channel.  You can call this routine if you want, but most of the time \*(C`write_channels()\*(C' is a better interface.</p>
  </dd>
  <dt>
    <em>write_programme()</em>
  </dt>
  <dd>
    <p>Write details for a single programme as \s-1XML\s0.</p>
  </dd>
  <dt>
    <em>end()</em>
  </dt>
  <dd>
    <p>Say you've finished writing programmes.  This ends the &lt;tv&gt; element and the file.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Ed Avis, ed@membled.com</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO XMLTV&hellip;</h2>
        <div class="sectioncontent">
<p>The file format is defined by the \s-1DTD\s0 xmltv.dtd, which is included in the xmltv package along with this module.  It should be installed in your system's standard place for \s-1SGML\s0 and \s-1XML\s0 DTDs.</p><p>The xmltv package has a web page at &lt;http://xmltv.org/&gt; which carries information about the file format and the various tools and apps which are distributed with this module.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="XML::XUpdate::LibXML.3pm.html"><span aria-hidden="true">&larr;</span> XML::XUpdate::LibXML.3pm: Simple implementation of xupdate format</a></li>
   <li class="next"><a href="XMLTV::Configure.3pm.html">XMLTV::Configure.3pm: Configuration file handling for xmltv grabbers <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

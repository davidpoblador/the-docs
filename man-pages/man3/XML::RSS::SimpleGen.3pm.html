<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>XML::RSS::SimpleGen: For writing rss files</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="For writing rss files">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="XML::RSS::SimpleGen (3pm) manual">
  <meta name="twitter:description" content="For writing rss files">
  <meta name="twitter:image" content="https://www.carta.tech/images/libxml-rss-simplegen-perl-XML::RSS::SimpleGen-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/XML::RSS::SimpleGen.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="XML::RSS::SimpleGen (3pm) manual" />
  <meta property="og:description" content="For writing rss files" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libxml-rss-simplegen-perl-XML::RSS::SimpleGen-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">XML::RSS::SimpleGen<small> (3pm)</small></h1>
        <p class="lead">For writing rss files</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/XML::RSS::SimpleGen.3pm.html">
      <span itemprop="name">XML::RSS::SimpleGen: For writing rss files</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libxml-rss-simplegen-perl/">
      <span itemprop="name">libxml-rss-simplegen-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/XML::RSS::SimpleGen.3pm.html">
      <span itemprop="name">XML::RSS::SimpleGen: For writing rss files</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  # A complete screen-scraper and RSS generator here:

  use strict;
  use XML::RSS::SimpleGen;
  my $url = q&lt;http://www.exile.ru/&gt;;

  rss_new( $url, "eXile", "Moscow-based Alternative Newspaper" );
  rss_language( &apos;en&apos; );
  rss_webmaster( &apos;xxxxx@yourdomain.com&apos; );
  rss_twice_daily();

  get_url( $url );

  while(
   m{&lt;h4&gt;&#92;s*&lt;a href=&apos;/(.*?)&apos;.*?&gt;(.*?)&lt;/a&gt;&#92;s*&lt;/h4&gt;&#92;s*&lt;p.*?&gt;(.*?)&lt;a href=&apos;/}sg
  ) {
    rss_item("$url$1", $2, $3);
  }

  die "No items in this content?! {{&#92;n$_&#92;n}}&#92;nAborting"
   unless rss_item_count();

  rss_save( &apos;exile.rss&apos;, 45 );
  exit;
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module is for writing \s-1RSS\s0 files, simply. It transparently handles all the unpleasant details of \s-1RSS\s0, like proper \s-1XML\s0 escaping, and also has a good number of Do-What-I-Mean features, like not changing the modtime on a written-out \s-1RSS\s0 file if the file content hasn't changed, and like automatically removing any \s-1HTML\s0 tags from content you might pass in.</p><p>This module isn't meant to have the full expressive power of \s-1RSS\s0; instead, it provides functions that are most commonly needed by RSS-writing programs.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INTERFACE</h2>
        <div class="sectioncontent">
<p>This module provides a bunch of functions for starting an \s-1RSS\s0 feed in memory, putting items into it, and saving it to disk (or printing it as a string, as in a \s-1CGI\s0). If you prefer an object-oriented interface (obviously more useful if you're composing several feeds at once), then you can use this module as a class whose methods are the same as the function names minus \*(L"rss_\*(R". Except for this detail of the naming, the functions and methods are the same, behave the same, and take the same arguments.</p><p>That is, this functional code:</p><p>  use XML::RSS::SimpleGen;   my $url = q&lt;http://www.exile.ru/&gt;;</p><p>  rss_new( $url, "eXile" );   rss_language( &apos;en&apos; );   get_url( $url );   ...</p><p>does the same work as this \s-1OO\s0 code:</p><p>  use XML::RSS::SimpleGen ();   my $url = q&lt;http://www.exile.ru/&gt;;   my $rss = XML::RSS::SimpleGen-&gt;new( $url, "eXile");   $rss-&gt;language( &apos;en&apos; );   $rss-&gt;get_url( $url );   ...</p><p>(Note that the function \*(C`get_url\*(C' doesn't have a leading \*(L"rss_\*(R", so its method name is the same as its function name.  It's the one exception.)</p><p>If this talk of objects puzzles you, see HTML::Tree::AboutObjects in the \*(C`HTML-Tree\*(C' dist, and/or see the chapter \*(L"User's View of Object-Oriented Modules\*(R" in my book <em>Perl & \s-1LWP\s0</em> (&lt;http://www.amazon.com/exec/obidos/ASIN/0596001789&gt;). (The book is also useful as an extended discussion of screen-scraping.)</p><p>Note: in the code below, I use the word \*(L"accessor\*(R" a lot, to refer to a function or method that you can call two possible ways: 1) like \*(C`foo(<strong>val)\*(C'</strong> to set the \*(L"foo\*(R" attribute to the value <em>val</em>, or 2) like \*(C`foo()\*(C' to return the value of the \*(L"foo\*(R" attribute.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FUNCTIONS</h2>
        <div class="sectioncontent">
<p>This function creates a new \s-1RSS\s0 feed in memory.  This should be the first \*(C`rss_<strong>whatever\*(C'</strong> function you call in your program.  If you call it again, it erases the current object (if any) and sets up a new one according to whatever parameters you pass. The parameters are the full \s-1URL\s0, the title, and the description of the site (or page) that you're providing an \s-1RSS\s0 feed of. The description is optional, but you should provide at least a \s-1URL\s0 and title. Examples:   rss_new( $url, "eXile", "Moscow-based Alternative Newspaper" );</p><p>  rss_new( &apos;http://www.mybazouki.com/news/&apos;, "Bazouki News!" ); (As a method, XML::RSS::SimpleGen-&gt;new simply returns a new \s-1RSS\s0 object.) This declares what language this \s-1RSS\s0 feed is in.  It must be an RFC3066-style language tags like \*(L"en\*(R", or \*(L"en-US\*(R", or \*(L"zh-TW\*(R". (See <em>I18N::LangTags::List</em> for a list.) If you don't set the feed's language, it defaults to \*(L"en\*(R", for generic English. If you call this function without a parameter, it returns the current value of the \s-1RSS\s0 feed's language.  For example:   print "I&apos;m making an RSS feed for ", rss_language(), "!&#92;n"; The same is true for all the functions that I label as \*(L"accessors\*(R". This sets the maximum number of items that this feed will show. The default value is 0, meaning that there is no maximum. If you set it to a positive number <em>N</em>, then the feed will show only the first <em>N</em> items that you declare with \*(C`rss_item\*(C'. (Or, if you set \*(C`rss_history_file\*(C', then the newest <em>N</em> items that you declare with \*(C`rss_item\*(C'.) If you set it to a negative number <em>-N</em>, then the feed will show only the last <em>N</em> items that you declare with \*(C`rss_item\*(C'. (Or, if you set \*(C`rss_history_file\*(C', then the oldest <em>N</em> items you declare with \*(C`rss_item\*(C', which is unlikely to be useful!) This declares what email address you, the \s-1RSS\s0 generator manager, can be reached at.  Example:   rss_webMaster( &apos;sburke@bazouki-news.int&apos; ); This declares that you want this \s-1RSS\s0 feed to keep track of what items are new, and to list them first when the \s-1RSS\s0 is emitted.  To do this, the \s-1RSS\s0 generator has to store information in a file, where it tracks its \*(L"history\*(R", i.e., when was the first time it saw given URLs, and the most recent time it saw given URLs. Typical usage is:   rss_history_file( &apos;thisrssfeed.dat&apos; ); You should call \*(C`rss_history_file\*(C' <em>before</em> you make any calls to \*(C`rss_item\*(C'. The history-file feature is meant for cases where your RSS-generator program calls \*(C`rss_item\*(C' on <em>every</em> link it sees, but only wants the <em>new</em> links to appear in the \s-1RSS\s0 output. (This can be a good approach if you're making an \s-1RSS\s0 feed of a page like \*(C`http://www.guardian.co.uk/\*(C' where there's some new links (to the recently added stories), but also links to some days-old stories, and <em>also</em> links to some always-there things like \*(L"Archive Search\*(R" and \*(L"Contact Us\*(R" pages. Once you call rss_history_file, the specified file is read in.  The in-memory history (stored in the \s-1RSS\s0 object) is updated as you call \*(C`rss_item\*(C'.  But the file isn't updated until you call rss_save. (A do-what-I-mean side effect of calling \*(C`rss_history_file\*(C' is that it sets rss_item_limit to 25 if it is currently 0.) (Incidentally, if you're using rss_history_file as part of a \s-1CGI\s0 that emits \s-1RSS\s0 data, instead of a program that just saves to an \s-1RSS\s0 file, then things will get complicated. You'll need to call an internal method to explicitly commit the history file to disk, and you'll need a semaphore file to avoid race conditions. Email me for full info.) This adds a new item to the current feed. You will need to specify the \s-1URL\s0 to add (and it should be a valid-looking \s-1URL\s0, starting with "<em>something:</em>", and not containing any spaces). You may also specify the title, but it's optional. And finally, you can optionally specify a description. (You can remember this because it starts with the essential item first, and progresses toward the most optional.) Leading and tailing whitespace is removed from whichever of <em>url,</em> title, and <em>description</em> are defined values, and \s-1HTML\s0 is parsed out. A simple usage:   rss_item(     "http://www.harpers.org/MostRecentWR.html",     "Harper&apos;s Magazine&apos;s Weekly Review"   ); Although in practice, a typical call won't have string constants, but will instead be like the example in the Synopsis sectios, namely:   rss_item("$url$1", $2, $3); Incidentally, as a do-what-I-mean feature, if the first parameter doesn't look like a \s-1URL\s0 but one of the others does, then this error is silently forgiven.  This is so you can occasionally slip up and forget the order of the parameters. (In the unlikely event where you <em>need</em> to avoid the HTML-removal features, you can do this by passing scalar-references instead of normal strings, like so: \*(C`rss_item($url, $title, &#92;$not_to_be_escaped)\*(C'.) This returns the number of items you've declared.  I anticipate that its main usage will be something like:   die "What, no objects found at $url ?!"    unless rss_item_count(); or, maybe...   exit unless rss_item_count(); ...depending on how/whether you'd want to react to cases where you don't see anything to put into an \s-1RSS\s0 feed. Note that the parens are optional, since this command takes no options (just like Perl's \*(C`time()\*(C' function). This declares that you want to declare a particular image as the logo for this feed.  Most feeds don't have such a thing, and most readers just ignore it anyway, but if you want to declare it, this function is how.  The three parameters, which are all required, are: the image's \s-1URL\s0, its height in pixels, and its width in pixels. According to various specs, the width should/must be between 1 and 144, an the height should/must be between 1 and 400. A typical usage:   rss_image("http://interglacial.com/rss/weebl.gif", 106, 140); Be careful not to mix up the height and width. This saves the \s-1RSS\s0 date to the file you specify.  If the \s-1RSS\s0 data hasn't changed, the file (and its modtime) aren't altered.  The optional <em>max_age_days</em> parameter means that if ever the file exists, and its content hasn't changed for that many days or longer, then the program should die with a warning message.  For example, in the case of a screen-scraper for a site that we know should (in theory) change its content at least weekly, we might save the \s-1RSS\s0 file with:   rss_save("whatever.rss", 17);    # Scream if the feed is unchanged for 17 days. The seventeen there is gotten by assuming that just maybe the site might skip two weeks for a vacation now and then, and might even put out the pre-vacation issue a few days early \*(-- but that if ever the program notices that the data hasn't changed for 17 days, then it should emit error messages.  If you want to disable this feature on a one-time basis, just change the modtime (like via \*(C`touch\*(C') on the <em>whatever.rss</em> file. If you don't specify a \*(C`max_age_days\*(C' value, then this whole complain-if-it's-old feature is disabled. This returns the RSS-XML data as a string.  This function is called internally by the rss_save function; but you might want to call it explicitly, as in a \s-1CGI\s0, where your \s-1CGI\s0 would probably end like this:   print "Content-type: application/xml&#92;n&#92;n", rss_as_string();   exit; This tries to get the content of the given url, and returns it. This is quite like LWP::Simple's \*(C`get\*(C' function, but with some additional features:</p><ul>
<li><p>If it can't get the \s-1URL\s0's content at first, it will sleep for a few seconds and try again, up to about five times. (This is to avoid the case of the \s-1URL\s0 being temporarily inaccessible simply because the \s-1DNS\s0 is a bit slow, or because the server is too busy.)</p></li><li><p>If it can't get the content, even after several retries, it will abort the program (like a \*(C`die\*(C').  If you want to override this behavior, then call it as \*(C`eval { get_url($url) };\*(C'</p></li><li><p>If you call the function in void context (i.e., not using its return value), then the function assigns the \s-1URL\s0's content to $_. That's so you can write nice concise code like this:            get_url $thatsite;            m/Top Stories Tonight/ or die "What, no top stories?";            while( m{&lt;a class="top" href="(.*?)"&gt;(.*?)&lt;/a&gt;}g ) {              rss_item("$thatsite/$1", $2);            }</p></li><li><p>This returns the content of the \s-1URL\s0 not exactly as-is, but after changing its newlines to native format.  That is, if the contents of the \s-1URL\s0 use CR-LF pairs to express newlines, then \*(C`get_url\*(C' changes these to \*(C`&#92;n\*(C''s before returning the content.  (Similarly for old MacOS newline format.)  Clearly this is wrong in you're dealing with binary data; in that case, use LWP::Simple's \*(C`get\*(C' directly.</p></li><li><p>Finally, as a resource-conversation measure, this function will also try to call \*(C`sleep\*(C' a few times if it sees several quick calls to itself coming from a program that seems to be running under crontab.  As most of my RSS-generators are crontabbed, I find it very useful that I can have however many \*(C`get_url\*(C''s in my crontabbed programs without worrying that they'll take even a noticeable part of the server's bandwidth.</p></li>
</ul><p>Calling one of these functions declares that this feed is usually generated at the same time(s) every day (or every week, in the case of \*(C`rss_weekly\*(C'). And, where it's not just once a day/week, these multiple times a day are evenly spaced.  These functions then set the feed's \*(C`updatePeriod\*(C', \*(C`updateBase\*(C', \*(C`updateFrequency\*(C', \*(C`skipHours\*(C', \*(C`skipDays\*(C', and \*(C`ttl\*(C' elements appropriately, so that \s-1RSS\s0 readers can know at at what times there could (or couldn't) be new content in this feed. In other words: use \*(C`rss_twice_daily\*(C' if this feed is updated at about the same time every day and then again 12 hours later.  Use \*(C`rss_thrice_daily\*(C' if this feed is updated at the same time daily, and then 8 hours later, and then 8 hours later.  And use \*(C`rss_every_other_hour\*(C' if the feed updates at about <em>n</em> minutes past every even numbered hour, or every odd-numbered hour. Clearly I mean these functions to be used in programs that are crontabbed to run at particular intervals, as with a crontab line like one of these:        52 * * * *         ~/thingy   # =&gt; rss_hourly        52 23 * * *        ~/thingy   # =&gt; rss_daily        52 4,16 * * *      ~/thingy   # =&gt; rss_twice_daily        52 5,13,21 * * *   ~/thingy   # =&gt; rss_thrice_daily        52 23 * * 3        ~/thingy   # =&gt; rss_weekly        52 */2 * * *       ~/thingy   # =&gt; rss_every_other_hour Clearly there aren't \*(C`rss_<strong>interval\*(C'</strong> functions for all the scheduling possibilities programs \*(-- if you have a program that has to run at 6am, 8am, 1pm, and 4pm, there's no function for that.  However, the above crontab lines (or with minor changes, like \*(C`1,9,17\*(C' instead of \*(C`5,13,21\*(C') are just fine for almost every \s-1RSS\s0 feed I've run. An aside: I recommend running the programs at about 52 minutes past the hour, generally in series, like so:        52 5,13,21 * * *   ~/thingy ; ~/dodad ; ~/makething ; ~/gizmo However, your mileage may vary. Incidentally, these functions take no arguments, so the parentheses are optional.  That is, these two lines do the same thing:        rss_hourly;        rss_hourly();</p><h3>\s-1MINOR\s0 \s-1FUNCTIONS\s0</h3>
<p>These are functions that you probably won't need often, or at all.  I include these for the sake of completeness, and so that advanced users might find them useful in some cases. This function directly sets the \*(C`skipHours\*(C' element's values to the specified \s-1GMT\s0 hour numbers. This function is a wrapper around \*(C`rss_skipHours\*(C' \*(-- you call \*(C`rss_updateHours\*(C' with a list of \s-1GMT\s0 hour numbers, and \*(C`rss_updateHours\*(C' will call \*(C`rss_skipHours(0 .. 23)\*(C' except <em>without</em> whatever hour numbers you specified. If you call with an empty list (i.e., \*(C`rss_updateHours();\*(C'), then we uses \*(C`gmtime\*(C' to find out the current hour (and rounds it up if it's after 50 minutes past), basically just as if you'd called:       rss_updateHours( (gmtime(600+time()))[2] ); This function directly sets the \*(C`skipDays\*(C' element's values to the specified weekdays.  Note that this accepts either integers (like 6 for Saturday, Sunday being either 0 or 7), or their exact English names. If you use the \*(C`skipDays\*(C' field, consider that it refers to days figured by \s-1GMT\s0, not local time.  For example, if I say to skip Saturdays, that means Saturdays \s-1GMT\s0, which in my timezone (Alaska) starts in the middle of Friday afternoon. This function is a wrapper around \*(C`rss_skipDays\*(C' \*(-- you call \*(C`rss_updateDays\*(C' with a list of \s-1GMT\s0 day names/numbers, and \*(C`rss_updateDays\*(C' will call \*(C`rss_skipDays(0 .. 6)\*(C' except <em>without</em> whatever days you specified. If you call with an empty list (i.e., \*(C`rss_updateDays();\*(C'), then we uses \*(C`gmtime\*(C' to find out the current day (\s-1GMT\s0!), basically just as if you'd called:       rss_updateDays( (gmtime(600+time()))[6] ); This function directly sets the \*(C`sy:updatePeriod\*(C' element's value to the period specified.  You must specify one of the strings: \*(L"yearly\*(R", \*(L"monthly\*(R", \*(L"weekly\*(R", \*(L"daily\*(R", \*(L"hourly\*(R". I advise using \*(L"weekly\*(R" only if you know what you're doing, and \*(L"yearly\*(R", \*(L"monthly\*(R" only if you <em>really</em> know what you're doing. This is a shortcut for \*(C`rss_updatePeriod(<strong>periodstring); rss_updateFrequency(</strong><strong>int)\*(C'</strong> This is a shortcut for \*(C`rss_updatePeriod(<strong>periodstring); rss_updateFrequency(</strong><strong>int);</strong> rss_updateBase(<strong>base)\*(C'</strong> This function directly sets the \*(C`sy:updateBase\*(C' element's value to the moment specified.  If you pass in an epoch time, it is converted to an \s-1ISO\s0 date string. This function directly sets the \*(C`sy:updateFrequency\*(C' element's value to the value specified.  The value has to be a nonzero positive integer. For example, this means that this feed updates at/by the start of every hour and 30 minutes past:   rss_updateBase(&apos;2000-01-01T00:00-00:00&apos;);   <strong>rss_updateFrequency</strong>(2);   rss_updatePeriod(&apos;hourly&apos;);  # 2*hourly means "twice an hour" Recall that this can also be done with the the \*(C`rss_updatePeriod( <strong>per, </strong><strong>freq, </strong><strong>base )\*(C'</strong> shortcut, like so:   rss_updateBase(&apos;hourly&apos;, 2, &apos;2000-01-01T00:00-00:00&apos;); If you are using an \*(C`rss_history_file(<strong>file)\*(C'</strong>, the history file will accrete a list of all URLs it has seen.  But to keep this file from potentially getting immense, items that haven't been seen for a while are thrown out. The period of time a feed's items go unseen before each is forgotten is called that feed's <strong>retention</strong>, and is expressed in seconds. The default retention value is 32 days (i.e., 32*24*60*60, the number of seconds in 32 days).  If you wanted to change it to just a week, you would do this with \*(C`rss_retention(7*24*60*60)\*(C'. As a special case, a zero or negative value for the retention means to never clear anything from the history file, no matter how long it has gone unseen. Call this function if you want to add extra \s-1XML\s0 comments to this \s-1RSS\s0 file. For example, if you call this:         rss_add_comment(           "Our terms of use: http://wherever.int/rsstou.html",           "Any questions? Ask jimmy@wherever.int",         ); ...then this \s-1RSS\s0 feed will contain this \s-1XML\s0 fairly early on in the file:         &lt;!-- Our terms of use: http://wherever.int/rsstou.html --&gt;         &lt;!-- Any questions? Ask jimmy@wherever.int --&gt; This defines the given \s-1URL\s0 as being the XML-CSS stylesheet for this \s-1RSS\s0 feed.  The default value is \*(L"./rss.css\*(R" if \*(C`-e "rss.css"\*(C' is true, otherwise is the value http://www.interglacial.com/rss/rss.css This defines the given \s-1URL\s0 as being the XML-XSL stylesheet for this \s-1RSS\s0 feed.  The default value is none. These define this feed's \s-1URL\s0, title, and description.  These functions are just for completeness, since it's simpler to just specify any/all of these parameters in the call to \*(C`rss_new\*(C'. This sets the parameter of this \s-1RSS\s0 feed's \*(C`ttl\*(C' element, which suggests how long (in minutes, not seconds!) an \s-1RSS\s0 reader should wait after it polls a feed until it polls it again.  For example, \*(C`rss_ttl(90)\*(C' would suggest that a reader should not poll this feed more often than every 90 minutes. (This element is somewhat obsolescent next to the newer and more informative \*(C`sy:update*\*(C' elements, but is included for backward compatibility.) This controls whether or not duplicate items are filtered out out the feed.  By default this is <em>on</em>.  Note that duplicates are detected only by their \s-1URL\s0, so if you call this:         rss_item(&apos;http://foo.int/donate&apos;, "Give!");         rss_item(&apos;http://foo.int/donate&apos;, "We need money!");         rss_save(&apos;begging.rss&apos;); ...then only the first will appear in the feed, since the second item has a \s-1URL\s0 that is already being saved in this feed.  (However, \*(C`rss_item_count\*(C' is still 2, because filtering out duplicates is something that only happens as the feed is saved.) This sets the value of the not-generally-useful \*(C`doc\*(C' \s-1RSS\s0 element. The default value is \*(L"./about_rss.html\*(R" if \*(C`-e "about_rss.html"\*(C' is true, otherwise \*(L"http://www.interglacial.com/rss/about.html\*(R". These are for manually setting the values of this feed's image element's subelements:   &lt;image&gt;               &lt;url&gt; (rss_image_url)         &lt;/url&gt;             &lt;width&gt; (rss_image_width)       &lt;/width&gt;            &lt;height&gt; (rss_image_height)      &lt;/height&gt;             &lt;title&gt; (rss_image_title)       &lt;/title&gt;              &lt;link&gt; (rss_image_link)        &lt;/link&gt;       &lt;description&gt; (rss_image_description) &lt;/description&gt;   &lt;/image&gt; You rarely need to call any of these \*(C`rss_image_<strong>whatever\*(C'</strong> functions \*(-- usually just calling \*(C`rss_image( <strong>url, h, w );\*(C'</strong> is enough.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RSS VERSION</h2>
        <div class="sectioncontent">
<p>\s-1RSS\s0 feeds emitted by this module are basically according to v0.92 \s-1RSS\s0, with a very few extensions from v2.0 \s-1RSS\s0.  They are not \s-1RDF\s0 files.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO XML::RSS::SimpleGen&hellip;</h2>
        <div class="sectioncontent">
<p>\s-1XML::RSS\s0</p><p>http://my.netscape.com/publish/formats/rss-0.91.dtd &lt;http://my.netscape.com/publish/formats/rss-0.91.dtd&gt;</p><p>&lt;http://blogs.law.harvard.edu/tech/rss&gt;</p><p>&lt;http://directory.google.com/Top/Reference/Libraries/Library_and_Information_Science/Technical_Services/Cataloguing/Metadata/RDF/Applications/RSS/Specifications/&gt;</p><p>&lt;http://feedvalidator.org/&gt;</p><p>You might also like my book <em>Perl and \s-1LWP\s0</em>, which discusses the many screen-scraping techniques that you would use for extracting data from \s-1HTML\s0 to make into \s-1RSS\s0 feeds:</p>
<dl class='dl-vertical'>
  <dt>
    &lt;http://www.oreilly.com/catalog/perllwp/&gt;
  </dt>
  <dd>
    
  </dd>
  <dt>
    &lt;http://www.amazon.com/exec/obidos/ASIN/0596001789/&gt;
  </dt>
  <dd>
    
  </dd>
  <dt>
    &lt;http://www.amazon.co.uk/exec/obidos/ASIN/0596001789/t&gt;
  </dt>
  <dd>
    
  </dd>
  <dt>
    &lt;http://interglacial.com/d/scrapers&gt; \*(-- examples of Perl programs that produce \s-1RSS\s0's (which are visible at &lt;http://interglacial.com/rss/&gt; )
  </dt>
  <dd>
    
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT AND DISCLAIMERS</h2>
        <div class="sectioncontent">
<p>Copyright (c) 2003,4 Sean M. Burke.  All rights reserved.</p><p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p><p>This program is distributed in the hope that it will be useful, but without any warranty; without even the implied warranty of merchantability or fitness for a particular purpose.</p><p>Portions of the data tables in this module are derived from the entity declarations in the W3C \s-1XHTML\s0 specification.</p><p>Currently (January 2004), that's these three:</p><p>       http://www.w3.org/TR/xhtml1/DTD/xhtml-lat1.ent        http://www.w3.org/TR/xhtml1/DTD/xhtml-special.ent        http://www.w3.org/TR/xhtml1/DTD/xhtml-symbol.ent</p><p>Portions of the code in this module were adapted from parts of Gisle Aas's LWP::Simple and the old (v2.x) version of his HTML::Parser.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Sean M. Burke \*(C`sburke@cpan.org\*(C'</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="XML::RSS::Headline::UsePerlJournals.3pm.html"><span aria-hidden="true">&larr;</span> XML::RSS::Headline::UsePerlJournals.3pm: Xml::rss::headline example subclass</a></li>
   <li class="next"><a href="XML::RSSLite.3pm.html">XML::RSSLite.3pm: Lightweight, "relaxed" rss (and xml-ish) parser <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

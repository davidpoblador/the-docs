<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>libhavege: Haveged rng</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Haveged rng">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="libhavege (3) manual">
  <meta name="twitter:description" content="Haveged rng">
  <meta name="twitter:image" content="https://www.carta.tech/images/libhavege-dev-libhavege-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/libhavege.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="libhavege (3) manual" />
  <meta property="og:description" content="Haveged rng" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libhavege-dev-libhavege-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">libhavege<small> (3)</small></h1>
        <p class="lead">Haveged rng</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/libhavege.3.html">
      <span itemprop="name">libhavege: Haveged rng</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libhavege-dev/">
      <span itemprop="name">libhavege-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/libhavege.3.html">
      <span itemprop="name">libhavege: Haveged rng</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
#include &lt;haveged/havege.h&gt;
H_PARAMS params = {0};
h_status status;
char     status_buf[512];

if (NULL==havege_version(HAVEGE_PREP_VERSION)) <strong>exit</strong>(1);
H_PTR handle = havege_create(&params);
havege_status(handle, &status);
havege_run(handle);
rc = havege_rng(handle, handle-&gt;io_buf, handle-&gt;i_readSz/sizeof(H_UINT));
havege_status_dump(handle, H_SD_TOPIC_BUILD, status_buf, sizeof(status_buf));
havege_destroy(handle);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The libhavege library provides the haveged random number generator and it's associated tuning and testing facilities in a development sub-package. All haveged conditional build features are preserved and all haveged options not directly related to it's daemon or file system interfaces are available. This means that the same haveged tuning and testing components are present in the library with the equivalent controls provided by the haveged command line.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">API METHODS</h2>
        <div class="sectioncontent">
<p>The libhavege library uses the opaque handle technique to manage it's required resources. Errors are returned in the "error" member of the handle. The havege_destroy() method should be called to dispose of any resources claimed by havege_create().</p><p><strong>H_PTR havege_create(H_PARAMS </strong><em>*params</em><strong>);</strong></p><p>Create an anchor. Most members of the H_PARAMS input to this call correspond closely to haveged command line options (see <a href="../man8/haveged.8.html"><strong>haveged</strong>(8)</a></strong> for details). The caller should check for a non-null return value with a error value of H_NOERR. Any non-null return should be disposed of by a call to havege_destroy() to free any resources. Possible error values: H_NOERR, H_NOTESTSPEC, H_NOBUF, H_NOTESTMEM, H_NOINIT</p><p><strong>void havege_destroy(H_PTR </strong><em>hptr</em><strong>);</strong></p><p>Free all allocated anchor resources. If the multi-core option is used, this method should be called from a signal handler to prevent zombie processes. If called by the process that called haveged_create(), hptr will be freed when all child processes (if any) have terminated. If called by a child process, H_EXIT will be set and all children awakened to exit.</p><p><strong>int havege_rng(H_PTR </strong><em>hptr</em><strong>, H_UINT </strong><em>*buf</em><strong>, H_UINT </strong><em>sz</em><strong>);</strong></p><p>Read random bytes from an active anchor. The RNG must have been previously readied by a call to havege_run(). The read must take place within the allocated buffer, hptr-&gt;io_buf. The range specified is the number of H_UINT to read. If the multi-core option is used, this buffer is memory mapped between collectors. Possible error values: H_NOERR, H_NOTESRUN, H_NOPOST, H_NODONE, H_NORQST, H_NOCOMP, H_EXIT</p><p><strong>int havege_run(H_PTR </strong><em>hptr</em><strong>);</strong></p><p>Warm up the RNG and run the start-up tests. The operation succeeded if the error member of the handle is H_NOERR. A failed handle should be disposed of by a call to havege_destroy(). Possible error values: H_NOERR, H_NOCOLLECT, H_NOWALK, H_NOTESTMEM, H_NOTASK, H_NOTESTTOT, H_NOWAIT, H_NOTIMER, and any havege_rng() error.</p><p><strong>void havege_status(H_PTR </strong><em>hptr</em><strong>, H_STATUS </strong><em>hsts</em><strong>);</strong></p><p>Fills in the h_status structure with read-only information collected from the package build, run-time tuning, and test components.</p><p><strong>int havege_status_dump(H_PTR </strong><em>hptr</em><strong>, H_SD_TOPIC </strong><em>topic</em><strong>, char </strong><em>*buf</em><strong>, size_t </strong><em>len</em><strong>);</strong></p><p>Calls havege_status() and formats standard presentations of havege status in the supplied buffer. The standard formats are:</p><p>H_SD_TOPIC_BUILD</p><p>ver: %s; arch: %s; vend: %s; build: (%s); collect: %dK</p><p>H_SD_TOPIC_TUNE</p><p>cpu: (%s); data: %dK (%s); inst: %dK (%s); idx: %d/%d; sz: %d/%d</p><p>H_SD_TOPIC_TEST</p><p>[tot tests(%s): A:%d/%d B: %d/%d;][continuous tests(%s): A:%d/%d B: %d/%d;][last entropy estimate %g]</p><p>H_SD_TOPIC_SUM</p><p>fills: %d, generated: %.4g %c bytes</p><p><strong>const char *havege_version(const char *</strong><em>version</em><strong>);</strong></p><p>Return/check library prep version. The prep version is the package version used to build the library. A null argument returns the prep version unconditionally. Using the definition of the prep string in havege.h as input returns the prep version if the header file is compatible with the library, or NULL if it is not. Intended to be called before attempting any initialization.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTES</h2>
        <div class="sectioncontent">
<p>The sizes of the processor level 1 instruction and data caches are used to tune the HAVEGE algorithm for maximum sensitivity. If these sizes not specified, haveged will attempt to determine the sizes dynamically from the Linux sysfs and/or cpuid instruction with a fallback to a compiled default if no better information is not available.</p><p>The haveged RNG includes a run time test facility based upon the test suite defined in the AIS-31 specification from the The German Federal Office for Information Security (Bundesamt f√ºr Sicherheit in der Informationstechnik). The test suite consists of 11 statistical tests packaged into two test suites ("A" and "B"). The tests can be run at initialization (a.k.a. a "tot" test), or continuously to monitor all output. Failure of a suite will abort operation unless the behavior is explicitly waived in the test setup options.</p><p>Procedure A contains 6 test procedures designed to ensure statistically inconspicuous behavior. The first test, "test0", checks the disjointedness of 65k six-bit strings. The remainder of the procedure consists of 257 repetitions of the FIPS140-1 tests, "test1" through "test4", and an auto-correlation test, "test5". The fixed size of the Procedure A input makes it ideal for continuous use, but the procedure is slow and resource intensive. In particular, test5 is several orders of magnitude slower than any other individual AIS test. As an alternative for those who cannot tolerate this load, procedure A variants A&lt;n&gt; are provided that execute all included tests but execute test5 only every 2^n repetitions. Even with this accommodation, procedure A is much slower than procedure B.</p><p>Procedure B contains 5 tests, "test6a", "test6b', "test7a", "test7b", and "test8". The first 4 tests verify the expected frequencies for samples 100,000 one-step, two-step, three-step, and four-step bit transitions. The last test provides an empirical entropy estimate of the input. The input required to complete these tests is variable, resulting in an ever-shifting bit alignment that guards against buffering artifacts.</p><p>Each test procedure requires more than 1MB of data. Test input is managed by a bit index into the collection buffer. An independent index manages where integer output is taken from the same buffer. A buffer fill is triggered when the output index indicates all data has been extracted from the buffer. Online testing takes place after the buffer has been refilled but before the output index update allows output to resume. If any online test fails while processing the buffer, the buffer will be refilled and reprocessed until any retry is complete and the buffer contains no failed online tests or the online test procedure has failed and the RNG is considered broken.</p><p>It is recommend to run both AIS test procedures at start-up to ensure the  RNG is properly initialized. If resources are in short supply, omitting procedure A will save memory and time, with little risk in circumstances where output is mixed with other sources in /dev/random or other csprng. Continuous testing is also recommended where the throughput penalty is acceptable. One recent assessment of testing throughput costs is shown below.</p>
<dl class='dl-vertical'>
  <dt>
    <p>haveged -n0 -oc | pv &gt; /dev/null</p>
  </dt>
  <dd>
    <p>400MiB/s</p>
  </dd>
  <dt>
    <p>haveged -n0 -ocb | pv &gt; /dev/null</p>
  </dt>
  <dd>
    <p>70MiB/s</p>
  </dd>
  <dt>
    <p>haveged -n0 -oca8b | pv &gt; /dev/null</p>
  </dt>
  <dd>
    <p>13MiB/s</p>
  </dd>
  <dt>
    <p>haveged -n0 -oca8 | pv &gt; /dev/null</p>
  </dt>
  <dd>
    <p>8MiB/s</p>
  </dd>
  <dt>
    <p>haveged -n0 -oca | pv &gt; /dev/null</p>
  </dt>
  <dd>
    <p>100kiB/s</p>
  </dd>

</dl>
<p>Continuous testing also exposes another possible pitfall. Even an ideal RNG has a 10e-4 chance of failing either test procedure. The strict retry policy of AIS-31 is designed to guarantee an ideal RNG will "almost never" fail a test procedure. A single retry is mandated only to recover from a previous attempt that experienced a single individual test failure. The haveged implementation logs all retries and terminates on test procedure failures unless the procedure has been flagged as advisory by the "w" argument (see --onlinetest in <a href="../man8/haveged.8.html"><strong>haveged</strong>(8)</a></strong> ). Little evidence of the retry mechanism is seen unless large data sets are processed. Procedure A is too slow to be practical in these situations, so procedure B has been the best studied. Retries are observed at the approximate rate of 0.7-0.8 failures/GB, mostly in the test7 multi-step transition checks.</p><p>The probability that procedureB will fail two times in a row (in which case the program will be terminated unless w option was specified) is 4e-7 which is expected to happen at an approximate rate of once per 3,000 TB. When producing large amounts of data in order of TBs it's recommended to use -w option to make sure that program will not prematurely terminate because of a failed retry and carefully examine the stderr output for any problems.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILES</h2>
        <div class="sectioncontent">
<p>Tuning information may be extracted from the following virtual file paths if tuning is required and the path exists.</p><p><em>/proc/cpuinfo</em></p><p><em>/proc/self/status</em></p><p><em>/sys/devices/system/cpu/online</em></p><p><em>/sys/devices/system/cpu/cpu%d/cache/index%d/level</em></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DIAGNOSTICS</h2>
        <div class="sectioncontent">
<p>To enable diagnostic output, supply a msg_out callback when creating the handle. All possible errors are enumerated in havege.h and reproduced here for reference.</p><p><strong>01 H_NOHANDLE</strong></p><p>No memory for handle</p><p><strong>02 H_NOBUF</strong></p><p>Output buffer allocation failed</p><p><strong>03 H_NOINIT</strong></p><p>Semaphore init failed</p><p><strong>04 H_NOCOLLECT</strong></p><p>Collector allocation failed</p><p><strong>05 H_NOWALK</strong></p><p>Walk buffer allocation failed</p><p><strong>06 H_NOTESTSPEC</strong></p><p>Invalid test specification</p><p><strong>07 H_NOTESTINIT</strong></p><p>Test setup failed</p><p><strong>08 H_NOTESTMEM</strong></p><p>Unable to allocate test memory</p><p><strong>09 H_NOTESTTOT</strong></p><p>Power on (i.e. 'tot') test failed</p><p><strong>10 H_NOTESTRUN</strong></p><p>Continuous test failed</p><p><strong>11 H_NOCORES</strong></p><p>Too many cores specified</p><p><strong>12 H_NOTASK</strong></p><p>Unable to create child task</p><p><strong>13 H_NOWAIT</strong></p><p>sem_wait failed</p><p><strong>14 H_NOPOST</strong></p><p>sem_post failed</p><p><strong>15 H_NODONE</strong></p><p>sem_post done failed</p><p><strong>16 H_NORQST</strong></p><p>sem_post request failed</p><p><strong>17 H_NOCOMP</strong></p><p>wait for completion failed</p><p><strong>18 H_EXIT</strong></p><p>Exit signal</p><p><strong>19 H_NOTIMER</strong></p><p>Timer failed</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLE</h2>
        <div class="sectioncontent">
<p>The following minimal program writes the contents of 16 collection buffers of random data to stdout with continuous testing.</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;haveged/havege.h&gt;
int main(void)
{
H_PTR havege_state;
H_PARAMS havege_parameters = {0};
int i, rc;

if (NULL==havege_version(HAVEGE_PREP_VERSION)) {
  fprintf(stderr, "Incompatible library %s&#92;n", havege_version(NULL));
  return 1;
  }
havege_parameters.testSpec="ta8bcb";
havege_state = havege_create(&havege_parameters);
rc = havege_state==NULL? H_NOHANDLE : havege_state-&gt;error;
if (H_NOERR==rc) {
  if (0==havege_run(havege_state)) {
    H_UINT *buf = havege_state-&gt;io_buf;
    int size = havege_state-&gt;i_readSz /sizeof(H_UINT);
    char info[256];

    for(i=0;i&lt;16;i++) {
        rc = havege_rng(havege_state, buf, size);
        if (rc != size) {
            fprintf(stderr, "RNG read failed %d&#92;n", havege_state-&gt;error);
            break;
            }
        rc = fwrite(buf, 1, size*sizeof(H_UINT), stdout);
        if ( rc &lt; size ) {
            fprintf(stderr, "Write failed&#92;n");
            break;
            }
        }
    i = havege_status_dump(havege_state, H_SD_TOPIC_TEST, info, sizeof(info));
    info[i++] = '&#92;n';
    havege_status_dump(havege_state, H_SD_TOPIC_SUM, info+i, sizeof(info)-i);
    fprintf(stderr, "%s&#92;n", info);
    }
  else fprintf(stderr, "Initialize failed %d&#92;n", havege_state-&gt;error);
  havege_destroy(havege_state);
  }
else fprintf(stderr, "Create failed %d&#92;n", rc);
return rc;
}
</pre>
<p>Defaults are provided for all inputs to havege_create() as documented in havege.h. In this case for example, (16*4kb=65kb) will be written to stdout because the default size for i_readsz in 4kb.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO libhavege&hellip;</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><a href="../man8/haveged.8.html"><strong>haveged</strong>(8)</a></strong></p>
  </dt>
  <dd>
    
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REFERENCES</h2>
        <div class="sectioncontent">
<p><a href="../man8/haveged.8.html"><strong>haveged</strong>(8)</a></strong> references provides a basic reading list. The following links are suggested as sources for further exploration.</p>
<dl class='dl-vertical'>
  <dt>
    <p>The origins of the HAVEGE concept can be found at:</p>
  </dt>
  <dd>
    <p>http://www.irisa.fr/caps/projects/hipsor/</p>
  </dd>
  <dt>
    <p>Tuning concepts inspired by (the complexity) at:</p>
  </dt>
  <dd>
    <p>http://www.open-mpi.org/projects/hwloc/</p>
  </dd>
  <dt>
    <p>Reference documentation for the AIS-31 test suite can be found at:</p>
  </dt>
  <dd>
    <p>https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Zertifizierung/Interpretationen/AIS_31_Functionality_classes_for_random_number_generators_e.pdf?__blob=publicationFile</p>
  </dd>
  <dt>
    <p>Implementation and design information available at:</p>
  </dt>
  <dd>
    <p>http://www.issihosts.com/haveged/</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p>Gary Wuertz &lt;gary@issiweb.com&gt; and Jirka Hladky &lt;hladky jiri AT gmail DOT com&gt;</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="libguestlib.3.html"><span aria-hidden="true">&larr;</span> libguestlib.3: Vmware shared library</a></li>
   <li class="next"><a href="libhersheyfont.3.html">libhersheyfont.3: Hershey vector fonts library <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

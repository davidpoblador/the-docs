<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SoFieldContainer: The sofieldcontainer class is a base class for all classes that contain fields.  the classes containing fields in coin are the node and engine classes, so they are all subclasses of sofieldcontainer.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The sofieldcontainer class is a base class for all classes that contain fields.  the classes containing fields in coin are the node and engine classes, so they are all subclasses of sofieldcontainer.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="SoFieldContainer (3) manual">
  <meta name="twitter:description" content="The sofieldcontainer class is a base class for all classes that contain fields.  the classes containing fields in coin are the node and engine classes, so they are all subclasses of sofieldcontainer.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcoin80-doc-SoFieldContainer-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/SoFieldContainer.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="SoFieldContainer (3) manual" />
  <meta property="og:description" content="The sofieldcontainer class is a base class for all classes that contain fields.  the classes containing fields in coin are the node and engine classes, so they are all subclasses of sofieldcontainer." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcoin80-doc-SoFieldContainer-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">SoFieldContainer<small> (3)</small></h1>
        <p class="lead">The sofieldcontainer class is a base class for all classes that contain fields.  the classes containing fields in coin are the node and engine classes, so they are all subclasses of sofieldcontainer.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoFieldContainer.3.html">
      <span itemprop="name">SoFieldContainer: The sofieldcontainer class is a base class for all classes that contain fields.  the classes containing fields in coin are the node and engine classes, so they are all subclasses of sofieldcontainer.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcoin80-doc/">
      <span itemprop="name">libcoin80-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoFieldContainer.3.html">
      <span itemprop="name">SoFieldContainer: The sofieldcontainer class is a base class for all classes that contain fields.  the classes containing fields in coin are the node and engine classes, so they are all subclasses of sofieldcontainer.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;Inventor/fields/SoFieldContainer.h&gt;</p><p>Inherits <strong>SoBase</strong>.</p><p>Inherited by <strong>SoEngine</strong>, and <strong>SoNode</strong>.</p><h3>Public Member Functions</h3>
<p>void <strong>setToDefaults</strong> (void)</p><p>SbBool <strong>hasDefaultValues</strong> (void) const </p><p>SbBool <strong>fieldsAreEqual</strong> (const <strong>SoFieldContainer</strong> *container) const </p><p>void <strong>copyFieldValues</strong> (const <strong>SoFieldContainer</strong> *container, SbBool copyconnections=FALSE)</p><p>SbBool <strong>set</strong> (const char *const fielddata)</p><p>void <strong>get</strong> (<strong>SbString</strong> &fielddata)</p><p>virtual int <strong>getFields</strong> (<strong>SoFieldList</strong> &l) const </p><p>virtual int <strong>getAllFields</strong> (<strong>SoFieldList</strong> &l) const </p><p>virtual <strong>SoField</strong> * <strong>getField</strong> (const <strong>SbName</strong> &name) const </p><p>virtual <strong>SoField</strong> * <strong>getEventIn</strong> (const <strong>SbName</strong> &name) const </p><p>virtual <strong>SoField</strong> * <strong>getEventOut</strong> (const <strong>SbName</strong> &name) const </p><p>SbBool <strong>getFieldName</strong> (const <strong>SoField</strong> *const field, <strong>SbName</strong> &name) const </p><p>SbBool <strong>enableNotify</strong> (const SbBool flag)</p><p>SbBool <strong>isNotifyEnabled</strong> (void) const </p><p>SbBool <strong>set</strong> (const char *fielddata, <strong>SoInput</strong> *input)</p><p>void <strong>get</strong> (<strong>SbString</strong> &fielddata, <strong>SoOutput</strong> *out)</p><p>virtual void <strong>notify</strong> (<strong>SoNotList</strong> *l)</p><p>virtual SbBool <strong>validateNewFieldValue</strong> (<strong>SoField</strong> *field, void *newval)</p><p>virtual void <strong>addWriteReference</strong> (<strong>SoOutput</strong> *out, SbBool isfromfield=FALSE)</p><p>virtual void <strong>writeInstance</strong> (<strong>SoOutput</strong> *out)</p><p>SbBool <strong>getIsBuiltIn</strong> (void) const </p><p>virtual const <strong>SoFieldData</strong> * <strong>getFieldData</strong> (void) const </p><p>virtual void <strong>copyContents</strong> (const <strong>SoFieldContainer</strong> *from, SbBool copyconnections)</p><p>virtual <strong>SoFieldContainer</strong> * <strong>copyThroughConnection</strong> (void) const </p><p>virtual void <strong>getFieldsMemorySize</strong> (size_t &managed, size_t &unmanaged) const </p><p>void <strong>setUserData</strong> (void *userdata) const </p><p>void * <strong>getUserData</strong> (void) const </p>
<h3>Static Public Member Functions</h3>
<p>static void <strong>initClass</strong> (void)</p><p>static <strong>SoType</strong> <strong>getClassTypeId</strong> (void)</p><p>static void <strong>cleanupClass</strong> (void)</p><p>static void <strong>initCopyDict</strong> (void)</p><p>static void <strong>addCopy</strong> (const <strong>SoFieldContainer</strong> *orig, const <strong>SoFieldContainer</strong> *copy)</p><p>static <strong>SoFieldContainer</strong> * <strong>checkCopy</strong> (const <strong>SoFieldContainer</strong> *orig)</p><p>static <strong>SoFieldContainer</strong> * <strong>findCopy</strong> (const <strong>SoFieldContainer</strong> *orig, const SbBool copyconnections)</p><p>static void <strong>copyDone</strong> (void)</p>
<h3>Protected Member Functions</h3>
<p><strong>SoFieldContainer</strong> (void)</p><p>virtual <strong>~SoFieldContainer</strong> ()</p><p>virtual SbBool <strong>readInstance</strong> (<strong>SoInput</strong> *in, unsigned short flags)</p>
<h3>Protected Attributes</h3>
<p>SbBool <strong>isBuiltIn</strong></p>
<h3>Additional Inherited Members</h3>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>The <strong>SoFieldContainer</strong> class is a base class for all classes that contain fields.</p><p>The classes containing fields in Coin are the node and engine classes, so they are all subclasses of <strong>SoFieldContainer</strong>.</p><p><strong>SoFieldContainer</strong> provides methods for reading, writing, comparing for equality, doing copy operations, etc on fields.</p><p><strong>See also:</strong></p><p><strong>SoField</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>SoFieldContainer::SoFieldContainer (void)\fC [protected]\fP</h3>
<p>Constructor.</p>
<h3>SoFieldContainer::~SoFieldContainer ()\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Destructor.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>void SoFieldContainer::setToDefaults (void)</h3>
<p>This method sets all fields which we are parenting to their respective default values.</p>
<h3>SbBool SoFieldContainer::hasDefaultValues (void) const</h3>
<p>This method checks to see if the fields of this container have their default values, and returns TRUE if that is the case.</p>
<h3>SbBool SoFieldContainer::fieldsAreEqual (const \fBSoFieldContainer\fP *container) const</h3>
<p>This method returns TRUE if the values of the fields of this and <em>container</em> are equal.</p>
<h3>void SoFieldContainer::copyFieldValues (const \fBSoFieldContainer\fP *container, SbBoolcopyconnections = \fCFALSE\fP)</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p><p>This method copies the field values from container into this. The fields are assumed to be of the same type. The <em>copyconnections</em> flag decides whether the field connections are to be copied aswell.</p>
<h3>SbBool SoFieldContainer::set (const char *constfielddata)</h3>
<p>This method parses the values of one or more fields from the <em>fielddata</em> string.</p><p>The fields must be in the same format as the Open Inventor file format. TRUE is returned upon success, and FALSE otherwise.</p><p><strong>See also:</strong></p><p><strong>get()</strong></p>
<h3>void SoFieldContainer::get (\fBSbString\fP &fielddata)</h3>
<p>This methods stores the field data in the given <em>fielddata</em> string. The format of the returned string follows the Open Inventor file format.</p><p><strong>See also:</strong></p><p><strong>set()</strong></p>
<h3>int SoFieldContainer::getFields (\fBSoFieldList\fP &fields) const\fC [virtual]\fP</h3>
<p>This method adds the fields in this container to the <em>l</em> argument, and returns the number of fields added.</p><p>The virtual nature of this function means that it can be overridden to e.g. hide private fields.</p>
<h3>int SoFieldContainer::getAllFields (\fBSoFieldList\fP &fields) const\fC [virtual]\fP</h3>
<p>Returns VRML eventIn and eventOut fields in addition to the 'ordinary' fields.</p><p><strong>See also:</strong></p><p><strong>getFields()</strong></p>
<h3>\fBSoField\fP * SoFieldContainer::getField (const \fBSbName\fP &name) const\fC [virtual]\fP</h3>
<p>This method returns a pointer to the field with <em>name</em>, or NULL<em> if no such field exists.</em></p>
<h3>\fBSoField\fP * SoFieldContainer::getEventIn (const \fBSbName\fP &name) const\fC [virtual]\fP</h3>
<p>This method returns a pointer to the eventIn with name <em>name</em>, or NULL<em> if no such eventIn exists.</em></p>
<h3>\fBSoField\fP * SoFieldContainer::getEventOut (const \fBSbName\fP &name) const\fC [virtual]\fP</h3>
<p>This method returns a pointer to the eventOut with name <em>name</em>, or NULL<em> if no such eventOut exists.</em></p>
<h3>SbBool SoFieldContainer::getFieldName (const \fBSoField\fP *constfield, \fBSbName\fP &name) const</h3>
<p>Finds the name of the given <em>field</em> and returns the value in the <em>name</em> argument.</p><p>TRUE is returned if the field is contained within this instance, and FALSE otherwise.</p>
<h3>SbBool SoFieldContainer::enableNotify (const SbBoolenable)</h3>
<p>This method sets whether notification will be propagated on changing the values of the contained fields. The old value of the flag is returned.</p><p>Notification is default <em>on</em>. Turning off automatic notification can be useful for optimizing performance. During series of updates you may want to avoid the propagation of notifications upon every field value change if you make a lot of them. This is how you should handle those cases:</p>
<pre>
SbBool autonotify = node-&gt;enableNotify(FALSE);
// ...
// Make modifications to fields of "node" here.
// ...
node-&gt;enableNotify(autonotify);
node-&gt;touch();
</pre>
<p><strong>See also:</strong></p><p><strong>isNotifyEnabled()</strong></p>
<h3>SbBool SoFieldContainer::isNotifyEnabled (void) const</h3>
<p>This method returns whether notification of changes to the field values in the container is propagated to its auditors.</p><p><strong>See also:</strong></p><p><strong>enableNotify()</strong></p>
<h3>SbBool SoFieldContainer::set (const char *fielddata, \fBSoInput\fP *in)</h3>
<p>This method parses the values of one or more fields from the <em>fielddata</em> string.</p><p>The fields must be in the same format as the Open Inventor file format. TRUE is returned upon success, and FALSE otherwise.</p><p>We use the reference dictionary provided by <em>in</em>.</p><p><strong>See also:</strong></p><p><strong>get()</strong></p>
<h3>void SoFieldContainer::get (\fBSbString\fP &fielddata, \fBSoOutput\fP *out)</h3>
<p>Put names and values of fields from this instance in the <em>fielddata</em> string. Fields will be separated in the returned string by end-of-line characters.</p><p>We use the reference dictionary provided by <em>out</em>.</p><p><strong>See also:</strong></p><p><strong>set()</strong></p>
<h3>void SoFieldContainer::notify (\fBSoNotList\fP *l)\fC [virtual]\fP</h3>
<p>Notifies all auditors for this instance when changes are made.</p><p>Reimplemented from <strong>SoBase</strong>.</p><p>Reimplemented in <strong>SoNode</strong>, <strong>SoSceneTexture2</strong>, <strong>SoVRMLSwitch</strong>, <strong>SoVRMLLOD</strong>, <strong>SoProfilerStats</strong>, <strong>SoSceneTextureCubeMap</strong>, <strong>SoTextureCubeMap</strong>, <strong>SoText3</strong>, <strong>SoTexture2</strong>, <strong>SoImage</strong>, <strong>SoTexture3</strong>, <strong>SoVRMLGroup</strong>, <strong>SoVertexProperty</strong>, <strong>SoVRMLParent</strong>, <strong>SoVRMLTransform</strong>, <strong>SoVRMLVertexShape</strong>, <strong>SoShadowGroup</strong>, <strong>SoVRMLElevationGrid</strong>, <strong>SoAsciiText</strong>, <strong>SoVRMLShape</strong>, <strong>SoSeparator</strong>, <strong>SoVRMLScript</strong>, <strong>SoBumpMap</strong>, <strong>SoVRMLProximitySensor</strong>, <strong>SoVRMLExtrusion</strong>, <strong>SoSwitch</strong>, <strong>SoVRMLBillboard</strong>, <strong>SoVRMLText</strong>, <strong>SoLOD</strong>, <strong>SoMaterial</strong>, <strong>SoShape</strong>, <strong>SoVertexAttribute</strong>, <strong>SoVRMLTouchSensor</strong>, <strong>SoLevelOfDetail</strong>, <strong>SoVRMLAppearance</strong>, <strong>SoVRMLIndexedLine</strong>, <strong>SoVRMLPixelTexture</strong>, <strong>SoEngine</strong>, <strong>SoVRMLIndexedLineSet</strong>, <strong>SoBlinker</strong>, <strong>SoIndexedLineSet</strong>, <strong>SoPackedColor</strong>, <strong>SoVertexShape</strong>, <strong>SoVRMLCollision</strong>, <strong>SoVRMLTimeSensor</strong>, <strong>SoVRMLVertexPoint</strong>, <strong>SoVRMLGeometry</strong>, <strong>SoVRMLVertexLine</strong>, <strong>SoNodeEngine</strong>, <strong>SoVRMLIndexedShape</strong>, and <strong>SoIndexedPointSet</strong>.</p>
<h3>SbBool SoFieldContainer::validateNewFieldValue (\fBSoField\fP *field, void *newval)\fC [virtual]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em> I can't make head or tails of this method, it seems to return TRUE no matter what the arguments are.</p>
<h3>void SoFieldContainer::addWriteReference (\fBSoOutput\fP *out, SbBoolisfromfield = \fCFALSE\fP)\fC [virtual]\fP</h3>
<p>This method is used during the first write pass of a write action to count the number of references to this object in the scene graph.</p><p>Reimplemented from <strong>SoBase</strong>.</p><p>Reimplemented in <strong>SoBaseKit</strong>.</p>
<h3>void SoFieldContainer::writeInstance (\fBSoOutput\fP *out)\fC [virtual]\fP</h3>
<p>Writes all the fields contained in this instance to the output stream within <em>out</em>.</p><p>This method is solely called from the write methods of fields.</p><p>Either from <strong>SoField</strong> if the write is done because of a field-to-field connection, or from one of the fields which may actually write <strong>SoFieldContainer</strong> instances, i.e. <strong>SoSFNode</strong>, <strong>SoMFNode</strong>, <strong>SoSFEngine</strong>, <strong>SoMFEngine</strong>, <strong>SoSFPath</strong> and <strong>SoMFPath</strong>.</p><p>This method, in addition to the ordinary write() method of <strong>SoNode</strong>, needs to be present since the fields don't have a write action instance in their writeValue() method, and <strong>writeInstance()</strong> will create a new <strong>SoWriteAction</strong> and call continueToApply() on it.</p><p>Reimplemented in <strong>SoNode</strong>, <strong>SoTimeCounter</strong>, <strong>SoEngine</strong>, <strong>SoElapsedTime</strong>, and <strong>SoNodeEngine</strong>.</p>
<h3>SbBool SoFieldContainer::getIsBuiltIn (void) const</h3>
<p>Returns TRUE if this object is instantiated from one of the native Coin classes, FALSE if the object's class is outside the standard Coin library.</p>
<h3>const \fBSoFieldData\fP * SoFieldContainer::getFieldData (void) const\fC [virtual]\fP</h3>
<p>Returns a pointer to the class-wide field data storage object for this instance. If no fields are present, returns NULL.</p><p>Reimplemented in <strong>SoExtSelection</strong>, <strong>SoShaderParameter</strong>, <strong>SoBaseKit</strong>, <strong>SoDragger</strong>, <strong>SoCamera</strong>, <strong>SoWWWInline</strong>, <strong>SoVRMLInline</strong>, <strong>SoEventCallback</strong>, <strong>SoShape</strong>, <strong>SoVRMLSwitch</strong>, <strong>SoTrackballDragger</strong>, <strong>SoDirectionalLightManip</strong>, <strong>SoProtoInstance</strong>, <strong>SoSpotLightManip</strong>, <strong>SoInteractionKit</strong>, <strong>SoSelection</strong>, <strong>SoVertexShape</strong>, <strong>SoVRMLElevationGrid</strong>, <strong>SoVRMLFontStyle</strong>, <strong>SoSTLFileKit</strong>, <strong>SoComposeMatrix</strong>, <strong>SoClipPlaneManip</strong>, <strong>SoPointLightManip</strong>, <strong>SoTransformManip</strong>, <strong>SoShaderObject</strong>, <strong>SoShaderProgram</strong>, <strong>SoTexture2</strong>, <strong>SoWWWAnchor</strong>, <strong>SoComposeRotationFromTo</strong>, <strong>SoComposeRotation</strong>, <strong>SoComposeVec2f</strong>, <strong>SoComposeVec3f</strong>, <strong>SoComposeVec4f</strong>, <strong>SoTexture3</strong>, <strong>SoTextureCubeMap</strong>, <strong>SoVRMLAudioClip</strong>, <strong>SoVRMLImageTexture</strong>, <strong>SoVRMLVertexShape</strong>, <strong>SoProfilerStats</strong>, <strong>SoRotateSphericalDragger</strong>, <strong>SoSpotLightDragger</strong>, <strong>SoTransformerDragger</strong>, <strong>SoDecomposeMatrix</strong>, <strong>SoDecomposeVec2f</strong>, <strong>SoDecomposeVec3f</strong>, <strong>SoDecomposeVec4f</strong>, <strong>SoImage</strong>, <strong>SoSceneTexture2</strong>, <strong>SoSceneTextureCubeMap</strong>, <strong>SoText3</strong>, <strong>SoVRMLAnchor</strong>, <strong>SoVRMLIndexedFaceSet</strong>, <strong>SoVRMLMovieTexture</strong>, <strong>SoVRMLViewpoint</strong>, <strong>SoHandleBoxDragger</strong>, <strong>SoScale2UniformDragger</strong>, <strong>SoTabPlaneDragger</strong>, <strong>SoTranslate1Dragger</strong>, <strong>SoTranslate2Dragger</strong>, <strong>SoDecomposeRotation</strong>, <strong>SoBumpMap</strong>, <strong>SoGeoCoordinate</strong>, <strong>SoGeoSeparator</strong>, <strong>SoPendulum</strong>, <strong>SoRotor</strong>, <strong>SoShuttle</strong>, <strong>SoSwitch</strong>, <strong>SoVertexProperty</strong>, <strong>SoVRMLDragSensor</strong>, <strong>SoVRMLSound</strong>, <strong>SoForeignFileKit</strong>, <strong>SoShadowGroup</strong>, <strong>SoCenterballDragger</strong>, <strong>SoDirectionalLightDragger</strong>, <strong>SoJackDragger</strong>, <strong>SoRotateCylindricalDragger</strong>, <strong>SoRotateDiscDragger</strong>, <strong>SoScale1Dragger</strong>, <strong>SoScale2Dragger</strong>, <strong>SoScaleUniformDragger</strong>, <strong>SoTransformBoxDragger</strong>, <strong>SoCalculator</strong>, <strong>SoComputeBoundingBox</strong>, <strong>SoNodeKitListPart</strong>, <strong>SoCacheHint</strong>, <strong>SoFontStyle</strong>, <strong>SoGeoLocation</strong>, <strong>SoIndexedFaceSet</strong>, <strong>SoIndexedLineSet</strong>, <strong>SoIndexedTriangleStripSet</strong>, <strong>SoVRMLBackground</strong>, <strong>SoVRMLFog</strong>, <strong>SoVRMLIndexedLineSet</strong>, <strong>SoVRMLNavigationInfo</strong>, <strong>SoVRMLText</strong>, <strong>SoVRMLTimeSensor</strong>, <strong>SoDragPointDragger</strong>, <strong>SoPointLightDragger</strong>, <strong>SoTabBoxDragger</strong>, <strong>SoElapsedTime</strong>, <strong>SoGate</strong>, <strong>SoOneShot</strong>, <strong>SoTimeCounter</strong>, <strong>SoAsciiText</strong>, <strong>SoIndexedNurbsCurve</strong>, <strong>SoIndexedNurbsSurface</strong>, <strong>SoLocateHighlight</strong>, <strong>SoMaterial</strong>, <strong>SoProfile</strong>, <strong>SoRotationXYZ</strong>, <strong>SoSeparator</strong>, <strong>SoTexture3Transform</strong>, <strong>SoTextureCoordinatePlane</strong>, <strong>SoVRMLCollision</strong>, <strong>SoVRMLExtrusion</strong>, <strong>SoVRMLGroup</strong>, <strong>SoVRMLLOD</strong>, <strong>SoVRMLPositionInterpolator</strong>, <strong>SoSelectOne</strong>, <strong>SoBlinker</strong>, <strong>SoDrawStyle</strong>, <strong>SoEnvironment</strong>, <strong>SoFile</strong>, <strong>SoGeoOrigin</strong>, <strong>SoIndexedPointSet</strong>, <strong>SoListener</strong>, <strong>SoLOD</strong>, <strong>SoNurbsCurve</strong>, <strong>SoNurbsSurface</strong>, <strong>SoSurroundScale</strong>, <strong>SoTextureCombine</strong>, <strong>SoTextureCoordinateReflectionMap</strong>, <strong>SoTransform</strong>, <strong>SoVRMLBillboard</strong>, <strong>SoVRMLColorInterpolator</strong>, <strong>SoVRMLMaterial</strong>, <strong>SoVRMLOrientationInterpolator</strong>, <strong>SoVRMLParent</strong>, <strong>SoVRMLProximitySensor</strong>, <strong>SoVRMLSphereSensor</strong>, <strong>SoVRMLTextureTransform</strong>, <strong>SoShadowDirectionalLight</strong>, <strong>SoShadowSpotLight</strong>, <strong>SoBoolOperation</strong>, <strong>SoCounter</strong>, <strong>SoAntiSquish</strong>, <strong>SoArray</strong>, <strong>SoBumpMapTransform</strong>, <strong>SoCube</strong>, <strong>SoDepthBuffer</strong>, <strong>SoFaceSet</strong>, <strong>SoIndexedMarkerSet</strong>, <strong>SoIndexedShape</strong>, <strong>SoLevelOfDetail</strong>, <strong>SoNormal</strong>, <strong>SoPolygonOffset</strong>, <strong>SoShapeHints</strong>, <strong>SoText2</strong>, <strong>SoTexture2Transform</strong>, <strong>SoTextureCoordinateNormalMap</strong>, <strong>SoVRMLAppearance</strong>, <strong>SoVRMLColor</strong>, <strong>SoVRMLCoordinate</strong>, <strong>SoVRMLCoordinateInterpolator</strong>, <strong>SoVRMLInterpolator</strong>, <strong>SoVRMLLight</strong>, <strong>SoVRMLNormal</strong>, <strong>SoVRMLNormalInterpolator</strong>, <strong>SoVRMLPixelTexture</strong>, <strong>SoVRMLShape</strong>, <strong>SoVRMLTextureCoordinate</strong>, <strong>SoVRMLTouchSensor</strong>, <strong>SoVRMLVertexPoint</strong>, <strong>SoVRMLVisibilitySensor</strong>, <strong>SoConcatenate</strong>, <strong>SoHeightMapToNormalMap</strong>, <strong>SoOnOff</strong>, <strong>SoTransformVec3f</strong>, <strong>SoTriggerAny</strong>, <strong>SoCenterballManip</strong>, <strong>SoHandleBoxManip</strong>, <strong>SoJackManip</strong>, <strong>SoTabBoxManip</strong>, <strong>SoTrackballManip</strong>, <strong>SoTransformBoxManip</strong>, <strong>SoTransformerManip</strong>, <strong>SoBaseColor</strong>, <strong>SoComplexity</strong>, <strong>SoCone</strong>, <strong>SoCoordinate3</strong>, <strong>SoCoordinate4</strong>, <strong>SoCylinder</strong>, <strong>SoGeometryShader</strong>, <strong>SoLight</strong>, <strong>SoNonIndexedShape</strong>, <strong>SoNurbsProfile</strong>, <strong>SoPackedColor</strong>, <strong>SoSpotLight</strong>, <strong>SoTextureCoordinate3</strong>, <strong>SoVRMLCone</strong>, <strong>SoVRMLCylinder</strong>, <strong>SoVRMLCylinderSensor</strong>, <strong>SoVRMLGeometry</strong>, <strong>SoVRMLPlaneSensor</strong>, <strong>SoVRMLPointLight</strong>, <strong>SoVRMLScalarInterpolator</strong>, <strong>SoVRMLSpotLight</strong>, <strong>SoVRMLTransform</strong>, <strong>SoVRMLVertexLine</strong>, <strong>SoVRMLWorldInfo</strong>, <strong>SoShadowCulling</strong>, <strong>SoShadowStyle</strong>, <strong>SoFieldConverter</strong>, <strong>SoInterpolate</strong>, <strong>SoTexture2Convert</strong>, <strong>SoSeparatorKit</strong>, <strong>SoCallback</strong>, <strong>SoClipPlane</strong>, <strong>SoDirectionalLight</strong>, <strong>SoFont</strong>, <strong>SoFrustumCamera</strong>, <strong>SoGroup</strong>, <strong>SoLightModel</strong>, <strong>SoLineSet</strong>, <strong>SoMarkerSet</strong>, <strong>SoMaterialBinding</strong>, <strong>SoMatrixTransform</strong>, <strong>SoMultipleCopy</strong>, <strong>SoNormalBinding</strong>, <strong>SoPathSwitch</strong>, <strong>SoPickStyle</strong>, <strong>SoPointLight</strong>, <strong>SoPointSet</strong>, <strong>SoQuadMesh</strong>, <strong>SoResetTransform</strong>, <strong>SoRotation</strong>, <strong>SoScale</strong>, <strong>SoSphere</strong>, <strong>SoTextureCoordinate2</strong>, <strong>SoTextureCoordinateBinding</strong>, <strong>SoTextureCoordinateEnvironment</strong>, <strong>SoTextureCoordinateObject</strong>, <strong>SoTextureScalePolicy</strong>, <strong>SoTextureUnit</strong>, <strong>SoTranslation</strong>, <strong>SoTransparencyType</strong>, <strong>SoTriangleStripSet</strong>, <strong>SoUnits</strong>, <strong>SoVertexAttributeBinding</strong>, <strong>SoVRMLBox</strong>, <strong>SoVRMLDirectionalLight</strong>, <strong>SoVRMLIndexedLine</strong>, <strong>SoVRMLIndexedShape</strong>, <strong>SoVRMLPointSet</strong>, <strong>SoVRMLSphere</strong>, <strong>SoVRMLTexture</strong>, <strong>SoAppearanceKit</strong>, <strong>SoCameraKit</strong>, <strong>SoLightKit</strong>, <strong>SoSceneKit</strong>, <strong>SoAnnotation</strong>, <strong>SoBumpMapCoordinate</strong>, <strong>SoColorIndex</strong>, <strong>SoFragmentShader</strong>, <strong>SoInfo</strong>, <strong>SoLabel</strong>, <strong>SoLinearProfile</strong>, <strong>SoOrthographicCamera</strong>, <strong>SoPerspectiveCamera</strong>, <strong>SoProfileCoordinate2</strong>, <strong>SoProfileCoordinate3</strong>, <strong>SoTextureCoordinateDefault</strong>, <strong>SoTextureMatrixTransform</strong>, <strong>SoTransformSeparator</strong>, <strong>SoVRMLSensor</strong>, <strong>SoInterpolateFloat</strong>, <strong>SoInterpolateRotation</strong>, <strong>SoInterpolateVec2f</strong>, <strong>SoInterpolateVec3f</strong>, <strong>SoInterpolateVec4f</strong>, <strong>SoShapeKit</strong>, <strong>SoWrapperKit</strong>, <strong>SoTextureCoordinateCube</strong>, <strong>SoTextureCoordinateCylinder</strong>, <strong>SoTextureCoordinateFunction</strong>, <strong>SoTextureCoordinateSphere</strong>, <strong>SoTransformation</strong>, and <strong>SoVertexShader</strong>.</p>
<h3>void SoFieldContainer::copyContents (const \fBSoFieldContainer\fP *from, SbBoolcopyconnections)\fC [virtual]\fP</h3>
<p>Makes a deep copy of all data of <em>from</em> into this instance, <em>except</em> external scenegraph references if <em>copyconnections</em> is FALSE<em>.</em></p><p>This is the method that should be overridden by extension node / engine / dragger / whatever subclasses which needs to account for internal data that are not handled automatically.</p><p>For copying nodes from application code, you should not invoke this function directly, but rather call the <strong>SoNode::copy()</strong> function:</p>
<pre>
SoNode * mynewnode = templatenode-&gt;copy();
</pre>
<p>The same also goes for engines.</p><p>Make sure that when you override the <strong>copyContents()</strong> method in your extension class that you also make it call upwards to it's parent superclass in the inheritance hierarchy, as <strong>copyContents()</strong> in for instance <strong>SoNode</strong> and <strong>SoFieldContainer</strong> does important work. It should go something like this:</p>
<pre>
void
MyCoinExtensionNode::copyContents(const SoFieldContainer * from,
                                  SbBool copyconnections)
{
  // let parent superclasses do their thing (copy fields, copy
  // instance name, etc etc)
  SoNode::copyContents(from, copyconnections);

  // [..then copy internal data..]
}
</pre>
<p>Reimplemented in <strong>SoNode</strong>, <strong>SoWWWInline</strong>, <strong>SoBaseKit</strong>, <strong>SoVRMLSwitch</strong>, <strong>SoVRMLLOD</strong>, <strong>SoInteractionKit</strong>, <strong>SoNodeKitListPart</strong>, <strong>SoVRMLParent</strong>, <strong>SoClipPlaneManip</strong>, <strong>SoGroup</strong>, <strong>SoDirectionalLightManip</strong>, <strong>SoSpotLightManip</strong>, <strong>SoVRMLShape</strong>, <strong>SoPointLightManip</strong>, <strong>SoTransformManip</strong>, <strong>SoVRMLScript</strong>, <strong>SoRotateSphericalDragger</strong>, <strong>SoRotateCylindricalDragger</strong>, <strong>SoFile</strong>, <strong>SoCallback</strong>, <strong>SoVertexAttribute</strong>, <strong>SoVRMLAppearance</strong>, and <strong>SoVRMLGeometry</strong>.</p>
<h3>\fBSoFieldContainer\fP * SoFieldContainer::copyThroughConnection (void) const\fC [virtual]\fP</h3>
<p>Return copy of this instance.</p><p>Note: default implementation just returns this pointer, <strong>SoNode</strong> and <strong>SoEngine</strong> overrides this method to return the pointer to the actual copy.</p><p>Reimplemented in <strong>SoNode</strong>, and <strong>SoEngine</strong>.</p>
<h3>void SoFieldContainer::initCopyDict (void)\fC [static]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p><p>Initialize a dictionary hash storing pointers for original fieldcontainer instances and their copies during scene graph copy operations.</p><p>This method is called from the start of <strong>SoNode::copy()</strong>.</p>
<h3>void SoFieldContainer::addCopy (const \fBSoFieldContainer\fP *orig, const \fBSoFieldContainer\fP *copy)\fC [static]\fP</h3>
<p>Add a pair of pointers to an original fieldcontainer and a copy of it to an internal pointer dictionary used during scene graph copy operations.</p>
<h3>\fBSoFieldContainer\fP * SoFieldContainer::checkCopy (const \fBSoFieldContainer\fP *orig)\fC [static]\fP</h3>
<p>Returns the copy of <em>orig</em>, if any. If no copy exists, we return a NULL<em> pointer.</em></p>
<h3>\fBSoFieldContainer\fP * SoFieldContainer::findCopy (const \fBSoFieldContainer\fP *orig, const SbBoolcopyconnections)\fC [static]\fP</h3>
<p>Returns a copy of <em>orig</em>.</p><p>If no copy has been made earlier when the function is called, a copy is made on-the-fly (which is the reason we need to pass along the <em>copyconnections</em> flag).</p><p>This method will also run the <strong>copyContents()</strong> method on the copy, if it hasn't been run already. Note that if you call <strong>copyContents()</strong> on the copy outside of this method, this will go undetected and the guts of <em>orig</em> will be copied multiple times into its copy.</p><p>If <strong>copyContents()</strong> is called directly (instead of using copy()), it's assumed that the user only wants to copy the field values, and we just return NULL here. This is done to match how it's done in SGI Inventor.</p><p><strong>See also:</strong></p><p><strong>checkCopy()</strong></p>
<h3>void SoFieldContainer::copyDone (void)\fC [static]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p><p>Clean up the dictionary hash.</p><p>This method is called from the end of <strong>SoNode::copy()</strong>.</p>
<h3>void SoFieldContainer::getFieldsMemorySize (size_t &managed, size_t &unmanaged) const\fC [virtual]\fP</h3>
<p>Returns the data array sizes of the SoFieldData-registered multi-fields. The <em>managed</em> argument returns the size of the fields that Coin manages the memory for, and the <em>unmanaged</em> argument returns the size of the data in the multi-fields controlled by the application through SoMField::setValuesPointer() which Coin will not delete.</p><p>Data that is kept in the object memory chunk (that is included when you do sizeof(object)) is not included in these values - only the memory that is managed in addtional memory chunks from the object chunk is returned.</p><p>Extension field types that are not known to the plain Coin library are not accounted for. This function is therefore virtual, so such extension field types can be added to the numbers for extension nodes.</p><p>This method is used for memory profiling purposes.</p><p><strong>Since:</strong></p><p>Coin 3.0</p>
<h3>void SoFieldContainer::setUserData (void *userdata) const</h3>
<p>Set a generic user data pointer for this field container.</p><p>This function can be used by the application programmer to, for instance, store a pointer to an application specific data structure that is in some way related to the field container. <strong>getUserData()</strong> can later be used to retrieve the pointer.</p><p><strong>See also:</strong></p><p><strong>getUserData()</strong></p><p><strong>Since:</strong></p><p>Coin 2.0</p>
<h3>void * SoFieldContainer::getUserData (void) const</h3>
<p>Return the generic user data pointer for this field container, or NULL if no user data has been set.</p><p><strong>See also:</strong></p><p><strong>setUserData()</strong></p><p><strong>Since:</strong></p><p>Coin 2.0</p>
<h3>SbBool SoFieldContainer::readInstance (\fBSoInput\fP *in, unsigned shortflags)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>This method is mainly intended for internal use during file import operations.</p><p>It reads a definition of an instance from the input stream <em>in</em>. The input stream state points to the start of a serialized / persistant representation of an instance of this class type.</p><p>TRUE or FALSE is returned, depending on if the instantiation and configuration of the new object of this class type went ok or not. The import process should be robust and handle corrupted input streams by returning FALSE.</p><p><em>flags</em> is used internally during binary import when reading user extension nodes, group nodes or engines.</p><p>Implements <strong>SoBase</strong>.</p><p>Reimplemented in <strong>SoNode</strong>, <strong>SoBaseKit</strong>, <strong>SoWWWInline</strong>, <strong>SoVRMLSwitch</strong>, <strong>SoVRMLLOD</strong>, <strong>SoInteractionKit</strong>, <strong>SoTextureCubeMap</strong>, <strong>SoNodeKitListPart</strong>, <strong>SoSeparator</strong>, <strong>SoTexture2</strong>, <strong>SoImage</strong>, <strong>SoVRMLParent</strong>, <strong>SoTexture3</strong>, <strong>SoShaderObject</strong>, <strong>SoProto</strong>, <strong>SoFile</strong>, <strong>SoGroup</strong>, <strong>SoVRMLImageTexture</strong>, <strong>SoEngine</strong>, <strong>SoProtoInstance</strong>, <strong>SoNormalBinding</strong>, <strong>SoBumpMap</strong>, <strong>SoVertexAttribute</strong>, <strong>SoTextureCoordinateBinding</strong>, <strong>SoVRMLBackground</strong>, <strong>SoNodeEngine</strong>, and <strong>SoVRMLPixelTexture</strong>.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Data Documentation</h2>
        <div class="sectioncontent">
<h3>SbBool SoFieldContainer::isBuiltIn\fC [protected]\fP</h3>
<p>Flag for storing whether or not this class instance is a built-in class or not. By knowing the difference between a class which is native Coin or a user extension, it is possible to automatically store and read extension nodes and engines.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for Coin from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="SoField.3.html"><span aria-hidden="true">&larr;</span> SoField.3: The sofield class is the top-level abstract base class for fields.  fields is the mechanism used throughout coin for encapsulating basic data types to detect changes made to them, and to provide conversion, import and export facilities.</a></li>
   <li class="next"><a href="SoFieldConverter.3.html">SoFieldConverter.3: The sofieldconverter class is the abstract base class for field converters.  when fields of different types are attempted connected, the coin library tries to find a field converter class which can be inserted between them, acting as a filter converting values from the master field to values matching the type of the slave field. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

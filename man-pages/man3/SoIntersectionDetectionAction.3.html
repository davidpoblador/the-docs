<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SoIntersectionDetectionAction: The sointersectiondetectionaction class is for detecting intersecting primitives in a scene.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The sointersectiondetectionaction class is for detecting intersecting primitives in a scene.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="SoIntersectionDetectionAction (3) manual">
  <meta name="twitter:description" content="The sointersectiondetectionaction class is for detecting intersecting primitives in a scene.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcoin80-doc-SoIntersectionDetectionAction-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/SoIntersectionDetectionAction.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="SoIntersectionDetectionAction (3) manual" />
  <meta property="og:description" content="The sointersectiondetectionaction class is for detecting intersecting primitives in a scene." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcoin80-doc-SoIntersectionDetectionAction-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">SoIntersectionDetectionAction<small> (3)</small></h1>
        <p class="lead">The sointersectiondetectionaction class is for detecting intersecting primitives in a scene.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoIntersectionDetectionAction.3.html">
      <span itemprop="name">SoIntersectionDetectionAction: The sointersectiondetectionaction class is for detecting intersecting primitives in a scene.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcoin80-doc/">
      <span itemprop="name">libcoin80-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoIntersectionDetectionAction.3.html">
      <span itemprop="name">SoIntersectionDetectionAction: The sointersectiondetectionaction class is for detecting intersecting primitives in a scene.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;Inventor/collision/SoIntersectionDetectionAction.h&gt;</p><p>Inherits <strong>SoAction</strong>.</p><h3>Public Types</h3>
<p>enum <strong>Resp</strong> { <strong>NEXT_PRIMITIVE</strong>, <strong>NEXT_SHAPE</strong>, <strong>ABORT</strong> }</p><p>typedef <strong>SoCallbackAction::Response</strong> <strong>SoIntersectionVisitationCB</strong> (void *closure, const <strong>SoPath</strong> *where)</p><p>typedef SbBool <strong>SoIntersectionFilterCB</strong> (void *closure, const <strong>SoPath</strong> *p1, const <strong>SoPath</strong> *p2)</p><p>typedef Resp <strong>SoIntersectionCB</strong> (void *closure, const <strong>SoIntersectingPrimitive</strong> *p1, const <strong>SoIntersectingPrimitive</strong> *p2)</p>
<h3>Public Member Functions</h3>
<p>virtual <strong>SoType</strong> <strong>getTypeId</strong> (void) const </p><p>void <strong>setIntersectionDetectionEpsilon</strong> (float epsilon)</p><p>float <strong>getIntersectionDetectionEpsilon</strong> (void) const </p><p>void <strong>setTypeEnabled</strong> (<strong>SoType</strong> type, SbBool enable)</p><p>SbBool <strong>isTypeEnabled</strong> (<strong>SoType</strong> type, SbBool checkgroups=FALSE) const </p><p>void <strong>setManipsEnabled</strong> (SbBool enable)</p><p>SbBool <strong>isManipsEnabled</strong> (void) const </p><p>void <strong>setDraggersEnabled</strong> (SbBool enable)</p><p>SbBool <strong>isDraggersEnabled</strong> (void) const </p><p>void <strong>setShapeInternalsEnabled</strong> (SbBool enable)</p><p>SbBool <strong>isShapeInternalsEnabled</strong> (void) const </p><p>void <strong>addVisitationCallback</strong> (<strong>SoType</strong> type, SoIntersectionVisitationCB *cb, void *closure)</p><p>void <strong>removeVisitationCallback</strong> (<strong>SoType</strong> type, SoIntersectionVisitationCB *cb, void *closure)</p><p>virtual void <strong>apply</strong> (<strong>SoNode</strong> *node)</p><p>virtual void <strong>apply</strong> (<strong>SoPath</strong> *path)</p><p>virtual void <strong>apply</strong> (const <strong>SoPathList</strong> &paths, SbBool obeysRules=FALSE)</p><p>virtual void <strong>setFilterCallback</strong> (SoIntersectionFilterCB *cb, void *closure=NULL)</p><p>virtual void <strong>addIntersectionCallback</strong> (SoIntersectionCB *cb, void *closure=NULL)</p><p>virtual void <strong>removeIntersectionCallback</strong> (SoIntersectionCB *cb, void *closure=NULL)</p>
<h3>Static Public Member Functions</h3>
<p>static <strong>SoType</strong> <strong>getClassTypeId</strong> (void)</p><p>static void <strong>addMethod</strong> (const <strong>SoType</strong> type, SoActionMethod method)</p><p>static void <strong>enableElement</strong> (const <strong>SoType</strong> type, const int stackindex)</p><p>static void <strong>initClass</strong> (void)</p><p>static void <strong>setIntersectionEpsilon</strong> (float epsilon)</p><p>static float <strong>getIntersectionEpsilon</strong> (void)</p>
<h3>Protected Member Functions</h3>
<p>virtual const</p><p><strong>SoEnabledElementsList</strong> & <strong>getEnabledElements</strong> (void) const "</p>
<h3>Static Protected Member Functions</h3>
<p>static <strong>SoEnabledElementsList</strong> * <strong>getClassEnabledElements</strong> (void)</p><p>static <strong>SoActionMethodList</strong> * <strong>getClassActionMethods</strong> (void)</p>
<h3>Additional Inherited Members</h3>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>The <strong>SoIntersectionDetectionAction</strong> class is for detecting intersecting primitives in a scene.</p><p>Note that only collisions between actual geometry in the scene is detected, so the contents of some special nodes like e.g. <strong>SoText2</strong> and <strong>SoImage</strong> (which projects to screen-plane bitmap graphics, and not actual polygons) will not be considered for collision detection.</p><p>Note also that the <strong>SoIntersectionDetectionAction</strong> class is not a high-performance component in Coin. Using it in a continuous manner over complex scene graphs is doomed to be a performance killer.</p><p>Below is a simple usage example for this class. It was written as a stand-alone framework set up for profiling and optimization of the <strong>SoIntersectionDetectionAction</strong>. It tests intersection of all shapes against each other for the loaded file.</p>
<pre>
#include &lt;cstdlib&gt;
#include &lt;Inventor/SbTime.h&gt;
#include &lt;Inventor/SoDB.h&gt;
#include &lt;Inventor/SoInteraction.h&gt;
#include &lt;Inventor/collision/SoIntersectionDetectionAction.h&gt;
#include &lt;Inventor/errors/SoDebugError.h&gt;
#include &lt;Inventor/nodekits/SoNodeKit.h&gt;
#include &lt;Inventor/nodes/SoSeparator.h&gt;

static SoIntersectionDetectionAction::Resp
intersectionCB(void * closure,
               const SoIntersectingPrimitive * pr1,
               const SoIntersectingPrimitive * pr2)
{
  (void)fprintf(stdout, "intersection hit!\n");
  return SoIntersectionDetectionAction::NEXT_PRIMITIVE;
}

int
main(int argc, char ** argv)
{
  SoDB::init();
  SoNodeKit::init();
  SoInteraction::init();

  if (argc != 2) {
    (void)fprintf(stderr, "\n\tUsage: testapp &lt;filename.iv&gt;\n\n");
    <strong>exit</strong>(1);
  }

  SoInput in;
  SbBool ok = in.openFile(argv[1]);
  assert(ok);
  SoSeparator * root = SoDB::readAll(&in);
  assert(root);

  root-&gt;ref();

  SoIntersectionDetectionAction ida;
  ida.addIntersectionCallback(intersectionCB, NULL);
  ida.setManipsEnabled(FALSE);
  ida.setDraggersEnabled(FALSE);
  ida.setIntersectionDetectionEpsilon(10.0f);

  SbTime starttime = SbTime::getTimeOfDay();
  SoDebugError::postInfo("main", "SoIntersectionDetectionAction::apply");

  ida.apply(root);

  SoDebugError::postInfo("main", "apply() done after %f seconds.",
                         (SbTime::getTimeOfDay() - starttime).getValue());

  root-&gt;unref();

  return 0;
}
</pre>
<p><strong>Since:</strong></p><p>Coin 2.1</p><p>TGS Inventor 2.4</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>\fBSoType\fP SoIntersectionDetectionAction::getTypeId (void) const\fC [virtual]\fP</h3>
<p>Returns the type identification of an action derived from a class inheriting <strong>SoAction</strong>. This is used for run-time type checking and 'downward' casting.</p><p>Usage example:</p>
<pre>
void bar(SoAction * action)
{
  if (action-&gt;getTypeId() == SoGLRenderAction::getClassTypeId()) {
    // safe downward cast, know the type
    SoGLRenderAction * glrender = (SoGLRenderAction *)action;
  }
  return; // ignore if not renderaction
}
</pre>
<p>For application programmers wanting to extend the library with new actions: this method needs to be overridden in <em>all</em> subclasses. This is typically done as part of setting up the full type system for extension classes, which is usually accomplished by using the pre-defined macros available through Inventor/nodes/SoSubAction.h: SO_ACTION_SOURCE, SO_ACTION_INIT_CLASS and SO_ACTION_CONSTRUCTOR.</p><p>For more information on writing Coin extensions, see the <strong>SoAction</strong> class documentation.</p><p>Returns the actual type id of an object derived from a class inheriting <strong>SoAction</strong>. Needs to be overridden in <em>all</em> subclasses.</p><p>Implements <strong>SoAction</strong>.</p>
<h3>void SoIntersectionDetectionAction::addMethod (const \fBSoType\fPtype, SoActionMethodmethod)\fC [static]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>void SoIntersectionDetectionAction::enableElement (const \fBSoType\fPtype, const intstackindex)\fC [static]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>const \fBSoEnabledElementsList\fP & SoIntersectionDetectionAction::getEnabledElements (void) const\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Returns a list of the elements used by action instances of this class upon traversal operations.</p><p>Reimplemented from <strong>SoAction</strong>.</p>
<h3>void SoIntersectionDetectionAction::setIntersectionDetectionEpsilon (floatepsilon)</h3>
<p>Sets the intersection detection distance epsilon value for the action object. This overrides the global value.</p><p>See also <strong>SoIntersectionDetectionAction::setIntersectionEpsilon()</strong> for important information about how this setting influences performance.</p>
<h3>float SoIntersectionDetectionAction::getIntersectionDetectionEpsilon (void) const</h3>
<p>Returns the set intersection detection distance epsilon value for the action object.</p>
<h3>void SoIntersectionDetectionAction::setIntersectionEpsilon (floatepsilon)\fC [static]\fP</h3>
<p>Sets the global intersection detection distance epsilon value.</p><p>This makes primitives within the epsilon distance be considered to intersect each other.</p><p>This will affect all intersection detection action objects in use that don't have a locally set value.</p><p>The epsilon value is a worldspace value.</p><p>Be aware that increasing the epsilon value can <em>dramatically</em> increase the number of primitive intersection tests being done to decide intersections. Increasing the epsilon value can therefore cause serious slow-downs in the running time of the intersections checks.</p>
<h3>float SoIntersectionDetectionAction::getIntersectionEpsilon (void)\fC [static]\fP</h3>
<p>Returns the globally set intersection detection distance epsilon value.</p>
<h3>void SoIntersectionDetectionAction::setTypeEnabled (\fBSoType\fPtype, SbBoolenable)</h3>
<p>Sets whether nodes of specific types (including derived objects) should be tested for intersection or not.</p><p><strong>See also:</strong></p><p><strong>isTypeEnabled()</strong>, <strong>setManipsEnabled()</strong>, <strong>setDraggersEnabled()</strong></p>
<h3>SbBool SoIntersectionDetectionAction::isTypeEnabled (\fBSoType\fPtype, SbBoolcheckgroups = \fCFALSE\fP) const</h3>
<p>Returns whether nodes of specific types are enabled or not. The <em>checkgroups</em> argument can be set to TRUE if you wan't the return value to reflect whether the node will be implicit enabled/disabled through the settings controlled by the <strong>setManipsEnabled()</strong> and <strong>setDraggersEnabled()</strong> functions.</p><p>The default is that all node types are enabled.</p><p>Note that derivation checks are not performed - the type needs to be the exact same type as has been disabled with <strong>setTypeEnabled()</strong></p><p><strong>See also:</strong></p><p><strong>setTypeEnabled()</strong></p>
<h3>void SoIntersectionDetectionAction::setManipsEnabled (SbBoolenable)</h3>
<p>Sets whether manipulators in the scene graph should be tested for intersection with other geometry or not.</p><p>Note that when draggers are disabled with <strong>setDraggersEnabled()</strong>, this setting has no effect - manipulators are disabled too.</p><p><strong>See also:</strong></p><p><strong>isManipsEnabled()</strong>, <strong>setDraggersEnabled()</strong>, <strong>setTypeEnabled()</strong></p>
<h3>SbBool SoIntersectionDetectionAction::isManipsEnabled (void) const</h3>
<p>Returns whether the actions is set up to test intersection on manipulators in the scene or not.</p><p>Note that when draggers are disabled with <strong>setDraggersEnabled()</strong>, this setting has no effect - manipulators are disabled too.</p><p>The default is that manipulators are enabled for intersection testing with other geometry in the scene.</p><p><strong>See also:</strong></p><p><strong>setManipsEnabled()</strong></p>
<h3>void SoIntersectionDetectionAction::setDraggersEnabled (SbBoolenable)</h3>
<p>Sets whether draggers in the scene graph should be tested for intersection with other geometry or not.</p><p>Note that when you disable draggers, manipulators are also automatically disabled, although the isManipsDisabled() setting might reflect otherwise.</p><p><strong>See also:</strong></p><p><strong>isDraggersEnabled()</strong>, <strong>setManipsEnabled()</strong>, <strong>setTypeEnabled()</strong></p>
<h3>SbBool SoIntersectionDetectionAction::isDraggersEnabled (void) const</h3>
<p>Returns whether the actions is set up to test intersection on draggers in the scene or not.</p><p>The default is that draggers are enabled for intersection testing with other geometry in the scene.</p><p><strong>See also:</strong></p><p><strong>setDraggersEnabled()</strong></p>
<h3>void SoIntersectionDetectionAction::setShapeInternalsEnabled (SbBoolenable)</h3>
<p>Sets whether nodes in the scene graph should be checked for intersecting primitives within themselves.</p><p>Default is FALSE.</p><p><strong>See also:</strong></p><p><strong>isShapeInternalsEnabled()</strong></p>
<h3>SbBool SoIntersectionDetectionAction::isShapeInternalsEnabled (void) const</h3>
<p>Returns whether nodes in the scene graph will be checked for intersecting primitives within themselves.</p><p>The default value for this setting is FALSE.</p><p><strong>See also:</strong></p><p><strong>setShapeInternalsEnabled()</strong></p>
<h3>void SoIntersectionDetectionAction::addVisitationCallback (\fBSoType\fPtype, SoIntersectionVisitationCB *cb, void *closure)</h3>
<p>The scene graph traversal can be controlled with callbacks which you set with this method. Use just like you would use <strong>SoCallbackAction::addPreCallback()</strong>.</p><p><strong>See also:</strong></p><p><strong>SoCallbackAction::addPreCallback()</strong></p>
<h3>void SoIntersectionDetectionAction::removeVisitationCallback (\fBSoType\fPtype, SoIntersectionVisitationCB *cb, void *closure)</h3>
<p>The scene graph traversal can be controlled with callbacks which you remove with this method. Use just like you would use SoCallbackAction::removePreCallback().</p><p><strong>See also:</strong></p><p>SoCallbackAction::removePreCallback()</p>
<h3>void SoIntersectionDetectionAction::apply (\fBSoNode\fP *root)\fC [virtual]\fP</h3>
<p>Applies the action to the scene graph rooted at <em>root</em>.</p><p>Note that you should <em>not</em> apply an action to a node with a zero reference count. The behavior in that case is undefined.</p><p>Reimplemented from <strong>SoAction</strong>.</p>
<h3>void SoIntersectionDetectionAction::apply (\fBSoPath\fP *path)\fC [virtual]\fP</h3>
<p>Applies the action to the parts of the graph defined by <em>path</em>.</p><p>Note that an <strong>SoPath</strong> will also contain all nodes that may influence e.g. geometry nodes in the path. So for instance applying an <strong>SoGLRenderAction</strong> on an <strong>SoPath</strong> will render that path as expected in the view, where geometry will get its materials, textures, and other appearance settings correctly.</p><p>If the <em>path</em> ends in an <strong>SoGroup</strong> node, the action will also traverse the tail node's children.</p><p>Reimplemented from <strong>SoAction</strong>.</p>
<h3>void SoIntersectionDetectionAction::apply (const \fBSoPathList\fP &pathlist, SbBoolobeysrules = \fCFALSE\fP)\fC [virtual]\fP</h3>
<p>Applies action to the graphs defined by <em>pathlist</em>. If <em>obeysrules</em> is set to TRUE<em>, </em><em>pathlist</em><em> must obey the following four conditions (which is the case for path lists returned from search actions for non-group nodes and path lists returned from picking actions):</em></p><p>All paths must start at the same head node. All paths must be sorted in traversal order. The paths must be unique. No path can continue through the end point of another path.</p><p><strong>See also:</strong></p><p><strong>SoAction::apply(SoPath * path)</strong></p><p>Reimplemented from <strong>SoAction</strong>.</p>
<h3>void SoIntersectionDetectionAction::setFilterCallback (SoIntersectionFilterCB *cb, void *closure = \fCNULL\fP)\fC [virtual]\fP</h3>
<p>This callback is called when two shapes are found to have intersecting bounding boxes, and are about to be checked for real intersection between their primitives.</p><p>When intersection epsilon values are in use, bounding box intersection testing is done approximately and will trigger the filter callback on boxes that are further from each other than the epsilon length.</p><p>If the callback returns TRUE, the intersection test will be performed. If the callback returns FALSE, the intersection testing will be skipped.</p><p>The API allows only one filter callback.</p>
<h3>void SoIntersectionDetectionAction::addIntersectionCallback (SoIntersectionCB *cb, void *closure = \fCNULL\fP)\fC [virtual]\fP</h3>
<p>Adds a callback to be called when two intersecting primitives are found in the scene.</p><p>If the callback returns ABORT, the intersection detection is aborted. If the callback returns NEXT_SHAPE, the intersection detection between these two shapes are aborted and the action continues checking other shapes. If the callback returns NEXT_PRIMITIVE, the intersection detection testing continues checking the other primitives in these two shapes.</p><p><strong>See also:</strong></p><p><strong>removeIntersectionCallback()</strong></p>
<h3>void SoIntersectionDetectionAction::removeIntersectionCallback (SoIntersectionCB *cb, void *closure = \fCNULL\fP)\fC [virtual]\fP</h3>
<p>Removes a callback set with <strong>addIntersectionCallback()</strong>.</p><p><strong>See also:</strong></p><p><strong>addIntersectionCallback()</strong></p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for Coin from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="SoIntersectingPrimitive.3.html"><span aria-hidden="true">&larr;</span> SoIntersectingPrimitive.3: Struct with collision information.</a></li>
   <li class="next"><a href="SoIntersectionDetectionAction.h.3.html">SoIntersectionDetectionAction.h.3: Sointersectiondetectionaction.h - <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

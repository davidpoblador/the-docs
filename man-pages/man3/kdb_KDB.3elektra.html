<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>kdb_KDB: Opens the session with the key database.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Opens the session with the key database.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="kdb_KDB (3elektra) manual">
  <meta name="twitter:description" content="Opens the session with the key database.">
  <meta name="twitter:image" content="https://www.carta.tech/images/elektra-doc-kdb_KDB-3elektra.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3elektra/kdb_KDB.3elektra.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="kdb_KDB (3elektra) manual" />
  <meta property="og:description" content="Opens the session with the key database." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/elektra-doc-kdb_KDB-3elektra.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">kdb_KDB<small> (3elektra)</small></h1>
        <p class="lead">Opens the session with the key database.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3elektra/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3elektra/kdb_KDB.3elektra.html">
      <span itemprop="name">kdb_KDB: Opens the session with the key database.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/elektra-doc/">
      <span itemprop="name">elektra-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3elektra/kdb_KDB.3elektra.html">
      <span itemprop="name">kdb_KDB: Opens the session with the key database.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;kdb.hpp&gt;</p><h3>Public Member Functions</h3>
<p><strong>KDB</strong> ()</p><p><em>Opens the session with the </em><strong>Key</strong><em> database. </em><strong></strong> <strong>KDB</strong> (<strong>Key</strong> &errorKey)</p><p><em>Opens the session with the </em><strong>Key</strong><em> database. </em><strong></strong> <strong>~KDB</strong> ()  throw ()</p><p>void <strong>open</strong> (<strong>Key</strong> &errorKey)</p><p><em>Opens the session with the </em><strong>Key</strong><em> database. </em><strong></strong> void <strong>close</strong> (<strong>Key</strong> &errorKey)  throw ()</p><p>int <strong>get</strong> (<strong>KeySet</strong> &returned, std::string const &keyname)</p><p><em>Retrieve keys in an atomic and universal way, all other </em><strong>kdbGet()</strong><em> Functions rely on that one. </em><strong></strong> int <strong>get</strong> (<strong>KeySet</strong> &returned, <strong>Key</strong> &parentKey)</p><p><em>Retrieve keys in an atomic and universal way, all other </em><strong>kdbGet()</strong><em> Functions rely on that one. </em><strong></strong> int <strong>set</strong> (<strong>KeySet</strong> &returned, std::string const &keyname)</p><p>int <strong>set</strong> (<strong>KeySet</strong> &returned, <strong>Key</strong> &parentKey)</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>Opens the session with the <strong>Key</strong> database.</p><p>Constructs a class <strong>KDB</strong>.</p><p><strong>Exceptions:</strong></p><p><em>KDBException</em> if database could not be opened</p><p>The first step is to open the default backend. With it system/elektra/mountpoints will be loaded and all needed libraries and mountpoints will be determined. These libraries for backends will be loaded and with it the <strong>KDB</strong><strong> datastructure will be initialized.</strong></p><p>You must always call this method before retrieving or committing any keys to the database. In the end of the program, after using the key database, you must not forget to <strong>kdbClose()</strong>. You can use the atexit () handler for it.</p><p>The pointer to the <strong>KDB</strong><strong> structure returned will be initialized like described above, and it must be passed along on any kdb*() method your application calls.</strong></p><p>Get a <strong>KDB</strong><strong> handle for every thread using elektra. Don't share the handle across threads, and also not the pointer accessing it:</strong></p>
<pre>
thread1
{
        KDB * h;
        h = <strong>kdbOpen</strong>(0);
        // fetch keys and work with them
        kdbClose(h, 0);
}
thread2
{
        KDB * h;
        h = <strong>kdbOpen</strong>(0);
        // fetch keys and work with them
        kdbClose(h, 0);
}

</pre>
<p>You don't need to use the <strong>kdbOpen()</strong> if you only want to manipulate plain in-memory <strong>Key</strong> or <strong>KeySet</strong> objects without any affairs with the backend key database or when your application loads plugins directly.</p><p><strong>Parameters:</strong></p><p><em>errorKey</em> the key which holds errors and warnings which were issued must be given</p><p><strong>See also:</strong></p><p><strong>kdbClose()</strong> to end all affairs to the <strong>Key</strong> database.</p><p><strong>Returns:</strong></p><p>a <strong>KDB</strong> pointer on success</p><p>NULL on failure</p><p>Access to the key database.</p><p><strong>Invariant:</strong></p><p>the object holds an valid connection to the key database or is empty</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>kdb::KDB::KDB ()\fC [inline]\fP</h3>
<p>Opens the session with the <strong>Key</strong> database. Constructs a class <strong>KDB</strong>.</p><p><strong>Exceptions:</strong></p><p><em>KDBException</em> if database could not be opened</p><p>The first step is to open the default backend. With it system/elektra/mountpoints will be loaded and all needed libraries and mountpoints will be determined. These libraries for backends will be loaded and with it the <strong>KDB</strong><strong> datastructure will be initialized.</strong></p><p>You must always call this method before retrieving or committing any keys to the database. In the end of the program, after using the key database, you must not forget to <strong>kdbClose()</strong>. You can use the atexit () handler for it.</p><p>The pointer to the <strong>KDB</strong><strong> structure returned will be initialized like described above, and it must be passed along on any kdb*() method your application calls.</strong></p><p>Get a <strong>KDB</strong><strong> handle for every thread using elektra. Don't share the handle across threads, and also not the pointer accessing it:</strong></p>
<pre>
thread1
{
        KDB * h;
        h = <strong>kdbOpen</strong>(0);
        // fetch keys and work with them
        kdbClose(h, 0);
}
thread2
{
        KDB * h;
        h = <strong>kdbOpen</strong>(0);
        // fetch keys and work with them
        kdbClose(h, 0);
}

</pre>
<p>You don't need to use the <strong>kdbOpen()</strong> if you only want to manipulate plain in-memory <strong>Key</strong> or <strong>KeySet</strong> objects without any affairs with the backend key database or when your application loads plugins directly.</p><p><strong>Parameters:</strong></p><p><em>errorKey</em> the key which holds errors and warnings which were issued must be given</p><p><strong>See also:</strong></p><p><strong>kdbClose()</strong> to end all affairs to the <strong>Key</strong> database.</p><p><strong>Returns:</strong></p><p>a <strong>KDB</strong> pointer on success</p><p>NULL on failure</p>
<h3>kdb::KDB::KDB (\fBKey\fP &errorKey)\fC [inline]\fP</h3>
<p>Opens the session with the <strong>Key</strong> database. Constructs a class <strong>KDB</strong>.</p><p><strong>Parameters:</strong></p><p><em>errorKey</em> is useful if you want to get the warnings in the successful case, when no exception is thrown.</p><p><strong>Exceptions:</strong></p><p><em>KDBException</em> if database could not be opened</p><p>The first step is to open the default backend. With it system/elektra/mountpoints will be loaded and all needed libraries and mountpoints will be determined. These libraries for backends will be loaded and with it the <strong>KDB</strong><strong> datastructure will be initialized.</strong></p><p>You must always call this method before retrieving or committing any keys to the database. In the end of the program, after using the key database, you must not forget to <strong>kdbClose()</strong>. You can use the atexit () handler for it.</p><p>The pointer to the <strong>KDB</strong><strong> structure returned will be initialized like described above, and it must be passed along on any kdb*() method your application calls.</strong></p><p>Get a <strong>KDB</strong><strong> handle for every thread using elektra. Don't share the handle across threads, and also not the pointer accessing it:</strong></p>
<pre>
thread1
{
        KDB * h;
        h = <strong>kdbOpen</strong>(0);
        // fetch keys and work with them
        kdbClose(h, 0);
}
thread2
{
        KDB * h;
        h = <strong>kdbOpen</strong>(0);
        // fetch keys and work with them
        kdbClose(h, 0);
}

</pre>
<p>You don't need to use the <strong>kdbOpen()</strong> if you only want to manipulate plain in-memory <strong>Key</strong> or <strong>KeySet</strong> objects without any affairs with the backend key database or when your application loads plugins directly.</p><p><strong>Parameters:</strong></p><p><em>errorKey</em> the key which holds errors and warnings which were issued must be given</p><p><strong>See also:</strong></p><p><strong>kdbClose()</strong> to end all affairs to the <strong>Key</strong> database.</p><p><strong>Returns:</strong></p><p>a <strong>KDB</strong> pointer on success</p><p>NULL on failure</p>
<h3>kdb::KDB::~KDB ()\fC [inline]\fP</h3>
<p>The destructor closes the database.</p><p>Closes the session with the <strong>Key</strong> database.</p><p>You should call this method when you finished your affairs with the key database. You can manipulate <strong>Key</strong> and <strong>KeySet</strong> objects also after <strong>kdbClose()</strong>. You must not use any kdb* call afterwards. You can implement <strong>kdbClose()</strong> in the atexit() handler.</p><p>This is the counterpart of <strong>kdbOpen()</strong>.</p><p>The handle parameter will be finalized and all resources associated to it will be freed. After a <strong>kdbClose()</strong>, this handle<strong> can't be used anymore, unless it gets initialized again with another call to </strong><strong>kdbOpen()</strong><strong>.</strong></p><p><strong>See also:</strong></p><p><strong>kdbOpen()</strong></p><p><strong>Parameters:</strong></p><p><em>handle</em> contains internal information of <strong>opened </strong> key database</p><p><em>errorKey</em> the key which holds error information</p><p><strong>Returns:</strong></p><p>0 on success</p><p>-1 on NULL pointer</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>void kdb::KDB::close (\fBKey\fP &errorKey)\fC [inline]\fP</h3>
<p>Open the database.</p><p>The return value does not matter because its only a null pointer check.</p><p><strong>Parameters:</strong></p><p><em>errorKey</em> is useful if you want to get the warnings</p><p>Closes the session with the <strong>Key</strong> database.</p><p>You should call this method when you finished your affairs with the key database. You can manipulate <strong>Key</strong> and <strong>KeySet</strong> objects also after <strong>kdbClose()</strong>. You must not use any kdb* call afterwards. You can implement <strong>kdbClose()</strong> in the atexit() handler.</p><p>This is the counterpart of <strong>kdbOpen()</strong>.</p><p>The handle parameter will be finalized and all resources associated to it will be freed. After a <strong>kdbClose()</strong>, this handle<strong> can't be used anymore, unless it gets initialized again with another call to </strong><strong>kdbOpen()</strong><strong>.</strong></p><p><strong>See also:</strong></p><p><strong>kdbOpen()</strong></p><p><strong>Parameters:</strong></p><p><em>handle</em> contains internal information of <strong>opened </strong> key database</p><p><em>errorKey</em> the key which holds error information</p><p><strong>Returns:</strong></p><p>0 on success</p><p>-1 on NULL pointer</p>
<h3>int kdb::KDB::get (\fBKeySet\fP &returned, std::string const &keyname)\fC [inline]\fP</h3>
<p>Retrieve keys in an atomic and universal way, all other <strong>kdbGet()</strong> Functions rely on that one. Get all keys below keyname inside returned.</p><p>The returned <strong>KeySet</strong> must be initialized. The returned<strong> </strong><strong>KeySet</strong><strong> may already contain some keys. The new retrieved keys will be appended using </strong><strong>ksAppendKey()</strong><strong>.</strong></p><p>It will fully retrieve all keys under the parentKey folder, with all subfolders and their children.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Example</h2>
        <div class="sectioncontent">
<p>This example demonstrates the typical usecase within an application without updating.</p><p><strong>Example:</strong></p>
<pre>
KeySet *myConfig = <strong>ksNew</strong>(0);
Key *key = keyNew("system/sw/MyApp",KEY_END);
KDB *handle = kdbOpen(key);

kdbGet(handle, myConfig, key);

keySetName(key, "user/sw/MyApp");
kdbGet(handle, myConfig, key);

// check for errors in key
keyDel(key);

key = ksLookupByName(myConfig,"/sw/MyApp/key", 0);
// check if key is not 0 and work with it...

ksDel (myConfig); // delete the in-memory configuration


// maybe you want kdbSet() myConfig here

kdbClose(handle, 0); // no more affairs with the key database.

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Details</h2>
        <div class="sectioncontent">
<p>When no backend could be found (e.g. no backend mounted) the default backend will be used.</p><p>If you pass NULL on any parameter <strong>kdbGet()</strong> will fail immediately without doing anything.</p><p>When a backend fails <strong>kdbGet()</strong> will return -1 without any changes to one of the parameter.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Updating</h2>
        <div class="sectioncontent">
<p>In the first run of kdbGet all keys are retrieved. On subsequent calls only the keys are retrieved where something was changed inside the key database. The other keys stay unchanged in the keyset, even when they were manipulated.</p><p>It is your responsibility to save the original keyset if you need it afterwards.</p><p>If you must get the same keyset again, e.g. in another thread you need to open a second handle to the key database using <strong>kdbOpen()</strong>.</p><p><strong>Parameters:</strong></p><p><em>handle</em> contains internal information of <strong>opened </strong> key database</p><p><em>parentKey</em> parent key holds the information which keys should be get - invalid name gets all keys</p><p><em>ks</em> the (pre-initialized) <strong>KeySet</strong> returned with all keys found will not be changed on error or if no update is required</p><p><strong>See also:</strong></p><p><strong>ksLookupByName()</strong> for powerful lookups after the <strong>KeySet</strong> was retrieved</p><p><strong>Returns:</strong></p><p>1 if the keys were retrieved successfully</p><p>0 if there was no update - no changes are made to the keyset then</p><p>-1 on failure - no changes are made to the keyset then</p>
<pre>
#include &lt;kdb.hpp&gt;

#include &lt;keyio.hpp&gt;

using namespace kdb;

int main()
{
        KeySet config;
        KDB kdb;
        kdb.get(config, "/sw/MyApp");

        Key k = config.lookup("/sw/MyApp/mykey");
        if (k)
        {
                std::cout &lt;&lt; k &lt;&lt; " is " &lt;&lt; k.get&lt;int&gt;() &lt;&lt; std::endl;
        }
        else
        {
                std::cerr &lt;&lt; "No key found" &lt;&lt; std::endl;
                return 1;
        }
}
</pre>
<p><strong>Parameters:</strong></p><p><em>returned</em> the keyset where the keys will be in</p><p><em>keyname</em> the root keyname which should be used to get keys below it</p><p><strong>Return values:</strong></p><p><em>0</em> if no key was updated</p><p><em>1</em> if user or system keys were updated</p><p><em>2</em> if user and system keys were updated</p><p><strong>Exceptions:</strong></p><p><em>KDBException</em> if there were problems with the database</p><p><strong>See also:</strong></p><p><strong>KDB::get</strong> (<strong>KeySet</strong> & returned, <strong>Key</strong> & parentKey)</p><h3>int kdb::KDB::get (\fBKeySet\fP &returned, \fBKey\fP &parentKey)\fC [inline]\fP</h3>
<p>Retrieve keys in an atomic and universal way, all other <strong>kdbGet()</strong> Functions rely on that one. Get all keys below parentKey inside returned.</p><p>The returned <strong>KeySet</strong> must be initialized. The returned<strong> </strong><strong>KeySet</strong><strong> may already contain some keys. The new retrieved keys will be appended using </strong><strong>ksAppendKey()</strong><strong>.</strong></p><p>It will fully retrieve all keys under the parentKey folder, with all subfolders and their children.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Example</h2>
        <div class="sectioncontent">
<p>This example demonstrates the typical usecase within an application without updating.</p><p><strong>Example:</strong></p>
<pre>
KeySet *myConfig = <strong>ksNew</strong>(0);
Key *key = keyNew("system/sw/MyApp",KEY_END);
KDB *handle = kdbOpen(key);

kdbGet(handle, myConfig, key);

keySetName(key, "user/sw/MyApp");
kdbGet(handle, myConfig, key);

// check for errors in key
keyDel(key);

key = ksLookupByName(myConfig,"/sw/MyApp/key", 0);
// check if key is not 0 and work with it...

ksDel (myConfig); // delete the in-memory configuration


// maybe you want kdbSet() myConfig here

kdbClose(handle, 0); // no more affairs with the key database.

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Details</h2>
        <div class="sectioncontent">
<p>When no backend could be found (e.g. no backend mounted) the default backend will be used.</p><p>If you pass NULL on any parameter <strong>kdbGet()</strong> will fail immediately without doing anything.</p><p>When a backend fails <strong>kdbGet()</strong> will return -1 without any changes to one of the parameter.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Updating</h2>
        <div class="sectioncontent">
<p>In the first run of kdbGet all keys are retrieved. On subsequent calls only the keys are retrieved where something was changed inside the key database. The other keys stay unchanged in the keyset, even when they were manipulated.</p><p>It is your responsibility to save the original keyset if you need it afterwards.</p><p>If you must get the same keyset again, e.g. in another thread you need to open a second handle to the key database using <strong>kdbOpen()</strong>.</p><p><strong>Parameters:</strong></p><p><em>handle</em> contains internal information of <strong>opened </strong> key database</p><p><em>parentKey</em> parent key holds the information which keys should be get - invalid name gets all keys</p><p><em>ks</em> the (pre-initialized) <strong>KeySet</strong> returned with all keys found will not be changed on error or if no update is required</p><p><strong>See also:</strong></p><p><strong>ksLookupByName()</strong> for powerful lookups after the <strong>KeySet</strong> was retrieved</p><p><strong>Returns:</strong></p><p>1 if the keys were retrieved successfully</p><p>0 if there was no update - no changes are made to the keyset then</p><p>-1 on failure - no changes are made to the keyset then</p><p><strong>Parameters:</strong></p><p><em>returned</em> the keyset where the keys will be in</p><p><em>parentKey</em> the parentKey of returned</p><p><strong>Return values:</strong></p><p><em>0</em> if no key was updated</p><p><em>1</em> if user or system keys were updated</p><p><em>2</em> if user and system keys were updated</p><p><strong>Exceptions:</strong></p><p><em>KDBException</em> if there were problems with the database</p><h3>void kdb::KDB::open (\fBKey\fP &errorKey)\fC [inline]\fP</h3>
<p>Opens the session with the <strong>Key</strong> database. Open the database</p><p><strong>Parameters:</strong></p><p><em>errorKey</em> is useful if you want to get the warnings in the successful case, when no exception is thrown.</p><p>The first step is to open the default backend. With it system/elektra/mountpoints will be loaded and all needed libraries and mountpoints will be determined. These libraries for backends will be loaded and with it the <strong>KDB</strong><strong> datastructure will be initialized.</strong></p><p>You must always call this method before retrieving or committing any keys to the database. In the end of the program, after using the key database, you must not forget to <strong>kdbClose()</strong>. You can use the atexit () handler for it.</p><p>The pointer to the <strong>KDB</strong><strong> structure returned will be initialized like described above, and it must be passed along on any kdb*() method your application calls.</strong></p><p>Get a <strong>KDB</strong><strong> handle for every thread using elektra. Don't share the handle across threads, and also not the pointer accessing it:</strong></p>
<pre>
thread1
{
        KDB * h;
        h = <strong>kdbOpen</strong>(0);
        // fetch keys and work with them
        kdbClose(h, 0);
}
thread2
{
        KDB * h;
        h = <strong>kdbOpen</strong>(0);
        // fetch keys and work with them
        kdbClose(h, 0);
}

</pre>
<p>You don't need to use the <strong>kdbOpen()</strong> if you only want to manipulate plain in-memory <strong>Key</strong> or <strong>KeySet</strong> objects without any affairs with the backend key database or when your application loads plugins directly.</p><p><strong>Parameters:</strong></p><p><em>errorKey</em> the key which holds errors and warnings which were issued must be given</p><p><strong>See also:</strong></p><p><strong>kdbClose()</strong> to end all affairs to the <strong>Key</strong> database.</p><p><strong>Returns:</strong></p><p>a <strong>KDB</strong> pointer on success</p><p>NULL on failure</p>
<h3>int kdb::KDB::set (\fBKeySet\fP &returned, std::string const &keyname)\fC [inline]\fP</h3>
<p>Set all keys below keyname.</p><p>If the keyname of the parentKey is invalid (e.g. empty) all keys will be set.</p><p>Set keys in an atomic and universal way.</p><p>All other kdbSet Functions rely on that one.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">parentKey</h2>
        <div class="sectioncontent">
<p>With parentKey you can only store a part of the given keyset.</p>
<pre>
KeySet *ks = <strong>ksNew</strong>(0);
Key *parentKey = keyNew("user/app/myapp/default", KEY_END);
kdbGet (h, ks, parentKey));

//now only set everything below user
if (kdbSet (h, ks, parentKey) == -1)
{
        // in parentKey you can check the error cause
        // ksCurrent(ks) is the faulty key
}

ksDel (ks);
</pre>
<p>If you pass a parentKey without a name the whole keyset will be set in an atomic way.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Update</h2>
        <div class="sectioncontent">
<p>Each key is checked with <strong>keyNeedSync()</strong> before being actually committed. So only changed keys are updated. If no key of a backend needs to be synced any affairs to backends omitted and 0 is returned.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Error Situations</h2>
        <div class="sectioncontent">
<p>If some error occurs, <strong>kdbSet()</strong> will stop. In this situation the <strong>KeySet</strong> internal cursor will be set on the key that generated the error.</p><p>None of the keys are actually commited.</p><p>You should present the error message to the user and let the user decide what to do. Possible solutions are:</p>
<dl class='dl-vertical'>
  <dt>
    *
  </dt>
  <dd>
    <p>repeat the same kdbSet (for temporary errors)</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>remove the key and set it again (for validation or type errors)</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>change the value and try it again (for validation errors)</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>do a kdbGet and then (for conflicts ...)</p>
  </dd>
  <dt>
      &bull;
  </dt>
  <dd>
    <p>set the same keyset again (in favour of what was set by this user)</p>
  </dd>
  <dt>
      &bull;
  </dt>
  <dd>
    <p>drop the old keyset (in favour of what was set elsewhere)</p>
  </dd>

</dl>
<ul>
<li><p>export the configuration into a file (for unresolvable errors)</p></li>
</ul><p><strong>Example of how this method can be used:</strong></p>
<pre>
int i;
KeySet *ks;  // the KeySet I want to set
// fill ks with some keys
for (i=0; i&lt; NR_OF_TRIES; i++) // limit to NR_OF_TRIES tries
{
        ret=kdbSet(handle, ks, parentKey);
        if (ret == -1)
        {
                // We got an error. Warn user.
                Key *problemKey = ksCurrent(ks);
                // parentKey has the errorInformation
                // problemKey is the faulty key (may be null)
                int userInput = showElektraErrorDialog (parentKey, problemKey);
                switch (userInput)
                {
                case INPUT_REPEAT: continue;
                case INPUT_REMOVE: ksLookup (ks, parentKey, KDB_O_POP); break;
                ...
                }
        }
}

</pre>
<p><strong>Parameters:</strong></p><p><em>handle</em> contains internal information of <strong>opened </strong> key database</p><p><em>ks</em> a <strong>KeySet</strong> which should contain changed keys, otherwise nothing is done</p><p><em>parentKey</em> holds the information below which key keys should be set, see above</p><p><strong>Returns:</strong></p><p>1 on success</p><p>0 if nothing had to be done</p><p>-1 on failure</p><p><strong>See also:</strong></p><p><strong>keyNeedSync()</strong>, <strong>ksNext()</strong>, <strong>ksCurrent()</strong></p><p><strong>Return values:</strong></p><p><em>0</em> if no key was updated</p><p><em>1</em> if user or system keys were updated</p><p><em>2</em> if user and system keys were updated</p><p><strong>Parameters:</strong></p><p><em>returned</em> the keyset where the keys will be in</p><p><em>keyname</em> the keyname below the names should be set</p><p><strong>Exceptions:</strong></p><p><em>KDBException</em> if there were problems with the database</p><h3>int kdb::KDB::set (\fBKeySet\fP &returned, \fBKey\fP &parentKey)\fC [inline]\fP</h3>
<p>Set all keys below parentKey.</p><p>If the keyname of the parentKey is invalid (e.g. empty) all keys will be set.</p><p>Set keys in an atomic and universal way.</p><p>All other kdbSet Functions rely on that one.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">parentKey</h2>
        <div class="sectioncontent">
<p>With parentKey you can only store a part of the given keyset.</p>
<pre>
KeySet *ks = <strong>ksNew</strong>(0);
Key *parentKey = keyNew("user/app/myapp/default", KEY_END);
kdbGet (h, ks, parentKey));

//now only set everything below user
if (kdbSet (h, ks, parentKey) == -1)
{
        // in parentKey you can check the error cause
        // ksCurrent(ks) is the faulty key
}

ksDel (ks);
</pre>
<p>If you pass a parentKey without a name the whole keyset will be set in an atomic way.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Update</h2>
        <div class="sectioncontent">
<p>Each key is checked with <strong>keyNeedSync()</strong> before being actually committed. So only changed keys are updated. If no key of a backend needs to be synced any affairs to backends omitted and 0 is returned.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Error Situations</h2>
        <div class="sectioncontent">
<p>If some error occurs, <strong>kdbSet()</strong> will stop. In this situation the <strong>KeySet</strong> internal cursor will be set on the key that generated the error.</p><p>None of the keys are actually commited.</p><p>You should present the error message to the user and let the user decide what to do. Possible solutions are:</p>
<dl class='dl-vertical'>
  <dt>
    *
  </dt>
  <dd>
    <p>repeat the same kdbSet (for temporary errors)</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>remove the key and set it again (for validation or type errors)</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>change the value and try it again (for validation errors)</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>do a kdbGet and then (for conflicts ...)</p>
  </dd>
  <dt>
      &bull;
  </dt>
  <dd>
    <p>set the same keyset again (in favour of what was set by this user)</p>
  </dd>
  <dt>
      &bull;
  </dt>
  <dd>
    <p>drop the old keyset (in favour of what was set elsewhere)</p>
  </dd>

</dl>
<ul>
<li><p>export the configuration into a file (for unresolvable errors)</p></li>
</ul><p><strong>Example of how this method can be used:</strong></p>
<pre>
int i;
KeySet *ks;  // the KeySet I want to set
// fill ks with some keys
for (i=0; i&lt; NR_OF_TRIES; i++) // limit to NR_OF_TRIES tries
{
        ret=kdbSet(handle, ks, parentKey);
        if (ret == -1)
        {
                // We got an error. Warn user.
                Key *problemKey = ksCurrent(ks);
                // parentKey has the errorInformation
                // problemKey is the faulty key (may be null)
                int userInput = showElektraErrorDialog (parentKey, problemKey);
                switch (userInput)
                {
                case INPUT_REPEAT: continue;
                case INPUT_REMOVE: ksLookup (ks, parentKey, KDB_O_POP); break;
                ...
                }
        }
}

</pre>
<p><strong>Parameters:</strong></p><p><em>handle</em> contains internal information of <strong>opened </strong> key database</p><p><em>ks</em> a <strong>KeySet</strong> which should contain changed keys, otherwise nothing is done</p><p><em>parentKey</em> holds the information below which key keys should be set, see above</p><p><strong>Returns:</strong></p><p>1 on success</p><p>0 if nothing had to be done</p><p>-1 on failure</p><p><strong>See also:</strong></p><p><strong>keyNeedSync()</strong>, <strong>ksNext()</strong>, <strong>ksCurrent()</strong></p><p><strong>Return values:</strong></p><p><em>0</em> if no key was updated</p><p><em>1</em> if user or system keys were updated</p><p><em>2</em> if user and system keys were updated</p><p><strong>Parameters:</strong></p><p><em>returned</em> the keyset where the keys are passed to the user</p><p><em>parentKey</em> the parentKey of returned</p><p><strong>Exceptions:</strong></p><p><em>KDBException</em> if there were problems with the database</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for Elektra from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="kdb_Context.3elektra.html"><span aria-hidden="true">&larr;</span> kdb_Context.3elektra: Provides a context for configuration.</a></li>
   <li class="next"><a href="kdb_KeySet.3elektra.html">kdb_KeySet.3elektra: A keyset holds together a set of keys. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

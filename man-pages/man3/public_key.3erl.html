<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>public_key: Api module for public key infrastructure.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Api module for public key infrastructure.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="public_key (3erl) manual">
  <meta name="twitter:description" content="Api module for public key infrastructure.">
  <meta name="twitter:image" content="https://www.carta.tech/images/erlang-manpages-public_key-3erl.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3erl/public_key.3erl.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="public_key (3erl) manual" />
  <meta property="og:description" content="Api module for public key infrastructure." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/erlang-manpages-public_key-3erl.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">public_key<small> (3erl)</small></h1>
        <p class="lead">Api module for public key infrastructure.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/public_key.3erl.html">
      <span itemprop="name">public_key: Api module for public key infrastructure.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/erlang-manpages/">
      <span itemprop="name">erlang-manpages</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/public_key.3erl.html">
      <span itemprop="name">public_key: Api module for public key infrastructure.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module provides functions to handle public key infrastructure. It can encode/decode different file formats (PEM, openssh), sign and verify digital signatures and validate certificate paths and certificate revocation lists.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PUBLIC_KEY</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>public_key requires the crypto and asn1 applications, the latter since R16 (hopefully the runtime dependency on asn1 will be removed again in the future).</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>Supports RFC 5280  - Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>Supports  PKCS-1  - RSA Cryptography Standard</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>Supports  DSS- Digital Signature Standard (DSA - Digital Signature Algorithm)</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>Supports  PKCS-3  - Diffie-Hellman Key Agreement Standard</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>Supports  PKCS-5 - Password-Based Cryptography Standard</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>Supports  PKCS-8 - Private-Key Information Syntax Standard</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>Supports  PKCS-10 - Certification Request Syntax Standard</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COMMON DATA TYPES </h2>
        <div class="sectioncontent">
<p><strong></strong> Note:</p><p>All records used in this manual are generated from ASN.1 specifications and are documented in the User's Guide. See <strong>Public key records</strong> and <strong>X.509 Certificate records</strong>.</p><p>Use the following include directive to get access to the records and constant macros described here and in the User's Guide.</p>
<pre>
 -include_lib("public_key/include/public_key.hrl").
</pre>
<p><em>Data Types </em></p>
<pre>
oid() - Object Identifier, a tuple of integers as generated by the ASN1 compiler.
</pre>

<pre>
boolean() = true | false
</pre>

<pre>
string() = [bytes()]
</pre>

<pre>
der_encoded() = binary()
</pre>

<pre>
pki_asn1_type() = 'Certificate' | 'RSAPrivateKey'| 'RSAPublicKey' |
    'DSAPrivateKey' | 'DSAPublicKey' | 'DHParameter' |
    'SubjectPublicKeyInfo' | 'PrivateKeyInfo' |
    'CertificationRequest' | 'ECPrivateKey' | 'EcpkParameters'
</pre>

<pre>
pem_entry () = {pki_asn1_type(), binary(), %% DER or encrypted DER
    not_encrypted | cipher_info()}
</pre>

<pre>
cipher_info()  =  {"RC2-CBC | "DES-CBC" | "DES-EDE3-CBC",
    crypto:<strong>rand_bytes</strong>(8) | {#'PBEParameter{}, digest_type()} |#'PBES2-params'{}}
</pre>

<pre>
public_key()  = rsa_public_key() | dsa_public_key() | ec_public_key()
</pre>

<pre>
private_key() = rsa_private_key() | dsa_private_key() | ec_private_key()
</pre>

<pre>
rsa_public_key()  = #'RSAPublicKey'{}
</pre>

<pre>
rsa_private_key() = #'RSAPrivateKey'{}
</pre>

<pre>
dsa_public_key()  = {integer(),  #'Dss-Parms'{}}
</pre>

<pre>
dsa_private_key() = #'DSAPrivateKey'{}
</pre>

<pre>
ec_public_key()   = {#'ECPoint'{}, #'EcpkParameters'{} |
    {namedCurve, oid()}}
</pre>

<pre>
ec_private_key()  = #'ECPrivateKey'{}
</pre>

<pre>
public_crypt_options() = [{rsa_pad, rsa_padding()}].
</pre>

<pre>
rsa_padding() =  'rsa_pkcs1_padding' | 'rsa_pkcs1_oaep_padding' |
    'rsa_no_padding'
</pre>

<pre>
digest_type() - Union of below digest types
</pre>

<pre>
rsa_digest_type()   = 'md5' | 'sha' | 'sha224' | 'sha256' | 'sha384' |
    'sha512'
</pre>

<pre>
dss_digest_type()   = 'sha'
</pre>

<pre>
ecdsa_digest_type() = 'sha'| 'sha224' | 'sha256' | 'sha384' | 'sha512'
</pre>

<pre>
crl_reason()  = unspecified | keyCompromise | cACompromise |
    affiliationChanged | superseded | cessationOfOperation |
    certificateHold | privilegeWithdrawn | aACompromise
</pre>

<pre>
ssh_file()  = openssh_public_key | rfc4716_public_key | known_hosts |
    auth_keys
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">
<p><strong></strong> compute_key(OthersKey, MyKey)-&gt;</p><p><strong></strong> compute_key(OthersKey, MyKey, Params)-&gt;</p><p>Types:</p><p>OthersKey = #'ECPoint'{} | binary(), MyKey = #'ECPrivateKey'{} | binary()</p><p>Params = #'DHParameter'{}</p><p>Compute shared secret</p><p><strong></strong> decrypt_private(CipherText, Key) -&gt; binary()</p><p><strong></strong> decrypt_private(CipherText, Key, Options) -&gt; binary()</p><p>Types:</p><p>CipherText = binary()</p><p>Key = rsa_private_key()</p><p>Options = public_crypt_options()</p><p>Public key decryption using the private key. See also <strong>crypto:private_decrypt/4</strong></p><p><strong></strong> decrypt_public(CipherText, Key) - &gt; binary()</p><p><strong></strong> decrypt_public(CipherText, Key, Options) - &gt; binary()</p><p>Types:</p><p>CipherText = binary()</p><p>Key = rsa_public_key()</p><p>Options = public_crypt_options()</p><p>Public key decryption using the public key. See also <strong>crypto:public_decrypt/4</strong></p><p><strong></strong> der_decode(Asn1type, Der) -&gt; term()</p><p>Types:</p><p>Asn1Type = atom()</p><p> ASN.1 type present in the public_key applications asn1 specifications.</p><p>Der = der_encoded()</p><p>Decodes a public key ASN.1 DER encoded entity.</p><p><strong></strong> der_encode(Asn1Type, Entity) -&gt; der_encoded()</p><p>Types:</p><p>Asn1Type = atom()</p><p> Asn1 type present in the public_key applications ASN.1 specifications.</p><p>Entity = term()</p><p>The erlang representation of <em>Asn1Type</em></p><p>Encodes a public key entity with ASN.1 DER encoding.</p><p><strong></strong> generate_key(Params) -&gt; {Public::binary(), Private::binary()} | #'ECPrivateKey'{}</p><p>Types:</p><p> Params = #'DHParameter'{} | {namedCurve, oid()} | #'ECParameters'{}</p><p>Generates a new keypair</p><p><strong></strong> pem_decode(PemBin) -&gt; [pem_entry()]</p><p>Types:</p><p>PemBin = binary()</p><p>Example {ok, PemBin} = file:read_file("cert.pem").</p><p>Decode PEM binary data and return entries as ASN.1 DER encoded entities.</p><p><strong></strong> pem_encode(PemEntries) -&gt; binary()</p><p>Types:</p><p> PemEntries = [pem_entry()]</p><p>Creates a PEM binary</p><p><strong></strong> pem_entry_decode(PemEntry) -&gt; term()</p><p><strong></strong> pem_entry_decode(PemEntry, Password) -&gt; term()</p><p>Types:</p><p> PemEntry = pem_entry()</p><p> Password = string()</p><p>Decodes a PEM entry. pem_decode/1 returns a list of PEM entries. Note that if the PEM entry is of type 'SubjectPublickeyInfo' it will be further decoded to an rsa_public_key() or dsa_public_key().</p><p><strong></strong> pem_entry_encode(Asn1Type, Entity) -&gt; pem_entry()</p><p><strong></strong> pem_entry_encode(Asn1Type, Entity, {CipherInfo, Password}) -&gt; pem_entry()</p><p>Types:</p><p>Asn1Type = pki_asn1_type()</p><p>Entity = term()</p><p>The Erlang representation of <em>Asn1Type</em>. If <em>Asn1Type</em> is 'SubjectPublicKeyInfo' then <em>Entity</em> must be either an rsa_public_key() or a dsa_public_key() and this function will create the appropriate 'SubjectPublicKeyInfo' entry.</p><p>CipherInfo = cipher_info()</p><p>Password = string()</p><p>Creates a PEM entry that can be feed to pem_encode/1.</p><p><strong></strong> encrypt_private(PlainText, Key) -&gt; binary()</p><p>Types:</p><p>PlainText = binary()</p><p>Key = rsa_private_key()</p><p>Public key encryption using the private key. See also <strong>crypto:private_encrypt/4</strong></p><p><strong></strong> encrypt_public(PlainText, Key) -&gt; binary()</p><p>Types:</p><p>PlainText = binary()</p><p>Key = rsa_public_key()</p><p>Public key encryption using the public key. See also <strong>crypto:public_encrypt/4</strong></p><p><strong></strong> pkix_decode_cert(Cert, otp|plain) -&gt; #'Certificate'{} | #'OTPCertificate'{}</p><p>Types:</p><p>Cert = der_encoded()</p><p>Decodes an ASN.1 DER encoded PKIX certificate. The otp option will use the customized ASN.1 specification OTP-PKIX.asn1 for decoding and also recursively decode most of the standard parts.</p><p><strong></strong> pkix_encode(Asn1Type, Entity, otp | plain) -&gt; der_encoded()</p><p>Types:</p><p>Asn1Type = atom()</p><p>The ASN.1 type can be 'Certificate', 'OTPCertificate' or a subtype of either .</p><p>Entity = #'Certificate'{} | #'OTPCertificate'{} | a valid subtype</p><p>DER encodes a PKIX x509 certificate or part of such a certificate. This function must be used for encoding certificates or parts of certificates that are decoded/created in the otp format, whereas for the plain format this function will directly call der_encode/2.</p><p><strong></strong> pkix_is_issuer(Cert, IssuerCert) -&gt; boolean()</p><p>Types:</p><p>Cert = der_encode() | #'OTPCertificate'{}</p><p>IssuerCert = der_encode() | #'OTPCertificate'{}</p><p>Checks if <em>IssuerCert</em> issued <em>Cert</em></p><p><strong></strong> pkix_is_fixed_dh_cert(Cert) -&gt; boolean()</p><p>Types:</p><p>Cert = der_encode() | #'OTPCertificate'{}</p><p>Checks if a Certificate is a fixed Diffie-Hellman Cert.</p><p><strong></strong> pkix_is_self_signed(Cert) -&gt; boolean()</p><p>Types:</p><p>Cert = der_encode() | #'OTPCertificate'{}</p><p>Checks if a Certificate is self signed.</p><p><strong></strong> pkix_issuer_id(Cert, IssuedBy) -&gt; {ok, IssuerID} | {error, Reason}</p><p>Types:</p><p>Cert = der_encode() | #'OTPCertificate'{}</p><p>IssuedBy = self | other</p><p>IssuerID = {integer(), {rdnSequence, [#'AttributeTypeAndValue'{}]}}</p><p>The issuer id consists of the serial number and the issuers name.</p><p>Reason = term()</p><p>Returns the issuer id.</p><p><strong></strong> pkix_normalize_name(Issuer) -&gt; Normalized</p><p>Types:</p><p>Issuer = {rdnSequence,[#'AttributeTypeAndValue'{}]}</p><p>Normalized = {rdnSequence, [#'AttributeTypeAndValue'{}]}</p><p>Normalizes a issuer name so that it can be easily compared to another issuer name.</p><p><strong></strong> pkix_path_validation(TrustedCert, CertChain, Options) -&gt; {ok, {PublicKeyInfo, PolicyTree}} | {error, {bad_cert, Reason}}</p><p>Types:</p><p> TrustedCert = #'OTPCertificate'{} | der_encode() | atom()</p><p>Normally a trusted certificate but it can also be a path validation error that can be discovered while constructing the input to this function and that should be run through the <em>verify_fun</em>. For example <em>unknown_ca </em> or <em>selfsigned_peer </em></p><p> CertChain = [der_encode()]</p><p>A list of DER encoded certificates in trust order ending with the peer certificate.</p><p> Options = proplists:proplist()</p><p>PublicKeyInfo = {?'rsaEncryption' | ?'id-dsa', rsa_public_key() | integer(), 'NULL' | 'Dss-Parms'{}}</p><p> PolicyTree = term()</p><p>At the moment this will always be an empty list as Policies are not currently supported</p><p> Reason = cert_expired | invalid_issuer | invalid_signature | name_not_permitted | missing_basic_constraint | invalid_key_usage | {revoked, crl_reason()} | atom()</p><p>Performs a basic path validation according to RFC 5280. However CRL validation is done separately by <strong>pkix_crls_validate/3 </strong> and should be called from the supplied <em>verify_fun</em></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{verify_fun, fun()}: The fun should be defined as:</p>
  </dd>

</dl>

<pre>
fun(OtpCert :: #'OTPCertificate'{},
    Event :: {bad_cert, Reason :: atom() | {revoked, atom()}} |
             {extension, #'Extension'{}},
    InitialUserState :: term()) -&gt;
	{valid, UserState :: term()} |
	{valid_peer, UserState :: term()} |
	{fail, Reason :: term()} |
	{unknown, UserState :: term()}.

</pre>
<p>If the verify callback fun returns {fail, Reason}, the verification process is immediately stopped. If the verify callback fun returns {valid, UserState}, the verification process is continued, this can be used to accept specific path validation errors such as <em>selfsigned_peer</em> as well as verifying application specific extensions. If called with an extension unknown to the user application the return value {unknown, UserState} should be used.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{max_path_length, integer()}:  The <em>max_path_length</em> is the maximum number of non-self-issued intermediate certificates that may follow the peer certificate in a valid certification path. So if <em>max_path_length</em> is 0 the PEER must be signed by the trusted ROOT-CA directly, if 1 the path can be PEER, CA, ROOT-CA, if it is 2 PEER, CA, CA, ROOT-CA and so on.</p>
  </dd>

</dl>
<p>Possible reasons for a bad certificate are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>cert_expired: The certificate is no longer valid as its expiration date has passed.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>invalid_issuer: The certificate issuer name does not match the name of the issuer certificate in the chain.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>invalid_signature: The certificate was not signed by its issuer certificate in the chain.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>name_not_permitted: Invalid Subject Alternative Name extension.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>missing_basic_constraint: Certificate, required to have the basic constraints extension, does not have a basic constraints extension.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>invalid_key_usage: Certificate key is used in an invalid way according to the key usage extension.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{revoked, crl_reason()}: Certificate has been revoked.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>atom(): Application specific error reason that should be checked by the verify_fun</p>
  </dd>

</dl>
<p><strong></strong> pkix_crls_validate(OTPCertificate, DPAndCRLs, Options) -&gt; CRLStatus()</p><p>Types:</p><p> OTPCertificate = #'OTPCertificate'{}</p><p> DPAndCRLs = [{DP::#'DistributionPoint'{}, {DerCRL::der_encoded(), CRL::#'CertificateList'{}}}]</p><p> Options = proplists:proplist()</p><p> CRLStatus() = valid | {bad_cert, revocation_status_undetermined} | {bad_cert, {revoked, crl_reason()}}</p><p>Performs CRL validation. It is intended to be called from the verify fun of <strong> pkix_path_validation/3 </strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{update_crl, fun()}: The fun has the following type spec:</p>
  </dd>

</dl>

<pre>
 fun(#'DistributionPoint'{}, #'CertificateList'{}) -&gt;
        #'CertificateList'{}
</pre>
<p>The fun should use the information in the distribution point to acesses the lates possible version of the CRL. If this fun is not specified public_key will use the default implementation:</p>
<pre>
 fun(_DP, CRL) -&gt; CRL end
</pre>

<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{issuer_fun, fun()}: The fun has the following type spec:</p>
  </dd>

</dl>

<pre>
fun(#'DistributionPoint'{}, #'CertificateList'{},
    {rdnSequence,[#'AttributeTypeAndValue'{}]}, term()) -&gt;
	{ok, #'OTPCertificate'{}, [der_encoded]}
</pre>
<p>The fun should return the root certificate and certificate chain that has signed the CRL.</p>
<pre>
 fun(DP, CRL, Issuer, UserState) -&gt; {ok, RootCert, CertChain}
</pre>
<p><strong></strong> pkix_sign(#'OTPTBSCertificate'{}, Key) -&gt; der_encode()</p><p>Types:</p><p>Key = rsa_public_key() | dsa_public_key()</p><p>Signs a 'OTPTBSCertificate'. Returns the corresponding der encoded certificate.</p><p><strong></strong> pkix_sign_types(AlgorithmId) -&gt; {DigestType, SignatureType}</p><p>Types:</p><p>AlgorithmId = oid()</p><p>Signature oid from a certificate or a certificate revocation list</p><p>DigestType = rsa_digest_type() | dss_digest_type()</p><p>SignatureType = rsa | dsa</p><p>Translates signature algorithm oid to erlang digest and signature types.</p><p><strong></strong> pkix_verify(Cert, Key) -&gt; boolean()</p><p>Types:</p><p>Cert = der_encode()</p><p>Key = rsa_public_key() | dsa_public_key()</p><p>Verify PKIX x.509 certificate signature.</p><p><strong></strong> sign(Msg, DigestType, Key) -&gt; binary()</p><p>Types:</p><p>Msg = binary() | {digest,binary()}</p><p>The msg is either the binary "plain text" data to be signed or it is the hashed value of "plain text" i.e. the digest.</p><p>DigestType = rsa_digest_type() | dss_digest_type() | ecdsa_digest_type()</p><p>Key = rsa_private_key() | dsa_private_key() | ec_private_key()</p><p>Creates a digital signature.</p><p><strong></strong> ssh_decode(SshBin, Type) -&gt; [{public_key(), Attributes::list()}]</p><p>Types:</p><p>SshBin = binary()</p><p>Example {ok, SshBin} = file:read_file("known_hosts").</p><p> Type = public_key | ssh_file()</p><p>If <em>Type</em> is <em>public_key</em> the binary may be either a rfc4716 public key or a openssh public key.</p><p>Decodes a ssh file-binary. In the case of know_hosts or auth_keys the binary may include one or more lines of the file. Returns a list of public keys and their attributes, possible attribute values depends on the file type represented by the binary.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>rfc4716 attributes - see RFC 4716: {headers, [{string(), utf8_string()}]}</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>auth_key attributes - see man sshd : {comment, string()}{options, [string()]}{bits, integer()} - In ssh version 1 files</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>known_host attributes - see man sshd: {hostnames, [string()]}{comment, string()}{bits, integer()} - In ssh version 1 files</p>
  </dd>

</dl>
<p><strong></strong> ssh_encode([{Key, Attributes}], Type) -&gt; binary()</p><p>Types:</p><p>Key = public_key()</p><p>Attributes = list()</p><p>Type = ssh_file()</p><p>Encodes a list of ssh file entries (public keys and attributes) to a binary. Possible attributes depends on the file type, see <strong> ssh_decode/2 </strong></p><p><strong></strong> verify(Msg, DigestType, Signature, Key) -&gt; boolean()</p><p>Types:</p><p>Msg = binary() | {digest,binary()}</p><p>The msg is either the binary "plain text" data or it is the hashed value of "plain text" i.e. the digest.</p><p>DigestType = rsa_digest_type() | dss_digest_type() | ecdsa_digest_type()</p><p>Signature = binary()</p><p>Key = rsa_public_key() | dsa_public_key() | ec_public_key()</p><p>Verifies a digital signature</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="proplists.3erl.html"><span aria-hidden="true">&larr;</span> proplists.3erl: Support functions for property lists</a></li>
   <li class="next"><a href="qlc.3erl.html">qlc.3erl: Query interface to mnesia, ets, dets, etc <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

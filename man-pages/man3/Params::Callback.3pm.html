<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Params::Callback: Parameter callback base class</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Parameter callback base class">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Params::Callback (3pm) manual">
  <meta name="twitter:description" content="Parameter callback base class">
  <meta name="twitter:image" content="https://www.carta.tech/images/libparams-callbackrequest-perl-Params::Callback-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Params::Callback.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Params::Callback (3pm) manual" />
  <meta property="og:description" content="Parameter callback base class" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libparams-callbackrequest-perl-Params::Callback-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Params::Callback<small> (3pm)</small></h1>
        <p class="lead">Parameter callback base class</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Params::Callback.3pm.html">
      <span itemprop="name">Params::Callback: Parameter callback base class</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libparams-callbackrequest-perl/">
      <span itemprop="name">libparams-callbackrequest-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Params::Callback.3pm.html">
      <span itemprop="name">Params::Callback: Parameter callback base class</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>Functional callback interface:</p>
<pre>
  sub my_callback {
      # Sole argument is a Params::Callback object.
      my $cb = shift;
      my $params = $cb-&gt;params;
      my $value = $cb-&gt;value;
      # Do stuff with above data.
  }
</pre>
<p>Object-oriented callback interface:</p><p>  package MyApp::Callback;   use base qw(Params::Callback);   use constant CLASS_KEY =&gt; &apos;MyHandler&apos;;   use strict;</p><p>  sub my_callback : Callback {       my $self = shift;       my $params = $self-&gt;params;       my $value = $self-&gt;value;       # Do stuff with above data.   }</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Params::Callback provides the interface for callbacks to access parameter hashes Params::CallbackRequest object, and callback metadata, as well as for executing common request actions, such as aborting a callback execution request. There are two ways to use Params::Callback: via functional-style callback subroutines and via object-oriented callback methods.</p><p>For functional callbacks, a Params::Callback object is constructed by Params::CallbackRequest for each call to its \*(C`request()\*(C' method, and passed as the sole argument for every execution of a callback function. See Params::CallbackRequest for details on how to create a Params::CallbackRequest object to execute your callback code.</p><p>In the object-oriented callback interface, Params::Callback is the parent class from which all callback classes inherit. Callback methods are declared in such subclasses via \*(C`Callback\*(C', \*(C`PreCallback\*(C', and \*(C`PostCallback\*(C' attributes to each method declaration. Methods and subroutines declared without one of these callback attributes are not callback methods, but normal methods or subroutines of the subclass. Read subclassing for details on subclassing Params::Callback.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INTERFACE</h2>
        <div class="sectioncontent">
<p>Params::Callback provides the parameter hash accessors and utility methods that will help manage a callback request (where a \*(L"callback request\*(R" is considered a single call to the \*(C`request()\*(C' method on a Params::CallbackRequest object). Functional callbacks always get a Params::Callback object passed as their first argument; the same Params::Callback object will be used for all callbacks in a single request. For object-oriented callback methods, the first argument will of course always be an object of the class corresponding to the class key used in the callback key (or, for request callback methods, an instance of the class for which the request callback method was loaded), and the same object will be reused for all subsequent callbacks to the same class in a single request.</p><h3>Accessor Methods</h3>
<p>All of the Params::Callback accessor methods are read-only. Feel free to add other attributes in your Params::Callback subclasses if you're using the object-oriented callback interface.</p><p><em>cb_request</em></p><p>  my $cb_request = $cb-&gt;cb_request;</p><p>Returns a reference to the Params::CallbackRequest object that executed the callback.</p><p><em>params</em></p><p>  my $params = $cb-&gt;params;</p><p>Returns a reference to the request parameters hash. Any changes you make to this hash will propagate beyond the lifetime of the request.</p><p><em>apache_req</em></p><p>  my $r = $cb-&gt;apache_req;</p><p>Returns the Apache request object for the current request, provided you've passed one to \*(C`Params::CallbackRequest-&gt;request\*(C'. This will be most useful in a mod_perl environment, of course. Use Apache:FakeRequest in tests to emmulate the behavior of an Apache request object.</p><p><em>requester</em></p><p>  my $r = $cb-&gt;requester;</p><p>Returns the object that executed the callback by calling \*(C`request()\*(C' on a Params::CallbackRequest object. Only available if the \*(C`requester\*(C' parameter is passed to \*(C`Params::CallbackRequest-&gt;request\*(C'. This can be useful for callbacks to get access to the object that executed the callbacks.</p><p><em>priority</em></p><p>  my $priority = $cb-&gt;priority;</p><p>Returns the priority level at which the callback was executed. Possible values range from \*(L"0\*(R" to \*(L"9\*(R", and may be set by a default priority setting, by the callback configuration or method declaration, or by the parameter callback trigger key. See Params::CallbackRequest for details.</p><p><em>cb_key</em></p><p>  my $cb_key = $cb-&gt;cb_key;</p><p>Returns the callback key that triggered the execution of the callback. For example, this callback-triggering parameter hash:</p><p>  my $params = { "DEFAULT|save_cb" =&gt; &apos;Save&apos; };</p><p>Will cause the \*(C`cb_key()\*(C' method in the relevant callback to return \*(L"save\*(R".</p><p><em>pkg_key</em></p><p>  my $pkg_key = $cb-&gt;pkg_key;</p><p>Returns the package key used in the callback trigger parameter key. For example, this callback-triggering parameter hash:</p><p>  my $params = { "MyCBs|save_cb" =&gt; &apos;Save&apos; };</p><p>Will cause the \*(C`pkg_key()\*(C' method in the relevant callback to return \*(L"MyCBs\*(R".</p><p><em>class_key</em></p><p>  my $class_key = $cb-&gt;class_key;</p><p>An alias for \*(C`pkg_key\*(C', only perhaps a bit more appealing for use in object-oriented callback methods.</p><p><em>trigger_key</em></p><p>  my $trigger_key = $cb-&gt;trigger_key;</p><p>Returns the complete parameter key that triggered the callback. For example, if the parameter key that triggered the callback looks like this:</p><p>  my $params = { "MyCBs|save_cb6" =&gt; &apos;Save&apos; };</p><p>Then the value returned by \*(C`trigger_key()\*(C' method will be \*(L"MyCBs|save_cb6\*(R".</p><p><strong>Note:</strong> Most browsers will submit \*(L"image\*(R" input fields with two arguments, one with \*(L".x\*(R" appended to its name, and the other with \*(L".y\*(R" appended to its name. Because Params::CallbackRequest is designed to be used with Web form fields populating a parameter hash, it will ignore these fields and either use the field that's named without the \*(L".x\*(R" or \*(L".y\*(R", or create a field with that name and give it a value of \*(L"1\*(R". The reasoning behind this approach is that the names of the callback-triggering fields should be the same as the names that appear in the \s-1HTML\s0 form fields. If you want the actual x and y image click coordinates, access them directly from the request parameters:</p><p>  my $params = $cb-&gt;params;   my $trigger_key = $cb-&gt;trigger_key;   my $x = $params-&gt;{"$trigger_key.x"};   my $y = $params-&gt;{"$trigger_key.y"};</p><p><em>value</em></p><p>  my $value = $cb-&gt;value;</p><p>Returns the value of the parameter that triggered the callback. This value can be anything that can be stored in a hash value \*(-- that is, any scalar value. Thus, in this example:</p><p>  my $params = { "DEFAULT|save_cb" =&gt; &apos;Save&apos;,                  "DEFAULT|open_cb" =&gt; [qw(one two)] };</p><p>\*(C`value()\*(C' will return the string \*(L"Save\*(R" in the save callback, but the array reference \*(C`[&apos;one&apos;, &apos;two&apos;]\*(C' in the open callback.</p><p>Although you may often be able to retrieve the value directly from the hash reference returned by \*(C`params()\*(C', if multiple callback keys point to the same subroutine or if the parameter that triggered the callback overrode the priority, you may not be able to determine which value was submitted for a particular callback execution. So Params::Callback kindly provides the value for you. The exception to this rule is values submitted under keys named for \s-1HTML\s0 \*(L"image\*(R" input fields. See the note about this under the documentation for the \*(C`trigger_key()\*(C' method.</p><p><em>redirected</em></p><p>  $cb-&gt;redirect($url) unless $cb-&gt;redirected;</p><p>If the request has been redirected, this method returns the redirection \s-1URL\s0. Otherwise, it returns false. This method is useful for conditions in which one callback has called \*(C`$cb-&gt;redirect\*(C' with the optional $wait argument set to a true value, thus allowing subsequent callbacks to continue to execute. If any of those subsequent callbacks want to call \*(C`$cb-&gt;redirect\*(C' themselves, they can check the value of \*(C`$cb-&gt;redirected\*(C' to make sure it hasn't been done already.</p>
<h3>Other Methods</h3>
<p>Params::Callback offers has a few other publicly accessible methods.</p><p><em>notes</em></p><p>  $cb-&gt;notes($key =&gt; $value);   my $val = $cb-&gt;notes($key);   my $notes = $cb-&gt;notes;</p><p>Shortcut for \*(C`$cb-&gt;cb_request-&gt;notes\*(C'. It provides a place to store application data, giving developers a way to share data among multiple callbacks. See \*(C`notes()\*(C' for more information.</p><p><em>redirect</em></p><p>  $cb-&gt;redirect($url);   $cb-&gt;redirect($url, $wait);   $cb-&gt;redirect($url, $wait, $status);</p><p>This method can be used to redirect a request in a mod_perl environment, provided that an Apache request object has been passed to \*(C`Params::CallbackRequest-&gt;new\*(C'. Outide of a mod_perl environment or without an Apache request object, \*(C`redirect()\*(C' will still set the proper value for the the \*(C`redirected()\*(C' method to return, and will still abort the callback request.</p><p>Given a \s-1URL\s0, this method generates a proper \s-1HTTP\s0 redirect for that \s-1URL\s0. By default, the status code used is \*(L"302\*(R", but this can be overridden via the $status argument. If the optional $wait argument is true, any callbacks scheduled to be executed after the call to \*(C`redirect\*(C' will continue to be executed. In that case, \*(C`$cb-&gt;abort\*(C' will not be called; rather, Params::CallbackRequest will finish executing all remaining callbacks and then return the abort status. If the $wait argument is unspecified or false, then the request will be immediately terminated without executing subsequent callbacks or. This approach relies on the execution of \*(C`$cb-&gt;abort\*(C'.</p><p>Since \*(C`$cb-&gt;redirect\*(C' calls \*(C`$cb-&gt;abort\*(C', it will be trapped by an \*(C`eval {}\*(C' block. If you are using an \*(C`eval {}\*(C' block in your code to trap exceptions, you need to make sure to rethrow these exceptions, like this:</p><p>  eval {       ...   };</p><p>  die $@ if $cb-&gt;aborted;</p><p>  # handle other exceptions</p><p><em>abort</em></p><p>  $cb-&gt;abort($status);</p><p>Aborts the current request without executing any more callbacks. The $status argument specifies a request status code to be returned to by \*(C`Params::CallbackRequest-&gt;request()\*(C'.</p><p>\*(C`abort()\*(C' is implemented by throwing a Params::Callback::Exception::Abort object and can thus be caught by \*(C`eval{}\*(C'. The \*(C`aborted()\*(C' method is a shortcut for determining whether an exception was generated by \*(C`abort()\*(C'.</p><p><em>aborted</em></p><p>  die $err if $cb-&gt;aborted;   die $err if $cb-&gt;aborted($err);</p><p>Returns true or \*(C`undef\*(C' to indicate whether the specified $err was generated by \*(C`abort()\*(C'. If no $err argument is passed, \*(C`aborted()\*(C' examines $@, instead.</p><p>In this code, we catch and process fatal errors while letting \*(C`abort()\*(C' exceptions pass through:</p><p>  eval { code_that_may_die_or_abort() };   if (my $err = $@) {       die $err if $cb-&gt;aborted($err);</p><p>      # handle fatal errors...   }</p><p>$@ can lose its value quickly, so if you're planning to call \*(C`$cb-&gt;aborted\*(C' more than a few lines after the \*(C`eval\*(C', you should save $@ to a temporary variable and explicitly pass it to \*(C`aborted()\*(C' as in the above example.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SUBCLASSING</h2>
        <div class="sectioncontent">
<p>Under Perl 5.6.0 and later, Params::Callback offers an object-oriented callback interface. The object-oriented approach is to subclass Params::Callback, add the callback methods you need, and specify a class key that uniquely identifies your subclass across all Params::Callback subclasses in your application. The key is to use Perl method attributes to identify methods as callback methods, so that Params::Callback can find them and execute them when the time comes. Here's an example:</p><p>  package MyApp::CallbackHandler;   use base qw(Params::Callback);   use strict;</p><p>  _\|_PACKAGE_\|_-&gt;register_subclass( class_key =&gt; &apos;MyHandler&apos; );</p><p>  sub build_utc_date : Callback( priority =&gt; 2 ) {       my $self = shift;       my $params = $self-&gt;params;       $params-&gt;{date} = sprintf "%04d-%02d-%02dT%02d:%02d:%02d",         delete @{$params}{qw(year month day hour minute second)};   }</p><p>This parameter-triggered callback can then be executed via a parameter hash such as this:</p><p>  my $params = { "MyHandler|build_utc_date_cb" =&gt; 1 };</p><p>Think of the part of the name preceding the pipe (the package key) as the class name, and the part of the name after the pipe (the callback key) as the method to call (plus '_cb'). If multiple parameters use the \*(L"MyHandler\*(R" class key in a single request, then a single MyApp::CallbackHandler object instance will be used to execute each of those callback methods for that request.</p><p>To configure your Params::CallbackRequest object to use this callback, use its \*(C`cb_classes\*(C' constructor parameter:</p><p>  my $cb_request = Params::CallbackRequest-&gt;new     ( cb_classes =&gt; [qw(MyHandler)] );   $cb_request-&gt;request($params);</p><p>Now, there are a few of things to note in the above callback class example. The first is the call to \*(C`_\|_PACKAGE_\|_-&gt;register_subclass\*(C'. This step is <strong>required</strong> in all callback subclasses in order that Params::Callback will know about them, and thus they can be loaded into an instance of a Params::CallbackRequest object via its \*(C`cb_classes\*(C' constructor parameter.</p><p>Second, a callback class key <strong>must</strong> be declared for the class. This can be done either by implementing the \*(C`CLASS_KEY()\*(C' class method or constant in your subclass, or by passing the \*(C`class_key\*(C' parameter to \*(C`_\|_PACKAGE_\|_-&gt;register_subclass\*(C', which will then create the \*(C`CLASS_KEY()\*(C' method for you. If no callback key is declared, then Params::Callback will throw an exception when you try to load your subclass' callback methods into a Params::CallbackRequest object.</p><p>One other, optional parameter, \*(C`default_priority\*(C', may also be passed to \*(C`register_subclass()\*(C'. The value of this parameter (an integer between 0 and 9) will be used to create a \*(C`DEFAULT_PRIORITY()\*(C' class method in the subclass. You can also explicitly implement the \*(C`DEFAULT_PRIORITY()\*(C' class method or constant in the subclass, if you'd rather. All parameter-triggered callback methods in that class will have their priorities set to the value returned by \*(C`DEFAULT_PRIORITY()\*(C', unless they override it via their \*(C`Callback\*(C' attributes.</p><p>And finally, notice the \*(C`Callback\*(C' attribute on the \*(C`build_utc_date\*(C' method declaration in the example above. This attribute is what identifies \*(C`build_utc_date\*(C' as a parameter-triggered callback. Without the \*(C`Callback\*(C' attribute, any subroutine declaration in your subclass will just be a subroutine or a method; it won't be a callback, and it will never be executed by Params::CallbackRequest. One parameter, \*(C`priority\*(C', can be passed via the \*(C`Callback\*(C' attribute. In the above example, we pass \*(C`priority =&gt; 2\*(C', which sets the priority for the callback. Without the \*(C`priority\*(C' parameter, the callback's priority will be set to the value returned by the \*(C`DEFAULT_PRIORITY()\*(C' class method. Of course, the priority can still be overridden by adding it to the callback trigger key. For example, here we force the callback priority for the execution of the \*(C`build_utc_date\*(C' callback method for this one field to be the highest priority, \*(L"0\*(R":</p><p>  my $params = { "MyHandler|build_utc_date_cb0" =&gt; 1 };</p><p>Other parameters to the \*(C`Callback\*(C' attribute may be added in future versions of Params::Callback.</p><p>Request callbacks can also be implemented as callback methods using the \*(C`PreCallback\*(C' and \*(C`PostCallback\*(C' attributes, which currently support no parameters.</p><h3>Subclassing Examples</h3>
<p>At this point, you may be wondering what advantage the object-oriented callback interface offer over functional callbacks. There are a number of advantages. First, it allows you to make use of callbacks provided by other users without having to reinvent the wheel for yourself. Say someone has implemented the above class with its exceptionally complex \*(C`build_utc_date()\*(C' callback method. You need to have the same functionality, only with fractions of a second added to the date format so that you can insert them into your database without an error. (This is admittedly a contrived example, but you get the idea.) To make it happen, you merely have to subclass the above class and override the \*(C`build_utc_date()\*(C' method to do what you need:</p><p>  package MyApp::Callback::Subclass;   use base qw(MyApp::CallbackHandler);   use strict;</p><p>  _\|_PACKAGE_\|_-&gt;register_subclass;</p><p>  # Implement CLASS_KEY ourselves.   use constant CLASS_KEY =&gt; &apos;SubHandler&apos;;</p><p>  sub build_utc_date : Callback( priority =&gt; 1 ) {       my $self = shift;       $self-&gt;SUPER::build_utc_date;       my $params = $self-&gt;params;       $params-&gt;{date} .= &apos;.000000&apos;;   }</p><p>This callback can then be triggered by a parameter hash such as this:</p><p>  my $params = { "SubHandler|build_utc_date_cb" =&gt; 1 };</p><p>Note that we've used the \*(L"SubHandler\*(R" class key. If we used the \*(L"MyHandler\*(R" class key, then the \*(C`build_utc_date()\*(C' method would be called on an instance of the MyApp::CallbackHandler class, instead.</p><p><em>Request Callback Methods</em></p><p>I'll admit that the case for request callback methods is a bit more tenuous. Granted, a given application may have 100s or even 1000s of parameter-triggered callbacks, but only one or two request callbacks, if any. But the advantage of request callback methods is that they encourage code sharing, in that Params::Callback creates a kind of plug-in architecture Perl templating architectures.</p><p>For example, say someone has kindly created a Params::Callback subclass, Params::Callback::Unicodify, with the request callback method \*(C`unicodify()\*(C', which translates character sets, allowing you to always store data in the database in Unicode. That's all well and good, as far as it goes, but let's say that you want to make sure that your Unicode strings are actually encoded using the Perl \*(C`&#92;x{..}\*(C' notation. Again, just subclass:</p><p>  package Params::Callback::Unicodify::PerlEncode;   use base qw(Params::Callback::Unicodify);   use strict;</p><p>  _\|_PACKAGE_\|_-&gt;register_subclass( class_key =&gt; &apos;PerlEncode&apos; );</p><p>  sub unicodify : PreCallback {       my $self = shift;       $self-&gt;SUPER::unicodify;       my $params = $self-&gt;params;       encode_unicode($params); # Hand waving.   }</p><p>Now you can just tell Params::CallbackRequest to use your subclassed callback handler:</p><p>  my $cb_request = Params::CallbackRequest-&gt;new     ( cb_classes =&gt; [qw(PerlEncode)] );</p><p>Yeah, okay, you could just create a second pre-callback request callback to encode the Unicode characters using the Perl \*(C`&#92;x{..}\*(C' notation. But you get the idea. Better examples welcome.</p><p><em>Overriding the Constructor</em></p><p>Another advantage to using callback classes is that you can override the Params::Callback \*(C`new()\*(C' constructor. Since every callback for a single class will be executed on the same instance object in a single request, you can set up object properties in the constructor that subsequent callback methods in the same request can then access.</p><p>For example, say you had a series of pages that all do different things to manage objects in your application. Each of those pages might have a number of parameters in common to assist in constructing an object:</p><p>  my $params = { class  =&gt; "MyApp::Spring",                  obj_id =&gt; 10,                  # ...                };</p><p>Then the remaining parameters created for each of these pages have different key/value pairs for doing different things with the object, perhaps with numerous parameter-triggered callbacks. Here's where subclassing comes in handy: you can override the constructor to construct the object when the callback object is constructed, so that each of your callback methods doesn't have to:</p><p>  package MyApp::Callback;   use base qw(Params::Callback);   use strict;   _\|_PACKAGE_\|_-&gt;register_subclass( class_key =&gt; &apos;MyCBHandler&apos; );</p><p>  sub new {       my $class = shift;       my $self = $class-&gt;SUPER::new(@_);       my $params = $self-&gt;params;       $self-&gt;object($params-&gt;{class}-&gt;lookup( id =&gt; $params-&gt;{obj_id} ));   }</p><p>  sub object {       my $self = shift;       if (@_) {           $self-&gt;{object} = shift;       }       return $self-&gt;{object};   }</p><p>  sub save : Callback {       my $self = shift;       $self-&gt;object-&gt;save;   }</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SUBCLASSING INTERFACE</h2>
        <div class="sectioncontent">
<p>Much of the interface for subclassing Params::Callback is evident in the above examples. Here is a reference to the complete callback subclassing \s-1API\s0.</p><h3>Callback Class Declaration</h3>
<p>Callback classes always subclass Params::Callback, so of course they must always declare such. In addition, callback classes must always call \*(C`_\|_PACKAGE_\|_-&gt;register_subclass\*(C' so that Params::Callback is aware of them and can tell Params::CallbackRequest about them.</p><p>Second, callback classes <strong>must</strong> have a class key. The class key can be created either by implementing a \*(C`CLASS_KEY()\*(C' class method or constant that returns the class key, or by passing the \*(C`class_key\*(C' parameter to \*(C`register_subclass()\*(C' method. If no \*(C`class_key\*(C' parameter is passed to \*(C`register_subclass()\*(C' and no \*(C`CLASS_KEY()\*(C' method exists, \*(C`register_subclass()\*(C' will create the \*(C`CLASS_KEY()\*(C' class method to return the actual class name. So here are a few example callback class declarations:</p><p>  package MyApp::Callback;   use base qw(Params::Callback);   _\|_PACKAGE_\|_-&gt;register_subclass( class_key =&gt; &apos;MyCBHandler&apos; );</p><p>In this declaration \*(C`register_subclass()\*(C' will create a \*(C`CLASS_KEY()\*(C' class method returning \*(L"MyCBHandler\*(R" in the MyApp::CallbackHandler class.</p><p>  package MyApp::AnotherCallback;   use base qw(MyApp::Callback);   _\|_PACKAGE_\|_-&gt;register_subclass;   use constant CLASS_KEY =&gt; &apos;AnotherCallback&apos;;</p><p>In this declaration, we've created an explicit \*(C`CLASS_KEY()\*(C' class method (using the handy \*(C`use constant\*(C' syntax, so that \*(C`register_subclass()\*(C' doesn't have to.</p><p>  package MyApp::Callback::Foo;   use base qw(Params::Callback);   _\|_PACKAGE_\|_-&gt;register_subclass;</p><p>And in this callback class declaration, we've specified neither a \*(C`class_key\*(C' parameter to \*(C`register_subclass()\*(C', nor created a \*(C`CLASS_KEY()\*(C' class method. This causes \*(C`register_subclass()\*(C' to create the \*(C`CLASS_KEY()\*(C' class method returning the name of the class itself, i.e., \*(L"MyApp::FooHandler\*(R". Thus any parameter-triggered callbacks in this class can be triggered by using the class name in the trigger key:</p><p>  my $params = { "MyApp::Callback::Foo|take_action_cb" =&gt; 1 };</p><p>A second, optional parameter, \*(C`default_priority\*(C', may also be passed to \*(C`register_subclass()\*(C' in order to set a default priority for all of the methods in the class (and for all the methods in subclasses that don't declare their own \*(C`default_priority\*(C's):</p><p>  package MyApp::Callback;   use base qw(Params::Callback);   _\|_PACKAGE_\|_-&gt;register_subclass( class_key =&gt; &apos;MyCB&apos;,                                   default_priority =&gt; 7 );</p><p>As with the \*(C`class_key\*(C' parameter, the \*(C`default_priority\*(C' parameter creates a class method, \*(C`DEFAULT_PRIORITY()\*(C'. If you'd rather, you can create this class method yourself; just be sure that its value is a valid priority \*(-- that is, an integer between \*(L"0\*(R" and \*(L"9\*(R":</p><p>  package MyApp::Callback;   use base qw(Params::Callback);   use constant DEFAULT_PRIORITY =&gt; 7;   _\|_PACKAGE_\|_-&gt;register_subclass( class_key =&gt; &apos;MyCB&apos; );</p><p>Any callback class that does not specify a default priority via the \*(C`default_priority\*(C' or by implementing a &lt;\s-1<em>DEFAULT_PRIORITY\s0()</em>&gt; class method will simply inherit the priority returned by \*(C`Params::Callback-&gt;DEFAULT_PRIORITY\*(C', which is \*(L"5\*(R".</p><p><strong>Note:</strong> In a mod_perl environment, it's important that you \*(C`use\*(C' any and all Params::Callback subclasses <em>before</em> you \*(C`use Params::CallbackRequest\*(C'. This is to get around an issue with identifying the names of the callback methods in mod_perl. Read the comments in the source code if you're interested in learning more.</p>
<h3>Method Attributes</h3>
<p>These method attributes are required to create callback methods in Params::Callback subclasses.</p><p><em>Callback</em></p><p>  sub take_action : Callback {       my $self = shift;       # Do stuff.   }</p><p>This attribute identifies a parameter-triggered callback method. The callback key is the same as the method name (\*(L"take_action\*(R" in this example). The priority for the callback may be set via an optional \*(C`priority\*(C' parameter to the \*(C`Callback\*(C' attribute, like so:</p><p>  sub take_action : Callback( priority =&gt; 5 ) {       my $self = shift;       # Do stuff.   }</p><p>Otherwise, the priority will be that returned by \*(C`$self-&gt;DEFAULT_PRIORITY\*(C'.</p><p><strong>Note:</strong> The priority set via the \*(C`priority\*(C' parameter to the \*(C`Callback\*(C' attribute is not inherited by any subclasses that override the callback method. This may change in the future.</p><p><em>PreCallback</em></p><p>  sub early_action : PreCallback {       my $self = shift;       # Do stuff.   }</p><p>This attribute identifies a method as a request callback that gets executed for every request <em>before</em> any parameter-triggered callbacks are executed . No parameters to \*(C`PreCallback\*(C' are currently supported.</p><p><em>PostCallback</em></p><p>  sub late_action : PostCallback {       my $self = shift;       # Do stuff.   }</p><p>This attribute identifies a method as a request callback that gets executed for every request <em>after</em> any parameter-triggered callbacks are executed . No parameters to \*(C`PostCallback\*(C' are currently supported.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TODO</h2>
        <div class="sectioncontent">
<ul>
<li><p>Allow methods that override parent methods to inherit the parent method's priority?</p></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Params::Callback&hellip;</h2>
        <div class="sectioncontent">
<p>Params::CallbackRequest constructs Params::Callback objects and executes the appropriate callback functions and/or methods. It's worth a read.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SUPPORT</h2>
        <div class="sectioncontent">
<p>This module is stored in an open repository at the following address:</p><p>https://svn.kineticode.com/Params-CallbackRequest/trunk/ &lt;https://svn.kineticode.com/Params-CallbackRequest/trunk/&gt;</p><p>Patches against Params::CallbackRequest are welcome. Please send bug reports to &lt;bug-params-callbackrequest@rt.cpan.org&gt;.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>David E. Wheeler &lt;david@justatheory.com&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT AND LICENSE</h2>
        <div class="sectioncontent">
<p>Copyright 2003-2011 David E. Wheeler. Some Rights Reserved.</p><p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Parallel::Runner.3pm.html"><span aria-hidden="true">&larr;</span> Parallel::Runner.3pm: An object to manage running things in parallel processes.</a></li>
   <li class="next"><a href="Params::CallbackRequest.3pm.html">Params::CallbackRequest.3pm: Functional and object-oriented callback architecture <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

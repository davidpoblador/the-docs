<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ct_netconfc: Netconf client module.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Netconf client module.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="ct_netconfc (3erl) manual">
  <meta name="twitter:description" content="Netconf client module.">
  <meta name="twitter:image" content="https://www.carta.tech/images/erlang-manpages-ct_netconfc-3erl.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3erl/ct_netconfc.3erl.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="ct_netconfc (3erl) manual" />
  <meta property="og:description" content="Netconf client module." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/erlang-manpages-ct_netconfc-3erl.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">ct_netconfc<small> (3erl)</small></h1>
        <p class="lead">Netconf client module.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/ct_netconfc.3erl.html">
      <span itemprop="name">ct_netconfc: Netconf client module.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/erlang-manpages/">
      <span itemprop="name">erlang-manpages</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/ct_netconfc.3erl.html">
      <span itemprop="name">ct_netconfc: Netconf client module.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Netconf client module.</p><p>The Netconf client is compliant with RFC4741 and RFC4742.</p><p>For each server to test against, the following entry can be added to a configuration file:</p><p><em>{server_id(),options()}.</em></p><p>The <em>server_id()</em> or an associated <em>target_name()</em> (see <strong>ct</strong>) shall then be used in calls to <strong>open/2</strong>.</p><p>If no configuration exists for a server, a session can still be opened by calling <strong>open/2</strong> with all necessary options given in the call. The first argument to <strong>open/2</strong> can then be any atom.</p><p><em></em><strong>Logging</strong></p><p>The netconf server uses the <em>error_logger</em> for logging of netconf traffic. A special purpose error handler is implemented in <em>ct_conn_log_h</em>. To use this error handler, add the <em>cth_conn_log</em> hook in your test suite, e.g.</p>
<pre>
  suite() -&gt;
     [{ct_hooks, [{cth_conn_log, [{conn_mod(),hook_options()}]}]}].
</pre>
<p>The <em>conn_mod()</em> is the name of the common_test module implementing the connection protocol, e.g. <em>ct_netconfc</em>.</p><p>The hook option <em>log_type</em> specifies the type of logging:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>raw</em>: The sent and received netconf data is logged to a separate text file as is without any formatting. A link to the file is added to the test case HTML log.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>pretty</em>: The sent and received netconf data is logged to a separate text file with XML data nicely indented. A link to the file is added to the test case HTML log.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>html (default)</em>: The sent and received netconf traffic is pretty printed directly in the test case HTML log.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>silent</em>: Netconf traffic is not logged.</p>
  </dd>

</dl>
<p>By default, all netconf traffic is logged in one single log file. However, it is possible to have different connections logged in separate files. To do this, use the hook option <em>hosts</em> and list the names of the servers/connections that will be used in the suite. Note that the connections must be named for this to work, i.e. they must be opened with <strong>open/2</strong>.</p><p>The <em>hosts</em> option has no effect if <em>log_type</em> is set to <em>html</em> or <em>silent</em>.</p><p>The hook options can also be specified in a configuration file with the configuration variable <em>ct_conn_log</em>:</p>
<pre>
  {ct_conn_log,[{conn_mod(),hook_options()}]}.
</pre>
<p>For example:</p>
<pre>
  {ct_conn_log,[{ct_netconfc,[{log_type,pretty},
                              {hosts,[key_or_name()]}]}]}
</pre>
<p><em>Note</em> that hook options specified in a configuration file will overwrite the hardcoded hook options in the test suite.</p><p><em></em><strong>Logging example 1</strong></p><p>The following <em>ct_hooks</em> statement will cause pretty printing of netconf traffic to separate logs for the connections named <em>nc_server1</em> and <em>nc_server2</em>. Any other connections will be logged to default netconf log.</p>
<pre>
  suite() -&gt;
     [{ct_hooks, [{cth_conn_log, [{ct_netconfc,[{log_type,pretty}},
                                                {hosts,[nc_server1,nc_server2]}]}
                                 ]}]}].
</pre>
<p>Connections must be opened like this:</p>
<pre>
  open(nc_server1,[...]),
  open(nc_server2,[...]).
</pre>
<p><em></em><strong>Logging example 2</strong></p><p>The following configuration file will cause raw logging of all netconf traffic into one single text file.</p>
<pre>
  {ct_conn_log,[{ct_netconfc,[{log_type,raw}]}]}.
</pre>
<p>The <em>ct_hooks</em> statement must look like this:</p>
<pre>
  suite() -&gt;
     [{ct_hooks, [{cth_conn_log, []}]}].
</pre>
<p>The same <em>ct_hooks</em> statement without the configuration file would cause HTML logging of all netconf connections into the test case HTML log.</p><p><em></em><strong>Notifications</strong></p><p>The netconf client is also compliant with RFC5277 NETCONF Event Notifications, which defines a mechanism for an asynchronous message notification delivery service for the netconf protocol.</p><p>Specific functions to support this are <strong>create_subscription/6</strong> and <strong>get_event_streams/3</strong>. (The functions also exist with other arities.)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DATA TYPES</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>client() = handle() | server_id() (see module ct_gen_conn) | target_name() (see module ct_gen_conn)</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>error_reason() = term()</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>event_time() = {eventTime, xml_attributes(), [xs_datetime()]}</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>handle() = term()</em>:</p><p>An opaque reference for a connection (netconf session). See <strong>ct</strong> for more information.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>host() = hostname() (see module inet) | ip_address() (see module inet)</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>netconf_db() = running | startup | candidate</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>notification() = {notification, xml_attributes(), notification_content()}</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>notification_content() = [event_time() | simple_xml()]</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>option() = {ssh, host()} | {port, port_number() (see module inet)} | {user, string()} | {password, string()} | {user_dir, string()} | {timeout, timeout()}</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>options() = [option()]</em>:</p><p>Options used for setting up ssh connection to a netconf server.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>simple_xml() = {xml_tag(), xml_attributes(), xml_content()} | {xml_tag(), xml_content()} | xml_tag()</em>:</p><p>This type is further described in the documentation for the <em>Xmerl</em> application.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>stream_data() = {description, string()} | {replaySupport, string()} | {replayLogCreationTime, string()} | {replayLogAgedTime, string()}</em>:</p><p>See XML Schema for Event Notifications found in RFC5277 for further detail about the data format for the string values.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>stream_name() = string()</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>streams() = [{stream_name(), [stream_data()]}]</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>xml_attribute_tag() = atom()</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>xml_attribute_value() = string()</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>xml_attributes() = [{xml_attribute_tag(), xml_attribute_value()}]</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>xml_content() = [simple_xml() | iolist()]</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>xml_tag() = atom()</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>xpath() = {xpath, string()}</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>xs_datetime() = string()</em>:</p><p>This date and time identifyer has the same format as the XML type dateTime and compliant to RFC3339. The format is</p>
  </dd>

</dl>

<pre>
     [-]CCYY-MM-DDThh:mm:ss[.s][Z|(+|-)hh:mm]
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">
<p><strong></strong> action(Client, Action) -&gt; Result</p><p>Equivalent to <strong>action(Client, Action, infinity)</strong>.</p><p><strong></strong> action(Client, Action, Timeout) -&gt; Result</p><p>Types:</p><p>Client = client()</p><p>Action = simple_xml()</p><p>Timeout = timeout()</p><p>Result = {ok, [simple_xml()]} | {error, error_reason()}</p><p>Execute an action.</p><p><strong></strong> close_session(Client) -&gt; Result</p><p>Equivalent to <strong>close_session(Client, infinity)</strong>.</p><p><strong></strong> close_session(Client, Timeout) -&gt; Result</p><p>Types:</p><p>Client = client()</p><p>Timeout = timeout()</p><p>Result = ok | {error, error_reason()}</p><p>Request graceful termination of the session associated with the client.</p><p>When a netconf server receives a <em>close-session</em> request, it will gracefully close the session. The server will release any locks and resources associated with the session and gracefully close any associated connections. Any NETCONF requests received after a <em>close-session</em> request will be ignored.</p><p><strong></strong> copy_config(Client, Source, Target) -&gt; Result</p><p>Equivalent to <strong>copy_config(Client, Source, Target, infinity)</strong>.</p><p><strong></strong> copy_config(Client, Target, Source, Timeout) -&gt; Result</p><p>Types:</p><p>Client = client()</p><p>Target = netconf_db()</p><p>Source = netconf_db()</p><p>Timeout = timeout()</p><p>Result = ok | {error, error_reason()}</p><p>Copy configuration data.</p><p>Which source and target options that can be issued depends on the capabilities supported by the server. I.e. <em>:candidate</em> and/or <em>:startup</em> are required.</p><p><strong></strong> create_subscription(Client) -&gt; term()</p><p><strong></strong> create_subscription(Client, Timeout) -&gt; term()</p><p><strong></strong> create_subscription(Client, Stream, Timeout) -&gt; term()</p><p><strong></strong> create_subscription(Client, StartTime, StopTime, Timeout) -&gt; term()</p><p><strong></strong> create_subscription(Client, Stream, StartTime, StopTime, Timeout) -&gt; term()</p><p><strong></strong> create_subscription(Client, Stream, Filter, StartTime, StopTime, Timeout) -&gt; Result</p><p>Types:</p><p>Client = client()</p><p>Stream = stream_name()</p><p>Filter = simple_xml() | [simple_xml()]</p><p>StartTime = xs_datetime()</p><p>StopTime = xs_datetime()</p><p>Timeout = timeout()</p><p>Result = ok | {error, error_reason()}</p><p>Create a subscription for event notifications.</p><p>This function sets up a subscription for netconf event notifications of the given stream type, matching the given filter. The calling process will receive notifications as messages of type <em>notification()</em>.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>Stream:: An optional parameter that indicates which stream of events is of interest. If not present, events in the default NETCONF stream will be sent.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>Filter:: An optional parameter that indicates which subset of all possible events is of interest. The format of this parameter is the same as that of the filter parameter in the NETCONF protocol operations. If not present, all events not precluded by other parameters will be sent.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>StartTime:: An optional parameter used to trigger the replay feature and indicate that the replay should start at the time specified. If <em>StartTime</em> is not present, this is not a replay subscription. It is not valid to specify start times that are later than the current time. If the <em>StartTime</em> specified is earlier than the log can support, the replay will begin with the earliest available notification. This parameter is of type dateTime and compliant to [RFC3339]. Implementations must support time zones.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>StopTime:: An optional parameter used with the optional replay feature to indicate the newest notifications of interest. If <em>StopTime</em> is not present, the notifications will continue until the subscription is terminated. Must be used with and be later than <em>StartTime</em>. Values of <em>StopTime</em> in the future are valid. This parameter is of type dateTime and compliant to [RFC3339]. Implementations must support time zones.</p>
  </dd>

</dl>
<p>See RFC5277 for further details about the event notification mechanism.</p><p><strong></strong> delete_config(Client, Target) -&gt; Result</p><p>Equivalent to <strong>delete_config(Client, Target, infinity)</strong>.</p><p><strong></strong> delete_config(Client, Target, Timeout) -&gt; Result</p><p>Types:</p><p>Client = client()</p><p>Target = startup | candidate</p><p>Timeout = timeout()</p><p>Result = ok | {error, error_reason()}</p><p>Delete configuration data.</p><p>The running configuration cannot be deleted and <em>:candidate</em> or <em>:startup</em> must be advertised by the server.</p><p><strong></strong> edit_config(Client, Target, Config) -&gt; Result</p><p>Equivalent to <strong>edit_config(Client, Target, Config, infinity)</strong>.</p><p><strong></strong> edit_config(Client, Target, Config, Timeout) -&gt; Result</p><p>Types:</p><p>Client = client()</p><p>Target = netconf_db()</p><p>Config = simple_xml()</p><p>Timeout = timeout()</p><p>Result = ok | {error, error_reason()}</p><p>Edit configuration data.</p><p>Per default only the running target is available, unless the server include <em>:candidate</em> or <em>:startup</em> in its list of capabilities.</p><p><strong></strong> format_data(How, Data) -&gt; term()</p><p><strong></strong> get(Client, Filter) -&gt; Result</p><p>Equivalent to <strong>get(Client, Filter, infinity)</strong>.</p><p><strong></strong> get(Client, Filter, Timeout) -&gt; Result</p><p>Types:</p><p>Client = client()</p><p>Filter = simple_xml() | xpath()</p><p>Timeout = timeout()</p><p>Result = {ok, [simple_xml()]} | {error, error_reason()}</p><p>Get data.</p><p>This operation returns both configuration and state data from the server.</p><p>Filter type <em>xpath</em> can only be used if the server supports <em>:xpath</em>.</p><p><strong></strong> get_capabilities(Client) -&gt; Result</p><p>Equivalent to <strong>get_capabilities(Client, infinity)</strong>.</p><p><strong></strong> get_capabilities(Client, Timeout) -&gt; Result</p><p>Types:</p><p>Client = client()</p><p>Timeout = timeout()</p><p>Result = [string()] | {error, error_reason()}</p><p>Returns the server side capabilities</p><p>The following capability identifiers, defined in RFC 4741, can be returned:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>"urn:ietf:params:netconf:base:1.0"</em></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>"urn:ietf:params:netconf:capability:writable-running:1.0"</em></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>"urn:ietf:params:netconf:capability:candidate:1.0"</em></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>"urn:ietf:params:netconf:capability:confirmed-commit:1.0"</em></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>"urn:ietf:params:netconf:capability:rollback-on-error:1.0"</em></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>"urn:ietf:params:netconf:capability:startup:1.0"</em></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>"urn:ietf:params:netconf:capability:url:1.0"</em></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>"urn:ietf:params:netconf:capability:xpath:1.0"</em></p>
  </dd>

</dl>
<p>Note, additional identifiers may exist, e.g. server side namespace.</p><p><strong></strong> get_config(Client, Source, Filter) -&gt; Result</p><p>Equivalent to <strong>get_config(Client, Source, Filter, infinity)</strong>.</p><p><strong></strong> get_config(Client, Source, Filter, Timeout) -&gt; Result</p><p>Types:</p><p>Client = client()</p><p>Source = netconf_db()</p><p>Filter = simple_xml() | xpath()</p><p>Timeout = timeout()</p><p>Result = {ok, [simple_xml()]} | {error, error_reason()}</p><p>Get configuration data.</p><p>To be able to access another source than <em>running</em>, the server must advertise <em>:candidate</em> and/or <em>:startup</em>.</p><p>Filter type <em>xpath</em> can only be used if the server supports <em>:xpath</em>.</p><p><strong></strong> get_event_streams(Client, Timeout) -&gt; Result</p><p>Equivalent to <strong>get_event_streams(Client, [], Timeout)</strong>.</p><p><strong></strong> get_event_streams(Client, Streams, Timeout) -&gt; Result</p><p>Types:</p><p>Client = client()</p><p>Streams = [stream_name()]</p><p>Timeout = timeout()</p><p>Result = {ok, streams()} | {error, error_reason()}</p><p>Send a request to get the given event streams.</p><p><em>Streams</em> is a list of stream names. The following filter will be sent to the netconf server in a <em>get</em> request:</p>
<pre>
  &lt;netconf xmlns="urn:ietf:params:xml:ns:netmod:notification"&gt;
    &lt;streams&gt;
      &lt;stream&gt;
        &lt;name&gt;StreamName1&lt;/name&gt;
      &lt;/stream&gt;
      &lt;stream&gt;
        &lt;name&gt;StreamName2&lt;/name&gt;
      &lt;/stream&gt;
      ...
    &lt;/streams&gt;
  &lt;/netconf&gt;
</pre>
<p>If <em>Streams</em> is an empty list, ALL streams will be requested by sending the following filter:</p>
<pre>
  &lt;netconf xmlns="urn:ietf:params:xml:ns:netmod:notification"&gt;
    &lt;streams/&gt;
  &lt;/netconf&gt;
</pre>
<p>If more complex filtering is needed, a use <strong>get/2</strong> or <strong>get/3</strong> and specify the exact filter according to XML Schema for Event Notifications found in RFC5277.</p><p><strong></strong> get_session_id(Client) -&gt; Result</p><p>Equivalent to <strong>get_session_id(Client, infinity)</strong>.</p><p><strong></strong> get_session_id(Client, Timeout) -&gt; Result</p><p>Types:</p><p>Client = client()</p><p>Timeout = timeout()</p><p>Result = pos_integer() | {error, error_reason()}</p><p>Returns the session id associated with the given client.</p><p><strong></strong> handle_msg(X1, State) -&gt; term()</p><p><strong></strong> hello(Client) -&gt; Result</p><p>Equivalent to <strong>hello(Client, infinity)</strong>.</p><p><strong></strong> hello(Client, Timeout) -&gt; Result</p><p>Types:</p><p>Client = handle()</p><p>Timeout = timeout()</p><p>Result = ok | {error, error_reason()}</p><p>Exchange <em>hello</em> messages with the server.</p><p>Sends a <em>hello</em> message to the server and waits for the return.</p><p><strong></strong> kill_session(Client, SessionId) -&gt; Result</p><p>Equivalent to <strong>kill_session(Client, SessionId, infinity)</strong>.</p><p><strong></strong> kill_session(Client, SessionId, Timeout) -&gt; Result</p><p>Types:</p><p>Client = client()</p><p>SessionId = pos_integer()</p><p>Timeout = timeout()</p><p>Result = ok | {error, error_reason()}</p><p>Force termination of the session associated with the supplied session id.</p><p>The server side shall abort any operations currently in process, release any locks and resources associated with the session, and close any associated connections.</p><p>Only if the server is in the confirmed commit phase, the configuration will be restored to its state before entering the confirmed commit phase. Otherwise, no configuration roll back will be performed.</p><p>If the given <em>SessionId</em> is equal to the current session id, an error will be returned.</p><p><strong></strong> lock(Client, Target) -&gt; Result</p><p>Equivalent to <strong>lock(Client, Target, infinity)</strong>.</p><p><strong></strong> lock(Client, Target, Timeout) -&gt; Result</p><p>Types:</p><p>Client = client()</p><p>Target = netconf_db()</p><p>Timeout = timeout()</p><p>Result = ok | {error, error_reason()}</p><p>Unlock configuration target.</p><p>Which target parameters that can be used depends on if <em>:candidate</em> and/or <em>:startup</em> are supported by the server. If successfull, the configuration system of the device is not available to other clients (Netconf, CORBA, SNMP etc). Locks are intended to be short-lived.</p><p>The operations <strong>kill_session/2</strong> or <strong>kill_session/3</strong> can be used to force the release of a lock owned by another Netconf session. How this is achieved by the server side is implementation specific.</p><p><strong></strong> only_open(Options) -&gt; Result</p><p>Types:</p><p>Options = options()</p><p>Result = {ok, handle()} | {error, error_reason()}</p><p>Open a netconf session, but don't send <em>hello</em>.</p><p>As <strong>open/1</strong> but does not send a <em>hello</em> message.</p><p><strong></strong> only_open(KeyOrName, ExtraOptions) -&gt; Result</p><p>Types:</p><p>KeyOrName = key_or_name() (see module ct_gen_conn)</p><p>ExtraOptions = options()</p><p>Result = {ok, handle()} | {error, error_reason()}</p><p>Open a name netconf session, but don't send <em>hello</em>.</p><p>As <strong>open/2</strong> but does not send a <em>hello</em> message.</p><p><strong></strong> open(Options) -&gt; Result</p><p>Types:</p><p>Options = options()</p><p>Result = {ok, handle()} | {error, error_reason()}</p><p>Open a netconf session and exchange <em>hello</em> messages.</p><p>If the server options are specified in a configuration file, or if a named client is needed for logging purposes (see <strong>Logging</strong>) use <strong>open/2</strong> instead.</p><p>The opaque <em>handler()</em> reference which is returned from this function is required as client identifier when calling any other function in this module.</p><p>The <em>timeout</em> option (milli seconds) is used when setting up the ssh connection and when waiting for the hello message from the server. It is not used for any other purposes during the lifetime of the connection.</p><p><strong></strong> open(KeyOrName, ExtraOptions) -&gt; Result</p><p>Types:</p><p>KeyOrName = key_or_name() (see module ct_gen_conn)</p><p>ExtraOptions = options()</p><p>Result = {ok, handle()} | {error, error_reason()}</p><p>Open a named netconf session and exchange <em>hello</em> messages.</p><p>If <em>KeyOrName</em> is a configured <em>server_id()</em> or a <em>target_name()</em> associated with such an ID, then the options for this server will be fetched from the configuration file.</p><p>The <em>ExtraOptions</em> argument will be added to the options found in the configuration file. If the same options are given, the values from the configuration file will overwrite <em>ExtraOptions</em>.</p><p>If the server is not specified in a configuration file, use <strong>open/1</strong> instead.</p><p>The opaque <em>handle()</em> reference which is returned from this function can be used as client identifier when calling any other function in this module. However, if <em>KeyOrName</em> is a <em>target_name()</em>, i.e. if the server is named via a call to <em>ct:require/2</em> or a <em>require</em> statement in the test suite, then this name may be used instead of the <em>handle()</em>.</p><p>The <em>timeout</em> option (milli seconds) is used when setting up the ssh connection and when waiting for the hello message from the server. It is not used for any other purposes during the lifetime of the connection.</p><p><em>See also:</em> <strong>ct:require/2</strong>.</p><p><strong></strong> send(Client, SimpleXml) -&gt; Result</p><p>Equivalent to <strong>send(Client, SimpleXml, infinity)</strong>.</p><p><strong></strong> send(Client, SimpleXml, Timeout) -&gt; Result</p><p>Types:</p><p>Client = client()</p><p>SimpleXml = simple_xml()</p><p>Timeout = timeout()</p><p>Result = simple_xml() | {error, error_reason()}</p><p>Send an XML document to the server.</p><p>The given XML document is sent as is to the server. This function can be used for sending XML documents that can not be expressed by other interface functions in this module.</p><p><strong></strong> send_rpc(Client, SimpleXml) -&gt; Result</p><p>Equivalent to <strong>send_rpc(Client, SimpleXml, infinity)</strong>.</p><p><strong></strong> send_rpc(Client, SimpleXml, Timeout) -&gt; Result</p><p>Types:</p><p>Client = client()</p><p>SimpleXml = simple_xml()</p><p>Timeout = timeout()</p><p>Result = [simple_xml()] | {error, error_reason()}</p><p>Send a Netconf <em>rpc</em> request to the server.</p><p>The given XML document is wrapped in a valid Netconf <em>rpc</em> request and sent to the server. The <em>message-id</em> and namespace attributes are added to the <em>rpc</em> element.</p><p>This function can be used for sending <em>rpc</em> requests that can not be expressed by other interface functions in this module.</p><p><strong></strong> unlock(Client, Target) -&gt; Result</p><p>Equivalent to <strong>unlock(Client, Target, infinity)</strong>.</p><p><strong></strong> unlock(Client, Target, Timeout) -&gt; Result</p><p>Types:</p><p>Client = client()</p><p>Target = netconf_db()</p><p>Timeout = timeout()</p><p>Result = ok | {error, error_reason()}</p><p>Unlock configuration target.</p><p>If the client earlier has aquired a lock, via <strong>lock/2</strong> or <strong>lock/3</strong>, this operation release the associated lock. To be able to access another target than <em>running</em>, the server must support <em>:candidate</em> and/or <em>:startup</em>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p>Support <em></em> &lt;&gt;</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="ct_master.3erl.html"><span aria-hidden="true">&larr;</span> ct_master.3erl: Distributed test execution control for common test.</a></li>
   <li class="next"><a href="ct_property_test.3erl.html">ct_property_test.3erl: Experimental support in common-test for calling property based tests. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

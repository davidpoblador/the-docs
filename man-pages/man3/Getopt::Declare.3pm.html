<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Getopt::Declare: Declaratively expressed command-line arguments via regular expressions</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Declaratively expressed command-line arguments via regular expressions">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Getopt::Declare (3pm) manual">
  <meta name="twitter:description" content="Declaratively expressed command-line arguments via regular expressions">
  <meta name="twitter:image" content="https://www.carta.tech/images/libgetopt-declare-perl-Getopt::Declare-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Getopt::Declare.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Getopt::Declare (3pm) manual" />
  <meta property="og:description" content="Declaratively expressed command-line arguments via regular expressions" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libgetopt-declare-perl-Getopt::Declare-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Getopt::Declare<small> (3pm)</small></h1>
        <p class="lead">Declaratively expressed command-line arguments via regular expressions</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Getopt::Declare.3pm.html">
      <span itemprop="name">Getopt::Declare: Declaratively expressed command-line arguments via regular expressions</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libgetopt-declare-perl/">
      <span itemprop="name">libgetopt-declare-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Getopt::Declare.3pm.html">
      <span itemprop="name">Getopt::Declare: Declaratively expressed command-line arguments via regular expressions</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">VERSION</h2>
        <div class="sectioncontent">
<p>This document describes version 1.14 of Getopt::Declare</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
 use Getopt::Declare;

 $args = Getopt::Declare-&gt;new($specification_string, $optional_source);

 # or:

 use Getopt::Declare $specification_string =&gt; $args;
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<h3>Overview</h3>
<p><em>Getopt::Declare</em> is <em>yet another</em> command-line argument parser, one which is specifically designed to be powerful but exceptionally easy to use.</p><p>To parse the command-line in @ARGV, one simply creates a <em>Getopt::Declare</em> object, by passing \*(C`Getopt::Declare::new()\*(C' a specification of the various parameters that may be encountered:</p><p>        use Getopt::Declare;         $args = Getopt::Declare-&gt;new($specification);</p><p>This may also be done in a one-liner:</p><p>        use Getopt::Declare, $specification =&gt; $args;</p><p>The specification is a single string such as this:</p><p>        $specification = q(</p><p>                -a              Process all data</p><p>                -b &lt;N:n&gt;        Set mean byte length threshold to &lt;N&gt;                                         { bytelen = $N; }</p><p>                +c &lt;FILE&gt;       Create new file &lt;FILE&gt;</p><p>                --del           Delete old file                                         { delold() }</p><p>                delete          [ditto]</p><p>                e &lt;H:i&gt;x&lt;W:i&gt;   Expand image to height &lt;H&gt; and width &lt;W&gt;                                         { expand($H,$W); }</p><p>                -F &lt;file&gt;...    Process named file(s)                                         { defer {for (@file) {process()}} }</p><p>                =getrand [&lt;N&gt;]  Get a random number                                 (or, optionally, &lt;N&gt; of them)                                         { $N = 1 unless defined $N; }</p><p>                --              Traditionally indicates end of arguments                                         { finish }         );</p><p><strong>Note that in each of the cases above, there is a tab between each</strong> parameter definition and description (even if you can't see it)! In the specification, the syntax of each parameter is declared, along with a description and (optionally) one or more actions to be performed when the parameter is encountered. The specification string may also include other usage formatting information (such as group headings or separators) as well as standard Perl comments (which are ignored).</p><p>Calling \*(C`Getopt::Delare::new()\*(C' parses the contents of the array @ARGV, extracting any arguments which match the parameters defined in the specification string, and storing the parsed values as hash elements within the new <em>Getopt::Declare</em> object being created.</p><p>Other features of the <em>Getopt::Declare</em> package include:</p><ul>
<li><p>The use of full Perl regular expressions to constrain matching of parameter components.</p></li><li><p>Automatic generation of error, usage and version information.</p></li><li><p>Optional conditional execution of embedded actions (i.e. only on successful parsing of the entire command-line)</p></li><li><p>Strict or non-strict parsing (unrecognized command-line elements may either trigger an error or may simply be left in @ARGV)</p></li><li><p>Declarative specification of various inter-parameter relationships (for example, two parameters may be declared mutually exclusive and this relationship will then be automatically enforced).</p></li><li><p>Intelligent clustering of adjacent flags (for example: the command-line sequence \*(L"-a&nbsp;-b&nbsp;-c\*(R" may be abbreviated to \*(L"-abc\*(R", unless there is also a \*(C`-abc\*(C' flag declared).</p></li><li><p>Selective or global case-insensitivity of parameters.</p></li><li><p>The ability to parse files (especially configuration files) instead of the command-line.</p></li>
</ul>
<h3>Terminology</h3>
<p>The terminology of command-line processing is often confusing, with various terms (such as \*(L"argument\*(R", \*(L"parameter\*(R", \*(L"option\*(R", \*(L"flag\*(R", etc.) frequently being used interchangeably and inconsistently in the various <em>Getopt::</em> packages available. In this documentation, the following terms are used consistently: The space-separated concatenation of the elements of the array @ARGV at the time a <em>Getopt::Declare</em> object is created. A specification of a single entity which may appear in the command-line. Always includes at least one syntax for the entity. Optionally may include other (<em>variant</em>) syntaxes, one or more <em>descriptions</em> of the entity, and/or <em>actions</em> to be performed when the entity is encountered. For example, the following is a single parameter specification (with two variants):     --window &lt;height&gt; x &lt;width&gt;     Set window to &lt;height&gt; by &lt;width&gt;                                         { setwin($width,$height); }</p><p>    --window &lt;h&gt;x&lt;w&gt;@&lt;x&gt;,&lt;y&gt;        Set window size and centroid                                         { setwin($w,$h,$x,$y); } A substring of the command-line which matches a single parameter variant. Unlike some other Getopt:: packages, in <em>Getopt::Declare</em> an argument may be a single element of @ARGV, or part of a single @ARGV element, or the concatenation of several adjacent @ARGV elements. A specification of one actual syntax variant matched by a parameter. Always consists of a leading <em>parameter flag</em> or <em>parameter variable</em>, optionally followed by one or more <em>parameter components</em> (that is, other parameter variables or <em>punctuators</em>). In the above example, \*(C`--window&nbsp;&lt;height&gt;&nbsp;x&nbsp;&lt;width&gt;\*(C' is a parameter definition. A sequence of non-space characters which introduces a parameter. Traditionally a parameter flag begins with \*(L"-\*(R" or \*(L"--\*(R", but <em>Getopt::Declare</em> allows almost any sequence of characters to be used as a flag. In the above example, \*(C`--window\*(C' is the parameter flag. A place-holder (within a parameter specification) for a value that will appear in any argument matching that parameter. In the above example, \*(C`&lt;height&gt;\*(C', \*(C`&lt;width&gt;\*(C', \*(C`&lt;h&gt;\*(C', \*(C`&lt;y&gt;\*(C', \*(C`&lt;x&gt;\*(C', and \*(C`&lt;y&gt;\*(C' are all parameter variables. A literal sequence of characters (within a parameter specification) which will appear in any argument matching that parameter. In the above example, the literals \*(C`x\*(C' and \*(C`@\*(C' are punctuators. A textual description of the purpose and/or use of a particular variant of parameter. In the above examples, the string:         Set window to &lt;height&gt; by &lt;width&gt; is a parameter description. A block of Perl code to be executed in response to encountering a specific parameter. In the above example:         { setwin($width,$height); } is a parameter action. One or more different syntaxes for a single parameter, all sharing the same leading flag, but having different trailing parameter variables and/or punctuators. <em>Getopt::Declare</em> considers all parameter definitions with the same leading flag to be merely variant forms of a single \*(L"underlying\*(R" parameter. The above example shows two parameter variants for the \*(C`--window\*(C' parameter.</p>
<h3>Parameter definitions</h3>
<p>As indicated above, a parameter specification consists of three parts: the parameter definition, a textual description, and any actions to be performed when the parameter is matched.</p><p>The parameter definition consists of a leading flag or parameter variable, followed by any number of parameter variables or punctuators, optionally separated by spaces. The parameter definition is terminated by the first tab that is encountered after the start of the parameter definition.  At least one trailing tab <em>must</em> be present.</p><p>For example, all of the following are valid <em>Getopt::Declare</em> parameter definitions:</p><p>        -v         in=&lt;infile&gt;         +range &lt;from&gt;..&lt;to&gt;         --lines &lt;start&gt; - &lt;stop&gt;         ignore bad lines         &lt;outfile&gt;</p><p><strong>Note that each of the above examples has at least one trailing tab</strong> (even if you can't see them)!. Note too that this hodge-podge of parameter styles is certainly not recommended within a single program, but is shown so as to illustrate some of the range of parameter syntax conventions <em>Getopt::Declare</em> supports.</p><p>The spaces between components of the parameter definition are optional but significant, both in the definition itself and in the arguments that the definition may match. If there is no space between components in the specification, then no space is allowed between corresponding arguments on the command-line. If there <em>is</em> space between components of the specification, then space between those components is optional on the command-line.</p><p>For example, the \*(C`--lines\*(C' parameter above matches:</p><p>        --lines1-10         --lines 1-10         --lines 1 -10         --lines 1 - 10         --lines1- 10</p><p>If it were instead specified as:</p><p>        --lines &lt;start&gt;-&lt;stop&gt;</p><p>then it would match only:</p><p>        --lines1-10         --lines 1-10</p><p>Note that the optional nature of spaces in parameter specification implies that flags and punctuators cannot contain the character '&lt;' (which is taken as the delimiter for a parameter variable) nor the character '[' (which introduces an optional parameter component - see \*(L"Optional parameter components\*(R").</p>
<h3>Types of parameter variables</h3>
<p>By default, a parameter variable will match a single blank-terminated or comma-delimited string. For example, the parameter:</p><p>        -val &lt;value&gt;</p><p>would match any of the following arguments:</p><p>        -value                  # &lt;value&gt; &lt;- "ue"         -val abcd               # &lt;value&gt; &lt;- "abcd"         -val 1234               # &lt;value&gt; &lt;- "1234"         -val "a value"          # &lt;value&gt; &lt;- "a value"</p><p>It is also possible to restrict the types of values which may be matched by a given parameter variable. For example:</p><p>        -limit &lt;threshold:n&gt;    Set threshold to some (real) value         -count &lt;N:i&gt;            Set count to &lt;N&gt; (must be an integer)</p><p>If a parameter variable is suffixed with \*(L":n\*(R", it will match any reasonable numeric value, whilst the \*(L":i\*(R" suffix restricts a parameter variable to only matching integer values. These two \*(L"type specifiers\*(R" are the simplest examples of a much more powerful mechanism, which allows parameter variables to be restricted to matching any specific regular expression. See \*(L"Defining new parameter variable types\*(R".</p><p>Parameter variables are treated as scalars by default, but this too can be altered. Any parameter variable immediately followed by an ellipsis (\*(C`...\*(C') is treated as a list variable, and matches its specified type sequentially as many times as possible. For example, the parameter specification:</p><p>        -pages &lt;page:i&gt;...</p><p>would match either of the following arguments:</p><p>        -pages 1         -pages 1 2 7 20</p><p>Note that both scalar and list parameter variables are \*(L"respectful\*(R" of the flags of other parameters as well as their own trailing punctuators. For example, given the specifications:</p><p>        -a         -b &lt;b_list&gt;...         -c &lt;c_list&gt;... ;</p><p>The following arguments will be parsed as indicated:</p><p>        -b -d -e -a             # &lt;b_list&gt;  &lt;-  ("-d", "-e")         -b -d ;                 # &lt;b_list&gt;  &lt;-  ("-d", ";")         -c -d ;                 # &lt;c_list&gt;  &lt;-  ("-d")</p><p>List parameter variables are also \*(L"repectful\*(R" of the needs of subsequent parameter variables. That is, a parameter specification like:</p><p>        -copy &lt;files&gt;... &lt;dir&gt;</p><p>will behave as expected, putting all but the last string after the \*(C`-copy\*(C' flag into the parameter variable \*(C`&lt;files&gt;\*(C', whilst the very last string is assigned to \*(C`&lt;dir&gt;\*(C'.</p>
<h3>Optional parameter components</h3>
<p>Except for the leading flag, any part of a parameter definition may be made optional by placing it in square brackets. For example:</p><p>        +range &lt;from&gt; [..] [&lt;to&gt;]</p><p>which matches any of:</p><p>        +range 1..10         +range 1..         +range 1 10         +range 1</p><p>List parameter variables may also be made optional (the ellipsis must follow the parameter variable name immediately, so it goes <em>inside</em> the square brackets):</p><p>        -list [&lt;page&gt;...]</p><p>Two or more parameter components may be made jointly optional, by specifying them in the same pair of brackets. Optional components may also be nested. For example:</p><p>        -range &lt;from&gt; [.. [&lt;to&gt;] ]</p><p>Scalar optional parameter variables (such as \*(C`[&lt;to&gt;]\*(C') are given undefined values if they are skipped during a successful parameter match. List optional parameter variables (such as \*(C`[&lt;page&gt;...]\*(C') are assigned an empty list if unmatched.</p><p>One important use for optional punctuators is to provide abbreviated versions of specific flags. For example:</p><p>        -num[eric]              # Match "-num" or "-numeric"         -lexic[ographic]al      # Match "-lexical" or "-lexicographical"         -b[ells+]w[histles]     # Match "-bw" or "-bells+whistles"</p><p>Note that the actual flags for these three parameters are \*(C`-num\*(C', \*(C`-lexic\*(C' and \*(C`-b\*(C', respectively.</p>
<h3>Parameter descriptions</h3>
<p>Providing a textual description for each parameter (or parameter variant) is optional, but strongly recommended. Apart from providing internal documentation, parameter descriptions are used in the automatically-generated usage information provided by <em>Getopt::Declare</em>.</p><p>Descriptions may be placed after the first tab(s) following the parameter definition and may be continued on subsequent lines, provided those lines do not contain any tabs after the first non-whitespace character (because any such line will instead be treated as a new parameter specification). The description is terminated by a blank line, an action specification (see below) or another parameter specification.</p><p>For example:</p><p>        -v                              Verbose mode         in=&lt;infile&gt;                     Specify input file                                         (will fail if file does not exist)</p><p>        +range &lt;from&gt;..&lt;to&gt;             Specify range of columns to consider         --lines &lt;start&gt; - &lt;stop&gt;        Specify range of lines to process</p><p>        ignore bad lines                Ignore bad lines :-)</p><p>        &lt;outfile&gt;                       Specify an output file</p><p>The parameter description may also contain special directives which alter the way in which the parameter is parsed. See the various subsections of \*(L"\s-1ADVANCED\s0 \s-1FEATURES\s0\*(R" for more information.</p><p>A common mistake is to use tabs to separate components of a parameter description:</p><p>        -delete &lt;filename&gt;              Delete the named file         -d      &lt;filename&gt;              Delete the named file</p><p>The tabs after "-delete" and "-d" do a good job of lining up the two "&lt;filename&gt;" parameter variables, but they also mark the start of the description, which means that after descriptions are stripped, the two parameters are:</p><p>        -delete         -d</p><p>The solution is to use spaces, not tabs, to align components within a parameter specification.</p>
<h3>Actions</h3>
<p>Each parameter specification may also include one or more blocks of Perl code, specified in a pair of curly brackets (which <em>must</em> start on a new line).</p><p>Each action is executed as soon as the corresponding parameter is successfully matched in the command-line (but see \*(L"Deferred actions\*(R" for a means of delaying this response).</p><p>For example:</p><p>        -v      Verbose mode                         { $::verbose = 1; }         -q      Quiet mode                         { $::verbose = 0; }</p><p>Actions are executed (as \*(C`do\*(C' blocks) in the package in which the <em>Getopt::Declare</em> object containing them was created. Hence they have access to all package variables and functions in that namespace.</p><p>In addition, each parameter variable belonging to the corresponding parameter is made available as a (block-scoped) Perl variable with the same name. For example:</p><p>        +range &lt;from&gt;..&lt;to&gt;     Set range                                         { setrange($from, $to); }</p><p>        -list &lt;page:i&gt;...       Specify pages to list                                         { foreach (@page)                                           {                                                 list($_) if $_ &gt; 0;                                           }                                         }</p><p>Note that scalar parameter variables become scalar Perl variables, and list parameter variables become Perl arrays.</p>
<h3>Predefined variables available in actions</h3>
<p>Within an action the following variables are also available: Stores the identifier of the current parameter: either the leading flag or, if there is no leading flag, the name of the first parameter variable. Stores the substring matched by each punctuator in the current parameter. The hash is indexed by the punctuator itself. The main purpose of this variable is to allow actions to check whether optional punctuators were in fact matched. For example:         -v[erbose]      Set verbose mode                         (doubly verbose if full word used)                             { if ($_PUNCT_{"erbose"}) { $verbose = 2; }                               else                    { $verbose = 1; }                             } This hash stores boolean values indicating whether or not a given parameter has already been found. The hash keys are the leading flags or parameter variables of each parameter. For instance, the following specification makes the \*(C`-q\*(C' and \*(C`-v\*(C' parameters mutually exclusive (but see \*(L"Parameter dependencies\*(R" for a <em>much</em> easier way to achieve this effect):         -v      Set verbose mode                         { die "Can&apos;t be verbose *and* quiet!&#92;n"                                 if $_FOUND_{"-q"};                         }</p><p>        -q      Set quiet mode                         { die "Can&apos;t be quiet *and* verbose!&#92;n"                                 if $_FOUND_{"-v"};                         } For reasons that will be explained in \*(L"Rejection and termination\*(R", a given parameter is not marked as found until <em>after</em> its associated actions are executed. That is, $_FOUND_{$_PARAM_} will not (usually) be true during a parameter action.</p><p>Note that, although numerous other internal variables on which the generated parser relies are also visible within parameter actions, accessing any of them may have Dire Consequences. Moreover, these other variables may no longer be accessible (or even present) in future versions of <em>Getopt::Declare</em>. All such internal variables have names beginning with an underscore. Avoiding such variables names will ensure there are no conflicts between actions and the parser itself.</p>
<h3>The command-line parsing process</h3>
<p>Whenever a <em>Getopt::Declare</em> object is created, the current command-line is parsed sequentially, by attempting to match each parameter in the object's specification string against the current elements in the @ARGV array (but see \*(L"Parsing from other sources\*(R"). The order in which parameters are compared against the arguments in @ARGV is determined by three rules:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>Parameters with longer flags are tried first. Hence the command-line argument \*(L"-quiet\*(R" would be parsed as matching the parameter \*(C`-quiet\*(C' rather than the parameter \*(C`-q&nbsp;&lt;string&gt;\*(C', even if the \*(C`-q\*(C' parameter was defined first.</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>Parameter <em>variants</em> with the most components are matched first. Hence the argument \*(L"-rand 12345\*(R" would be parsed as matching the parameter variant \*(C`-rand&nbsp;&lt;seed&gt;\*(C', rather than the variant \*(C`-rand\*(C', even if the \*(L"shorter\*(R" \*(C`-rand\*(C' variant was defined first.</p>
  </dd>
  <dt>
    3.
  </dt>
  <dd>
    <p>Otherwise, parameters are matched in the order they are defined.</p>
  </dd>

</dl>
<p>Note, however, that the <em>arguments</em> themselves are considered strictly in the order they appear on the command line. That is: Getopt::Declare takes the first (leftmost) argument and compares it against all the parameter specifications in the order described above. Then it gets the second argument and does the same. Et cetera. So, whilst parameters are considered \*(L"flags-first-by-length\*(R", arguments are considered \*(L"left-to-right\*(R". If that seems paradoxical, you probably need to review the difference between \*(L"arguments\*(R" and \*(L"parameters\*(R", as explained in \*(L"Terminology\*(R".</p><p>Elements of @ARGV which do not match any defined parameter are collected during the parse and are eventually put back into @ARGV (see \*(L"Strict and non-strict command-line parsing\*(R").</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ADVANCED FEATURES</h2>
        <div class="sectioncontent">
<h3>Case-insensitive parameter matching</h3>
<p>By default, a <em>Getopt::Declare</em> object parses the command-line in a <em>case-sensitive</em> manner. The \*(C`[nocase]\*(C' directive enables a specific parameter (or, alternatively, <em>all</em> parameters) to be matched case-insensitively.</p><p>If a \*(C`[nocase]\*(C' directive is included in the description of a specific parameter variant, then that variant (only) will be matched without regard for case. For example, the specification:</p><p>        -q      Quiet mode [nocase]</p><p>        -v      Verbose mode</p><p>means that the arguments \*(L"-q\*(R" and \*(L"-Q\*(R" will both match the \*(C`-q\*(C' parameter, but that only \*(L"-v\*(R" (and <em>not</em> \*(L"-V\*(R") will match the \*(C`-v\*(C' parameter.</p><p>If a \*(C`[nocase]\*(C' directive appears anywhere <em>outside</em> a parameter description, then the entire specification is declared case-insensitive and all parameters defined in that specification are matched without regard to case.</p>
<h3>Termination and rejection</h3>
<p>It is sometimes useful to be able to terminate command-line processing before all arguments have been parsed. To this end, <em>Getopt::Declare</em> provides a special local operator (\*(C`finish\*(C') which may be used within actions. The \*(C`finish\*(C' operator takes a single optional argument. If the argument is true (or omitted), command-line processing is terminated at once (although the current parameter is still marked as having been successfully matched). For example:</p><p>        --      Traditional argument list terminator                         { finish }</p><p>        -no--   Use non-traditional terminator instead                         { $nontrad = 1; }</p><p>        ##      Non-traditional terminator (only valid if -no-- flag seen)                         { finish($nontrad); }</p><p>It is also possible to reject a single parameter match from within an action (and then continue trying other candidates). This allows actions to be used to perform more sophisticated tests on the type of a parameter variable, or to implement complicated parameter interdependencies.</p><p>To reject a parameter match, the \*(C`reject\*(C' operator is used. The \*(C`reject\*(C' operator takes an optional argument. If the argument is true (or was omitted), the current parameter match is immediately rejected. For example:</p><p>        -ar &lt;R:n&gt;       Set aspect ratio (must be in the range (0..1])                                 {                                   $::sawaspect++;                                   reject $R &lt;= 0 || $R &gt; 1 ;                                   setaspect($R);                                 }</p><p>        -q              Quiet option (not available on Wednesdays)                                 {                                   reject((localtime)[6] == 3);                                   $::verbose = 0;                                 }</p><p>Note that any actions performed <em>before</em> the call to \*(C`reject\*(C' will still have effect (for example, the variable $::sawaspect remains incremented even if the aspect ratio parameter is subsequently rejected).</p><p>The \*(C`reject\*(C' operator may also take a second argument, which is used as an error message if the rejected argument subsequently fails to match any other parameter. For example:</p><p>        -q      Quiet option (not available on Wednesdays)                         {                           reject((localtime)[6] == 3 =&gt; "Not today!");                           $::verbose = 0;                         }</p>
<h3>Specifying other parameter variable types</h3>
<p>As was mentioned in \*(L"Type of parameter variables\*(R", parameter variables can be restricted to matching only numbers or only integers by using the type specifiers \*(L":n\*(R" and \*(L":i\*(R". <em>Getopt::Declare</em> provides seven other inbuilt type specifiers, as well as two mechanisms for defining new restrictions on parameter variables.</p><p>The other inbuilt type specifiers are:</p>
<dl class='dl-vertical'>
  <dt>
    :+i
  </dt>
  <dd>
    <p>which restricts a parameter variable to matching positive, non-zero integers (that is: 1, 2, 3, etc.)</p>
  </dd>
  <dt>
    :+n
  </dt>
  <dd>
    <p>which restricts a parameter variable to matching positive, non-zero numbers (that is, floating point numbers strictly greater than zero).</p>
  </dd>
  <dt>
    :0+i
  </dt>
  <dd>
    <p>which restricts a parameter variable to matching non-negative integers (that is: 0, 1, 2, 3, etc.)</p>
  </dd>
  <dt>
    :0+n
  </dt>
  <dd>
    <p>which restricts a parameter variable to matching non-negative numbers (that is, floating point numbers greater than or equal to zero).</p>
  </dd>
  <dt>
    :qs
  </dt>
  <dd>
    <p>which allows a parameter variable to match any quote-delimited or whitespace-terminated string. Note that this specifier simply makes explicit the default behaviour.</p>
  </dd>
  <dt>
    :id
  </dt>
  <dd>
    <p>which allows a parameter variable to match any identifier sequence. That is: a alphabetic or underscore, followed by zero-or-more alphanumerics or underscores.</p>
  </dd>
  <dt>
    :if
  </dt>
  <dd>
    <p>which is used to match input file names. Like type ':s', type ':if' matches any quote-delimited or whitespace-terminated string. However this type does <em>not</em> respect other command-line flags and also requires that the matched string is either \*(L"-\*(R" (indicating standard input) or the name of a readable file.</p>
  </dd>
  <dt>
    :of
  </dt>
  <dd>
    <p>which is used to match output file names. It is exactly like type ':if' except that it requires that the string is either \*(L"-\*(R" (indicating standard output) or the name of a file that is either writable or non-existent.</p>
  </dd>
  <dt>
    :s
  </dt>
  <dd>
    <p>which allows a parameter variable to match any quote-delimited or whitespace-terminated string. Note that this specifier simply makes explicit the default behaviour.</p>
  </dd>

</dl>
<p>For example:</p><p>        -repeat &lt;count:+i&gt;      Repeat &lt;count&gt; times (must be &gt; 0)</p><p>        -scale &lt;factor:0+n&gt;     Set scaling factor (cannot be negative)</p><p>Alternatively, parameter variables can be restricted to matching a specific regular expression, by providing the required pattern explicitly (in matched \*(L"/\*(R" delimiters after the \*(L":\*(R"). For example:</p><p>        -parity &lt;p:/even|odd|both/&gt;     Set parity (&lt;p&gt; must be "even",                                         "odd" or "both")</p><p>        -file &lt;name:/&#92;w*&#92;.[A-Z]{3}/&gt;    File name must have a three-                                         capital-letter extension</p><p>If an explicit regular expression is used, there are three \*(L"convenience\*(R" extensions available: If the sequence %T appears in a pattern, it is translated to a negative lookahead containing the parameter variable's trailing context. Hence the parameter definition:         -find &lt;what:/(%T&#92;.)+/&gt; ; ensures that the command line argument \*(L"-find abcd;\*(R" causes \*(C`&lt;what&gt;\*(C' to match \*(L"abcd\*(R", <em>not</em> \*(L"abcd;\*(R". If the sequence %D appears in a pattern, it is translated into a subpattern which matches any single digit (like a \*(C`&#92;d\*(C'), but only if that digit would <em>not</em> match the parameter variable's trailing context. Hence %D is just a convenient short-hand for \*(C`(?:%T&#92;d)\*(C' (and is actually implemented that way). By default, any explicit pattern is modified by <em>Getopt::Declare</em> so that it fails if the argument being matched represents some defined parameter flag. If however the sequence %F appears anywhere in a pattern, it causes the pattern <em>not</em> to reject strings which would otherwise match another flag. By default, no inbuilt type allows arguments to match a flag.</p>
<h3>Defining new parameter variable types</h3>
<p>Explicit regular expressions are very powerful, but also cumbersome to use (or reuse) in some situations. <em>Getopt::Declare</em> provides a general \*(L"parameter variable type definition\*(R" mechanism to simplify such cases.</p><p>To declare a new parameter variable type, the \*(C`[pvtype:...]\*(C' directive is used. A \*(C`[pvtype...]\*(C' directive specifies the name, matching pattern, and action for the new parameter variable type (though both the pattern and action are optional).</p><p>The name string may be <em>any</em> whitespace-terminated sequence of characters which does not include a \*(L"&gt;\*(R". The name may also be specified within a pair of quotation marks (single or double) or within any Perl quotelike operation. For example:</p><p>        [pvtype: num     ]      # Makes this valid: -count &lt;N:num&gt;         [pvtype: &apos;a num&apos; ]      # Makes this valid: -count &lt;N:a num&gt;         [pvtype: q{nbr}  ]      # Makes this valid: -count &lt;N:nbr&gt;</p><p>The pattern is used in initial matching of the parameter variable. Patterns are normally specified as a \*(L"/.../\*(R"-delimited Perl regular expression:</p><p>        [pvtype: num      /&#92;d+/          ]         [pvtype: &apos;a num&apos;  /&#92;d+(?:&#92;.&#92;d*)/ ]         [pvtype: q{nbr}   /[+-]?&#92;d+/     ]</p><p>Note that the regular expression should <em>not</em> contain any capturing parentheses, as this will interfere with the correct processing of subsequent parameter variables.</p><p>Alternatively the pattern associated with a new type may be specified as a \*(L":\*(R" followed by the name of another parameter variable type (in quotes if necessary). In this case the new type matches the same pattern (and action! - see below) as the named type.  For example:</p><p>        [pvtype: num      :+i      ]    # &lt;X:num&gt; is the same as &lt;X:+i&gt;         [pvtype: &apos;a num&apos;  :n       ]    # &lt;X:a num&gt; is the same as &lt;X:n&gt;         [pvtype: q{nbr}   :&apos;a num&apos; ]    # &lt;X:nbr&gt; is also the same as &lt;X:n&gt;</p><p>As a third alternative, the pattern may be omitted altogether, in which case the new type matches whatever the inbuilt pattern \*(L":s\*(R" matches.</p><p>The optional action which may be included in any \*(C`[pvtype:...]\*(C' directive is executed <em>after</em> the corresponding parameter variable matches the command line but <em>before</em> any actions belonging to the enclosing parameter are executed. Typically, such type actions will call the \*(C`reject\*(C' operator (see \*(L"Termination and rejection\*(R") to test extra conditions, but any valid Perl code is acceptable. For example:</p><p>        [pvtype: num    /&#92;d+/    { reject if (localtime)[6]==3 }      ]         [pvtype: &apos;a num&apos;  :n       { print "a num!" }           ]         [pvtype: q{nbr}   :&apos;a num&apos; { reject $::no_nbr }         ]</p><p>If a new type is defined in terms of another (for example, \*(L":a num\*(R" and \*(L":nbr\*(R" above), any action specified by that new type is <em>prepended</em> to the action of that other type. Hence:</p><ul>
<li><p>the new type \*(L":num\*(R" matches any string of digits, but then rejects the match if it's Wednesday.</p></li><li><p>the new type \*(L":a num\*(R" matches any string of digits (like its parent type \*(L":num\*(R"), <em>then</em> prints out \*(L"a num!\*(R", <em>and then</em> rejects the match if it's Wednesday (like its parent type \*(L":num\*(R").</p></li><li><p>the new type \*(L":nbr\*(R" matches any string of digits (like its parent type \*(L":a num\*(R"), but then rejects the match if the global $::no_nbr variable is true. Otherwise it next prints out \*(L"a num!\*(R" (like its parent type \*(L":a num\*(R"), and finally rejects the match if it's Wednesday (like its grandparent type \*(L":num\*(R").</p></li>
</ul><p>When a type action is executed (as part of a particular parameter match), three local variables are available: which contains the value matched by the type's pattern. It is this value which is ultimately assigned to the local Perl variable which is available to parameter actions. Hence if the type action changes the value of $_VAL_, that changed value becomes the \*(L"real\*(R" value of the corresponding parameter variable (see the Roman numeral example below). which contains the name of the parameter variable being matched. which contains the name of the parameter currently being matched.</p><p>Here is a example of the use of these variables:</p><p>        $specs = q{         [pvtype: type  /[OAB]|AB&apos;)/                                     ]         [pvtype: Rh?   /Rh[+-]/                                         ]         [pvtype: days  :+i  { reject $_VAL_&lt;14 " $_PARAM_ (too soon!)"} ]</p><p>          -donated &lt;D:days&gt;               Days since last donation           -applied &lt;A:days&gt;               Days since applied to donate</p><p>          -blood &lt;type:type&gt; [&lt;rh:Rh?&gt;]   Specify blood type                                           and (optionally) rhesus factor         };         $args = Getopt::Declare-&gt;new($specs);</p><p>In the above example, the \*(L":days\*(R" parameter variable type is defined to match whatever the \*(L":+i\*(R" type matches (that is positive, non-zero integers), with the proviso that the matching value ($_VAL_) must be at least 14. If a shorter value is specified for \*(C`&lt;D&gt;\*(C', or \*(C`&lt;A&gt;\*(C' parameter variables, then <em>Getopt::Declare</em> would issue the following (respective) error messages:</p><p>        Error: -donated (too soon!)         Error: -applied (too soon!)</p><p>Note that the \*(L"inbuilt\*(R" parameter variable types (\*(L"i\*(R", \*(L"n\*(R", etc.) are really just predefined type names, and hence can be altered if necessary:</p><p>        $args = Getopt::Declare-&gt;new(&lt;&lt;&apos;EOPARAM&apos;);</p><p>        [pvtype: &apos;n&apos; /[MDCLXVI]+/ { reject !($_VAL_=to_roman $_VAL_) } ]</p><p>                -index &lt;number:n&gt;       Index number                         { print $data[$number]; }         EOPARAM</p><p>The above \*(C`[pvtype:...]\*(C' directive means that all parameter variables specified with a type \*(L":n\*(R" henceforth only match valid Roman numerals, but that any such numerals are <em>automatically</em> converted to ordinary numbers (by passing $_VAL_) through the \*(C`to_roman\*(C' function).</p><p>Hence the requirement that all \*(L":n\*(R" numbers now must be Roman can be imposed <em>transparently</em>, at least as far as the actual parameter variables which use the \*(L":n\*(R" type are concerned. Thus $number can be still used to index the array @data despite the new restrictions placed upon it by the redefinition of type \*(L":n\*(R".</p><p>Note too that, because the \*(L":+n\*(R" and \*(L":0+n\*(R" types are implicitly defined in terms of the original \*(L":n\*(R" type (as if the directives:</p><p>        [pvtype: &apos;+n&apos;  :n { reject if $_VAL &lt;= 0  }  ]         [pvtype: &apos;0+n&apos; :n { reject if $_VAL &lt; 0   }  ]</p><p>were included in every specification), the above redefinition of \*(L":n\*(R" affects those types as well. In such cases the format conversion is performed <em>before</em> the \*(L"sign\*(R" tests (in other words, the \*(L"inherited\*(R" actions are performed <em>after</em> any newly defined ones).</p><p>Parameter variable type definitions may appear anywhere in a <em>Getopt::Declare</em> specification and are effective for the entire scope of the specification. In particular, new parameter variable types may be defined <em>after</em> they are used.</p>
<h3>Undocumented parameters</h3>
<p>If a parameter description is omitted, or consists entirely of whitespace, or contains the special directive \*(C`[undocumented]\*(C', then the parameter is still parsed as normal, but will not appear in the automatically generated usage information (see \*(L"Usage information\*(R").</p><p>Apart from allowing for \*(L"secret\*(R" parameters (a dubious benefit), this feature enables the programmer to specify some undocumented action which is to be taken on encountering an otherwise unknown argument. For example:</p><p>        &lt;unknown&gt;                         { handle_unknown($unknown); } Sometimes it is desirable to provide two or more alternate flags for the same behaviour (typically, a short form and a long form). To reduce the burden of specifying such pairs, the special directive \*(C`[ditto]\*(C' is provided. If the description of a parameter <em>begins</em> with a \*(C`[ditto]\*(C' directive, that directive is replaced with the description for the immediately preceding parameter (including any other directives). For example:</p><p>        -v              Verbose mode         --verbose       [ditto] (long form)</p><p>In the automatically generated usage information this would be displayed as:</p><p>        -v              Verbose mode         --verbose          "     "   (long form)</p><p>Furthermore, if the \*(L"dittoed\*(R" parameter has no action(s) specified, the action(s) of the preceding parameter are reused. For example, the specification:</p><p>        -v              Verbose mode                                 { $::verbose = 1; }         --verbose       [ditto]</p><p>would result in the \*(C`--verbose\*(C' option setting $::verbose just like the \*(C`-v\*(C' option. On the other hand, the specification:</p><p>        -v              Verbose mode                                 { $::verbose = 1; }         --verbose       [ditto]                                 { $::verbose = 2; }</p><p>would give separate actions to each flag.</p>
<h3>Deferred actions</h3>
<p>It is often desirable or necessary to defer actions taken in response to particular flags until the entire command-line has been parsed. The most obvious case is where modifier flags must be able to be specified <em>after</em> the command-line arguments they modify.</p><p>To support this, <em>Getopt::Declare</em> provides a local operator (\*(C`defer\*(C') which delays the execution of a particular action until the command-line processing is finished. The \*(C`defer\*(C' operator takes a single block, the execution of which is deferred until the command-line is fully and successfully parsed. If command-line processing <em>fails</em> for some reason (see \*(L"\s-1DIAGNOSTICS\s0\*(R"), the deferred blocks are never executed.</p><p>For example:</p><p>        &lt;files&gt;...      Files to be processed                             { defer { foreach (@files) { proc($_); } } }</p><p>        -rev[erse]      Process in reverse order                             { $::ordered = -1; }</p><p>        -rand[om]       Process in random order                             { $::ordered = 0; }</p><p>With the above specification, the \*(C`-rev\*(C' and/or \*(C`-rand\*(C' flags can be specified <em>after</em> the list of files, but still affect the processing of those files. Moreover, if the command-line parsing fails for some reason (perhaps due to an unrecognized argument), the deferred processing will not be performed.</p>
<h3>Flag clustering</h3>
<p>Like some other <em>Getopt::</em> packages, <em>Getopt::Declare</em> allows parameter flags to be \*(L"clustered\*(R". That is, if two or more flags have the same \*(L"flag prefix\*(R" (one or more leading non-whitespace, non-alphanumeric characters), those flags may be concatenated behind a single copy of that flag prefix. For example, given the parameter specifications:</p><p>        -+              Swap signs         -a              Append mode         -b              Bitwise compare         -c &lt;FILE&gt;       Create new file         +del            Delete old file         +e &lt;NICE:i&gt;     Execute (at specified nice level) when complete</p><p>The following command-lines (amongst others) are all exactly equivalent:</p><p>        -a -b -c newfile +e20 +del         -abc newfile +dele20         -abcnewfile+dele20         -abcnewfile +e 20del</p><p>The last two alternatives are correctly parsed because <em>Getopt::Declare</em> allows flag clustering at <em>any point</em> where the remainder of the command-line being processed starts with a non-whitespace character and where the remaining substring would not otherwise immediately match a parameter flag.</p><p>Hence the trailing \*(L"+dele20\*(R" in the third command-line example is parsed as \*(L"+del&nbsp;+e20\*(R" and not \*(L"-+&nbsp;del&nbsp;+e20\*(R". This is because the previous \*(L"-\*(R" prefix is <em>not</em> propagated (since the leading \*(L"+del\*(R" <em>is</em> a valid flag).</p><p>In contrast, the trailing \*(L"+e&nbsp;20del\*(R" in the fourth example is parsed as \*(L"+e&nbsp;20&nbsp;+del\*(R" because, after the \*(L"&nbsp;20\*(R" is parsed (as the integer parameter variable \*(C`&lt;NICE&gt;\*(C'), the next characters are \*(L"del\*(R", which <em>do not</em> form a flag themselves unless prefixed with the controlling \*(L"+\*(R".</p><p>In some circumstances a clustered sequence of flags on the command-line might also match a single (multicharacter) parameter flag. For example, given the specifications:</p><p>        -a              Blood type is A         -b              Blood type is B         -ab             Blood type is AB         -ba             Donor has a Bachelor of Arts</p><p>A command-line argument \*(L"-aba\*(R" might be parsed as \*(L"-a&nbsp;-b&nbsp;-a\*(R" or \*(L"-a&nbsp;-ba\*(R" or \*(L"-ab&nbsp;-a\*(R". In all such cases, <em>Getopt::Declare</em> prefers the longest unmatched flag first. Hence the previous example would be parsed as \*(L"-ab&nbsp;-a\*(R", unless the \*(C`-ab\*(C' flag had already appeared in the command-line (in which case, it would be parsed as \*(L"-a&nbsp;-ba\*(R").</p><p>These rules are designed to produce consistency and \*(L"least surprise\*(R", but (as the above example illustrates) may not always do so. If the idea of unconstrained flag clustering is too libertarian for a particular application, the feature may be restricted (or removed completely), by including a \*(C`[cluster:...]\*(C' directive anywhere in the specification string.</p><p>The options are: This version of the directive allows any flag to be clustered (that is, it merely makes explicit the default behaviour). This version of the directive restricts clustering to parameters which are \*(L"pure\*(R" flags (that is, those which have no parameter variables or punctuators). This version of the directive restricts clustering to parameters which are \*(L"pure\*(R" flags, and which consist of a flag prefix followed by a single alphanumeric character. This version of the directive turns off clustering completely.</p><p>For example:</p><p>        $args = Getopt::Declare-&gt;new(&lt;&lt;&apos;EOSPEC&apos;);                 -a              Append mode                 -b              Back-up mode                 -bu             [ditto]                 -c &lt;file&gt;       Copy mode                 -d [&lt;file&gt;]     Delete mode                 -e[xec]         Execute mode</p><p>                [cluster:singles]         EOSPEC</p><p>In the above example, only the \*(C`-a\*(C' and \*(C`-b\*(C' parameters may be clustered. The \*(C`-bu\*(C' parameter is excluded because it consists of more than one letter, whilst the \*(C`-c\*(C' and \*(C`-d\*(C' parameters are excluded because they take (or may take, in \*(C`-d\*(C''s case) a variable. The \*(C`-e[xec]\*(C' parameter is excluded because it may take a trailing punctuator (\*(C`[xec]\*(C').</p><p>By comparison, if the directive had been \*(C`[cluster: flags]\*(C', then \*(C`-bu\*(C' <em>could</em> be clustered, though \*(C`-c\*(C', \*(C`-d\*(C' and \*(C`-e[xec]\*(C' would still be excluded since they are not \*(L"pure flags\*(R").</p>
<h3>Strict and non-strict command-line parsing</h3>
<p>\*(L"Strictness\*(R" in <em>Getopt::Declare</em> refers to the way in which unrecognized command-line arguments are handled. By default, <em>Getopt::Declare</em> is \*(L"non-strict\*(R", in that it simply skips silently over any unrecognized command-line argument, leaving it in @ARGV at the conclusion of command-line processing (but only if they were originally parsed from @ARGV).</p><p>No matter where they came from, the remaining arguments are also available by calling the \*(C`unused\*(C' method on the Getopt::Declare object, after it has parsed. In a list context, this method returns a list of the unprocessed arguments; in a scalar context a single string with the unused arguments concatenated is returned.</p><p>Likewise, there is a \*(C`used\*(C' method that returns the arguments that were successfully processed by the parser.</p><p>However, if a new <em>Getopt::Declare</em> object is created with a specification string containing the \*(C`[strict]\*(C' directive (at any point in the specification):</p><p>        $args = Getopt::Declare-&gt;new(&lt;&lt;&apos;EOSPEC&apos;);</p><p>                [strict]</p><p>                -a      Append mode                 -b      Back-up mode                 -c      Copy mode         EOSPEC</p><p>then the command-line is parsed \*(L"strictly\*(R". In this case, any unrecognized argument causes an error message (see \*(L"\s-1DIAGNOSTICS\s0\*(R") to be written to \s-1STDERR\s0, and command-line processing to (eventually) fail. On such a failure, the call to \*(C`Getopt::Declare::new()\*(C' returns \*(C`undef\*(C' instead of the usual hash reference.</p><p>The only concession that \*(L"strict\*(R" mode makes to the unknown is that, if command-line processing is prematurely terminated via the \*(C`finish\*(C' operator, any command-line arguments which have not yet been examined are left in @ARGV and do not cause the parse to fail (of course, if any unknown arguments were encountered <em>before</em> the \*(C`finish\*(C' was executed, those earlier arguments <em>will</em> cause command-line processing to fail).</p><p>The \*(L"strict\*(R" option is useful when <em>all</em> possible parameters can be specified in a single <em>Getopt::Declare</em> object, whereas the \*(L"non-strict\*(R" approach is needed when unrecognized arguments are either to be quietly tolerated, or processed at a later point (possibly in a second <em>Getopt::Declare</em> object).</p>
<h3>Parameter dependencies</h3>
<p><em>Getopt::Declare</em> provides five other directives which modify the behaviour of the command-line parser in some way. One or more of these directives may be included in any parameter description. In addition, the \*(C`[mutex:...]\*(C' directive may also appear in any usage \*(L"decoration\*(R" (see \*(L"Usage information\*(R").</p><p>Each directive specifies a particular set of conditions that a command-line must fulfil (for example, that certain parameters may not appear on the same command-line). If any such condition is violated, an appropriate error message is printed (see \*(L"\s-1DIAGNOSTICS\s0\*(R"). Furthermore, once the command-line is completely parsed, if any condition was violated, the program terminates (whilst still inside \*(C`Getopt::Declare::new()\*(C').</p><p>The directives are: Specifies that an argument matching at least one variant of the corresponding parameter <em>must</em> be specified somewhere in the command-line. That is, if two or more required parameters share the same flag, it suffices that <em>any one</em> of them matches an argument (recall that <em>Getopt::Declare</em> considers all parameter specifications with the same flag merely to be variant forms of a single \*(L"underlying\*(R" parameter). If an argument matching a \*(L"required\*(R" flag is <em>not</em> found in the command-line, an error message to that effect is issued, command-line processing fails, and \*(C`Getopt::Declare::new()\*(C' returns \*(C`undef\*(C'. By default, <em>Getopt::Declare</em> objects allow each of their parameters to be matched only once (that is, once any variant of a particular parameter matches an argument, <em>all</em> variants of that same parameter are subsequently excluded from further consideration when parsing the rest of the command-line). However, it is sometimes useful to allow a particular parameter to match more than once.  Any parameter whose description includes the directive \*(C`[repeatable]\*(C' is <em>never</em> excluded as a potential argument match, no matter how many times it has matched previously:         -nice           Increase nice value (linearly if repeated)                         [repeatable]                                 { set_nice( get_nice()+1 ); }</p><p>        -w              Toggle warnings [repeatable] for the rest                         of the command-line                                 { $warn = !$warn; } As a more general mechanism is a \*(C`[repeatable]\*(C' directive appears in a specification anywhere other than a flag's description, then <em>all</em> parameters are marked repeatable:         [repeatable]</p><p>        -nice           Increase nice value (linearly if repeated)                                 { set_nice( get_nice()+1 ); }</p><p>        -w              Toggle warnings for the rest of the command-line                                 { $warn = !$warn; } The \*(C`[mutex:...]\*(C' directive specifies that the parameters whose flags it lists are mutually exclusive. That is, no two or more of them may appear in the same command-line. For example:         -case           set to all lower case         -CASE           SET TO ALL UPPER CASE         -Case           Set to sentence case         -CaSe           SeT tO "RAnSom nOTe" CasE</p><p>                        [mutex: -case -CASE -Case -CaSe] The interaction of the \*(C`[mutex:...]\*(C' and \*(C`[required]\*(C' directives is potentially awkward in the case where two \*(L"required\*(R" arguments are also mutually exclusive (since the \*(C`[required]\*(C' directives insist that both parameters must appear in the command-line, whilst the \*(C`[mutex:...]\*(C' directive expressly forbids this). <em>Getopt::Declare</em> resolves such contradictory constraints by relaxing the meaning of \*(L"required\*(R" slightly. If a flag is marked \*(L"required\*(R", it is considered \*(L"found\*(R" for the purposes of error checking if it or <em>any other flag with which it is mutually</em> exclusive appears on the command-line. Hence the specifications:         -case           set to all lower case      [required]         -CASE           SET TO ALL UPPER CASE      [required]         -Case           Set to sentence case       [required]         -CaSe           SeT tO "RAnSom nOTe" CasE  [required]</p><p>                        [mutex: -case -CASE -Case -CaSe] mean that <em>exactly one</em> of these four flags must appear on the command-line, but that the presence of any one of them will suffice to satisfy the \*(L"requiredness\*(R" of all four. It should also be noted that mutual exclusion is only tested for <em>after</em> a parameter has been completely matched (that is, after the execution of its actions, if any). This prevents \*(L"rejected\*(R" parameters (see \*(L"Termination and rejection\*(R") from incorrectly generating mutual exclusion errors. However, it also sometimes makes it necessary to defer the actions of a pair of mutually exclusive parameters (for example, if those actions are expensive or irreversible). The \*(C`[excludes:...]\*(C' directive provides a \*(L"pairwise\*(R" version of mutual exclusion, specifying that the current parameter is mutually exclusive with all the other parameters lists, but those other parameters are not mutually exclusive with each other. That is, whereas the specification:         -left           Justify to left margin         -right          Justify to right margin         -centre         Centre each line</p><p>        [mutex: -left -right -centre] means that only one of these three justification alternatives can ever be used at once, the specification:         -left           Justify to left margin         -right          Justify to right margin         -centre         Centre each line  [excludes: -left -right] means that \*(C`-left\*(C' and \*(C`-right\*(C' can still be used together (probably to indicate "left <em>and</em> right" justification), but that neither can be used with \*(C`-centre\*(C'. Note that the \*(C`[excludes:...]\*(C' directive also differs from the \*(C`[mutex:...]\*(C' in that it is always connected with a paricular parameter, <em>implicitly</em> using the flag of that parameter as the target of exclusion. The \*(C`[requires]\*(C' directive specifies a set of flags which must also appear in order for a particular flag to be permitted in the command-line. The condition is a boolean expression, in which the terms are the flags or various parameters, and the operations are \*(C`&&\*(C', \*(C`||\*(C', \*(C`!\*(C', and bracketting. For example, the specifications:         -num            Use numeric sort order         -lex            Use "dictionary" sort order         -len            Sort on length of line (or field)</p><p>        -field &lt;N:+i&gt;   Sort on value of field &lt;N&gt;</p><p>        -rev            Reverse sort order                         [requires: -num || -lex || !(-len && -field)] means that the \*(C`-rev\*(C' flag is allowed only if either the \*(C`-num\*(C' or the \*(C`-lex\*(C' parameter has been used, or if it is not true that <em>both</em> the \*(C`-len\*(C' <em>and</em> the \*(C`-field\*(C' parameters have been used. Note that the operators \*(C`&&\*(C', \*(C`||\*(C', and \*(C`!\*(C' retain their normal Perl precedences.</p>
<h3>Parsing from other sources</h3>
<p><em>Getopt::Declare</em> normally parses the contents of @ARGV, but can be made to parse specified files instead. To accommodate this, \*(C`Getopt::Declare::new()\*(C' takes an optional second parameter, which specifies a file to be parsed. The parameter may be either: in which case \*(C`Getopt::Declare::new()\*(C' reads the corresponding handle until end-of-file, and parses the resulting text (even if it is an empty string). in which case \*(C`Getopt::Declare::new()\*(C' looks for the files <em></em><strong>$ENV</strong><em>{\s-1HOME\s0}/.${progname}rc</em> and <em></em><strong>$ENV</strong><em>{\s-1PWD\s0}/.${progname}rc</em>, concatenates their contents, and parses that. If neither file is found (or if both are inaccessible) \*(C`Getopt::Declare::new()\*(C' immediately returns zero. If a file is found but the parse subsequently fails, \*(C`undef\*(C' is returned. in which case \*(C`Getopt::Declare::new()\*(C' builds a parser from the supplied grammar and returns a reference to it, but does not parse anything. See \*(L"The <em>Getopt::Declare::code()</em> method\*(R" and \*(L"The <em>Getopt::Declare::parse()</em> method\*(R". in which case \*(C`Getopt::Declare::new()\*(C' immediately returns zero. This alternative is useful when using a \*(C`FileHandle\*(C':         my $args = Getopt::Declare-&gt;new($grammar, new FileHandle ($filename) || -SKIP); because it makes explicit what happens if \*(C`FileHandle::new()\*(C' fails. Of course, if the \*(C`-SKIP\*(C' alternative were omitted, &lt;Getopt::Declare::new&gt; would still return immediately, having found \*(C`undef\*(C' as its second argument.</p>
<dl class='dl-vertical'>
  <dt>
    Any other \s-1ARRAY\s0 reference
  </dt>
  <dd>
    <p>in which case \*(C`Getopt::Declare::new()\*(C' treats the array elements as a list of filenames, concatenates the contents of those files, and parses that. If the list does not denote any accessible file(s) \*(C`Getopt::Declare::new()\*(C' immediately returns zero. If matching files are found, but not successfully parsed, \*(C`undef\*(C' is returned.</p>
  </dd>
  <dt>
    A string
  </dt>
  <dd>
    <p>in which case \*(C`Getopt::Declare::new()\*(C' parses that string directly.</p>
  </dd>

</dl>
<p>Note that when \*(C`Getopt::Declare::new()\*(C' parses from a source other than @ARGV, unrecognized arguments are <em>not</em> placed back in @ARGV.</p>
<h3>Using \fIGetopt::Declare\fP objects after command-line processing</h3>
<p>After command-line processing is completed, the object returned by \*(C`Getopt::Declare::new()\*(C' will have the following features:</p>
<dl class='dl-vertical'>
  <dt>
    Parameter data
  </dt>
  <dd>
    <p>For each successfully matched parameter, the <em>Getopt::Declare</em> object will contain a hash element. The key of that element will be the leading flag or parameter variable name of the parameter. The value of the element will be a reference to another hash which contains the names and values of each distinct parameter variable and/or punctuator which was matched by the parameter. Punctuators generate string values containing the actual text matched. Scalar parameter variables generate scalar values. List parameter variables generate array references. As a special case, if a parameter consists of a single component (either a single flag or a single parameter variable), then the value for the corresponding hash key is not a hash reference, but the actual value matched. The following example illustrates the various possibilities:         $args = Getopt::Declare-&gt;new( q{</p><p>                -v &lt;value&gt; [etc]        One or more values                 &lt;infile&gt;                Input file [required]                 -o &lt;outfiles&gt;...        Output files         } );</p><p>        if ( $args-&gt;{&apos;-v&apos;} )         {                 print  "Using value: ", $args-&gt;{&apos;-v&apos;}{&apos;&lt;value&gt;&apos;};                 print  " (et cetera)" if $args-&gt;{&apos;-v&apos;}{&apos;etc&apos;};                 print  "&#92;n";         }</p><p>        open INFILE, $args-&gt;{&apos;&lt;infile&gt;&apos;} or die;         @data = &lt;INFILE&gt;;</p><p>        foreach $outfile ( @{$args-&gt;{&apos;-o&apos;}{&apos;&lt;outfiles&gt;&apos;}} )         {                 open  OUTFILE, "&gt;$outfile"  or die;                 print OUTFILE process(@data);                 close OUTFILE;         } The values which are assigned to the various hash elements are copied from the corresponding blocked-scoped variables which are available within actions. In particular, if the value of any of those block-scoped variables is changed within an action, that changed value is saved in the hash. For example, given the specification:         $args = Getopt::Declare-&gt;new( q{</p><p>        -ar &lt;R:n&gt;       Set aspect ratio (will be clipped to [0..1])                                 {                                   $R = 0 if $R &lt; 0;                                   $R = 1 if $R &gt; 1;                                 }         } ); then the value of \*(C`$args-&gt;{&apos;-ar&apos;}{&apos;&lt;R&gt;&apos;}\*(C' will always be between zero and one. In its \*(L"non-strict\*(R" mode, once a <em>Getopt::Declare</em> object has completed its command-line processing, it pushes any unrecognized arguments back into the emptied command-line array @ARGV (whereas all <em>recognized</em> arguments will have been removed). Note that these remaining arguments will be in sequential elements (starting at $ARGV[0]), <em>not</em> in their original positions in @ARGV. Once a <em>Getopt::Declare</em> object is created, its \*(C`usage()\*(C' method may be called to explicitly print out usage information corresponding to the specification with which it was built. See \*(L"Usage information\*(R" for more details. If the \*(C`usage()\*(C' method is called with an argument, that argument is passed to \*(C`exit\*(C' after the usage information is printed (the no-argument version of \*(C`usage()\*(C' simply returns at that point). Another useful method of a <em>Getopt::Declare</em> object is \*(C`version()\*(C', which prints out the name of the enclosing program, the last time it was modified, and the value of $::VERSION, if it is defined. Note that this implies that <em>all</em> <em>Getopt::Declare</em> objects in a single program will print out identical version information. Like the \*(C`usage()\*(C' method, if \*(C`version\*(C' is passed an argument, it will exit with that value after printing. It is possible to separate the construction of a <em>Getopt::Declare</em> parser from the actual parsing it performs. If \*(C`Getopt::Declare::new()\*(C' is called with a second parameter &apos;-BUILD&apos; (see \*(L"Parsing from other sources\*(R", it constructs and returns a parser, without parsing anything. The resulting parser object can then be used to parse multiple sources, by calling its \*(C`parse()\*(C' method. \*(C`Getopt::Declare::parse()\*(C' takes an optional parameter which specifies the source of the text to be parsed (it parses @ARGV if the parameter is omitted). This parameter takes the same set of values as the optional second parameter of \*(C`Getopt::Declare::new()\*(C' (see \*(L"Parsing from other sources\*(R"). \*(C`Getopt::Declare::parse()\*(C' returns true if the source is located and parsed successfully. It returns a defined false (zero) if the source is not located. An \*(C`undef\*(C' is returned if the source is located, but not successfully parsed. Thus, the following code first constructs a parser for a series of alternate configuration files and the command line, and then parses them:         # BUILD PARSERS         my $config  = Getopt::Declare-&gt;new($config_grammar, -BUILD);         my $cmdline = Getopt::Declare-&gt;new($cmdline_grammar, -BUILD);</p><p>        # TRY STANDARD CONFIG FILES         $config-&gt;parse(-CONFIG)</p><p>        # OTHERWISE, TRY GLOBAL CONFIG         or $config-&gt;parse(&apos;/usr/local/config/.demo_rc&apos;)</p><p>        # OTHERWISE, TRY OPENING A FILEHANDLE (OR JUST GIVE UP)         or $config-&gt;parse(new FileHandle (".config") || -SKIP);</p><p>        # NOW PARSE THE COMMAND LINE</p><p>        $cmdline-&gt;parse() or die; It is also possible to retrieve the command-line parsing code generated internally by \*(C`Getopt::Declare::new()\*(C'. The \*(C`Getopt::Declare::code()\*(C' method returns a string containing the complete command-line processing code, as a single \*(C`do\*(C' block plus a leading \*(C`package\*(C' declaration. \*(C`Getopt::Declare::code()\*(C' takes as its sole argument a string containing the complete name of the package (for the leading \*(C`package\*(C' declaration in the generated code). If this string is empty or undefined, the package name defaults to \*(L"main\*(R". Since the default behaviour of \*(C`Getopt::Declare::new()\*(C' is to execute the command-line parsing code it generates, if the goal is only to generate the parser code, the optional second '-BUILD' parameter (see \*(L"Parsing from other sources\*(R") should be specified when calling &lt;<em>Getopt::Declare::new()</em>&gt;. For example, the following program \*(L"inlines\*(R" a \*(C`Getopt::Declare\*(C' specification, by extracting it from between the first \*(L"=for Getopt::Declare\*(R" and the next \*(L"=cut\*(R" appearing on \*(C`STDIN\*(C':         use Getopt::Declare;</p><p>        sub encode { return Getopt::Declare-&gt;new(shift,-BUILD)-&gt;code() || die }</p><p>        undef $/;         if (&lt;&gt;)         {                 s {^=for&#92;s+Getopt::Declare&#92;s*&#92;n(.*?)&#92;n=cut}                   {&apos;my (&#92;$self,$source) = ({});&apos;.encode($1).&apos; or die "&#92;n";&apos;}                   esm;         }</p><p>        print; Note that the generated inlined version expects to find a lexical variable named $source, which tells it what to parse (this variable is normally set by the optional parameters of \*(C`Getopt::Declare::new()\*(C' or \*(C`Getopt::Declare::parse()\*(C'). The inlined code leaves all extracted parameters in the lexical variable $self and does not autogenerate help or version flags (since there is no actual <em>Getopt::Declare</em> object in the inlined code through which to generate them).</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTOGENERATED FEATURES</h2>
        <div class="sectioncontent">
<h3>Usage information</h3>
<p>The specification passed to \*(C`Getopt::Declare::new\*(C' is used (almost verbatim) as a \*(L"usage\*(R" display whenever usage information is requested.</p><p>Such requests may be made either by specifying an argument matching the help parameter (see \*(L"Help parameters\*(R") or by explicitly calling the \*(C`Getopt::Declare::usage()\*(C' method (through an action or after command-line processing):</p><p>        $args = Getopt::Declare-&gt;new( q{</p><p>                -usage          Show usage information and exit                                         { $self-&gt;<strong>usage</strong>(0); }</p><p>                +usage          Show usage information at end of program         } );</p><p>        # PROGRAM HERE</p><p>        $args-&gt;usage()  if $args-&gt;{&apos;+usage&apos;};</p><p>The following changes are made to the original specification before it is displayed:</p><ul>
<li><p>All actions and comments are deleted,</p></li><li><p>any \*(C`[ditto]\*(C' directive is converted to an appropriate set of \*(L"ditto\*(R" marks,</p></li><li><p>any text in matching square brackets (including any directive) is deleted,</p></li><li><p>any parameter variable type specifier (\*(L":i\*(R", \*(L":n\*(R", \*(L":/pat/\*(R", etc.) is deleted.</p></li>
</ul><p>Otherwise, the usage information displayed retains all the formatting present in the original specification.</p><p>In addition to this information, if the input source is @ARGV, <em>Getopt::Declare</em> displays three sample command-lines: one indicating the normal usage (including any required parameter variables), one indicating how to invoke help (see \*(L"Help parameters\*(R"), and one indicating how to determine the current version of the program (see \*(L"Version parameters\*(R").</p><p>The usage information is printed to \*(C`STDOUT\*(C' and (since <em>Getopt::Declare</em> tends to encourage longer and better-documented parameter lists) if the <em>IO::Pager</em> package is available, an <em>IO::Pager</em> object is used to page out the entire usage documentation. It is sometimes convenient to add other \*(L"decorative\*(R" features to a program's usage information, such as subheadings, general notes, separators, etc. <em>Getopt::Declare</em> accommodates this need by ignoring such items when interpreting a specification string, but printing them when asked for usage information.</p><p>Any line which cannot be interpreted as either a parameter definition, a parameter description, or a parameter action, is treated as a \*(L"decorator\*(R" line, and is printed verbatim (after any square bracketted substrings have been removed from it). If your decoration needs square brackets, you need to escape the opening square bracket with a backslash, e.g. \*(C`&#92;[decoration]\*(C'.</p><p>The key to successfully decorating <em>Getopt::Declare</em> usage information is to ensure that decorator lines are separated from any preceding parameter specification, either by an action or by an empty line. In addition, like a parameter description, a decorator line cannot contain a tab character after the first non-whitespace character (because it would then be treated as a parameter specification).</p><p>The following specification demonstrates various forms of usage decoration. In fact, there are only four actual parameters (\*(C`-in\*(C', \*(C`-r\*(C', \*(C`-p\*(C', and \*(C`-out\*(C') specified. Note in particular that <em>leading</em> tabs are perfectly acceptible in decorator lines.</p><p>        $args = Getopt::Declare-&gt;new(&lt;&lt;&apos;EOPARAM&apos;);</p><p>        ============================================================         Required parameter:</p><p>                -in &lt;infile&gt;            Input file [required]</p><p>        ------------------------------------------------------------</p><p>        Optional parameters:</p><p>                (The first two are mutually exclusive) [mutex: -r -p]</p><p>                -r[and[om]]             Output in random order                 -p[erm[ute]]            Output all permutations</p><p>                ---------------------------------------------------</p><p>                -out &lt;outfile&gt;          Optional output file</p><p>        ------------------------------------------------------------         Note: this program is known to run very slowly of files with               long individual lines.         ============================================================         EOPARAM</p>
<h3>Help parameters</h3>
<p>By default, <em>Getopt::Declare</em> automatically defines <em>all</em> of the following parameters:</p><p>        -help   Show usage information [undocumented]                         { $self-&gt;<strong>usage</strong>(0); }         -Help   [ditto]         -HELP   [ditto]         --help  [ditto]         --Help  [ditto]         --HELP  [ditto]         -h      [ditto]         -H      [ditto]</p><p>Hence, most attempts by the user to get help will automatically work successfully.</p><p>Note however that, if a parameter with any of these flags is explicitly specified in the string passed to \*(C`Getopt::Declare::new()\*(C', that flag (only) is removed from the list of possible help flags. For example:</p><p>        -w &lt;pixels:+i&gt;  Specify width in pixels         -h &lt;pixels:+i&gt;  Specify height in pixels</p><p>would cause the \*(C`-h\*(C' help parameter to be removed (although help would still be accessible through the other seven alternatives).</p>
<h3>Version parameters</h3>
<p><em>Getopt::Declare</em> also automatically creates a set of parameters which can be used to retrieve program version information:</p><p>        -version        Show version information [undocumented]                                 { $self-&gt;<strong>version</strong>(0); }         -Version        [ditto]         -VERSION        [ditto]         --version       [ditto]         --Version       [ditto]         --VERSION       [ditto]         -v              [ditto]         -V              [ditto]</p><p>As with the various help commands, explicitly specifying a parameter with any of the above flags removes that flag from the list of version flags.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DIAGNOSTICS</h2>
        <div class="sectioncontent">
<p><em>Getopt::Declare</em> may issue the following diagnostics whilst parsing a command-line. All of them are fatal (the first five, instantly so): A matching pair of angle brackets were specified as part of a parameter definition, but did not form a valid parameter variable specification (that is, it wasn't in the form: &lt;<em>name</em>&gt; or &lt;<em>name</em>:<em>type</em>&gt;). An unknown type specifier was used in a parameter variable type suffix. A Perl syntax error was detected in the indicated action. An action was found for which there was no preceding parameter specification. This usually occurs because the trailing tab was omitted from the preceding parameter specification. An action was found, but it was missing one or more closing '}'s. The condition specified as part of the indicated \*(C`[requires:...]\*(C' directive was not a well-formed boolean expression. Common problems include: omitting a \*(C`&&\*(C'/\*(C`||\*(C' operator between two flags, mismatched brackets, or using \*(C`and\*(C'/\*(C`or\*(C' instead of \*(C`&&\*(C'/\*(C`||\*(C'. Either there was a Perl syntax error in one some action (which was not caught by the previous diagnostic), or (less likely) there is a bug in the code generator inside <em>Getopt::Declare</em>. The flag for the indicated parameter was found, but the argument did not then match any of that parameter's variant syntaxes. Two mutually exclusive flags were specified together. No argument matching the specified \*(L"required\*(R" parameter was found during command-line processing. The indicated parameter has a \*(C`[requires:...]\*(C' directive, which was not satisfied. A command-line argument was encountered which did not match any specified parameter. This diagnostic can only only appear if the \*(L"strict\*(R" option is in effect. A parameter variable in the indicated parameter was declared with the type \*(L":+i\*(R" (or a type derived from it), but the corresponding argument was not a positive, non-zero integer. A parameter variable in the indicated parameter was declared with the type \*(L":+n\*(R" (or a type derived from it), but the corresponding argument was not a positive, non-zero number. A parameter variable in the indicated parameter was declared with the type \*(L":0+i\*(R" (or a type derived from it), but the corresponding argument was not a positive integer. A parameter variable in the indicated parameter was declared with the type \*(L":0+n\*(R" (or a type derived from it), but the corresponding argument was not a positive number.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Damian Conway &lt;damian@conway.org&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS AND ANNOYANCES</h2>
        <div class="sectioncontent">
<p>There are undoubtedly serious bugs lurking somewhere in this code.</p><p>If nothing else, it shouldn't take 1500 lines to explain a package that was designed for intuitive ease of use!</p><p>Bug reports and other feedback are most welcome at: https://rt.cpan.org/Public/Bug/Report.html?Queue=Getopt-Declare</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>       Copyright (c) 1997-2000, Damian Conway. All Rights Reserved.      This module is free software. It may be used, redistributed      and/or modified under the terms of the Perl Artistic License           (see http://www.perl.com/perl/misc/Artistic.html)</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Getopt::Complete::Options.3pm.html"><span aria-hidden="true">&larr;</span> Getopt::Complete::Options.3pm: A command-line options specification</a></li>
   <li class="next"><a href="Getopt::Mixed.3pm.html">Getopt::Mixed.3pm: Getopt processing with both long and short options <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

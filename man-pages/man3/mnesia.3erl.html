<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>mnesia: A distributed telecommunications dbms</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="A distributed telecommunications dbms">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="mnesia (3erl) manual">
  <meta name="twitter:description" content="A distributed telecommunications dbms">
  <meta name="twitter:image" content="https://www.carta.tech/images/erlang-manpages-mnesia-3erl.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3erl/mnesia.3erl.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="mnesia (3erl) manual" />
  <meta property="og:description" content="A distributed telecommunications dbms" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/erlang-manpages-mnesia-3erl.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">mnesia<small> (3erl)</small></h1>
        <p class="lead">A distributed telecommunications dbms</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/mnesia.3erl.html">
      <span itemprop="name">mnesia: A distributed telecommunications dbms</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/erlang-manpages/">
      <span itemprop="name">erlang-manpages</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/mnesia.3erl.html">
      <span itemprop="name">mnesia: A distributed telecommunications dbms</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><em>Mnesia</em> is a distributed DataBase Management System (DBMS), appropriate for telecommunications applications and other Erlang applications which require continuous operation and exhibit soft real-time properties.</p><p>Listed below are some of the most important and attractive capabilities, Mnesia provides:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>A relational/object hybrid data model which is suitable for telecommunications applications.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>A specifically designed DBMS query language, QLC (as an add-on library).</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>Persistence. Tables may be coherently kept on disc as well as in main memory.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>Replication. Tables may be replicated at several nodes.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>Atomic transactions. A series of table manipulation operations can be grouped into a single atomic transaction.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>Location transparency. Programs can be written without knowledge of the actual location of data.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>Extremely fast real time data searches.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>Schema manipulation routines. It is possible to reconfigure the DBMS at runtime without stopping the system.</p>
  </dd>

</dl>
<p>This Reference Manual describes the Mnesia API. This includes functions used to define and manipulate Mnesia tables.</p><p>All functions documented in these pages can be used in any combination with queries using the list comprehension notation. The query notation is described in the QLC's man page.</p><p>Data in Mnesia is organized as a set of tables. Each table has a name which must be an atom. Each table is made up of Erlang records. The user is responsible for the record definitions. Each table also has a set of properties. Below are some of the properties that are associated with each table:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>type</em>. Each table can either have 'set', 'ordered_set' or 'bag' semantics. Note: currently 'ordered_set' is not supported for 'disc_only_copies'. If a table is of type 'set' it means that each key leads to either one or zero records.</p><p>If a new item is inserted with the same key as an existing record, the old record is overwritten. On the other hand, if a table is of type 'bag', each key can map to several records. However, all records in type bag tables are unique, only the keys may be duplicated.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>record_name</em>. All records stored in a table must have the same name. You may say that the records must be instances of the same record type.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>ram_copies</em> A table can be replicated on a number of Erlang nodes. The <em>ram_copies</em> property specifies a list of Erlang nodes where RAM copies are kept. These copies can be dumped to disc at regular intervals. However, updates to these copies are not written to disc on a transaction basis.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>disc_copies</em> The <em>disc_copies</em> property specifies a list of Erlang nodes where the table is kept in RAM as well as on disc. All updates of the table are performed on the actual table and are also logged to disc. If a table is of type <em>disc_copies</em> at a certain node, it means that the entire table is resident in RAM memory as well as on disc. Each transaction performed on the table is appended to a LOG file as well as written into the RAM table.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>disc_only_copies</em> Some, or all, table replicas can be kept on disc only. These replicas are considerably slower than the RAM based replicas.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>index</em> This is a list of attribute names, or integers, which specify the tuple positions on which Mnesia shall build and maintain an extra index table.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>local_content</em> When an application requires tables whose contents is local to each node, <em>local_content</em> tables may be used. The name of the table is known to all Mnesia nodes, but its contents is unique on each node. This means that access to such a table must be done locally. Set the <em>local_content</em> field to <em>true</em> if you want to enable the <em>local_content</em> behavior. The default is <em>false</em>.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>majority</em> This attribute can be either <em>true</em> or <em>false</em> (default is <em>false</em>). When <em>true</em>, a majority of the table replicas must be available for an update to succeed. Majority checking can be enabled on tables with mission-critical data, where it is vital to avoid inconsistencies due to network splits.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>snmp</em> Each (set based) Mnesia table can be automatically turned into an SNMP ordered table as well. This property specifies the types of the SNMP keys.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>attributes</em>. The names of the attributes for the records that are inserted in the table.</p>
  </dd>

</dl>
<p>See <em>mnesia:create_table/2</em> about the complete set of table properties and their details.</p><p>This document uses a table of persons to illustrate various examples. The following record definition is assumed:</p>
<pre>
-record(person, {name,
                 age = 0,
                 address = unknown,
                 salary = 0,
                 children = []}),

</pre>
<p>The first attribute of the record is the primary key, or key for short.</p><p>The function descriptions are sorted in alphabetic order. <em>Hint:</em> start to read about <em>mnesia:create_table/2</em>, <em>mnesia:lock/2</em> and <em>mnesia:activity/4</em> before you continue on and learn about the rest.</p><p>Writing or deleting in transaction context creates a local copy of each modified record during the transaction. During iteration, i.e. <em>mnesia:fold[lr]/4</em> <em>mnesia:next/2</em> <em>mnesia:prev/2</em> <em>mnesia:snmp_get_next_index/2</em>, mnesia will compensate for every written or deleted record, which may reduce the performance. If possible avoid writing or deleting records in the same transaction before iterating over the table.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">
<p><strong></strong> abort(Reason) -&gt; transaction abort</p><p>Makes the transaction silently return the tuple <em>{aborted, Reason}</em>. The abortion of a Mnesia transaction means that an exception will be thrown to an enclosing <em>catch</em>. Thus, the expression <em>catch mnesia:abort(x)</em> does not abort the transaction.</p><p><strong></strong> activate_checkpoint(Args) -&gt; {ok,Name,Nodes} | {error,Reason}</p><p>A checkpoint is a consistent view of the system. A checkpoint can be activated on a set of tables. This checkpoint can then be traversed and will present a view of the system as it existed at the time when the checkpoint was activated, even if the tables are being or have been manipulated.</p><p><em>Args</em> is a list of the following tuples:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{name,Name}</em>. <em>Name</em> of checkpoint. Each checkpoint must have a name which is unique to the associated nodes. The name can be reused only once the checkpoint has been deactivated. By default, a name which is probably unique is generated.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{max,MaxTabs}</em>. <em>MaxTabs</em> is a list of tables that should be included in the checkpoint. The default is []. For these tables, the redundancy will be maximized and checkpoint information will be retained together with all replicas. The checkpoint becomes more fault tolerant if the tables have several replicas. When a new replica is added by means of the schema manipulation function <em>mnesia:add_table_copy/3</em>, a retainer will also be attached automatically.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{min,MinTabs}</em>. <em>MinTabs</em> is a list of tables that should be included in the checkpoint. The default is []. For these tables, the redundancy will be minimized and the checkpoint information will only be retained with one replica, preferably on the local node.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{allow_remote,Bool}</em>. <em>false</em> means that all retainers must be local. The checkpoint cannot be activated if a table does not reside locally. <em>true</em> allows retainers to be allocated on any node. Default is set to <em>true</em>.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{ram_overrides_dump,Bool}</em>. Only applicable for <em>ram_copies</em>. <em>Bool</em> allows you to choose to backup the table state as it is in RAM, or as it is on disc. <em>true</em> means that the latest committed records in RAM should be included in the checkpoint. These are the records that the application accesses. <em>false</em> means that the records dumped to DAT files should be included in the checkpoint. These are the records that will be loaded at startup. Default is <em>false</em>.</p>
  </dd>

</dl>
<p>Returns <em>{ok,Name,Nodes}</em> or <em>{error,Reason}</em>. <em>Name</em> is the (possibly generated) name of the checkpoint. <em>Nodes</em> are the nodes that are involved in the checkpoint. Only nodes that keep a checkpoint retainer know about the checkpoint.</p><p><strong></strong> activity(AccessContext, Fun [, Args]) -&gt; ResultOfFun | exit(Reason)</p><p>Invokes <em>mnesia:activity(AccessContext, Fun, Args, AccessMod)</em> where <em>AccessMod</em> is the default access callback module obtained by <em>mnesia:system_info(access_module)</em>. <em>Args</em> defaults to the empty list <em>[]</em>.</p><p><strong></strong> activity(AccessContext, Fun, Args, AccessMod) -&gt; ResultOfFun | exit(Reason)</p><p>This function executes the functional object <em>Fun</em> with the arguments <em>Args</em>.</p><p>The code which executes inside the activity can consist of a series of table manipulation functions, which is performed in a <em>AccessContext</em>. Currently, the following access contexts are supported:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>transaction</em>: Short for <em>{transaction, infinity}</em></p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{transaction, Retries}</em>: Invokes <em>mnesia:transaction(Fun, Args, Retries)</em>. Note that the result from the <em>Fun</em> is returned if the transaction was successful (atomic), otherwise the function exits with an abort reason.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>sync_transaction</em>: Short for <em>{sync_transaction, infinity}</em></p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{sync_transaction, Retries}</em>: Invokes <em>mnesia:sync_transaction(Fun, Args, Retries)</em>. Note that the result from the <em>Fun</em> is returned if the transaction was successful (atomic), otherwise the function exits with an abort reason.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>async_dirty</em>: Invokes <em>mnesia:async_dirty(Fun, Args)</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>sync_dirty</em>: Invokes <em>mnesia:sync_dirty(Fun, Args)</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>ets</em>: Invokes <em>mnesia:ets(Fun, Args)</em>.</p>
  </dd>

</dl>
<p>This function (<em>mnesia:activity/4</em>) differs in an important aspect from the <em>mnesia:transaction</em>, <em>mnesia:sync_transaction</em>, <em>mnesia:async_dirty</em>, <em>mnesia:sync_dirty</em> and <em>mnesia:ets</em> functions. The <em>AccessMod</em> argument is the name of a callback module which implements the <em>mnesia_access</em> behavior.</p><p>Mnesia will forward calls to the following functions:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>mnesia:lock/2 (read_lock_table/1, write_lock_table/1)</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>mnesia:write/3 (write/1, s_write/1)</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>mnesia:delete/3 (delete/1, s_delete/1)</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>mnesia:delete_object/3 (delete_object/1, s_delete_object/1)</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>mnesia:read/3 (read/1, wread/1)</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>mnesia:match_object/3 (match_object/1)</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>mnesia:all_keys/1</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>mnesia:first/1</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>mnesia:last/1</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>mnesia:prev/2</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>mnesia:next/2</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>mnesia:index_match_object/4 (index_match_object/2)</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>mnesia:index_read/3</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>mnesia:table_info/2</p>
  </dd>

</dl>
<p>to the corresponding:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>AccessMod:lock(ActivityId, Opaque, LockItem, LockKind)</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>AccessMod:write(ActivityId, Opaque, Tab, Rec, LockKind)</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>AccessMod:delete(ActivityId, Opaque, Tab, Key, LockKind)</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>AccessMod:delete_object(ActivityId, Opaque, Tab, RecXS, LockKind)</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>AccessMod:read(ActivityId, Opaque, Tab, Key, LockKind)</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>AccessMod:match_object(ActivityId, Opaque, Tab, Pattern, LockKind)</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>AccessMod:all_keys(ActivityId, Opaque, Tab, LockKind)</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>AccessMod:first(ActivityId, Opaque, Tab)</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>AccessMod:last(ActivityId, Opaque, Tab)</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>AccessMod:prev(ActivityId, Opaque, Tab, Key)</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>AccessMod:next(ActivityId, Opaque, Tab, Key)</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>AccessMod:index_match_object(ActivityId, Opaque, Tab, Pattern, Attr, LockKind)</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>AccessMod:index_read(ActivityId, Opaque, Tab, SecondaryKey, Attr, LockKind)</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>AccessMod:table_info(ActivityId, Opaque, Tab, InfoItem)</p>
  </dd>

</dl>
<p>where <em>ActivityId</em> is a record which represents the identity of the enclosing Mnesia activity. The first field (obtained with <em>element(1, ActivityId)</em> contains an atom which may be interpreted as the type of the activity: <em>'ets'</em>, <em>'async_dirty'</em>, <em>'sync_dirty'</em> or <em>'tid'</em>. <em>'tid'</em> means that the activity is a transaction. The structure of the rest of the identity record is internal to Mnesia.</p><p><em>Opaque</em> is an opaque data structure which is internal to Mnesia.</p><p><strong></strong> add_table_copy(Tab, Node, Type) -&gt; {aborted, R} | {atomic, ok}</p><p>This function makes another copy of a table at the node <em>Node</em>. The <em>Type</em> argument must be either of the atoms <em>ram_copies</em>, <em>disc_copies</em>, or <em>disc_only_copies</em>. For example, the following call ensures that a disc replica of the <em>person</em> table also exists at node <em>Node</em>.</p>
<pre>
mnesia:add_table_copy(person, Node, disc_copies)

</pre>
<p>This function can also be used to add a replica of the table named <em>schema</em>.</p><p><strong></strong> add_table_index(Tab, AttrName) -&gt; {aborted, R} | {atomic, ok}</p><p>Table indices can and should be used whenever the user wants to frequently use some other field than the key field to look up records. If this other field has an index associated with it, these lookups can occur in constant time and space. For example, if our application wishes to use the age field of persons to efficiently find all person with a specific age, it might be a good idea to have an index on the age field. This can be accomplished with the following call:</p>
<pre>
mnesia:add_table_index(person, age)

</pre>
<p>Indices do not come free, they occupy space which is proportional to the size of the table. They also cause insertions into the table to execute slightly slower.</p><p><strong></strong> all_keys(Tab) -&gt; KeyList | transaction abort</p><p>This function returns a list of all keys in the table named <em>Tab</em>. The semantics of this function is context sensitive. See <em>mnesia:activity/4</em> for more information. In transaction context it acquires a read lock on the entire table.</p><p><strong></strong> async_dirty(Fun, [, Args]) -&gt; ResultOfFun | exit(Reason)</p><p>Call the <em>Fun</em> in a context which is not protected by a transaction. The Mnesia function calls performed in the <em>Fun</em> are mapped to the corresponding dirty functions. This still involves logging, replication and subscriptions, but there is no locking, local transaction storage, or commit protocols involved. Checkpoint retainers and indices are updated, but they will be updated dirty. As for normal mnesia:dirty_* operations, the operations are performed semi-asynchronously. See <em>mnesia:activity/4</em> and the Mnesia User's Guide for more details.</p><p>It is possible to manipulate the Mnesia tables without using transactions. This has some serious disadvantages, but is considerably faster since the transaction manager is not involved and no locks are set. A dirty operation does, however, guarantee a certain level of consistency and it is not possible for the dirty operations to return garbled records. All dirty operations provide location transparency to the programmer and a program does not have to be aware of the whereabouts of a certain table in order to function.</p><p><em>Note:</em>It is more than 10 times more efficient to read records dirty than within a transaction.</p><p>Depending on the application, it may be a good idea to use the dirty functions for certain operations. Almost all Mnesia functions which can be called within transactions have a dirty equivalent which is much more efficient. However, it must be noted that it is possible for the database to be left in an inconsistent state if dirty operations are used to update it. Dirty operations should only be used for performance reasons when it is absolutely necessary.</p><p><em>Note:</em> Calling (nesting) a <em>mnesia:[a]sync_dirty</em> inside a transaction context will inherit the transaction semantics.</p><p><strong></strong> backup(Opaque [, BackupMod]) -&gt; ok | {error,Reason}</p><p>Activates a new checkpoint covering all Mnesia tables, including the schema, with maximum degree of redundancy and performs a backup using <em>backup_checkpoint/2/3</em>. The default value of the backup callback module <em>BackupMod</em> is obtained by <em>mnesia:system_info(backup_module)</em>.</p><p><strong></strong> backup_checkpoint(Name, Opaque [, BackupMod]) -&gt; ok | {error,Reason}</p><p>The tables are backed up to external media using the backup module <em>BackupMod</em>. Tables with the local contents property is being backed up as they exist on the current node. <em>BackupMod</em> is the default backup callback module obtained by <em>mnesia:system_info(backup_module)</em>. See the User's Guide about the exact callback interface (the <em>mnesia_backup behavior</em>).</p><p><strong></strong> change_config(Config, Value) -&gt; {error, Reason} | {ok, ReturnValue}</p><p>The <em>Config</em> should be an atom of the following configuration parameters:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>extra_db_nodes</em>: <em>Value</em> is a list of nodes which Mnesia should try to connect to. The <em>ReturnValue</em> will be those nodes in <em>Value</em> that Mnesia are connected to.</p><p>Note: This function shall only be used to connect to newly started ram nodes (N.D.R.S.N.) with an empty schema. If for example it is used after the network have been partitioned it may lead to inconsistent tables.</p><p>Note: Mnesia may be connected to other nodes than those returned in <em>ReturnValue</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>dc_dump_limit</em>: <em>Value</em> is a number. See description in <em>Configuration Parameters</em> below. The <em>ReturnValue</em> is the new value. Note this configuration parameter is not persistent, it will be lost when mnesia stopped.</p>
  </dd>

</dl>
<p><strong></strong> change_table_access_mode(Tab, AccessMode) -&gt; {aborted, R} | {atomic, ok}</p><p>The <em>AcccessMode</em> is by default the atom <em>read_write</em> but it may also be set to the atom <em>read_only</em>. If the <em>AccessMode</em> is set to <em>read_only</em>, it means that it is not possible to perform updates to the table. At startup Mnesia always loads <em>read_only</em> tables locally regardless of when and if Mnesia was terminated on other nodes.</p><p><strong></strong> change_table_copy_type(Tab, Node, To) -&gt; {aborted, R} | {atomic, ok}</p><p>For example:</p>
<pre>
mnesia:change_table_copy_type(person, node(), disc_copies)

</pre>
<p>Transforms our <em>person</em> table from a RAM table into a disc based table at <em>Node</em>.</p><p>This function can also be used to change the storage type of the table named <em>schema</em>. The schema table can only have <em>ram_copies</em> or <em>disc_copies</em> as the storage type. If the storage type of the schema is <em>ram_copies</em>, no other table can be disc resident on that node.</p><p><strong></strong> change_table_load_order(Tab, LoadOrder) -&gt; {aborted, R} | {atomic, ok}</p><p>The <em>LoadOrder</em> priority is by default <em>0</em> (zero) but may be set to any integer. The tables with the highest <em>LoadOrder</em> priority will be loaded first at startup.</p><p><strong></strong> change_table_majority(Tab, Majority) -&gt; {aborted, R} | {atomic, ok}</p><p><em>Majority</em> must be a boolean; the default is <em>false</em>. When <em>true</em>, a majority of the table's replicas must be available for an update to succeed. When used on fragmented tables, <em>Tab</em> must be the name base table. Directly changing the majority setting on individual fragments is not allowed.</p><p><strong></strong> clear_table(Tab) -&gt; {aborted, R} | {atomic, ok}</p><p>Deletes all entries in the table <em>Tab</em>.</p><p><strong></strong> create_schema(DiscNodes) -&gt; ok | {error,Reason}</p><p>Creates a new database on disc. Various files are created in the local Mnesia directory of each node. Note that the directory must be unique for each node. Two nodes may never share the same directory. If possible, use a local disc device in order to improve performance.</p><p><em>mnesia:create_schema/1</em> fails if any of the Erlang nodes given as <em>DiscNodes</em> are not alive, if Mnesia is running on anyone of the nodes, or if anyone of the nodes already has a schema. Use <em>mnesia:delete_schema/1</em> to get rid of old faulty schemas.</p><p><em>Note:</em> Only nodes with disc should be included in <em>DiscNodes</em>. Disc-less nodes, that is nodes where all tables including the schema only resides in RAM, may not be included.</p><p><strong></strong> create_table(Name, TabDef) -&gt; {atomic, ok} | {aborted, Reason}</p><p>This function creates a Mnesia table called <em>Name</em> according to the argument <em>TabDef</em>. This list must be a list of <em>{Item, Value}</em> tuples, where the following values are allowed:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{access_mode, Atom}</em>. The access mode is by default the atom <em>read_write</em> but it may also be set to the atom <em>read_only</em>. If the <em>AccessMode</em> is set to <em>read_only</em>, it means that it is not possible to perform updates to the table.</p><p>At startup Mnesia always loads <em>read_only</em> tables locally regardless of when and if Mnesia was terminated on other nodes. This argument returns the access mode of the table. The access mode may either be read_only or read_write.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{attributes, AtomList}</em> a list of the attribute names for the records that are supposed to populate the table. The default value is <em>[key, val]</em>. The table must have at least one extra attribute in addition to the key.</p><p>When accessing single attributes in a record, it is not necessary, or even recommended, to hard code any attribute names as atoms. Use the construct <em>record_info(fields, RecordName)</em> instead. It can be used for records of type <em>RecordName</em></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{disc_copies, Nodelist}</em>, where <em>Nodelist</em> is a list of the nodes where this table is supposed to have disc copies. If a table replica is of type <em>disc_copies</em>, all write operations on this particular replica of the table are written to disc as well as to the RAM copy of the table.</p><p>It is possible to have a replicated table of type <em>disc_copies</em> on one node, and another type on another node. The default value is <em>[]</em></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{disc_only_copies, Nodelist}</em>, where <em>Nodelist</em> is a list of the nodes where this table is supposed to have <em>disc_only_copies</em>. A disc only table replica is kept on disc only and unlike the other replica types, the contents of the replica will not reside in RAM. These replicas are considerably slower than replicas held in RAM.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{index, Intlist}</em>, where <em>Intlist</em> is a list of attribute names (atoms) or record fields for which Mnesia shall build and maintain an extra index table. The <em>qlc</em> query compiler may or may not utilize any additional indices while processing queries on a table.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{load_order, Integer}</em>. The load order priority is by default <em>0</em> (zero) but may be set to any integer. The tables with the highest load order priority will be loaded first at startup.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{majority, Flag}</em>, where <em>Flag</em> must be a boolean. If <em>true</em>, any (non-dirty) update to the table will abort unless a majority of the table's replicas are available for the commit. When used on a fragmented table, all fragments will be given the same majority setting.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{ram_copies, Nodelist}</em>, where <em>Nodelist</em> is a list of the nodes where this table is supposed to have RAM copies. A table replica of type <em>ram_copies</em> is obviously not written to disc on a per transaction basis. It is possible to dump <em>ram_copies</em> replicas to disc with the function <em>mnesia:dump_tables(Tabs)</em>. The default value for this attribute is <em>[node()]</em>.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{record_name, Name}</em>, where <em>Name</em> must be an atom. All records, stored in the table, must have this name as the first element. It defaults to the same name as the name of the table.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{snmp, SnmpStruct}</em>. See <em>mnesia:snmp_open_table/2</em> for a description of <em>SnmpStruct</em>. If this attribute is present in the <em>ArgList</em> to <em>mnesia:create_table/2</em>, the table is immediately accessible by means of the Simple Network Management Protocol (SNMP). This means that applications which use SNMP to manipulate and control the system can be designed easily, since Mnesia provides a direct mapping between the logical tables that make up an SNMP control application and the physical data which makes up a Mnesia table.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{storage_properties, [{Backend, Properties}]</em>. Forwards additional properties to the backend storage. <em>Backend</em> can currently be <em>ets</em> or <em>dets</em> and <em>Properties</em> is a list of options sent to the backend storage during table creation. <em>Properties</em> may not contain properties already used by mnesia such as <em>type</em> or <em>named_table</em>.</p><p>For example:</p>
  </dd>

</dl>

<pre>
mnesia:create_table(table, [{ram_copies, [node()]}, {disc_only_copies, nodes()},
			    {storage_properties,
			     [{ets, [compressed]}, {dets, [{auto_save, 5000}]} ]}])

</pre>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{type, Type}</em>, where <em>Type</em> must be either of the atoms <em>set</em>, <em>ordered_set</em> or <em>bag</em>. The default value is <em>set</em>. In a <em>set</em> all records have unique keys and in a <em>bag</em> several records may have the same key, but the record content is unique. If a non-unique record is stored the old, conflicting record(s) will simply be overwritten. Note: currently 'ordered_set' is not supported for 'disc_only_copies'.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{local_content, Bool}</em>, where <em>Bool</em> must be either <em>true</em> or <em>false</em>. The default value is <em>false</em>.</p>
  </dd>

</dl>
<p>For example, the following call creates the <em>person</em> table previously defined and replicates it on 2 nodes:</p>
<pre>
mnesia:create_table(person,
    [{ram_copies, [N1, N2]},
     {attributes, record_info(fields,person)}]).

</pre>
<p>If it was required that Mnesia build and maintain an extra index table on the <em>address</em> attribute of all the <em>person</em> records that are inserted in the table, the following code would be issued:</p>
<pre>
mnesia:create_table(person,
    [{ram_copies, [N1, N2]},
     {index, [address]},
     {attributes, record_info(fields,person)}]).

</pre>
<p>The specification of <em>index</em> and <em>attributes</em> may be hard coded as <em>{index, [2]}</em> and <em>{attributes, [name, age, address, salary, children]}</em> respectively.</p><p><em>mnesia:create_table/2</em> writes records into the <em>schema</em> table. This function, as well as all other schema manipulation functions, are implemented with the normal transaction management system. This guarantees that schema updates are performed on all nodes in an atomic manner.</p><p><strong></strong> deactivate_checkpoint(Name) -&gt; ok | {error, Reason}</p><p>The checkpoint is automatically deactivated when some of the tables involved have no retainer attached to them. This may happen when nodes go down or when a replica is deleted. Checkpoints will also be deactivated with this function. <em>Name</em> is the name of an active checkpoint.</p><p><strong></strong> del_table_copy(Tab, Node) -&gt; {aborted, R} | {atomic, ok}</p><p>Deletes the replica of table <em>Tab</em> at node <em>Node</em>. When the last replica is deleted with this function, the table disappears entirely.</p><p>This function may also be used to delete a replica of the table named <em>schema</em>. Then the mnesia node will be removed. Note: Mnesia must be stopped on the node first.</p><p><strong></strong> del_table_index(Tab, AttrName) -&gt; {aborted, R} | {atomic, ok}</p><p>This function deletes the index on attribute with name <em>AttrName</em> in a table.</p><p><strong></strong> delete({Tab, Key}) -&gt; transaction abort | ok</p><p>Invokes <em>mnesia:delete(Tab, Key, write)</em></p><p><strong></strong> delete(Tab, Key, LockKind) -&gt; transaction abort | ok</p><p>Deletes all records in table <em>Tab</em> with the key <em>Key</em>.</p><p>The semantics of this function is context sensitive. See <em>mnesia:activity/4</em> for more information. In transaction context it acquires a lock of type <em>LockKind</em> in the record. Currently the lock types <em>write</em> and <em>sticky_write</em> are supported.</p><p><strong></strong> delete_object(Record) -&gt; transaction abort | ok</p><p>Invokes <em>mnesia:delete_object(Tab, Record, write)</em> where <em>Tab</em> is <em>element(1, Record)</em>.</p><p><strong></strong> delete_object(Tab, Record, LockKind) -&gt; transaction abort | ok</p><p>If a table is of type <em>bag</em>, we may sometimes want to delete only some of the records with a certain key. This can be done with the <em>delete_object/3</em> function. A complete record must be supplied to this function.</p><p>The semantics of this function is context sensitive. See <em>mnesia:activity/4</em> for more information. In transaction context it acquires a lock of type <em>LockKind</em> on the record. Currently the lock types <em>write</em> and <em>sticky_write</em> are supported.</p><p><strong></strong> delete_schema(DiscNodes) -&gt; ok | {error,Reason}</p><p>Deletes a database created with <em>mnesia:create_schema/1</em>. <em>mnesia:delete_schema/1</em> fails if any of the Erlang nodes given as <em>DiscNodes</em> is not alive, or if Mnesia is running on any of the nodes.</p><p>After the database has been deleted, it may still be possible to start Mnesia as a disc-less node. This depends on how the configuration parameter <em>schema_location</em> is set.</p><p><strong></strong> Warning:</p><p>This function must be used with extreme caution since it makes existing persistent data obsolete. Think twice before using it.</p><p><strong></strong> delete_table(Tab) -&gt; {aborted, Reason} | {atomic, ok}</p><p>Permanently deletes all replicas of table <em>Tab</em>.</p><p><strong></strong> dirty_all_keys(Tab) -&gt; KeyList | exit({aborted, Reason}).</p><p>This is the dirty equivalent of the <em>mnesia:all_keys/1</em> function.</p><p><strong></strong> dirty_delete({Tab, Key}) -&gt; ok | exit({aborted, Reason})</p><p>Invokes <em>mnesia:dirty_delete(Tab, Key)</em>.</p><p><strong></strong> dirty_delete(Tab, Key) -&gt; ok | exit({aborted, Reason})</p><p>This is the dirty equivalent of the <em>mnesia:delete/3</em> function.</p><p><strong></strong> dirty_delete_object(Record)</p><p>Invokes <em>mnesia:dirty_delete_object(Tab, Record)</em> where <em>Tab</em> is <em>element(1, Record)</em>.</p><p><strong></strong> dirty_delete_object(Tab, Record)</p><p>This is the dirty equivalent of the <em>mnesia:delete_object/3</em> function.</p><p><strong></strong> dirty_first(Tab) -&gt; Key | exit({aborted, Reason})</p><p>Records in <em>set</em> or <em>bag</em> tables are not ordered. However, there is an ordering of the records which is not known to the user. Accordingly, it is possible to traverse a table by means of this function in conjunction with the <em>mnesia:dirty_next/2</em> function.</p><p>If there are no records at all in the table, this function returns the atom <em>'$end_of_table'</em>. For this reason, it is highly undesirable, but not disallowed, to use this atom as the key for any user records.</p><p><strong></strong> dirty_index_match_object(Pattern, Pos)</p><p>Invokes <em>mnesia:dirty_index_match_object(Tab, Pattern, Pos)</em> where <em>Tab</em> is <em>element(1, Pattern)</em>.</p><p><strong></strong> dirty_index_match_object(Tab, Pattern, Pos)</p><p>This is the dirty equivalent of the <em>mnesia:index_match_object/4</em> function.</p><p><strong></strong> dirty_index_read(Tab, SecondaryKey, Pos)</p><p>This is the dirty equivalent of the <em>mnesia:index_read/3</em> function.</p><p><strong></strong> dirty_last(Tab) -&gt; Key | exit({aborted, Reason})</p><p>This function works exactly like <em>mnesia:dirty_first/1</em> but returns the last object in Erlang term order for the <em>ordered_set</em> table type. For all other table types, <em>mnesia:dirty_first/1</em> and <em>mnesia:dirty_last/1</em> are synonyms.</p><p><strong></strong> dirty_match_object(Pattern) -&gt; RecordList | exit({aborted, Reason}).</p><p>Invokes <em>mnesia:dirty_match_object(Tab, Pattern)</em> where <em>Tab</em> is <em>element(1, Pattern)</em>.</p><p><strong></strong> dirty_match_object(Tab, Pattern) -&gt; RecordList | exit({aborted, Reason}).</p><p>This is the dirty equivalent of the <em>mnesia:match_object/3</em> function.</p><p><strong></strong> dirty_next(Tab, Key) -&gt; Key | exit({aborted, Reason})</p><p>This function makes it possible to traverse a table and perform operations on all records in the table. When the end of the table is reached, the special key <em>'$end_of_table'</em> is returned. Otherwise, the function returns a key which can be used to read the actual record.The behavior is undefined if another Erlang process performs write operations on the table while it is being traversed with the <em>mnesia:dirty_next/2</em> function.</p><p><strong></strong> dirty_prev(Tab, Key) -&gt; Key | exit({aborted, Reason})</p><p>This function works exactly like <em>mnesia:dirty_next/2</em> but returns the previous object in Erlang term order for the ordered_set table type. For all other table types, <em>mnesia:dirty_next/2</em> and <em>mnesia:dirty_prev/2</em> are synonyms.</p><p><strong></strong> dirty_read({Tab, Key}) -&gt; ValueList | exit({aborted, Reason}</p><p>Invokes <em>mnesia:dirty_read(Tab, Key)</em>.</p><p><strong></strong> dirty_read(Tab, Key) -&gt; ValueList | exit({aborted, Reason}</p><p>This is the dirty equivalent of the <em>mnesia:read/3</em> function.</p><p><strong></strong> dirty_select(Tab, MatchSpec) -&gt; ValueList | exit({aborted, Reason}</p><p>This is the dirty equivalent of the <em>mnesia:select/2</em> function.</p><p><strong></strong> dirty_slot(Tab, Slot) -&gt; RecordList | exit({aborted, Reason})</p><p>This function can be used to traverse a table in a manner similar to the <em>mnesia:dirty_next/2</em> function. A table has a number of slots which range from 0 (zero) to some unknown upper bound. The function <em>mnesia:dirty_slot/2</em> returns the special atom <em>'$end_of_table'</em> when the end of the table is reached. The behavior of this function is undefined if a write operation is performed on the table while it is being traversed.</p><p><strong></strong> dirty_update_counter({Tab, Key}, Incr) -&gt; NewVal | exit({aborted, Reason})</p><p>Invokes <em>mnesia:dirty_update_counter(Tab, Key, Incr)</em>.</p><p><strong></strong> dirty_update_counter(Tab, Key, Incr) -&gt; NewVal | exit({aborted, Reason})</p><p>There are no special counter records in Mnesia. However, records of the form <em>{Tab, Key, Integer}</em> can be used as (possibly disc resident) counters, when <em>Tab</em> is a <em>set</em>. This function updates a counter with a positive or negative number. However, counters can never become less than zero. There are two significant differences between this function and the action of first reading the record, performing the arithmetics, and then writing the record:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>It is much more efficient</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>mnesia:dirty_update_counter/3</em> is performed as an atomic operation despite the fact that it is not protected by a transaction.</p>
  </dd>

</dl>
<p>If two processes perform <em>mnesia:dirty_update_counter/3</em> simultaneously, both updates will take effect without the risk of losing one of the updates. The new value <em>NewVal</em> of the counter is returned.</p><p>If <em>Key</em> don't exits, a new record is created with the value <em>Incr</em> if it is larger than 0, otherwise it is set to 0.</p><p><strong></strong> dirty_write(Record) -&gt; ok | exit({aborted, Reason})</p><p>Invokes <em>mnesia:dirty_write(Tab, Record)</em> where <em>Tab</em> is <em>element(1, Record)</em>.</p><p><strong></strong> dirty_write(Tab, Record) -&gt; ok | exit({aborted, Reason})</p><p>This is the dirty equivalent of <em>mnesia:write/3</em>.</p><p><strong></strong> dump_log() -&gt; dumped</p><p>Performs a user initiated dump of the local log file. This is usually not necessary since Mnesia, by default, manages this automatically. See configuration parameters <strong>dump_log_time_threshold</strong> and <strong>dump_log_write_threshold</strong>.</p><p><strong></strong> dump_tables(TabList) -&gt; {atomic, ok} | {aborted, Reason}</p><p>This function dumps a set of <em>ram_copies</em> tables to disc. The next time the system is started, these tables are initiated with the data found in the files that are the result of this dump. None of the tables may have disc resident replicas.</p><p><strong></strong> dump_to_textfile(Filename)</p><p>Dumps all local tables of a mnesia system into a text file which can then be edited (by means of a normal text editor) and then later be reloaded with <em>mnesia:load_textfile/1</em>. Only use this function for educational purposes. Use other functions to deal with real backups.</p><p><strong></strong> error_description(Error) -&gt; String</p><p>All Mnesia transactions, including all the schema update functions, either return the value <em>{atomic, Val}</em> or the tuple <em>{aborted, Reason}</em>. The <em>Reason</em> can be either of the following atoms. The <em>error_description/1</em> function returns a descriptive string which describes the error.</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>nested_transaction</em>. Nested transactions are not allowed in this context.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>badarg</em>. Bad or invalid argument, possibly bad type.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>no_transaction</em>. Operation not allowed outside transactions.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>combine_error</em>. Table options were illegally combined.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>bad_index</em>. Index already exists or was out of bounds.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>already_exists</em>. Schema option is already set.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>index_exists</em>. Some operations cannot be performed on tabs with index.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>no_exists</em>. Tried to perform operation on non-existing, or not alive, item.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>system_limit</em>. Some system_limit was exhausted.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>mnesia_down</em>. A transaction involving records at some remote node which died while transaction was executing. Record(s) are no longer available elsewhere in the network.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>not_a_db_node</em>. A node which does not exist in the schema was mentioned.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>bad_type</em>. Bad type on some arguments.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>node_not_running</em>. Node not running.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>truncated_binary_file</em>. Truncated binary in file.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>active</em>. Some delete operations require that all active records are removed.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>illegal</em>. Operation not supported on record.</p>
  </dd>

</dl>
<p>The <em>Error</em> may be <em>Reason</em>, <em>{error, Reason}</em>, or <em>{aborted, Reason}</em>. The <em>Reason</em> may be an atom or a tuple with <em>Reason</em> as an atom in the first field.</p><p><strong></strong> ets(Fun, [, Args]) -&gt; ResultOfFun | exit(Reason)</p><p>Call the <em>Fun</em> in a raw context which is not protected by a transaction. The Mnesia function call is performed in the <em>Fun</em> are performed directly on the local <em>ets</em> tables on the assumption that the local storage type is <em>ram_copies</em> and the tables are not replicated to other nodes. Subscriptions are not triggered and checkpoints are not updated, but it is extremely fast. This function can also be applied to <em>disc_copies</em> tables if all operations are read only. See <em>mnesia:activity/4</em> and the Mnesia User's Guide for more details.</p><p><em>Note:</em> Calling (nesting) a <em>mnesia:ets</em> inside a transaction context will inherit the transaction semantics.</p><p><strong></strong> first(Tab) -&gt; Key | transaction abort</p><p>Records in <em>set</em> or <em>bag</em> tables are not ordered. However, there is an ordering of the records which is not known to the user. Accordingly, it is possible to traverse a table by means of this function in conjunction with the <em>mnesia:next/2</em> function.</p><p>If there are no records at all in the table, this function returns the atom <em>'$end_of_table'</em>. For this reason, it is highly undesirable, but not disallowed, to use this atom as the key for any user records.</p><p><strong></strong> foldl(Function, Acc, Table) -&gt; NewAcc | transaction abort</p><p>Iterates over the table <em>Table</em> and calls <em>Function(Record, NewAcc)</em> for each <em>Record</em> in the table. The term returned from <em>Function</em> will be used as the second argument in the next call to the <em>Function</em>.</p><p><em>foldl</em> returns the same term as the last call to <em>Function</em> returned.</p><p><strong></strong> foldr(Function, Acc, Table) -&gt; NewAcc | transaction abort</p><p>This function works exactly like <em>foldl/3</em> but iterates the table in the opposite order for the <em>ordered_set</em> table type. For all other table types, <em>foldr/3</em> and <em>foldl/3</em> are synonyms.</p><p><strong></strong> force_load_table(Tab) -&gt; yes | ErrorDescription</p><p>The Mnesia algorithm for table load might lead to a situation where a table cannot be loaded. This situation occurs when a node is started and Mnesia concludes, or suspects, that another copy of the table was active after this local copy became inactive due to a system crash.</p><p>If this situation is not acceptable, this function can be used to override the strategy of the Mnesia table load algorithm. This could lead to a situation where some transaction effects are lost with a inconsistent database as result, but for some applications high availability is more important than consistent data.</p><p><strong></strong> index_match_object(Pattern, Pos) -&gt; transaction abort | ObjList</p><p>Invokes <em>mnesia:index_match_object(Tab, Pattern, Pos, read)</em> where <em>Tab</em> is <em>element(1, Pattern)</em>.</p><p><strong></strong> index_match_object(Tab, Pattern, Pos, LockKind) -&gt; transaction abort | ObjList</p><p>In a manner similar to the <em>mnesia:index_read/3</em> function, we can also utilize any index information when we try to match records. This function takes a pattern which obeys the same rules as the <em>mnesia:match_object/3</em> function with the exception that this function requires the following conditions:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>The table <em>Tab</em> must have an index on position <em>Pos</em>.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>The element in position <em>Pos</em> in <em>Pattern</em> must be bound. <em>Pos</em> may either be an integer (#record.Field), or an attribute name.</p>
  </dd>

</dl>
<p>The two index search functions described here are automatically invoked when searching tables with <em>qlc</em> list comprehensions and also when using the low level <em>mnesia:[dirty_]match_object</em> functions.</p><p>The semantics of this function is context sensitive. See <em>mnesia:activity/4</em> for more information. In transaction context it acquires a lock of type <em>LockKind</em> on the entire table or on a single record. Currently, the lock type <em>read</em> is supported.</p><p><strong></strong> index_read(Tab, SecondaryKey, Pos) -&gt; transaction abort | RecordList</p><p>Assume there is an index on position <em>Pos</em> for a certain record type. This function can be used to read the records without knowing the actual key for the record. For example, with an index in position 1 of the <em>person</em> table, the call <em>mnesia:index_read(person, 36, #person.age)</em> returns a list of all persons with age equal to 36. <em>Pos</em> may also be an attribute name (atom), but if the notation <em>mnesia:index_read(person, 36, age)</em> is used, the field position will be searched for in runtime, for each call.</p><p>The semantics of this function is context sensitive. See <em>mnesia:activity/4</em> for more information. In transaction context it acquires a read lock on the entire table.</p><p><strong></strong> info() -&gt; ok</p><p>Prints some information about the system on the tty. This function may be used even if Mnesia is not started. However, more information will be displayed if Mnesia is started.</p><p><strong></strong> install_fallback(Opaque) -&gt; ok | {error,Reason}</p><p>Invokes <em>mnesia:install_fallback(Opaque, Args)</em> where <em>Args</em> is <em>[{scope, global}]</em>.</p><p><strong></strong> install_fallback(Opaque), BackupMod) -&gt; ok | {error,Reason}</p><p>Invokes <em>mnesia:install_fallback(Opaque, Args)</em> where <em>Args</em> is <em>[{scope, global}, {module, BackupMod}]</em>.</p><p><strong></strong> install_fallback(Opaque, Args) -&gt; ok | {error,Reason}</p><p>This function is used to install a backup as fallback. The fallback will be used to restore the database at the next start-up. Installation of fallbacks requires Erlang to be up and running on all the involved nodes, but it does not matter if Mnesia is running or not. The installation of the fallback will fail if the local node is not one of the disc resident nodes in the backup.</p><p><em>Args</em> is a list of the following tuples:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{module, BackupMod}</em>. All accesses of the backup media is performed via a callback module named <em>BackupMod</em>. The <em>Opaque</em> argument is forwarded to the callback module which may interpret it as it wish. The default callback module is called <em>mnesia_backup</em> and it interprets the <em>Opaque</em> argument as a local filename. The default for this module is also configurable via the <em>-mnesia mnesia_backup</em> configuration parameter.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{scope, Scope}</em> The <em>Scope</em> of a fallback may either be <em>global</em> for the entire database or <em>local</em> for one node. By default, the installation of a fallback is a global operation which either is performed all nodes with disc resident schema or none. Which nodes that are disc resident or not, is determined from the schema info in the backup.</p><p>If the <em>Scope</em> of the operation is <em>local</em> the fallback will only be installed on the local node.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{mnesia_dir, AlternateDir}</em> This argument is only valid if the scope of the installation is <em>local</em>. Normally the installation of a fallback is targeted towards the Mnesia directory as configured with the <em>-mnesia dir</em> configuration parameter. But by explicitly supplying an <em>AlternateDir</em> the fallback will be installed there regardless of the Mnesia directory configuration parameter setting. After installation of a fallback on an alternate Mnesia directory that directory is fully prepared for usage as an active Mnesia directory.</p><p>This is a somewhat dangerous feature which must be used with care. By unintentional mixing of directories you may easily end up with a inconsistent database, if the same backup is installed on more than one directory.</p>
  </dd>

</dl>
<p><strong></strong> is_transaction() -&gt; boolean</p><p>When this function is executed inside a transaction context it returns <em>true</em>, otherwise <em>false</em>.</p><p><strong></strong> last(Tab) -&gt; Key | transaction abort</p><p>This function works exactly like <em>mnesia:first/1</em> but returns the last object in Erlang term order for the <em>ordered_set</em> table type. For all other table types, <em>mnesia:first/1</em> and <em>mnesia:last/1</em> are synonyms.</p><p><strong></strong> load_textfile(Filename)</p><p>Loads a series of definitions and data found in the text file (generated with <em>mnesia:dump_to_textfile/1</em>) into Mnesia. This function also starts Mnesia and possibly creates a new schema. This function is intended for educational purposes only and using other functions to deal with real backups, is recommended.</p><p><strong></strong> lock(LockItem, LockKind) -&gt; Nodes | ok | transaction abort</p><p>Write locks are normally acquired on all nodes where a replica of the table resides (and is active). Read locks are acquired on one node (the local node if a local replica exists). Most of the context sensitive access functions acquire an implicit lock if they are invoked in a transaction context. The granularity of a lock may either be a single record or an entire table.</p><p>The normal usage is to call the function without checking the return value since it exits if it fails and the transaction is restarted by the transaction manager. It returns all the locked nodes if a write lock is acquired, and <em>ok</em> if it was a read lock.</p><p>This function <em>mnesia:lock/2</em> is intended to support explicit locking on tables but also intended for situations when locks need to be acquired regardless of how tables are replicated. Currently, two <em>LockKind</em>'s are supported:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>write</em>: Write locks are exclusive, which means that if one transaction manages to acquire a write lock on an item, no other transaction may acquire any kind of lock on the same item.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>read</em>: Read locks may be shared, which means that if one transaction manages to acquire a read lock on an item, other transactions may also acquire a read lock on the same item. However, if someone has a read lock no one can acquire a write lock at the same item. If some one has a write lock no one can acquire a read lock nor a write lock at the same item.</p>
  </dd>

</dl>
<p>Conflicting lock requests are automatically queued if there is no risk of a deadlock. Otherwise the transaction must be aborted and executed again. Mnesia does this automatically as long as the upper limit of maximum <em>retries</em> is not reached. See <em>mnesia:transaction/3</em> for the details.</p><p>For the sake of completeness sticky write locks will also be described here even if a sticky write lock is not supported by this particular function:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>sticky_write</em>: Sticky write locks are a mechanism which can be used to optimize write lock acquisition. If your application uses replicated tables mainly for fault tolerance (as opposed to read access optimization purpose), sticky locks may be the best option available.</p><p>When a sticky write lock is acquired, all nodes will be informed which node is locked. Subsequently, sticky lock requests from the same node will be performed as a local operation without any communication with other nodes. The sticky lock lingers on the node even after the transaction has ended. See the Mnesia User's Guide for more information.</p>
  </dd>

</dl>
<p>Currently, two kinds of <em>LockItem</em>'s are supported by this function:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{table, Tab}</em>: This acquires a lock of type <em>LockKind</em> on the entire table <em>Tab</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{global, GlobalKey, Nodes}</em>: This acquires a lock of type <em>LockKind</em> on the global resource <em>GlobalKey</em>. The lock is acquired on all active nodes in the <em>Nodes</em> list.</p>
  </dd>

</dl>
<p>Locks are released when the outermost transaction ends.</p><p>The semantics of this function is context sensitive. See <em>mnesia:activity/4</em> for more information. In transaction context it acquires locks otherwise it just ignores the request.</p><p><strong></strong> match_object(Pattern) -&gt;transaction abort | RecList</p><p>Invokes <em>mnesia:match_object(Tab, Pattern, read)</em> where <em>Tab</em> is <em>element(1, Pattern)</em>.</p><p><strong></strong> match_object(Tab, Pattern, LockKind) -&gt;transaction abort | RecList</p><p>This function takes a pattern with 'don't care' variables denoted as a '_' parameter. This function returns a list of records which matched the pattern. Since the second element of a record in a table is considered to be the key for the record, the performance of this function depends on whether this key is bound or not.</p><p>For example, the call <em>mnesia:match_object(person, {person, '_', 36, '_', '_'}, read)</em> returns a list of all person records with an age field of thirty-six (36).</p><p>The function <em>mnesia:match_object/3</em> automatically uses indices if these exist. However, no heuristics are performed in order to select the best index.</p><p>The semantics of this function is context sensitive. See <em>mnesia:activity/4</em> for more information. In transaction context it acquires a lock of type <em>LockKind</em> on the entire table or a single record. Currently, the lock type <em>read</em> is supported.</p><p><strong></strong> move_table_copy(Tab, From, To) -&gt; {aborted, Reason} | {atomic, ok}</p><p>Moves the copy of table <em>Tab</em> from node <em>From</em> to node <em>To</em>.</p><p>The storage type is preserved. For example, a RAM table moved from one node remains a RAM on the new node. It is still possible for other transactions to read and write in the table while it is being moved.</p><p>This function cannot be used on <em>local_content</em> tables.</p><p><strong></strong> next(Tab, Key) -&gt; Key | transaction abort</p><p>This function makes it possible to traverse a table and perform operations on all records in the table. When the end of the table is reached, the special key <em>'$end_of_table'</em> is returned. Otherwise, the function returns a key which can be used to read the actual record.</p><p><strong></strong> prev(Tab, Key) -&gt; Key | transaction abort</p><p>This function works exactly like <em>mnesia:next/2</em> but returns the previous object in Erlang term order for the ordered_set table type. For all other table types, <em>mnesia:next/2</em> and <em>mnesia:prev/2</em> are synonyms.</p><p><strong></strong> read({Tab, Key}) -&gt; transaction abort | RecordList</p><p>Invokes <em>mnesia:read(Tab, Key, read)</em>.</p><p><strong></strong> read(Tab, Key) -&gt; transaction abort | RecordList</p><p>Invokes <em>mnesia:read(Tab, Key, read)</em>.</p><p><strong></strong> read(Tab, Key, LockKind) -&gt; transaction abort | RecordList</p><p>This function reads all records from table <em>Tab</em> with key <em>Key</em>. This function has the same semantics regardless of the location of <em>Tab</em>. If the table is of type <em>bag</em>, the <em>mnesia:read(Tab, Key)</em> can return an arbitrarily long list. If the table is of type <em>set</em>, the list is either of length 1, or <em>[]</em>.</p><p>The semantics of this function is context sensitive. See <em>mnesia:activity/4</em> for more information. In transaction context it acquires a lock of type <em>LockKind</em>. Currently, the lock types <em>read</em>, <em>write</em> and <em>sticky_write</em> are supported.</p><p>If the user wants to update the record it is more efficient to use <em>write/sticky_write</em> as the LockKind. If majority checking is active on the table, it will be checked as soon as a write lock is attempted. This can be used to quickly abort if the majority condition isn't met.</p><p><strong></strong> read_lock_table(Tab) -&gt; ok | transaction abort</p><p>Invokes <em>mnesia:lock({table, Tab}, read)</em>.</p><p><strong></strong> report_event(Event) -&gt; ok</p><p>When tracing a system of Mnesia applications it is useful to be able to interleave Mnesia's own events with application related events that give information about the application context.</p><p>Whenever the application begins a new and demanding Mnesia task, or if it is entering a new interesting phase in its execution, it may be a good idea to use <em>mnesia:report_event/1</em>. The <em>Event</em> may be any term and generates a <em>{mnesia_user, Event}</em> event for any processes that subscribe to Mnesia system events.</p><p><strong></strong> restore(Opaque, Args) -&gt; {atomic, RestoredTabs} |{aborted, Reason}</p><p>With this function, tables may be restored online from a backup without restarting Mnesia. <em>Opaque</em> is forwarded to the backup module. <em>Args</em> is a list of the following tuples:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{module,BackupMod}</em> The backup module <em>BackupMod</em> will be used to access the backup media. If omitted, the default backup module will be used.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{skip_tables, TabList}</em> Where <em>TabList</em> is a list of tables which should not be read from the backup.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{clear_tables, TabList}</em> Where <em>TabList</em> is a list of tables which should be cleared, before the records from the backup are inserted, ie. all records in the tables are deleted before the tables are restored. Schema information about the tables is not cleared or read from backup.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{keep_tables, TabList}</em> Where <em>TabList</em> is a list of tables which should be not be cleared, before the records from the backup are inserted, i.e. the records in the backup will be added to the records in the table. Schema information about the tables is not cleared or read from backup.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{recreate_tables, TabList}</em> Where <em>TabList</em> is a list of tables which should be re-created, before the records from the backup are inserted. The tables are first deleted and then created with the schema information from the backup. All the nodes in the backup needs to be up and running.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{default_op, Operation}</em> Where <em>Operation</em> is one of the following operations <em>skip_tables</em>, <em>clear_tables</em>, <em>keep_tables</em> or <em>recreate_tables</em>. The default operation specifies which operation should be used on tables from the backup which are not specified in any of the lists above. If omitted, the operation <em>clear_tables</em> will be used.</p>
  </dd>

</dl>
<p>The affected tables are write locked during the restoration, but regardless of the lock conflicts caused by this, the applications can continue to do their work while the restoration is being performed. The restoration is performed as one single transaction.</p><p>If the database is huge, it may not be possible to restore it online. In such cases, the old database must be restored by installing a fallback and then restart.</p><p><strong></strong> s_delete({Tab, Key}) -&gt; ok | transaction abort</p><p>Invokes <em>mnesia:delete(Tab, Key, sticky_write)</em></p><p><strong></strong> s_delete_object(Record) -&gt; ok | transaction abort</p><p>Invokes <em>mnesia:delete_object(Tab, Record, sticky_write)</em> where <em>Tab</em> is <em>element(1, Record)</em>.</p><p><strong></strong> s_write(Record) -&gt; ok | transaction abort</p><p>Invokes <em>mnesia:write(Tab, Record, sticky_write)</em> where <em>Tab</em> is <em>element(1, Record)</em>.</p><p><strong></strong> schema() -&gt; ok</p><p>Prints information about all table definitions on the tty.</p><p><strong></strong> schema(Tab) -&gt; ok</p><p>Prints information about one table definition on the tty.</p><p><strong></strong> select(Tab, MatchSpec [, Lock]) -&gt; transaction abort | [Object]</p><p>Matches the objects in the table <em>Tab</em> using a match_spec as described in the ERTS Users Guide. Optionally a lock <em>read</em> or <em>write</em> can be given as the third argument, default is <em>read</em>. The return value depends on the <em>MatchSpec</em>.</p><p><em>Note:</em> for best performance <em>select</em> should be used before any modifying operations are done on that table in the same transaction, i.e. don't use <em>write</em> or <em>delete</em> before a <em>select</em>.</p><p>In its simplest forms the match_spec's look like this:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>MatchSpec = [MatchFunction]</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>MatchFunction = {MatchHead, [Guard], [Result]}</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>MatchHead = tuple() | record()</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>Guard = {"Guardtest name", ...}</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>Result = "Term construct"</p>
  </dd>

</dl>
<p>See the ERTS Users Guide and <em>ets</em> documentation for a complete description of the select.</p><p>For example to find the names of all male persons with an age over 30 in table Tab do:</p>
<pre>
MatchHead = #person{name='$1', sex=male, age='$2', _='_'},
Guard = {'&gt;', '$2', 30},
Result = '$1',
mnesia:select(Tab,[{MatchHead, [Guard], [Result]}]),

</pre>
<p><strong></strong> select(Tab, MatchSpec, NObjects, Lock) -&gt; transaction abort | {[Object],Cont} | '$end_of_table'</p><p>Matches the objects in the table <em>Tab</em> using a match_spec as described in ERTS users guide, and returns a chunk of terms and a continuation, the wanted number of returned terms is specified by the <em>NObjects</em> argument. The lock argument can be <em>read</em> or <em>write</em>. The continuation should be used as argument to <em>mnesia:select/1</em>, if more or all answers are needed.</p><p><em>Note:</em> for best performance <em>select</em> should be used before any modifying operations are done on that table in the same transaction, i.e. don't use <em>mnesia:write</em> or <em>mnesia:delete</em> before a <em>mnesia:select</em>. For efficiency the <em>NObjects</em> is a recommendation only and the result may contain anything from an empty list to all available results.</p><p><strong></strong> select(Cont) -&gt; transaction abort | {[Object],Cont} | '$end_of_table'</p><p>Selects more objects with the match specification initiated by <em>mnesia:select/4</em>.</p><p><em>Note:</em> Any modifying operations, i.e. <em>mnesia:write</em> or <em>mnesia:delete</em>, that are done between the <em>mnesia:select/4</em> and <em>mnesia:select/1</em> calls will not be visible in the result.</p><p><strong></strong> set_debug_level(Level) -&gt; OldLevel</p><p>Changes the internal debug level of Mnesia. See the chapter about configuration parameters for details.</p><p><strong></strong> set_master_nodes(MasterNodes) -&gt; ok | {error, Reason}</p><p>For each table Mnesia will determine its replica nodes (<em>TabNodes</em>) and invoke <em>mnesia:set_master_nodes(Tab, TabMasterNodes)</em> where <em>TabMasterNodes</em> is the intersection of <em>MasterNodes</em> and <em>TabNodes</em>. See <em>mnesia:set_master_nodes/2</em> about the semantics.</p><p><strong></strong> set_master_nodes(Tab, MasterNodes) -&gt; ok | {error, Reason}</p><p>If the application detects that there has been a communication failure (in a potentially partitioned network) which may have caused an inconsistent database, it may use the function <em>mnesia:set_master_nodes(Tab, MasterNodes)</em> to define from which nodes each table will be loaded. At startup Mnesia's normal table load algorithm will be bypassed and the table will be loaded from one of the master nodes defined for the table, regardless of when and if Mnesia was terminated on other nodes. The <em>MasterNodes</em> may only contain nodes where the table has a replica and if the <em>MasterNodes</em> list is empty, the master node recovery mechanism for the particular table will be reset and the normal load mechanism will be used at next restart.</p><p>The master node setting is always local and it may be changed regardless of whether Mnesia is started or not.</p><p>The database may also become inconsistent if the <em>max_wait_for_decision</em> configuration parameter is used or if <em>mnesia:force_load_table/1</em> is used.</p><p><strong></strong> snmp_close_table(Tab) -&gt; {aborted, R} | {atomic, ok}</p><p>Removes the possibility for SNMP to manipulate the table.</p><p><strong></strong> snmp_get_mnesia_key(Tab, RowIndex) -&gt; {ok, Key} | undefined</p><p>Types:</p><p>Tab ::= atom()</p><p>RowIndex ::= [integer()]</p><p>Key ::= key() | {key(), key(), ...}</p><p>key() ::= integer() | string() | [integer()]</p><p>Transforms an SNMP index to the corresponding Mnesia key. If the SNMP table has multiple keys, the key is a tuple of the key columns.</p><p><strong></strong> snmp_get_next_index(Tab, RowIndex) -&gt; {ok, NextIndex} | endOfTable</p><p>Types:</p><p>Tab ::= atom()</p><p>RowIndex ::= [integer()]</p><p>NextIndex ::= [integer()]</p><p>The <em>RowIndex</em> may specify a non-existing row. Specifically, it might be the empty list. Returns the index of the next lexicographical row. If <em>RowIndex</em> is the empty list, this function will return the index of the first row in the table.</p><p><strong></strong> snmp_get_row(Tab, RowIndex) -&gt; {ok, Row} | undefined</p><p>Types:</p><p>Tab ::= atom()</p><p>RowIndex ::= [integer()]</p><p>Row ::= record(Tab)</p><p>Makes it possible to read a row by its SNMP index. This index is specified as an SNMP OBJECT IDENTIFIER, a list of integers.</p><p><strong></strong> snmp_open_table(Tab, SnmpStruct) -&gt; {aborted, R} | {atomic, ok}</p><p>Types:</p><p>Tab ::= atom()</p><p>SnmpStruct ::= [{key, type()}]</p><p>type() ::= type_spec() | {type_spec(), type_spec(), ...}</p><p>type_spec() ::= fix_string | string | integer</p><p>It is possible to establish a direct one to one mapping between Mnesia tables and SNMP tables. Many telecommunication applications are controlled and monitored by the SNMP protocol. This connection between Mnesia and SNMP makes it simple and convenient to achieve this.</p><p>The <em>SnmpStruct</em> argument is a list of SNMP information. Currently, the only information needed is information about the key types in the table. It is not possible to handle multiple keys in Mnesia, but many SNMP tables have multiple keys. Therefore, the following convention is used: if a table has multiple keys, these must always be stored as a tuple of the keys. Information about the key types is specified as a tuple of atoms describing the types. The only significant type is <em>fix_string</em>. This means that a string has fixed size. For example:</p>
<pre>
mnesia:snmp_open_table(person, [{key, string}])

</pre>
<p>causes the <em>person</em> table to be ordered as an SNMP table.</p><p>Consider the following schema for a table of company employees. Each employee is identified by department number and name. The other table column stores the telephone number:</p>
<pre>
mnesia:create_table(employee,
    [{snmp, [{key, {integer, string}}]},
     {attributes, record_info(fields, employees)}]),

</pre>
<p>The corresponding SNMP table would have three columns; <em>department</em>, <em>name</em> and <em>telno</em>.</p><p>It is possible to have table columns that are not visible through the SNMP protocol. These columns must be the last columns of the table. In the previous example, the SNMP table could have columns <em>department</em> and <em>name</em> only. The application could then use the <em>telno</em> column internally, but it would not be visible to the SNMP managers.</p><p>In a table monitored by SNMP, all elements must be integers, strings, or lists of integers.</p><p>When a table is SNMP ordered, modifications are more expensive than usual, O(logN). And more memory is used.</p><p><em>Note:</em>Only the lexicographical SNMP ordering is implemented in Mnesia, not the actual SNMP monitoring.</p><p><strong></strong> start() -&gt; ok | {error, Reason}</p><p>The start-up procedure for a set of Mnesia nodes is a fairly complicated operation. A Mnesia system consists of a set of nodes, with Mnesia started locally on all participating nodes. Normally, each node has a directory where all the Mnesia files are written. This directory will be referred to as the Mnesia directory. Mnesia may also be started on disc-less nodes. See <em>mnesia:create_schema/1</em> and the Mnesia User's Guide for more information about disc-less nodes.</p><p>The set of nodes which makes up a Mnesia system is kept in a schema and it is possible to add and remove Mnesia nodes from the schema. The initial schema is normally created on disc with the function <em>mnesia:create_schema/1</em>. On disc-less nodes, a tiny default schema is generated each time Mnesia is started. During the start-up procedure, Mnesia will exchange schema information between the nodes in order to verify that the table definitions are compatible.</p><p>Each schema has a unique cookie which may be regarded as a unique schema identifier. The cookie must be the same on all nodes where Mnesia is supposed to run. See the Mnesia User's Guide for more information about these details.</p><p>The schema file, as well as all other files which Mnesia needs, are kept in the Mnesia directory. The command line option <em>-mnesia dir Dir</em> can be used to specify the location of this directory to the Mnesia system. If no such command line option is found, the name of the directory defaults to <em>Mnesia.Node</em>.</p><p><em>application:start(mnesia)</em> may also be used.</p><p><strong></strong> stop() -&gt; stopped</p><p>Stops Mnesia locally on the current node.</p><p><em>application:stop(mnesia)</em> may also be used.</p><p><strong></strong> subscribe(EventCategory)</p><p>Ensures that a copy of all events of type <em>EventCategory</em> are sent to the caller. The event types available are described in the Mnesia User's Guide.</p><p><strong></strong> sync_dirty(Fun, [, Args]) -&gt; ResultOfFun | exit(Reason)</p><p>Call the <em>Fun</em> in a context which is not protected by a transaction. The Mnesia function calls performed in the <em>Fun</em> are mapped to the corresponding dirty functions. It is performed in almost the same context as <em>mnesia:async_dirty/1,2</em>. The difference is that the operations are performed synchronously. The caller waits for the updates to be performed on all active replicas before the <em>Fun</em> returns. See <em>mnesia:activity/4</em> and the Mnesia User's Guide for more details.</p><p><strong></strong> sync_log() -&gt; ok | {error, Reason}</p><p>Ensures that the local transaction log file is synced to disk. On a single node system data written to disk tables, since the last dump, can be lost in case of a power outage. See <strong>dump_log/0</strong>.</p><p><strong></strong> sync_transaction(Fun, [[, Args], Retries]) -&gt; {aborted, Reason} | {atomic, ResultOfFun}</p><p>This function waits until data have been committed and logged to disk (if disk is used) on every involved node before it returns, otherwise it behaves as <em>mnesia:transaction/[1,2,3]</em>.</p><p>This functionality can be used to avoid that one process may overload a database on another node.</p><p><strong></strong> system_info(InfoKey) -&gt; Info | exit({aborted, Reason})</p><p>Returns information about the Mnesia system, such as transaction statistics, db_nodes, and configuration parameters. Valid keys are:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>all</em>. This argument returns a list of all local system information. Each element is a <em>{InfoKey, InfoVal}</em> tuples.<em>Note:</em> New <em>InfoKey</em>'s may be added and old undocumented <em>InfoKey</em>'s may be removed without notice.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>access_module</em>. This argument returns the name of the module which is configured to be the activity access callback module.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>auto_repair</em>. This argument returns <em>true</em> or <em>false</em> to indicate if Mnesia is configured to invoke the auto repair facility on corrupted disc files.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>backup_module</em>. This argument returns the name of the module which is configured to be the backup callback module.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>checkpoints</em>. This argument returns a list of the names of the checkpoints currently active on this node.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>event_module</em>. This argument returns the name of the module which is the event handler callback module.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>db_nodes</em>. This argument returns the nodes which make up the persistent database. Disc less nodes will only be included in the list of nodes if they explicitly has been added to the schema, e.g. with <em>mnesia:add_table_copy/3</em>. The function can be invoked even if Mnesia is not yet running.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>debug</em>. This argument returns the current debug level of Mnesia.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>directory</em>. This argument returns the name of the Mnesia directory. It can be invoked even if Mnesia is not yet running.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>dump_log_load_regulation</em>. This argument returns a boolean which tells whether Mnesia is configured to load regulate the dumper process or not. This feature is temporary and will disappear in future releases.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>dump_log_time_threshold</em>. This argument returns the time threshold for transaction log dumps in milliseconds.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>dump_log_update_in_place</em>. This argument returns a boolean which tells whether Mnesia is configured to perform the updates in the dets files directly or if the updates should be performed in a copy of the dets files.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>dump_log_write_threshold</em>. This argument returns the write threshold for transaction log dumps as the number of writes to the transaction log.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>extra_db_nodes</em>. This argument returns a list of extra db_nodes to be contacted at start-up.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>fallback_activated</em>. This argument returns true if a fallback is activated, otherwise false.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>held_locks</em>. This argument returns a list of all locks held by the local Mnesia lock manager.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>is_running</em>. This argument returns <em>yes</em> or <em>no</em> to indicate if Mnesia is running. It may also return <em>starting</em> or <em>stopping</em>. Can be invoked even if Mnesia is not yet running.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>local_tables</em>. This argument returns a list of all tables which are configured to reside locally.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>lock_queue</em>. This argument returns a list of all transactions that are queued for execution by the local lock manager.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>log_version</em>. This argument returns the version number of the Mnesia transaction log format.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>master_node_tables</em>. This argument returns a list of all tables with at least one master node.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>protocol_version</em>. This argument returns the version number of the Mnesia inter-process communication protocol.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>running_db_nodes</em>. This argument returns a list of nodes where Mnesia currently is running. This function can be invoked even if Mnesia is not yet running, but it will then have slightly different semantics. If Mnesia is down on the local node, the function will return those other <em>db_nodes</em> and <em>extra_db_nodes</em> that for the moment are up and running. If Mnesia is started, the function will return those nodes that Mnesia on the local node is fully connected to. Only those nodes that Mnesia has exchanged schema information with are included as <em>running_db_nodes</em>. After the merge of schemas, the local Mnesia system is fully operable and applications may perform access of remote replicas. Before the schema merge Mnesia will only operate locally. Sometimes there may be more nodes included in the <em>running_db_nodes</em> list than all <em>db_nodes</em> and <em>extra_db_nodes</em> together.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>schema_location</em>. This argument returns the initial schema location.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>subscribers</em>. This argument returns a list of local processes currently subscribing to system events.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>tables</em>. This argument returns a list of all locally known tables.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>transactions</em>. This argument returns a list of all currently active local transactions.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>transaction_failures</em>. This argument returns a number which indicates how many transactions have failed since Mnesia was started.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>transaction_commits</em>. This argument returns a number which indicates how many transactions have terminated successfully since Mnesia was started.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>transaction_restarts</em>. This argument returns a number which indicates how many transactions have been restarted since Mnesia was started.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>transaction_log_writes</em>. This argument returns a number which indicates the number of write operation that have been performed to the transaction log since start-up.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>use_dir</em>. This argument returns a boolean which indicates whether the Mnesia directory is used or not. Can be invoked even if Mnesia is not yet running.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>version</em>. This argument returns the current version number of Mnesia.</p>
  </dd>

</dl>
<p><strong></strong> table(Tab [,[Option]]) -&gt; QueryHandle</p><p>Returns a QLC (Query List Comprehension) query handle, see <strong>qlc(3erl)</strong>.The module <em>qlc</em> implements a query language, it can use mnesia tables as sources of data. Calling <em>mnesia:table/1,2</em> is the means to make the <em>mnesia</em> table <em>Tab</em> usable to QLC.</p><p>The list of Options may contain mnesia options or QLC options, the following options are recognized by Mnesia: <em>{traverse, SelectMethod},{lock, Lock},{n_objects,Number}</em>, any other option is forwarded to QLC. The <em>lock</em> option may be <em>read</em> or <em>write</em>, default is <em>read</em>. The option <em>n_objects</em> specifies (roughly) the number of objects returned from mnesia to QLC. Queries to remote tables may need a larger chunks to reduce network overhead, default <em>100</em> objects at a time are returned. The option <em>traverse</em> determines the method to traverse the whole table (if needed), the default method is <em>select</em>:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>select</em>. The table is traversed by calling <em>mnesia:select/4</em> and <em>mnesia:select/1</em>. The match specification (the second argument of <em>select/3</em>) is assembled by QLC: simple filters are translated into equivalent match specifications while more complicated filters have to be applied to all objects returned by <em>select/3</em> given a match specification that matches all objects.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{select, MatchSpec}</em>. As for <em>select</em> the table is traversed by calling <em>mnesia:select/3</em> and <em>mnesia:select/1</em>. The difference is that the match specification is explicitly given. This is how to state match specifications that cannot easily be expressed within the syntax provided by QLC.</p>
  </dd>

</dl>
<p><strong></strong> table_info(Tab, InfoKey) -&gt; Info | exit({aborted, Reason})</p><p>The <em>table_info/2</em> function takes two arguments. The first is the name of a Mnesia table, the second is one of the following keys:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>all</em>. This argument returns a list of all local table information. Each element is a <em>{InfoKey, ItemVal}</em> tuples. <em>Note:</em> New <em>InfoItem</em>'s may be added and old undocumented <em>InfoItem</em>'s may be removed without notice.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>access_mode</em>. This argument returns the access mode of the table. The access mode may either be read_only or read_write.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>arity</em>. This argument returns the arity of records in the table as specified in the schema.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>attributes</em>. This argument returns the table attribute names which are specified in the schema.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>checkpoints</em>. This argument returns the names of the currently active checkpoints which involves this table on this node.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>cookie</em>. This argument returns a table cookie which is a unique system generated identifier for the table. The cookie is used internally to ensure that two different table definitions using the same table name cannot accidentally be intermixed. The cookie is generated when the table is initially created.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>disc_copies</em>. This argument returns the nodes where a disc_copy of the table resides according to the schema.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>disc_only_copies </em>. This argument returns the nodes where a disc_only_copy of the table resides according to the schema.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>index</em>. This argument returns the list of index position integers for the table.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>load_node</em>. This argument returns the name of the node that Mnesia loaded the table from. The structure of the returned value is unspecified but may be useful for debugging purposes.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>load_order</em>. This argument returns the load order priority of the table. It is an integer and defaults to <em>0</em> (zero).</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>load_reason</em>. This argument returns the reason of why Mnesia decided to load the table. The structure of the returned value is unspecified but may be useful for debugging purposes.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>local_content</em>. This argument returns <em>true</em> or <em>false</em> to indicate whether the table is configured to have locally unique content on each node.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>master_nodes</em>. This argument returns the master nodes of a table.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>memory</em>. This argument returns the number of words allocated to the table on this node.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>ram_copies</em>. This argument returns the nodes where a ram_copy of the table resides according to the schema.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>record_name</em>. This argument returns the record name, common for all records in the table</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>size</em>. This argument returns the number of records inserted in the table.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>snmp</em>. This argument returns the SNMP struct. <em>[]</em>meaning that the table currently has no SNMP properties.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>storage_type</em>.This argument returns the local storage type of the table. It can be <em>disc_copies</em>, <em>ram_copies</em>, <em>disc_only_copies</em>, or the atom <em>unknown</em>. <em>unknown</em> is returned for all tables which only reside remotely.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>subscribers</em>. This argument returns a list of local processes currently subscribing to local table events which involve this table on this node.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>type</em>. This argument returns the table type, which is either <em>bag</em>, <em>set</em> or <em>ordered_set</em>..</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>user_properties</em>. This argument returns the user associated table properties of the table. It is a list of the stored property records.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>version</em>. This argument returns the current version of the table definition. The table version is incremented when the table definition is changed. The table definition may be incremented directly when the table definition has been changed in a schema transaction, or when a committed table definition is merged with table definitions from other nodes during start-up.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>where_to_read</em>.This argument returns the node where the table can be read. If the value <em>nowhere</em> is returned, the table is not loaded, or it resides at a remote node which is not running.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>where_to_write</em>. This argument returns a list of the nodes that currently hold an active replica of the table.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>wild_pattern</em>. This argument returns a structure which can be given to the various match functions for a certain table. A record tuple is where all record fields have the value <em>'_'</em>.</p>
  </dd>

</dl>
<p><strong></strong> transaction(Fun [[, Args], Retries]) -&gt; {aborted, Reason} | {atomic, ResultOfFun}</p><p>This function executes the functional object <em>Fun</em> with arguments <em>Args</em> as a transaction.</p><p>The code which executes inside the transaction can consist of a series of table manipulation functions. If something goes wrong inside the transaction as a result of a user error or a certain table not being available, the entire transaction is aborted and the function <em>transaction/1</em> returns the tuple <em>{aborted, Reason}</em>.</p><p>If all is well, <em>{atomic, ResultOfFun}</em> is returned where <em>ResultOfFun</em> is the value of the last expression in <em>Fun</em>.</p><p>A function which adds a family to the database can be written as follows if we have a structure <em>{family, Father, Mother, ChildrenList}</em>:</p>
<pre>
add_family({family, F, M, Children}) -&gt;
    ChildOids = lists:map(fun oid/1, Children),
    Trans = fun() -&gt;
        mnesia:write(F#person{children = ChildOids},
        mnesia:write(M#person{children = ChildOids},
        Write = fun(Child) -&gt; mnesia:write(Child) end,
        lists:foreach(Write, Children)
    end,
    mnesia:transaction(Trans).

oid(Rec) -&gt; {element(1, Rec), element(2, Rec)}.

</pre>
<p>This code adds a set of people to the database. Running this code within one transaction will ensure that either the whole family is added to the database, or the whole transaction aborts. For example, if the last child is badly formatted, or the executing process terminates due to an <em>'EXIT'</em> signal while executing the family code, the transaction aborts. Accordingly, the situation where half a family is added can never occur.</p><p>It is also useful to update the database within a transaction if several processes concurrently update the same records. For example, the function <em>raise(Name, Amount)</em>, which adds <em>Amount</em> to the salary field of a person, should be implemented as follows:</p>
<pre>
raise(Name, Amount) -&gt;
    mnesia:transaction(fun() -&gt;
        case mnesia:wread({person, Name}) of
            [P] -&gt;
                Salary = Amount + P#person.salary,
                P2 = P#person{salary = Salary},
                mnesia:write(P2);
            _ -&gt;
                mnesia:abort("No such person")
        end
    end).

</pre>
<p>When this function executes within a transaction, several processes running on different nodes can concurrently execute the <em>raise/2</em> function without interfering with each other.</p><p>Since Mnesia detects deadlocks, a transaction can be restarted any number of times. This function will attempt a restart as specified in <em>Retries</em>. <em>Retries</em> must be an integer greater than 0 or the atom <em>infinity</em>. Default is <em>infinity</em>.</p><p><strong></strong> transform_table(Tab, Fun, NewAttributeList, NewRecordName) -&gt; {aborted, R} | {atomic, ok}</p><p>This function applies the argument <em>Fun</em> to all records in the table. <em>Fun</em> is a function which takes a record of the old type and returns a transformed record of the new type. The <em>Fun</em> argument can also be the atom <em>ignore</em>, it indicates that only the meta data about the table will be updated. Usage of <em>ignore</em> is not recommended but included as a possibility for the user do to his own transform. <em>NewAttributeList</em> and <em>NewRecordName</em> specifies the attributes and the new record type of converted table. Table name will always remain unchanged, if the record_name is changed only the mnesia functions which uses table identifiers will work, e.g. <em>mnesia:write/3</em> will work but <em>mnesia:write/1</em> will not.</p><p><strong></strong> transform_table(Tab, Fun, NewAttributeList) -&gt; {aborted, R} | {atomic, ok}</p><p>Invokes <em>mnesia:transform_table(Tab, Fun, NewAttributeList, RecName)</em> where <em>RecName</em> is <em>mnesia:table_info(Tab, record_name)</em>.</p><p><strong></strong> traverse_backup(Source, [SourceMod,] Target, [TargetMod,] Fun, Acc) -&gt; {ok, LastAcc} | {error, Reason}</p><p>With this function it is possible to iterate over a backup, either for the purpose of transforming it into a new backup, or just reading it. The arguments are explained briefly below. See the Mnesia User's Guide for additional details.</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>SourceMod</em> and <em>TargetMod</em> are the names of the modules which actually access the backup media.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>Source</em> and <em>Target</em> are opaque data used exclusively by the modules <em>SourceMod</em> and <em>TargetMod</em> for the purpose of initializing the backup media.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>Acc</em> is an initial accumulator value.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>Fun(BackupItems, Acc)</em> is applied to each item in the backup. The Fun must return a tuple <em>{BackupItems,NewAcc}</em>, where <em>BackupItems</em> is a list of valid backup items, and <em>NewAcc</em> is a new accumulator value. The returned backup items are written in the target backup.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>LastAcc</em> is the last accumulator value. This is the last <em>NewAcc</em> value that was returned by <em>Fun</em>.</p>
  </dd>

</dl>
<p><strong></strong> uninstall_fallback() -&gt; ok | {error,Reason}</p><p>Invokes <em>mnesia:uninstall_fallback([{scope, global}])</em>.</p><p><strong></strong> uninstall_fallback(Args) -&gt; ok | {error,Reason}</p><p>This function is used to de-install a fallback before it has been used to restore the database. This is normally a distributed operation that is either performed on all nodes with disc resident schema or none. Uninstallation of fallbacks requires Erlang to be up and running on all involved nodes, but it does not matter if Mnesia is running or not. Which nodes that are considered as disc-resident nodes is determined from the schema info in the local fallback.</p><p><em>Args</em> is a list of the following tuples:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{module, BackupMod}</em>. See <em>mnesia:install_fallback/2</em> about the semantics.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{scope, Scope}</em> See <em>mnesia:install_fallback/2</em> about the semantics.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{mnesia_dir, AlternateDir}</em> See <em>mnesia:install_fallback/2</em> about the semantics.</p>
  </dd>

</dl>
<p><strong></strong> unsubscribe(EventCategory)</p><p>Stops sending events of type <em>EventCategory</em> to the caller.</p><p><strong></strong> wait_for_tables(TabList,Timeout) -&gt; ok | {timeout, BadTabList} | {error, Reason}</p><p>Some applications need to wait for certain tables to be accessible in order to do useful work. <em>mnesia:wait_for_tables/2</em> hangs until all tables in the <em>TabList</em> are accessible, or until <em>timeout</em> is reached.</p><p><strong></strong> wread({Tab, Key}) -&gt; transaction abort | RecordList</p><p>Invoke <em>mnesia:read(Tab, Key, write)</em>.</p><p><strong></strong> write(Record) -&gt; transaction abort | ok</p><p>Invoke <em>mnesia:write(Tab, Record, write)</em> where <em>Tab</em> is <em>element(1, Record)</em>.</p><p><strong></strong> write(Tab, Record, LockKind) -&gt; transaction abort | ok</p><p>Writes the record <em>Record</em> to the table <em>Tab</em>.</p><p>The function returns <em>ok</em>, or aborts if an error occurs. For example, the transaction aborts if no <em>person</em> table exists.</p><p>The semantics of this function is context sensitive. See <em>mnesia:activity/4</em> for more information. In transaction context it acquires a lock of type <em>LockKind</em>. The following lock types are supported: <em>write</em> and <em>sticky_write</em>.</p><p><strong></strong> write_lock_table(Tab) -&gt; ok | transaction abort</p><p>Invokes <em>mnesia:lock({table, Tab}, write)</em>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONFIGURATION PARAMETERS</h2>
        <div class="sectioncontent">
<p>Mnesia reads the following application configuration parameters:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>-mnesia access_module Module</em>. The name of the Mnesia activity access callback module. The default is <em>mnesia</em>.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>-mnesia auto_repair true | false</em>. This flag controls whether Mnesia will try to automatically repair files that have not been properly closed. The default is <em>true</em>.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>-mnesia backup_module Module</em>. The name of the Mnesia backup callback module. The default is <em>mnesia_backup</em>.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>-mnesia debug Level</em> Controls the debug level of Mnesia. Possible values are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>none</em>: No trace outputs at all. This is the default setting.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>verbose</em>: Activates tracing of important debug events. These debug events generate <em>{mnesia_info, Format, Args}</em> system events. Processes may subscribe to these events with <em>mnesia:subscribe/1</em>. The events are always sent to Mnesia's event handler.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>debug</em>: Activates all events at the verbose level plus full trace of all debug events. These debug events generate <em>{mnesia_info, Format, Args}</em> system events. Processes may subscribe to these events with <em>mnesia:subscribe/1</em>. The events are always sent to the Mnesia event handler. On this debug level, the Mnesia event handler starts subscribing to updates in the schema table.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>trace</em>: Activates all events at the level debug. On this debug level, the Mnesia event handler starts subscribing to updates on all Mnesia tables. This level is only intended for debugging small toy systems since many large events may be generated.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>false</em>: An alias for none.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>true</em>: An alias for debug.</p>
  </dd>

</dl>

  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>-mnesia core_dir Directory</em>. The name of the directory where Mnesia core files is stored or false. Setting it implies that also ram only nodes, will generate a core file if a crash occurs.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>-mnesia dc_dump_limit Number</em>. Controls how often <em>disc_copies</em> tables are dumped from memory. Tables are dumped when <em>filesize(Log) &gt; (filesize(Tab)/Dc_dump_limit)</em>. Lower values reduces cpu overhead but increases disk space and startup times. The default is 4.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>-mnesia dir Directory</em>. The name of the directory where all Mnesia data is stored. The name of the directory must be unique for the current node. Two nodes may, under no circumstances, share the same Mnesia directory. The results are totally unpredictable.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>-mnesia dump_log_load_regulation true | false</em>. Controls if the log dumps should be performed as fast as possible or if the dumper should do its own load regulation. This feature is temporary and will disappear in a future release. The default is <em>false</em>.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>-mnesia dump_log_update_in_place true | false</em>. Controls if log dumps are performed on a copy of the original data file, or if the log dump is performed on the original data file. The default is <em>true</em></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>-mnesia dump_log_write_threshold Max</em>, where <em>Max</em> is an integer which specifies the maximum number of writes allowed to the transaction log before a new dump of the log is performed. It defaults to 100 log writes.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>-mnesia dump_log_time_threshold Max</em>, where <em>Max</em> is an integer which specifies the dump log interval in milliseconds. It defaults to 3 minutes. If a dump has not been performed within <em>dump_log_time_threshold</em> milliseconds, then a new dump is performed regardless of how many writes have been performed.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>-mnesia event_module Module</em>. The name of the Mnesia event handler callback module. The default is <em>mnesia_event</em>.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>-mnesia extra_db_nodes Nodes</em> specifies a list of nodes, in addition to the ones found in the schema, with which Mnesia should also establish contact. The default value is the empty list <em>[]</em>.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>-mnesia fallback_error_function {UserModule, UserFunc}</em> specifies a user supplied callback function which will be called if a fallback is installed and mnesia goes down on another node. Mnesia will call the function with one argument the name of the dying node, e.g. <em>UserModule:UserFunc(DyingNode)</em>. Mnesia should be restarted or else the database could be inconsistent. The default behaviour is to terminate mnesia.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>-mnesia max_wait_for_decision Timeout</em>. Specifies how long Mnesia will wait for other nodes to share their knowledge regarding the outcome of an unclear transaction. By default the <em>Timeout</em> is set to the atom <em>infinity</em>, which implies that if Mnesia upon startup encounters a "heavyweight transaction" whose outcome is unclear, the local Mnesia will wait until Mnesia is started on some (in worst cases all) of the other nodes that were involved in the interrupted transaction. This is a very rare situation, but when/if it happens, Mnesia does not guess if the transaction on the other nodes was committed or aborted. Mnesia will wait until it knows the outcome and then act accordingly.</p><p>If <em>Timeout</em> is set to an integer value in milliseconds, Mnesia will force "heavyweight transactions" to be finished, even if the outcome of the transaction for the moment is unclear. After <em>Timeout</em> milliseconds, Mnesia will commit/abort the transaction and continue with the startup. This may lead to a situation where the transaction is committed on some nodes and aborted on other nodes. If the transaction was a schema transaction, the inconsistency may be fatal.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>-mnesia no_table_loaders NUMBER</em> specifies the number of parallel table loaders during start. More loaders can be good if the network latency is high or if many tables contains few records. The default value is <em>2</em>.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>-mnesia send_compressed Level</em> specifies the level of compression to be used when copying a table from the local node to another one. The default level is 0.</p><p><em>Level</em> must be an integer in the interval [0, 9], with 0 representing no compression and 9 representing maximum compression. Before setting it to a non-zero value, make sure the remote nodes understand this configuration.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>-mnesia schema_location Loc</em> controls where Mnesia will look for its schema. The parameter <em>Loc</em> may be one of the following atoms:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>disc</em>: Mandatory disc. The schema is assumed to be located in the Mnesia directory. If the schema cannot be found, Mnesia refuses to start. This is the old behavior.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>ram</em>: Mandatory RAM. The schema resides in RAM only. At start-up, a tiny new schema is generated. This default schema just contains the definition of the schema table and only resides on the local node. Since no other nodes are found in the default schema, the configuration parameter <em>extra_db_nodes</em> must be used in order to let the node share its table definitions with other nodes. (The <em>extra_db_nodes</em> parameter may also be used on disc based nodes.)</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>opt_disc</em>: Optional disc. The schema may reside either on disc or in RAM. If the schema is found on disc, Mnesia starts as a disc based node and the storage type of the schema table is <em>disc_copies</em>. If no schema is found on disc, Mnesia starts as a disc-less node and the storage type of the schema table is <em>ram_copies</em>. The default value for the application parameter is <em>opt_disc</em>.</p>
  </dd>

</dl>

  </dd>

</dl>
<p>First the SASL application parameters are checked, then the command line flags are checked, and finally, the default value is chosen.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO mnesia&hellip;</h2>
        <div class="sectioncontent">
<p>mnesia_registry(3erl), mnesia_session(3erl), qlc(3erl), dets(3erl), ets(3erl), disk_log(3erl), application(3erl)</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="memsup.3erl.html"><span aria-hidden="true">&larr;</span> memsup.3erl: A memory supervisor process</a></li>
   <li class="next"><a href="mnesia_frag_hash.3erl.html">mnesia_frag_hash.3erl: Defines mnesia_frag_hash callback behaviour <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>TM: Topic maps, base class</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Topic maps, base class">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="TM (3pm) manual">
  <meta name="twitter:description" content="Topic maps, base class">
  <meta name="twitter:image" content="https://www.carta.tech/images/libtm-perl-TM-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/TM.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="TM (3pm) manual" />
  <meta property="og:description" content="Topic maps, base class" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libtm-perl-TM-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">TM<small> (3pm)</small></h1>
        <p class="lead">Topic maps, base class</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/TM.3pm.html">
      <span itemprop="name">TM: Topic maps, base class</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libtm-perl/">
      <span itemprop="name">libtm-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/TM.3pm.html">
      <span itemprop="name">TM: Topic maps, base class</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
    my $tm = new TM (baseuri =&gt; &apos;tm://whatever/&apos;);   # empty map

    # add a toplet (= minimal topic, only identification, no characteristics)
    # by specifying an internal ID
    $tm-&gt;internalize (&apos;aaa&apos;);                        # only internal identifier
    $tm-&gt;internalize (&apos;bbb&apos; =&gt;   &apos;http://bbb/&apos;);     # with a subject address
    $tm-&gt;internalize (&apos;ccc&apos; =&gt; &#92; &apos;http://ccc/&apos;);     # with a subject indicator

    # without specifying an internal ID (will be auto-generated)
    $tm-&gt;internalize (undef =&gt;   &apos;http://ccc/&apos;);     # with a subject address
    $tm-&gt;internalize (undef =&gt; &#92; &apos;http://ccc/&apos;);     # with a subject indicator

    # get rid of toplet(s)
    $tm-&gt;externalize (&apos;tm://whatever/aaa&apos;, ...);

    # find full URI of a toplet
    my $tid  = $tm-&gt;tids (&apos;person&apos;);                     # returns tm://whatever/person
    my @tids = $tm-&gt;tids (&apos;person&apos;, ...)                 # for a whole list

    my $tid  = $tm-&gt;tids (  &apos;http://bbb/&apos;);              # with subject address
    my $tid  = $tm-&gt;tids (&#92; &apos;http://ccc/&apos;);              # with subject indicator

    my @ts   = $tm-&gt;toplets;                             # get all toplets
    my @ts   = $tm-&gt;toplets (&#92; &apos;+all -infrastructure&apos;);  # only those you added

    my @as   = $tm-&gt;asserts (&#92; &apos;+all -infrastructure&apos;);  # only those you added

    my @as   = $tm-&gt;retrieve;                            # all assertions
    my $a    = $tm-&gt;retrieve (&apos;23ac4637....345&apos;);        # returns only that one assertion
    my @as   = $tm-&gt;retrieve (&apos;23ac4637....345&apos;, &apos;...&apos;); # returns all these assertions

    # create standalone assertion
    my $a = Assertion-&gt;new (type    =&gt; &apos;is-subclass-of&apos;,
                            roles   =&gt; [ &apos;subclass&apos;, &apos;superclass&apos; ],
                            players =&gt; [ &apos;rumsti&apos;, &apos;ramsti&apos; ]);
    $tm-&gt;assert ($a);                                    # add that to map

    # create a name
    my $n = Assertion-&gt;new (kind    =&gt; TM-&gt;NAME,
                            type    =&gt; &apos;name&apos;,
                            scope   =&gt; &apos;us&apos;,
                            roles   =&gt; [ &apos;thing&apos;, &apos;value&apos; ],
                            players =&gt; [ &apos;rumsti&apos;, new TM::Literal (&apos;AAA&apos;) ])
    # create an occurrence
    my $o = Assertion-&gt;new (kind    =&gt; TM-&gt;OCC,
                            type    =&gt; &apos;occurrence&apos;,
                            scope   =&gt; &apos;us&apos;,
                            roles   =&gt; [ &apos;thing&apos;, &apos;value&apos; ],
                            players =&gt; [ &apos;rumsti&apos;, new TM::Literal (&apos;http://whatever/&apos;) ])

    $tm-&gt;assert ($n, $o);                                # throw them in

    $tm-&gt;retract ($a-&gt;[TM-&gt;LID], ...);                   # get rid of assertion(s)

    my @as = $tm-&gt;retrieve (&apos;id..of...assertion&apos;);       # extract particular assertions

    # find particular assertions
    # generic search patterns
    my @as = $tm-&gt;match_forall (scope   =&gt; &apos;tm://whatever/sss&apos;);

    my @bs = $tm-&gt;match_forall (type    =&gt; &apos;tm://whatever/ttt&apos;,
                                roles   =&gt; [ &apos;tm://whatever/aaa&apos;, &apos;tm://whatever/bbb&apos; ]);

    # specialized search patterns (see TM::Axes)
    my @cs = $tm-&gt;match_forall (type    =&gt; &apos;is-subclass-of&apos;,
                                arole   =&gt; &apos;superclass&apos;,
                                aplayer =&gt; &apos;tm://whatever/rumsti&apos;,
                                brole   =&gt; &apos;subclass&apos;);

    my @ds = $tm-&gt;match_forall (type    =&gt; &apos;isa&apos;,
                                class   =&gt; &apos;tm://whatever/person&apos;);

    # perform merging, cleanup, etc.
    $tm-&gt;consolidate;

    # check internal consistency of the data structure
    die "panic" if $tm-&gt;insane;

    # taxonomy stuff
    warn "what a subtle joke" if $tm-&gt;is_a ($tm-&gt;tids (&apos;gw_bush&apos;, &apos;moron&apos;));

    die "what a subtle joke"
        unless $tm-&gt;is_subclass ($tm-&gt;tids (&apos;politician&apos;, &apos;moron&apos;));

    # returns Mr. Spock if Volcans are subclassing Aliens
    warn "my best friends: ". Dumper [ $tm-&gt;instancesT ($tm-&gt;tids (&apos;alien&apos;)) ];
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ABSTRACT</h2>
        <div class="sectioncontent">
<p>This class provides read/write access to a data structure according to the Topic Maps paradigm. As it stands, this class implements directly so-called <em>materialized</em> maps, i.e. those maps which completely reside in memory. Implementations for non-materialized maps can be derived from it.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This class implements directly so-called <em>materialized</em> topic maps, i.e. those maps which completely reside in memory. Non-materialized and non-materializable maps can be implemented by deriving from this class by overloading one or all of the sub-interfaces. If this is done cleverly, then any application, even a \s-1TMQL\s0 query processor can operate on non-materialized (virtual) maps in the same way as on materialized ones.</p><h3>Data Structures</h3>
<p>The Topic Maps paradigm knows two abstractions</p>
<dl class='dl-vertical'>
  <dt>
    <em>\s-1TMDM\s0</em>, Topic Maps Data Model
  </dt>
  <dd>
    <p>http://www.isotopicmaps.org/sam/sam-model/ &lt;http://www.isotopicmaps.org/sam/sam-model/&gt;</p>
  </dd>
  <dt>
    <em>\s-1TMRM\s0</em>, Topic Maps Reference Model
  </dt>
  <dd>
    <p>&lt;http://www.isotopicmaps.org/tmrm/&gt;</p>
  </dd>

</dl>
<p>For historical reasons, this package adopts an abstraction which is in between these two. Accordingly, there are only following types of data structures</p>
<dl class='dl-vertical'>
  <dt>
    Toplets:
  </dt>
  <dd>
    <p>These are like \s-1TMDM\s0 topics, but only contain addressing information (subject identifiers and subject addresses) along with an internal identifier.</p>
  </dd>
  <dt>
    Assertions:
  </dt>
  <dd>
    <p>These are like \s-1TMDM\s0 associations, but are generalized to host also occurrences and names. Also associations using predefined association types, such as \*(C`isa\*(C' (<em>instance-class</em>) and \*(C`iko\*(C' (<em>subtype-supertype</em>) are represented as assertions.</p>
  </dd>
  <dt>
    Variants:
  </dt>
  <dd>
    <p>No idea what they are good for. They can be probably safely ignored.</p>
  </dd>

</dl>
<p>The data manipulation interface is very low-level and <strong>directly</strong> exposes internal data structures. As long as you do not mess with the information you get and you follow the \s-1API\s0 rules, this can provide a convenient, fast, albeit not overly comfortable interface. If you prefer more a TMDM-like style of accessing a map then have a look at \s-1TM::DM\s0.</p>
<h3>Identifiers</h3>
<p>Of course, \s-1TM\s0 supports the subject locator and the subject indicator mechanism as mandated by the Topic Maps standards.</p><p>Additionally, this package also uses <em>internal</em> identifiers to address everything which looks and smells like a topic, also associations, names and occurrences. For topics the application (or author) of the topic map will most likely provide these internal identifiers. For the others the identifiers are generated.</p><p>Since v1.31 this package distinguishes between 3 kinds of internal identifiers:</p>
<dl class='dl-vertical'>
  <dt>
    <em>canonicalized</em> toplet identifiers
  </dt>
  <dd>
    <p>These identifiers are always interpreted local to a map, in that the \*(C`baseuri\*(C' of the map is used as prefix. So, a local identifier   chinese-working-conditions will become   tm://nirvana/chinese-working-conditions if the base \s-1URI\s0 of the map were   tm://nirvana/ So if you want to use identifiers such as these, then you should either use the absolut version (including the base \s-1URI\s0) or use the method \*(C`tids\*(C' to find the absolute version.</p>
  </dd>
  <dt>
    <em>sacrosanct</em> toplet identifiers
  </dt>
  <dd>
    <p>All toplets from the infrastructure are declared <em>sacrosanct</em>, i.e. untouchable. Examples are \*(C`isa\*(C', \*(C`class\*(C' or \*(C`us\*(C' (universal scope). These identifiers are always the same in all maps this package system manages. That implies that if you use such an identifier, then you cannot attach a local meaning to it. And it implies that at merging time, toplets with these identifiers will merge. Even if there were no subject indicators or addresses involved. It is probably a good idea to leave such toplets alone as the software is relying on the stability of the sacrosanct identifiers.</p>
  </dd>
  <dt>
    assertion identifiers
  </dt>
  <dd>
    <p>Each assertion also has an (internal) identifier. It is a function from the content, so it is characteristic for the assertion.</p>
  </dd>

</dl>

<h3>Consistency</h3>
<p>An application using a map may expect that a map is <em>consolidated</em>, i.e. that the following consistency conditions are met:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>A1</strong> (fixed on)
  </dt>
  <dd>
    <p>Every identifier appearing in some assertion as type, scope, role or player is also registered as toplet.</p>
  </dd>
  <dt>
    <strong>Indicator_based_Merging</strong> (default: on)
  </dt>
  <dd>
    <p>Two (or more) toplets sharing the same <em>subject identifier</em> are treated as one toplet.</p>
  </dd>
  <dt>
    <strong>Subject_based_Merging</strong> (default: on)
  </dt>
  <dd>
    <p>Two (or more) toplets sharing the same <em>subject locator</em> are treated as one toplet.</p>
  </dd>
  <dt>
    <strong>TNC_based_Merging</strong> (default: off)
  </dt>
  <dd>
    <p>Two (or more) toplet sharing the same name in the same scope are treated as one toplet.</p>
  </dd>

</dl>
<p>While A1 is related with the internal consistency of the data structure (see \*(C`insane\*(C'), the others are a choice the application can make (see \*(C`consistency\*(C').</p><p><em>Consistency</em> is not automatically provided when a map is modified by the application. It is the applications responsibility to trigger the process to consolidate the map. As that may be potentially expensive, the control remains at the application.</p><p>When an \s-1IO\s0 driver is consuming a map from a resource, say, loading from an \s-1XTM\s0 file, then that driver will ensure that the map is consolidated according to the current settings before it hands it to the application. The application is then in full control of the map as it can change, add and delete toplets and assertions. The map can become unconsolidated in this process. The method \*(C`consolidate\*(C' reinstates consistency again.</p><p>You can change these defaults by (a) providing an additional option to the constructor</p><p>   new TM (....,            consistency =&gt; [ TM-&gt;Subject_based_Merging,                             TM-&gt;Indicator_based_Merging ]);</p><p>or (b) by later using the accessor \*(C`consistency\*(C' (see below).</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MAP INTERFACE</h2>
        <div class="sectioncontent">
<h3>Constructor</h3>
<p><em></em><strong>$tm</strong><em></em> = new \s-1TM\s0 (...)</p><p>The constructor will create an empty map, or, to be more exact, it will fill the map with the taxonomy from \s-1TM::PSI\s0 which covers basic Topic Maps concepts such as <em>topic</em> or <em>associations</em>.</p><p>The constructor understands a number of key/value pair parameters: Every toplet in the map has an unique local identifier (e.g. \*(C`shoesize\*(C'). The \*(C`baseuri\*(C' parameter controls how an absolute \s-1URI\s0 is built from this identifier. This controls the consistency settings. They can be changed later with the \*(C`consistency\*(C' method.</p>
<h3>Methods</h3>

<dl class='dl-vertical'>
  <dt>
    <strong>baseuri</strong>
  </dt>
  <dd>
    <p><em></em><strong>$bu</strong><em></em> = <em></em><strong>$tm</strong><em></em>-&gt;baseuri This methods retrieves the base \s-1URI\s0 component of the map. This is a read-only method. The base \s-1URI\s0 is <strong>always</strong> defined.</p>
  </dd>
  <dt>
    <strong>consistency</strong>
  </dt>
  <dd>
    <p><em></em><strong>@merging_constraints</strong><em></em> = <em></em><strong>$tm</strong><em></em>-&gt;consistency <em></em><strong>$tm</strong><em></em>-&gt;consistency (<em></em><strong>@list_of_consistency_constants</strong><em></em>) This method provides read/write access to the consistency settings. If no parameters are provided, then the current list of consistency settings is returned. If parameters are provided, that list must consist of the constants defined under \*(L"Consistency\*(R". <strong>\s-1NOTE\s0</strong>: Changing the consistency does <strong>\s-1NOT\s0</strong> automatically trigger \*(C`consolidate\*(C'.</p>
  </dd>
  <dt>
    <strong>last_mod</strong>
  </dt>
  <dd>
    <p>Returns the Time::HiRes date of last time the map has been modified (content-wise).</p>
  </dd>
  <dt>
    <strong>consolidate</strong>
  </dt>
  <dd>
    <p><em></em><strong>$tm</strong><em></em>-&gt;consolidate <em></em><strong>$tm</strong><em></em>-&gt;consolidate (<em></em><strong>@list_of_consistency_constants</strong><em></em>) This method <em>consolidates</em> a map by performing the following actions:</p><ul>
<li><p>perform merging based on subject address (see \s-1TMDM\s0 section 5.3.2)</p></li><li><p>perform merging based on subject indicators (see \s-1TMDM\s0 section 5.3.2)</p></li><li><p>remove all superfluous toplets (those which do not take part in any assertion) <strong>\s-1NOTE\s0</strong>: Not implemented yet!</p></li>
</ul><p>This method will normally use the map's consistency settings. These settings can be overridden by adding consistency settings as parameters (see \*(L"Consistency\*(R"). In that case the map's settings are <strong>not</strong> modified, so use this carefully. <strong>\s-1NOTE\s0</strong>: In all cases the map will be modified. <strong>\s-1NOTE\s0</strong>: After merging some of the <em>lids</em> might not be reliably point to a topic.</p>
  </dd>
  <dt>
    <strong>clear</strong>
  </dt>
  <dd>
    <p><em></em><strong>$tm</strong><em></em>-&gt;clear This method removes all toplets and assertions (except the infrastructure). Everything else remains.</p>
  </dd>
  <dt>
    <strong>add</strong>
  </dt>
  <dd>
    <p><em></em><strong>$tm</strong><em></em>-&gt;add (<em></em><strong>$tm2</strong><em></em>, ...) This method accepts a list of \s-1TM\s0 objects and adds all content from these maps to the current object. <strong>\s-1NOTE\s0</strong>: There is <strong>\s-1NO\s0</strong> merging done for user-supplied toplets. Use explicitly method \*(C`consolidate\*(C' for it. Merging is done for all sacrosanct toplets, i.e. those from the infrastructure. From v1.31 onwards this method tries to favour the <em>internal</em> identifiers (LIDs) of <strong>this</strong> map over LIDs of the added maps. This means, firstly, that internal identifiers of <strong>this</strong> map are <strong>not</strong> touched (or re-generated) in any way and that any shorthands (without a baseuri prefix) will remain valid when using \*(C`tids\*(C'. Secondly, LIDs in the added map will be attempted to blend into <strong>this</strong> map by changing simply their prefix. If that newly generated \s-1LID\s0 is already taken by something in <strong>this</strong> map, then the original \s-1LID\s0 will be used. That allows many added LIDs be used together with \*(C`tids\*(C' without (much) change in code. Of course, the only reliable way to reach a topic is a subject locator or an indicator. This is all about convenience. <strong>\s-1NOTE\s0</strong>: This procedure implies that some assertions are recomputed, so that also their \s-1LID\s0 will change!</p>
  </dd>
  <dt>
    <strong>diff</strong>
  </dt>
  <dd>
    <p><em></em><strong>$diff</strong><em></em> = <em></em><strong>$new_tm</strong><em></em>-&gt;diff (<em></em><strong>$old_tm</strong><em></em>) <em></em><strong>$diff</strong><em></em> = TM::diff (<em></em><strong>$new_tm</strong><em></em>, <em></em><strong>$old_tm</strong><em></em>) <em></em><strong>$diff</strong><em></em> = TM::diff (<em></em><strong>$new_tm</strong><em></em>, <em></em><strong>$old_tm</strong><em></em>,</p>
<pre>
                     {consistency =&gt; &#92; @list_of_consistency_consts,
                      include_changes =&gt; 1})
</pre>
<p>\*(C`diff\*(C' compares two topic maps and returns their differences as a hash reference. While it works on any two maps, it is most useful after one map (the <em>old map</em>) is modified into a <em>new map</em>. If \*(C`diff\*(C' is used in OO-style, the current map is interpreted as the <em>new</em> map and the map in the arguments as <em>the old one</em>. By default, the toplet and assertion identifiers for any changes are returned; the option \*(C`include_changes\*(C' causes the return of the actual toplets and assertions themselves. This option makes \*(C`diff\*(C''s output more self-contained: enabled, one can fully (re)create the new map from the old one using the diff (or vice versa). The \*(C`consistency\*(C' option uses the same format as the \s-1TM\s0 constructor (see \*(L"Constructor\*(R") and describes how corresponding toplets in the two maps are to be identified.  Toplets with the same internal ids are always considered equal. If <em>subject based consistency</em> is active, toplets with the same <em>subject locator</em> are considered equal (overriding the topic identities).  If <em>indicator</em> based consistency is active, toplets with a matching <em>subject indicator</em> are considered equal (overriding the previous identities). <strong>\s-1NOTE\s0</strong>: This overriding of previous conditions for identity is necessary to keep the equality relationship unique and one-to-one.  As an example, consider the following scenario: a toplet <em>a</em> in the old map is split into multiple new toplets <em>a</em> and <em>b</em> in the new map. If <em>a</em> had a locator or identifier that is moved to <em>b</em> (and if consistency options were active), then the identity detector will consider <em>b</em> to be equal to <em>a</em>, and <strong>not</strong> <em>a</em> in the new map to correspond to <em>a</em> in the old map.  However, this will never lead to loss of information: <em>a</em> in the new map is flagged as completely new toplet. The differences between old and new map are returned underneath the keys <em>plus</em>, <em>minus</em>, <em>identities</em> and <em>modified</em>. If \*(C`include_changes\*(C' is on, the extra keys <em>plus_midlets</em>, <em>minus_midlets</em> and <em>assertions</em> are populated. The values of all these keys are hash references themselves.</p>
<dl class='dl-vertical'>
  <dt>
    <em>plus</em>, <em>minus</em>
  </dt>
  <dd>
    <p>The \*(C`plus\*(C' and \*(C`minus\*(C' hashes list new or removed toplets, respectively (with their identifiers as keys).  For each toplet, the value of the hash is an array of associated assertion ids. The array is empty but defined if there are no associated assertions. For toplets the attached assertions are the usual ones (names, occurrences) and class-instance relationships (attached to the instance toplet). For associations, the assertions are attached to the <em>type</em> toplet.</p>
  </dd>
  <dt>
    <em>identities</em>
  </dt>
  <dd>
    <p>This hash consists of the non-trivial toplet identities that were found. If neither Subject- nor Indicator-based merging is active and if neither map object was created with a \s-1TM\s0 version before 1.31, then this hash is empty. Otherwise, the keys are toplet identifiers in the old map, with the corresponding topic identifier in the new map as value. This includes standalone topics as well as assertions and associations that were renamed due to changed player or role identities. For diff operations between maps where one map was created with a \s-1TM\s0 version before 1.31 (which can happen with frozen/thawed or MLDBM-based maps) extra identifying steps are performed (because the identifier format for assertions and infrastructure toplets and the stored format of toplets have changed). This situation is detected automatically, and if so the identities hash will also include all map elements that were identical but have different names due to the version incompatibility.</p>
  </dd>
  <dt>
    <em>modified</em>
  </dt>
  <dd>
    <p>The <em>modified</em> hash contains the changes for matched toplets. The key is the toplet identifier in the old map (which is potentially different from the one in the new map; see the note about identities above). The value is a hash with three keys: <em>plus</em>, <em>minus</em> and <em>identities</em>.  The value for the \*(C`identities\*(C' key is defined if and only if the toplet associated with this toplet has changed (i.e. Subject Locator or Indicators have changed).  The values for the \*(C`plus\*(C' and \*(C`minus\*(C' keys are arrays with the new or removed assertions that are attached to this toplet. These arrays are defined but empty where no applicable information is present.</p>
  </dd>
  <dt>
    <em>plus_midlets</em>, <em>minus_midlets</em>
  </dt>
  <dd>
    <p>These hashes hold the actual new or removed toplets if the option \*(C`include_changes\*(C' is active. Keys are the toplet ids, values are references to the actual toplet data structures.</p>
  </dd>
  <dt>
    <em>assertions</em>
  </dt>
  <dd>
    <p>This hash holds the actual assertions where the maps differ; it exists only if the option \*(C`include_changes\*(C' is active. Keys are the assertion identifiers, values the references to the actual assertion data structure. Note that assertion ids uniquely identify the assertion contents, therefore this hash can hold assertions from both new and old map.</p>
  </dd>

</dl>

  </dd>
  <dt>
    <strong>melt</strong> (\s-1DEPRECATED\s0)
  </dt>
  <dd>
    <p><em></em><strong>$tm</strong><em></em>-&gt;melt (<em></em><strong>$tm2</strong><em></em>) This - probably more auxiliary - function copies relevant aspect of a second map into the object.</p>
  </dd>
  <dt>
    <strong>insane</strong>
  </dt>
  <dd>
    <p>warn \*(L"topic map broken\*(R" if <em></em><strong>$tm</strong><em></em>-&gt;insane This method tests invariant conditions inside the \s-1TM\s0 structure of that map. Specifically,</p><ul>
<li><p>each toplet has a \s-1LID\s0 which points to a toplet with the same address</p></li>
</ul><p>It returns a string with a message or \*(C`undef\*(C' if everything seems fine. \s-1TODO:\s0 add test whether all variant entries have a proper \s-1LID\s0 (and toplet)</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TOPLET INTERFACE</h2>
        <div class="sectioncontent">
<p><em>Toplets</em> are light-weight versions of \s-1TMDM\s0 topics. They only carry addressing information and are represented by an array (struct) with the following fields: The internal identifier. Mostly it repeats the key in the toplet hash, but also aliased identifiers may exist. It contains the <strong>subject locator</strong> (address) \s-1URI\s0, if known. Otherwise \*(C`undef\*(C'. This is a reference to a list containing <strong>subject identifiers</strong> (indicators). The list can be empty, no duplicate removal is attempted at this stage.</p><p>You can create this structure manually, but mostly you would leave it to \*(C`internalize\*(C' to do the work.</p><p>Example:</p><p>   # dogmatic way to produce it    my $to = Toplet-&gt;new (lid   =&gt; $baseuri . &apos;my-lovely-cat&apos;,                          saddr =&gt; &apos;http://subject-address.com/&apos;,                          sinds =&gt; []);</p><p>   # also good and well    my $to = [ $baseuri . &apos;my-lovely-cat&apos;,               &apos;http://subject-address.com/&apos;,                [] ];</p><p>   # better    my $to = $tm-&gt;internalize (&apos;my-lovely-cat&apos; =&gt; &apos;http://subject-address.com/&apos;);</p><p>To access the individual fields, you can either use the struct accessors \*(C`saddr\*(C' and \*(C`sinds\*(C', or use the constants defined above for indices into the array:</p><p>Example:</p><p>   warn "indicators: ", join (", ", @{$to-&gt;sinds});</p><p>   warn "locator:    ", $to-&gt;[TM-&gt;ADDRESS];</p><h3>Methods</h3>

<dl class='dl-vertical'>
  <dt>
    <strong>internalize</strong>
  </dt>
  <dd>
    <p><em></em><strong>$iid</strong><em></em>  = <em></em><strong>$tm</strong><em></em>-&gt;internalize (<em></em><strong>$some_id</strong><em></em>) <em></em><strong>$iid</strong><em></em>  = <em></em><strong>$tm</strong><em></em>-&gt;internalize (<em></em><strong>$some_id</strong><em></em> =&gt; <em></em><strong>$some_id</strong><em></em>) <em></em><strong>@iids</strong><em></em> = <em></em><strong>$tm</strong><em></em>-&gt;internalize (<em></em><strong>$some_id</strong><em></em> =&gt; <em></em><strong>$some_id</strong><em></em>, ...) This method does some trickery when a new toplet should be added to the map, depending on how parameters are passed into it. The general scheme is that pairs of identifiers are passed in.  The first is usually the internal identifier, the second a subject identifier or the subject locator. The convention is that subject identifier URIs are passed in as string references, whereas subject locator URIs are passed in as strings. The following cases are covered:</p><p>If the \s-1ID\s0 is already an absolute \s-1URI\s0 and contains the \*(C`baseuri\*(C' of the map as prefix, then this \s-1URI\s0 is used as internal toplet identifier. If the \s-1ID\s0 is some other \s-1URI\s0, then a toplet with that \s-1URI\s0 as subject locator is searched in the map. If such a toplet already exists, then nothing special needs to happen.  If no such toplet existed, a new \s-1URI\s0, based on the \*(C`baseuri\*(C' and a random number will be created for the internal identifier and the original \s-1URI\s0 is used as subject address. <strong>\s-1NOTE\s0</strong>: Using \*(C`URI =&gt; URI\*(C' implies that you use two different URIs as subject addresses. This will result in an error. Like above, only that the \s-1URI\s0 is directly interpreted as subject address. Like above, only that the \s-1URI\s0 is interpreted as another subject identifier. If the toplet already existed, then this subject identifier is simply added. Duplicates are suppressed (since v1.31). Like above, only that the internal identifier is auto-created if there is no toplet with the \s-1URI\s0 as subject address. Attention: If you call internalize like this   $tm-&gt;internalize(undef =&gt; $whatever) then perl will (un)helpfully replace the required undef with the string \*(L"undef\*(R" and wreck the operation. Using either a variable to hold the undef or replacing the (syntactic sugar) arrow with a comma works around this issue. Attention: If you call internalize like this   $tm-&gt;internalize(undef =&gt; $whatever) then perl will (un)helpfully replace the required undef with the string \*(L"undef\*(R" and wreck the operation. Using either a variable to hold the undef or replacing the (syntactic sugar) arrow with a comma works around this issue. Like above, only that the \s-1URI\s0 us used as subject identifier. A toplet with an auto-generated \s-1ID\s0 will be inserted.</p><p>In any case, the internal identifier(s) of all inserted (or existing) toplets are returned for convenience.</p>
  </dd>
  <dt>
    <strong>toplet</strong> (old name <strong>midlet</strong>)
  </dt>
  <dd>
    <p><em></em><strong>$t</strong><em></em>  = <em></em><strong>$tm</strong><em></em>-&gt;toplet (<em></em><strong>$mid</strong><em></em>) <em></em><strong>@ts</strong><em></em> = <em></em><strong>$tm</strong><em></em>-&gt;toplet (<em></em><strong>$mid</strong><em></em>, ....) This function returns a reference to a toplet structure. It can be used in scalar and list context.</p>
  </dd>
  <dt>
    <strong>toplets</strong> (old name <strong>midlets</strong>)
  </dt>
  <dd>
    <p><em></em><strong>@mids</strong><em></em> = <em></em><strong>$tm</strong><em></em>-&gt;toplets <em></em><strong>@mids</strong><em></em> = <em></em><strong>$tm</strong><em></em>-&gt;toplets (<em></em><strong>@list_of_ids</strong><em></em>) <em></em><strong>@mids</strong><em></em> = <em></em><strong>$tm</strong><em></em>-&gt;toplets (<em></em><strong>$selection_spec</strong><em></em>) This function returns toplet structures from the map. <strong>\s-1NOTE\s0</strong>: This has changed from v 1.13. Before you got ids. If no parameter is provided, all toplets are returned. This includes really everything also infrastructure toplets. If an explicit list is provided as parameter, then all toplets with these identifiers are returned. If a search specification is used, it has to be passed in as string reference. That string contains the selection specification using the following simple language (curly brackets mean repetition, round bracket grouping, vertical bar alternatives):     specification -&gt; { ( &apos;+&apos; | &apos;-&apos; ) group } whereby <em>group</em> is one of the following:</p><p>refers to <strong>all</strong> toplets in the map. This includes those supplied by the application. The list also includes all infrastructure topics which the software maintains for completeness. refers to all toplets the infrastructure has provided. This implies that    all - infrastructure is everything the user (application) has supplied.</p><p>Examples:      # all toplets except those from TM::PSI      $tm-&gt;toplets (&#92; &apos;+all -infrastructure&apos;) <strong>\s-1NOTE\s0</strong>: No attempt is made to make this list unique. <strong>\s-1NOTE\s0</strong>: The specifications are not commutative, but are interpreted from left-to-right. So \*(C`all -infrastructure +infrastructure\*(C' is not the same as \*(C`all +infrastructure -infrastructure\*(C'. In the latter case the infrastructure toplets have been added twice, and are then deducted completely with \*(C`-infrastructure\*(C'.</p>
  </dd>
  <dt>
    <strong>tids</strong> (old name <strong>mids</strong>)
  </dt>
  <dd>
    <p><em></em><strong>$mid</strong><em></em>  = <em></em><strong>$tm</strong><em></em>-&gt;tids (<em></em><strong>$some_id</strong><em></em>) <em></em><strong>@mids</strong><em></em> = <em></em><strong>$tm</strong><em></em>-&gt;tids (<em></em><strong>$some_id</strong><em></em>, ...) This function tries to build absolute versions of the identifiers passed in. \*(C`undef\*(C' will be returned if no such can be constructed. Can be used in scalar and list context.</p><ul>
<li><p>If the passed-in identifier is a relative \s-1URI\s0, so it is made absolute by prefixing it with the map \*(C`baseuri\*(C' and then we look for a toplet with that internal identifier.</p></li><li><p>If the passed-in identifier is an absolute \s-1URI\s0, where the \*(C`baseuri\*(C' is a prefix, then that \s-1URI\s0 will be used as internal identifier to look for a toplet.</p></li><li><p>If the passed-in identifier is an absolute \s-1URI\s0, where the \*(C`baseuri\*(C' is <strong>\s-1NOT\s0</strong> a prefix, then that \s-1URI\s0 will be used as subject locator and such a toplet will be looked for.</p></li><li><p>If the passed-in identifier is a reference to an absolute \s-1URI\s0, then that \s-1URI\s0 will be used as subject identifier and such a toplet will be looked for.</p></li>
</ul>
  </dd>
  <dt>
    <strong>externalize</strong>
  </dt>
  <dd>
    <p><em></em><strong>$tm</strong><em></em>-&gt;externalize (<em></em><strong>$some_id</strong><em></em>, ...) This function simply deletes the toplet entry for the given internal identifier(s). The function returns all deleted toplet entries. <strong>\s-1NOTE\s0</strong>: Assertions in which this topic is involved will <strong>not</strong> be removed. Use \*(C`consolidate\*(C' to clean up all assertion where non-existing toplets still exist.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ASSERTIONS INTERFACE</h2>
        <div class="sectioncontent">
<p>One assertion is a record containing its own identifier, the scope, the type of the assocation, an field whether this is an association, an occurrence or a name and then all roles and all players, both in separate lists.</p><p>Assertions consist of the following components: Every assertion has an identifier. It is a unique identifier generated from a canonicalized form of the assertion itself. This component holds the scope of the assertion. For technical reasons (read: it is faster) we distinguish between full associations (\*(C`ASSOC\*(C'), names (\*(C`NAME\*(C') and occurrences (\*(C`OCC\*(C'). The toplet id of the type of this assertion. A list reference which holds a list of toplet ids for the roles. A list reference which holds a list of toplet IDs for the players. Either 1 or \*(C`undef\*(C' to signal whether this assertion has been (already) canonicalized (see \*(L"canonicalize\*(R"). If an assertion is canonicalized, then the players and roles lists are sorted (somehow), so that assertions can be easily compared.</p><p>Obviously the lists for roles and players <strong>always</strong> have the same length, so that every player corresponds to exactly one role. If one role is played by several players, the role appears multiple times.</p><p>As a special case, names and occurrences are mapped into assertions, by</p><ul>
<li><p>setting the <em>roles</em> to \*(C`thing\*(C' and \*(C`value\*(C',</p></li><li><p>setting the <em>players</em> to the toplet id in question and using a TM::Literal as the player for \*(C`value\*(C',</p></li><li><p>using the <em>type</em> component to store the name/occurrence type,</p></li><li><p>using as <em>kind</em> either \*(C`NAME\*(C' or \*(C`OCC\*(C'</p></li>
</ul><p>Example:</p><p>   # general association    $a = Assertion-&gt;new (type =&gt; &apos;is-subclass-of&apos;,                         roles   =&gt; [ &apos;subclass&apos;, &apos;superclass&apos; ],                         players =&gt; [ &apos;rumsti&apos;,   &apos;ramsti&apos; ])</p><p>   warn $a-&gt;scope . " is the same as " . $a-&gt;[TM-&gt;SCOPE];</p><p>   # create a name    use TM::Literal;    $n = Assertion-&gt;new (kind    =&gt; TM-&gt;NAME,                         type    =&gt; &apos;name&apos;,                         scope   =&gt; &apos;us&apos;,                         roles   =&gt; [ &apos;thing&apos;, &apos;value&apos; ],                         players =&gt; [ &apos;rumsti&apos;,                                      new TM::Literal (&apos;AAA&apos;) ]);</p><p>   # create an occurrence    use TM::Literal;    $n = Assertion-&gt;new (kind    =&gt; TM-&gt;OCC,                         type    =&gt; &apos;occurrence&apos;,                         scope   =&gt; &apos;us&apos;,                         roles   =&gt; [ &apos;thing&apos;, &apos;value&apos; ],                         players =&gt; [ &apos;rumsti&apos;,                                      new TM::Literal (&apos;http://whatever/&apos;) ]);</p><h3>Special Assertions</h3>
<p>This package adopts the following conventions to store certain assertions: Associations of this type should have one role \*(C`subclass\*(C' and another \*(C`superclass\*(C'. The scope should always be \*(C`us\*(C'. Associations of this type should have one role \*(C`instance\*(C' and another \*(C`class\*(C'. The scope should always be \*(C`us\*(C'. Assertions for names should have the \*(C`KIND\*(C' component set to it and use the \*(C`TYPE\*(C' component to store the name type. The two roles to use are \*(C`value\*(C' for the value and \*(C`thing\*(C' for the toplet carrying the name. Assertions for occurrences should have the \*(C`KIND\*(C' component set to it and use the \*(C`TYPE\*(C' component to store the occurrence type. The two roles to use are \*(C`value\*(C' for the value and \*(C`thing\*(C' for the toplet carrying the name.</p>
<h3>Methods</h3>

<dl class='dl-vertical'>
  <dt>
    <strong>assert</strong>
  </dt>
  <dd>
    <p><em></em><strong>@as</strong><em></em> = <em></em><strong>$tm</strong><em></em>-&gt;assert (<em></em><strong>@list</strong><em>-of-assertions</em>) This method takes a list of assertions, canonicalizes them and then injects them into the map. If one of the newly added assertions already existed in the map, it will be ignored. In this process, all assertions will be completed (if fields are missing).</p><p>Then the assertion will be canonicalized (unless it already was). This implies that non-canonicalized assertions will be modified, in that the role/player lists change.  Any assertion not having an \s-1LID\s0 will get one. The method returns a list of all asserted assertions. Example:   my $a = Assertion-&gt;new (type =&gt; &apos;rumsti&apos;);   $tm-&gt;assert ($a); <strong>\s-1NOTE\s0</strong>: Maybe the type will default to <em>association</em> in the future.</p>
  </dd>
  <dt>
    <strong>retrieve</strong>
  </dt>
  <dd>
    <p><em></em><strong>$assertion</strong><em></em>  = <em></em><strong>$tm</strong><em></em>-&gt;retrieve (<em></em><strong>$some_assertion_id</strong><em></em>) <em></em><strong>@assertions</strong><em></em> = <em></em><strong>$tm</strong><em></em>-&gt;retrieve (<em></em><strong>$some_assertion_id</strong><em></em>, ...) This method takes a list of assertion IDs and returns the assertion(s) with the given (subject) \s-1ID\s0(s). If the assertion is not identifiable, \*(C`undef\*(C' will be returned in its place. Called in list context, it will return a list of assertion references.</p>
  </dd>
  <dt>
    <strong>asserts</strong>
  </dt>
  <dd>
    <p><em></em><strong>@assertions</strong><em></em> = <em></em><strong>$tm</strong><em></em>-&gt;asserts (<em></em><strong>$selection_spec</strong><em></em>) If a search specification is used, it has to be passed in as string reference. That string contains the selection specification using the following simple language (curly brackets mean repetition, round bracket grouping, vertical bar alternatives):     specification -&gt; { ( &apos;+&apos; | &apos;-&apos; ) group } whereby <em>group</em> is one of the following:</p><p>refers to <strong>all</strong> assertions in the map. This includes those supplied by the application, but also all predefined associations, names and occurrences. refers to all assertions which are actually associations refers to all assertions which are actually name characteristics refers to all assertions which are actually occurrences refers to all assertions the infrastructure has provided. This implies that    all - infrastructure is everything the user (application) has supplied.</p><p>Examples:      # all toplets except those from TM::PSI      $tm-&gt;asserts (&#92; &apos;+all -infrastructure&apos;)</p><p>     # like above, without assocs, so with names and occurrences      $tm-&gt;asserts (&#92; &apos;+all -associations&apos;) <strong>\s-1NOTE\s0</strong>: No attempt is made to make this list unique. <strong>\s-1NOTE\s0</strong>: The specifications are not commutative, but are interpreted from left-to-right. So \*(C`all -associations +associations\*(C' is not the same as \*(C`all +associations -associations\*(C'. \*(C`-infrastructure\*(C'.</p>
  </dd>
  <dt>
    <strong>is_asserted</strong>
  </dt>
  <dd>
    <p><em></em><strong>$bool</strong><em></em> = <em></em><strong>$tm</strong><em></em>-&gt;is_asserted (<em></em><strong>$a</strong><em></em>) This method will return 1 if the passed-in assertion exists in the store. The assertion will be canonicalized before checking, but no defaults will be added if parts are missing.</p>
  </dd>
  <dt>
    <strong>retract</strong>
  </dt>
  <dd>
    <p><em></em><strong>$tm</strong><em></em>-&gt;retract (<em></em><strong>@list_of_assertion_ids</strong><em></em>) This methods expects a list of assertion IDs and will remove the assertions from the map. If an \s-1ID\s0 is bogus, it will be ignored. <strong>\s-1NOTE\s0</strong>: Only these particular assertions will be deleted. Any toplets mentioned in these assertions will remain. Use \*(C`consolidate\*(C' to remove unnecessary toplets.</p>
  </dd>
  <dt>
    <strong>match</strong>, <strong>match_forall</strong>, <strong>match_exists</strong>
  </dt>
  <dd>
    <p><em></em><strong>@assertions</strong><em></em> = <em></em><strong>$tm</strong><em></em>-&gt;match (\s-1TM-\s0&gt;\s-1FORALL\s0 [ , <em>search-spec</em> ] ); <em></em><strong>@assertions</strong><em></em> = <em></em><strong>$tm</strong><em></em>-&gt;match (\s-1TM-\s0&gt;\s-1EXISTS\s0 [ , <em>search-spec</em> ] ); <em></em><strong>@assertions</strong><em></em> = <em></em><strong>$tm</strong><em></em>-&gt;match_forall ( [ <em>search-spec</em> ] ); <em></em><strong>@assertions</strong><em></em> = <em></em><strong>$tm</strong><em></em>-&gt;match_exists ( [ <em>search-spec</em> ] ); These methods take a search specification and return matching assertions. The result list contains references to the assertions themselves, not to copies. You can change the assertions themselves on your own risk (read: better not do it). For \*(C`match\*(C', if the constant \*(C`FORALL\*(C' is used as first parameter, this method returns a list of <strong>all</strong> assertions in the store following the search specification. If the constant \*(C`EXISTS\*(C' is used, the method will return a non-empty value if <strong>at least one</strong> can be found. Calling the more specific \*(C`match_forall\*(C' is the same as calling \*(C`match\*(C' with \*(C`FORALL\*(C'. Similar for \*(C`match_exists\*(C'. <strong>\s-1NOTE\s0</strong>: \*(C`EXISTS\*(C' is not yet implemented. For <em>search specifications</em> there are two alternatives:</p>
<dl class='dl-vertical'>
  <dt>
    Generic Search
  </dt>
  <dd>
    <p>Here the search specification is a hash with the same fields as for the constructor of an assertion: Example:    $tm-&gt;match (TM-&gt;FORALL, type    =&gt; &apos;...&apos;,                            scope   =&gt; &apos;...,                            roles   =&gt; [ ...., ....],                            players =&gt; [ ...., ....]); Any combination of assertion components can be used, all are optional, with the only constraint that the number of roles must match that for the players. All involved IDs should be absolutized before matching. If you use \*(C`undef\*(C' for a role or a player, then this is interpreted as <em>dont-care</em> (wildcard).</p>
  </dd>
  <dt>
    Specialized Search
  </dt>
  <dd>
    <p>The implementation also understands a number of specialized search specifications. These are listed in TM::Axes.</p>
  </dd>

</dl>
<p><strong>\s-1NOTE\s0</strong>: Some combinations will be very fast, while others quite slow. If you experience problems, then it might be time to think about indexing (see TM::Index). <strong>\s-1NOTE\s0</strong>: For the assertion type and the role subclassing is honored.</p>
  </dd>

</dl>

<h3>Role Retrieval</h3>

<dl class='dl-vertical'>
  <dt>
    <strong>is_player</strong>, <strong>is_x_player</strong>
  </dt>
  <dd>
    <p><em></em><strong>$bool</strong><em></em> = is_player   (<em></em><strong>$tm</strong><em></em>, <em></em><strong>$assertion</strong><em></em>, <em></em><strong>$player_id</strong><em></em>, [ <em></em><strong>$role_id</strong><em></em> ]) <em></em><strong>$bool</strong><em></em> = is_x_player (<em></em><strong>$tm</strong><em></em>, <em></em><strong>$assertion</strong><em></em>, <em></em><strong>$player_id</strong><em></em>, [ <em></em><strong>$role_id</strong><em></em> ]) This function returns 1 if the identifier specified by the \*(C`player_id\*(C' parameter plays any role in the assertion provided as \*(C`assertion\*(C' parameter. If the \*(C`role_id\*(C' is provided as third parameter then it must be exactly this role (or any subclass thereof) that is played. The 'x'-version is using equality instead of 'subclassing' ('x' for \*(L"exact\*(R").</p>
  </dd>
  <dt>
    <strong>get_players</strong>, <strong>get_x_players</strong>
  </dt>
  <dd>
    <p><em></em><strong>@player_ids</strong><em></em> = get_players   (<em></em><strong>$tm</strong><em></em>, <em></em><strong>$assertion</strong><em></em>, [ <em></em><strong>$role_id</strong><em></em> ]) <em></em><strong>@player_ids</strong><em></em> = get_x_players (<em></em><strong>$tm</strong><em></em>, <em></em><strong>$assertion</strong><em></em>, <em></em><strong>$role_id</strong><em></em>) This function returns the player(s) for the given role. If the role is not provided all players are returned. The \*(L"x\*(R" version does not honor subclassing.</p>
  </dd>
  <dt>
    <strong>is_role</strong>, <strong>is_x_role</strong>
  </dt>
  <dd>
    <p><em></em><strong>$bool</strong><em></em> = is_role   (<em></em><strong>$tm</strong><em></em>, <em></em><strong>$assertion</strong><em></em>, <em></em><strong>$role_id</strong><em></em>) <em></em><strong>$bool</strong><em></em> = is_x_role (<em></em><strong>$tm</strong><em></em>, <em></em><strong>$assertion</strong><em></em>, <em></em><strong>$role_id</strong><em></em>) This function returns 1 if the \*(C`role_id\*(C' is a role in the assertion provided. The \*(L"x\*(R" version of this function does not honor subclassing.</p>
  </dd>
  <dt>
    <strong>get_roles</strong>
  </dt>
  <dd>
    <p><em></em><strong>@role_ids</strong><em></em> = get_roles (<em></em><strong>$tm</strong><em></em>, <em></em><strong>$assertion</strong><em></em>, <em></em><strong>$player</strong><em></em>) This function returns a list of roles a particular player plays in a given assertion.</p>
  </dd>
  <dt>
    <strong>get_role_s</strong>
  </dt>
  <dd>
    <p><em></em><strong>@role_ids</strong><em></em> = @{ get_role_s (<em></em><strong>$tm</strong><em></em>, <em></em><strong>$assertion</strong><em></em>) } This function extracts a reference to the list of role identifiers.</p>
  </dd>

</dl>

<h3>Auxiliary Functions</h3>

<dl class='dl-vertical'>
  <dt>
    <strong>absolutize</strong>
  </dt>
  <dd>
    <p><em></em><strong>$assertion</strong><em></em> = absolutize (<em></em><strong>$tm</strong><em></em>, <em></em><strong>$assertion</strong><em></em>) This method takes one assertion and makes sure that all identifiers in it (for the type, the scope and all the role and players) are made absolute for the context map. It returns this very assertion. It will not touch canonicalized assertions.</p>
  </dd>
  <dt>
    <strong>canonicalize</strong>
  </dt>
  <dd>
    <p><em></em><strong>$assertion</strong><em></em> = canonicalize (<em></em><strong>$tm</strong><em></em>, <em></em><strong>$assertion</strong><em></em>) This method takes an assertion and reorders the roles (together with their respective players) in a consistent way. It also makes sure that the \s-1KIND\s0 is defined (defaults to \*(C`ASSOC\*(C'), that the type is defined (defaults to \*(C`THING\*(C') and that all references are made absolute LIDs. Finally, the field \*(C`CANON\*(C' is set to 1 to indicate that the assertion is canonicalized. The function will not do anything if the assertion is already canonicalized.  The component \*(C`CANON\*(C' is set to 1 if the assertion has been canonicalized. Conveniently, the function returns the same assertion, albeit a maybe modified one. \s-1TODO:\s0 remove map parameter, it is no longer necessary</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TAXONOMICS AND SUBSUMPTION</h2>
        <div class="sectioncontent">
<p>The following methods provide useful basic, ontological functionality around transitive subclassing between classes and instance/type relationships.</p><p><strong>\s-1NOTE\s0</strong>: Everything is a subclass of \*(C`thing\*(C' (changed in v1.35).</p><p><strong>\s-1NOTE\s0</strong>: Everything is an instance of \*(C`thing\*(C'.</p><p><strong>\s-1NOTE\s0</strong>: See \s-1TM::PSI\s0 for predefined things.</p><h3>Boolean Methods</h3>

<dl class='dl-vertical'>
  <dt>
    <strong>is_subclass</strong>
  </dt>
  <dd>
    <p><em></em><strong>$bool</strong><em></em> = <em></em><strong>$tm</strong><em></em>-&gt;is_subclass (<em></em><strong>$superclass_id</strong><em></em>, <em></em><strong>$subclass_id</strong><em></em>) This function returns 1 if the first parameter is a (transitive) superclass of the second, i.e. there is an assertion of type <em>is-subclass-of</em> in the context map. It also returns 1 if the superclass is a $TM::PSI::THING or if subclass and superclass are the same (reflexive).</p>
  </dd>
  <dt>
    <strong>is_a</strong>
  </dt>
  <dd>
    <p><em></em><strong>$bool</strong><em></em> = <em></em><strong>$tm</strong><em></em>-&gt;is_a (<em></em><strong>$something_lid</strong><em></em>, <em></em><strong>$class_lid</strong><em></em>) This method returns 1 if the thing referenced by the first parameter is an instance of the class referenced by the second. The method honors transitive subclassing.</p>
  </dd>

</dl>

<h3>List Methods</h3>

<dl class='dl-vertical'>
  <dt>
    <strong>subclasses</strong>, <strong>subclassesT</strong>
  </dt>
  <dd>
    <p><em></em><strong>@lids</strong><em></em> = <em></em><strong>$tm</strong><em></em>-&gt;subclasses  (<em></em><strong>$lid</strong><em></em>, ...) <em></em><strong>@lids</strong><em></em> = <em></em><strong>$tm</strong><em></em>-&gt;subclassesT (<em></em><strong>$lid</strong><em></em>, ...) \*(C`subclasses\*(C' returns all <strong>direct</strong> subclasses of the toplet identified by $lid. If the toplet does not exist, the list will be empty. \*(C`subclassesT\*(C' is a variant which honors the transitive subclassing (so if A is a subclass of B and B is a subclass of C, then A is also a subclass of C). Duplicates are suppressed.</p>
  </dd>
  <dt>
    <strong>superclasses</strong>, <strong>superclassesT</strong>
  </dt>
  <dd>
    <p><em></em><strong>@lids</strong><em></em> = <em></em><strong>$tm</strong><em></em>-&gt;superclasses  (<em></em><strong>$lid</strong><em></em>, ...) <em></em><strong>@lids</strong><em></em> = <em></em><strong>$tm</strong><em></em>-&gt;superclassesT (<em></em><strong>$lid</strong><em></em>, ...) The method \*(C`superclasses\*(C' returns all direct superclasses of the toplet identified by $lid. If the toplet does not exist, the list will be empty. \*(C`superclassesT\*(C' is a variant which honors transitive subclassing. Duplicates are suppressed.</p>
  </dd>
  <dt>
    <strong>types</strong>, <strong>typesT</strong>
  </dt>
  <dd>
    <p><em></em><strong>@lids</strong><em></em> = <em></em><strong>$tm</strong><em></em>-&gt;types  (<em></em><strong>$lid</strong><em></em>, ...) <em></em><strong>@lids</strong><em></em> = <em></em><strong>$tm</strong><em></em>-&gt;typesT (<em></em><strong>$lid</strong><em></em>, ...) The method \*(C`types\*(C' returns all direct classes of the toplet identified by $lid. If the toplet does not exist, the list will be empty. \*(C`typesT\*(C' is a variant which honors transitive subclassing (so if <em>a</em> is an instance of type <em>A</em> and <em>A</em> is a subclass of <em>B</em>, then <em>a</em> is also an instance of <em>B</em>). Duplicates will be suppressed.</p>
  </dd>
  <dt>
    <strong>instances</strong>, <strong>instancesT</strong>
  </dt>
  <dd>
    <p><em></em><strong>@lids</strong><em></em> = <em></em><strong>$tm</strong><em></em>-&gt;instances  (<em></em><strong>$lid</strong><em></em>, ...) <em></em><strong>@lids</strong><em></em> = <em></em><strong>$tm</strong><em></em>-&gt;instancesT (<em></em><strong>$lid</strong><em></em>, ...) These methods return the direct (\*(C`instances\*(C') and also indirect (\*(C`instancesT\*(C') instances of the toplet identified by $lid. Duplicates are suppressed.</p>
  </dd>

</dl>

<h3>Filters</h3>
<p>Quite often one needs to walk through a list of things to determine whether they are instances (or types, subtypes or supertypes) of some concept. This list of functions lets you do that: you pass in a list (reference) and the function behaves as filter, returning a list reference.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>are_instances</strong>
  </dt>
  <dd>
    <p><em></em><strong>@id</strong><em></em> = <em></em><strong>$tm</strong><em></em>-&gt;are_instances (<em></em><strong>$class_id</strong><em></em>, <em></em><strong>@list_of_ids</strong><em></em>) Returns all those ids where the topic is an instance of the class provided.</p>
  </dd>
  <dt>
    <strong>are_types</strong> (Warning: placeholder only)
  </dt>
  <dd>
    <p><em></em><strong>@ids</strong><em></em> = <em></em><strong>$tm</strong><em></em>-&gt;are_types (<em></em><strong>$instance_id</strong><em></em>, <em></em><strong>@list_of_ids</strong><em></em>) Returns all those ids where the topic is a type of the instance provided.</p>
  </dd>
  <dt>
    <strong>are_supertypes</strong> (Warning: placeholder only)
  </dt>
  <dd>
    <p><em></em><strong>@ids</strong><em></em> = <em></em><strong>$tm</strong><em></em>-&gt;are_supertypes (<em></em><strong>$class_id</strong><em></em>, <em></em><strong>@list_of_ids</strong><em></em>) Returns all those ids where the topic is a supertype of the class provided.</p>
  </dd>
  <dt>
    <strong>are_subtypes</strong> (Warning: placeholder only)
  </dt>
  <dd>
    <p><em></em><strong>@ids</strong><em></em> = <em></em><strong>$tm</strong><em></em>-&gt;are_subtypes (<em></em><strong>$class_id</strong><em></em>, <em></em><strong>@list_of_ids</strong><em></em>) Returns all those ids where the topic is a subtype of the class provided.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REIFICATION</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <strong>is_reified</strong>
  </dt>
  <dd>
    <p>(<em></em><strong>$tid</strong><em></em>) = <em></em><strong>$tm</strong><em></em>-&gt;is_reified (<em></em><strong>$assertion</strong><em></em>) (<em></em><strong>$tid</strong><em></em>) = <em></em><strong>$tm</strong><em></em>-&gt;is_reified (<em></em><strong>$url</strong><em></em>) In the case that the handed-in assertion is internally reified in the map, this method will return the internal identifier of the reifying toplet. Or \*(C`undef\*(C' if there is none. In the case that the handed-in \s-1URL\s0 is used as subject address of a toplet, this method will return the internal identifier of the reifying toplet. Or \*(C`undef\*(C' if there is none.</p>
  </dd>
  <dt>
    <strong>reifies</strong>
  </dt>
  <dd>
    <p><em></em><strong>$url</strong><em></em>       = <em></em><strong>$tm</strong><em></em>-&gt;reifies (<em></em><strong>$tid</strong><em></em>) <em></em><strong>$assertion</strong><em></em> = <em></em><strong>$tm</strong><em></em>-&gt;reifies (<em></em><strong>$tid</strong><em></em>) Given a toplet identifier, this method returns either the internally reified assertion, an externally reified object via its \s-1URL\s0, or \*(C`undef\*(C' if that toplet does not reify at all. No comment.</p>
  </dd>
  <dt>
    <strong>variants</strong>
  </dt>
  <dd>
    <p><em></em><strong>$tm</strong><em></em>-&gt;variants (<em></em><strong>$id</strong><em></em>, <em></em><strong>$variant</strong><em></em>) <em></em><strong>$tm</strong><em></em>-&gt;variants (<em></em><strong>$id</strong><em></em>) With this method you can get/set a variant tree for <strong>any</strong> topic. According to the standard only basenames (aka topic names) can have variants, but, hey, this is such an ugly beast (I am digressing). According to this data model you can have variants for <strong>all</strong> toplets/maplets. You only need their id. The structure is like this:   $VAR1 = {     &apos;tm:param1&apos; =&gt; {       &apos;variants&apos; =&gt; {         &apos;tm:param3&apos; =&gt; {           &apos;variants&apos; =&gt; undef,           &apos;value&apos; =&gt; &apos;name for param3&apos;         }       },       &apos;value&apos; =&gt; &apos;name for param1&apos;     },     &apos;tm:param2&apos; =&gt; {       &apos;variants&apos; =&gt; undef,       &apos;value&apos; =&gt; &apos;name for param2&apos;     }   }; The parameters are the keys (there can only be one, which is a useful, cough, restriction of the standard) and the data is the value. Obviously, one key value (i.e. parameter) can only exists once. Caveat: This is not very well tested (read: not tested at all).</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LOGGING</h2>
        <div class="sectioncontent">
<p>The \s-1TM\s0 module hosts (since 1.29) the Log4Perl object $TM::log. It is initialized with some reasonable defaults, but an using application can access it, tweak it, or overwrite it completely.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO TM&hellip;</h2>
        <div class="sectioncontent">
<p>\s-1TM::PSI\s0, Log::Log4perl</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT AND LICENSE</h2>
        <div class="sectioncontent">
<p>Copyright 200[1-8] by Robert Barta, &lt;drrho@cpan.org&gt;</p><p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="TAP::Harness::Archive.3pm.html"><span aria-hidden="true">&larr;</span> TAP::Harness::Archive.3pm: Create an archive of tap test results</a></li>
   <li class="next"><a href="TM::Analysis.3pm.html">TM::Analysis.3pm: Topic maps, analysis functions <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Carp::Datum: Debugging and tracing ultimate module</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Debugging and tracing ultimate module">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Carp::Datum (3pm) manual">
  <meta name="twitter:description" content="Debugging and tracing ultimate module">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcarp-datum-perl-Carp::Datum-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Carp::Datum.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Carp::Datum (3pm) manual" />
  <meta property="og:description" content="Debugging and tracing ultimate module" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcarp-datum-perl-Carp::Datum-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Carp::Datum<small> (3pm)</small></h1>
        <p class="lead">Debugging and tracing ultimate module</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Carp::Datum.3pm.html">
      <span itemprop="name">Carp::Datum: Debugging and tracing ultimate module</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcarp-datum-perl/">
      <span itemprop="name">libcarp-datum-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Carp::Datum.3pm.html">
      <span itemprop="name">Carp::Datum: Debugging and tracing ultimate module</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
 # In modules
 use Carp::Datum;

 # Programming by contract
 sub routine {
     DFEATURE my $f_, "optional message";    # $f_ is a lexical lvalue here
     my ($a, $b) = @_;
     DREQUIRE $a &gt; $b, "a &gt; b";
     $a += 1; $b += 1;
     DASSERT $a &gt; $b, "ordering a &gt; b preserved";
     my $result = $b - $a;
     DENSURE $result &lt; 0;
     return DVAL $result;
 }

 # Tracing
 DTRACE "this is a debug message";
 DTRACE TRC_NOTICE, "note: a = ", $a, " is positive";
 DTRACE {-level =&gt; TRC_NOTICE, -marker =&gt; "!!"}, "note with marker";

 # Returning
 return DVAL $scalar;     # single value
 return DARY @list;       # list of values

 # In application&apos;s main
 use Carp::Datum qw(:all on);      # turns Datum "on" or "off"

 DLOAD_CONFIG(-file =&gt; "debug.cf", -config =&gt; "config string");
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The \*(C`Carp::Datum\*(C' module brings powerful debugging and tracing features to development code: automatic flow tracing, returned value tracing, assertions, and debugging traces.  Its various functions may be customized dynamically (i.e. at run time) via a configuration language allowing selective activation on a routine, file, or object type basis.  See Carp::Datum::Cfg for configuration defails.</p><p>\*(C`Carp::Datum\*(C' traces are implemented on top of \*(C`Log::Agent\*(C' and go to its debugging channel.  This lets the application have full control of the final destination of the debugging information (logfile, syslog, etc...).</p><p>\*(C`Carp::Datum\*(C' can be globally turned on or off by the application.  It is off by default, which means no control flow tracing (routine entry and exit), and no returned value tracing.  However, assertions are still fully monitored, and the \*(C`DTRACE\*(C' calls are redirected to \*(C`Log::Agent\*(C'.</p><p>The C version of \*(C`Carp::Datum\*(C' is implemented with macros, which may be redefined to nothing to remove all assertions in the released code.  The Perl version cannot be handled that way, but comes with a \*(C`Carp::Datum::Strip\*(C' module that will <strong>lexically</strong> remove all the assertions, leaving only \*(C`DTRACE\*(C' calls.  Modules using \*(C`Carp::Datum\*(C' can make use of \*(C`Carp::Datum::MakeMaker\*(C' in their Makefile.PL to request stripping at build time.  See Carp::Datum::MakeMaker for instructions.</p><p>Here is a small example showing what traces look like, and what happens by default on assertion failure.  Since \*(C`Log::Agent\*(C' is not being customized, the debugging channel is \s-1STDERR\s0.  In real life, one would probably customize Log::Agent with a file driver, and redirect the debug channel to a file separate from both \s-1STDOUT\s0 and \s-1STDERR\s0.</p><p>First, the script, with line number:</p><p>  1 #!/usr/bin/perl   2   3 use Carp::Datum qw(:all on);   4   5 DFEATURE my $f_;   6   7 show_inv(2, 0.5, 0);   8   9 sub show_inv {  10      DFEATURE my $f_;  11      foreach (@_) {  12          print "Inverse of $_ is ", inv($_), "&#92;n";  13      }  14      return DVOID;  15 }  16  17  sub inv {  18      DFEATURE my $f_;  19      my ($x) = @_;  20      DREQUIRE $x != 0, "x=$x not null";  21      return DVAL 1 / $x;  22  }  23</p><p>What goes to \s-1STDOUT:\s0</p><p> Inverse of 2 is 0.5  Inverse of 0.5 is 2  FATAL: PANIC: pre-condition FAILED: x=0 not null ($x != 0) [./demo:20]</p><p>The debugging output on \s-1STDERR:\s0</p><p>    +-&gt; global [./demo:5]     |  +-&gt; main::show_inv(2, 0.5, 0) from global at ./demo:7 [./demo:10]     |  |  +-&gt; main::<strong>inv</strong>(2) from main::show_inv() at ./demo:12 [./demo:18]     |  |  |  Returning: (0.5) [./demo:21]     |  |  +-&lt; main::<strong>inv</strong>(2) from main::show_inv() at ./demo:12     |  |  +-&gt; main::inv(0.5) from main::show_inv() at ./demo:12 [./demo:18]     |  |  |  Returning: (2) [./demo:21]     |  |  +-&lt; main::inv(0.5) from main::show_inv() at ./demo:12     |  |  +-&gt; main::<strong>inv</strong>(0) from main::show_inv() at ./demo:12 [./demo:18]  !! |  |  |  pre-condition FAILED: x=0 not null ($x != 0) [./demo:20]  !! |  |  |  main::<strong>inv</strong>(0) called at ./demo line 12  !! |  |  |  main::show_inv(2, 0.5, 0) called at ./demo line 7  ** |  |  |  FATAL: PANIC: pre-condition FAILED: x=0 not null ($x != 0) [./demo:20]     |  |  +-&lt; main::<strong>inv</strong>(0) from main::show_inv() at ./demo:12     |  +-&lt; main::show_inv(2, 0.5, 0) from global at ./demo:7     +-&lt; global</p><p>The last three lines were manually re-ordered for this manpage: because of the pre-condition failure, Perl enters its global object destruction routine, and the destruction order of the lexicals is not right.  The $f_ in <em>show_inv()</em> is destroyed before the one in <em>inv()</em>, resulting in the inversion.  To better please the eye, it has been fixed.  And the \s-1PANIC\s0 is emitted when the pre-condition failure is detected, but it would have messed up the trace example.</p><p>Note that the stack dump is prefixed with the \*(L"!!\*(R" token, and the fatal error is tagged with \*(L"**\*(R".  This is a visual aid only, to quickly locate troubles in logfiles by catching the eye.</p><p>Routine entry and exit are tagged, returned values and parameters are shown, and the immediate caller of each routine is also traced.  The final tags \*(C`from global at ./demo:7 [./demo:10]\*(C' refer to the file name (here the script used was called \*(L"demo\*(R") and the line number where the call to the \*(C`Carp::Datum\*(C' routine is made: here the \*(C`DFEATURE\*(C' at line 10. It also indicates the caller origin: here, the call is made at line 7 of file \*(C`demo\*(C'.</p><p>The special name \*(L"global\*(R" (without trailing () marker) is used to indicate that the caller is the main script, i.e. there is no calling routine.</p><p>Returned values in <em>inv()</em> are traced as \*(L"(0.5)\*(R" and \*(L"(2)\*(R", and not as \*(L"0.5\*(R" and \*(L"2\*(R" as one would expect, because the routine was called in non-scalar context (within a print statement).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PROGRAMMING BY CONTRACT</h2>
        <div class="sectioncontent">
<h3>Introduction</h3>
<p>The Programming by Contract paradigm was introduced by Bertrand Meyer in his <em>Object Oriented Software Construction</em> book, and later implemented natively in the Eiffel language.  It is very simple, yet extremely powerful.</p><p>Each feature (routine) of a program is viewed externally as a supplier for some service.  For instance, the <em>sqrt()</em> routine computes the square root of any positive number.  The computation could be verified, but <em>sqrt()</em> probably provides an efficient algorithm for that, and it has already been written and validated.</p><p>However, <em>sqrt()</em> is only defined for positive numbers.  Giving a negative number to it is not correct.  The old way (i.e. in the old days before Programming by Contract was formalized), people implemented that restriction by testing the argument <em>x</em> of <em>sqrt()</em>, and doing so in the routine itself to factorize code.  Then, on error, <em>sqrt()</em> would return -1 for instance (which cannot be a valid square root for a real number), and the desired quantity otherwise.  The caller had then to check the returned value to determine whether an error had occurred.  Here it is easy, but in languages where no out-of-band value such as Perl's \*(C`undef\*(C' are implemented, it can be quite difficult to both report an error and return a result.</p><p>With Programming by Contract, the logic is reversed, and the code is greatly simplified:</p><ul>
<li><p>It is up to the caller to always supply a positive value to <em>sqrt()</em>, i.e. to check the value first.</p></li><li><p>In return, <em>sqrt()</em> promises to always return the square root of its argument.</p></li>
</ul><p>What are the benefits of such a gentlemen's agreement?  The code of the <em>sqrt()</em> routine is much simpler (meaning fewer bugs) because it does not have to bother with handling the case of negative arguments, since the caller promised to never call with such invalid values.  And the code of the caller is at worst as complex as before (one test to check that the argument is positive, against a check for an error code) and at best less complex: if it is known that the value is positive, it doesn't even have to be checked, for instance if it is the result of an <em>abs()</em> call.</p><p>But if <em>sqrt()</em> is called with a negative argument, and there's no explicit test in <em>sqrt()</em> to trap the case, what happens if <em>sqrt()</em> is given a negative value, despite a promise never to do so?  Well, it's a bug, and it's a bug in the caller, not in the <em>sqrt()</em> routine.</p><p>To find those bugs, one usually monitors the assertions (pre- and post-conditions, plus any other assertion in the code, which is both a post-condition for the code above and a pre-condition for the code below, at the same time) during testing.  When the product is released, assertions are no longer checked.</p>
<h3>Formalism</h3>
<p>Each routine is equipped with a set of pre-conditions and post-conditions. A routine <em>r</em> is therefore defined as:</p><p>  r(x)     pre-condition     body     post-condition</p><p>The pre- and post-conditions are expressions involving the parameters of r(), here only <em>x</em>, and, for the post-condition, the returned value of r() as well. Conditions satisfying this property are made visible to the clients, and become the routine's <em>contract</em>, which can be written as:</p><ul>
<li><p>You, the caller, promise to always call me with my pre-condition satisfied. Failure to do so will be a bug in your code.</p></li><li><p>I promise you, the caller, that my implementation will then perform correctly and that my post-condition will be satisfied.  Failure to do so will be a bug in my code.</p></li>
</ul><p>In object-oriented programming, pre- and post-conditions can also use internal attributes of the object, but then become debugging checks that everything happens correctly (in the proper state, the proper order, etc...) and cannot be part of the contract (for external users of the class) since clients cannot check that the pre-condition is true, because it will not have access to the internal attributes.</p><p>Furthermore, in object-oriented programming, a redefined feature must <em>weaken</em> the pre-condition of its parent feature and <em>strengthen</em> its post-condition. It can also keep them as-is.  To fully understand why, it's best to read Meyer.  Intuitively, it's easy to understand why the pre-condition cannot be strengthened, nor why the post-condition cannot be weakened: because of dynamic binding, a caller of r() only has the static type of the object, not its dynamic type.  Therefore, it cannot know in advance which of the routines will be called amongst the inheritance tree.</p>
<h3>Common Pitfalls</h3>
<ul>
<li><p>Do not write both a pre-condition and a test with the same expression.</p></li><li><p>Never write a pre-condition when trying to validate user input!</p></li><li><p>Never write a test on an argument when failure means an error, use a pre-condition. If a pre-condition is so important that it needs to always be monitored, even within the released product, then \*(C`Carp::Datum\*(C' provides \*(C`VERIFY\*(C', a pre-condition that will always be checked (i.e. never stripped by \*(C`Carp::Datum::Strip\*(C').  It can be used to protect the external interface of a module against abuse.</p></li>
</ul>
<h3>Implementation</h3>
<p>With Carp::Datum, pre-conditions can be given using \*(C`DREQUIRE\*(C' or \*(C`VERIFY\*(C'. Assertions are written with \*(C`DASSERT\*(C' and post-conditions given by \*(C`DENSURE\*(C'.</p><p>Although all assertions could be expressed with only \*(C`DASSERT\*(C', stating whether it's a pre-condition with \*(C`DREQUIRE\*(C' also has a commentary value for the reader.  Moreover, one day, there might be an automatic tool to extract the pre- and post-conditions of all the routines for documentation purposes, and if all assertions are called \*(C`DASSERT\*(C', the tool will have a hard time figuring out which is what.</p><p>Moreover, remember that a pre-condition failure <em>always</em> means a bug in the caller, whilst other assertion failures means a bug near the place of failure. If only for that, it's worth making the distinction.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INTERFACE</h2>
        <div class="sectioncontent">
<h3>Control Flow</h3>
<p>This statement marks the very top of any routine.  Do not omit the \*(C`my\*(C' which is very important to ensure that what is going to be stored in the lexically scoped $f_ variable will be destroyed when the routine ends. Any name can be used for that lexical, but $f_ is recommended because it is both unlikely to conflict with any real variable and short. The <em>optional comment</em> part will be printed in the logs at routine entry time, and can be used to flag object constructors, for instance, for easier grep'ing in the logs afterwards.</p>
<dl class='dl-vertical'>
  <dt>
    return \s-1DVOID\s0
  </dt>
  <dd>
    <p>This can be used in place of an ordinary \*(C`return\*(C' from a routine. It allows tracing of the return statement.</p>
  </dd>
  <dt>
    return \s-1DVAL\s0 <em>scalar</em>
  </dt>
  <dd>
    <p>Use this form when returning something in scalar context.  Do not put any parentheses around <em>scalar</em>, or it will be incorrectly stripped by \*(C`Carp::Datum::Strip\*(C'.  Examples:     return DVAL 5;                      # OK     return DVAL ($a == 1) ? 2 : 4;      # WRONG (has parenthesis)     return DVAL (1, 2, 4);              # WRONG (and will return 4)</p><p>    my $x = ($a == 1) ? 2 : 4;     return DVAL $x;                     # OK</p><p>    return DVAL &foo();                 # Will be traced as array context Using \s-1DVAL\s0 allows tracing of the returned value.</p>
  </dd>
  <dt>
    return \s-1DARY\s0 (<em>list</em>)
  </dt>
  <dd>
    <p>Use this form when returning something in list context. Using \s-1DARY\s0 allows tracing of the returned values.     return DARY @x; If a routine returns something different depending on its calling context, then write:     return DARY @x if wantarray;     return DVAL $x; Be very careful with that, otherwise the program will behave differently when the \*(C`DARY\*(C' and \*(C`DVAL\*(C' tokens are stripped by \*(C`Carp::Datum::Strip\*(C', thereby raising subtle bugs.</p>
  </dd>

</dl>

<h3>Programming by Contract</h3>
<p>Specify a pre-condition <em>expr</em>, along with a <em>tag</em> that will be printed whenever the pre-condition fails, i.e. when <em>expr</em> evaluates to false. The <em>tag</em> string may be used to dump faulty values, for instance:     DREQUIRE $x &gt; 0, "x = $x positive"; The <em>tag</em> is optional and may be left off. This is really the same as \*(C`DREQUIRE\*(C', except that it will not be stripped by \*(C`Carp::Datum::Strip\*(C' and that it will always be monitored and cause a fatal error, whatever dynamic configuration is setup. Specify a post-condition <em>expr</em>, along with an optional <em>tag</em> that will be printed whenever the post-condition fails, i.e. when <em>expr</em> evaluates to false. Specify an assertion <em>expr</em>, and an optional <em>tag</em> printed when <em>expr</em> evaluates to false.</p>
<h3>Tracing</h3>
<p>Tracing is ensured by the \*(C`DTRACE\*(C' routine, which is never stripped.  When \*(C`Carp::Datum\*(C' is off, traces are redirected to \*(C`Log::Agent\*(C' (then channel depends on the level of the trace).</p><p>The following forms can be used, from the simpler to the more complex:</p><p>    DTRACE "the variable x+1 is ", $x + 1, " and y is $y";     DTRACE TRC_WARNING, "a warning message";     DTRACE { -level =&gt; TRC_CRITICAL, -marker =&gt; "##" }, "very critical";</p><p>The first call emits a trace at the \*(C`TRC_DEBUG\*(C' level, by default.  The second call emits a warning at the \*(C`TRC_WARNING\*(C' level, and the last call emits a \*(C`TRC_CRITICAL\*(C' message prefixed with a marker.</p><p>Markers are 2-char strings emitted in the very first columns of the debugging output, and can be used to put emphasis on specifice messages. Internally, \*(C`Carp::Datum\*(C' and \*(C`Log::Agent\*(C' use the following markers:</p><p>    !!    assertion failure and stack trace     **    critical errors, fatal if not trapped by eval {}     &gt;&gt;    a message emitted via a Log::Agent routine, not DTRACE</p><p>The table below lists the available \*(C`TRC_\*(C' levels defined by \*(C`Carp::Datum\*(C', and how they remap to \*(C`Log::Agent\*(C' routines when \*(C`Carp::Datum\*(C' is off:</p><p>     Carp::Datum     Log::Agent     -------------   -------------     TRC_EMERGENCY   logdie     TRC_ALERT       logerr     TRC_CRITICAL    logerr     TRC_ERROR       logerr     TRC_WARNING     logwarn     TRC_NOTICE      logsay     TRC_INFO        logtrc "info"     TRC_DEBUG       logtrc "debug"</p><p>If an application does not configure \*(C`Log::Agent\*(C' specifically, all the calls map nicely to perl's native routines (die, warn and print).</p>
<h3>Convenience Routines</h3>
<p>Returns true when both <em>expr1</em> and <em>expr2</em> have the same truth value, whether they are both true or both false. Returns the truth value of <em>expr1</em> implies <em>expr2</em>, which is the same as:     !expr1 || expr2 It is always true except when <em>expr1</em> is true and <em>expr2</em> is false. Warning: this is function, not a macro.  That is to say, both arguments are evaluated, and there is no short-circuit when <em>expr1</em> is false.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DEBUG CONFIGURATION</h2>
        <div class="sectioncontent">
<h3>Global Switch on/off</h3>
<p>The \*(C`Carp::Datum\*(C' module can be turned on/off. This indication must be included when the module is imported in the main program as followed:</p><p> # In application&apos;s main  use Carp::Datum qw(:all on);      # to turn on  use Carp::Datum qw(:all off);     # to turn off</p><p>When \*(C`Carp::Datum\*(C' is turned off, most of the specific functions (\s-1DFEATURE\s0, ...) continue to be invoked during the program execution but they return immediately. In details, all the tracing functions are disconnected, the contracts (\s-1DASSERT\s0, \s-1DREQUIRE\s0, \s-1DENSURE\s0) continue to be verified: assertion failure will stop the program.</p><p>That leads to a tiny perfomance loss when running production release. But, the delivered code keeps the possibility to be easily debugged. If the performance would be problematic in a production release, there is a stripper program available that can extract all the \*(C`Carp::Datum\*(C' calls from a source file. (see Carp::Datum::Strip).</p><p>To turn on/off debugging according to an environment variable, the module can be imported like the following:</p><p> # In application&apos;s main  use Carp::Datum (":all", $ENV{DATUM});</p><p> # as a preamble to the program execution  # in your favorite shell (here /bin/ksh)  export DATUM=on        # to turn on  export DATUM=off       # to turn off</p>
<h3>Dynamic Configuration</h3>
<p>The dynamic configuration is loaded when the \*(C`DLOAD_CONFIG\*(C' function is invoked in the main program. The function signature passes either a filename or directly a string (or both).</p><p> DLOAD_CONFIG(-file =&gt; "./debug.cf")  # filename   - or -  DLOAD_CONFIG(-config =&gt; &lt;&lt;EOM);      # string  routine "show_inv" {      all(yes);      flow(no);      trace(no);      return(no);  }  EOM</p><p>The syntax used in the file or the one of the config string is described in Carp::Datum::Cfg.</p><p>The dynamic setting allows to filter the debug traces when running. For instance, one can enforce a routine to be silent.</p><p>As an important note, the dynamic configuration is effective only when the global debug switch is turned on.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LIMITATIONS</h2>
        <div class="sectioncontent">
<p>It's not possible to insert tracing hooks like \*(C`DFEATURE\*(C' or \*(C`DVAL\*(C' in stringification overloading routines.  For \*(C`DFEATURE\*(C', that is because the argument list might be dumped, and printing $self will re-invoke the stringification routine recursively.  For \*(C`DVAL\*(C', this is implied by the fact that there cannot be any \*(C`DFEATURE\*(C' in the routine, hence \*(C`DVAL\*(C' cannot be used.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>Please report any bugs to the current maintainer.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">HISTORY AND CREDITS</h2>
        <div class="sectioncontent">
<p>The seed of the \*(C`Carp::Datum\*(C' module started to grow in 1996 when Raphael Manfredi and Christophe Dehaudt were involved in a tricky project involving kernel environment. It was Christophe's first experience with <em>Programming By Contract</em> principles. Raphael was already familar with the concept due to his participation in the development of the Eiffel compiler.</p><p>Written in C, the first release was based on pre-processor macros. It already distinguished the pre-conditions, post-conditions and assertions. Also included were the concepts of dynamic configuration and flow tracing. The benefit of this lonely include file was very important since the final integration was very short and, since then, there has been no major bug reported on the delivered product.</p><p>Based on this first success, they leveraged the techniques for developments in \*(C+. The debug module was upgraded with the necessary notions required for true \s-1OO\s0 programming in \*(C+.</p><p>The Perl module was produced in 2000, when Raphael and Christophe needed for Perl the same powerful support that they had initiated a few years prior. Before the first official release in spring 2001, they developed several other Perl modules and applications (mainly related to \s-1CGI\s0 programming) that were powered by \*(C`Carp::Datum\*(C'. Some of them have also been published in \s-1CPAN\s0 directory (for instance: \*(C`CGI::Mxscreen\*(C').</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p>Christophe Dehaudt and Raphael Manfredi are the original authors.</p><p>Send bug reports, hints, tips, suggestions to Dave Hoover at &lt;squirrel@cpan.org&gt;.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Carp::Datum&hellip;</h2>
        <div class="sectioncontent">
<p><em>Carp::Datum::Cfg</em>\|(3), <em>Carp::Datum::MakeMaker</em>\|(3), <em>Carp::Datum::Strip</em>\|(3), <em>Log::Agent</em>\|(3).</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Carp::Clan::Share.3pm.html"><span aria-hidden="true">&larr;</span> Carp::Clan::Share.3pm: Share your carp::clan settings with your whole clan</a></li>
   <li class="next"><a href="Carp::Datum::Assert.3pm.html">Carp::Datum::Assert.3pm: Assertion expression extractor <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

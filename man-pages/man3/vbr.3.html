<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>vbr: Vouch by reference service facility</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Vouch by reference service facility">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="vbr (3) manual">
  <meta name="twitter:description" content="Vouch by reference service facility">
  <meta name="twitter:image" content="https://www.carta.tech/images/libvbr-dev-vbr-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/vbr.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="vbr (3) manual" />
  <meta property="og:description" content="Vouch by reference service facility" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libvbr-dev-vbr-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">vbr<small> (3)</small></h1>
        <p class="lead">Vouch by reference service facility</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/vbr.3.html">
      <span itemprop="name">vbr: Vouch by reference service facility</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libvbr-dev/">
      <span itemprop="name">libvbr-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/vbr.3.html">
      <span itemprop="name">vbr: Vouch by reference service facility</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include <em>&lt;vbr.h&gt;</em></p><p>VBR * <strong>vbr_init</strong> (void *(* <strong>mallocf</strong> )(void *, size_t), void (* <strong>freef</strong> )(void *, void *p), void * <strong>closure</strong> );</p><p>void <strong>vbr_options</strong> (VBR * <strong>vbr</strong> , unsigned int <strong>opts</strong> );</p><p>unsigned char * <strong>vbr_geterror</strong> (VBR * <strong>vbr</strong> );</p><p>VBR_STAT <strong>vbr_getheader</strong> (VBR * <strong>vbr,</strong> unsigned char * <strong>hdr,</strong> size_t <strong>len</strong> );</p><p>void <strong>vbr_setcert</strong> (VBR * <strong>vbr,</strong> unsigned char * <strong>cert</strong> );</p><p>void <strong>vbr_settype</strong> (VBR * <strong>vbr,</strong> unsigned char * <strong>cert</strong> );</p><p>void <strong>vbr_setdomain</strong> (VBR * <strong>vbr,</strong> unsigned char * <strong>cert</strong> );</p><p>void <strong>vbr_trustedcerts</strong> (VBR * <strong>vbr,</strong> unsigned char ** <strong>cert</strong> );</p><p>VBR_STAT <strong>vbr_query</strong> (VBR * <strong>vbr,</strong> unsigned char ** <strong>res,</strong> unsigned char ** <strong>cert</strong> );</p><p>VBR_STAT <strong>vbr_settimeout</strong> (VBR * <strong>vbr,</strong> unsigned int <strong>timeout</strong> );</p><p>VBR_STAT <strong>vbr_setcallbackint</strong> (VBR * <strong>vbr,</strong> unsigned int <strong>cbint</strong> );</p><p>VBR_STAT <strong>vbr_setcallbackctx</strong> (VBR *, <strong>vbr,</strong> void * <strong>ctx</strong> );</p><p>VBR_STAT <strong>vbr_setdnscallback</strong> (VBR *, <strong>vbr,</strong> void (* <strong>func</strong> )(const void *));</p><p>void * <strong>vbr_dns_set_query_service</strong> (VBR * <strong>vbr,</strong> void * <strong>svc</strong> );</p><p>void <strong>vbr_dns_set_query_cancel</strong> (VBR * <strong>vbr,</strong> int (* <strong>func</strong> )(void *, void *));</p><p>void <strong>vbr_dns_set_query_start</strong> (VBR * <strong>vbr,</strong> int (* <strong>func</strong> )(void *, int, unsigned char *, unsigned char *, size_t, void **));</p><p>void <strong>vbr_dns_set_query_waitreply</strong> (VBR * <strong>vbr,</strong> int (* <strong>func</strong> )(void *, void *, struct timeval *, size_t *, int *, int *));</p><p>void <strong>vbr_dns_set_init</strong> (VBR * <strong>vbr,</strong> int (* <strong>func</strong> )(void **);</p><p>void <strong>vbr_dns_set_close</strong> (VBR * <strong>vbr,</strong> int (* <strong>func</strong> )(void *);</p><p>void <strong>vbr_dns_set_config</strong> (VBR * <strong>vbr,</strong> int (* <strong>func</strong> )(void *, const char *);</p><p>void <strong>vbr_dns_set_nslist</strong> (VBR * <strong>vbr,</strong> int (* <strong>func</strong> )(void *, const char *);</p><p>void <strong>vbr_dns_set_trustanchor</strong> (VBR * <strong>vbr,</strong> int (* <strong>func</strong> )(void *, const char *);</p><p>VBR_STAT <strong>vbr_dns_init</strong> (VBR * <strong>vbr</strong> );</p><p>void <strong>vbr_close</strong> (VBR *);</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>These functions are an interface to a facility to conduct Vouch By Reference (VBR) queries and return their results.  VBR is defined in RFC5518.</p><p>An application first initializes the package by calling <strong>vbr_init().</strong> The optional <em>mallocf</em> parameter is a caller-provided memory allocation function taking a pointer to a caller-provided opaque data structure (the <em>closure</em> parameter) and a number of bytes to allocate.  If <em>mallocf</em> is not provided, the default system memory allocator function <a href="../man3/malloc.3.html"><strong>malloc</strong>(3)</a></strong> is used.  The optional <em>freef</em> parameter specifies a matching caller-provided memory deallocator function, taking a pointer to a caller-provided opaque data structure (the <em>closure</em> parameter) and a pointer to the memory to be released.  If <em>freef</em> is not provided, the default system memory release function <a href="../man3/free.3.html"><strong>free</strong>(3)</a></strong> is used.  A handle for future use of the initialized library instance is returned, or NULL on error and <em>errno</em> will be set to indicate the cause of the failure.</p><p>The caller can use <strong>vbr_options()</strong> to set query processing options.  See the OPTIONS section for details.</p><p>The <strong>vbr_geterror()</strong> function can be used to poll the library for an error string that provides further description for the most recent failed operation.</p><p>Calling <strong>vbr_getheader()</strong> can be used to generate an RFC-compliant VBR-Info: haeder field based on data provided by other accessor functions, namely <em>vbr_setcert(),</em> <em>vbr_settype()</em> and <em>vbr_setdomain()</em> (below).  A library instance is provided as the first parameter, and a pointer to the destination buffer and its length are provided in the second and third. Note that only the value of the header field is stored into the buffer, not its name; the standard name of the header field is available as the VBR_INFOHEADER macro.</p><p><strong>vbr_setcert()</strong> takes a VBR library instance as its first argument and a colon-separated list of claimed vouching domains as its second. Similarly, <strong>vbr_settype()</strong> sets the message type, and <strong>vbr_setdomain()</strong> sets the sending domain.  These correspond, respectively, to the "mv", "mc" and "md" values from a received message's VBR-Info header field.  These values are used by the library instance when calling <em>vbr_getheader()</em> to generate VBR information header fields to attach to outgoing messages or when calling <em>vbr_query()</em> to check for a vouching reference.  Note that the library does no validation of the possible values of the message type (to allow for new message types that may appear outside of the original RFC), and has no context to validate the domain.</p><p><strong>vbr_trustedcerts()</strong> takes a VBR library instance as its first argument and a NULL-terminated array of pointers to certifier names as its second, which is used by <em>vbr_query()</em> to select vouching services the caller trusts.  The intersection of these trusted certifiers and those claimed by an arriving message.  The list is initially empty.</p><p><strong>vbr_query()</strong> polls trusted certifiers to see if any of them agree with the assertion made by the message sender.  The pointer <strong>res</strong> will be set to point to a result string after the query has been resolved.  The result will be "pass" if any trusted certifier concurred with the assertion made by the sender.  If <strong>cert</strong> is not NULL, it will be updated to point to the name of the trusted certifier that concurred with the sender's assertion when a "pass" result is returned. If any queries were made but none of them resulted in concurrence, a result of "fail" is returned.  If no query was made because of errors or because the trusted certifier set and the sender's certifier set included no vouchers in common, <strong>cert</strong> will be unchanged.</p><p>The <strong>vbr_settimeout()</strong> function can be used to change the query timeout.  The default is ten seconds. Note that this timeout is applied for each voucher query, so a call to <em>vbr_query()</em> can take longer than this if multiple queries need to be made.</p><p>If it is useful to have the library periodically call a user-provided function as an indication that queries are still in progress, such a function can be registered with the <strong>vbr_setdnscallback()</strong> function.  The function provided should take a void context pointer as its sole argument. <strong>vbr_setcallbackctx()</strong> is used to tell the library what context pointer should be used, and <strong>vbr_setcallbackint()</strong> is used to tell the library what frequency, in seconds, should be used to call that callback function.  Each of these takes the corresponding VBR library handle as its first argument, and the obvious parameter for its second.</p><p>By default, the library will use the stock system resolver to conduct DNS queries.  If alternates should be used, these can be specified using the following functions:</p><p><strong>vbr_dns_set_query_service()</strong> sets a context pointer to the query service to be used, if any.  This will be passed as-is to the other DNS functions.  It returns its previous value.</p><p><strong>vbr_dns_set_query_cancel()</strong> sets a pointer to the function that should be called to cancel an open query, and should take the following parameters: a void pointer to the DNS query service to be used, and a void pointer to a query handle as previously returned by a call to <em>vbr_dns_set_query_start().</em> The function should return one of the DNS result codes described below.</p><p><strong>vbr_dns_set_query_start()</strong> sets a pointer to the function that should be called to initiate a new query, and should take the following parameters: a void pointer to the DNS query service to be used, a DNS record type (e.g. T_TXT), a pointer to a string containing the query to be started, a pointer to a buffer into which the reply should be written, the number of bytes available in that buffer, and a pointer to a void pointer that will be updated to contain a unique handle for that query once started.  The function should return one of the DNS result codes described below.</p><p><strong>vbr_dns_set_query_waitreply()</strong> sets a pointer to the function that should be called to wait for a reply to an open query, and should take the following parameters: a void pointer to the DNS query service to be used, a void pointer referencing the query of interest as previously returned by a call to <em>vbr_dns_set_query_start(),</em> a pointer to a "struct timeval" structure indicating how long the function should wait for a reply (or NULL if infinite waiting is acceptable), a pointer to a "size_t" that will be updated to contain the size of the received reply, a pointer to an integer that will contain an error code if the query fails (can be NULL if that information is not interesting to the caller), and a pointer to an integer that will contain a DNSSEC status indication (can be NULL if that information is not interesting to the caller).  The function should return one of the DNS result codes described below.</p><p><strong>vbr_dns_set_init()</strong> sets a pointer to the function that should be called when it is necessary to initialize a resolver.  The function should store a handle to the initialized resolver and return zero, or return non-zero if initialization could not be completed.</p><p><strong>vbr_dns_set_close()</strong> sets a pointer to the function that should be called when it is necessary to terminate a resolver.  The function will receive a handle referencing the resolver to be terminated, and should return zero on success or non-zero on failure.</p><p><strong>vbr_dns_set_nslist()</strong> sets a pointer to the function that should be called when it is necessary to change the set of nameservers that are to be used to resolve RBL queries. The function will receive a handle referencing the active resolver and a string containing a comma-separated list of nameservers to use.  It should return zero on success and non-zero on failure.</p><p><strong>vbr_dns_set_config()</strong> sets a pointer to the function that should be called when it is necessary to provide arbitrary configuration information to the resolver. The function will receive a handle referencing the active resolver and a string containing the configuration.  It should return zero on success and non-zero on failure.</p><p><strong>vbr_dns_set_trustanchor()</strong> sets a pointer to the function that should be called when it is necessary to provide trust anchor information (supporting DNSSEC) to the resolver. The function will receive a handle referencing the active resolver and a string containing the trust anchor data.  It should return zero on success and non-zero on failure.</p><p>Calling <strong>vbr_dns_init()</strong> forces (re-)initialization of the resolver.  This essentially causes the library to call any initialization function defined by <strong>vbr_dns_set_init().</strong></p><p>When the library handle is no longer needed, it should be passed to <strong>vbr_close().</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONS</h2>
        <div class="sectioncontent">
<p>Setting options is done using the <em>vbr_options()</em> function.  The <em>opts</em> parameter is a bitwise-OR list of the available options requested by the application.  The currently supported option:</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>VBR_FLAG_TRUSTEDONLY</em></p>
  </dt>
  <dd>
    <p>By default, a VBR query will be sent to the intersection of the trusted certifiers (provided by the <em>vbr_trustedcerts()</em> function) and the list of certifiers claimed on a message (provided by the <em>vbr_sercert()</em> function).  With this option enabled, the trusted certifiers will be checked and the provided certifiers will be ignored.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUES</h2>
        <div class="sectioncontent">
<p>The following return codes, of type VBR_STAT, can be returned:</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>VBR_STAT_OK</em></p>
  </dt>
  <dd>
    <p>successful completion</p>
  </dd>
  <dt>
    <p><em>VBR_STAT_INVALID</em></p>
  </dt>
  <dd>
    <p>operation failed because an invalid parameter was provided</p>
  </dd>
  <dt>
    <p><em>VBR_STAT_DNSERROR</em></p>
  </dt>
  <dd>
    <p>operation could not be completed because of errors requesting or receiving a DNS reply; note that this does not include a successful reply that contains a "no record found" result, which is a successful answer</p>
  </dd>
  <dt>
    <p><em>VBR_STAT_NORESOURCE</em></p>
  </dt>
  <dd>
    <p>a caller-provided buffer was too small to complete the requested operation, or a memory or file descriptor allocation failed</p>
  </dd>
  <dt>
    <p><em>VBR_STAT_NOTIMPLEMENT</em></p>
  </dt>
  <dd>
    <p>an optional library feature was not selected at compilation time</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DNS RETURN CODES</h2>
        <div class="sectioncontent">
<p>Any registered DNS functions should return one of the following result codes:</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>VBR_DNS_ERROR</em></p>
  </dt>
  <dd>
    <p>An error occurred.  The cause of the error can be retrieved using <em>vbr_geterror().</em></p>
  </dd>
  <dt>
    <p><em>VBR_DNS_SUCCESS</em></p>
  </dt>
  <dd>
    <p>The operation was successful.</p>
  </dd>
  <dt>
    <p><em>VBR_DNS_REPLY</em></p>
  </dt>
  <dd>
    <p>A reply is available (returned by the "waitreply" function).</p>
  </dd>
  <dt>
    <p><em>VBR_DNS_NOREPLY</em></p>
  </dt>
  <dd>
    <p>No reply was received by the time the query timeout was reached (returned by the "waitreply" function).</p>
  </dd>
  <dt>
    <p><em>VBR_DNS_EXPIRED</em></p>
  </dt>
  <dd>
    <p>The query expired completely (returned by the "waitreply" function).  Some resolvers set an overall timeout for the query at start time in addition to one for each single wait request; this code indicates the former timeout expired.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright (c) 2010, 2012, The Trusted Domain Project.  All rights reserved.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO vbr&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man2/intro.2.html"><strong>intro</strong>(2)</a></em></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="vbo_rendering.3.html"><span aria-hidden="true">&larr;</span> vbo_rendering.3: Vertex array and vbo rendering in coin coin 2.5 added improved support for opengl vertex array and vbo rendering. this might lead to major rendering performance improvements compared to the old rendering code. the new rendering code has been added for the soindexedfaceset, sovrmlindexedfaceset, soindexedlineset, sovrmlindexedlineset, sopointset, sofaceset and sovrmlpointset nodes.  to take advantage of the improved performance vertex array and vbo rendering yields, you'll need to organize your vertex data in a way that makes it possible to render it with opengl vertex arrays. opengl vertex array rendering does not support multiple index arrays, so all your vertex data (coordinates, normals, colors and texture coordinates) must use the same index array; or use overall binding. for the indexed nodes, this means that per_vertex_indexed and overall are the only supported bindings for materials, normals and texture coordinates. when per_vertex_indexed binding is used, the corresponding index field should by empty. this will signal the shape to use the coordindex field for indices. below is an example scene graph that will be rendered using vertex arrays:</a></li>
   <li class="next"><a href="vdprintf.3.html">vdprintf.3: Print to a file descriptor <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Scanf: Formatted input functions.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Formatted input functions.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Scanf (3o) manual">
  <meta name="twitter:description" content="Formatted input functions.">
  <meta name="twitter:image" content="https://www.carta.tech/images/ocaml-nox-Scanf-3o.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3o/Scanf.3o.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Scanf (3o) manual" />
  <meta property="og:description" content="Formatted input functions." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/ocaml-nox-Scanf-3o.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Scanf<small> (3o)</small></h1>
        <p class="lead">Formatted input functions.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3o/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3o/Scanf.3o.html">
      <span itemprop="name">Scanf: Formatted input functions.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/ocaml-nox/">
      <span itemprop="name">ocaml-nox</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3o/Scanf.3o.html">
      <span itemprop="name">Scanf: Formatted input functions.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">Module</h2>
        <div class="sectioncontent">
<p>Module   Scanf</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Documentation</h2>
        <div class="sectioncontent">
<p>Module <strong>Scanf</strong>  : <strong>sig end</strong></p><p>Formatted input functions.</p><p><strong>===</strong> <strong>Introduction</strong> <strong>===</strong></p><p><strong>===</strong> <strong>Functional input with format strings</strong> <strong>===</strong></p><p><strong>=== The module Scanf provides formatted input functions or scanners.</strong> <strong></strong> <strong>The formatted input functions can read from any kind of input, including</strong> <strong>strings, files, or anything that can return characters. The more general</strong> <strong>source of characters is named a formatted input channel (or scanning buffer) and has type Scanf.Scanning.in_channel. The more general</strong> <strong>formatted input function reads from any scanning buffer and is named</strong> <strong>bscanf.</strong> <strong></strong> <strong>Generally speaking, the formatted input functions have 3 arguments:</strong> <strong>- the first argument is a source of characters for the input,</strong> <strong>- the second argument is a format string that specifies the values to</strong> <strong>read,</strong> <strong>- the third argument is a receiver function that is applied to the</strong> <strong>values read.</strong> <strong></strong> <strong>Hence, a typical call to the formatted input function Scanf.bscanf is</strong> <strong>bscanf ic fmt f, where:</strong> <strong></strong> <strong>- ic is a source of characters (typically a formatted input channel with type Scanf.Scanning.in_channel),</strong> <strong></strong> <strong>- fmt is a format string (the same format strings as those used to print</strong> <strong>material with module Printf or Format),</strong> <strong></strong> <strong>- f is a function that has as many arguments as the number of values to</strong> <strong>read in the input.</strong> <strong>===</strong></p><p><strong>===</strong> <strong>A simple example</strong> <strong>===</strong></p><p><strong>=== As suggested above, the expression bscanf ic %d f reads a decimal</strong> <strong>integer n from the source of characters ic and returns f n.</strong> <strong></strong> <strong>For instance,</strong> <strong></strong> <strong>- if we use stdin as the source of characters (Scanf.Scanning.stdin is</strong> <strong>the predefined formatted input channel that reads from standard input),</strong> <strong></strong> <strong>- if we define the receiver f as let f x = x + 1,</strong> <strong></strong> <strong>then bscanf Scanning.stdin %d f reads an integer n from the</strong> <strong>standard input and returns f n (that is n + 1). Thus, if we</strong> <strong>evaluate bscanf stdin %d f, and then enter 41 at the</strong> <strong>keyboard, we get 42 as the final result. ===</strong></p><p><strong>===</strong> <strong>Formatted input as a functional feature</strong> <strong>===</strong></p><p><strong>=== The OCaml scanning facility is reminiscent of the corresponding C feature.</strong> <strong>However, it is also largely different, simpler, and yet more powerful:</strong> <strong>the formatted input functions are higher-order functionals and the</strong> <strong>parameter passing mechanism is just the regular function application not</strong> <strong>the variable assignment based mechanism which is typical for formatted</strong> <strong>input in imperative languages; the OCaml format strings also feature</strong> <strong>useful additions to easily define complex tokens; as expected within a</strong> <strong>functional programming language, the formatted input functions also</strong> <strong>support polymorphism, in particular arbitrary interaction with</strong> <strong>polymorphic user-defined scanners. Furthermore, the OCaml formatted input</strong> <strong>facility is fully type-checked at compile time. ===</strong></p><p><strong>===</strong> <strong>Formatted input channel</strong> <strong>===</strong></p><p><em>module Scanning :</em> <strong>sig end</strong></p><p><strong>===</strong> <strong>Type of formatted input functions</strong> <strong>===</strong></p><p><em>type</em> <strong>('a, 'b, 'c, 'd)</strong> <em>scanner</em> = <strong>('a, Scanning.in_channel, 'b, 'c, 'a -&gt; 'd, 'd) format6 -&gt; 'c</strong></p><p>The type of formatted input scanners: <strong>('a, 'b, 'c, 'd) scanner</strong> is the type of a formatted input function that reads from some formatted input channel according to some format string; more precisely, if <strong>scan</strong> is some formatted input function, then <strong>scan</strong> <strong>ic fmt f</strong> applies <strong>f</strong> to the arguments specified by the format string <strong>fmt</strong> , when <strong>scan</strong> has read those arguments from the formatted input channel <strong>ic</strong> .</p><p>For instance, the <strong>scanf</strong> function below has type <strong>('a, 'b, 'c, 'd)</strong> <strong>scanner</strong> , since it is a formatted input function that reads from <strong>Scanning.stdin</strong> : <strong>scanf fmt f</strong> applies <strong>f</strong> to the arguments specified by <strong>fmt</strong> , reading those arguments from <strong>Pervasives.stdin</strong> as expected.</p><p>If the format <strong>fmt</strong> has some <strong>%r</strong> indications, the corresponding input functions must be provided before the receiver <strong>f</strong> argument. For instance, if <strong>read_elem</strong> is an input function for values of type <strong>t</strong> , then <strong>bscanf ic %r; read_elem f</strong> reads a value <strong>v</strong> of type <strong>t</strong> followed by a <strong>';'</strong> character, and returns <strong>f v</strong> .</p><p><strong>Since</strong> 3.10.0</p><p><em>exception Scan_failure</em> <strong>of</strong> <strong>string</strong></p><p>The exception that formatted input functions raise when the input cannot be read according to the given format.</p><p><strong>===</strong> <strong>The general formatted input function</strong> <strong>===</strong></p><p><em>val bscanf</em> : <strong>Scanning.in_channel -&gt; ('a, 'b, 'c, 'd) scanner</strong></p><p><strong>bscanf ic fmt r1 ... rN f</strong> reads arguments for the function <strong>f</strong> , from the formatted input channel <strong>ic</strong> , according to the format string <strong>fmt</strong> , and applies <strong>f</strong> to these values. The result of this call to <strong>f</strong> is returned as the result of the entire <strong>bscanf</strong> call. For instance, if <strong>f</strong> is the function <strong>fun s i -&gt; i + 1</strong> , then <strong>Scanf.sscanf x=  1 %s = %i f</strong> returns <strong>2</strong> .</p><p>Arguments <strong>r1</strong> to <strong>rN</strong> are user-defined input functions that read the argument corresponding to the <strong>%r</strong> conversions specified in the format string.</p><p><strong>===</strong> <strong>Format string description</strong> <strong>===</strong></p><p><strong>=== The format string is a character string which contains three types of</strong> <strong>objects:</strong> <strong>- plain characters, which are simply matched with the characters of the</strong> <strong>input (with a special case for space and line feed, see Scanf.space),</strong> <strong>- conversion specifications, each of which causes reading and conversion of</strong> <strong>one argument for the function f (see Scanf.conversion),</strong> <strong>- scanning indications to specify boundaries of tokens</strong> <strong>(see scanning Scanf.indication).</strong> <strong>===</strong></p><p><strong>===</strong> <strong>The space character in format strings</strong> <strong>===</strong></p><p><strong>=== As mentioned above, a plain character in the format string is just</strong> <strong>matched with the next character of the input; however, two characters are</strong> <strong>special exceptions to this rule: the space character (' ' or ASCII code</strong> <strong>32) and the line feed character ('\(rsn' or ASCII code 10).</strong> <strong>A space does not match a single space character, but any amount of</strong> <strong>'whitespace' in the input. More precisely, a space inside the format</strong> <strong>string matches any number of tab, space, line feed and carriage</strong> <strong>return characters. Similarly, a line feed character in the format string</strong> <strong>matches either a single line feed or a carriage return followed by a line</strong> <strong>feed.</strong> <strong></strong> <strong>Matching any amount of whitespace, a space in the format string</strong> <strong>also matches no amount of whitespace at all; hence, the call bscanf ib</strong> <strong>Price = %d $ (fun p -&gt; p) succeeds and returns 1 when reading an</strong> <strong>input with various whitespace in it, such as Price = 1 $,</strong> <strong>Price = 1 $, or even Price=1$. ===</strong></p><p><strong>===</strong> <strong>Conversion specifications in format strings</strong> <strong>===</strong></p><p><strong>=== Conversion specifications consist in the % character, followed by</strong> <strong>an optional flag, an optional field width, and followed by one or</strong> <strong>two conversion characters. The conversion characters and their</strong> <strong>meanings are:</strong> <strong></strong> <strong>- d: reads an optionally signed decimal integer.</strong> <strong>- i: reads an optionally signed integer</strong> <strong>(usual input conventions for decimal (0-9+), hexadecimal</strong> <strong>(0x[0-9a-f]+ and 0X[0-9A-F]+), octal (0o[0-7]+), and binary</strong> <strong>(0b[0-1]+) notations are understood).</strong> <strong>- u: reads an unsigned decimal integer.</strong> <strong>- x or X: reads an unsigned hexadecimal integer ([0-9a-fA-F]+).</strong> <strong>- o: reads an unsigned octal integer ([0-7]+).</strong> <strong>- s: reads a string argument that spreads as much as possible, until the</strong> <strong>following bounding condition holds:</strong> <strong>- a whitespace has been found (see Scanf.space),</strong> <strong>- a scanning indication (see scanning Scanf.indication) has been</strong> <strong>encountered,</strong> <strong>- the end-of-input has been reached.</strong> <strong></strong> <strong>Hence, this conversion always succeeds: it returns an empty</strong> <strong>string if the bounding condition holds when the scan begins.</strong> <strong>- S: reads a delimited string argument (delimiters and special</strong> <strong>escaped characters follow the lexical conventions of OCaml).</strong> <strong>- c: reads a single character. To test the current input character</strong> <strong>without reading it, specify a null field width, i.e. use</strong> <strong>specification %0c. Raise Invalid_argument, if the field width</strong> <strong>specification is greater than 1.</strong> <strong>- C: reads a single delimited character (delimiters and special</strong> <strong>escaped characters follow the lexical conventions of OCaml).</strong> <strong>- f, e, E, g, G: reads an optionally signed</strong> <strong>floating-point number in decimal notation, in the style dddd.ddd</strong> <strong>e/E+-dd.</strong> <strong>- F: reads a floating point number according to the lexical</strong> <strong>conventions of OCaml (hence the decimal point is mandatory if the</strong> <strong>exponent part is not mentioned).</strong> <strong>- B: reads a boolean argument (true or false).</strong> <strong>- b: reads a boolean argument (for backward compatibility; do not use</strong> <strong>in new programs).</strong> <strong>- ld, li, lu, lx, lX, lo: reads an int32 argument to</strong> <strong>the format specified by the second letter for regular integers.</strong> <strong>- nd, ni, nu, nx, nX, no: reads a nativeint argument to</strong> <strong>the format specified by the second letter for regular integers.</strong> <strong>- Ld, Li, Lu, Lx, LX, Lo: reads an int64 argument to</strong> <strong>the format specified by the second letter for regular integers.</strong> <strong>- [ range ]: reads characters that matches one of the characters</strong> <strong>mentioned in the range of characters range (or not mentioned in</strong> <strong>it, if the range starts with ^). Reads a string that can be</strong> <strong>empty, if the next input character does not match the range. The set of</strong> <strong>characters from c1 to c2 (inclusively) is denoted by c1-c2.</strong> <strong>Hence, %[0-9] returns a string representing a decimal number</strong> <strong>or an empty string if no decimal digit is found; similarly,</strong> <strong>%[\(rs\(rs048-\(rs\(rs057\(rs\(rs065-\(rs\(rs070] returns a string of hexadecimal digits.</strong> <strong>If a closing bracket appears in a range, it must occur as the</strong> <strong>first character of the range (or just after the ^ in case of</strong> <strong>range negation); hence []] matches a ] character and</strong> <strong>[^]] matches any character that is not ].</strong> <strong>Use %% and %@ to include a % or a @ in a range.</strong> <strong>- r: user-defined reader. Takes the next ri formatted input</strong> <strong>function and applies it to the scanning buffer ib to read the</strong> <strong>next argument. The input function ri must therefore have type</strong> <strong>Scanning.in_channel -&gt; 'a and the argument read has type 'a.</strong> <strong>- { fmt %}: reads a format string argument. The format string</strong> <strong>read must have the same type as the format string specification</strong> <strong>fmt. For instance, %{ %i %} reads any format string that</strong> <strong>can read a value of type int; hence, if s is the string</strong> <strong>fmt:\(rs number is %u\(rs"", then Scanf.sscanf s fmt: %{%i%}</strong> <strong>succeeds and returns the format string number is %u .</strong> <strong>- \(rs( fmt %\(rs): scanning sub-format substitution.</strong> <strong>Reads a format string rf in the input, then goes on scanning with</strong> <strong>rf instead of scanning with fmt.</strong> <strong>The format string rf must have the same type as the format string</strong> <strong>specification fmt that it replaces.</strong> <strong>For instance, %( %i %) reads any format string that can read a value</strong> <strong>of type int.</strong> <strong>The conversion returns the format string read rf, and then a value</strong> <strong>read using rf.</strong> <strong>Hence, if s is the string \(rs %4d\(rs"1234.00", then</strong> <strong>Scanf.sscanf s %(%i%) (fun fmt i -&gt; fmt, i) evaluates to</strong> <strong>("%4d", 1234).</strong> <strong></strong> <strong>This behaviour is not mere format substitution, since the conversion</strong> <strong>returns the format string read as additional argument. If you need</strong> <strong>pure format substitution, use special flag _ to discard the</strong> <strong>extraneous argument: conversion %_\(rs( fmt %\(rs) reads a format string</strong> <strong>rf and then behaves the same as format string rf. Hence, if s is</strong> <strong>the string \(rs %4d\(rs"1234.00", then Scanf.sscanf s %_(%i%) is</strong> <strong>simply equivalent to Scanf.sscanf 1234.00 %4d .</strong> <strong></strong> <strong>- l: returns the number of lines read so far.</strong> <strong>- n: returns the number of characters read so far.</strong> <strong>- N or L: returns the number of tokens read so far.</strong> <strong>- !: matches the end of input condition.</strong> <strong>- %: matches one % character in the input.</strong> <strong>- @: matches one @ character in the input.</strong> <strong>- ,: does nothing.</strong> <strong></strong> <strong>Following the % character that introduces a conversion, there may be</strong> <strong>the special flag _: the conversion that follows occurs as usual,</strong> <strong>but the resulting value is discarded.</strong> <strong>For instance, if f is the function fun i -&gt; i + 1, and s is the</strong> <strong>string x = 1 , then Scanf.sscanf s %_s = %i f returns 2.</strong> <strong></strong> <strong>The field width is composed of an optional integer literal</strong> <strong>indicating the maximal width of the token to read.</strong> <strong>For instance, %6d reads an integer, having at most 6 decimal digits;</strong> <strong>%4f reads a float with at most 4 characters; and %8[\(rs\(rs000-\(rs\(rs255]</strong> <strong>returns the next 8 characters (or all the characters still available,</strong> <strong>if fewer than 8 characters are available in the input).</strong> <strong></strong> <strong>Notes:</strong> <strong></strong> <strong>- as mentioned above, a %s conversion always succeeds, even if there is</strong> <strong>nothing to read in the input: in this case, it simply returns  .</strong> <strong></strong> <strong>- in addition to the relevant digits, '_' characters may appear</strong> <strong>inside numbers (this is reminiscent to the usual OCaml lexical</strong> <strong>conventions). If stricter scanning is desired, use the range</strong> <strong>conversion facility instead of the number conversions.</strong> <strong></strong> <strong>- the scanf facility is not intended for heavy duty lexical</strong> <strong>analysis and parsing. If it appears not expressive enough for your</strong> <strong>needs, several alternative exists: regular expressions (module</strong> <strong>Str), stream parsers, ocamllex-generated lexers,</strong> <strong>ocamlyacc-generated parsers.</strong> <strong>===</strong></p><p><strong>===</strong> <strong>Scanning indications in format strings</strong> <strong>===</strong></p><p><strong>=== Scanning indications appear just after the string conversions %s</strong> <strong>and %[ range ] to delimit the end of the token. A scanning</strong> <strong>indication is introduced by a @ character, followed by some</strong> <strong>plain character c. It means that the string token should end</strong> <strong>just before the next matching c (which is skipped). If no c</strong> <strong>character is encountered, the string token spreads as much as</strong> <strong>possible. For instance, %s@\(rst reads a string up to the next</strong> <strong>tab character or to the end of input. If a @ character appears</strong> <strong>anywhere else in the format string, it is treated as a plain character.</strong> <strong></strong> <strong>Note:</strong> <strong></strong> <strong>- As usual in format strings, % and @ characters must be escaped</strong> <strong>using %% and %@; this rule still holds within range specifications</strong> <strong>and scanning indications.</strong> <strong>For instance, %s@%% reads a string up to the next % character.</strong> <strong>- The scanning indications introduce slight differences in the syntax of</strong> <strong>Scanf format strings, compared to those used for the Printf</strong> <strong>module. However, the scanning indications are similar to those used in</strong> <strong>the Format module; hence, when producing formatted text to be scanned</strong> <strong>by !Scanf.bscanf, it is wise to use printing functions from the</strong> <strong>Format module (or, if you need to use functions from Printf, banish</strong> <strong>or carefully double check the format strings that contain '@'</strong> <strong>characters).</strong> <strong>===</strong></p><p><strong>===</strong> <strong>Exceptions during scanning</strong> <strong>===</strong></p><p><strong>=== Scanners may raise the following exceptions when the input cannot be read</strong> <strong>according to the format string:</strong> <strong></strong> <strong>- Raise Scanf.Scan_failure if the input does not match the format.</strong> <strong></strong> <strong>- Raise Failure if a conversion to a number is not possible.</strong> <strong></strong> <strong>- Raise End_of_file if the end of input is encountered while some more</strong> <strong>characters are needed to read the current conversion specification.</strong> <strong></strong> <strong>- Raise Invalid_argument if the format string is invalid.</strong> <strong></strong> <strong>Note:</strong> <strong></strong> <strong>- as a consequence, scanning a %s conversion never raises exception</strong> <strong>End_of_file: if the end of input is reached the conversion succeeds and</strong> <strong>simply returns the characters read so far, or  if none were ever read.</strong> <strong>===</strong></p><p><strong>===</strong> <strong>Specialised formatted input functions</strong> <strong>===</strong></p><p><em>val fscanf</em> : <strong>Pervasives.in_channel -&gt; ('a, 'b, 'c, 'd) scanner</strong></p><p>Same as <strong>Scanf.bscanf</strong> , but reads from the given regular input channel.</p><p>Warning: since all formatted input functions operate from a formatted input channel, be aware that each <strong>fscanf</strong> invocation will operate with a formatted input channel reading from the given channel. This extra level of bufferization can lead to a strange scanning behaviour if you use low level primitives on the channel (reading characters, seeking the reading position, and so on).</p><p>As a consequence, never mix direct low level reading and high level scanning from the same regular input channel.</p><p><em>val sscanf</em> : <strong>string -&gt; ('a, 'b, 'c, 'd) scanner</strong></p><p>Same as <strong>Scanf.bscanf</strong> , but reads from the given string.</p><p><em>val scanf</em> : <strong>('a, 'b, 'c, 'd) scanner</strong></p><p>Same as <strong>Scanf.bscanf</strong> , but reads from the predefined formatted input channel <strong>Scanf.Scanning.stdin</strong> that is connected to <strong>Pervasives.stdin</strong> .</p><p><em>val kscanf</em> : <strong>Scanning.in_channel -&gt;</strong> <strong>(Scanning.in_channel -&gt; exn -&gt; 'd) -&gt; ('a, 'b, 'c, 'd) scanner</strong></p><p>Same as <strong>Scanf.bscanf</strong> , but takes an additional function argument <strong>ef</strong> that is called in case of error: if the scanning process or some conversion fails, the scanning function aborts and calls the error handling function <strong>ef</strong> with the formatted input channel and the exception that aborted the scanning process as arguments.</p><p><strong>===</strong> <strong>Reading format strings from input</strong> <strong>===</strong></p><p><em>val bscanf_format</em> : <strong>Scanning.in_channel -&gt;</strong> <strong>('a, 'b, 'c, 'd, 'e, 'f) format6 -&gt;</strong> <strong>(('a, 'b, 'c, 'd, 'e, 'f) format6 -&gt; 'g) -&gt; 'g</strong></p><p><strong>bscanf_format ic fmt f</strong> reads a format string token from the formatted input channel <strong>ic</strong> , according to the given format string <strong>fmt</strong> , and applies <strong>f</strong> to the resulting format string value. Raise <strong>Scan_failure</strong> if the format string value read does not have the same type as <strong>fmt</strong> .</p><p><strong>Since</strong> 3.09.0</p><p><em>val sscanf_format</em> : <strong>string -&gt;</strong> <strong>('a, 'b, 'c, 'd, 'e, 'f) format6 -&gt;</strong> <strong>(('a, 'b, 'c, 'd, 'e, 'f) format6 -&gt; 'g) -&gt; 'g</strong></p><p>Same as <strong>Scanf.bscanf_format</strong> , but reads from the given string.</p><p><strong>Since</strong> 3.09.0</p><p><em>val format_from_string</em> : <strong>string -&gt;</strong> <strong>('a, 'b, 'c, 'd, 'e, 'f) format6 -&gt; ('a, 'b, 'c, 'd, 'e, 'f) format6</strong></p><p><strong>format_from_string s fmt</strong> converts a string argument to a format string, according to the given format string <strong>fmt</strong> . Raise <strong>Scan_failure</strong> if <strong>s</strong> , considered as a format string, does not have the same type as <strong>fmt</strong> .</p><p><strong>Since</strong> 3.10.0</p><p><em>val unescaped</em> : <strong>string -&gt; string</strong></p><p>Return a copy of the argument with escape sequences, following the lexical conventions of OCaml, replaced by their corresponding special characters. If there is no escape sequence in the argument, still return a copy, contrary to String.escaped.</p><p><strong>Since</strong> 4.00.0</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Random.State.3o.html"><span aria-hidden="true">&larr;</span> Random.State.3o: No description</a></li>
   <li class="next"><a href="Scanf.Scanning.3o.html">Scanf.Scanning.3o: No description <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

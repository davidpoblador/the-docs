<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Net::Hotline::Client: Perl library for the hotline internet client</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Perl library for the hotline internet client">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Net::Hotline::Client (3pm) manual">
  <meta name="twitter:description" content="Perl library for the hotline internet client">
  <meta name="twitter:image" content="https://www.carta.tech/images/libnet-hotline-perl-Net::Hotline::Client-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Net::Hotline::Client.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Net::Hotline::Client (3pm) manual" />
  <meta property="og:description" content="Perl library for the hotline internet client" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libnet-hotline-perl-Net::Hotline::Client-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Net::Hotline::Client<small> (3pm)</small></h1>
        <p class="lead">Perl library for the hotline internet client</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Net::Hotline::Client.3pm.html">
      <span itemprop="name">Net::Hotline::Client: Perl library for the hotline internet client</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libnet-hotline-perl/">
      <span itemprop="name">libnet-hotline-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Net::Hotline::Client.3pm.html">
      <span itemprop="name">Net::Hotline::Client: Perl library for the hotline internet client</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
    use Net::Hotline::Client;

    $hlc = new Net::Hotline::Client;
    $hlc-&gt;connect("127.0.0.1")

    $hlc-&gt;chat_handler(&#92;&Chat_Handler);
    $hlc-&gt;msg_handler(&#92;&Msg_Handler);

    $hlc-&gt;login(Login    =&gt; "Steve",
                Password =&gt; "xyzzy",
                Nickname =&gt; "Jobs",
                Icon     =&gt; 128);

    $hlc-&gt;run();
    ...
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Net::Hotline::Client is a class implementing a Hotline internet client in Perl.  It was specifically developed to aid in the creation of Hotline \*(L"bots,\*(R" although it's suitable for most other tasks as well. Hotline is an internet client/server system that's sort of a cross between \s-1IRC\s0 and a \s-1BBS\s0. See http://www.hotlinesw.com/ for more information.</p><p>This document assumes you have some knowledge of the Hotline client. If not, I suggest downloading it from the \s-1URL\s0 above.  (It's shareware. Mac and \s-1PC\s0 versions are available)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CAVEATS</h2>
        <div class="sectioncontent">
<p>The Hotline protocol is not public. (An \s-1RFC\s0?  I wish!)  This module got its start with the aid of the C source code from the Unix \*(L"hx\*(R" Hotline client written by Ryan Nielsen, the beginnings of a Java Hotline bot written by Gary Wong, and many hours spent staring at hexdumps of network data. Some features are still not implemented, the most notable being user administration capabilities.  Finally, I'm sure all hell will break loose with the next major revision of Hotline.  Such is life.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">GETTING STARTED</h2>
        <div class="sectioncontent">
<p>Before delving into the nitty-gritty details, it's important to understand the philosophy behind design of this module.  If you do not read this section first, you will probably be confused by the rest of the documentation. Take the time now and save yourself headaches later.</p><p>Hotline is an event-driven protocol.  A Hotline client receives packets each time something interesting occurs on the server\*(--a new user joins, someone says something in chat, someone goes idle, etc.  The client receives these packets whether it's ready for them or not.  This type of interaction lends itself to an event-loop/callback-routine design, which is how this module was originally implemented.  Handler routines are set for the events you're interested in, and then the event loop is started.</p><p>In this model, client actions are also treated as events.  To retrieve the news, for example, the client calls a function that sends a news request to the server and returns a task \s-1ID\s0 number.  The client then returns to the event loop and watches the incoming packet stream for a packet with the same task \s-1ID\s0 (it will be either a packet containing the news or a task error packet).  In the time between when the news request was sent and the response is received from the server, many other unrelated events can (and probably will) occur.</p><p>This system works great for things like bots that want to deal with events in a non-linear fashion, but what about when you want to do things in a more deterministic manner?  For example, imagine trying to implement a command line FTP-like Hotline client using the event loop model.  Sure, it's possible, but it's not pretty!  I found this out the hard way.  What's needed are what I'm going to call \*(L"blocking tasks.\*(R"  That is, function calls that don't return until their work is done.  In this new model, the news request function would not merely return a task \s-1ID\s0 number, it would return the news itself (or an error, of course).</p><p>To accomplish this, the \*(L"blocking task\*(R" version of the news retrieval function has to do everything that you'd do in the event loop model: send a request for the news and watch the incoming packet stream for the task results.  There's no magic here.  Of course, the question of what to do with those \*(L"unrelated\*(R" packets presents itself.  They can't just be ignored because they may be telling the client something important like \*(L"you've just been disconnected.\*(R"  On the other hand, allowing them to invoke handler routines might spin us off into another section of the code indefinitely.</p><p>The solution I came up with is to let the user decide.  All unrelated events that occur during blocking tasks are subject to the bare minimum processing needed to keep the internal state of the client object consistent (tracking joining and leaving users, disconnect messages, etc.). Going further, handler routines can indeed be called.  The behavior is controlled by the client object's attributes.</p><p>These two modes of operation are called \*(L"event loop mode\*(R" and \*(L"blocking task mode\*(R" in the rest of the documentation. It's important to decide which model suits your particular needs before starting your Hotline client code. Blindly mixing and matching these techniques will get you nowhere fast. Now, on to the good stuff...</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">
<h3>\s-1CONNECTING\s0</h3>

<dl class='dl-vertical'>
  <dt>
    connect \s-1ADDRESS\s0
  </dt>
  <dd>
    <p>Opens a network connection to \s-1ADDRESS\s0, which can be an \s-1IP\s0 address or hostname optionally followed by a space or a colon and a port number. If no port is given, it defaults to 5500 (Hotline standard port) Examples:     $hlc-&gt;connect("127.0.0.1:1234");     $hlc-&gt;connect("hostname.com 5678"); Returns 1 if successful, undef otherwise.</p>
  </dd>
  <dt>
    disconnect
  </dt>
  <dd>
    <p>Closes the network connection.  Returns 1 if a connection was closed, undef if the connection wasn't open to begin with.</p>
  </dd>
  <dt>
    login \s-1PARAMETERS\s0
  </dt>
  <dd>
    <p>Logs into a Hotline server opened via \*(C`connect()\*(C', and requests the news and the userlist (unless overridden by the \*(L"NoNews\*(R" and \*(L"NoUserList\*(R" parameters).  Arguments are in a \*(L"named parameter\*(R" format, and are case-sensitive.  The parameters are:     Nickname    Your nickname (default: guest)     Login       Your account name (default: guest)     Password    Your account password (default: &lt;none&gt;)     Icon        Your icon number (default: 410, the big red "H")     NoNews      If true, do not request the news.     NoUserList  If true, do not request the userlist. Example of use:     $hlc-&gt;login(Login    =&gt; "Steve",                 Password =&gt; "xyzzy",                 Nickname =&gt; "Jobs",                 Icon     =&gt; 128,                 NoNews   =&gt; 1); If omitted, all parameters except Password will default to some sane (if not necessarily \*(L"sensible\*(R") value.  The news and userlist will be requested unless NoNews and/or NoUserList are explicitly set by the user.  Keep in mind that client functions like the tracking of connected users will not work properly without the userlist. In blocking task mode, <em>login()</em> returns 1 on success, undef if an error occurred, and \*(L"zero but true\*(R" (\*(L"0E-0\*(R") if the login was successful, but the news and/or userlist retrieval failed. In event loop mode, <em>login()</em> returns the task number if the login request was sent successfully, undef otherwise.</p>
  </dd>
  <dt>
    run
  </dt>
  <dd>
    <p>Starts the event loop.  Returns when the connection has to the server has been closed.</p>
  </dd>

</dl>

<h3>\s-1SETTINGS\s0</h3>

<dl class='dl-vertical'>
  <dt>
    blocking \s-1EXPR\s0
  </dt>
  <dd>
    <p>Turns blocking network i/o on or off depending on how \s-1EXPR\s0 evaluates (true turns blocking i/o on).  Returns the current setting.  Blocking i/o is on by default.  In this mode, the event loop will cycle each time data of any kind comes from the server.  This means that your hotline client may spend a lot of its time blocked (and therefore unable to do anything interesting) waiting for something to happen on the server.  Using non-blocking i/o will cycle through the event loop more frequently (see \*(C`event_timing()\*(C' below) regardless of server activity.</p>
  </dd>
  <dt>
    blocking_tasks \s-1EXPR\s0
  </dt>
  <dd>
    <p>With no arguments, returns the blocking task status.  With one argument, blocking tasks will be turned on or off depending on how \s-1EXPR\s0 evaluates (true means blocking task mode is active).  Blocking tasks are off by default.</p>
  </dd>
  <dt>
    clear_error
  </dt>
  <dd>
    <p>Clears the error message text available via \*(C`last_error()\*(C'. \*(C`last_error()\*(C' is not cleared by the client object, so you may need to explicitly clear it before running a blocking task to prevent it from containing an old, unrelated error message if the blocking task somehow failed without setting \*(C`last_error()\*(C'.  (This should not happen, but you never know...)</p>
  </dd>
  <dt>
    connect_timeout \s-1SECS\s0
  </dt>
  <dd>
    <p>Sets the connection timeout to \s-1SECS\s0 seconds (if present).  Returns the current connection timeout.</p>
  </dd>
  <dt>
    data_fork_extension \s-1TEXT\s0
  </dt>
  <dd>
    <p>Sets the data fork filename extension for downloads to \s-1TEXT\s0 (if present). Returns the current data fork filename extension.  The default setting is \*(L".data\*(R"</p>
  </dd>
  <dt>
    downloads_dir \s-1PATH\s0
  </dt>
  <dd>
    <p>Sets the directory where downloaded files are placed to \s-1PATH\s0 (if present). Returns the current setting.</p>
  </dd>
  <dt>
    event_timing \s-1SECS\s0
  </dt>
  <dd>
    <p>Sets the event loop timing to \s-1SECS\s0 seconds (if present).  Fractional seconds are allowed. The default setting is 1 second.  This option only has an effect when non-blocking i/o is active (see \*(C`blocking()\*(C').  Returns the current event timing setting.</p>
  </dd>
  <dt>
    handlers_during_blocking_tasks \s-1EXPR\s0
  </dt>
  <dd>
    <p>Allows handlers to run during blocking tasks if \s-1EXPR\s0 is present and evaluates to true.  Returns the current setting.  The default setting is off.</p>
  </dd>
  <dt>
    path_separator \s-1CHARACTER\s0
  </dt>
  <dd>
    <p>Sets the path separator to \s-1CHARACTER\s0 (if present).  The default setting is the Mac \s-1OS\s0 path separator \*(L":\*(R".  Returns the current value of the path separator.  Note that this is the path separator used when sending commands to the server and has no bearing on what the path separator is on the local system.  You should not need to change this, since all current Hotline servers use \*(L":\*(R" regardless of the platform they're running on.</p>
  </dd>
  <dt>
    rsrc_fork_extension \s-1TEXT\s0
  </dt>
  <dd>
    <p>Sets the resource fork filename extension for downloads to \s-1TEXT\s0 (if present). Returns the current resource fork filename extension.  The default setting is \*(L".rsrc\*(R"</p>
  </dd>
  <dt>
    tracker \s-1ADDR\s0
  </dt>
  <dd>
    <p>Sets the tracker address to \s-1ADDR\s0 (if present), where \s-1ADDR\s0 is an \s-1IP\s0 address or hostname, optionally followed by a colon and a port number.  Returns the current tracker address.</p>
  </dd>
  <dt>
    xfer_bufsize \s-1BYTES\s0
  </dt>
  <dd>
    <p>Sets the file transfer buffer size to \s-1BYTES\s0.  Returns the current buffer size.  The default is 4096 bytes.</p>
  </dd>

</dl>

<h3>\s-1COMMANDS\s0</h3>
<p>Unless otherwise specified, the methods in this section are treated as \*(L"tasks\*(R" by Hotline. Their status (start time, finish time, error state, etc.) is tracked internally by task number.  In event mode, they return a task number if the request was sent successfully, and undef or an empty list if an error occurred.  In blocking task mode, the return values vary.</p><p>Some commands (like \*(C`chat()\*(C' and \*(C`pchat()\*(C', for example) are not treated as \*(L"tasks\*(R" by Hotline. They always return 1 on success, rather than a task number.  The actual completion of a such commands can only be determined by examining the resulting data from the server.  For example, if you \*(C`chat("hello")\*(C', you can look for that line of chat in your chat handler. (This is rarely necessary since the failure of such a command usually means that you have much bigger problems.)</p>
<dl class='dl-vertical'>
  <dt>
    ban \s-1USER\s0
  </dt>
  <dd>
    
  </dd>
  <dt>
    ban \s-1SOCKET\s0
  </dt>
  <dd>
    <p>Bans the user specified by a Net::Hotline::User object or a user socket number. In blocking task mode, returns 1 on success or undef if an error occurred. In event loop mode, returns a task number if the request was sent successfully, or undef if an error occurred.</p>
  </dd>
  <dt>
    chat \s-1LIST\s0
  </dt>
  <dd>
    <p>Sends the text formed by the concatenation of \s-1LIST\s0 to the server as \*(L"chat.\*(R" Perl newlines (\*(L"&#92;n\*(R") are translated to Net::Hotline::Constants::HTLC_NEWLINE, which is Hotline's native newline character. Not treated as a task: returns 1 on success, undef or an empty list on failure.</p>
  </dd>
  <dt>
    chat_action \s-1LIST\s0
  </dt>
  <dd>
    <p>Sends the text formed by the concatenation of \s-1LIST\s0 to the server as a \*(L"chat action.\*(R"  Perl newlines (\*(L"&#92;n\*(R") are translated to Net::Hotline::Constants::HTLC_NEWLINE, which is Hotline's native newline character. Not treated as a task: returns 1 on success, undef or an empty list on failure.</p>
  </dd>
  <dt>
    comment \s-1PATH\s0, \s-1TEXT\s0
  </dt>
  <dd>
    <p>Sets the comments for the file or folder located at \s-1PATH\s0 to \s-1TEXT\s0. If \s-1TEXT\s0 is undef or an empty string, the comments for the file or folder will be removed. In blocking task mode, returns 1 on success or undef if an error occurred. In event loop mode, returns a task number if the request was sent successfully, or undef if an error occurred.</p>
  </dd>
  <dt>
    delete_file \s-1PATH\s0
  </dt>
  <dd>
    <p>Deletes the file or folder located at located at \s-1PATH\s0. In blocking task mode, returns 1 on success or undef if an error occurred. In event loop mode, returns a task number if the request was sent successfully, or undef if an error occurred.</p>
  </dd>
  <dt>
    get_file \s-1PATH\s0
  </dt>
  <dd>
    <p>Download the file on the server located at \s-1PATH\s0 to the local directory set via \*(C`downloads_dir()\*(C'.  In Mac \s-1OS\s0, file names longer than 31 characters are truncated, preserving the filename extension (i.e. \*(L".jpg\*(R") if possible. In blocking task mode, returns either an array (in array context) or a reference to an array (in scalar context) containing a Net::Hotline::Task object, a download reference number, and the size of the download on success, an undef or an empty list if an error occurred.  Those return values are meant to be fed to \*(C`recv_file()\*(C' like this (error handling omitted):         ($task, $ref, $size) = $hlc-&gt;get_file("Folder1:file.sit");</p><p>        $hlc-&gt;recv_file($task, $ref, $size); In event loop mode, returns a task number if the request was sent successfully, and undef or an empty list if an error occurred.</p>
  </dd>
  <dt>
    get_file_resume \s-1PATH\s0
  </dt>
  <dd>
    <p>Resume downloading the file on the server located at \s-1PATH\s0 to the local directory set via \*(C`downloads_dir()\*(C'.  The partially downloaded file(s) must exist in the local download directory, and (on non-Mac \s-1OS\s0 systems) must have filename extensions matching the current settings of \*(C`data_fork_extension()\*(C' and \*(C`rsrc_fork_extensions()\*(C'. In blocking task mode, returns either an array (in array context) or a reference to an array (in scalar context) containing a Net::Hotline::Task object, a download reference number, and the size of the download on success, and undef or an empty list if an error occurred.  Those return values are meant to be fed to \*(C`recv_file()\*(C' like this (error handling omitted):         ($task, $ref, $size) = $hlc-&gt;get_file_resume("Folder1:file.sit");</p><p>        $hlc-&gt;recv_file($task, $ref, $size); In event loop mode, returns a task number if the request was sent successfully, and undef or an empty list if an error occurred.</p>
  </dd>
  <dt>
    get_fileinfo \s-1PATH\s0
  </dt>
  <dd>
    <p>Returns a Net::Hotline::FileInfoItem object corresponding to the file specified by \s-1PATH\s0, or undef if an error occurred. Should only be used in blocking task mode.</p>
  </dd>
  <dt>
    get_filelist \s-1PATH\s0
  </dt>
  <dd>
    <p>Returns an array (in array context) or a reference to an array (in scalar context) of Net::Hotline::FileListItem objects corresponding to the contents of the server directory \s-1PATH\s0, and the scalar value 0 if an error occurred (in order to distinguish between an empty directory and an error: an empty directory will return an empty list in array context and undef in scalar context). Should only be used in blocking task mode.</p>
  </dd>
  <dt>
    get_news
  </dt>
  <dd>
    <p>Get the news from the server. Returns an array containing the new posts (in array context) or the news as a string (in scalar context) on success, and undef if an error occurred. Note that successful retrieval of an empty news file will return an empty string ("") or an empty list. Should only be used in blocking task mode.</p>
  </dd>
  <dt>
    get_userinfo \s-1SOCKET\s0
  </dt>
  <dd>
    <p>Returns information about the user specified by \s-1SOCKET\s0 as a string, or undef if there was an error.  Will not work unless the userlist has been retrieved from the server.  Should only be used in blocking task mode.</p>
  </dd>
  <dt>
    get_userlist
  </dt>
  <dd>
    <p>Returns a reference to a hash keyed by socket number containing Net::Hotline::User objects for all users currently logged on. Should only be used in blocking task mode.</p>
  </dd>
  <dt>
    icon \s-1ICON\s0
  </dt>
  <dd>
    <p>Sets your icon in the userlist to \s-1ICON\s0, where \s-1ICON\s0 is an icon \s-1ID\s0 number.</p>
  </dd>
  <dt>
    kick \s-1USER\s0
  </dt>
  <dd>
    
  </dd>
  <dt>
    kick \s-1SOCKET\s0
  </dt>
  <dd>
    <p>Disconnects the user specified by a Net::Hotline::User object or a user socket number. In blocking task mode, returns 1 on success or undef if an error occurred. In event loop mode, returns a task number if the request was sent successfully, or undef if an error occurred.</p>
  </dd>
  <dt>
    macbinary \s-1MACBIN_FILE\s0, \s-1DATA_FILE\s0, \s-1DATA_LEN\s0, \s-1RSRC_FILE\s0, \s-1RSRC_LEN\s0 \s-1BUF_SIZE\s0, \s-1TYPE\s0, \s-1CREATOR\s0, \s-1COMMENTS\s0, \s-1CREATED\s0, \s-1MODIFIED\s0, \s-1FINDER_FLAGS\s0
  </dt>
  <dd>
    <p>Creates a MacBinary \s-1II\s0 file at the path designated by \s-1MACBIN_FILE\s0 based on the file paths and other information supplied as arguments (see the \*(C`recv_file()\*(C' method for a description of the other arguments).  If \s-1MACBIN_FILE\s0 is undefined, it defaults to \s-1DATA_FILE\s0 with \*(L".bin\*(R" tacked onto the end.  It returns 1 on success, and undef if \s-1MACBIN_FILE\s0 already exists or can't be created, if \s-1DATA_LEN\s0 is greater than zero and \s-1DATA_FILE\s0 can't be opened, or if \s-1RSRC_LEN\s0 is greater than zero and \s-1RSRC_FILE\s0 can't be opened.  The error condition is available via both \*(C`last_error()\*(C' and $! because <em>macbinary()</em> can be called as a method or as a function.  Example:     # As a method     unless($hlc-&gt;macbinary(@args))     {       die "macbinary: ", $hlc-&gt;last_error();     }</p><p>    # As a function     unless(macbinary(@args))     {       die "macbinary: $!";     }</p>
  </dd>
  <dt>
    move \s-1SRC\s0, \s-1DEST\s0
  </dt>
  <dd>
    <p>Moves the file or folder located at the path \s-1SRC\s0 to the directory located at the path \s-1DEST\s0.  \s-1SRC\s0 should be the full path to the file or folder you want to move, and \s-1DEST\s0 should be the full path to the <strong>directory</strong> you want to move \s-1SRC\s0 too.  The file or folder name should only appear in the \s-1SRC\s0 path, never in the \s-1DEST\s0 path.  As a consequence, renaming files or folders must be done through \*(C`rename()\*(C' and cannot be rolled into a \*(C`move()\*(C' call. Here's an example of a valid call to \*(C`move()\*(C':     $hlc-&gt;move("Folder1:file1", "Folder2:"); This moves the \*(L"file1\*(R" from \*(L"Folder1\*(R" to \*(L"Folder2\*(R" In blocking task mode, returns 1 on success or undef if an error occurred. In event loop mode, returns a task number if the request was sent successfully, or undef if an error occurred.</p>
  </dd>
  <dt>
    msg \s-1USER\s0, \s-1LIST\s0
  </dt>
  <dd>
    
  </dd>
  <dt>
    msg \s-1SOCKET\s0, \s-1LIST\s0
  </dt>
  <dd>
    <p>Sends the text formed by the concatenation of \s-1LIST\s0 as a private message to the user specified by a Net::Hotline::User object or a user socket number. In blocking task mode, returns 1 on success or undef if an error occurred. In event loop mode, returns a task number if the request was sent successfully, or undef if an error occurred.</p>
  </dd>
  <dt>
    new_folder \s-1PATH\s0
  </dt>
  <dd>
    <p>Create a new folder located at \s-1PATH\s0. In blocking task mode, returns 1 on success or undef if an error occurred. In event loop mode, returns a task number if the request was sent successfully, or undef if an error occurred.</p>
  </dd>
  <dt>
    nick \s-1TEXT\s0
  </dt>
  <dd>
    <p>Sets your nickname in the userlist to \s-1TEXT\s0.</p>
  </dd>
  <dt>
    pchat \s-1REF\s0, \s-1LIST\s0
  </dt>
  <dd>
    <p>Sends the text formed by the concatenation of \s-1LIST\s0 to the private chat window specified by \s-1REF\s0.  Perl newlines (\*(L"&#92;n\*(R") are translated to Net::Hotline::Constants::HTLC_NEWLINE, which is Hotline's native newline character. Not treated as a task: returns 1 on success, undef or an empty list on failure.</p>
  </dd>
  <dt>
    pchat_action \s-1REF\s0, \s-1LIST\s0
  </dt>
  <dd>
    <p>Sends the text formed by the concatenation of \s-1LIST\s0 to the private chat window specified by \s-1REF\s0 as a \*(L"chat action\*(R".  Perl newlines (\*(L"&#92;n\*(R") are translated to Net::Hotline::Constants::HTLC_NEWLINE, which is Hotline's native newline character. Not treated as a task: returns 1 on success, undef or an empty list on failure.</p>
  </dd>
  <dt>
    pchat_accept \s-1REF\s0
  </dt>
  <dd>
    <p>Accepts an invitaton to the private chat sepcified by \s-1REF\s0. In blocking task mode, returns 1 on success.  In event loop mode, returns a task number if the request was sent successfully.  In both modes, it returns undef or an empty list if an error occurred.</p>
  </dd>
  <dt>
    pchat_decline \s-1REF\s0
  </dt>
  <dd>
    <p>Declines an invitaton to the private chat sepcified by \s-1REF\s0. Not treated as a task: returns 1 on success, undef or an empty list on failure.</p>
  </dd>
  <dt>
    pchat_invite \s-1SOCKET\s0, \s-1REF\s0
  </dt>
  <dd>
    <p>Invite the user specified by \s-1SOCKET\s0 to an existing private chat specfied by \s-1REF\s0, or create a new private chat if \s-1REF\s0 is not given.  There is no \*(C`pchat_create()\*(C' command.  To create a new private chat, you must invite someone.  Call \*(C`pchat_invite()\*(C' with your own socket number and no \s-1REF\s0 argument to create a new private chat with only yourself in it (you will not have to explicitly accept this invitation). In blocking task mode, returns 1 on success, and undef or an empty list if an error occurred. In event mode, it returns a task number if it had to create a new private chat (i.e. if no \s-1REF\s0 argument was given) or 1 (if inviting to an existing private chat) on success, and undef or an empty list if an error occurred.</p>
  </dd>
  <dt>
    pchat_leave \s-1REF\s0
  </dt>
  <dd>
    <p>Leave the private chat specified by \s-1REF\s0. Not treated as a task: returns 1 on success, undef or an empty list on failure.</p>
  </dd>
  <dt>
    pchat_subject \s-1REF\s0, \s-1TEXT\s0
  </dt>
  <dd>
    <p>Sets the subject of the private chat specified by \s-1REF\s0 to \s-1TEXT\s0. Not treated as a task: returns 1 on success, undef or an empty list on failure.</p>
  </dd>
  <dt>
    post_news \s-1LIST\s0
  </dt>
  <dd>
    <p>Sends the text formed by the concatenation of \s-1LIST\s0 to the server as a news post. In blocking task mode, returns 1 on success.  In event loop mode, returns a task number if the request was sent successfully.  In both modes, it returns undef or an empty list if an error occurred.</p>
  </dd>
  <dt>
    put_file \s-1SRC_PATH\s0, \s-1DEST_PATH\s0, \s-1COMMENT\s0
  </dt>
  <dd>
    <p>Upload the file located at \s-1SRC_PATH\s0 to the server directory \s-1DEST_PATH\s0, with the file comments \s-1COMMENT\s0.  \s-1SRC_PATH\s0 must be in the native path format of the local system (i.e. using \*(L":\*(R" as the path separator on Mac \s-1OS\s0, and \*(L"/\*(R" on most other OSes).  \s-1DEST_PATH\s0 must be in Hotline's native path format (\*(L":\*(R" as the path separator). If \s-1COMMENT\s0 is omitted, the actual Finder comments will be read from the file to be uploaded if running on Mac \s-1OS\s0. Otherwise, the comments will be blank.  \*(C`put_file()\*(C' tries to upload a new file. If you are resuming a file upload, you must call \*(C`send_file_resume()\*(C' instead. In blocking task mode, returns an array (in array context) or a reference to an array (in scalar context) containing a Net::Hotline::Task object, an upload reference number, and the size of the upload, and undef or an empty list if an error occurred.  Those return values are meant to be fed to \*(C`send_file()\*(C' like this (error handling omitted):         ($task, $ref, $size) = $hlc-&gt;put_file("/home/john/file.gz",                                               "Folder1:Folder2"                                               "A fun file!");</p><p>        $hlc-&gt;send_file($task, $ref, $size); In event loop mode, returns a task number if the request was sent successfully, and undef or an empty list if an error occurred.</p>
  </dd>
  <dt>
    put_file_resume \s-1SRC_PATH\s0, \s-1DEST_PATH\s0, \s-1COMMENT\s0
  </dt>
  <dd>
    <p>Resume uploading the file located at \s-1SRC_PATH\s0 to the server directory \s-1DEST_PATH\s0, with the file comments \s-1COMMENT\s0.  \s-1SRC_PATH\s0 must be in the native path format of the local system (i.e. using \*(L":\*(R" as the path separator on Mac \s-1OS\s0, and \*(L"/\*(R" on most other OSes).  \s-1DEST_PATH\s0 must be in Hotline's native path format (\*(L":\*(R" as the path separator). If \s-1COMMENT\s0 is omitted, the actual Finder comments will be read from the file to be uploaded if running on Mac \s-1OS\s0. Otherwise, the comments will be blank.  Use \*(C`put_file()\*(C' to upload a new file. In blocking task mode, returns an array (in array context) or a reference to an array (in scalar context) containing a Net::Hotline::Task object, an upload reference number, the size of the upload, and additional information needed to resume the upload, and undef or an empty list if an error occurred. Those return values are meant to be fed to \*(C`send_file()\*(C' like this (error handling omitted):         ($task, $ref, $size, $rflt) =           $hlc-&gt;put_file_resume("/home/john/file.gz",                                 "Folder1:Folder2"                                 "A fun file!");</p><p>        $hlc-&gt;send_file($task, $ref, $size, $rflt); In event loop mode, returns a task number if the request was sent successfully, and undef or an empty list if an error occurred.</p>
  </dd>
  <dt>
    recv_file \s-1TASK\s0, \s-1REF\s0, \s-1SIZE\s0
  </dt>
  <dd>
    <p>Starts receiving the file designated by the Net::Hotline::Task object \s-1TASK\s0, the download reference number \s-1REF\s0, and the size in bytes \s-1SIZE\s0 returned by \*(C`get_file()\*(C' (in blocking task mode) or supplied to the \*(C`get_file()\*(C' handler routine (in event loop mode).  When the download is complete, \*(C`recv_file()\*(C' returns  a reference to an array containing the following values:     DATA_FILE      Path to the file containing the data fork.     DATA_LEN       Length of the data fork.     RSRC_FILE      Path to the file containing the Mac resource fork.     RSRC_LEN       Length of the resource fork.     BUFSIZE        Buffer size that was used during the download.     TYPE           Four-letter Mac file type code.     CREATOR        Four-letter Mac file creator code.     COMMENTS       Mac Finder comments.     CREATED        Date created (in Mac time format)     MODIFIED       Date modified (in Mac time format)     FINDER_FLAGS   Mac finder flags packed in two bytes. which are typically fed to the \*(C`macbinary()\*(C' method to create a single MacBinary \s-1II\s0 file from the separate resource fork and data fork files. (On Mac \s-1OS\s0 systems, a single Mac OS-native two-forked file is created, so there's no need to call \*(C`macbinary()\*(C')  Here's an example of typical usage (error checking omitted):     # Event loop mode:     # (Inside your get_file() handler subroutine)     ...     $ret = $hlc-&gt;recv_file($task, $ref, $size);     $hlc-&gt;macbinary(undef, $ret);     ... or     # Blocking task mode:     ...     ($task, $ref, $size) = $hlc-&gt;get_file($path);     $ret = $hlc-&gt;recv_file($task, $ref, $size);     $hlc-&gt;macbinary(undef, $ret)     ... See \*(C`macbinary()\*(C' for more details on its usage.  If either the data fork or resource fork is empty, the fork length returned by \*(C`recv_file()\*(C' will be zero and the file path returned will be undef.</p>
  </dd>
  <dt>
    rename \s-1PATH\s0, \s-1NAME\s0
  </dt>
  <dd>
    <p>Renames the file or folder located at \s-1PATH\s0 to \s-1NAME\s0.  Note that \s-1PATH\s0 is the full path to the target, but \s-1NAME\s0 is just the new name without any path specification.  Example:     $hlc-&gt;rename("Pets:cat", "dog"); This changes the name of the file \*(L"cat\*(R" in the folder \*(L"Pets\*(R" to \*(L"dog\*(R" In blocking task mode, returns 1 on success or undef if an error occurred. In event loop mode, returns a task number if the request was sent successfully, or undef if an error occurred.</p>
  </dd>
  <dt>
    send_file \s-1TASK\s0, \s-1REF\s0, \s-1SIZE\s0, \s-1RFLT\s0
  </dt>
  <dd>
    <p>Starts sending the file designated by the Net::Hotline::Task object \s-1TASK\s0, the upload reference number \s-1REF\s0, the size in bytes \s-1SIZE\s0, and the resume information \s-1RFLT\s0 returned by \*(C`put_file()\*(C' (in blocking task mode) or supplied to the \*(C`put_file()\*(C' handler routine (in event loop mode). Returns 1 if the upload completed successfully, or undef if there was an error.</p>
  </dd>
  <dt>
    tracker_list \s-1TIMEOUT\s0
  </dt>
  <dd>
    <p>Connects to the server set via the \*(C`tracker()\*(C' method and retrieves the list of servers tracked by that tracker.  Returns an array (in array context) or a reference to an array (in scalar context) of Net::Hotline::TrackerListItem objects on success, and undef or an empty list on failure, with the error condition available via \*(C`last_error()\*(C'. The initial connection to the tracker will timeout after \s-1TIMEOUT\s0 seconds, or the current value set via \*(C`connection_timeout()\*(C' if \s-1TIMEOUT\s0 is omitted. A \s-1TIMEOUT\s0 value of zero will disable the timeout. Note that this method does not return until it has retrieved the list of tracked servers, and that the timeout applies <strong>only</strong> to the initial connection to the tracker.  It is often the case with overloaded trackers that this method will hang when writing to or reading from the tracker (regardless of the timeout value), many times resulting in a \*(C`die\*(C' with a broken pipe error in one of the network I/O functions.  To avoid this, either try a more responsive tracker and/or wrap your \*(C`tracker_list()\*(C' call in an \*(C`eval\*(C' block and check $@.</p>
  </dd>

</dl>

<h3>\s-1REQUESTS\s0</h3>
<p>All the methods in this section are treated as \*(L"tasks\*(R" by Hotline. Their status (start time, finish time, error state, etc.) is tracked internally by task number.  They return a task number if the request was sent successfully, undef otherwise.</p><p>When a tasks completes, the data is stored in the appropriate Net::Hotline::Client attribute.  For example, when a \*(C`req_news()\*(C' task completes, the data is available via the <em>news()</em> method.</p>
<dl class='dl-vertical'>
  <dt>
    req_filelist \s-1PATH\s0
  </dt>
  <dd>
    <p>Requests the file listing for the folder specified by \s-1PATH\s0, or the root directory if \s-1PATH\s0 is omitted.</p>
  </dd>
  <dt>
    req_fileinfo \s-1PATH\s0
  </dt>
  <dd>
    <p>Requests the file information for the file or folder specified by \s-1PATH\s0.</p>
  </dd>
  <dt>
    req_news
  </dt>
  <dd>
    <p>Requests the news from the server.</p>
  </dd>
  <dt>
    req_userinfo \s-1SOCKET\s0
  </dt>
  <dd>
    <p>Requests user information for the user specified by \s-1SOCKET\s0.</p>
  </dd>
  <dt>
    req_userlist
  </dt>
  <dd>
    <p>Request the list of users currently logged on.</p>
  </dd>

</dl>

<h3>\s-1ATTRIBUTES\s0</h3>
<p>The methods in this section return data or references to data structures in the Net::Hotline::Client object.  Some data structures contain references to objects.  For details on those objects, see their respective documentation (i.e. perldoc Net::Hotline::User)</p>
<dl class='dl-vertical'>
  <dt>
    agreement
  </dt>
  <dd>
    <p>Returns a reference to the server's user agreement text, or undef if there is none.</p>
  </dd>
  <dt>
    connected
  </dt>
  <dd>
    <p>Returns true if a network connection to a server is open.</p>
  </dd>
  <dt>
    files
  </dt>
  <dd>
    <p>Returns a reference to a hash of arrays containing Net::Hotline::FileListItem objects, keyed by directory path.  Here's some sample code that prints the entire file tree:     $files = $hlc-&gt;files();              # Get reference to the file tree</p><p>    foreach $directory (keys(%{$files}))     {       print "$directory&#92;n";              # Ex: "Uploads:Pictures"</p><p>      foreach $file (@{$files-&gt;{$directory}})       {         print "&#92;t", $file-&gt;name(), "&#92;n"; # Ex: "Picture.jpg"       }     }</p>
  </dd>
  <dt>
    last_activity
  </dt>
  <dd>
    <p>Returns the time the last packet was received from the server in the system's native \*(C`time()\*(C' format. (Usually seconds since the Unix epoch. MacPerl is probably the only odd-ball)</p>
  </dd>
  <dt>
    last_error
  </dt>
  <dd>
    <p>Returns a text error message detailing the last error that occurred.  Use this method to determine the cause of failure when a blocking task returns undef. Example:         ...         $hlc-&gt;<strong>blocking_tasks</strong>(1);         ...         $hlc-&gt;get_filelist("Folder1") || die $hlc-&gt;last_error(); Don't rely on \*(C`last_error()\*(C' unless you're in blocking task mode.  In event loop mode, set a handler routine via \*(C`task_error_handler()\*(C' and deal with errors there via the task object's \*(C`error()\*(C' and \*(C`error_text()\*(C' methods.</p>
  </dd>
  <dt>
    logged_in
  </dt>
  <dd>
    <p>Returns true if currently logged into a server.</p>
  </dd>
  <dt>
    news
  </dt>
  <dd>
    <p>Returns a reference to an array of news posts, or undef if the news has not yet been requested or is empty.</p>
  </dd>
  <dt>
    pchats
  </dt>
  <dd>
    <p>Returns a reference to a hash of Net::Hotline::PrivateChat objects, keyed by reference number, that represent all the private chats that the client is currently engaged in, or undef or an empty list if not in any private chats.</p>
  </dd>
  <dt>
    server
  </dt>
  <dd>
    <p>Returns the address of the server currently connected to as a hostname or \s-1IP\s0 address, depending on what the actual argument to \*(C`connect()\*(C' was.  If the port connected to is anything other than the standard Hotline port (5500), then a colon and the port number are tacked onto the end of the server name.  If not connected at all, undef is returned.</p>
  </dd>
  <dt>
    userlist
  </dt>
  <dd>
    <p>Returns a reference to a hash of Net::Hotline::User objects keyed by socket number, or undef if the userlist has not yet been received.</p>
  </dd>
  <dt>
    user_by_nick \s-1REGEX\s0
  </dt>
  <dd>
    <p>Returns reference(s) to user objects with nicknames matching \s-1REGEX\s0, and undef or an empty list if there are no matches.  Also returns undef or an empty list if called before the userlist has been retrieved from the server. \s-1REGEX\s0 is treated as a case-sensitive anchored regular expression internally (i.e. \*(C`/^REGEX$/\*(C'). If your regex matches more than one user's nickname, and \*(C`user_by_nick()\*(C' was called in array context, an array of references to user objects will be returned. Otherwise, the first user object that matched will be returned (as ordered by socket number, from low to high).</p>
  </dd>
  <dt>
    user_by_socket \s-1SOCKET\s0
  </dt>
  <dd>
    <p>Returns the user object whose socket number is equal to \s-1SOCKET\s0, or undef if there is no user at that socket.</p>
  </dd>

</dl>

<h3>\s-1HANDLERS\s0</h3>
<p>The methods in this section deal with getting and setting the handler routines for events and tasks.  If you do not set your own handler for an event, the default handler (usually just a print to \s-1STDOUT\s0) will be used. You can enable and disable the default handlers with the \*(C`default_handlers()\*(C' method.  They are disabled by default.</p>
<dl class='dl-vertical'>
  <dt>
    default_handlers \s-1EXPR\s0
  </dt>
  <dd>
    <p>If \s-1EXPR\s0 is omitted, it returns the default handler setting.  Otherwise, it sets the default handler setting to \s-1EXPR\s0 (anything that evaluates to true is considered \*(L"on\*(R").  Default handlers are disabled by default.</p>
  </dd>
  <dt>
    handlers
  </dt>
  <dd>
    <p>Returns a reference to a hash, keyed by event type strings (the strings in \s-1CAPS\s0 below).  The values associated with the keys are either code references or undef.  Event types are as follows:     Events:</p><p>    AGREEMENT      User agreement text received.     CHAT           New chat appeared.     CHAT_ACTION    A new chat "action" appeared.     COLOR          A user changed color in the userlist.     EVENT          Next cycle in the event loop.     ICON           A user changed icon in the userlist.     JOIN           A user joined the server.     LEAVE          A user left the server.     MSG            A private message arrived.     NEWS           News received.     NEWS_POSTED    A news post was made by another user.     NICK           A user changed nickname in the userlist.     PCHAT_CHAT     New private chat appeared.     PCHAT_ACTION   A new private chat action appeared.     PCHAT_INVITE   An invitation to private chat arrived.     PCHAT_JOIN     A user joined a private chat.     PCHAT_LEAVE    A user left a private chat.     PCHAT_SUBJECT  Private chat subject changed.     QUIT           The server was shutdown politely.     SERVER_MSG     A server message arrived.</p><p>    Tasks:</p><p>    BAN            Ban user task completed.     FILE_DELETE    A file or folder was deleted.     FILE_GET       A file download is ready to begin.     FILE_PUT       A file upload is ready to begin.     FILE_GET_INFO  File information received.     FILE_SET_INFO  File information set.     FILE_LIST      File list received.     FILE_MKDIR     New folder created.     FILE_MOVE      A file or folder was moved.     KICK           Disconnect user task completed.     LOGIN          Login task completed.     NEWS_POST      News post task completed.     PCHAT_ACCEPT   You have joined a private chat.     PCHAT_CREATE   New private chat created.     SEND_MSG       Private message sent.     TASK_ERROR     A task error ocurred.     USER_GETINFO   User information received.     USER_LIST      User list received.</p>
  </dd>

</dl>

<h3>\s-1SET/GET\s0 \s-1HANDLERS\s0</h3>
<p>The methods in this section expect either one code reference argument, or no arguments at all.  With one argument, the handler is set to the given code reference.  The return value is always the current value of the handler (should be either undef or a code reference).</p><p>The code reference should point to a subroutine that expects at least one argument: the Net::Hotline::Client object itself (listed as \*(L"\s-1SELF\s0\*(R" below). Other arguments vary according to the event being handled. In this section, only the varying arguments to the handler subroutine are described.</p><p>Also note that you don't have to do the \*(L"obvious\*(R" tasks associated with each handler.  For example, in the \*(L"leave\*(R" handler, you don't have to remove the user from the userlist.  That will be done for you by the Net::Hotline::Client object.</p><p><em>\s-1EVENTS\s0</em></p>
<dl class='dl-vertical'>
  <dt>
    agreement_handler \s-1CODE\s0 (\s-1SELF\s0, \s-1TEXT\s0)
  </dt>
  <dd>
    <p>User agreement text received.     TEXT        Reference to the agreement text.</p>
  </dd>
  <dt>
    chat_handler \s-1CODE\s0 (\s-1SELF\s0, \s-1TEXT\s0)
  </dt>
  <dd>
    <p>New chat appeared.     TEXT        Reference to the chat text.</p>
  </dd>
  <dt>
    chat_action_handler \s-1CODE\s0 (\s-1SELF\s0, \s-1TEXT\s0)
  </dt>
  <dd>
    <p>A new chat \*(L"action\*(R" appeared.     TEXT        Reference to the chat action text.</p>
  </dd>
  <dt>
    color_handler \s-1CODE\s0 (\s-1SELF\s0, \s-1USER\s0, \s-1OLD_COLOR\s0, \s-1NEW_COLOR\s0)
  </dt>
  <dd>
    <p>A user changed color in the userlist.     USER        A Net::Hotline::User object.     OLD_COLOR   The user&apos;s previous color.     NEW_COLOR   The user&apos;s new color. Valid colors:     1    Black  Active normal user.     2    Red    Active admin user.     3    Gray   Inactive normal user.     4    Pink   Inactive admin user. The hash %Net::Hotline::Constants::HTLC_COLORS contains color number-to-name mappings.</p>
  </dd>
  <dt>
    event_loop_handler \s-1CODE\s0 (\s-1SELF\s0, \s-1IDLE\s0)
  </dt>
  <dd>
    <p>Next cycle in the event loop.  Idle events only occur when non-blocking i/o is active.     IDLE        True if the event is an idle event.</p>
  </dd>
  <dt>
    icon_handler \s-1CODE\s0 (\s-1SELF\s0, \s-1USER\s0, \s-1OLD_ICON\s0, \s-1NEW_ICON\s0)
  </dt>
  <dd>
    <p>A user changed icon in the userlist.     USER        A Net::Hotline::User object.     OLD_ICON    The user&apos;s previous icon number.     NEW_ICON    The user&apos;s new icon number.</p>
  </dd>
  <dt>
    join_handler \s-1CODE\s0 (\s-1SELF\s0, \s-1USER\s0)
  </dt>
  <dd>
    <p>A user joined the server.     USER        A Net::Hotline::User object.</p>
  </dd>
  <dt>
    leave_handler \s-1CODE\s0 (\s-1SELF\s0, \s-1USER\s0)
  </dt>
  <dd>
    <p>A user left the server.     USER        A Net::Hotline::User object.</p>
  </dd>
  <dt>
    msg_handler \s-1CODE\s0 (\s-1SELF\s0, \s-1USER\s0, \s-1TEXT\s0, REPLY-TO)
  </dt>
  <dd>
    <p>A private message arrived.     USER        Reference to the sender&apos;s Net::Hotline::User object.     TEXT        Reference to the message text.     REPLY-TO    Reference to the text to which this is a reply (if any)</p>
  </dd>
  <dt>
    news_posted_handler \s-1CODE\s0 (\s-1SELF\s0, \s-1TEXT\s0)
  </dt>
  <dd>
    <p>A news post was made by another user.     TEXT        Reference to the news post text.</p>
  </dd>
  <dt>
    nick_handler \s-1CODE\s0 (\s-1SELF\s0, \s-1USER\s0, \s-1OLD_NICK\s0, \s-1NEW_NICK\s0)
  </dt>
  <dd>
    <p>A user changed nickname in the userlist.     USER        A Net::Hotline::User object.     OLD_NICK    The user&apos;s previous nickname.     NEW_NICK    The user&apos;s new nickname.</p>
  </dd>
  <dt>
    pchat_action_handler (\s-1SELF\s0, \s-1REF\s0, \s-1TEXT\s0)
  </dt>
  <dd>
    <p>A new private chat action appeared.     REF         Private chat reference number.     TEXT        Reference to the chat action text.</p>
  </dd>
  <dt>
    pchat_chat_handler (\s-1SELF\s0, \s-1REF\s0, \s-1TEXT\s0)
  </dt>
  <dd>
    <p>New private chat appeared.     REF         Private chat reference number.     TEXT        Reference to the chat text.</p>
  </dd>
  <dt>
    pchat_invite_handler (\s-1SELF\s0, \s-1REF\s0, \s-1SOCKET\s0, \s-1NICK\s0)
  </dt>
  <dd>
    <p>An invitation to private chat arrived.     REF         Private chat reference number.     SOCKET      Socket number of the inviting user.     NICK        Nick of the inviting user.</p>
  </dd>
  <dt>
    pchat_join_handler (\s-1SELF\s0, \s-1PCHAT\s0, \s-1SOCKET\s0)
  </dt>
  <dd>
    <p>A user joined a private chat.     PCHAT       A Net::Hotline::PrivateChat object.     SOCKET      Socket number of the joining user.</p>
  </dd>
  <dt>
    pchat_leave_handler (\s-1SELF\s0, \s-1PCHAT\s0, \s-1SOCKET\s0)
  </dt>
  <dd>
    <p>A user left a private chat.     PCHAT       A Net::Hotline::PrivateChat object.     SOCKET      Socket number of the leaving user. Note that the user who left will no longer be in the private chat object's userlist.</p>
  </dd>
  <dt>
    pchat_subject_handler (\s-1SELF\s0, \s-1REF\s0, \s-1TEXT\s0)
  </dt>
  <dd>
    <p>Private chat subject changed.     REF         Private chat reference number.     TEXT        Reference to the subject text.</p>
  </dd>
  <dt>
    quit_handler \s-1CODE\s0 (\s-1SELF\s0, \s-1TEXT\s0)
  </dt>
  <dd>
    <p>The server was shutdown politely.     TEXT        Reference to shutdown message text.</p>
  </dd>
  <dt>
    server_msg_handler \s-1CODE\s0 (\s-1SELF\s0, \s-1TEXT\s0)
  </dt>
  <dd>
    <p>A server message arrived.     TEXT        Reference to the message text.</p>
  </dd>

</dl>
<p><em>\s-1TASKS\s0</em></p>
<dl class='dl-vertical'>
  <dt>
    ban_handler \s-1CODE\s0 (\s-1SELF\s0, \s-1TASK\s0)
  </dt>
  <dd>
    <p>Ban user task completed.     TASK        A Net::Hotline::Task object.</p>
  </dd>
  <dt>
    delete_file_handler \s-1CODE\s0 (\s-1SELF\s0, \s-1TASK\s0)
  </dt>
  <dd>
    <p>A file or folder was deleted.     TASK        A Net::Hotline::Task object.</p>
  </dd>
  <dt>
    file_info_handler \s-1CODE\s0 (\s-1SELF\s0, \s-1TASK\s0, \s-1INFO\s0)
  </dt>
  <dd>
    <p>File information received.     TASK        A Net::Hotline::Task object.     INFO        A Net::Hotline::FileInfoItem object.</p>
  </dd>
  <dt>
    file_list_handler \s-1CODE\s0 (\s-1SELF\s0, \s-1TASK\s0)
  </dt>
  <dd>
    <p>File list received.     TASK        A Net::Hotline::Task object.</p>
  </dd>
  <dt>
    get_file_handler \s-1CODE\s0 (\s-1SELF\s0, \s-1TASK\s0, \s-1REF\s0, \s-1SIZE\s0)
  </dt>
  <dd>
    <p>A file download is ready to begin.     TASK        A Net::Hotline::Task object.     REF         Download reference number.     SIZE        Size of download in bytes. If you do not set a handler for \*(C`get_file()\*(C', a default handler will be used regardless of your \*(C`default_handlers()\*(C' setting.  The default handler simply does:     SELF-&gt;recv_file(TASK, REF, SIZE); which initiates the file download and does not return until the download has completed.  If you want to download in the background, call \*(C`fork()\*(C' (or something similar) in your handler routine.</p>
  </dd>
  <dt>
    kick_handler \s-1CODE\s0 (\s-1SELF\s0, \s-1TASK\s0)
  </dt>
  <dd>
    <p>Disconnect user task completed.     TASK        A Net::Hotline::Task object.</p>
  </dd>
  <dt>
    login_handler \s-1CODE\s0 (\s-1SELF\s0, \s-1TASK\s0)
  </dt>
  <dd>
    <p>Login task completed.     TASK        A Net::Hotline::Task object.</p>
  </dd>
  <dt>
    move_file \s-1CODE\s0 (\s-1SELF\s0, \s-1TASK\s0)
  </dt>
  <dd>
    <p>A file or folder was moved.     TASK        A Net::Hotline::Task object.</p>
  </dd>
  <dt>
    new_folder \s-1CODE\s0 (\s-1SELF\s0, \s-1TASK\s0)
  </dt>
  <dd>
    <p>New folder created.     TASK        A Net::Hotline::Task object.</p>
  </dd>
  <dt>
    news_handler \s-1CODE\s0 (\s-1SELF\s0, \s-1TASK\s0)
  </dt>
  <dd>
    <p>The news has arrived and is now available via the \*(C`news()\*(C' method.     TASK        A Net::Hotline::Task object.</p>
  </dd>
  <dt>
    pchat_accept_handler (\s-1SELF\s0, \s-1TASK\s0, \s-1PCHAT\s0)
  </dt>
  <dd>
    <p>You have joined a private chat.     TASK        A Net::Hotline::Task object.     PCHAT       A Net::Hotline::PrivateChat object.</p>
  </dd>
  <dt>
    pchat_create (\s-1SELF\s0, \s-1TASK\s0, \s-1PCHAT\s0)
  </dt>
  <dd>
    <p>New private chat created.     TASK        A Net::Hotline::Task object.     PCHAT       A Net::Hotline::PrivateChat object. Note that you do not have to save the private chat object yourself.  The client object keeps track of all private chats it is currently engaged in (the list is accessible via the \*(C`pchats()\*(C' method), updates the userlists as users join and leave, and deletes the objects when you leave the private chat.</p>
  </dd>
  <dt>
    post_news_handler \s-1CODE\s0 (\s-1SELF\s0, \s-1TASK\s0)
  </dt>
  <dd>
    <p>News post task completed.     TASK        A Net::Hotline::Task object.</p>
  </dd>
  <dt>
    put_file_handler \s-1CODE\s0 (\s-1SELF\s0, \s-1TASK\s0, \s-1REF\s0, \s-1SIZE\s0, \s-1RFLT\s0)
  </dt>
  <dd>
    <p>A file upload is ready to begin.     TASK        A Net::Hotline::Task object.     REF         Download reference number.     SIZE        Size of the upload in bytes.     RFLT        Data needed to resume an upload. If you do not set a handler for \*(C`put_file()\*(C', a default handler will be used regardless of your \*(C`default_handlers()\*(C' setting.  The default handler simply does:     SELF-&gt;send_file(TASK, REF, SIZE, RFLT); which initiates the file upload and does not return until the upload has completed.  If you want to upload in the background, call \*(C`fork()\*(C' (or something similar) in your handler routine.</p>
  </dd>
  <dt>
    send_msg_handler \s-1CODE\s0 (\s-1SELF\s0, \s-1TASK\s0)
  </dt>
  <dd>
    <p>Private message sent.     TASK        A Net::Hotline::Task object.</p>
  </dd>
  <dt>
    set_file_info_handler \s-1CODE\s0 (\s-1SELF\s0, \s-1TASK\s0)
  </dt>
  <dd>
    <p>File information set (this includes both renaming and setting file comments).     TASK        A Net::Hotline::Task object.</p>
  </dd>
  <dt>
    task_error_handler \s-1CODE\s0 (\s-1SELF\s0, \s-1TASK\s0)
  </dt>
  <dd>
    <p>A task error ocurred.     TASK        A Net::Hotline::Task object.</p>
  </dd>
  <dt>
    user_info_handler \s-1CODE\s0 (\s-1SELF\s0, \s-1TASK\s0)
  </dt>
  <dd>
    <p>User information received.     TASK        A Net::Hotline::Task object.</p>
  </dd>
  <dt>
    user_list_handler \s-1CODE\s0 (\s-1SELF\s0, \s-1TASK\s0)
  </dt>
  <dd>
    <p>User list received.     TASK        A Net::Hotline::Task object.</p>
  </dd>

</dl>

<h3>\s-1MISCELLANEOUS\s0</h3>

<dl class='dl-vertical'>
  <dt>
    debug \s-1EXPR\s0
  </dt>
  <dd>
    <p>If \s-1EXPR\s0 is omitted, returns the debugging status (off by default), otherwise sets debugging status to \s-1EXPR\s0 (true means debugging is on).</p>
  </dd>
  <dt>
    version
  </dt>
  <dd>
    <p>Returns the Net::Hotline::Client version string.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TO DO</h2>
        <div class="sectioncontent">
<ul>
<li><p>User administration.</p></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>Please send bug reports to siracusa@mindspring.com.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>John C. Siracusa (siracusa@mindspring.com)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright(c) 1999 by John C. Siracusa.  All rights reserved.  This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Net::Hotline.3pm.html"><span aria-hidden="true">&larr;</span> Net::Hotline.3pm: Perl libraries for the hotline internet client</a></li>
   <li class="next"><a href="Net::Hotline::FileInfoItem.3pm.html">Net::Hotline::FileInfoItem.3pm: File object used internally by net::hotline::client <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

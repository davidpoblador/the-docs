<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>DBIx::OO: Database to perl objects abstraction</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Database to perl objects abstraction">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="DBIx::OO (3pm) manual">
  <meta name="twitter:description" content="Database to perl objects abstraction">
  <meta name="twitter:image" content="https://www.carta.tech/images/libdbix-oo-perl-DBIx::OO-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/DBIx::OO.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="DBIx::OO (3pm) manual" />
  <meta property="og:description" content="Database to perl objects abstraction" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libdbix-oo-perl-DBIx::OO-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">DBIx::OO<small> (3pm)</small></h1>
        <p class="lead">Database to perl objects abstraction</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/DBIx::OO.3pm.html">
      <span itemprop="name">DBIx::OO: Database to perl objects abstraction</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libdbix-oo-perl/">
      <span itemprop="name">libdbix-oo-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/DBIx::OO.3pm.html">
      <span itemprop="name">DBIx::OO: Database to perl objects abstraction</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
    package MyDB;
    use base &apos;DBIx::OO&apos;;

    # We need to overwrite get_dbh since it&apos;s an abstract function.
    # The way you connect to the DB is really your job; this function
    # should return the database handle.  The default get_dbh() croaks.

    my $dbh;
    sub get_dbh {
        $dbh = DBI-&gt;connect_cached(&apos;dbi:mysql:test&apos;, &apos;user&apos;, &apos;passwd&apos;)
          if !defined $dbh;
        return $dbh;
    }

    package MyDB::Users;
    use base &apos;MyDB&apos;;

    _\|_PACKAGE_\|_-&gt;table(&apos;Users&apos;);
    _\|_PACKAGE_\|_-&gt;columns(P =&gt; [ &apos;id&apos; ],
                         E =&gt; [qw/ first_name last_name email /]);
    _\|_PACKAGE_\|_-&gt;has_many(pages =&gt; &apos;MyDB::Pages&apos;, &apos;user&apos;);

    package MyDB::Pages;
    use base &apos;MyDB&apos;;

    _\|_PACKAGE_\|_-&gt;table(&apos;Pages&apos;);
    _\|_PACKAGE_\|_-&gt;columns(P =&gt; [ &apos;id&apos; ],
                         E =&gt; [qw/ title content user /]);
    _\|_PACKAGE_\|_-&gt;has_a(user =&gt; &apos;MyDB::Users&apos;);

    package main;

    my $u = MyDB::Users-&gt;create({ id          =&gt; &apos;userid&apos;,
                                  first_name  =&gt; &apos;Q&apos;,
                                  last_name   =&gt; &apos;W&apos; });

    my $foo = MyDB::Users-&gt;retrieve(&apos;userid&apos;);
    my @p = @{ $foo-&gt;fk_pages };
    print "User: ", $foo-&gt;first_name, " ", $foo-&gt;last_name, " pages:&#92;n";
    foreach (@p) {
        print $_-&gt;title, "&#92;n";
    }

    $foo-&gt;first_name(&apos;John&apos;);
    $foo-&gt;last_name(&apos;Doe&apos;);
# or
    $foo-&gt;set(first_name =&gt; &apos;John&apos;, last_name =&gt; &apos;Doe&apos;);
    $foo-&gt;update;
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">IMPORTANT NOTE</h2>
        <div class="sectioncontent">
<p>This code is tested only with MySQL.  That's what I use.  I don't have too much time to test/fix it for other DBMS-es (it shouldn't be too difficult though), but for now this is it...  Volunteers are welcome.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module has been inspired by the wonderful Class::DBI.  It is a database-to-Perl-Objects abstraction layer, allowing you to interact with a database using common Perl syntax.</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>I had the feeling that Class::DBI is no longer maintained.  This doesn't seem to be the case, because:</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>My code was broken multiple times by Class::DBI upgrades.</p>
  </dd>
  <dt>
    3.
  </dt>
  <dd>
    <p>Class::DBI doesn't quote table or field names, making it impossible to use a column named, say, 'group' with MySQL.</p>
  </dd>
  <dt>
    4.
  </dt>
  <dd>
    <p>I wanted to know very well what happens \*(L"under the hood\*(R".</p>
  </dd>
  <dt>
    5.
  </dt>
  <dd>
    <p>I hoped my module would be faster than \s-1CDBI\s0.  I'm not sure this is the case, but it certainly has less features. :-)</p>
  </dd>
  <dt>
    6.
  </dt>
  <dd>
    <p>There's more than one way to do it.</p>
  </dd>

</dl>
<p>All in all, I now use it in production code so this thing is here to stay.</p><h3>Features</h3>

<dl class='dl-vertical'>
  <dt>
    <strong>retrieve, search, create, update, delete</strong>
  </dt>
  <dd>
    <p>As Class::DBI, we have functions to retrieve an object by the primary key, search a table and create multiple objects at once, create a new object, update an existing object.</p>
  </dd>
  <dt>
    <strong>manage fields with convenient accessors</strong>
  </dt>
  <dd>
    <p>Same like Class::DBI, we provide accessors for each declared column in a table.  Usually accessors will have the same name as the column name, but note that there are cases when we can't do that, such as \*(L"can\*(R", \*(L"get\*(R", \*(L"set\*(R", etc. \*(-- because DBIx::OO or parent objects already define these functions and have a different meaning. When it is not possible to use the column name, it is prefixed with \*(L"col_\*(R" \*(-- so if you have a table with a column named \*(L"can\*(R", its accessor will be named \*(L"col_can\*(R".</p>
  </dd>
  <dt>
    <strong>has_a, has_many, has_mapping</strong>
  </dt>
  <dd>
    <p>We support a few types of table relationships.  They provide a few nice features, though overally are not as flexible as Class::DBI's. The syntax is quite different too, be sure to check the documentation of these functions.</p>
  </dd>
  <dt>
    <strong>\s-1JOIN\s0</strong>-s
  </dt>
  <dd>
    <p>has_a also creates a search function that allows you to retrieve data from both tables using a \s-1JOIN\s0 construct.  This can drastically reduce the number of \s-1SQL\s0 queries required to fetch a list of objects.</p>
  </dd>

</dl>

<h3>Missing features:</h3>

<dl class='dl-vertical'>
  <dt>
    <strong>\s-1NO\s0 caching of any kind</strong>
  </dt>
  <dd>
    <p>DBIx::OO does not cache objects.  This means that you can have the same \s-1DB\s0 record in multiple Perl objects.  Sometimes this can put you in trouble (not if you're careful though). At some point I might want to implement object uniqueness like Class::DBI, but not for now.</p>
  </dd>
  <dt>
    <strong>\s-1NO\s0 triggers</strong>
  </dt>
  <dd>
    <p>Triggers are nice, but can cause considerable performance problems when misused. \s-1UPDATE:\s0 The only trigger that currently exists is <em>before_set()</em>, check its documentation.</p>
  </dd>
  <dt>
    <strong>A lot others</strong>
  </dt>
  <dd>
    <p>Constraints, integrity maintenance, etc.  By contrast Class::DBI has a lot of nice features, but I think the performance price we pay for them is just too big.  I hope this module to stay small and be fast.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">QUICK START</h2>
        <div class="sectioncontent">
<p>You need to subclass DBIx::OO in order to provide an implementation to the <strong>get_dbh</strong>() method.  This function is pure virtual and should retrieve the database handler, as returned by <strong>\s-1DBI-\s0&gt;connect</strong>, for the database that you want to use.  You can use an interim package for that, as we did in our example above (<strong>MyDB</strong>).</p><p>Then, each derived package will handle exactly one table, should setup columns and relationships.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">API DOCUMENTATION</h2>
        <div class="sectioncontent">
<p>Currently, <strong></strong><strong>new()</strong><strong></strong> takes no arguments and constructs an empty object. You normally shouldn't need to call this directly. This method should return a database handler, as returned by \s-1DBI-\s0&gt;connect.  The default implementation croaks, so you <em>need</em> to overwrite it in your subclasses.  To write it only once, you can use an intermediate object. Call this method in each derived package to inform DBIx::OO of the table that you wish that package to use.</p><p>    _\|_PACKAGE_\|_-&gt;table(&apos;Users&apos;) Sets/retrieves the columns of the current package.</p><p>Similarly to Class::DBI, DBIx::OO uses a sort of column grouping. The 'P' group is always the primary key.  The 'E' group is the essential group\*(--which will be fetched whenever the object is first instantiated.  You can specify any other groups names here, and they will simply group retrieval of columns.</p><p>Example:</p><p>    _\|_PACKAGE_\|_-&gt;columns(P =&gt; [ &apos;id&apos; ],                          E =&gt; [ &apos;name&apos;, &apos;description&apos; ],                          X =&gt; [ &apos;c1&apos;, &apos;big_content1&apos;, &apos;big_title1&apos; ],                          Y =&gt; [ &apos;c2&apos;, &apos;big_content2&apos;, &apos;big_title2&apos; ]);</p><p>The above code defines 4 groups.  When an object is first instantiated, it will fetch 'id', 'name' and 'description'.  When you say $obj-&gt;c1, it will fetch 'c1, 'big_content1' and 'big_title1', because they are in the same group.  When you say $obj-&gt;c2 it will fetch 'c2', 'big_content2' and 'big_title2'.  That's pretty much like Class::DBI.</p><p>To retrieve columns, you pass a group name.</p><p><em>Notes</em></p><ul>
<li><p>Class::DBI allows you to call <em>columns()</em> multiple times, passing one group at a time.  Our module should allow this too, but it's untested and might be buggy.  We suggest defining all groups in one shot, like the example above.</p></li><li><p>Group 'P' is <em>required</em>.  I mean that.  We won't guess the primary key column like Class::DBI does. Though public, it's likely you won't need this function.  It returns a list of column names that would be cloned in a <em>clone()</em> operation. By default it excludes any columns in the "<strong>P</strong>" group (primary keys) but you can pass a list of other names to exclude as well. Using this function you can declare some default values for your columns.  They will be used unless alternative values are specified when a record is inserted (e.g. with <em>create()</em>).  Example:</p></li>
</ul><p>    _\|_PACKAGE_\|_-&gt;defaults(created     =&gt; [&apos;now()&apos;],                           hidden      =&gt; 1,                           modified_by =&gt; &#92;&get_current_user_id);</p><p>You can specify any scalar supported by SQL::Abstract's insert operation.  For instance, an array reference specifies literal \s-1SQL\s0 (won't be quoted).  Additionally, you can pass code references, in which case the subroutine will be called right when the data is inserted and its return value will be used. Retrieves the value of one or more columns.  If you pass more column names, it will return an array of values, in the right order. Sets one or more columns to the specified value(s).</p><p>This function calls \*(C`before_set\*(C' right before modifying the object data, passing a hash reference to the new values. By default this function does nothing.  It will be called by the framework right before setting column values.  A hash reference with columns to be set will be passed.  You can modify this hash if you wish.  For example, assuming you have an Users table with a \s-1MD5\s0 password and you want to create the \s-1MD5\s0 right when the column is set, you can do this:</p><p>    package Users;</p><p>    ...</p><p>    sub before_set {         my ($self, $h, $is_create) = @_;         if (exists $h-&gt;{password}) {             $h-&gt;{password} = make_md5_passwd($h-&gt;{password});         }     }</p><p>    my $u = Users-&gt;retrieve(&apos;foo&apos;);     $u-&gt;password(&apos;foobar&apos;);     print $u-&gt;password;     # be8cd58c70ad7dc935802fdb051869fe</p><p>The $is_create argument will be true (1) if this function is called as a result of a <em>create()</em> command. Returns the value(s) of the primary key(s).  If the primary key consists of more columns, this method will return an array with the values, in the order the \s-1PK\s0 column names were specified.</p><p>Currently this is equivalent to $self-&gt;get(@{ $self-&gt;columns('P') }). Use these functions to start, commit or rollback a \s-1DB\s0 transaction. These simply call begin_work, rollback and commit methods on the \s-1DB\s0 handle returned by <em>get_dbh()</em>. There are a few column names that we can't allow as accessor names. This function receives a column name and returns the name of the accessor for that field.  By default it prefixes forbidden names with 'col_'.  The forbidden names are:</p><p>  - id   - can   - our   - columns   - table   - get   - set   - count</p><p>If you don't like this behavior you can override this function in your classes to return something else.  However, be very careful about allowing any the above forbidden names as accessors\*(--basically nothing will work. This function returns the name of a foreign key accessor, as defined by has_a/has_many.  The default returns \*(L"fk_$name\*(R"--thus prepending \*(L"fk_\*(R".</p><p>If you want the Class::DBI behavior, you can override this function in your derived module:</p><p>    sub get_fk_name { return $_[1]; }</p><p>(the first argument will be object ref. or package)</p><p>I think the Class::DBI model is unwise.  Many times I found my columns inflated to objects when I was in fact expecting to get an \s-1ID\s0.  Having the code do implicit work for you is nice, but you can spend hours debugging when it gets it wrong\*(--which is why, DBIx::OO will by default prepend a \*(L"fk_\*(R" to foreign objects accessors.  You'll get use to it.     _\|_PACKAGE_\|_-&gt;has_a(name, type[, mapping[, order ]]);     _\|_PACKAGE_\|_-&gt;has_many(name, type[, mapping[, order[, limit[, offset ]]]]);</p><p>Creates a relationship between two packages.  In the simplest form, you call:</p><p>    _\|_PACKAGE_\|_-&gt;has_a(user =&gt; Users);</p><p>This declaration creates a relation between _\|_PACKAGE_\|_ (assuming it has a column named 'user') and 'Users' package.  It is assuming that 'user' from the current package points to the primary key of the Users package.</p><p>The declaration creates a method named 'fk_user', which you can call in order to retrieve the pointed object.  Example:</p><p>    package Pages;     use base &apos;MyDB&apos;;     _\|_PACKAGE_\|_-&gt;columns(&apos;P&apos; =&gt; [ &apos;id&apos; ],                          &apos;E&apos; =&gt; [ &apos;user&apos;, ... ]);     _\|_PACKAGE_\|_-&gt;has_a(user =&gt; &apos;Users&apos;);</p><p>    my $p = Pages-&gt;<strong>retrieve</strong>(1);     my $u = $p-&gt;fk_user;     print $u-&gt;first_name;</p><p>In more complex cases, you might need to point to a different field than the primary key of the target package.  You can call it like this:</p><p>    Users-&gt;has_many(pages =&gt; Pages, &apos;user&apos;);     my $u = Users-&gt;retrieve(&apos;foo&apos;);     my @pages = @{ $u-&gt;fk_pages };</p><p>The above specifies that an User has many pages, and that they are determined by mapping the 'user' field of the Pages package to the <em>primary key</em> of the \*(C`Users\*(C' package.</p><p><em>has_many()</em> also defines an utility function that allows us to easily count the number of rows in the referenced table, without retrieving their data.  Example:</p><p>    print $u-&gt;count_pages;</p><p>You can specify an \s-1WHERE\s0 clause too, in SQL::Abstract syntax:</p><p>    print $u-&gt;count_pages(keywords =&gt; { -like =&gt; &apos;%dhtml%&apos; });</p><p>The above returns the number of \s-1DHTML\s0 pages that belong to the user.</p><p>In even more complex cases, you want to map one or more arbitrary columns of one package to columns of another package, so you can pass a hash reference that describes the column mapping:</p><p>    ## FIXME: find a good example</p><p><em>has_many()</em> is very similar to has_a, but the accessor it creates simply returns multiple values (as an array ref).  We can pass some arguments too, either to has_a/has_many declarations, or to the accessor.</p><p>    @pages = @{ $u-&gt;fk_pages(&apos;created&apos;, 10, 5) }</p><p>The above will retrieve the user's pages ordered by 'created', starting at \s-1OFFSET\s0 5 and LIMIT-ing to 10 results.</p><p>You can use has_a even if there's not a direct mapping.  Example, a page can have multiple revisions, but we can also easily access the first/last revision:</p><p>    Pages-&gt;has_many(revisions =&gt; &apos;Revisions&apos;, &apos;page&apos;);     Pages-&gt;has_a(first_revision =&gt; &apos;Revisions&apos;, &apos;page&apos;, &apos;created&apos;);     Pages-&gt;has_a(last_revision =&gt; &apos;Revisions&apos;, &apos;page&apos;, &apos;^created&apos;);</p><p><em>has_a()</em> will \s-1LIMIT\s0 the result to one.  Ordering the results by 'created', we make sure that we actually retrieve what we need. <strong>Note</strong> that by prefixing the column name with a '^' character, we're asking the module to do a \s-1DESC\s0 ordering.</p><p>(Of course, it's a lot faster if we had first_revision and last_revision as columns in the Pages table that link to Revision id, but we just wanted to point out that the above is possible ;-)</p><p><em>Join</em></p><p><em>has_a()</em> will additionally create a join function.  It allows you to select data from 2 tables using a single \s-1SQL\s0 query.  Example:</p><p>    package MyDB::Users;     MyDB::Users-&gt;table(&apos;Users&apos;);     MyDB::Users-&gt;has_a(profile =&gt; &apos;Profiles&apos;);</p><p>    package MyDB::Profiles;     MyDB::Profiles-&gt;table(&apos;Profiles&apos;);</p><p>    @data = Users-&gt;search_join_profile;     foreach (@data) {         my $user = $_-&gt;{Users};        # the key is the SQL B&lt;table&gt; name         my $profile = $_-&gt;{Profiles};         print $user-&gt;id, " has address: ", $profile-&gt;address;     }</p><p>The above only does 1 \s-1SELECT\s0.  Note that the join search function returns an array of hashes that map from the \s-1SQL\s0 table name to the DBIx::OO instance.</p><p>You can pass additional \s-1WHERE\s0, \s-1ORDER\s0, \s-1LIMIT\s0 and \s-1OFFSET\s0 clauses to the join functions as well:</p><p>    @data = Users-&gt;search_join_profile({ &apos;Users.last_name&apos; =&gt; &apos;Doe&apos; },                                        &apos;Users.nickname&apos;,                                        10);</p><p>The above fetches the first 10 members of the Doe family ordered by nickname.</p><p>Due to lack of support from SQL::Abstract side, the \s-1JOIN\s0 is actually a select like this:</p><p>    SELECT ... FROM table1, table2 WHERE table1.foreign = table2.id</p><p>In the future I hope to add better support for this, that is, use \*(L"\s-1INNER\s0 \s-1JOIN\s0\*(R" and eventually support other \s-1JOIN\s0 types as well.</p><p><em>Notes</em></p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>The \*(C`fk_\*(C' accessors will actually retrieve data at each call. Therefore:     $p1 = $user-&gt;fk_pages;     $p2 = $user-&gt;fk_pages; will retrieve 2 different arrays, containing different sets of objects (even if they point to the same records), hitting the database twice. This is subject to change, but for now you have to be careful about this.  It's best to keep a reference to the returned object(s) rather than calling <em>fk_pages()</em> all over the place.</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p><em>has_many()</em> creates accessors that select multiple objects.  The database will be hit once, though, and multiple objects are created from the returned data.  If this isn't desirable, feel free to \s-1LIMIT\s0 your results. Alias to <em>has_a()</em>. You can use has_mapping to map one object to another using an intermediate table.  You can have these tables:</p>
  </dd>

</dl>
<p>    Users: id, first_name, etc.     Groups: id, description, etc.     Users_To_Groups: user, group</p><p>This is quite classical, I suppose, to declare many-to-many relationships.  The Users_To_Groups contains records that map one user to one group.  To get the ID-s of all groups that a certain user belongs to, you would say:</p><p>    SELECT group FROM Users_To_Group where user = &apos;$user&apos;</p><p>But since you usually need the Group objects directly, you could speed things up with a join:</p><p>    SELECT Groups.id, Groups.description, ... FROM Groups, Users_To_Groups            WHERE Users_To_Groups.group = Groups.id              AND Users_To_Groups.user = &apos;$user&apos;;</p><p>The relationship declared with <em>has_mapping()</em> does exactly that.  You would call it like this:</p><p>    package Users;     _\|_PACKAGE_\|_-&gt;table(&apos;Users&apos;);     _\|_PACKAGE_\|_-&gt;columns(P =&gt; [ &apos;id&apos; ], ...);</p><p>    _\|_PACKAGE_\|_-&gt;has_mapping(groups, &apos;Groups&apos;,                              &apos;Users_To_Groups&apos;, &apos;user&apos;, &apos;group&apos;);</p><p>    package Groups;     _\|_PACKAGE_\|_-&gt;table(&apos;Groups&apos;);     _\|_PACKAGE_\|_-&gt;columns(P =&gt; [ &apos;id&apos; ], ...);</p><p>    # You can get the reverse mapping as well:     _\|_PACKAGE_\|_-&gt;has_mapping(users, &apos;Users&apos;,                              &apos;Users_To_Groups&apos;, &apos;group&apos;, &apos;user&apos;);</p><p>    package Users_To_Groups;     _\|_PACKAGE_\|_-&gt;table(&apos;Users_To_Groups&apos;);     _\|_PACKAGE_\|_-&gt;columns(P =&gt; [ &apos;user&apos;, &apos;group&apos; ]);</p><p>Note that Users_To_Groups has a multiple primary key.  This isn't required, but you should at least have an unique index for the (user, group) pair.</p><p><em>Arguments</em></p><p>I started with an example because the function itself is quite complicated.  Here are arguments documentation:</p>
<dl class='dl-vertical'>
  <dt>
    name
  </dt>
  <dd>
    <p>This is used to name the accessors.  By default we will prepend a \*(L"fk_\*(R" (see get_fk_name).</p>
  </dd>
  <dt>
    type
  </dt>
  <dd>
    <p>The type of the target objects.</p>
  </dd>
  <dt>
    maptype
  </dt>
  <dd>
    <p>The mapping object type.  This is the name of the object that maps one type to another.  Even though you'll probably never need to instantiate such an object, it still has to be declared.</p>
  </dd>
  <dt>
    map1
  </dt>
  <dd>
    <p>Specifies how we map from current package (_\|_PACKAGE_\|_) to the \*(C`maptype\*(C' object.  This can be a scalar or an hash ref.  If it's a scalar, we will assume that _\|_PACKAGE_\|_ has a simple primary key (not multiple) and \*(C`map1\*(C' is the name of the column from \*(C`maptype\*(C' that we should map this key to.  If it's a hash reference, it should directly specify the mapping; the keys will be taken from _\|_PACKAGE_\|_ and the values from \*(C`maptype\*(C'.  If that sounds horrible, check the example below.</p>
  </dd>
  <dt>
    map2
  </dt>
  <dd>
    <p>Similar to \*(C`map1\*(C', but \*(C`map2\*(C' specifies the mapping from \*(C`maptype\*(C' to the target \*(C`type\*(C'.  If a scalar, it will be the name of the column from \*(C`maptype\*(C' that maps to the primary key of the target package (assumed to be a simple primary key).  If a hash reference, it specifies the full mapping.</p>
  </dd>
  <dt>
    order, limit, offset
  </dt>
  <dd>
    <p>Similar to has_many, these can specify default \s-1ORDER\s0 \s-1BY\s0 and/or \s-1LIMIT/OFFSET\s0 clauses for the resulted query.</p>
  </dd>

</dl>
<p><em>Example</em></p><p>Here's the mapping overview:</p><p>                     map1                      map2      _\|_PACKAGE_\|_     ===&gt;    C&lt;maptype&gt;        ===&gt;       C&lt;type&gt;    current package        table that holds           the target package                             the mapping     my $u = Users-&gt;create({ id          =&gt; &apos;foo&apos;,                             first_name  =&gt; &apos;John&apos;,                             last_name   =&gt; &apos;Doe&apos; });</p><p>Creates a new record and stores it in the database.  Returns the newly created object.  We recommend passing a hash reference, but you can pass a hash by value as well.</p><h3>clone(@except)</h3>
<p>Clones an object, returning a hash (reference) suitable for <em>create()</em>. Here's how you would call it:</p><p>  my $val = $page-&gt;clone;   my $new_page = Pages-&gt;create($val);</p><p>Or, supposing you don't want to copy the value of the \*(L"created\*(R" field:</p><p>  my $val = $page-&gt;clone(&apos;created&apos;);   my $new_page = Pages-&gt;create($val); Initializes one or more objects from the given data.  $data can be a hashref (in which case a single object will be created and returned) or an arrayref (multiple objects will be created and returned as an array reference).</p><p>The hashes simply contain the data, as retrieved from the database. That is, map column name to field value.</p><p>This method is convenient in those cases where you already have the data (suppose you SELECT-ed it in a different way than using DBIx::OO) and want to initialize DBIx::OO objects without the penalty of going through the \s-1DB\s0 again.     my $u = Users-&gt;retrieve(&apos;foo&apos;);</p><p>Retrieves an object from the database.  You need to pass its \s-1ID\s0 (the value of the primary key).  If the primary key consists on more columns, you can pass the values in order as an array, or you can pass a hash reference.</p><p>Returns undef if no objects were found.     $a = Users-&gt;search({ created =&gt; [ &apos;&gt;=&apos;, &apos;2006-01-01 00:00:00&apos; ]});</p><p>Searches the database and returns an array of objects that match the search criteria.  All arguments are optional.  If you pass no arguments, it will return an array containing all objects in the \s-1DB\s0. The syntax of $where and $order are described in SQL::Abstract.</p><p>In scalar context it will return a reference to the array.</p><p>The $limit and $offset arguments are added by DBIx::OO and allow you to limit/paginate your query.</p><p>\s-1UPDATE\s0 0.0.7:</p><p>Certain queries are difficult to express in SQL::Abstract syntax.  The search accepts a literal \s-1WHERE\s0 clause too, but until version 0.0.7 there was no way to specify bind variables.  For example, now you can do this:</p><p>    @admins = Users-&gt;search("mode & ? &lt;&gt; 0 and created &gt; ?",                             undef, undef, undef,                             MODE_FLAGS-&gt;{admin},                             strftime(&apos;%Y-%m-%d&apos;, localtime)).</p><p>In order to pass bind variables, you must pass order, limit and offset (give undef if you don't care about them) and add your bind variables immediately after. <em>retrieve_all()</em> is an alias to <em>search()</em> \*(-- since with no arguments it fetches all objects.     $u-&gt;set(first_name =&gt; &apos;Foo&apos;,             last_name =&gt; &apos;Bar&apos;);     $u-&gt;update;</p><p>Saves any modified columns to the database.     $u = Users-&gt;retrieve(&apos;foo&apos;);     $u-&gt;delete;</p><p>Removes the object's record from the database.  Note that the Perl object remains intact and you can actually revive it (if you're not losing it) using <em>undelete()</em>.     $u = Users-&gt;retrieve(&apos;foo&apos;);     $u-&gt;delete;    # record&apos;s gone     $u-&gt;undelete;  # resurrected</p><p>This function can \*(L"ressurect\*(R" an object that has been deleted (that is, it re-INSERT-s the record into the database), provided that you still have a reference to the object.  I'm not sure how useful it is, but it helped me test the <em>delete()</em> function. :-)</p><p>Other (useless) thing you can do with it is manually emulating the <em>create()</em> function:</p><p>    $u = new Users;     $u-&gt;{values}{id} = &apos;foo&apos;;     $u-&gt;first_name(&apos;Foo&apos;);     $u-&gt;last_name(&apos;Bar&apos;);     $u-&gt;undelete;</p><p>Note we can't call the column accessors, nor use set/get, before we have a primary key.</p><p>This method is not too useful in itself, but it helps understanding the internals of DBIx::OO.  If you want to read more about this, see \*(L"under the hood\*(R".     $u = Users-&gt;retrieve(&apos;foo&apos;);     $u-&gt;first_name(undef);     $u-&gt;revert;</p><p>Discards any changes to the object, reverting to the state in the database.  Note this doesn't \s-1SELECT\s0 new data, it just reverts to values saved in the \*(C`modified\*(C' hash.  See \*(L"under the hood\*(R" for more info.</p><p>\*(C`discard_changes()\*(C' is an alias to \*(C`revert()\*(C'.</p>
<h3>get_sql_abstract</h3>
<p>Returns the instance of SQL::Abstract::WithLimit (our custom derivative) suitable for generating \s-1SQL\s0.  This is cached (will be created only the first time get_sql_abstract is called).</p>
<h3>count</h3>
<p>Returns the result of an \s-1SQL\s0 \s-1COUNT\s0(*) for the specified where clause. Call this as a package method, for example:</p><p>    $number_of_romanians = Users-&gt;count({ country =&gt; &apos;RO&apos; });</p><p>The argument is an SQL::Abstract where clause. Enable or disable foreign key checks in the backend \s-1DB\s0 server.  These are hard-coded in MySQL syntax for now so be careful not to use them with other servers. ;-) You can use this facility to automatically create / upgrade your database.  It takes a very simple (rudimentary even) approach, but we found it to be useful.  Here's the \*(L"big\*(R" idea.</p><p>    package MyDB::Users;     use base &apos;MyDB&apos;;</p><p>    _\|_PACKAGE_\|_-&gt;table(&apos;Users&apos;);     _\|_PACKAGE_\|_-&gt;columns(P =&gt; [ &apos;id&apos; ],                          E =&gt; [qw/ first_name last_name /]);</p><p>    sub get_autocreate_data {q{     #### (users:0) ####</p><p>    CREATE TABLE Users ( id VARCHAR(32) NOT NULL PRIMARY KEY,                          first_name VARCHAR(64),                          last_name VARCHAR(64) );</p><p>    # you can put Perl comments too.</p><p>    CREATE INDEX idx_Users_first_name ON Users(first_name)     }}</p><p>\s-1OK\s0, now you can write this make_database.pl script:</p><p>    /usr/bin/perl -w</p><p>    use MyDB;     MyDB-&gt;autocreate(qw( MyDB::Users ));</p><p>When you run this script the first time, it will create the Users table.  (An internal _dbix_oo_versions table gets created as well; we're using it inside DBIx::OO in order to keep track of existing table versions).  Note that if you run it again, it doesn't do anything\*(--the database is up to date.</p><p>Later.  You sold a billion copies of your software, customers are happy but they are crying loud for an \*(L"email\*(R" field in their user profiles, also wondering what was your idea to index on first_name and not on last_name!  In order to make it easy for them to upgrade their databases, you need to modify MyDB::Users.  Besides declaring the 'email' column using _\|_PACKAGE_\|_-&gt;columns, <strong>append</strong> the following to your get_autocreate_data section:</p><p>    #### (users:1) ####</p><p>    # (note that we incremented the version number)</p><p>    # add the &apos;email&apos; field     ALTER TABLE Users ADD (email VARCHAR(128));</p><p>    # index it     CREATE UNIQUE INDEX idx_Users_email ON Users(email);</p><p>    # and add that last_name index     CREATE INDEX idx_Users_last_name ON Users(last_name);</p><p>Now you can just tell your users to run make_database.pl again and everything gets updated.</p><p>The #### (foo:N) #### syntax is meant simply to declare an \s-1ID\s0 and a version number.  \*(L"foo\*(R" can be anything you want \*(-- it doesn't have to be the table name.  You can actually create multiple tables, if you need to.</p>
<h3>autopopulate</h3>
<p>This is supposed to initialize tables.  Untested and may not work \*(-- don't use it.</p>
<h3>get_autocreate_data</h3>
<p>See the documentation of \*(L"autocreate\*(R".</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CAVEATS</h2>
        <div class="sectioncontent">
<p>There are a number of problems you might encounter, mostly related to the fact that we don't cache objects.</p><h3>Concurrent objects</h3>
<p>    $u1 = Users-&gt;retrieve(&apos;foo&apos;);     $u2 = Users-&gt;retrieve(&apos;foo&apos;);</p><p>$u1 and $u2 now point to different objects, but both point to the same record in the database.  Now the problem:</p><p>    $u1-&gt;first_name(&apos;Foo&apos;);     $u2-&gt;first_name(&apos;Bar&apos;);     $u1-&gt;update;</p><p>Which one gets set?  'Foo', but $u2 has uncommitted changes.  When you further say $u2-&gt;update, it will set the name to 'Bar'.  If you say $u2-&gt;revert, it will revert to whatever was there <em>before</em> 'Foo'. This can lead to potential problems.</p><p>Class::DBI (almost) doesn't have this problem (it can appear when you have multiple processes accessing the database concurrently, such as httpd processes).</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">UNDER THE HOOD</h2>
        <div class="sectioncontent">
<p>A DBIx::OO object is a hash blessed into the DBIx::OO package. The hash currently contains 2 keys:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>values</strong>
  </dt>
  <dd>
    <p>A hash containing the field =&gt; value pairs that are currently retrieved from the database.</p>
  </dd>
  <dt>
    <strong>modified</strong>
  </dt>
  <dd>
    <p>Another hash that maps field_name =&gt; 'original value' for the fields that were modified and not yet committed of the current object.</p>
  </dd>

</dl>
<p>If a field is not present in <strong>values</strong> and is requested with <em>get()</em>, then the database will be queried for it and for all other fields that aren't present in \*(L"values\*(R" but are listed in the <strong>E</strong>ssential group.</p><p>If a field is present in <strong>modified</strong>, then it will be saved in the \s-1DB\s0 on the next <em>update()</em> call.  An object can discard these operations with the <em>discard()</em> method.  Discard restores the values using those stored in the \*(C`modified\*(C' hash.</p><p>Each operation plays around these hashes.  For instance, when you call <em>search()</em>, a single \s-1SQL\s0 will run and then we'll iterate over the results, create objects and assign the SELECT-ed values to the <strong>values</strong> hash.</p><p>A <em>retrieve()</em> operation creates a new object and assign the passed value to its primary key, then it will call the internal _retrieve_columns([ 'P', 'E' ]) function in order to fetch essential object data from the \s-1DB\s0.  Note that a call to _retrieve_columns is not actually necessary, since it will happen anyway the first time you want to retrieve a field that doesn't exist in <strong>values</strong> \*(-- but it's good to call it because <em>retrieve()</em> should return <strong>undef</strong> if the object can't be found in the \s-1DB\s0.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>Yeah, the documentation sucks.  Other bugs?</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO DBIx::OO&hellip;</h2>
        <div class="sectioncontent">
<p>SQL::Abstract, Class::DBI, DBIx::Class</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Mihai Bazon, &lt;mihai.bazon@gmail.com&gt;</p>
<pre>
    http://www.dynarch.com/
    http://www.bazon.net/mishoo/
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright (c) Mihai Bazon 2006.  All rights reserved.</p><p>This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THANKS</h2>
        <div class="sectioncontent">
<p>I'd like to thank irc.n0i.net \*(-- our small but wonderful community that's always there when you need it.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DISCLAIMER OF WARRANTY</h2>
        <div class="sectioncontent">
<p>\s-1BECAUSE\s0 \s-1THIS\s0 \s-1SOFTWARE\s0 \s-1IS\s0 \s-1LICENSED\s0 \s-1FREE\s0 \s-1OF\s0 \s-1CHARGE\s0, \s-1THERE\s0 \s-1IS\s0 \s-1NO\s0 \s-1WARRANTY\s0 \s-1FOR\s0 \s-1THE\s0 \s-1SOFTWARE\s0, \s-1TO\s0 \s-1THE\s0 \s-1EXTENT\s0 \s-1PERMITTED\s0 \s-1BY\s0 \s-1APPLICABLE\s0 \s-1LAW\s0. \s-1EXCEPT\s0 \s-1WHEN\s0 \s-1OTHERWISE\s0 \s-1STATED\s0 \s-1IN\s0 \s-1WRITING\s0 \s-1THE\s0 \s-1COPYRIGHT\s0 \s-1HOLDERS\s0 \s-1AND/OR\s0 \s-1OTHER\s0 \s-1PARTIES\s0 \s-1PROVIDE\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \*(L"\s-1AS\s0 \s-1IS\s0\*(R" \s-1WITHOUT\s0 \s-1WARRANTY\s0 \s-1OF\s0 \s-1ANY\s0 \s-1KIND\s0, \s-1EITHER\s0 \s-1EXPRESSED\s0 \s-1OR\s0 \s-1IMPLIED\s0, \s-1INCLUDING\s0, \s-1BUT\s0 \s-1NOT\s0 \s-1LIMITED\s0 \s-1TO\s0, \s-1THE\s0 \s-1IMPLIED\s0 \s-1WARRANTIES\s0 \s-1OF\s0 \s-1MERCHANTABILITY\s0 \s-1AND\s0 \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0. \s-1THE\s0 \s-1ENTIRE\s0 \s-1RISK\s0 \s-1AS\s0 \s-1TO\s0 \s-1THE\s0 \s-1QUALITY\s0 \s-1AND\s0 \s-1PERFORMANCE\s0 \s-1OF\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1IS\s0 \s-1WITH\s0 \s-1YOU\s0. \s-1SHOULD\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1PROVE\s0 \s-1DEFECTIVE\s0, \s-1YOU\s0 \s-1ASSUME\s0 \s-1THE\s0 \s-1COST\s0 \s-1OF\s0 \s-1ALL\s0 \s-1NECESSARY\s0 \s-1SERVICING\s0, \s-1REPAIR\s0, \s-1OR\s0 \s-1CORRECTION\s0.</p><p>\s-1IN\s0 \s-1NO\s0 \s-1EVENT\s0 \s-1UNLESS\s0 \s-1REQUIRED\s0 \s-1BY\s0 \s-1APPLICABLE\s0 \s-1LAW\s0 \s-1OR\s0 \s-1AGREED\s0 \s-1TO\s0 \s-1IN\s0 \s-1WRITING\s0 \s-1WILL\s0 \s-1ANY\s0 \s-1COPYRIGHT\s0 \s-1HOLDER\s0, \s-1OR\s0 \s-1ANY\s0 \s-1OTHER\s0 \s-1PARTY\s0 \s-1WHO\s0 \s-1MAY\s0 \s-1MODIFY\s0 \s-1AND/OR\s0 \s-1REDISTRIBUTE\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1AS\s0 \s-1PERMITTED\s0 \s-1BY\s0 \s-1THE\s0 \s-1ABOVE\s0 \s-1LICENCE\s0, \s-1BE\s0 \s-1LIABLE\s0 \s-1TO\s0 \s-1YOU\s0 \s-1FOR\s0 \s-1DAMAGES\s0, \s-1INCLUDING\s0 \s-1ANY\s0 \s-1GENERAL\s0, \s-1SPECIAL\s0, \s-1INCIDENTAL\s0, \s-1OR\s0 \s-1CONSEQUENTIAL\s0 \s-1DAMAGES\s0 \s-1ARISING\s0 \s-1OUT\s0 \s-1OF\s0 \s-1THE\s0 \s-1USE\s0 \s-1OR\s0 \s-1INABILITY\s0 \s-1TO\s0 \s-1USE\s0 \s-1THE\s0 \s-1SOFTWARE\s0 (\s-1INCLUDING\s0 \s-1BUT\s0 \s-1NOT\s0 \s-1LIMITED\s0 \s-1TO\s0 \s-1LOSS\s0 \s-1OF\s0 \s-1DATA\s0 \s-1OR\s0 \s-1DATA\s0 \s-1BEING\s0 \s-1RENDERED\s0 \s-1INACCURATE\s0 \s-1OR\s0 \s-1LOSSES\s0 \s-1SUSTAINED\s0 \s-1BY\s0 \s-1YOU\s0 \s-1OR\s0 \s-1THIRD\s0 \s-1PARTIES\s0 \s-1OR\s0 A \s-1FAILURE\s0 \s-1OF\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1TO\s0 \s-1OPERATE\s0 \s-1WITH\s0 \s-1ANY\s0 \s-1OTHER\s0 \s-1SOFTWARE\s0), \s-1EVEN\s0 \s-1IF\s0 \s-1SUCH\s0 \s-1HOLDER\s0 \s-1OR\s0 \s-1OTHER\s0 \s-1PARTY\s0 \s-1HAS\s0 \s-1BEEN\s0 \s-1ADVISED\s0 \s-1OF\s0 \s-1THE\s0 \s-1POSSIBILITY\s0 \s-1OF\s0 \s-1SUCH\s0 \s-1DAMAGES\s0.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="DBIx::Intrors.3pm.html"><span aria-hidden="true">&larr;</span> DBIx::Intrors.3pm: Embperl and dbix::recordset</a></li>
   <li class="next"><a href="DBIx::OO::Tree.3pm.html">DBIx::OO::Tree.3pm: Manipulate hierarchical data using the "nested sets" model <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

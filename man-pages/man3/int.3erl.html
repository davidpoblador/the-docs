<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>int: Interpreter interface</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Interpreter interface">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="int (3erl) manual">
  <meta name="twitter:description" content="Interpreter interface">
  <meta name="twitter:image" content="https://www.carta.tech/images/erlang-manpages-int-3erl.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3erl/int.3erl.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="int (3erl) manual" />
  <meta property="og:description" content="Interpreter interface" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/erlang-manpages-int-3erl.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">int<small> (3erl)</small></h1>
        <p class="lead">Interpreter interface</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/int.3erl.html">
      <span itemprop="name">int: Interpreter interface</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/erlang-manpages/">
      <span itemprop="name">erlang-manpages</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/int.3erl.html">
      <span itemprop="name">int: Interpreter interface</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The Erlang interpreter provides mechanisms for breakpoints and stepwise execution of code. It is mainly intended to be used by the <em>Debugger</em>, see Debugger User's Guide and <em>debugger(3erl)</em>.</p><p>From the shell, it is possible to:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>Specify which modules should be interpreted.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>Specify breakpoints.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>Monitor the current status of all processes executing code in interpreted modules, also processes at other Erlang nodes.</p>
  </dd>

</dl>
<p>By <em>attaching to</em> a process executing interpreted code, it is possible to examine variable bindings and order stepwise execution. This is done by sending and receiving information to/from the process via a third process, called the meta process. It is possible to implement your own attached process. See <em>int.erl</em> for available functions and <em>dbg_ui_trace.erl</em> for possible messages.</p><p>The interpreter depends on the Kernel, STDLIB and GS applications, which means modules belonging to any of these applications are not allowed to be interpreted as it could lead to a deadlock or emulator crash. This also applies to modules belonging to the Debugger application itself.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BREAKPOINTS</h2>
        <div class="sectioncontent">
<p>Breakpoints are specified on a line basis. When a process executing code in an interpreted module reaches a breakpoint, it will stop. This means that that a breakpoint must be set at an executable line, that is, a line of code containing an executable expression.</p><p>A breakpoint have a status, a trigger action and may have a condition associated with it. The status is either <em>active</em> or <em>inactive</em>. An inactive breakpoint is ignored. When a breakpoint is reached, the trigger action specifies if the breakpoint should continue to be active (<em>enable</em>), if it should become inactive (<em>disable</em>), or if it should be removed (<em>delete</em>). A condition is a tuple <em>{Module,Name}</em>. When the breakpoint is reached, <em>Module:Name(Bindings)</em> is called. If this evaluates to <em>true</em>, execution will stop. If this evaluates to <em>false</em>, the breakpoint is ignored. <em>Bindings</em> contains the current variable bindings, use <em>get_binding</em> to retrieve the value for a given variable.</p><p>By default, a breakpoint is active, has trigger action <em>enable</em> and has no condition associated with it. For more detailed information about breakpoints, refer to Debugger User's Guide.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">
<p><strong></strong> i(AbsModule) -&gt; {module,Module} | error</p><p><strong></strong> i(AbsModules) -&gt; ok</p><p><strong></strong> ni(AbsModule) -&gt; {module,Module} | error</p><p><strong></strong> ni(AbsModules) -&gt; ok</p><p>Types:</p><p>AbsModules = [AbsModule]</p><p>AbsModule = Module | File | [Module | File]</p><p> Module = atom()</p><p> File = string()</p><p>Interprets the specified module(s). <em>i/1</em> interprets the module only at the current node. <em>ni/1</em> interprets the module at all known nodes.</p><p>A module may be given by its module name (atom) or by its file name. If given by its module name, the object code <em>Module.beam</em> is searched for in the current path. The source code <em>Module.erl</em> is searched for first in the same directory as the object code, then in a <em>src</em> directory next to it.</p><p>If given by its file name, the file name may include a path and the <em>.erl</em> extension may be omitted. The object code <em>Module.beam</em> is searched for first in the same directory as the source code, then in an <em>ebin</em> directory next to it, and then in the current path.</p><p><strong></strong> Note:</p><p>The interpreter needs both the source code and the object code, and the object code <em>must</em> include debug information. That is, only modules compiled with the option <em>debug_info</em> set can be interpreted.</p><p>The functions returns <em>{module,Module}</em> if the module was interpreted, or <em>error</em> if it was not.</p><p>The argument may also be a list of modules/file names, in which case the function tries to interpret each module as specified above. The function then always returns <em>ok</em>, but prints some information to stdout if a module could not be interpreted.</p><p><strong></strong> n(AbsModule) -&gt; ok</p><p><strong></strong> nn(AbsModule) -&gt; ok</p><p>Types:</p><p>AbsModule = Module | File | [Module | File]</p><p> Module = atom()</p><p> File = string()</p><p>Stops interpreting the specified module. <em>n/1</em> stops interpreting the module only at the current node. <em>nn/1</em> stops interpreting the module at all known nodes.</p><p>As for <em>i/1</em> and <em>ni/1</em>, a module may be given by either its module name or its file name.</p><p><strong></strong> interpreted() -&gt; [Module]</p><p>Types:</p><p>Module = atom()</p><p>Returns a list with all interpreted modules.</p><p><strong></strong> file(Module) -&gt; File | {error,not_loaded}</p><p>Types:</p><p>Module = atom()</p><p>File = string()</p><p>Returns the source code file name <em>File</em> for an interpreted module <em>Module</em>.</p><p><strong></strong> interpretable(AbsModule) -&gt; true | {error,Reason}</p><p>Types:</p><p>AbsModule = Module | File</p><p> Module = atom()</p><p> File = string()</p><p>Reason = no_src | no_beam | no_debug_info | badarg | {app,App}</p><p> App = atom()</p><p>Checks if a module is possible to interpret. The module can be given by its module name <em>Module</em> or its source file name <em>File</em>. If given by a module name, the module is searched for in the code path.</p><p>The function returns <em>true</em> if both source code and object code for the module is found, the module has been compiled with the option <em>debug_info</em> set and does not belong to any of the applications Kernel, STDLIB, GS or Debugger itself.</p><p>The function returns <em>{error,Reason}</em> if the module for some reason is not possible to interpret.</p><p><em>Reason</em> is <em>no_src</em> if no source code is found or <em>no_beam</em> if no object code is found. It is assumed that the source- and object code are located either in the same directory, or in <em>src</em> and <em>ebin</em> directories next to each other.</p><p><em>Reason</em> is <em>no_debug_info</em> if the module has not been compiled with the option <em>debug_info</em> set.</p><p><em>Reason</em> is <em>badarg</em> if <em>AbsModule</em> is not found. This could be because the specified file does not exist, or because <em>code:which/1</em> does not return a beam file name, which is the case not only for non-existing modules but also for modules which are preloaded or cover compiled.</p><p><em>Reason</em> is <em>{app,App}</em> where <em>App</em> is <em>kernel</em>, <em>stdlib</em>, <em>gs</em> or <em>debugger</em> if <em>AbsModule</em> belongs to one of these applications.</p><p>Note that the function can return <em>true</em> for a module which in fact is not interpretable in the case where the module is marked as sticky or resides in a directory marked as sticky, as this is not discovered until the interpreter actually tries to load the module.</p><p><strong></strong> auto_attach() -&gt; false | {Flags,Function}</p><p><strong></strong> auto_attach(false)</p><p><strong></strong> auto_attach(Flags, Function)</p><p>Types:</p><p>Flags = [init | break | exit]</p><p>Function = {Module,Name,Args}</p><p> Module = Name = atom()</p><p> Args = [term()]</p><p>Gets and sets when and how to automatically attach to a process executing code in interpreted modules. <em>false</em> means never automatically attach, this is the default. Otherwise automatic attach is defined by a list of flags and a function. The following flags may be specified:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>init</em> - attach when a process for the very first time calls an interpreted function.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>break</em> - attach whenever a process reaches a breakpoint.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>exit</em> - attach when a process terminates.</p>
  </dd>

</dl>
<p>When the specified event occurs, the function <em>Function</em> will be called as:</p>
<pre>
spawn(Module, Name, [Pid | Args])

</pre>
<p><em>Pid</em> is the pid of the process executing interpreted code.</p><p><strong></strong> stack_trace() -&gt; Flag</p><p><strong></strong> stack_trace(Flag)</p><p>Types:</p><p>Flag = all | no_tail | false</p><p>Gets and sets how to save call frames in the stack. Saving call frames makes it possible to inspect the call chain of a process, and is also used to emulate the stack trace if an error (an exception of class error) occurs.</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>all</em> - save information about all current calls, that is, function calls that have not yet returned a value.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>no_tail</em> - save information about current calls, but discard previous information when a tail recursive call is made. This option consumes less memory and may be necessary to use for processes with long lifetimes and many tail recursive calls. This is the default.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>false</em> - do not save any information about current calls.</p>
  </dd>

</dl>
<p><strong></strong> break(Module, Line) -&gt; ok | {error,break_exists}</p><p>Types:</p><p>Module = atom()</p><p>Line = int()</p><p>Creates a breakpoint at <em>Line</em> in <em>Module</em>.</p><p><strong></strong> delete_break(Module, Line) -&gt; ok</p><p>Types:</p><p>Module = atom()</p><p>Line = int()</p><p>Deletes the breakpoint located at <em>Line</em> in <em>Module</em>.</p><p><strong></strong> break_in(Module, Name, Arity) -&gt; ok | {error,function_not_found}</p><p>Types:</p><p>Module = Name = atom()</p><p>Arity = int()</p><p>Creates a breakpoint at the first line of every clause of the <em>Module:Name/Arity</em> function.</p><p><strong></strong> del_break_in(Module, Name, Arity) -&gt; ok | {error,function_not_found}</p><p>Types:</p><p>Module = Name = atom()</p><p>Arity = int()</p><p>Deletes the breakpoints at the first line of every clause of the <em>Module:Name/Arity</em> function.</p><p><strong></strong> no_break() -&gt; ok</p><p><strong></strong> no_break(Module) -&gt; ok</p><p>Deletes all breakpoints, or all breakpoints in <em>Module</em>.</p><p><strong></strong> disable_break(Module, Line) -&gt; ok</p><p>Types:</p><p>Module = atom()</p><p>Line = int()</p><p>Makes the breakpoint at <em>Line</em> in <em>Module</em> inactive.</p><p><strong></strong> enable_break(Module, Line) -&gt; ok</p><p>Types:</p><p>Module = atom()</p><p>Line = int()</p><p>Makes the breakpoint at <em>Line</em> in <em>Module</em> active.</p><p><strong></strong> action_at_break(Module, Line, Action) -&gt; ok</p><p>Types:</p><p>Module = atom()</p><p>Line = int()</p><p>Action = enable | disable | delete</p><p>Sets the trigger action of the breakpoint at <em>Line</em> in <em>Module</em> to <em>Action</em>.</p><p><strong></strong> test_at_break(Module, Line, Function) -&gt; ok</p><p>Types:</p><p>Module = atom()</p><p>Line = int()</p><p>Function = {Module,Name}</p><p> Name = atom()</p><p>Sets the conditional test of the breakpoint at <em>Line</em> in <em>Module</em> to <em>Function</em>. The function must fulfill the requirements specified in the section <em>Breakpoints</em> above.</p><p><strong></strong> get_binding(Var, Bindings) -&gt; {value,Value} | unbound</p><p>Types:</p><p>Var = atom()</p><p>Bindings = term()</p><p>Value = term()</p><p>Retrieves the binding of <em>Var</em>. This function is intended to be used by the conditional function of a breakpoint.</p><p><strong></strong> all_breaks() -&gt; [Break]</p><p><strong></strong> all_breaks(Module) -&gt; [Break]</p><p>Types:</p><p>Break = {Point,Options}</p><p> Point = {Module,Line}</p><p> Module = atom()</p><p> Line = int()</p><p> Options = [Status,Trigger,null,Cond|]</p><p> Status = active | inactive</p><p> Trigger = enable | disable | delete</p><p> Cond = null | Function</p><p> Function = {Module,Name}</p><p> Name = atom()</p><p>Gets all breakpoints, or all breakpoints in <em>Module</em>.</p><p><strong></strong> snapshot() -&gt; [Snapshot]</p><p>Types:</p><p>Snapshot = {Pid, Function, Status, Info}</p><p> Pid = pid()</p><p> Function = {Module,Name,Args}</p><p> Module = Name = atom()</p><p> Args = [term()]</p><p> Status = idle | running | waiting | break | exit | no_conn</p><p> Info = {} | {Module,Line} | ExitReason</p><p> Line = int()</p><p> ExitReason = term()</p><p>Gets information about all processes executing interpreted code.</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>Pid</em> - process identifier.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>Function</em> - first interpreted function called by the process.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>Status</em> - current status of the process.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>Info</em> - additional information.</p>
  </dd>

</dl>
<p><em>Status</em> is one of:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>idle</em> - the process is no longer executing interpreted code. <em>Info={}</em>.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>running</em> - the process is running. <em>Info={}</em>.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>waiting</em> - the process is waiting at a <em>receive</em>. <em>Info={}</em>.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>break</em> - process execution has been stopped, normally at a breakpoint. <em>Info={Module,Line}</em>.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>exit</em> - the process has terminated. <em>Info=ExitReason</em>.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>no_conn</em> - the connection is down to the node where the process is running. <em>Info={}</em>.</p>
  </dd>

</dl>
<p><strong></strong> clear() -&gt; ok</p><p>Clears information about processes executing interpreted code by removing all information about terminated processes.</p><p><strong></strong> continue(Pid) -&gt; ok | {error,not_interpreted}</p><p><strong></strong> continue(X,Y,Z) -&gt; ok | {error,not_interpreted}</p><p>Types:</p><p>Pid = pid()</p><p>X = Y = Z = int()</p><p>Resume process execution for <em>Pid</em>, or for <em>c:pid(X,Y,Z)</em>.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="instrument.3erl.html"><span aria-hidden="true">&larr;</span> instrument.3erl: Analysis and utility functions for instrumentation</a></li>
   <li class="next"><a href="interceptors.3erl.html">interceptors.3erl: Describe the functions which must be exported by any supplied orber native interceptor. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

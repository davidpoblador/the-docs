<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>XML::TokeParser: Simplified interface to xml::parser</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Simplified interface to xml::parser">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="XML::TokeParser (3pm) manual">
  <meta name="twitter:description" content="Simplified interface to xml::parser">
  <meta name="twitter:image" content="https://www.carta.tech/images/libxml-tokeparser-perl-XML::TokeParser-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/XML::TokeParser.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="XML::TokeParser (3pm) manual" />
  <meta property="og:description" content="Simplified interface to xml::parser" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libxml-tokeparser-perl-XML::TokeParser-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">XML::TokeParser<small> (3pm)</small></h1>
        <p class="lead">Simplified interface to xml::parser</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/XML::TokeParser.3pm.html">
      <span itemprop="name">XML::TokeParser: Simplified interface to xml::parser</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libxml-tokeparser-perl/">
      <span itemprop="name">libxml-tokeparser-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/XML::TokeParser.3pm.html">
      <span itemprop="name">XML::TokeParser: Simplified interface to xml::parser</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
    use XML::TokeParser;
                                                                    #
    #parse from file
    my $p = XML::TokeParser-&gt;new(&apos;file.xml&apos;)
                                                                    #
    #parse from open handle
    open IN, &apos;file.xml&apos; or die $!;
    my $p = XML::TokeParser-&gt;new( &#92;*IN, Noempty =&gt; 1 );
                                                                    #
    #parse literal text
    my $text = &apos;&lt;tag xmlns="http://www.omsdev.com"&gt;text&lt;/tag&gt;&apos;;
    my $p    = XML::TokeParser-&gt;new( &#92;$text, Namespaces =&gt; 1 );
                                                                    #
    #read next token
    my $token = $p-&gt;get_token();
                                                                    #
    #skip to &lt;title&gt; and read text
    $p-&gt;get_tag(&apos;title&apos;);
    $p-&gt;get_text();
                                                                    #
    #read text of next &lt;para&gt;, ignoring any internal markup
    $p-&gt;get_tag(&apos;para&apos;);
    $p-&gt;get_trimmed_text(&apos;/para&apos;);
                                                                    #
    #process &lt;para&gt; if interesting text
    $t = $p-&gt;get_tag(&apos;para&apos;);
    $p-&gt;begin_saving($t);
    if ( $p-&gt;get_trimmed_text(&apos;/para&apos;) =~ /interesting stuff/ ) {
        $p-&gt;restore_saved();
        process_para($p);
    }
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>XML::TokeParser provides a procedural (\*(L"pull mode\*(R") interface to XML::Parser in much the same way that Gisle Aas' HTML::TokeParser provides a procedural interface to HTML::Parser.  XML::TokeParser splits its \s-1XML\s0 input up into \*(L"tokens,\*(R" each corresponding to an XML::Parser event.</p><p>A token is a <strong>bless'd</strong> reference to an array whose first element is an event-type string and whose last element is the literal text of the \s-1XML\s0 input that generated the event, with intermediate elements varying according to the event type.</p><p>Each token is an <em>object</em> of type XML::TokeParser::Token. Read \*(L"XML::TokeParser::Token\*(R" to learn what methods are available for inspecting the token, and retrieving data from it.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">
<p>Creates a new parser, specifying the input source and any options.  If $input is a string, it is the name of the file to parse.  If $input is a reference to a string, that string is the actual text to parse.  If $input is a reference to a typeglob or an IO::Handle object corresponding to an open file or socket, the text read from the handle will be parsed. Options are name=&gt;value pairs and can be any of the following:</p>
<dl class='dl-vertical'>
  <dt>
    Namespaces
  </dt>
  <dd>
    <p>If set to a true value, namespace processing is enabled.</p>
  </dd>
  <dt>
    ParseParamEnt
  </dt>
  <dd>
    <p>This option is passed on to the underlying XML::Parser object; see that module's documentation for details.</p>
  </dd>
  <dt>
    Noempty
  </dt>
  <dd>
    <p>If set to a true value, text tokens consisting of only whitespace (such as those created by indentation and line breaks in between tags) will be ignored.</p>
  </dd>
  <dt>
    Latin
  </dt>
  <dd>
    <p>If set to a true value, all text other than the literal text elements of tokens will be translated into the \s-1ISO\s0 8859-1 (Latin-1) character encoding rather than the normal \s-1UTF-8\s0 encoding.</p>
  </dd>
  <dt>
    Catalog
  </dt>
  <dd>
    <p>The value is the \s-1URI\s0 of a catalog file used to resolve \s-1PUBLIC\s0 and \s-1SYSTEM\s0 identifiers.  See XML::Catalog for details.</p>
  </dd>

</dl>
<p>Returns the next token, as an array reference, from the input.  Returns undef if there are no remaining tokens. Pushes tokens back so they will be re-read.  Useful if you've read one or more tokens too far.  Correctly handles \*(L"partial\*(R" tokens returned by <em>get_tag()</em>. If no argument given, skips tokens until the next start tag or end tag token. If an argument is given, skips tokens until the start tag or end tag (if the argument begins with '/') for the named element.  The returned token does not include an event type code; its first element is the element name, prefixed by a '/' if the token is for an end tag. If no argument given, returns the text at the current position, or an empty string if the next token is not a 'T' token.  If an argument is given, gathers up all text between the current position and the specified start or end tag, stripping out any intervening tags (much like the way a typical Web browser deals with unknown tags). Like <em>get_text()</em>, but deletes any leading or trailing whitespaces and collapses multiple whitespace (including newlines) into single spaces. Causes subsequent calls to <em>get_token()</em>, <em>get_tag()</em>, <em>get_text()</em>, and <em>get_trimmed_text()</em> to save the returned tokens.  In conjunction with <em>restore_saved()</em>, allows you to \*(L"back up\*(R" within a token stream.  If an argument is supplied, it is placed at the beginning of the list of saved tokens (useful because you often won't know you want to begin saving until you've already read the first token you want saved). Pushes all the tokens saved by <em>begin_saving()</em> back onto the token stream. Stops saving tokens.  To cancel saving without backing up, call <em>begin_saving()</em> and <em>restore_saved()</em> in succession.</p><h3>XML::TokeParser::Token</h3>
<p>A token is a blessed array reference, that you acquire using \*(C`$p-&gt;get_token\*(C' or \*(C`$p-&gt;get_tag\*(C', and that might look like:</p><p>    ["S",  $tag, $attr, $attrseq, $raw]     ["E",  $tag, $raw]     ["T",  $text, $raw]     ["C",  $text, $raw]     ["PI", $target, $data, $raw]</p><p>If you don't like remembering array indices (you're a real programmer), you may access the attributes of a token like:</p><p>\*(C`$t-&gt;tag\*(C', \*(C`$t-&gt;attr\*(C', \*(C`$t-&gt;attrseq\*(C', \*(C`$t-&gt;raw\*(C', \*(C`$t-&gt;text\*(C', \*(C`$t-&gt;target\*(C', \*(C`$t-&gt;data\*(C'.</p><p><strong>****Please note that this may change in the future,</strong> <strong>where as there will be 4 token types, XML::TokeParser::Token::StartTag ....</strong></p><p>What kind of token is it?</p><p>To find out, inspect your token using any of these is_* methods (1 == true, 0 == false, d'oh):</p>
<dl class='dl-vertical'>
  <dt>
    is_text
  </dt>
  <dd>
    
  </dd>
  <dt>
    is_comment
  </dt>
  <dd>
    
  </dd>
  <dt>
    is_pi which is short for is_process_instruction
  </dt>
  <dd>
    
  </dd>
  <dt>
    is_start_tag
  </dt>
  <dd>
    
  </dd>
  <dt>
    is_end_tag
  </dt>
  <dd>
    
  </dd>
  <dt>
    is_tag
  </dt>
  <dd>
    
  </dd>

</dl>
<p>What's that token made of? To retrieve data from your token, use any of the following methods, depending on the kind of token you have:</p>
<dl class='dl-vertical'>
  <dt>
    target
  </dt>
  <dd>
    <p>only for process instructions</p>
  </dd>
  <dt>
    data
  </dt>
  <dd>
    <p>only for process instructions</p>
  </dd>
  <dt>
    raw
  </dt>
  <dd>
    <p>for all tokens</p>
  </dd>
  <dt>
    attr
  </dt>
  <dd>
    <p>only for start tags, returns a hashref ( \*(C`print "#link ", \*(C'\*(C`$t-&gt;attr\*(C'\*(C`-&gt;{href}\*(C' ). only for start tags, returns an array ref of the keys found in \*(C`$t-&gt;attr\*(C' in the order they originally appeared in. only for tags ( \*(C`print "opening ", \*(C'\*(C`$t-&gt;tag\*(C'\*(C` if \*(C'\*(C`$t-&gt;is_start_tag\*(C' ). only for tokens of type text and comment</p>
  </dd>

</dl>
<p>Here's more detailed info about the tokens.</p>
<dl class='dl-vertical'>
  <dt>
    Start tag
  </dt>
  <dd>
    <p>The token has five elements: 'S', the element's name, a reference to a hash of attribute values keyed by attribute names, a reference to an array of attribute names in the order in which they appeared in the tag, and the literal text.</p>
  </dd>
  <dt>
    End tag
  </dt>
  <dd>
    <p>The token has three elements: 'E', the element's name, and the literal text.</p>
  </dd>
  <dt>
    Character data (text)
  </dt>
  <dd>
    <p>The token has three elements: 'T', the parsed text, and the literal text. All contiguous runs of text are gathered into single tokens; there will never be two 'T' tokens in a row.</p>
  </dd>
  <dt>
    Comment
  </dt>
  <dd>
    <p>The token has three elements: 'C', the parsed text of the comment, and the literal text.</p>
  </dd>
  <dt>
    Processing instruction
  </dt>
  <dd>
    <p>The token has four elements: '\s-1PI\s0', the target, the data, and the literal text.</p>
  </dd>

</dl>
<p>The literal text includes any markup delimiters (pointy brackets, &lt;![CDATA[, etc.), entity references, and numeric character references and is in the \s-1XML\s0 document's original character encoding.  All other text is in \s-1UTF-8\s0 (unless the Latin option is set, in which case it's in \s-1ISO-8859-1\s0) regardless of the original encoding, and all entity and character references are expanded.</p><p>If the Namespaces option is set, element and attribute names are prefixed by their (possibly empty) namespace URIs enclosed in curly brackets and xmlns:* attributes do not appear in 'S' tokens.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DIFFERENCES FROM HTML::TokeParser</h2>
        <div class="sectioncontent">
<p>Uses a true \s-1XML\s0 parser rather than a modified \s-1HTML\s0 parser.</p><p>Text and comment tokens include extracted text as well as literal text.</p><p>\s-1PI\s0 tokens include target and data as well as literal text.</p><p>No tokens for declarations.</p><p>No \*(L"textify\*(R" hash.</p><p>unget_token correctly handles partial tokens returned by <em>get_tag()</em>.</p><p><em>begin_saving()</em> and <em>restore_saved()</em></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>Example:</p><p>    use XML::TokeParser;     use strict;                                                                                #     my $text = &apos;&lt;tag foo="bar" foy="floy"&gt; some text &lt;!--comment--&gt;&lt;/tag&gt;&apos;;     my $p    = XML::TokeParser-&gt;new( &#92;$text );                                                                                #     print $/;                                                                                #     while( defined( my $t = $p-&gt;get_token() ) ){         local $&#92;="&#92;n";         print &apos;         raw = &apos;, $t-&gt;raw;                                                                                #         if( $t-&gt;tag ){             print &apos;         tag = &apos;, $t-&gt;tag;                                                                                #             if( $t-&gt;is_start_tag ) {                 print &apos;        attr = &apos;, join &apos;,&apos;, %{$t-&gt;attr};                 print &apos;     attrseq = &apos;, join &apos;,&apos;, @{$t-&gt;attrseq};             }                                                                                #             print &apos;is_tag       &apos;, $t-&gt;is_tag;             print &apos;is_start_tag &apos;, $t-&gt;is_start_tag;             print &apos;is_end_tag   &apos;, $t-&gt;is_end_tag;         }         elsif( $t-&gt;is_pi ){             print &apos;      target = &apos;, $t-&gt;target;             print &apos;        data = &apos;, $t-&gt;data;             print &apos;is_pi        &apos;, $t-&gt;is_pi;         }         else {             print &apos;        text = &apos;, $t-&gt;text;             print &apos;is_text      &apos;, $t-&gt;is_text;             print &apos;is_comment   &apos;, $t-&gt;is_comment;         }                                                                                #         print $/;     }     _\|_END_\|_</p><p>Output:</p><p>             raw = &lt;tag foo="bar" foy="floy"&gt;              tag = tag             attr = foo,bar,foy,floy          attrseq = foo,foy     is_tag       1     is_start_tag 1     is_end_tag   0</p><p>             raw =  some text             text =  some text     is_text      1     is_comment   0</p><p>             raw = &lt;!--comment--&gt;             text = comment     is_text      0     is_comment   1</p><p>             raw = &lt;/tag&gt;              tag = tag     is_tag       1     is_start_tag 0     is_end_tag   1</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>To report bugs, go to &lt;http://rt.cpan.org/NoAuth/Bugs.html?Dist=XML-TokeParser&gt; or send mail to &lt;bug-XML-Tokeparser@rt.cpan.org&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Copyright (c) 2003 D.H. aka PodMaster (current maintainer). Copyright (c) 2001 Eric Bohlman (original author).</p><p>All rights reserved. This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself. If you don't know what this means, visit &lt;http://perl.com/&gt; or &lt;http://cpan.org/&gt;.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO XML::TokeParser&hellip;</h2>
        <div class="sectioncontent">
<p>HTML::TokeParser, XML::Parser, XML::Catalog, XML::Smart, XML::Twig.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="XML::Tidy.3pm.html"><span aria-hidden="true">&larr;</span> XML::Tidy.3pm: Tidy indenting of xml documents</a></li>
   <li class="next"><a href="XML::TreePP.3pm.html">XML::TreePP.3pm: Pure perl implementation for parsing/writing xml documents <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Mail::SRS: Interface to sender rewriting scheme</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Interface to sender rewriting scheme">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Mail::SRS (3pm) manual">
  <meta name="twitter:description" content="Interface to sender rewriting scheme">
  <meta name="twitter:image" content="https://www.carta.tech/images/libmail-srs-perl-Mail::SRS-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Mail::SRS.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Mail::SRS (3pm) manual" />
  <meta property="og:description" content="Interface to sender rewriting scheme" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libmail-srs-perl-Mail::SRS-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Mail::SRS<small> (3pm)</small></h1>
        <p class="lead">Interface to sender rewriting scheme</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Mail::SRS.3pm.html">
      <span itemprop="name">Mail::SRS: Interface to sender rewriting scheme</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libmail-srs-perl/">
      <span itemprop="name">libmail-srs-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Mail::SRS.3pm.html">
      <span itemprop="name">Mail::SRS: Interface to sender rewriting scheme</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
        use Mail::SRS;
        my $srs = new Mail::SRS(
                Secret     =&gt; [ .... ],    # scalar or array
                MaxAge     =&gt; 49,          # days
                HashLength =&gt; 4,           # base64 characters: 4 x 6bits
                HashMin    =&gt; 4,           # base64 characters
                        );
        my $srsaddress = $srs-&gt;forward($sender, $alias);
        my $sender = $srs-&gt;reverse($srsaddress);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The Sender Rewriting Scheme preserves .forward functionality in an SPF-compliant world.</p><p>\s-1SPF\s0 requires the \s-1SMTP\s0 client \s-1IP\s0 to match the envelope sender (return-path). When a message is forwarded through an intermediate server, that intermediate server may need to rewrite the return-path to remain \s-1SPF\s0 compliant. If the message bounces, that intermediate server needs to validate the bounce and forward the bounce to the original sender.</p><p>\s-1SRS\s0 provides a convention for return-path rewriting which allows multiple forwarding servers to compact the return-path. \s-1SRS\s0 also provides an authentication mechanism to ensure that purported bounces are not arbitrarily forwarded.</p><p>\s-1SRS\s0 is documented at http://spf.pobox.com/srs.html and many points about the scheme are discussed at http://www.anarres.org/projects/srs/</p><p>For a better understanding of this code and how it functions, please read this document and run the interactive walkthrough in eg/simple.pl in this distribution. To run this from the build directory, type \*(L"make teach\*(R".</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">
<p>Construct a new Mail::SRS object and return it. Available parameters are: A key for the cryptographic algorithms. This may be an array or a single string. A string is promoted into an array of one element.</p>
<dl class='dl-vertical'>
  <dt>
    MaxAge
  </dt>
  <dd>
    <p>The maximum number of days for which a timestamp is considered valid. After this time, the timestamp is invalid. The number of bytes of base64 encoded data to use for the cryptographic hash. More is better, but makes for longer addresses which might exceed the 64 character length suggested by \s-1RFC2821\s0. This defaults to 4, which gives 4 x 6 = 24 bits of cryptographic information, which means that a spammer will have to make 2^24 attempts to guarantee forging an \s-1SRS\s0 address. The shortest hash which we will allow to pass authentication. Since we allow any valid prefix of the full \s-1SHA1\s0 \s-1HMAC\s0 to pass authentication, a spammer might just suggest a hash of length 0. We require at least HashMin characters, which must all be correct. Naturally, this must be no greater than HashLength and will default to HashLength unless otherwise specified. Specify the initial separator to use immediately after the \s-1SRS\s0 tag. \s-1SRS\s0 uses the = separator throughout \s-1EXCEPT\s0 for the initial separator, which may be any of + - or =. Some MTAs already have a feature by which text after a + or - is ignored for the purpose of identifying a local recipient. If the initial separator is set to + or -, then an administrator may process all \s-1SRS\s0 mails by creating users \s-1SRS0\s0 and \s-1SRS1\s0, and using Mail::SRS in the default delivery rule for these users. Some notes on the use and preservation of these separators are found in the perldoc for Mail::SRS::Guarded. \s-1SRS\s0 rewriting is not performed by default if the alias host matches the sender host, since it would be unnecessary to do so, and it interacts badly with ezmlm if we do. Set this to true if you want always to rewrite when requested to do so. Consider all timestamps to be valid. Defaults to false. It is \s-1STRONGLY\s0 recommended that this remain false. This parameter is provided so that timestamps may be ignored temporarily after a change in the timestamp format or encoding, until all timestamps in the old encoding would have become invalid. Note that timestamps still form a part of the cryptographic data when this is enabled.</p>
  </dd>
  <dt>
    AllowUnsafeSrs
  </dt>
  <dd>
    <p>This is a backwards compatibility option for an older version of the protocol where \s-1SRS1\s0 was not hash-protected. The 'reverse' method will detect such addresses, and handle them properly. Deployments upgrading from version &lt;=0.27 to any version &gt;=0.28 should enable this for MaxAge+1 days. When this option is enabled, all new addresses will be generated with cryptographic protection.</p>
  </dd>

</dl>
<p>Some subclasses require other parameters. See their documentation for details. Map a sender address into a new sender and a cryptographic cookie. Returns an \s-1SRS\s0 address to use as the new sender.</p><p>There are alternative subclasses, some of which will return \s-1SRS\s0 compliant addresses, some will simply return non-SRS but valid \s-1RFC821\s0 addresses. See the interactive walkthrough for more information on this (\*(L"make teach\*(R"). Reverse the mapping to get back the original address. Validates all cryptographic and timestamp information. Returns the original sender address. This method will die if the address cannot be reversed. This method, designed to be overridden by subclasses, takes as parameters the original host and user and must compile a new username for the \s-1SRS\s0 transformed address. It is expected that this new username will be joined on $SRSSEP, and will contain a hash generated from $self-&gt;hash_create(...), and possibly a timestamp generated by $self-&gt;<em>timestamp_create()</em>. This method, designed to be overridden by subclasses, takes an SRS-transformed username as an argument, and must reverse the transformation produced by <em>compile()</em>. It is required to verify any hash and timestamp in the parsed data, using $self-&gt;hash_verify($hash, ...) and $self-&gt;timestamp_check($timestamp). Return a two character timestamp representing 'today', or $time if given. $time is a Unix timestamp (seconds since the aeon).</p><p>This Perl function has been designed to be agnostic as to base, and in practice, base32 is used since it can be reversed even if a remote \s-1MTA\s0 smashes case (in violation of \s-1RFC2821\s0 section 2.4). The agnosticism means that the Perl uses division instead of rightshift, but in Perl that doesn't matter. C implementors should implement this operation as a right shift by 5. Return 1 if a timestamp is valid, undef otherwise. There are 4096 possible timestamps, used in a cycle. At any time, $srs-&gt;{MaxAge} timestamps in this cycle are valid, the last one being today. A timestamp from the future is not valid, neither is a timestamp from too far into the past. Of course if you go far enough into the future, the cycle wraps around, and there are valid timestamps again, but the likelihood of a random timestamp being valid is 4096/$srs-&gt;{MaxAge}, which is usually quite small: 1 in 132 by default. Similar to $srs-&gt;timestamp_check($timestamp), but takes a Unix time, and checks that an alias created at that Unix time is still valid. This is designed for use by subclasses with storage backends. Returns a cryptographic hash of all data in @data. Any piece of data encoded into an address which must remain inviolate should be hashed, so that when the address is reversed, we can check that this data has not been tampered with. You must provide at least one piece of data to this method (otherwise this system is both cryptographically weak and there may be collision problems with sender addresses). Verify that @data has not been tampered with, given the cryptographic hash previously output by $srs-&gt;<em>hash_create()</em>; Returns 1 or undef. All known secrets are tried in order to see if the hash was created with an old secret. Add a new secret to the rewriter. When an address is returned, all secrets are tried to see if the hash can be validated. Don't use \*(L"foo\*(R", \*(L"secret\*(R", \*(L"password\*(R", \*(L"10downing\*(R", \*(L"god\*(R" or \*(L"wednesday\*(R" as your secret. Return the list of secrets. These are secret. Don't publish them. Return the initial separator, which follows the \s-1SRS\s0 tag. This is only used as the initial separator, for the convenience of administrators who wish to make srs0 and srs1 users on their mail servers and require to use + or - as the user delimiter. All other separators in the \s-1SRS\s0 address must be \*(C`=\*(C'.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">
<p>Given :all, this module exports the following variables. The \s-1SRS\s0 separator. The choice of \*(C`=\*(C' as internal separator was fairly arbitrary. It cannot be any of the following:</p>
<dl class='dl-vertical'>
  <dt>
    / +
  </dt>
  <dd>
    <p>Used in Base64.</p>
  </dd>
  <dt>
    -
  </dt>
  <dd>
    <p>Used in domains.</p>
  </dd>
  <dt>
    ! %
  </dt>
  <dd>
    <p>Used in bang paths and source routing.</p>
  </dd>
  <dt>
    :
  </dt>
  <dd>
    <p>Cannot be used in a Windows \s-1NT\s0 or Apple filename.</p>
  </dd>
  <dt>
    ; | *
  </dt>
  <dd>
    <p>Shell or regular expression metacharacters are probably to be avoided.</p>
  </dd>

</dl>
<p>The \s-1SRS0\s0 tag. The \s-1SRS1\s0 tag. Deprecated, equal to $SRS0TAG. Deprecated, equal to $SRS1TAG. The default hash length for the \s-1SRS\s0 \s-1HMAC\s0. The default expiry time for timestamps.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES OF USAGE</h2>
        <div class="sectioncontent">
<p>For people wanting boilerplate and those less familiar with using Perl modules in larger applications.</p><h3>Forward Rewriting</h3>
<p>        my $srs = new Mail::SRS(...);         my $address = ...         my $domain = ...         my $srsaddress = eval { $srs-&gt;forward($srsaddress, $domain); };         if ($@) {                 # The rewrite failed         }         else {                 # The rewrite succeeded         }</p>
<h3>Reverse Rewriting</h3>
<p>        my $srs = new Mail::SRS(...);         my $srsaddress = ...         my $address = eval { $srs-&gt;reverse($srsaddress); };         if ($@) {                 # The rewrite failed         }         else {                 # The rewrite succeeded         }</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTES ON SRS</h2>
        <div class="sectioncontent">
<h3>Case Sensitivity</h3>
<p>\s-1RFC2821\s0 states in section 2.4: \*(L"The local-part of a mailbox \s-1MUST\s0 \s-1BE\s0 treated as case sensitive. Therefore, \s-1SMTP\s0 implementations \s-1MUST\s0 take care to preserve the case of mailbox local-parts. [...]  In particular, for some hosts the user \*(R"smith\*(L" is different from the user \*(R"Smith\*(L". However, exploiting the case sensitivity of mailbox local-parts impedes interoperability and is discouraged.\*(R"</p><p>\s-1SRS\s0 does not rely on case sensitivity in the local part. It uses base64 for encoding the hash, but allows a case insensitive match, making this approximately equivalent to base36 at worst. It will issue a warning if it detects that a remote \s-1MTA\s0 has smashed case. The timestamp is encoded in base32.</p>
<h3>The 64 Billion Character Question</h3>
<p>\s-1RFC2821\s0 section 4.5.3.1: Size limits and minimums:</p><p>        There are several objects that have required minimum/maximum         sizes.  Every implementation MUST be able to receive objects         of at least these sizes. Objects larger than these sizes         SHOULD be avoided when possible. However, some Internet         mail constructs such as encoded X.400 addresses [16] will         often require larger objects: clients MAY attempt to transmit         these, but MUST be prepared for a server to reject them if         they cannot be handled by it. To the maximum extent possible,         implementation techniques which impose no limits on the length         of these objects should be used.</p><p>        local-part                 The maximum total length of a user name or other                 local-part is 64 characters.</p><p>Clearly, by including 2 domain names and a local-part in the rewritten address, there is no way in which \s-1SRS\s0 can guarantee to stay under this limit. However, very few systems are known to actively enforce this limit, and those which become known to the developers will be listed here.</p>
<dl class='dl-vertical'>
  <dt>
    Cisco: \s-1PIX\s0 MailGuard (firewall gimmick)
  </dt>
  <dd>
    
  </dd>
  <dt>
    WebShield [something] (firewall gimmick)
  </dt>
  <dd>
    
  </dd>

</dl>

<h3>Invalid \s-1SRS\s0 Addresses</h3>
<p>\s-1DO\s0 \s-1NOT\s0 \s-1MALFORMAT\s0 \s-1ADDRESSES\s0. This is designed to be an interoperable format. Certain things are allowed, such as changing the semantics of the hash or the timestamp. However, both of these fields must be present and separated by the \s-1SRS\s0 separator character \*(C`=\*(C'. The purpose of this section is to illustrate that if a malicious party were to malformat an address, he would gain nothing by doing so, nor would the network suffer.</p><p>The \s-1SRS\s0 protocol is predicated on the fact that the first forwarder provides a cryptographic wrapper on the forward chain for sending mail to the original sender. So what happens if an \s-1SRS\s0 address is invalid, or faked by a spammer?</p><p>The minimum parsing of existing \s-1SRS\s0 addresses is done at each hop. If an \s-1SRS0\s0 address is not valid or badly formatted, it will not affect the operation of the system: the mail will go out along the forwarder chain, and return to the invalid or badly formatted address.</p><p>If the spammer is not pretending to be the first hop, then he must somehow construct an \s-1SRS0\s0 address to embed within his \s-1SRS1\s0 address. The cryptographic checks on this \s-1SRS0\s0 address will fail at the first forwarder and the mail will be dropped.</p><p>If the spammer is pretending to be the first hop, then \s-1SPF\s0 should require that any bounces coming back return to his mail server, thus he wins nothing.</p>
<h3>Cryptographic Systems</h3>
<p>The hash in the address is designed to prevent the forging of reverse addresses by a spammer, who might then use the \s-1SRS\s0 host as a forwarder. It may only be constructed or validated by a party who knows the secret key.</p><p>The cryptographic system in the default implementation is not mandated. Since nobody else ever needs to interpret the hash, it is reasonable to put any binary data into this field (subject to the possible constraint of case insensitive encoding).</p><p>The \s-1SRS\s0 maintainers have attempted to provide a good system. It satisfies a simple set of basic requirements: to provide unforgeability of \s-1SRS\s0 addresses given that every \s-1MTA\s0 for a domain shares a secret key. We prefer \s-1SHA1\s0 over \s-1MD5\s0 for political, rather than practical reasons. (Anyone disputing this statement must include an example of a practical weakness in their mail. We would love to see it.)</p><p>If you find a weakness in our system, or you think you know of a better system, please tell us. If your requirements are different, you may override <em>hash_create()</em> and <em>hash_verify()</em> to implement a different system without adversely impacting the network, as long as your addresses still behave as \s-1SRS\s0 addresses.</p>
<h3>Extending Mail::SRS</h3>
<p>Write a subclass. You will probably want to override <em>compile()</em> and <em>parse()</em>. If you are more familiar with the internals of \s-1SRS\s0, you might want to override <em>hash_create()</em>, <em>hash_verify()</em>, <em>timestamp_create()</em> or <em>timestamp_check()</em>.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CHANGELOG</h2>
        <div class="sectioncontent">
<h3>\s-1MINOR\s0 \s-1CHANGES\s0 since v0.29</h3>

<dl class='dl-vertical'>
  <dt>
    timestamp_check now explicitly smashes case when verifying. This means that the base used must be base32, \s-1NOT\s0 base64.
  </dt>
  <dd>
    
  </dd>
  <dt>
    hash_create and hash_verify now explicitly smash case when creating and verifying hashes. This does not have a significant cryptographic impact.
  </dt>
  <dd>
    
  </dd>

</dl>

<h3>\s-1MAJOR\s0 \s-1CHANGES\s0 since v0.27</h3>

<dl class='dl-vertical'>
  <dt>
    The \s-1SRS1\s0 address format has changed to include cryptographic information. Existing deployments should consider setting AllowUnsafeSrs for MaxAge+1 days.
  </dt>
  <dd>
    
  </dd>

</dl>

<h3>\s-1MINOR\s0 \s-1CHANGES\s0 since v0.26</h3>

<dl class='dl-vertical'>
  <dt>
    <em>parse()</em> and <em>compile()</em> are explicitly specified to <em>die()</em> on error.
  </dt>
  <dd>
    
  </dd>

</dl>

<h3>\s-1MINOR\s0 \s-1CHANGES\s0 since v0.23</h3>

<dl class='dl-vertical'>
  <dt>
    Update \s-1BASE32\s0 according to \s-1RFC3548\s0.
  </dt>
  <dd>
    
  </dd>

</dl>

<h3>\s-1MINOR\s0 \s-1CHANGES\s0 since v0.21</h3>

<dl class='dl-vertical'>
  <dt>
    Dates are now encoded in base32.
  </dt>
  <dd>
    
  </dd>
  <dt>
    Case insensitive \s-1MAC\s0 validation is now allowed, but will issue a warning.
  </dt>
  <dd>
    
  </dd>

</dl>

<h3>\s-1MINOR\s0 \s-1CHANGES\s0 since v0.18</h3>

<dl class='dl-vertical'>
  <dt>
    Mail::SRS::Reversable is now Mail::SRS::Reversible
  </dt>
  <dd>
    <p>This should not be a problem since people should not be using it!</p>
  </dd>

</dl>
<p>You must use $SRS0RE and $SRS1RE to detect \s-1SRS\s0 addresses.</p>
<h3>\s-1MAJOR\s0 \s-1CHANGES\s0 since v0.15</h3>

<dl class='dl-vertical'>
  <dt>
    The cryptographic scheme is now \s-1HMAC\s0 with \s-1SHA1\s0.
  </dt>
  <dd>
    
  </dd>
  <dt>
    Only a prefix of the \s-1MAC\s0 is used.
  </dt>
  <dd>
    
  </dd>

</dl>
<p>This \s-1API\s0 is still a release candidate and should remain relatively stable.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>Email address parsing for quoted addresses is not yet done properly.</p><p>Case insensitive \s-1MAC\s0 validation should become an option.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TODO</h2>
        <div class="sectioncontent">
<p>Write a testsuite for testing user-defined \s-1SRS\s0 implementations.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Mail::SRS&hellip;</h2>
        <div class="sectioncontent">
<p>Mail::SRS::Guarded, Mail::SRS::DB, Mail::SRS::Reversable, \*(L"make teach\*(R", eg/*, http://www.anarres.org/projects/srs/</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>        Shevek         CPAN ID: SHEVEK         cpan@anarres.org         http://www.anarres.org/projects/</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright (c) 2004 Shevek. All rights reserved.</p><p>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Mail::RFC822::Address.3pm.html"><span aria-hidden="true">&larr;</span> Mail::RFC822::Address.3pm: Perl extension for validating email addresses according to rfc822</a></li>
   <li class="next"><a href="Mail::SRS::DB.3pm.html">Mail::SRS::DB.3pm: A mldbm based sender rewriting scheme <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

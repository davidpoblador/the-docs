<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SoShape: The soshape class is the superclass for geometry shapes.  the node types which have actual geometry to render inherits this class. for convenience, the soshape class contains various common code used by the subclasses.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The soshape class is the superclass for geometry shapes.  the node types which have actual geometry to render inherits this class. for convenience, the soshape class contains various common code used by the subclasses.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="SoShape (3) manual">
  <meta name="twitter:description" content="The soshape class is the superclass for geometry shapes.  the node types which have actual geometry to render inherits this class. for convenience, the soshape class contains various common code used by the subclasses.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcoin80-doc-SoShape-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/SoShape.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="SoShape (3) manual" />
  <meta property="og:description" content="The soshape class is the superclass for geometry shapes.  the node types which have actual geometry to render inherits this class. for convenience, the soshape class contains various common code used by the subclasses." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcoin80-doc-SoShape-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">SoShape<small> (3)</small></h1>
        <p class="lead">The soshape class is the superclass for geometry shapes.  the node types which have actual geometry to render inherits this class. for convenience, the soshape class contains various common code used by the subclasses.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoShape.3.html">
      <span itemprop="name">SoShape: The soshape class is the superclass for geometry shapes.  the node types which have actual geometry to render inherits this class. for convenience, the soshape class contains various common code used by the subclasses.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcoin80-doc/">
      <span itemprop="name">libcoin80-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoShape.3.html">
      <span itemprop="name">SoShape: The soshape class is the superclass for geometry shapes.  the node types which have actual geometry to render inherits this class. for convenience, the soshape class contains various common code used by the subclasses.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;Inventor/nodes/SoShape.h&gt;</p><p>Inherits <strong>SoNode</strong>.</p><p>Inherited by <strong>SoAsciiText</strong>, <strong>SoCone</strong>, <strong>SoCube</strong>, <strong>SoCylinder</strong>, <strong>SoImage</strong>, <strong>SoIndexedNurbsCurve</strong>, <strong>SoIndexedNurbsSurface</strong>, <strong>SoNurbsCurve</strong>, <strong>SoNurbsSurface</strong>, <strong>SoSphere</strong>, <strong>SoText2</strong>, <strong>SoText3</strong>, <strong>SoVertexShape</strong>, and <strong>SoVRMLGeometry</strong>.</p><h3>Public Types</h3>
<p>enum <strong>TriangleShape</strong> { <strong>TRIANGLE_STRIP</strong>, <strong>TRIANGLE_FAN</strong>, <strong>TRIANGLES</strong>, <strong>POLYGON</strong>, <strong>QUADS</strong>, <strong>QUAD_STRIP</strong>, <strong>POINTS</strong>, <strong>LINES</strong>, <strong>LINE_STRIP</strong> }</p>
<h3>Public Member Functions</h3>
<p>virtual <strong>SoType</strong> <strong>getTypeId</strong> (void) const </p><p><em>Returns the type identification of an object derived from a class inheriting </em><strong>SoBase</strong><em>. This is used for run-time type checking and 'downward' casting. </em><strong></strong> virtual SbBool <strong>affectsState</strong> (void) const </p><p>virtual void <strong>notify</strong> (<strong>SoNotList</strong> *nl)</p><p>virtual void <strong>getBoundingBox</strong> (<strong>SoGetBoundingBoxAction</strong> *action)</p><p>virtual void <strong>GLRender</strong> (<strong>SoGLRenderAction</strong> *action)</p><p>virtual void <strong>rayPick</strong> (<strong>SoRayPickAction</strong> *action)</p><p>virtual void <strong>callback</strong> (<strong>SoCallbackAction</strong> *action)</p><p>virtual void <strong>computeBBox</strong> (<strong>SoAction</strong> *action, <strong>SbBox3f</strong> &box, <strong>SbVec3f</strong> &center)=0</p><p>virtual void <strong>getPrimitiveCount</strong> (<strong>SoGetPrimitiveCountAction</strong> *action)</p><p>const <strong>SoBoundingBoxCache</strong> * <strong>getBoundingBoxCache</strong> (void) const </p>
<h3>Static Public Member Functions</h3>
<p>static <strong>SoType</strong> <strong>getClassTypeId</strong> (void)</p><p>static void <strong>initClass</strong> (void)</p><p>static void <strong>getScreenSize</strong> (<strong>SoState</strong> *const state, const <strong>SbBox3f</strong> &boundingbox, <strong>SbVec2s</strong> &rectsize)</p><p>static float <strong>getDecimatedComplexity</strong> (<strong>SoState</strong> *state, float complexity)</p>
<h3>Protected Member Functions</h3>
<p>virtual const <strong>SoFieldData</strong> * <strong>getFieldData</strong> (void) const </p><p><strong>SoShape</strong> (void)</p><p>virtual <strong>~SoShape</strong> ()</p><p>float <strong>getComplexityValue</strong> (<strong>SoAction</strong> *action)</p><p>virtual void <strong>generatePrimitives</strong> (<strong>SoAction</strong> *action)=0</p><p>virtual SbBool <strong>shouldGLRender</strong> (<strong>SoGLRenderAction</strong> *action)</p><p>void <strong>beginSolidShape</strong> (<strong>SoGLRenderAction</strong> *action)</p><p>void <strong>endSolidShape</strong> (<strong>SoGLRenderAction</strong> *action)</p><p>void <strong>GLRenderBoundingBox</strong> (<strong>SoGLRenderAction</strong> *action)</p><p>SbBool <strong>shouldPrimitiveCount</strong> (<strong>SoGetPrimitiveCountAction</strong> *action)</p><p>SbBool <strong>shouldRayPick</strong> (<strong>SoRayPickAction</strong> *const action)</p><p>void <strong>computeObjectSpaceRay</strong> (<strong>SoRayPickAction</strong> *const action)</p><p>void <strong>computeObjectSpaceRay</strong> (<strong>SoRayPickAction</strong> *const action, const <strong>SbMatrix</strong> &matrix)</p><p>virtual <strong>SoDetail</strong> * <strong>createTriangleDetail</strong> (<strong>SoRayPickAction</strong> *action, const <strong>SoPrimitiveVertex</strong> *v1, const <strong>SoPrimitiveVertex</strong> *v2, const <strong>SoPrimitiveVertex</strong> *v3, <strong>SoPickedPoint</strong> *pp)</p><p>virtual <strong>SoDetail</strong> * <strong>createLineSegmentDetail</strong> (<strong>SoRayPickAction</strong> *action, const <strong>SoPrimitiveVertex</strong> *v1, const <strong>SoPrimitiveVertex</strong> *v2, <strong>SoPickedPoint</strong> *pp)</p><p>virtual <strong>SoDetail</strong> * <strong>createPointDetail</strong> (<strong>SoRayPickAction</strong> *action, const <strong>SoPrimitiveVertex</strong> *v, <strong>SoPickedPoint</strong> *pp)</p><p>void <strong>invokeTriangleCallbacks</strong> (<strong>SoAction</strong> *const action, const <strong>SoPrimitiveVertex</strong> *const v1, const <strong>SoPrimitiveVertex</strong> *const v2, const <strong>SoPrimitiveVertex</strong> *const v3)</p><p>void <strong>invokeLineSegmentCallbacks</strong> (<strong>SoAction</strong> *const action, const <strong>SoPrimitiveVertex</strong> *const v1, const <strong>SoPrimitiveVertex</strong> *const v2)</p><p>void <strong>invokePointCallbacks</strong> (<strong>SoAction</strong> *const action, const <strong>SoPrimitiveVertex</strong> *const v)</p><p>void <strong>beginShape</strong> (<strong>SoAction</strong> *const action, const <strong>TriangleShape</strong> shapetype, <strong>SoDetail</strong> *const detail=NULL)</p><p>void <strong>shapeVertex</strong> (const <strong>SoPrimitiveVertex</strong> *const v)</p><p>void <strong>endShape</strong> (void)</p><p>void <strong>generateVertex</strong> (<strong>SoPrimitiveVertex</strong> *const pv, const <strong>SbVec3f</strong> &point, const SbBool useTexFunc, const SoMultiTextureCoordinateElement *const tce, const float s, const float t, const <strong>SbVec3f</strong> &normal)</p><p>void <strong>generateVertex</strong> (<strong>SoPrimitiveVertex</strong> *const pv, const <strong>SbVec3f</strong> &point, const SbBool useTexFunc, const SoMultiTextureCoordinateElement *const tce, const float s, const float t, const float r, const <strong>SbVec3f</strong> &normal)</p><p>SbBool <strong>startVertexArray</strong> (<strong>SoGLRenderAction</strong> *action, const <strong>SoCoordinateElement</strong> *coords, const <strong>SbVec3f</strong> *pervertexnormals, const SbBool texpervertex, const SbBool colorpervertex)</p><p>void <strong>finishVertexArray</strong> (<strong>SoGLRenderAction</strong> *action, const SbBool vbo, const SbBool normpervertex, const SbBool texpervertex, const SbBool colorpervertex)</p>
<h3>Static Protected Member Functions</h3>
<p>static const <strong>SoFieldData</strong> ** <strong>getFieldDataPtr</strong> (void)</p>
<h3>Additional Inherited Members</h3>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>The <strong>SoShape</strong> class is the superclass for geometry shapes.</p><p>The node types which have actual geometry to render inherits this class. For convenience, the <strong>SoShape</strong> class contains various common code used by the subclasses.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Enumeration Documentation</h2>
        <div class="sectioncontent">
<h3>enum \fBSoShape::TriangleShape\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>SoShape::SoShape (void)\fC [protected]\fP</h3>
<p>Constructor.</p>
<h3>SoShape::~SoShape ()\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Destructor.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>\fBSoType\fP SoShape::getTypeId (void) const\fC [virtual]\fP</h3>
<p>Returns the type identification of an object derived from a class inheriting <strong>SoBase</strong>. This is used for run-time type checking and 'downward' casting. Usage example:</p>
<pre>
void foo(SoNode * node)
{
  if (node-&gt;getTypeId() == SoFile::getClassTypeId()) {
    SoFile * filenode = (SoFile *)node;  // safe downward cast, knows the type
  }
}
</pre>
<p>For application programmers wanting to extend the library with new nodes, engines, nodekits, draggers or others: this method needs to be overridden in <em>all</em> subclasses. This is typically done as part of setting up the full type system for extension classes, which is usually accomplished by using the pre-defined macros available through for instance <strong>Inventor/nodes/SoSubNode.h</strong> (SO_NODE_INIT_CLASS and SO_NODE_CONSTRUCTOR for node classes), Inventor/engines/SoSubEngine.h (for engine classes) and so on.</p><p>For more information on writing Coin extensions, see the class documentation of the toplevel superclasses for the various class groups.</p><p>Implements <strong>SoBase</strong>.</p><p>Reimplemented in <strong>SoVertexShape</strong>, <strong>SoVRMLElevationGrid</strong>, <strong>SoVRMLVertexShape</strong>, <strong>SoImage</strong>, <strong>SoText3</strong>, <strong>SoVRMLIndexedFaceSet</strong>, <strong>SoIndexedFaceSet</strong>, <strong>SoIndexedLineSet</strong>, <strong>SoIndexedTriangleStripSet</strong>, <strong>SoVRMLIndexedLineSet</strong>, <strong>SoVRMLText</strong>, <strong>SoAsciiText</strong>, <strong>SoIndexedNurbsCurve</strong>, <strong>SoIndexedNurbsSurface</strong>, <strong>SoVRMLExtrusion</strong>, <strong>SoIndexedPointSet</strong>, <strong>SoNurbsCurve</strong>, <strong>SoNurbsSurface</strong>, <strong>SoCube</strong>, <strong>SoFaceSet</strong>, <strong>SoIndexedMarkerSet</strong>, <strong>SoIndexedShape</strong>, <strong>SoText2</strong>, <strong>SoVRMLVertexPoint</strong>, <strong>SoCone</strong>, <strong>SoCylinder</strong>, <strong>SoNonIndexedShape</strong>, <strong>SoVRMLCone</strong>, <strong>SoVRMLCylinder</strong>, <strong>SoVRMLGeometry</strong>, <strong>SoVRMLVertexLine</strong>, <strong>SoLineSet</strong>, <strong>SoMarkerSet</strong>, <strong>SoPointSet</strong>, <strong>SoQuadMesh</strong>, <strong>SoSphere</strong>, <strong>SoTriangleStripSet</strong>, <strong>SoVRMLBox</strong>, <strong>SoVRMLIndexedLine</strong>, <strong>SoVRMLIndexedShape</strong>, <strong>SoVRMLPointSet</strong>, and <strong>SoVRMLSphere</strong>.</p>
<h3>const \fBSoFieldData\fP * SoShape::getFieldData (void) const\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Returns a pointer to the class-wide field data storage object for this instance. If no fields are present, returns NULL.</p><p>Reimplemented from <strong>SoFieldContainer</strong>.</p><p>Reimplemented in <strong>SoVertexShape</strong>, <strong>SoVRMLElevationGrid</strong>, <strong>SoVRMLVertexShape</strong>, <strong>SoImage</strong>, <strong>SoText3</strong>, <strong>SoVRMLIndexedFaceSet</strong>, <strong>SoIndexedFaceSet</strong>, <strong>SoIndexedLineSet</strong>, <strong>SoIndexedTriangleStripSet</strong>, <strong>SoVRMLIndexedLineSet</strong>, <strong>SoVRMLText</strong>, <strong>SoAsciiText</strong>, <strong>SoIndexedNurbsCurve</strong>, <strong>SoIndexedNurbsSurface</strong>, <strong>SoVRMLExtrusion</strong>, <strong>SoIndexedPointSet</strong>, <strong>SoNurbsCurve</strong>, <strong>SoNurbsSurface</strong>, <strong>SoCube</strong>, <strong>SoFaceSet</strong>, <strong>SoIndexedMarkerSet</strong>, <strong>SoIndexedShape</strong>, <strong>SoText2</strong>, <strong>SoVRMLVertexPoint</strong>, <strong>SoCone</strong>, <strong>SoCylinder</strong>, <strong>SoNonIndexedShape</strong>, <strong>SoVRMLCone</strong>, <strong>SoVRMLCylinder</strong>, <strong>SoVRMLGeometry</strong>, <strong>SoVRMLVertexLine</strong>, <strong>SoLineSet</strong>, <strong>SoMarkerSet</strong>, <strong>SoPointSet</strong>, <strong>SoQuadMesh</strong>, <strong>SoSphere</strong>, <strong>SoTriangleStripSet</strong>, <strong>SoVRMLBox</strong>, <strong>SoVRMLIndexedLine</strong>, <strong>SoVRMLIndexedShape</strong>, <strong>SoVRMLPointSet</strong>, and <strong>SoVRMLSphere</strong>.</p>
<h3>SbBool SoShape::affectsState (void) const\fC [virtual]\fP</h3>
<p>Returns TRUE if the node could have any effect on the state during traversal.</p><p>If it returns FALSE, no data in the traversal-state will change from the pre-traversal state to the post-traversal state. The <strong>SoSeparator</strong> node will for instance return FALSE<strong>, as it pushes and pops the state before and after traversal of its children. All </strong><strong>SoShape</strong><strong> nodes will also return FALSE</strong><strong>, as just pushing out geometry data to the rendering engine won't affect the actual rendering state.</strong></p><p>The default method returns TRUE, on a 'better safe than sorry' philosophy.</p><p>Reimplemented from <strong>SoNode</strong>.</p>
<h3>void SoShape::notify (\fBSoNotList\fP *l)\fC [virtual]\fP</h3>
<p>Notifies all auditors for this instance when changes are made.</p><p>Reimplemented from <strong>SoNode</strong>.</p><p>Reimplemented in <strong>SoText3</strong>, <strong>SoImage</strong>, <strong>SoVRMLVertexShape</strong>, <strong>SoVRMLElevationGrid</strong>, <strong>SoAsciiText</strong>, <strong>SoVRMLExtrusion</strong>, <strong>SoVRMLText</strong>, <strong>SoVRMLIndexedLine</strong>, <strong>SoVRMLIndexedLineSet</strong>, <strong>SoIndexedLineSet</strong>, <strong>SoVertexShape</strong>, <strong>SoVRMLVertexPoint</strong>, <strong>SoVRMLGeometry</strong>, <strong>SoVRMLVertexLine</strong>, <strong>SoVRMLIndexedShape</strong>, and <strong>SoIndexedPointSet</strong>.</p>
<h3>void SoShape::getBoundingBox (\fBSoGetBoundingBoxAction\fP *action)\fC [virtual]\fP</h3>
<p>Action method for the <strong>SoGetBoundingBoxAction</strong>.</p><p>Calculates bounding box and center coordinates for node and modifies the values of the <em>action</em> to encompass the bounding box for this node and to shift the center point for the scene more towards the one for this node.</p><p>Nodes influencing how geometry nodes calculates their bounding box also overrides this method to change the relevant state variables.</p><p>Reimplemented from <strong>SoNode</strong>.</p><p>Reimplemented in <strong>SoVRMLVertexShape</strong>, <strong>SoIndexedNurbsCurve</strong>, <strong>SoNurbsCurve</strong>, <strong>SoVRMLIndexedLineSet</strong>, <strong>SoIndexedLineSet</strong>, <strong>SoVRMLVertexLine</strong>, <strong>SoVRMLVertexPoint</strong>, <strong>SoIndexedPointSet</strong>, <strong>SoLineSet</strong>, <strong>SoPointSet</strong>, and <strong>SoVRMLPointSet</strong>.</p>
<h3>void SoShape::GLRender (\fBSoGLRenderAction\fP *action)\fC [virtual]\fP</h3>
<p>Action method for the <strong>SoGLRenderAction</strong>.</p><p>This is called during rendering traversals. Nodes influencing the rendering state in any way or who wants to throw geometry primitives at OpenGL overrides this method.</p><p>Reimplemented from <strong>SoNode</strong>.</p><p>Reimplemented in <strong>SoMarkerSet</strong>, <strong>SoVRMLVertexShape</strong>, <strong>SoText3</strong>, <strong>SoImage</strong>, <strong>SoVRMLElevationGrid</strong>, <strong>SoCylinder</strong>, <strong>SoVRMLText</strong>, <strong>SoAsciiText</strong>, <strong>SoCone</strong>, <strong>SoIndexedNurbsSurface</strong>, <strong>SoVRMLExtrusion</strong>, <strong>SoNurbsSurface</strong>, <strong>SoText2</strong>, <strong>SoVRMLIndexedFaceSet</strong>, <strong>SoIndexedNurbsCurve</strong>, <strong>SoVRMLCylinder</strong>, <strong>SoCube</strong>, <strong>SoNurbsCurve</strong>, <strong>SoVRMLCone</strong>, <strong>SoIndexedFaceSet</strong>, <strong>SoIndexedLineSet</strong>, <strong>SoIndexedTriangleStripSet</strong>, <strong>SoVRMLIndexedLineSet</strong>, <strong>SoVRMLVertexLine</strong>, <strong>SoVRMLVertexPoint</strong>, <strong>SoFaceSet</strong>, <strong>SoIndexedMarkerSet</strong>, <strong>SoIndexedPointSet</strong>, <strong>SoLineSet</strong>, <strong>SoQuadMesh</strong>, <strong>SoPointSet</strong>, <strong>SoSphere</strong>, <strong>SoTriangleStripSet</strong>, <strong>SoVRMLBox</strong>, <strong>SoVRMLSphere</strong>, and <strong>SoVRMLPointSet</strong>.</p>
<h3>void SoShape::rayPick (\fBSoRayPickAction\fP *action)\fC [virtual]\fP</h3>
<p>Calculates picked point based on primitives generated by subclasses.</p><p>Reimplemented from <strong>SoNode</strong>.</p><p>Reimplemented in <strong>SoImage</strong>, <strong>SoVRMLElevationGrid</strong>, <strong>SoCone</strong>, <strong>SoCylinder</strong>, <strong>SoIndexedNurbsSurface</strong>, <strong>SoNurbsSurface</strong>, <strong>SoText2</strong>, <strong>SoIndexedNurbsCurve</strong>, <strong>SoVRMLCylinder</strong>, <strong>SoCube</strong>, <strong>SoNurbsCurve</strong>, <strong>SoVRMLCone</strong>, <strong>SoSphere</strong>, <strong>SoVRMLBox</strong>, and <strong>SoVRMLSphere</strong>.</p>
<h3>void SoShape::callback (\fBSoCallbackAction\fP *action)\fC [virtual]\fP</h3>
<p>Action method for <strong>SoCallbackAction</strong>.</p><p>Simply updates the state according to how the node behaves for the render action, so the application programmer can use the <strong>SoCallbackAction</strong> for extracting information about the scene graph.</p><p>Reimplemented from <strong>SoNode</strong>.</p><p>Reimplemented in <strong>SoVRMLVertexShape</strong>, <strong>SoVRMLVertexLine</strong>, and <strong>SoVRMLVertexPoint</strong>.</p>
<h3>void SoShape::computeBBox (\fBSoAction\fP *action, \fBSbBox3f\fP &box, \fBSbVec3f\fP &center)\fC [pure virtual]\fP</h3>
<p>Implemented by <strong>SoShape</strong> subclasses to let the <strong>SoShape</strong> superclass know the exact size and weighted center point of the shape's bounding box.</p><p>The bounding box and center point should be calculated and returned in the local coordinate system.</p><p>The method implements action behavior for shape nodes for <strong>SoGetBoundingBoxAction</strong>. It is invoked from <strong>SoShape::getBoundingBox()</strong>. (Subclasses should <em>not</em> override <strong>SoNode::getBoundingBox()</strong>.)</p><p>The <em>box</em> parameter sent in is guaranteed to be an empty box, while <em>center</em> is undefined upon function entry.</p><p>Implemented in <strong>SoImage</strong>, <strong>SoText3</strong>, <strong>SoVRMLElevationGrid</strong>, <strong>SoVRMLText</strong>, <strong>SoCylinder</strong>, <strong>SoIndexedNurbsSurface</strong>, <strong>SoCone</strong>, <strong>SoAsciiText</strong>, <strong>SoNurbsSurface</strong>, <strong>SoText2</strong>, <strong>SoIndexedNurbsCurve</strong>, <strong>SoVRMLVertexPoint</strong>, <strong>SoVRMLExtrusion</strong>, <strong>SoNurbsCurve</strong>, <strong>SoVRMLCylinder</strong>, <strong>SoCube</strong>, <strong>SoVRMLCone</strong>, <strong>SoFaceSet</strong>, <strong>SoQuadMesh</strong>, <strong>SoLineSet</strong>, <strong>SoIndexedShape</strong>, <strong>SoPointSet</strong>, <strong>SoSphere</strong>, <strong>SoTriangleStripSet</strong>, <strong>SoVRMLBox</strong>, <strong>SoVRMLSphere</strong>, <strong>SoVRMLIndexedShape</strong>, and <strong>SoVRMLIndexedLine</strong>.</p>
<h3>void SoShape::getPrimitiveCount (\fBSoGetPrimitiveCountAction\fP *action)\fC [virtual]\fP</h3>
<p>Action method for the <strong>SoGetPrimitiveCountAction</strong>.</p><p>Calculates the number of triangle, line segment and point primitives for the node and adds these to the counters of the <em>action</em>.</p><p>Nodes influencing how geometry nodes calculates their primitive count also overrides this method to change the relevant state variables.</p><p>Reimplemented from <strong>SoNode</strong>.</p><p>Reimplemented in <strong>SoMarkerSet</strong>, <strong>SoImage</strong>, <strong>SoText3</strong>, <strong>SoVRMLElevationGrid</strong>, <strong>SoCone</strong>, <strong>SoCylinder</strong>, <strong>SoIndexedNurbsSurface</strong>, <strong>SoVRMLText</strong>, <strong>SoAsciiText</strong>, <strong>SoVRMLExtrusion</strong>, <strong>SoNurbsSurface</strong>, <strong>SoText2</strong>, <strong>SoVRMLIndexedFaceSet</strong>, <strong>SoIndexedNurbsCurve</strong>, <strong>SoVRMLCylinder</strong>, <strong>SoVRMLVertexPoint</strong>, <strong>SoCube</strong>, <strong>SoNurbsCurve</strong>, <strong>SoVRMLCone</strong>, <strong>SoIndexedLineSet</strong>, <strong>SoFaceSet</strong>, <strong>SoIndexedFaceSet</strong>, <strong>SoIndexedTriangleStripSet</strong>, <strong>SoVRMLIndexedLineSet</strong>, <strong>SoIndexedPointSet</strong>, <strong>SoLineSet</strong>, <strong>SoPointSet</strong>, <strong>SoQuadMesh</strong>, <strong>SoSphere</strong>, <strong>SoVRMLBox</strong>, <strong>SoVRMLSphere</strong>, and <strong>SoTriangleStripSet</strong>.</p>
<h3>void SoShape::getScreenSize (\fBSoState\fP *conststate, const \fBSbBox3f\fP &boundingbox, \fBSbVec2s\fP &rectsize)\fC [static]\fP</h3>
<p>A convenience function that returns the size of a <em>boundingbox</em> projected onto the screen. Useful for SCREEN_SPACE<em> complexity geometry.</em></p>
<h3>float SoShape::getDecimatedComplexity (\fBSoState\fP *state, floatcomplexity)\fC [static]\fP</h3>
<p>Not implemented in Coin. Should probably have been private in TGS Inventor API.</p>
<h3>const \fBSoBoundingBoxCache\fP * SoShape::getBoundingBoxCache (void) const</h3>
<p>Return the bounding box cache for this shape. It might return NULL if no bounding box cache has been created. If not NULL, the caller must check if the cache is valid before using it. This can be done using <strong>SoCache::isValid()</strong>.</p><p>This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2.1 API.</p><p><strong>Since:</strong></p><p>Coin 2.0</p>
<h3>float SoShape::getComplexityValue (\fBSoAction\fP *action)\fC [protected]\fP</h3>
<p>Returns the complexity value to be used by subclasses. Considers complexity type. For OBJECT_SPACE complexity this will be a number between 0 and 1. For SCREEN_SPACE complexity it is a number from 0 and up.</p>
<h3>void SoShape::generatePrimitives (\fBSoAction\fP *action)\fC [protected]\fP, \fC [pure virtual]\fP</h3>
<p>The method implements action behavior for shape nodes for <strong>SoCallbackAction</strong>. It is invoked from <strong>SoShape::callback()</strong>. (Subclasses should <em>not</em> override <strong>SoNode::callback()</strong>.)</p><p>The subclass implementations uses the convenience methods <strong>SoShape::beginShape()</strong>, <strong>SoShape::shapeVertex()</strong>, and <strong>SoShape::endShape()</strong>, with <strong>SoDetail</strong> instances, to pass the primitives making up the shape back to the caller.</p><p>Implemented in <strong>SoImage</strong>, <strong>SoText3</strong>, <strong>SoVRMLElevationGrid</strong>, <strong>SoVRMLText</strong>, <strong>SoVRMLExtrusion</strong>, <strong>SoCylinder</strong>, <strong>SoIndexedNurbsSurface</strong>, <strong>SoAsciiText</strong>, <strong>SoCone</strong>, <strong>SoVRMLIndexedFaceSet</strong>, <strong>SoNurbsSurface</strong>, <strong>SoText2</strong>, <strong>SoIndexedNurbsCurve</strong>, <strong>SoIndexedFaceSet</strong>, <strong>SoNurbsCurve</strong>, <strong>SoVRMLCylinder</strong>, <strong>SoCube</strong>, <strong>SoIndexedTriangleStripSet</strong>, <strong>SoVRMLCone</strong>, <strong>SoFaceSet</strong>, <strong>SoIndexedPointSet</strong>, <strong>SoQuadMesh</strong>, <strong>SoVRMLIndexedLineSet</strong>, <strong>SoLineSet</strong>, <strong>SoPointSet</strong>, <strong>SoSphere</strong>, <strong>SoTriangleStripSet</strong>, <strong>SoVRMLBox</strong>, <strong>SoVRMLSphere</strong>, and <strong>SoVRMLPointSet</strong>.</p>
<h3>SbBool SoShape::shouldGLRender (\fBSoGLRenderAction\fP *action)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p><p>Reimplemented in <strong>SoVRMLVertexShape</strong>, <strong>SoVertexShape</strong>, <strong>SoVRMLVertexPoint</strong>, <strong>SoVRMLVertexLine</strong>, and <strong>SoVRMLGeometry</strong>.</p>
<h3>void SoShape::beginSolidShape (\fBSoGLRenderAction\fP *action)\fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>void SoShape::endSolidShape (\fBSoGLRenderAction\fP *action)\fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>void SoShape::GLRenderBoundingBox (\fBSoGLRenderAction\fP *action)\fC [protected]\fP</h3>
<p>Render a bounding box.</p>
<h3>SbBool SoShape::shouldPrimitiveCount (\fBSoGetPrimitiveCountAction\fP *action)\fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>SbBool SoShape::shouldRayPick (\fBSoRayPickAction\fP *constaction)\fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>void SoShape::computeObjectSpaceRay (\fBSoRayPickAction\fP *constaction)\fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>void SoShape::computeObjectSpaceRay (\fBSoRayPickAction\fP *constaction, const \fBSbMatrix\fP &matrix)\fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>\fBSoDetail\fP * SoShape::createTriangleDetail (\fBSoRayPickAction\fP *action, const \fBSoPrimitiveVertex\fP *v1, const \fBSoPrimitiveVertex\fP *v2, const \fBSoPrimitiveVertex\fP *v3, \fBSoPickedPoint\fP *pp)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Will create triangle detail for a <strong>SoPickedPoint</strong>. This method will only be called internally, when <strong>generatePrimitives()</strong> is used for picking (<strong>SoShape::rayPick()</strong> is not overridden).</p><p>This method returns NULL in Open Inventor, and subclasses will need to override this method to create details for a <strong>SoPickedPoint</strong>.</p><p>This is not necessary with Coin. Of course, if you choose to override it, it will work in the same way as Open Inventor.</p><p>For this to work, you must supply a face or line detail when generating primitives. If you supply NULL for the detail argument in <strong>SoShape::beginShape()</strong>, you'll have to override this method.</p><p>Reimplemented in <strong>SoText3</strong>, <strong>SoVRMLExtrusion</strong>, <strong>SoIndexedNurbsSurface</strong>, <strong>SoAsciiText</strong>, and <strong>SoNurbsSurface</strong>.</p>
<h3>\fBSoDetail\fP * SoShape::createLineSegmentDetail (\fBSoRayPickAction\fP *action, const \fBSoPrimitiveVertex\fP *v1, const \fBSoPrimitiveVertex\fP *v2, \fBSoPickedPoint\fP *pp)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Will create line detail for a <strong>SoPickedPoint</strong>. This method will only be called internally, when <strong>generatePrimitives()</strong> is used for picking (<strong>SoShape::rayPick()</strong> is not overridden).</p><p>This method returns NULL in Open Inventor, and subclasses will need to override this method to create details for a <strong>SoPickedPoint</strong>.</p><p>This is not necessary with Coin. Of course, if you choose to override it, it will work in the same way as Open Inventor.</p><p>For this to work, you must supply a face or line detail when generating primitives. If you supply NULL for the detail argument in <strong>SoShape::beginShape()</strong>, you'll have to override this method.</p><p>Reimplemented in <strong>SoIndexedNurbsCurve</strong>, and <strong>SoNurbsCurve</strong>.</p>
<h3>\fBSoDetail\fP * SoShape::createPointDetail (\fBSoRayPickAction\fP *action, const \fBSoPrimitiveVertex\fP *v, \fBSoPickedPoint\fP *pp)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Will create point detail for a <strong>SoPickedPoint</strong>. This method will only be called internally, when <strong>generatePrimitives()</strong> is used for picking (<strong>SoShape::rayPick()</strong> is not overridden).</p><p>This method returns NULL in Open Inventor, and subclasses will need to override this method to create details for a <strong>SoPickedPoint</strong>.</p><p>This is not necessary with Coin. Of course, if you choose to override it, it will work in the same way as Open Inventor.</p><p>For this to work, you must supply a point detail in the <strong>SoPrimitiveVertex</strong> in <strong>generatePrimitives()</strong>.</p>
<h3>void SoShape::invokeTriangleCallbacks (\fBSoAction\fP *constaction, const \fBSoPrimitiveVertex\fP *constv1, const \fBSoPrimitiveVertex\fP *constv2, const \fBSoPrimitiveVertex\fP *constv3)\fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>void SoShape::invokeLineSegmentCallbacks (\fBSoAction\fP *constaction, const \fBSoPrimitiveVertex\fP *constv1, const \fBSoPrimitiveVertex\fP *constv2)\fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>void SoShape::invokePointCallbacks (\fBSoAction\fP *constaction, const \fBSoPrimitiveVertex\fP *constv)\fC [protected]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>void SoShape::beginShape (\fBSoAction\fP *constaction, const \fBTriangleShape\fPshapetype, \fBSoDetail\fP *constdetail = \fCNULL\fP)\fC [protected]\fP</h3>
<p>This method is used to generate primitives for a shape. It's typically called from a node's <strong>generatePrimitives()</strong> method. If you have your own shape and want to write a <strong>generatePrimitives()</strong> method for that shape, it's probably a good idea to take a peek in the <strong>generatePrimitives()</strong> method for a similar shape in Coin.</p><p><strong>generatePrimitives()</strong> can contain several <strong>beginShape()</strong>/endShape() sequences. <strong>shapeVertex()</strong> is used for each vertex between <strong>beginShape()</strong> and <strong>endShape()</strong>. For instance, to generate primitives for a triangle you'd do something like this:</p>
<pre>
SoPrimitiveVertex vertex;

this-&gt;beginShape(action, SoShape::POLYGON);
vertex.setPoint(SbVec3f(0.0f, 0.0f, 0.0f));
this-&gt;shapeVertex(&vertex);
vertex.setPoint(SbVec3f(1.0f, 0.0f, 0.0f));
this-&gt;shapeVertex(&vertex);
vertex.setPoint(SbVec3f(1.0f, 1.0f, 0.0f));
this-&gt;shapeVertex(&vertex);
this-&gt;endShape();
</pre>
<p>Note that the <strong>SoPrimitiveVertex</strong> instance can simply be placed on the stack and not allocated. <strong>SoShape</strong> will copy the needed information when you call <strong>shapeVertex()</strong>.</p><p>Before calling <strong>shapeVertex()</strong>, you can set extra information for the <strong>SoPrimitiveVertex</strong>, including normal, material index, and texture coordinates.</p><p>This method is slightly different from its counterpart from the original Open Inventor library, as this method has an <strong>SoDetail</strong> as the last argument, and not an <strong>SoFaceDetail</strong>. This is because we accept more TriangleShape types, and the detail might be a <strong>SoFaceDetail</strong> or a <strong>SoLineDetail</strong>. There is no use sending in a <strong>SoPointDetail</strong>, as nothing will be done with it.</p>
<h3>void SoShape::shapeVertex (const \fBSoPrimitiveVertex\fP *constv)\fC [protected]\fP</h3>
<p>This method is used while generating primitives for a shape. See <strong>beginShape()</strong> for more details.</p><p><strong>See also:</strong></p><p><strong>beginShape()</strong>, <strong>endShape()</strong></p>
<h3>void SoShape::endShape (void)\fC [protected]\fP</h3>
<p>This method is used while generating primitives for a shape. See <strong>beginShape()</strong> for more details.</p><p><strong>See also:</strong></p><p><strong>beginShape()</strong>, <strong>shapeVertex()</strong></p>
<h3>void SoShape::generateVertex (\fBSoPrimitiveVertex\fP *constpv, const \fBSbVec3f\fP &point, const SbBoolusetexfunc, const SoMultiTextureCoordinateElement *consttce, const floats, const floatt, const \fBSbVec3f\fP &normal)\fC [protected]\fP</h3>
<p>Convenience function which sets up an <strong>SoPrimitiveVertex</strong>, and sends it using the <strong>SoShape::shapeVertex()</strong> function. 2D version</p>
<h3>void SoShape::generateVertex (\fBSoPrimitiveVertex\fP *constpv, const \fBSbVec3f\fP &point, const SbBoolusetexfunc, const SoMultiTextureCoordinateElement *consttce, const floats, const floatt, const floatr, const \fBSbVec3f\fP &normal)\fC [protected]\fP</h3>
<p>Convenience function which sets up an <strong>SoPrimitiveVertex</strong>, and sends it using the <strong>SoShape::shapeVertex()</strong> function. 3D version.</p><p>This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2.1 API.</p><p><strong>Since:</strong></p><p>Coin 2.0</p>
<h3>SbBool SoShape::startVertexArray (\fBSoGLRenderAction\fP *action, const \fBSoCoordinateElement\fP *coords, const \fBSbVec3f\fP *pervertexnormals, const SbBooltexpervertex, const SbBoolcolorpervertex)\fC [protected]\fP</h3>
<p>Convenience method that enables vertex arrays and/or VBOs Returns <em>TRUE</em> if VBO is used.</p><p><strong>See also:</strong></p><p><strong>finishVertexArray()</strong></p><p><strong>Since:</strong></p><p>Coin 3.0</p>
<h3>void SoShape::finishVertexArray (\fBSoGLRenderAction\fP *action, const SbBoolvbo, const SbBoolnormpervertex, const SbBooltexpervertex, const SbBoolcolorpervertex)\fC [protected]\fP</h3>
<p>Should be called after rendering with vertex arrays. This method will disable arrays and VBOs enabled in the <strong>startVertexArray()</strong> function.</p><p><strong>See also:</strong></p><p><strong>startVertexArray()</strong></p><p><strong>Since:</strong></p><p>Coin 3.0</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for Coin from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="SoShadowStyleElement.3.html"><span aria-hidden="true">&larr;</span> SoShadowStyleElement.3: The soshadowstyleelement class is yet to be documented.  fixme: write doc.</a></li>
   <li class="next"><a href="SoShapeHints.3.html">SoShapeHints.3: The soshapehints class is a node containing hints about how to render geometry.  the soshapehints node is used to set up clues to the rendering subsystem about how particular aspects of the subsequent geometry in the scene graph should be drawn. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ttb: A base for building trace tools for distributed systems.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="A base for building trace tools for distributed systems.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="ttb (3erl) manual">
  <meta name="twitter:description" content="A base for building trace tools for distributed systems.">
  <meta name="twitter:image" content="https://www.carta.tech/images/erlang-manpages-ttb-3erl.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3erl/ttb.3erl.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="ttb (3erl) manual" />
  <meta property="og:description" content="A base for building trace tools for distributed systems." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/erlang-manpages-ttb-3erl.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">ttb<small> (3erl)</small></h1>
        <p class="lead">A base for building trace tools for distributed systems.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/ttb.3erl.html">
      <span itemprop="name">ttb: A base for building trace tools for distributed systems.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/erlang-manpages/">
      <span itemprop="name">erlang-manpages</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/ttb.3erl.html">
      <span itemprop="name">ttb: A base for building trace tools for distributed systems.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The Trace Tool Builder <em>ttb</em> is a base for building trace tools for distributed systems.</p><p>When using <em>ttb</em>, <em>dbg</em> shall not be used in parallel.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">
<p><strong></strong> start_trace(Nodes, Patterns, FlagSpec, Opts) -&gt; Result</p><p>Types:</p><p>Result = see p/2</p><p>Nodes = see tracer/2</p><p>Patterns = [tuple()]</p><p>FlagSpec = {Procs, Flags}</p><p>Proc = see p/2</p><p>Flags = see p/2</p><p>Opts = see tracer/2</p><p>This function is a shortcut allowing to start a trace with one command. Each tuple in <em>Patterns</em> is converted to list which is in turn passed to <em>ttb:tpl</em>. The call:</p>
<pre>
ttb:start_trace([Node, OtherNode],
[{mod, foo, []}, {mod, bar, 2}],
{all, call},
[{file, File}, {handler,{fun myhandler/4, S}}])
</pre>

<pre>
ttb:start_trace([Node, OtherNode], [{file, File}, {handler,{fun myhandler/4, S}}]),
ttb:tpl(mod, foo, []),
ttb:tpl(mod, bar, 2, []),
ttb:p(all, call)
</pre>
<p><strong></strong> tracer() -&gt; Result</p><p>This is equivalent to <em>tracer(node())</em>.</p><p><strong></strong> tracer(Shortcut) -&gt; Result</p><p>Types:</p><p>Shortcut = shell | dbg</p><p><em>shell</em> is equivalent to <em>tracer(node(),[{file, {local, "ttb"}}, shell])</em>.</p><p><em>dbg</em> is equivalent to <em>tracer(node(),[{shell, only}])</em>.</p><p><strong></strong> tracer(Nodes) -&gt; Result</p><p>This is equivalent to <em>tracer(Nodes,[])</em>.</p><p><strong></strong> tracer(Nodes,Opts) -&gt; Result</p><p>Types:</p><p>Result = {ok, ActivatedNodes} | {error,Reason}</p><p>Nodes = atom() | [atom()] | all | existing | new</p><p>Opts = Opt | [Opt]</p><p>Opt = {file,Client} | {handler, FormatHandler} | {process_info,PI} | shell | {shell, ShellSpec} | {timer, TimerSpec} | {overload_check, {MSec, Module, Function}} | {flush, MSec} | resume | {resume, FetchTimeout}</p><p>TimerSpec = MSec | {MSec, StopOpts}</p><p>MSec = FetchTimeout = integer()</p><p>Module = Function = atom()</p><p>StopOpts = see stop/2</p><p>Client = File | {local, File}</p><p>File = Filename | Wrap</p><p>Filename = string()</p><p>Wrap = {wrap,Filename} | {wrap,Filename,Size,Count}</p><p>FormatHandler = See format/2</p><p>PI = true | false</p><p>ShellSpec = true | false | only</p><p>This function starts a file trace port on all given nodes and also points the system tracer for sequential tracing to the same port.</p><p>The given <em>Filename</em> will be prefixed with the node name. Default <em>Filename</em> is "ttb".</p><p><em>File={wrap,Filename,Size,Count}</em> can be used if the size of the trace logs must be limited. Default values are <em>Size=128*1024</em> and <em>Count=8</em>.</p><p>When tracing diskless nodes, <em>ttb</em> must be started from an external "trace control node" with disk access, and <em>Client</em> must be <em>{local, File}</em>. All trace information is then sent to the trace control node where it is written to file.</p><p>The <em>process_info</em> option indicates if process information should be collected. If <em>PI = true</em> (which is default), each process identifier <em>Pid</em> is replaced by a tuple <em>{Pid,ProcessInfo,Node}</em>, where <em>ProcessInfo</em> is the process' registered name its globally registered name, or its initial function. It is possible to turn off this functionality by setting <em>PI = false</em>.</p><p>The <em>{shell, ShellSpec}</em> option indicates that the trace messages should be printed on the console as they are received by the tracing process. This implies <em>{local, File}</em> trace client. If the ShellSpec is <em>only</em> (instead of <em>true</em>), no trace logs are stored.</p><p>The <em>shell</em> option is a shortcut for <em>{shell, true}</em>.</p><p>The <em>timer</em> option indicates that the trace should be automatically stopped after <em>MSec</em> milliseconds. <em>StopOpts</em> are passed to <em>ttb:stop/2</em> command if specified (default is <em>[]</em>). Note that the timing is approximate, as delays related to network communication are always present. The timer starts after <em>ttb:p/2</em> is issued, so you can set up your trace patterns before.</p><p>The <em>overload_check</em> option allows to enable overload checking on the nodes under trace. <em>Module:Function(check)</em> is performed each <em>MSec</em> milliseconds. If the check returns <em>true</em>, the tracing is disabled on a given node.</p><p><em>Module:Function</em> should be able to handle at least three atoms: <em>init</em>, <em>check</em> and <em>stop</em>. <em>init</em> and <em>stop</em> give the user a possibility to initialize and clean up the check environment.</p><p>When a node gets overloaded, it is not possible to issue <em>ttb:p</em> nor any command from the <em>ttb:tp</em> family, as it would lead to inconsistent tracing state (different trace specifications on different node).</p><p>The <em>flush</em> option periodically flushes all file trace port clients (see <em>dbg:flush_trace_port/1</em>). When enabled, the buffers are freed each <em>MSec</em> milliseconds. This option is not allowed with <em>{file, {local, File}}</em> tracing.</p><p><em>{resume, FetchTimeout}</em> enables the autoresume feature. Whenever enabled, remote nodes try to reconnect to the controlling node in case they were restarted. The feature requires <em>runtime_tools</em> application to be started (so it has to be present in the <em>.boot</em> scripts if the traced nodes run with embedded erlang). If this is not possible, resume may be performed manually by starting <em>runtime_tools</em> remotely using <em>rpc:call/4</em>.</p><p><em>ttb</em> tries to fetch all logs from a reconnecting node before reinitializing the trace. This has to finish within FetchTimeout milliseconds or is aborted</p><p>By default, autostart information is stored in a file called <em>ttb_autostart.bin</em> on each node. If this is not desired (i.e. on diskless nodes), a custom module to handle autostart information storage and retrieval can be provided by specifying <em>ttb_autostart_module</em> environment variable for the <em>runtime_tools</em> application. The module has to respond to the following API:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>write_config(Data) -&gt; ok</em>: Store the provided data for further retrieval. It is important to realize that the data storage used must not be affected by the node crash.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>read_config() -&gt; {ok, Data} | {error, Error}</em>: Retrieve configuration stored with <em>write_config(Data)</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>delete_config() -&gt; ok</em>: Delete configuration stored with <em>write_config(Data)</em>. Note that after this call any subsequent calls to <em>read_config</em> must return <em>{error, Error}</em>.</p>
  </dd>

</dl>
<p>The <em>resume</em> option implies the default <em>FetchTimeout</em>, which is 10 seconds</p><p><strong></strong> p(Procs,Flags) -&gt; Return</p><p>Types:</p><p>Return = {ok,[{Procs,MatchDesc}]}</p><p>Procs = Process | [Process] | all | new | existing</p><p>Process = pid() | atom() | {global,atom()}</p><p>Flags = Flag | [Flag]</p><p>This function sets the given trace flags on the given processes. The <em>timestamp</em> flag is always turned on.</p><p>Please turn to the Reference manual for module <em>dbg</em> for details about the possible trace flags. The parameter <em>MatchDesc</em> is the same as returned from <em>dbg:p/2</em></p><p>Processes can be given as registered names, globally registered names or process identifiers. If a registered name is given, the flags are set on processes with this name on all active nodes.</p><p>Issuing this command starts the timer for this trace if <em>timer</em> option was specified with <em>tracer/2</em>.</p><p><strong></strong> tp, tpl, ctp, ctpl, ctpg</p><p>These functions should be used in combination with the <em>call</em> trace flag for setting and clearing trace patterns. When the <em>call</em> trace flag is set on a process, function calls will be traced on that process if a trace pattern has been set for the called function. Trace patterns specifies how to trace a function by using match specifications. Match specifications are described in the User's Guide for the erlang runtime system <em>erts</em>.</p><p>These functions are equivalent to the corresponding functions in <em>dbg</em>, but all calls are stored in the history. The history buffer makes it easy to create config files so that the same trace environment can be setup several times, e.g. if you want to compare two test runs. It also reduces the amount of typing when using <em>ttb</em> from the erlang shell.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>tp</em>: Set trace pattern on global function calls</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>tpl</em>: Set trace pattern on local and global function calls</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>ctp</em>: Clear trace pattern on local and global function calls</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>ctpl</em>: Clear trace pattern on local function calls</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>ctpg</em>: Clear trace pattern on global function calls</p>
  </dd>

</dl>
<p>With <em>tp</em> and <em>tpl</em> one of match specification shortcuts may be used (example: <em>ttb:tp(foo_module, caller)</em>). The shortcuts are:</p><p><strong></strong> list_history() -&gt; History</p><p>Types:</p><p>History = [{N,Func,Args}]</p><p>All calls to <em>ttb</em> is stored in the history. This function returns the current content of the history. Any entry can be re-executed with <em>run_history/1</em> or stored in a config file with <em>write_config/2/3</em>.</p><p><strong></strong> run_history(N) -&gt; ok | {error, Reason}</p><p>Types:</p><p>N = integer() | [integer()]</p><p>Executes the given entry or entries from the history list. History can be listed with <em>list_history/0</em>.</p><p><strong></strong> write_config(ConfigFile,Config)</p><p>Equivalent to <em>write_config(ConfigFile,Config,[])</em>.</p><p><strong></strong> write_config(ConfigFile,Config,Opts) -&gt; ok | {error,Reason}</p><p>Types:</p><p>ConfigFile = string()</p><p>Config = all | [integer()] | [{Mod,Func,Args}]</p><p>Mod = atom()</p><p>Func = atom()</p><p>Args = [term()]</p><p>Opts = Opt | [Opt]</p><p>Opt = append</p><p>This function creates or extends a config file which can be used for restoring a specific configuration later.</p><p>The content of the config file can either be fetched from the history or given directly as a list of <em>{Mod,Func,Args}</em>.</p><p>If the complete history is to be stored in the config file <em>Config</em> should be <em>all</em>. If only a selected number of entries from the history should be stored, <em>Config</em> should be a list of integers pointing out the entries to be stored.</p><p>If <em>Opts</em> is not given or if it is <em>[]</em>, <em>ConfigFile</em> is deleted and a new file is created. If <em>Opts = [append]</em>, <em>ConfigFile</em> will not be deleted. The new information will be appended at the end of the file.</p><p><strong></strong> run_config(ConfigFile) -&gt; ok | {error,Reason}</p><p>Types:</p><p>ConfigFile = string()</p><p>Executes all entries in the given config file. Note that the history of the last trace is always available in the file named <em>ttb_last_config</em>.</p><p><strong></strong> run_config(ConfigFile,NumList) -&gt; ok | {error,Reason}</p><p>Types:</p><p>ConfigFile = string()</p><p>NumList = [integer()]</p><p>Executes selected entries from the given config file. <em>NumList</em> is a list of integers pointing out the entries to be executed.</p><p>The content of a config file can be listed with <em>list_config/1</em>.</p><p>Note that the history of the last trace is always available in the file named <em>ttb_last_config</em>.</p><p><strong></strong> list_config(ConfigFile) -&gt; Config | {error,Reason}</p><p>Types:</p><p>ConfigFile = string()</p><p>Config = [{N,Func,Args}]</p><p>Lists all entries in the given config file.</p><p><strong></strong> write_trace_info(Key,Info) -&gt; ok</p><p>Types:</p><p>Key = term()</p><p>Info = Data | fun() -&gt; Data</p><p>Data = term()</p><p>The <em>.ti</em> file contains <em>{Key,ValueList}</em> tuples. This function adds <em>Data</em> to the ValueList associated with <em>Key</em>. All information written with this function will be included in the call to the format handler.</p><p><strong></strong> seq_trigger_ms() -&gt; MatchSpec</p><p>Equivalent to <em>seq_trigger_ms(all)</em></p><p><strong></strong> seq_trigger_ms(Flags) -&gt; MatchSpec</p><p>Types:</p><p>MatchSpec = match_spec()</p><p>Flags = all | SeqTraceFlag | [SeqTraceFlag]</p><p>SeqTraceFlag = atom()</p><p>A match specification can turn on or off sequential tracing. This function returns a match specification which turns on sequential tracing with the given <em>Flags</em>.</p><p>This match specification can be given as the last argument to <em>tp</em> or <em>tpl</em>. The activated <em>Item</em> will then become a <em>trigger</em> for sequential tracing. This means that if the item is called on a process with the <em>call</em> trace flag set, the process will be "contaminated" with the seq_trace token.</p><p>If <em>Flags = all</em>, all possible flags are set.</p><p>Please turn to the reference manual for the <em></em><em>seq_trace</em> module in the <em></em><em>kernel</em> application to see the possible values for <em>SeqTraceFlag</em>. For a description of the match_spec() syntax, please turn to the <em>User's guide</em> for the runtime system (<em>erts</em>). The chapter <em>Match Specification in Erlang</em> explains the general match specification "language".</p><p><strong></strong> Note:</p><p>The <em>system tracer</em> for sequential tracing is automatically initiated by <em>ttb</em> when a trace port is started with <em>ttb:tracer/0/1/2</em>.</p><p>Example of how to use the <em>seq_trigger_ms/0/1</em> function:</p>
<pre>
(tiger@durin)5&gt; ttb:tracer().
{ok,[tiger@durin]}
(tiger@durin)6&gt; ttb:p(all,call).
{ok,{[all],[call]}}
(tiger@durin)7&gt; ttb:tp(mod,func,ttb:seq_trigger_ms()).
{ok,[{matched,1},{saved,1}]}
(tiger@durin)8&gt;
</pre>
<p>Whenever <em>mod:func(...)</em> is called after this, the seq_trace token will be set on the executing process.</p><p><strong></strong> stop()</p><p>Equivalent to <em>stop([])</em>.</p><p><strong></strong> stop(Opts) -&gt; stopped | {stopped, Dir}</p><p>Types:</p><p>Opts = Opt | [Opt]</p><p>Opt = nofetch | {fetch_dir, Dir} | format | {format, FormatOpts} | return_fetch_dir</p><p>Dir = string()</p><p>FormatOpts = see format/2</p><p>Stops tracing on all nodes. Logs and trace information files are sent to the trace control node and stored in a directory named <em>ttb_upload_FileName-Timestamp</em>, where <em>Filename</em> is the one provided with <em>{file, File}</em> during trace setup and <em>Timestamp</em> is of the form <em>yyyymmdd-hhmmss</em>. Even logs from nodes on the same machine as the trace control node are moved to this directory. The history list is saved to a file named <em>ttb_last_config</em> for further reference (as it will be not longer accessible through history and configuration management functions (like <em>ttb:list_history/0</em>).</p><p>The <em>nofetch</em> option indicates that trace logs shall not be collected after tracing is stopped.</p><p>The <em>{fetch, Dir}</em> option allows to specify the directory to fetch the data to. If the directory already exists, an error is thrown.</p><p>The <em>format</em> option indicates that the trace logs shall be formatted after tracing is stopped. All logs in the fetch directory will be merged. You may use <em>{format, FormatOpts}</em> to pass additional arguments to <em>format/2</em>.</p><p>The <em>return_fetch_dir</em> option indicates that the return value should be <em>{stopped, Dir}</em> and not just <em>stopped</em>. This implies <em>fetch</em>.</p><p><strong></strong> get_et_handler()</p><p>The <em>et</em> handler returned by the function may be used with <em>format/2</em> or <em>tracer/2</em>. Example: <em>ttb:format(Dir, [{handler, ttb:get_et_handler()}])</em>.</p><p><strong></strong> format(File)</p><p>Same as <em>format(File,[])</em>.</p><p><strong></strong> format(File,Options) -&gt; ok | {error, Reason}</p><p>Types:</p><p>File = string() | [string()]</p><p>This can be the name of a binary log, a list of such logs or the name of a directory containing one or more binary logs.</p><p>Options = Opt | [Opt]</p><p>Opt = {out,Out} | {handler,FormatHandler} | disable_sort</p><p>Out = standard_io | string()</p><p>FormatHandler = {Function, InitialState}</p><p>Function = fun(Fd,Trace,TraceInfo,State) -&gt; State</p><p>Fd = standard_io | FileDescriptor</p><p>This is the file descriptor of the destination file <em>Out</em></p><p>Trace = tuple()</p><p>This is the trace message. Please turn to the Reference manual for the <em>erlang</em>module for details.</p><p>TraceInfo = [{Key,ValueList}]</p><p>This includes the keys <em>flags</em>, <em>client</em> and <em>node</em>, and if <em>handler</em> is given as option to the tracer function, this is also included. In addition all information written with the <em>write_trace_info/2</em>function is included.</p><p>Reads the given binary trace log(s). The logs are processed in the order of their timestamp as long as <em>disable_sort</em> option is not given.</p><p>If <em>FormatHandler = {Function,InitialState}</em>, <em>Function</em> will be called for each trace message. If <em>FormatHandler = get_et_handler()</em>, <em>et_viewer</em> in the <em>Event Tracer</em> application (<em>et</em>) is used for presenting the trace log graphically. <em>ttb</em> provides a few different filters which can be selected from the Filter menu in the <em>et_viewer</em>. If <em>FormatHandler</em> is not given, a default handler is used which presents each trace message as a line of text.</p><p>The state returned from each call of <em>Function</em> is passed to the next call, even if next call is to format a message from another log file.</p><p>If <em>Out</em> is given, <em>FormatHandler</em> gets the file descriptor to <em>Out</em> as the first parameter.</p><p><em>Out</em> is ignored if <em>et</em> format handler is used.</p><p>Wrap logs can be formatted one by one or all in one go. To format one of the wrap logs in a set, give the exact name of the file. To format the whole set of wrap logs, give the name with '*' instead of the wrap count. See examples in the <em>ttb</em> User's Guide.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="timer.3erl.html"><span aria-hidden="true">&larr;</span> timer.3erl: Timer functions</a></li>
   <li class="next"><a href="unicode.3erl.html">unicode.3erl: Functions for converting unicode characters <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

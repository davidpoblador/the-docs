<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>CmdWrite: Writing c language extensions to tcl.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Writing c language extensions to tcl.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="CmdWrite (3tclx) manual">
  <meta name="twitter:description" content="Writing c language extensions to tcl.">
  <meta name="twitter:image" content="https://www.carta.tech/images/tclx8.4-doc-CmdWrite-3tclx.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3tclx/CmdWrite.3tclx.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="CmdWrite (3tclx) manual" />
  <meta property="og:description" content="Writing c language extensions to tcl." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/tclx8.4-doc-CmdWrite-3tclx.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">CmdWrite<small> (3tclx)</small></h1>
        <p class="lead">Writing c language extensions to tcl.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3tclx/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3tclx/CmdWrite.3tclx.html">
      <span itemprop="name">CmdWrite: Writing c language extensions to tcl.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/tclx8.4-doc/">
      <span itemprop="name">tclx8.4-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3tclx/CmdWrite.3tclx.html">
      <span itemprop="name">CmdWrite: Writing c language extensions to tcl.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">OVERVIEW</h2>
        <div class="sectioncontent">
<p>This document is intended to help the programmer who wishes to extend Tcl with C language routines.  It should also be useful to someone wishing to add Tcl to an existing editor, communications program, window manager, etc. C programming information can also be found in the <em>*.3</em> manual pages in the <em>doc</em> directory of the Berkeley distribution, and in the <em>*.3</em> manpages in the <em>man</em> directory of Extended Tcl.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">WRITING TCL EXTENSIONS IN C</h2>
        <div class="sectioncontent">
<p>All C-based Tcl commands are called with four arguments: a client data pointer, an interpreter pointer, an argument count and a pointer to an array of pointers to character strings containing the Tcl arguments to the command.</p><p>A simple Tcl extension in C is now presented, and described below:</p>
<pre>
    #include "tcl.h"

    int App_EchoCmd(clientData, interp, argc, argv)
        void       *clientData;
        Tcl_Interp *interp;
        int         argc;
        char      **argv;
    {
            int i;

            for (i = 1; i &lt; argc; i++) {
                    printf("%s",argv[i]);
		    if (i &lt; argc - 1) printf(" ");
            }
            printf("&#92;n");
            return TCL_OK;
    }
</pre>
<p>The client data pointer will be described later.</p><p>The interpreter pointer is the ``key'' to an interpreter.  It is returned by <strong>Tcl_CreateInterp</strong> and is used extensively within Tcl, and will be by your C extensions.  The data structure pointed to by the interpreter pointer, and all of the subordinate structures that branch off of it, make up a Tcl interpreter, which includes all of the currently defined procedures, commands, variables, arrays and the execution state of that interpreter.  (For more information on creating and deleting interpreters, please examine the <strong>CrtInterp</strong>(3) manpage in the Berkeley Tcl distribution. For information on creating interpreters that include the commands provided by Extended Tcl, check out the <strong>TclX_Init</strong>(3) manpage of Extended Tcl. For a manual page describing the user-visible fields of a Tcl interpreter, please look at <strong>Interp</strong>(3) in Berkeley Tcl.)</p><p>The argument count and pointer to an array of pointers to textual arguments is handled by your C code in the same manner that you would use in writing a C <em>main</em> function -- the argument count and array of pointers works the same as in a C <em>main</em> call; pointers to the arguments to the function are contained in the <em>argv</em> array.  Similar to a C main, the first argument (<em>argv[0]</em>) is the name the routine was called as (in a main, the name the program was invoked as).</p><p>In the above example, all of the arguments are output with a space between each one by looping through <em>argv</em> from one to the argument count, <em>argc</em>, and a newline is output to terminate the line -- an ``echo'' command.</p><p>All arguments from a Tcl call to a Tcl C extension are passed as strings. If your C routine expects certain numeric arguments, your routine must first convert them using the <strong>Tcl_GetInt</strong> or <strong>Tcl_GetDouble</strong> function, Extended Tcl's <strong>Tcl_GetLong</strong> or <strong>Tcl_GetUnsigned</strong>, or some other method of your own devising.  Likewise for converting boolean values, <strong>Tcl_GetBoolean</strong> should be used. These routines automatically leave an appropriate error message in the Tcl interpreter's result buffer and return <strong>TCL_ERROR</strong> if a conversion error occurs.   (For more information on these routines, please look at the <strong>GetInt</strong>(3) manpage in the Berkeley Tcl distribution.)</p><p>Likewise, if you program produces a numeric result, it should return a string equivalent to that numeric value.  A common way of doing this is something like...</p>
<pre>
	sprintf(interp-&gt;result, "%ld", result);
</pre>
<p>Writing results directly into the interpreter's result buffer is only good for relatively short results.  Tcl has a function, <strong>Tcl_SetResult</strong>, which provides the ability for your C extensions to return very large strings to Tcl, with the ability to tell the interpreter whether it ``owns'' the string (meaning that Tcl should delete the string when it's done with it), that the string is likely to be changed or overwritten soon (meaning that Tcl should make a copy of the string right away), or that the string won't change (so Tcl can use the string as is and not worry about it).  Understanding how results are passed back to Tcl is essential to the C extension writer. Please study the <strong>SetResult</strong>(3) manual page in the Tcl distribution.</p><p>Sophisticated commands should verify their arguments whenever possible, both by examining the argument count, by verifying that numeric fields are really numeric, that values are in range (when their ranges are known), and so forth.</p><p>Tcl is designed to be as bullet-proof as possible, in the sense that no Tcl program should be able to cause Tcl to dump core.  Please carry this notion forward with your C extensions by validating arguments as above.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ANOTHER C EXTENSION - THE MAX COMMAND</h2>
        <div class="sectioncontent">
<p>In the command below, two or more arguments are compared and the one with the maximum value is returned, if all goes well.  It is an error if there are fewer than three arguments (the pointer to the ``max'' command text itself, <em>argv[0]</em>, and pointers to at least two arguments to compare the values of).</p><p>This routine also shows the use of the programmer labor-saving <strong>Tcl_AppendResult</strong> routine.  See the Tcl manual page, <strong>SetResult</strong>(3), for details. Also examine the calls <strong>Tcl_AddErrorInfo</strong>, <strong>Tcl_SetErrorCode</strong> and <strong>Tcl_PosixError</strong> documented in the Tcl manual page <strong>AddErrInfo</strong>(3).</p>
<pre>
    int
    Tcl_MaxCmd (clientData, interp, argc, argv)
        char       *clientData;
        Tcl_Interp *interp;
        int         argc;
        char      **argv;
    {
        int maxVal = MININT;
        int maxIdx = 1;
        int value, idx;


        if (argc &lt; 3) {
            Tcl_AppendResult (interp, "bad # arg: ", argv[0],
                              " num1 num2 [..numN]", (char *)NULL);
            return TCL_ERROR;
        }

        for (idx = 1; idx &lt; argc; idx++) {
            if (Tcl_GetInt (argv[idx], 10, &Value) != TCL_OK)
                return TCL_ERROR;

            if (value &gt; maxVal) {
                maxVal = value;
                maxIdx = idx;
            }
        }
        Tcl_SetResult (interp, argv [maxIdx], TCL_VOLATILE);
        return TCL_OK;
    }
</pre>
<p>When Tcl-callable functions complete, they should normally return <strong>TCL_OK</strong> or <strong>TCL_ERROR</strong>. <strong>TCL_OK</strong> is returned when the command succeeded and <strong>TCL_ERROR</strong> is returned when the command has failed in some abnormal way. <strong>TCL_ERROR</strong> should be returned for all syntax errors, non-numeric values (when numeric ones were expected), and so forth.  Less clear in some cases is whether Tcl errors should be returned or whether a function should just return a status value. For example, end-of-file during a <em>gets</em> returns a status, but <em>open</em> returns an error if the open fails.  Errors can be caught from Tcl programs using the <em>catch</em> command.  (See Tcl's <strong>catch</strong>(n) and <strong>error</strong>(n) manual pages.)</p><p>Less common return values are <strong>TCL_RETURN</strong>, <strong>TCL_BREAK</strong> and <strong>TCL_CONTINUE</strong>. These are used if you are adding new control and/or looping structures to Tcl.  To see these values in action, examine the source code to Tcl's <em>while</em>, <em>for</em> and <em>if</em>, and Extended Tcl's <em>loop</em> commands.</p><p>Note the call to <em>Tcl_SetResult</em> in the above command to set the return value to Tcl.  <strong>TCL_VOLATILE</strong> is used because the memory containing the result will be freed upon the function's return.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ANOTHER C EXTENSION - THE LREVERSE COMMAND</h2>
        <div class="sectioncontent">
<p>In the command below, one list is passed as an argument, and a list containing all of the elements of the list in reverse order is returned.  It is an error if anything other than two arguments are passed (the pointer to the ``lreverse'' command text itself, <em>argv[0]</em>, and a pointer to the list to reverse.</p><p>Once <em>lreverse</em> has determined that it has received the correct number of arguments, <strong>Tcl_SplitList</strong> is called to break the list into an <em>argc</em> and <em>argv</em> array of pointers.</p><p><em>lreverse</em> then operates on the array of pointers, swapping them from lowest to highest, second-lowest to second-highest, and so forth.</p><p>Finally <strong>Tcl_Merge</strong> is calleds to create a single new string containing the reversed list and it is set as the result via <strong>Tcl_SetResult</strong>. Note that <strong>TCL_DYNAMIC</strong> is used to tell <strong>Tcl_SetResult</strong> that it now owns the string and it is up to Tcl to free the string when it is done with it.</p><p>Note that it <em>is</em> safe to play around with the <em>argv</em> list like this, and that a single call to <strong>ckfree</strong> can be made to free all the data returned by <strong>Tcl_SplitList</strong> in this manner.</p>
<pre>
int
Tcl_LreverseCmd(notUsed, interp, argc, argv)
    ClientData notUsed;			/* Not used. */
    Tcl_Interp *interp;			/* Current interpreter. */
    int argc;				/* Number of arguments. */
    char **argv;			/* Argument strings. */
{
    int listArgc, lowListIndex, hiListIndex;
    char **listArgv;
    char *temp, *resultList;

    if (argc != 2) {
	Tcl_AppendResult(interp, "wrong # args: should be 
		" list
	return TCL_ERROR;
    }

    if (Tcl_SplitList(interp, argv[1], &listArgc, &listArgv) != TCL_OK) {
	return TCL_ERROR;
    }
    for (lowListIndex = 0, hiListIndex = listArgc;
	 --hiListIndex &gt; lowListIndex; lowListIndex++) {
	temp = listArgv[lowListIndex];
	listArgv[lowListIndex] = listArgv[hiListIndex];
	listArgv[hiListIndex] = temp;
    }
    resultList = Tcl_Merge (listArgc, listArgv);
    ckfree (listArgv);
    Tcl_SetResult (interp, resultList, TCL_DYNAMIC);
    return TCL_OK;
}
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INSTALLING YOUR COMMAND</h2>
        <div class="sectioncontent">
<p>To install your command into Tcl you must call <strong>Tcl_CreateCommand</strong>, passing it the pointer to the interpreter you want to install the command into, the name of the command, a pointer to the C function that implements the command, a client data pointer, and a pointer to an optional callback routine.</p><p>The client data pointer and the callback routine will be described later.</p><p>For example, for the max function above (which, incidentally, comes from TclX's tclXmath.c in the <em>TclX7.4/src</em> directory):</p>
<pre>
    Tcl_CreateCommand (interp, "max", Tcl_MaxCmd, (ClientData)NULL,
                      (void (*)())NULL);
</pre>
<p>In the above example, the max function is added to the specified interpreter.  The client data pointer and callback function pointer are NULL.  (For complete information on <strong>Tcl_CreateCommand</strong> and its companion routine, <strong>Tcl_CommandInfo</strong>, please examine the <strong>CrtCommand</strong>(3) command page in the Berkeley Tcl distribution.)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DYNAMIC STRINGS</h2>
        <div class="sectioncontent">
<p><em>Dynamic strings</em> are an important abstraction that first became available with Tcl 7.0.  Dynamic strings, or <em>DStrings</em>, provide a way to build up arbitrarily long strings through a repeated process of appending information to them.  DStrings reduce the amount of allocating and copying required to add information to a string. Further, they simplify the process of doing so.  For complete information on dynamic strings, please examine the <strong>DString</strong>(3) manual page in the Berkeley Tcl distribution.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CLIENT DATA</h2>
        <div class="sectioncontent">
<p>The client data pointer provides a means for Tcl commands to have data associated with them that is not global to the C program nor included in the Tcl core.  Client data is essential in a multi-interpreter environment (where a single program has created and is making use of multiple Tcl interpreters) for the C routines to maintain any permanent data they need on a per-interpreter basis. Otherwise there would be reentrancy problems. Tcl solves this through the client data mechanism.  When you are about to call <strong>Tcl_CreateCommand</strong> to add a new command to an interpreter, if that command needs to keep some read/write data across invocations, you should allocate the space, preferably using <strong>ckalloc</strong>, then pass the address of that space as the ClientData pointer to <strong>Tcl_CreateCommand</strong>.</p><p>When your command is called from Tcl, the ClientData pointer you gave to <strong>Tcl_CreateCommand</strong> when you added the command to that interpreter is passed to your C routine through the ClientData pointer calling argument.</p><p>Commands that need to share this data with one another can do so by using the same ClientData pointer when the commands are added.</p><p>It is important to note that the Tcl extensions in the <em>tclX7.4/src</em> directory have had all of their data set up in this way. Since release 6.2, Extended Tcl has supported multiple interpreters within one invocation of Tcl.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THEORY OF HANDLES</h2>
        <div class="sectioncontent">
<p>Sometimes you need to have a data element that isn't readily representable as a string within Tcl, for example a pointer to a complex C data structure. It is not a good idea to try to pass pointers around within Tcl as strings by converting them to and from hex or integer representations, for example.  It is too easy to mess one up, and the likely outcome of doing that is a core dump.</p><p>Instead we have developed and made use of the concept of <em>handles</em>. Handles are identifiers a C extension can pass to, and accept from, Tcl to make the transition between what your C code knows something as and what name Tcl knows it by to be as safe and painless as possible. For example, the stdio package included in Tcl uses file handles.  When you open a file from Tcl, a handle is returned of the form <strong>file</strong><em>n</em> where <em>n</em> is a file number.  When you pass the file handle back to <em>puts</em>, <em>gets</em>, <em>seek</em>, <em>flush</em> and so forth, they validate the file handle by checking the the <strong>file</strong> text is present, then converting the file number to an integer that they use to look into a data structure of pointers to Tcl open file structures, which contain a Unix file descriptor, flags indicating whether or not the file is currently open, whether the file is a file or a pipe and so forth.</p><p>Handles have proven so useful that, as of release 6.1a, general support has been added for them. If you need a similar capability, it would be best to use the handle routines, documented in <strong>Handles</strong>(3) in Extended Tcl. We recommend that you use a unique-to-your-package textual handle coupled with a specific identifier and let the handle management routines validate it when it's passed back. It is much easier to track down a bug with an implicated handle named something like <strong>file4</strong> or <strong>bitmap6</strong> than just <strong>6</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TRACKING MEMORY CORRUPTION PROBLEMS</h2>
        <div class="sectioncontent">
<p>Occasionally you may write code that scribbles past the end of an allocated piece of memory.  The memory debugging routines included in Tcl can help find these problems.  See <em>Memory(TCL)</em> for details.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INSTALLING YOUR EXTENSIONS INTO EXTENDED TCL</h2>
        <div class="sectioncontent">
<p>To add your extensions to Extended Tcl, you must compile them and cause them to be linked with TclX.  For the routines to be linked into the <strong>tcl</strong> and <strong>wishx</strong> executables, they must be referenced (directly or indirectly) from TclX.  For these extensions to be visible as Tcl commands, they must be installed into Tcl with <strong>Tcl_CreateCommand</strong>.</p><p>Application-specific startup is accomplished by creating or editing the <em>Tcl_AppInit</em> function.  In <em>Tcl_AppInit</em> you should add a call to an application-specific init function which you create.  This function should take the address of the interpreter it should install its commands into, and it should install those commands with <strong>Tcl_CreateCommand</strong> and do any other application-specific startup that is necessary.</p><p>The naming convention for application startup routines is <strong>App_Init</strong>, where <em>App</em> is the name of your application.  For example, to add an application named <em>cute</em> one would create a <em>Cute_Init</em> routine that expected a <strong>Tcl_Interp</strong> pointer as an argument, and add the following code to <em>Tcl_AppInit</em>:</p>
<pre>
    if (Cute_Init (interp) == TCL_ERROR) {
	return TCL_ERROR;
    }
</pre>
<p>As you can guess from the above example, if your init routine is unable to initialize, it should use <strong>Tcl_AppendResult</strong> to provide some kind of useful error message back to TclX, then return <strong>TCL_ERROR</strong> to indicate that an error occurred.  If the routine executed successfully, it should return <strong>TCL_OK</strong>.</p><p>When you examine <em>Tcl_AppInit</em>, note that there is one call already there to install an application -- the call to <em>TclX_Init</em> installs Extended Tcl into the Tcl core.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MAKING APPLICATION INFORMATION VISIBLE FROM EXTENDED TCL</h2>
        <div class="sectioncontent">
<p>TclX's <strong>infox</strong> command can return several pieces of information relevant to Extended Tcl, including the application's name, descriptive name, patch level and version.  Your application's startup can set these variables to application-specific values.  If it doesn't, they are given default values for Extended Tcl.</p><p>To set these values, first be sure that you include either <strong>tclExtend.h</strong> or <strong>tclExtdInt.h</strong> from the source file that defines your init routine. This will create external declarations for the variables.  Then, set the variables in your init route, for example:</p>
<pre>
    tclAppName = "cute";
    tclAppLongName = "Call Unix/Tcl Environment";
    tclAppVersion = "2.1";
</pre>
<p>Note that the default values are set by <em>TclX_Init</em>, so if you wish to override them, you must call your init routine in <em>Tcl_AppInit</em> after its call to <em>TclX_Init</em>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXTENDED TCL EXIT</h2>
        <div class="sectioncontent">
<p>When Extended Tcl exits, <strong>Tcl_DeleteInterp</strong> may be called to free memory used by Tcl -- normally, this is only called if <strong>TCL_MEM_DEBUG</strong> was defined, since Unix will return all of the allocated memory back to the system, anyway. If <strong>TCL_MEM_DEBUG</strong> was defined, it is called so that any memory that was allocated without ever being freed can be detected.  This greatly reduces the amount of work to detect and track down memory leaks, a situation where some piece of your code allocates memory repeatedly without ever freeing it, or without always freeing it.</p><p>It is often necessary for an application to perform special cleanup functions upon the deletion of an interpreter as well.  To facilitate this activity, Tcl provides the ability to perform a function callback when an interpreter is deleted.  To arrange for a C function to be called when the interpreter is deleted, call <strong>Tcl_CallWhenDeleted</strong> from your application initialization routine.  For details on how to use this function, read the <strong>CallDel</strong>(3) manual page that ships with Berkeley Tcl.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXECUTING TCL CODE FROM YOUR C EXTENSION</h2>
        <div class="sectioncontent">
<p>Suppose you are in the middle of coding a C extension and you realize that you need some operation performed, one that would be simple from Tcl but possibly excruciating to do directly in C.  Tcl provides the <strong>Tcl_Eval</strong>, <strong>Tcl_VarEval</strong>, <strong>Tcl_EvalFile</strong> and <strong>Tcl_GlobalEval</strong> functions for the purpose of executing Tcl code from within a C extension.  The results of the call will be in <strong>interp-&gt;result</strong>.  For more information please consult the <strong>Eval</strong>(3) manual page within the Tcl distribution.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ACCESSING TCL VARIABLES AND ARRAYS FROM YOUR C EXTENSIONS</h2>
        <div class="sectioncontent">
<p>Tcl variables and arrays can be read from a C extension through the <strong>Tcl_GetVar</strong> and <strong>Tcl_GetVar2</strong> functions, and set from C extensions through the <strong>Tcl_SetVar</strong> and <strong>Tcl_SetVar2</strong> functions.  They can also be unset via the <strong>Tcl_UnsetVar</strong> and <strong>Tcl_UnsetVar2</strong> functions. For complete information on these functions, please refer to the <strong>SetVar</strong>(3) manual page in the <em>doc</em> directory of the Berkeley Tcl distribution.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LINKING TCL VARIABLES TO C VARIABLES</h2>
        <div class="sectioncontent">
<p><strong>Tcl_LinkVar</strong> and <strong>Tcl_UnlinkVar</strong> can be used to automatically keep Tcl variables synchronized with corresponding C variables.  Once a Tcl variable has been linked to a C variable with <strong>Tcl_LinkVar</strong>, anytime the Tcl variable is read the value of the C variable will be returned, and when the Tcl variable is written, the C variable will be updated with the new value.</p><p><strong>Tcl_LinkVar</strong> uses variable traces to keep the Tcl variable named by <em>varName</em> in sync with the C variable at the address given by <em>addr</em>.</p><p>Whenever the Tcl variable is read the value of the C variable will be returned, and whenever the Tcl variable is written the C variable will be updated to have the same value.</p><p><em>Int</em>, <em>double</em>, <em>boolean</em> and <em>char *</em> variables are supported.  For more information, please examine the <strong>LinkVar</strong>(3) manual page in the Berkeley Tcl distribution.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ADDING NEW MATH FUNCTIONS TO TCL</h2>
        <div class="sectioncontent">
<p>As of Tcl version 7.0, math functions such as <em>sin</em>, <em>cos</em>, etc, are directly supported within Tcl expressions.  These obsolete the Extended Tcl commands that provided explicit calls for these functions for many releases.</p><p>New math functions can be added to Tcl, or existing math functions can be replaced, by calling <strong>Tcl_CreateMathFunc</strong>.</p><p>For more information on adding math functions, please examine the <strong>CrtMathFnc</strong>(3) manual page in the Berkeley Tcl distribution.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PERFORMING TILDE SUBSTITUTIONS ON FILENAMES</h2>
        <div class="sectioncontent">
<p>The <strong>Tcl_TildeSubst</strong> function is available to C extension writers to perform tilde substitutions on filenames.  If the name starts with a ``~'' character, the function returns a new string where the name is replaced with the home directory of the given user. For more information please consult the <strong>TildeSubst</strong>(3) manual page in the Berkeley Tcl distribution.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SETTING THE RECURSION LIMIT</h2>
        <div class="sectioncontent">
<p>Tcl has a preset recursion limit that limits the maximum allowable nesting depth of calls within an interpreter.  This is useful for detecting infinite recursions before other limits such as the process memory limit or, worse, available swap space on the system, are exceeded.</p><p>The default limit is just a guess, however, and applications that make heavy use of recursion may need to call <strong>Tcl_SetRecursionLimit</strong> to raise this limit.  For more information, please consult the <strong>SetRecLmt</strong>(3) manual page in the Berkeley Tcl distribution.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">HANDLING SIGNALS FROM TCL EXTENSIONS</h2>
        <div class="sectioncontent">
<p>If an event such as a signal occurs while a Tcl script is being executed, it isn't safe to do much in the signal handling routine -- the Tcl environment cannot be safely manipulated at this point because it could be in the middle of some operation, such as updating pointers, leaving the interpreter in an unreliable state.</p><p>The only safe approach is to set a flag indicating that the event occurred, then handle the event later when the interpreter has returned to a safe state, such as after the current Tcl command completes.</p><p>The <strong>Tcl_AsyncCreate</strong>, <strong>Tcl_AsyncMark</strong>, <strong>Tcl_AsyncInvoke</strong>, and <strong>Tcl_AsyncDelete</strong> functions provide a safe mechanism for dealing with signals and other asynchronous events.  For more information on how to use this capability, please refer to the <strong>Async</strong>(3) manual page in the Berkeley Tcl distribution.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PARSING BACKSLASH SEQUENCES</h2>
        <div class="sectioncontent">
<p>The <strong>Tcl_Backslash</strong> function is called to parse Tcl backslash sequences. These backslash sequences are the usual sort that you see in the C programming language, such as <strong>&#92;n</strong> for newline, <strong>&#92;r</strong> for return, and so forth.  <strong>Tcl_Backslash</strong> parses a single backslash sequence and returns a single character corresponding to the backslash sequence.</p><p>For more info on this call, look at the <strong>Backslash</strong>(3) manual page in the Berkeley Tcl distribution.  For information on the valid backslash sequences, consult the summary of Tcl language syntax, <strong>Tcl</strong>(n) in the same distribution.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">HASH TABLES</h2>
        <div class="sectioncontent">
<p><em>Hash tables</em> provide Tcl with a high-performance facility for looking up and managing key-value pairs located and maintained in memory.  Tcl uses hash tables internally to locate procedure definitions, Tcl variables, array elements, file handles and so forth.  Tcl makes the hash table functions accessible to C extension writers as well.</p><p>Hash tables grow automatically to maintain efficiency, rather than exposing the table size to the programmer at allocation time, which would needlessly add complexity to Tcl and would be prone to inefficiency due to the need to guess the number of items that will go into the table, and the seemingly inevitable growth in amount of data processed per run over the life of the program.</p><p>For more information on hash tables, please consult the <a href="../man3/hash.3.html"><strong>Hash</strong>(3)</a> manual page in the Berkeley Tcl distribution.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TRACING VARIABLE ACCESSES</h2>
        <div class="sectioncontent">
<p>The C extension writer can arrange to have a C routine called whenever a Tcl variable is read, written, or unset.  Variable traces are the mechanism by which Tk toolkit widgets such as radio and checkbuttons, messages and so forth update without Tcl programmer intervention when their data variables are changed.  They are also used by the routine that links Tcl and C variables, <strong>Tcl_LinkVar</strong>, described above.</p><p><strong>Tcl_TraceVar</strong> is called to establish a variable trace.  Entire arrays and individual array elements can be traced as well.  If the programmer already has an array name in one string and a variable name in another, <strong>Tcl_TraceVar2</strong> can be called.  Calls are also available to request information about traces and to delete them.</p><p>For more information on variable traces, consult the <strong>TraceVar</strong>(3) manual page in the Berkeley Tcl distribution.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TRACING EXECUTION</h2>
        <div class="sectioncontent">
<p>Tcl has the ability to call C routines for every command it executes, up to a specified depth of nesting levels.  The command <strong>Tcl_CreateTrace</strong> creates an execution trace; <strong>Tcl_DeleteTrace</strong> deletes it.</p><p>Command tracing is used in Extended Tcl to implement the <em>cmdtrace</em> Tcl command, a useful command for debugging Tcl applications.</p><p>For complete information on execution tracing, please look at the <strong>CrtTrace</strong>(3) manual pages in the Berkeley Tcl distribution.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EVALUATING TCL EXPRESSIONS FROM C</h2>
        <div class="sectioncontent">
<p><strong>Tcl_ExprLong</strong>, <strong>Tcl_ExprDouble</strong>, <strong>Tcl_ExprBool</strong>, and <strong>Tcl_ExprString</strong> can be called to evaluate Tcl expressions from within a C routine.  Depending on the routine called, the result is either a C <em>long</em>, a <em>double</em>, a boolean (<em>int</em> with a value of <strong>0</strong> or <em>1</em>), or a <em>char *</em> (pointed to by <em>interp-&gt;result</em>).</p><p>For complete information on evaluating Tcl expressions from C, you are invited to examine the <strong>ExprLong</strong>(3) manpage in the Berkeley Tcl distribution.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PATTERN MATCHING</h2>
        <div class="sectioncontent">
<p>The <strong>Tcl_StringMatch</strong> function can be called to see if a string matches a specified pattern.  <strong>Tcl_StringMatch</strong> is called by the Tcl <em>string match</em> command, so the format for patterns is identical.  The pattern format is similar to the one used by the C-shell; <strong>string</strong>(n) describes this format.</p><p>More information about <strong>Tcl_StringMatch</strong> is available in the <strong>StrMatch</strong>(3) manpage in the Berkeley Tcl distribution.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REGULAR EXPRESSION PATTERN MATCHING</h2>
        <div class="sectioncontent">
<p><strong>Tcl_RegExpMatch</strong> can be called to determine whether a string matches a regular expression.  <strong>Tcl_RegExpMatch</strong> is used internally by the <em>regexp</em> Tcl command.</p><p>For more information on this function, please consult the <strong>RegExp</strong>(3) manpage in the Berkeley Tcl distribution.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MANIPULATING TCL LISTS FROM C EXTENSIONS</h2>
        <div class="sectioncontent">
<p>The C extension writer often needs to create, manipulate and decompose Tcl lists.  <strong>Tcl_SplitList</strong> parses a list into an <em>argv</em> and <em>argc</em> like to the way command-line arguments are passed to a Tcl extension.  <strong>Tcl_Merge</strong>, likewise, creates a single string (pointer to a <em>char *</em>) from an <em>argv</em> and <em>argc</em>.</p><p>Two routines, <strong>Tcl_ScanElement</strong> and <strong>Tcl_ConvertElement</strong>, do most of the work of <strong>Tcl_Merge</strong>, and may also be of use to the C programmer.</p><p>For more information on these commands, please consult the <strong>SplitList</strong>(3) manual page in the Berkeley Tcl distribution.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONCATENATING STRINGS</h2>
        <div class="sectioncontent">
<p><strong>Tcl_Concat</strong> concatenates zero or more strings into a single string.  The strings are space-separated.  <strong>Tcl_Concat</strong> works like <em>Tcl_Merge</em>, except that <strong>Tcl_Concat</strong> does not attempt to make the resulting string into a valid Tcl list.</p><p><strong>Tcl_Concat</strong> is documented in the <strong>Concat</strong>(3) manpage in the Berkeley Tcl distribution.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DETECTING WHETHER OR NOT YOU HAVE A COMPLETE COMMAND</h2>
        <div class="sectioncontent">
<p>C routines that collect data to form a command to be passed to <em>Tcl_Eval</em> often need a way to tell whether they have a complete command already or whether they need more data.  (Programs that read typed-in Tcl input such as Tcl shells need this capability.) <strong>Tcl_CommandComplete</strong> can be used to tell whether or not you have a complete command.</p><p>For more information examine <strong>CmdCmplt</strong>(3) in the Berkeley Tcl distribution.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RECORDING COMMANDS FOR COMMAND HISTORY</h2>
        <div class="sectioncontent">
<p>Tcl has a history mechanism that is accessed from Tcl through the <em>history</em> command.  To propagate commands into the command history, your extension should call <em>Tcl_RecordAndEval</em>. This command works just like <em>Tcl_Eval</em>, except that it records the command as well as executing it.</p><p><em>Tcl_RecordAndEval</em> should only be called with user-entered top-level commands, since the history mechanism exists to allow the user to easily access, edit and reissue previously issued commands.</p><p>For complete information on this function, please examine the <strong>RecordEval</strong>.3 manual page in the Berkeley Tcl distribution.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONVERTING FLOATING POINT VALUES TO STRINGS</h2>
        <div class="sectioncontent">
<p><strong>Tcl_PrintDouble</strong> converts a C <em>double</em> into an ASCII string.  It ensures that the string output will continue to be interpreted as a floating point number, rather than an integer, by always putting a ``.'' or ``e'' into the string representing the number. The precision of the output string is controlled by the Tcl <strong>tcl_precision</strong> variable.</p><p>For complete information on <em>Tcl_PrintDouble</em>, examine <strong>PrintDbl</strong>(3) in the Berkeley Tcl distribution.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CREATING CHILD PROCESSES AND PIPELINES FROM C</h2>
        <div class="sectioncontent">
<p><strong>Tcl_CreatePipeline</strong> is a useful procedure for spawning child processes.  The child (or pipeline of children) can have its standard input, output and error redirected from files, variables or pipes.  To understand the meaning of the redirection symbols understood by this function, look at the <strong>exec</strong>(n) Tcl command.  For complete information on <strong>Tcl_CreatePipeline</strong>, please examine <strong>CrtPipelin</strong>(3).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ACCESSING TCL FILEHANDLES FROM C</h2>
        <div class="sectioncontent">
<p>Files opened from your C code can be made visible to Tcl code via the <strong>Tcl_EnterFile</strong> function.  Likewise, Tcl filehandles passed to your C extension can be translated to a Posix <em>FILE *</em> structure using the <strong>Tcl_GetOpenFile</strong> function.</p><p>For complete explanations of these commands, please look at <strong>EnterFile</strong>(3) in the Berkeley Tcl distribution.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MANAGING BACKGROUND PROCESS TERMINATION AND CLEANUP</h2>
        <div class="sectioncontent">
<p>When a Posix system does a <em>fork</em> to create a new process, the process ID of the child is returned to the caller.  After the child process exits, its process table entry (and some other data associated with the process) cannot be reclaimed by the operating system until a call to <em>waitpid</em>, or one of a couple of other, similar system calls, has been made by the parent process.</p><p>The C extension writer who has created a subprocess, by whatever mechanism, can turn over responsibility for detecting the processes' termination and calling <em>waitpid</em> to obtain its exit status by calling <strong>Tcl_DetachPids</strong>.</p><p><strong>Tcl_ReapDetachedProcs</strong> is the C routine that will detect the termination of any processes turned over to Tcl, permitting the processes to be fully reclaimed by the operating system.</p><p>For complete information on these routines, please look at <strong>DetachPids</strong>(3)</em> in the Berkeley Tcl distribution.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FOR MORE INFORMATION</h2>
        <div class="sectioncontent">
<p>In addition to the documentation referenced above, you can learn a lot by studying the source code of the commands added by Tcl, Tk and Extended Tcl.  The <em>comp.lang.tcl</em> Usenet newsgroup is read by tens of thousands of Tcl people, and is a good place to ask questions. Finally, if you have interactive Internet access, you can ftp to <em>ftp.aud.alcatel.com</em>, the site for contributed Tcl sources. This site contains quite a few extensions, applications, and so forth, including several object-oriented extension packages.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p>Extended Tcl was created by Karl Lehenbauer (karl@neosoft.com) and Mark Diekhans (markd@grizzly.com).</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="next"><a href="Keylist.3tclx.html">Keylist.3tclx: Keyed list management routines. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>PDF::Reuse: Reuse and mass produce pdf documents</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Reuse and mass produce pdf documents">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="PDF::Reuse (3pm) manual">
  <meta name="twitter:description" content="Reuse and mass produce pdf documents">
  <meta name="twitter:image" content="https://www.carta.tech/images/libpdf-reuse-perl-PDF::Reuse-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/PDF::Reuse.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="PDF::Reuse (3pm) manual" />
  <meta property="og:description" content="Reuse and mass produce pdf documents" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libpdf-reuse-perl-PDF::Reuse-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">PDF::Reuse<small> (3pm)</small></h1>
        <p class="lead">Reuse and mass produce pdf documents</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/PDF::Reuse.3pm.html">
      <span itemprop="name">PDF::Reuse: Reuse and mass produce pdf documents</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libpdf-reuse-perl/">
      <span itemprop="name">libpdf-reuse-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/PDF::Reuse.3pm.html">
      <span itemprop="name">PDF::Reuse: Reuse and mass produce pdf documents</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
   use PDF::Reuse;
   prFile(&apos;myFile.pdf&apos;);
   prText(100, 500, &apos;Hello World !&apos;);
   prEnd();
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module could be used when you want to mass produce similar (but not identical) \s-1PDF\s0 documents and reuse templates, JavaScripts and some other components. It is functional to be fast, and to give your programs capacity to produce many pages per second and very big \s-1PDF\s0 documents if necessary.</p><p>The module produces \s-1PDF-1\s0.4 files. Some features of \s-1PDF-1\s0.5, like \*(L"object streams\*(R" and \*(L"cross reference streams\*(R", are supported, but only at an experimental level. More testing is needed. (If you get problems with a new document from Acrobat 6 or higher, try to save it or recreate it as a \s-1PDF-1\s0.4 document first, before using it together with this module.)</p>
<dl class='dl-vertical'>
  <dt>
    Templates
  </dt>
  <dd>
    <p>Use your favorite program, probably a commercial visual tool, to produce single PDF-files to be used as templates, and then use this module to <strong>mass produce</strong> files from them. (If you want small PDF-files or want special graphics, you can use this module also, but visual tools are often most practical.)</p>
  </dd>
  <dt>
    Lists
  </dt>
  <dd>
    <p>The module uses \*(L"XObjects\*(R" extensively. This is a format that makes it possible create big lists, which are compact at the same time.</p>
  </dd>
  <dt>
    PDF-operators
  </dt>
  <dd>
    <p>The module gives you a good possibility to program at a \*(L"low level\*(R" with the basic graphic operators of \s-1PDF\s0, if that is what you want to do. You can build your own libraries of low level routines, with PDF-directives \*(L"controlled\*(R" by Perl.</p>
  </dd>
  <dt>
    Archive-format
  </dt>
  <dd>
    <p>If you want, you get your new documents logged in a format suitable for archiving or transfer. PDF::Reuse::Tutorial might show you best what you can do with this module.</p>
  </dd>
  <dt>
    JavaScript
  </dt>
  <dd>
    <p>You can attach JavaScripts to your PDF-files. You can have libraries of JavaScripts. No cutting or pasting, and those who include the scripts in documents only need to know how to initiate them. (Of course those who write the scripts have to know Acrobat JavaScript well.)</p>
  </dd>

</dl>
<h3>Remarks about JavaScript</h3>
<p>Some of the functions handling JavaScript have to be rewritten for Acrobat 7.</p><p>There are many limitations with Acrobat JavaScript, and the rules often change. So what works for one version of Acrobat/Reader, might not work for another. Another complication is this: When documents are downloaded via the net by Acrobat, they are most often converted (!) and necessary JavaScripts are lost.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FUNCTIONS</h2>
        <div class="sectioncontent">
<p>All functions which are successful return specified values or 1.</p><p>The module doesn't make any attempt to import anything from encrypted files.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Overview</h2>
        <div class="sectioncontent">
<p>To write a program with PDF::Reuse, you need these components:</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Mandatory Functions</h2>
        <div class="sectioncontent">
<h3>prFile		- define output</h3>
<p>Alternative 1:</p><p>   prFile ( $fileName );</p><p>Alternative 2 with parameters in an anonymous hash:</p><p>   prFile ( { Name         =&gt; $fileName,               HideToolbar  =&gt; 1,            # 1 or 0               HideMenubar  =&gt; 1,            # 1 or 0               HideWindowUI =&gt; 1,            # 1 or 0               FitWindow    =&gt; 1,            # 1 or 0               CenterWindow =&gt; 1   } );      # 1 or 0</p><p>Alternative 3:</p><p>   prFile ( $r );  # For mod_perl 2 pass the request object</p><p>$fileName is optional, just like the rest of the parameters. File to create. If another file is current when this function is called, the first one is written and closed. Only one file is processed at a single moment. If $fileName is undefined, output is written to \s-1STDOUT\s0.</p><p>HideToolbar, HideMenubar, HideWindowUI, FitWindow and CenterWindow control the way the document is initially displayed.</p><p>Look at any program in this documentation for examples. <em>prInitVars()</em> shows how this function could be used together with a web server.</p>
<h3>prEnd		- end/flush buffers</h3>
<p>   prEnd ()</p><p>When the processing is going to end, the buffers of the <strong>last</strong> file has to be written to the disc. If this function is not called, the page structure, xref part and so on will be lost.</p><p>Look at any program in this documentation for an example.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Optional Functions</h2>
        <div class="sectioncontent">
<p>    prAdd ( $string )</p><p>With this command you can add whatever you want to the current content stream. No syntactical checks are made, but if you use an internal name, the module tries to add the resource of the \*(L"name object\*(R" to the \*(L"Resources\*(R" of current page. \*(L"Name objects\*(R" always begin with a '/'.</p><p>(In this documentation I often use talk about an \*(L"internal name\*(R". It denotes a \*(L"name object\*(R". When PDF::Reuse creates these objects, it assigns Ft1, Ft2, Ft3 ... for fonts, Ig1, Ig2, Ig3 for images, Fo1 .. for forms, Cs1 .. for Color spaces, Pt1 .. for patterns, Sh1 .. for shading directories, Gs0 .. for graphic state parameter dictionaries. These names are kept until the program finishes, and my ambition is also to keep the resources available in internal tables.)</p><p>This is a simple and very powerful function. You should study the examples and the \*(L"PDF-reference manual\*(R", if you want to use it.(When this text is written, a possible link to download it is: http://partners.adobe.com/asn/developer/acrosdk/docs.html)</p><p>This function is intended to give you detail control at a low level.</p><p>   use PDF::Reuse;    use strict;</p><p>   prFile(&apos;myFile.pdf&apos;);    my $string = "150 600 100 50 re&#92;n";  # a rectangle    $string   .= "0 0 1 rg&#92;n";           # blue (to fill)    $string   .= "b&#92;n";                  # fill and stroke    prAdd($string);    prEnd();</p><h3>prBookmark		- define bookmarks</h3>
<p>   prBookmark($reference)</p><p>Defines a \*(L"bookmark\*(R". $reference refers to a hash or array of hashes which looks something like this:</p><p>          {  text  =&gt; &apos;Document&apos;,              act   =&gt; &apos;this.pageNum = 0; this.scroll(40, 500);&apos;,              kids  =&gt; [ { text =&gt; &apos;Chapter 1&apos;,                           act  =&gt; &apos;1, 40, 600&apos;                         },                         { text =&gt; &apos;Chapter 2&apos;,                           act  =&gt; &apos;10, 40, 600&apos;                         }                       ]           }</p><p>Each hash can have these components:</p><p>        text    the text shown beside the bookmark         act     the action to be triggered. Has to be a JavaScript action.                 (Three simple numbers are translated to page, x and y in the                 sentences: this.pageNum = page; this.scroll(x, y); )         kids    will have a reference to another hash or array of hashes         close   if this component is present, the bookmark will be closed                 when the document is opened         color   3 numbers, RGB-colors e.g. &apos;0.5 0.5 1&apos; for light blue         style   0, 1, 2, or 3. 0 = Normal, 1 = Italic, 2 = Bold, 3 = Bold Italic</p><p>Creating bookmarks for a document:</p><p>    use PDF::Reuse;     use strict;</p><p>    my @pageMarks;</p><p>    prFile(&apos;myDoc.pdf&apos;);</p><p>    for (my $i = 0; $i &lt; 100; $i++)     {   prText(40, 600, &apos;Something is written&apos;);         # ...         my $page = $i + 1;         my $bookMark = { text =&gt; "Page $page",                          act  =&gt; "$i, 40, 700" };         push @pageMarks, $bookMark;         prPage();     }     prBookmark( { text  =&gt; &apos;Document&apos;,                   close =&gt; 1,                   kids  =&gt; &#92;@pageMarks } );     prEnd();</p><p>Traditionally bookmarks have mainly been used for navigation within a document, but they can be used for many more things. You can e.g. use them to navigate within your data. You can let your users go to external links also, so they can \*(L"drill down\*(R" to other documents.</p><p><strong>See \*(L"Remarks about JavaScript\*(R"</strong></p>
<h3>prCompress		- compress/zip added streams</h3>
<p>   prCompress (1)</p><p>'1' here is a directive to compress all <strong>new</strong> streams of the current file. Streams which are included with prForm, prDocForm, prDoc or prSinglePage are not changed. New JavaScripts are also created as streams and compressed, if they are at least 100 bytes long. The streams are compressed in memory, so probably there is a limit of how big they can be.</p><p><em>prCompress()</em>; is a directive not to compress. This is default.</p><p>See e.g. \*(L"Starting to reuse\*(R" in the tutorial for an example.</p>
<h3>prDoc		- include pages from a document</h3>
<p>   prDoc ( $documentName, $firstPage, $lastPage )</p><p>or with the parameters in an anonymous hash:</p><p>   prDoc ( { file  =&gt; $documentName,              first =&gt; $firstPage,              last  =&gt; $lastPage } );</p><p>Returns number of extracted pages.</p><p>If \*(L"first\*(R" is not given, 1 is assumed. If \*(L"last\*(R" is not given, you don't have any upper limit. N.B. The numbering of the pages differs from Acrobat JavaScript. In JavaScript the first page has index 0.</p><p>Adds pages from a document to the one you are creating. N.B. From version 0.32 of this module: If there are contents created with with prText, prImage,prAdd, prForm and so on, prDoc tries to put the contents on the first extracted page from the old document.</p><p>If it is the first interactive component ( <em>prDoc()</em> or <em>prDocForm()</em> ) the interactive functions are kept and also merged with JavaScripts you have added, if any. But, if you specify a first page different than 1 or a last page, no JavaScript are extracted from the document, because then there is a risk that an included JavaScript function might refer to something not included.</p><p>   use PDF::Reuse;    use strict;</p><p>   prFile(&apos;myFile.pdf&apos;);                  # file to make    prJs(&apos;customerResponse.js&apos;);           # include a JavaScript file    prInit(&apos;nameAddress(12, 150, 600);&apos;);  # init a JavaScript function    prForm(&apos;best.pdf&apos;);                    # page 1 from best.pdf    prPage();    prDoc(&apos;long.pdf&apos;);                     # a document with 11 pages    prForm(&apos;best.pdf&apos;);                    # page 1 from best.pdf    prText(150, 700, &apos;Customer Data&apos;);     # a line of text    prEnd();</p><p>To extract pages 2-3 and 5-7 from a document and create a new document:</p><p>   use PDF::Reuse;    use strict;</p><p>   prFile(&apos;new.pdf&apos;);    prDoc( { file  =&gt; &apos;old.pdf&apos;,             first =&gt; 2,             last  =&gt; 3 });    prDoc( { file  =&gt; &apos;old.pdf&apos;,             first =&gt; 5,             last  =&gt; 7 });    prEnd();</p><p>To add a form, image and page number to each page of an 16 pages long document (The document Battery.pdf is cropped so each page is fairly small)  You could also have used prSinglePage, look at a very similar example under that function.</p><p>   use PDF::Reuse;    use PDF::Reuse::Util;    use strict;</p><p>   prFile(&apos;test.pdf&apos;);</p><p>     my $pageNumber = 0;</p><p>     for (my $page = 1; $page &lt; 17; $page++)      {   $pageNumber++;          prForm(  { file =&gt;&apos;Words.pdf&apos;,                     page =&gt; 5,                     x    =&gt; 150,                     y    =&gt; 150} );</p><p>         prImage( { file =&gt;&apos;Media.pdf&apos;,                     page =&gt; 6,                     imageNo =&gt; 1,                     x  =&gt; 450,                     y  =&gt; 450 } );          blackText();          prText( 360, 250, $pageNumber);          prDoc(&apos;Battery.pdf&apos;, $pageNumber, $pageNumber);      }    prEnd;</p>
<h3>prDocDir		- set directory for produced documents</h3>
<p>   prDocDir ( $directoryName )</p><p>Sets directory for produced documents</p><p>   use PDF::Reuse;    use strict;</p><p>   prDocDir(&apos;C:/temp/doc&apos;);    prFile(&apos;myFile.pdf&apos;);         # writes to C:&#92;temp&#92;doc&#92;myFile.pdf    prForm(&apos;myFile.pdf&apos;);         # page 1 from ..&#92;myFile.pdf    prText(200, 600, &apos;New text&apos;);    prEnd();</p>
<h3>prDocForm		- use an interactive page as a form</h3>
<p>Alternative 1) You put your parameters in an anonymous hash (only <strong>file</strong> is really necessary, the others get default values if not given).</p><p>   prDocForm ( { file     =&gt; $pdfFile,       # template file                  page     =&gt; $page,          # page number (of imported template)                  adjust   =&gt; $adjust,        # try to fill the media box                  effect   =&gt; $effect,        # action to be taken                  tolerant =&gt; $tolerant,      # continue even with an invalid form                  x        =&gt; $x,             # $x points from the left                  y        =&gt; $y,             # $y points from the bottom                  rotate   =&gt; $degree,        # rotate                  size     =&gt; $size,          # multiply everything by $size                  xsize    =&gt; $xsize,         # multiply horizontally by $xsize                  ysize    =&gt; $ysize } )      # multiply vertically by $ysize Ex.:     my $internalName = prDocForm ( {file     =&gt; &apos;myFile.pdf&apos;,                                     page     =&gt; 2 } );</p><p>Alternative 2) You put your parameters in this order</p><p>        prDocForm ( $pdfFile, [$page, $adjust, $effect, $tolerant, $x, $y, $degree,             $size, $xsize, $ysize] )</p><p>Anyway the function returns in list context:  <strong></strong><strong>$intName</strong><strong>, </strong><strong>@BoundingBox</strong><strong>,</strong> <strong>$numberOfImages</strong><strong></strong>, in scalar context:  <strong></strong><strong>$internalName</strong><strong></strong> of the form.</p><p>Look at <em>prForm()</em> for an explanation of the parameters.</p><p>N.B. Usually you shouldn't adjust or change size and proportions of an interactive page. The graphic and interactive components are independent of each other and there is a great risk that any coordination is lost.</p><p>This function redefines a page to an \*(L"XObject\*(R" (the graphic parts), then the page can be reused in a much better way. Unfortunately there is an important limitation here. \*(L"XObjects\*(R" can only have single streams. If the page consists of many streams, you should concatenate them first. Adobe Acrobat can do that. (If it is an important file, take a copy of it first. Sometimes the procedure fails.) Open the document with Acrobat. Then choose the the \*(L"TouchUp Text\*(R" tool (icon or from the tools menu). Select a line of text somewhere on the page. Right-click the mouse. Choose \*(L"Attributes\*(R".Change font size or anything else, and then you change it back to the old value. Save the document. If there was no text on the page, use some other \*(L"Touch Up\*(R" tool.</p><p>   use PDF::Reuse;    use strict;</p><p>   prDocDir(&apos;C:/temp/doc&apos;);    prFile(&apos;newForm.pdf&apos;);    prField(&apos;Mr/Ms&apos;, &apos;Mr&apos;);    prField(&apos;First_Name&apos;, &apos;Lars&apos;);    prDocForm(&apos;myFile.pdf&apos;);    prFontSize(24);    prText(75, 790, &apos;This text is added&apos;);    prEnd();</p><p>(You can use the output from the example in <em>prJs()</em> as input to this example. Remember to save that file before closing it.)</p><p><strong>See Remarks about JavaScript</strong></p>
<h3>prExtract		- extract an object group</h3>
<p>   prExtract ( $pdfFile, $pageNo, $oldInternalName )</p><p><strong>oldInternalName</strong>, a \*(L"name\*(R"-object.  This is the internal name you find in the original file. Returns a <strong></strong><strong>$newInternalName</strong><strong></strong> which can be used for \*(L"low level\*(R" programming. You have better look at graphObj_pl and modules it has generated for the tutorial, e.g. thermometer.pm, to see how this function can be used.</p><p>When you call this function, the necessary objects will be copied to your new PDF-file, and you can refer to them with the new name you receive.</p>
<h3>prField		- assign a value to an interactive field</h3>
<p>        prField ( $fieldName, $value )</p><p><strong></strong><strong>$fieldName</strong><strong></strong> is an interactive field in the document you are creating. It has to be spelled exactly the same way here as it spelled in the document. <strong></strong><strong>$value</strong><strong></strong> is what you want to assigned to the field. Put all your sentences with prField early in your script. After prFile and <strong>before</strong> prDoc or prDocForm and of course before prEnd. Each sentence with prField is translated to JavaScript and merged with old JavaScript</p><p>See <em>prDocForm()</em> for an example</p><p>If you are going to assign a value to a field consisting of several lines, you can write like this:</p><p>   my $string = "This is the first line &#92;r second line &#92;n 3:rd line";    prField(&apos;fieldName&apos;, $string);</p><p>You can also let '$value' be a  snippet of JavaScript-code that assigns something to the field. Then you have to put 'js:' first in \*(L"$value\*(R" like this:</p><p>   my $sentence = encrypt(&apos;This will be decrypted by "unPack"(JavaScript) &apos;);    prField(&apos;Interest_9&apos;, "js: unPack(&apos;$sentence&apos;)");</p><p>If you refer to a JavaScript function, it has to be included with prJs first. (The JavaScript interpreter will simply not be aware of old functions in the PDF-document, when the initiation is done.)</p>
<h3>prFont		- set current font</h3>
<p>   prFont ( $fontName )</p><p>$fontName is an \*(L"external\*(R" font name. The parameter is optional. In list context returns <strong></strong><strong>$internalName</strong><strong>, </strong><strong>$externalName</strong><strong>, </strong><strong>$oldInternalName</strong><strong>,</strong> <strong>$oldExternalname</strong><strong></strong> The first two variables refer to the current font, the two later to the font before the change. In scalar context returns b&lt;$internalName&gt;</p><p>If a font wasn't found, Helvetica will be set. These names are always recognized: <strong>Times-Roman, Times-Bold, Times-Italic, Times-BoldItalic, Courier, Courier-Bold,</strong> Courier-Oblique, Courier-BoldOblique, Helvetica, Helvetica-Bold, Helvetica-Oblique, Helvetica-BoldOblique or abbreviated <strong>\s-1TR\s0, \s-1TB\s0, \s-1TI\s0, \s-1TBI\s0, C, \s-1CB\s0, \s-1CO\s0, \s-1CBO\s0, H, \s-1HB\s0, \s-1HO\s0, \s-1HBO\s0</strong>. (<strong>Symbol and ZapfDingbats</strong> or abbreviated <strong>S, Z</strong>, also belong to the predefined fonts, but there is something with them that I really don't understand. You should print them first on a page, and then use other fonts, otherwise they are not displayed.)</p><p>You can also use a font name from an included page. It has to be spelled exactly as it is done there. Look in the file and search for \*(L"/BaseFont\*(R" and the font name. But take care, e.g. the PDFMaker which converts to \s-1PDF\s0 from different Microsoft programs, only defines exactly those letters you can see on the page. You can use the font, but perhaps some of your letters were not defined.</p><p>In the distribution there is an utility program, 'reuseComponent_pl', which displays included fonts in a PDF-file and prints some letters. Run it to see the name of the font and if it is worth extracting.</p><p>   use PDF::Reuse;    use strict;    prFile(&apos;myFile.pdf&apos;);</p><p>   ####### One possibility #########</p><p>   prFont(&apos;Times-Roman&apos;);     # Just setting a font    prFontSize(20);    prText(180, 790, "This is a heading");</p><p>   ####### Another possibility #######</p><p>   my $font = prFont(&apos;C&apos;);    # Setting a font, getting an                               # internal name    prAdd("BT /$font 12 Tf 25 760 Td (This is some other text)Tj ET");    prEnd();</p><p>The example above shows you two ways of setting and using a font. One simple, and one complicated with a possibility to detail control.</p>
<h3>prFontSize		- set current font size</h3>
<p>   prFontSize ( $size )</p><p>Returns <strong></strong><strong>$actualSize</strong><strong>, </strong><strong>$fontSizeBeforetheChange</strong><strong></strong>. Without parameters <em>prFontSize()</em> sets the size to 12 points, which is default.</p>
<h3>prForm		- use a page from an old document as a form/background</h3>
<p>Alternative 1) You put your parameters in an anonymous hash (only <strong>file</strong> is really necessary, the others get default values if not given).</p><p>   prForm ( { file     =&gt; $pdfFile,       # template file               page     =&gt; $page,          # page number (of imported template)               adjust   =&gt; $adjust,        # try to fill the media box               effect   =&gt; $effect,        # action to be taken               tolerant =&gt; $tolerant,      # continue even with an invalid form               x        =&gt; $x,             # $x points from the left               y        =&gt; $y,             # $y points from the bottom               rotate   =&gt; $degree,        # rotate               size     =&gt; $size,          # multiply everything by $size               xsize    =&gt; $xsize,         # multiply horizontally by $xsize               ysize    =&gt; $ysize } )      # multiply vertically by $ysize Ex.:     my $internalName = prForm ( {file     =&gt; &apos;myFile.pdf&apos;,                                  page     =&gt; 2 } );</p><p>Alternative 2) You put your parameters in this order</p><p>        prForm ( $pdfFile, $page, $adjust, $effect, $tolerant, $x, $y, $degree,             $size, $xsize, $ysize )</p><p>Anyway the function returns in list context:  <strong></strong><strong>$intName</strong><strong>, </strong><strong>@BoundingBox</strong><strong>,</strong> <strong>$numberOfImages</strong><strong></strong>, in scalar context:  <strong></strong><strong>$internalName</strong><strong></strong> of the form.</p><p>if <strong>page</strong> is excluded 1 is assumed.</p><p><strong>adjust</strong>, could be 1, 2 or 0/nothing. If it is 1, the program tries to adjust the form to the current media box (paper size) and keeps the proportions unchanged. If it is 2, the program tries to fill as much of the media box as possible, without regards to the original proportions. If this parameter is given, \*(L"x\*(R", \*(L"y\*(R", \*(L"rotate\*(R", \*(L"size\*(R", \*(L"xsize\*(R" and \*(L"ysize\*(R" will be ignored.</p><p><strong>effect</strong> can have 3 values: <strong>'print'</strong>, which is default, loads the page in an internal table, adds it to the document and prints it to the current page. <strong>'add'</strong>, loads the page and adds it to the document. (Now you can \*(L"manually\*(R" manage the way you want to print it to different pages within the document.) <strong>'load'</strong> just loads the page in an internal table. (You can now take <em>parts</em> of a page like fonts and objects and manage them, without adding all the page to the document.)You don't get any defined internal name of the form, if you let this parameter be 'load'.</p><p><strong>tolerant</strong> can be nothing or something. If it is undefined, you will get an error if your program tries to load a page which the system cannot really handle, if it e.g. consists of many streams. If it is set to something, you have to test the first return value $internalName to know if the function was successful. Look at the program 'reuseComponent_pl' for an example of usage.</p><p><strong>x</strong> where to start along the x-axis   (cannot be combined with \*(L"adjust\*(R")</p><p><strong>y</strong> where to start along the y-axis   (cannot be combined with \*(L"adjust\*(R")</p><p><strong>rotate</strong> A degree 0-360 to rotate the form counter-clockwise. (cannot be combined with \*(L"adjust\*(R") Often the form disappears out of the media box if degree &gt;= 90. Then you can move it back with the x and y-parameters. If degree == 90, you can add the width of the form to x, If degree == 180 add both width and height to x and y, and if degree == 270 you can add the height to y.</p><p><strong>rotate</strong> can also by one of 'q1', 'q2' or 'q3'. Then the system rotates the form clockwise 90, 180 or 270 degrees and tries to keep the form within the media box.</p><p>The rotation takes place after the form has been resized or moved.</p><p>   Ex. To rotate from portrait (595 x 842 pt) to landscape (842 x 595 pt)</p><p>   use PDF::Reuse;    use strict;</p><p>   prFile(&apos;New_Report.pdf&apos;);    prMbox(0, 0, 842, 595);</p><p>   prForm({file   =&gt; &apos;cert1.pdf&apos;,            rotate =&gt; &apos;q1&apos; } );    prEnd();</p><p>The same rotation can be achieved like this:</p><p>   use PDF::Reuse;    use strict;</p><p>   prFile(&apos;New_Report.pdf&apos;);    prMbox(0, 0, 842, 595);</p><p>   prForm({file   =&gt; &apos;cert1.pdf&apos;,            rotate =&gt; 270,            y      =&gt; 595 } );    prEnd();</p><p><strong>size</strong> multiply every measure by this value (cannot be combined with \*(L"adjust\*(R")</p><p><strong>xsize</strong> multiply horizontally by this value (cannot be combined with \*(L"adjust\*(R")</p><p><strong>ysize</strong> multiply vertically by $ysize (cannot be combined with \*(L"adjust\*(R")</p><p>This function redefines a page to an \*(L"XObject\*(R" (the graphic parts), then the page can be reused and referred to as a unit. Unfortunately there is an important limitation here. \*(L"XObjects\*(R" can only have single streams. If the page consists of many streams, you should concatenate them first. Adobe Acrobat can do that. (If it is an important file, take a copy of it first. Sometimes the procedure fails.) Open the document with Acrobat. Then choose the \*(L"TouchUp Text\*(R" tool. Select a line of text somewhere. Right-click the mouse. Choose \*(L"Attributes\*(R". Change font size or anything else, and then you change it back to the old value. Save the document. You could alternatively save the file as Postscript and redistill it with the distiller or with Ghost script, but this is a little more risky. You might loose fonts or something else. An other alternative could be to use <em>prSinglePage()</em>.</p><p>   use PDF::Reuse;    use strict;</p><p>   prFile(&apos;myFile.pdf&apos;);    prForm(&apos;best.pdf&apos;);    # Takes page No 1    prText(75, 790, &apos;Dear Mr Gates&apos;);    # ...    prPage();    prMbox(0, 0, 900, 960);    my @vec = prForm(   { file =&gt; &apos;EUSA.pdf&apos;,                          adjust =&gt; 1 } );    prPage();    prMbox();    prText(35, 760, &apos;This is the final page&apos;);</p><p>   # More text ..</p><p>   #################################################################    # We want to put a miniature of EUSA.pdf, 35 points from the left    # 85 points up, and in the format 250 X 200 points    #################################################################</p><p>   my $xScale = 250 / ($vec[3] - $vec[1]);    my $yScale = 200 / ($vec[4] - $vec[2]);</p><p>   prForm ({ file =&gt; &apos;EUSA.pdf&apos;,              xsize =&gt; $xScale,              ysize =&gt; $yScale,              x     =&gt; 35,              y     =&gt; 85 });</p><p>   prEnd();</p><p>The first <em>prForm()</em>, in the code, is a simple and \*(L"normal\*(R" way of using the the function. The second time it is used, the size of the imported page is changed. It is adjusted to the media box which is current at that moment. Also data about the form is taken, so you can control more in detail how it will be displayed.</p>
<h3>prGetLogBuffer		- get the log buffer.</h3>
<p>prGetLogBuffer ()</p><p>returns a <strong></strong><strong>$buffer</strong><strong></strong> of the log of the current page. (It could be used e.g. to calculate a MD5-digest of what has been registered that far, instead of accumulating the single values) A log has to be active, see <em>prLogDir()</em> below</p><p>Look at \*(L"Using the template\*(R" and \*(L"Restoring a document from the log\*(R" in the tutorial for examples of usage.</p>
<h3>prGraphState		- define a graphic state parameter dictionary</h3>
<p>   prGraphState ( $string )</p><p>This is a \*(L"low level\*(R" function. Returns <strong></strong><strong>$internalName</strong><strong></strong>. The <strong></strong><strong>$string</strong><strong></strong> has to be a complete dictionary with initial \*(L"&lt;&lt;\*(R" and terminating \*(L"&gt;&gt;\*(R". No syntactical checks are made. Perhaps you will never have to use this function.</p><p>   use PDF::Reuse;    use strict;</p><p>   prFile(&apos;myFile.pdf&apos;);</p><p>   ###################################################    # Draw a triangle with Gs0 (automatically defined)    ###################################################</p><p>   my $str = "q&#92;n";    $str   .= "/Gs0 gs&#92;n";    $str   .= "150 700 m&#92;n";    $str   .= "225 800 l&#92;n";    $str   .= "300 700 l&#92;n";    $str   .= "150 700 l&#92;n";    $str   .= "S&#92;n";    $str   .= "Q&#92;n";    prAdd($str);</p><p>   ########################################################    # Define a new graph. state param. dic. and draw a new    # triangle further down    ########################################################</p><p>   $str = &apos;&lt;&lt;/Type/ExtGState/SA false/SM 0.02/TR2 /Default&apos;                       . &apos;/LW 15/LJ 1/ML 1&gt;&gt;&apos;;    my $gState = prGraphState($str);    $str  = "q&#92;n";    $str .= "/$gState gs&#92;n";    $str .= "150 500 m&#92;n";    $str .= "225 600 l&#92;n";    $str .= "300 500 l&#92;n";    $str .= "150 500 l&#92;n";    $str .= "S&#92;n";    $str .= "Q&#92;n";    prAdd($str);</p><p>   prEnd();</p>
<h3>prImage		- reuse an image from an old \s-1PDF\s0 document</h3>
<p>Alternative 1) You put your parameters in an anonymous hash (only <strong>file</strong> is really necessary, the others get default values if not given).</p><p>   prImage( { file     =&gt; $pdfFile,       # template file               page     =&gt; $page,          # page number               imageNo  =&gt; $imageNo        # image number               adjust   =&gt; $adjust,        # try to fill the media box               effect   =&gt; $effect,        # action to be taken               x        =&gt; $x,             # $x points from the left               y        =&gt; $y,             # $y points from the bottom               rotate   =&gt; $degree,        # rotate               size     =&gt; $size,          # multiply everything by $size               xsize    =&gt; $xsize,         # multiply horizontally by $xsize               ysize    =&gt; $ysize } )      # multiply vertically by $ysize Ex.:    prImage( { file    =&gt; &apos;myFile.pdf&apos;,               page    =&gt; 10,               imageNo =&gt; 2 } );</p><p>Alternative 2) You put your parameters in this order</p><p>        prImage ( $pdfFile, [$page, $imageNo, $effect, $adjust, $x, $y, $degree,             $size, $xsize, $ysize] )</p><p>Returns in scalar context <strong></strong><strong>$internalName</strong><strong></strong> As a list <strong></strong><strong>$internalName</strong><strong>, </strong><strong>$width</strong><strong>,</strong> <strong>$height</strong><strong></strong></p><p>Assumes that $pageNo and $imageNo are 1, if not specified. If $effect is given and anything else then 'print', the image will be defined in the document, but not shown at this moment.</p><p>For all other parameters, look at <em>prForm()</em>.</p><p>   use PDF::Reuse;    use strict;</p><p>   prFile(&apos;myFile.pdf&apos;);    my @vec = prImage({ file  =&gt; &apos;best.pdf&apos;,                        x     =&gt; 10,                        y     =&gt; 400,                        xsize =&gt; 0.9,                        ysize =&gt; 0.8 } );    prText(35, 760, &apos;This is some text&apos;);    # ...    prPage();    my @vec2 = prImage( { file    =&gt; &apos;destiny.pdf&apos;,                          page    =&gt; 1,                          imageNo =&gt; 1,                          effect  =&gt; &apos;add&apos; } );    prText(25, 760, "There shouldn&apos;t be any image on this page");    prPage();    ########################################################    #  Now we make both images so that they could fit into    #  a box 300 X 300 points, and they are displayed    ########################################################</p><p>   prText(25, 800, &apos;This is the first image :&apos;);</p><p>   my $xScale = 300 / $vec[1];    my $yScale = 300 / $vec[2];    if ($xScale &lt; $yScale)    {  $yScale = $xScale;    }    else    {  $xScale = $yScale;    }    prImage({ file   =&gt; &apos;best.pdf&apos;,              x      =&gt; 25,              y      =&gt; 450,              xsize  =&gt; $xScale,              ysize  =&gt; $yScale} );</p><p>   prText(25, 400, &apos;This is the second image :&apos;);</p><p>   $xScale = 300 / $vec2[1];    $yScale = 300 / $vec2[2];    if ($xScale &lt; $yScale)    {  $yScale = $xScale;    }    else    {  $xScale = $yScale;    }    prImage({ file   =&gt; &apos;destiny.pdf&apos;,              x      =&gt; 25,              y      =&gt; 25,              xsize  =&gt; $xScale,              ysize  =&gt; $yScale} );</p><p>   prEnd();</p><p>On the first page an image is displayed in a simple way. While the second page is processed, <em>prImage()</em>, loads an image, but it is not shown here. On the 3:rd page, the two images are scaled and shown.</p><p>In the distribution there is an utility program, 'reuseComponent_pl', which displays included images in a PDF-file and their \*(L"names\*(R".</p>
<h3>prInit		- add JavaScript to be executed at initiation</h3>
<p>   prInit ( $string, $duplicateCode )</p><p><strong></strong><strong>$string</strong><strong></strong> can be any JavaScript code, but you can only refer to functions included with prJs. The JavaScript interpreter will not know other functions in the document. Often you can add new things, but you can't remove or change interactive fields, because the interpreter hasn't come that far, when initiation is done.</p><p><strong></strong><strong>$duplicateCode</strong><strong></strong> is undefined or anything. It duplicates the JavaScript code which has been used at initiation, so you can look at it from within Acrobat and debug it. It makes the document bigger. This parameter is <strong>deprecated</strong>.</p><p>   use PDF::Reuse;    use strict;</p><p>   prFile(&apos;myFile.pdf&apos;);    prInit(&apos;app.alert("This is displayed when opening the document");&apos;);</p><p>   prEnd();</p><p>Remark: Avoid to use \*(L"return\*(R" in the code you use at initiation. If your user has downloaded a page with Web Capture, and after that opens a PDF-document where a JavaScript is run at initiation and that JavaScript contains a return-statement, a bug occurs. The JavaScript interpreter \*(L"exits\*(R" instead of returning, the execution of the JavaScript might finish to early. This is a bug in Acrobat/Reader 5.</p>
<h3>prInitVars		- initiate global variables and internal tables</h3>
<p>   <strong>prInitVars</strong>(1)</p><p>If you run programs with PDF::Reuse as persistent procedures, you probably need to initiate global variables. If you have '1' or anything as parameter, internal tables for forms, images, fonts and interactive functions are <strong>not</strong> initiated. The module \*(L"learns\*(R" offset and sizes of used objects, and can process them faster, but at the same time the size of the program grows.</p><p>   use PDF::Reuse;    use strict;    prInitVars();     # To initiate ALL global variables and tables    # <strong>prInitVars</strong>(1);  # To make it faster, but more memory consuming</p><p>   $| = 1;    print STDOUT "Content-Type: application/pdf &#92;n&#92;n";</p><p>   prFile();         # To send the document uncatalogued to STDOUT</p><p>   prForm(&apos;best.pdf&apos;);    prText(25, 790, &apos;Dear Mr. Anders Persson&apos;);    # ...    prEnd();</p><p>If you call this function without parameters all global variables, including the internal tables, are initiated.</p>
<h3>prJpeg		- import a jpeg-image</h3>
<p>   prJpeg ( $imageFile, $width, $height )</p><p><strong></strong><strong>$imageFile</strong><strong></strong> contains 1 single jpeg-image. <strong></strong><strong>$width</strong><strong></strong> and <strong></strong><strong>$height</strong><strong></strong> also have to be specified. Returns the <strong></strong><strong>$internalName</strong><strong></strong></p><p>   use PDF::Reuse;    use Image::Info qw(image_info dim);    use strict;</p><p>   my $file = &apos;myImage.jpg&apos;;    my $info = image_info($file);    my ($width, $height) = dim($info);    # Get the dimensions</p><p>   prFile(&apos;myFile.pdf&apos;);    my $intName = prJpeg("$file",         # Define the image                          $width,         # in the document                          $height);</p><p>   my $str = "q&#92;n";    $str   .= "$width 0 0 $height 10 10 cm&#92;n";    $str   .= "/$intName Do&#92;n";    $str   .= "Q&#92;n";    prAdd($str);    prEnd();</p><p>This is a little like an extra or reserve routine to add images to the document. The most simple way is to use <em>prImage()</em></p>
<h3>prJs		- add JavaScript</h3>
<p>   prJs ( $string|$fileName )</p><p>To add JavaScript to your new document. <strong></strong><strong>$string</strong><strong></strong> has to consist only of JavaScript functions: function a (..){ ... } function b (..) { ...} and so on If <strong></strong><strong>$string</strong><strong></strong> doesn't contain '{', <strong></strong><strong>$string</strong><strong></strong> is interpreted as a filename. In that case the file has to consist only of JavaScript functions.</p><p><strong>See \*(L"Remarks about JavaScript\*(R"</strong></p>
<h3>prLink    - add a hyper link</h3>
<p>   prLink( { page   =&gt; $pageNo,     # Starting with 1  !              x      =&gt; $x,              y      =&gt; $y,              width  =&gt; $width,              height =&gt; $height,              URI    =&gt; $URI     } );</p><p>You can also call prLink like this:</p><p>   prLink($page, $x, $y, $width, $height, $URI);</p><p>You have to put prLink <strong>after prFile and before the sentences where its' page</strong> is created. The links are created at the page-breaks. If the page is already created, no new link will be inserted.</p><p>Here is an example where the links of a 4 page document are preserved, and a link is added at the end of the document. We assume that there is some suitable text at that place (x = 400, y = 350):</p><p>   use strict;    use PDF::Reuse;</p><p>   prFile(&apos;test.pdf&apos;);</p><p>   prLink( {page   =&gt; 4,             x      =&gt; 400,             y      =&gt; 350,             width  =&gt; 105,             height =&gt; 15,             URI    =&gt; &apos;http://www.purelyInvented.com/info.html&apos; } );</p><p>   prDoc(&apos;fourPages.pdf&apos;);</p><p>   prEnd();</p><p>( If you are creating each page of a document separately, you can also use 'hyperLink' from PDF::Reuse::Util. Then you get an external text in Helvetica-Oblique, underlined and in blue.</p><p>  use strict;   use PDF::Reuse;   use PDF::Reuse::Util;</p><p>  prFile(&apos;test.pdf&apos;);   prForm(&apos;template.pdf&apos;, 5);   my ($from, $pos) = prText(25, 700, &apos;To get more information  &apos;);</p><p>  $pos = hyperLink( $pos, 700, &apos;Press this link&apos;,                     &apos;http://www.purelyInvented.com/info.html&apos; );   ($from, $pos) = prText( $pos, 700, &apos; And get connected&apos;);   prEnd();</p><p>'hyperLink' has a few parameters: $x, $y, $textToBeShown, $hyperLink and $fontSize (not shown in the example). It returns current x-position. )</p>
<h3>prLog		- add a string to the log</h3>
<p>   prLog ( $string )</p><p>Adds whatever you want to the current log (a reference No, a commentary, a tag ?) A log has to be active see <em>prLogDir()</em></p><p>Look at \*(L"Using the template\*(R" and \*(L"Restoring the document from the log\*(R" in the tutorial for an example.</p>
<h3>prLogDir		- set directory for the log</h3>
<p>   prLogDir ( $directory )</p><p>Sets a directory for the logs and activates the logging. A little log file is created for each PDF-file. Normally it should be much, much more compact then the PDF-file, and it should be possible to restore or verify a document with the help of it. (Of course you could compress or store the logs in a database to save even more space.)</p><p>   use PDF::Reuse;    use strict;</p><p>   prDocDir(&apos;C:/temp/doc&apos;);    prLogDir(&apos;C:/run&apos;);</p><p>   prFile(&apos;myFile.pdf&apos;);    prForm(&apos;best.pdf&apos;);    prText(25, 790, &apos;Dear Mr. Anders Persson&apos;);    # ...    prEnd();</p><p>In this example a log file with the name 'myFile.pdf.dat' is created in the directory 'C:&#92;run'. If that directory doesn't exist, the system tries to create it. (But, just as mkdir does, it only creates the last level in a directory tree.)</p>
<h3>prMbox		- define the format (MediaBox) for a new page.</h3>
<p>   prMbox ( $lowerLeftX, $lowerLeftY, $upperRightX, $upperRightY )</p><p>If the function or the parameters are missing, they are set to 0, 0, 595, 842 points respectively. Only for new pages. Pages created with prDoc and prSinglePage keep their media boxes unchanged.</p><p>See <em>prForm()</em> for an example.</p>
<h3>prPage		- create/insert a page</h3>
<p>   prPage ($noLog)</p><p>Don't use the optional parameter, it is only used internally, not to clutter the log, when automatic page breaks are made.</p><p>See <em>prForm()</em> for an example.</p>
<h3>prSinglePage  - take single pages, one by one, from an old document</h3>
<p>   prSinglePage($file, $pageNumber)</p><p>$pageNumber is optional. If not given, next page is assumed Returns number of remaining pages. This function is a variant of prDoc for single pages, with the addition that it has a counter of last page read, and total number of pages of the old document, so it can be used to loop through a document.</p><p>To add a form, image and page number to each page of a document (The document Battery.pdf is cropped so each page is fairly small)  You could also have used prDoc, but only if you knew in advance the number of pages of the old document</p><p>   use PDF::Reuse;    use PDF::Reuse::Util;    use strict;</p><p>   prFile(&apos;test.pdf&apos;);</p><p>   my $pageNumber = 0;    my $left = 1;            # Every valid PDF-document has at least 1 page,                             # so that can be assumed</p><p>   while ($left)    {   $pageNumber++;        prForm(  { file =&gt;&apos;Words.pdf&apos;,                   page =&gt; 5,                   x    =&gt; 150,                   y    =&gt; 150} );</p><p>       prImage( { file    =&gt;&apos;Media.pdf&apos;,                   page    =&gt; 6,                   imageNo =&gt; 1,                   x       =&gt; 450,                   y       =&gt; 450 } );        blackText();        prText( 360, 250, $pageNumber);        $left = prSinglePage(&apos;Battery.pdf&apos;);     }</p><p>    prEnd;</p><p>prSinglePage creates a new page from an old document and adds new content (to the array of streams of that page). Most often you can add new contents to the page like the example above, and it works fine, but sometimes you get surprises. There can e.g. be instructions in the earlier contents to make filling color white, and then you will probably not see added new text. That is why <em>PDF::Reuse::Util::blackText()</em> is used in the example. There can be other instructions like moving or rotating the user space. Also new contents can end up outside the crop-box. Of course all new programs should be tested. If prSinglePage can't be used, try to use prForm followed by prPage instead.</p>
<h3>prStrWidth   - calculate the string width</h3>
<p>   prStrWidth($string, $font, $fontSize)</p><p>Returns string width in points. Should be used in conjunction with one of these predefined fonts of Acrobat/Reader: Times-Roman, Times-Bold, Times-Italic, Times-BoldItalic, Courier, Courier-Bold, Courier-Oblique, Courier-BoldOblique, Helvetica, Helvetica-Bold, Helvetica-Oblique, Helvetica-BoldOblique or with a TrueType font embedded with prTTFont. If some other font is given, Helvetica is used, and the returned value will at the best be approximate.</p>
<h3>prText		- add a text-string</h3>
<p>   prText ( $x, $y, $string, $align, $rotation )</p><p>Puts <strong></strong><strong>$string</strong><strong></strong> at position <strong></strong><strong>$x</strong><strong>, </strong><strong>$y</strong><strong></strong> Returns 1 in scalar context. Returns ($xFrom, $xTo) in list context. $xTo will not be defined together with a rotation. <em>prStrWidth()</em> is used to calculate the length of the strings, so only the predefined fonts together with Acrobat/Reader, or embedded TrueType fonts will give reliable values for $xTo.</p><p>$align can be 'left' (= default), 'center' or 'right'. The parameter is optional.</p><p>$rotation can be a degree 0 - 360, 'q1', 'q2' or 'q3'. Also optional.</p><p>Current font and font size are used. (If you use <em>prAdd()</em> before this function, many other things could also influence the text.)</p><p>   use strict;    use PDF::Reuse;</p><p>   prFile(&apos;test.pdf&apos;);</p><p>   #####################################    # Use a "curser" ($pos) along a line    #####################################</p><p>   my ($from, $pos) = prText(25, 800, &apos;First write this. &apos;);    ($from, $pos) = prText($pos, 800, &apos;Then write this. &apos;);    prText($pos, 800, &apos;Finally write this.&apos;);</p><p>   #####################################    # Right adjust and center sentences    #####################################</p><p>   prText( 200, 750, &apos;A short sentence&apos;, &apos;right&apos;);    prText( 200, 735, &apos;This is a longer sentence&apos;, &apos;right&apos;);    prText( 200, 720, &apos;A word&apos;, &apos;right&apos;);</p><p>   prText( 200, 705, &apos;Centered around a point 200 points from the left&apos;, &apos;center&apos;);    prText( 200, 690, &apos;The same center&apos;, &apos;center&apos;);    prText( 200, 675, &apos;-&gt;.&lt;-&apos;, &apos;center&apos;);</p><p>   ############    # Rotation    ############</p><p>   prText( 200, 550, &apos; Rotate 0 degrees&apos;,&apos;&apos;, 0);    prText( 200, 550, &apos; Rotate 60 degrees&apos;,&apos;&apos;, 60);    prText( 200, 550, &apos; Rotate 120 degrees&apos;,&apos;&apos;, 120);    prText( 200, 550, &apos; Rotate 180 degrees&apos;,&apos;&apos;, 180);    prText( 200, 550, &apos; Rotate 240 degrees&apos;,&apos;&apos;, 240);    prText( 200, 550, &apos; Rotate 300 degrees&apos;,&apos;&apos;, 300);</p><p>   prText( 400, 430, &apos;Rotate 90 degrees clock-wise&apos;,&apos;&apos;,&apos;q1&apos;);    prText( 400, 430, &apos;Rotate 180 degrees clock-wise&apos;,&apos;&apos;, &apos;q2&apos;);    prText( 400, 430, &apos;Rotate 270 degrees clock-wise&apos;,&apos;&apos;, &apos;q3&apos;);</p><p>   ##########################    # Rotate and right adjust    ##########################</p><p>   prText( 200, 230, &apos;Rotate 90 degrees clock-wise ra-&gt;&apos;,&apos;right&apos;,&apos;q1&apos;);    prText( 200, 230, &apos;Rotate 180 degrees clock-wise ra-&gt;&apos;,&apos;right&apos;, &apos;q2&apos;);    prText( 200, 230, &apos;Rotate 270 degrees clock-wise ra-&gt;&apos;,&apos;right&apos;, &apos;q3&apos;);</p><p>   prEnd();</p>
<h3>prTTFont         - select and embed a TrueType font</h3>
<p>  prTTFont ( "/path/to/font/file.ttf" )</p><p>This function is equivalent to \*(C`prFont\*(C' except that rather than restricting you to the list of core built-in fonts, it allows you to select an external TrueType font file and have it embedded in your \s-1PDF\s0 document.  Using TrueType fonts also enables the \*(C`prText\*(C' function to accept \s-1UTF-8\s0 strings, which allows you to use characters outside the Mac-Roman/Win-ANSI character sets used by the built-in fonts.</p><p>You can specify the same font path multiple times in one document and only one copy will be embedded.  Alternatively, \*(C`prTTFont\*(C' returns an identifier which can be used to select the same font again:</p><p>  my $arial = prTTFont(&apos;/path/to/Arial.ttf&apos;);   prFontSize(20);   prText(20, 700, &apos;Some text in Arial&apos;);   #   # ... later ...   #   prPage();   prTTFont($arial);   prFontSize(12);   prText(20, 700, &apos;Some more text in Arial&apos;);   #   #  to pass a UTF8 string to prText   #   prText(20, 675, "T&#92;x{113}n&#92;x{101} koutou");  # T?n? Koutou</p><p>In list context this function returns $internalName, $externalName, $oldInternalName, $oldExternalname. The first two variables refer to the current font, the last two refer to the font before the change. In scalar context only $internalName is returned.</p><p>Note: To use this function, you must have the Font::TTF and Text::PDF modules installed.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INTERNAL OR DEPRECATED FUNCTIONS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    prBar		- define and paint bars for bar fonts
  </dt>
  <dd>
    <p>   prBar ($x, $y, $string) Prints a bar font pattern at the current page. Returns $internalName for the font. $x and $y are coordinates in points and $string should consist of the characters '0', '1' and '2' (or 'G'). '0' is a white bar, '1' is a dark bar. '2' and 'G' are dark, slightly longer bars, guard bars. You can use e.g. GD::Barcode or one module in that group to calculate the bar code pattern. prBar \*(L"translates\*(R" the pattern to white and black bars.    use PDF::Reuse;    use GD::Barcode::Code39;    use strict;</p><p>   prFile(&apos;myFile.pdf&apos;);    my $oGdB = GD::Barcode::Code39-&gt;new(&apos;JOHN DOE&apos;);    my $sPtn = $oGdB-&gt;barcode();    prBar(100, 600, $sPtn);    prEnd(); Internally the module uses a font for the bars, so you might want to change the font size before calling this function. In that case, use <em>prFontSize()</em> . If you call this function without arguments it defines the bar font but does not write anything to the current page. <strong>An easier and often better way to produce bar codes is to use PDF::Reuse::Barcode.</strong> Look at that module!</p>
  </dd>
  <dt>
    prCid		- define time stamp/check id
  </dt>
  <dd>
    <p>   prCid ( $timeStamp ) An internal function. Don't bother about it. It is used in automatic routines when you want to restore a document. It gives modification time of the next PDF-file or JavaScript. See \*(L"Restoring a document from the log\*(R" in the tutorial for more about the time stamp</p>
  </dd>
  <dt>
    prId		- define id-string of a \s-1PDF\s0 document
  </dt>
  <dd>
    <p>   prId ( $string ) An internal function. Don't bother about it. It is used e.g. when a document is restored and an id has to be set, not calculated.</p>
  </dd>
  <dt>
    prIdType		- define id-type
  </dt>
  <dd>
    <p>   prIdType ( $string ) An internal function. Avoid using it. <strong></strong><strong>$string</strong><strong></strong> could be \*(L"Rep\*(R" for replace or \*(L"None\*(R" to avoid calculating an id. Normally you don't use this function. Then an id is calculated with the help of Digest::MD5::md5_hex and some data from the run.</p>
  </dd>
  <dt>
    prTouchUp		- make changes and reuse more difficult
  </dt>
  <dd>
    <p>   prTouchUp (1); By default and after you have issued <em>prTouchUp</em>\|(1), you can change the document with the TouchUp tool from within Acrobat. If you want to switch off this possibility, you use <em>prTouchUp()</em> without any parameter.  Then the user shouldn't be able to change anything graphic by mistake. He has to do something premeditated and perhaps with a little effort. He could still save it as Postscript and redistill, or he could remove or add single pages. (Here is a strong reason why the log files, and perhaps also check sums, are needed. It would be very difficult to forge a document unless the forger also has access to your computer and knows how the check sums are calculated.) <strong>Avoid to switch off the TouchUp tool for your templates.</strong> It creates an extra level within the PDF-documents . Use this function for your final documents. See \*(L"Using the template\*(R" in the tutorial for an example. This function works for pages created with prPage, but mot with prDoc and prSinglePage, So it is more or less deprecated as these function have developed. (To encrypt your documents: use the batch utility within Acrobat)</p>
  </dd>
  <dt>
    prVers		- check version of log and program
  </dt>
  <dd>
    <p>   prVers ( $versionNo ) To check version of this module in case a document has to be restored.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO PDF::Reuse&hellip;</h2>
        <div class="sectioncontent">
<p>   PDF::Reuse::Tutorial    PDF::Reuse::Barcode    PDF::Reuse::OverlayChart</p><p>To program with PDF-operators, look at \*(L"The PDF-reference Manual\*(R" which probably is possible to download from http://partners.adobe.com/asn/tech/pdf/specifications.jsp Look especially at chapter 4 and 5, Graphics and Text, and the Operator summary.</p><p>Technical Note # 5186 contains the \*(L"Acrobat JavaScript Object Specification\*(R". I downloaded it from http://partners.adobe.com/asn/developer/technotes/acrobatpdf.html</p><p>If you are serious about producing PDF-files, you probably need Adobe Acrobat sooner or later. It has a price tag. Other good programs are GhostScript and GSview. I got them via http://www.cs.wisc.edu/~ghost/index.html  Sometimes they can replace Acrobat. A nice little detail is e.g. that GSview shows the x- and y-coordinates better then Acrobat. If you need to convert HTML-files to \s-1PDF\s0, \s-1HTMLDOC\s0 is a possible tool. Download it from http://www.easysw.com . A simple tool for vector graphics is Mayura Draw 2.04, download it from http://www.mayura.com. It is free. I have used it to produce the graphic OO-code in the tutorial. It produces postscript which the Acrobat Distiller (you get it together with Acrobat) or Ghostscript can convert to \s-1PDF\s0.(The commercial product, Mayura Draw 4.01 or something higher can produce PDF-files straight away)</p><p>If you want to import jpeg-images, you might need</p><p>   Image::Info</p><p>To get definitions for e.g. colors, take them from</p><p>   PDF::API2::Util</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LIMITATIONS</h2>
        <div class="sectioncontent">
<p>Meta data, info and many other features of the PDF-format have not been implemented in this module.</p><p>Many things can be added afterwards, after creating the files. If you e.g. need files to be encrypted, you can use a standard batch routine within Adobe Acrobat.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THANKS TO</h2>
        <div class="sectioncontent">
<p>Martin Langhoff, Matisse Enzer, Yunliang Yu and others who have contributed with code, suggestions and error reports.</p><p>Grant McLean has implemented font embedding by grafting Font::TTF and Text::PDF::TTFont0 onto the PDF::Reuse \s-1API\s0. He has written the embedded packages PDF::Reuse::DocProxy and PDF::Reuse::TTFont.</p><p>The functionality of prDoc and prSinglePage to include new contents was developed for a specific task with support from the Electoral Enrolment Centre, Wellington, New Zealand</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MAILING LIST</h2>
        <div class="sectioncontent">
<p>   http://groups.google.com/group/PDF-Reuse</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Lars Lundberg larslund@cpan.org</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright (C) 2003 - 2004 Lars Lundberg, Solidez \s-1HB\s0. Copyright (C) 2005 Karin Lundberg. Copyright (C) 2006 - Lars Lundberg, Solidez \s-1HB\s0. This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DISCLAIMER</h2>
        <div class="sectioncontent">
<p>You get this module free as it is, but nothing is guaranteed to work, whatever implicitly or explicitly stated in this document, and everything you do, you do at your own risk - I will not take responsibility for any damage, loss of money and/or health that may arise from the use of this module.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="PDF::API2::Simple.3pm.html"><span aria-hidden="true">&larr;</span> PDF::API2::Simple.3pm: Simplistic wrapper for the excellent pdf::api2 modules</a></li>
   <li class="next"><a href="PDF::Table.3pm.html">PDF::Table.3pm: A utility class for building table layouts in a pdf::api2 object. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

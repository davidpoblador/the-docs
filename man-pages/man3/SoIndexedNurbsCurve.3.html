<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SoIndexedNurbsCurve: The soindexednurbscurve class is a node for representing smooth curves.  explaining nurbs is beyond the scope of this documentation. if you are unfamiliar with the principles of representing smooth curves and surfaces when doing 3d visualization, we recommend finding a good book on the subject.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The soindexednurbscurve class is a node for representing smooth curves.  explaining nurbs is beyond the scope of this documentation. if you are unfamiliar with the principles of representing smooth curves and surfaces when doing 3d visualization, we recommend finding a good book on the subject.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="SoIndexedNurbsCurve (3) manual">
  <meta name="twitter:description" content="The soindexednurbscurve class is a node for representing smooth curves.  explaining nurbs is beyond the scope of this documentation. if you are unfamiliar with the principles of representing smooth curves and surfaces when doing 3d visualization, we recommend finding a good book on the subject.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcoin80-doc-SoIndexedNurbsCurve-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/SoIndexedNurbsCurve.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="SoIndexedNurbsCurve (3) manual" />
  <meta property="og:description" content="The soindexednurbscurve class is a node for representing smooth curves.  explaining nurbs is beyond the scope of this documentation. if you are unfamiliar with the principles of representing smooth curves and surfaces when doing 3d visualization, we recommend finding a good book on the subject." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcoin80-doc-SoIndexedNurbsCurve-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">SoIndexedNurbsCurve<small> (3)</small></h1>
        <p class="lead">The soindexednurbscurve class is a node for representing smooth curves.  explaining nurbs is beyond the scope of this documentation. if you are unfamiliar with the principles of representing smooth curves and surfaces when doing 3d visualization, we recommend finding a good book on the subject.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoIndexedNurbsCurve.3.html">
      <span itemprop="name">SoIndexedNurbsCurve: The soindexednurbscurve class is a node for representing smooth curves.  explaining nurbs is beyond the scope of this documentation. if you are unfamiliar with the principles of representing smooth curves and surfaces when doing 3d visualization, we recommend finding a good book on the subject.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcoin80-doc/">
      <span itemprop="name">libcoin80-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoIndexedNurbsCurve.3.html">
      <span itemprop="name">SoIndexedNurbsCurve: The soindexednurbscurve class is a node for representing smooth curves.  explaining nurbs is beyond the scope of this documentation. if you are unfamiliar with the principles of representing smooth curves and surfaces when doing 3d visualization, we recommend finding a good book on the subject.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;Inventor/nodes/SoIndexedNurbsCurve.h&gt;</p><p>Inherits <strong>SoShape</strong>.</p><h3>Public Member Functions</h3>
<p>virtual <strong>SoType</strong> <strong>getTypeId</strong> (void) const </p><p><em>Returns the type identification of an object derived from a class inheriting </em><strong>SoBase</strong><em>. This is used for run-time type checking and 'downward' casting. </em><strong></strong> <strong>SoIndexedNurbsCurve</strong> (void)</p><p>virtual void <strong>GLRender</strong> (<strong>SoGLRenderAction</strong> *action)</p><p>virtual void <strong>rayPick</strong> (<strong>SoRayPickAction</strong> *action)</p><p>virtual void <strong>getPrimitiveCount</strong> (<strong>SoGetPrimitiveCountAction</strong> *action)</p><p>virtual void <strong>getBoundingBox</strong> (<strong>SoGetBoundingBoxAction</strong> *action)</p><p>void <strong>sendPrimitive</strong> (<strong>SoAction</strong> *, <strong>SoPrimitiveVertex</strong> *)</p>
<h3>Static Public Member Functions</h3>
<p>static <strong>SoType</strong> <strong>getClassTypeId</strong> (void)</p><p>static void <strong>initClass</strong> (void)</p>
<h3>Public Attributes</h3>
<p><strong>SoSFInt32</strong> <strong>numControlPoints</strong></p><p><strong>SoMFInt32</strong> <strong>coordIndex</strong></p><p><strong>SoMFFloat</strong> <strong>knotVector</strong></p>
<h3>Protected Member Functions</h3>
<p>virtual const <strong>SoFieldData</strong> * <strong>getFieldData</strong> (void) const </p><p>virtual <strong>~SoIndexedNurbsCurve</strong> ()</p><p>virtual void <strong>generatePrimitives</strong> (<strong>SoAction</strong> *action)</p><p>virtual void <strong>computeBBox</strong> (<strong>SoAction</strong> *action, <strong>SbBox3f</strong> &box, <strong>SbVec3f</strong> &center)</p><p>virtual <strong>SoDetail</strong> * <strong>createLineSegmentDetail</strong> (<strong>SoRayPickAction</strong> *action, const <strong>SoPrimitiveVertex</strong> *v1, const <strong>SoPrimitiveVertex</strong> *v2, <strong>SoPickedPoint</strong> *pp)</p>
<h3>Static Protected Member Functions</h3>
<p>static const <strong>SoFieldData</strong> ** <strong>getFieldDataPtr</strong> (void)</p>
<h3>Additional Inherited Members</h3>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>The <strong>SoIndexedNurbsCurve</strong> class is a node for representing smooth curves.</p><p>Explaining NURBS is beyond the scope of this documentation. If you are unfamiliar with the principles of representing smooth curves and surfaces when doing 3D visualization, we recommend finding a good book on the subject.</p><p><strong>FILE FORMAT/DEFAULTS:</strong></p>
<pre>
IndexedNurbsCurve {
    numControlPoints 0
    coordIndex 0
    knotVector 0
}

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>SoIndexedNurbsCurve::SoIndexedNurbsCurve (void)</h3>
<p>Constructor.</p>
<h3>SoIndexedNurbsCurve::~SoIndexedNurbsCurve ()\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Destructor.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>\fBSoType\fP SoIndexedNurbsCurve::getTypeId (void) const\fC [virtual]\fP</h3>
<p>Returns the type identification of an object derived from a class inheriting <strong>SoBase</strong>. This is used for run-time type checking and 'downward' casting. Usage example:</p>
<pre>
void foo(SoNode * node)
{
  if (node-&gt;getTypeId() == SoFile::getClassTypeId()) {
    SoFile * filenode = (SoFile *)node;  // safe downward cast, knows the type
  }
}
</pre>
<p>For application programmers wanting to extend the library with new nodes, engines, nodekits, draggers or others: this method needs to be overridden in <em>all</em> subclasses. This is typically done as part of setting up the full type system for extension classes, which is usually accomplished by using the pre-defined macros available through for instance <strong>Inventor/nodes/SoSubNode.h</strong> (SO_NODE_INIT_CLASS and SO_NODE_CONSTRUCTOR for node classes), Inventor/engines/SoSubEngine.h (for engine classes) and so on.</p><p>For more information on writing Coin extensions, see the class documentation of the toplevel superclasses for the various class groups.</p><p>Reimplemented from <strong>SoShape</strong>.</p>
<h3>const \fBSoFieldData\fP * SoIndexedNurbsCurve::getFieldData (void) const\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Returns a pointer to the class-wide field data storage object for this instance. If no fields are present, returns NULL.</p><p>Reimplemented from <strong>SoShape</strong>.</p>
<h3>void SoIndexedNurbsCurve::GLRender (\fBSoGLRenderAction\fP *action)\fC [virtual]\fP</h3>
<p>Action method for the <strong>SoGLRenderAction</strong>.</p><p>This is called during rendering traversals. Nodes influencing the rendering state in any way or who wants to throw geometry primitives at OpenGL overrides this method.</p><p>Reimplemented from <strong>SoShape</strong>.</p>
<h3>void SoIndexedNurbsCurve::rayPick (\fBSoRayPickAction\fP *action)\fC [virtual]\fP</h3>
<p>Calculates picked point based on primitives generated by subclasses.</p><p>Reimplemented from <strong>SoShape</strong>.</p>
<h3>void SoIndexedNurbsCurve::getPrimitiveCount (\fBSoGetPrimitiveCountAction\fP *action)\fC [virtual]\fP</h3>
<p>Action method for the <strong>SoGetPrimitiveCountAction</strong>.</p><p>Calculates the number of triangle, line segment and point primitives for the node and adds these to the counters of the <em>action</em>.</p><p>Nodes influencing how geometry nodes calculates their primitive count also overrides this method to change the relevant state variables.</p><p>Reimplemented from <strong>SoShape</strong>.</p>
<h3>void SoIndexedNurbsCurve::getBoundingBox (\fBSoGetBoundingBoxAction\fP *action)\fC [virtual]\fP</h3>
<p>Redefined to notify open caches that this shape contains lines.</p><p>Reimplemented from <strong>SoShape</strong>.</p>
<h3>void SoIndexedNurbsCurve::sendPrimitive (\fBSoAction\fP *, \fBSoPrimitiveVertex\fP *)</h3>
<p>This method is part of the original SGI Inventor API, but not implemented in Coin, as it looks like a method that should probably have been private in Open Inventor.</p>
<h3>void SoIndexedNurbsCurve::generatePrimitives (\fBSoAction\fP *action)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>The method implements action behavior for shape nodes for <strong>SoCallbackAction</strong>. It is invoked from <strong>SoShape::callback()</strong>. (Subclasses should <em>not</em> override <strong>SoNode::callback()</strong>.)</p><p>The subclass implementations uses the convenience methods <strong>SoShape::beginShape()</strong>, <strong>SoShape::shapeVertex()</strong>, and <strong>SoShape::endShape()</strong>, with <strong>SoDetail</strong> instances, to pass the primitives making up the shape back to the caller.</p><p>Implements <strong>SoShape</strong>.</p>
<h3>void SoIndexedNurbsCurve::computeBBox (\fBSoAction\fP *action, \fBSbBox3f\fP &box, \fBSbVec3f\fP &center)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Calculates the bounding box of all control points, and sets the center to the average of these points.</p><p>Implements <strong>SoShape</strong>.</p>
<h3>\fBSoDetail\fP * SoIndexedNurbsCurve::createLineSegmentDetail (\fBSoRayPickAction\fP *action, const \fBSoPrimitiveVertex\fP *v1, const \fBSoPrimitiveVertex\fP *v2, \fBSoPickedPoint\fP *pp)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Will create line detail for a <strong>SoPickedPoint</strong>. This method will only be called internally, when <strong>generatePrimitives()</strong> is used for picking (<strong>SoShape::rayPick()</strong> is not overridden).</p><p>This method returns NULL in Open Inventor, and subclasses will need to override this method to create details for a <strong>SoPickedPoint</strong>.</p><p>This is not necessary with Coin. Of course, if you choose to override it, it will work in the same way as Open Inventor.</p><p>For this to work, you must supply a face or line detail when generating primitives. If you supply NULL for the detail argument in <strong>SoShape::beginShape()</strong>, you'll have to override this method.</p><p>Reimplemented from <strong>SoShape</strong>.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Data Documentation</h2>
        <div class="sectioncontent">
<h3>\fBSoSFInt32\fP SoIndexedNurbsCurve::numControlPoints</h3>
<p>Number of control points for this curve.</p>
<h3>\fBSoMFInt32\fP SoIndexedNurbsCurve::coordIndex</h3>
<p>The control point indices. Supply at least numControlPoint indices.</p>
<h3>\fBSoMFFloat\fP SoIndexedNurbsCurve::knotVector</h3>
<p>The knot vector.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for Coin from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="SoIndexedMarkerSet.3.html"><span aria-hidden="true">&larr;</span> SoIndexedMarkerSet.3: The soindexedmarkerset class is used to display a set of bitmap markers at 3d positions.  this node either uses the coordinates currently on the state (typically set up by a leading socoordinate3 node in the scenegraph) or from a sovertexproperty node attached to this node to render a set of 3d points.</a></li>
   <li class="next"><a href="SoIndexedNurbsSurface.3.html">SoIndexedNurbsSurface.3: The soindexednurbssurface class can be used to render nurbs surfaces.  it is very similar to the sonurbssurface class, but controlpoints can be specified using indices. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

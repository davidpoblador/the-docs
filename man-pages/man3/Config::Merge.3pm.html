<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Config::Merge: Load a configuration directory tree containing yaml, json, xml, perl, ini or config::general files</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Load a configuration directory tree containing yaml, json, xml, perl, ini or config::general files">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Config::Merge (3pm) manual">
  <meta name="twitter:description" content="Load a configuration directory tree containing yaml, json, xml, perl, ini or config::general files">
  <meta name="twitter:image" content="https://www.carta.tech/images/libconfig-merge-perl-Config::Merge-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Config::Merge.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Config::Merge (3pm) manual" />
  <meta property="og:description" content="Load a configuration directory tree containing yaml, json, xml, perl, ini or config::general files" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libconfig-merge-perl-Config::Merge-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Config::Merge<small> (3pm)</small></h1>
        <p class="lead">Load a configuration directory tree containing yaml, json, xml, perl, ini or config::general files</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Config::Merge.3pm.html">
      <span itemprop="name">Config::Merge: Load a configuration directory tree containing yaml, json, xml, perl, ini or config::general files</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libconfig-merge-perl/">
      <span itemprop="name">libconfig-merge-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Config::Merge.3pm.html">
      <span itemprop="name">Config::Merge: Load a configuration directory tree containing yaml, json, xml, perl, ini or config::general files</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
   OO style
   -------------------------------------------------------
   use Config::Merge();

   my $config    = Config::Merge-&gt;new(&apos;/path/to/config&apos;);

   @hosts        = $config-&gt;(&apos;db.hosts.session&apos;);
   $hosts_ref    = $config-&gt;(&apos;db.hosts.session&apos;);
   @cloned_hosts = $config-&gt;clone(&apos;db.hosts.session&apos;);
   -------------------------------------------------------
</pre>
<p>\s-1OR\s0</p><p>   Functional style    -------------------------------------------------------    # On startup    use Config::Merge(&apos;My::Config&apos; =&gt; &apos;/path/to/config&apos;);</p><p>   # Then, in any module where you want to use the config    package My::Module;    use My::Config;</p><p>   @hosts        = C(&apos;db.hosts.sesssion&apos;);    $hosts_ref    = C(&apos;db.hosts.sesssion&apos;);    @cloned_hosts = My::Config::clone(&apos;db.hosts.session&apos;);    $config       = My::Config::object;    -------------------------------------------------------</p><p>\s-1ADVANCED\s0 \s-1USAGE\s0</p><p>   OO style    -------------------------------------------------------    my $config    = Config::Merge-&gt;new(        path      =&gt; &apos;/path/to/config&apos;,        skip      =&gt; sub {} | regex | {} ,        is_local  =&gt; sub {} | regex | {} ,        load_as   =&gt; sub {} | regex ,        sort      =&gt; sub {} ,        debug     =&gt; 1 | 0    );    -------------------------------------------------------</p><p>   Functional style    -------------------------------------------------------    use Config::Merge(        &apos;My::Config&apos; =&gt; &apos;/path/to/config&apos;,        {            skip      =&gt; sub {} | regex | {} ,            is_local  =&gt; sub {} | regex | {} ,            load_as   =&gt; sub {} | regex ,            sort      =&gt; sub {} ,            debug     =&gt; 1 | 0        }    );</p><p>   # Also, you can subclass these:</p><p>     package My::Config;      sub skip {          ...      }</p><p>   -------------------------------------------------------</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Config::Merge is a configuration module which has six goals:</p>
<dl class='dl-vertical'>
  <dt>
    *
  </dt>
  <dd>
    <p>Flexible storage Store all configuration in your format(s) of choice (\s-1YAML\s0, \s-1JSON\s0, \s-1INI\s0, \s-1XML\s0, Perl, Config::General / Apache-style config) broken down into individual files in a configuration directory tree, for easy maintenance.  See \*(L"\s-1CONFIG\s0 \s-1TREE\s0 \s-1LAYOUT\s0\*(R"</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>Flexible access Provide a simple, easy to read, concise way of accessing the configuration values (similar to Template). See \*(L"\s-1ACCESSING\s0 \s-1CONFIG\s0 \s-1DATA\s0\*(R"</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>Minimal maintenance Specify the location of the configuration files only once per application, so that it requires minimal effort to relocate. See \*(L"\s-1USING\s0 Config::Merge\*(R"</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>Easy to alter development environment Provide a way for overriding configuration values on a development machine, so that differences between the dev environment and the live environment do not get copied over accidentally. See \*(L"\s-1OVERRIDING\s0 \s-1CONFIG\s0 \s-1LOCALLY\s0\*(R"</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>Minimise memory use Load all config at startup so that (eg in the mod_perl environment) the data is shared between all child processes. See \*(L"\s-1MINIMISING\s0 \s-1MEMORY\s0 \s-1USE\s0\*(R"</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>Flexible implementation You may want to use a different schema for your configuration files, so you can pass in (or subclass) methods for determining how your files are merged.  See \*(L"\s-1ADVANCED\s0 \s-1USAGE\s0\*(R". There are two ways to use \*(C`Config::Merge\*(C':</p>
  </dd>
  <dt>
    \s-1OO\s0 \s-1STYLE\s0
  </dt>
  <dd>
    <p>   use Config::Merge();    my $config    = Config::Merge-&gt;new(&apos;/path/to/config&apos;);</p><p>   @hosts        = $config-&gt;(&apos;db.hosts.session&apos;);    $hosts_ref    = $config-&gt;(&apos;db.hosts.session&apos;);    @cloned_hosts = $config-&gt;clone(&apos;db.hosts.session&apos;); Also, see \*(L"\s-1ADVANCED\s0 \s-1USAGE\s0\*(R".</p>
  </dd>
  <dt>
    \s-1YOUR\s0 \s-1OWN\s0 \s-1CONFIG\s0 \s-1CLASS\s0 (functional style)
  </dt>
  <dd>
    <p>The following code:    # On startup    use Config::Merge(&apos;My::Config&apos; =&gt; &apos;/path/to/config&apos;);</p><ul>
<li><p>auto-generates the class \*(C`My::Config\*(C'</p></li><li><p>loads the configuration data in &apos;/path/to/config&apos;</p></li><li><p>creates the subs \*(C`My::Config::C\*(C', \*(C`My::Config::clone\*(C' and \*(C`My::Config::object\*(C'.</p></li>
</ul><p>Then when you want your application to have access to your configuration data, you add this (eg in your class \*(C`My::Module\*(C'):    package My::Module;    use My::Config;       # Note, no () This exports the sub \*(C`C\*(C' into your current package, which allows you to access your configuation data as follows:    @hosts        = C(&apos;db.hosts.sesssion&apos;);    $hosts_ref    = C(&apos;db.hosts.sesssion&apos;);    @cloned_hosts = My::Config::clone(&apos;db.hosts.session&apos;);    $config       = My::Config::object;</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONFIG TREE LAYOUT</h2>
        <div class="sectioncontent">
<p>Config::Merge reads the data from any number (and type) of config files stored in a directory tree. File names and directory names are used as keys in the configuration hash.</p><p>It uses file extensions to decide what type of data the file contains, so:</p><p>    YAML            : .yaml .yml     JSON            : .json .jsn     XML             : .xml     INI             : .ini     Perl            : .perl .pl     Config::General : .conf .cnf</p><p>When loading your config data, Config::Merge starts at the directory specified at startup (see \*(L"\s-1USING\s0 Config::Merge\*(R") and looks through all the sub-directories for files ending in one of the above extensions.</p><p>The name of the file or subdirectory is used as the first key.  So:</p><p>    global/         db.yaml:             username : admin             hosts:                      - host1                      - host2             password:               host1:   password1               host2:   password2</p><p>would be loaded as :</p><p>    $Config = {        global =&gt; {            db =&gt; {                username =&gt; &apos;admin&apos;,                password =&gt; { host1 =&gt; &apos;password1&apos;, host2 =&gt; &apos;password2&apos;},                hosts    =&gt; [&apos;host1&apos;,&apos;host2&apos;],            }        }     }</p><p>Subdirectories are processed before the current directory, so you can have a directory and a config file with the same name, and the values will be merged into a single hash, so for instance, you can have:</p><p>    confdir:        syndication/        --data_types/          --traffic.yaml          --headlines.yaml        --data_types.ini        syndication.conf</p><p>The config items in syndication.conf will be added to (or overwrite) the items loaded into the syndication namespace via the subdirectory called syndication.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OVERRIDING CONFIG LOCALLY</h2>
        <div class="sectioncontent">
<p>The situation often arises where it is necessary to specify different config values on different machines. For instance, the database host on a dev machine may be different from the host on the live application. Also, see \*(L"\s-1ADVANCED\s0 \s-1USAGE\s0\*(R" which provides you with other means to merge local data.</p><p>Instead of changing this data during dev and then having to remember to change it back before putting the new code live, we have a mechanism for overriding config locally in a \*(C`local.*\*(C' file and then, as long as that file never gets uploaded to live, you are protected.</p><p>You can put a file called \*(C`local.*\*(C' (where * is any of the recognised extensions) in any sub-directory, and the data in this file will be merged with the existing data.</p><p>Just make sure that the \*(C`local.*\*(C' files are never checked into your live code.</p><p>For instance, if we have:</p><p>    confdir:         db.yaml         local.yaml</p><p>and db.yaml has :</p><p>    connections:         default_settings:             host:       localhost             table:      abc             password:   123</p><p>And in local.yaml:</p><p>    db:         connections:             default_settings:                 password:   456</p><p>the resulting configuration will look like this:</p><p>    db:         connections:             default_settings:                 host:       localhost                 table:      abc                 password:   456</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ACCESSING CONFIG DATA</h2>
        <div class="sectioncontent">
<p>All configuration data is loaded into a single hash, eg:</p><p>    $config = {         db    =&gt; {             hosts  =&gt; {                 session  =&gt; [&apos;host1&apos;,&apos;host2&apos;,&apos;host3&apos;],                 images   =&gt; [&apos;host1&apos;,&apos;host2&apos;,&apos;host3&apos;],                 etc...             }         }     }</p><p>If you want to access it via standard Perl dereferences, you can just ask for the hash:</p><p>    OO:        $data_ref  = $config-&gt;();        $hosts_ref = $data_ref-&gt;{db}{hosts}{session};        $host_1    = $data_ref-&gt;{db}{hosts}{session}[0];</p><p>    Functional:        $data_ref  = C();        $hosts_ref = $data_ref-&gt;{db}{hosts}{session};        $host_1    = $data_ref-&gt;{db}{hosts}{session}[0];</p><p>However, \*(C`Config::Merge\*(C' also provides an easy to read dot-notation in the style of Template Toolkit: \*(C`(&apos;key1.key2.keyn&apos;)\*(C'.</p><p>A key can be the key of a hash or the index of an array. The return value is context sensitive, so if called in list context, a hash ref or array ref will be dereferenced.</p><p>    OO:        @hosts     = $config-&gt;(&apos;db.hosts.session&apos;);        $hosts_ref = $config-&gt;(&apos;db.hosts.session&apos;);        $host_1    = $config-&gt;(&apos;db.hosts.session.0&apos;);</p><p>    Functional:        @hosts     = C(&apos;db.hosts.session&apos;);        $hosts_ref = C(&apos;db.hosts.session&apos;);        $host_1    = C(&apos;db.hosts.session.0&apos;);</p><p>These lookups are memo'ised, so lookups are fast.</p><p>If the specified key is not found, then an error is thrown.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MINIMISING MEMORY USE</h2>
        <div class="sectioncontent">
<p>The more configuration data you load, the more memory you use. In order to keep the memory use as low as possible for mod_perl (or other forking applications), the configuration data should be loaded at startup in the parent process.</p><p>As long as the data is never changed by the children, the configuration hash will be stored in shared memory, rather than there being a separate copy in each child process.</p><p>(See &lt;http://search.cpan.org/~pgollucci/mod_perl-2.0.3/docs/user/performance/mpm.pod&gt;)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">
<p>    $conf = Config::Merge-&gt;new($config_dir); <em>new()</em> instantiates a config object, loads the config from the directory specified, and returns the object.   $val = $config-&gt;C(&apos;key1.key2.keyn&apos;);   $val = $config-&gt;C(&apos;key1.key2.keyn&apos;,$hash_ref); \*(C`Config::Merge\*(C' objects are overloaded so that this also works:   $val = $config-&gt;(&apos;key1.key2.keyn&apos;);   $val = $config-&gt;(&apos;key1.key2.keyn&apos;,$hash_ref); Or, if used in the functional style (see \*(L"\s-1USING\s0 Config::Merge\*(R"):   $val = C(&apos;key1.key2.keyn&apos;);   $val = C(&apos;key1.key2.keyn&apos;,$hash_ref); \*(C`key1\*(C' etc can be keys in a hash, or indexes of an array. \*(C`C(&apos;key1.key2.keyn&apos;)\*(C' returns everything from \*(C`keyn\*(C' down, so you can use the return value just as you would any normal Perl variable. The return values are context-sensitive, so if called in list context, an array ref or hash ref will be returned as lists. Scalar values, code refs, regexes and blessed objects will always be returned as themselves. So for example:   $password = C(&apos;database.main.password&apos;);   $regex    = C(&apos;database.main.password_regex&apos;);</p><p>  @countries = C(&apos;lists.countries&apos;);   $countries_array_ref = C(&apos;lists.countries&apos;);</p><p>  etc If called with a hash ref as the second parameter, then that hash ref will be examined, rather than the $config data. This works exactly the same way as \*(L"C()\*(R" but it performs a deep clone of the data before returning it. This means that the returned data can be changed without affecting the data stored in the $conf object; The data is deep cloned, using Storable, so the bigger the data, the more performance hit.  That said, Storable's dclone is very fast.     Config::Merge-&gt;register_loader( &apos;Config::Merge::XYZ&apos;);</p><p>    Config::Merge-&gt;register_loader( &apos;Config::Merge::XYZ&apos; =&gt; &apos;xyz&apos;,&apos;xxx&apos;); By default, \*(C`Config::Merge\*(C' uses the \*(C`Config::Any\*(C' plugins to support \s-1YAML\s0, \s-1JSON\s0, \s-1INI\s0, \s-1XML\s0, Perl and Config::General configuration files, using the standard file extensions to recognise the file type. (See \*(L"\s-1CONFIG\s0 \s-1TREE\s0 \s-1LAYOUT\s0\*(R"). If you would like to change the handler for an extension (eg, you want \*(C`.conf\*(C' and \*(C`.cnf\*(C' files to be treated as \s-1YAML\s0), do the following:     Config::Merge-&gt;register_loader (&apos;Config::Any::YAML&apos; =&gt; &apos;conf&apos;, &apos;cnf&apos;); If you would like to add a new config style, then your module should have two methods: \*(C`extensions()\*(C' (which returns a list of the extensions it handles), and \*(C`load()\*(C' which accepts the name of the file to load, and returns a hash ref containing the data in the file. See Config::Any for details. Alternatively, you can specify the extensions when you load it:     Config::Merge-&gt;register_loader (&apos;My::Merge&apos; =&gt; &apos;conf&apos;, &apos;cnf&apos;);     $config-&gt;load_config(); Will reload the config files located in the directory specified at object creation (see \*(L"<em>new()</em>\*(R"). \s-1BEWARE\s0 : If you are using this in a mod_perl environment, you will lose the benefit of shared memory by calling this in a child process  - each child will have its own copy of the data. See \*(L"\s-1MINIMISING\s0 \s-1MEMORY\s0 \s-1USE\s0\*(R". Returns the config hash ref.     $config-&gt;clear_cache(); Config data is generally not supposed to be changed at runtime. However, if you do make changes, you may get inconsistent results, because lookups are cached. For instance:     print $config-&gt;C(&apos;db.hosts.session&apos;);  # Caches this lookup     &gt; "host1 host2 host3"</p><p>    $data = $config-&gt;C(&apos;db.hosts&apos;);     $data-&gt;{session} = 123;</p><p>    print $config-&gt;C(&apos;db.hosts.session&apos;); # uses cached value     &gt; "host1 host2 host3"</p><p>    $config-&gt;clear_cache();     print $config-&gt;C(&apos;db.hosts.session&apos;); # uses actual value     &gt; "123" \*(C`import()\*(C' will normally be called automatically when you \*(C`use Config::Merge\*(C'. However, you may want to do this:     use Config::Merge();     Config::Merge-&gt;register_loader(&apos;My::Plugin&apos; =&gt; &apos;ext&apos;);     Config::Merge-&gt;import(&apos;My::Config&apos; =&gt; &apos;/path/to/config/dir&apos;); If called with two params: $config_class and $config_dir, it generates the new class (which inherits from Config::Merge) specified in $config_class, creates a new object of that class and creates 4 subs:</p><p>    As a function:         C(&apos;keys...&apos;)</p><p>    is the equivalent of:         $config-&gt;C(&apos;keys...&apos;);     As a function:         clone(&apos;keys...&apos;)</p><p>    is the equivalent of:         $config-&gt;clone(&apos;keys...&apos;);     $config = My::Config-&gt;object(); Returns the $config object, When you use your generated config class, it exports the \*(C`C()\*(C' sub into your package:     use My::Config;     $hosts = C(&apos;db.hosts.session&apos;);</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ADVANCED USAGE</h2>
        <div class="sectioncontent">
<p>The items in the section allow you to customise how Config::Merge loads your data.  You may never need them.</p><p>You can:</p>
<dl class='dl-vertical'>
  <dt>
    *
  </dt>
  <dd>
    <p>Override array values</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>Skip the loading of parts of your config tree</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>Specify which files / dirs are local</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>Specify how to translate a file / dir name into a key</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>Change order in which files are loaded</p>
  </dd>
  <dt>
    *
  </dt>
  <dd>
    <p>See debug output</p>
  </dd>
  <dt>
    Overriding array values
  </dt>
  <dd>
    <p>Overriding hash values is easy, however arrays are more complex. it may be simpler to copy and paste and edit the array you want to change locally. However, if your array is too long, and you want to make small changes, then you can use the following: In the main config:     {       cron =&gt; [qw( job1 job2 job3 job4)]     } In the local file     {       cron =&gt; {         &apos;3&apos;  =&gt; &apos;newjob4&apos;,      # changes &apos;job4&apos; -&gt; &apos;newjob4&apos;</p><p>        &apos;!&apos;  =&gt; {               # signals an array override</p><p>             &apos;-&apos; =&gt; [1],        # deletes &apos;job2&apos;</p><p>             &apos;+&apos; =&gt; [&apos;job5&apos;],   # appends &apos;job5&apos;</p><p>          OR &apos;+&apos; =&gt; {           # inserts &apos;job3a&apos; after &apos;job3&apos;                  2 =&gt; &apos;job3a&apos;              }         }     }</p><ul>
<li><p>The override has to be a hash, with at least this structure  \*(C`{ &apos;!&apos; =&gt; {} }\*(C' to signal an array override</p></li><li><p>Any other keys with integers are treated as indexes and are used to change the value at that index in the original array</p></li><li><p>The &apos;-&apos; key should contain an array ref, with the indexes of the elements to remove from the array.</p></li><li><p>If the &apos;+&apos; key contains an array ref, then its contents are appended to the original array.</p></li><li><p>If the &apos;+&apos; key contains a hash ref, then each value is inserted into the original array at the index given in the key</p></li><li><p>Indexes are zero based, just as in Perl.</p></li>
</ul><p>    $c = Config::Merge-&gt;new(             path  =&gt; &apos;/path/to/config&apos;,             skip  =&gt; qr/regex/,                      | [ qr/regex1/, qr/regex2/...]                      | {  name1 =&gt; 1, name2 =&gt; 2}                      | sub {}     ); \*(C`skip()\*(C' allows you to skip the loading of parts of your config tree.  For instance, if you don't need a list of cron jobs when running your web server, you can skip it. The decision is made based on the path to that value, eg 'app.db.hosts' rather than on filenames. Also, the check is only performed for each new directory or filename - it doesn't check the data within each file. To use \*(C`skip()\*(C', you can either subclass it, or pass in a parameter to new:</p><p>Each regex will be checked against the key path, and if it matches then the loading of that tree will be skipped If the key path exists in the hash, then loading will be skipped    sub {        my ($self,$key_path) = @_;        ...make decision...        return 1 | 0;    }</p><p>    $c = Config::Merge-&gt;new(             path     =&gt; &apos;/path/to/config&apos;,             is_local =&gt; qr/regex/,                         | [ qr/regex1/, qr/regex2/...]                         | {  name1 =&gt; 1, name2 =&gt; 2}                         | sub {}     ); \*(C`is_local()\*(C' indicates whether a file or dir should be considered part of the main config (and thus loaded normally) or part of the local config (and thus merged into the main config). The decision is made based on the name of the file / dir, without any extension. To use \*(C`is_local()\*(C', you can either subclass it, or pass in a parameter to new:</p><p>Each regex will be checked against the file/dir name, and if it matches then that tree will be merged If the file/dir name exists in the hash, then that tree will be merged    sub {        my ($self,$name) = @_;        ...make decision...        return 1 | 0;    }</p><p>See \*(L"\s-1EXAMPLE\s0 \s-1USING\s0 <em>is_local()</em> \s-1AND\s0 <em>load_as()</em>\*(R".</p><p>    $c = Config::Merge-&gt;new(             path     =&gt; &apos;/path/to/config&apos;,             load_as  =&gt; qr/(regex)/,                         | sub {}     ); \*(C`load_as()\*(C' returns the name of the key to use when loading the file / dir. By default, it returns the $name for main config files, or &apos;&apos; for local files. The decision is made based on the name of the file / dir, without any extension. If \*(C`load_as()\*(C' returns an empty string, then each key in the file/tree is merged separately. This is how the \*(C`local.*\*(C' files work by default. See \*(L"\s-1OVERRIDING\s0 \s-1CONFIG\s0 \s-1LOCALLY\s0\*(R". For instance:    main.yaml:      key1:  value      key2:  value</p><p>   db.yaml:      key3:  value      key4:  value</p><p>   local.yaml:      main:         key1: new_value      db:         key4: new_value To use \*(C`load_as()\*(C', you can either subclass it, or pass in a parameter to new:</p><p>The regex will be checked against the file/dir name, and if it matches then it returns the string captured in the regex, otherwise it returns the original name.    sub {        my ($self,$name,$is_local) = @_;        ...make decision...        return &apos;string&apos;;   # string is used as the keyname        return &apos;&apos;;         # acts like local.* (see above)        return undef;      # don&apos;t load this file/dir    }</p><p>Also, see \*(L"\s-1EXAMPLE\s0 \s-1USING\s0 <em>is_local()</em> \s-1AND\s0 <em>load_as()</em>\*(R".</p><p>For instance, instead of using \*(C`local.*\*(C' files, you may want to keep versioned copies of local configs for different machines, and so use:    app.yaml    app-(dev1.domain.com).yaml    app-(dev2.domain.com).yaml You would implement this as follows:     my $config = Config::Merge-&gt;new(         path        =&gt; &apos;/path/to/config&apos;,</p><p>        # If matches &apos;xxx-(yyy)&apos;         is_local    =&gt; sub {             my ( $self, $name ) = @_;             return $name=~/- [(] .+ [)]/x ? 1 : 0;         },</p><p>        # If local and matches &apos;xxx-(hostname)&apos;, return xxx         load_as =&gt; sub {             my ( $self, $name, $is_local ) = @_;             if ($is_local) {                 if ( $name=~/(.*) - [(] ($hostname) [)] /x ) {                     return  $1;                 }                 return undef;             }             return $name;         }     ); See \*(C`examples/advanced.pl\*(C' for a working illustration.     $c = Config::Merge-&gt;new(             path   =&gt; &apos;/path/to/config&apos;,             sort   =&gt; sub {}     ); By default, directory entries are sorted alphabetically, with directories before filenames. This would be the order for these directory entries:   api/   api-(dev1)/   api.yaml   api-(dev1).yaml To override this, you can subclass \*(C`sort()\*(C' or pass it in as a parameter to new:    sub {        my ($self,$names_array_ref) = @_        ...sort...        return $names_array_ref;    }     my $config = Config::Merge-&gt;new(         path        =&gt; &apos;/path/to/config&apos;,         debug       =&gt; 1 | 0     ); If \*(C`debug\*(C' is true, then Config::Merge prints out an explanation of what it is doing on \s-1STDERR\s0.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Config::Merge&hellip;</h2>
        <div class="sectioncontent">
<p>Storable, Config::Any, Config::Any::YAML, Config::Any::JSON, Config::Any::INI, Config::Any::XML, Config::Any::General</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THANKS</h2>
        <div class="sectioncontent">
<p>Thanks to Hasanuddin Tamir [\s-1HASANT\s0] for vacating the Config::Merge namespace, which allowed me to rename Config::Loader to the more meaningful Config::Merge.</p><p>His version of Config::Merge can be found in &lt;http://backpan.cpan.org/modules/by-authors/id/H/HA/HASANT/&gt;.</p><p>Thanks to Joel Bernstein and Brian Cassidy for the interface to the various configuration modules. Also to Ewan Edwards for his suggestions about how to make Config::Merge more flexible.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>No bugs have been reported.</p><p>Please report any bugs or feature requests to &lt;http://github.com/clintongormley/ConfigMerge/issues&gt;.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Clinton Gormley, &lt;clinton@traveljury.com&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright (C) 2007-2010 by Clinton Gormley</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LICENSE</h2>
        <div class="sectioncontent">
<p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself, either Perl version 5.8.7 or, at your option, any later version of Perl 5 you may have available.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Config::JSON.3pm.html"><span aria-hidden="true">&larr;</span> Config::JSON.3pm: A json based config file system.</a></li>
   <li class="next"><a href="Config::Merge::Perl.3pm.html">Config::Merge::Perl.3pm: Load perl config files <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

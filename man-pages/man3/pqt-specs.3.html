<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>pqt-specs: A manual for libpqtypes data type specifier strings.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="A manual for libpqtypes data type specifier strings.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="pqt-specs (3) manual">
  <meta name="twitter:description" content="A manual for libpqtypes data type specifier strings.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libpqtypes-dev-pqt-specs-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/pqt-specs.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="pqt-specs (3) manual" />
  <meta property="og:description" content="A manual for libpqtypes data type specifier strings." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libpqtypes-dev-pqt-specs-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">pqt-specs<small> (3)</small></h1>
        <p class="lead">A manual for libpqtypes data type specifier strings.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/pqt-specs.3.html">
      <span itemprop="name">pqt-specs: A manual for libpqtypes data type specifier strings.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libpqtypes-dev/">
      <span itemprop="name">libpqtypes-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/pqt-specs.3.html">
      <span itemprop="name">pqt-specs: A manual for libpqtypes data type specifier strings.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The type system allows addressing backend data types by their fully qualified schema name.  Similar to the backend type system, libpqtypes has an input and output function for each type: put and get respectively. All builtin types are supported by libpqtypes.  Additional types, such as composites and user-defined types, can be registered by an API-user on a per connection basis.</p><p>Putting and getting types are addressed by their backend names as printf-style format specifiers.  For instance: %int4, %timestamptz or %text. They can also be addressed using their fully qualified schema names: %pg_catalog.int4, %pg_catalog.timestamptz, %pg_catalog.text or %myschema.mytype to avoid ambiguity.</p><h3>Specifier Strings</h3>
<p><em>Specifier Mark</em></p><p>A specifier mark indicates where a specifier begins. A mark is not part of the type name.</p>
<pre>
   %  Marks the beginning of a type name.  When getting results, this
      also indicates that a field will be referenced by number.
</pre>

<pre>
   #  Marks the beginning of a type name.  When getting results, this
      also indicates that a field will be referenced by name.
</pre>

<pre>
   @  Marks the beginning of a prepared specifier name, see
      PQspecPrepare().  When used, it must be the first and only
      specifier in the format string: "@prepared_spec", "@myfunc",
      etc...  NOTE: the \'@\' must be the first character, no spaces.
</pre>
<p><em>Type Specifier</em></p><p>Type specifiers are comprised of an optional schema name and type name. Type specifiers have a set of rules:</p>
<pre>
   -) Format: [schema].type - optional schema name, a "." separator
      between schema and type and the type name.
</pre>

<pre>
   -) First character must be a-z or an underscore
</pre>

<pre>
   -) Double quotes are required for characters not in [a-zA-Z0-9_]
      NOTE: In libpqtypes, this includes "double precision"
</pre>

<pre>
   -) Schema "." separator, specifier marks or flags are not included
      in double quotes
</pre>

<pre>
   -) Non-quoted type names are casefolded, quoted names are not.
</pre>

<pre>
   -) Examples:
      "%int4"
      "%pg_catalog.int4"
      "%       "%myschema.       "%abc.int4 %pg_catalog.int4" &lt;= fully qualified type names
</pre>

<pre>
   -) Last in First out: To find a type referenced in a specifier
      string, the search begins with the last type registered.
      User registered type handlers are searched first, followed
      by builtin types.
</pre>

<pre>
   -) pqt schema: There is a builtin schema named pqt.  By default,
      it contains two types: \'str\' and \'null\'.  Anything can be
      put into this schema, which has nothing to do with the server.
      This is good for aliases or type sub-classes that are
      client-specific.
</pre>
<p><em>Specifier Flag</em></p><p>Flags are used to alter the behavior of a type specifier.  They are always placed at the end of the specifier name.  If the name is double quoted, the flag is just after the closing quote.</p>
<pre>
   *  This is called the pointer flag.  It is only supported on a
      handful of builtin types during a <a href="../man3/PQputf.3.html"><strong>PQputf</strong>(3)</a></em>, but user registered
      types can provide support for them.  Supported types are:
      VARCHAR, BPCHAR, TEXT, BYTEA, NAME and the pqt.str.
</pre>

<pre>
      Putting data: this flag tells libpqtypes to store a direct
      pointer to the data being put, rather than making a copy of
      it.
</pre>

<pre>
      Getting data: no built-in types make use of the pointer flag.
      User-defined type handlers can make the pointer flag behave
      anyway they see fit.  The \'get\' type handler is supplied a
      PGtypeArgs which contains an \'is_ptr\' member.
</pre>

<pre>
   [] This is called the array flag.  It indicates that an array is
      being referenced rather than a simple type.  This flag is always
      used with a PGarray.
</pre>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NUMERICS</h2>
        <div class="sectioncontent">
<p>With the exception of the "numeric" type, all numeric types behave identically: int2, int4, int8, float4 and float8.</p>
<pre>
PG type    C type
PGint2     short
PGint4     int
PGint8     long long (platform dependent)
PGfloat4   float
PGfloat8   double
</pre>
<p>Putting numeric values: If the value supplied is too large for the PG type, it will be silently truncated.</p>
<pre>
<strong></strong>
PQputf(param, "%int2 %int4 %int8 %float4 %float8",
	SHRT_MAX, INT_MAX, LLONG_MAX, 1234.56, 123456.789);
</pre>
<p>Getting numeric values: Like scanf, the correctly sized data type must be used.  For instance: you cannot use a 4-byte int for %int2 - you must use a short.</p>
<pre>
<strong></strong>
// Read an int2 from field 0, int4 from field 1, int8 from
// field 2, float4 from field 3 and a float8 from field 4
PGint2 i2;
PGint4 i4;
PGint8 i8;
PGfloat4 f4;
PGfloat8 f8;
PQgetf(result, tup_num, "%int2 %int4 %int8 %float4 %float8",
	0, &i2, 1, &i4, 2, &i8, 3, &f4, 4, &f8);
</pre>
<p>The numeric data type is always exposed in text format. There is no C data structure. It is always sent in binary format.</p>
<pre>
<strong></strong>
PQputf(param, "%numeric", "1728718718271827121233.121212121212");
</pre>
<p>Even if binary results are used when getting a numeric value, libpqtypes will internally convert the numeric to text. This has the advantage of allowing you to use binary results and still have access to numeric fields.  If you want to work with a numeric in binary form, use PQgetvalue() on a binary result set.</p>
<pre>
<strong></strong>
PGnumeric numstr;
PQgetf(result, tup_num, "%numeric", field_num, &numstr);
</pre>
<p>The first argument is the field number of the numeric. The second argument is a pointer to a PGnumeric to receive the numeric string value (which will always be NUL terminated).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ARRAY</h2>
        <div class="sectioncontent">
<p>Arrays are put using the PGarray structure.  Elements are put using <a href="../man3/PQputf.3.html"><strong>PQputf</strong>(3)</a></em> into a PGparam structure contained withn a PGarray.  The PGarray contains array dimension members for specifing the number of dimension, the dimensions of each dimension and the lower bounds of each dimension.</p><p>Arrays are only handled using binary format.  This means that any type used as an array element must be put and gotten in binary format.  If a user-defined type does not implement a send and recv function in the backend, it can not be used as an array element.</p><p>For a discussion of composite arrays, &#96;man <a href="../man3/pqt-composites.3.html"><strong>pqt-composites</strong>(3)</a>\'.</p>
<pre>
<strong></strong>
typedef struct
{
	/* The number of array dimensions.  Specifing zero for this
	 * value on puts has special meaning.  When zero, this value
	 * is set to one, dims[0] is set to the number of items in
	 * the \'param\' member and lbound[0] is set to one.
	 */
	int ndims;

	/* An array of lower bounds for each dimension. */
	int lbound[MAXDIM];

	/* An array of dimensions for each dimension. */
	int dims[MAXDIM];

	/* When putting array elements, this PGparam is used.  Each
	 * item put is one array element.  Because the <a href="../man3/PQputf.3.html"><strong>PQputf</strong>(3)</a></em>
	 * interface allows putting more than one item at a time, you
	 * can put multiple array elements.
	 */
	PGparam *param;

	/* When getting an array, this is the PGresult object that
	 * contains the array elements.  Each element is one tuple,
	 * regardless of the array dimensions.  If the array has 100
	 * elements across 3 dimensions, PQntuples(arr.res) will return
	 * 100.  The only valid field, for non-composite arrays, is
	 * field zero.
	 */
	PGresult *res;
} PGarray;

</pre>
<p>When all elements have been put, the PGarray structure must be put using the "[]" array specifer flag into a PGparam structure.  <a href="../man3/PQputf.3.html"><strong>PQputf</strong>(3)</a></em> is used to build the array elements and to put the resulting PGarray.</p><p>Putting an array value:</p>
<pre>
<strong></strong>
PGint4 i;
PGarray arr;
PGparam *param;

/* One dimensional arrays do not require setting dimension info. For
 * convience, you can zero the structure or set ndims to zero.
 */
arr.ndims = 0;

/* create the param object that will contain the elements */
arr.param = PQparamCreate(conn);

/* Use <a href="../man3/PQputf.3.html"><strong>PQputf</strong>(3)</a></em> to put the array elements */
for(i=0; i &lt; 1000; i++)
  PQputf(arr.param, "%int4", i);

/* The PGarray must be put into a PGparam struture.  So far, only
 * the array elements have been put.  \'param\' can continue to be
 * used to pack more parameters.  The array is now a single parameter
 * within \'param\'.
 */
param = PQparamCreate(conn);
PQputf(param, "%int[]", &arr);

/* no longer needed */
PQparamClear(arr.param);

</pre>
<p>To get an array, <a href="../man3/PQgetf.3.html"><strong>PQgetf</strong>(3)</a></em> is used in conjunction with the PGarray structure.  The result object contained with the PGarray is populated with the array elements.  The dimension info is assigned as well.  Each array element is its own tuple that only contains a single field for non composite arrays.</p><p>Getting an array value:</p>
<pre>
<strong></strong>
int i;
PGint4 val;
int ntups;
PGarray arr;
PGresult *result = ...;

PQgetf(result, 0, "%int[]", 0, &arr);

/* not needed anymore*/
PQclear(result);

/* each tuple is an array element */
ntups = PQntuples(arr.res);
for(i=0; i &lt; ntups; i++)
{
  /* Always field 0 */
  PQgetf(arr.res, i, "%int4", 0, &val);
  printf("[%03d] %d&#92;n", i, val);
}

PQclear(arr.res);

</pre>
<p>The result object is not organized based on the dimension info.  Indexes are always zero-based.  If the dimension info is meaningful to your application, index translation must be done using the ndims, dims and lbound members of the PGarray structure.</p><p>You cannot reference an array element by field name.  The only logical name for an array element would be the string version of its index ... "0", "1", etc..  The index value of a non-composite array is its tuple number, the field number is always zero.  This means "#int" is not legal for non-composite arrays.  You must use "%int" and reference field 0.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CHAR</h2>
        <div class="sectioncontent">
<p>The "char" data type uses the PGchar.  The value is limited to 8-bits.</p><p>Putting a "char" value:</p>
<pre>
<strong></strong>
PGchar c = \'a\';
PQputf(param, "%char %char", 213, c);
</pre>
<p>Getting a "char" value:</p>
<pre>
<strong></strong>
PGchar c;
PQgetf(result, tup_num, "%char", field_num, &c);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">VARIABLE-LENGTH CHARACTER TYPES</h2>
        <div class="sectioncontent">
<p>BPCHAR, VARCHAR, NAME and TEXT are handled identically.  libpqtypes does no range checking on NAME, BPCHAR or VARCHAR, it lets the server perform these checks. There are two ways to put strings: allow libpqtypes to make an internal copy of the string (default behavior) or as a direct pointer: (both require that the C string is NUL-terminated)</p>
<pre>
<strong></strong>
/* Put a string so libpqtypes makes a copy. In this case,
 * 4 copies would be made of the same string.
 */
PGtext str = "foobar";
PQputf(param, "%bpchar %varchar %name %text", str, str, str, str);

/* Put a string so libpqtypes doesn\'t make a copy,
 * keeps a direct pointer.  More efficient than above,
 * especially if these are large strings.
 */
PQputf(param, "%bpchar* %varchar* %name* %text*", str, str, str, str);
</pre>
<p>WARNING: Be careful about variable scope when using the "*" specifier flag:</p>
<pre>
<strong></strong>
/* when \'func\' returns, the str pointer becomes invalid!
 * The below should be using "%text" ... w/o the * flag.
 */
int func(PGparam *param)
{
	PGchar str[16];
	strcpy(str, "foobar");
	return PQputf(param, "%text*", str); // BAD IDEA!
}
</pre>
<p>To <a href="../man3/PQgetf.3.html"><strong>PQgetf</strong>(3)</a></em> a string, you supply a pointer to a PGtext.  Unlike putting string values, getting them doesn\'t make use of the "*" specifier flag (silently ignored).</p>
<pre>
<strong></strong>
/* Get a string value */
PGvarchar str;
PQgetf(result, tup_num, "%varchar", field_num, &str);

/* identical to */
str = PQgetvalue(result, tup_num, field_num);
</pre>
<p>The reason the \'*\' specifier flag is silently ignored, rather than raising a syntax error, is it is common to define macros for specifer strings; that can be used for puts and gets:</p>
<pre>
<strong></strong>
/* user_id, username, password */
#define TYPESPEC_USERINFO "%int4 %text* %text*"

PGint4 uid = 0;
PGtext user = "foo", pass = "bar";
PQputf(param, TYPESPEC_USERINFO, uid, user, pass);
PQgetf(param, tup_num, TYPESPEC_USERINFO, 0, &uid, 1, &user, 2, &pass);
</pre>
<p>The above allowance is more useful than a syntax error.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BYTEA</h2>
        <div class="sectioncontent">
<p>There are two ways to put a bytea: copy or direct pointer (just like variable-length character types).  In either case, you supply a pointer to a PGbytea.</p>
<pre>
<strong></strong>
typedef struct
{
  int len;    /* number of bytes */
  char *data; /* pointer to the bytea data */
} PGbytea;

/* Put a bytea letting libpqtypes make a copy; */
PGbytea bytea = {4, {0, 1, 2, 3}};
PQputf(param, "%bytea", &bytea);

/* Put a bytea not letting libpqtypes make a copy, stores a
 * direct pointer to PGbytea.data.
 */
PQputf(param, "%bytea*", &bytea);
</pre>
<p>To get a bytea, you provide a pointer to a PGbytea.  Unlike putting bytea values, there is only one way to get them.</p>
<pre>
<strong></strong>
/* Get a bytea value (exposed as binary, no
 * escaping/unescaping needed)
 */
PGbytea bytea;
PQgetf(result, tup_num, "%bytea", field_num, &bytea);
</pre>
<p>NOTE: For text results, PQgetlength will not match the length returned by <a href="../man3/PQgetf.3.html"><strong>PQgetf</strong>(3)</a></em>. The values <a href="../man3/PQgetf.3.html"><strong>PQgetf</strong>(3)</a></em> assigns to the user provided PGbytea* represent the unescaped bytea value.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DATE</h2>
        <div class="sectioncontent">
<p>PGdate is used by DATE, TIMESTAMP and TIMESTAMPTZ data types. To put a date, you must set the isbc, year, mon and mday members.  All other members are ignored.</p>
<pre>
<strong>typedef struct</strong>
{
	/* When non-zero, the date is in the BC ERA. */
	int isbc;

	/*
	 * The BC or AD year, which is NOT adjusted by 1900 like
	 * the POSIX struct tm.  Years are always positive values,
	 * even BC years.  To distinguish between BC and AD years,
	 * use the isbc flag: (year 0 not used)
	 *   Ex. -1210 is represented as: isbc=1, year=1209
	 */
	int year;

	/* The number of months since January, in the range 0 to 11. */
	int mon;

	/* The day of the month, in the range 1 to 31. */
	int mday;

	/* The Julian day in the Gregorian calendar. */
	int jday;

	/* The number of days since January 1, in the range 0 to 365. */
	int yday;

	/* The number of days since Sunday, in the range 0 to 6. */
	int wday;
} PGdate;
</pre>
<p>Putting a date value:</p>
<pre>
<strong></strong>
// \'1401-01-19 BC\'
PGdate date;
date.isbc = 1;
date.year = 1401;
date.mon  = 0;
date.mday = 19;
PQputf(param, "%date", &date);
</pre>
<p>Getting a date value:</p>
<pre>
<strong></strong>
PQgetf(result, tup_num, "%date", field_num, &date);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TIME</h2>
        <div class="sectioncontent">
<p>PGtime is used by TIME, TIMETZ, TIMESTAMP and TIMESTAMPTZ data types. To put a time, you must set the hour, min, sec and usec members.  All other members are ignored.</p>
<pre>
<strong></strong>
typedef struct
{
	/* The number of hours past midnight, in the range 0 to 23. */
	int hour;

	/* The number of minutes after the hour, in the
	 * range 0 to 59.
	 */
	int min;

	/* The number of seconds after the minute, in the
	 * range 0 to 59.
	 */
	int sec;

	/* The number of microseconds after the second, in the
	 * range of 0 to 999999.
	 */
	int usec;

	/*
	 * When non-zero, this is a TIME WITH TIME ZONE.  Otherwise,
	 * it is a TIME WITHOUT TIME ZONE.
	 */
	int withtz;

	/* A value of 1 indicates daylight savings time.  A value of 0
	 * indicates standard time.  A value of -1 means unknown or
	 * could not determine.
	 */
	int isdst;

	/* Offset from UTC in seconds. This value is not always
	 * available. It is set to 0 if it cannot be determined.
	 */
	int gmtoff;

	/* Timezone abbreviation: such as EST, GMT, PDT, etc.
	 * This value is not always available.  It is set to an empty
	 * string if it cannot be determined.
	 */
	char tzabbr[16];
} PGtime;

</pre>
<p>Putting a time value:</p>
<pre>
<strong></strong>
// \'10:41:06.002897\'
PGdate time;
time.hour   = 10;
time.min    = 41;
time.sec    = 6;
time.usec   = 2897;
PQputf(param, "%time", &time);
</pre>
<p>Getting a time value:</p>
<pre>
<strong></strong>
PQgetf(result, tup_num, "%time", field_num, &time);

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TIMETZ</h2>
        <div class="sectioncontent">
<p>The TIMETZ data type uses the PGtime structure, for a description of this structure see the TIME section.  To put a timetz, you must set the hour, min, sec, usec and gmtoff members.  All other members are ignored.</p><p>Putting a timetz value:</p>
<pre>
<strong></strong>
// \'10:41:06.002897-05\'
PGdate timetz;
timetz.hour   = 10;
timetz.min    = 41;
timetz.sec    = 6;
timetz.usec   = 2897;
timetz.gmtoff = -18000;
PQputf(param, "%timetz", &timetz);

</pre>
<p>Getting a timetz value:</p>
<pre>
<strong></strong>
PQgetf(result, tup_num, "%timetz", field_num, &timetz);

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TIMESTAMP</h2>
        <div class="sectioncontent">
<p>To put a timestamp, the isbc, year, mon, mday, hour, min, sec and usec members must be set.  No other members are used.</p>
<pre>
<strong></strong>
typedef struct
{
	/* The number seconds before or after midnight UTC of
	 * January 1, 1970, not counting leap seconds.
	 */
	PGint8 epoch;

	/* The date part of the timestamp. */
	PGdate date;

	/* The time part of the timestamp. */
	PGtime time;
} PGtimestamp;

</pre>
<p>Putting a timestamp value:</p>
<pre>
<strong></strong>
// \'2000-01-19 10:41:06\'
PGtimestamp ts;
ts.date.isbc   = 0;
ts.date.year   = 2000;
ts.date.mon    = 0;
ts.date.mday   = 19;
ts.time.hour   = 10;
ts.time.min    = 41;
ts.time.sec    = 6;
ts.time.usec   = 0;
PQputf(param, "%timestamp", &ts);

</pre>
<p>Getting a timestamp value:</p>
<pre>
<strong></strong>
PQgetf(result, tup_num, "%timestamp", field_num, &ts);

</pre>
<p>The timestamp type has no concept of timezone, so the value returned by <a href="../man3/PQgetf.3.html"><strong>PQgetf</strong>(3)</a></em> is exactly what the server sent; no timezone adjustments are attempted.  The gmtoff is always set to zero, tzabbr will be an empty string and withtz will be zero.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TIMESTAMPTZ</h2>
        <div class="sectioncontent">
<p>To put a timestamptz, the isbc, year, mon, mday, hour, min, sec, usec and gmtoff members must be set.  No other members are used.</p><p>Putting a timestamptz value:</p>
<pre>
<strong></strong>
// \'2000-01-19 10:41:06-05\'
PGtimestamp ts;
ts.date.isbc   = 0;
ts.date.year   = 2000;
ts.date.mon    = 0;
ts.date.mday   = 19;
ts.time.hour   = 10;
ts.time.min    = 41;
ts.time.sec    = 6;
ts.time.usec   = 0;
ts.time.gmtoff = -18000;
PQputf(param, "%timestamptz", &ts);

</pre>
<p>Getting a timestamptz value:</p>
<pre>
<strong></strong>
PQgetf(result, tup_num, "%timestamptz", field_num, &ts);

</pre>
<p>When using <a href="../man3/PQgetf.3.html"><strong>PQgetf</strong>(3)</a></em> in binary mode, the timestamptz value is converted into the local machine\'s timezone.  If the local machine's timezone can not be determined, the value will be in GMT (gmtoff is set to zero and tzabbr is set to GMT).</p><p>When using <a href="../man3/PQgetf.3.html"><strong>PQgetf</strong>(3)</a></em> in text mode, the timestamptz value is returned as a datetime string in the server\'s timezone.  No adjustments are made to this value.  If the server is using a DateStyle that encodes the gmtoff "00:00:00-05", then gmtoff will be set to this value and tzabbr will be "GMT+/-hhmmss" (00:00:00-05 =&gt; GMT-0500).  In this case, isdst is set to -1 ... meaning unknown.  If the server\'s DateStyle encodes a timezone abbreviation, like PST, then tzabbr is set to this value.  The gmtoff and isdst members are properly set:</p>
<pre>
  DateStyle includes a timezone abbrev - "SQL, MDY"
  01/25/2007 00:00:00 EST =&gt; tzabbr=EST, gmtoff=-18000, isdst=0
  01/25/2007 01:00:00 EDT =&gt; tzabbr=EDT, gmtoff=-14400, isdst=1
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INTERVAL</h2>
        <div class="sectioncontent">
<p>To put an interval, all relevant members of a PGinterval should be assigned and those not used should be set to zero.</p>
<pre>
<strong></strong>
typedef struct
{
	/* the number of years */
	int years;

	/* the number of months */
	int mons;

	/* the number of days */
	int days;

	/* the number of hours */
	int hours;

	/* the number of mins */
	int mins;

	/* the number of seconds */
	int secs;

	/* the number of microseconds */
	int usecs;
} PGinterval;

</pre>
<p>Putting an interval value:</p>
<pre>
<strong></strong>
// "20 years 8 months 9 hours 10 mins 15 secs 123456 usecs"
PGinterval interval;
interval.years = 20;
interval.mons  = 8;
interval.days  = 0; // not used, set to 0
interval.hours = 9;
interval.mins  = 10;
interval.secs  = 15;
interval.usecs = 123456;
PQputf(param, "%interval", &interval);

</pre>
<p>Getting an interval value:</p>
<pre>
<strong></strong>
PQgetf(result, tup_num, "%interval", field_num, &interval);

</pre>
<p>NOTE: When using text results with a non-ISO DateStyle, microseconds are truncated to a 2 digit value.  For example: "4 mins 2.11 secs" but microseconds is really 111456.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">POINT</h2>
        <div class="sectioncontent">
<p>The PGpoint structure is used to put and get a point.</p>
<pre>
<strong></strong>
typedef struct
{
	double x; // point x value
	double y; // point y value
} PGpoint;

</pre>
<p>Putting a point value:</p>
<pre>
<strong></strong>
PGpoint pt = {12.345, 6.789};
PQputf(param, "%point", &pt);

</pre>
<p>Getting a point value:</p>
<pre>
<strong></strong>
PGpoint pt;
PQgetf(result, tup_num, "%point", field_num, &pt);

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LSEG</h2>
        <div class="sectioncontent">
<p>The PGlseg structure is used to put and get a line segnment.</p>
<pre>
<strong></strong>
typedef struct
{
  PGpoint pts[2];
} PGlseg;

</pre>
<p>Putting a lseg value:</p>
<pre>
<strong></strong>
PGlseg lseg = {{{12.345, 6.789}, {99.8, 88.9}}};
PQputf(param, "%lseg", &lseg);

</pre>
<p>Getting a lseg value:</p>
<pre>
<strong></strong>
PGlseg lseg;
PQgetf(result, tup_num, "%lseg", field_num, &lseg);

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BOX</h2>
        <div class="sectioncontent">
<p>The PGbox structure is used to put and get a box.</p>
<pre>
<strong></strong>
typedef struct
{
  PGpoint high;
  PGpoint low;
} PGbox;

</pre>
<p>Putting a box value:</p>
<pre>
<strong></strong>
PGbox box = {{12.345, 6.789}, {22.234, 1.9998}};
PQputf(param, "%box", &box);

</pre>
<p>Getting a box value:</p>
<pre>
<strong></strong>
PGbox box;
PQgetf(result, tup_num, "%box", field_num, &box);

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CIRCLE</h2>
        <div class="sectioncontent">
<p>The PGcircle structure is used to put and get a circle.</p>
<pre>
<strong></strong>
typedef struct
{
  PGpoint center;
  double radius;
} PGcircle;

</pre>
<p>Putting a circle value:</p>
<pre>
<strong></strong>
PGcircle circle = {{12.345, 6.789}, 2.34567};
PQputf(param, "%circle", &circle);

</pre>
<p>Getting a circle value:</p>
<pre>
<strong></strong>
PGcircle circle;
PQgetf(result, tup_num, "%circle", field_num, &circle);

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PATH</h2>
        <div class="sectioncontent">
<p>The PGpath structure is used to put and get a path.  If the closed member is non-zero, the path is closed, otherwise it is open.</p>
<pre>
<strong></strong>
typedef struct
{
  int npts;
  int closed;
  PGpoint *pts;
} PGpath;

</pre>
<p>Putting a path value:</p>
<pre>
<strong></strong>
// Put a closed path that contains 2 points
PGpoint pts[] = {{12.345, 6.789}, {19.773, 7.882}};
PGpath path = {2, 1, pts};
PQputf(param, "%path", &path);

</pre>
<p>Getting a path value:</p>
<pre>
<strong></strong>
PGpath path;
if(PQgetf(result, tup_num, "%path", field_num, &path))
{
	// path.pts must be copied out if needed after clearing results
	copy_points(path.npts, path.pts, ...);

	PQclear(result);
	// path.pts is now invalid!
}

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">POLYGON</h2>
        <div class="sectioncontent">
<p>The PGpolygon structure is used to put and get a polygon.</p>
<pre>
<strong></strong>
typedef struct
{
  int npts;
  PGpoint *pts;
} PGpolygon;

</pre>
<p>Putting a polygon value:</p>
<pre>
<strong></strong>
// Put a polygon that contains 2 points
PGpoint pts[] = {{12.345, 6.789}, {19.773, 7.882}};
PGpolygon polygon = {2, 1, pts};
PQputf(param, "%polygon", &polygon);

</pre>
<p>Getting a polygon value:</p>
<pre>
<strong></strong>
PGpolygon polygon;
if(PQgetf(result, tup_num, "%polygon", field_num, &polygon))
{
	// polygon.pts must be copied out if needed after clearing results
	copy_points(polygon.npts, polygon.pts, ...);

	PQclear(result);
	// polygon.pts is now invalid
}

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INET & CIDR</h2>
        <div class="sectioncontent">
<p>When putting an inet or cidr, all members must be set excluding the sa_len.</p>
<pre>
<strong></strong>
typedef struct
{
	/* The address mask, 32 for a single IP. */
	int mask;

	/* When non-zero, the PGinet structure represents a cidr
	 * otherwise an inet.
	 */
	int is_cidr;

	/* the length in bytes of the sa_buf member. */
	int sa_len;

	/* the socket address buffer, contains the data.  This can
	 * be casted to a sockaddr, sockaddr_in, sockaddr_in6 or a
	 * sockaddr_storage structure. This buffer is 128 bytes so
	 * that it is large enough for a sockaddr_storage structure.
	 */
	char sa_buf[128];
} PGinet;

</pre>
<p>Putting an inet or cidr:</p>
<pre>
<strong></strong>
socklen_t len;
PGinet inet;

cli_fd = accept(srv_fd, (struct sockaddr *)inet.sa_buf, &len);
if(cli_fd != -1)
{
	inet.is_cidr = 0;
	inet.mask = 32;
	PQputf(param, "%inet", &inet);
}

</pre>
<p>Getting an inet or cidr:</p>
<pre>
<strong></strong>
PGinet inet;
unsigned short port;

/* gets an inet from field 2 and an int2 from field 6 */
if(PQgetf(result, tup_num, "%inet %int2", 2, &inet, 6, &port))
{
	char ip[80];
	struct sockaddr *sa = (struct sockaddr *)inet.sa_buf;

	// converting a PGinet to an IPv4 or IPv6 address string
	getnameinfo(sa, inet.sa_len, ip, sizeof(ip),
		NULL, 0, NI_NUMERICHOST);

	// The inet data type does not store a port.
	if(sa-&gt;sa_family == AF_INET)
		((struct sockaddr_in *)sa)-&gt;sin_port = htons(port);
	else
		((struct sockaddr_in6 *)sa)-&gt;sin6_port = htons(port);

	printf("Connecting to %s:%d&#92;n", ip, port);
	connect(sock_fd, sa, inet.sa_len);
}

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MACADDR</h2>
        <div class="sectioncontent">
<p>The PGmacaddr structure is used to put and get a macaddr.</p>
<pre>
<strong></strong>
typedef struct
{
	int a;
	int b;
	int c;
	int d;
	int e;
	int f;
} PGmacaddr;

</pre>
<p>Putting a macaddr value:</p>
<pre>
<strong></strong>
PGmacaddr macaddr = {0, 1, 2, 3, 4, 5};
PQputf(param, "%macaddr", &macaddr);

</pre>
<p>Getting a macaddr value:</p>
<pre>
<strong></strong>
PGmacaddr macaddr;
PQgetf(result, tup_num, "%macaddr", field_num, &macaddr);

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MONEY</h2>
        <div class="sectioncontent">
<p>The money type is put/get as a PGmoney (64-bit integer).  It can be converted to dollar and cents format by dividing by 100: double money = (double)money64 / 100.0;.  Pre 8.3 servers are limited to 32-bit money values.</p><p>Putting a money value:</p>
<pre>
<strong></strong>
PGmoney money = 600000000054LL; // 6 billion dollars and 54 cents
PQputf(param, "%money", money);

</pre>
<p>Getting a money value:</p>
<pre>
<strong></strong>
PQgetf(result, tup_num, "%money", field_num, &money);

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BOOL</h2>
        <div class="sectioncontent">
<p>The bool type is put/get as a PGbool.  To put true or false, use 1 or 0.</p><p>Putting a bool value:</p>
<pre>
<strong></strong>
PGbool b = 1; // put true
PQputf(param, "%bool", b);

</pre>
<p>Getting a bool value:</p>
<pre>
<strong></strong>
PGbool b;
PQgetf(result, tup_num, "%bool", field_num, &b);

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">UUID</h2>
        <div class="sectioncontent">
<p>The uuid type is put/get as a sequence of 16 bytes.  To put a uuid as text, use "%str".  NOTE: this type is not available on pre 8.3 servers.</p><p>Putting a uuid value:</p>
<pre>
<strong></strong>
PGuuid uuid = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};
PQputf(param, "%uuid", uuid);

</pre>
<p>Getting a uuid value:</p>
<pre>
<strong></strong>
PGuuid uuid;
PQgetf(result, tup_num, "%uuid", field_num, &uuid);

</pre>
<p>WARNING: The data provided on a put call is expected to be at least 16 bytes.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OID</h2>
        <div class="sectioncontent">
<p>Putting an oid value:</p>
<pre>
<strong></strong>
Oid oid = 2318;
PQputf(param, "%oid", oid);

</pre>
<p>Getting an oid value:</p>
<pre>
<strong></strong>
Oid oid;
PQgetf(result, tup_num, "%oid", field_num, &oid);

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>None.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>A contribution of eSilo, LLC. for the PostgreSQL Database Management System. Written by Andrew Chernow and Merlin Moncure.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REPORTING BUGS</h2>
        <div class="sectioncontent">
<p>Report bugs to &lt;libpqtypes@esilo.com&gt;.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright (c) 2011 eSilo, LLC. All rights reserved.</p><p>This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or  FITNESS FOR A PARTICULAR PURPOSE.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO pqt-specs&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man3/PQgetf.3.html"><strong>PQgetf</strong>(3)</a></em>, <a href="../man3/PQputf.3.html"><strong>PQputf</strong>(3)</a></em>.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="pqt-composites.3.html"><span aria-hidden="true">&larr;</span> pqt-composites.3: A manual for libpqtypes composite handling.</a></li>
   <li class="next"><a href="prefixedoutstream.hpp.3.html">prefixedoutstream.hpp.3: Src/mlpack/core/util/prefixedoutstream.hpp - <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>vfs: Commands and procedures to create virtual filesystems</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Commands and procedures to create virtual filesystems">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="vfs (3tcl) manual">
  <meta name="twitter:description" content="Commands and procedures to create virtual filesystems">
  <meta name="twitter:image" content="https://www.carta.tech/images/tcl-vfs-vfs-3tcl.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3tcl/vfs.3tcl.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="vfs (3tcl) manual" />
  <meta property="og:description" content="Commands and procedures to create virtual filesystems" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/tcl-vfs-vfs-3tcl.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">vfs<small> (3tcl)</small></h1>
        <p class="lead">Commands and procedures to create virtual filesystems</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3tcl/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3tcl/vfs.3tcl.html">
      <span itemprop="name">vfs: Commands and procedures to create virtual filesystems</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/tcl-vfs/">
      <span itemprop="name">tcl-vfs</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3tcl/vfs.3tcl.html">
      <span itemprop="name">vfs: Commands and procedures to create virtual filesystems</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>package require Tcl 8.4</strong></p><p><strong>package require vfs ?1.2.1?</strong></p><p><strong>vfs::filesystem</strong> <em>info</em></p><p><strong>vfs::filesystem</strong> <em>mount</em></p><p><strong>vfs::filesystem</strong> <em>unmount</em></p><p><strong>vfs::accessMode</strong> <em>mode</em></p><p><strong>vfs::matchDirectories</strong> <em>types</em></p><p><strong>vfs::matchFiles</strong> <em>types</em></p><p><strong>vfs::matchCorrectTypes</strong> <em>types</em> <em>filelist</em> <em>?inDir?</em></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The <strong>::vfs</strong> package provides commands to query, mount and unmount virtual filesystems, and provides as Tcl libraries some facilities for helping the writing of new virtual filesystems in Tcl.  Once a virtual filesystem is in place, the standard Tcl <strong>file</strong>, <strong>glob</strong>, <strong>cd</strong>, <strong>pwd</strong>, <strong>open</strong> commands, including all their C APIs in the Tcl library (e.g. <strong>Tcl_FSOpenFileChannel</strong>, <strong>Tcl_FSMatchInDirectory</strong>,...), can be used within the filesystem (and indeed, properly written extensions such as Tk which may open or read files will also transparently access the virtual filesystem). Because all of Tcl's FS activity passes through a single layer, it can all be intercepted.  This package does just that.  Notice that this is quite different to overloading the <strong>file</strong> command in Tcl.  We are actually providing vfs replacements for C commands like <strong>access</strong>, <strong>stat</strong>.  By implementing just a handful of commands at this low level, we ensure that all commands at higher levels function irrespective of what is going on inside the FS layer.</p><p>Tcl's filesystem hooks operate on a per-process basis.  This means every Tcl interpreter in the same process/application sees the same filesystem, including any virtual filesystems.</p><p>The <strong>package require vfs</strong> command should be used to access this library.  It automatically registers the vfs hooks into Tcl's filesystem, and these will not be removed until Tcl exits (if desired, control over this could be exposed to Tcl in the future).  However, the vfs package will at that stage not have any new filesystems mounted, so it will have little effect.  Note that <strong>package require vfs</strong> has two effects.  First of all, when it is issued in <strong>any</strong> Tcl interpreter it will ensure the vfs hooks have been registered with Tcl's core just once (and if any of those interpreters are later deleted, the vfs hooks will still remain registered - they remain until Tcl exits).  The second effect is to provide the command <strong>vfs::filesystem</strong> which allows the interpreter to intercept filesystem commands and handle them with Tcl code in that interpreter.</p><p>There are three somewhat unsupported subcommands of <strong>vfs::filesystem</strong>, <strong>fullynormalize path</strong>, <strong>posixerror int</strong>, <strong>internalerror ?script?</strong>, which are used to normalize a path (including any final symlink), to register a posix error code with a Tcl error, and to trap/report internal errors in tclvfs implementations respectively.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>vfs::filesystem</strong> <em>mount</em> <em>?-volume?</em> <em>path</em> <em>command</em></p>
  </dt>
  <dd>
    <p>To use a virtual filesystem, it must be 'mounted'.  Mounting involves declaring to the vfs package that any subdirectories of a given <em>path</em> in the filesystem should be handled by the given <em>command</em> which should be a Tcl command or procedure in the interpreter in which the <strong>vfs::filesystem</strong> is executed.  If the <em>?-volume?</em> flag is given, the given mount point is also registered with Tcl as a new volume (like a new drive which will appear in <em>file volumes</em>). This is useful (and required for reasonable operation) for mounts like <em>ftp://</em>.  For paths mounted inside the native filesystem, it should of course not be given.  The new filesystem mounts will be observed immediately in all interpreters in the current process.  If the interpreter is later deleted, all mounts which are intercepted by it will be automatically removed (and will therefore affect the view of the filesystem seen by all interpreters).</p>
  </dd>
  <dt>
    <p><strong>vfs::filesystem</strong> <em>unmount</em> <em>path</em></p>
  </dt>
  <dd>
    <p>This unmounts the virtual filesystem which was mounted at <em>path</em> (hence removing it from Tcl's filesystem), or throws an error if no filesystem was mounted there.</p>
  </dd>
  <dt>
    <p><strong>vfs::filesystem</strong> <em>info</em> <em>?path?</em></p>
  </dt>
  <dd>
    <p>If no arguments are given, this returns a list of all filesystems mounted (in all interpreters).  If a path argument is given, then the <em>command</em> to be used for that path is returned, or an error is thrown if no vfs is mounted for that path.  There is currently no facility for examining in which interpreter each command will be evaluated.</p>
  </dd>
  <dt>
    <p><strong>vfs::filesystem</strong> <em>fullynormalize</em> <em>path</em></p>
  </dt>
  <dd>
    <p>Performs a full expansion of <em>path</em>, (as per 'file normalize'), but including following any links in the last element of path.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">IMPLEMENTING A TCL ONLY VFS</h2>
        <div class="sectioncontent">
<p>The vfs package will intercept every filesystem operation which falls within a given mount point, and pass the operation on to the mount point's <em>command</em> in the interpreter which registered it. In general this occurs by the C equivalent of an evaluation like this: <em>eval $command [list $subcmd $root $relative</em> $actualpath] $args.</p><p>Here <em>subcmd</em> may be any of the following: <em>access</em>, <em>createdirectory</em>, <em>deletefile</em>, <em>fileattributes</em>, <em>matchindirectory</em>, <em>open</em>, <em>removedirectory</em>, <em>stat</em>, <em>utime</em>. If <em>command</em> takes appropriate action for each of these cases, a complete, perfect virtual filesystem will be achieved, indistinguishable to Tcl from the native filesystem.  (CAVEATS: right now I don't expose to Tcl all the permission-related flags of 'glob').</p><p>The remaining arguments specify a file path on which to operate (all commands operate on one of these), and any additional arguments which may be required to carry out the action.  The file path is specified by three arguments: <em>root</em> is the part of the path which lies outside this filesystem's mount point, <em>relative</em> is the part of the path which lies inside this filesytem, and <em>actualpath</em> is the original (unnormalized) name of the path which was used in the current command wherever it originated (in Tcl or C).  For example, if <em>C:/foo/bar/mount.zip/xxx/yyy</em> is a path in your filesystem, where <em>mount.zip</em> is a zip archive which has been mounted (on top of itself) and contains <em>xxx/yyy</em>, and the current working directory is inside <em>xxx</em>, and we evaluate a command like <em>file exists</em> yyy, then <em>root</em> will be <em>C:/foo/bar/mount.zip</em>, <em>relative</em> will be <em>xxx/yyy</em>, and <em>actualpath</em> will be <em>yyy</em>. The file separator between the <em>root</em> and <em>relative</em> is omitted.</p><p>Note that most filesystem operations will only require the <em>relative</em> argument to work correctly, but the other arguments are actually required for correct operation of some subcommands.</p><p>Almost all of these commands should either return correctly (i.e. with a TCL_OK result at the C level) or they should use vfs::filesystem posixerror to signal the appropriate posix error code.  If a Tcl error is thrown, that should be considered a bug, but it will be interpreted as an unknown posix error in the filesystem call.  The exceptions to these rules are those filesystem commands which are able to specify a Tcl error message directly: open (when an interpreter is given), matchindirectory and fileattributes (for a set or get operation only).  These three commands are allowed to throw any Tcl error message which will be passed along to the caller, or they may throw a posix error which will be handled appropriately.</p><p>The actual commands are as follows (where <em>r-r-a</em> represents the standard argument triplet of <em>root</em>, <em>relative</em> and <em>actualpath</em>):</p>
<dl class='dl-vertical'>
  <dt>
    <p><em>command</em> <em>access</em> <em>r-r-a</em> <em>mode</em></p>
  </dt>
  <dd>
    <p>Return TCL_OK or throw a posix error depending on whether the given access mode (which is an integer) is compatible with the file.</p>
  </dd>
  <dt>
    <p><em>command</em> <em>createdirectory</em> <em>r-r-a</em></p>
  </dt>
  <dd>
    <p>Create a directory with the given name.  The command can assume that all sub-directories in the path exist and are valid, and that the actual desired path does not yet exist (Tcl takes care of all of that for us).</p>
  </dd>
  <dt>
    <p><em>command</em> <em>deletefile</em> <em>r-r-a</em></p>
  </dt>
  <dd>
    <p>Delete the given file.</p>
  </dd>
  <dt>
    <p><em>command</em> <em>fileattributes</em> <em>r-r-a</em> <em>?index?</em> <em>?value?</em></p>
  </dt>
  <dd>
    <p>If neither index nor value is given, then return a list of all acceptable attribute names.  If <em>index</em> is given, but no value, then retrieve the value of the <em>index</em>'th attribute (counting in order over the list returned when no argument is given) for the given file.  If a value is also given then set the <em>index</em>'th attribute of the given file to that value.</p>
  </dd>
  <dt>
    <p><em>command</em> <em>matchindirectory</em> <em>r-r-a</em> <em>pattern</em> <em>types</em></p>
  </dt>
  <dd>
    <p>Return the list of files or directories in the given path (which is always the name of an existing directory), which match the <em>pattern</em> and are compatible with the <em>types</em> given.  It is very important that the command correctly handle <em>types</em> requests for directories only (and files only), because to handle any kind of recursive globbing, Tcl will actually generate requests for directory-only matches from the filesystem.  See <strong>vfs::matchDirectories</strong> below for help.</p>
  </dd>
  <dt>
    <p><em>command</em> <em>open</em> <em>r-r-a</em> <em>mode</em> <em>permissions</em></p>
  </dt>
  <dd>
    <p>For this command, <em>mode</em> is any of "r", "w", "a", "w+", "a+". If the open involves creating a file, then <em>permissions</em> dictates what modes to create it with.  If the open operation was not successful, an error should be thrown.  If the open operation is successful, the command should return a list of either one or two items.  The first item (which is obligatory) is the name of the channel which has been created.  The second item, if given, is a Tcl-callback to be used when the channel is closed, so that the vfs can clean up as appropriate.  This callback will be evaluated by Tcl just before the channel is closed.  The channel will still exist, and all available data will have been flushed into it.  The callback can, for example, seek to the beginning of the channel, read its contents and store that contents elsewhere (e.g. compressed or on a remote ftp site, etc).  The return code or any errors returned by the callback are ignored (if the callback wishes to signal an error, it must do so asycnhronously, with bgerror, for example), unless the 'internalerror' script has been specified, when they are passed to that script for further action.</p>
  </dd>
  <dt>
    <p><em>command</em> <em>removedirectory</em> <em>r-r-a</em> <em>recursive</em></p>
  </dt>
  <dd>
    <p>Delete the given directory.  <em>recursive</em> is either 0 or 1. If it is 1 then even if the directory is non-empty, an attempt should be made to recursively delete it and its contents.  If it is 0 and the directory is non-empty, a posix error (ENOTEMPTY) should be thrown.</p>
  </dd>
  <dt>
    <p><em>command</em> <em>stat</em> <em>r-r-a</em></p>
  </dt>
  <dd>
    <p>Return a list of even length containing field-name and value pairs for the contents of a stat structure.  The order is not important. The option names are dev (long), ino (long), mode (int), nlink (long), uid (long), gid (long), size (long), atime (long), mtime (long), ctime (long), type (string which is either "directory" or "file"), where the type of each argument is given in brackets.  The procedure should therefore return with something like <em>return [list dev 0 type file</em> mtime 1234 ...].</p>
  </dd>
  <dt>
    <p><em>command</em> <em>utime</em> <em>r-r-a</em> <em>actime</em> <em>mtime</em></p>
  </dt>
  <dd>
    <p>Set the access and modification times of the given file (these are read with 'stat').</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">VFS HELPERS</h2>
        <div class="sectioncontent">
<p>The vfslib provides a number of Tcl procedures which can help with writing command procedures to handle the above possibilities.  These are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>vfs::accessMode</strong> <em>mode</em></p>
  </dt>
  <dd>
    <p>converts an integer <em>access</em> mode to a somewhat more preferable string, any of F X W XW R RX RW.</p>
  </dd>
  <dt>
    <p><strong>vfs::matchDirectories</strong> <em>types</em></p>
  </dt>
  <dd>
    <p>Does <em>types</em> want directories included?</p>
  </dd>
  <dt>
    <p><strong>vfs::matchFiles</strong> <em>types</em></p>
  </dt>
  <dd>
    <p>Does <em>types</em> want files included?</p>
  </dd>
  <dt>
    <p><strong>vfs::matchCorrectTypes</strong> <em>types</em> <em>filelist</em> <em>?inDir?</em></p>
  </dt>
  <dd>
    <p>Returns that subset of the <em>filelist</em> (which are either absolute paths or names of files in <em>inDir</em>) which are compatible with the <em>types</em> given.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">VFS DEBUGGING</h2>
        <div class="sectioncontent">
<p>Use something like this to debug problems in your implementation: vfs::filesystem internalerror report ; proc report {} { puts stderr $::errorInfo }</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LIMITATIONS</h2>
        <div class="sectioncontent">
<p>There are very few limitations to the vfs code.  One subtlety that you may encounter is if you mount a case-sensitive virtual filesystem into a case-insensitive system (e.g. the standard Windows or MacOS fs) and your code relies on case-insensitivity, then it will not run properly in the virtual filesystem.  Of course if your code relies on case-insensitivity, it wouldn't run under Tcl on Unix either, so the best solution is to fix your code!</p><p>We may add <em>link</em> and <em>lstat</em> commands in the future to allow virtual filesystems to support reading and writing links - this is supported by the C API, but has simply not been exposed to Tcl in this extension, yet.</p><p>The Tcl 'Tcl_FSMatchInDirectory' function takes a variety of type information in a Tcl_GlobTypeData structure.  We currently only expose the 'type' field from that structure (so the 'permissions' and MacOS type/creator fields are ignored).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">KEYWORDS</h2>
        <div class="sectioncontent">
<p>vfs, filesystem, file</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="tkhtml.3tcl.html"><span aria-hidden="true">&larr;</span> tkhtml.3tcl: Widget to render html documents.</a></li>
   <li class="next"><a href="vfslib.3tcl.html">vfslib.3tcl: Procedures to interact with virtual filesystems <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RlwrapFilter: Perl class for rlwrap filters</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Perl class for rlwrap filters">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="RlwrapFilter (3pm) manual">
  <meta name="twitter:description" content="Perl class for rlwrap filters">
  <meta name="twitter:image" content="https://www.carta.tech/images/rlwrap-RlwrapFilter-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/RlwrapFilter.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="RlwrapFilter (3pm) manual" />
  <meta property="og:description" content="Perl class for rlwrap filters" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/rlwrap-RlwrapFilter-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">RlwrapFilter<small> (3pm)</small></h1>
        <p class="lead">Perl class for rlwrap filters</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/RlwrapFilter.3pm.html">
      <span itemprop="name">RlwrapFilter: Perl class for rlwrap filters</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/rlwrap/">
      <span itemprop="name">rlwrap</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/RlwrapFilter.3pm.html">
      <span itemprop="name">RlwrapFilter: Perl class for rlwrap filters</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  use lib $ENV{RLWRAP_FILTERDIR};
  use RlwrapFilter;

  $filter = new RlwrapFilter;

  $filter -&gt; output_handler(sub {s/apple/orange/; $_}); # re-write output
  $filter -&gt; prompt_handler(&#92;&pimp_the_prompt); # change prompt
  $filter -&gt; history_handler(sub {s/with password &#92;w+/with password ****/; $_}); # keep passwords out of history

  $filter -&gt; run;
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><strong>rlwrap</strong> (1) (&lt;http://utopia.knoware.nl/~hlub/uck/rlwrap&gt;) is a tiny utility that sits between the user and any console command, in order to bestow readline capabilities (line editing, history recall) to commands that don't have them.</p><p>Since version 0.32, rlwrap can use filters to script almost every aspect of rlwrap's interaction with the user: changing the history, re-writing output and input, calling a pager or computing completion word lists from the current input.</p><p><strong>RlwrapFilter</strong> makes it very simple to write rlwrap filters in perl. A filter only needs to instantiate a RlwrapFilter object, change a few of its default handlers and then call its 'run' method.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PUBLIC METHODS</h2>
        <div class="sectioncontent">
<h3>\s-1CONSTRUCTOR\s0</h3>
<p>Return a new RlwrapFilter object.</p>
<h3>\s-1SETTING/GETTING\s0 \s-1HANDLERS\s0</h3>
<p>Handlers are user-defined callbacks that get called from the 'run' method with a message  (i.e. the un-filtered input, output, prompt) as their first argument. For convenience, $_ is set to the same value. They should return the re-written message text. They get called in a fixed cyclic order: prompt, completion, history, input, echo, output, prompt, ... etc ad infinitum. Rlwrap may always skip a handler when in direct mode, on the other hand, completion and output handlers may get called more than once in succession. If a handler is left undefined, the result is as if the message text were returned unaltered.</p><p>It is important to note that the filter, and hence all its handlers, are bypassed when <em>command</em> is in direct mode, i.e. when it asks for single keystrokes (and also, for security reasons, when it doesn't echo, e.g. when asking for a password). If you don't want this to happen, use <strong>rlwrap -a</strong> to force <strong>rlwrap</strong> to remain in readline mode and to apply the filter to <em>all</em> of <em>command</em>'s in- and output. This will make editors and pagers (which respond to single keystrokes) unusable, unless you use rlwrap's <strong>-N</strong> option (linux only)</p><p>The getters/setters for the respective handlers are listed below: The prompt handler re-writes prompts and gets called when rlwrap decides it is time to \*(L"cook\*(R" the prompt, by default some 40 ms after the last output has arrived. Of course, <strong>rlwrap</strong> cannot read the mind of <em>command</em>, so what looks like a prompt to <strong>rlwrap</strong> may actually be the beginning of an output line that took <em>command</em> a little longer to formulate. If this is a problem, specify a longer \*(L"cooking\*(R" time with rlwrap's <strong>-w</strong> option, use the <strong>prompts_are_never_empty</strong> method or \*(L"reject\*(R" the prompt (cf. the <strong>prompt_rejected</strong> method) The completion handler gets called with the the entire input line, the prefix (partial word to complete), and rlwrap's own completion list as arguments. It should return a (possibly revised) list of completions.  As an example, suppose the user has typed \*(L"She played for A&lt;\s-1TAB\s0&gt;\*(R". The handler will be called like this:      myhandler("She played for A", "A", "Arsenal", "Arendal", "Anderlecht") it could then return a list of stronger clubs: (\*(L"Ajax\*(R", \*(L"\s-1AZ67\s0\*(R",  \*(L"Arnhem\*(R") Every input line is submitted to this handler, the return value is put in rlwrap's history. Returning an empty or undefined value will keep the input line out of the history. Every input line is submitted to this handler, The handler's return value is written to <em>command</em>'s pty (pseudo-terminal). The first line of output that is read back from <em>command</em>'s pty is the echo'ed input line. If your input handler alters the input line, it is the altered input that will be echo'ed back. If you don't want to confuse the user, use an echo handler that returns your original input. If you use rlwrap in --multi-line mode, additional echo lines will have to be handled by the output handler All <em>command</em> output after the echo line is submitted to the output handler (including newlines). This handler may get called many times in succession, dependent on the size of <em>command</em>'s <em>write()</em> calls, and the whims of your system's scheduler. Therefore your handler should be prepared to rewrite your output in \*(L"chunks\*(R", where you even don't have the guarantee that the chunks contain entire unbroken lines. If you want to handle <em>command</em>'s entire output in one go, you can specify an output handler that returns an empty string, and then use $filter -&gt; cumulative_output in your prompt handler to send the re-written output \*(L"out-of-band\*(R" just before the prompt:     $filter -&gt; output_handler(sub {""});</p><p>    $filter -&gt; prompt_handler(                   sub{ $filter -&gt; send_output_oob(mysub($filter -&gt; cumulative_output));                        "Hi there &gt; "                      }); Note that when rlwrap is run in --multi-line mode the echo handler will still only handle the first echo line.  The remainder will generally be echoed back preceded by a continuation prompt; it is up to the output handler what to do with it. This handler gets called (as handler($message, $tag)) for every incoming message, and every tag (including out-of-band tags), before all other handlers. Its return value is ignored, but it may be useful for logging and debugging purposes. The $tag is an integer that can be converted to a tag name by the 'tag2name' method</p>
<h3>\s-1OTHER\s0 \s-1METHODS\s0</h3>
<p>Set the help text for this filter. It will be displayed by rlwrap -z &lt;filter&gt;. The second line of the help text is used by \*(C`rlwrap -z listing\*(C'; it should be a short description of what the filter does. Die unless rlwrap is version x.yy or newer return the name of <em>command</em>'s current working directory. This uses the /proc filesystem, and may only work on newer linux systems (on older linux and on Solaris, it will return something like \*(L"/proc/12345/cwd\*(R", useful to find the contents of <em>command</em>'s working directory, but not its name) return the current cumulative output. All (untreated) output gets appended to the cumulative output after the output_handler has been called. The cumulative output starts with a fresh slate with every \s-1OUTPUT\s0 message that directly follows an \s-1INPUT\s0 message (ignoring out-of-band messages and rejected prompts) When necessary (i.e. when <strong>rlwrap</strong> is in \*(L"impatient mode\*(R") the prompt is removed from $filter-&gt;cumulative_output by the time the prompt handler is called. The tag of the last preceding in-band message. A tag is an integer between 0 and 255, its name can be found with the following method: Convert the tag (an integer) to its name (e.g. \*(L"\s-1TAG_PROMPT\s0\*(R") Convert a valid tag name like \*(L"\s-1TAG_PROMPT\s0\*(R" to a tag (an integer) Make rlwrap display $text. $text is sent \*(L"out-of-band\*(R": <strong>rlwrap</strong> will not see it until just  after it has sent the next message to the filter Send an out-of-band \s-1TAG_IGNORE\s0 message to rlwrap. <strong>rlwrap</strong> will silently discard it, but it can be useful when debugging filters Permanently add or remove the words in @words to/from rlwrap's completion list. Send $question to <em>command</em>'s input and read back everything that comes back until $prompt is seen at \*(L"end-of-chunk\*(R", or no new chunks arrive for $timeout seconds, whichever comes first.  Return the response (without the final $prompt).  <strong>rlwrap</strong> remains completely unaware of this conversation. If $verbosity evaluates to a true value, make rlwrap print all questions sent to <em>command</em> by the \*(C`cloak_and_dagger\*(C' method, and <em>command</em>'s responses. By default, $verbosity = 0; setting it to 1 will mess up the screen but greatly facilitate the (otherwise rather tricky) use of \*(C`cloak_and_dagger\*(C' A special text (\*(L"_THIS_CANNOT_BE_A_PROMPT_\*(R") to be returned by a prompt handler to \*(L"reject\*(R" the prompt. This will make rlwrap skip cooking the prompt.  $self-&gt;previous_tag and $self-&gt;cumulative_output will not be touched. If $val evaluates to a true value, automatically reject empty prompts. In scalar context: the rlwrapped command and its arguments as a string (\*(L"command -v blah\*(R") in list context: the same as a list (\*(L"command\*(R", \*(L"-v\*(R", \*(L"blah\*(R") Whether the filter is run by <strong>rlwrap</strong>, or directly from the command line Start an event loop that reads rlwrap's messages from the input pipe, calls the appropriate handlers and writes the result to the output pipe.  This method never returns.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LOW LEVEL PROTOCOL</h2>
        <div class="sectioncontent">
<p><strong>rlwrap</strong> communicates with a filter through messages consisting of a tag byte (\s-1TAG_OUTPUT\s0, \s-1TAG_PROMPT\s0 etc. - to inform the filter of what is being sent), an unsigned 32-bit integer containing the length of the message, the message text and an extra newline. For every message sent, rlwrap expects, and waits for an answer message with the same tag. Sending back a different (in-band) tag is an error and instantly kills rlwrap, though filters may precede their answer message with \*(L"out-of-band\*(R" messages to output text (\s-1TAG_OUTPUT_OUT_OF_BAND\s0), report errors (\s-1TAG_ERROR\s0), and to manipulate the completion word list (\s-1TAG_ADD_TO_COMPLETION_LIST\s0 and \s-1TAG_REMOVE_FROM_COMPLETION_LIST\s0) Out-of-band messages are not serviced by <strong>rlwrap</strong> until right after it has sent the next in-band message - the communication with the filter is synchronous and driven by rlwrap.</p><p>Messages are received and sent via two pipes. \s-1STDIN\s0, \s-1STDOUT\s0 and \s-1STDERR\s0 are still connected to the user's terminal, and you can read and write them directly, though this may mess up the screen and confuse the user unless you are careful. A filter can even communicate with the rlwrapped command behind rlwrap's back (cf the <em>cloak_and_dagger()</em> method)</p><p>The protocol uses the following tags (tags &gt; 128 are out-of-band)</p><p> TAG_INPUT       0  TAG_OUTPUT      1  TAG_HISTORY     2  TAG_COMPLETION  3  TAG_PROMPT      4</p><p> TAG_IGNORE                      251  TAG_ADD_TO_COMPLETION_LIST      252  TAG_REMOVE_FROM_COMPLETION_LIST 253  TAG_OUTPUT_OUT_OF_BAND          254  TAG_ERROR                       255</p><p>To see how this works, you can eavesdrop on the protocol using the 'logger' filter.</p><p>The constants \s-1TAG_INPUT\s0, ... are exported by the RlwrapFilter.pm module.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SIGNALS</h2>
        <div class="sectioncontent">
<p>As \s-1STDIN\s0 is still connected to the users teminal, one might expect the filter to receive \s-1SIGINT\s0, \s-1SIGTERM\s0, \s-1SIGTSTP\s0 directly from the terminal driver if the user presses CTRL-C, CTRL-Z etc Normally, we don't want this - it would confuse rlwrap, and the user (who thinks she is talking straight to the rlwapped command) probably meant those signals to be sent to the command itself. For this reason the filter starts with all signals blocked.</p><p>Filters that interact with the users terminal (e.g. to run a pager) should unblock signals like \s-1SIGTERM\s0, \s-1SIGWINCH\s0.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILTER LIFETIME</h2>
        <div class="sectioncontent">
<p>The filter is started by <strong>rlwrap</strong> after <em>command</em>, and stays alive as long as <strong>rlwrap</strong> runs. Filter methods are immediately usable. When <em>command</em> exits, the filter stays around for a little longer in order to process <em>command</em>'s last words. As calling the cwd and cloak_and_dagger methods at that time will make the filter die with an error, it may be advisable to wrap those calls in eval{}</p><p>If a filter calls <em>die()</em> it will send an (out-of-band) \s-1TAG_ERROR\s0 message to rlwrap before exiting. rlwrap will then report the message and exit (just after its next in-band message - out-of-band messages are not always processed immediately)</p><p><em>die()</em> within an <em>eval()</em> sets $@ as usual.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ENVIRONMENT</h2>
        <div class="sectioncontent">
<p>Before calling a filter, <strong>rlwrap</strong> sets the following environment variables:</p><p>    RLWRAP_FILTERDIR      directory where RlwrapFilter.pm and most filters live (set by B&lt;rlwrap&gt;, can be                           overridden by the user before calling rlwrap)</p><p>    PATH                  rlwrap automatically adds $RLWRAP_FILTERDIR to the front of filter&apos;s PATH</p><p>    RLWRAP_VERSION        rlwrap version (e.g. "0.35")</p><p>    RLWRAP_COMMAND_PID    process ID of the rlwrapped command</p><p>    RLWRAP_COMMAND_LINE   command line of the rlwrapped command</p><p>    RLWRAP_IMPATIENT      whether rlwrap is in "impatient mode" (cf B&lt;rlwrap (1)&gt;). In impatient mode,                           the candidate prompt is filtered through the output handler (and displayed before                           being overwritten by the cooked prompt).</p><p>    RLWRAP_INPUT_PIPE_FD  File descriptor of input pipe. For internal use only</p><p>    RLWRAP_OUTPUT_PIPE_FD File descriptor of output pipe. For internal use only</p><p>    RLWRAP_MASTER_PTY_FD File descriptor of I&lt;command&gt;&apos;s pty.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DEBUGGING FILTERS</h2>
        <div class="sectioncontent">
<p>While RlwrapFilter.pm makes it easy to write simple filters, debugging them can be a problem. A couple of useful tricks:</p><h3>\s-1LOGGING\s0</h3>
<p>When running a filter, the in- and outgoing messages can be logged by the <strong>logger</strong> filter, using a pipeline:</p><p>  rlwrap -z &apos;pipeline logger incoming : my_filter : logger outgoing&apos; command</p>
<h3>\s-1RUNNING\s0 \s-1WITHOUT\s0 \fBrlwrap\fP</h3>
<p>When called by rlwrap, filters get their input from $RLWRAP_INPUT_PIPE_FD and write their output to $RLWRAP_OUTPUT_PIPE_FD, and expect and write messages consisting of a tag byte, a 32-bit length and the message proper. This is not terribly useful when running a filter directly from the command line (outside rlwrap), even if we set the RLWRAP_*_FD ourselves.</p><p>Therefore, when run directly from the command line, a filter expects input messages on its standard input of the form</p><p>\s-1TAG_PROMPT\s0 myprompt &gt;</p><p>(i.a. a tag name, one space and a message followed by a newline) and it will respond in the same way on its standard output</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO RlwrapFilter&hellip;</h2>
        <div class="sectioncontent">
<p><strong>rlwrap</strong> (1), <strong>readline</strong> (3)</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Regexp::RegGrp.3pm.html"><span aria-hidden="true">&larr;</span> Regexp::RegGrp.3pm: Groups a regular expressions collection</a></li>
   <li class="next"><a href="RoPkg.3pm.html">RoPkg.3pm: Collection of perl classes. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

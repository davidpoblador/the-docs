<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>JudyL: C library for creating and accessing a dynamic array of words, using a word as an index.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="C library for creating and accessing a dynamic array of words, using a word as an index.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="JudyL (3) manual">
  <meta name="twitter:description" content="C library for creating and accessing a dynamic array of words, using a word as an index.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libjudy-dev-JudyL-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/JudyL.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="JudyL (3) manual" />
  <meta property="og:description" content="C library for creating and accessing a dynamic array of words, using a word as an index." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libjudy-dev-JudyL-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">JudyL<small> (3)</small></h1>
        <p class="lead">C library for creating and accessing a dynamic array of words, using a word as an index.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/JudyL.3.html">
      <span itemprop="name">JudyL: C library for creating and accessing a dynamic array of words, using a word as an index.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libjudy-dev/">
      <span itemprop="name">libjudy-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/JudyL.3.html">
      <span itemprop="name">JudyL: C library for creating and accessing a dynamic array of words, using a word as an index.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
cc [flags] <em>sourcefiles</em> -lJudy

#include &lt;Judy.h&gt;

int      Rc_int;                          // return code - integer
Word_t   Rc_word;                         // return code - unsigned word
Word_t   Index, Index1, Index2, Nth;
PWord_t  PValue;                          // pointer to return value
Pvoid_t PJLArray = (Pvoid_t) NULL;        // initialize JudyL array

JLI( PValue,  PJLArray, Index);          // JudyLIns()
JLD( Rc_int,  PJLArray, Index);          // JudyLDel()
JLG( PValue,  PJLArray, Index);          // JudyLGet()
JLC( Rc_word, PJLArray, Index1, Index2); // JudyLCount()
JLBC(PValue,  PJLArray, Nth, Index);     // JudyLByCount()
JLFA(Rc_word, PJLArray);                 // JudyLFreeArray()
JLMU(Rc_word, PJLArray);                 // JudyLMemUsed()
JLF( PValue,  PJLArray, Index);          // JudyLFirst()
JLN( PValue,  PJLArray, Index);          // JudyLNext()
JLL( PValue,  PJLArray, Index);          // JudyLLast()
JLP( PValue,  PJLArray, Index);          // JudyLPrev()
JLFE(Rc_int,  PJLArray, Index);          // JudyLFirstEmpty()
JLNE(Rc_int,  PJLArray, Index);          // JudyLNextEmpty()
JLLE(Rc_int,  PJLArray, Index);          // JudyLLastEmpty()
JLPE(Rc_int,  PJLArray, Index);          // JudyLPrevEmpty()
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>A JudyL array is the equivalent of an array of word-sized values. A <strong>Value</strong> is addressed by an <strong>Index</strong> (key). The array may be sparse, and the <strong>Index</strong> may be any word-sized number. Memory to support the array is allocated as index/value pairs are inserted, and released as index/value pairs are deleted.  A JudyL array can also be thought of as a mapper, that is "map" a word to another word/pointer.</p><p>As with an ordinary array, there are no duplicate indexes in a JudyL array.</p><p>The value may be used as a scalar, or a pointer to a structure or block of data (or even another Judy array).</p><p>A JudyL array is allocated with a <strong>NULL</strong> pointer</p>
<pre>
Pvoid_t PJLArray = (Pvoid_t) NULL;
</pre>
<p>Using the macros described here, rather than the <strong>JudyL function calls</strong>, the default error handling sends a message to the standard error and terminates the program with <strong>exit</strong>(1);</em>. For other error handling methods, see the <em>ERRORS</em> section. <em>JLI</em>( PValue,  PJLArray, Index);          // <strong>JudyLIns()</strong></p><p>Because the macro forms are sometimes faster and have a simpler error handling interface than the equivalent <strong>JudyL functions</strong>, they are the preferred way of calling the JudyL functions.</p>
<dl class='dl-vertical'>
  <dt>
    <p> <strong>JLI(PValue, PJLArray, Index)</strong> // <strong>JudyLIns()</strong></p>
  </dt>
  <dd>
    <p>Insert an <strong>Index</strong> and <strong>Value</strong> into the JudyL array <strong>PJLArray</strong>. If the <strong>Index</strong> is successfully inserted, the <strong>Value</strong> is initialized to 0. If the <strong>Index</strong> was already present, the <strong>Value</strong> is not modified.</p><ul>
<li><p>Return <strong>PValue</strong> pointing to <strong>Value</strong>. Your program can use this pointer to read or modify <strong>Value</strong> until the next <strong>JLI()</strong> (insert), <strong>JLD()</strong> (delete) or <strong>JLFA()</strong> (freearray) is executed on <strong>PJLArray</strong>. Examples:</p></li><li>
<pre>
*PValue = 1234;
Value = *PValue;
</pre>
</li><li><p>Return <strong>PValue</strong> set to <strong>PJERR</strong> if a <em>malloc()</em> fail occured. <strong>Note</strong>: <strong>JLI()</strong> and <strong>JLD()</strong> reorganize the JudyL array. Therefore, <strong>PValue</strong> returned from previous <strong>JudyL</strong> calls become invalid and must be re-acquired.</p></li><li></li>
</ul>
  </dd>
  <dt>
    <p> <strong>JLD(Rc_int, PJLArray, Index)</strong> // <strong>JudyLDel()</strong></p>
  </dt>
  <dd>
    <p>Delete the <strong>Index</strong>/<strong>Value</strong> pair from the JudyL array.</p><ul>
<li><p>Return <strong>Rc_int</strong> set to 1 if successful. Return <strong>Rc_int</strong> set to 0 if <strong>Index</strong> was not present. Return <strong>Rc_int</strong> set to <strong>JERR</strong> if a <em>malloc()</em> fail occured.</p></li><li></li>
</ul>
  </dd>
  <dt>
    <p> <strong>JLG(PValue, PJLArray, Index)</strong> // <strong>JudyLGet()</strong></p>
  </dt>
  <dd>
    <p>Get the pointer <strong>PValue</strong> associated with <strong>Index</strong> in the <strong>PJLArray</strong> Judy array.</p><ul>
<li><p>Return <strong>PValue</strong> pointing to <strong>Value</strong>. Return <strong>PValue</strong> set to <strong>NULL</strong> if the <strong>Index</strong> was not present. Return <strong>PValue</strong> set to <strong>PJERR</strong> if a <em>malloc()</em> fail occured.</p></li><li></li>
</ul>
  </dd>
  <dt>
    <p> <strong>JLC(Rc_word, PJLArray, Index1, Index2)</strong> // <strong>JudyLCount()</strong></p>
  </dt>
  <dd>
    <p>Count the number of indexes present in the JudyL array <strong>PJLArray</strong> between <strong>Index1</strong> and <strong>Index2</strong> (inclusive).</p><ul>
<li><p>Return <strong>Rc_word</strong> set to the count. A return value of 0 can be valid as a count.</p></li><li><p>To count all indexes present in a JudyL array, use:</p></li><li>
<pre>
JLC(Rc_word, PJLArray, 0, -1);
</pre>
</li><li></li>
</ul>
  </dd>
  <dt>
    <p> <strong>JLBC(PValue, PJLArray, Nth, Index)</strong> // <strong>JudyLByCount()</strong></p>
  </dt>
  <dd>
    <p>Locate the <strong>Nth</strong> index that is present in the JudyL array <strong>PJLArray</strong> (<strong>Nth</strong> = 1 returns the first index present).</p><ul>
<li><p>Return <strong>PValue</strong> pointing to its <strong>Value</strong> and <strong>Index</strong> set to the <strong>Nth</strong> index if found, otherwise return <strong>PValue</strong> set to <strong>NULL</strong> (the value of <strong>Index</strong> is undefined).</p></li><li></li>
</ul>
  </dd>
  <dt>
    <p> <strong>JLFA(Rc_word, PJLArray)</strong> // <strong>JudyLFreeArray()</strong></p>
  </dt>
  <dd>
    <p>Given a pointer to a JudyL array, free the entire array (much faster than using a <strong>JLN()</strong>, <strong>JLD()</strong> loop).</p><ul>
<li><p>Return <strong>Rc_word</strong> set to the number of bytes freed and <strong>PJLArray</strong> set to <strong>NULL</strong>.</p></li><li></li>
</ul>
  </dd>
  <dt>
    <p> <strong>JLMU(Rc_word, PJLArray)</strong> // <strong>JudyLMemUsed()</strong></p>
  </dt>
  <dd>
    <p>Return <strong>Rc_word</strong> set to the number of bytes of memory <em>malloc()</em>'ed by <strong>PJLArray</strong>. This is a very fast routine, and may be used before and after a <strong>JLI()</strong> or <strong>JLD()</strong> call with little performance impact.</p><ul>
<li></li>
</ul>
  </dd>
  <dt>
    <p> <strong>JudyL Search Functions</strong></p>
  </dt>
  <dd>
    <p><strong>JLF()</strong>, <strong>JLN()</strong>, <strong>JLL()</strong>, <strong>JLP()</strong> allow you to search for indexes in the array. You may search inclusively or exclusively, in either forward or reverse directions. If successful, <strong>Index</strong> is returned set to the found index, and <strong>PValue</strong> is returned set to a pointer to <strong>Index</strong>'s <strong>Value</strong>. If unsuccessful, <strong>PValue</strong> is returned set to <strong>NULL</strong>, and <strong>Index</strong> contains no useful information. <strong>PValue</strong> must be tested for non-<strong>NULL</strong> prior to using <strong>Index</strong>, since a search failure is possible.</p><ul>
<li><p><strong>JLFE()</strong>, <strong>JLNE()</strong>, <strong>JLLE()</strong>, <strong>JLPE()</strong> allow you to search for indexes that are not present ("empty") in the array. You may search inclusively or exclusively, in either forward or reverse directions. If successful, <strong>Index</strong> is returned set to a not present ("empty") index, and <strong>Rc_int</strong> is returned set to 1. If unsuccessful, <strong>Rc_int</strong> is returned set to 0, and and <strong>Index</strong> contains no useful information. <strong>Rc_int</strong> must be checked prior to using <strong>Index</strong>, since a search failure is possible.</p></li><li></li>
</ul>
  </dd>
  <dt>
    <p> <strong>JLF(PValue, PJLArray, Index)</strong> // <strong>JudyLFirst()</strong></p>
  </dt>
  <dd>
    <p>Search (inclusive) for the first index present that is equal to or greater than the passed <strong>Index</strong>. (Start with <strong>Index</strong> = 0 to find the first index in the array.) <strong>JLF()</strong> is typically used to <em>begin</em> a sorted-order scan of the indexes present in a JudyL array.</p><ul>
<li></li>
</ul>
  </dd>
  <dt>
    <p> <strong>JLN(PValue, PJLArray, Index)</strong> // <strong>JudyLNext()</strong></p>
  </dt>
  <dd>
    <p>Search (exclusive) for the next index present that is greater than the passed <strong>Index</strong>. <strong>JLN()</strong> is typically used to <em>continue</em> a sorted-order scan of the indexes present in a JudyL array, or to locate a "neighbor" of a given index.</p><ul>
<li></li>
</ul>
  </dd>
  <dt>
    <p> <strong>JLL(PValue, PJLArray, Index)</strong> // <strong>JudyLLast()</strong></p>
  </dt>
  <dd>
    <p>Search (inclusive) for the last index present that is equal to or less than the passed <strong>Index</strong>. (Start with <strong>Index</strong> = -1, that is, all ones, to find the last index in the array.) <strong>JLL()</strong> is typically used to <em>begin</em> a reverse-sorted-order scan of the indexes present in a JudyL array.</p><ul>
<li></li>
</ul>
  </dd>
  <dt>
    <p> <strong>JLP(PValue, PJLArray, Index)</strong> // <strong>JudyLPrev()</strong></p>
  </dt>
  <dd>
    <p>Search (exclusive) for the previous index present that is less than the passed <strong>Index</strong>. <strong>JLP()</strong> is typically used to <em>continue</em> a reverse-sorted-order scan of the indexes present in a JudyL array, or to locate a "neighbor" of a given index.</p><ul>
<li></li>
</ul>
  </dd>
  <dt>
    <p> <strong>JLFE(Rc_int, PJLArray, Index)</strong> // <strong>JudyLFirstEmpty()</strong></p>
  </dt>
  <dd>
    <p>Search (inclusive) for the first index absent that is equal to or greater than the passed <strong>Index</strong>. (Start with <strong>Index</strong> = 0 to find the first index absent in the array.)</p><ul>
<li></li>
</ul>
  </dd>
  <dt>
    <p> <strong>JLNE(Rc_int, PJLArray, Index)</strong> // <strong>JudyLNextEmpty()</strong></p>
  </dt>
  <dd>
    <p>Search (exclusive) for the next index absent that is greater than the passed <strong>Index</strong>.</p><ul>
<li></li>
</ul>
  </dd>
  <dt>
    <p> <strong>JLLE(Rc_int, PJLArray, Index)</strong> // <strong>JudyLLastEmpty()</strong></p>
  </dt>
  <dd>
    <p>Search (inclusive) for the last index absent that is equal to or less than the passed <strong>Index</strong>. (Start with <strong>Index</strong> = -1, that is, all ones, to find the last index absent in the array.)</p><ul>
<li></li>
</ul>
  </dd>
  <dt>
    <p> <strong>JLPE(Rc_int, PJLArray, Index)</strong> // <strong>JudyLPrevEmpty()</strong></p>
  </dt>
  <dd>
    <p>Search (exclusive) for the previous index absent that is less than the passed <strong>Index</strong>.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Multi-dimensional JudyL Arrays</h2>
        <div class="sectioncontent">
<p>Storing a pointer to another JudyL array in a JudyL array's <strong>Value</strong> is a simple way to support dynamic multi-dimensional arrays. These arrays (or trees) built using JudyL arrays are very fast and memory efficient. (In fact, that is how JudySL and JudyHS are implemented). An arbitrary number of dimensions can be realized this way. To terminate the number of dimensions (or tree), the <strong>Value</strong> pointer is marked to <strong>NOT</strong> point to another Judy array. A <strong>JLAP_INVALID</strong> flag is used in the least significant bit(s) of the pointer. After the flag <strong>JLAP_INVALID</strong> is removed, it is used as a pointer to the users data. The <strong>Judy.h</strong> header file defines <strong>JLAP_INVALID</strong>. See code fragment below.</p><p>Note: The current version of <strong>Judy.h</strong> changed this flag from 0x4 to 0x1 to allow for a <em>malloc()</em> that does not deliver memory on an 8 byte aligned boundry (such as old versions of valgrind).</p><p>The following example code segment can be used to determine whether or not a pointer points to another JudyL:</p>
<pre>
PValue = (PWord_t)PMultiDimArray;

for (Dim = 0; ;Dim++)
{
   if (PValue == (PWord_t)NULL) goto IndexNotFound;

   /* Advance to next dimension in array */
   JLG(PValue, (Pvoid_t)*PValue, Index[Dim]);

   /* Check if pointer to user buffer: */
   if (*PValue & JLAP_INVALID)) break;
}
UPointer = (UPointer_t) (*PValue & ~JLAP_INVALID);  // mask and cast.
printf("User object pointer is 0x%lx&#92;n", (Word_t) UPointer);
       &.&.&.
</pre>
<p>Note:  This works because <em>malloc()</em> guarantees to return a pointer with the least bit(s) == 0x0. You must remove <strong>JLAP_INVALID</strong> before using the pointer.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">\fBERRORS:\fP See: \fIJudy_3.htm#ERRORS\fP</h2>
        <div class="sectioncontent">

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLE</h2>
        <div class="sectioncontent">
<p>Read a series of index/value pairs from the standard input, store in a JudyL array, and then print out in sorted order.</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;Judy.h&gt;

Word_t   Index;                     // array index
Word_t   Value;                     // array element value
Word_t * PValue;                    // pointer to array element value
int      Rc_int;                    // return code

Pvoid_t  PJLArray = (Pvoid_t) NULL; // initialize JudyL array

while (scanf("%lu %lu", &Index, &Value))
{
    JLI(PValue, PJLArray, Index);
    If (PValue == PJERR) goto process_malloc_failure;
    *PValue = Value;                 // store new value
}
// Next, visit all the stored indexes in sorted order, first ascending,
// then descending, and delete each index during the descending pass.

Index = 0;
JLF(PValue, PJLArray, Index);
while (PValue != NULL)
{
    printf("%lu %lu&#92;n", Index, *PValue));
    JLN(PValue, PJLArray, Index);
}

Index = -1;
JLL(PValue, PJLArray, Index);
while (PValue != NULL)
{
    printf("%lu %lu&#92;n", Index, *PValue));

    JLD(Rc_int, PJLArray, Index);
    if (Rc_int == JERR) goto process_malloc_failure;

    JLP(PValue, PJLArray, Index);
}
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Judy was invented by Doug Baskins and implemented -Packard.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO JudyL&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man3/Judy.3.html"><strong>Judy</strong>(3)</a>, <a href="../man3/Judy1.3.html"><strong>Judy1</strong>(3)</a>, <a href="../man3/JudySL.3.html"><strong>JudySL</strong>(3)</a>, <a href="../man3/JudyHS.3.html"><strong>JudyHS</strong>(3)</a>,</p><p><em>malloc()</em>,</p><p><em>http://judy.sourceforge.net</em>, for more information and Application Notes.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="JudyHS_funcs.3.html"><span aria-hidden="true">&larr;</span> JudyHS_funcs.3: C library for creating and accessing a dynamic array, using an array-of-bytes of a length: length as an index and a word as a value.</a></li>
   <li class="next"><a href="JudyLByCount.3.html">JudyLByCount.3: C library for creating and accessing a dynamic array of words, using any value of a word as an index <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

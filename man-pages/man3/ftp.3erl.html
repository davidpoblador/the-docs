<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ftp: A file transfer protocol client</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="A file transfer protocol client">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="ftp (3erl) manual">
  <meta name="twitter:description" content="A file transfer protocol client">
  <meta name="twitter:image" content="https://www.carta.tech/images/erlang-manpages-ftp-3erl.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3erl/ftp.3erl.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="ftp (3erl) manual" />
  <meta property="og:description" content="A file transfer protocol client" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/erlang-manpages-ftp-3erl.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">ftp<small> (3erl)</small></h1>
        <p class="lead">A file transfer protocol client</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/ftp.3erl.html">
      <span itemprop="name">ftp: A file transfer protocol client</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/erlang-manpages/">
      <span itemprop="name">erlang-manpages</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/ftp.3erl.html">
      <span itemprop="name">ftp: A file transfer protocol client</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The <em>ftp</em> module implements a client for file transfer according to a subset of the File Transfer Protocol (see 959).</p><p>Starting from inets version 4.4.1 the ftp client will always try to use passive ftp mode and only resort to active ftp mode if this fails. There is a start option <strong>mode</strong> where this default behavior may be changed.</p><p>There are two ways to start an ftp client. One is using the <strong>Inets service framework</strong> and the other is to start it directy as a standalone process using the <strong>open</strong> function.</p><p>For a simple example of an ftp session see <strong>Inets User's Guide.</strong></p><p>In addition to the ordinary functions for receiving and sending files (see <em>recv/2</em>, <em>recv/3</em>, <em>send/2</em> and <em>send/3</em>) there are functions for receiving remote files as binaries (see <em>recv_bin/2</em>) and for sending binaries to to be stored as remote files (see <em>send_bin/3</em>).</p><p>There is also a set of functions for sending and receiving contiguous parts of a file to be stored in a remote file (for send see <em>send_chunk_start/2</em>, <em>send_chunk/2</em> and <em>send_chunk_end/1</em> and for receive see <em>recv_chunk_start/2</em> and <em>recv_chunk/</em>).</p><p>The particular return values of the functions below depend very much on the implementation of the FTP server at the remote host. In particular the results from <em>ls</em> and <em>nlist</em> varies. Often real errors are not reported as errors by <em>ls</em>, even if for instance a file or directory does not exist. <em>nlist</em> is usually more strict, but some implementations have the peculiar behaviour of responding with an error, if the request is a listing of the contents of directory which exists but is empty.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FTP CLIENT SERVICE START/STOP </h2>
        <div class="sectioncontent">
<p>The FTP client can be started and stopped dynamically in runtime by calling the Inets application API <em>inets:start(ftpc, ServiceConfig)</em>, or <em>inets:start(ftpc, ServiceConfig, How)</em>, and <em>inets:stop(ftpc, Pid)</em>. See <strong>inets(3erl)</strong> for more info.</p><p>Below follows a description of the available configuration options.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{host, Host}:</p><p>Host = <em>string() | ip_address()</em></p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{port, Port}:</p><p>Port = <em>integer() &gt; 0</em></p><p>Default is 21.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{mode, Mode}:</p><p>Mode = <em>active | passive</em></p><p>Default is <em>passive</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{verbose, Verbose}:</p><p>Verbose = <em>boolean()</em></p><p>This determines if the FTP communication should be verbose or not.</p><p>Default is <em>false</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{debug, Debug}:</p><p>Debug = <em>trace | debug | disable</em></p><p>Debugging using the dbg toolkit.</p><p>Default is <em>disable</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{ipfamily, IpFamily}:</p><p>IpFamily = <em>inet | inet6 | inet6fb4</em></p><p>With <em>inet6fb4</em> the client behaves as before (it tries to use IPv6 and only if that does not work, it uses IPv4).</p><p>Default is <em>inet</em> (IPv4).</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{timeout, Timeout}:</p><p>Timeout = <em>non_neg_integer()</em></p><p>Connection timeout.</p><p>Default is 60000 (milliseconds).</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{dtimeout, DTimeout}:</p><p>DTimeout = <em>non_neg_integer() | infinity</em></p><p>Data Connect timeout. The time the client will wait for the server to connect to the data socket.</p><p>Default is infinity.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{progress, Progress}:</p><p>Progress = <em>ignore | {CBModule, CBFunction, InitProgress}</em></p><p>CBModule = <em>atom()</em>, CBFunction = <em>atom()</em></p><p>InitProgress = <em>term()</em></p><p>Default is <em>ignore</em>.</p>
  </dd>

</dl>
<p>The progress option is intended to be used by applications that want to create some type of progress report such as a progress bar in a GUI. The default value for the progress option is ignore e.i. the option is not used. When the progress option is specified the following will happen when ftp:send/[3,4] or ftp:recv/[3,4] are called.</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>Before a file is transfered the following call will be made to indicate the start of the file transfer and how big the file is. The return value of the callback function should be a new value for the UserProgressTerm that will bu used as input next time the callback function is called.</p><p><em> CBModule:CBFunction(InitProgress, File, {file_size, FileSize}) </em></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>Every time a chunk of bytes is transfered the following call will be made:</p><p><em> CBModule:CBFunction(UserProgressTerm, File, {transfer_size, TransferSize}) </em></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>At the end of the file the following call will be made to indicate the end of the transfer.</p><p><em> CBModule:CBFunction(UserProgressTerm, File, {transfer_size, 0}) </em></p>
  </dd>

</dl>
<p>The callback function should be defined as</p><p><em> CBModule:CBFunction(UserProgressTerm, File, Size) -&gt; UserProgressTerm </em></p><p><em> CBModule = CBFunction = atom() </em></p><p><em> UserProgressTerm = term() </em></p><p><em> File = string() </em></p><p><em> Size = {transfer_size, integer()} | {file_size, integer()} | {file_size, unknown} </em></p><p>Alas for remote files it is not possible for ftp to determine the file size in a platform independent way. In this case the size will be <em>unknown</em> and it is left to the application to find out the size.</p><p><strong></strong> Note:</p><p>The callback is made by a middleman process, hence the file transfer will not be affected by the code in the progress callback function. If the callback should crash this will be detected by the ftp connection process that will print an info-report and then go one as if the progress option was set to ignore.</p><p>The file transfer type is set to the default of the FTP server when the session is opened. This is usually ASCCI-mode.</p><p>The current local working directory (cf. <em>lpwd/1</em>) is set to the value reported by <em>file:get_cwd/1</em>. the wanted local directory.</p><p>The return value <em>Pid</em> is used as a reference to the newly created ftp client in all other functions, and they should be called by the process that created the connection. The ftp client process monitors the process that created it and will terminate if that process terminates.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COMMON DATA TYPES </h2>
        <div class="sectioncontent">
<p>Here follows type definitions that are used by more than one function in the FTP client API.</p><p><em> pid() - identifier of an ftp connection.</em></p><p><em> string() = list of ASCII characters.</em></p><p><em> shortage_reason() = etnospc | epnospc</em></p><p><em> restriction_reason() = epath | efnamena | elogin | enotbinary - note not all restrictions may always relevant to all functions </em></p><p><em>common_reason() = econn | eclosed | term() - some kind of explanation of what went wrong.</em></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">
<p><strong></strong> account(Pid, Account) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Pid = pid()</p><p>Account = string()</p><p>Reason = eacct | common_reason()</p><p>If an account is needed for an operation set the account with this operation.</p><p><strong></strong> append(Pid, LocalFile) -&gt;</p><p><strong></strong> append(Pid, LocalFile, RemoteFile) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Pid = pid()</p><p>LocalFile = RemoteFile = string()</p><p>Reason = epath | elogin | etnospc | epnospc | efnamena | common_reason</p><p>Transfers the file <em>LocalFile</em> to the remote server. If <em>RemoteFile</em> is specified, the name of the remote file that the file will be appended to is set to <em>RemoteFile</em>; otherwise the name is set to <em>LocalFile</em> If the file does not exists the file will be created.</p><p><strong></strong> append_bin(Pid, Bin, RemoteFile) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Pid = pid()</p><p>Bin = binary()()</p><p>RemoteFile = string()</p><p>Reason = restriction_reason()| shortage_reason() | common_reason()</p><p>Transfers the binary <em>Bin</em> to the remote server and append it to the file <em>RemoteFile</em>. If the file does not exists it will be created.</p><p><strong></strong> append_chunk(Pid, Bin) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Pid = pid()</p><p>Bin = binary()</p><p>Reason = echunk | restriction_reason() | common_reason()</p><p>Transfer the chunk <em>Bin</em> to the remote server, which append it into the file specified in the call to <em>append_chunk_start/2</em>.</p><p>Note that for some errors, e.g. file system full, it is necessary to to call <em>append_chunk_end</em> to get the proper reason.</p><p><strong></strong> append_chunk_start(Pid, File) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Pid = pid()</p><p>File = string()</p><p>Reason = restriction_reason() | common_reason()</p><p>Start the transfer of chunks for appending to the file <em>File</em> at the remote server. If the file does not exists it will be created.</p><p><strong></strong> append_chunk_end(Pid) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Pid = pid()</p><p>Reason = echunk | restriction_reason() | shortage_reason()</p><p>Stops transfer of chunks for appending to the remote server. The file at the remote server, specified in the call to <em>append_chunk_start/2</em> is closed by the server.</p><p><strong></strong> cd(Pid, Dir) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Pid = pid()</p><p>Dir = string()</p><p>Reason = restriction_reason() | common_reason()</p><p>Changes the working directory at the remote server to <em>Dir</em>.</p><p><strong></strong> close(Pid) -&gt; ok</p><p>Types:</p><p>Pid = pid()</p><p>Ends an ftp session, created using the <strong>open</strong> function.</p><p><strong></strong> delete(Pid, File) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Pid = pid()</p><p>File = string()</p><p>Reason = restriction_reason() | common_reason()</p><p>Deletes the file <em>File</em> at the remote server.</p><p><strong></strong> formaterror(Tag) -&gt; string()</p><p>Types:</p><p>Tag = {error, atom()} | atom()</p><p>Given an error return value <em>{error, AtomReason}</em>, this function returns a readable string describing the error.</p><p><strong></strong> lcd(Pid, Dir) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Pid = pid()</p><p>Dir = string()</p><p>Reason = restriction_reason()</p><p>Changes the working directory to <em>Dir</em> for the local client.</p><p><strong></strong> lpwd(Pid) -&gt; {ok, Dir}</p><p>Types:</p><p>Pid = pid()</p><p>Returns the current working directory at the local client.</p><p><strong></strong> ls(Pid) -&gt;</p><p><strong></strong> ls(Pid, Pathname) -&gt; {ok, Listing} | {error, Reason}</p><p>Types:</p><p>Pid = pid()</p><p>Pathname = string()</p><p>Listing = string()</p><p>Reason = restriction_reason() | common_reason()</p><p>Returns a list of files in long format.</p><p><em>Pathname</em> can be a directory, a group of files or even a file. The <em>Pathname</em> string can contain wildcard(s).</p><p><em>ls/1</em> implies the user's current remote directory.</p><p>The format of <em>Listing</em> is operating system dependent (on UNIX it is typically produced from the output of the <em>ls -l</em> shell command).</p><p><strong></strong> mkdir(Pid, Dir) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Pid = pid()</p><p>Dir = string()</p><p>Reason = restriction_reason() | common_reason()</p><p>Creates the directory <em>Dir</em> at the remote server.</p><p><strong></strong> nlist(Pid) -&gt;</p><p><strong></strong> nlist(Pid, Pathname) -&gt; {ok, Listing} | {error, Reason}</p><p>Types:</p><p>Pid = pid()</p><p>Pathname = string()</p><p>Listing = string()</p><p>Reason = restriction_reason() | common_reason()</p><p>Returns a list of files in short format.</p><p><em>Pathname</em> can be a directory, a group of files or even a file. The <em>Pathname</em> string can contain wildcard(s).</p><p><em>nlist/1</em> implies the user's current remote directory.</p><p>The format of <em>Listing</em> is a stream of file names, where each name is separated by &lt;CRLF&gt; or &lt;NL&gt;. Contrary to the <em>ls</em> function, the purpose of <em>nlist</em> is to make it possible for a program to automatically process file name information.</p><p><strong></strong> open(Host) -&gt; {ok, Pid} | {error, Reason}</p><p><strong></strong> open(Host, Opts) -&gt; {ok, Pid} | {error, Reason}</p><p>Types:</p><p>Host = string() | ip_address()</p><p>Opts = options()</p><p>options() = [option()]</p><p>option() = start_option() | open_option()</p><p>start_option() = {verbose, verbose()} | {debug, debug()}</p><p>verbose() = boolean() (defaults to false)</p><p>debug() = disable | debug | trace (defaults to disable)</p><p>open_option() = {ipfamily, ipfamily()} | {port, port()} | {mode, mode()} | {tls, tls_options()} | {timeout, timeout()} | {dtimeout, dtimeout()} | {progress, progress()}</p><p>ipfamily() = inet | inet6 | inet6fb4 (defaults to inet)</p><p>port() = integer() &gt; 0 (defaults to 21)</p><p>mode() = active | passive (defaults to passive)</p><p>tls_options() = [<strong>ssl:ssloption()</strong>]</p><p>timeout() = integer() &gt; 0 (defaults to 60000 milliseconds)</p><p>dtimeout() = integer() &gt; 0 | infinity (defaults to infinity)</p><p>pogress() = ignore | {module(), function(), initial_data()} (defaults to ignore)</p><p>module() = atom()</p><p>function() = atom()</p><p>initial_data() = term()</p><p>Reason = ehost | term()</p><p>This function is used to start a standalone ftp client process (without the inets service framework) and open a session with the FTP server at <em>Host</em>.</p><p>If the option <em>{tls, tls_options()}</em> is present, the ftp session will be transported over tls (ftps, see RFC 4217). The list <em>tls_options()</em> may be empty. The function <strong></strong><em>ssl:connect/3</em> is used for securing both the control connection and the data sessions.</p><p>A session opened in this way, is closed using the <strong>close</strong> function.</p><p><strong></strong> pwd(Pid) -&gt; {ok, Dir} | {error, Reason}</p><p>Types:</p><p>Pid = pid()</p><p>Reason = restriction_reason() | common_reason()</p><p>Returns the current working directory at the remote server.</p><p><strong></strong> pwd(Pid) -&gt; {ok, Dir} | {error, Reason}</p><p>Types:</p><p>Pid = pid()</p><p>Reason = restriction_reason() | common_reason()</p><p>Returns the current working directory at the remote server.</p><p><strong></strong> recv(Pid, RemoteFile) -&gt;</p><p><strong></strong> recv(Pid, RemoteFile, LocalFile) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Pid = pid()</p><p>RemoteFile = LocalFile = string()</p><p>Reason = restriction_reason() | common_reason() | file_write_error_reason()</p><p>file_write_error_reason() = see file:write/2</p><p>Transfer the file <em>RemoteFile</em> from the remote server to the the file system of the local client. If <em>LocalFile</em> is specified, the local file will be <em>LocalFile</em>; otherwise it will be <em>RemoteFile</em>.</p><p>If the file write fails (e.g. enospc), then the command is aborted and <em>{error, file_write_error_reason()}</em> is returned. The file is however <em>not</em> removed.</p><p><strong></strong> recv_bin(Pid, RemoteFile) -&gt; {ok, Bin} | {error, Reason}</p><p>Types:</p><p>Pid = pid()</p><p>Bin = binary()</p><p>RemoteFile = string()</p><p>Reason = restriction_reason() | common_reason()</p><p>Transfers the file <em>RemoteFile</em> from the remote server and receives it as a binary.</p><p><strong></strong> recv_chunk_start(Pid, RemoteFile) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Pid = pid()</p><p>RemoteFile = string()</p><p>Reason = restriction_reason() | common_reason()</p><p>Start transfer of the file <em>RemoteFile</em> from the remote server.</p><p><strong></strong> recv_chunk(Pid) -&gt; ok | {ok, Bin} | {error, Reason}</p><p>Types:</p><p>Pid = pid()</p><p>Bin = binary()</p><p>Reason = restriction_reason() | common_reason()</p><p>Receive a chunk of the remote file (<em>RemoteFile</em> of <em>recv_chunk_start</em>). The return values has the following meaning:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>ok</em> the transfer is complete.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{ok, Bin}</em> just another chunk of the file.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{error, Reason}</em> transfer failed.</p>
  </dd>

</dl>
<p><strong></strong> rename(Pid, Old, New) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Pid = pid()</p><p>CurrFile = NewFile = string()</p><p>Reason = restriction_reason() | common_reason()</p><p>Renames <em>Old</em> to <em>New</em> at the remote server.</p><p><strong></strong> rmdir(Pid, Dir) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Pid = pid()</p><p>Dir = string()</p><p>Reason = restriction_reason() | common_reason()</p><p>Removes directory <em>Dir</em> at the remote server.</p><p><strong></strong> send(Pid, LocalFile) -&gt;</p><p><strong></strong> send(Pid, LocalFile, RemoteFile) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Pid = pid()</p><p>LocalFile = RemoteFile = string()</p><p>Reason = restriction_reason() | common_reason() | shortage_reason()</p><p>Transfers the file <em>LocalFile</em> to the remote server. If <em>RemoteFile</em> is specified, the name of the remote file is set to <em>RemoteFile</em>; otherwise the name is set to <em>LocalFile</em>.</p><p><strong></strong> send_bin(Pid, Bin, RemoteFile) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Pid = pid()</p><p>Bin = binary()()</p><p>RemoteFile = string()</p><p>Reason = restriction_reason() | common_reason() | shortage_reason()</p><p>Transfers the binary <em>Bin</em> into the file <em>RemoteFile</em> at the remote server.</p><p><strong></strong> send_chunk(Pid, Bin) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Pid = pid()</p><p>Bin = binary()</p><p>Reason = echunk | restriction_reason() | common_reason()</p><p>Transfer the chunk <em>Bin</em> to the remote server, which writes it into the file specified in the call to <em>send_chunk_start/2</em>.</p><p>Note that for some errors, e.g. file system full, it is necessary to to call <em>send_chunk_end</em> to get the proper reason.</p><p><strong></strong> send_chunk_start(Pid, File) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Pid = pid()</p><p>File = string()</p><p>Reason = restriction_reason() | common_reason()</p><p>Start transfer of chunks into the file <em>File</em> at the remote server.</p><p><strong></strong> send_chunk_end(Pid) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Pid = pid()</p><p>Reason = restriction_reason() | common_reason() | shortage_reason()</p><p>Stops transfer of chunks to the remote server. The file at the remote server, specified in the call to <em>send_chunk_start/2</em> is closed by the server.</p><p><strong></strong> type(Pid, Type) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Pid = pid()</p><p>Type = ascii | binary</p><p>Reason = etype | restriction_reason() | common_reason()</p><p>Sets the file transfer type to <em>ascii</em> or <em>binary</em>. When an ftp session is opened, the default transfer type of the server is used, most often <em>ascii</em>, which is the default according to RFC 959.</p><p><strong></strong> user(Pid, User, Password) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Pid = pid()</p><p>User = Password = string()</p><p>Reason = euser | common_reason()</p><p>Performs login of <em>User</em> with <em>Password</em>.</p><p><strong></strong> user(Pid, User, Password, Account) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Pid = pid()</p><p>User = Password = string()</p><p>Reason = euser | common_reason()</p><p>Performs login of <em>User</em> with <em>Password</em> to the account specified by <em>Account</em>.</p><p><strong></strong> quote(Pid, Command) -&gt; [FTPLine]</p><p>Types:</p><p>Pid = pid()</p><p>Command = string()</p><p>FTPLine = string() - Note the telnet end of line characters, from the ftp protocol definition, CRLF e.g. "&#92;&#92;r&#92;&#92;n" has been removed.</p><p>Sends an arbitrary FTP command and returns verbatimly a list of the lines sent back by the FTP server. This functions is intended to give an application accesses to FTP commands that are server specific or that may not be provided by this FTP client.</p><p><strong></strong> Note:</p><p>FTP commands that require a data connection can not be successfully issued with this function.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ERRORS</h2>
        <div class="sectioncontent">
<p>The possible error reasons and the corresponding diagnostic strings returned by <em>formaterror/1</em> are as follows:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>echunk</em>: Synchronisation error during chunk sending.</p><p>A call has been made to <em>send_chunk/2</em> or <em>send_chunk_end/1</em>, before a call to <em>send_chunk_start/2</em>; or a call has been made to another transfer function during chunk sending, i.e. before a call to <em>send_chunk_end/1</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>eclosed</em>: The session has been closed.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>econn</em>: Connection to remote server prematurely closed.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>ehost</em>: Host not found, FTP server not found, or connection rejected by FTP server.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>elogin</em>: User not logged in.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>enotbinary</em>: Term is not a binary.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>epath</em>: No such file or directory, or directory already exists, or permission denied.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>etype</em>: No such type.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>euser</em>: User name or password not valid.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>etnospc</em>: Insufficient storage space in system [452].</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>epnospc</em>: Exceeded storage allocation (for current directory or dataset) [552].</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>efnamena</em>: File name not allowed [553].</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO ftp&hellip;</h2>
        <div class="sectioncontent">
<p>file, filename, J. Postel and J. Reynolds: File Transfer Protocol (RFC 959).</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="fprof.3erl.html"><span aria-hidden="true">&larr;</span> fprof.3erl: A time profiling tool using trace to file for minimal runtime performance impact.</a></li>
   <li class="next"><a href="gb_sets.3erl.html">gb_sets.3erl: General balanced trees <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>IPC::Shareable: Share perl variables between processes</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Share perl variables between processes">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="IPC::Shareable (3pm) manual">
  <meta name="twitter:description" content="Share perl variables between processes">
  <meta name="twitter:image" content="https://www.carta.tech/images/libipc-shareable-perl-IPC::Shareable-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/IPC::Shareable.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="IPC::Shareable (3pm) manual" />
  <meta property="og:description" content="Share perl variables between processes" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libipc-shareable-perl-IPC::Shareable-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">IPC::Shareable<small> (3pm)</small></h1>
        <p class="lead">Share perl variables between processes</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/IPC::Shareable.3pm.html">
      <span itemprop="name">IPC::Shareable: Share perl variables between processes</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libipc-shareable-perl/">
      <span itemprop="name">libipc-shareable-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/IPC::Shareable.3pm.html">
      <span itemprop="name">IPC::Shareable: Share perl variables between processes</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
 use IPC::Shareable (&apos;:lock&apos;);
 tie SCALAR, &apos;IPC::Shareable&apos;, GLUE, OPTIONS;
 tie ARRAY,  &apos;IPC::Shareable&apos;, GLUE, OPTIONS;
 tie HASH,   &apos;IPC::Shareable&apos;, GLUE, OPTIONS;

 (tied VARIABLE)-&gt;shlock;
 (tied VARIABLE)-&gt;shunlock;

 (tied VARIABLE)-&gt;shlock(LOCK_SH|LOCK_NB)
        or print "resource unavailable&#92;n";

 (tied VARIABLE)-&gt;remove;

 IPC::Shareable-&gt;clean_up;
 IPC::Shareable-&gt;clean_up_all;
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONVENTIONS</h2>
        <div class="sectioncontent">
<p>The occurrence of a number in square brackets, as in [N], in the text of this document refers to a numbered note in the \*(L"\s-1NOTES\s0\*(R".</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>IPC::Shareable allows you to tie a variable to shared memory making it easy to share the contents of that variable with other Perl processes. Scalars, arrays, and hashes can be tied.  The variable being tied may contain arbitrarily complex data structures - including references to arrays, hashes of hashes, etc.</p><p>The association between variables in distinct processes is provided by \s-1GLUE\s0.  This is an integer number or 4 character string[1] that serves as a common identifier for data across process space.  Hence the statement</p><p> tie $scalar, &apos;IPC::Shareable&apos;, &apos;data&apos;;</p><p>in program one and the statement</p><p> tie $variable, &apos;IPC::Shareable&apos;, &apos;data&apos;;</p><p>in program two will bind $scalar in program one and $variable in program two.</p><p>There is no pre-set limit to the number of processes that can bind to data; nor is there a pre-set limit to the complexity of the underlying data of the tied variables[2].  The amount of data that can be shared within a single bound variable is limited by the system's maximum size for a shared memory segment (the exact value is system-dependent).</p><p>The bound data structures are all linearized (using Raphael Manfredi's Storable module) before being slurped into shared memory.  Upon retrieval, the original format of the data structure is recovered. Semaphore flags can be used for locking data between competing processes.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OPTIONS</h2>
        <div class="sectioncontent">
<p>Options are specified by passing a reference to a hash as the fourth argument to the <em>tie()</em> function that enchants a variable. Alternatively you can pass a reference to a hash as the third argument; IPC::Shareable will then look at the field named <strong>key</strong> in this hash for the value of \s-1GLUE\s0.  So,</p><p> tie $variable, &apos;IPC::Shareable&apos;, &apos;data&apos;, &#92;%options;</p><p>is equivalent to</p><p> tie $variable, &apos;IPC::Shareable&apos;, { key =&gt; &apos;data&apos;, ... };</p><p>Boolean option values can be specified using a value that evaluates to either true or false in the Perl sense.</p><p>\s-1NOTE:\s0 Earlier versions allowed you to use the word <strong>yes</strong> for true and the word <strong>no</strong> for false, but support for this \*(L"feature\*(R" is being removed.  <strong>yes</strong> will still act as true (since it is true, in the Perl sense), but use of the word <strong>no</strong> now emits an (optional) warning and then converts to a false value.  This warning will become mandatory in a future release and then at some later date the use of <strong>no</strong> will stop working altogether.</p><p>The following fields are recognized in the options hash.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>key</strong>
  </dt>
  <dd>
    <p>The <strong>key</strong> field is used to determine the \s-1GLUE\s0 when using the three-argument form of the call to <em>tie()</em>.  This argument is then, in turn, used as the \s-1KEY\s0 argument in subsequent calls to <em>shmget()</em> and <em>semget()</em>. The default value is \s-1IPC_PRIVATE\s0, meaning that your variables cannot be shared with other processes.</p>
  </dd>
  <dt>
    <strong>create</strong>
  </dt>
  <dd>
    <p><strong>create</strong> is used to control whether calls to <em>tie()</em> create new shared memory segments or not.  If <strong>create</strong> is set to a true value, IPC::Shareable will create a new binding associated with \s-1GLUE\s0 as needed.  If <strong>create</strong> is false, IPC::Shareable will not attempt to create a new shared memory segment associated with \s-1GLUE\s0.  In this case, a shared memory segment associated with \s-1GLUE\s0 must already exist or the call to <em>tie()</em> will fail and return undef.  The default is false.</p>
  </dd>
  <dt>
    <strong>exclusive</strong>
  </dt>
  <dd>
    <p>If <strong>exclusive</strong> field is set to a true value, calls to <em>tie()</em> will fail (returning undef) if a data binding associated with \s-1GLUE\s0 already exists.  If set to a false value, calls to <em>tie()</em> will succeed even if a shared memory segment associated with \s-1GLUE\s0 already exists.  The default is false</p>
  </dd>
  <dt>
    <strong>mode</strong>
  </dt>
  <dd>
    <p>The <em>mode</em> argument is an octal number specifying the access permissions when a new data binding is being created.  These access permission are the same as file access permissions in that 0666 is world readable, 0600 is readable only by the effective \s-1UID\s0 of the process creating the shared variable, etc.  The default is 0666 (world readable and writable).</p>
  </dd>
  <dt>
    <strong>destroy</strong>
  </dt>
  <dd>
    <p>If set to a true value, the shared memory segment underlying the data binding will be removed when the process calling <em>tie()</em> exits (gracefully)[3].  Use this option with care.  In particular you should not use this option in a program that will fork after binding the data.  On the other hand, shared memory is a finite resource and should be released if it is not needed. The default is false</p>
  </dd>
  <dt>
    <strong>size</strong>
  </dt>
  <dd>
    <p>This field may be used to specify the size of the shared memory segment allocated.  The default is <em>IPC::Shareable::SHM_BUFSIZ()</em>.</p>
  </dd>

</dl>
<p>Default values for options are</p><p> key       =&gt; IPC_PRIVATE,  create    =&gt; 0,  exclusive =&gt; 0,  destroy   =&gt; 0,  mode      =&gt; 0,  size      =&gt; IPC::Shareable::SHM_BUFSIZ(),</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LOCKING</h2>
        <div class="sectioncontent">
<p>IPC::Shareable provides methods to implement application-level advisory locking of the shared data structures.  These methods are called <em>shlock()</em> and <em>shunlock()</em>.  To use them you must first get the object underlying the tied variable, either by saving the return value of the original call to <em>tie()</em> or by using the built-in <em>tied()</em> function.</p><p>To lock a variable, do this:</p><p> $knot = tie $sv, &apos;IPC::Shareable&apos;, $glue, { %options };  ...  $knot-&gt;shlock;</p><p>or equivalently</p><p> tie($scalar, &apos;IPC::Shareable&apos;, $glue, { %options });  (tied $scalar)-&gt;shlock;</p><p>This will place an exclusive lock on the data of $scalar.  You can also get shared locks or attempt to get a lock without blocking. IPC::Shareable makes the constants \s-1LOCK_EX\s0, \s-1LOCK_SH\s0, \s-1LOCK_UN\s0, and \s-1LOCK_NB\s0 exportable to your address space with the export tags \*(C`:lock\*(C', \*(C`:flock\*(C', or \*(C`:all\*(C'.  The values should be the same as the standard \*(C`flock\*(C' option arguments.</p><p> if ( (tied $scalar)-&gt;shlock(LOCK_SH|LOCK_NB) ) {         print "The value is $scalar&#92;n";         (tied $scalar)-&gt;shunlock;  } else {         print "Another process has an exlusive lock.&#92;n";  }</p><p>If no argument is provided to \*(C`shlock\*(C', it defaults to \s-1LOCK_EX\s0.  To unlock a variable do this:</p><p> $knot-&gt;shunlock;</p><p>or</p><p> (tied $scalar)-&gt;shunlock;</p><p>or</p><p> $knot-&gt;shlock(LOCK_UN);        # Same as calling shunlock</p><p>There are some pitfalls regarding locking and signals about which you should make yourself aware; these are discussed in \*(L"\s-1NOTES\s0\*(R".</p><p>If you use the advisory locking, IPC::Shareable assumes that you know what you are doing and attempts some optimizations.  When you obtain a lock, either exclusive or shared, a fetch and thaw of the data is performed.  No additional fetch/thaw operations are performed until you release the lock and access the bound variable again.  During the time that the lock is kept, all accesses are perfomed on the copy in program memory.  If other processes do not honor the lock, and update the shared memory region unfairly, the process with the lock will not be in sync.  In other words, IPC::Shareable does not enforce the lock for you.</p><p>A similar optimization is done if you obtain an exclusive lock. Updates to the shared memory region will be postponed until you release the lock (or downgrade to a shared lock).</p><p>Use of locking can significantly improve performance for operations such as iterating over an array, retrieving a list from a slice or doing a slice assignment.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REFERENCES</h2>
        <div class="sectioncontent">
<p>When a reference to a non-tied scalar, hash, or array is assigned to a <em>tie()</em>d variable, IPC::Shareable will attempt to <em>tie()</em> the thingy being referenced[4].  This allows disparate processes to see changes to not only the top-level variable, but also changes to nested data.  This feature is intended to be transparent to the application, but there are some caveats to be aware of.</p><p>First of all, IPC::Shareable does not (yet) guarantee that the ids shared memory segments allocated automagically are unique.  The more automagical <em>tie()</em>ing that happens, the greater the chance of a collision.</p><p>Secondly, since a new shared memory segment is created for each thingy being referenced, the liberal use of references could cause the system to approach its limit for the total number of shared memory segments allowed.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OBJECTS</h2>
        <div class="sectioncontent">
<p>IPC::Shareable implements <em>tie()</em>ing objects to shared memory too. Since an object is just a reference, the same principles (and caveats) apply to <em>tie()</em>ing objects as other reference types.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESTRUCTION</h2>
        <div class="sectioncontent">
<p><em>perl</em>\|(1) will destroy the object underlying a tied variable when then tied variable goes out of scope.  Unfortunately for IPC::Shareable, this may not be desirable: other processes may still need a handle on the relevant shared memory segment.  IPC::Shareable therefore provides an interface to allow the application to control the timing of removal of shared memory segments.  The interface consists of three methods - <em>remove()</em>, <em>clean_up()</em>, and <em>clean_up_all()</em> - and the <strong>destroy</strong> option to <em>tie()</em>.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>destroy option</strong>
  </dt>
  <dd>
    <p>As described in \*(L"\s-1OPTIONS\s0\*(R", specifying the <strong>destroy</strong> option when <em>tie()</em>ing a variable coerces IPC::Shareable to remove the underlying shared memory segment when the process calling <em>tie()</em> exits gracefully. Note that any related shared memory segments created automagically by the use of references will also be removed.</p>
  </dd>
  <dt>
    <strong></strong><strong>remove()</strong><strong></strong>
  </dt>
  <dd>
    <p> (tied $var)-&gt;remove; Calling <em>remove()</em> on the object underlying a <em>tie()</em>d variable removes the associated shared memory segment.  The segment is removed irrespective of whether it has the <strong>destroy</strong> option set or not and irrespective of whether the calling process created the segment.</p>
  </dd>
  <dt>
    <strong></strong><strong>clean_up()</strong><strong></strong>
  </dt>
  <dd>
    <p> IPC::Shareable-&gt;clean_up; This is a class method that provokes IPC::Shareable to remove all shared memory segments created by the process.  Segments not created by the calling process are not removed.</p>
  </dd>
  <dt>
    <strong></strong><strong>clean_up_all()</strong><strong></strong>
  </dt>
  <dd>
    <p> IPC::Shareable-&gt;clean_up_all; This is a class method that provokes IPC::Shareable to remove all shared memory segments encountered by the process.  Segments are removed even if they were not created by the calling process.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>In a file called <strong>server</strong>:</p><p> #!/usr/bin/perl -w  use strict;  use IPC::Shareable;  my $glue = &apos;data&apos;;  my %options = (      create    =&gt; &apos;yes&apos;,      exclusive =&gt; 0,      mode      =&gt; 0644,      destroy   =&gt; &apos;yes&apos;,  );  my %colours;  tie %colours, &apos;IPC::Shareable&apos;, $glue, { %options } or      die "server: tie failed&#92;n";  %colours = (      red =&gt; [          &apos;fire truck&apos;,          &apos;leaves in the fall&apos;,      ],      blue =&gt; [          &apos;sky&apos;,          &apos;police cars&apos;,      ],  );  ((print "server: there are 2 colours&#92;n"), sleep 5)      while scalar keys %colours == 2;  print "server: here are all my colours:&#92;n";  foreach my $c (keys %colours) {      print "server: these are $c: ",          join(&apos;, &apos;, @{$colours{$c}}), "&#92;n";  }  exit;</p><p>In a file called <strong>client</strong></p><p> #!/usr/bin/perl -w  use strict;  use IPC::Shareable;  my $glue = &apos;data&apos;;  my %options = (      create    =&gt; 0,      exclusive =&gt; 0,      mode      =&gt; 0644,      destroy   =&gt; 0,      );  my %colours;  tie %colours, &apos;IPC::Shareable&apos;, $glue, { %options } or      die "client: tie failed&#92;n";  foreach my $c (keys %colours) {      print "client: these are $c: ",          join(&apos;, &apos;, @{$colours{$c}}), "&#92;n";  }  delete $colours{&apos;red&apos;};  exit;</p><p>And here is the output (the sleep commands in the command line prevent the output from being interrupted by shell prompts):</p><p> bash$ ( ./server & ) ; sleep 10 ; ./client ; sleep 10  server: there are 2 colours  server: there are 2 colours  server: there are 2 colours  client: these are blue: sky, police cars  client: these are red: fire truck, leaves in the fall  server: here are all my colours:  server: these are blue: sky, police cars</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUES</h2>
        <div class="sectioncontent">
<p>Calls to <em>tie()</em> that try to implement IPC::Shareable will return true if successful, <em>undef</em> otherwise.  The value returned is an instance of the IPC::Shareable class.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Benjamin Sugars &lt;bsugars@canoe.ca&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTES</h2>
        <div class="sectioncontent">
<h3>Footnotes from the above sections</h3>

<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>If \s-1GLUE\s0 is longer than 4 characters, only the 4 most significant characters are used.  These characters are turned into integers by <em>unpack()</em>ing them.  If \s-1GLUE\s0 is less than 4 characters, it is space padded.</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>IPC::Shareable provides no pre-set limits, but the system does. Namely, there are limits on the number of shared memory segments that can be allocated and the total amount of memory usable by shared memory.</p>
  </dd>
  <dt>
    3.
  </dt>
  <dd>
    <p>If the process has been smoked by an untrapped signal, the binding will remain in shared memory.  If you're cautious, you might try  $SIG{INT} = &#92;&catch_int;  sub catch_int {      die;  }  ...  tie $variable, IPC::Shareable, &apos;data&apos;, { &apos;destroy&apos; =&gt; &apos;Yes!&apos; }; which will at least clean up after your user hits CTRL-C because IPC::Shareable's \s-1END\s0 method will be called.  Or, maybe you'd like to leave the binding in shared memory, so subsequent process can recover the data...</p>
  </dd>
  <dt>
    4.
  </dt>
  <dd>
    <p>This behaviour is markedly different from previous versions of IPC::Shareable.  Older versions would sometimes <em>tie()</em> referenced thingies, and sometimes not.  The new approach is more reliable (I think) and predictable (certainly) but uses more shared memory segments.</p>
  </dd>

</dl>

<h3>General Notes</h3>
<ul>
<li><p>When using <em>shlock()</em> to lock a variable, be careful to guard against signals.  Under normal circumstances, IPC::Shareable's \s-1END\s0 method unlocks any locked variables when the process exits.  However, if an untrapped signal is received while a process holds an exclusive lock, \s-1DESTROY\s0 will not be called and the lock may be maintained even though the process has exited.  If this scares you, you might be better off implementing your own locking methods. One advantage of using \*(C`flock\*(C' on some known file instead of the locking implemented with semaphores in IPC::Shareable is that when a process dies, it automatically releases any locks.  This only happens with IPC::Shareable if the process dies gracefully.  The alternative is to attempt to account for every possible calamitous ending for your process (robust signal handling in Perl is a source of much debate, though it usually works just fine) or to become familiar with your system's tools for removing shared memory and semaphores.  This concern should be balanced against the significant performance improvements you can gain for larger data structures by using the locking mechanism implemented in IPC::Shareable.</p></li><li><p>There is a program called ipcs(1/8) (and ipcrm(1/8)) that is available on at least Solaris and Linux that might be useful for cleaning moribund shared memory segments or semaphore sets produced by bugs in either IPC::Shareable or applications using it.</p></li><li><p>This version of IPC::Shareable does not understand the format of shared memory segments created by versions prior to 0.60.  If you try to tie to such segments, you will get an error.  The only work around is to clear the shared memory segments and start with a fresh set.</p></li><li><p>Iterating over a hash causes a special optimization if you have not obtained a lock (it is better to obtain a read (or write) lock before iterating over a hash tied to Shareable, but we attempt this optimization if you do not).  The fetch/thaw operation is performed when the first key is accessed.  Subsequent key and and value accesses are done without accessing shared memory.  Doing an assignment to the hash or fetching another value between key accesses causes the hash to be replaced from shared memory.  The state of the iterator in this case is not defined by the Perl documentation.  Caveat Emptor.</p></li>
</ul>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CREDITS</h2>
        <div class="sectioncontent">
<p>Thanks to all those with comments or bug fixes, especially</p><p> Maurice Aubrey      &lt;maurice@hevanet.com&gt;  Stephane Bortzmeyer &lt;bortzmeyer@pasteur.fr&gt;  Doug MacEachern     &lt;dougm@telebusiness.co.nz&gt;  Robert Emmery       &lt;roberte@netscape.com&gt;  Mohammed J. Kabir   &lt;kabir@intevo.com&gt;  Terry Ewing         &lt;terry@intevo.com&gt;  Tim Fries           &lt;timf@dicecorp.com&gt;  Joe Thomas          &lt;jthomas@women.com&gt;  Paul Makepeace      &lt;Paul.Makepeace@realprogrammers.com&gt;  Raphael Manfredi    &lt;Raphael_Manfredi@pobox.com&gt;  Lee Lindley         &lt;Lee.Lindley@bigfoot.com&gt;  Dave Rolsky         &lt;autarch@urth.org&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>Certainly; this is beta software. When you discover an anomaly, send an email to me at bsugars@canoe.ca.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO IPC::Shareable&hellip;</h2>
        <div class="sectioncontent">
<p><em>perl</em>\|(1), <em>perltie</em>\|(1), <em>Storable</em>\|(3), <em>shmget</em>\|(2), <em>ipcs</em>\|(1), <em>ipcrm</em>\|(1) and other SysV \s-1IPC\s0 man pages.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="IPC::Run::Timer.3pm.html"><span aria-hidden="true">&larr;</span> IPC::Run::Timer.3pm: Timer channels for ipc::run.</a></li>
   <li class="next"><a href="IPC::Shareable::SharedMem.3pm.html">IPC::Shareable::SharedMem.3pm: Object oriented interface to shared memory <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Template::Plugin::XML::LibXML: Xml::libxml template toolkit plugin</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Xml::libxml template toolkit plugin">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Template::Plugin::XML::LibXML (3pm) manual">
  <meta name="twitter:description" content="Xml::libxml template toolkit plugin">
  <meta name="twitter:image" content="https://www.carta.tech/images/libtemplate-plugin-xml-perl-Template::Plugin::XML::LibXML-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Template::Plugin::XML::LibXML.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Template::Plugin::XML::LibXML (3pm) manual" />
  <meta property="og:description" content="Xml::libxml template toolkit plugin" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libtemplate-plugin-xml-perl-Template::Plugin::XML::LibXML-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Template::Plugin::XML::LibXML<small> (3pm)</small></h1>
        <p class="lead">Xml::libxml template toolkit plugin</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Template::Plugin::XML::LibXML.3pm.html">
      <span itemprop="name">Template::Plugin::XML::LibXML: Xml::libxml template toolkit plugin</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libtemplate-plugin-xml-perl/">
      <span itemprop="name">libtemplate-plugin-xml-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Template::Plugin::XML::LibXML.3pm.html">
      <span itemprop="name">Template::Plugin::XML::LibXML: Xml::libxml template toolkit plugin</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
   [% USE docroot = XML.LibXML("helloworld.xml") %]
</pre>
<p>   The message is: [% docroot.find("/greeting/text") %]</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module provides a plugin for the XML::LibXML module.  It can be utilised the same as any other Template Toolkit plugin, by using a \s-1USE\s0 statement from within a Template.  The use statment will return a reference to root node of the parsed document</p><p><strong>&#92;$1</strong></p><p>The plugin is capable of using either a string, a filename or a filehandle as a source for either \s-1XML\s0 data, or \s-1HTML\s0 data which will be converted to \s-1XHTML\s0 internally.</p><p>The \s-1USE\s0 statement can take one or more arguments to specify what \s-1XML\s0 should be processed.  If only one argument is passed then the plugin will attempt to guess how what it has been passed should be interpreted.</p><p>When it is forced to guess what type of data it is used the routine will first look for an open filehandle, which if it finds it will assume it's a filehandle to a file containing \s-1XML\s0.  Failing this (in decreasing order) it will look for the chars \*(L"&lt;?xml\*(R" at the start of what it was passed (and assume it's an \s-1XML\s0 string,) look for a \*(L"&lt;html&gt;\*(R" tag (and assume it's \s-1HTML\s0 string,) look for a \*(L"&lt;\*(R" (and assume it's \s-1XML\s0 string without a header,) or assume what it's been passed is the filename to a file containing \s-1XML\s0.</p><p>In the interests of being explicit, you may specify the type of data you are loading using the same names as in the <strong>XML::LibXML</strong> documentation:</p><p>   # value contains the xml string    [% USE docroot = XML.LibXML(string =&gt; value) %]</p><p>   # value contains the filename of the xml    [% USE docroot = XML.LibXML(file =&gt; value) %]</p><p>   # value contains an open filehandle to some xml    [% USE docroot = XML.LibXML(fh =&gt; value) %]</p><p>   # value contains the html string    [% USE docroot = XML.LibXML(html_string =&gt; value) %]</p><p>   # value contains the filename of the html    [% USE docroot = XML.LibXML(html_file =&gt; value) %]</p><p>   # value contains an open filehandle to some html    [% USE docroot = XML.LibXML(html_fh =&gt; value) %]</p><p>Or, if you want you can use similar names to that the \s-1XML\s0.XPath plugin uses:</p><p>   # value contains the xml string    [% USE docroot = XML.LibXML(xml =&gt; value) %] or    [% USE docroot = XML.LibXML(text =&gt; value) %]</p><p>   # value contains the filename of the xml    [% USE docroot = XML.LibXML(filename =&gt; value) %]</p><p>   # value contains the html string    [% USE docroot = XML.LibXML(html =&gt; value) %] or    [% USE docroot = XML.LibXML(html_text =&gt; value) %]</p><p>   # value contains the filename of the html    [% USE docroot = XML.LibXML(html_file =&gt; value) %]    [% USE docroot = XML.LibXML(html_filename =&gt; value) %]</p><p>You can provide extra arguments which will be used to set parser options.  See XML::LibXML for details on these.  I will repeat the following warning however: \*(L"LibXML options are global (unfortunately this is a limitation of the underlying implementation, not this interface)...Note that even two forked processes will share some of the same options, so be careful out there!\*(R"</p><p>   # turn off expanding entities    [% USE docroot = XML.LibXML("file.xml",                                expand_entities =&gt; 0); XML::LibXML provides two simple mechanisms for obtaining sections of the \s-1XML\s0 document, both of which can be used from within the Template Toolkit</p><p>The first of these is to use a XPath statement.  Simple values can be found with the \*(C`findvalue\*(C' routine:</p><p>  # get the title attribute of the first page node   # (note xpath starts counting from one not zero)   [% docroot.findvalue("/website/section/page[1]/@title"); %]</p><p>  # get the text contained within a node   [% htmldoc.findvalue("/html/body/h1[1]/text()") %]</p><p>Nodes of the xml document can be found with the \*(C`findnodes\*(C'</p><p>  # get all the pages (&apos;pages&apos; is a list of nodes)   [% pages = docroot.findnodes("/website/section/page") %]</p><p>  # get the first page (as TT folds single elements arrays   # to scalars, &apos;page1&apos; is the one node that matched)   [% page1 = docroot.findnodes("/website/section/page[1]") %]</p><p>Then further xpath commands can then be applied to those nodes in turn:</p><p>  # get the title attribute of the first page   [% page1.findvalue("@title") %]</p><p>An alternative approach is to use individual method calls to move around the tree.  So the above could be written:</p><p>  # get the text of the h1 node    [% htmlroot.documentElement               .getElementsByLocalName("body").first               .getElementsByLocalName("h1").first               .textContent %]</p><p>  # get the title of the first page   [% docroot.documentElement             .getElementsByLocalName("section").first             .getElementsByLocalName("page").first             .getAttribute("title") %]</p><p>You should use the technique that makes the most since in the particular situation.  These approaches can even be mixed:</p><p>  # get the first page title   [% page1 = htmlroot.findnodes("/website/section/page[1]");      page1.getAttribute("title") %]</p><p>Much more information can be found in XML::LibXML::Node. The simplest way to use this plugin is simply to extract each value you want to print by hand</p><p>   The title of the first page is &apos;[%     docroot.findvalue("/website/section/page[1]/@title") %]&apos;</p><p>or</p><p>   The title of the first page is &apos;[%      docroot.documentElement             .getElementsByLocalName("section").first             .getElementsByLocalName("page").first             .getAttribute("title") %]&apos;</p><p>You might want to discard whitespace from text areas.  XPath can remove all leading and following whitespace, and condense all multiple spaces in the text to single spaces.</p><p>   &lt;p&gt;[% htmlroot.findvalue("normalize-space(                               /html/body/p[1]/text()                            )" | html %]&lt;/p&gt;</p><p>Note that, as above, when we're inserting the values extracted into a \s-1XML\s0 or \s-1HTML\s0 document we have to be careful to re-encode the attributes we need to escape with something like the html filter.  A slightly more advanced technique is to extract a whole node and use the toString method call on it to convert it to a string of \s-1XML\s0.  This is most useful when you are extracting an existing chunk of \s-1XML\s0 en mass, as things like &lt;b&gt; and &lt;i&gt; tags will be passed thought correctly and entities will be encoded suitably (for example '"' will be turned into '&quot;')</p><p>  # get the second paragraph and insert it here as XML   [% htmlroot.findnodes("/html/body/p[2]").toString %]</p><p>The most powerful technique is to use a view (as defined by the \s-1VIEW\s0 keyword) to recursively render out the \s-1XML\s0.  By loading this plugin \*(C`present\*(C' methods will be created in the <strong>XML::LibXML::Node</strong> classes and subclasses.  Calling \*(C`present\*(C' on a node with a \s-1VIEW\s0 will cause it to be rendered by the view block matching the local name of that node (with any non alphanumeric charecters turned to underscores.  So a &lt;author&gt; tag will be rendered by the 'author' block.  Text nodes will call the 'text' block with the text of the node.</p><p>As the blocks can refer back to both the node it was called with and the view they can choose to recursively render out it's children using the view again.  To better facilitate this technique the extra methods \*(C`starttag\*(C' (recreate a string of the starting tag, including attributes,) \*(C`endtag\*(C' (recreate a string of the ending tag) and \*(C`content\*(C' (when called with a view, will render by calling all the children of that node in turn with that view) have been added.</p><p>This is probably best shown with a well commented example:</p><p>  # create the view   [% VIEW myview notfound =&gt; &apos;passthru&apos; %]</p><p>    # default tag that will recreate the tag &apos;as is&apos; meaning     # that unknown tags will &apos;passed though&apos; by the view     [% BLOCK passthru; item.starttag;                        item.content(view);                        item.endtag;     END %]</p><p>    # convert all sections to headed paragraphs     [% BLOCK section %]     &lt;h2&gt;[% item.getAttribute("title") %]&lt;/h2&gt;     &lt;p&gt;[% item.content(view) %]&lt;/p&gt;     [% END %]</p><p>    # urls link to themselves     [% BLOCK url %]     &lt;a href="[% item.content(view) %]"&gt;[% item.content(view) %]&lt;/a&gt;     [% END %]</p><p>    # email link to themselves with mailtos     [% BLOCK email %]     &lt;a href="mailto:[% item.content(view) %]"&gt;[% item.content(view) %]&lt;/a&gt;     [% END %]</p><p>    # make pod links bold     [% BLOCK pod %]     &lt;b&gt;[% item.content(view) %]&lt;/b&gt;     [% END %]</p><p>    # render text, re-encoding the attributes as we go     [% BLOCK text; item | html; END %]</p><p>    # render arrays out     [% BLOCK list; FOREACH i = item; view.print(i); END ; END %]</p><p>  [% END %]</p><p>  # use it to render the paragraphs   [% USE doc = XML.LibXML("mydoc.xml") %]   &lt;html&gt;    &lt;head&gt;     &lt;title&gt;[% doc.findvalue("/doc/page[1]/@title") %]&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;     [% sections = doc.findnodes("/doc/page[1]/section");        FOREACH section = sections %]     &lt;!-- next section --&gt;     [% section.present(myview);        END %]    &lt;/body&gt;   &lt;/html&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>In order to detect if a scalar is an open filehandle (which is used if the \s-1USE\s0 isn't explicit about it's data source) this plugin uses the \*(C`openhandle\*(C' routine from <strong>Scalar::Util</strong>.  If you do not have <strong>Scalar::Util</strong> installed, or the version of <strong>Scalar::Util</strong> is sufficiently old that it does not support the \*(C`openhandle\*(C' routine then a much cruder \*(C`defined(fileno $scalar)\*(C' check will be employed.</p><p>Bugs may be reported either via the \s-1CPAN\s0 \s-1RT\s0 at http://rt.cpan.org/NoAuth/Bugs.html?Dist=Template-Plugin-XML-LibXML or via the Template Toolkit mailing list: http://www.template-toolkit.org/mailman/listinfo/templates or direct to the author</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Written by Mark Fowler &lt;mark@twoshortplanks.com&gt;</p><p>Copyright Mark Fowler 2002-3, all rights reserved.</p><p>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p><p>This module wouldn't have been possible without the wonderful work that has been put into the libxml library by the gnome team or the equally wonderful work put in by Matt Sergeant and Christian Glahn in creating XML::LibXML.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Template::Plugin::XML::LibXML&hellip;</h2>
        <div class="sectioncontent">
<p>Template, Template::Plugin, XML::LibXML, XML::LibXML::Node.</p><p>On a similar note, you may want to see Template::Plugin::XML::XPath.</p><p>The t/test directory in the Template-Plugin-XML-LibXML distribution contains all the example \s-1XML\s0 files discussed in this documentation.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Template::Plugin::XML::File.3pm.html"><span aria-hidden="true">&larr;</span> Template::Plugin::XML::File.3pm: Tt plugin for xml files</a></li>
   <li class="next"><a href="Template::Plugin::XML::RSS.3pm.html">Template::Plugin::XML::RSS.3pm: Plugin interface to xml::rss <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Cache::Memcached::Managed: Provide api for managing cached information</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Provide api for managing cached information">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Cache::Memcached::Managed (3pm) manual">
  <meta name="twitter:description" content="Provide api for managing cached information">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcache-memcached-managed-perl-Cache::Memcached::Managed-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Cache::Memcached::Managed.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Cache::Memcached::Managed (3pm) manual" />
  <meta property="og:description" content="Provide api for managing cached information" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcache-memcached-managed-perl-Cache::Memcached::Managed-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Cache::Memcached::Managed<small> (3pm)</small></h1>
        <p class="lead">Provide api for managing cached information</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Cache::Memcached::Managed.3pm.html">
      <span itemprop="name">Cache::Memcached::Managed: Provide api for managing cached information</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcache-memcached-managed-perl/">
      <span itemprop="name">libcache-memcached-managed-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Cache::Memcached::Managed.3pm.html">
      <span itemprop="name">Cache::Memcached::Managed: Provide api for managing cached information</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
 use Cache::Memcached::Managed;

 my $cache = Cache::Memcached::Managed-&gt;new( &apos;127.0.0.1:12345&apos; );

 $cache-&gt;set( $value );

 $cache-&gt;set( $value,$id );

 $cache-&gt;set( value      =&gt; $value,
              id         =&gt; $id,
              key        =&gt; $key,
              version    =&gt; "1.1",
              namespace  =&gt; &apos;foo&apos;,
              expiration =&gt; &apos;1D&apos;, );

 my $value = $cache-&gt;get( $id );

 my $value = $cache-&gt;get( id  =&gt; $id,
                          key =&gt; $key );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">VERSION</h2>
        <div class="sectioncontent">
<p>This documentation describes version 0.22.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DIFFERENCES FROM THE Cache::Memcached API</h2>
        <div class="sectioncontent">
<p>The Cache::Memcached::Managed module provides an \s-1API\s0 to values, cached in one or more memcached servers.  Apart from being very similar to the \s-1API\s0 of Cache::Memcached, the Cached::Memcached::Managed \s-1API\s0 allows for management of groups of values, for simplified key generation and expiration, as well as version and namespace management and a few other goodies.</p><p>These are the main differences between this module and the Cache::Memcached module.</p><h3>automatic key generation</h3>
<p>The calling subroutine provides the key (by default).  Whenever the \*(L"get\*(R" and \*(L"set\*(R" operations occur in the same subroutine, you don't need to think up an identifying key that will have to be unique across the entire cache.</p>
<h3>\s-1ID\s0 refinement</h3>
<p>An \s-1ID\s0 can be added to the (automatically) generated key (none is by default), allowing easy identification of similar data objects (e.g. the primary key of a Class::DBI object).  If necessary, a unique \s-1ID\s0 can be created automatically (useful when logging events).</p>
<h3>version management</h3>
<p>The caller's package provides an identifying version (by default), allowing differently formatted data-structures caused by source code changes, to live separately from each other in the cache.</p>
<h3>namespace support</h3>
<p>A namespace identifier allows different realms to co-exist in the same cache (the uid by default).  This e.g. allows a group of developers to all use the same cache without interfering with each other.</p>
<h3>group management</h3>
<p>A piece of cached data can be assigned to any number of groups.  Cached data can be retrieved and removed by specifying the group to which the data belongs.  This can be used to selectively remove cached data that has been invalidated by a database change, or to obtain logged events of which the identification is not known (but the group name is).</p>
<h3>easy (default) expiration specification</h3>
<p>A default expiration per Cache::Memcached::Managed object can be specified. Expirations can be used by using mnemonics D, H, M, S, (e.g. '2D3H' would be 2 days and 3 hours).</p>
<h3>automatic \fIfork()\fP detection</h3>
<p>Sockets are automatically reset in forked processes, no manual reset needed. This allows the module to be used to access cached data during the server start phase in a mod_perl environment.</p>
<h3>magical increment</h3>
<p>Counters are automagically created with incr if they don't exist yet.</p>
<h3>instant invalidation</h3>
<p>Support for the new \*(L"flush_all\*(R" memcached action to invalidate all data in a cache in one fell swoop.</p>
<h3>dead memcached server detection</h3>
<p>An easy way to check whether all related memcached servers are still alive.</p>
<h3>starting/stopping memcached servers</h3>
<p>Easy start / stop of indicated memcached servers, mainly intended for development and testing environments.</p>
<h3>extensive test-suite</h3>
<p>An extensive test-suite is included (which is sadly lacking in the Cache::Memcached distribution).</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BASIC PREMISES</h2>
        <div class="sectioncontent">
<p>The basic premise is that each piece of information that is to be cached, can be identified by a key, an optional \s-1ID\s0, a version and a namespace.</p><p>The key determines the basic identification of the value to be cached. The \s-1ID\s0 specifies a refinement on the basic identification.  The version ensures that differently formatted values with the same key and \s-1ID\s0 do not interfere with each other.  The namespace ensures that different realms of information (for instance, for different users) do not interfere with each other.</p><h3>key</h3>
<p>The default for the key is the fully qualified subroutine name from which the cached value is accessed.  For instance, if a cached value is to be accessed from subroutine \*(L"bar\*(R" in the Foo package, then the key is \*(L"Foo::bar\*(R". Explicit keys can be specified and may contain any characters except the delimiter.</p><p>A special case is applicable if the cache is being accessed from the lowest level in a script.  In that case the default key will be created consisted of the server name (as determined by \*(C`uname -n\*(C') and the absolute path of the executing script.</p>
<h3>\s-1ID\s0</h3>
<p>If no \s-1ID\s0 is specified for a piece of information, then just the key will be assumed.  The \s-1ID\s0 can be any string.  It can for instance be the primary key of a Class::DBI object.  \s-1ID\s0's can be specified as a scalar value, or as list ref, or as a hash ref (for instance, for multi-keyed Class::DBI objects).</p><p>Some examples:</p><p> my $value = $cache-&gt;get( $id );</p><p> my $value = $cache-&gt;get( [$id,$checkin,$checkout] );</p><p> my $value =   $cache-&gt;get( {id =&gt; $id,checkin =&gt; $checkin,checkout =&gt; $checkout} );</p><p>If the \s-1ID\s0 should be something unique, and you're not interested in the \s-1ID\s0 per se (for instance, if you're only interested in the group to which the information will be linked), you can specify the string \*(C`:unique\*(C' to have a unique \s-1ID\s0 automatically generated.</p>
<h3>version management</h3>
<p>The version indicates which version (generation) of the data is to be fetched or stored.  By default, it takes the value of the $VERSION variable of the package to which the key is associated.  This allows new modules that cache information to be easily installed in a server park without having to fear data format changes.</p><p>A specific version can be specified with each of the add, decr, get, get_multi, incr, replace and set to indicate the link with the group of the information being cached.</p><p> Please always use a string as the version indicator.  Using floating point  values may yield unexpected results, where B&lt;1.0&gt; would actually use B&lt;1&gt;  as the version.</p>
<h3>namespace management</h3>
<p>The namespace indicates the realm to which the data belongs.  By default, the effective user id of the process (as known by $&gt;) is assumed.  This allows several users to share the same \*(L"data server\*(R" and \*(L"directory server\*(R", while each still having their own set of cached data.</p><p>A specific namespace can be specified with each of the add, decr, get, get_multi, incr, replace and set to indicate the link with the group of the information being cached.</p>
<h3>data server</h3>
<p>The data server is a Cache::Memcached (compatible) object in which all data (keyed to a \*(L"data key\*(R") is stored.  It uses one or more memcached servers. The data server can be obtained with the data object.</p>
<h3>data key</h3>
<p>The data key identifies a piece of data in the \*(L"data server\*(R".  It is formed by appending the namespace (by default the user id of the process), version, key and \s-1ID\s0, separated by the delimiter.</p><p>If a scalar value is specified as an \s-1ID\s0, then that value is used.</p><p>If the \s-1ID\s0 is specified as a list ref, then the values are concatenated with the delimiter.</p><p>If the \s-1ID\s0 is specified as a hash ref, then the sorted key and value pairs are concatenated with the delimiter.</p>
<h3>group management</h3>
<p>The group concept was added to allow easier management of cached information.  Since it is impossible to delete cached information from the \*(L"data server\*(R" by a matching a wildcard key value (because you can only access cached information if you know the exact key), another way was needed to access groups of cached data.</p><p>Another way that would not need another (database) backend or be dependent on running on a single hardware.  This is achieved by using a \*(L"directory server\*(R", which is basically just another memcached server dedicated to keeping a directory of data kept in the \*(L"data server\*(R".</p><p>The group concept allows you to associate a given \*(L"data key\*(R" to a named group and an group \s-1ID\s0 value (e.g. the group named \*(L"group\*(R" and the name of an \s-1SQL\s0 table).  This information is then stored in the \*(L"directory server\*(R", from which it is possible to obtain a list of \*(L"data keys\*(R" associated with the group name and the \s-1ID\s0 value.</p><p>In the current implementation, the only one group name is recognized by default:</p>
<dl class='dl-vertical'>
  <dt>
    group
  </dt>
  <dd>
    <p>Intended for generic data without specific keys.</p>
  </dd>

</dl>
<p>You can specify your own set of group names with the \*(L"group_names\*(R" parameter in new.</p><p>Group names and \s-1ID\s0's can be specified with each of the add, decr, incr, replace and set to indicate the link with the group of the information being cached.</p><p>The pseudo group \s-1ID\s0 '\*(C`:key\*(C'' can be specified to indicate that the key should be used for the group \s-1ID\s0.  This is usually used in conjunction with the generic '\*(C`group\*(C'' group name</p><p>A list of valid group names can be obtained with the group_names method.</p>
<h3>directory server</h3>
<p>The directory server is a Cache::Memcached (compatible) object that is being used to store \*(L"data key\*(R"s (as opposed to the data itself) used in \*(L"group management\*(R".  If no directory server was specified, then the data server will be assumed.</p><p>If there are multiple memcached servers used for the \*(L"data server\*(R", then it is advised to use a separate directory server (as a failure in one of the memcached backend servers will leave you with an incomplete directory otherwise).</p><p>Should the directory server fail, and it is vital that there is no stale data in the data server, then a flush_all would need to be executed to ensure that no stale data remains behind.  Of course, this will also delete all non-stale data from the data server, so your mileage may vary.</p>
<h3>expiration specification</h3>
<p>Expiration can be specified in seconds, but, for convenience, can also be specified in days, hours and minutes (and seconds).  This is indicated by a number, immediately followed by a letter <strong>D</strong> (for days) or <strong>H</strong> (for hours) or <strong>M</strong> (for minutes) or <strong>S</strong> (for seconds).  For example:</p><p> 2D3H</p><p>means 2 days and 3 hours, which means <strong>183600</strong> seconds.</p>
<h3>transparent fork handling</h3>
<p>Using this module, you do not have to worry if everything will still work after a <em>fork()</em>.  As soon as it is detected that the process has forked, new handles will be opened to the memcached servers in the child process (so the meticulous calling of \*(L"disconnect_all\*(R" of Cache::Memcached is no longer needed).</p><p>Transparent thread handling is still on the todo list.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CLASS METHODS</h2>
        <div class="sectioncontent">
<h3>new</h3>
<p> my $cache = Cache::Memcached::Managed-&gt;new;</p><p> my $cache = Cache::Memcached::Managed-&gt;new( &apos;127.0.0.1:11311&apos; );</p><p> my $cache = Cache::Memcached::Managed-&gt;new(   data           =&gt; &apos;127.0.0.1:11311&apos;,   # default: &apos;127.0.0.1:11211&apos;   directory      =&gt; &apos;127.0.0.1:11411&apos;,   # default: data   delimiter      =&gt; &apos;;&apos;,                 # default: &apos;#&apos;   expiration     =&gt; &apos;1H&apos;,                # default: &apos;1D&apos;   flush_interval =&gt; 10,                  # default: none   namespace      =&gt; &apos;foo&apos;,               # default: $&gt; ($EUID)   group_names    =&gt; [qw(foo bar)],       # default: [&apos;group&apos;]</p><p>  memcached_class =&gt; &apos;Cached::Memcached::Fast&apos;, # default: &apos;Cache::Memcached&apos;  );</p><p> my $cache = Cache::Memcached::Managed-&gt;new( inactive =&gt; 1 );</p><p>Create a new Cache::Memcached::Managed object.  If there are less than two input parameters, then the input parameter is assumed to be the value of the \*(L"data\*(R" field, with a default of '127.0.0.1:11211'.  If there are more than one input parameter, the parameters are assumed to be a hash with the following fields:</p>
<dl class='dl-vertical'>
  <dt>
    data
  </dt>
  <dd>
    <p> data =&gt; &apos;127.0.0.1:11211,127.0.0.1:11212&apos;,</p><p> data =&gt; [&apos;127.0.0.1:11211&apos;,&apos;127.0.0.1:11212&apos;],</p><p> data =&gt; {   servers =&gt; [&apos;127.0.0.1:11211&apos;,&apos;127.0.0.1:11212&apos;],   debug   =&gt; 1,  },</p><p> data =&gt; $memcached, The specification of the memcached server backend(s) for the \*(L"data server\*(R". It should either be:  - string with comma separated memcached server specification  - list ref with memcached server specification  - hash ref with Cache::Memcached object specification  - blessed object adhering to the Cache::Memcached API There is no default for this field, it <strong>must</strong> be specified.  The blessed object can later be obtained with the data method.</p>
  </dd>
  <dt>
    delimiter
  </dt>
  <dd>
    <p> delimiter =&gt; &apos;;&apos;,    # default: &apos;#&apos; Specify the delimiter to be used in key generation.  Should only be specified if you expect key, \s-1ID\s0, version or namespace values to contain the character '#'.  Can be any character that will not be part of key, \s-1ID\s0, version or namespace values. The current delimiter can be obtained with the delimiter method. Using the null byte (<em>&#92;&#92;0</em>) is not advised at this moment, as there are some encoding issues within Cache::Memcached regarding null bytes.</p>
  </dd>
  <dt>
    directory
  </dt>
  <dd>
    <p> directory =&gt; &apos;127.0.0.1:11311,127.0.0.1:11312&apos;,</p><p> directory =&gt; [&apos;127.0.0.1:11311&apos;,&apos;127.0.0.1:11312&apos;],</p><p> directory =&gt; {   servers =&gt; [&apos;127.0.0.1:11311&apos;,&apos;127.0.0.1:11312&apos;],   debug   =&gt; 1,  },</p><p> directory =&gt; $memcached, The specification of the memcached server backend(s) for the \*(L"directory server\*(R".  It should either be:  - string with comma separated memcached server specification  - list ref with memcached server specification  - hash ref with Cache::Memcached object specification  - blessed object adhering to the Cache::Memcached API If this field is not specified, the \*(L"data server\*(R" object will be assumed. The blessed object can later be obtained with the directory method.</p>
  </dd>
  <dt>
    expiration
  </dt>
  <dd>
    <p> expiration =&gt; &apos;1H&apos;,   # default: &apos;1D&apos; The specification of the default expiration.  The following postfixes can be specified:  - S seconds  - M minutes  - H hours  - D days  - W weeks The default default expiration is one day ('1D').  The default expiration will be used whenever no expiration has been specified with add, decr, incr, replace or set.  The default expiration can be obtained with the expiration method.</p>
  </dd>
  <dt>
    flush_interval
  </dt>
  <dd>
    <p> flush_interval =&gt; 10,   # default: none The specification of the default interval between which memcached servers will be flushed with flush_all.  No interval will be used by default if not specified.</p>
  </dd>
  <dt>
    group_names
  </dt>
  <dd>
    <p> group_names =&gt; [qw(foo bar)],   # default: [&apos;group&apos;] The specification of allowable group names.  Should be specified as a list reference to the allowable group names.  Defaults to one element list reference with 'group' only. Any group name can be specified, as long it consists of alphanumeric characters and does not interfere with other functions.  Currently disallowed name are:  - data  - delete  - directory  - expiration  - id  - group_names  - namespace There is hardly any penalty for using a lot of different group names in itself. However, linking cached information to a lot of different groups <strong>does</strong> have a penalty.</p>
  </dd>
  <dt>
    inactive
  </dt>
  <dd>
    <p> inactive =&gt; 1, Indicate that the object is inactive.  If this is specified, an instantiated object is returned with the same \s-1API\s0 as Cache::Memcached::Managed, but which will not do anything.  Intended to be uses in situations where no active memcached servers can be reached: all code will then function as if there are no cached values in the cache.</p>
  </dd>
  <dt>
    memcached_class
  </dt>
  <dd>
    <p>  memcached_class =&gt; &apos;Cached::Memcached::Fast&apos;, By default, this module uses the Cache::Memcached class as a \*(C`memcached\*(C' client.  Recently, other implementations have been developed, such as Cache::Memcached::Fast, that are considered to be \s-1API\s0 compatible.  To be able to use these other implementation of the memcached client, you can specify the name of the class to be used.  By default, \*(C`Cache::Memcached\*(C' will be assumed: the module will be loaded automatically if not loaded already.</p>
  </dd>
  <dt>
    namespace
  </dt>
  <dd>
    <p> namespace =&gt; &apos;foo&apos;,   # default: $&gt; ($EUID) The specification of the default namespace to be used with set, incr, decr, add, replace, get, get_multi, group, get_group and grab_group.  Defaults to the effective user \s-1ID\s0 of the process, as indicated by $&gt; ($EUID).</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OBJECT METHODS</h2>
        <div class="sectioncontent">
<p>The following object methods are available (in alphabetical order):</p><h3>add</h3>
<p> $cache-&gt;add( $value );</p><p> $cache-&gt;add( $value, $id );</p><p> $cache-&gt;add( $value, $id, $expiration );</p><p> $cache-&gt;add( value      =&gt; $value,               id         =&gt; $id,     # optional               key        =&gt; $key,    # optional               group      =&gt; &apos;foo&apos;,   # optional               expiration =&gt; &apos;3H&apos;,    # optional               version    =&gt; &apos;1.0&apos;,   # optional               namespace  =&gt; &apos;foo&apos;,   # optional             );</p><p>Add a value to the cache, but only if it doesn't exist yet.  Otherwise the same as set.</p>
<h3>data</h3>
<p> my $data = $cache-&gt;data;</p><p>Returns the data server object as specified with new.</p>
<h3>dead</h3>
<p> my @dead = $cache-&gt;dead;</p><p> my $dead = $cache-&gt;dead; # hash ref</p><p>Returns the memcached backend servers that appear to be non-functional. In list context returns the specifications of the servers in alphabetical order.  Returns a hash reference in scalar context, where the unresponsive servers are the keys.  Call errors to obtain the number of errors that were found for each memcached server.</p>
<h3>decr</h3>
<p> $cache-&gt;decr;</p><p> $cache-&gt;decr( $value );</p><p> $cache-&gt;decr( $value, $id, $expiration );</p><p> $cache-&gt;decr( value      =&gt; $value,  # default: 1                id         =&gt; $id,     # default: key only                key        =&gt; $key,    # default: caller environment                expiration =&gt; &apos;3H&apos;,    # default: $cache-&gt;expiration                version    =&gt; &apos;1.0&apos;,   # default: key environment                namespace  =&gt; &apos;foo&apos;,   # default: $cache-&gt;namespace              );</p><p>Decrement a value to the cache, but only if it already exists.  Otherwise the same as set.  Default for value is <strong>1</strong>.</p><p>Please note that any group associations will <strong>never</strong> be honoured: it is assumed they would be all the same for all calls to this counter and are therefore set only with set, add or incr.</p>
<h3>delete</h3>
<p> $cache-&gt;delete;</p><p> $cache-&gt;delete( $id );</p><p> $cache-&gt;delete( id        =&gt; $id,     # optional                  key       =&gt; $key,    # optional                  version   =&gt; &apos;1.0&apos;,   # optional                  namespace =&gt; &apos;foo&apos;,   # optional                );</p><p>Delete a value, associated with the specified \*(L"data key\*(R", from the cache. Can be called with unnamed and named parameters (assumed if two or more input parameters given).  If called with unnamed parameters, then they are:</p>
<dl class='dl-vertical'>
  <dt>
    1 id
  </dt>
  <dd>
    <p>The \s-1ID\s0 to be used to identify the value to be deleted.  Defaults to no \s-1ID\s0 (then uses key only).</p>
  </dd>

</dl>
<p>When using named parameters, the following names can be specified:</p>
<dl class='dl-vertical'>
  <dt>
    id
  </dt>
  <dd>
    <p>The \s-1ID\s0 to be used to identify the value to be deleted.  Defaults to no \s-1ID\s0 (then uses key only).</p>
  </dd>
  <dt>
    key
  </dt>
  <dd>
    <p>The key to be used to identify the value to be deleted.  Defaults to the default key (as determined by the caller environment).</p>
  </dd>
  <dt>
    version
  </dt>
  <dd>
    <p>The version to be used to identify the value to be deleted.  Defaults to the version associated with the key.</p>
  </dd>
  <dt>
    namespace
  </dt>
  <dd>
    <p>The namespace to be used to identify the value to be deleted.  Defaults to the default namespace associated with the object.</p>
  </dd>

</dl>

<h3>delete_group</h3>
<p> my $deleted = $cache-&gt;delete_group( group =&gt; &apos;foo&apos; );</p><p>Deletes all cached information related to one or more given groups (specified as name and \s-1ID\s0 value pairs) and returns how many items were actually deleted.</p>
<h3>delimiter</h3>
<p> my $delimiter = $cache-&gt;delimiter;</p><p>Returns the delimiter as (implicitely) specified with new.</p>
<h3>directory</h3>
<p> my $directory = $cache-&gt;directory;</p><p>Returns the directory cache object as (implicitely) specified with new.</p>
<h3>errors</h3>
<p> my $errors = $cache-&gt;errors( "reset" );  foreach ($cache-&gt;servers) {      print "Found $errors-&gt;{$_} errors for $_&#92;n" if exists $errors-&gt;{$_};  }</p><p>Return a hash reference with the number of errors when storing data values in a memcached backend server.  Use dead to find out whether a server is not responding.  A true value for the input parameter indicates that the error counts should be reset.</p>
<h3>expiration</h3>
<p> $expiration = $cache-&gt;expiration;</p><p>Returns the default expiration as (implicitely) specified with new.</p>
<h3>flush_all</h3>
<p> my $flushed = $cache-&gt;flush_all;</p><p> my $flushed = $cache-&gt;flush_all( 30 ); # flush with 30 second intervals</p><p>Initialize contents of all of the memcached backend servers of the \*(L"data server\*(R".  The input parameter specifies interval between flushes of backend memcached servers, default is the flush_interval value implicitely) specified with new.  Returns whether all memcached servers were successfully flushed.</p><p>Please note that this method returns immediately after instructing each of the memcached servers.  Also note that the timed flush_all functionality has only recently become part of the standard memcached \s-1API\s0 (starting from publicly released version 1.2.1). See the file \*(L"flush_interval.patch\*(R" for a patch for release 1.1.12 of the memcached software that implements timed flush_all functionality.</p>
<h3>flush_interval</h3>
<p> my $interval = $cache-&gt;flush_interval;</p><p>Returns the default flush interval values used with flush_all, as (implicitely) specified with new.</p>
<h3>get</h3>
<p> my $value = $cache-&gt;get;</p><p> my $value = $cache-&gt;get( $id );</p><p> my $value = $cache-&gt;get( id        =&gt; $id,     # optional                           key       =&gt; $key,    # optional                           version   =&gt; &apos;1.1&apos;,   # optional                           namespace =&gt; &apos;foo&apos;,   # optional                         );</p><p>Obtain a value, associated with a \*(L"data key\*(R", from the cache.  Can be called with unnamed and named parameters.  If called with unnamed parameters, then these are:</p>
<dl class='dl-vertical'>
  <dt>
    1 id
  </dt>
  <dd>
    <p>The \s-1ID\s0 to be used to identify the value to be fetched.  Defaults to no \s-1ID\s0 (then uses the default key only).</p>
  </dd>

</dl>
<p>When using named parameters, the following names can be specified:</p>
<dl class='dl-vertical'>
  <dt>
    id
  </dt>
  <dd>
    <p>The \s-1ID\s0 to be used to identify the value to be fetched.  Defaults to no \s-1ID\s0 (then uses key only).</p>
  </dd>
  <dt>
    key
  </dt>
  <dd>
    <p>The key to be used to identify the value to be fetched.  Defaults to the default key (as determined by the caller environment).</p>
  </dd>
  <dt>
    version
  </dt>
  <dd>
    <p>The version to be used to identify the value to be deleted.  Defaults to the version associated with the key.</p>
  </dd>
  <dt>
    namespace
  </dt>
  <dd>
    <p>The namespace to be used to identify the value to be deleted.  Defaults to the default namespace associated with the object.</p>
  </dd>

</dl>

<h3>get_group</h3>
<p> my $group = $cache-&gt;get_group(   group     =&gt; $groupname,   namespace =&gt; $namespace,   # default: $cache-&gt;namespace  );  foreach my $key (sort keys %{$group}) {    print "key: $key&#92;n"    my $versions = $group-&gt;{$key};    foreach my $version (sort keys %{$versions}) {      print "  version: $version&#92;n";      my $ids = $versions-&gt;{$version};      foreach my $id (sort keys %{$ids}) {        print "    id: $ids-&gt;{$id}&#92;n";      }    }  }</p><p> my @value = $cache-&gt;get_group(   group     =&gt; $groupname,   namespace =&gt; $namespace,   # default: $cache-&gt;namespace  );</p><p>Either returns a reference to a multi level hash for the given group name and \s-1ID\s0 (containing the group's data) in scalar context, or a list with values (regardless of key, version or id) in list context.</p><p>The input parameters are a hash that should contain the group name and associated \s-1ID\s0, with an optional namespace specification.</p><p>The structure of the returned hash reference is:</p><p> $result   |--- key         |-- version             |-- id                 |-- value</p><p>See \*(L"group management\*(R" for more information about groups.  See grab_group for obtaining the group and deleting it at the same time.</p>
<h3>get_multi</h3>
<p> my $hash = $cache-&gt;get_multi( &#92;@id );</p><p> my $hash = $cache-&gt;get_multi(   id        =&gt; &#92;@id,   key       =&gt; $key,   namespace =&gt; $namespace,  );</p><p>Optimized way of obtaining multiple values, associated with the same key, from the cache.  Returns a hash reference with values found, keyed to the associated \s-1ID\s0.</p><p>Can be called with named and unnamed parameters.  If called with unnamed parameters, the parameters are:</p>
<dl class='dl-vertical'>
  <dt>
    1 id
  </dt>
  <dd>
    <p>A list reference of \s-1ID\s0's to be used to identify the values to be fetched. Must be specified.</p>
  </dd>

</dl>
<p>When using named parameters, the following names can be specified:</p>
<dl class='dl-vertical'>
  <dt>
    id
  </dt>
  <dd>
    <p>A list reference of \s-1ID\s0's to be used to identify the values to be fetched. Must be specified.</p>
  </dd>
  <dt>
    key
  </dt>
  <dd>
    <p>The key to be used to identify the values to be fetched.  Defaults to the default key (as determined by the caller environment).</p>
  </dd>
  <dt>
    namespace
  </dt>
  <dd>
    <p>The namespace for which to fetch values.  Defaults to the namespace that was (implicitely) specified with new.</p>
  </dd>

</dl>

<h3>grab_group</h3>
<p> my $group = $cache-&gt;grab_group(   group     =&gt; $groupname,   namespace =&gt; $namespace,   # default: $cache-&gt;namespace  );</p><p>Same as get_group, but removes the returned data from the cache at the same time.</p>
<h3>group</h3>
<p> my $group = $cache-&gt;group(   group     =&gt; $groupname,   namespace =&gt; $namespace,   # default: $cache-&gt;namespace  );  foreach my $key (sort keys %{$group}) {      print "key: $key&#92;n"      print " ids: @{$group-&gt;{$key}}&#92;n";  }</p><p>Return a reference to a multi level hash for the given group name and \s-1ID\s0. The input parameters are a hash that should contain the group name and associated \s-1ID\s0, with an optional namespace specification.</p><p>The structure of the hash is:</p><p> $result   |--- key         |--- [id1,id2..idN]</p><p>See \*(L"group management\*(R" for more information about groups.</p>
<h3>group_names</h3>
<p> my @group_name = $cache-&gt;group_names;</p><p> my $group_names = $cache-&gt;group_names; # hash ref</p><p>Returns the valid group names as (implicitely) specified with new.  Returns them in alphabetical order if called in a list context, or as a hash ref if called in scalar context.</p>
<h3>inactive</h3>
<p> print "Inactive!&#92;n" if $cache-&gt;inactive;</p><p>Returns whether the cache object is inactive.  This happens if a true value is specified with new.</p>
<h3>incr</h3>
<p> $cache-&gt;incr;</p><p> $cache-&gt;incr( $value );</p><p> $cache-&gt;incr( $value, $id );</p><p> $cache-&gt;incr( $value, $id, $expiration );</p><p> $cache-&gt;incr( value      =&gt; $value,  # default: 1                id         =&gt; $id,     # default: key only                key        =&gt; $key,    # default: caller environment                expiration =&gt; &apos;3H&apos;,    # default: $cache-&gt;expiration                version    =&gt; &apos;1.1&apos;,   # default: key environment                namespace  =&gt; &apos;foo&apos;,   # default: $cache-&gt;namespace                group      =&gt; &apos;bar&apos;,   # default: none              );</p><p>Increment a value to the cache.  Otherwise the same as set.  Default for value is <strong>1</strong>.</p><p>Differently from the <em>incr()</em> of Cache::Memcached, this increment function is magical in the sense that it automagically will add the counter if it doesn't exist yet.</p><p>Please note that any group associations will only be set when the counter is created (and will be ignored in any subsequent increments of the same counter).</p>
<h3>namespace</h3>
<p> my $namespace = $cache-&gt;namespace;</p><p>Obtain the default namespace, as (implicitely) specified with new.</p>
<h3>replace</h3>
<p> $cache-&gt;replace( $value );</p><p> $cache-&gt;replace( $value, $id );</p><p> $cache-&gt;replace( $value, $id, $expiration );</p><p> $cache-&gt;replace( value      =&gt; $value,  # undef                   id         =&gt; $id,     # default: key only                   key        =&gt; $key,    # default: caller environment                   expiration =&gt; &apos;3H&apos;,    # default: $cache-&gt;expiration                   version    =&gt; &apos;1.1&apos;,   # default: key environment                   namespace  =&gt; &apos;foo&apos;,   # default: $cache-&gt;namespace                 );</p><p>Replace a value to the cache, but only if it already exists.  Otherwise the same as set.</p><p>Please note that any group associations will <strong>never</strong> be honoured: it is assumed they would be all the same for all calls to this counter and are therefore set only with set, add or incr.</p>
<h3>reset</h3>
<p> $cache-&gt;reset;</p><p>Resets the client side of the cache system.  Mainly for internal usage only. Always returns true.</p>
<h3>servers</h3>
<p> my @backend = $cache-&gt;servers;</p><p> my $backend = $cache-&gt;servers; # hash ref</p><p>Returns the configuration details of the memcached backend servers that are currently configured to be used.  Returns a list in alphabetical order in list context, and a hash ref in scalar context.</p><p>See also dead to find out if any of the memcached backend servers are not responding.</p>
<h3>set</h3>
<p> $cache-&gt;set;</p><p> $cache-&gt;set( $value );</p><p> $cache-&gt;set( $value,$id );</p><p> $cache-&gt;set( $value, $id, $expiration );</p><p> $cache-&gt;set( value      =&gt; $value,  # default: undef               id         =&gt; $id,     # default: key only               key        =&gt; $key,    # default: caller environment               expiration =&gt; &apos;3H&apos;,    # default: $cache-&gt;expiration               version    =&gt; &apos;1.1&apos;,   # default: key environment               namespace  =&gt; &apos;foo&apos;,   # default: $cache-&gt;namespace               group      =&gt; &apos;bar&apos;,   # default: none             );</p><p>Set a value in the cache, regardless of whether it exists already or not.</p><p>Can be called with named or unnamed parameters (if called with two input parameters or less).  If called with unnamed parameters, then the input parameters are:</p>
<dl class='dl-vertical'>
  <dt>
    1 value
  </dt>
  <dd>
    <p>The value to set in the cache.  Defaults to \*(C`undef\*(C'.</p>
  </dd>
  <dt>
    2 id
  </dt>
  <dd>
    <p>The \s-1ID\s0 to be used to identify the value.  Defaults to no \s-1ID\s0 (then uses key only).</p>
  </dd>
  <dt>
    3 expiration
  </dt>
  <dd>
    <p>The expiration of the value.  Defaults to the value as specified with expiration for the key.</p>
  </dd>

</dl>
<p>With named input parameters, the following names and values can be specified as a hash (in alphabetical order).</p>
<dl class='dl-vertical'>
  <dt>
    expiration
  </dt>
  <dd>
    <p>The expiration time in seconds of the given value.  Defaults to the value as specified with expiration for the key.  Values below 30*24*60*60 (30 days) will be considered to be relative to the current time.  Other values will be assumed to be absolute epoch times (seconds since 1 Jan. 1970 \s-1GMT\s0). See \*(L"expiration specification\*(R" for more ways to set expiration.</p>
  </dd>
  <dt>
    id
  </dt>
  <dd>
    <p>The \s-1ID\s0 to be used to identify the value.  Defaults to no \s-1ID\s0 (then uses key only).</p>
  </dd>
  <dt>
    key
  </dt>
  <dd>
    <p>The key to be used to identify the value.  Defaults to the default key (as determined by the caller environment).  Can be specified as a relative key when prefixed with \*(L"::\*(R", so that \*(L"::bar\*(R" would refer to the key \*(L"Foo::bar\*(R" if called from the package \*(L"Foo\*(R".</p>
  </dd>
  <dt>
    namespace
  </dt>
  <dd>
    <p>The namespace to which to associate the value.  Defaults to the namespace that was (implicitely) specified with new.</p>
  </dd>
  <dt>
    value
  </dt>
  <dd>
    <p>The value to set in the cache.  Defaults to \*(C`undef\*(C'.</p>
  </dd>
  <dt>
    version
  </dt>
  <dd>
    <p>The version to be used to identify the value to be set.  Defaults to the version associated with the key.</p>
  </dd>

</dl>
<p>Other than these named parameters, any number of group name and \s-1ID\s0 pairs can be specified to indicate a link to that group.</p>
<h3>start</h3>
<p> my $started_ok = $cache-&gt;start;</p><p> my $started_ok = $cache-&gt;start( $config );</p><p>Attempts to start the memcached servers that have been configured with new (and which can be find out with servers) by default, or the servers with the specified configs.  Returns whether all servers (implicitely) specified have been started successfully.</p><p>This only works if the memcached server(s) will be running on the same physical hardware as the script is running (which will generally not be the case in a production environment).  It is therefore of limited usage generally, but it is a handy feature to have if you're developing or testing.</p><p>See also stop.</p>
<h3>stats</h3>
<p> my $stats = $cache-&gt;stats;</p><p>Return a hash ref with simple statistics of all of the memcached backend servers.  The structure of the hash ref is as follows:</p><p> $stats    |-- server specification         |-- key              |-- value</p><p>See the memcached server documentation on possible keys and values.</p>
<h3>stop</h3>
<p> my $stopped = $cache-&gt;stop;</p><p> my $stopped = $cache-&gt;stop( $config );</p><p>Attempts to stop the specified memcached servers (as specified by config value), returns whether all servers have actually stopped.  Defaults to stopping all servers as initially specified with new.</p><p>This only works if the memcached server(s) are running on the same physical hardware as the script is running (which will generally not be the case in a production environment).  It is therefore of limited usage generally, but it is a handy feature to have if you're developing or testing.</p><p>See also start.</p>
<h3>version</h3>
<p> my $version = $cache-&gt;version; # hash ref</p><p> my $version = $cache-&gt;version( $config ); # hash ref</p><p>Obtain the version information of the specified memcached servers, or all memcached servers being used if no input parameters are specified.  Returns a hash reference in which the keys are the config information of the servers used (as returned by servers) and the values are the version information of the associated memcached server.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<h3>generic grouped event logging</h3>
<p> $cache-&gt;set( group =&gt; &apos;event1&apos;,               id    =&gt; &apos;:unique&apos;,               value =&gt; $value             );</p><p>This would put the value $value into the cache, linked to the group 'event1'.  Since we're not interested in the id of the event, but want to make sure it is always unique, the pseudo id ':unique' is specified.</p><p>A recurring process, usually a cron job, would then need to do the following to grab all of the values cached:</p><p> my @value = $cache-&gt;grab_group( group =&gt; &apos;event1&apos; );  foreach (@value) {  # perform whatever you want to do with the value in C&lt;$_&gt;  }</p><p>Please not that only the values are returned because grab_group is called in list context.</p>
<h3>generic content logging</h3>
<p> my $cache = Cache::Memcached::Managed-&gt;new(   data        =&gt; $servers,   group_names =&gt; [qw(hotel_id room_id)],   expiration  =&gt; &apos;1H&apos;,  );  package Foo;  sub available {    my ($cache,$hotel_id,$room_id,$checkin,$checkout) = @_;    my $available;    unless ($available = $cache-&gt;get( id =&gt; [$room_id,$checkin,$checkout] )) {  # perform complicated calculations setting C&lt;$available&gt;      $cache-&gt;set( id       =&gt; [$room_id,$checkin,$checkout],                   value    =&gt; $available,                   room_id  =&gt; $room_id,                   hotel_id =&gt; $hotel_id,                 );    }    return $available;  } #available</p><p>This example shows availability caching in a specific subroutine.  Because the get and the set are located in de same subroutine, it is not necessary to specify the key (which will be automatically set to \*(L"Foo::available\*(R").</p><p>Please also not the absence of a namespace specification.  Since each user of the \*(L"available\*(R" subroutine should have its \*(L"realm\*(R" depending on the cache object, no namespace specification is done.</p><p>Now, whenever something related to the hotel_id is changed, a simple:</p><p> $cache-&gt;delete_group( hotel_id =&gt; $hotel_id );</p><p>would be enough to also remove any availability cached in the above example (for the same value of $hotel_id).</p><p>The same would apply when something related to the room_id is changed: a simple:</p><p> $cache-&gt;delete_group( room_id =&gt; $room_id );</p><p>would be enough to also remove any availability cached in the above example (for the same value of $room_id).</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CAVEATS</h2>
        <div class="sectioncontent">
<h3>Race Conditions</h3>
<p>Several race conditions exists that can not be fixed because of a lack of semaphores when using memcached.</p><p>Most important race condition is when a group is deleted: between the moment the main pointer (\*(L"directory key\*(R") is reset and all of the index keys are removed, it is possible for another process to be adding information to the same directory key already.  In a worst case scenario, this means that a data key can get lost.</p><p>To prevent this, a delay of <strong>2</strong> seconds is applied to each time a group is deleted.  This should give some time for the cleaning process to clean up before other processes start accessing again, but it is no way a guarantee that other processes wouldn't be able to add information if the cleaning process needs more than 2 seconds to clean up.</p>
<h3>Cron jobs</h3>
<p>Because the \*(L"data key\*(R"s by default includes the user id (uid) of the process as the namespace with which the entry was stored in the cache, cron jobs (which usually run under a different user id) will need to set the namespace to the user id of the process storing information into the cache.</p>
<h3>Incompatibility with Cache module</h3>
<p>John Goulah pointed out to me that there is an inconsistency with unnamed parameter passing in respect to the Cache module.  Specifically, the \*(C`set\*(C' method:</p><p> $c-&gt;set( $key, $data, [ $expiry ] );</p><p>is incompatible with this module's \*(C`set\*(C' method:</p><p> $cache-&gt;set;</p><p> $cache-&gt;set( $value );</p><p> $cache-&gt;set( $value, $id );</p><p> $cache-&gt;set( $value, $id, $expiration );</p><p>The reason for this simple: in this module, <strong>all</strong> parameters are optional. So you can specify just a value: the key will be generated for you from the caller environment.  Since I felt at the time that you would more likely specify a value than a key, I made that the first parameter (as opposed to the \*(C`set\*(C' method of Cache.  Changing to the format as imposed by the Cache module, is not an option at this moment in the lifetime of this module, as it would break existing code (the same way as it breaks the test-suite).</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THEORY OF OPERATION</h2>
        <div class="sectioncontent">
<p>The group management is implemented by keeping a type of directory information in a (separate) directory memcached server.</p><p>For each group one directory key is maintained in the directory memcached server.  This key consists of the string \*(L"Cache::Memcached::Managed::\*(R", appended with the namespace, group name, the delimiter and the \s-1ID\s0 of the group.  For instance, the directory key for the group</p><p> group =&gt; &apos;foo&apos;</p><p>when running as user \*(L"500\*(R" would be:</p><p> Cache::Memcached::Managed#500#group#foo</p><p>The value of the directory key of a group is used as a counter.  Each time a some content is added that is linked to the group, that counter will be incremented and its value prepended to create an "index key".  So the first index key of the above example, would be:</p><p> 1#Cache::Memcached::Managed#500#group#foo</p><p>This index key is then also stored in the directory memcached server, with the original \*(L"data key\*(R" as its value, and with the same expiration as used for the data key.</p><p>Whenever the index keys are needed of a group (e.g. for fetching all of its members, or for deleting all of its members), the value of the directory key of the group is inspected, and that is used to generate a list of index keys. Suppose the value of the directory key is 5, then then following index keys would be generated (essentially mapping 1..5):</p><p> 1#Cache::Memcached::Managed#500#group#foo  2#Cache::Memcached::Managed#500#group#foo  3#Cache::Memcached::Managed#500#group#foo  4#Cache::Memcached::Managed#500#group#foo  5#Cache::Memcached::Managed#500#group#foo</p><p>If the group is to be deleted or fetched, then all possible values for these index keys are obtained.  For instance, this would fetch:</p><p> 1#Cache::Memcached::Managed#500#group#foo =&gt; 500#1.0#Foo::zip#23  2#Cache::Memcached::Managed#500#group#foo =&gt; 500#1.1#Bar::pod#47  3#Cache::Memcached::Managed#500#group#foo =&gt; 500#1.0#Foo::zip#23  4#Cache::Memcached::Managed#500#group#foo =&gt; 500#1.1#Bar::pid#12  5#Cache::Memcached::Managed#500#group#foo =&gt; 500#1.1#Bar::pid#14</p><p>Note that index key 1 and 3 return the same backend key.  This can be caused by doing multiple sets with the same key / id combination.  The final list of backend keys then becomes:</p><p> 500#1.0#Foo::zip#23  500#1.1#Bar::pod#47  500#1.1#Bar::pid#12  500#1.1#Bar::pid#14</p><p>If the group is to be deleted (delete_group), then the index keys are removed from the directory memcached server.  And the associated data keys are removed from the data memcached server.</p><p>If the group (data) is to be fetched (group or get_group), then the superfluous index keys are removed from the directory memcached server. In this example, that would be:</p><p> 1#Cache::Memcached::Managed#500#group#foo</p><p>because:</p><p> 3#Cache::Memcached::Managed#500#group#foo</p><p>also refers to the data key</p><p> 500#1.0#Foo::zip#23</p><p>Because of this, the lowest index key with a valid data key has become:</p><p> 2#Cache::Memcached::Managed#500#group#foo</p><p>making \*(L"2\*(R" the lowest ordinal number of the index keys.  In that case a special key, the lowest index key, is saved in the directory memcached server.  The name of the keys is the same as the directory key for the group, postfixed with the delimiter and the string \*(L"_lowest\*(R".  In this example, this would be:</p><p> Cache::Memcached::Managed#500#group#foo#_lowest</p><p>Whenever index keys are fetched, the value of this key is used to determine the start point for the generation of index keys.  If, in the above example another fetch of that group would be done, then these index_keys would be generated (essentially mapping 2..5):</p><p> 2#Cache::Memcached::Managed#500#group#foo  3#Cache::Memcached::Managed#500#group#foo  4#Cache::Memcached::Managed#500#group#foo  5#Cache::Memcached::Managed#500#group#foo</p><p>Since 32 bit counters are being used, about 4 billion items can be linked to a group, before a group should be deleted to completely restart.  In most live situation, this overflow condition will not occur, since this mechanism was mainly intended to be able to delete groups of information from the cache. And a deletion will remove the counter and all of its associated keys, essentially starting again at 1.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REQUIRED MODULES</h2>
        <div class="sectioncontent">
<p> Cache::Memcached (any)  Scalar::Util (any)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p> Elizabeth Mattijsen</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">HISTORY</h2>
        <div class="sectioncontent">
<p>This module started life as an internal module at \s-1BOOKINGS\s0 Online Hotel Reservation, the foremost European on-line hotel booking portal.  With approval and funding of Bookings, this module was generalized and put on \s-1CPAN\s0, for which Elizabeth Mattijsen would like to express her gratitude.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>(C) 2005, 2006 \s-1BOOKINGS\s0 (C) 2007, 2008 \s-1BOOKING\s0.COM (C) 2012 Elizabeth Mattijsen</p><p>This program is free software; you can redistribute it and/or modify it under the terms of the \s-1GNU\s0 General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.</p><p>This program is distributed in the hope that it will be useful, but \s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of \s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.  See the \s-1GNU\s0 General Public License for more details.</p><p>You should have received a copy of the \s-1GNU\s0 General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, \s-1MA\s0  02111-1307, \s-1USA\s0.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Cache::Memcached.3pm.html"><span aria-hidden="true">&larr;</span> Cache::Memcached.3pm: Client library for memcached (memory cache daemon)</a></li>
   <li class="next"><a href="Cache::Memcached::Managed::Inactive.3pm.html">Cache::Memcached::Managed::Inactive.3pm: Inactive cache::memcache::managed object <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

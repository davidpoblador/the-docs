<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Crypt::SaltedHash: Perl interface to functions that assist in working with salted hashes.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Perl interface to functions that assist in working with salted hashes.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Crypt::SaltedHash (3pm) manual">
  <meta name="twitter:description" content="Perl interface to functions that assist in working with salted hashes.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcrypt-saltedhash-perl-Crypt::SaltedHash-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Crypt::SaltedHash.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Crypt::SaltedHash (3pm) manual" />
  <meta property="og:description" content="Perl interface to functions that assist in working with salted hashes." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcrypt-saltedhash-perl-Crypt::SaltedHash-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Crypt::SaltedHash<small> (3pm)</small></h1>
        <p class="lead">Perl interface to functions that assist in working with salted hashes.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Crypt::SaltedHash.3pm.html">
      <span itemprop="name">Crypt::SaltedHash: Perl interface to functions that assist in working with salted hashes.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcrypt-saltedhash-perl/">
      <span itemprop="name">libcrypt-saltedhash-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Crypt::SaltedHash.3pm.html">
      <span itemprop="name">Crypt::SaltedHash: Perl interface to functions that assist in working with salted hashes.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
        use Crypt::SaltedHash;

        my $csh = Crypt::SaltedHash-&gt;new(algorithm =&gt; &apos;SHA-1&apos;);
        $csh-&gt;add(&apos;secret&apos;);

        my $salted = $csh-&gt;generate;
        my $valid = Crypt::SaltedHash-&gt;validate($salted, &apos;secret&apos;);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The \*(C`Crypt::SaltedHash\*(C' module provides an object oriented interface to create salted (or seeded) hashes of clear text data. The original formalization of this concept comes from \s-1RFC-3112\s0 and is extended by the use of different digital agorithms.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ABSTRACT</h2>
        <div class="sectioncontent">
<h3>Setting the data</h3>
<p>The process starts with 2 elements of data:</p><ul>
<li><p>a clear text string (this could represent a password for instance).</p></li><li><p>the salt, a random seed of data. This is the value used to augment a hash in order to ensure that 2 hashes of identical data yield different output.</p></li>
</ul><p>For the purposes of this abstract we will analyze the steps within code that perform the necessary actions to achieve the endresult hashes. Cryptographers call this hash a digest. We will not however go into an explanation of a one-way encryption scheme. Readers of this abstract are encouraged to get information on that subject by their own.</p><p>Theoretically, an implementation of a one-way function as an algorithm takes input, and provides output, that are both in binary form; realistically though digests are typically encoded and stored in a database or in a flat text or \s-1XML\s0 file. Take slappasswd5 for instance, it performs the exact functionality described above. We will use it as a black box compiled piece of code for our analysis.</p><p>In pseudocode we generate a salted hash as follows:</p><p>    Get the source string and salt as separate binary objects     Concatenate the 2 binary values     Hash the concatenation into SaltedPasswordHash     Base64Encode(concat(SaltedPasswordHash, Salt))</p><p>We take a clear text string and hash this into a binary object representing the hashed value of the clear text string plus the random salt. Then we have the Salt value, which are typically 4 bytes of purely random binary data represented as hexadecimal notation (Base16 as 8 bytes).</p><p>Using \s-1SHA-1\s0 as the hashing algorithm, SaltedPasswordHash is of length 20 (bytes) in raw binary form (40 bytes if we look at it in hex). Salt is then 4 bytes in raw binary form. The \s-1SHA-1\s0 algorithm generates a 160 bit hash string. Consider that 8 bits = 1 byte. So 160 bits = 20 bytes, which is exactly what the algorithm gives us.</p><p>The Base64 encoding of the binary result looks like:</p><p>    {SSHA}B0O0XSYdsk7g9K229ZEr73Lid7HBD9DX</p><p>Take note here that the final output is a 32-byte string of data. The Base64 encoding process uses bit shifting, masking, and padding as per \s-1RFC-3548\s0.</p><p>A couple of examples of salted hashes using on the same exact clear-text string:</p><p>    slappasswd -s testing123     {SSHA}72uhy5xc1AWOLwmNcXALHBSzp8xt4giL</p><p>    slappasswd -s testing123     {SSHA}zmIAVaKMmTngrUi4UlS0dzYwVAbfBTl7</p><p>    slappasswd -s testing123     {SSHA}Be3F12VVvBf9Sy6MSqpOgAdEj6JCZ+0f</p><p>    slappasswd -s testing123     {SSHA}ncHs4XYmQKJqL+VuyNQzQjwRXfvu6noa</p><p>4 runs of slappasswd against the same clear text string each yielded unique endresult hashes. The random salt is generated silently and never made visible.</p>
<h3>Extracting the data</h3>
<p>One of the keys to note is that the salt is dealt with twice in the process. It is used once for the actual application of randomness to the given clear text string, and then it is stored within the final output as purely Base64 encoded data. In order to perform an authentication query for instance, we must break apart the concatenation that was created for storage of the data. We accomplish this by splitting up the binary data we get after Base64 decoding the stored hash.</p><p>In pseudocode we would perform the extraction and verification operations as such:</p><p>    Strip the hash identifier from the Digest     Base64Decode(Digest, 20)     Split Digest into 2 byte arrays, one for bytes 0 X 20(pwhash), one for bytes 21 X 32 (salt)     Get the target string and salt as separate binary object     Concatenate the 2 binary values     SHA hash the concatenation into targetPasswordHash     Compare targetPasswordHash with pwhash     Return corresponding Boolean value</p><p>Our job is to split the original digest up into 2 distinct byte arrays, one of the left 20 (0 - 20 including the null terminator) bytes and the other for the rest of the data. The left 0 X 20 bytes will represent the salted  binary value we will use for a byte-by-byte data match against the new clear text presented for verification. The string presented for verification will have to be salted as well. The rest of the bytes (21 X 32) represent the random salt which when decoded will show the exact hex characters that make up the once randomly generated seed.</p><p>We are now ready to verify some data. Let's start with the 4 hashes presented earlier. We will run them through our code to extract the random salt and then using that verify the clear text string hashed by slappasswd. First, let's do a verification test with an erroneous password; this should fail the matching test:</p><p>    {SSHA}72uhy5xc1AWOLwmNcXALHBSzp8xt4giL Test123     Hash extracted (in hex): ef6ba1cb9c5cd4058e2f098d71700b1c14b3a7cc     Salt extracted (in hex): 6de2088b     Hash length is: 20 Salt length is: 4     Hash presented in hex: 256bc48def0ce04b0af90dfd2808c42588bf9542     Hashes DON&apos;T match: Test123</p><p>The match failure test was successful as expected. Now let's use known valid data through the same exact code:</p><p>    {SSHA}72uhy5xc1AWOLwmNcXALHBSzp8xt4giL testing123     Hash extracted (in hex): ef6ba1cb9c5cd4058e2f098d71700b1c14b3a7cc     Salt extracted (in hex): 6de2088b     Hash length is: 20 Salt length is: 4     Hash presented in hex: ef6ba1cb9c5cd4058e2f098d71700b1c14b3a7cc     Hashes match: testing123</p><p>The process used for salted passwords should now be clear. We see that salting hashed data does indeed add another layer of security to the clear text one-way hashing process. But we also see that salted hashes should also be protected just as if the data was in clear text form. Now that we have seen salted hashes actually work you should also realize that in code it is possible to extract salt values and use them for various purposes. Obviously the usage can be on either side of the colored hat line, but the data is there.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <strong>new( [%options] )</strong>
  </dt>
  <dd>
    <p>Returns a new Crypt::SaltedHash object. Possible keys for <em></em><strong>%options</strong><em></em> are:</p><ul>
<li><p><em>algorithm</em>: It's also possible to use common string representations of the algorithm (e.g. \*(L"sha256\*(R", \*(L"\s-1SHA-384\s0\*(R"). If the argument is missing, \s-1SHA-1\s0 will be used by default.</p></li><li><p><em>salt</em>: You can specify your on salt. You can either specify it as a sequence of charactres or as a hex encoded string of the form \*(L"HEX{...}\*(R". If the argument is missing, a random seed is provided for you (recommended).</p></li><li><p><em>salt_len</em>:  By default, the module assumes a salt length of 4 bytes (or 8, if it is encoded in hex). If you choose a different length, you have to tell the <em>validate</em> function how long your seed was.</p></li>
</ul><p>Logically joins the arguments into a single string, and uses it to update the current digest state. For more details see Digest.</p>
  </dd>
  <dt>
    <strong></strong><strong>clear()</strong><strong></strong>
  </dt>
  <dd>
    <p>Resets the digest.</p>
  </dd>
  <dt>
    <strong></strong><strong>salt_bin()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the salt in binary form.</p>
  </dd>
  <dt>
    <strong></strong><strong>salt_hex()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns the salt in hexadecimal form ('HEX{...}')</p>
  </dd>
  <dt>
    <strong></strong><strong>generate()</strong><strong></strong>
  </dt>
  <dd>
    <p>Generates the seeded hash. Uses the <em>clone</em>-method of Digest before actually performing the digest calculation, so adding more cleardata after a call of <em>generate</em> to an instance of <em>Crypt::SaltedHash</em> has the same effect as adding the data before the call of <em>generate</em>. Validates a hasheddata previously generated against cleardata. <em></em><strong>$salt_len</strong><em></em> defaults to 4 if not set. Returns 1 if the validation is successful, 0 otherwise.</p>
  </dd>
  <dt>
    <strong></strong><strong>obj()</strong><strong></strong>
  </dt>
  <dd>
    <p>Returns a handle to Digest object.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FUNCTIONS</h2>
        <div class="sectioncontent">
<p><em>none yet.</em></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Crypt::SaltedHash&hellip;</h2>
        <div class="sectioncontent">
<p>Digest, MIME::Base64</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Sascha Kiefer, esskar@cpan.org</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ACKNOWLEDGMENTS</h2>
        <div class="sectioncontent">
<p>The author is particularly grateful to Andres Andreu for his article: Salted hashes demystified - A Primer (&lt;http://www.securitydocs.com/library/3439&gt;)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT AND LICENSE</h2>
        <div class="sectioncontent">
<p>Copyright (C) 2010 Sascha Kiefer</p><p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Crypt::Random::Seed.3pm.html"><span aria-hidden="true">&larr;</span> Crypt::Random::Seed.3pm: Simple method to get strong randomness</a></li>
   <li class="next"><a href="Crypt::Simple.3pm.html">Crypt::Simple.3pm: Encrypt stuff simply <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

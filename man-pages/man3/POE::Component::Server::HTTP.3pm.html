<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>POE::Component::Server::HTTP: Foundation of a poe http daemon</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Foundation of a poe http daemon">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="POE::Component::Server::HTTP (3pm) manual">
  <meta name="twitter:description" content="Foundation of a poe http daemon">
  <meta name="twitter:image" content="https://www.carta.tech/images/libpoe-component-server-http-perl-POE::Component::Server::HTTP-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/POE::Component::Server::HTTP.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="POE::Component::Server::HTTP (3pm) manual" />
  <meta property="og:description" content="Foundation of a poe http daemon" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libpoe-component-server-http-perl-POE::Component::Server::HTTP-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">POE::Component::Server::HTTP<small> (3pm)</small></h1>
        <p class="lead">Foundation of a poe http daemon</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/POE::Component::Server::HTTP.3pm.html">
      <span itemprop="name">POE::Component::Server::HTTP: Foundation of a poe http daemon</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libpoe-component-server-http-perl/">
      <span itemprop="name">libpoe-component-server-http-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/POE::Component::Server::HTTP.3pm.html">
      <span itemprop="name">POE::Component::Server::HTTP: Foundation of a poe http daemon</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
 use POE::Component::Server::HTTP;
 use HTTP::Status;
 my $aliases = POE::Component::Server::HTTP-&gt;new(
     Port =&gt; 8000,
     ContentHandler =&gt; {
           &apos;/&apos; =&gt; &#92;&handler1,
           &apos;/dir/&apos; =&gt; sub { ... },
           &apos;/file&apos; =&gt; sub { ... }
     },
     Headers =&gt; { Server =&gt; &apos;My Server&apos; },
  );

  sub handler {
      my ($request, $response) = @_;
      $response-&gt;code(RC_OK);
      $response-&gt;content("Hi, you fetched ". $request-&gt;uri);
      return RC_OK;
  }

  POE::Kernel-&gt;call($aliases-&gt;{httpd}, "shutdown");
  # next line isn&apos;t really needed
  POE::Kernel-&gt;call($aliases-&gt;{tcp}, "shutdown");
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>POE::Component::Server::HTTP (PoCo::HTTPD) is a framework for building custom \s-1HTTP\s0 servers based on \s-1POE\s0. It is loosely modeled on the ideas of apache and the mod_perl/Apache module.</p><p>It is built alot on work done by Gisle Aas on HTTP::* modules and the \s-1URI\s0 module which are subclassed.</p><p>PoCo::HTTPD lets you register different handler, stacked by directory that will be run during the cause of the request.</p><p><strong>&#92;$1</strong></p><p>Handlers are put on a stack in fifo order. The path /foo/bar/baz/honk.txt will first push the handlers of / then of /foo/ then of /foo/bar/, then of /foo/bar/baz/, and lastly /foo/bar/baz/honk.txt.  Pay attention to directories!  A request for /honk will not match /honk/ as you are used to with apache.  If you want /honk to act like a directory, you should have a handler for /honk which redirects to /honk/.</p><p>However, there can be only one ContentHandler and if any handler installs a ContentHandler that will override the old ContentHandler.</p><p>If no handler installs a ContentHandler it will find the closest one directory wise and use it.</p><p>There is also a special StreamHandler which is a coderef that gets invoked if you have turned on streaming by doing $response-&gt;<em>streaming</em>\|(1);</p><p>Handlers take the $request and $response objects as arguments.</p>
<dl class='dl-vertical'>
  <dt>
    \s-1RC_OK\s0
  </dt>
  <dd>
    <p>Everything is ok, please continue processing.</p>
  </dd>
  <dt>
    \s-1RC_DENY\s0
  </dt>
  <dd>
    <p>If it is a TransHandler, stop translation handling and carry on with a PreHandler, if it is a PostHandler do nothing, else return denied to the client.</p>
  </dd>
  <dt>
    \s-1RC_WAIT\s0
  </dt>
  <dd>
    <p>This is a special handler that suspends the execution of the handlers. They will be suspended until $response-&gt;<em>continue()</em> is called, this is usefull if you want to do a long request and not blocck.</p>
  </dd>

</dl>
<p>The following handlers are available.</p>
<dl class='dl-vertical'>
  <dt>
    TransHandler
  </dt>
  <dd>
    <p>TransHandlers are run before the \s-1URI\s0 has been resolved, giving them a chance to change the \s-1URI\s0. They can therefore not be registred per directory.     new(TransHandler =&gt; [ sub {return RC_OK} ]); A TransHandler can stop the dispatching of TransHandlers and jump to the next handler type by specifing \s-1RC_DENY\s0;</p>
  </dd>
  <dt>
    PreHandler
  </dt>
  <dd>
    <p>PreHandlers are stacked by directory and run after TransHandler but before the ContentHandler. They can change ContentHandler (but beware, other PreHandlers might also change it) and push on PostHandlers.     new(PreHandler =&gt; { &apos;/&apos; =&gt; [sub {}], &apos;/foo/&apos; =&gt; [&#92;&foo]});</p>
  </dd>
  <dt>
    ContentHandler
  </dt>
  <dd>
    <p>The handler that is supposed to give the content. When this handler returns it will send the response object to the client. It will automaticly add Content-Length and Date if these are not set. If the response is streaming it will make sure the correct headers are set. It will also expand any cookies which have been pushed onto the response object.     new(ContentHandler =&gt; { &apos;/&apos; =&gt; sub {}, &apos;/foo/&apos; =&gt; &#92;&foo});</p>
  </dd>
  <dt>
    ErrorHandler
  </dt>
  <dd>
    <p>This handler is called when there is a read or write error on the socket. This is most likely caused by the remote side closing the connection. $resquest-&gt;is_error and $response-&gt;is_error will return true.  Note that \*(C`PostHanlder\*(C' will still called, but \*(C`TransHandler\*(C' and \*(C`PreHandler\*(C' won't be.  It is a map to coderefs just like ContentHandler is.</p>
  </dd>
  <dt>
    PostHandler
  </dt>
  <dd>
    <p>These handlers are run after the socket has been flushed.     new(PostHandler =&gt; { &apos;/&apos; =&gt; [sub {}], &apos;/foo/&apos; =&gt; [&#92;&foo]});</p>
  </dd>
  <dt>
    StreamHandler
  </dt>
  <dd>
    <p>If you turn on streaming in any other handler, the request is placed in streaming mode.  This handler is called, with the usual parameters, when streaming mode is first entered, and subsequently when each block of data is flushed to the client. Streaming mode is turned on via the $response object:     $response-&gt;<strong>streaming</strong>(1); You deactivate streaming mode with the same object:     $response-&gt;close; Content is also sent to the client via the $response object:     $response-&gt;send($somedata); The output filter is set to POE::Filter::Stream, which passes the data through unchanged.  If you are doing a multipart/mixed response, you will have to set up your own headers. Example:     sub new {         .....         POE::Component::Filter::HTTP-&gt;new(                  ContentHandler =&gt; { &apos;/someurl&apos; =&gt; sub { $self-&gt;someurl(@_) },                  StreamHandler  =&gt; sub { $self-&gt;stream(@_),             );     }</p><p>    sub someurl {         my($self, $resquest, $response)=@_;         $self-&gt;{todo} = [ .... ];         $response-&gt;<strong>streaming</strong>(1);         $response-&gt;code(RC_OK);         # you must set up your response header         $response-&gt;content_type(...);</p><p>        return RC_OK;     }</p><p>    sub stream {         my($self, $resquest, $response)=@_;</p><p>        if( @{$self-&gt;{todo}} ) {             $response-&gt;send(shift @{$self-&gt;{todo}});         }         else {             $response-&gt;close;         }     } Another example can be found in t/30_stream.t.  The parts dealing with multipart/mixed are well documented and at the end of the file. \s-1NOTE:\s0 Changes in streaming mode are only verified when StreamHandler exits. So you must either turn streaming off in your StreamHandler, or make sure that the StreamHandler will be called again.  This last is done by sending data to the client.  If for some reason you have no data to send, you can get the same result with \*(C`continue\*(C'. Remember that this will also cause the StreamHandler to be called one more time.     my $aliases=POE::Component::Filter::HTTP-&gt;new( ....);</p><p>    # and then, when the end of the stream in met     $response-&gt;close;     $response-&gt;continue; \s-1NOTE:\s0 even when the stream ends, the client connection will be held open if Keepalive is active.  To force the connection closed, set the <em>Connection</em> header to <em>close</em>:     $resquest-&gt;header(Connection =&gt; &apos;close&apos;); <em>This might be a bug.  Are there any cases where we'd want to keep the</em> connection open after a stream?</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Events</h2>
        <div class="sectioncontent">
<p>The \*(C`shutdown\*(C' event may be sent to the component indicating that it should shut down.  The event may be sent using the return value of the <em></em><em>new()</em><em></em> method (which is a session id) by either <em>post()</em>ing or <em>call()</em>ing.</p><p>I've experienced some problems with the session not receiving the event when it gets <em>post()</em>ed so <em>call()</em> is advised.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">See Also</h2>
        <div class="sectioncontent">
<p>Please also take a look at HTTP::Response, HTTP::Request, \s-1URI\s0, \s-1POE\s0 and POE::Filter::HTTPD</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TODO</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    Document Connection Response and Request objects.
  </dt>
  <dd>
    
  </dd>
  <dt>
    Write more tests
  </dt>
  <dd>
    
  </dd>
  <dt>
    Add a PoCo::Server::HTTP::Session that matches a http session against poe session using cookies or other state system
  </dt>
  <dd>
    
  </dd>
  <dt>
    Add more options to streaming
  </dt>
  <dd>
    
  </dd>
  <dt>
    Probably lots of other \s-1API\s0 changes
  </dt>
  <dd>
    
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Arthur Bergman, arthur@contiller.se</p><p>Additional hacking by Philip Gwyn, poe-at-pied.nu</p><p>Released under the same terms as \s-1POE\s0.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="POE::Component::SSLify::ServerHandle.3pm.html"><span aria-hidden="true">&larr;</span> POE::Component::SSLify::ServerHandle.3pm: Server-side handle for sslify</a></li>
   <li class="next"><a href="POE::Component::Server::SOAP.3pm.html">POE::Component::Server::SOAP.3pm: Publish poe event handlers via soap over http <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

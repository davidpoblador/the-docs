<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SoOffscreenRenderer: The sooffscreenrenderer class is used for rendering scenes in offscreen buffers.  if you want to render to a memory buffer instead of an on-screen opengl context, use this class. rendering to a memory buffer can be used to generate texture maps on-the-fly, or for saving snapshots of the scene to disk files (as pixel bitmaps or as postscript files for sending to a postscript-capable printer).</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The sooffscreenrenderer class is used for rendering scenes in offscreen buffers.  if you want to render to a memory buffer instead of an on-screen opengl context, use this class. rendering to a memory buffer can be used to generate texture maps on-the-fly, or for saving snapshots of the scene to disk files (as pixel bitmaps or as postscript files for sending to a postscript-capable printer).">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="SoOffscreenRenderer (3) manual">
  <meta name="twitter:description" content="The sooffscreenrenderer class is used for rendering scenes in offscreen buffers.  if you want to render to a memory buffer instead of an on-screen opengl context, use this class. rendering to a memory buffer can be used to generate texture maps on-the-fly, or for saving snapshots of the scene to disk files (as pixel bitmaps or as postscript files for sending to a postscript-capable printer).">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcoin80-doc-SoOffscreenRenderer-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/SoOffscreenRenderer.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="SoOffscreenRenderer (3) manual" />
  <meta property="og:description" content="The sooffscreenrenderer class is used for rendering scenes in offscreen buffers.  if you want to render to a memory buffer instead of an on-screen opengl context, use this class. rendering to a memory buffer can be used to generate texture maps on-the-fly, or for saving snapshots of the scene to disk files (as pixel bitmaps or as postscript files for sending to a postscript-capable printer)." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcoin80-doc-SoOffscreenRenderer-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">SoOffscreenRenderer<small> (3)</small></h1>
        <p class="lead">The sooffscreenrenderer class is used for rendering scenes in offscreen buffers.  if you want to render to a memory buffer instead of an on-screen opengl context, use this class. rendering to a memory buffer can be used to generate texture maps on-the-fly, or for saving snapshots of the scene to disk files (as pixel bitmaps or as postscript files for sending to a postscript-capable printer).</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoOffscreenRenderer.3.html">
      <span itemprop="name">SoOffscreenRenderer: The sooffscreenrenderer class is used for rendering scenes in offscreen buffers.  if you want to render to a memory buffer instead of an on-screen opengl context, use this class. rendering to a memory buffer can be used to generate texture maps on-the-fly, or for saving snapshots of the scene to disk files (as pixel bitmaps or as postscript files for sending to a postscript-capable printer).</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcoin80-doc/">
      <span itemprop="name">libcoin80-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoOffscreenRenderer.3.html">
      <span itemprop="name">SoOffscreenRenderer: The sooffscreenrenderer class is used for rendering scenes in offscreen buffers.  if you want to render to a memory buffer instead of an on-screen opengl context, use this class. rendering to a memory buffer can be used to generate texture maps on-the-fly, or for saving snapshots of the scene to disk files (as pixel bitmaps or as postscript files for sending to a postscript-capable printer).</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;Inventor/SoOffscreenRenderer.h&gt;</p><h3>Public Types</h3>
<p>enum <strong>Components</strong> { <strong>LUMINANCE</strong> = 1, <strong>LUMINANCE_TRANSPARENCY</strong> = 2, <strong>RGB</strong> = 3, <strong>RGB_TRANSPARENCY</strong> = 4 }</p>
<h3>Public Member Functions</h3>
<p><strong>SoOffscreenRenderer</strong> (const <strong>SbViewportRegion</strong> &viewportregion)</p><p><strong>SoOffscreenRenderer</strong> (<strong>SoGLRenderAction</strong> *action)</p><p><strong>~SoOffscreenRenderer</strong> ()</p><p>void <strong>setComponents</strong> (const <strong>Components</strong> components)</p><p><strong>Components</strong> <strong>getComponents</strong> (void) const </p><p>void <strong>setViewportRegion</strong> (const <strong>SbViewportRegion</strong> &region)</p><p>const <strong>SbViewportRegion</strong> & <strong>getViewportRegion</strong> (void) const </p><p>void <strong>setBackgroundColor</strong> (const <strong>SbColor</strong> &color)</p><p>const <strong>SbColor</strong> & <strong>getBackgroundColor</strong> (void) const </p><p>void <strong>setGLRenderAction</strong> (<strong>SoGLRenderAction</strong> *action)</p><p><strong>SoGLRenderAction</strong> * <strong>getGLRenderAction</strong> (void) const </p><p>SbBool <strong>render</strong> (<strong>SoNode</strong> *scene)</p><p>SbBool <strong>render</strong> (<strong>SoPath</strong> *scene)</p><p>unsigned char * <strong>getBuffer</strong> (void) const </p><p>const void *const & <strong>getDC</strong> (void) const </p><p>SbBool <strong>writeToRGB</strong> (FILE *fp) const </p><p>SbBool <strong>writeToPostScript</strong> (FILE *fp) const </p><p>SbBool <strong>writeToPostScript</strong> (FILE *fp, const <strong>SbVec2f</strong> &printsize) const </p><p>SbBool <strong>writeToRGB</strong> (const char *filename) const </p><p>SbBool <strong>writeToPostScript</strong> (const char *filename) const </p><p>SbBool <strong>writeToPostScript</strong> (const char *filename, const <strong>SbVec2f</strong> &printsize) const </p><p>SbBool <strong>isWriteSupported</strong> (const <strong>SbName</strong> &filetypeextension) const </p><p>int <strong>getNumWriteFiletypes</strong> (void) const </p><p>void <strong>getWriteFiletypeInfo</strong> (const int idx, <strong>SbPList</strong> &extlist, <strong>SbString</strong> &fullname, <strong>SbString</strong> &description)</p><p>SbBool <strong>writeToFile</strong> (const <strong>SbString</strong> &filename, const <strong>SbName</strong> &filetypeextension) const </p><p>void <strong>setPbufferEnable</strong> (SbBool enable)</p><p>SbBool <strong>getPbufferEnable</strong> (void) const </p>
<h3>Static Public Member Functions</h3>
<p>static float <strong>getScreenPixelsPerInch</strong> (void)</p><p>static <strong>SbVec2s</strong> <strong>getMaximumResolution</strong> (void)</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>The <strong>SoOffscreenRenderer</strong> class is used for rendering scenes in offscreen buffers.</p><p>If you want to render to a memory buffer instead of an on-screen OpenGL context, use this class. Rendering to a memory buffer can be used to generate texture maps on-the-fly, or for saving snapshots of the scene to disk files (as pixel bitmaps or as Postscript files for sending to a Postscript-capable printer).</p><p>Here's a dead simple usage example, just the code directly related to the <strong>SoOffscreenRenderer</strong>:</p>
<pre>
SoOffscreenRenderer myRenderer(vpregion);
SoNode * root = myViewer-&gt;getSceneManager()-&gt;getSceneGraph();
SbBool ok = myRenderer.render(root);
unsigned char * imgbuffer = myRenderer.getBuffer();
// [then use image buffer in a texture, or write it to file, or whatever]
</pre>
<p>And here a complete stand-alone example with a moving camera saving multiple frames to disk as JPGs:</p>
<pre>
#include &lt;Inventor/SoDB.h&gt;
#include &lt;Inventor/SoOffscreenRenderer.h&gt;
#include &lt;Inventor/engines/SoInterpolateVec3f.h&gt;
#include &lt;Inventor/nodes/SoCube.h&gt;
#include &lt;Inventor/nodes/SoDirectionalLight.h&gt;
#include &lt;Inventor/nodes/SoPerspectiveCamera.h&gt;
#include &lt;Inventor/nodes/SoSeparator.h&gt;

#include &lt;iostream&gt;

int main()
{
  // Init Coin
  SoDB::init();

  // The root node
  SoSeparator * root = new SoSeparator;
  root-&gt;ref();

  // It is mandatory to have at least one light for the offscreen renderer
  SoDirectionalLight * light = new SoDirectionalLight;
  root-&gt;addChild(light);

  // It is mandatory to have at least one camera for the offscreen renderer
  SoPerspectiveCamera * camera = new SoPerspectiveCamera;
  SbRotation cameraRotation = SbRotation::identity();
  cameraRotation *= SbRotation(SbVec3f(1, 0, 0), -0.4f);
  cameraRotation *= SbRotation(SbVec3f(0, 1, 0), 0.4f);
  camera-&gt;orientation = cameraRotation;
  root-&gt;addChild(camera);

  // Something to show... A box
  SoCube * cube = new SoCube;
  root-&gt;addChild(cube);

  // Set up the two camera positions we want to move the camera between
  SoInterpolateVec3f * interpolate = new SoInterpolateVec3f;
  interpolate-&gt;input0 = SbVec3f(2, 2, 9);
  interpolate-&gt;input1 = SbVec3f(2, 2, 5);
  camera-&gt;position.connectFrom(&interpolate-&gt;output);

  // Set up the offscreen renderer
  SbViewportRegion vpRegion(400, 300);
  SoOffscreenRenderer offscreenRenderer(vpRegion);

  // How many frames to render for the video
  int frames = 5;
  std::cout &lt;&lt; "Writing " &lt;&lt; frames &lt;&lt; " frames..." &lt;&lt; std::endl;

  for (int i = 0; i &lt; frames; i++) {
    // Update the camera position
    interpolate-&gt;alpha = float(i) / (frames - 1);

    // Render the scene
    SbBool ok = offscreenRenderer.render(root);

    // Save the image to disk
    SbString filename = SbString("coinvideo-") + (i + 1) + ".jpg";
    if (ok) {
      offscreenRenderer.writeToFile(filename.getString(), "jpg");
    } else {
      std::cout &lt;&lt; "Error saving image: " &lt;&lt; filename.getString() &lt;&lt; std::endl;
      break;
    }
  }

  std::cout &lt;&lt; "Done!" &lt;&lt; std::endl;

  root-&gt;unref();
  return 0;
}
</pre>
<p>Note that the <strong>SoOffscreenRenderer</strong> potentially allocates a fairly large amount of resources, both OpenGL and general system resources, for each instance. You will therefore be well adviced to try to reuse <strong>SoOffscreenRenderer</strong> instances, instead of constructing and destructing a new instance e.g. for each frame when generating pictures for video.</p><p>Offscreen rendering is internally done through either a GLX offscreen context (i.e. OpenGL on X11), WGL (i.e. OpenGL on Win32), AGL (old-style OpenGL on the Mac OS X) or CGL (new-style Mac OS X).</p><p>If the OpenGL driver supports the pbuffer extension, it is detected and used to provide hardware-accelerated offscreen rendering.</p><p>The pixeldata is fetched from the OpenGL buffer with glReadPixels(), with the format and type arguments set to GL_RGBA and GL_UNSIGNED_BYTE, respectively. This means that the maximum resolution is 32 bits, 8 bits for each of the R/G/B/A components.</p><p>One particular usage of the <strong>SoOffscreenRenderer</strong> is to make it render frames to be used for the construction of movies. The general technique for doing this is to iterate over the following actions:</p><ul>
<li><p>move camera to correct position for frame</p></li><li><p>update the realTime global field (see explanation below)</p></li><li><p>invoke the <strong>SoOffscreenRenderer</strong></p></li><li><p>dump rendered scene to file</p></li>
</ul><p>..then you use some external tool or library to construct the movie file, for instance in MPEG format, from the set of files dumped to disk from the iterative process above.</p><p>The code would go something like the following (pseudo-code style). First we need to stop the Coin library itself from doing any automatic updating of the realTime field, so your application initialization for Coin should look something like:</p>
<pre>
[...] = SoQt::init([...]); // or SoWin::init() or SoDB::init()
// ..and then immediately:

// Control realTime field ourselves, so animations within the scene
// follows "movie-time" and not "wallclock-time".
SoDB::enableRealTimeSensor(FALSE);
SoSceneManager::enableRealTimeUpdate(FALSE);
SoSFTime * realtime = SoDB::getGlobalField("realTime");
realtime-&gt;setValue(0.0);
</pre>
<p>Note that it is important that the realTime field is initialized to <em>your</em> start-time <em>before</em> setting up any engines or other entities in the system that uses the realTime<em> field.</em></p><p>Then for the rendering loop, something like:</p>
<pre>
for (int i=0; i &lt; NRFRAMES; i++) {
  // [...reposition camera here, if necessary...]

  // render
  offscreenrend-&gt;render(root);

  // dump to file
  SbString framefile;
  framefile.sprintf("frame%06d.rgb", i);
  offscreenrend-&gt;writeToRGB(framefile.getString());

  // advance "current time" by the frames-per-second value, which
  // is 24 fps in this example
  realtime-&gt;setValue(realtime.getValue() + 1/24.0);
}
</pre>
<p>When making movies you need to write your application control code to take care of moving the camera along the correct trajectory yourself, and to explicitly control the global realTime field. The latter is so you're able to 'step' with appropriate time units for each render operation (e.g. if you want a movie that has a 24 FPS refresh rate, first render with realTime=0.0, then add 1/24s to the realTime field, render again to a new frame, add another 1/24s to the realTime field, render, and so on).</p><p>For further information about how to control the realTime field, see documentation of <strong>SoDB::getGlobalField()</strong>, <strong>SoDB::enableRealTimeSensor()</strong>, and <strong>SoSceneManager::enableRealTimeUpdate()</strong>.</p><p>If you want to use this class to create snapshots of your current viewer's view, but want to control the size of the snapshot, you need to modify the camera a bit while rendering to be sure that everything you see in the current view is visible in the snapshot.</p><p>Below you'll find some pseude-code that does this. There are probably other ways to do this as well.</p>
<pre>
void render_offscreen(const SbVec2s size)
{
  SbVec2s glsize = this-&gt;getGLSize(); // size of your normal viewer
  float glar = float(glsize[0] / float(glsize[1]));
  float ar = float(size[0]) / float(size[1]);
  SoCamera * camera = this-&gt;getCamera(); // the camera you're using
  SoCamera::ViewportMapping oldmap = (SoCamera::ViewportMapping)
    camera-&gt;viewportMapping.getValue();
  float oldar = camera-&gt;aspectRatio.getValue();

  camera-&gt;viewportMapping = SoCamera::LEAVE_ALONE;
  camera-&gt;aspectRatio = ar;

  float scaleheight = 1.0f;
  if (glar &gt; ar) {
    scaleheight = glar / ar;
    camera-&gt;scaleHeight(scaleheight);
  }
  else {
    scaleheight = ar / glar;
    camera-&gt;scaleHeight(scaleheight);
  }
  SoOffscreenRenderer * renderer = new SoOffscreenRenderer(size);
  renderer-&gt;render(root);

  // ... save image

  // restore camera
  camera-&gt;viewportMapping = oldmap;
  camera-&gt;aspectRatio = oldar;

  if (scaleheight != 1.0f) {
    camera-&gt;scaleHeight(1.0f / scaleheight);
  }
}
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Enumeration Documentation</h2>
        <div class="sectioncontent">
<h3>enum \fBSoOffscreenRenderer::Components\fP</h3>
<p>Enumerated values for the available image formats.</p><p><strong>See also:</strong></p><p><strong>setComponents()</strong></p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>SoOffscreenRenderer::SoOffscreenRenderer (const \fBSbViewportRegion\fP &viewportregion)</h3>
<p>Constructor. Argument is the <em>viewportregion</em> we should use when rendering. An internal <strong>SoGLRenderAction</strong> will be constructed.</p>
<h3>SoOffscreenRenderer::SoOffscreenRenderer (\fBSoGLRenderAction\fP *action)</h3>
<p>Constructor. Argument is the <em>action</em> we should apply to the scene graph when rendering the scene. Information about the viewport is extracted from the <em>action</em>.</p>
<h3>SoOffscreenRenderer::~SoOffscreenRenderer ()</h3>
<p>Destructor.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>float SoOffscreenRenderer::getScreenPixelsPerInch (void)\fC [static]\fP</h3>
<p>Returns the screen pixels per inch resolution of your monitor.</p>
<h3>\fBSbVec2s\fP SoOffscreenRenderer::getMaximumResolution (void)\fC [static]\fP</h3>
<p>Get maximum dimensions (width, height) of the offscreen buffer.</p><p>Note that from Coin version 2 onwards, the returned value will always be (SHRT_MAX, SHRT_MAX), where SHRT_MAX on most systems is equal to 32767.</p><p>This because the <strong>SoOffscreenRenderer</strong> can in principle generate unlimited size offscreen canvases by tiling together multiple renderings of the same scene.</p>
<h3>void SoOffscreenRenderer::setComponents (const \fBComponents\fPcomponents)</h3>
<p>Sets the component format of the offscreen buffer.</p><p>If set to LUMINANCE, a grayscale image is rendered, LUMINANCE_TRANSPARENCY gives us a grayscale image with transparency, RGB will give us a 24-bit image with 8 bits each for the red, green and blue component, and RGB_TRANSPARENCY yields a 32-bit image (RGB plus transparency).</p><p>The default format to render to is RGB.</p><p>This will invalidate the current buffer, if any. The buffer will not contain valid data until another call to <strong>SoOffscreenRenderer::render()</strong> happens.</p>
<h3>\fBSoOffscreenRenderer::Components\fP SoOffscreenRenderer::getComponents (void) const</h3>
<p>Returns the component format of the offscreen buffer.</p><p><strong>See also:</strong></p><p><strong>setComponents()</strong></p>
<h3>void SoOffscreenRenderer::setViewportRegion (const \fBSbViewportRegion\fP &region)</h3>
<p>Sets the viewport region.</p><p>This will invalidate the current buffer, if any. The buffer will not contain valid data until another call to <strong>SoOffscreenRenderer::render()</strong> happens.</p>
<h3>const \fBSbViewportRegion\fP & SoOffscreenRenderer::getViewportRegion (void) const</h3>
<p>Returns the viewerport region.</p>
<h3>void SoOffscreenRenderer::setBackgroundColor (const \fBSbColor\fP &color)</h3>
<p>Sets the background color. The buffer is cleared to this color before rendering.</p>
<h3>const \fBSbColor\fP & SoOffscreenRenderer::getBackgroundColor (void) const</h3>
<p>Returns the background color.</p>
<h3>void SoOffscreenRenderer::setGLRenderAction (\fBSoGLRenderAction\fP *action)</h3>
<p>Sets the render action. Use this if you have special rendering needs.</p>
<h3>\fBSoGLRenderAction\fP * SoOffscreenRenderer::getGLRenderAction (void) const</h3>
<p>Returns the rendering action currently used.</p>
<h3>SbBool SoOffscreenRenderer::render (\fBSoNode\fP *scene)</h3>
<p>Render the scenegraph rooted at <em>scene</em> into our internal pixel buffer.</p><p>Important note: make sure you pass in a <em>scene</em> node pointer which has both a camera and at least one lightsource below it -- otherwise you are likely to end up with just a blank or black image buffer.</p><p>This mistake is easily made if you use an <strong>SoOffscreenRenderer</strong> on a scenegraph from one of the standard viewer components, as you will often just leave the addition of a camera and a headlight lightsource to the viewer to set up. This camera and lightsource are then part of the viewer's private 'super-graph' outside of the scope of the scenegraph passed in by the application programmer. To make sure the complete scenegraph (including the viewer's 'private parts' (<em>snicker</em>)) are passed to this method, you can get the scenegraph root from the viewer's internal <strong>SoSceneManager</strong> instance instead of from the viewer's own getSceneGraph() method, like this:</p>
<pre>
SoOffscreenRenderer * myRenderer = new SoOffscreenRenderer(vpregion);
SoNode * root = myViewer-&gt;getSceneManager()-&gt;getSceneGraph();
SbBool ok = myRenderer-&gt;render(root);
// [then use image buffer in a texture, or write it to file, or whatever]
</pre>
<p>If you do this and still get a blank buffer, another common problem is to have a camera which is not actually pointing at the scene geometry you want a snapshot of. If you suspect that could be the cause of problems on your end, take a look at <strong>SoCamera::pointAt()</strong> and <strong>SoCamera::viewAll()</strong> to see how you can make a camera node guaranteed to be directed at the scene geometry.</p><p>Yet another common mistake when setting up the camera is to specify values for the <strong>SoCamera::nearDistance</strong> and <strong>SoCamera::farDistance</strong> fields which doesn't not enclose the full scene. This will result in either just the background color, or that parts at the front or the back of the scene will not be visible in the rendering.</p><p><strong>See also:</strong></p><p><strong>writeToRGB()</strong></p>
<h3>SbBool SoOffscreenRenderer::render (\fBSoPath\fP *scene)</h3>
<p>Render the <em>scene</em> path into our internal memory buffer.</p>
<h3>unsigned char * SoOffscreenRenderer::getBuffer (void) const</h3>
<p>Returns the offscreen memory buffer.</p>
<h3>const void *const & SoOffscreenRenderer::getDC (void) const</h3>
<p>Win32 only:</p><p>returns a direct handle to the internal DC of the offscreen context.</p><p>Useful for efficient access to the raw image under certain special circumstances. <strong>getBuffer()</strong> might be too slow, for instance due to pixel format conversion (Windows DCs are usually BGRA, while the 32-bit buffers returned from <strong>getBuffer()</strong> are RGBA).</p><p>Notes:</p><p>The return value is a reference to a HDC. The HDC typedef has been unwound to a native C++ type for multiplatform compatibility reasons.</p><p>Returned reference will contain a NULL value on other platforms.</p><p>Important limitation: if the current dimensions of the <strong>SoOffscreenRenderer</strong> instance are larger than what can be rendered with a single offscreen buffer, tiling will be used by the <strong>SoOffscreenRenderer</strong>, and the returned HDC will contain only part of the full rendered image.</p><p><strong>See also:</strong></p><p><strong>getBuffer()</strong></p><p><strong>Since:</strong></p><p>Coin 3.1</p>
<h3>SbBool SoOffscreenRenderer::writeToRGB (FILE *fp) const</h3>
<p>Writes the buffer in SGI RGB format by appending it to the already open file. Returns FALSE if writing fails.</p><p>Important note: do <em>not</em> use this method when the Coin library has been compiled as an MSWindows DLL, as passing FILE* instances back or forth to DLLs is dangerous and will most likely cause a crash. This is an intrinsic limitation for MSWindows DLLs.</p>
<h3>SbBool SoOffscreenRenderer::writeToPostScript (FILE *fp) const</h3>
<p>Writes the buffer in Postscript format by appending it to the already open file. Returns FALSE if writing fails.</p><p>Important note: do <em>not</em> use this method when the Coin library has been compiled as an MSWindows DLL, as passing FILE* instances back or forth to DLLs is dangerous and will most likely cause a crash. This is an intrinsic limitation for MSWindows DLLs.</p>
<h3>SbBool SoOffscreenRenderer::writeToPostScript (FILE *fp, const \fBSbVec2f\fP &printsize) const</h3>
<p>Writes the buffer to a file in Postscript format, with <em>printsize</em> dimensions.</p><p>Important note: do <em>not</em> use this method when the Coin library has been compiled as an MSWindows DLL, as passing FILE* instances back or forth to DLLs is dangerous and will most likely cause a crash. This is an intrinsic limitation for MSWindows DLLs.</p>
<h3>SbBool SoOffscreenRenderer::writeToRGB (const char *filename) const</h3>
<p>Opens a file with the given name and writes the offscreen buffer in SGI RGB format to the new file. If the file already exists, it will be overwritten (if permitted by the filesystem).</p><p>Returns TRUE if all went ok, otherwise FALSE.</p>
<h3>SbBool SoOffscreenRenderer::writeToPostScript (const char *filename) const</h3>
<p>Opens a file with the given name and writes the offscreen buffer in Postscript format to the new file. If the file already exists, it will be overwritten (if permitted by the filesystem).</p><p>Returns TRUE if all went ok, otherwise FALSE.</p>
<h3>SbBool SoOffscreenRenderer::writeToPostScript (const char *filename, const \fBSbVec2f\fP &printsize) const</h3>
<p>Opens a file with the given name and writes the offscreen buffer in Postscript format with <em>printsize</em> dimensions to the new file. If the file already exists, it will be overwritten (if permitted by the filesystem).</p><p>Returns TRUE if all went ok, otherwise FALSE.</p>
<h3>SbBool SoOffscreenRenderer::isWriteSupported (const \fBSbName\fP &filetypeextension) const</h3>
<p>Returns TRUE if the buffer can be saved as a file of type <em>filetypeextension</em>, using <strong>SoOffscreenRenderer::writeToFile()</strong>. This function needs simage v1.1 or newer.</p><p>Examples of possibly supported extensions are: 'jpg', 'png', 'tiff', 'gif', 'bmp', etc. The extension match is not case sensitive.</p><p>Which formats are <em>actually</em> supported depends on the capabilities of Coin's support library for handling import and export of pixel-data files: the simage library. If the simage library is not installed on your system, no extension output formats will be supported.</p><p>Also, note that it is possible to build and install a simage library that lacks support for most or all of the file formats it is <em>capable</em> of supporting. This is so because the simage library depends on other, external 3rd party libraries -- in the same manner as Coin depends on the simage library for added file format support.</p><p>The two built-in formats that are supported through the <strong>SoOffscreenRenderer::writeToRGB()</strong> and <strong>SoOffscreenRenderer::writeToPostScript()</strong> methods (for SGI RGB format and for Adobe Postscript files, respectively) are <em>not</em> considered by this method, as those two formats are guaranteed to <em>always</em> be supported through those functions.</p><p>So if you want to be guaranteed to be able to export a screenshot in your wanted format, you will have to use either one of the above mentioned method for writing SGI RGB or Adobe Postscript directly, or make sure the Coin library has been built and is running on top of a version of the simage library (that you have preferably built yourself) with the file format(s) you want support for.</p><p>This method is an extension versus the original SGI Open Inventor API.</p><p><strong>See also:</strong></p><p><strong>getNumWriteFiletypes()</strong>, <strong>getWriteFiletypeInfo()</strong>, <strong>writeToFile()</strong></p>
<h3>int SoOffscreenRenderer::getNumWriteFiletypes (void) const</h3>
<p>Returns the number of available exporters. Detailed information about the exporters can then be found using <strong>getWriteFiletypeInfo()</strong>.</p><p>See <strong>SoOffscreenRenderer::isWriteSupported()</strong> for information about which file formats you can expect to be present.</p><p>Note that the two built-in export formats, SGI RGB and Adobe Postscript, are not counted.</p><p>This method is an extension versus the original SGI Open Inventor API.</p><p><strong>See also:</strong></p><p><strong>getWriteFiletypeInfo()</strong></p>
<h3>void SoOffscreenRenderer::getWriteFiletypeInfo (const intidx, \fBSbPList\fP &extlist, \fBSbString\fP &fullname, \fBSbString\fP &description)</h3>
<p>Returns information about an image exporter. <em>extlist</em> is a list of filename extensions for a file format. E.g. for JPEG it is legal to use both jpg and jpeg. Extlist will contain const char * pointers (you need to cast the void * pointers to const char * before using them).</p><p><em>fullname</em> is the full name of the image format. <em>description</em> is an optional string with more information about the file format.</p><p>See <strong>SoOffscreenRenderer::isWriteSupported()</strong> for information about which file formats you can expect to be present.</p><p>This method is an extension versus the original SGI Open Inventor API.</p><p>Here is a stand-alone, complete code example that shows how you can check exactly which output formats are supported:</p>
<pre>
#include &lt;Inventor/SoDB.h&gt;
#include &lt;Inventor/SoOffscreenRenderer.h&gt;

int
main(int argc, char **argv)
{
  SoDB::init();
  SoOffscreenRenderer * r = new SoOffscreenRenderer(*(new SbViewportRegion));
  int num = r-&gt;getNumWriteFiletypes();

  if (num == 0) {
    (void)fprintf(stdout,
                  "No image formats supported by the "
                  "SoOffscreenRenderer except SGI RGB and Postscript.\n");
  }
  else {
    for (int i=0; i &lt; num; i++) {
      SbPList extlist;
      SbString fullname, description;
      r-&gt;getWriteFiletypeInfo(i, extlist, fullname, description);
      (void)fprintf(stdout, "%s: %s (extension%s: ",
                    fullname.getString(), description.getString(),
                    extlist.getLength() &gt; 1 ? "s" : "");
      for (int j=0; j &lt; extlist.getLength(); j++) {
        (void)fprintf(stdout, "%s%s", j&gt;0 ? ", " : "", (const char*) extlist[j]);
      }
      (void)fprintf(stdout, ")\n");
    }
  }

  delete r;
  return 0;
}
</pre>
<p><strong>See also:</strong></p><p><strong>getNumWriteFiletypes()</strong>, <strong>writeToFile()</strong></p><p><strong>Since:</strong></p><p>Coin 2.3</p>
<h3>SbBool SoOffscreenRenderer::writeToFile (const \fBSbString\fP &filename, const \fBSbName\fP &filetypeextension) const</h3>
<p>Saves the buffer to <em>filename</em>, in the filetype specified by <em>filetypeextensions</em>.</p><p>Note that you must still specify the <em>full</em> <em>filename</em> for the first argument, i.e. the second argument will not automatically be attached to the filename -- it is only used to decide the filetype.</p><p>This method is an extension versus the orignal SGI Open Inventor API.</p><p><strong>See also:</strong></p><p><strong>isWriteSupported()</strong></p>
<h3>void SoOffscreenRenderer::setPbufferEnable (SbBoolenable)</h3>
<p>Control whether or not <strong>SoOffscreenRenderer</strong> can use the 'pbuffer' feature of OpenGL to render the scenes with hardware acceleration.</p><p>This is a dummy function in Coin, provided for API compatibility reasons, as it is really superfluous:</p><p>Coin has internal heuristics to figure out if pbuffers are available and can be allocated and used for the <strong>SoOffscreenRenderer</strong>. The <strong>SoOffscreenRenderer</strong> will also automatically fall back on 'soft' buffers if it can not use pbuffers (or any other hardware accelerated rendering technique).</p><p><strong>Since:</strong></p><p>Coin 3.1</p>
<h3>SbBool SoOffscreenRenderer::getPbufferEnable (void) const</h3>
<p>See <strong>SoOffscreenRenderer::setPbufferEnable()</strong>.</p><p><strong>Since:</strong></p><p>Coin 3.1</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for Coin from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="SoNurbsSurface.3.html"><span aria-hidden="true">&larr;</span> SoNurbsSurface.3: The sonurbssurface class is used to render smooth surfaces.  a general explanation of nurbs is beyond the scope of the coin documentation. for detailed information, refer to the specialized literature on the topic (for example 'an introduction to nurbs: with historical perspective' by david f. rogers). a basic overview of curve and surface rendering using nurbs can be found in chapter 8 of 'the inventor mentor'.</a></li>
   <li class="next"><a href="SoOnOff.3.html">SoOnOff.3: The soonoff engine is a simple on/off switch. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

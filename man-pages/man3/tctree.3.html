<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>tctree: The utility api</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The utility api">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="tctree (3) manual">
  <meta name="twitter:description" content="The utility api">
  <meta name="twitter:image" content="https://www.carta.tech/images/libtokyocabinet-dev-tctree-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/tctree.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="tctree (3) manual" />
  <meta property="og:description" content="The utility api" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libtokyocabinet-dev-tctree-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">tctree<small> (3)</small></h1>
        <p class="lead">The utility api</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/tctree.3.html">
      <span itemprop="name">tctree: The utility api</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libtokyocabinet-dev/">
      <span itemprop="name">libtokyocabinet-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/tctree.3.html">
      <span itemprop="name">tctree: The utility api</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The utility API is a set of routines to handle records on memory easily.  Especially, extensible string, array list, hash map, and ordered tree are useful.</p><p>To use the utility API, include `<strong>tcutil.h</strong>' and related standard header files.  Usually, write the following description near the front of a source file.</p><p><strong>#include &lt;tcutil.h&gt;</strong></p><p><strong>#include &lt;stdlib.h&gt;</strong></p><p><strong>#include &lt;time.h&gt;</strong></p><p><strong>#include &lt;stdbool.h&gt;</strong></p><p><strong>#include &lt;stdint.h&gt;</strong></p><p>Objects whose type is pointer to `<strong>TCXSTR</strong>' are used for extensible string.  An extensible string object is created with the function `<strong>tcxstrnew</strong>' and is deleted with the function `<strong>tcxstrdel</strong>'.  Objects whose type is pointer to `<strong>TCLIST</strong>' are used for array list.  A list object is created with the function `<strong>tclistnew</strong>' and is deleted with the function `<strong>tclistdel</strong>'.  Objects whose type is pointer to `<strong>TCMAP</strong>' are used for hash map.  A map object is created with the function `<strong>tcmapnew</strong>' and is deleted with the function `<strong>tcmapdel</strong>'.  Objects whose type is pointer to `<strong>TCTREE</strong>' are used for ordered tree.  A tree object is created with the function `<strong>tctreenew</strong>' and is deleted with the function `<strong>tctreedel</strong>'.  To avoid memory leak, it is important to delete every object when it is no longer in use.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">API OF BASIC UTILITIES</h2>
        <div class="sectioncontent">
<p>The constant `tcversion' is the string containing the version information.</p><p><strong>extern const char *tcversion;</strong></p><p>The variable `tcfatalfunc' is the pointer to the call back function for handling a fatal error.</p><p><strong>extern void (*tcfatalfunc)(const char *);</strong></p><p>The argument specifies the error message.</p><p>The initial value of this variable is `NULL'.  If the value is `NULL', the default function is called when a fatal error occurs.  A fatal error occurs when memory allocation is failed.</p><p>The function `tcmalloc' is used in order to allocate a region on memory.</p><p><strong>void *tcmalloc(size_t </strong><em>size</em><strong>);</strong></p><p>`<em>size</em>' specifies the size of the region.</p><p>The return value is the pointer to the allocated region.</p><p>This function handles failure of memory allocation implicitly.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</p><p>The function `tccalloc' is used in order to allocate a nullified region on memory.</p><p><strong>void *tccalloc(size_t </strong><em>nmemb</em><strong>, size_t </strong><em>size</em><strong>);</strong></p><p>`<em>nmemb</em>' specifies the number of elements.</p><p>`<em>size</em>' specifies the size of each element.</p><p>The return value is the pointer to the allocated nullified region.</p><p>This function handles failure of memory allocation implicitly.  Because the region of the return value is allocated with the `calloc' call, it should be released with the `free' call when it is no longer in use.</p><p>The function `tcrealloc' is used in order to re-allocate a region on memory.</p><p><strong>void *tcrealloc(void *</strong><em>ptr</em><strong>, size_t </strong><em>size</em><strong>);</strong></p><p>`<em>ptr</em>' specifies the pointer to the region.</p><p>`<em>size</em>' specifies the size of the region.</p><p>The return value is the pointer to the re-allocated region.</p><p>This function handles failure of memory allocation implicitly.  Because the region of the return value is allocated with the `realloc' call, it should be released with the `free' call when it is no longer in use.</p><p>The function `tcmemdup' is used in order to duplicate a region on memory.</p><p><strong>void *tcmemdup(const void *</strong><em>ptr</em><strong>, size_t </strong><em>size</em><strong>);</strong></p><p>`<em>ptr</em>' specifies the pointer to the region.</p><p>`<em>size</em>' specifies the size of the region.</p><p>The return value is the pointer to the allocated region of the duplicate.</p><p>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</p><p>The function `tcstrdup' is used in order to duplicate a string on memory.</p><p><strong>char *tcstrdup(const void *</strong><em>str</em><strong>);</strong></p><p>`<em>str</em>' specifies the string.</p><p>The return value is the allocated string equivalent to the specified string.</p><p>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</p><p>The function `tcfree' is used in order to free a region on memory.</p><p><strong>void tcfree(void *</strong><em>ptr</em><strong>);</strong></p><p>`<em>ptr</em>' specifies the pointer to the region.  If it is `NULL', this function has no effect.</p><p>Although this function is just a wrapper of `free' call, this is useful in applications using another package of the `malloc' series.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">API OF EXTENSIBLE STRING</h2>
        <div class="sectioncontent">
<p>The function `tcxstrnew' is used in order to create an extensible string object.</p><p><strong>TCXSTR *tcxstrnew(void);</strong></p><p>The return value is the new extensible string object.</p><p>The function `tcxstrnew2' is used in order to create an extensible string object from a character string.</p><p><strong>TCXSTR *tcxstrnew2(const char *</strong><em>str</em><strong>);</strong></p><p>`<em>str</em>' specifies the string of the initial content.</p><p>The return value is the new extensible string object containing the specified string.</p><p>The function `tcxstrnew3' is used in order to create an extensible string object with the initial allocation size.</p><p><strong>TCXSTR *tcxstrnew3(int </strong><em>asiz</em><strong>);</strong></p><p>`<em>asiz</em>' specifies the initial allocation size.</p><p>The return value is the new extensible string object.</p><p>The function `tcxstrdup' is used in order to copy an extensible string object.</p><p><strong>TCXSTR *tcxstrdup(const TCXSTR *</strong><em>xstr</em><strong>);</strong></p><p>`<em>xstr</em>' specifies the extensible string object.</p><p>The return value is the new extensible string object equivalent to the specified object.</p><p>The function `tcxstrdel' is used in order to delete an extensible string object.</p><p><strong>void tcxstrdel(TCXSTR *</strong><em>xstr</em><strong>);</strong></p><p>`<em>xstr</em>' specifies the extensible string object.</p><p>Note that the deleted object and its derivatives can not be used anymore.</p><p>The function `tcxstrcat' is used in order to concatenate a region to the end of an extensible string object.</p><p><strong>void tcxstrcat(TCXSTR *</strong><em>xstr</em><strong>, const void *</strong><em>ptr</em><strong>, int </strong><em>size</em><strong>);</strong></p><p>`<em>xstr</em>' specifies the extensible string object.</p><p>`<em>ptr</em>' specifies the pointer to the region to be appended.</p><p>`<em>size</em>' specifies the size of the region.</p><p>The function `tcxstrcat2' is used in order to concatenate a character string to the end of an extensible string object.</p><p><strong>void tcxstrcat2(TCXSTR *</strong><em>xstr</em><strong>, const char *</strong><em>str</em><strong>);</strong></p><p>`<em>xstr</em>' specifies the extensible string object.</p><p>`<em>str</em>' specifies the string to be appended.</p><p>The function `tcxstrptr' is used in order to get the pointer of the region of an extensible string object.</p><p><strong>const void *tcxstrptr(const TCXSTR *</strong><em>xstr</em><strong>);</strong></p><p>`<em>xstr</em>' specifies the extensible string object.</p><p>The return value is the pointer of the region of the object.</p><p>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.</p><p>The function `tcxstrsize' is used in order to get the size of the region of an extensible string object.</p><p><strong>int tcxstrsize(const TCXSTR *</strong><em>xstr</em><strong>);</strong></p><p>`<em>xstr</em>' specifies the extensible string object.</p><p>The return value is the size of the region of the object.</p><p>The function `tcxstrclear' is used in order to clear an extensible string object.</p><p><strong>void tcxstrclear(TCXSTR *</strong><em>xstr</em><strong>);</strong></p><p>`<em>xstr</em>' specifies the extensible string object.</p><p>The internal buffer of the object is cleared and the size is set zero.</p><p>The function `tcxstrprintf' is used in order to perform formatted output into an extensible string object.</p><p><strong>void tcxstrprintf(TCXSTR *</strong><em>xstr</em><strong>, const char *</strong><em>format</em><strong>, ...);</strong></p><p>`<em>xstr</em>' specifies the extensible string object.</p><p>`<em>format</em>' specifies the printf-like format string.  The conversion character `%' can be used with such flag characters as `s', `d', `o', `u', `x', `X', `c', `e', `E', `f', `g', `G', `@', `?', `b', and `%'.  `@' works as with `s' but escapes meta characters of XML.  `?' works as with `s' but escapes meta characters of URL.  `b' converts an integer to the string as binary numbers.  The other conversion character work as with each original.</p><p>The other arguments are used according to the format string.</p><p>The function `tcsprintf' is used in order to allocate a formatted string on memory.</p><p><strong>char *tcsprintf(const char *</strong><em>format</em><strong>, ...);</strong></p><p>`<em>format</em>' specifies the printf-like format string.  The conversion character `%' can be used with such flag characters as `s', `d', `o', `u', `x', `X', `c', `e', `E', `f', `g', `G', `@', `?', `b', and `%'.  `@' works as with `s' but escapes meta characters of XML.  `?' works as with `s' but escapes meta characters of URL.  `b' converts an integer to the string as binary numbers.  The other conversion character work as with each original.</p><p>The other arguments are used according to the format string.</p><p>The return value is the pointer to the region of the result string.</p><p>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">API OF ARRAY LIST</h2>
        <div class="sectioncontent">
<p>The function `tclistnew' is used in order to create a list object.</p><p><strong>TCLIST *tclistnew(void);</strong></p><p>The return value is the new list object.</p><p>The function `tclistnew2' is used in order to create a list object with expecting the number of elements.</p><p><strong>TCLIST *tclistnew2(int </strong><em>anum</em><strong>);</strong></p><p>`<em>anum</em>' specifies the number of elements expected to be stored in the list.</p><p>The return value is the new list object.</p><p>The function `tclistnew3' is used in order to create a list object with initial string elements.</p><p><strong>TCLIST *tclistnew3(const char *</strong><em>str</em><strong>, ...);</strong></p><p>`<em>str</em>' specifies the string of the first element.</p><p>The other arguments are other elements.  They should be trailed by a `NULL' argument.</p><p>The return value is the new list object.</p><p>The function `tclistdup' is used in order to copy a list object.</p><p><strong>TCLIST *tclistdup(const TCLIST *</strong><em>list</em><strong>);</strong></p><p>`<em>list</em>' specifies the list object.</p><p>The return value is the new list object equivalent to the specified object.</p><p>The function `tclistdel' is used in order to delete a list object.</p><p><strong>void tclistdel(TCLIST *</strong><em>list</em><strong>);</strong></p><p>`<em>list</em>' specifies the list object.</p><p>Note that the deleted object and its derivatives can not be used anymore.</p><p>The function `tclistnum' is used in order to get the number of elements of a list object.</p><p><strong>int tclistnum(const TCLIST *</strong><em>list</em><strong>);</strong></p><p>`<em>list</em>' specifies the list object.</p><p>The return value is the number of elements of the list.</p><p>The function `tclistval' is used in order to get the pointer to the region of an element of a list object.</p><p><strong>const void *tclistval(const TCLIST *</strong><em>list</em><strong>, int </strong><em>index</em><strong>, int *</strong><em>sp</em><strong>);</strong></p><p>`<em>list</em>' specifies the list object.</p><p>`<em>index</em>' specifies the index of the element.</p><p>`<em>sp</em>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</p><p>The return value is the pointer to the region of the value.</p><p>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  If `index' is equal to or more than the number of elements, the return value is `NULL'.</p><p>The function `tclistval2' is used in order to get the string of an element of a list object.</p><p><strong>const char *tclistval2(const TCLIST *</strong><em>list</em><strong>, int </strong><em>index</em><strong>);</strong></p><p>`<em>list</em>' specifies the list object.</p><p>`<em>index</em>' specifies the index of the element.</p><p>The return value is the string of the value.</p><p>If `index' is equal to or more than the number of elements, the return value is `NULL'.</p><p>The function `tclistpush' is used in order to add an element at the end of a list object.</p><p><strong>void tclistpush(TCLIST *</strong><em>list</em><strong>, const void *</strong><em>ptr</em><strong>, int </strong><em>size</em><strong>);</strong></p><p>`<em>list</em>' specifies the list object.</p><p>`<em>ptr</em>' specifies the pointer to the region of the new element.</p><p>`<em>size</em>' specifies the size of the region.</p><p>The function `tclistpush2' is used in order to add a string element at the end of a list object.</p><p><strong>void tclistpush2(TCLIST *</strong><em>list</em><strong>, const char *</strong><em>str</em><strong>);</strong></p><p>`<em>list</em>' specifies the list object.</p><p>`<em>str</em>' specifies the string of the new element.</p><p>The function `tclistpop' is used in order to remove an element of the end of a list object.</p><p><strong>void *tclistpop(TCLIST *</strong><em>list</em><strong>, int *</strong><em>sp</em><strong>);</strong></p><p>`<em>list</em>' specifies the list object.</p><p>`<em>sp</em>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</p><p>The return value is the pointer to the region of the removed element.</p><p>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  If the list is empty, the return value is `NULL'.</p><p>The function `tclistpop2' is used in order to remove a string element of the end of a list object.</p><p><strong>char *tclistpop2(TCLIST *</strong><em>list</em><strong>);</strong></p><p>`<em>list</em>' specifies the list object.</p><p>The return value is the string of the removed element.</p><p>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  If the list is empty, the return value is `NULL'.</p><p>The function `tclistunshift' is used in order to add an element at the top of a list object.</p><p><strong>void tclistunshift(TCLIST *</strong><em>list</em><strong>, const void *</strong><em>ptr</em><strong>, int </strong><em>size</em><strong>);</strong></p><p>`<em>list</em>' specifies the list object.</p><p>`<em>ptr</em>' specifies the pointer to the region of the new element.</p><p>`<em>size</em>' specifies the size of the region.</p><p>The function `tclistunshift2' is used in order to add a string element at the top of a list object.</p><p><strong>void tclistunshift2(TCLIST *</strong><em>list</em><strong>, const char *</strong><em>str</em><strong>);</strong></p><p>`<em>list</em>' specifies the list object.</p><p>`<em>str</em>' specifies the string of the new element.</p><p>The function `tclistshift' is used in order to remove an element of the top of a list object.</p><p><strong>void *tclistshift(TCLIST *</strong><em>list</em><strong>, int *</strong><em>sp</em><strong>);</strong></p><p>`<em>list</em>' specifies the list object.</p><p>`<em>sp</em>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</p><p>The return value is the pointer to the region of the removed element.</p><p>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  If the list is empty, the return value is `NULL'.</p><p>The function `tclistshift2' is used in order to remove a string element of the top of a list object.</p><p><strong>char *tclistshift2(TCLIST *</strong><em>list</em><strong>);</strong></p><p>`<em>list</em>' specifies the list object.</p><p>The return value is the string of the removed element.</p><p>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  If the list is empty, the return value is `NULL'.</p><p>The function `tclistinsert' is used in order to add an element at the specified location of a list object.</p><p><strong>void tclistinsert(TCLIST *</strong><em>list</em><strong>, int </strong><em>index</em><strong>, const void *</strong><em>ptr</em><strong>, int </strong><em>size</em><strong>);</strong></p><p>`<em>list</em>' specifies the list object.</p><p>`<em>index</em>' specifies the index of the new element.</p><p>`<em>ptr</em>' specifies the pointer to the region of the new element.</p><p>`<em>size</em>' specifies the size of the region.</p><p>If `index' is equal to or more than the number of elements, this function has no effect.</p><p>The function `tclistinsert2' is used in order to add a string element at the specified location of a list object.</p><p><strong>void tclistinsert2(TCLIST *</strong><em>list</em><strong>, int </strong><em>index</em><strong>, const char *</strong><em>str</em><strong>);</strong></p><p>`<em>list</em>' specifies the list object.</p><p>`<em>index</em>' specifies the index of the new element.</p><p>`<em>str</em>' specifies the string of the new element.</p><p>If `index' is equal to or more than the number of elements, this function has no effect.</p><p>The function `tclistremove' is used in order to remove an element at the specified location of a list object.</p><p><strong>void *tclistremove(TCLIST *</strong><em>list</em><strong>, int </strong><em>index</em><strong>, int *</strong><em>sp</em><strong>);</strong></p><p>`<em>list</em>' specifies the list object.</p><p>`<em>index</em>' specifies the index of the element to be removed.</p><p>`<em>sp</em>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</p><p>The return value is the pointer to the region of the removed element.</p><p>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  If `index' is equal to or more than the number of elements, no element is removed and the return value is `NULL'.</p><p>The function `tclistremove2' is used in order to remove a string element at the specified location of a list object.</p><p><strong>char *tclistremove2(TCLIST *</strong><em>list</em><strong>, int </strong><em>index</em><strong>);</strong></p><p>`<em>list</em>' specifies the list object.</p><p>`<em>index</em>' specifies the index of the element to be removed.</p><p>The return value is the string of the removed element.</p><p>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  If `index' is equal to or more than the number of elements, no element is removed and the return value is `NULL'.</p><p>The function `tclistover' is used in order to overwrite an element at the specified location of a list object.</p><p><strong>void tclistover(TCLIST *</strong><em>list</em><strong>, int </strong><em>index</em><strong>, const void *</strong><em>ptr</em><strong>, int </strong><em>size</em><strong>);</strong></p><p>`<em>list</em>' specifies the list object.</p><p>`<em>index</em>' specifies the index of the element to be overwritten.</p><p>`<em>ptr</em>' specifies the pointer to the region of the new content.</p><p>`<em>size</em>' specifies the size of the new content.</p><p>If `index' is equal to or more than the number of elements, this function has no effect.</p><p>The function `tclistover2' is used in order to overwrite a string element at the specified location of a list object.</p><p><strong>void tclistover2(TCLIST *</strong><em>list</em><strong>, int </strong><em>index</em><strong>, const char *</strong><em>str</em><strong>);</strong></p><p>`<em>list</em>' specifies the list object.</p><p>`<em>index</em>' specifies the index of the element to be overwritten.</p><p>`<em>str</em>' specifies the string of the new content.</p><p>If `index' is equal to or more than the number of elements, this function has no effect.</p><p>The function `tclistsort' is used in order to sort elements of a list object in lexical order.</p><p><strong>void tclistsort(TCLIST *</strong><em>list</em><strong>);</strong></p><p>`<em>list</em>' specifies the list object.</p><p>The function `tclistlsearch' is used in order to search a list object for an element using liner search.</p><p><strong>int tclistlsearch(const TCLIST *</strong><em>list</em><strong>, const void *</strong><em>ptr</em><strong>, int </strong><em>size</em><strong>);</strong></p><p>`<em>list</em>' specifies the list object.</p><p>`<em>ptr</em>' specifies the pointer to the region of the key.</p><p>`<em>size</em>' specifies the size of the region.</p><p>The return value is the index of a corresponding element or -1 if there is no corresponding element.</p><p>If two or more elements correspond, the former returns.</p><p>The function `tclistbsearch' is used in order to search a list object for an element using binary search.</p><p><strong>int tclistbsearch(const TCLIST *</strong><em>list</em><strong>, const void *</strong><em>ptr</em><strong>, int </strong><em>size</em><strong>);</strong></p><p>`<em>list</em>' specifies the list object.  It should be sorted in lexical order.</p><p>`<em>ptr</em>' specifies the pointer to the region of the key.</p><p>`<em>size</em>' specifies the size of the region.</p><p>The return value is the index of a corresponding element or -1 if there is no corresponding element.</p><p>If two or more elements correspond, which returns is not defined.</p><p>The function `tclistclear' is used in order to clear a list object.</p><p><strong>void tclistclear(TCLIST *</strong><em>list</em><strong>);</strong></p><p>`<em>list</em>' specifies the list object.</p><p>All elements are removed.</p><p>The function `tclistdump' is used in order to serialize a list object into a byte array.</p><p><strong>void *tclistdump(const TCLIST *</strong><em>list</em><strong>, int *</strong><em>sp</em><strong>);</strong></p><p>`<em>list</em>' specifies the list object.</p><p>`<em>sp</em>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</p><p>The return value is the pointer to the region of the result serial region.</p><p>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</p><p>The function `tclistload' is used in order to create a list object from a serialized byte array.</p><p><strong>TCLIST *tclistload(const void *</strong><em>ptr</em><strong>, int </strong><em>size</em><strong>);</strong></p><p>`<em>ptr</em>' specifies the pointer to the region of serialized byte array.</p><p>`<em>size</em>' specifies the size of the region.</p><p>The return value is a new list object.</p><p>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">API OF HASH MAP</h2>
        <div class="sectioncontent">
<p>The function `tcmapnew' is used in order to create a map object.</p><p><strong>TCMAP *tcmapnew(void);</strong></p><p>The return value is the new map object.</p><p>The function `tcmapnew2' is used in order to create a map object with specifying the number of the buckets.</p><p><strong>TCMAP *tcmapnew2(uint32_t </strong><em>bnum</em><strong>);</strong></p><p>`<em>bnum</em>' specifies the number of the buckets.</p><p>The return value is the new map object.</p><p>The function `tcmapnew3' is used in order to create a map object with initial string elements.</p><p><strong>TCMAP *tcmapnew3(const char *</strong><em>str</em><strong>, ...);</strong></p><p>`<em>str</em>' specifies the string of the first element.</p><p>The other arguments are other elements.  They should be trailed by a `NULL' argument.</p><p>The return value is the new map object.</p><p>The key and the value of each record are situated one after the other.</p><p>The function `tcmapdup' is used in order to copy a map object.</p><p><strong>TCMAP *tcmapdup(const TCMAP *</strong><em>map</em><strong>);</strong></p><p>`<em>map</em>' specifies the map object.</p><p>The return value is the new map object equivalent to the specified object.</p><p>The function `tcmapdel' is used in order to delete a map object.</p><p><strong>void tcmapdel(TCMAP *</strong><em>map</em><strong>);</strong></p><p>`<em>map</em>' specifies the map object.</p><p>Note that the deleted object and its derivatives can not be used anymore.</p><p>The function `tcmapput' is used in order to store a record into a map object.</p><p><strong>void tcmapput(TCMAP *</strong><em>map</em><strong>, const void *</strong><em>kbuf</em><strong>, int </strong><em>ksiz</em><strong>, const void *</strong><em>vbuf</em><strong>, int </strong><em>vsiz</em><strong>);</strong></p><p>`<em>map</em>' specifies the map object.</p><p>`<em>kbuf</em>' specifies the pointer to the region of the key.</p><p>`<em>ksiz</em>' specifies the size of the region of the key.</p><p>`<em>vbuf</em>' specifies the pointer to the region of the value.</p><p>`<em>vsiz</em>' specifies the size of the region of the value.</p><p>If a record with the same key exists in the map, it is overwritten.</p><p>The function `tcmapput2' is used in order to store a string record into a map object.</p><p><strong>void tcmapput2(TCMAP *</strong><em>map</em><strong>, const char *</strong><em>kstr</em><strong>, const char *</strong><em>vstr</em><strong>);</strong></p><p>`<em>map</em>' specifies the map object.</p><p>`<em>kstr</em>' specifies the string of the key.</p><p>`<em>vstr</em>' specifies the string of the value.</p><p>If a record with the same key exists in the map, it is overwritten.</p><p>The function `tcmapputkeep' is used in order to store a new record into a map object.</p><p><strong>bool tcmapputkeep(TCMAP *</strong><em>map</em><strong>, const void *</strong><em>kbuf</em><strong>, int </strong><em>ksiz</em><strong>, const void *</strong><em>vbuf</em><strong>, int </strong><em>vsiz</em><strong>);</strong></p><p>`<em>map</em>' specifies the map object.</p><p>`<em>kbuf</em>' specifies the pointer to the region of the key.</p><p>`<em>ksiz</em>' specifies the size of the region of the key.</p><p>`<em>vbuf</em>' specifies the pointer to the region of the value.</p><p>`<em>vsiz</em>' specifies the size of the region of the value.</p><p>If successful, the return value is true, else, it is false.</p><p>If a record with the same key exists in the map, this function has no effect.</p><p>The function `tcmapputkeep2' is used in order to store a new string record into a map object.</p><p><strong>bool tcmapputkeep2(TCMAP *</strong><em>map</em><strong>, const char *</strong><em>kstr</em><strong>, const char *</strong><em>vstr</em><strong>);</strong></p><p>`<em>map</em>' specifies the map object.</p><p>`<em>kstr</em>' specifies the string of the key.</p><p>`<em>vstr</em>' specifies the string of the value.</p><p>If successful, the return value is true, else, it is false.</p><p>If a record with the same key exists in the map, this function has no effect.</p><p>The function `tcmapputcat' is used in order to concatenate a value at the end of the value of the existing record in a map object.</p><p><strong>void tcmapputcat(TCMAP *</strong><em>map</em><strong>, const void *</strong><em>kbuf</em><strong>, int </strong><em>ksiz</em><strong>, const void *</strong><em>vbuf</em><strong>, int </strong><em>vsiz</em><strong>);</strong></p><p>`<em>map</em>' specifies the map object.</p><p>`<em>kbuf</em>' specifies the pointer to the region of the key.</p><p>`<em>ksiz</em>' specifies the size of the region of the key.</p><p>`<em>vbuf</em>' specifies the pointer to the region of the value.</p><p>`<em>vsiz</em>' specifies the size of the region of the value.</p><p>If there is no corresponding record, a new record is created.</p><p>The function `tcmapputcat2' is used in order to concatenate a string value at the end of the value of the existing record in a map object.</p><p><strong>void tcmapputcat2(TCMAP *</strong><em>map</em><strong>, const char *</strong><em>kstr</em><strong>, const char *</strong><em>vstr</em><strong>);</strong></p><p>`<em>map</em>' specifies the map object.</p><p>`<em>kstr</em>' specifies the string of the key.</p><p>`<em>vstr</em>' specifies the string of the value.</p><p>If there is no corresponding record, a new record is created.</p><p>The function `tcmapout' is used in order to remove a record of a map object.</p><p><strong>bool tcmapout(TCMAP *</strong><em>map</em><strong>, const void *</strong><em>kbuf</em><strong>, int </strong><em>ksiz</em><strong>);</strong></p><p>`<em>map</em>' specifies the map object.</p><p>`<em>kbuf</em>' specifies the pointer to the region of the key.</p><p>`<em>ksiz</em>' specifies the size of the region of the key.</p><p>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</p><p>The function `tcmapout2' is used in order to remove a string record of a map object.</p><p><strong>bool tcmapout2(TCMAP *</strong><em>map</em><strong>, const char *</strong><em>kstr</em><strong>);</strong></p><p>`<em>map</em>' specifies the map object.</p><p>`<em>kstr</em>' specifies the string of the key.</p><p>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</p><p>The function `tcmapget' is used in order to retrieve a record in a map object.</p><p><strong>const void *tcmapget(const TCMAP *</strong><em>map</em><strong>, const void *</strong><em>kbuf</em><strong>, int </strong><em>ksiz</em><strong>, int *</strong><em>sp</em><strong>);</strong></p><p>`<em>map</em>' specifies the map object.</p><p>`<em>kbuf</em>' specifies the pointer to the region of the key.</p><p>`<em>ksiz</em>' specifies the size of the region of the key.</p><p>`<em>sp</em>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</p><p>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned when no record corresponds.</p><p>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.</p><p>The function `tcmapget2' is used in order to retrieve a string record in a map object.</p><p><strong>const char *tcmapget2(const TCMAP *</strong><em>map</em><strong>, const char *</strong><em>kstr</em><strong>);</strong></p><p>`<em>map</em>' specifies the map object.</p><p>`<em>kstr</em>' specifies the string of the key.</p><p>If successful, the return value is the string of the value of the corresponding record.  `NULL' is returned when no record corresponds.</p><p>The function `tcmapmove' is used in order to move a record to the edge of a map object.</p><p><strong>bool tcmapmove(TCMAP *</strong><em>map</em><strong>, const void *</strong><em>kbuf</em><strong>, int </strong><em>ksiz</em><strong>, bool </strong><em>head</em><strong>);</strong></p><p>`<em>map</em>' specifies the map object.</p><p>`<em>kbuf</em>' specifies the pointer to the region of a key.</p><p>`<em>ksiz</em>' specifies the size of the region of the key.</p><p>`<em>head</em>' specifies the destination which is the head if it is true or the tail if else.</p><p>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</p><p>The function `tcmapmove2' is used in order to move a string record to the edge of a map object.</p><p><strong>bool tcmapmove2(TCMAP *</strong><em>map</em><strong>, const char *</strong><em>kstr</em><strong>, bool </strong><em>head</em><strong>);</strong></p><p>`<em>map</em>' specifies the map object.</p><p>`<em>kstr</em>' specifies the string of a key.</p><p>`<em>head</em>' specifies the destination which is the head if it is true or the tail if else.</p><p>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</p><p>The function `tcmapiterinit' is used in order to initialize the iterator of a map object.</p><p><strong>void tcmapiterinit(TCMAP *</strong><em>map</em><strong>);</strong></p><p>`<em>map</em>' specifies the map object.</p><p>The iterator is used in order to access the key of every record stored in the map object.</p><p>The function `tcmapiternext' is used in order to get the next key of the iterator of a map object.</p><p><strong>const void *tcmapiternext(TCMAP *</strong><em>map</em><strong>, int *</strong><em>sp</em><strong>);</strong></p><p>`<em>map</em>' specifies the map object.</p><p>`<em>sp</em>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</p><p>If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record can be fetched from the iterator.</p><p>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  The order of iteration is assured to be the same as the stored order.</p><p>The function `tcmapiternext2' is used in order to get the next key string of the iterator of a map object.</p><p><strong>const char *tcmapiternext2(TCMAP *</strong><em>map</em><strong>);</strong></p><p>`<em>map</em>' specifies the map object.</p><p>If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record can be fetched from the iterator.</p><p>The order of iteration is assured to be the same as the stored order.</p><p>The function `tcmaprnum' is used in order to get the number of records stored in a map object.</p><p><strong>uint64_t tcmaprnum(const TCMAP *</strong><em>map</em><strong>);</strong></p><p>`<em>map</em>' specifies the map object.</p><p>The return value is the number of the records stored in the map object.</p><p>The function `tcmapmsiz' is used in order to get the total size of memory used in a map object.</p><p><strong>uint64_t tcmapmsiz(const TCMAP *</strong><em>map</em><strong>);</strong></p><p>`<em>map</em>' specifies the map object.</p><p>The return value is the total size of memory used in a map object.</p><p>The function `tcmapkeys' is used in order to create a list object containing all keys in a map object.</p><p><strong>TCLIST *tcmapkeys(const TCMAP *</strong><em>map</em><strong>);</strong></p><p>`<em>map</em>' specifies the map object.</p><p>The return value is the new list object containing all keys in the map object.</p><p>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</p><p>The function `tcmapvals' is used in order to create a list object containing all values in a map object.</p><p><strong>TCLIST *tcmapvals(const TCMAP *</strong><em>map</em><strong>);</strong></p><p>`<em>map</em>' specifies the map object.</p><p>The return value is the new list object containing all values in the map object.</p><p>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</p><p>The function `tcmapaddint' is used in order to add an integer to a record in a map object.</p><p><strong>int tcmapaddint(TCMAP *</strong><em>map</em><strong>, const void *</strong><em>kbuf</em><strong>, int </strong><em>ksiz</em><strong>, int </strong><em>num</em><strong>);</strong></p><p>`<em>map</em>' specifies the map object.</p><p>`<em>kbuf</em>' specifies the pointer to the region of the key.</p><p>`<em>ksiz</em>' specifies the size of the region of the key.</p><p>`<em>num</em>' specifies the additional value.</p><p>The return value is the summation value.</p><p>If the corresponding record exists, the value is treated as an integer and is added to.  If no record corresponds, a new record of the additional value is stored.</p><p>The function `tcmapadddouble' is used in order to add a real number to a record in a map object.</p><p><strong>double tcmapadddouble(TCMAP *</strong><em>map</em><strong>, const void *</strong><em>kbuf</em><strong>, int </strong><em>ksiz</em><strong>, double </strong><em>num</em><strong>);</strong></p><p>`<em>map</em>' specifies the map object.</p><p>`<em>kbuf</em>' specifies the pointer to the region of the key.</p><p>`<em>ksiz</em>' specifies the size of the region of the key.</p><p>`<em>num</em>' specifies the additional value.</p><p>The return value is the summation value.</p><p>If the corresponding record exists, the value is treated as a real number and is added to.  If no record corresponds, a new record of the additional value is stored.</p><p>The function `tcmapclear' is used in order to clear a map object.</p><p><strong>void tcmapclear(TCMAP *</strong><em>map</em><strong>);</strong></p><p>`<em>map</em>' specifies the map object.</p><p>All records are removed.</p><p>The function `tcmapcutfront' is used in order to remove front records of a map object.</p><p><strong>void tcmapcutfront(TCMAP *</strong><em>map</em><strong>, int </strong><em>num</em><strong>);</strong></p><p>`<em>map</em>' specifies the map object.</p><p>`<em>num</em>' specifies the number of records to be removed.</p><p>The function `tcmapdump' is used in order to serialize a map object into a byte array.</p><p><strong>void *tcmapdump(const TCMAP *</strong><em>map</em><strong>, int *</strong><em>sp</em><strong>);</strong></p><p>`<em>map</em>' specifies the map object.</p><p>`<em>sp</em>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</p><p>The return value is the pointer to the region of the result serial region.</p><p>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</p><p>The function `tcmapload' is used in order to create a map object from a serialized byte array.</p><p><strong>TCMAP *tcmapload(const void *</strong><em>ptr</em><strong>, int </strong><em>size</em><strong>);</strong></p><p>`<em>ptr</em>' specifies the pointer to the region of serialized byte array.</p><p>`<em>size</em>' specifies the size of the region.</p><p>The return value is a new map object.</p><p>Because the object of the return value is created with the function `tcmapnew', it should be deleted with the function `tcmapdel' when it is no longer in use.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">API OF ORDERED TREE</h2>
        <div class="sectioncontent">
<p>The function `tctreenew' is used in order to create a tree object.</p><p><strong>TCTREE *tctreenew(void);</strong></p><p>The return value is the new tree object.</p><p>The function `tctreenew2' is used in order to create a tree object with specifying the custom comparison function.</p><p><strong>TCTREE *tctreenew2(TCCMP </strong><em>cmp</em><strong>, void *</strong><em>cmpop</em><strong>);</strong></p><p>`<em>cmp</em>' specifies the pointer to the custom comparison function.  It receives five parameters.  The first parameter is the pointer to the region of one key.  The second parameter is the size of the region of one key.  The third parameter is the pointer to the region of the other key.  The fourth parameter is the size of the region of the other key.  The fifth parameter is the pointer to the optional opaque object.  It returns positive if the former is big, negative if the latter is big, 0 if both are equivalent.</p><p>`<em>cmpop</em>' specifies an arbitrary pointer to be given as a parameter of the comparison function.  If it is not needed, `NULL' can be specified.</p><p>The return value is the new tree object.</p><p>The default comparison function compares keys of two records by lexical order.  The functions `tccmplexical' (default), `tccmpdecimal', `tccmpint32', and `tccmpint64' are built-in.</p><p>The function `tctreedup' is used in order to copy a tree object.</p><p><strong>TCTREE *tctreedup(const TCTREE *</strong><em>tree</em><strong>);</strong></p><p>`<em>tree</em>' specifies the tree object.</p><p>The return value is the new tree object equivalent to the specified object.</p><p>The function `tctreedel' is used in order to delete a tree object.</p><p><strong>void tctreedel(TCTREE *</strong><em>tree</em><strong>);</strong></p><p>`tree' specifies the tree object.</p><p>Note that the deleted object and its derivatives can not be used anymore.</p><p>The function `tctreeput' is used in order to store a record into a tree object.</p><p><strong>void tctreeput(TCTREE *</strong><em>tree</em><strong>, const void *</strong><em>kbuf</em><strong>, int </strong><em>ksiz</em><strong>, const void *</strong><em>vbuf</em><strong>, int </strong><em>vsiz</em><strong>);</strong></p><p>`<em>tree</em>' specifies the tree object.</p><p>`<em>kbuf</em>' specifies the pointer to the region of the key.</p><p>`<em>ksiz</em>' specifies the size of the region of the key.</p><p>`<em>vbuf</em>' specifies the pointer to the region of the value.</p><p>`<em>vsiz</em>' specifies the size of the region of the value.</p><p>If a record with the same key exists in the tree, it is overwritten.</p><p>The function `tctreeput2' is used in order to store a string record into a tree object.</p><p><strong>void tctreeput2(TCTREE *</strong><em>tree</em><strong>, const char *</strong><em>kstr</em><strong>, const char *</strong><em>vstr</em><strong>);</strong></p><p>`<em>tree</em>' specifies the tree object.</p><p>`<em>kstr</em>' specifies the string of the key.</p><p>`<em>vstr</em>' specifies the string of the value.</p><p>If a record with the same key exists in the tree, it is overwritten.</p><p>The function `tctreeputkeep' is used in order to store a new record into a tree object.</p><p><strong>bool tctreeputkeep(TCTREE *</strong><em>tree</em><strong>, const void *</strong><em>kbuf</em><strong>, int </strong><em>ksiz</em><strong>, const void *</strong><em>vbuf</em><strong>, int </strong><em>vsiz</em><strong>);</strong></p><p>`<em>tree</em>' specifies the tree object.</p><p>`<em>kbuf</em>' specifies the pointer to the region of the key.</p><p>`<em>ksiz</em>' specifies the size of the region of the key.</p><p>`<em>vbuf</em>' specifies the pointer to the region of the value.</p><p>`<em>vsiz</em>' specifies the size of the region of the value.</p><p>If successful, the return value is true, else, it is false.</p><p>If a record with the same key exists in the tree, this function has no effect.</p><p>The function `tctreeputkeep2' is used in order to store a new string record into a tree object.</p><p><strong>bool tctreeputkeep2(TCTREE *</strong><em>tree</em><strong>, const char *</strong><em>kstr</em><strong>, const char *</strong><em>vstr</em><strong>);</strong></p><p>`<em>tree</em>' specifies the tree object.</p><p>`<em>kstr</em>' specifies the string of the key.</p><p>`<em>vstr</em>' specifies the string of the value.</p><p>If successful, the return value is true, else, it is false.</p><p>If a record with the same key exists in the tree, this function has no effect.</p><p>The function `tctreeputcat' is used in order to concatenate a value at the end of the value of the existing record in a tree object.</p><p><strong>void tctreeputcat(TCTREE *</strong><em>tree</em><strong>, const void *</strong><em>kbuf</em><strong>, int </strong><em>ksiz</em><strong>, const void *</strong><em>vbuf</em><strong>, int </strong><em>vsiz</em><strong>);</strong></p><p>`<em>tree</em>' specifies the tree object.</p><p>`<em>kbuf</em>' specifies the pointer to the region of the key.</p><p>`<em>ksiz</em>' specifies the size of the region of the key.</p><p>`<em>vbuf</em>' specifies the pointer to the region of the value.</p><p>`<em>vsiz</em>' specifies the size of the region of the value.</p><p>If there is no corresponding record, a new record is created.</p><p>The function `tctreeputcat2' is used in order to concatenate a string value at the end of the value of the existing record in a tree object.</p><p><strong>void tctreeputcat2(TCTREE *</strong><em>tree</em><strong>, const char *</strong><em>kstr</em><strong>, const char *</strong><em>vstr</em><strong>);</strong></p><p>`<em>tree</em>' specifies the tree object.</p><p>`<em>kstr</em>' specifies the string of the key.</p><p>`<em>vstr</em>' specifies the string of the value.</p><p>If there is no corresponding record, a new record is created.</p><p>The function `tctreeout' is used in order to remove a record of a tree object.</p><p><strong>bool tctreeout(TCTREE *</strong><em>tree</em><strong>, const void *</strong><em>kbuf</em><strong>, int </strong><em>ksiz</em><strong>);</strong></p><p>`<em>tree</em>' specifies the tree object.</p><p>`<em>kbuf</em>' specifies the pointer to the region of the key.</p><p>`<em>ksiz</em>' specifies the size of the region of the key.</p><p>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</p><p>The function `tctreeout2' is used in order to remove a string record of a tree object.</p><p><strong>bool tctreeout2(TCTREE *</strong><em>tree</em><strong>, const char *</strong><em>kstr</em><strong>);</strong></p><p>`<em>tree</em>' specifies the tree object.</p><p>`<em>kstr</em>' specifies the string of the key.</p><p>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</p><p>The function `tctreeget' is used in order to retrieve a record in a tree object.</p><p><strong>const void *tctreeget(TCTREE *</strong><em>tree</em><strong>, const void *</strong><em>kbuf</em><strong>, int </strong><em>ksiz</em><strong>, int *</strong><em>sp</em><strong>);</strong></p><p>`<em>tree</em>' specifies the tree object.</p><p>`<em>kbuf</em>' specifies the pointer to the region of the key.</p><p>`<em>ksiz</em>' specifies the size of the region of the key.</p><p>`<em>sp</em>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</p><p>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned when no record corresponds.</p><p>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.</p><p>The function `tctreeget2' is used in order to retrieve a string record in a tree object.</p><p><strong>const char *tctreeget2(TCTREE *</strong><em>tree</em><strong>, const char *</strong><em>kstr</em><strong>);</strong></p><p>`<em>tree</em>' specifies the tree object.</p><p>`<em>kstr</em>' specifies the string of the key.</p><p>If successful, the return value is the string of the value of the corresponding record.  `NULL' is returned when no record corresponds.</p><p>The function `tctreeiterinit' is used in order to initialize the iterator of a tree object.</p><p><strong>void tctreeiterinit(TCTREE *</strong><em>tree</em><strong>);</strong></p><p>`<em>tree</em>' specifies the tree object.</p><p>The iterator is used in order to access the key of every record stored in the tree object.</p><p>The function `tctreeiternext' is used in order to get the next key of the iterator of a tree object.</p><p><strong>const void *tctreeiternext(TCTREE *</strong><em>tree</em><strong>, int *</strong><em>sp</em><strong>);</strong></p><p>`<em>tree</em>' specifies the tree object.</p><p>`<em>sp</em>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</p><p>If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record can be fetched from the iterator.</p><p>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  The order of iteration is assured to be ascending of the keys.</p><p>The function `tctreeiternext2' is used in order to get the next key string of the iterator of a tree object.</p><p><strong>const char *tctreeiternext2(TCTREE *</strong><em>tree</em><strong>);</strong></p><p>`<em>tree</em>' specifies the tree object.</p><p>If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record can be fetched from the iterator.</p><p>The order of iteration is assured to be ascending of the keys.</p><p>The function `tctreernum' is used in order to get the number of records stored in a tree object.</p><p><strong>uint64_t tctreernum(const TCTREE *</strong><em>tree</em><strong>);</strong></p><p>`<em>tree</em>' specifies the tree object.</p><p>The return value is the number of the records stored in the tree object.</p><p>The function `tctreemsiz' is used in order to get the total size of memory used in a tree object.</p><p><strong>uint64_t tctreemsiz(const TCTREE *</strong><em>tree</em><strong>);</strong></p><p>`<em>tree</em>' specifies the tree object.</p><p>The return value is the total size of memory used in a tree object.</p><p>The function `tctreekeys' is used in order to create a list object containing all keys in a tree object.</p><p><strong>TCLIST *tctreekeys(const TCTREE *</strong><em>tree</em><strong>);</strong></p><p>`<em>tree</em>' specifies the tree object.</p><p>The return value is the new list object containing all keys in the tree object.</p><p>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</p><p>The function `tctreevals' is used in order to create a list object containing all values in a tree object.</p><p><strong>TCLIST *tctreevals(const TCTREE *</strong><em>tree</em><strong>);</strong></p><p>`<em>tree</em>' specifies the tree object.</p><p>The return value is the new list object containing all values in the tree object.</p><p>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</p><p>The function `tctreeaddint' is used in order to add an integer to a record in a tree object.</p><p><strong>int tctreeaddint(TCTREE *</strong><em>tree</em><strong>, const void *</strong><em>kbuf</em><strong>, int </strong><em>ksiz</em><strong>, int </strong><em>num</em><strong>);</strong></p><p>`<em>tree</em>' specifies the tree object.</p><p>`<em>kbuf</em>' specifies the pointer to the region of the key.</p><p>`<em>ksiz</em>' specifies the size of the region of the key.</p><p>`<em>num</em>' specifies the additional value.</p><p>The return value is the summation value.</p><p>If the corresponding record exists, the value is treated as an integer and is added to.  If no record corresponds, a new record of the additional value is stored.</p><p>The function `tctreeadddouble' is used in order to add a real number to a record in a tree object.</p><p><strong>double tctreeadddouble(TCTREE *</strong><em>tree</em><strong>, const void *</strong><em>kbuf</em><strong>, int </strong><em>ksiz</em><strong>, double </strong><em>num</em><strong>);</strong></p><p>`<em>tree</em>' specifies the tree object.</p><p>`<em>kbuf</em>' specifies the pointer to the region of the key.</p><p>`<em>ksiz</em>' specifies the size of the region of the key.</p><p>`<em>num</em>' specifies the additional value.</p><p>The return value is the summation value.</p><p>If the corresponding record exists, the value is treated as a real number and is added to.  If no record corresponds, a new record of the additional value is stored.</p><p>The function `tctreeclear' is used in order to clear a tree object.</p><p><strong>void tctreeclear(TCTREE *</strong><em>tree</em><strong>);</strong></p><p>`<em>tree</em>' specifies the tree object.</p><p>All records are removed.</p><p>The function `tctreecutfringe' is used in order to remove fringe records of a tree object.</p><p><strong>void tctreecutfringe(TCTREE *</strong><em>tree</em><strong>, int </strong><em>num</em><strong>);</strong></p><p>`<em>tree</em>' specifies the tree object.</p><p>`<em>num</em>' specifies the number of records to be removed.</p><p>The function `tctreedump' is used in order to serialize a tree object into a byte array.</p><p><strong>void *tctreedump(const TCTREE *</strong><em>tree</em><strong>, int *</strong><em>sp</em><strong>);</strong></p><p>`<em>tree</em>' specifies the tree object.</p><p>`<em>sp</em>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</p><p>The return value is the pointer to the region of the result serial region.</p><p>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</p><p>The function `tctreeload' is used in order to create a tree object from a serialized byte array.</p><p><strong>TCTREE *tctreeload(const void *</strong><em>ptr</em><strong>, int </strong><em>size</em><strong>, TCCMP </strong><em>cmp</em><strong>, void *</strong><em>cmpop</em><strong>);</strong></p><p>`<em>ptr</em>' specifies the pointer to the region of serialized byte array.</p><p>`<em>size</em>' specifies the size of the region.</p><p>`<em>cmp</em>' specifies the pointer to the custom comparison function.</p><p>`<em>cmpop</em>' specifies an arbitrary pointer to be given as a parameter of the comparison function.</p><p>If it is not needed, `NULL' can be specified.</p><p>The return value is a new tree object.</p><p>Because the object of the return value is created with the function `tctreenew', it should be deleted with the function `tctreedel' when it is no longer in use.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">API OF ON-MEMORY HASH DATABASE</h2>
        <div class="sectioncontent">
<p>The function `tcmdbnew' is used in order to create an on-memory hash database object.</p><p><strong>TCMDB *tcmdbnew(void);</strong></p><p>The return value is the new on-memory hash database object.</p><p>The object can be shared by plural threads because of the internal mutex.</p><p>The function `tcmdbnew2' is used in order to create an on-memory hash database object with specifying the number of the buckets.</p><p><strong>TCMDB *tcmdbnew2(uint32_t </strong><em>bnum</em><strong>);</strong></p><p>`<em>bnum</em>' specifies the number of the buckets.</p><p>The return value is the new on-memory hash database object.</p><p>The object can be shared by plural threads because of the internal mutex.</p><p>The function `tcmdbdel' is used in order to delete an on-memory hash database object.</p><p><strong>void tcmdbdel(TCMDB *</strong><em>mdb</em><strong>);</strong></p><p>`<em>mdb</em>' specifies the on-memory hash database object.</p><p>The function `tcmdbput' is used in order to store a record into an on-memory hash database object.</p><p><strong>void tcmdbput(TCMDB *</strong><em>mdb</em><strong>, const void *</strong><em>kbuf</em><strong>, int </strong><em>ksiz</em><strong>, const void *</strong><em>vbuf</em><strong>, int </strong><em>vsiz</em><strong>);</strong></p><p>`<em>mdb</em>' specifies the on-memory hash database object.</p><p>`<em>kbuf</em>' specifies the pointer to the region of the key.</p><p>`<em>ksiz</em>' specifies the size of the region of the key.</p><p>`<em>vbuf</em>' specifies the pointer to the region of the value.</p><p>`<em>vsiz</em>' specifies the size of the region of the value.</p><p>If a record with the same key exists in the database, it is overwritten.</p><p>The function `tcmdbput2' is used in order to store a string record into an on-memory hash database object.</p><p><strong>void tcmdbput2(TCMDB *</strong><em>mdb</em><strong>, const char *</strong><em>kstr</em><strong>, const char *</strong><em>vstr</em><strong>);</strong></p><p>`<em>mdb</em>' specifies the on-memory hash database object.</p><p>`<em>kstr</em>' specifies the string of the key.</p><p>`<em>vstr</em>' specifies the string of the value.</p><p>If a record with the same key exists in the database, it is overwritten.</p><p>The function `tcmdbputkeep' is used in order to store a new record into an on-memory hash database object.</p><p><strong>bool tcmdbputkeep(TCMDB *</strong><em>mdb</em><strong>, const void *</strong><em>kbuf</em><strong>, int </strong><em>ksiz</em><strong>, const void *</strong><em>vbuf</em><strong>, int </strong><em>vsiz</em><strong>);</strong></p><p>`<em>mdb</em>' specifies the on-memory hash database object.</p><p>`<em>kbuf</em>' specifies the pointer to the region of the key.</p><p>`<em>ksiz</em>' specifies the size of the region of the key.</p><p>`<em>vbuf</em>' specifies the pointer to the region of the value.</p><p>`<em>vsiz</em>' specifies the size of the region of the value.</p><p>If successful, the return value is true, else, it is false.</p><p>If a record with the same key exists in the database, this function has no effect.</p><p>The function `tcmdbputkeep2' is used in order to store a new string record into an on-memory hash database object.</p><p><strong>bool tcmdbputkeep2(TCMDB *</strong><em>mdb</em><strong>, const char *</strong><em>kstr</em><strong>, const char *</strong><em>vstr</em><strong>);</strong></p><p>`<em>mdb</em>' specifies the on-memory hash database object.</p><p>`<em>kstr</em>' specifies the string of the key.</p><p>`<em>vstr</em>' specifies the string of the value.</p><p>If successful, the return value is true, else, it is false.</p><p>If a record with the same key exists in the database, this function has no effect.</p><p>The function `tcmdbputcat' is used in order to concatenate a value at the end of the existing record in an on-memory hash database.</p><p><strong>void tcmdbputcat(TCMDB *</strong><em>mdb</em><strong>, const void *</strong><em>kbuf</em><strong>, int </strong><em>ksiz</em><strong>, const void *</strong><em>vbuf</em><strong>, int </strong><em>vsiz</em><strong>);</strong></p><p>`<em>mdb</em>' specifies the on-memory hash database object.</p><p>`<em>kbuf</em>' specifies the pointer to the region of the key.</p><p>`<em>ksiz</em>' specifies the size of the region of the key.</p><p>`<em>vbuf</em>' specifies the pointer to the region of the value.</p><p>`<em>vsiz</em>' specifies the size of the region of the value.</p><p>If there is no corresponding record, a new record is created.</p><p>The function `tcmdbputcat2' is used in order to concatenate a string at the end of the existing record in an on-memory hash database.</p><p><strong>void tcmdbputcat2(TCMDB *</strong><em>mdb</em><strong>, const char *</strong><em>kstr</em><strong>, const char *</strong><em>vstr</em><strong>);</strong></p><p>`<em>mdb</em>' specifies the on-memory hash database object.</p><p>`<em>kstr</em>' specifies the string of the key.</p><p>`<em>vstr</em>' specifies the string of the value.</p><p>If there is no corresponding record, a new record is created.</p><p>The function `tcmdbout' is used in order to remove a record of an on-memory hash database object.</p><p><strong>bool tcmdbout(TCMDB *</strong><em>mdb</em><strong>, const void *</strong><em>kbuf</em><strong>, int </strong><em>ksiz</em><strong>);</strong></p><p>`<em>mdb</em>' specifies the on-memory hash database object.</p><p>`<em>kbuf</em>' specifies the pointer to the region of the key.</p><p>`<em>ksiz</em>' specifies the size of the region of the key.</p><p>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</p><p>The function `tcmdbout2' is used in order to remove a string record of an on-memory hash database object.</p><p><strong>bool tcmdbout2(TCMDB *</strong><em>mdb</em><strong>, const char *</strong><em>kstr</em><strong>);</strong></p><p>`<em>mdb</em>' specifies the on-memory hash database object.</p><p>`<em>kstr</em>' specifies the string of the key.</p><p>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</p><p>The function `tcmdbget' is used in order to retrieve a record in an on-memory hash database object.</p><p><strong>void *tcmdbget(TCMDB *</strong><em>mdb</em><strong>, const void *</strong><em>kbuf</em><strong>, int </strong><em>ksiz</em><strong>, int *</strong><em>sp</em><strong>);</strong></p><p>`<em>mdb</em>' specifies the on-memory hash database object.</p><p>`<em>kbuf</em>' specifies the pointer to the region of the key.</p><p>`<em>ksiz</em>' specifies the size of the region of the key.</p><p>`<em>sp</em>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</p><p>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned when no record corresponds.</p><p>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</p><p>The function `tcmdbget2' is used in order to retrieve a string record in an on-memory hash database object.</p><p><strong>char *tcmdbget2(TCMDB *</strong><em>mdb</em><strong>, const char *</strong><em>kstr</em><strong>);</strong></p><p>`<em>mdb</em>' specifies the on-memory hash database object.</p><p>`<em>kstr</em>' specifies the string of the key.</p><p>If successful, the return value is the string of the value of the corresponding record.  `NULL' is returned when no record corresponds.</p><p>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</p><p>The function `tcmdbvsiz' is used in order to get the size of the value of a record in an on-memory hash database object.</p><p><strong>int tcmdbvsiz(TCMDB *</strong><em>mdb</em><strong>, const void *</strong><em>kbuf</em><strong>, int </strong><em>ksiz</em><strong>);</strong></p><p>`<em>mdb</em>' specifies the on-memory hash database object.</p><p>`<em>kbuf</em>' specifies the pointer to the region of the key.</p><p>`<em>ksiz</em>' specifies the size of the region of the key.</p><p>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</p><p>The function `tcmdbvsiz2' is used in order to get the size of the value of a string record in an on-memory hash database object.</p><p><strong>int tcmdbvsiz2(TCMDB *</strong><em>mdb</em><strong>, const char *</strong><em>kstr</em><strong>);</strong></p><p>`<em>mdb</em>' specifies the on-memory hash database object.</p><p>`<em>kstr</em>' specifies the string of the key.</p><p>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</p><p>The function `tcmdbiterinit' is used in order to initialize the iterator of an on-memory hash database object.</p><p><strong>void tcmdbiterinit(TCMDB *</strong><em>mdb</em><strong>);</strong></p><p>`<em>mdb</em>' specifies the on-memory hash database object.</p><p>The iterator is used in order to access the key of every record stored in the on-memory hash database.</p><p>The function `tcmdbiternext' is used in order to get the next key of the iterator of an on-memory hash database object.</p><p><strong>void *tcmdbiternext(TCMDB *</strong><em>mdb</em><strong>, int *</strong><em>sp</em><strong>);</strong></p><p>`<em>mdb</em>' specifies the on-memory hash database object.</p><p>`<em>sp</em>' specifies the pointer to the variable into which the size of the region of the return</p><p>value is assigned.</p><p>If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record can be fetched from the iterator.</p><p>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  The order of iteration is assured to be the same as the stored order.</p><p>The function `tcmdbiternext2' is used in order to get the next key string of the iterator of an on-memory hash database object.</p><p><strong>char *tcmdbiternext2(TCMDB *</strong><em>mdb</em><strong>);</strong></p><p>`<em>mdb</em>' specifies the on-memory hash database object.</p><p>If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record can be fetched from the iterator.</p><p>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  The order of iteration is assured to be the same as the stored order.</p><p>The function `tcmdbfwmkeys' is used in order to get forward matching keys in an on-memory hash database object.</p><p><strong>TCLIST *tcmdbfwmkeys(TCMDB *</strong><em>mdb</em><strong>, const void *</strong><em>pbuf</em><strong>, int </strong><em>psiz</em><strong>, int </strong><em>max</em><strong>);</strong></p><p>`<em>mdb</em>' specifies the on-memory hash database object.</p><p>`<em>pbuf</em>' specifies the pointer to the region of the prefix.</p><p>`<em>psiz</em>' specifies the size of the region of the prefix.</p><p>`<em>max</em>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</p><p>The return value is a list object of the corresponding keys.  This function does never fail.  It returns an empty list even if no key corresponds.</p><p>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.</p><p>The function `tcmdbfwmkeys2' is used in order to get forward matching string keys in an on-memory hash database object.</p><p><strong>TCLIST *tcmdbfwmkeys2(TCMDB *</strong><em>mdb</em><strong>, const char *</strong><em>pstr</em><strong>, int </strong><em>max</em><strong>);</strong></p><p>`<em>mdb</em>' specifies the on-memory hash database object.</p><p>`<em>pstr</em>' specifies the string of the prefix.</p><p>`<em>max</em>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</p><p>The return value is a list object of the corresponding keys.  This function does never fail.  It returns an empty list even if no key corresponds.</p><p>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.</p><p>The function `tcmdbrnum' is used in order to get the number of records stored in an on-memory hash database object.</p><p><strong>uint64_t tcmdbrnum(TCMDB *</strong><em>mdb</em><strong>);</strong></p><p>`<em>mdb</em>' specifies the on-memory hash database object.</p><p>The return value is the number of the records stored in the database.</p><p>The function `tcmdbmsiz' is used in order to get the total size of memory used in an on-memory hash database object.</p><p><strong>uint64_t tcmdbmsiz(TCMDB *</strong><em>mdb</em><strong>);</strong></p><p>`<em>mdb</em>' specifies the on-memory hash database object.</p><p>The return value is the total size of memory used in the database.</p><p>The function `tcmdbaddint' is used in order to add an integer to a record in an on-memory hash database object.</p><p><strong>int tcmdbaddint(TCMDB *</strong><em>mdb</em><strong>, const void *</strong><em>kbuf</em><strong>, int </strong><em>ksiz</em><strong>, int </strong><em>num</em><strong>);</strong></p><p>`<em>mdb</em>' specifies the on-memory hash database object.</p><p>`<em>kbuf</em>' specifies the pointer to the region of the key.</p><p>`<em>ksiz</em>' specifies the size of the region of the key.</p><p>`<em>num</em>' specifies the additional value.</p><p>The return value is the summation value.</p><p>If the corresponding record exists, the value is treated as an integer and is added to.  If no record corresponds, a new record of the additional value is stored.</p><p>The function `tcmdbadddouble' is used in order to add a real number to a record in an on-memory hash database object.</p><p><strong>double tcmdbadddouble(TCMDB *</strong><em>mdb</em><strong>, const void *</strong><em>kbuf</em><strong>, int </strong><em>ksiz</em><strong>, double </strong><em>num</em><strong>);</strong></p><p>`<em>mdb</em>' specifies the on-memory hash database object.</p><p>`<em>kbuf</em>' specifies the pointer to the region of the key.</p><p>`<em>ksiz</em>' specifies the size of the region of the key.</p><p>`<em>num</em>' specifies the additional value.</p><p>The return value is the summation value.</p><p>If the corresponding record exists, the value is treated as a real number and is added to.  If no record corresponds, a new record of the additional value is stored.</p><p>The function `tcmdbvanish' is used in order to clear an on-memory hash database object.</p><p><strong>void tcmdbvanish(TCMDB *</strong><em>mdb</em><strong>);</strong></p><p>`<em>mdb</em>' specifies the on-memory hash database object.</p><p>All records are removed.</p><p>The function `tcmdbcutfront' is used in order to remove front records of an on-memory hash database object.</p><p><strong>void tcmdbcutfront(TCMDB *</strong><em>mdb</em><strong>, int </strong><em>num</em><strong>);</strong></p><p>`<em>mdb</em>' specifies the on-memory hash database object.</p><p>`<em>num</em>' specifies the number of records to be removed.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">API OF ON-MEMORY TREE DATABASE</h2>
        <div class="sectioncontent">
<p>The function `tcndbnew' is used in order to create an on-memory tree database object.</p><p><strong>TCNDB *tcndbnew(void);</strong></p><p>The return value is the new on-memory tree database object.</p><p>The object can be shared by plural threads because of the internal mutex.</p><p>The function `tcndbnew2' is used in order to create an on-memory tree database object with specifying the custom comparison function.</p><p><strong>TCNDB *tcndbnew2(TCCMP </strong><em>cmp</em><strong>, void *</strong><em>cmpop</em><strong>);</strong></p><p>`<em>cmp</em>' specifies the pointer to the custom comparison function.</p><p>`<em>cmpop</em>' specifies an arbitrary pointer to be given as a parameter of the comparison function.  If it is not needed, `NULL' can be specified.</p><p>The return value is the new on-memory tree database object.</p><p>The default comparison function compares keys of two records by lexical order.  The functions `tccmplexical' (default), `tccmpdecimal', `tccmpint32', and `tccmpint64' are built-in.  The object can be shared by plural threads because of the internal mutex.</p><p>The function `tcndbdel' is used in order to delete an on-memory tree database object.</p><p><strong>void tcndbdel(TCNDB *</strong><em>ndb</em><strong>);</strong></p><p>`<em>ndb</em>' specifies the on-memory tree database object.</p><p>The function `tcndbput' is used in order to store a record into an on-memory tree database object.</p><p><strong>void tcndbput(TCNDB *</strong><em>ndb</em><strong>, const void *</strong><em>kbuf</em><strong>, int </strong><em>ksiz</em><strong>, const void *</strong><em>vbuf</em><strong>, int </strong><em>vsiz</em><strong>);</strong></p><p>`<em>ndb</em>' specifies the on-memory tree database object.</p><p>`<em>kbuf</em>' specifies the pointer to the region of the key.</p><p>`<em>ksiz</em>' specifies the size of the region of the key.</p><p>`<em>vbuf</em>' specifies the pointer to the region of the value.</p><p>`<em>vsiz</em>' specifies the size of the region of the value.</p><p>If a record with the same key exists in the database, it is overwritten.</p><p>The function `tcndbput2' is used in order to store a string record into an on-memory tree database object.</p><p><strong>void tcndbput2(TCNDB *</strong><em>ndb</em><strong>, const char *</strong><em>kstr</em><strong>, const char *</strong><em>vstr</em><strong>);</strong></p><p>`<em>ndb</em>' specifies the on-memory tree database object.</p><p>`<em>kstr</em>' specifies the string of the key.</p><p>`<em>vstr</em>' specifies the string of the value.</p><p>If a record with the same key exists in the database, it is overwritten.</p><p>The function `tcndbputkeep' is used in order to store a new record into an on-memory tree database object.</p><p><strong>bool tcndbputkeep(TCNDB *</strong><em>ndb</em><strong>, const void *</strong><em>kbuf</em><strong>, int </strong><em>ksiz</em><strong>, const void *</strong><em>vbuf</em><strong>, int </strong><em>vsiz</em><strong>);</strong></p><p>`<em>ndb</em>' specifies the on-memory tree database object.</p><p>`<em>kbuf</em>' specifies the pointer to the region of the key.</p><p>`<em>ksiz</em>' specifies the size of the region of the key.</p><p>`<em>vbuf</em>' specifies the pointer to the region of the value.</p><p>`<em>vsiz</em>' specifies the size of the region of the value.</p><p>If successful, the return value is true, else, it is false.</p><p>If a record with the same key exists in the database, this function has no effect.</p><p>The function `tcndbputkeep2' is used in order to store a new string record into an on-memory tree database object.</p><p><strong>bool tcndbputkeep2(TCNDB *</strong><em>ndb</em><strong>, const char *</strong><em>kstr</em><strong>, const char *</strong><em>vstr</em><strong>);</strong></p><p>`<em>ndb</em>' specifies the on-memory tree database object.</p><p>`<em>kstr</em>' specifies the string of the key.</p><p>`<em>vstr</em>' specifies the string of the value.</p><p>If successful, the return value is true, else, it is false.</p><p>If a record with the same key exists in the database, this function has no effect.</p><p>The function `tcndbputcat' is used in order to concatenate a value at the end of the existing record in an on-memory tree database.</p><p><strong>void tcndbputcat(TCNDB *</strong><em>ndb</em><strong>, const void *</strong><em>kbuf</em><strong>, int </strong><em>ksiz</em><strong>, const void *</strong><em>vbuf</em><strong>, int </strong><em>vsiz</em><strong>);</strong></p><p>`<em>ndb</em>' specifies the on-memory tree database object.</p><p>`<em>kbuf</em>' specifies the pointer to the region of the key.</p><p>`<em>ksiz</em>' specifies the size of the region of the key.</p><p>`<em>vbuf</em>' specifies the pointer to the region of the value.</p><p>`<em>vsiz</em>' specifies the size of the region of the value.</p><p>If there is no corresponding record, a new record is created.</p><p>The function `tcndbputcat2' is used in order to concatenate a string at the end of the existing record in an on-memory tree database.</p><p><strong>void tcndbputcat2(TCNDB *</strong><em>ndb</em><strong>, const char *</strong><em>kstr</em><strong>, const char *</strong><em>vstr</em><strong>);</strong></p><p>`<em>ndb</em>' specifies the on-memory tree database object.</p><p>`<em>kstr</em>' specifies the string of the key.</p><p>`<em>vstr</em>' specifies the string of the value.</p><p>If there is no corresponding record, a new record is created.</p><p>The function `tcndbout' is used in order to remove a record of an on-memory tree database object.</p><p><strong>bool tcndbout(TCNDB *</strong><em>ndb</em><strong>, const void *</strong><em>kbuf</em><strong>, int </strong><em>ksiz</em><strong>);</strong></p><p>`<em>ndb</em>' specifies the on-memory tree database object.</p><p>`<em>kbuf</em>' specifies the pointer to the region of the key.</p><p>`<em>ksiz</em>' specifies the size of the region of the key.</p><p>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</p><p>The function `tcndbout2' is used in order to remove a string record of an on-memory tree database object.</p><p><strong>bool tcndbout2(TCNDB *</strong><em>ndb</em><strong>, const char *</strong><em>kstr</em><strong>);</strong></p><p>`<em>ndb</em>' specifies the on-memory tree database object.</p><p>`<em>kstr</em>' specifies the string of the key.</p><p>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</p><p>The function `tcndbget' is used in order to retrieve a record in an on-memory tree database object.</p><p><strong>void *tcndbget(TCNDB *</strong><em>ndb</em><strong>, const void *</strong><em>kbuf</em><strong>, int </strong><em>ksiz</em><strong>, int *</strong><em>sp</em><strong>);</strong></p><p>`<em>ndb</em>' specifies the on-memory tree database object.</p><p>`<em>kbuf</em>' specifies the pointer to the region of the key.</p><p>`<em>ksiz</em>' specifies the size of the region of the key.</p><p>`<em>sp</em>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</p><p>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned when no record corresponds.</p><p>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</p><p>The function `tcndbget2' is used in order to retrieve a string record in an on-memory tree database object.</p><p><strong>char *tcndbget2(TCNDB *</strong><em>ndb</em><strong>, const char *</strong><em>kstr</em><strong>);</strong></p><p>`<em>ndb</em>' specifies the on-memory tree database object.</p><p>`<em>kstr</em>' specifies the string of the key.</p><p>If successful, the return value is the string of the value of the corresponding record.  `NULL' is returned when no record corresponds.</p><p>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</p><p>The function `tcndbvsiz' is used in order to get the size of the value of a record in an on-memory tree database object.</p><p><strong>int tcndbvsiz(TCNDB *</strong><em>ndb</em><strong>, const void *</strong><em>kbuf</em><strong>, int </strong><em>ksiz</em><strong>);</strong></p><p>`<em>ndb</em>' specifies the on-memory tree database object.</p><p>`<em>kbuf</em>' specifies the pointer to the region of the key.</p><p>`<em>ksiz</em>' specifies the size of the region of the key.</p><p>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</p><p>The function `tcndbvsiz2' is used in order to get the size of the value of a string record in an on-memory tree database object.</p><p><strong>int tcndbvsiz2(TCNDB *</strong><em>ndb</em><strong>, const char *</strong><em>kstr</em><strong>);</strong></p><p>`<em>ndb</em>' specifies the on-memory tree database object.</p><p>`<em>kstr</em>' specifies the string of the key.</p><p>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</p><p>The function `tcndbiterinit' is used in order to initialize the iterator of an on-memory tree database object.</p><p><strong>void tcndbiterinit(TCNDB *</strong><em>ndb</em><strong>);</strong></p><p>`<em>ndb</em>' specifies the on-memory tree database object.</p><p>The iterator is used in order to access the key of every record stored in the on-memory database.</p><p>The function `tcndbiternext' is used in order to get the next key of the iterator of an on-memory tree database object.</p><p><strong>void *tcndbiternext(TCNDB *</strong><em>ndb</em><strong>, int *</strong><em>sp</em><strong>);</strong></p><p>`<em>ndb</em>' specifies the on-memory tree database object.</p><p>`<em>sp</em>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</p><p>If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record can be fetched from the iterator.</p><p>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  The order of iteration is assured to be the same as the stored order.</p><p>The function `tcndbiternext2' is used in order to get the next key string of the iterator of an on-memory tree database object.</p><p><strong>char *tcndbiternext2(TCNDB *</strong><em>ndb</em><strong>);</strong></p><p>`<em>ndb</em>' specifies the on-memory tree database object.</p><p>If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record can be fetched from the iterator.</p><p>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  The order of iteration is assured to be the same as the stored order.</p><p>The function `tcndbfwmkeys' is used in order to get forward matching keys in an on-memory tree database object.</p><p><strong>TCLIST *tcndbfwmkeys(TCNDB *</strong><em>ndb</em><strong>, const void *</strong><em>pbuf</em><strong>, int </strong><em>psiz</em><strong>, int </strong><em>max</em><strong>);</strong></p><p>`<em>ndb</em>' specifies the on-memory tree database object.</p><p>`<em>pbuf</em>' specifies the pointer to the region of the prefix.</p><p>`<em>psiz</em>' specifies the size of the region of the prefix.</p><p>`<em>max</em>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</p><p>The return value is a list object of the corresponding keys.  This function does never fail.  It returns an empty list even if no key corresponds.</p><p>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</p><p>The function `tcndbfwmkeys2' is used in order to get forward matching string keys in an on-memory tree database object.</p><p><strong>TCLIST *tcndbfwmkeys2(TCNDB *</strong><em>ndb</em><strong>, const char *</strong><em>pstr</em><strong>, int </strong><em>max</em><strong>);</strong></p><p>`<em>ndb</em>' specifies the on-memory tree database object.</p><p>`<em>pstr</em>' specifies the string of the prefix.</p><p>`<em>max</em>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</p><p>The return value is a list object of the corresponding keys.  This function does never fail.  It returns an empty list even if no key corresponds.</p><p>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</p><p>The function `tcndbrnum' is used in order to get the number of records stored in an on-memory tree database object.</p><p><strong>uint64_t tcndbrnum(TCNDB *</strong><em>ndb</em><strong>);</strong></p><p>`<em>ndb</em>' specifies the on-memory tree database object.</p><p>The return value is the number of the records stored in the database.</p><p>The function `tcndbmsiz' is used in order to get the total size of memory used in an on-memory tree database object.</p><p><strong>uint64_t tcndbmsiz(TCNDB *</strong><em>ndb</em><strong>);</strong></p><p>`<em>ndb</em>' specifies the on-memory tree database object.</p><p>The return value is the total size of memory used in the database.</p><p>The function `tcndbaddint' is used in order to add an integer to a record in an on-memory tree database object.</p><p><strong>int tcndbaddint(TCNDB *</strong><em>ndb</em><strong>, const void *</strong><em>kbuf</em><strong>, int </strong><em>ksiz</em><strong>, int </strong><em>num</em><strong>);</strong></p><p>`<em>ndb</em>' specifies the on-memory tree database object.</p><p>`<em>kbuf</em>' specifies the pointer to the region of the key.</p><p>`<em>ksiz</em>' specifies the size of the region of the key.</p><p>`<em>num</em>' specifies the additional value.</p><p>The return value is the summation value.</p><p>If the corresponding record exists, the value is treated as an integer and is added to.  If no record corresponds, a new record of the additional value is stored.</p><p>The function `tcndbadddouble' is used in order to add a real number to a record in an on-memory tree database object.</p><p><strong>double tcndbadddouble(TCNDB *</strong><em>ndb</em><strong>, const void *</strong><em>kbuf</em><strong>, int </strong><em>ksiz</em><strong>, double </strong><em>num</em><strong>);</strong></p><p>`<em>ndb</em>' specifies the on-memory tree database object.</p><p>`<em>kbuf</em>' specifies the pointer to the region of the key.</p><p>`<em>ksiz</em>' specifies the size of the region of the key.</p><p>`<em>num</em>' specifies the additional value.</p><p>The return value is the summation value.</p><p>If the corresponding record exists, the value is treated as a real number and is added to.  If no record corresponds, a new record of the additional value is stored.</p><p>The function `tcndbvanish' is used in order to clear an on-memory tree database object.</p><p><strong>void tcndbvanish(TCNDB *</strong><em>ndb</em><strong>);</strong></p><p>`<em>ndb</em>' specifies the on-memory tree database object.</p><p>All records are removed.</p><p>The function `tcndbcutfringe' is used in order to remove fringe records of an on-memory tree database object.</p><p><strong>void tcndbcutfringe(TCNDB *</strong><em>ndb</em><strong>, int </strong><em>num</em><strong>);</strong></p><p>`<em>ndb</em>' specifies the on-memory tree database object.</p><p>`<em>num</em>' specifies the number of records to be removed.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">API OF MEMORY POOL</h2>
        <div class="sectioncontent">
<p>The function `tcmpoolnew' is used in order to create a memory pool object.</p><p><strong>TCMPOOL *tcmpoolnew(void);</strong></p><p>The return value is the new memory pool object.</p><p>The function `tcmpooldel' is used in order to delete a memory pool object.</p><p><strong>void tcmpooldel(TCMPOOL *</strong><em>mpool</em><strong>);</strong></p><p>`<em>mpool</em>' specifies the memory pool object.</p><p>Note that the deleted object and its derivatives can not be used anymore.</p><p>The function `tcmpoolpush' is used in order to relegate an arbitrary object to a memory pool object.</p><p><strong>void *tcmpoolpush(TCMPOOL *</strong><em>mpool</em><strong>, void *</strong><em>ptr</em><strong>, void (*</strong><em>del</em><strong>)(void *));</strong></p><p>`<em>mpool</em>' specifies the memory pool object.</p><p>`<em>ptr</em>' specifies the pointer to the object to be relegated.  If it is `NULL', this function has no effect.</p><p>`<em>del</em>' specifies the pointer to the function to delete the object.</p><p>The return value is the pointer to the given object.</p><p>This function assures that the specified object is deleted when the memory pool object is deleted.</p><p>The function `tcmpoolpushptr' is used in order to relegate an allocated region to a memory pool object.</p><p><strong>void *tcmpoolpushptr(TCMPOOL *</strong><em>mpool</em><strong>, void *</strong><em>ptr</em><strong>);</strong></p><p>`<em>mpool</em>' specifies the memory pool object.</p><p>`<em>ptr</em>' specifies the pointer to the region to be relegated.  If it is `NULL', this function has no effect.</p><p>The return value is the pointer to the given object.</p><p>This function assures that the specified region is released when the memory pool object is deleted.</p><p>The function `tcmpoolpushxstr' is used in order to relegate an extensible string object to a memory pool object.</p><p><strong>TCXSTR *tcmpoolpushxstr(TCMPOOL *</strong><em>mpool</em><strong>, TCXSTR *</strong><em>xstr</em><strong>);</strong></p><p>`<em>mpool</em>' specifies the memory pool object.</p><p>`<em>xstr</em>' specifies the extensible string object.  If it is `NULL', this function has no effect.</p><p>The return value is the pointer to the given object.</p><p>This function assures that the specified object is deleted when the memory pool object is deleted.</p><p>The function `tcmpoolpushlist' is used in order to relegate a list object to a memory pool object.</p><p><strong>TCLIST *tcmpoolpushlist(TCMPOOL *</strong><em>mpool</em><strong>, TCLIST *</strong><em>list</em><strong>);</strong></p><p>`<em>mpool</em>' specifies the memory pool object.</p><p>`<em>list</em>' specifies the list object.  If it is `NULL', this function has no effect.</p><p>The return value is the pointer to the given object.</p><p>This function assures that the specified object is deleted when the memory pool object is deleted.</p><p>The function `tcmpoolpushmap' is used in order to relegate a map object to a memory pool object.</p><p><strong>TCMAP *tcmpoolpushmap(TCMPOOL *</strong><em>mpool</em><strong>, TCMAP *</strong><em>map</em><strong>);</strong></p><p>`<em>mpool</em>' specifies the memory pool object.</p><p>`<em>map</em>' specifies the map object.  If it is `NULL', this function has no effect.</p><p>The return value is the pointer to the given object.</p><p>This function assures that the specified object is deleted when the memory pool object is deleted.</p><p>The function `tcmpoolpushtree' is used in order to relegate a tree object to a memory pool object.</p><p><strong>TCTREE *tcmpoolpushtree(TCMPOOL *</strong><em>mpool</em><strong>, TCTREE *</strong><em>tree</em><strong>);</strong></p><p>`<em>mpool</em>' specifies the memory pool object.</p><p>`<em>tree</em>' specifies the tree object.  If it is `NULL', this function has no effect.</p><p>The return value is the pointer to the given object.</p><p>This function assures that the specified object is deleted when the memory pool object is deleted.</p><p>The function `tcmpoolmalloc' is used in order to allocate a region relegated to a memory pool object.</p><p><strong>void *tcmpoolmalloc(TCMPOOL *</strong><em>mpool</em><strong>, size_t </strong><em>size</em><strong>);</strong></p><p>`<em>mpool</em>' specifies the memory pool object.</p><p>The return value is the pointer to the allocated region under the memory pool.</p><p>The function `tcmpoolxstrnew' is used in order to create an extensible string object relegated to a memory pool object.</p><p><strong>TCXSTR *tcmpoolxstrnew(TCMPOOL *</strong><em>mpool</em><strong>);</strong></p><p>The return value is the new extensible string object under the memory pool.</p><p>The function `tcmpoollistnew' is used in order to create a list object relegated to a memory pool object.</p><p><strong>TCLIST *tcmpoollistnew(TCMPOOL *</strong><em>mpool</em><strong>);</strong></p><p>The return value is the new list object under the memory pool.</p><p>The function `tcmpoolmapnew' is used in order to create a map object relegated to a memory pool object.</p><p><strong>TCMAP *tcmpoolmapnew(TCMPOOL *</strong><em>mpool</em><strong>);</strong></p><p>The return value is the new map object under the memory pool.</p><p>The function `tcmpooltreenew' is used in order to create a tree object relegated to a memory pool object.</p><p><strong>TCTREE *tcmpooltreenew(TCMPOOL *</strong><em>mpool</em><strong>);</strong></p><p>The return value is the new tree object under the memory pool.</p><p>The function `tcmpoolpop' is used in order to remove the most recently installed cleanup handler of a memory pool object.</p><p><strong>void tcmpoolpop(TCMPOOL *</strong><em>mpool</em><strong>, bool </strong><em>exe</em><strong>);</strong></p><p>`<em>mpool</em>' specifies the memory pool object.</p><p>`<em>exe</em>' specifies whether to execute the destructor of the removed handler.</p><p>The function `tcmpoolclear' is used in order to remove all cleanup handler of a memory pool object.</p><p><strong>void tcmpoolclear(TCMPOOL *</strong><em>mpool</em><strong>, bool </strong><em>exe</em><strong>);</strong></p><p>`<em>mpool</em>' specifies the memory pool object.</p><p>`<em>exe</em>' specifies whether to execute the destructors of the removed handlers.</p><p>The function `tcmpoolglobal' is used in order to get the global memory pool object.</p><p><strong>TCMPOOL *tcmpoolglobal(void);</strong></p><p>The return value is the global memory pool object.</p><p>The global memory pool object is a singleton and assured to be deleted when the process is terminating normally.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">API OF MISCELLANEOUS UTILITIES</h2>
        <div class="sectioncontent">
<p>The function `tclmax' is used in order to get the larger value of two integers.</p><p><strong>long tclmax(long </strong><em>a</em><strong>, long </strong><em>b</em><strong>);</strong></p><p>`<em>a</em>' specifies an integer.</p><p>`<em>b</em>' specifies the other integer.</p><p>The return value is the larger value of the two.</p><p>The function `tclmin' is used in order to get the lesser value of two integers.</p><p><strong>long tclmin(long </strong><em>a</em><strong>, long </strong><em>b</em><strong>);</strong></p><p>`<em>a</em>' specifies an integer.</p><p>`<em>b</em>' specifies the other integer.</p><p>The return value is the lesser value of the two.</p><p>The function `tclrand' is used in order to get a random number as long integer based on uniform distribution.</p><p><strong>unsigned long tclrand(void);</strong></p><p>The return value is the random number between 0 and `ULONG_MAX'.</p><p>This function uses the random number source device and generates a real random number if possible.</p><p>The function `tcdrand' is used in order to get a random number as double decimal based on uniform distribution.</p><p><strong>double tcdrand(void);</strong></p><p>The return value is the random number equal to or greater than 0, and less than 1.0.</p><p>This function uses the random number source device and generates a real random number if possible.</p><p>The function `tcdrandnd' is used in order to get a random number as double decimal based on normal distribution.</p><p><strong>double tcdrandnd(double </strong><em>avg</em><strong>, double </strong><em>sd</em><strong>);</strong></p><p>`<em>avg</em>' specifies the average.</p><p>`<em>sd</em>' specifies the standard deviation.</p><p>The return value is the random number.</p><p>This function uses the random number source device and generates a real random number if possible.</p><p>The function `tcstricmp' is used in order to compare two strings with case insensitive evaluation.</p><p><strong>int tcstricmp(const char *</strong><em>astr</em><strong>, const char *</strong><em>bstr</em><strong>);</strong></p><p>`<em>astr</em>' specifies a string.</p><p>`<em>bstr</em>' specifies of the other string.</p><p>The return value is positive if the former is big, negative if the latter is big, 0 if both are equivalent.</p><p>The function `tcstrfwm' is used in order to check whether a string begins with a key.</p><p><strong>bool tcstrfwm(const char *</strong><em>str</em><strong>, const char *</strong><em>key</em><strong>);</strong></p><p>`<em>str</em>' specifies the target string.</p><p>`<em>key</em>' specifies the forward matching key string.</p><p>The return value is true if the target string begins with the key, else, it is false.</p><p>The function `tcstrifwm' is used in order to check whether a string begins with a key with case insensitive evaluation.</p><p><strong>bool tcstrifwm(const char *</strong><em>str</em><strong>, const char *</strong><em>key</em><strong>);</strong></p><p>`<em>str</em>' specifies the target string.</p><p>`<em>key</em>' specifies the forward matching key string.</p><p>The return value is true if the target string begins with the key, else, it is false.</p><p>The function `tcstrbwm' is used in order to check whether a string ends with a key.</p><p><strong>bool tcstrbwm(const char *</strong><em>str</em><strong>, const char *</strong><em>key</em><strong>);</strong></p><p>`<em>str</em>' specifies the target string.</p><p>`<em>key</em>' specifies the backward matching key string.</p><p>The return value is true if the target string ends with the key, else, it is false.</p><p>The function `tcstribwm' is used in order to check whether a string ends with a key with case insensitive evaluation.</p><p><strong>bool tcstribwm(const char *</strong><em>str</em><strong>, const char *</strong><em>key</em><strong>);</strong></p><p>`<em>str</em>' specifies the target string.</p><p>`<em>key</em>' specifies the backward matching key string.</p><p>The return value is true if the target string ends with the key, else, it is false.</p><p>The function `tcstrdist' is used in order to calculate the edit distance of two strings.</p><p><strong>int tcstrdist(const char *</strong><em>astr</em><strong>, const char *</strong><em>bstr</em><strong>);</strong></p><p>`<em>astr</em>' specifies a string.</p><p>`<em>bstr</em>' specifies of the other string.</p><p>The return value is the edit distance which is known as the Levenshtein distance.  The cost is calculated by byte.</p><p>The function `tcstrdistutf' is used in order to calculate the edit distance of two UTF-8 strings.</p><p><strong>int tcstrdistutf(const char *</strong><em>astr</em><strong>, const char *</strong><em>bstr</em><strong>);</strong></p><p>`<em>astr</em>' specifies a string.</p><p>`<em>bstr</em>' specifies of the other string.</p><p>The return value is the edit distance which is known as the Levenshtein distance.  The cost is calculated by Unicode character.</p><p>The function `tcstrtoupper' is used in order to convert the letters of a string into upper case.</p><p><strong>char *tcstrtoupper(char *</strong><em>str</em><strong>);</strong></p><p>`<em>str</em>' specifies the string to be converted.</p><p>The return value is the string itself.</p><p>The function `tcstrtolower' is used in order to convert the letters of a string into lower case.</p><p><strong>char *tcstrtolower(char *</strong><em>str</em><strong>);</strong></p><p>`<em>str</em>' specifies the string to be converted.</p><p>The return value is the string itself.</p><p>The function `tcstrtrim' is used in order to cut space characters at head or tail of a string.</p><p><strong>char *tcstrtrim(char *</strong><em>str</em><strong>);</strong></p><p>`<em>str</em>' specifies the string to be converted.</p><p>The return value is the string itself.</p><p>The function `tcstrsqzspc' is used in order to squeeze space characters in a string and trim it.</p><p><strong>char *tcstrsqzspc(char *</strong><em>str</em><strong>);</strong></p><p>`<em>str</em>' specifies the string to be converted.</p><p>The return value is the string itself.</p><p>The function `tcstrsubchr' is used in order to substitute characters in a string.</p><p><strong>char *tcstrsubchr(char *</strong><em>str</em><strong>, const char *</strong><em>rstr</em><strong>, const char *</strong><em>sstr</em><strong>);</strong></p><p>`<em>str</em>' specifies the string to be converted.</p><p>`<em>rstr</em>' specifies the string containing characters to be replaced.</p><p>`<em>sstr</em>' specifies the string containing characters to be substituted.</p><p>If the substitute string is shorter then the replacement string, corresponding characters are removed.</p><p>The function `tcstrcntutf' is used in order to count the number of characters in a string of UTF-8.</p><p><strong>int tcstrcntutf(const char *</strong><em>str</em><strong>);</strong></p><p>`<em>str</em>' specifies the string of UTF-8.</p><p>The return value is the number of characters in the string.</p><p>The function `tcstrcututf' is used in order to cut a string of UTF-8 at the specified number of characters.</p><p><strong>char *tcstrcututf(char *</strong><em>str</em><strong>, int </strong><em>num</em><strong>);</strong></p><p>`<em>str</em>' specifies the string of UTF-8.</p><p>`<em>num</em>' specifies the number of characters to be kept.</p><p>The return value is the string itself.</p><p>The function `tcstrutftoucs' is used in order to convert a UTF-8 string into a UCS-2 array.</p><p><strong>void tcstrutftoucs(const char *</strong><em>str</em><strong>, uint16_t *</strong><em>ary</em><strong>, int *</strong><em>np</em><strong>);</strong></p><p>`<em>str</em>' specifies the UTF-8 string.</p><p>`<em>ary</em>' specifies the pointer to the region into which the result UCS-2 codes are written.  The size of the buffer should be sufficient.</p><p>`<em>np</em>' specifies the pointer to a variable into which the number of elements of the result array is assigned.</p><p>The function `tcstrucstoutf' is used in order to convert a UCS-2 array into a UTF-8 string.</p><p><strong>int tcstrucstoutf(const uint16_t *</strong><em>ary</em><strong>, int </strong><em>num</em><strong>, char *</strong><em>str</em><strong>);</strong></p><p>`<em>ary</em>' specifies the array of UCS-2 codes.</p><p>`<em>num</em>' specifies the number of the array.</p><p>`<em>str</em>' specifies the pointer to the region into which the result UTF-8 string is written.  The size of the buffer should be sufficient.</p><p>The return value is the length of the result string.</p><p>The function `tcstrsplit' is used in order to create a list object by splitting a string.</p><p><strong>TCLIST *tcstrsplit(const char *</strong><em>str</em><strong>, const char *</strong><em>delims</em><strong>);</strong></p><p>`<em>str</em>' specifies the source string.</p><p>`<em>delims</em>' specifies a string containing delimiting characters.</p><p>The return value is a list object of the split elements.</p><p>If two delimiters are successive, it is assumed that an empty element is between the two.  Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</p><p>The function `tcstrjoin' is used in order to create a string by joining all elements of a list object.</p><p><strong>char *tcstrjoin(const TCLIST *</strong><em>list</em><strong>, char </strong><em>delim</em><strong>);</strong></p><p>`<em>list</em>' specifies a list object.</p><p>`<em>delim</em>' specifies a delimiting character.</p><p>The return value is the result string.</p><p>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</p><p>The function `tcatoi' is used in order to convert a string to an integer.</p><p><strong>int64_t tcatoi(const char *</strong><em>str</em><strong>);</strong></p><p>`<em>str</em>' specifies the string.</p><p>The return value is the integer.  If the string does not contain numeric expression, 0 is returned.</p><p>This function is equivalent to `atoll' except that it does not depend on the locale.</p><p>The function `tcatoix' is used in order to convert a string with a metric prefix to an integer.</p><p><strong>int64_t tcatoix(const char *</strong><em>str</em><strong>);</strong></p><p>`<em>str</em>' specifies the string, which can be trailed by a binary metric prefix.  "K", "M", "G", "T", "P", and "E" are supported.  They are case-insensitive.</p><p>The return value is the integer.  If the string does not contain numeric expression, 0 is returned.  If the integer overflows the domain, `INT64_MAX' or `INT64_MIN' is returned according to the sign.</p><p>The function `tcatof' is used in order to convert a string to a real number.</p><p><strong>double tcatof(const char *</strong><em>str</em><strong>);</strong></p><p>`<em>str</em>' specifies the string.</p><p>The return value is the real number.  If the string does not contain numeric expression, 0.0 is returned.</p><p>This function is equivalent to `atof' except that it does not depend on the locale.</p><p>The function `tcregexmatch' is used in order to check whether a string matches a regular expression.</p><p><strong>bool tcregexmatch(const char *</strong><em>str</em><strong>, const char *</strong><em>regex</em><strong>);</strong></p><p>`<em>str</em>' specifies the target string.</p><p>`<em>regex</em>' specifies the regular expression string.  If it begins with `*', the trailing substring is used as a case-insensitive regular expression.</p><p>The return value is true if matching is success, else, it is false.</p><p>The function `tcregexreplace' is used in order to replace each substring matching a regular expression string.</p><p><strong>char *tcregexreplace(const char *</strong><em>str</em><strong>, const char *</strong><em>regex</em><strong>, const char *</strong><em>alt</em><strong>);</strong></p><p>`<em>str</em>' specifies the target string.</p><p>`<em>regex</em>' specifies the regular expression string for substrings.  If it begins with `*', the trailing substring is used as a case-insensitive regular expression.</p><p>`<em>alt</em>' specifies the alternative string with which each substrings is replaced.  Each `&' in the string is replaced with the matched substring.  Each `\' in the string escapes the following character.  Special escapes "\1" through "\9" referring to the corresponding matching sub-expressions in the regular expression string are supported.</p><p>The return value is a new converted string.  Even if the regular expression is invalid, a copy of the original string is returned.</p><p>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</p><p>The function `tcmd5hash' is used in order to get the MD5 hash value of a serial object.</p><p><strong>void tcmd5hash(const void *</strong><em>ptr</em><strong>, int </strong><em>size</em><strong>, char *</strong><em>buf</em><strong>);</strong></p><p>`<em>ptr</em>' specifies the pointer to the region.</p><p>`<em>size</em>' specifies the size of the region.</p><p>`<em>buf</em>' specifies the pointer to the region into which the result string is written.  The size of the buffer should be equal to or more than 48 bytes.</p><p>The function `tcarccipher' is used in order to cipher or decipher a serial object with the Arcfour stream cipher.</p><p><strong>void tcarccipher(const void *</strong><em>ptr</em><strong>, int </strong><em>size</em><strong>, const void *</strong><em>kbuf</em><strong>, int </strong><em>ksiz</em><strong>, void *</strong><em>obuf</em><strong>);</strong></p><p>`<em>ptr</em>' specifies the pointer to the region.</p><p>`<em>size</em>' specifies the size of the region.</p><p>`<em>kbuf</em>' specifies the pointer to the region of the cipher key.</p><p>`<em>ksiz</em>' specifies the size of the region of the cipher key.</p><p>`<em>obuf</em>' specifies the pointer to the region into which the result data is written.  The size of the buffer should be equal to or more than the input region.</p><p>The function `tctime' is used in order to get the time of day in seconds.</p><p><strong>double tctime(void);</strong></p><p>The return value is the time of day in seconds.  The accuracy is in microseconds.</p><p>The function `tccalendar' is used in order to get the Gregorian calendar of a time.</p><p><strong>void tccalendar(int64_t </strong><em>t</em><strong>, int </strong><em>jl</em><strong>, int *</strong><em>yearp</em><strong>, int *</strong><em>monp</em><strong>, int *</strong><em>dayp</em><strong>, int *</strong><em>hourp</em><strong>, int *</strong><em>minp</em><strong>, int *</strong><em>secp</em><strong>);</strong></p><p>`<em>t</em>' specifies the source time in seconds from the epoch.  If it is `INT64_MAX', the current time is specified.</p><p>`<em>jl</em>' specifies the jet lag of a location in seconds.  If it is `INT_MAX', the local jet lag is specified.</p><p>`<em>yearp</em>' specifies the pointer to a variable to which the year is assigned.  If it is `NULL', it is not used.</p><p>`<em>monp</em>' specifies the pointer to a variable to which the month is assigned.  If it is `NULL', it is not used.  1 means January and 12 means December.</p><p>`<em>dayp</em>' specifies the pointer to a variable to which the day of the month is assigned.  If it is `NULL', it is not used.</p><p>`<em>hourp</em>' specifies the pointer to a variable to which the hours is assigned.  If it is `NULL', it is not used.</p><p>`<em>minp</em>' specifies the pointer to a variable to which the minutes is assigned.  If it is `NULL', it is not used.</p><p>`<em>secp</em>' specifies the pointer to a variable to which the seconds is assigned.  If it is `NULL', it is not used.</p><p>The function `tcdatestrwww' is used in order to format a date as a string in W3CDTF.</p><p><strong>void tcdatestrwww(int64_t </strong><em>t</em><strong>, int </strong><em>jl</em><strong>, char *</strong><em>buf</em><strong>);</strong></p><p>`<em>t</em>' specifies the source time in seconds from the epoch.  If it is `INT64_MAX', the current time is specified.</p><p>`<em>jl</em>' specifies the jet lag of a location in seconds.  If it is `INT_MAX', the local jet lag is specified.</p><p>`<em>buf</em>' specifies the pointer to the region into which the result string is written.  The size of the buffer should be equal to or more than 48 bytes.</p><p>W3CDTF represents a date as "YYYY-MM-DDThh:mm:ddTZD".</p><p>The function `tcdatestrhttp' is used in order to format a date as a string in RFC 1123 format.</p><p><strong>void tcdatestrhttp(int64_t </strong><em>t</em><strong>, int </strong><em>jl</em><strong>, char *</strong><em>buf</em><strong>);</strong></p><p>`<em>t</em>' specifies the source time in seconds from the epoch.  If it is `INT64_MAX', the current time is specified.</p><p>`<em>jl</em>' specifies the jet lag of a location in seconds.  If it is `INT_MAX', the local jet lag is specified.</p><p>`<em>buf</em>' specifies the pointer to the region into which the result string is written.  The size of the buffer should be equal to or more than 48 bytes.</p><p>RFC 1123 format represents a date as "Wdy, DD-Mon-YYYY hh:mm:dd TZD".</p><p>The function `tcstrmktime' is used in order to get the time value of a date string.</p><p><strong>int64_t tcstrmktime(const char *</strong><em>str</em><strong>);</strong></p><p>`<em>str</em>' specifies the date string in decimal, hexadecimal, W3CDTF, or RFC 822 (1123).  Decimal can be trailed by "s" for in seconds, "m" for in minutes, "h" for in hours, and "d" for in days.</p><p>The return value is the time value of the date or `INT64_MIN' if the format is invalid.</p><p>The function `tcjetlag' is used in order to get the jet lag of the local time.</p><p><strong>int tcjetlag(void);</strong></p><p>The return value is the jet lag of the local time in seconds.</p><p>The function `tcdayofweek' is used in order to get the day of week of a date.</p><p><strong>int tcdayofweek(int </strong><em>year</em><strong>, int </strong><em>mon</em><strong>, int </strong><em>day</em><strong>);</strong></p><p>`<em>year</em>' specifies the year of a date.</p><p>`<em>mon</em>' specifies the month of the date.</p><p>`<em>day</em>' specifies the day of the date.</p><p>The return value is the day of week of the date.  0 means Sunday and 6 means Saturday.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">API OF FILESYSTEM UTILITIES</h2>
        <div class="sectioncontent">
<p>The function `tcrealpath' is used in order to get the canonicalized absolute path of a file.</p><p><strong>char *tcrealpath(const char *</strong><em>path</em><strong>);</strong></p><p>`<em>path</em>' specifies the path of the file.</p><p>The return value is the canonicalized absolute path of a file, or `NULL' if the path is invalid.</p><p>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</p><p>The function `tcstatfile' is used in order to get the status information of a file.</p><p><strong>bool tcstatfile(const char *</strong><em>path</em><strong>, bool *</strong><em>isdirp</em><strong>, int64_t *</strong><em>sizep</em><strong>, int64_t *</strong><em>mtimep</em><strong>);</strong></p><p>`<em>path</em>' specifies the path of the file.</p><p>`<em>isdirp</em>' specifies the pointer to a variable into which whether the file is a directory is assigned.  If it is `NULL', it is ignored.</p><p>`<em>sizep</em>' specifies the pointer to a variable into which the size of the file is assigned.  If it is `NULL', it is ignored.</p><p>`<em>ntimep</em>' specifies the pointer to a variable into which the size of the file is assigned.  If it is `NULL', it is ignored.</p><p>If successful, the return value is true, else, it is false.</p><p>The function `tcreadfile' is used in order to read whole data of a file.</p><p><strong>void *tcreadfile(const char *</strong><em>path</em><strong>, int </strong><em>limit</em><strong>, int *</strong><em>sp</em><strong>);</strong></p><p>`<em>path</em>' specifies the path of the file.  If it is `NULL', the standard input is specified.</p><p>`<em>limit</em>' specifies the limiting size of reading data.  If it is not more than 0, the limitation is not specified.</p><p>`<em>sp</em>' specifies the pointer to the variable into which the size of the region of the return value is assigned.  If it is `NULL', it is not used.</p><p>The return value is the pointer to the allocated region of the read data, or `NULL' if the file could not be opened.</p><p>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when when is no longer in use.</p><p>The function `tcreadfilelines' is used in order to read every line of a file.</p><p><strong>TCLIST *tcreadfilelines(const char *</strong><em>path</em><strong>);</strong></p><p>`<em>path</em>' specifies the path of the file.  If it is `NULL', the standard input is specified.</p><p>The return value is a list object of every lines if successful, else it is `NULL'.</p><p>Line separators are cut out.  Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</p><p>The function `tcwritefile' is used in order to write data into a file.</p><p><strong>bool tcwritefile(const char *</strong><em>path</em><strong>, const void *</strong><em>ptr</em><strong>, int </strong><em>size</em><strong>);</strong></p><p>`<em>path</em>' specifies the path of the file.  If it is `NULL', the standard output is specified.</p><p>`<em>ptr</em>' specifies the pointer to the data region.</p><p>`<em>size</em>' specifies the size of the region.</p><p>If successful, the return value is true, else, it is false.</p><p>The function `tccopyfile' is used in order to copy a file.</p><p><strong>bool tccopyfile(const char *</strong><em>src</em><strong>, const char *</strong><em>dest</em><strong>);</strong></p><p>`<em>src</em>' specifies the path of the source file.</p><p>`<em>dest</em>' specifies the path of the destination file.</p><p>The return value is true if successful, else, it is false.</p><p>If the destination file exists, it is overwritten.</p><p>The function `tcreaddir' is used in order to read names of files in a directory.</p><p><strong>TCLIST *tcreaddir(const char *</strong><em>path</em><strong>);</strong></p><p>`<em>path</em>' specifies the path of the directory.</p><p>The return value is a list object of names if successful, else it is `NULL'.</p><p>Links to the directory itself and to the parent directory are ignored.</p><p>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</p><p>The function `tcglobpat' is used in order to expand a pattern into a list of matched paths.</p><p><strong>TCLIST *tcglobpat(const char *</strong><em>pattern</em><strong>);</strong></p><p>`<em>pattern</em>' specifies the matching pattern.</p><p>The return value is a list object of matched paths.  If no path is matched, an empty list is returned.</p><p>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</p><p>The function `tcremovelink' is used in order to remove a file or a directory and its sub ones recursively.</p><p><strong>bool tcremovelink(const char *</strong><em>path</em><strong>);</strong></p><p>`<em>path</em>' specifies the path of the link.</p><p>If successful, the return value is true, else, it is false.  False is returned when the link does not exist or the permission is denied.</p><p>The function `tcwrite' is used in order to write data into a file.</p><p><strong>bool tcwrite(int </strong><em>fd</em><strong>, const void *</strong><em>buf</em><strong>, size_t </strong><em>size</em><strong>);</strong></p><p>`<em>fd</em>' specifies the file descriptor.</p><p>`<em>buf</em>' specifies the buffer to be written.</p><p>`<em>size</em>' specifies the size of the buffer.</p><p>The return value is true if successful, else, it is false.</p><p>The function `tcread' is used in order to read data from a file.</p><p><strong>bool tcread(int </strong><em>fd</em><strong>, void *</strong><em>buf</em><strong>, size_t </strong><em>size</em><strong>);</strong></p><p>`<em>fd</em>' specifies the file descriptor.</p><p>`<em>buf</em>' specifies the buffer to store into.</p><p>`<em>size</em>' specifies the size of the buffer.</p><p>The return value is true if successful, else, it is false.</p><p>The function `tclock' is used in order to lock a file.</p><p><strong>bool tclock(int </strong><em>fd</em><strong>, bool </strong><em>ex</em><strong>, bool </strong><em>nb</em><strong>);</strong></p><p>`<em>fd</em>' specifies the file descriptor.</p><p>`<em>ex</em>' specifies whether an exclusive lock or a shared lock is performed.</p><p>`<em>nb</em>' specifies whether to request with non-blocking.</p><p>The return value is true if successful, else, it is false.</p><p>The function `tcunlock' is used in order to unlock a file.</p><p><strong>bool tcunlock(int </strong><em>fd</em><strong>);</strong></p><p>`<em>fd</em>' specifies the file descriptor.</p><p>The return value is true if successful, else, it is false.</p><p>The function `tcsystem' is used in order to execute a shell command.</p><p><strong>int tcsystem(const char **</strong><em>args</em><strong>, int </strong><em>anum</em><strong>);</strong></p><p>`<em>args</em>' specifies an array of the command name and its arguments.</p><p>`<em>anum</em>' specifies the number of elements of the array.</p><p>The return value is the exit code of the command or `INT_MAX' on failure.</p><p>The command name and the arguments are quoted and meta characters are escaped.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">API OF ENCODING UTILITIES</h2>
        <div class="sectioncontent">
<p>The function `tcurlencode' is used in order to encode a serial object with URL encoding.</p><p><strong>char *tcurlencode(const char *</strong><em>ptr</em><strong>, int </strong><em>size</em><strong>);</strong></p><p>`<em>ptr</em>' specifies the pointer to the region.</p><p>`<em>size</em>' specifies the size of the region.</p><p>The return value is the result string.</p><p>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if when is no longer in use.</p><p>The function `tcurldecode' is used in order to decode a string encoded with URL encoding.</p><p><strong>char *tcurldecode(const char *</strong><em>str</em><strong>, int *</strong><em>sp</em><strong>);</strong></p><p>`<em>str</em>' specifies the encoded string.</p><p>`<em>sp</em>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</p><p>The return value is the pointer to the region of the result.</p><p>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</p><p>The function `tcurlbreak' is used in order to break up a URL into elements.</p><p><strong>TCMAP *tcurlbreak(const char *</strong><em>str</em><strong>);</strong></p><p>`<em>str</em>' specifies the URL string.</p><p>The return value is the map object whose keys are the name of elements.  The key "self" indicates the URL itself.  The key "scheme" indicates the scheme.  The key "host" indicates the host of the server.  The key "port" indicates the port number of the server.  The key "authority" indicates the authority information.  The key "path" indicates the path of the resource.  The key "file" indicates the file name without the directory section.  The key "query" indicates the query string.  The key "fragment" indicates the fragment string.</p><p>Supported schema are HTTP, HTTPS, FTP, and FILE.  Absolute URL and relative URL are supported.  Because the object of the return value is created with the function `tcmapnew', it should be deleted with the function `tcmapdel' when it is no longer in use.</p><p>The function `tcurlresolve' is used in order to resolve a relative URL with an absolute URL.</p><p><strong>char *tcurlresolve(const char *</strong><em>base</em><strong>, const char *</strong><em>target</em><strong>);</strong></p><p>`<em>base</em>' specifies the absolute URL of the base location.</p><p>`<em>target</em>' specifies the URL to be resolved.</p><p>The return value is the resolved URL.  If the target URL is relative, a new URL of relative location from the base location is returned.  Else, a copy of the target URL is returned.</p><p>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</p><p>The function `tcbaseencode' is used in order to encode a serial object with Base64 encoding.</p><p><strong>char *tcbaseencode(const char *</strong><em>ptr</em><strong>, int </strong><em>size</em><strong>);</strong></p><p>`<em>ptr</em>' specifies the pointer to the region.</p><p>`<em>size</em>' specifies the size of the region.</p><p>The return value is the result string.</p><p>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if when is no longer in use.</p><p>The function `tcbasedecode' is used in order to decode a string encoded with Base64 encoding.</p><p><strong>char *tcbasedecode(const char *</strong><em>str</em><strong>, int *</strong><em>sp</em><strong>);</strong></p><p>`<em>str</em>' specifies the encoded string.</p><p>`<em>sp</em>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</p><p>The return value is the pointer to the region of the result.</p><p>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</p><p>The function `tcquoteencode' is used in order to encode a serial object with Quoted-printable encoding.</p><p><strong>char *tcquoteencode(const char *</strong><em>ptr</em><strong>, int </strong><em>size</em><strong>);</strong></p><p>`<em>ptr</em>' specifies the pointer to the region.</p><p>`<em>size</em>' specifies the size of the region.</p><p>The return value is the result string.</p><p>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if when is no longer in use.</p><p>The function `tcquotedecode' is used in order to decode a string encoded with Quoted-printable encoding.</p><p><strong>char *tcquotedecode(const char *</strong><em>str</em><strong>, int *</strong><em>sp</em><strong>);</strong></p><p>`<em>str</em>' specifies the encoded string.</p><p>`<em>sp</em>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</p><p>The return value is the pointer to the region of the result.</p><p>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</p><p>The function `tcmimeencode' is used in order to encode a string with MIME encoding.</p><p><strong>char *tcmimeencode(const char *</strong><em>str</em><strong>, const char *</strong><em>encname</em><strong>, bool </strong><em>base</em><strong>);</strong></p><p>`<em>str</em>' specifies the string.</p><p>`<em>encname</em>' specifies the string of the name of the character encoding.</p><p>`<em>base</em>' specifies whether to use Base64 encoding.  If it is false, Quoted-printable is used.</p><p>The return value is the result string.</p><p>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</p><p>The function `tcmimedecode' is used in order to decode a string encoded with MIME encoding.</p><p><strong>char *tcmimedecode(const char *</strong><em>str</em><strong>, char *</strong><em>enp</em><strong>);</strong></p><p>`<em>str</em>' specifies the encoded string.</p><p>`<em>enp</em>' specifies the pointer to the region into which the name of encoding is written.  If it is `NULL', it is not used.  The size of the buffer should be equal to or more than 32 bytes.</p><p>The return value is the result string.</p><p>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</p><p>The function `tcmimebreak' is used in order to split a string of MIME into headers and the body.</p><p><strong>char *tcmimebreak(const char *</strong><em>ptr</em><strong>, int </strong><em>size</em><strong>, TCMAP *</strong><em>headers</em><strong>, int *</strong><em>sp</em><strong>);</strong></p><p>`<em>ptr</em>' specifies the pointer to the region of MIME data.</p><p>`<em>size</em>' specifies the size of the region.</p><p>`<em>headers</em>' specifies a map object to store headers.  If it is `NULL', it is not used.  Each key of the map is an uncapitalized header name.</p><p>`<em>sp</em>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</p><p>The return value is the pointer to the region of the body data.</p><p>If the content type is defined, the header map has the key "TYPE" specifying the type.  If the character encoding is defined, the key "CHARSET" indicates the encoding name.  If the boundary string of multipart is defined, the key "BOUNDARY" indicates the string.  If the content disposition is defined, the key "DISPOSITION" indicates the direction.  If the file name is defined, the key "FILENAME" indicates the name.  If the attribute name is defined, the key "NAME" indicates the name.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</p><p>The function `tcmimeparts' is used in order to split multipart data of MIME into its parts.</p><p><strong>TCLIST *tcmimeparts(const char *</strong><em>ptr</em><strong>, int </strong><em>size</em><strong>, const char *</strong><em>boundary</em><strong>);</strong></p><p>`<em>ptr</em>' specifies the pointer to the region of multipart data of MIME.</p><p>`<em>size</em>' specifies the size of the region.</p><p>`<em>boundary</em>' specifies the boundary string.</p><p>The return value is a list object.  Each element of the list is the data of a part.</p><p>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</p><p>The function `tchexencode' is used in order to encode a serial object with hexadecimal encoding.</p><p><strong>char *tchexencode(const char *</strong><em>ptr</em><strong>, int </strong><em>size</em><strong>);</strong></p><p>`<em>ptr</em>' specifies the pointer to the region.</p><p>`<em>size</em>' specifies the size of the region.</p><p>The return value is the result string.</p><p>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if when is no longer in use.</p><p>The function `tchexdecode' is used in order to decode a string encoded with hexadecimal encoding.</p><p><strong>char *tchexdecode(const char *</strong><em>str</em><strong>, int *</strong><em>sp</em><strong>);</strong></p><p>`<em>str</em>' specifies the encoded string.</p><p>`<em>sp</em>' specifies the pointer to a variable into which the size of the region of the return</p><p>value is assigned.</p><p>The return value is the pointer to the region of the result.</p><p>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</p><p>The function `tcpackencode' is used in order to compress a serial object with Packbits encoding.</p><p><strong>char *tcpackencode(const char *</strong><em>ptr</em><strong>, int </strong><em>size</em><strong>, int *</strong><em>sp</em><strong>);</strong></p><p>`<em>ptr</em>' specifies the pointer to the region.</p><p>`<em>size</em>' specifies the size of the region.</p><p>`<em>sp</em>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</p><p>If successful, the return value is the pointer to the result object, else, it is `NULL'.</p><p>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</p><p>The function `tcpackdecode' is used in order to decompress a serial object compressed with Packbits encoding.</p><p><strong>char *tcpackdecode(const char *</strong><em>ptr</em><strong>, int </strong><em>size</em><strong>, int *</strong><em>sp</em><strong>);</strong></p><p>`<em>ptr</em>' specifies the pointer to the region.</p><p>`<em>size</em>' specifies the size of the region.</p><p>`<em>sp</em>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</p><p>If successful, the return value is the pointer to the result object, else, it is `NULL'.</p><p>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</p><p>The function `tcbsencode' is used in order to compress a serial object with TCBS encoding.</p><p><strong>char *tcbsencode(const char *</strong><em>ptr</em><strong>, int </strong><em>size</em><strong>, int *</strong><em>sp</em><strong>);</strong></p><p>`<em>ptr</em>' specifies the pointer to the region.</p><p>`<em>size</em>' specifies the size of the region.</p><p>`<em>sp</em>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</p><p>If successful, the return value is the pointer to the result object, else, it is `NULL'.</p><p>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</p><p>The function `tcbsdecode' is used in order to decompress a serial object compressed with TCBS encoding.</p><p><strong>char *tcbsdecode(const char *</strong><em>ptr</em><strong>, int </strong><em>size</em><strong>, int *</strong><em>sp</em><strong>);</strong></p><p>`<em>ptr</em>' specifies the pointer to the region.</p><p>`<em>size</em>' specifies the size of the region.</p><p>`<em>sp</em>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</p><p>If successful, the return value is the pointer to the result object, else, it is `NULL'.</p><p>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</p><p>The function `tcdeflate' is used in order to compress a serial object with Deflate encoding.</p><p><strong>char *tcdeflate(const char *</strong><em>ptr</em><strong>, int </strong><em>size</em><strong>, int *</strong><em>sp</em><strong>);</strong></p><p>`<em>ptr</em>' specifies the pointer to the region.</p><p>`<em>size</em>' specifies the size of the region.</p><p>`<em>sp</em>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</p><p>If successful, the return value is the pointer to the result object, else, it is `NULL'.</p><p>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</p><p>The function `tcinflate' is used in order to decompress a serial object compressed with Deflate encoding.</p><p><strong>char *tcinflate(const char *</strong><em>ptr</em><strong>, int </strong><em>size</em><strong>, int *</strong><em>sp</em><strong>);</strong></p><p>`<em>ptr</em>' specifies the pointer to the region.</p><p>`<em>size</em>' specifies the size of the region.</p><p>`<em>sp</em>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</p><p>If successful, the return value is the pointer to the result object, else, it is `NULL'.</p><p>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</p><p>The function `tcgzipencode' is used in order to compress a serial object with GZIP encoding.</p><p><strong>char *tcgzipencode(const char *</strong><em>ptr</em><strong>, int </strong><em>size</em><strong>, int *</strong><em>sp</em><strong>);</strong></p><p>`<em>ptr</em>' specifies the pointer to the region.</p><p>`<em>size</em>' specifies the size of the region.</p><p>`<em>sp</em>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</p><p>If successful, the return value is the pointer to the result object, else, it is `NULL'.</p><p>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</p><p>The function `tcgzipdecode' is used in order to decompress a serial object compressed with GZIP encoding.</p><p><strong>char *tcgzipdecode(const char *</strong><em>ptr</em><strong>, int </strong><em>size</em><strong>, int *</strong><em>sp</em><strong>);</strong></p><p>`<em>ptr</em>' specifies the pointer to the region.</p><p>`<em>size</em>' specifies the size of the region.</p><p>`<em>sp</em>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</p><p>If successful, the return value is the pointer to the result object, else, it is `NULL'.</p><p>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</p><p>The function `tcgetcrc' is used in order to get the CRC32 checksum of a serial object.</p><p><strong>unsigned int tcgetcrc(const char *</strong><em>ptr</em><strong>, int </strong><em>size</em><strong>);</strong></p><p>`<em>ptr</em>' specifies the pointer to the region.</p><p>`<em>size</em>' specifies the size of the region.</p><p>The return value is the CRC32 checksum of the object.</p><p>The function `tcbzipencode' is used in order to compress a serial object with BZIP2 encoding.</p><p><strong>char *tcbzipencode(const char *</strong><em>ptr</em><strong>, int </strong><em>size</em><strong>, int *</strong><em>sp</em><strong>);</strong></p><p>`<em>ptr</em>' specifies the pointer to the region.</p><p>`<em>size</em>' specifies the size of the region.</p><p>`<em>sp</em>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</p><p>If successful, the return value is the pointer to the result object, else, it is `NULL'.</p><p>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</p><p>The function `tcbzipdecode' is used in order to decompress a serial object compressed with BZIP2 encoding.</p><p><strong>char *tcbzipdecode(const char *</strong><em>ptr</em><strong>, int </strong><em>size</em><strong>, int *</strong><em>sp</em><strong>);</strong></p><p>`<em>ptr</em>' specifies the pointer to the region.</p><p>`<em>size</em>' specifies the size of the region.</p><p>`<em>sp</em>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</p><p>If successful, the return value is the pointer to the result object, else, it is `NULL'.</p><p>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</p><p>The function `tcberencode' is used in order to encode an array of nonnegative integers with BER encoding.</p><p><strong>char *tcberencode(const unsigned int *</strong><em>ary</em><strong>, int </strong><em>anum</em><strong>, int *</strong><em>sp</em><strong>);</strong></p><p>`<em>ary</em>' specifies the pointer to the array of nonnegative integers.</p><p>`<em>anum</em>' specifies the size of the array.</p><p>`<em>sp</em>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</p><p>The return value is the pointer to the region of the result.</p><p>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if when is no longer in use.</p><p>The function `tcberdecode' is used in order to decode a serial object encoded with BER encoding.</p><p><strong>unsigned int *tcberdecode(const char *</strong><em>ptr</em><strong>, int </strong><em>size</em><strong>, int *</strong><em>np</em><strong>);</strong></p><p>`<em>ptr</em>' specifies the pointer to the region.</p><p>`<em>size</em>' specifies the size of the region.</p><p>`<em>np</em>' specifies the pointer to a variable into which the number of elements of the return value is assigned.</p><p>The return value is the pointer to the array of the result.</p><p>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if when is no longer in use.</p><p>The function `tcxmlescape' is used in order to escape meta characters in a string with the entity references of XML.</p><p><strong>char *tcxmlescape(const char *</strong><em>str</em><strong>);</strong></p><p>`<em>str</em>' specifies the string.</p><p>The return value is the pointer to the escaped string.</p><p>This function escapes only `&', `&lt;', `&gt;', and `"'.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</p><p>The function `tcxmlunescape' is used in order to unescape entity references in a string of XML.</p><p><strong>char *tcxmlunescape(const char *</strong><em>str</em><strong>);</strong></p><p>`<em>str</em>' specifies the string.</p><p>The return value is the unescaped string.</p><p>This function restores only `&amp;', `&lt;', `&gt;', and `&quot;'.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO tctree&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man1/tcutest.1.html"><strong>tcutest</strong>(1)</a>, <a href="../man1/tcucodec.1.html"><strong>tcucodec</strong>(1)</a>, <a href="../man3/tokyocabinet.3.html"><strong>tokyocabinet</strong>(3)</a></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="tctdb.3.html"><span aria-hidden="true">&larr;</span> tctdb.3: The table database api</a></li>
   <li class="next"><a href="tculog.3.html">tculog.3: The update log api <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>zlib: Zlib compression interface.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Zlib compression interface.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="zlib (3erl) manual">
  <meta name="twitter:description" content="Zlib compression interface.">
  <meta name="twitter:image" content="https://www.carta.tech/images/erlang-manpages-zlib-3erl.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3erl/zlib.3erl.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="zlib (3erl) manual" />
  <meta property="og:description" content="Zlib compression interface." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/erlang-manpages-zlib-3erl.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">zlib<small> (3erl)</small></h1>
        <p class="lead">Zlib compression interface.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/zlib.3erl.html">
      <span itemprop="name">zlib: Zlib compression interface.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/erlang-manpages/">
      <span itemprop="name">erlang-manpages</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/zlib.3erl.html">
      <span itemprop="name">zlib: Zlib compression interface.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The zlib module provides an API for the zlib library (http://www.zlib.org). It is used to compress and decompress data. The data format is described by RFCs 1950 to 1952.</p><p>A typical (compress) usage looks like:</p>
<pre>
Z = zlib:open(),
ok = zlib:deflateInit(Z,default),

Compress = fun(end_of_data, _Cont) -&gt; [];
              (Data, Cont) -&gt;
                 [zlib:deflate(Z, Data)|Cont(Read(),Cont)]
           end,
Compressed = Compress(Read(),Compress),
Last = zlib:deflate(Z, [], finish),
ok = zlib:deflateEnd(Z),
zlib:close(Z),
list_to_binary([Compressed|Last])
</pre>
<p>In all functions errors, <em>{'EXIT',{Reason,Backtrace}}</em>, might be thrown, where <em>Reason</em> describes the error. Typical reasons are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>badarg</em>: Bad argument</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>data_error</em>: The data contains errors</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>stream_error</em>: Inconsistent stream state</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>einval</em>: Bad value or wrong function called</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{need_dictionary,Adler32}</em>: See <em>inflate/2</em></p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DATA TYPES</h2>
        <div class="sectioncontent">

<pre>
<strong>zstream()</strong> = port()

</pre>
<p>A zlib stream, see <strong>open/0</strong>.</p>
<pre>
<strong>zlevel()</strong> = none

         | default

         | best_compression

         | best_speed

         | 0..9

</pre>

<pre>
<strong>zmemlevel()</strong> = 1..9

</pre>

<pre>
<strong>zmethod()</strong> = deflated

</pre>

<pre>
<strong>zstrategy()</strong> = default | filtered | huffman_only | rle

</pre>

<pre>
<strong>zwindowbits()</strong> = -15..-9 | 9..47

</pre>
<p>Normally in the range <em>-15..-9 | 9..15</em>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">

<pre>
<strong></strong>
open() -&gt; zstream()

</pre>
<p>Open a zlib stream.</p>
<pre>
<strong></strong>
close(Z) -&gt; ok

</pre>
<p>Types:</p><p>Z = <strong>zstream()</strong></p><p>Closes the stream referenced by <em>Z</em>.</p>
<pre>
<strong></strong>
deflateInit(Z) -&gt; ok

</pre>
<p>Types:</p><p>Z = <strong>zstream()</strong></p><p>Same as <em>zlib:deflateInit(Z, default)</em>.</p>
<pre>
<strong></strong>
deflateInit(Z, Level) -&gt; ok

</pre>
<p>Types:</p><p>Z = <strong>zstream()</strong></p><p>Level = <strong>zlevel()</strong></p><p>Initialize a zlib stream for compression.</p><p><em>Level</em> decides the compression level to be used, 0 (<em>none</em>), gives no compression at all, 1 (<em>best_speed</em>) gives best speed and 9 (<em>best_compression</em>) gives best compression.</p>
<pre>
<strong></strong>
deflateInit(Z, Level, Method, WindowBits, MemLevel, Strategy) -&gt;
<strong></strong>
               ok

</pre>
<p>Types:</p><p>Z = <strong>zstream()</strong></p><p>Level = <strong>zlevel()</strong></p><p>Method = <strong>zmethod()</strong></p><p>WindowBits = <strong>zwindowbits()</strong></p><p>MemLevel = <strong>zmemlevel()</strong></p><p>Strategy = <strong>zstrategy()</strong></p><p>Initiates a zlib stream for compression.</p><p>The <em>Level</em> parameter decides the compression level to be used, 0 (<em>none</em>), gives no compression at all, 1 (<em>best_speed</em>) gives best speed and 9 (<em>best_compression</em>) gives best compression.</p><p>The <em>Method</em> parameter decides which compression method to use, currently the only supported method is <em>deflated</em>.</p><p>The <em>WindowBits</em> parameter is the base two logarithm of the window size (the size of the history buffer). It should be in the range 9 through 15. Larger values of this parameter result in better compression at the expense of memory usage. The default value is 15 if <em>deflateInit/2</em>. A negative <em>WindowBits</em> value suppresses the zlib header (and checksum) from the stream. Note that the zlib source mentions this only as a undocumented feature.</p><p>The <em>MemLevel</em> parameter specifies how much memory should be allocated for the internal compression state. <em>MemLevel</em>=1 uses minimum memory but is slow and reduces compression ratio; <em>MemLevel</em>=9 uses maximum memory for optimal speed. The default value is 8.</p><p>The <em>Strategy</em> parameter is used to tune the compression algorithm. Use the value <em>default</em> for normal data, <em>filtered</em> for data produced by a filter (or predictor), <em>huffman_only</em> to force Huffman encoding only (no string match), or <em>rle</em> to limit match distances to one (run-length encoding). Filtered data consists mostly of small values with a somewhat random distribution. In this case, the compression algorithm is tuned to compress them better. The effect of <em>filtered</em>is to force more Huffman coding and less string matching; it is somewhat intermediate between <em>default</em> and <em>huffman_only</em>. <em>rle</em> is designed to be almost as fast as <em>huffman_only</em>, but give better compression for PNG image data. The <em>Strategy</em> parameter only affects the compression ratio but not the correctness of the compressed output even if it is not set appropriately.</p>
<pre>
<strong></strong>
deflate(Z, Data) -&gt; Compressed

</pre>
<p>Types:</p><p>Z = <strong>zstream()</strong></p><p>Data = iodata()</p><p>Compressed = iolist()</p><p>Same as <em>deflate(Z, Data, none)</em>.</p>
<pre>
<strong></strong>
deflate(Z, Data, Flush) -&gt; Compressed

</pre>
<p>Types:</p><p>Z = <strong>zstream()</strong></p><p>Data = iodata()</p><p>Flush = none | sync | full | finish</p><p>Compressed = iolist()</p><p><em>deflate/3</em> compresses as much data as possible, and stops when the input buffer becomes empty. It may introduce some output latency (reading input without producing any output) except when forced to flush.</p><p>If the parameter <em>Flush</em> is set to <em>sync</em>, all pending output is flushed to the output buffer and the output is aligned on a byte boundary, so that the decompressor can get all input data available so far. Flushing may degrade compression for some compression algorithms and so it should be used only when necessary.</p><p>If <em>Flush</em> is set to <em>full</em>, all output is flushed as with <em>sync</em>, and the compression state is reset so that decompression can restart from this point if previous compressed data has been damaged or if random access is desired. Using <em>full</em> too often can seriously degrade the compression.</p><p>If the parameter <em>Flush</em> is set to <em>finish</em>, pending input is processed, pending output is flushed and <em>deflate/3</em> returns. Afterwards the only possible operations on the stream are <em>deflateReset/1</em> or <em>deflateEnd/1</em>.</p><p><em>Flush</em> can be set to <em>finish</em> immediately after <em>deflateInit</em> if all compression is to be done in one step.</p>
<pre>
zlib:deflateInit(Z),
B1 = zlib:deflate(Z,Data),
B2 = zlib:deflate(Z,&lt;&lt; &gt;&gt;,finish),
zlib:deflateEnd(Z),
list_to_binary([B1,B2])
</pre>

<pre>
<strong></strong>
deflateSetDictionary(Z, Dictionary) -&gt; Adler32

</pre>
<p>Types:</p><p>Z = <strong>zstream()</strong></p><p>Dictionary = iodata()</p><p>Adler32 = integer()</p><p>Initializes the compression dictionary from the given byte sequence without producing any compressed output. This function must be called immediately after <em>deflateInit/[1|2|6]</em> or <em>deflateReset/1</em>, before any call of <em>deflate/3</em>. The compressor and decompressor must use exactly the same dictionary (see <em>inflateSetDictionary/2</em>). The adler checksum of the dictionary is returned.</p>
<pre>
<strong></strong>
deflateReset(Z) -&gt; ok

</pre>
<p>Types:</p><p>Z = <strong>zstream()</strong></p><p>This function is equivalent to <em>deflateEnd/1</em> followed by <em>deflateInit/[1|2|6]</em>, but does not free and reallocate all the internal compression state. The stream will keep the same compression level and any other attributes.</p>
<pre>
<strong></strong>
deflateParams(Z, Level, Strategy) -&gt; ok

</pre>
<p>Types:</p><p>Z = <strong>zstream()</strong></p><p>Level = <strong>zlevel()</strong></p><p>Strategy = <strong>zstrategy()</strong></p><p>Dynamically update the compression level and compression strategy. The interpretation of <em>Level</em> and <em>Strategy</em> is as in <em>deflateInit/6</em>. This can be used to switch between compression and straight copy of the input data, or to switch to a different kind of input data requiring a different strategy. If the compression level is changed, the input available so far is compressed with the old level (and may be flushed); the new level will take effect only at the next call of <em>deflate/3</em>.</p><p>Before the call of <em>deflateParams</em>, the stream state must be set as for a call of <em>deflate/3</em>, since the currently available input may have to be compressed and flushed.</p>
<pre>
<strong></strong>
deflateEnd(Z) -&gt; ok

</pre>
<p>Types:</p><p>Z = <strong>zstream()</strong></p><p>End the deflate session and cleans all data used. Note that this function will throw an <em>data_error</em> exception if the last call to <em>deflate/3</em> was not called with <em>Flush</em> set to <em>finish</em>.</p>
<pre>
<strong></strong>
inflateInit(Z) -&gt; ok

</pre>
<p>Types:</p><p>Z = <strong>zstream()</strong></p><p>Initialize a zlib stream for decompression.</p>
<pre>
<strong></strong>
inflateInit(Z, WindowBits) -&gt; ok

</pre>
<p>Types:</p><p>Z = <strong>zstream()</strong></p><p>WindowBits = <strong>zwindowbits()</strong></p><p>Initialize decompression session on zlib stream.</p><p>The <em>WindowBits</em> parameter is the base two logarithm of the maximum window size (the size of the history buffer). It should be in the range 9 through 15. The default value is 15 if <em>inflateInit/1</em> is used. If a compressed stream with a larger window size is given as input, inflate() will throw the <em>data_error</em> exception. A negative <em>WindowBits</em> value makes zlib ignore the zlib header (and checksum) from the stream. Note that the zlib source mentions this only as a undocumented feature.</p>
<pre>
<strong></strong>
inflate(Z, Data) -&gt; Decompressed

</pre>
<p>Types:</p><p>Z = <strong>zstream()</strong></p><p>Data = iodata()</p><p>Decompressed = iolist()</p><p><em>inflate/2</em> decompresses as much data as possible. It may some introduce some output latency (reading input without producing any output).</p><p>If a preset dictionary is needed at this point (see <em>inflateSetDictionary</em> below), <em>inflate/2</em> throws a <em>{need_dictionary,Adler}</em> exception where <em>Adler</em> is the adler32 checksum of the dictionary chosen by the compressor.</p>
<pre>
<strong></strong>
inflateSetDictionary(Z, Dictionary) -&gt; ok

</pre>
<p>Types:</p><p>Z = <strong>zstream()</strong></p><p>Dictionary = iodata()</p><p>Initializes the decompression dictionary from the given uncompressed byte sequence. This function must be called immediately after a call of <em>inflate/2</em> if this call threw a <em>{need_dictionary,Adler}</em> exception. The dictionary chosen by the compressor can be determined from the Adler value thrown by the call to <em>inflate/2</em>. The compressor and decompressor must use exactly the same dictionary (see <em>deflateSetDictionary/2</em>).</p><p>Example:</p>
<pre>
unpack(Z, Compressed, Dict) -&gt;
     case catch zlib:inflate(Z, Compressed) of
          {'EXIT',{{need_dictionary,DictID},_}} -&gt;
                   zlib:inflateSetDictionary(Z, Dict),
                 Uncompressed = zlib:inflate(Z, []);
          Uncompressed -&gt;
                 Uncompressed
     end.
</pre>

<pre>
<strong></strong>
inflateReset(Z) -&gt; ok

</pre>
<p>Types:</p><p>Z = <strong>zstream()</strong></p><p>This function is equivalent to <em>inflateEnd/1</em> followed by <em>inflateInit/1</em>, but does not free and reallocate all the internal decompression state. The stream will keep attributes that may have been set by <em>inflateInit/[1|2]</em>.</p>
<pre>
<strong></strong>
inflateEnd(Z) -&gt; ok

</pre>
<p>Types:</p><p>Z = <strong>zstream()</strong></p><p>End the inflate session and cleans all data used. Note that this function will throw a <em>data_error</em> exception if no end of stream was found (meaning that not all data has been uncompressed).</p>
<pre>
<strong></strong>
setBufSize(Z, Size) -&gt; ok

</pre>
<p>Types:</p><p>Z = <strong>zstream()</strong></p><p>Size = integer() &gt;= 0</p><p>Sets the intermediate buffer size.</p>
<pre>
<strong></strong>
getBufSize(Z) -&gt; Size

</pre>
<p>Types:</p><p>Z = <strong>zstream()</strong></p><p>Size = integer() &gt;= 0</p><p>Get the size of intermediate buffer.</p>
<pre>
<strong></strong>
crc32(Z) -&gt; CRC

</pre>
<p>Types:</p><p>Z = <strong>zstream()</strong></p><p>CRC = integer()</p><p>Get the current calculated CRC checksum.</p>
<pre>
<strong></strong>
crc32(Z, Data) -&gt; CRC

</pre>
<p>Types:</p><p>Z = <strong>zstream()</strong></p><p>Data = iodata()</p><p>CRC = integer()</p><p>Calculate the CRC checksum for <em>Data</em>.</p>
<pre>
<strong></strong>
crc32(Z, PrevCRC, Data) -&gt; CRC

</pre>
<p>Types:</p><p>Z = <strong>zstream()</strong></p><p>PrevCRC = integer()</p><p>Data = iodata()</p><p>CRC = integer()</p><p>Update a running CRC checksum for <em>Data</em>. If <em>Data</em> is the empty binary or the empty iolist, this function returns the required initial value for the crc.</p>
<pre>
Crc = lists:foldl(fun(Data,Crc0) -&gt;
                      zlib:crc32(Z, Crc0, Data),
                  end, zlib:crc32(Z,&lt;&lt; &gt;&gt;), Datas)
</pre>

<pre>
<strong></strong>
crc32_combine(Z, CRC1, CRC2, Size2) -&gt; CRC

</pre>
<p>Types:</p><p>Z = <strong>zstream()</strong></p><p>CRC = CRC1 = CRC2 = Size2 = integer()</p><p>Combine two CRC checksums into one. For two binaries or iolists, <em>Data1</em> and <em>Data2</em> with sizes of <em>Size1</em> and <em>Size2</em>, with CRC checksums <em>CRC1</em> and <em>CRC2</em>. <em>crc32_combine/4</em> returns the <em>CRC</em> checksum of <em>[Data1,Data2]</em>, requiring only <em>CRC1</em>, <em>CRC2</em>, and <em>Size2</em>.</p>
<pre>
<strong></strong>
adler32(Z, Data) -&gt; CheckSum

</pre>
<p>Types:</p><p>Z = <strong>zstream()</strong></p><p>Data = iodata()</p><p>CheckSum = integer()</p><p>Calculate the Adler-32 checksum for <em>Data</em>.</p>
<pre>
<strong></strong>
adler32(Z, PrevAdler, Data) -&gt; CheckSum

</pre>
<p>Types:</p><p>Z = <strong>zstream()</strong></p><p>PrevAdler = integer()</p><p>Data = iodata()</p><p>CheckSum = integer()</p><p>Update a running Adler-32 checksum for <em>Data</em>. If <em>Data</em> is the empty binary or the empty iolist, this function returns the required initial value for the checksum.</p>
<pre>
Crc = lists:foldl(fun(Data,Crc0) -&gt;
                      zlib:adler32(Z, Crc0, Data),
                  end, zlib:adler32(Z,&lt;&lt; &gt;&gt;), Datas)
</pre>

<pre>
<strong></strong>
adler32_combine(Z, Adler1, Adler2, Size2) -&gt; Adler

</pre>
<p>Types:</p><p>Z = <strong>zstream()</strong></p><p>Adler = Adler1 = Adler2 = Size2 = integer()</p><p>Combine two Adler-32 checksums into one. For two binaries or iolists, <em>Data1</em> and <em>Data2</em> with sizes of <em>Size1</em> and <em>Size2</em>, with Adler-32 checksums <em>Adler1</em> and <em>Adler2</em>. <em>adler32_combine/4</em> returns the <em>Adler</em> checksum of <em>[Data1,Data2]</em>, requiring only <em>Adler1</em>, <em>Adler2</em>, and <em>Size2</em>.</p>
<pre>
<strong></strong>
compress(Data) -&gt; Compressed

</pre>
<p>Types:</p><p>Data = iodata()</p><p>Compressed = binary()</p><p>Compress data (with zlib headers and checksum).</p>
<pre>
<strong></strong>
uncompress(Data) -&gt; Decompressed

</pre>
<p>Types:</p><p>Data = iodata()</p><p>Decompressed = binary()</p><p>Uncompress data (with zlib headers and checksum).</p>
<pre>
<strong></strong>
zip(Data) -&gt; Compressed

</pre>
<p>Types:</p><p>Data = iodata()</p><p>Compressed = binary()</p><p>Compress data (without zlib headers and checksum).</p>
<pre>
<strong></strong>
unzip(Data) -&gt; Decompressed

</pre>
<p>Types:</p><p>Data = iodata()</p><p>Decompressed = binary()</p><p>Uncompress data (without zlib headers and checksum).</p>
<pre>
<strong></strong>
gzip(Data) -&gt; Compressed

</pre>
<p>Types:</p><p>Data = iodata()</p><p>Compressed = binary()</p><p>Compress data (with gz headers and checksum).</p>
<pre>
<strong></strong>
gunzip(Data) -&gt; Decompressed

</pre>
<p>Types:</p><p>Data = iodata()</p><p>Decompressed = binary()</p><p>Uncompress data (with gz headers and checksum).</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="zip.3erl.html"><span aria-hidden="true">&larr;</span> zip.3erl: Utility for reading and creating 'zip' archives.</a></li>
   <li class="next"><a href="zlib_stub.3erl.html">zlib_stub.3erl: Zlib compression interface. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

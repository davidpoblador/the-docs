<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Term::ReadLine::Zoid: Another readline package</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Another readline package">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Term::ReadLine::Zoid (3pm) manual">
  <meta name="twitter:description" content="Another readline package">
  <meta name="twitter:image" content="https://www.carta.tech/images/libterm-readline-zoid-perl-Term::ReadLine::Zoid-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Term::ReadLine::Zoid.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Term::ReadLine::Zoid (3pm) manual" />
  <meta property="og:description" content="Another readline package" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libterm-readline-zoid-perl-Term::ReadLine::Zoid-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Term::ReadLine::Zoid<small> (3pm)</small></h1>
        <p class="lead">Another readline package</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Term::ReadLine::Zoid.3pm.html">
      <span itemprop="name">Term::ReadLine::Zoid: Another readline package</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libterm-readline-zoid-perl/">
      <span itemprop="name">libterm-readline-zoid-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Term::ReadLine::Zoid.3pm.html">
      <span itemprop="name">Term::ReadLine::Zoid: Another readline package</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
        # In your app:
        use Term::ReadLine;
        my $term = Term::ReadLine-&gt;new("my app");
</pre>
<p>        my $prompt = "eval: ";         my $OUT = $term-&gt;OUT || &#92;*STDOUT;         while ( defined ($_ = $term-&gt;readline($prompt)) ) {                 # Think while (&lt;STDIN&gt;) {}                 my $res = eval($_);                 warn $@ if $@;                 print $OUT $res, "&#92;n" unless $@;         }</p><p>        # In some rc file         export PERL_RL=Zoid</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This package provides a set of modules that form an interactive input buffer written in plain perl with minimal dependencies. It features almost all key-bindings described in the posix spec for the <em>sh</em>\|(1) utility with some extensions like multiline editing; this includes a vi-command mode with a save-buffer (for copy-pasting) and an undo-stack.</p><p>Historically this code was part of the Zoidberg shell, but this implementation is complete independent from zoid and uses the  Term::ReadLine interface, so it can be used with other perl programs.</p><p>( The documentation sometimes referes to 'the application', this is the program using the ReadLine module for input. )</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ENVIRONMENT</h2>
        <div class="sectioncontent">
<p>The Term::ReadLine interface module uses the \*(C`PERL_RL\*(C' variable to decide which module to load; so if you want to use this module for all your perl applications, try something like:</p><p>        export PERL_RL=Zoid</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">KEY MAPPING</h2>
        <div class="sectioncontent">
<p>The function name is given between parenthesis, these can be used for privat key maps.</p><p><strong>&#92;$1</strong></p><p>The default key mapping is as follows:</p>
<dl class='dl-vertical'>
  <dt>
    escape, ^[  (<em>switch_mode_command</em>)
  </dt>
  <dd>
    <p>Place the line editor in command mode, see Term::ReadLine::Zoid::ViCommand.</p>
  </dd>
  <dt>
    ^C  (<em>return_empty_string</em>)
  </dt>
  <dd>
    <p>End editing and return an empty string.</p>
  </dd>
  <dt>
    ^D  (<em>delete_char_or_eof</em>)
  </dt>
  <dd>
    <p>For a single line buffer ends editing and returns \*(C`undef\*(C' if the line is empty, else it deletes a char. For a multiline buffer, ends editing and returns the lines to the application if the cursor is on the last line and this line is empty, else it deletes a char. Note that the <em>delete_char_or_eof</em> function does what <em>delete_char</em> should do to be compatible with \s-1GNU\s0 readline lib.</p>
  </dd>
  <dt>
    delete  (<em>delete_char</em>)
  </dt>
  <dd>
    
  </dd>
  <dt>
    backspace, ^H, ^?  (<em>backward_delete_char</em>)
  </dt>
  <dd>
    <p>Delete and backspace kill the current or previous character. The key '^?' is by default considered a backspace because most modern keyboards use this key for the \*(L"backspace\*(R" key and an escape sequence for the \*(L"delete\*(R" key. Of course '^H' is also considered a backspace.</p>
  </dd>
  <dt>
    tab, ^I  (<em>complete</em>)
  </dt>
  <dd>
    <p>Try to complete the bigword on left of the cursor. There is no default completion included in this package, so unless you define a custom expansion it doesn't do anything. See the \*(L"completion_function\*(R" option. Uses the \s-1PAGER\s0 environment variable to find a suitable pager when there are more completions to be shown then would fit on the screen. See also the \*(L"autolist\*(R" and \*(L"maxcomplete\*(R" options.</p>
  </dd>
  <dt>
    return, ^J  (<em>accept_line</em>)
  </dt>
  <dd>
    <p>End editing and return the edit line to the application unless the newline is escaped. If _all_ lines in the buffer end with a single '&#92;', the newline is considered escaped you can continue typing on the next line. This behaviour can be a bit unexpected because this module has multiline support which historic readline implementations have not, historically the escaping of a newline is done by the application not by the library. The surpress this behaviour, and let the application do it's thing, disable the \*(L"automultiline\*(R" option. To enter the real multiline editing mode, press 'escape m', see Term::ReadLine::Zoid::MultiLine.</p>
  </dd>
  <dt>
    ^O  (<em>operate_and_get_next</em>)
  </dt>
  <dd>
    <p>Return the current buffer to the application but remember where we are in history. This can be used to quickly (re-)execute series of commands from history.</p>
  </dd>
  <dt>
    ^K  (<em>kill_line</em>)
  </dt>
  <dd>
    <p>Delete from cursor to the end of the line.</p>
  </dd>
  <dt>
    ^L  (<em>clear_screen</em>)
  </dt>
  <dd>
    <p>Clear entire screen. In contrast with other readline libraries, the prompt will remain at the bottom of the screen.</p>
  </dd>
  <dt>
    ^R  (<em>switch_mode_isearch</em>)
  </dt>
  <dd>
    <p>Enter incremental search mode, see Term::ReadLine::Zoid::ISearch.</p>
  </dd>
  <dt>
    ^U  (<em>unix_line_discard</em>)
  </dt>
  <dd>
    <p>This is also known as the \*(L"kill\*(R" char. It deletes all characters on the edit line and puts them in the save buffer. You can paste them back in later with 'escape-p'.</p>
  </dd>
  <dt>
    ^V  (<em>quoted_insert</em>)
  </dt>
  <dd>
    <p>Insert next key literally, ignoring any key-bindings. \s-1WARNING:\s0 control or escape chars in the editline can cause unexpected results</p>
  </dd>
  <dt>
    ^W  (<em>unix_word_rubout</em>)
  </dt>
  <dd>
    <p>Delete the word before the cursor.</p>
  </dd>
  <dt>
    insert  (<em>overwrite_mode</em>)
  </dt>
  <dd>
    <p>Toggle replace bit.</p>
  </dd>
  <dt>
    home, ^A  (<em>beginning_of_line</em>)
  </dt>
  <dd>
    <p>Move cursor to the begin of the edit line.</p>
  </dd>
  <dt>
    end, ^E  (<em>end_of_line</em>)
  </dt>
  <dd>
    <p>Move cursor to the end of the edit line.</p>
  </dd>
  <dt>
    left, ^B  (<em>backward_char</em>)
  </dt>
  <dd>
    
  </dd>
  <dt>
    right, ^F  (<em>forward_char</em>)
  </dt>
  <dd>
    <p>These keys can be used to move the cursor in the edit line.</p>
  </dd>
  <dt>
    up, page_up, ^P  (<em>previous_history</em>)
  </dt>
  <dd>
    
  </dd>
  <dt>
    down, page_down, ^N  (<em>next_history</em>)
  </dt>
  <dd>
    <p>These keys are used to rotate the history. The following keys are different in mutline mode, the others fall back to the default behaviour.</p>
  </dd>
  <dt>
    return (<em>insert_line</em>)
  </dt>
  <dd>
    <p>Insert a newline at the current cursor position.</p>
  </dd>
  <dt>
    up (<em>backward_line</em>)
  </dt>
  <dd>
    <p>Move the cursor one line up.</p>
  </dd>
  <dt>
    down (<em>forward_line</em>)
  </dt>
  <dd>
    <p>Move the cursor one line down.</p>
  </dd>
  <dt>
    page_up (<em>page_up</em>)
  </dt>
  <dd>
    <p>Move the cursor one screen down, or to the bottom of the buffer.</p>
  </dd>
  <dt>
    page_down (<em>page_down</em>)
  </dt>
  <dd>
    <p>Move the cursor one screen up, or to the top of the buffer.</p>
  </dd>
  <dt>
    <em>return_eof</em>
  </dt>
  <dd>
    <p>End editing and return \*(C`undef\*(C'.</p>
  </dd>
  <dt>
    <em>return_eof_maybe</em>
  </dt>
  <dd>
    <p>End editing and return \*(C`undef\*(C' if the buffer is completely empty.</p>
  </dd>
  <dt>
    <em>possible_completions</em>
  </dt>
  <dd>
    <p>Like <em>complete</em> but only shows the completions without actually doing them.</p>
  </dd>
  <dt>
    <em>redraw_current_line</em>
  </dt>
  <dd>
    <p>Redraw the current line. This is done all the time automaticly so you'll almost never need to call this one explicitly.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ATTRIBS</h2>
        <div class="sectioncontent">
<p>The hash with options can be accessed with the \*(L"Attribs\*(R" method. These can be modified from the rc-file (see \*(L"\s-1FILES\s0\*(R") or can be set from the \*(C`PERL_RL\*(C' environment variable. For example to disable the \*(L"autolist\*(R" feature you can set \*(C`PERL_RL='Zoid autolist=0'\*(C' before you start the application.</p><p>( Also they can be altered interactively using the mini-buffer of the command mode, see Term::ReadLine::Zoid::ViCommand. )</p>
<dl class='dl-vertical'>
  <dt>
    autohistory
  </dt>
  <dd>
    <p>If enabled lines are added to the history automaticly, subject to \*(L"MinLine\*(R". By default enabled.</p>
  </dd>
  <dt>
    autoenv
  </dt>
  <dd>
    <p>If enabled the environment variables \*(C`COLUMNS\*(C' and \*(C`LINES\*(C' are kept up to date. By default enabled.</p>
  </dd>
  <dt>
    autolist
  </dt>
  <dd>
    <p>If set completions are listed directly when a completion fails, if not set you need to press \*(L"tab\*(R" twice to see a list of possible completions. By default enabled.</p>
  </dd>
  <dt>
    automultiline
  </dt>
  <dd>
    <p>See \*(L"return\*(R" for a description. By default enabled.</p>
  </dd>
  <dt>
    beat
  </dt>
  <dd>
    <p>This option can contain a \s-1CODE\s0 reference. It is called on the heartbeat event.</p>
  </dd>
  <dt>
    bell
  </dt>
  <dd>
    <p>This option can contain a \s-1CODE\s0 reference. The default is \*(C`print "&#92;cG"\*(C', which makes the terminal ring a bell.</p>
  </dd>
  <dt>
    comment_begin
  </dt>
  <dd>
    <p>This option can be set to a string, if the edit line starts with this string the line is regarded to be a comment and is not returned to the application, but it will appear in the history if 'autohistory' is also set. Defaults to \*(L"#\*(R". When there are multiple lines in the buffer they all need to start with the comment string for the buffer to be regarded as a comment.</p>
  </dd>
  <dt>
    completion_function
  </dt>
  <dd>
    <p>This option can contain either a code ref or the name of a function to perform completion. For compatibility with Term::ReadLine::Perl the global scalar $readline::rl_completion_function will be checked if this option isn't defined. The function will get the following arguments: $word, $buffer, $start. Where $word is the word before the cursor, while $buffer is the complete text on the command line; $start is the offset of $word in $buffer. The function should return a list of possible completions of $word. The completion list is checked for double entries. There is <strong>no</strong> default. \s-1FIXME\s0 tell about the meta fields for advanced completion</p>
  </dd>
  <dt>
    default_mode
  </dt>
  <dd>
    <p>Specifies the mode the buffer starts in when you do a \*(C`readline()\*(C', also other modes return to this mode if you exit them. The default is 'insert' which is the single-line insert mode. If you always want to edit in multiline mode set this option to 'multiline'.</p>
  </dd>
  <dt>
    maxcomplete
  </dt>
  <dd>
    <p>Maximum number of completions to be displayed, when the number of completions is bigger the user is asked before displaying them. If set to zero completions are always displayed. If this option is set to the string 'pager' the user is asked when the number of completions is to big to fit on screen and a pager would be used.</p>
  </dd>
  <dt>
    minline
  </dt>
  <dd>
    <p>This option controls which lines are included in the history, lines shorter then this number are ignored. When set to \*(L"0\*(R" all lines are included in the history, when set to \*(C`undef\*(C' all lines are ignored. Defaults to \*(L"0\*(R".</p>
  </dd>
  <dt>
    \s-1PS2\s0
  </dt>
  <dd>
    <p>This option can contain the prompt to be used for extra buffer lines. It defaults to "&gt; ". Although the \*(L"\s-1PS1\s0\*(R" prompt (as specified as an argument to the \*(C`readline()\*(C' method) can contain newlines, the \s-1PS2\s0 prompt can't.</p>
  </dd>
  <dt>
    \s-1RPS1\s0
  </dt>
  <dd>
    <p>This option can contain a string that will be shown on the right side of the screen. This is known as the \*(L"right prompt\*(R" and the idea is stolen from <em>zsh</em>\|(1).</p>
  </dd>
  <dt>
    title
  </dt>
  <dd>
    <p>Used to set the terminal title, defaults to the appname.</p>
  </dd>
  <dt>
    low_latency
  </dt>
  <dd>
    <p>Changes the escape sequences are read from input. If true delays evalution of the escape key till the next char is known. By default disabled.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILES</h2>
        <div class="sectioncontent">
<p>This module reads a rc-file on intialisation, either <em>$HOME/.perl_rl_zoid_rc</em>, <em>$HOME/.zoid/perl_rl_zoid_rc</em> or <em>/etc/perl_rl_zoid_rc</em>. The rc-file is a perl script with access to the Term::ReadLine::Zoid object through the method \*(C`current()\*(C'. If you want to have different behaviour for different applications, try to check for \*(C`$rl-&gt;{appname}\*(C'.</p><p>        # in for example ~/.perl_rl_zoid_rc         my $rl = Term::ReadLine::Zoid-&gt;current();</p><p>        # set low latency         $rl-&gt;Attribs()-&gt;{low_latency} = 1;</p><p>        # alias control-space to escape         $rl-&gt;bindchr( <strong>chr</strong>(0), 'escape' );</p><p>        # create an ad hoc macro         $rl-&gt;bindkey('^P', sub { $rl-&gt;press('mplayer -vo sdl ') } );</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">
<p>Functions specified by the Term::ReadLine documentation. Simple constructor. Arguments are the application name (used for default prompt and title string) and optional filehandles for input and output. Returns the name of the current ReadLine module actually used. Returns a string entered by the user. The final newline is stripped, though the string might contain newlines elsewhere. The prompt only supports the escape \*(L"!\*(R" for the history number of the current line, use \*(L"!!\*(R" for a literal \*(L"!\*(R". All other escapes you need to parse yourself, before supplying the prompt. The prompt defaults to "$appname !&gt; ". If you want to do more with your prompt see Env::PS1. $preput can be used to set some text on the edit line allready. Add a command to the history (subject to the \*(L"minline\*(R" option). If \*(L"autohistory\*(R" is set this method will be called automaticly by \*(L"readline\*(R". Returns the filehandle used for input. Returns the filehandle used for output. Sets \*(L"minline\*(R" option to $value and returns old value. \s-1TODO\s0 - what uses does this have ? Returns a reference to the options hash. Returns a reference to a hash with names of implemented features. Be aware that the naming scheme is quite arbitrary, this module uses the same names as Term::ReadLine::Gnu for common features. Simple acces to the history arry, the \*(L"set\*(R" function supports both a list and a reference, the \*(L"get\*(R" function uses \*(L"wantarray\*(R". Not sure which behaviour is compatible with T:RL::Gnu. Returns number of columns and lines on the terminal. This method can be called to continue the previous \*(C`readline()\*(C' call. Can be used to build a custom auto-mulitline feature. Returns the current T:RL::Zoid object, for use in rc files, see \*(L"\s-1FILES\s0\*(R". Bind a \s-1CODE\s0 reference to a key, the function gets called when the key is typed with the key name as an argument. The $map argument is optional and can be either \*(L"default\*(R", \*(L"command\*(R", \*(L"isearch\*(R" or \*(L"multiline\*(R". If $sub is not a reference it is considered an alias; these aliases are not recursive. For alphanumeric characters the name is the character itself, special characters have long speaking names and control characters are prefixed with a '^'. Binding combination with the meta- or alt-key is not supported (see \*(L"\s-1NOTES\s0\*(R"). Methods for use in overload classes.</p><p><em>Avoid using these methods from the application.</em> Switch to input mode $mode; changes the key map and reblesses the object if the \*(C`_on_switch\*(C' key returns a class name. Reset all temporary attributes. Returns a ref with a copy of some temporary attributes. Can be used to switch between multiple edit lines in combination with \*(L"restore\*(R". Restores saved attributes. Sets history entry $int in the buffer. Returns the longest match among the completions followed by the completions itself. Used for completion functions.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DEVELOPMENT</h2>
        <div class="sectioncontent">
<p>\s-1FIXME\s0 minimum subroutines new mode-class</p><p>\s-1FIXME\s0 how to set up a keymap</p><p>\s-1FIXME\s0 how to add a keymap/mode</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTES</h2>
        <div class="sectioncontent">
<p>With most modern keymappings the combination of the meta key (alt) with a letter is identical with an escape character followed by that letter.</p><p>Some functioality may in time be moved to the ::Base package.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TODO</h2>
        <div class="sectioncontent">
<p>\s-1UTF8\s0 support, or general charset support, would be nice but at the moment I lack the means to test these things. If anyone has ideas or suggestions about this please contact me.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>Line wrap doesn't always displays the last character on the line right, no functional bug though.</p><p>If the buffer size exceeds the screen size some bugs appear in the rendering.</p><p>Please mail the author if you find any other bugs.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Jaap Karssenberg || Pardus [Larus] &lt;pardus@cpan.org&gt;</p><p>Copyright (c) 2004 Jaap G Karssenberg. All rights reserved. This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Term::ReadLine::Zoid&hellip;</h2>
        <div class="sectioncontent">
<p>Term::ReadLine::Zoid::ViCommand, Term::ReadLine::Zoid::MultiLine, Term::ReadLine::Zoid::ISearch, Term::ReadLine::Zoid::FileBrowse, Term::ReadLine::Zoid::Base, Term::ReadLine, Env::PS1, Zoidberg</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Term::Query.3pm.html"><span aria-hidden="true">&larr;</span> Term::Query.3pm: Table-driven query routine.</a></li>
   <li class="next"><a href="Term::ReadLine::Zoid::Base.3pm.html">Term::ReadLine::Zoid::Base.3pm: Atomic routines <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

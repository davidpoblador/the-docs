<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>XML::Checker: A perl module for validating xml</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="A perl module for validating xml">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="XML::Checker (3pm) manual">
  <meta name="twitter:description" content="A perl module for validating xml">
  <meta name="twitter:image" content="https://www.carta.tech/images/libxml-checker-perl-XML::Checker-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/XML::Checker.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="XML::Checker (3pm) manual" />
  <meta property="og:description" content="A perl module for validating xml" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libxml-checker-perl-XML::Checker-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">XML::Checker<small> (3pm)</small></h1>
        <p class="lead">A perl module for validating xml</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/XML::Checker.3pm.html">
      <span itemprop="name">XML::Checker: A perl module for validating xml</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libxml-checker-perl/">
      <span itemprop="name">libxml-checker-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/XML::Checker.3pm.html">
      <span itemprop="name">XML::Checker: A perl module for validating xml</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>XML::Checker::Parser - an XML::Parser that validates at parse time</p><p>XML::DOM::ValParser - an XML::DOM::Parser that validates at parse time</p><p>(Some of the package names may change! This is only an alpha release...)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>XML::Checker can be used in different ways to validate \s-1XML\s0. See the manual pages of XML::Checker::Parser and XML::DOM::ValParser for more information.</p><p>This document only describes common topics like error handling and the XML::Checker class itself.</p><p>\s-1WARNING:\s0 Not all errors are currently checked. Almost everything is subject to change. Some reported errors may not be real errors.  For production code, it is recommended that you use XML::LibXML or \s-1XML::GDOME\s0 instead of XML::Checker.  Both modules share the same \s-1DTD\s0 validation code with libxml2 and XML::LibXML is easier to install.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ERROR HANDLING</h2>
        <div class="sectioncontent">
<p>Whenever XML::Checker (or one of the packages that uses XML::Checker) detects a potential error, the 'fail handler' is called. It is currently also called to report information, like how many times an Entity was referenced. (The whole error handling mechanism is subject to change, I'm afraid...)</p><p>The default fail handler is <em>XML::Checker::print_error()</em>, which prints an error message to \s-1STDERR\s0. It does not stop the XML::Checker, so it will continue looking for other errors. The error message is created with <em>XML::Checker::error_string()</em>.</p><p>You can define your own fail handler in two ways, locally and globally. Use a local variable to temporarily override the fail handler. This way the default fail handler is restored when the local variable goes out of scope, esp. when exceptions are thrown e.g.</p>
<pre>
 # Using a local variable to temporarily override the fail handler (preferred)
 { # new block - start of local scope
   local $XML::Checker::FAIL = &#92;&my_fail;
   ... your code here ...
 } # end of block - the previous fail handler is restored
</pre>
<p>You can also set the error handler globally, risking that your code may not be reusable or may clash with other modules that use XML::Checker.</p><p> # Globally setting the fail handler (not recommended)  $XML::Checker::FAIL = &#92;&my_fail;  ... rest of your code ...</p><p>The fail handler is called with the following parameters ($code, $msg, @context), where $code is the error code, $msg is the error description and @context contains information on where the error occurred. The @context is a (ordered) list of (key,value) pairs and can easily be turned into a hash. It contains the following information:</p><p> Element - tag name of Element node (if applicable)  Attr - attribute name (if applicable)  ChildElementIndex - if applicable (see error 157)  line - only when parsing  column - only when parsing  byte - only when parsing (-1 means: end of file)</p><p>Some examples of fail handlers:</p><p> # Don&apos;t print info messages  sub my_fail  {      my $code = shift;      print STDERR XML::Checker::error_message ($code, @_)          if $code &lt; 300;  }</p><p> # Die when the first error is encountered - this will stop  # the parsing process. Ignore information messages.  sub my_fail  {      my $code = shift;      die XML::Checker::error_message ($code, @_) if $code &lt; 300;  }</p><p> # Count the number of undefined NOTATION references  # and print the error as usual  sub my_fail  {      my $code = shift;      $count_undef_notations++ if $code == 100;      XML::Checker::print_error ($code, @_);  }</p><p> # Die when an error is encountered.  # Don&apos;t die if a warning or info message is encountered, just print a message.  sub my_fail {      my $code = shift;      die XML::Checker::error_string ($code, @_) if $code &lt; 200;      XML::Checker::print_error ($code, @_);  }</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INSIGNIFICANT WHITESPACE</h2>
        <div class="sectioncontent">
<p>XML::Checker keeps track of whether whitespace found in character data is significant or not. It is considered insignicant if it is found inside an element that has a \s-1ELEMENT\s0 rule that is not of type Mixed or of type \s-1ANY\s0. (A Mixed \s-1ELEMENT\s0 rule does contains the #PCDATA keyword. An \s-1ANY\s0 rule contains the \s-1ANY\s0 keyword. See the \s-1XML\s0 spec for more info.)</p><p>XML::Checker can not determine whether whitespace is insignificant in those two cases, because they both allow regular character data to appear within \s-1XML\s0 elements and XML::Checker can therefore not deduce whether whitespace is part of the actual data or was just added for readability of the \s-1XML\s0 file.</p><p>XML::Checker::Parser and XML::DOM::ValParser both have the option to skip insignificant whitespace when setting <strong>SkipInsignifWS</strong> to 1 in their constructor. If set, they will not call the Char handler when insignificant whitespace is encountered. This means that in XML::DOM::ValParser no Text nodes are created for insignificant whitespace.</p><p>Regardless of whether the SkipInsignifWS options is set, XML::Checker always keeps track of whether whitespace is insignificant. After making a call to XML::Checker's Char handler, you can find out if it was insignificant whitespace by calling the isInsignifWS method.</p><p>When using multiple (nested) XML::Checker instances or when using XML::Checker without using XML::Checker::Parser or XML::DOM::ValParser (which hardly anybody probably will), make sure to set a local variable in the scope of your checking code, e.g.</p><p>  { # new block - start of local scope     local $XML::Checker::INSIGNIF_WS = 0;     ... insert your code here ...   } # end of scope</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ERROR CODES</h2>
        <div class="sectioncontent">
<p>There are 3 categories, errors, warnings and info messages. (The codes are still subject to change, as well the error descriptions.)</p><p>Most errors have a link to the appropriate Validaty Constraint (<strong>\s-1VC\s0</strong>) or other section in the \s-1XML\s0 specification.</p><h3>\s-1ERROR\s0 Messages</h3>

<h3>100 - 109</h3>
<ul>
<li><p><strong>100</strong> - undefined \s-1NOTATION\s0 [$notation] in \s-1ATTLIST\s0 The \s-1ATTLIST\s0 contained a Notation reference that was not defined in a \s-1NOTATION\s0 definition. <strong>\s-1VC:\s0</strong> Notation Attributes &lt;http://www.w3.org/TR/REC-xml#notatn&gt;</p></li><li><p><strong>101</strong> - undefined \s-1ELEMENT\s0 [$tagName] The specified Element was never defined in an \s-1ELEMENT\s0 definition. This is not an error according to the \s-1XML\s0 spec. See Element Type Declarations &lt;http://www.w3.org/TR/REC-xml#elemdecls&gt;</p></li><li><p><strong>102</strong> - undefined unparsed \s-1ENTITY\s0 [$entity] The attribute value referenced an undefined unparsed entity. <strong>\s-1VC:\s0</strong> Entity Name &lt;http://www.w3.org/TR/REC-xml#entname&gt;</p></li><li><p><strong>103</strong> - undefined attribute [$attrName] The specified attribute was not defined in an \s-1ATTLIST\s0 for that Element. <strong>\s-1VC:\s0</strong> Attribute Value Type &lt;http://www.w3.org/TR/REC-xml#ValueType&gt;</p></li>
</ul>
<h3>110 - 119</h3>
<ul>
<li><p><strong>110</strong> - attribute [$attrName] of element [$tagName] already defined The specified attribute was already defined in this \s-1ATTLIST\s0 definition or in a previous one. This is not an error according to the \s-1XML\s0 spec. See Attribute-List Declarations &lt;http://www.w3.org/TR/REC-xml#attdecls&gt;</p></li><li><p><strong>111</strong> - \s-1ID\s0 [$value] already defined An \s-1ID\s0 with the specified value was already defined in an attribute within the same document. <strong>\s-1VC:\s0</strong> \s-1ID\s0 &lt;http://www.w3.org/TR/REC-xml#id&gt;</p></li><li><p><strong>112</strong> - unparsed \s-1ENTITY\s0 [$entity] already defined This is not an error according to the \s-1XML\s0 spec. See Entity Declarations &lt;http://www.w3.org/TR/REC-xml#sec-entity-decl&gt;</p></li><li><p><strong>113</strong> - \s-1NOTATION\s0 [$notation] already defined</p></li><li><p><strong>114</strong> - \s-1ENTITY\s0 [$entity] already defined This is not an error according to the \s-1XML\s0 spec. See Entity Declarations &lt;http://www.w3.org/TR/REC-xml#sec-entity-decl&gt;</p></li><li><p><strong>115</strong> - \s-1ELEMENT\s0 [$name] already defined <strong>\s-1VC:\s0</strong> Unique Element Type Declaration &lt;http://www.w3.org/TR/REC-xml#EDUnique&gt;</p></li>
</ul>
<h3>120 - 129</h3>
<ul>
<li><p><strong>120</strong> - invalid default \s-1ENTITY\s0 [$default] (Or \s-1IDREF\s0 or \s-1NMTOKEN\s0 instead of \s-1ENTITY\s0.) The \s-1ENTITY\s0, \s-1IDREF\s0 or \s-1NMTOKEN\s0 reference in the default attribute value for an attribute with types \s-1ENTITY\s0, \s-1IDREF\s0 or \s-1NMTOKEN\s0 was not valid. <strong>\s-1VC:\s0</strong> Attribute Default Legal &lt;http://www.w3.org/TR/REC-xml#defattrvalid&gt;</p></li><li><p><strong>121</strong> - invalid default [$token] in \s-1ENTITIES\s0 [$default] (Or \s-1IDREFS\s0 or \s-1NMTOKENS\s0 instead of \s-1ENTITIES\s0) One of the \s-1ENTITY\s0, \s-1IDREF\s0 or \s-1NMTOKEN\s0 references in the default attribute value for an attribute with types \s-1ENTITIES\s0, \s-1IDREFS\s0 or \s-1NMTOKENS\s0 was not valid. <strong>\s-1VC:\s0</strong> Attribute Default Legal &lt;http://www.w3.org/TR/REC-xml#defattrvalid&gt;</p></li><li><p><strong>122</strong> - invalid default attribute value [$default] The specified default attribute value is not a valid attribute value. <strong>\s-1VC:\s0</strong> Attribute Default Legal &lt;http://www.w3.org/TR/REC-xml#defattrvalid&gt;</p></li><li><p><strong>123</strong> - invalid default \s-1ID\s0 [$default], must be #REQUIRED or #IMPLIED The default attribute value for an attribute of type \s-1ID\s0 has to be #REQUIRED or #IMPLIED. <strong>\s-1VC:\s0</strong> \s-1ID\s0 Attribute Default &lt;http://www.w3.org/TR/REC-xml#id-default&gt;</p></li><li><p><strong>124</strong> - bad model [$model] for \s-1ELEMENT\s0 [$name] The model in the \s-1ELEMENT\s0 definition did not conform to the \s-1XML\s0 syntax for Mixed models. See Mixed Content &lt;http://www.w3.org/TR/REC-xml#sec-mixed-content&gt;</p></li>
</ul>
<h3>130 - 139</h3>
<ul>
<li><p><strong>130</strong> - invalid \s-1NMTOKEN\s0 [$attrValue] The attribute value is not a valid NmToken token. <strong>\s-1VC:\s0</strong> Enumeration &lt;http://www.w3.org/TR/REC-xml#enum&gt;</p></li><li><p><strong>131</strong> - invalid \s-1ID\s0 [$attrValue] The specified attribute value is not a valid Name token. <strong>\s-1VC:\s0</strong> \s-1ID\s0 &lt;http://www.w3.org/TR/REC-xml#id&gt;</p></li><li><p><strong>132</strong> - invalid \s-1IDREF\s0 [$value] The specified attribute value is not a valid Name token. <strong>\s-1VC:\s0</strong> \s-1IDREF\s0 &lt;http://www.w3.org/TR/REC-xml#idref&gt;</p></li><li><p><strong>133</strong> - invalid \s-1ENTITY\s0 name [$name] The specified attribute value is not a valid Name token. <strong>\s-1VC:\s0</strong> Entity Name &lt;http://www.w3.org/TR/REC-xml#entname&gt;</p></li><li><p><strong>134</strong> - invalid Enumeration value [$value] in \s-1ATTLIST\s0 The specified value is not a valid NmToken (see \s-1XML\s0 spec for def.) See definition of NmToken &lt;http://www.w3.org/TR/REC-xml#NT-Nmtoken&gt;</p></li><li><p><strong>135</strong> - empty \s-1NOTATION\s0 list in \s-1ATTLIST\s0 The \s-1NOTATION\s0 list of the \s-1ATTLIST\s0 definition did not contain any \s-1NOTATION\s0 references. See definition of NotationType &lt;http://www.w3.org/TR/REC-xml#NT-NotationType&gt;</p></li><li><p><strong>136</strong> - empty Enumeration list in \s-1ATTLIST\s0 The \s-1ATTLIST\s0 definition of the attribute of type Enumeration did not contain any values. See definition of Enumeration &lt;http://www.w3.org/TR/REC-xml#NT-Enumeration&gt;</p></li><li><p><strong>137</strong> - invalid \s-1ATTLIST\s0 type [$type] The attribute type has to be one of: \s-1ID\s0, \s-1IDREF\s0, \s-1IDREFS\s0, \s-1ENTITY\s0, \s-1ENTITIES\s0, \s-1NMTOKEN\s0, \s-1NMTOKENS\s0, \s-1CDATA\s0, \s-1NOTATION\s0 or an Enumeration. See definition of AttType &lt;http://www.w3.org/TR/REC-xml#NT-AttType&gt;</p></li>
</ul>
<h3>149 - 159</h3>
<ul>
<li><p><strong>149</strong> - invalid text content [$value] A text was found in an element that should only include sub-elements The text is not made of non-significant whitespace. <strong>150</strong> - bad #FIXED attribute value [$value], it should be [$default] The specified attribute was defined as #FIXED in the \s-1ATTLIST\s0 definition and the found attribute $value differs from the specified $default value. <strong>\s-1VC:\s0</strong> Fixed Attribute Default &lt;http://www.w3.org/TR/REC-xml#FixedAttr&gt;</p></li><li><p><strong>151</strong> - only one \s-1ID\s0 allowed in \s-1ATTLIST\s0 per element first=[$attrName] The \s-1ATTLIST\s0 definitions for an Element may contain only one attribute with the type \s-1ID\s0. The specified $attrName is the one that was found first. <strong>\s-1VC:\s0</strong> One \s-1ID\s0 per Element Type &lt;http://www.w3.org/TR/REC-xml#one-id-per-el&gt;</p></li><li><p><strong>152</strong> - Element should be \s-1EMPTY\s0, found Element [$tagName] The \s-1ELEMENT\s0 definition for the specified Element said it should be \s-1EMPTY\s0, but a child Element was found. <strong>\s-1VC:\s0</strong> Element Valid (sub1) &lt;http://www.w3.org/TR/REC-xml#elementvalid&gt;</p></li><li><p><strong>153</strong> - Element should be \s-1EMPTY\s0, found text [$text] The \s-1ELEMENT\s0 definition for the specified Element said it should be \s-1EMPTY\s0, but text was found. Currently, whitespace is not allowed between the open and close tag. (This may be wrong, please give feedback.) To allow whitespace (subject to change), set:     $XML::Checker::Context::EMPTY::ALLOW_WHITE_SPACE = 1; <strong>\s-1VC:\s0</strong> Element Valid (sub1) &lt;http://www.w3.org/TR/REC-xml#elementvalid&gt;</p></li><li><p><strong>154</strong> - bad order of Elements Found=[$found] RE=[$re] The child elements of the specified Element did not match the regular expression found in the \s-1ELEMENT\s0 definition. $found contains a comma separated list of all the child element tag names that were found. $re contains the (decoded) regular expression that was used internally. <strong>\s-1VC:\s0</strong> Element Valid &lt;http://www.w3.org/TR/REC-xml#elementvalid&gt;</p></li><li><p><strong>155</strong> - more than one root Element [$tags] An \s-1XML\s0 Document may only contain one Element. $tags is a comma separated list of element tag names encountered sofar. XML::Parser (expat) throws 'no element found' exception. See two_roots.xml for an example. See definition of document &lt;http://www.w3.org/TR/REC-xml#dt-root&gt;</p></li><li><p><strong>156</strong> - unexpected root Element [$tagName], expected [$rootTagName] The tag name of the root Element of the \s-1XML\s0 Document differs from the name specified in the \s-1DOCTYPE\s0 section. XML::Parser (expat) throws 'not well-formed' exception. See bad_root.xml for an example. <strong>\s-1VC:\s0</strong> Root Element Type &lt;http://www.w3.org/TR/REC-xml#vc-roottype&gt;</p></li><li><p><strong>157</strong> - unexpected Element [$tagName] The \s-1ELEMENT\s0 definition for the specified Element does not allow child Elements with the specified $tagName. <strong>\s-1VC:\s0</strong> Element Valid &lt;http://www.w3.org/TR/REC-xml#elementvalid&gt; The error context contains ChildElementIndex which is the index within its parent Element (counting only Element nodes.)</p></li><li><p><strong>158</strong> - unspecified value for #IMPLIED attribute [$attrName] The \s-1ATTLIST\s0 for the specified attribute said the attribute was #IMPLIED, which means the user application should supply a value, but the attribute value was not specified. (User applications should pass a value and set $specified to 1 in the Attr handler.)</p></li><li><p><strong>159</strong> - unspecified value for #REQUIRED attribute [$attrName] The \s-1ATTLIST\s0 for the specified attribute said the attribute was #REQUIRED, which means that a value should have been specified. <strong>\s-1VC:\s0</strong> Required Attribute &lt;http://www.w3.org/TR/REC-xml#RequiredAttr&gt;</p></li>
</ul>
<h3>160 - 169</h3>
<ul>
<li><p><strong>160</strong> - invalid Enumeration value [$attrValue] The specified attribute value does not match one of the Enumeration values in the \s-1ATTLIST\s0. <strong>\s-1VC:\s0</strong> Enumeration &lt;http://www.w3.org/TR/REC-xml#enum&gt;</p></li><li><p><strong>161</strong> - invalid \s-1NOTATION\s0 value [$attrValue] The specified attribute value was not found in the list of possible \s-1NOTATION\s0 references as found in the \s-1ATTLIST\s0 definition. <strong>\s-1VC:\s0</strong> Notation Attributes &lt;http://www.w3.org/TR/REC-xml#notatn&gt;</p></li><li><p><strong>162</strong> - undefined \s-1NOTATION\s0 [$attrValue] The \s-1NOTATION\s0 referenced by the specified attribute value was not defined. <strong>\s-1VC:\s0</strong> Notation Attributes &lt;http://www.w3.org/TR/REC-xml#notatn&gt;</p></li>
</ul>
<h3>\s-1WARNING\s0 Messages (200 and up)</h3>
<ul>
<li><p><strong>200</strong> - undefined \s-1ID\s0 [$id] was referenced [$n] times The specified \s-1ID\s0 was referenced $n times, but never defined in an attribute value with type \s-1ID\s0. <strong>\s-1VC:\s0</strong> \s-1IDREF\s0 &lt;http://www.w3.org/TR/REC-xml#idref&gt;</p></li>
</ul>
<h3>\s-1INFO\s0 Messages (300 and up)</h3>
<ul>
<li><p><strong>300</strong> - [$n] references to \s-1ID\s0 [$id] The specified \s-1ID\s0 was referenced $n times.</p></li>
</ul>
<h3>Not checked</h3>
<p>The following errors are already checked by XML::Parser (expat) and are currently not checked by XML::Checker:</p><p>(?? \s-1TODO\s0 - add more info)</p>
<dl class='dl-vertical'>
  <dt>
    root element is missing
  </dt>
  <dd>
    <p>XML::Parser (expat) throws 'no element found' exception. See no_root.xml for an example.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">XML::Checker</h2>
        <div class="sectioncontent">
<p>XML::Checker can be easily plugged into your application. It uses mostly the same style of event handlers (or callbacks) as XML::Parser. See XML::Parser manual page for descriptions of most handlers.</p><p>It also implements PerlSAX style event handlers. See \*(L"PerlSAX interface\*(R".</p><p>Currently, the XML::Checker object is a blessed hash with the following (potentially useful) entries:</p><p> $checker-&gt;{RootElement} - root element name as found in the DOCTYPE  $checker-&gt;{NOTATION}-&gt;{$notation} - is 1 if the NOTATION was defined  $checker-&gt;{ENTITY}-&gt;{$name} - contains the (first) ENTITY value if defined  $checker-&gt;{Unparsed}-&gt;{$entity} - is 1 if the unparsed ENTITY was defined  $checker-&gt;{ID}-&gt;{$id} - is 1 if the ID was defined  $checker-&gt;{IDREF}-&gt;{$id} - number of times the ID was referenced</p><p> # Less useful:  $checker-&gt;{ERule}-&gt;{$tag} - the ELEMENT rules by Element tag name  $checker-&gt;{ARule}-&gt;{$tag} - the ATTLIST rules by Element tag name  $checker-&gt;{Context} - context stack used internally  $checker-&gt;{CurrARule} - current ATTLIST rule for the current Element</p><h3>XML:Checker methods</h3>
<p>This section is only interesting when using XML::Checker directly. XML::Checker supports most event handlers that XML::Parser supports with minor differences. Note that the XML::Checker event handler methods are instance methods and not static, so don't forget to call them like this, without passing $expat (as in the XML::Parser) handlers:</p><p> $checker-&gt;Start($tagName);</p>
<dl class='dl-vertical'>
  <dt>
    Constructor
  </dt>
  <dd>
    <p> $checker = new XML::Checker;  $checker = new XML::Checker (%user_args); User data may be stored by client applications. Only $checker-&gt;{User} is guaranteed not to clash with internal hash keys.</p>
  </dd>
  <dt>
    getRootElement ()
  </dt>
  <dd>
    <p> $tagName = $checker-&gt;getRootElement; Returns the root element name as found in the \s-1DOCTYPE\s0</p>
  </dd>

</dl>

<h3>Expat interface</h3>
<p>XML::Checker supports what I call the <em>Expat</em> interface, which is the collection of methods you normally specify as the callback handlers when using XML::Parser.</p><p>Only the following XML::Parser handlers are currently supported: Init, Final, Char, Start, End, Element, Attlist, Doctype, Unparsed, Entity, Notation.</p><p>I don't know how to correctly support the Default handler for all XML::Parser releases. The Start handler works a little different (see below) and I added Attr, InitDomElem, FinalDomElem, \s-1CDATA\s0 and EntityRef handlers. See XML::Parser for a description of the handlers that are not listed below.</p><p>Note that this interface may disappear, when the PerlSAX interface stabilizes.</p>
<dl class='dl-vertical'>
  <dt>
    Start ($tag)
  </dt>
  <dd>
    <p> $checker-&gt;Start($tag); Call this when an Element with the specified $tag name is encountered. Different from the Start handler in XML::Parser, in that no attributes are passed in (use the Attr handler for those.)  $checker-&gt;Attr($tag,$attrName,$attrValue,$spec); Checks an attribute with the specified $attrName and $attrValue against the \s-1ATTLIST\s0 definition of the element with the specified $tag name. $isSpecified means whether the attribute was specified (1) or defaulted (0).</p>
  </dd>
  <dt>
    EndAttr ()
  </dt>
  <dd>
    <p> $checker-&gt;EndAttr; This should be called after all attributes are passed with <em>Attr()</em>. It will check which of the #REQUIRED attributes were not specified and generate the appropriate error (159) for each one that is missing.</p>
  </dd>
  <dt>
    \s-1CDATA\s0 ($text)
  </dt>
  <dd>
    <p> $checker-&gt;CDATA($text); This should be called whenever CDATASections are encountered. Similar to Char handler (but might perform different checks later...)  $checker-&gt;EntityRef($entity,$isParameterEntity); Checks the \s-1ENTITY\s0 reference. Set $isParameterEntity to 1 for entity references that start with '%'.</p>
  </dd>
  <dt>
    InitDomElem () and FinalDomElem ()
  </dt>
  <dd>
    <p>Used by <em>XML::DOM::Element::check()</em> to initialize (and cleanup) the context stack when checking a single element.</p>
  </dd>

</dl>

<h3>PerlSAX interface</h3>
<p>XML::Checker now also supports the PerlSAX interface, so you can use XML::Checker wherever you use PerlSAX handlers.</p><p>XML::Checker implements the following methods: start_document, end_document, start_element, end_element, characters, processing_instruction, comment, start_cdata, end_cdata, entity_reference, notation_decl, unparsed_entity_decl, entity_decl, element_decl, attlist_decl, doctype_decl, xml_decl</p><p>Not implemented: set_document_locator, ignorable_whitespace</p><p>See PerlSAX.pod for details. (It is called lib/PerlSAX.pod in the libxml-perl distribution which can be found at \s-1CPAN\s0.)</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CAVEATS</h2>
        <div class="sectioncontent">
<p>This is an alpha release.  It is not actively maintained, patches are accepted and incoporated in new releases, but that's about it.  If you are interested in taking over maintimance of the module, email tjmather@tjmather.com.</p><p>For a much faster, and correct \s-1DTD\s0 validator, see XML::LibXML.  It uses the libxml2 library to validate \s-1DTD\s0.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Enno Derksen is the original author.</p><p>Send patches to T.J. Mather at &lt;<em>tjmather@tjmather.com</em>&gt;.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO XML::Checker&hellip;</h2>
        <div class="sectioncontent">
<p>XML::LibXML provides validating parsers against a \s-1DTD\s0 and is recommended over XML::Checker since it uses the libxml2 library which is fast and well-tested.</p><p>The \s-1XML\s0 spec (Extensible Markup Language 1.0) at http://www.w3.org/TR/REC-xml &lt;http://www.w3.org/TR/REC-xml&gt;</p><p>The XML::Parser and XML::Parser::Expat manual pages.</p><p>The other packages that come with XML::Checker: XML::Checker::Parser, XML::DOM::ValParser</p><p>The \s-1DOM\s0 Level 1 specification at http://www.w3.org/TR/REC-DOM-Level-1 &lt;http://www.w3.org/TR/REC-DOM-Level-1&gt;</p><p>The PerlSAX specification. It is currently in lib/PerlSAX.pod in the libxml-perl distribution by Ken MacLeod.</p><p>The original \s-1SAX\s0 specification (Simple \s-1API\s0 for \s-1XML\s0) can be found at &lt;http://www.megginson.com/SAX&gt; and &lt;http://www.megginson.com/SAX/SAX2&gt;</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="XML::CSV.3pm.html"><span aria-hidden="true">&larr;</span> XML::CSV.3pm: Perl extension converting csv files to xml</a></li>
   <li class="next"><a href="XML::Checker::Parser.3pm.html">XML::Checker::Parser.3pm: An xml::parser that validates at parse time <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

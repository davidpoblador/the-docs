<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>libexpect: Programmed dialogue library with interactive programs</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Programmed dialogue library with interactive programs">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="libexpect (3) manual">
  <meta name="twitter:description" content="Programmed dialogue library with interactive programs">
  <meta name="twitter:image" content="https://www.carta.tech/images/tcl-expect-dev-libexpect-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/libexpect.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="libexpect (3) manual" />
  <meta property="og:description" content="Programmed dialogue library with interactive programs" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/tcl-expect-dev-libexpect-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">libexpect<small> (3)</small></h1>
        <p class="lead">Programmed dialogue library with interactive programs</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/libexpect.3.html">
      <span itemprop="name">libexpect: Programmed dialogue library with interactive programs</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/tcl-expect-dev/">
      <span itemprop="name">tcl-expect-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/libexpect.3.html">
      <span itemprop="name">libexpect: Programmed dialogue library with interactive programs</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This library contains functions that allow Expect to be used as a Tcl extension or to be used directly from C or C++ (without Tcl). Adding Expect as a Tcl extension is very short and simple, so that will be covered first.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
<strong>#include expect_tcl.h</strong>
<strong>Expect_Init(interp);</strong>

<strong>cc files... -lexpect5.20 -ltcl7.5 -lm</strong>

</pre>
<p>Note: library versions may differ in the actual release.</p><p>The Expect_Init function adds expect commands to the named interpreter.  It avoids overwriting commands that already exist, however aliases beginning with "exp_" are always created for expect commands.  So for example, "send" can be used as "exp_send".</p><p>Generally, you should only call Expect commands via Tcl_Eval. Certain auxiliary functions may be called directly.  They are summarized below.  They may be useful in constructing your own main.  Look at the file exp_main_exp.c in the Expect distribution as a prototype main.  Another prototype is tclAppInit.c in the Tcl source distribution.  A prototype for working with Tk is in exp_main_tk.c in the Expect distribution.</p>
<pre>
int exp_cmdlinecmds;
int exp_interactive;
FILE *exp_cmdfile;
char *exp_cmdfilename;
int exp_tcl_debugger_available;

void	exp_parse_argv(Tcl_Interp *,int argc,char **argv);
int	exp_interpreter(Tcl_Interp *);
void	exp_interpret_cmdfile(Tcl_Interp *,FILE *);
void	exp_interpret_cmdfilename(Tcl_Interp *,char *);
void	exp_interpret_rcfiles(Tcl_Interp *,int my_rc,int sys_rc);
char *	exp_cook(char *s,int *len);
void	(*exp_app_exit)EXP_PROTO((Tcl_Interp *);
void	exp_exit(Tcl_Interp *,int status);
void	exp_exit_handlers(Tcl_Interp *);
void	exp_error(Tcl_Interp,char *,...);

</pre>
<p><strong>exp_cmdlinecmds</strong> is 1 if Expect has been invoked with commands on the program command-line (using "-c" for example). <strong>exp_interactive</strong> is 1 if Expect has been invoked with the -i flag or if no commands or script is being invoked. <strong>exp_cmdfile</strong> is a stream from which Expect will read commands. <strong>exp_cmdfilename</strong> is the name of a file which Expect will open and read commands from. <strong>exp_tcl_debugger_available</strong> is 1 if the debugger has been armed.</p><p><strong>exp_parse_argv</strong> reads the representation of the command line. Based on what is found, any of the other variables listed here are initialized appropriately. <strong>exp_interpreter</strong> interactively prompts the user for commands and evaluates them. <strong>exp_interpret_cmdfile</strong> reads the given stream and evaluates any commands found. <strong>exp_interpret_cmdfilename</strong> opens the named file and evaluates any commands found. <strong>exp_interpret_rcfiles</strong> reads and evalutes the .rc files.  If my_rc is zero, then ~/.expectrc is skipped.  If sys_rc is zero, then the system-wide expectrc file is skipped. <strong>exp_cook</strong> returns a static buffer containing the argument reproduced with newlines replaced by carriage-return linefeed sequences. The primary purpose of this is to allow messages to be produced without worrying about whether the terminal is in raw mode or cooked mode. If length is zero, it is computed via strlen. <strong>exp_error is a printf-like function that writes the result</strong> to interp-&gt;result.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
<strong>#include &lt;expect.h&gt;</strong>

<strong>int</strong>
<strong>exp_spawnl(file, arg0 [, arg1, ..., argn] (char *)0);</strong>
<strong>char *file;</strong>
<strong>char *arg0, *arg1, ... *argn;</strong>

<strong>int</strong>
<strong>exp_spawnv(file,argv);</strong>
<strong>char *file, *argv[ ];</strong>

<strong>int</strong>
<strong>exp_spawnfd(fd);</strong>
<strong>int fd;</strong>

<strong>FILE *</strong>
<strong>exp_popen(command);</strong>
<strong>char *command;</strong>

<strong>extern int exp_pid;</strong>
<strong>extern int exp_ttyinit;</strong>
<strong>extern int exp_ttycopy;</strong>
<strong>extern int exp_console;</strong>
<strong>extern char *exp_stty_init;</strong>
<strong>extern void (*exp_close_in_child)();</strong>
<strong>extern void (*exp_child_exec_prelude)();</strong>
<strong>extern void exp_close_tcl_files();</strong>

<strong>cc files... -lexpect -ltcl -lm</strong>
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><strong>exp_spawnl</strong> and <strong>exp_spawnv</strong> fork a new process so that its stdin, stdout, and stderr can be written and read by the current process. <em>file</em> is the name of a file to be executed.  The <em>arg</em> pointers are null-terminated strings.  Following the style of execve(), <em>arg0</em> (or <em>argv[0]</em>) is customarily a duplicate of the name of the file.</p><p>Four interfaces are available, <strong>exp_spawnl</strong> is useful when the number of arguments is known at compile time. <strong>exp_spawnv</strong> is useful when the number of arguments is not known at compile time. <strong>exp_spawnfd</strong> is useful when an open file descriptor is already available as a source. <strong>exp_popen</strong> is explained later on.</p><p>If the process is successfully created, a file descriptor is returned which corresponds to the process's stdin, stdout and stderr. A stream may be associated with the file descriptor by using fdopen(). (This should almost certainly be followed by setbuf() to unbuffer the I/O.)</p><p>Closing the file descriptor will typically be detected by the process as an EOF.  Once such a process exits, it should be waited upon (via wait) in order to free up the kernel process slot.  (Some systems allow you to avoid this if you ignore the SIGCHLD signal).</p><p><strong>exp_popen</strong> is yet another interface, styled after popen().  It takes a Bourne shell command line, and returns a stream that corresponds to the process's stdin, stdout and stderr.  The actual implementation of <strong>exp_popen</strong> below demonstrates <strong>exp_spawnl</strong>.</p>
<pre>
FILE *
exp_popen(program)
char *program;
{
	FILE *fp;
	int ec;

	if (0 &gt; (ec = exp_spawnl("sh","sh","-c",program,(char *)0)))
		<strong>return</strong>(0);
	if (NULL == (fp = fdopen(ec,"r+")) <strong>return</strong>(0);
	setbuf(fp,(char *)0);
	return(fp);
}
</pre>
<p>After a process is started, the variable <strong>exp_pid</strong> is set to the process-id of the new process.  The variable <strong>exp_pty_slave_name</strong> is set to the name of the slave side of the pty.</p><p>The spawn functions uses a pty to communicate with the process.  By default, the pty is initialized the same way as the user's tty (if possible, i.e., if the environment has a controlling terminal.)  This initialization can be skipped by setting exp_ttycopy to 0.</p><p>The pty is further initialized to some system wide defaults if exp_ttyinit is non-zero.  The default is generally comparable to "stty sane".</p><p>The tty setting can be further modified by setting the variable <strong>exp_stty_init</strong>. This variable is interpreted in the style of stty arguments.  For example, exp_stty_init = "sane"; repeats the default initialization.</p><p>On some systems, it is possible to redirect console output to ptys. If this is supported, you can force the next spawn to obtain the console output by setting the variable <strong>exp_console</strong> to 1.</p><p>Between the time a process is started and the new program is given control, the spawn functions can clean up the environment by closing file descriptors.  By default, the only file descriptors closed are ones internal to Expect and any marked "close-on-exec".</p><p>If needed, you can close additional file descriptors by creating an appropriate function and assigning it to exp_close_in_child. The function will be called after the fork and before the exec. (This also modifies the behavior of the spawn command in Expect.)</p><p>If you are also using Tcl, it may be convenient to use the function exp_close_tcl_files which closes all files between the default standard file descriptors and the highest descriptor known to Tcl. (Expect does this.)</p><p>The function exp_child_exec_prelude is the last function called prior to the actual exec in the child.  You can redefine this for effects such as manipulating the uid or the signals.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">IF YOU WANT TO ALLOCATE YOUR OWN PTY</h2>
        <div class="sectioncontent">

<pre>
<strong>extern int exp_autoallocpty;</strong>
<strong>extern int exp_pty[2];</strong>
</pre>
<p>The spawn functions use a pty to communicate with the process.  By default, a pty is automatically allocated each time a process is spawned. If you want to allocate ptys yourself, before calling one of the spawn functions, set <strong>exp_autoallocpty</strong> to 0, <strong>exp_pty[0]</strong> to the master pty file descriptor and <strong>exp_pty[1]</strong> to the slave pty file descriptor. The expect library will not do any pty initializations (e.g., exp_stty_init will not be used). The slave pty file descriptor will be automatically closed when the process is spawned.  After the process is started, all further communication takes place with the master pty file descriptor.</p><p><strong>exp_spawnl</strong> and <strong>exp_spawnv</strong> duplicate the shell's actions in searching for an executable file in a list of directories.  The directory list is obtained from the environment.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPECT PROCESSING</h2>
        <div class="sectioncontent">
<p>While it is possible to use read() to read information from a process spawned by <strong>exp_spawnl</strong> or <strong>exp_spawnv</strong>, more convenient functions are provided.  They are as follows:</p>
<pre>
<strong>int</strong>
<strong>exp_expectl(fd,type1,pattern1,[re1,],value1,type2,...,exp_end);</strong>
<strong>int fd;</strong>
<strong>enum exp_type type;</strong>
<strong>char *pattern1, *pattern2, ...;</strong>
<strong>regexp *re1, *re2, ...;</strong>
<strong>int value1, value2, ...;</strong>
<strong></strong>

<strong>int</strong>
<strong>exp_fexpectl(fp,type1,pattern1,[re1,]value1,type2,...,exp_end);</strong>
<strong>FILE *fp;</strong>
<strong>enum exp_type type;</strong>
<strong>char *pattern1, *pattern2, ...;</strong>
<strong>regexp *re1, *re2, ...;</strong>
<strong>int value1, value2, ...;</strong>

<strong>enum exp_type {</strong>
<strong>exp_end,</strong>
<strong>exp_glob,</strong>
<strong>exp_exact,</strong>
<strong>exp_regexp,</strong>
<strong>exp_compiled,</strong>
<strong>exp_null,</strong>
<strong>};</strong>

<strong>struct exp_case {</strong>
<strong>char *pattern;</strong>
<strong>regexp *re;</strong>
<strong>enum exp_type type;</strong>
<strong>int value;</strong>
<strong>};</strong>

<strong>int</strong>
<strong>exp_expectv(fd,cases);</strong>
<strong>int fd;</strong>
<strong>struct exp_case *cases;</strong>

<strong>int</strong>
<strong>exp_fexpectv(fp,cases);</strong>
<strong>FILE *fp;</strong>
<strong>struct exp_case *cases;</strong>

<strong>extern int exp_timeout;</strong>
<strong>extern char *exp_match;</strong>
<strong>extern char *exp_match_end;</strong>
<strong>extern char *exp_buffer;</strong>
<strong>extern char *exp_buffer_end;</strong>
<strong>extern int exp_match_max;</strong>
<strong>extern int exp_full_buffer;</strong>
<strong>extern int exp_remove_nulls;</strong>
</pre>
<p>The functions wait until the output from a process matches one of the patterns, a specified time period has passed, or an EOF is seen.</p><p>The first argument to each function is either a file descriptor or a stream. Successive sets of arguments describe patterns and associated integer values to return when the pattern matches.</p><p>The type argument is one of four values.  exp_end indicates that no more patterns appear. exp_glob indicates that the pattern is a glob-style string pattern. exp_exact indicates that the pattern is an exact string. exp_regexp indicates that the pattern is a regexp-style string pattern. exp_compiled indicates that the pattern is a regexp-style string pattern, and that its compiled form is also provided. exp_null indicates that the pattern is a null (for debugging purposes, a string pattern must also follow).</p><p>If the compiled form is not provided with the functions <strong>exp_expectl</strong> and <strong>exp_fexpectl</strong>, any pattern compilation done internally is thrown away after the function returns.  The functions <strong>exp_expectv</strong> and <strong>exp_fexpectv</strong> will automatically compile patterns and will not throw them away. Instead, they must be discarded by the user, by calling free on each pattern.  It is only necessary to discard them, the last time the cases are used.</p><p>Regexp subpatterns matched are stored in the compiled regexp. Assuming "re" contains a compiled regexp, the matched string can be found in re-&gt;startp[0].  The match substrings (according to the parentheses) in the original pattern can be found in re-&gt;startp[1], re-&gt;startp[2], and so on, up to re-&gt;startp[9].  The corresponding strings ends are re-&gt;endp[x] where x is that same index as for the string start.</p><p>The type exp_null matches if a null appears in the input.  The variable exp_remove_nulls must be set to 0 to prevent nulls from being automatically stripped.  By default, exp_remove_nulls is set to 1 and nulls are automatically stripped.</p><p><strong>exp_expectv</strong> and <strong>exp_fexpectv</strong> are useful when the number of patterns is not known in advance.  In this case, the sets are provided in an array. The end of the array is denoted by a struct exp_case with type exp_end. For the rest of this discussion, these functions will be referred to generically as <em>expect.</em></p><p>If a pattern matches, then the corresponding integer value is returned. Values need not be unique, however they should be positive to avoid being mistaken for EXP_EOF, EXP_TIMEOUT, or EXP_FULLBUFFER. Upon EOF or timeout, the value <strong>EXP_EOF</strong> or <strong>EXP_TIMEOUT</strong> is returned.  The default timeout period is 10 seconds but may be changed by setting the variable <strong>exp_timeout</strong>. A value of -1 disables a timeout from occurring. A value of 0 causes the expect function to return immediately (i.e., poll) after one read(). However it must be preceded by a function such as select, poll, or an event manager callback to guarantee that there is data to be read.</p><p>If the variable exp_full_buffer is 1, then EXP_FULLBUFFER is returned if exp_buffer fills with no pattern having matched.</p><p>When the expect function returns, <strong>exp_buffer</strong> points to the buffer of characters that was being considered for matching. <strong>exp_buffer_end</strong> points to one past the last character in exp_buffer. If a match occurred, <strong>exp_match</strong> points into <strong>exp_buffer</strong> where the match began. <strong>exp_match_end</strong> points to one character past where the match ended.</p><p>Each time new input arrives, it is compared to each pattern in the order they are listed.  Thus, you may test for absence of a match by making the last pattern something guaranteed to appear, such as a prompt.  In situations where there is no prompt, you must check for <strong>EXP_TIMEOUT</strong> (just like you would if you were interacting manually).  More philosophy and strategies on specifying <strong>expect</strong> patterns can be found in the documentation on the <strong>expect</strong> program itself.  See SEE ALSO below.</p><p>Patterns are the usual C-shell-style regular expressions.  For example, the following fragment looks for a successful login, such as from a telnet dialogue.</p>
<pre>
	switch (exp_expectl(
		exp_glob,"connected",CONN,
		exp_glob,"busy",BUSY,
		exp_glob,"failed",ABORT,
		exp_glob,"invalid password",ABORT,
		exp_end)) {
	case CONN:	/* logged in successfully */
		break;
	case BUSY:	/* couldn't log in at the moment */
		break;
	case EXP_TIMEOUT:
	case ABORT:	/* can't log in at any moment! */
		break;
	default: /* problem with expect */
	}
</pre>
<p>Asterisks (as in the example above) are a useful shorthand for omitting line-termination characters and other detail. Patterns must match the entire output of the current process (since the previous read on the descriptor or stream). More than 2000 bytes of output can force earlier bytes to be "forgotten".  This may be changed by setting the variable <strong>exp_match_max</strong>. Note that excessively large values can slow down the pattern matcher.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RUNNING IN THE BACKGROUND</h2>
        <div class="sectioncontent">

<pre>
<strong>extern int exp_disconnected;</strong>
<strong>int exp_disconnect();</strong>

</pre>
<p>It is possible to move a process into the background after it has begun running.  A typical use for this is to read passwords and then go into the background to sleep before using the passwords to do real work.</p><p>To move a process into the background, fork, call exp_disconnect() in the child process and exit() in the parent process.  This disassociates your process from the controlling terminal.  If you wish to move a process into the background in a different way, you must set the variable exp_disconnected to 1.  This allows processes spawned after this point to be started correctly.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MULTIPLEXING</h2>
        <div class="sectioncontent">
<p>By default, the expect functions block inside of a read on a single file descriptor.  If you want to wait on patterns from multiple file descriptors, use select, poll, or an event manager. They will tell you what file descriptor is ready to read.</p><p>When a file descriptor is ready to read, you can use the expect functions to do one and only read by setting timeout to 0.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SLAVE CONTROL</h2>
        <div class="sectioncontent">

<pre>
<strong>void</strong>
<strong>exp_slave_control(fd,enable)</strong>
<strong>int fd;</strong>
<strong>int enable;</strong>

</pre>
<p>Pty trapping is normally done automatically by the expect functions. However, if you want to issue an ioctl, for example, directly on the slave device, you should temporary disable trapping.</p><p>Pty trapping can be controlled with exp_slave_control.  The first argument is the file descriptor corresponding to the spawned process. The second argument is a 0 if trapping is to be disabled and 1 if it is to be enabled.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ERRORS</h2>
        <div class="sectioncontent">
<p>All functions indicate errors by returning -1 and setting errno.</p><p>Errors that occur after the spawn functions fork (e.g., attempting to spawn a non-existent program) are written to the process's stderr, and will be read by the first <strong>expect</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SIGNALS</h2>
        <div class="sectioncontent">

<pre>
<strong>extern int exp_reading;</strong>
<strong>extern jmp_buf exp_readenv;</strong>
</pre>
<p><strong>expect</strong> uses alarm() to timeout, thus if you generate alarms during <strong>expect</strong>, it will timeout prematurely.</p><p>Internally, <strong>expect</strong> calls read() which can be interrupted by signals.  If you define signal handlers, you can choose to restart or abort <strong>expect</strong>'s internal read.  The variable, <strong>exp_reading</strong>, is true if (and only if) <strong>expect</strong>'s read has been interrupted.  longjmp(exp_readenv,EXP_ABORT) will abort the read.  longjmp(exp_readenv,EXP_RESTART) will restart the read.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LOGGING</h2>
        <div class="sectioncontent">

<pre>
<strong>extern int exp_loguser;</strong>
<strong>extern int exp_logfile_all</strong>
<strong>extern FILE *exp_logfile;</strong>
</pre>
<p>If <strong>exp_loguser</strong> is nonzero, <strong>expect</strong> sends any output from the spawned process to stdout.  Since interactive programs typically echo their input, this usually suffices to show both sides of the conversation.  If <strong>exp_logfile</strong> is also nonzero, this same output is written to the stream defined by <strong>exp_logfile</strong>. If <strong>exp_logfile_all</strong> is non-zero, <strong>exp_logfile</strong> is written regardless of the value of <strong>exp_loguser</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DEBUGGING</h2>
        <div class="sectioncontent">
<p>While I consider the library to be easy to use, I think that the standalone expect program is much, much, easier to use than working with the C compiler and its usual edit, compile, debug cycle.  Unlike typical C programs, most of the debugging isn't getting the C compiler to accept your programs - rather, it is getting the dialogue correct. Also, translating scripts from expect to C is usually not necessary. For example, the speed of interactive dialogues is virtually never an issue.  So please try the standalone 'expect' program first.  I suspect it is a more appropriate solution for most people than the library.</p><p>Nonetheless, if you feel compelled to debug in C, here are some tools to help you.</p>
<pre>
<strong>extern int exp_is_debugging;</strong>
<strong>extern FILE *exp_debugfile;</strong>
</pre>
<p>While expect dialogues seem very intuitive, trying to codify them in a program can reveal many surprises in a program's interface.  Therefore a variety of debugging aids are available.  They are controlled by the above variables, all 0 by default.</p><p>Debugging information internal to <strong>expect</strong> is sent to stderr when <strong>exp_is_debugging</strong> is non-zero.  The debugging information includes every character received, and every attempt made to match the current input against the patterns.  In addition, non-printable characters are translated to a printable form.  For example, a control-C appears as a caret followed by a C.  If <strong>exp_logfile</strong> is non-zero, this information is also written to that stream.</p><p>If <strong>exp_debugfile</strong> is non-zero, all normal and debugging information is written to that stream, regardless of the value of <strong>exp_is_debugging</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CAVEATS</h2>
        <div class="sectioncontent">
<p>The stream versions of the <strong>expect</strong> functions are much slower than the file descriptor versions because there is no way to portably read an unknown number of bytes without the potential of timing out. Thus, characters are read one at a time.  You are therefore strongly encouraged to use the file descriptor versions of <strong>expect</strong> (although, automated versions of interactive programs don't usually demand high speed anyway).</p><p>You can actually get the best of both worlds, writing with the usual stream functions and reading with the file descriptor versions of <strong>expect</strong> as long as you don't attempt to intermix other stream input functions (e.g., fgetc). To do this, pass fileno(stream) as the file descriptor each time. Fortunately, there is little reason to use anything but the <strong>expect</strong> functions when reading from interactive programs.</p><p>There is no matching exp_pclose to exp_popen (unlike popen and pclose). It only takes two functions to close down a connection (fclose() followed by waiting on the pid), but it is not uncommon to separate these two actions by large time intervals, so the function seems of little value.</p><p>If you are running on a Cray running Unicos (all I know for sure from experience), you must run your compiled program as root or setuid.  The problem is that the Cray only allows root processes to open ptys. You should observe as much precautions as possible:  If you don't need permissions, <strong>setuid</strong>(0) only immediately before calling one of the spawn functions and immediately set it back afterwards.</p><p>Normally, <strong>spawn</strong> takes little time to execute.  If you notice spawn taking a significant amount of time, it is probably encountering ptys that are wedged.  A number of tests are run on ptys to avoid entanglements with errant processes.  (These take 10 seconds per wedged pty.)  Running expect with the -d option will show if <strong>expect</strong> is encountering many ptys in odd states.  If you cannot kill the processes to which these ptys are attached, your only recourse may be to reboot.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>The <strong>exp_fexpect</strong> functions don't work at all under HP-UX - it appears to be a bug in getc. Follow the advice (above) about using the <strong>exp_expect</strong> functions (which doesn't need to call getc).  If you fix the problem (before I do - please check the latest release) let me know.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO libexpect&hellip;</h2>
        <div class="sectioncontent">
<p>An alternative to this library is the <strong>expect</strong> program. <strong>expect</strong> interprets scripts written in a high-level language which direct the dialogue. In addition, the user can take control and interact directly when desired. If it is not absolutely necessary to write your own C program, it is much easier to use <strong>expect</strong> to perform the entire interaction. It is described further in the following references:</p><p><em></em> "expect: Curing Those Uncontrollable Fits of Interactivity" by Don Libes, Proceedings of the Summer 1990 USENIX Conference, Anaheim, California, June 11-15, 1990.</p><p><em></em> "Using expect to Automate System Administration Tasks" by Don Libes, Proceedings of the 1990 USENIX Large Installation Systems Administration Conference, Colorado Springs, Colorado, October 17-19, 1990.</p><p><a href="../man1/expect.1.html"><strong>expect</strong>(1)</a>, <strong>alarm</strong>(3), <a href="../man2/read.2.html"><strong>read</strong>(2)</a>, <a href="../man2/write.2.html"><strong>write</strong>(2)</a>, <a href="../man3/fdopen.3.html"><strong>fdopen</strong>(3)</a>, <a href="../man2/execve.2.html"><strong>execve</strong>(2)</a>, <a href="../man3/execvp.3.html"><strong>execvp</strong>(3)</a>, <a href="../man3/longjmp.3.html"><strong>longjmp</strong>(3)</a>, <strong>pty</strong>(4).</p><p>There are several examples C programs in the test directory of <strong>expect</strong>'s source distribution which use the expect library.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Don Libes, libes@nist.gov, National Institute of Standards and Technology</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ACKNOWLEDGEMENTS</h2>
        <div class="sectioncontent">
<p>Thanks to John Ousterhout (UCBerkeley) for supplying the pattern matcher.</p><p>Design and implementation of the <strong>expect</strong> library was paid for by the U.S. government and is therefore in the public domain. However the author and NIST would like credit if this program and documentation or portions of them are used.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="libemu.3.html"><span aria-hidden="true">&larr;</span> libemu.3: Emulate x86 shellcodes</a></li>
   <li class="next"><a href="libexslt.3.html">libexslt.3: Extension library for xslt <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>afnix-net: Standard networking module</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Standard networking module">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="afnix-net (3) manual">
  <meta name="twitter:description" content="Standard networking module">
  <meta name="twitter:image" content="https://www.carta.tech/images/afnix-afnix-net-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/afnix-net.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="afnix-net (3) manual" />
  <meta property="og:description" content="Standard networking module" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/afnix-afnix-net-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">afnix-net<small> (3)</small></h1>
        <p class="lead">Standard networking module</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/afnix-net.3.html">
      <span itemprop="name">afnix-net: Standard networking module</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/afnix/">
      <span itemprop="name">afnix</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/afnix-net.3.html">
      <span itemprop="name">afnix-net: Standard networking module</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">STANDARD NETWORKING MODULE</h2>
        <div class="sectioncontent">
<p>The Standard Networking module is an original implementation of networking facilities for the Internet Protocol. The module features standard TCP and UDP sockets for point to point communication as well as multicast socket. Numerous functions and objects for address manipulation are also included in this module. This module is also designed to support IP version 6 with certain platforms.</p><p><strong>IP address</strong></p><p>The IP based communication uses a standard address to reference a particular peer. With IP version 4, the standard dot notation is with 4 bytes. With IP version 6, the standard semicolon notation is with 16 bytes. The current implementation supports both versions.</p>
<pre>
127.0.0.1       # ipv4 localhost
0:0:0:0:0:0:0:1 # ipv6 localhost
</pre>
<p>IP address architecture and behavior are described in various documents as listed in the bibliography.</p><p><em>Domain name system</em></p><p>The translation between a host name and an IP address is performed by a resolver which uses the Domain Name System or DNS. Access to the DNS is automatic with the implementation. Depending on the machine resolver configuration, a particular domain name translation might result in an IP version 4 or IP version 6 address. Most of the time, an IP version 4 address is returned. The mapping between an IP address and a host name returns the associated canonical name for that IP address. This is the reverse of the preceding operation.</p><p><strong>The Address class</strong></p><p>The Address class allows manipulation of IP address. The constructor takes a string as its arguments. The argument string can be either an IP address or a host name which can be qualified or not. When the address is constructed with a host name, the IP address resolution is done immediately.</p><p><em>Name to address translation</em></p><p>The most common operation is to translate a host name to its equivalent IP address. Once the Address object is constructed, the get-address method returns a string representation of the internal IP address. The following example prints the IP address of the localhost, that is 127.0.0.1 with IP version 4.</p>
<pre>
# load network module
interp:library "afnix-net"
# get the localhost address
const addr (afnix:net:Address "localhost")
# print the ip address
println (addr:get-address)
</pre>
<p>As another example, the get-host-name function returns the host name of the running machine. The previous example can be used to query its IP address.</p><p><em>Address to name translation</em></p><p>The reverse operation of name translation maps an IP address to a canonical name. It shall be noted that the reverse lookup is not done automatically, unless the reverse flag is set in the constructoor. The get-canonical-name method of the Address class returns such name. Example XNET001.als is a demonstration program which prints the address original name, the IP address and the canonical name. Fell free to use it with your favorite site to check the equivalence between the original name and the canonical name.</p>
<pre>
# print the ip address information of the arguments
# usage: axi XNET001.als [hosts ...]
# get the network module
interp:library "afnix-net"
# print the ip address
const ip-address-info (host) {
  try {
    const addr (afnix:net:Address host true)
    println "host name        : " (addr:get-name)
    println "  ip address     : " (addr:get-address)
    println "  canonical name : " (
      addr:get-canonical-name)
    # get aliases
    const size (addr:get-alias-size)
    loop (trans i 0) (&lt; i size) (i:++) {
      println "  alias address  : " (
        addr:get-alias-address i)
      println "  alias name     : " (
        addr:get-alias-name i)
    }
  } (errorln "error: " what:reason)
}
# get the hosts
for (s) (interp:argv) (ip-address-info s)
zsh&gt; axi net-0001.als localhost
host name        : localhost
ip address     : 127.0.0.1
canonical name : localhost
</pre>
<p><em>Address operations</em></p><p>The Address class provides several methods and operators that ease the address manipulation in a protocol indepedant way. For example, the == operator compares two addresses. The ++ operator can also be used to get the next IP address.</p><p><strong>Transport layers</strong></p><p>The two transport layer protocols supported by the Internet protocol is the TCP, a full-duplex oriented protocol, and UDP, a datagram protocol. TCP is a reliable protocol while UDP is not. By reliable, we mean that the protocol provides automatically some mechanisms for error recovery, message delivery, acknowledgment of reception, etc... The use of TCP vs. UDP is dictated mostly by the reliability concerns, while UDP reduces the traffic congestion.</p><p><em>Service port</em></p><p>In the client-server model, a connection is established between two hosts. The connections is made via the IP address and the port number. For a given service, a port identifies that service at a particular address. This means that multiple services can exist at the same address. More precisely, the transport layer protocol is also used to distinguish a particular service. The network module provides a simple mechanism to retrieve the port number, given its name and protocol. The function get-tcp-service and get-udp-service returns the port number for a given service by name. For example, the daytime server is located at port number 13.</p>
<pre>
assert 13 (afnix:net:get-tcp-service "daytime")
assert 13 (afnix:net:get-udp-service "daytime")
</pre>
<p><em>Host and peer</em></p><p>With the client server model, the only information needed to identify a particular client or server is the address and the port number. When a client connects to a server, it specify the port number the server is operating. The client uses a random port number for itself. When a server is created, the port number is used to bind the server to that particular port. If the port is already in use, that binding will fail. From a reporting point of view, a connection is therefore identified by the running host address and port, and the peer address and port. For a client, the peer is the server. For a server, the peer is the client.</p><p><strong>TCP client socket</strong></p><p>The TcpClient class creates an TCP client object by address and port. The address can be either a string or an Address object. During the object construction, the connection is established with the server. Once the connection is established, the client can use the read and write method to communicate with the server. The TcpClient class is derived from the Socket class which is derived from the InputStream and OutputStream classes.</p><p><em>Day time client</em></p><p>The simplest example is a client socket which communicates with the daytime server. The server is normally running on all machines and is located at port 13.</p>
<pre>
# get the network module
interp:library "afnix-net"
# get the daytime server port
const port (afnix:net:get-tcp-service "daytime")
# create a tcp client socket
const s (afnix:net:TcpClient "localhost" port)
# read the data - the server close the connection
while (s:valid-p) (println (s:readln))
</pre>
<p>Example 3201.als in the example directory prints the day time of the local host without argument or the day time of the argument. Feel free to use it with www.afnix.org. If the server you are trying to contact does not have a day time server, an exception will be raised and the program terminates.</p>
<pre>
zsh&gt; axi 3201.als www.afnix.org
</pre>
<p><em>HTTP request example</em></p><p>Another example which illustrates the use of the TcpClient object is a simple client which download a web page. At this stage we are not concern with the URL but rather the mechanics involved. The request is made by opening a TCP client socket on port 80 (the HTTP server port) and sending a request by writing some HTTP commands. When the commands have been sent, the data sent by the server are read and printed on the standard output. Note that this example is not concerned by error detection.</p>
<pre>
# fetch an html page by host and page
# usage: axi 3203.als [host] [page]
# get the network module
interp:library "afnix-net"
interp:library "afnix-sys"
# connect to the http server and issue a request
const send-http-request (host page) {
  # create a client sock on port 80
  const s     (afnix:net:TcpClient host 80)
  const saddr (s:get-socket-address)
  # format the request
  s:writeln "GET " page " HTTP/1.1"
  s:writeln "Host: " (saddr:get-canonical-name)
  s:writeln "Connection: close"
  s:writeln "User-Agent: afnix tcp client example"
  s:newline
  # write the result
  while (s:valid-p) (println (s:readln))
}
# get the argument
if (!= (interp:argv:length) 2) (afnix:sys:exit 1)
const host (interp:argv:get 0)
const page (interp:argv:get 1)
# send request
send-http-request host page
</pre>
<p><strong>UDP client socket</strong></p><p>UDP client socket is similar to TCP client socket. However, due to the unreliable nature of UDP, UDP clients are somehow more difficult to manage. Since there is no flow control, it becomes more difficult to assess whether or not a datagram has reached its destination. The same apply for a server, where a reply datagram might be lost. The UdpClient class is the class which creates a UDP client object. Its usage is similar to the TcpClient.</p><p><em>The time client</em></p><p>The UDP time server normally runs on port 37 is the best place to enable it. A UDP client is created with the UdpClient class. Once the object is created, the client sends an empty datagram to the server. The server send a reply datagram with 4 bytes, in network byte order, corresponding to the date as of January 1st 1900. Example 3204.als prints date information after contacting the local host time server or the host specified as the first argument.</p>
<pre>
# get the libraries
interp:library "afnix-net"
interp:library "afnix-sys"
# get the daytime server port
const port (afnix:net:get-udp-service "time")
# create a client socket and read the data
const print-time (host) {
  # create a udp client socket
  const s (afnix:net:UdpClient host port)
  # send an empty datagram
  s:write
  # read the 4 bytes data and adjust to epoch
  const buf (s:read 4)
  const val (- (buf:get-quad) 2208988800)
  # format the date
  const time (afnix:sys:Time val)
  println (time:format-date) ' ' (time:format-time)
}
# check for one argument or use localhost
const host (if (== (interp:argv:length) 0)
  "localhost" (interp:argv:get 0))
print-time host
</pre>
<p>This example calls for several comments. First the write method without argument sends an empty datagram. It is the datagram which trigger the server. The read method reads 4 bytes from the reply datagram and places them in a Buffer object. Since the bytes are in network byte order, the conversion into an integer value is done with the get-quad method. Finally, in order to use the Time class those epoch is January 1st 1970, the constant 2208988800 is subtracted from the result. Remember that the time server sends the date in reference to January 1st 1900. More information about the time server can be found in RFC738.</p><p><em>More on reliability</em></p><p>The previous example has some inherent problems due to the unreliability of UDP. If the first datagram is lost, the read method will block indefinitely. Another scenario which causes the read method to block is the loss of the server reply datagram. Both problem can generally be fixed by checking the socket with a timeout using the valid-p method. With one argument, the method timeout and return false. In this case, a new datagram can be send to the server. Example 3205.als illustrates this point. We print below the extract of code.</p>
<pre>
# create a client socket and read the data
const print-time (host) {
  # create a udp client socket
  const s (afnix:net:UdpClient host port)
  # send an empty datagram until the socket is valid
  s:write
  # retransmit datagram each second
  while (not (s:valid-p 1000)) (s:write)
  # read the 4 bytes data and adjust to epoch
  const buf (s:read 4)
  const val (- (buf:get-quad) 2208988800)
  # format the date
  const time (afnix:sys:Time val)
  println (time:format-date) ' ' (time:format-time)
}
</pre>
<p>Note that this solution is a naive one. In the case of multiple datagrams, a sequence number must be placed because there is no clue about the lost datagram. A simple rule of thumb is to use TCP as soon as reliability is a concern, but this choice might not so easy.</p><p><em>Error detection</em></p><p>Since UDP is not reliable, there is no simple solution to detect when a datagram has been lost. Even worse, if the server is not running, it is not easy to detect that the client datagram has been lost. In such situation, the client might indefinitely send datagram without getting an answer. One solution to this problem is again to count the number of datagram re-transmit and eventually give up after a certain time.</p><p><strong>Socket class</strong></p><p>The Socket class is the base class for both TcpClient and UdpClient. The class provides methods to query the socket port and address as well as the peer port and address. Note at this point that the UDP socket is a connected socket. Therefore, these methods will work fine. The get-socket-address and get-socket-port returns respectively the address and port of the connected socket. The get-peer-address and get-peer-port returns respectively the address and port of the connected socket's peer. Example 3206.als illustrates the use of these methods.</p>
<pre>
# create a client socket and read the data
const print-socket-info (host) {
  # create a tcp client socket
  const s (afnix:net:TcpClient host port)
  # print socket address and port
  const saddr (s:get-socket-address)
  const sport (s:get-socket-port)
  println "socket ip address     : " (
    saddr:get-address)
  println "socket canonical name : " (
    saddr:get-canonical-name)
  println "socket port           : " sport
  # print peer address and port
  const paddr (s:get-peer-address)
  const pport (s:get-peer-port)
  println "peer ip address       : " (
    paddr:get-address)
  println "peer canonical name   : " (
    paddr:get-canonical-name)
  println "peer port             : " pport
}
</pre>
<p><em>Socket predicates</em></p><p>The Socket class is associated with the socket-p predicate. The respective client objects have the tcp-client-p predicate and udp-client-p predicate.</p><p><strong>TCP server socket</strong></p><p>The TcpServer class creates an TCP server object. There are several constructors for the TCP server. In its simplest form, without port, a TCP server is created on the localhost with an ephemeral port number (i.e port 0 during the call). With a port number, the TCP server is created on the localhost. For a multi-homed host, the address to use to run the server can be specified as the first argument. The address can be either a string or an Address object. In both cases, the port is specified as the second argument. Finally, a third argument called the backlog can be specified to set the number of acceptable incoming connection. That is the maximum number of pending connection while processing a connection. The following example shows various ways to create a TCP server.</p>
<pre>
trans s (afnix:net:TcpServer)
trans s (afnix:net:TcpServer 8000)
trans s (afnix:net:TcpServer 8000 5)
trans s (afnix:net:TcpServer "localhost" 8000)
trans s (afnix:net:TcpServer "localhost" 8000 5)
trans s (afnix:net:TcpServer (
    Address "localhost") 8000)
trans s (afnix:net:TcpServer (
    Address "localhost") 8000 5)
</pre>
<p><em>Echo server example</em></p><p>A simple echo server can be built and tested with the standard telnet application. The application will echo all lines that are typed with the telnet client. The server is bound on the port 8000, since ports 0 to 1024 are privileged ports.</p>
<pre>
# get the network module
interp:library "afnix-net"
# create a tcp server on port 8000
const srv (afnix:net:TcpServer 8000)
# wait for a connection
const s (srv:accept)
# echo the line until the end
while (s:valid-p) (s:writeln (s:readln))
</pre>
<p>The telnet session is then quite simple. The line hello world is echoed by the server.</p>
<pre>
zsh&gt; telnet localhost 8000
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
hello world
^D
</pre>
<p><em>The accept method</em></p><p>The previous example illustrates the mechanics of a server. When the server is created, the server is ready to accept connection. The accept method blocks until a client connect with the server. When the connection is established, the accept method returns a socket object which can be used to read and write data.</p><p><em>Multiple connections</em></p><p>One problem with the previous example is that the server accepts only one connection. In order to accept multiple connection, the accept method must be placed in a loop, and the server operation in a thread (There are some situations where a new process might be more appropriate than a thread). Example 3302.als illustrates such point.</p>
<pre>
# get the network module
interp:library "afnix-net"
# this function echo a line from the client
const echo-server (s) {
  while (s:valid-p) (s:writeln (s:readln))
}
# create a tcp server on port 8000
const srv (afnix:net:TcpServer 8000)
# wait for a connection
while true {
  trans s (srv:accept)
  launch  (echo-server s)
}
</pre>
<p><strong>UDP server socket</strong></p><p>The UdpServer class is similar to the TcpServer object, except that there is no backlog parameters. In its simplest form, the UDP server is created on the localhost with an ephemeral port (i.e port 0). With a port number, the server is created on the localhost. For a multi-homed host, the address used to run the server can be specified as the first argument. The address can be either a string or an Address object. In both cases, the port is specified as the second argument.</p>
<pre>
trans s (afnix:net:UdpServer)
trans s (afnix:net:UdpServer 8000)
trans s (afnix:net:UdpServer "localhost" 8000)
trans s (afnix:net:UdpServer (
    Address "localhost") 8000)
</pre>
<p><em>Echo server example</em></p><p>The echo server can be revisited to work with udp datagram. The only difference is the use of the accept method. For a UDP server, the method return a Datagram object which can be used to read and write data.</p>
<pre>
# get the network module
interp:library "afnix-net"
# create a udp server on port 8000
const srv (afnix:net:UdpServer 8000)
# wait for a connection
while true {
  trans dg   (srv:accept)
  dg:writeln (dg:readln)
}
</pre>
<p><em>Datagram object</em></p><p>With a UDP server, the accept method returns a Datagram object. Because a UDP is connection-less, the server has no idea from whom the datagram is coming until that one has been received. When a datagram arrives, the Datagram object is constructed with the peer address being the source address. Standard i/o methods can be used to read or write. When a write method is used, the data are sent back to the peer in a form of another datagram.</p>
<pre>
# wait for a datagram
trans dg (s:accept)
# assert datagram type
assert true (datagram-p dg)
# get contents length
println "datagram buffer size : " (dg:get-buffer-length)
# read a line from this datagram
trans line (dg:readln)
# send it back to the sender
s:writeln line
</pre>
<p><em>Input data buffer</em></p><p>For a datagram, and generally speaking, for a UDP socket, all input operations are buffered. This means that when a datagram is received, the accept method places all data in an input buffer. This means that a read operation does not necessarily flush the whole buffer but rather consumes only the requested character. For example, if one datagram contains the string hello world. A call to readln will return the entire string. A call to read will return only the character 'h'. Subsequent call will return the next available characters. A call like read 5 will return a buffer with 5 characters. Subsequent calls will return the remaining string. In any case, the get-buffer-length will return the number of available characters in the buffer. A call to valid-p will return true if there are some characters in the buffer or if a new datagram has arrived. Care should be taken with the read method. For example if there is only 4 characters in the input buffer and a call to read for 10 characters is made, the method will block until a new datagram is received which can fill the remaining 6 characters. Such situation can be avoided by using the get-buffer-length and the valid-p methods. Note also that a timeout can be specified with the valid-p method.</p><p><strong>Low level socket methods</strong></p><p>Some folks always prefer to do everything by themselves. Most of the time for good reasons. If this is your case, you might have to use the low level socket methods. Instead of using a client or server class, the implementation let's you create a TcpSocket or UdpSocket. Once this done, the bind, connect and other methods can be used to create the desired connection.</p><p><em>A socket client</em></p><p>A simple TCP socket client is created with the TcpSocket class. Then the connect method is called to establish the connection.</p>
<pre>
# create an address and a tcp socket
const addr (afnix:net:Address "localhost")
const sid  (afnix:net:TcpSocket)
# connect the socket
sid:connect 13 addr
</pre>
<p>Once the socket is connected, normal read and write operations can be performed. After the socket is created, it is possible to set some options. A typical one is NO-DELAY which disable the Naggle algorithm.</p>
<pre>
# create an address and a tcp socket
const addr (afnix:net:Address "localhost")
const sid  (afnix:net:TcpSocket)
# disable the naggle algorithm
sid:set-option sid:NO-DELAY true
# connect the socket
sid:connect 13 addr
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NETWORKING REFERENCE</h2>
        <div class="sectioncontent">
<p><strong>Address</strong></p><p>The Address class is the Internet address manipulation class. The class can be used to perform the conversion between a host name and an IP address. The opposite is also possible. Finally, the class supports both IP version 4 and IP version 6 address formats.</p><p><em>Predicate</em></p><p>address-p</p><p><em>Inheritance</em></p><p>Object</p><p><em>Constructors</em></p><p><strong>Address (String)</strong></p><p>The Address constructor create an IP address object by name. The name argument is a string of a host name or a valid IP address representation.</p><p><strong>Address (String Boolean)</strong></p><p>The Address constructor create an IP address object by name and force the reverse lookup resolution depending on the boolean flag value. The first argument is a string of a host name or a valid IP address representation. The second argument is a boolean flag that indicates whether or not reverse lookup must occur during the construction.</p><p><em>Operators</em></p><p><strong>== -&gt; Boolean (Address)</strong></p><p>The == operator returns true if the calling object is equal to the address argument.</p><p><strong>!= -&gt; Boolean (Address)</strong></p><p>The != operator returns true if the calling object is not equal to the address argument.</p><p><strong>&lt; -&gt; Boolean (Address)</strong></p><p>The &lt; operator returns true if the calling address is less than the address object.</p><p><strong>&lt;= -&gt; Boolean (Address)</strong></p><p>The &lt;= operator returns true if the calling address is less equal than the address object.</p><p><strong>&gt; -&gt; Boolean (Address)</strong></p><p>The &gt; operator returns true if the calling address is greater than the address object.</p><p><strong>&gt;= -&gt; Boolean (Address)</strong></p><p>The &lt;= operator returns true if the calling address is greater equal than the address object.</p><p><strong>++ -&gt; Address (Address)</strong></p><p>The ++ operator increments the calling address by one position.</p><p><em>Methods</em></p><p><strong>resolve -&gt; String Boolean (none)</strong></p><p>The resolve method resolves an host name and eventually performs a reverse lookup. The first argument is a string of a host name or a valid IP address representation. The second argument is a boolean flag that indicates whether or not reverse lookup must occur during the resolution.</p><p><strong>get-name -&gt; String (none)</strong></p><p>The get-name method returns the original name used during the object construction.</p><p><strong>get-address -&gt; String (none)</strong></p><p>The get-address method returns a string representation of the IP address. The string representation follows the IP version 4 or IP version 6 preferred formats, depending on the internal representation.</p><p><strong>get-vector -&gt; Vector (none)</strong></p><p>The get-vector method returns a vector representation of the IP address. The vector result follows the IP version 4 or IP version 6 preferred format, depending on the internal representation.</p><p><strong>get-canonical-name -&gt; String (none)</strong></p><p>The get-canonical-name method returns a fully qualified name of the address. The resulting name is obtained by performing a reverse lookup. Note that the name can be different from the original name.</p><p><strong>get-alias-size -&gt; Integer (none)</strong></p><p>The get-alias-size method returns the number of aliases for the address. The number of aliases includes as well the primary resolved name which is located at index 0.</p><p><strong>get-alias-name -&gt; String (Integer)</strong></p><p>The get-alias-name method returns a fully qualified name of the address alias by index. The first argument is the alias index number which must be in the alias index range. The resulting name is obtained by performing a reverse lookup. Note that the name can be different from the original name. Using index 0 is equivalent to call get-canonical-name.</p><p><strong>get-alias-address -&gt; String (Integer)</strong></p><p>The get-alias-address method returns a string representation of the IP address alias by index. The first argument is the alias index number which must be in the alias index range. The string representation follows the IP version 4 or IP version 6 preferred formats, depending on the internal representation. Using index 0 is equivalent to call get-address.</p><p><strong>get-alias-vector -&gt; Vector (Integer)</strong></p><p>The get-alias-vector method returns a vector representation of the IP address alias by index. The first argument is the alias index number which must be in the alias index range. The vector result follows the IP version 4 or IP version 6 preferred format, depending on the internal representation. Using index 0 is equivalent to call get-vector.</p><p><em>Functions</em></p><p><strong>get-loopback -&gt; String (none)</strong></p><p>The get-loopback function returns the name of the machine loopback. On a UNIX system, that name is localhost.</p><p><strong>get-tcp-service -&gt; String (Integer)</strong></p><p>The get-tcp-service function returns the name of the tcp service given its port number. For example, the tcp service at port 13 is the daytime server.</p><p><strong>get-udp-service -&gt; String (Integer)</strong></p><p>The get-udp-service function returns the name of the udp service given its port number. For example, the udp service at port 19 is the chargen server.</p><p><strong>Socket</strong></p><p>The Socket class is a base class for the  AFNIX  network services. The class is automatically constructed by a derived class and provide some common methods for all socket objects.</p><p><em>Predicate</em></p><p>socket-p</p><p><em>Inheritance</em></p><p>InputStreamOutputStream</p><p><em>Constants</em></p><p><strong>REUSE-ADDRESS</strong></p><p>The REUSE-ADDRESS constant is used by the set-option method to enable socket address reuse. This option changes the rules that validates the address used by bind. It is not recommended to use that option as it decreases TCP reliability.</p><p><strong>BROADCAST</strong></p><p>The BROADCAST constant is used by the set-option method to enable broadcast of packets. This options only works with IP version 4 address. The argument is a boolean flag only.</p><p><strong>DONT-ROUTE</strong></p><p>The DONT-ROUTE constant is used by the set-option method to control if a packet is to be sent via the routing table. This option is rarely used with . The argument is a boolean flag only.</p><p><strong>KEEP-ALIVE</strong></p><p>The KEEP-ALIVE constant is used by the set-option method to check periodically if the connection is still alive. This option is rarely used with . The argument is a boolean flag only.</p><p><strong>LINGER</strong></p><p>The LINGER constant is used by the set-option method to turn on or off the lingering on close. If the first argument is true, the second argument is the linger time.</p><p><strong>RCV-SIZE</strong></p><p>The RCV-SIZE constant is used by the set-option method to set the receive buffer size.</p><p><strong>SND-SIZE</strong></p><p>The SND-SIZE constant is used by the set-option method to set the send buffer size.</p><p><strong>HOP-LIMIT</strong></p><p>The HOP-LIMIT constant is used by the set-option method to set packet hop limit.</p><p><strong>MULTICAST-LOOPBACK</strong></p><p>The MULTICAST-LOOPBACK constant is used by the set-option method to control whether or not multicast packets are copied to the loopback. The argument is a boolean flag only.</p><p><strong>MULTICAST-HOP-LIMIT</strong></p><p>The MULTICAST-HOP-LIMIT constant is used by the set-option method to set the hop limit for multicast packets.</p><p><strong>MAX-SEGMENT-SIZE</strong></p><p>The MAX-SEGMENT-SIZE constant is used by the set-option method to set the TCP maximum segment size.</p><p><strong>NO-DELAY</strong></p><p>The NO-DELAY constant is used by the set-option method to enable or disable the Naggle algorithm.</p><p><em>Methods</em></p><p><strong>bind -&gt; none (Integer)</strong></p><p>The bind method binds this socket to the port specified as the argument.</p><p><strong>bind -&gt; none (Integer Address)</strong></p><p>The bind method binds this socket to the port specified as the first argument and the address specified as the second argument.</p><p><strong>connect -&gt; none (Integer Address [Boolean])</strong></p><p>The connect method connects this socket to the port specified as the first argument and the address specified as the second argument. A connected socket is useful with udp client that talks only with one fixed server. The optional third argument is a boolean flag that permits to select whether or not the alias addressing scheme should be used. If the flag is false, the default address is used. If the flag is true, an attempt is made to connect to the first successful address that is part of the alias list.</p><p><strong>open-p -&gt; Boolean (none)</strong></p><p>The open-p predicate returns true if the socket is open. The method checks that a descriptor is attached to the object. This does not mean that the descriptor is valid in the sense that one can read or write on it. This method is useful to check if a socket has not been closed.</p><p><strong>shutdown -&gt; Boolean (none|Boolean)</strong></p><p>The shutdown method shutdowns or close the connection. Without argument, the connection is closed without consideration for those symbols attached to the object. With one argument, the connection is closed in one direction only. If the mode argument is false, further receive is disallowed. If the mode argument is true, further send is disallowed. The method returns true on success, false otherwise.</p><p><strong>ipv6-p -&gt; Boolean (none)</strong></p><p>The ipv6-p predicate returns true if the socket address is an IP version 6 address, false otherwise.</p><p><strong>get-socket-address -&gt; Address (none)</strong></p><p>The get-socket-address method returns an address object of the socket. The returned object can be later used to query the canonical name and the ip address.</p><p><strong>get-socket-port -&gt; Integer (none)</strong></p><p>The get-socket-port method returns the port number of the socket.</p><p><strong>get-socket-authority -&gt; String (none)</strong></p><p>The get-socket-authority method returns the authority string in the form of an address and port pair of the socket.</p><p><strong>get-peer-address -&gt; Address (none)</strong></p><p>The get-peer-address method returns an address object of the socket's peer. The returned object can be later used to query the canonical name and the ip address.</p><p><strong>get-peer-port -&gt; Integer (none)</strong></p><p>The get-peer-port method returns the port number of the socket's peer.</p><p><strong>get-peer-authority -&gt; String (none)</strong></p><p>The get-peer-authority method returns the authority string in the form of an address and port pair of the socket's peer.</p><p><strong>set-option -&gt; Boolean (constant [Boolean|Integer] [Integer])</strong></p><p>The set-option method set a socket option. The first argument is the option to set. The second argument is a boolean value which turn on or off the option. The optional third argument is an integer needed for some options.</p><p><strong>set-encoding-mode -&gt; none (Item|String)</strong></p><p>The set-encoding-mode method sets the input and output encoding mode. In the first form, with an item, the stream encoding mode is set directly. In the second form, the encoding mode is set with a string and might also alter the stream transcoing mode.</p><p><strong>set-input-encoding-mode -&gt; none (Item|String)</strong></p><p>The set-input-encoding-mode method sets the input encoding mode. In the first form, with an item, the stream encoding mode is set directly. In the second form, the encoding mode is set with a string and might also alter the stream transcoing mode.</p><p><strong>get-input-encoding-mode -&gt; Item (none)</strong></p><p>The get-input-encoding-mode method return the input encoding mode.</p><p><strong>set-output-encoding-mode -&gt; none (Item|String)</strong></p><p>The set-output-encoding-mode method sets the output encoding mode. In the first form, with an item, the stream encoding mode is set directly. In the second form, the encoding mode is set with a string and might also alter the stream transcoing mode.</p><p><strong>get-output-encoding-mode -&gt; Item (none)</strong></p><p>The get-output-encoding-mode method return the output encoding mode.</p><p><strong>TcpSocket</strong></p><p>The TcpSocket class is a base class for all tcp socket objects. The class is derived from the Socket class and provides some specific tcp methods. If a TcpSocket is created, the user is responsible to connect it to the proper address and port.</p><p><em>Predicate</em></p><p>tcp-socket-p</p><p><em>Inheritance</em></p><p>Socket</p><p><em>Constructors</em></p><p><strong>TcpSocket (none)</strong></p><p>The TcpSocket constructor creates a new tcp socket.</p><p><em>Methods</em></p><p><strong>accept -&gt; TcpSocket (none)</strong></p><p>The accept method waits for incoming connection and returns a TcpSocket object initialized with the connected peer. The result socket can be used to perform i/o operations. This method is used by tcp server.</p><p><strong>listen -&gt; Boolean (none|Integer)</strong></p><p>The listen method initialize a socket to accept incoming connection. Without argument, the default number of incoming connection is 5. The integer argument can be used to specify the number of incoming connection that socket is willing to queue. This method is used by tcp server.</p><p><strong>TcpClient</strong></p><p>The TcpClient class creates a tcp client by host and port. The host argument can be either a name or an address object. The port argument is the server port to contact. The TcpClient class is derived from the TcpSocket class. This class has no specific methods.</p><p><em>Predicate</em></p><p>tcp-client-p</p><p><em>Inheritance</em></p><p>TcpSocket</p><p><em>Constructors</em></p><p><strong>TcpClient (String Integer)</strong></p><p>The TcpClient constructor creates a new tcp client socket by host name and port number.</p><p><strong>TcpServer</strong></p><p>The TcpServer class creates a tcp server by port. An optional host argument can be either a name or an address object. The port argument is the server port to bind. The TcpServer class is derived from the TcpSocket class. This class has no specific methods. With one argument, the server bind the port argument on the local host. The backlog can be specified as the last argument. The host name can also be specified as the first argument, the port as second argument and eventually the backlog. Note that the host can be either a string or an address object.</p><p><em>Predicate</em></p><p>tcp-server-p</p><p><em>Inheritance</em></p><p>TcpSocket</p><p><em>Constructors</em></p><p><strong>TcpServer (none)</strong></p><p>The TcpServer constructor creates a default tcp server.</p><p><strong>TcpServer (Integer)</strong></p><p>The TcpServer constructor creates a default tcp server which is bound on the specified port argument.</p><p><strong>TcpServer (Integer Integer)</strong></p><p>The TcpServer constructor creates a default tcp server which is bound on the specified port argument. The second argument is the backlog value.</p><p><strong>TcpServer (String Integer)</strong></p><p>The TcpServer constructor creates a tcp server by host name and port number. The first argument is the host name. The second argument is the port number.</p><p><strong>TcpServer (String Integer Integer)</strong></p><p>The TcpServer constructor creates a tcp server by host name and port number. The first argument is the host name. The second argument is the port number. The third argument is the backlog.</p><p><strong>Datagram</strong></p><p>The Datagram class is a socket class used by udp socket. A datagram is constructed by the UdpSocketaccept method. The purpose of a datagram is to store the peer information so one can reply to the sender. The datagram also stores in a buffer the data sent by the peer. This class does not have any constructor nor any specific method.</p><p><em>Predicate</em></p><p>datagram-p</p><p><em>Inheritance</em></p><p>Socket</p><p><strong>UdpSocket</strong></p><p>The UdpSocket class is a base class for all udp socket objects. The class is derived from the Socket class and provides some specific udp methods.</p><p><em>Predicate</em></p><p>udp-socket-p</p><p><em>Inheritance</em></p><p>Socket</p><p><em>Constructors</em></p><p><strong>UdpSocket (none)</strong></p><p>The UdpSocket constructor creates a new udp socket.</p><p><em>Methods</em></p><p><strong>accept -&gt; Datagram (none)</strong></p><p>The accept method waits for an incoming datagram and returns a Datagram object. The datagram is initialized with the peer address and port as well as the incoming data.</p><p><strong>UdpClient</strong></p><p>The UdpClient class creates a udp client by host and port. The host argument can be either a name or an address object. The port argument is the server port to contact. The UdpClient class is derived from the UdpSocket class. This class has no specific methods.</p><p><em>Predicate</em></p><p>udp-client-p</p><p><em>Inheritance</em></p><p>UdpSocket</p><p><em>Constructors</em></p><p><strong>UdpClient (String Integer)</strong></p><p>The UdpClient constructor creates a new udp client by host and port. The first argument is the host name. The second argument is the port number.</p><p><strong>UdpServer</strong></p><p>The UdpServer class creates a udp server by port. An optional host argument can be either a name or an address object. The port argument is the server port to bind. The UdpServer class is derived from the UdpSocket class. This class has no specific methods. With one argument, the server bind the port argument on the local host. The host name can also be specified as the first argument, the port as second argument. Note that the host can be either a string or an address object.</p><p><em>Predicate</em></p><p>udp-server-p</p><p><em>Inheritance</em></p><p>UdpSocket</p><p><em>Constructors</em></p><p><strong>UdpServer (none)</strong></p><p>The UdpServer constructor creates a default udp server object.</p><p><strong>UdpServer (String|Address)</strong></p><p>The UdpServer constructor creates a udp server object by host. The first argument is the host name or host address.</p><p><strong>UdpServer (String|Address Integer)</strong></p><p>The UdpServer constructor creates a udp server object by host and port. The first argument is the host name or host address. The second argument is the port number.</p><p><strong>Multicast</strong></p><p>The Multicast class creates a udp multicast socket by port. An optional host argument can be either a name or an address object. The port argument is the server port to bind. The Multicast class is derived from the UdpSocket class. This class has no specific methods. With one argument, the server bind the port argument on the local host. The host name can also be specified as the first argument, the port as second argument. Note that the host can be either a string or an address object. This class is similar to the UdpServer class, except that the socket join the multicast group at construction and leave it at destruction.</p><p><em>Predicate</em></p><p>multicast-p</p><p><em>Inheritance</em></p><p>UdpSocket</p><p><em>Constructors</em></p><p><strong>Multicast (String|Address)</strong></p><p>The Multicast constructor creates a multicast socket object by host. The first argument is the host name or host address.</p><p><strong>Multicast (String|Address Integer)</strong></p><p>The Multicast constructor creates a multicast socket object by host and port. The first argument is the host name or host address. The second argument is the port number.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="afnix-mth.3.html"><span aria-hidden="true">&larr;</span> afnix-mth.3: Standard math module</a></li>
   <li class="next"><a href="afnix-nwg.3.html">afnix-nwg.3: Standard network working group module <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

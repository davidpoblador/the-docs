<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SoQtRenderArea: The soqtrenderarea class adds scenegraph handling and event management.  the soqtrenderarea class is a component that adds scenegraph management and input device event handling to the soqtglwidget component.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The soqtrenderarea class adds scenegraph handling and event management.  the soqtrenderarea class is a component that adds scenegraph management and input device event handling to the soqtglwidget component.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="SoQtRenderArea (3) manual">
  <meta name="twitter:description" content="The soqtrenderarea class adds scenegraph handling and event management.  the soqtrenderarea class is a component that adds scenegraph management and input device event handling to the soqtglwidget component.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libsoqt-dev-common-SoQtRenderArea-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/SoQtRenderArea.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="SoQtRenderArea (3) manual" />
  <meta property="og:description" content="The soqtrenderarea class adds scenegraph handling and event management.  the soqtrenderarea class is a component that adds scenegraph management and input device event handling to the soqtglwidget component." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libsoqt-dev-common-SoQtRenderArea-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">SoQtRenderArea<small> (3)</small></h1>
        <p class="lead">The soqtrenderarea class adds scenegraph handling and event management.  the soqtrenderarea class is a component that adds scenegraph management and input device event handling to the soqtglwidget component.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoQtRenderArea.3.html">
      <span itemprop="name">SoQtRenderArea: The soqtrenderarea class adds scenegraph handling and event management.  the soqtrenderarea class is a component that adds scenegraph management and input device event handling to the soqtglwidget component.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libsoqt-dev-common/">
      <span itemprop="name">libsoqt-dev-common</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoQtRenderArea.3.html">
      <span itemprop="name">SoQtRenderArea: The soqtrenderarea class adds scenegraph handling and event management.  the soqtrenderarea class is a component that adds scenegraph management and input device event handling to the soqtglwidget component.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;Inventor/Qt/SoQtRenderArea.h&gt;</p><p>Inherits <strong>SoQtGLWidget</strong>.</p><p>Inherited by <strong>SoQtViewer</strong>.</p><h3>Public Member Functions</h3>
<p><strong>SoQtRenderArea</strong> (QWidget *parent=NULL, const char *name=NULL, SbBool embed=TRUE, SbBool mouseInput=TRUE, SbBool keyboardInput=TRUE)</p><p><strong>~SoQtRenderArea</strong> ()</p><p>virtual void <strong>setSceneGraph</strong> (SoNode *scene)</p><p>virtual SoNode * <strong>getSceneGraph</strong> (void)</p><p>void <strong>setOverlaySceneGraph</strong> (SoNode *scene)</p><p>SoNode * <strong>getOverlaySceneGraph</strong> (void)</p><p>void <strong>setBackgroundColor</strong> (const SbColor &color)</p><p>const SbColor & <strong>getBackgroundColor</strong> (void) const </p><p>void <strong>setBackgroundIndex</strong> (int idx)</p><p>int <strong>getBackgroundIndex</strong> (void) const </p><p>void <strong>setOverlayBackgroundIndex</strong> (int idx)</p><p>int <strong>getOverlayBackgroundIndex</strong> (void) const </p><p>void <strong>setColorMap</strong> (int start, int num, const SbColor *colors)</p><p>void <strong>setOverlayColorMap</strong> (int start, int num, const SbColor *colors)</p><p>void <strong>setViewportRegion</strong> (const SbViewportRegion &newRegion)</p><p>const SbViewportRegion & <strong>getViewportRegion</strong> (void) const </p><p>void <strong>setTransparencyType</strong> (SoGLRenderAction::TransparencyType type)</p><p>SoGLRenderAction::TransparencyType <strong>getTransparencyType</strong> (void) const </p><p>void <strong>setAntialiasing</strong> (SbBool smoothing, int numPasses)</p><p>void <strong>getAntialiasing</strong> (SbBool &smoothing, int &numPasses) const </p><p>void <strong>setClearBeforeRender</strong> (SbBool enable, SbBool zbEnable=TRUE)</p><p>SbBool <strong>isClearBeforeRender</strong> (void) const </p><p>SbBool <strong>isClearZBufferBeforeRender</strong> (void) const </p><p>void <strong>setClearBeforeOverlayRender</strong> (SbBool enable)</p><p>SbBool <strong>isClearBeforeOverlayRender</strong> (void) const </p><p>void <strong>setAutoRedraw</strong> (SbBool enable)</p><p>SbBool <strong>isAutoRedraw</strong> (void) const </p><p>void <strong>setRedrawPriority</strong> (uint32_t priority)</p><p>uint32_t <strong>getRedrawPriority</strong> (void) const </p><p>void <strong>render</strong> (void)</p><p>void <strong>renderOverlay</strong> (void)</p><p>void <strong>scheduleRedraw</strong> (void)</p><p>void <strong>scheduleOverlayRedraw</strong> (void)</p><p>void <strong>redrawOnSelectionChange</strong> (SoSelection *selection)</p><p>void <strong>redrawOverlayOnSelectionChange</strong> (SoSelection *selection)</p><p>void <strong>setEventCallback</strong> (SoQtRenderAreaEventCB *func, void *user=NULL)</p><p>void <strong>setSceneManager</strong> (SoSceneManager *manager)</p><p>SoSceneManager * <strong>getSceneManager</strong> (void) const </p><p>void <strong>setOverlaySceneManager</strong> (SoSceneManager *manager)</p><p>SoSceneManager * <strong>getOverlaySceneManager</strong> (void) const </p><p>void <strong>setGLRenderAction</strong> (SoGLRenderAction *action)</p><p>SoGLRenderAction * <strong>getGLRenderAction</strong> (void) const </p><p>void <strong>setOverlayGLRenderAction</strong> (SoGLRenderAction *action)</p><p>SoGLRenderAction * <strong>getOverlayGLRenderAction</strong> (void) const </p><p>SbBool <strong>sendSoEvent</strong> (const SoEvent *event)</p><p>void <strong>registerDevice</strong> (<strong>SoQtDevice</strong> *device)</p><p>void <strong>unregisterDevice</strong> (<strong>SoQtDevice</strong> *device)</p>
<h3>Static Public Member Functions</h3>
<p>static uint32_t <strong>getDefaultRedrawPriority</strong> (void)</p>
<h3>Protected Member Functions</h3>
<p><strong>SoQtRenderArea</strong> (QWidget *parent, const char *name, SbBool embed, SbBool mouseInput, SbBool keyboardInput, SbBool build)</p><p>virtual void <strong>redraw</strong> (void)</p><p>virtual void <strong>actualRedraw</strong> (void)</p><p>virtual void <strong>redrawOverlay</strong> (void)</p><p>virtual void <strong>actualOverlayRedraw</strong> (void)</p><p>virtual SbBool <strong>processSoEvent</strong> (const SoEvent *const event)</p><p>virtual void <strong>processEvent</strong> (QEvent *event)</p><p>virtual void <strong>initGraphic</strong> (void)</p><p>virtual void <strong>initOverlayGraphic</strong> (void)</p><p>virtual void <strong>sizeChanged</strong> (const SbVec2s &size)</p><p>virtual void <strong>widgetChanged</strong> (QWidget *widget)</p><p>virtual void <strong>afterRealizeHook</strong> (void)</p><p>QWidget * <strong>buildWidget</strong> (QWidget *parent)</p><p>virtual const char * <strong>getDefaultWidgetName</strong> (void) const </p><p>virtual const char * <strong>getDefaultTitle</strong> (void) const </p><p>virtual const char * <strong>getDefaultIconTitle</strong> (void) const </p><p>virtual SbBool <strong>glScheduleRedraw</strong> (void)</p>
<h3>Friends</h3>
<p>class <strong>SoQtRenderAreaP</strong></p>
<h3>Additional Inherited Members</h3>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>The <strong>SoQtRenderArea</strong> class adds scenegraph handling and event management.</p><p>The <strong>SoQtRenderArea</strong> class is a component that adds scenegraph management and input device event handling to the <strong>SoQtGLWidget</strong> component.</p><p>The class has many convenient methods for controlling aspects of the rendering, like for instance transparency, aliasing and for scheduling of redraws.</p><p>Native toolkit events are caught by <strong>SoQtRenderArea</strong> components, translated to Coin SoEvent instances and passed on to the scenegraph, in case the user is doing interactive operations on for instance Coin geometry draggers.</p><p><strong>SoQtRenderArea</strong> is the first non-abstract component in it's inheritance hierarchy that you can use directly from client application code to set up a scenegraph viewer canvas.</p><p>For an <strong>SoQtRenderArea</strong> component to properly display your scenegraph, it must contain an SoCamera-derived node and at least one SoLight-derived lightsource node.</p><p>Here's a complete, stand-alone example on how to set up an <strong>SoQtRenderArea</strong> with a scenegraph:</p>
<pre>
#include &lt;Inventor/Qt/SoQt.h&gt;
#include &lt;Inventor/Qt/SoQtRenderArea.h&gt;

#include &lt;Inventor/nodes/SoCube.h&gt;
#include &lt;Inventor/nodes/SoRotor.h&gt;
#include &lt;Inventor/nodes/SoArray.h&gt;
#include &lt;Inventor/nodes/SoDirectionalLight.h&gt;
#include &lt;Inventor/nodes/SoPerspectiveCamera.h&gt;
#include &lt;Inventor/nodes/SoSeparator.h&gt;

// Set up a simple scenegraph, just for demonstration purposes.
static SoSeparator *
get_scene_graph(void)
{
  SoSeparator * root = new SoSeparator;

  SoGroup * group = new SoGroup;

  SoRotor * rotor = new SoRotor;
  rotor-&gt;rotation = SbRotation(SbVec3f(0.2, 0.5, 0.9), M_PI/4.0);
  group-&gt;addChild(rotor);

  SoCube * cube = new SoCube;
  group-&gt;addChild(cube);

  SoArray * array = new SoArray;
  array-&gt;origin = SoArray::CENTER;
  array-&gt;addChild(group);
  array-&gt;numElements1 = 2;
  array-&gt;numElements2 = 2;
  array-&gt;separation1 = SbVec3f(4, 0, 0);
  array-&gt;separation2 = SbVec3f(0, 4, 0);

  root-&gt;addChild(array);
  return root;
}

int
main(int argc, char ** argv)
{
  QWidget * window = SoQt::init(argv[0]);

  SoSeparator * root = new SoSeparator;
  root-&gt;ref();

  SoPerspectiveCamera * camera;
  root-&gt;addChild(camera = new SoPerspectiveCamera);

  root-&gt;addChild(new SoDirectionalLight);

  SoSeparator * userroot = get_scene_graph();
  root-&gt;addChild(userroot);

  SoQtRenderArea * renderarea = new SoQtRenderArea(window);
  camera-&gt;viewAll(userroot, renderarea-&gt;getViewportRegion());
  renderarea-&gt;setSceneGraph(root);
  renderarea-&gt;setBackgroundColor(SbColor(0.0f, 0.2f, 0.3f));
  if (argc &gt; 1) {
    renderarea-&gt;setTitle(argv[1]);
    renderarea-&gt;setIconTitle(argv[1]);
  }
  renderarea-&gt;show();

  SoQt::show(window);
  SoQt::mainLoop();

  delete renderarea;
  root-&gt;unref();

  return 0;
}
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>SoQtRenderArea::SoQtRenderArea (QWidget *parent = \fCNULL\fP, const char *name = \fCNULL\fP, SbBoolembed = \fCTRUE\fP, SbBoolmouseInput = \fCTRUE\fP, SbBoolkeyboardInput = \fCTRUE\fP)</h3>
<p>Public constructor.</p>
<h3>SoQtRenderArea::~SoQtRenderArea ()</h3>
<p>Destructor.</p><p>References redrawOnSelectionChange(), redrawOverlayOnSelectionChange(), and unregisterDevice().</p>
<h3>SoQtRenderArea::SoQtRenderArea (QWidget *parent, const char *name, SbBoolembed, SbBoolmouseInput, SbBoolkeyboardInput, SbBoolbuild)\fC [protected]\fP</h3>
<p>Protected constructor used by derived classes.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>void SoQtRenderArea::setSceneGraph (SoNode *scene)\fC [virtual]\fP</h3>
<p>This method sets the scene graph to be rendered in the normal bitmap planes.</p><p><strong>See also:</strong></p><p><strong>getSceneGraph()</strong>, <strong>setOverlaySceneGraph()</strong></p><p>Reimplemented in <strong>SoQtViewer</strong>.</p>
<h3>SoNode * SoQtRenderArea::getSceneGraph (void)\fC [virtual]\fP</h3>
<p>This method returns a reference to the scene graph root node as set by the user.</p><p><strong>See also:</strong></p><p><strong>SoQtRenderArea::getSceneManager()</strong></p><p>Reimplemented in <strong>SoQtViewer</strong>.</p>
<h3>void SoQtRenderArea::setOverlaySceneGraph (SoNode *scene)</h3>
<p>This method sets the scene graph to render for the overlay bitmap planes.</p><p>It will automatically take care of setting up overplay planes in the OpenGL canvas if the OpenGL hardware and driver supports it.</p><p>Important note: not all graphics hardware and / or drivers for graphics hardware support overlay planes, so application programmers are adviced to find some other way of accomplishing what they want to do before resorting to using overlay planes. Using overlay planes will in practice severely limit the portability of applications which depend on them being available.</p><p><strong>See also:</strong></p><p><strong>setSceneGraph()</strong>, <strong>getOverlaySceneGraph()</strong></p><p>References getOverlaySceneGraph(), and SoQtGLWidget::setOverlayRender().</p>
<h3>SoNode * SoQtRenderArea::getOverlaySceneGraph (void)</h3>
<p>This method returns the scene graph for the overlay scene.</p><p>Referenced by glScheduleRedraw(), and setOverlaySceneGraph().</p>
<h3>void SoQtRenderArea::setBackgroundColor (const SbColor &color)</h3>
<p>This method sets the background color of the scene.</p><p>References scheduleRedraw().</p>
<h3>const SbColor & SoQtRenderArea::getBackgroundColor (void) const</h3>
<p>This method returns the background color for the scene.</p><p>Referenced by SoQtViewer::actualRedraw().</p>
<h3>void SoQtRenderArea::setBackgroundIndex (intidx)</h3>
<p>This method sets the index of the background color for the scene.</p><p>References scheduleRedraw().</p>
<h3>int SoQtRenderArea::getBackgroundIndex (void) const</h3>
<p>This method returns the index of the background color for the scene.</p>
<h3>void SoQtRenderArea::setOverlayBackgroundIndex (intidx)</h3>
<p>This method sets the index of the background for the overlay scene.</p><p>References scheduleOverlayRedraw().</p>
<h3>int SoQtRenderArea::getOverlayBackgroundIndex (void) const</h3>
<p>This method returns the index of the background for the overlay scene.</p>
<h3>void SoQtRenderArea::setColorMap (intstart, intnum, const SbColor *colors)</h3>
<p>This method sets the colormap for the scene.</p><p>References scheduleRedraw().</p>
<h3>void SoQtRenderArea::setOverlayColorMap (intstart, intnum, const SbColor *colors)</h3>
<p>This method sets the colormap for the overlay scene.</p><p>References scheduleOverlayRedraw().</p>
<h3>void SoQtRenderArea::setViewportRegion (const SbViewportRegion &region)</h3>
<p>This method sets the viewport region.</p><p>References scheduleRedraw().</p><p>Referenced by sizeChanged().</p>
<h3>const SbViewportRegion & SoQtRenderArea::getViewportRegion (void) const</h3>
<p>This method returns the viewport region.</p><p>Referenced by SoQtConstrainedViewer::findUpDirection(), SoQtViewer::seekToPoint(), SoQtViewer::setSceneGraph(), and SoQtViewer::viewAll().</p>
<h3>void SoQtRenderArea::setTransparencyType (SoGLRenderAction::TransparencyTypetype)</h3>
<p>This method sets the transparency type to be used for the scene.</p><p>References scheduleRedraw().</p>
<h3>SoGLRenderAction::TransparencyType SoQtRenderArea::getTransparencyType (void) const</h3>
<p>This method returns the transparency type used for the scene.</p>
<h3>void SoQtRenderArea::setAntialiasing (SbBoolsmoothing, intnumPasses)</h3>
<p>This method sets the antialiasing used for the scene.</p><p>The <em>smoothing</em> flag signifies whether or not line and point aliasing should be turned on. See documentation of SoGLRenderAction::setSmoothing(), which will be called from this function.</p><p><em>numPasses</em> gives the number of re-renderings to do of the scene, blending together the results from slight 'jitters' of the camera view, into the OpenGL accumulation buffer. For further information, see documentation of SoGLRenderAction::setNumPasses() and <strong>SoQtGLWidget::setAccumulationBuffer()</strong>.</p><p>References scheduleRedraw().</p>
<h3>void SoQtRenderArea::getAntialiasing (SbBool &smoothing, int &numPasses) const</h3>
<p>This method returns the antialiasing used for the scene.</p>
<h3>void SoQtRenderArea::setClearBeforeRender (SbBoolenable, SbBoolzbEnable = \fCTRUE\fP)</h3>
<p>This method sets whether the render buffer should be cleared before rendering.</p><p>The first argument specifies whether or not to clear out the pixels in the buffer, the second argument specifies whether or not the z-buffer values should be cleared between renderings.</p><p>Setting the first argument to FALSE can for instance be used when you want to clear out the buffer yourself, for instance by drawing a background image 'under' the 3D scene rendered by Coin / Inventor.</p><p>References scheduleRedraw().</p>
<h3>SbBool SoQtRenderArea::isClearBeforeRender (void) const</h3>
<p>This method returns whether the render buffer is cleared before each render.</p><p>Referenced by SoQtViewer::actualRedraw().</p>
<h3>SbBool SoQtRenderArea::isClearZBufferBeforeRender (void) const</h3>
<p>This method returns whether the render buffer's Z buffer is cleared before each render.</p><p>Referenced by SoQtViewer::actualRedraw().</p>
<h3>void SoQtRenderArea::setClearBeforeOverlayRender (SbBoolenable)</h3>
<p>This method sets whether the overlay render buffer should be cleared before each render or not.</p><p>References scheduleOverlayRedraw().</p>
<h3>SbBool SoQtRenderArea::isClearBeforeOverlayRender (void) const</h3>
<p>This method returns whether the overlay render buffer is cleared before each redraw or not.</p>
<h3>void SoQtRenderArea::setAutoRedraw (SbBoolenable)</h3>
<p>This method sets whether redrawing should be handled automatically or not when data in the scenegraph changes.</p><p>The default setting causes the renderarea to automatically trigger a redraw of the scenegraph contents.</p>
<h3>SbBool SoQtRenderArea::isAutoRedraw (void) const</h3>
<p>This method returns whether redrawing is handled automatically not.</p>
<h3>void SoQtRenderArea::setRedrawPriority (uint32_tpriority)</h3>
<p>This method sets the redraw priority.</p>
<h3>uint32_t SoQtRenderArea::getRedrawPriority (void) const</h3>
<p>This method returns the redraw priority.</p>
<h3>uint32_t SoQtRenderArea::getDefaultRedrawPriority (void)\fC [static]\fP</h3>
<p>This function returns the default redraw priority.</p>
<h3>void SoQtRenderArea::render (void)</h3>
<p>This method causes the immediate rendering of the scene, by calling <strong>SoQtRenderArea::redraw()</strong>.</p><p>References redraw().</p>
<h3>void SoQtRenderArea::renderOverlay (void)</h3>
<p>This method renders the overlay scene.</p><p>References redrawOverlay().</p>
<h3>void SoQtRenderArea::scheduleRedraw (void)</h3>
<p>This method schedules a redraw to happen at a later time (when the application has processed it's other events first).</p><p>Referenced by SoQtFlyViewer::actualRedraw(), SoQtExaminerViewer::actualRedraw(), glScheduleRedraw(), SoQtViewer::setAnaglyphStereoColorMasks(), setAntialiasing(), SoQtViewer::setAutoClipping(), SoQtViewer::setAutoClippingStrategy(), setBackgroundColor(), setBackgroundIndex(), setClearBeforeRender(), setColorMap(), SoQtExaminerViewer::setFeedbackSize(), SoQtExaminerViewer::setFeedbackVisibility(), SoQtViewer::setStereoOffset(), SoQtViewer::setStereoViewing(), setTransparencyType(), SoQtFlyViewer::setViewing(), setViewportRegion(), and SoQtViewer::setWireframeOverlayColor().</p>
<h3>void SoQtRenderArea::scheduleOverlayRedraw (void)</h3>
<p>This method schedules a redraw of the overlay scene.</p><p>Referenced by glScheduleRedraw(), setClearBeforeOverlayRender(), setOverlayBackgroundIndex(), and setOverlayColorMap().</p>
<h3>void SoQtRenderArea::redrawOnSelectionChange (SoSelection *selection)</h3>
<p>Do automatic redraw of the scenegraph when a selection under the SoSelection node is changed.</p><p>Pass NULL to deactivate.</p><p>(Only one SoSelection node can be monitored at any given time. This is obviously a rather silly design flaw. We choose to match the original Inventor API here, but this will probably change in the next major revision of the library.)</p><p>Referenced by ~SoQtRenderArea().</p>
<h3>void SoQtRenderArea::redrawOverlayOnSelectionChange (SoSelection *selection)</h3>
<p>Do automatic redraw of the scenegraph in the overlay planes when a selection under the SoSelection node is changed.</p><p>Pass NULL to deactivate.</p><p><strong>See also:</strong></p><p><strong>SoQtRenderArea::redrawOnSelectionChange()</strong></p><p>Referenced by ~SoQtRenderArea().</p>
<h3>void SoQtRenderArea::setEventCallback (SoQtRenderAreaEventCB *func, void *user = \fCNULL\fP)</h3>
<p>This method sets the render area event callback.</p>
<h3>void SoQtRenderArea::setSceneManager (SoSceneManager *manager)</h3>
<p>This method sets the normal scene SoSceneManager object.</p><p>The previous set scene manager is deleted, and there is no way to currently avoid that. This might change in the future.</p><p>References SoQtGLWidget::getGLSize().</p>
<h3>SoSceneManager * SoQtRenderArea::getSceneManager (void) const</h3>
<p>This method returns the normal scene SoSceneManager object.</p><p>Having a reference to the SoSceneManager instance is useful for getting at the <em>real</em> root node of the rendering scenegraph, including camera, headlight and miscellaneous drawstyle nodes. The <strong>getSceneGraph()</strong> method will only return the <em>user</em> scenegrah for <strong>SoQtRenderArea</strong> subclass <strong>SoQtViewer</strong> and further subclasses. The reason this is not always what you want is because certain actions (like the SoRayPickAction) needs to traverse a valid camera if it should work as expected.</p><p>If you need to get a pointer to the <em>real</em> root node use this method to get the SoSceneManager instance reference used by the <strong>SoQtRenderArea</strong>, then use SoSceneManager::getSceneGraph() to get the root node Coin uses for rendering.</p><p>Referenced by SoQtViewer::actualRedraw(), SoQtConstrainedViewer::findUpDirection(), and initGraphic().</p>
<h3>void SoQtRenderArea::setOverlaySceneManager (SoSceneManager *manager)</h3>
<p>This method sets the overlay scene SoSceneManager object.</p><p>The previous set scene manager is not freed and will leak unless the user frees it.</p><p>References SoQtGLWidget::getGLSize().</p>
<h3>SoSceneManager * SoQtRenderArea::getOverlaySceneManager (void) const</h3>
<p>This method returns the overlay scene SoSceneManager object.</p><p>Referenced by initOverlayGraphic().</p>
<h3>void SoQtRenderArea::setGLRenderAction (SoGLRenderAction *action)</h3>
<p>This method sets the SoGLRenderAction object for the normal scene.</p><p>References SoQtComponent::getSize(), and sizeChanged().</p>
<h3>SoGLRenderAction * SoQtRenderArea::getGLRenderAction (void) const</h3>
<p>This method returns the SoGLRenderAction object for the normal scene.</p><p>Referenced by SoQtViewer::setViewing().</p>
<h3>void SoQtRenderArea::setOverlayGLRenderAction (SoGLRenderAction *action)</h3>
<p>This method sets the SoGLRenderAction object for rendering the overlay scenegraph.</p>
<h3>SoGLRenderAction * SoQtRenderArea::getOverlayGLRenderAction (void) const</h3>
<p>This method returns the SoGLRenderAction object for the overlay scene graph.</p>
<h3>SbBool SoQtRenderArea::sendSoEvent (const SoEvent *event)</h3>
<p>This method posts and processes an SoEvent object to the SoQtRenderArea-based component and returns the result value from the event handler. This is a synchronous operation.</p><p>References processSoEvent().</p>
<h3>void SoQtRenderArea::registerDevice (\fBSoQtDevice\fP *device)</h3>
<p>This method adds <em>device</em> to the list of devices handling events for this component.</p><p>References SoQtDevice::enable(), SoQtGLWidget::getGLSize(), SoQtGLWidget::getGLWidget(), and SoQtDevice::setWindowSize().</p><p>Referenced by afterRealizeHook().</p>
<h3>void SoQtRenderArea::unregisterDevice (\fBSoQtDevice\fP *device)</h3>
<p>This method removes <em>device</em> from the list of devices handling events for this component.</p><p>References SoQtDevice::disable(), and SoQtGLWidget::getGLWidget().</p><p>Referenced by ~SoQtRenderArea().</p>
<h3>void SoQtRenderArea::redraw (void)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>This method is called from the <strong>render()</strong> method and takes care of setting up the context for OpenGL rendering (by making the OpenGL canvas the current context and specifying either the front or back buffer for rendering, depending on whether we're in singlebuffer or doublebuffer mode).</p><p>After setting up the OpenGL context, it calls <strong>actualRedraw()</strong> for the actual scenegraph rendering to take place.</p><p>Finally, the OpenGL buffers are either swapped back-to-front (for doublebuffering) or flushed (for singlebuffering), and our OpenGL context is unlocked.</p><p>The application programmer may override this method if extreme low-level control of the rendering process is necessary. Usually, you should be able to get away with overriding <strong>actualRedraw()</strong> for special cases, though.</p><p>Implements <strong>SoQtGLWidget</strong>.</p><p>References actualRedraw(), SoQtGLWidget::glFlushBuffer(), SoQtGLWidget::glLockNormal(), SoQtGLWidget::glSwapBuffers(), SoQtGLWidget::glUnlockNormal(), SoQtGLWidget::hasNormalGLArea(), SoQtGLWidget::isDoubleBuffer(), SoQtGLWidget::isDrawToFrontBufferEnable(), SoQtComponent::isVisible(), and SoQtGLWidget::waitForExpose.</p><p>Referenced by render().</p>
<h3>void SoQtRenderArea::actualRedraw (void)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>This method instantly redraws the normal (non-overlay) scenegraph by calling SoSceneManager::render().</p><p>Subclasses may override this method to add their own rendering before or after Coin renders it's scenegraph.</p><p>The following is a complete example that demonstrates one way of adding both a background image and foreground (overlay) geometry to the 'normal' rendering:</p>
<pre>
// This example shows how to put a permanent background image on
// your viewer canvas, below the 3D graphics, plus overlay
// foreground geometry.  Written by mortene.
// Copyright Kongsberg Oil & Gas Technologies 2002.

// *************************************************************************

#include &lt;Inventor/Qt/SoQt.h&gt;
#include &lt;Inventor/Qt/viewers/SoQtExaminerViewer.h&gt;
#include &lt;Inventor/nodes/SoBaseColor.h&gt;
#include &lt;Inventor/nodes/SoCone.h&gt;
#include &lt;Inventor/nodes/SoCube.h&gt;
#include &lt;Inventor/nodes/SoImage.h&gt;
#include &lt;Inventor/nodes/SoLightModel.h&gt;
#include &lt;Inventor/nodes/SoOrthographicCamera.h&gt;
#include &lt;Inventor/nodes/SoRotationXYZ.h&gt;
#include &lt;Inventor/nodes/SoSeparator.h&gt;
#include &lt;Inventor/nodes/SoTranslation.h&gt;

#include &lt;GL/gl.h&gt;

// *************************************************************************

class MyExaminerViewer : public SoQtExaminerViewer {

public:
  MyExaminerViewer(QWidget * parent, const char * filename);
  ~MyExaminerViewer();

protected:
  virtual void actualRedraw(void);

private:
  SoSeparator * bckgroundroot;
  SoSeparator * foregroundroot;
  SoRotationXYZ * arrowrotation;
};

MyExaminerViewer::MyExaminerViewer(QWidget * parent, const char * filename)
  : SoQtExaminerViewer(parent)
{
  // Coin should not clear the pixel-buffer, so the background image
  // is not removed.
  this-&gt;setClearBeforeRender(FALSE, TRUE);


  // Set up background scenegraph with image in it.

  this-&gt;bckgroundroot = new SoSeparator;
  this-&gt;bckgroundroot-&gt;ref();

  SoOrthographicCamera * cam = new SoOrthographicCamera;
  cam-&gt;position = SbVec3f(0, 0, 1);
  cam-&gt;height = 1;
  // SoImage will be at z==0.0.
  cam-&gt;nearDistance = 0.5;
  cam-&gt;farDistance = 1.5;

  SoImage * img = new SoImage;
  img-&gt;vertAlignment = SoImage::HALF;
  img-&gt;horAlignment = SoImage::CENTER;
  img-&gt;filename = filename;

  this-&gt;bckgroundroot-&gt;addChild(cam);
  this-&gt;bckgroundroot-&gt;addChild(img);

  // Set up foreground, overlayed scenegraph.

  this-&gt;foregroundroot = new SoSeparator;
  this-&gt;foregroundroot-&gt;ref();

  SoLightModel * lm = new SoLightModel;
  lm-&gt;model = SoLightModel::BASE_COLOR;

  SoBaseColor * bc = new SoBaseColor;
  bc-&gt;rgb = SbColor(1, 1, 0);

  cam = new SoOrthographicCamera;
  cam-&gt;position = SbVec3f(0, 0, 5);
  cam-&gt;height = 10;
  cam-&gt;nearDistance = 0;
  cam-&gt;farDistance = 10;

  const double ARROWSIZE = 2.0;

  SoTranslation * posit = new SoTranslation;
  posit-&gt;translation = SbVec3f(-2.5 * ARROWSIZE, 1.5 * ARROWSIZE, 0);

  arrowrotation = new SoRotationXYZ;
  arrowrotation-&gt;axis = SoRotationXYZ::Z;

  SoTranslation * offset = new SoTranslation;
  offset-&gt;translation = SbVec3f(ARROWSIZE/2.0, 0, 0);

  SoCube * cube = new SoCube;
  cube-&gt;width = ARROWSIZE;
  cube-&gt;height = ARROWSIZE/15.0;

  this-&gt;foregroundroot-&gt;addChild(cam);
  this-&gt;foregroundroot-&gt;addChild(lm);
  this-&gt;foregroundroot-&gt;addChild(bc);
  this-&gt;foregroundroot-&gt;addChild(posit);
  this-&gt;foregroundroot-&gt;addChild(arrowrotation);
  this-&gt;foregroundroot-&gt;addChild(offset);
  this-&gt;foregroundroot-&gt;addChild(cube);
}

MyExaminerViewer::~MyExaminerViewer()
{
  this-&gt;bckgroundroot-&gt;unref();
  this-&gt;foregroundroot-&gt;unref();
}

void
MyExaminerViewer::actualRedraw(void)
{
  // Must set up the OpenGL viewport manually, as upon resize
  // operations, Coin won't set it up until the SoGLRenderAction is
  // applied again. And since we need to do glClear() before applying
  // the action..
  const SbViewportRegion vp = this-&gt;getViewportRegion();
  SbVec2s origin = vp.getViewportOriginPixels();
  SbVec2s size = vp.getViewportSizePixels();
  glViewport(origin[0], origin[1], size[0], size[1]);

  const SbColor col = this-&gt;getBackgroundColor();
  glClearColor(col[0], col[1], col[2], 0.0f);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

  // Render our scenegraph with the image.
  SoGLRenderAction * glra = this-&gt;getGLRenderAction();
  glra-&gt;apply(this-&gt;bckgroundroot);


  // Render normal scenegraph.
  SoQtExaminerViewer::actualRedraw();


  // Increase arrow angle with 1/1000 ° every frame.
  arrowrotation-&gt;angle = arrowrotation-&gt;angle.getValue() + (0.001 / M_PI * 180);
  // Render overlay front scenegraph.
  glClear(GL_DEPTH_BUFFER_BIT);
  glra-&gt;apply(this-&gt;foregroundroot);
}

// *************************************************************************

int
main(int argc, char ** argv)
{
  if (argc != 2) {
    (void)fprintf(stderr, "\n\n\tUsage: %s &lt;image-filename&gt;\n\n", argv[0]);
    <strong>exit</strong>(1);
  }

  QWidget * window = SoQt::init(argv[0]);

  MyExaminerViewer * viewer = new MyExaminerViewer(window, argv[1]);

  viewer-&gt;setSceneGraph(new SoCone);
  viewer-&gt;show();

  SoQt::show(window);
  SoQt::mainLoop();

  delete viewer;
  return 0;
}

// *************************************************************************
</pre>
<p>Reimplemented in <strong>SoQtViewer</strong>, <strong>SoQtExaminerViewer</strong>, <strong>SoQtFlyViewer</strong>, and <strong>SoQtPlaneViewer</strong>.</p><p>References SoQtComponent::isVisible().</p><p>Referenced by redraw().</p>
<h3>void SoQtRenderArea::redrawOverlay (void)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>This method redraws the overlay scene.</p><p>Reimplemented from <strong>SoQtGLWidget</strong>.</p><p>References actualOverlayRedraw(), SoQtGLWidget::glFlushBuffer(), SoQtGLWidget::glLockOverlay(), SoQtGLWidget::glUnlockOverlay(), SoQtGLWidget::hasOverlayGLArea(), SoQtComponent::isVisible(), and SoQtGLWidget::waitForExpose.</p><p>Referenced by renderOverlay().</p>
<h3>void SoQtRenderArea::actualOverlayRedraw (void)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>This method renders the overlay scene.</p><p>References SoQtComponent::isVisible().</p><p>Referenced by redrawOverlay().</p>
<h3>SbBool SoQtRenderArea::processSoEvent (const SoEvent *constevent)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Toolkit-native events are attempted converted to Coin-generic events in the <strong>SoQtRenderArea::processEvent()</strong> method. If this succeeds, they are forwarded to this method.</p><p>This is a virtual method, and is overridden in it's subclasses to catch events of particular interest to the viewer classes, for instance.</p><p>Return TRUE iff the event was processed. If not it should be passed on further up in the inheritance hierarchy by the caller. This last point is extremely important to take note of if you are expanding the toolkit with your own viewer class.</p><p>This method is not part of the original SGI InventorXt API. Note that you can still override the toolkit-native <strong>processEvent()</strong> method instead of this 'generic' method.</p><p>Reimplemented in <strong>SoQtViewer</strong>, <strong>SoQtFullViewer</strong>, <strong>SoQtExaminerViewer</strong>, <strong>SoQtFlyViewer</strong>, and <strong>SoQtPlaneViewer</strong>.</p><p>Referenced by processEvent(), and sendSoEvent().</p>
<h3>void SoQtRenderArea::processEvent (QEvent *event)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Overrides <strong>SoQtGLWidget::processEvent()</strong> to attempt to convert toolkit-native events to Coin-generic events. If this succeeds, the generic SoEvent is forwarded to <strong>SoQtRenderArea::processSoEvent()</strong>.</p><p>Reimplemented from <strong>SoQtGLWidget</strong>.</p><p>References SoQtGLWidget::glLockNormal(), SoQtGLWidget::glUnlockNormal(), and processSoEvent().</p>
<h3>void SoQtRenderArea::initGraphic (void)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>This method is invoked to initialize the normal graphics.</p><p>Reimplemented from <strong>SoQtGLWidget</strong>.</p><p>References getSceneManager(), and SoQtGLWidget::isRGBMode().</p>
<h3>void SoQtRenderArea::initOverlayGraphic (void)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>This method is invoked to initialize the overlay graphics.</p><p>Reimplemented from <strong>SoQtGLWidget</strong>.</p><p>References getOverlaySceneManager().</p>
<h3>void SoQtRenderArea::sizeChanged (const SbVec2s &size)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Called internally from within the <strong>SoQt</strong> library when the widget embedded in a component changes it size, which is usually triggered by end-user interaction.</p><p>This method is then invoked to notify the component that the size has changed. It is called from the top and all the way down to the bottom, the size being adjusted to take into account extra decorations having been added at each level in the component class hierarchy.</p><p>Reimplemented from <strong>SoQtGLWidget</strong>.</p><p>Reimplemented in <strong>SoQtViewer</strong>, and <strong>SoQtFullViewer</strong>.</p><p>References SoQtObject::getClassTypeId(), SoQtGLWidget::getGLSize(), SoQtObject::getTypeId(), SoQtGLWidget::setGLSize(), and setViewportRegion().</p><p>Referenced by setGLRenderAction().</p>
<h3>void SoQtRenderArea::widgetChanged (QWidget *w)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>This is the method which gets called whenever we change which OpenGL widget is used.</p><p>Should be overridden in subclasses which directly or indirectly store the return value from the <strong>SoQtGLWidget::getGLWidget()</strong> method.</p><p><strong>See also:</strong></p><p><strong>sizeChanged()</strong></p><p>Reimplemented from <strong>SoQtGLWidget</strong>.</p><p>References SoQtGLWidget::isRGBMode().</p>
<h3>void SoQtRenderArea::afterRealizeHook (void)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>A function 'hook' / callback invoked just after the window for the component has been realized.</p><p>Override this if you need specific initialization for your own component or viewer class to happen right after it has been made visible, but remember to call upwards in the inheritance hierarchy:</p>
<pre>
void
MyLittleViewer::afterRealizeHook(void)
{
  &lt;superclass&gt;::afterRealizeHook();
  // [own initialization here]
}
</pre>
<p>Reimplemented from <strong>SoQtComponent</strong>.</p><p>Reimplemented in <strong>SoQtExaminerViewer</strong>, <strong>SoQtPlaneViewer</strong>, and <strong>SoQtFlyViewer</strong>.</p><p>References registerDevice().</p>
<h3>const char * SoQtRenderArea::getDefaultWidgetName (void) const\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>This method returns the default name of a component widget class.</p><p>It should be overridden by derived non-abstract classes for the topmost widget in the component to have a proper name.</p><p>Reimplemented from <strong>SoQtComponent</strong>.</p><p>Reimplemented in <strong>SoQtExaminerViewer</strong>, <strong>SoQtFlyViewer</strong>, and <strong>SoQtPlaneViewer</strong>.</p>
<h3>const char * SoQtRenderArea::getDefaultTitle (void) const\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>This method returns the default window caption string of the component.</p><p>It should be overridden by derived non-abstract classes so the window and popup menu will get a proper title.</p><p>Reimplemented from <strong>SoQtComponent</strong>.</p><p>Reimplemented in <strong>SoQtExaminerViewer</strong>, <strong>SoQtFlyViewer</strong>, and <strong>SoQtPlaneViewer</strong>.</p>
<h3>const char * SoQtRenderArea::getDefaultIconTitle (void) const\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>This method returns the default icon title of the component.</p><p>It should be overridden by derived non-abstract classes so icons will get proper titles.</p><p>Reimplemented from <strong>SoQtComponent</strong>.</p><p>Reimplemented in <strong>SoQtExaminerViewer</strong>, <strong>SoQtFlyViewer</strong>, and <strong>SoQtPlaneViewer</strong>.</p>
<h3>SbBool SoQtRenderArea::glScheduleRedraw (void)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Will be called whenever scene graph needs to be redrawn. If this method return FALSE, <strong>redraw()</strong> will be called immediately.</p><p>Default method simply returns FALSE. Override this method to schedule a redraw and return TRUE if you're trying to do The Right Thing.</p><p>Reimplemented from <strong>SoQtGLWidget</strong>.</p><p>References getOverlaySceneGraph(), SoQtGLWidget::hasOverlayGLArea(), scheduleOverlayRedraw(), and scheduleRedraw().</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for SoQt from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="SoQtPlaneViewer.3.html"><span aria-hidden="true">&larr;</span> SoQtPlaneViewer.3: The soqtplaneviewer class is for examining 3d models by moving the camera in orthogonal planes.  the soqtplaneviewer is a viewer that is useful for 'cad-style' applications, where you want the end-user to examine your model with the viewpoint set from one of the three principal axes.</a></li>
   <li class="next"><a href="SoQuadMesh.3.html">SoQuadMesh.3: The soquadmesh class is used to render and optimize a quadrilateral mesh.  this node uses the coordinates in order, either from the state or from the soquadmesh::vertexproperty node, to construct a quadrilateral mesh. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

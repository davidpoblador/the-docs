<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>supervisor: Generic supervisor behaviour</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Generic supervisor behaviour">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="supervisor (3erl) manual">
  <meta name="twitter:description" content="Generic supervisor behaviour">
  <meta name="twitter:image" content="https://www.carta.tech/images/erlang-manpages-supervisor-3erl.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3erl/supervisor.3erl.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="supervisor (3erl) manual" />
  <meta property="og:description" content="Generic supervisor behaviour" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/erlang-manpages-supervisor-3erl.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">supervisor<small> (3erl)</small></h1>
        <p class="lead">Generic supervisor behaviour</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/supervisor.3erl.html">
      <span itemprop="name">supervisor: Generic supervisor behaviour</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/erlang-manpages/">
      <span itemprop="name">erlang-manpages</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/supervisor.3erl.html">
      <span itemprop="name">supervisor: Generic supervisor behaviour</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>A behaviour module for implementing a supervisor, a process which supervises other processes called child processes. A child process can either be another supervisor or a worker process. Worker processes are normally implemented using one of the <em>gen_event</em>, <em>gen_fsm</em>, or <em>gen_server</em> behaviours. A supervisor implemented using this module will have a standard set of interface functions and include functionality for tracing and error reporting. Supervisors are used to build an hierarchical process structure called a supervision tree, a nice way to structure a fault tolerant application. Refer to <em>OTP Design Principles</em> for more information.</p><p>A supervisor assumes the definition of which child processes to supervise to be located in a callback module exporting a pre-defined set of functions.</p><p>Unless otherwise stated, all functions in this module will fail if the specified supervisor does not exist or if bad arguments are given.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SUPERVISION PRINCIPLES</h2>
        <div class="sectioncontent">
<p>The supervisor is responsible for starting, stopping and monitoring its child processes. The basic idea of a supervisor is that it should keep its child processes alive by restarting them when necessary.</p><p>The children of a supervisor is defined as a list of <em>child specifications</em>. When the supervisor is started, the child processes are started in order from left to right according to this list. When the supervisor terminates, it first terminates its child processes in reversed start order, from right to left.</p><p>A supervisor can have one of the following <em>restart strategies</em>:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>one_for_one</em> - if one child process terminates and should be restarted, only that child process is affected.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>one_for_all</em> - if one child process terminates and should be restarted, all other child processes are terminated and then all child processes are restarted.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>rest_for_one</em> - if one child process terminates and should be restarted, the 'rest' of the child processes -- i.e. the child processes after the terminated child process in the start order -- are terminated. Then the terminated child process and all child processes after it are restarted.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>simple_one_for_one</em> - a simplified <em>one_for_one</em> supervisor, where all child processes are dynamically added instances of the same process type, i.e. running the same code.</p><p>The functions <em>delete_child/2</em> and <em>restart_child/2</em> are invalid for <em>simple_one_for_one</em> supervisors and will return <em>{error,simple_one_for_one}</em> if the specified supervisor uses this restart strategy.</p><p>The function <em>terminate_child/2</em> can be used for children under <em>simple_one_for_one</em> supervisors by giving the child's <em>pid()</em> as the second argument. If instead the child specification identifier is used, <em>terminate_child/2</em> will return <em>{error,simple_one_for_one}</em>.</p><p>Because a <em>simple_one_for_one</em> supervisor could have many children, it shuts them all down at same time. So, order in which they are stopped is not defined. For the same reason, it could have an overhead with regards to the <em>Shutdown</em> strategy.</p>
  </dd>

</dl>
<p>To prevent a supervisor from getting into an infinite loop of child process terminations and restarts, a <em>maximum restart frequency</em> is defined using two integer values <em>MaxR</em> and <em>MaxT</em>. If more than <em>MaxR</em> restarts occur within <em>MaxT</em> seconds, the supervisor terminates all child processes and then itself.</p><p>This is the type definition of a child specification:</p>
<pre>
child_spec() = {Id,StartFunc,Restart,Shutdown,Type,Modules}
 Id = term()
 StartFunc = {M,F,A}
  M = F = atom()
  A = [term()]
 Restart = permanent | transient | temporary
 Shutdown = brutal_kill | int()&gt;0 | infinity
 Type = worker | supervisor
 Modules = [Module] | dynamic
  Module = atom()
</pre>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>Id</em> is a name that is used to identify the child specification internally by the supervisor.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>StartFunc</em> defines the function call used to start the child process. It should be a module-function-arguments tuple <em>{M,F,A}</em> used as <em>apply(M,F,A)</em>.</p><p>The start function <em>must create and link to</em> the child process, and should return <em>{ok,Child}</em> or <em>{ok,Child,Info}</em> where <em>Child</em> is the pid of the child process and <em>Info</em> an arbitrary term which is ignored by the supervisor.</p><p>The start function can also return <em>ignore</em> if the child process for some reason cannot be started, in which case the child specification will be kept by the supervisor (unless it is a temporary child) but the non-existing child process will be ignored.</p><p>If something goes wrong, the function may also return an error tuple <em>{error,Error}</em>.</p><p>Note that the <em>start_link</em> functions of the different behaviour modules fulfill the above requirements.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>Restart</em> defines when a terminated child process should be restarted. A <em>permanent</em> child process should always be restarted, a <em>temporary</em> child process should never be restarted (even when the supervisor's restart strategy is <em>rest_for_one</em> or <em>one_for_all</em> and a sibling's death causes the temporary process to be terminated) and a <em>transient</em> child process should be restarted only if it terminates abnormally, i.e. with another exit reason than <em>normal</em>, <em>shutdown</em> or <em>{shutdown,Term}</em>.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>Shutdown</em> defines how a child process should be terminated. <em>brutal_kill</em> means the child process will be unconditionally terminated using <em>exit(Child,kill)</em>. An integer timeout value means that the supervisor will tell the child process to terminate by calling <em>exit(Child,shutdown)</em> and then wait for an exit signal with reason <em>shutdown</em> back from the child process. If no exit signal is received within the specified number of milliseconds, the child process is unconditionally terminated using <em>exit(Child,kill)</em>.</p><p>If the child process is another supervisor, <em>Shutdown</em> should be set to <em>infinity</em> to give the subtree ample time to shutdown. It is also allowed to set it to <em>infinity</em>, if the child process is a worker.</p>
  </dd>

</dl>
<p><strong></strong> Warning:</p><p>Be careful by setting the <em>Shutdown</em> strategy to <em>infinity</em> when the child process is a worker. Because, in this situation, the termination of the supervision tree depends on the child process, it must be implemented in a safe way and its cleanup procedure must always return.</p><p>Note that all child processes implemented using the standard OTP behavior modules automatically adhere to the shutdown protocol.</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>Type</em> specifies if the child process is a supervisor or a worker.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>Modules</em> is used by the release handler during code replacement to determine which processes are using a certain module. As a rule of thumb <em>Modules</em> should be a list with one element <em>[Module]</em>, where <em>Module</em> is the callback module, if the child process is a supervisor, gen_server or gen_fsm. If the child process is an event manager (gen_event) with a dynamic set of callback modules, <em>Modules</em> should be <em>dynamic</em>. See <em>OTP Design Principles</em> for more information about release handling.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>Internally, the supervisor also keeps track of the pid <em>Child</em> of the child process, or <em>undefined</em> if no pid exists.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DATA TYPES</h2>
        <div class="sectioncontent">

<pre>
<strong>child()</strong> = undefined | pid()

</pre>

<pre>
<strong>child_id()</strong> = term()

</pre>
<p>Not a <em>pid()</em>.</p>
<pre>
<strong>child_spec()</strong> =

    {Id :: <strong>child_id()</strong>,

     StartFunc :: <strong>mfargs()</strong>,

     Restart :: <strong>restart()</strong>,

     Shutdown :: <strong>shutdown()</strong>,

     Type :: <strong>worker()</strong>,

     Modules :: <strong>modules()</strong>}

</pre>

<pre>
<strong>mfargs()</strong> =

    {M :: module(), F :: atom(), A :: [term()] | undefined}

</pre>
<p><em>A</em> (the argument list) has the value <em>undefined</em> if <em>Restart</em> is <em>temporary</em>.</p>
<pre>
<strong>modules()</strong> = [module()] | dynamic

</pre>

<pre>
<strong>restart()</strong> = permanent | transient | temporary

</pre>

<pre>
<strong>shutdown()</strong> = brutal_kill | timeout()

</pre>

<pre>
<strong>strategy()</strong> = one_for_all

           | one_for_one

           | rest_for_one

           | simple_one_for_one

</pre>

<pre>
<strong>sup_ref()</strong> = (Name :: atom())

          | {Name :: atom(), Node :: node()}

          | {global, Name :: atom()}

          | {via, Module :: module(), Name :: any()}

          | pid()

</pre>

<pre>
<strong>worker()</strong> = worker | supervisor

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">

<pre>
<strong></strong>
start_link(Module, Args) -&gt; startlink_ret()

</pre>

<pre>
<strong></strong>
start_link(SupName, Module, Args) -&gt; startlink_ret()

</pre>
<p>Types:</p><p>SupName = <strong>sup_name()</strong></p><p>Module = module()</p><p>Args = term()</p>
<pre>
<strong>startlink_ret()</strong> = {ok, pid()}

                | ignore

                | {error, <strong>startlink_err()</strong>}
</pre>

<pre>
<strong>startlink_err()</strong> = {already_started, pid()}

                | {shutdown, term()}

                | term()
</pre>

<pre>
<strong>sup_name()</strong> = {local, Name :: atom()}

           | {global, Name :: atom()}

           | {via, Module :: module(), Name :: any()}
</pre>
<p>Creates a supervisor process as part of a supervision tree. The function will, among other things, ensure that the supervisor is linked to the calling process (its supervisor).</p><p>The created supervisor process calls <em>Module:init/1</em> to find out about restart strategy, maximum restart frequency and child processes. To ensure a synchronized start-up procedure, <em>start_link/2,3</em> does not return until <em>Module:init/1</em> has returned and all child processes have been started.</p><p>If <em>SupName={local,Name}</em> the supervisor is registered locally as <em>Name</em> using <em>register/2</em>. If <em>SupName={global,Name}</em> the supervisor is registered globally as <em>Name</em> using <em>global:register_name/2</em>. If <em>SupName={via,Module,Name}</em> the supervisor is registered as <em>Name</em> using the registry represented by <em>Module</em>. The <em>Module</em> callback should export the functions <em>register_name/2</em>, <em>unregister_name/1</em> and <em>send/2</em>, which should behave like the corresponding functions in <em>global</em>. Thus, <em>{via,global,Name}</em> is a valid reference.</p><p>If no name is provided, the supervisor is not registered.</p><p><em>Module</em> is the name of the callback module.</p><p><em>Args</em> is an arbitrary term which is passed as the argument to <em>Module:init/1</em>.</p><p>If the supervisor and its child processes are successfully created (i.e. if all child process start functions return <em>{ok,Child}</em>, <em>{ok,Child,Info}</em>, or <em>ignore</em>) the function returns <em>{ok,Pid}</em>, where <em>Pid</em> is the pid of the supervisor. If there already exists a process with the specified <em>SupName</em> the function returns <em>{error,{already_started,Pid}}</em>, where <em>Pid</em> is the pid of that process.</p><p>If <em>Module:init/1</em> returns <em>ignore</em>, this function returns <em>ignore</em> as well and the supervisor terminates with reason <em>normal</em>. If <em>Module:init/1</em> fails or returns an incorrect value, this function returns <em>{error,Term}</em> where <em>Term</em> is a term with information about the error, and the supervisor terminates with reason <em>Term</em>.</p><p>If any child process start function fails or returns an error tuple or an erroneous value, the supervisor will first terminate all already started child processes with reason <em>shutdown</em> and then terminate itself and return <em>{error, {shutdown, Reason}}</em>.</p>
<pre>
<strong></strong>
start_child(SupRef, ChildSpec) -&gt; startchild_ret()

</pre>
<p>Types:</p><p>SupRef = <strong>sup_ref()</strong></p><p>ChildSpec = <strong>child_spec()</strong> | (List :: [term()])</p>
<pre>
<strong>child_spec()</strong> =

    {Id :: <strong>child_id()</strong>,

     StartFunc :: <strong>mfargs()</strong>,

     Restart :: <strong>restart()</strong>,

     Shutdown :: <strong>shutdown()</strong>,

     Type :: <strong>worker()</strong>,

     Modules :: <strong>modules()</strong>}
</pre>

<pre>
<strong>startchild_ret()</strong> = {ok, Child :: <strong>child()</strong>}

                 | {ok, Child :: <strong>child()</strong>, Info :: term()}

                 | {error, <strong>startchild_err()</strong>}
</pre>

<pre>
<strong>startchild_err()</strong> = already_present

                 | {already_started, Child :: <strong>child()</strong>}

                 | term()
</pre>
<p>Dynamically adds a child specification to the supervisor <em>SupRef</em> which starts the corresponding child process.</p><p><strong></strong><em>SupRef</em> can be:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>the pid,</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>Name</em>, if the supervisor is locally registered,</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{Name,Node}</em>, if the supervisor is locally registered at another node, or</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{global,Name}</em>, if the supervisor is globally registered.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>{via,Module,Name}</em>, if the supervisor is registered through an alternative process registry.</p>
  </dd>

</dl>
<p><em>ChildSpec</em> should be a valid child specification (unless the supervisor is a <em>simple_one_for_one</em> supervisor, see below). The child process will be started by using the start function as defined in the child specification.</p><p>If the case of a <em>simple_one_for_one</em> supervisor, the child specification defined in <em>Module:init/1</em> will be used and <em>ChildSpec</em> should instead be an arbitrary list of terms <em>List</em>. The child process will then be started by appending <em>List</em> to the existing start function arguments, i.e. by calling <em>apply(M, F, A++List)</em> where <em>{M,F,A}</em> is the start function defined in the child specification.</p><p>If there already exists a child specification with the specified <em>Id</em>, <em>ChildSpec</em> is discarded and the function returns <em>{error,already_present}</em> or <em>{error,{already_started,Child}}</em>, depending on if the corresponding child process is running or not.</p><p>If the child process start function returns <em>{ok,Child}</em> or <em>{ok,Child,Info}</em>, the child specification and pid is added to the supervisor and the function returns the same value.</p><p>If the child process start function returns <em>ignore</em>, the child specification is added to the supervisor, the pid is set to <em>undefined</em> and the function returns <em>{ok,undefined}</em>.</p><p>If the child process start function returns an error tuple or an erroneous value, or if it fails, the child specification is discarded and the function returns <em>{error,Error}</em> where <em>Error</em> is a term containing information about the error and child specification.</p>
<pre>
<strong></strong>
terminate_child(SupRef, Id) -&gt; Result

</pre>
<p>Types:</p><p>SupRef = <strong>sup_ref()</strong></p><p>Id = pid() | <strong>child_id()</strong></p><p>Result = ok | {error, Error}</p><p>Error = not_found | simple_one_for_one</p><p>Tells the supervisor <em>SupRef</em> to terminate the given child.</p><p>If the supervisor is not <em>simple_one_for_one</em>, <em>Id</em> must be the child specification identifier. The process, if there is one, is terminated and, unless it is a temporary child, the child specification is kept by the supervisor. The child process may later be restarted by the supervisor. The child process can also be restarted explicitly by calling <em>restart_child/2</em>. Use <em>delete_child/2</em> to remove the child specification.</p><p>If the child is temporary, the child specification is deleted as soon as the process terminates. This means that <em>delete_child/2</em> has no meaning and <em>restart_child/2</em> can not be used for these children.</p><p>If the supervisor is <em>simple_one_for_one</em>, <em>Id</em> must be the child process' <em>pid()</em>. If the specified process is alive, but is not a child of the given supervisor, the function will return <em>{error,not_found}</em>. If the child specification identifier is given instead instead of a <em>pid()</em>, the function will return <em>{error,simple_one_for_one}</em>.</p><p>If successful, the function returns <em>ok</em>. If there is no child specification with the specified <em>Id</em>, the function returns <em>{error,not_found}</em>.</p><p>See <em>start_child/2</em> for a description of <em>SupRef</em>.</p>
<pre>
<strong></strong>
delete_child(SupRef, Id) -&gt; Result

</pre>
<p>Types:</p><p>SupRef = <strong>sup_ref()</strong></p><p>Id = <strong>child_id()</strong></p><p>Result = ok | {error, Error}</p><p>Error = running | restarting | not_found | simple_one_for_one</p><p>Tells the supervisor <em>SupRef</em> to delete the child specification identified by <em>Id</em>. The corresponding child process must not be running, use <em>terminate_child/2</em> to terminate it.</p><p>See <strong></strong><em>start_child/2</em> for a description of <em>SupRef</em>.</p><p>If successful, the function returns <em>ok</em>. If the child specification identified by <em>Id</em> exists but the corresponding child process is running or about to be restarted, the function returns <em>{error,running}</em> or <em>{error,restarting}</em> respectively. If the child specification identified by <em>Id</em> does not exist, the function returns <em>{error,not_found}</em>.</p>
<pre>
<strong></strong>
restart_child(SupRef, Id) -&gt; Result

</pre>
<p>Types:</p><p>SupRef = <strong>sup_ref()</strong></p><p>Id = <strong>child_id()</strong></p><p>Result = {ok, Child :: <strong>child()</strong>}</p>
<pre>
       | {ok, Child :: <strong>child()</strong>, Info :: term()}
</pre>

<pre>
       | {error, Error}
</pre>
<p>Error = running</p>
<pre>
      | restarting
</pre>

<pre>
      | not_found
</pre>

<pre>
      | simple_one_for_one
</pre>

<pre>
      | term()
</pre>
<p>Tells the supervisor <em>SupRef</em> to restart a child process corresponding to the child specification identified by <em>Id</em>. The child specification must exist and the corresponding child process must not be running.</p><p>Note that for temporary children, the child specification is automatically deleted when the child terminates, and thus it is not possible to restart such children.</p><p>See <strong></strong><em>start_child/2</em> for a description of <em>SupRef</em>.</p><p>If the child specification identified by <em>Id</em> does not exist, the function returns <em>{error,not_found}</em>. If the child specification exists but the corresponding process is already running, the function returns <em>{error,running}</em>.</p><p>If the child process start function returns <em>{ok,Child}</em> or <em>{ok,Child,Info}</em>, the pid is added to the supervisor and the function returns the same value.</p><p>If the child process start function returns <em>ignore</em>, the pid remains set to <em>undefined</em> and the function returns <em>{ok,undefined}</em>.</p><p>If the child process start function returns an error tuple or an erroneous value, or if it fails, the function returns <em>{error,Error}</em> where <em>Error</em> is a term containing information about the error.</p>
<pre>
<strong></strong>
which_children(SupRef) -&gt; [{Id, Child, Type, Modules}]

</pre>
<p>Types:</p><p>SupRef = <strong>sup_ref()</strong></p><p>Id = <strong>child_id()</strong> | undefined</p><p>Child = <strong>child()</strong> | restarting</p><p>Type = <strong>worker()</strong></p><p>Modules = <strong>modules()</strong></p><p>Returns a newly created list with information about all child specifications and child processes belonging to the supervisor <em>SupRef</em>.</p><p>Note that calling this function when supervising a large number of children under low memory conditions can cause an out of memory exception.</p><p>See <strong></strong><em>start_child/2</em> for a description of <em>SupRef</em>.</p><p>The information given for each child specification/process is:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>Id</em> - as defined in the child specification or <em>undefined</em> in the case of a <em>simple_one_for_one</em> supervisor.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>Child</em> - the pid of the corresponding child process, the atom <em>restarting</em> if the process is about to be restarted or <em>undefined</em> if there is no such process.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>Type</em> - as defined in the child specification.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>Modules</em> - as defined in the child specification.</p>
  </dd>

</dl>

<pre>
<strong></strong>
count_children(SupRef) -&gt; PropListOfCounts

</pre>
<p>Types:</p><p>SupRef = <strong>sup_ref()</strong></p><p>PropListOfCounts = [Count]</p><p>Count = {specs, ChildSpecCount :: integer() &gt;= 0}</p>
<pre>
      | {active, ActiveProcessCount :: integer() &gt;= 0}
</pre>

<pre>
      | {supervisors,
</pre>

<pre>
         ChildSupervisorCount :: integer() &gt;= 0}
</pre>

<pre>
      | {workers, ChildWorkerCount :: integer() &gt;= 0}
</pre>
<p>Returns a property list (see <em>proplists</em>) containing the counts for each of the following elements of the supervisor's child specifications and managed processes:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>specs</em> - the total count of children, dead or alive.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>active</em> - the count of all actively running child processes managed by this supervisor.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>supervisors</em> - the count of all children marked as child_type = supervisor in the spec list, whether or not the child process is still alive.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>workers</em> - the count of all children marked as child_type = worker in the spec list, whether or not the child process is still alive.</p>
  </dd>

</dl>

<pre>
<strong></strong>
check_childspecs(ChildSpecs) -&gt; Result

</pre>
<p>Types:</p><p>ChildSpecs = [<strong>child_spec()</strong>]</p><p>Result = ok | {error, Error :: term()}</p><p>This function takes a list of child specification as argument and returns <em>ok</em> if all of them are syntactically correct, or <em>{error,Error}</em> otherwise.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CALLBACK FUNCTIONS</h2>
        <div class="sectioncontent">
<p>The following functions should be exported from a <em>supervisor</em> callback module.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">
<p><strong></strong> Module:init(Args) -&gt; Result</p><p>Types:</p><p>Args = term()</p><p>Result = {ok,{{RestartStrategy,MaxR,MaxT},[ChildSpec]}} | ignore</p><p> RestartStrategy = <strong>strategy()</strong></p><p> MaxR = integer()&gt;=0</p><p> MaxT = integer()&gt;0</p><p> ChildSpec = <strong>child_spec()</strong></p><p>Whenever a supervisor is started using <em>supervisor:start_link/2,3</em>, this function is called by the new process to find out about restart strategy, maximum restart frequency and child specifications.</p><p><em>Args</em> is the <em>Args</em> argument provided to the start function.</p><p><em>RestartStrategy</em> is the restart strategy and <em>MaxR</em> and <em>MaxT</em> defines the maximum restart frequency of the supervisor. <em>[ChildSpec]</em> is a list of valid child specifications defining which child processes the supervisor should start and monitor. See the discussion about Supervision Principles above.</p><p>Note that when the restart strategy is <em>simple_one_for_one</em>, the list of child specifications must be a list with one child specification only. (The <em>Id</em> is ignored). No child process is then started during the initialization phase, but all children are assumed to be started dynamically using <em>supervisor:start_child/2</em>.</p><p>The function may also return <em>ignore</em>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO supervisor&hellip;</h2>
        <div class="sectioncontent">
<p><strong>gen_event(3erl)</strong>, <strong>gen_fsm(3erl)</strong>, <strong>gen_server(3erl)</strong>, <strong>sys(3erl)</strong></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="string.3erl.html"><span aria-hidden="true">&larr;</span> string.3erl: String processing functions</a></li>
   <li class="next"><a href="supervisor_bridge.3erl.html">supervisor_bridge.3erl: Generic supervisor bridge behaviour. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

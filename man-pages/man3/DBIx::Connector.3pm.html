<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>DBIx::Connector: None</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="None">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="DBIx::Connector (3pm) manual">
  <meta name="twitter:description" content="None">
  <meta name="twitter:image" content="https://www.carta.tech/images/libdbix-connector-perl-DBIx::Connector-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/DBIx::Connector.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="DBIx::Connector (3pm) manual" />
  <meta property="og:description" content="None" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libdbix-connector-perl-DBIx::Connector-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">DBIx::Connector<small> (3pm)</small></h1>
        <p class="lead">None</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/DBIx::Connector.3pm.html">
      <span itemprop="name">DBIx::Connector: None</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libdbix-connector-perl/">
      <span itemprop="name">libdbix-connector-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/DBIx::Connector.3pm.html">
      <span itemprop="name">DBIx::Connector: None</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">Name</h2>
        <div class="sectioncontent">
<p>DBIx::Connector - Fast, safe \s-1DBI\s0 connection and transaction management</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Synopsis</h2>
        <div class="sectioncontent">

<pre>
  use DBIx::Connector;

  # Create a connection.
  my $conn = DBIx::Connector-&gt;new($dsn, $username, $password, {
      RaiseError =&gt; 1,
      AutoCommit =&gt; 1,
  });

  # Get the database handle and do something with it.
  my $dbh  = $conn-&gt;dbh;
  $dbh-&gt;do(&apos;INSERT INTO foo (name) VALUES (?)&apos;, undef, &apos;Fred&apos; );

  # Do something with the handle more efficiently.
  $conn-&gt;run(fixup =&gt; sub {
      $_-&gt;do(&apos;INSERT INTO foo (name) VALUES (?)&apos;, undef, &apos;Fred&apos; );
  });
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Description</h2>
        <div class="sectioncontent">
<p>DBIx::Connector provides a simple interface for fast and safe \s-1DBI\s0 connection and transaction management. Connecting to a database can be expensive; you don't want your application to re-connect every time you need to run a query. The efficient thing to do is to hang on to a database handle to maintain a connection to the database in order to minimize that overhead. DBIx::Connector lets you do that without having to worry about dropped or corrupted connections.</p><p>You might be familiar with Apache::DBI and with the \s-1DBI\s0's \*(C`connect_cached()\*(C' constructor. DBIx::Connector serves a similar need, but does a much better job. How is it different? I'm glad you asked!</p><ul>
<li><p>Fork Safety Like Apache::DBI, but unlike \*(C`connect_cached()\*(C', DBIx::Connector create a new database connection if a new process has been \*(C`fork\*(C'ed. This happens all the time under mod_perl, in \s-1POE\s0 applications, and elsewhere. Works best with \s-1DBI\s0 1.614 and higher.</p></li><li><p>Thread Safety Unlike Apache::DBI or \*(C`connect_cached()\*(C', DBIx::Connector will create a new database connection if a new thread has been spawned. As with \*(C`fork\*(C'ing, spawning a new thread can break database connections.</p></li><li><p>Works Anywhere Unlike Apache::DBI, DBIx::Connector runs anywhere \*(-- inside of mod_perl or not. Why limit yourself?</p></li><li><p>Explicit Interface DBIx::Connector has an explicit interface. There is none of the magical action-at-a-distance crap that Apache::DBI is guilty of, and no global caching. I've personally diagnosed a few issues with Apache::DBI's magic, and killed it off in two different projects in favor of \*(C`connect_cached()\*(C', only to be tripped up by other gotchas. No more.</p></li><li><p>Optimistic Execution If you use \*(C`run()\*(C' and \*(C`txn()\*(C', the database handle will be passed without first pinging the server. For the 99% or more of the time when the database is just there, you'll save a ton of overhead without the ping.</p></li>
</ul><p>DBIx::Connector's other feature is transaction management. Borrowing an interface from DBIx::Class, DBIx::Connector offers an \s-1API\s0 that efficiently handles the scoping of database transactions so that you needn't worry about managing the transaction yourself. Even better, it offers an \s-1API\s0 for savepoints if your database supports them. Within a transaction, you can scope savepoints to behave like subtransactions, so that you can save some of your work in a transaction even if part of it fails. See \*(C`txn()\*(C' and \*(C`svp()\*(C' for the goods.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Usage</h2>
        <div class="sectioncontent">
<p>Unlike Apache::DBI and \*(C`connect_cached()\*(C', DBIx::Connector doesn't cache database handles. Rather, for a given connection, it makes sure that the connection is just there whenever you want it, to the extent possible. The upshot is that it's safe to create a connection and then keep it around for as long as you need it, like so:</p><p>  my $conn = DBIx::Connector-&gt;new(@args);</p><p>You can store the connection somewhere in your app where you can easily access it, and for as long as it remains in scope, it will try its hardest to maintain a database connection. Even across \*(C`fork\*(C's (especially with \s-1DBI\s0 1.614 and higher) and new threads, and even calls to \*(C`$conn-&gt;dbh-&gt;disconnect\*(C'. When you don't need it anymore, let it go out of scope and the database connection will be closed.</p><p>The upshot is that your code is responsible for hanging onto a connection for as long as it needs it. There is no magical connection caching like in Apache::DBI and \*(C`connect_cached()\*(C'.</p><h3>Execution Methods</h3>
<p>The real utility of DBIx::Connector comes from the use of the execution methods, \*(C`run()\*(C', \*(C`txn()\*(C', or \*(C`svp()\*(C'. Instead of this:</p><p>  $conn-&gt;dbh-&gt;do($query);</p><p>Try this:</p><p>  $conn-&gt;run(sub { $_-&gt;do($query) }); # returns retval from the sub {...}</p><p>The difference is that the \*(C`run()\*(C' optimistically assumes that an existing database handle is connected and executes the code reference without pinging the database. The vast majority of the time, the connection will of course still be open. You therefore save the overhead of a ping query every time you use \*(C`run()\*(C' (or \*(C`txn()\*(C').</p><p>Of course, if a block passed to \*(C`run()\*(C' dies because the \s-1DBI\s0 isn't actually connected to the database you'd need to catch that failure and try again. DBIx::Connector provides a way to overcome this issue: connection modes.</p><p><em>Connection Modes</em></p><p>When calling \*(C`run()\*(C', \*(C`txn()\*(C', or \*(C`svp()\*(C', each executes within the context of a \*(L"connection mode.\*(R" The supported modes are:</p><ul>
<li><p>\*(C`ping\*(C'</p></li><li><p>\*(C`fixup\*(C'</p></li><li><p>\*(C`no_ping\*(C'</p></li>
</ul><p>Use them via an optional first argument, like so:</p><p>  $conn-&gt;run(ping =&gt; sub { $_-&gt;do($query) });</p><p>Or set up a default mode via the \*(C`mode()\*(C' accessor:</p><p>  $conn-&gt;mode(&apos;fixup&apos;);   $conn-&gt;run(sub { $_-&gt;do($query) });</p><p>The return value of the block will be returned from the method call in scalar or array context as appropriate, and the block can use \*(C`wantarray\*(C' to determine the context. Returning the value makes them handy for things like constructing a statement handle:</p><p>  my $sth = $conn-&gt;run(fixup =&gt; sub {       my $sth = $_-&gt;prepare(&apos;SELECT isbn, title, rating FROM books&apos;);       $sth-&gt;execute;       $sth;   });</p><p>In \*(C`ping\*(C' mode, \*(C`run()\*(C' will ping the database <em>before</em> running the block. This is similar to what Apache::DBI and the \s-1DBI\s0's \*(C`connect_cached()\*(C' method do to check the database connection, and is the safest way to do so. If the ping fails, DBIx::Connector will attempt to reconnect to the database before executing the block. However, \*(C`ping\*(C' mode does impose the overhead of the \*(C`ping\*(C' ever time you use it.</p><p>In \*(C`fixup\*(C' mode, DBIx::Connector executes the block without pinging the database. But in the event the block throws an exception, if DBIx::Connector finds that the database handle is no longer connected, it will reconnect to the database and re-execute the block. Therefore, the code reference should have <strong>no side-effects outside of the database,</strong> as double-execution in the event of a stale database connection could break something:</p><p>  my $count;   $conn-&gt;run(fixup =&gt; sub { $count++ });   say $count; # may be 1 or 2</p><p>\*(C`fixup\*(C' is the most efficient connection mode. If you're confident that the block will have no deleterious side-effects if run twice, this is the best option to choose. If you decide that your block is likely to have too many side-effects to execute more than once, you can simply switch to \*(C`ping\*(C' mode.</p><p>The default is \*(C`no_ping\*(C', but you likely won't ever use it directly, and isn't recommended in any event.</p><p>Simple, huh? Better still, go for the transaction management in \*(C`txn()\*(C' and the savepoint management in \*(C`svp()\*(C'. You won't be sorry, I promise.</p><p><em>Rollback Exceptions</em></p><p>In the event of a rollback in \*(C`txn()\*(C' or \*(C`svp()\*(C', if the rollback itself fails, a DBIx::Connector::TxnRollbackError or DBIx::Connector::SvpRollbackError exception will be thrown, as appropriate. These classes, which inherit from DBIx::Connector::RollbackError, stringify to display both the rollback error and the transaction or savepoint error that led to the rollback, something like this:</p><p>    Transaction aborted: No such table "foo" at foo.pl line 206.     Transaction rollback failed: Invalid transaction ID at foo.pl line 203.</p><p>For finer-grained exception handling, you can access the individual errors via accessors: The transaction or savepoint error. The rollback error.</p><p>For example:</p><p>  use Try::Tiny;   $conn-&gt;txn(sub {       try {           # ...       } catch {           if (eval { $_-&gt;isa(&apos;DBIx::Connector::RollbackError&apos;) }) {               say STDERR &apos;Transaction aborted: &apos;, $_-&gt;error;               say STDERR &apos;Rollback failed too: &apos;, $_-&gt;rollback_error;           } else {               warn "Caught exception: $_";           }       };   });</p><p>If a \*(C`svp()\*(C' rollback fails and its surrounding \*(C`txn()\*(C' rollback <em>also</em> fails, the thrown DBIx::Connetor::TxnRollbackError exception object will have the the savepoint rollback exception, which will be an DBIx::Connetor::SvpRollbackError exception object in its \*(C`error\*(C' attribute:</p><p>  use Try::Tiny;   $conn-&gt;txn(sub {       try {           $conn-&gt;svp(sub { # ... });       } catch {           if (eval { $_-&gt;isa(&apos;DBIx::Connector::RollbackError&apos;) }) {               if (eval { $_-&gt;error-&gt;isa(&apos;DBIx::Connector::SvpRollbackError&apos;) }) {                   say STDERR &apos;Savepoint aborted: &apos;, $_-&gt;error-&gt;error;                   say STDERR &apos;Its rollback failed too: &apos;, $_-&gt;error-&gt;rollback_error;               } else {                   say STDERR &apos;Transaction aborted: &apos;, $_-&gt;error;               }               say STDERR &apos;Transaction rollback failed too: &apos;, $_-&gt;rollback_error;           } else {               warn "Caught exception: $_";           }       };   });</p><p>But most of the time, you should be fine with the stringified form of the exception, which will look something like this:</p><p>    Transaction aborted: Savepoint aborted: No such table "bar" at foo.pl line 190.     Savepoint rollback failed: Invalid savepoint name at foo.pl line 161.     Transaction rollback failed: Invalid transaction identifier at fool.pl line 184.</p><p>This allows you to see you original \s-1SQL\s0 error, as well as the errors for the savepoint rollback and transaction rollback failures.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Interface</h2>
        <div class="sectioncontent">
<p>And now for the nitty-gritty.</p><h3>Constructor</h3>
<p><em></em><strong>\*(C`new\*(C'</strong><em></em></p><p>  my $conn = DBIx::Connector-&gt;new($dsn, $username, $password, {       RaiseError =&gt; 1,       AutoCommit =&gt; 1,   });</p><p>Constructs and returns a DBIx::Connector object. The supported arguments are exactly the same as those supported by the \s-1DBI\s0. Default values for those parameters vary from the \s-1DBI\s0 as follows: Defaults to true if unspecified, and if \*(C`HandleError\*(C' is unspecified. Use of the \*(C`RaiseError\*(C' attribute, or a \*(C`HandleError\*(C' attribute that always throws exceptions (such as that provided by Exception::Class::DBI), is required for the exception-handling functionality of \*(C`run()\*(C', \*(C`txn()\*(C', and \*(C`svp()\*(C' to work properly. Their explicit use is therefor recommended if for proper error handling with these execution methods. Added in \s-1DBI\s0 1.613. Defaults to true if unspecified. This is important for safe disconnects across forking processes.</p><p>In addition, explicitly setting \*(C`AutoCommit\*(C' to true is strongly recommended if you plan to use \*(C`txn()\*(C' or \*(C`svp()\*(C', as otherwise you won't get the transactional scoping behavior of those two methods.</p><p>If you would like to execute custom logic each time a new connection to the database is made you can pass a sub as the \*(C`connected\*(C' key to the \*(C`Callbacks\*(C' parameter. See \*(L"Callbacks\*(R" in \s-1DBI\s0 for usage and other available callbacks.</p><p>Other attributes may be modified by individual drivers. See the documentation for the drivers for details:</p>
<dl class='dl-vertical'>
  <dt>
    DBIx::Connector::Driver::MSSQL
  </dt>
  <dd>
    
  </dd>
  <dt>
    DBIx::Connector::Driver::Oracle
  </dt>
  <dd>
    
  </dd>
  <dt>
    DBIx::Connector::Driver::Pg
  </dt>
  <dd>
    
  </dd>
  <dt>
    DBIx::Connector::Driver::SQLite
  </dt>
  <dd>
    
  </dd>
  <dt>
    DBIx::Connector::Driver::mysql
  </dt>
  <dd>
    
  </dd>

</dl>

<h3>Class Method</h3>
<p><em></em><strong>\*(C`connect\*(C'</strong><em></em></p><p>  my $dbh = DBIx::Connector-&gt;connect($dsn, $username, $password, &#92;%attr);</p><p>Syntactic sugar for:</p><p>  my $dbh = DBIx::Connector-&gt;new(@args)-&gt;dbh;</p><p>Though there's probably not much point in that, as you'll generally want to hold on to the DBIx::Connector object. Otherwise you'd just use the \s-1DBI\s0, no?</p>
<h3>Instance Methods</h3>
<p><em></em><strong>\*(C`dbh\*(C'</strong><em></em></p><p>  my $dbh = $conn-&gt;dbh;</p><p>Returns the connection's database handle. It will use a an existing handle if there is one, if the process has not been \*(C`fork\*(C'ed or a new thread spawned, and if the database is pingable. Otherwise, it will instantiate, cache, and return a new handle.</p><p>When called from blocks passed to \*(C`run()\*(C', \*(C`txn()\*(C', and \*(C`svp()\*(C', \*(C`dbh()\*(C' assumes that the pingability of the database is handled by those methods and skips the \*(C`ping()\*(C'. Otherwise, it performs all the same validity checks. The upshot is that it's safe to call \*(C`dbh()\*(C' inside those blocks without the overhead of multiple \*(C`ping\*(C's. Indeed, it's preferable to do so if you're doing lots of non-database processing in those blocks.</p><p><em></em><strong>\*(C`run\*(C'</strong><em></em></p><p>  $conn-&gt;run(ping =&gt; sub { $_-&gt;do($query) });</p><p>Simply executes the block, setting $_ to and passing in the database handle. Returns the value returned by the block in scalar or array context as appropriate (and the block can use \*(C`wantarray\*(C' to decide what to do).</p><p>An optional first argument sets the connection mode, overriding that set in the \*(C`mode()\*(C' accessor, and may be one of \*(C`ping\*(C', \*(C`fixup\*(C', or \*(C`no_ping\*(C' (the default). See \*(L"Connection Modes\*(R" for further explication.</p><p>For convenience, you can nest calls to \*(C`run()\*(C' (or \*(C`txn()\*(C' or \*(C`svp()\*(C'), although the connection mode will be invoked to check the connection (or not) only in the outer-most block method call.</p><p>  $conn-&gt;txn(fixup =&gt; sub {       my $dbh = shift;       $dbh-&gt;do($_) for @queries;       $conn-&gt;run(sub {           $_-&gt;do($expensive_query);           $conn-&gt;txn(sub {               $_-&gt;do($another_expensive_query);           });       });   });</p><p>All code executed inside the top-level call to \*(C`txn()\*(C' will be executed in a single transaction. If you'd like subtransactions, nest \*(C`svp()\*(C' calls.</p><p>It's preferable to use \*(C`dbh()\*(C' to fetch the database handle from within the block if your code is doing lots of non-database stuff (shame on you!):</p><p>  $conn-&gt;run(ping =&gt; sub {       parse_gigabytes_of_xml(); # Get this out of the transaction!       $conn-&gt;dbh-&gt;do($query);   });</p><p>This is because \*(C`dbh()\*(C' will better ensure that the database handle is active and \*(C`fork\*(C'- and thread-safe, although it will never \*(C`ping()\*(C' the database when called from inside a \*(C`run()\*(C', \*(C`txn()\*(C' or \*(C`svp()\*(C' block.</p><p><em></em><strong>\*(C`txn\*(C'</strong><em></em></p><p>  my $sth = $conn-&gt;txn(fixup =&gt; sub { $_-&gt;do($query) });</p><p>Starts a transaction, executes the block, setting $_ to and passing in the database handle, and commits the transaction. If the block throws an exception, the transaction will be rolled back and the exception re-thrown. Returns the value returned by the block in scalar or array context as appropriate (and the block can use \*(C`wantarray\*(C' to decide what to do).</p><p>An optional first argument sets the connection mode, overriding that set in the \*(C`mode()\*(C' accessor, and may be one of \*(C`ping\*(C', \*(C`fixup\*(C', or \*(C`no_ping\*(C' (the default). In the case of \*(C`fixup\*(C' mode, this means that the transaction block will be re-executed for a new connection if the database handle is no longer connected. In such a case, a second exception from the code block will cause the transaction to be rolled back and the exception re-thrown. See \*(L"Connection Modes\*(R" for further explication.</p><p>As with \*(C`run()\*(C', calls to \*(C`txn()\*(C' can be nested, although the connection mode will be invoked to check the connection (or not) only in the outer-most block method call. It's preferable to use \*(C`dbh()\*(C' to fetch the database handle from within the block if your code is doing lots of non-database processing.</p><p><em></em><strong>\*(C`svp\*(C'</strong><em></em></p><p>Executes a code block within the scope of a database savepoint if your database supports them. Returns the value returned by the block in scalar or array context as appropriate (and the block can use \*(C`wantarray\*(C' to decide what to do).</p><p>You can think of savepoints as a kind of subtransaction. What this means is that you can nest your savepoints and recover from failures deeper in the nest without throwing out all changes higher up in the nest. For example:</p><p>  $conn-&gt;txn(fixup =&gt; sub {       my $dbh = shift;       $dbh-&gt;do(&apos;INSERT INTO table1 VALUES (1)&apos;);       eval {           $conn-&gt;svp(sub {               shift-&gt;do(&apos;INSERT INTO table1 VALUES (2)&apos;);               die &apos;OMGWTF?&apos;;           });       };       warn "Savepoint failed&#92;n" if $@;       $dbh-&gt;do(&apos;INSERT INTO table1 VALUES (3)&apos;);   });</p><p>This transaction will insert the values 1 and 3, but not 2.</p><p>  $conn-&gt;svp(fixup =&gt; sub {       my $dbh = shift;       $dbh-&gt;do(&apos;INSERT INTO table1 VALUES (4)&apos;);       $conn-&gt;svp(sub {           shift-&gt;do(&apos;INSERT INTO table1 VALUES (5)&apos;);       });   });</p><p>This transaction will insert both 4 and 5.</p><p>Superficially, \*(C`svp()\*(C' resembles \*(C`run()\*(C' and \*(C`txn()\*(C', including its support for the optional connection mode argument, but in fact savepoints can only be used within the scope of a transaction. Thus \*(C`svp()\*(C' will start a transaction for you if it's called without a transaction in-progress. It simply redispatches to \*(C`txn()\*(C' with the appropriate connection mode. Thus, this call from outside of a transaction:</p><p>  $conn-&gt;svp(ping =&gt; sub {       $conn-&gt;svp( sub { ... } );   });</p><p>Is equivalent to:</p><p>  $conn-&gt;txn(ping =&gt; sub {       $conn-&gt;svp( sub { ... } );   })</p><p>Savepoints are supported by the following RDBMSs:</p><ul>
<li><p>PostgreSQL 8.0</p></li><li><p>SQLite 3.6.8</p></li><li><p>MySQL 5.0.3 (InnoDB)</p></li><li><p>Oracle</p></li><li><p>Microsoft \s-1SQL\s0 Server</p></li>
</ul><p>For all other RDBMSs, \*(C`svp()\*(C' works just like \*(C`txn()\*(C': savepoints will be ignored and the outer-most transaction will be the only transaction. This tends to degrade well for non-savepoint-supporting databases, doing the right thing in most cases.</p><p><em></em><strong>\*(C`mode\*(C'</strong><em></em></p><p>  my $mode = $conn-&gt;mode;   $conn-&gt;mode(&apos;fixup&apos;);   $conn-&gt;txn(sub { ... }); # uses fixup mode.   $conn-&gt;mode($mode);</p><p>Gets and sets the connection mode attribute, which is used by \*(C`run()\*(C', \*(C`txn()\*(C', and \*(C`svp()\*(C' if no mode is passed to them. Defaults to \*(L"no_ping\*(R". Note that inside a block passed to \*(C`run()\*(C', \*(C`txn()\*(C', or \*(C`svp()\*(C', the mode attribute will be set to the optional first parameter:</p><p>  $conn-&gt;mode(&apos;ping&apos;);   $conn-&gt;txn(fixup =&gt; sub {       say $conn-&gt;mode; # Outputs "fixup"   });   say $conn-&gt;mode; # Outputs "ping"</p><p>In this way, you can reliably tell in what mode the code block is executing.</p><p><em></em><strong>\*(C`connected\*(C'</strong><em></em></p><p>  if ( $conn-&gt;connected ) {       $conn-&gt;dbh-&gt;do($query);   }</p><p>Returns true if currently connected to the database and false if it's not. You probably won't need to bother with this method; DBIx::Connector uses it internally to determine whether or not to create a new connection to the database before returning a handle from \*(C`dbh()\*(C'.</p><p><em></em><strong>\*(C`in_txn\*(C'</strong><em></em></p><p>  if ( $conn-&gt;in_txn ) {      say &apos;Transacting!&apos;;   }</p><p>Returns true if the connection is in a transaction. For example, inside a \*(C`txn()\*(C' block it would return true. It will also work if you use the \s-1DBI\s0 \s-1API\s0 to manage transactions (i.e., \*(C`begin_work()\*(C' or \*(C`AutoCommit\*(C'.</p><p>Essentially, this is just sugar for:</p><p>  $con-&gt;run( no_ping =&gt; sub { !$_-&gt;{AutoCommit} } );</p><p>But without the overhead of the code reference or connection checking.</p><p><em></em><strong>\*(C`disconnect_on_destroy\*(C'</strong><em></em></p><p>  $conn-&gt;<strong>disconnect_on_destroy</strong>(0);</p><p>By default, DBIx::Connector calls \*(C`$dbh-&gt;disconnect\*(C' when it goes out of scope and is garbage-collected by the system (that is, in its \*(C`DESTROY()\*(C' method). Usually this is what you want, but in some cases it might not be. For example, you might have a module that uses DBIx::Connector internally, but then makes the database handle available to callers, even after the DBIx::Connector object goes out of scope. In such a case, you don't want the database handle to be disconnected when the DBIx::Connector goes out of scope. So pass a false value to \*(C`disconnect_on_destroy\*(C' to prevent the disconnect. An example:</p><p>  sub database_handle {        my $conn = DBIx::Connector-&gt;new(@_);        $conn-&gt;run(sub {            # Do stuff here.        });        $conn-&gt;<strong>disconnect_on_destroy</strong>(0);        return $conn-&gt;dbh;   }</p><p>Of course, if you don't need to do any work with the database handle before returning it to your caller, you can just use \*(C`connect()\*(C':</p><p>  sub database_handle {       DBIx::Connector-&gt;connect(@_);   }</p><p><em></em><strong>\*(C`disconnect\*(C'</strong><em></em></p><p>  $conn-&gt;disconnect;</p><p>Disconnects from the database. Unless \*(C`disconnect_on_destroy()\*(C' has been passed a false value, DBIx::Connector uses this method internally in its \*(C`DESTROY\*(C' method to make sure that things are kept tidy.</p><p><em></em><strong>\*(C`driver\*(C'</strong><em></em></p><p>  $conn-&gt;driver-&gt;begin_work( $conn-&gt;dbh );</p><p>In order to support all database features in a database-neutral way, DBIx::Connector provides a number of different database drivers, subclasses of DBIx::Connector::Driver, that offer methods to handle database communications. Although the \s-1DBI\s0 provides a standard interface, for better or for worse, not all of the drivers implement them, and some have bugs. To avoid those issues, all database communications are handled by these driver objects.</p><p>This can be useful if you want more fine-grained control of your transactionality. For example, to create your own savepoint within a transaction, you might do something like this:</p><p>  use Try::Tiny;   my $driver = $conn-&gt;driver;   $conn-&gt;txn(sub {       my $dbh = shift;       try {           $driver-&gt;savepoint($dbh, &apos;mysavepoint&apos;);           # do stuff ...           $driver-&gt;release(&apos;mysavepoint&apos;);       } catch {           $driver-&gt;rollback_to($dbh, &apos;mysavepoint&apos;);       };   });</p><p>Most often you should be able to get what you need out of \*(C`txn()\*(C' and \*(C`svp()\*(C', but sometimes you just need the finer control. In those cases, take advantage of the driver object to keep your use of the \s-1API\s0 universal across database back-ends.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">See Also</h2>
        <div class="sectioncontent">
<ul>
<li><p>DBIx::Connector::Driver</p></li><li><p>\s-1DBI\s0</p></li><li><p>DBIx::Class</p></li><li><p>Catalyst::Model::DBI</p></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Support</h2>
        <div class="sectioncontent">
<p>This module is managed in an open GitHub repository &lt;http://github.com/theory/dbix-connector/&gt;. Feel free to fork and contribute, or to clone git://github.com/theory/dbix-connector.git &lt;git://github.com/theory/dbix-connector.git&gt; and send patches!</p><p>Found a bug? Please post &lt;http://github.com/theory/dbix-connector/issues&gt; or email &lt;mailto:bug-dbix-connector@rt.cpan.org&gt; a report!</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Authors</h2>
        <div class="sectioncontent">
<p>This module was written and is maintained by:</p><ul>
<li><p>David E. Wheeler &lt;david@kineticode.com&gt;</p></li>
</ul><p>It is based on documentation, ideas, kibbitzing, and code from:</p><ul>
<li><p>Tim Bunce &lt;http://tim.bunce.name&gt;</p></li><li><p>Brandon L. Black &lt;blblack@gmail.com&gt;</p></li><li><p>Matt S. Trout &lt;mst@shadowcat.co.uk&gt;</p></li><li><p>Peter Rabbitson &lt;ribasushi@cpan.org&gt;</p></li><li><p>Ash Berlin &lt;ash@cpan.org&gt;</p></li><li><p>Rob Kinyon &lt;rkinyon@cpan.org&gt;</p></li><li><p>Cory G Watson &lt;gphat@cpan.org&gt;</p></li><li><p>Anders Nor Berle &lt;berle@cpan.org&gt;</p></li><li><p>John Siracusa &lt;siracusa@gmail.com&gt;</p></li><li><p>Alex Pavlovic &lt;alex.pavlovic@taskforce-1.com&gt;</p></li><li><p>Many other DBIx::Class contributors</p></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Copyright and License</h2>
        <div class="sectioncontent">
<p>Copyright (c) 2009-2010 David E. Wheeler. Some Rights Reserved.</p><p>This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="DBIx::Compat.3pm.html"><span aria-hidden="true">&larr;</span> DBIx::Compat.3pm: Perl extension for compatibility infos about dbd drivers</a></li>
   <li class="next"><a href="DBIx::Connector::Driver.3pm.html">DBIx::Connector::Driver.3pm: None <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

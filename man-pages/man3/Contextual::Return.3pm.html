<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Contextual::Return: Create context-sensitive return values</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Create context-sensitive return values">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Contextual::Return (3pm) manual">
  <meta name="twitter:description" content="Create context-sensitive return values">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcontextual-return-perl-Contextual::Return-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Contextual::Return.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Contextual::Return (3pm) manual" />
  <meta property="og:description" content="Create context-sensitive return values" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcontextual-return-perl-Contextual::Return-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Contextual::Return<small> (3pm)</small></h1>
        <p class="lead">Create context-sensitive return values</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Contextual::Return.3pm.html">
      <span itemprop="name">Contextual::Return: Create context-sensitive return values</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcontextual-return-perl/">
      <span itemprop="name">libcontextual-return-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Contextual::Return.3pm.html">
      <span itemprop="name">Contextual::Return: Create context-sensitive return values</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">VERSION</h2>
        <div class="sectioncontent">
<p>This document describes Contextual::Return version 0.004007</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
    use Contextual::Return;
    use Carp;

    sub foo {
        return
            SCALAR { &apos;thirty-twelve&apos; }
            LIST   { 1,2,3 }

            BOOL { 1 }
            NUM  { 7*6 }
            STR  { &apos;forty-two&apos; }

            HASHREF  { {name =&gt; &apos;foo&apos;, value =&gt; 99} }
            ARRAYREF { [3,2,1] }

            GLOBREF  { &#92;*STDOUT }
            CODEREF  { croak "Don&apos;t use this result as code!"; }
        ;
    }

    # and later...

    if (my $foo = foo()) {
        for my $count (1..$foo) {
            print "$count: $foo is:&#92;n"
                . "  array: @{$foo}&#92;n"
                . "  hash:  $foo-&gt;{name} =&gt; $foo-&gt;{value}&#92;n"
                ;
        }
        print {$foo} $foo-&gt;();
    }
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Usually, when you need to create a subroutine that returns different values in different contexts (list, scalar, or void), you write something like:</p><p>    sub get_server_status {         my ($server_ID) = @_;</p><p>        # Acquire server data somehow...         my %server_data = _ascertain_server_status($server_ID);</p><p>        # Return different components of that data,         # depending on call context...         if (wantarray()) {             return @server_data{ qw(name uptime load users) };         }         if (defined wantarray()) {             return $server_data{load};         }         if (!defined wantarray()) {             carp &apos;Useless use of get_server_status() in void context&apos;;             return;         }         else {             croak q{Bad context! No biscuit!};         }     }</p><p>That works okay, but the code could certainly be more readable. In its simplest usage, this module makes that code more readable by providing three subroutines\*(--\*(C`LIST()\*(C', \*(C`SCALAR()\*(C', \*(C`VOID()\*(C'--that are true only when the current subroutine is called in the corresponding context:</p><p>    use Contextual::Return;</p><p>    sub get_server_status {         my ($server_ID) = @_;</p><p>        # Acquire server data somehow...         my %server_data = _ascertain_server_status($server_ID);</p><p>        # Return different components of that data         # depending on call context...         if (LIST)   { return @server_data{ qw(name uptime load users) } }         if (SCALAR) { return $server_data{load}                         }         if (VOID)   { print "$server_data{load}&#92;n"                      }         else        { croak q{Bad context! No biscuit!}                 }     }</p><h3>Contextual returns</h3>
<p>Those three subroutines can also be used in another way: as labels on a series of <em>contextual return blocks</em> (collectively known as a <em>contextual</em> return sequence). When a context sequence is returned, it automatically selects the appropriate contextual return block for the calling context. So the previous example could be written even more cleanly as:</p><p>    use Contextual::Return;</p><p>    sub get_server_status {         my ($server_ID) = @_;</p><p>        # Acquire server data somehow...         my %server_data = _ascertain_server_status($server_ID);</p><p>        # Return different components of that data         # depending on call context...         return (             LIST    { return @server_data{ qw(name uptime load users) } }             SCALAR  { return $server_data{load}                         }             VOID    { print "$server_data{load}&#92;n"                      }             DEFAULT { croak q{Bad context! No biscuit!}                 }         );     }</p><p>The context sequence automatically selects the appropriate block for each call context.</p>
<h3>Lazy contextual return values</h3>
<p>\*(C`LIST\*(C' and \*(C`VOID\*(C' blocks are always executed during the \*(C`return\*(C' statement. However, scalar return blocks (\*(C`SCALAR\*(C', \*(C`STR\*(C', \*(C`NUM\*(C', \*(C`BOOL\*(C', etc.) blocks are not. Instead, returning any of scalar block types causes the subroutine to return an object that lazily evaluates that block only when the return value is used.</p><p>This means that returning a \*(C`SCALAR\*(C' block is a convenient way to implement a subroutine with a lazy return value. For example:</p><p>    sub digest {         return SCALAR {             my ($text) = @_;             md5($text);         }     }</p><p>    my $digest = digest($text);</p><p>    print $digest;   # md5() called only when $digest used as string</p><p>To better document this usage, the \*(C`SCALAR\*(C' block has a synonym: \*(C`LAZY\*(C'.</p><p>    sub digest {         return LAZY {             my ($text) = @_;             md5($text);         }     }</p>
<h3>Active contextual return values</h3>
<p>Once a return value has been lazily evaluated in a given context, the resulting value is cached, and thereafter reused in that same context.</p><p>However, you can specify that, rather than being cached, the value should be re-evaluated <em>every</em> time the value is used:</p><p>     sub make_counter {         my $counter = 0;         return ACTIVE             SCALAR   { ++$counter }             ARRAYREF { [1..$counter] }     }</p><p>    my $idx = make_counter();</p><p>    print "$idx&#92;n";      # 1     print "$idx&#92;n";      # 2     print "[@$idx]&#92;n";   # [1 2]     print "$idx&#92;n";      # 3     print "[@$idx]&#92;n";   # [1 2 3]</p>
<h3>Semi-lazy contextual return values</h3>
<p>Sometimes, single or repeated lazy evaluation of a scalar return value in different contexts isn't what you really want. Sometimes what you really want is for the return value to be lazily evaluated once only (the first time it's used in any context), and then for that first value to be reused whenever the return value is subsequently reevaluated in any other context.</p><p>To get that behaviour, you can use the \*(C`FIXED\*(C' modifier, which causes the return value to morph itself into the actual value the first time it is used. For example:</p><p>    sub lazy {         return             SCALAR { 42 }             ARRAYREF { [ 1, 2, 3 ] }         ;     }</p><p>    my $lazy = lazy();     print $lazy + 1;            # 43     print "@{$lazy}";           # 1 2 3</p><p>    sub semilazy {         return FIXED             SCALAR { 42 }             ARRAYREF { [ 1, 2, 3 ] }         ;     }</p><p>    my $semi = semilazy();     print $semi + 1;            # 43     print "@{$semi}";           # die q{Can&apos;t use string ("42") as an ARRAY ref}</p>
<h3>Finer distinctions of scalar context</h3>
<p>Because the scalar values returned from a context sequence are lazily evaluated, it becomes possible to be more specific about <em>what kind</em> of scalar value should be returned: a boolean, a number, or a string. To support those distinctions, Contextual::Return provides four extra context blocks: \*(C`NUM\*(C', \*(C`STR\*(C', \*(C`BOOL\*(C', and \*(C`PUREBOOL\*(C':</p><p>    sub get_server_status {         my ($server_ID) = @_;</p><p>        # Acquire server data somehow...         my %server_data = _ascertain_server_status($server_ID);</p><p>        # Return different components of that data         # depending on call context...         return (                LIST { @server_data{ qw(name uptime load users) }          }            PUREBOOL { $_ = $server_data{uptime}; $server_data{uptime} &gt; 0 }                BOOL { $server_data{uptime} &gt; 0                            }                NUM  { $server_data{load}                                  }                STR  { "$server_data{name}: $server_data{uptime}"          }                VOID { print "$server_data{load}&#92;n"                        }             DEFAULT { croak q{Bad context! No biscuit!}                   }         );     }</p><p>With these in place, the object returned from a scalar-context call to \*(C`get_server_status()\*(C' now behaves differently, depending on how it's used. For example:</p><p>    if ( my $status = get_server_status() ) {  # BOOL: True if uptime &gt; 0         $load_distribution[$status]++;         # INT:  Evaluates to load value         print "$status&#92;n";                     # STR:  Prints "name: uptime"     }</p><p>    if (get_server_status()) {                 # PUREBOOL: also sets $_;         print;                                 # ...which is then used here     }</p><p><em>Boolean vs Pure Boolean contexts</em></p><p>There is a special subset of boolean contexts where the return value is being used and immediately thrown away. For example, in the loop:</p><p>    while (get_data()) {         ...     }</p><p>the value returned by \*(C`get_data()\*(C' is tested for truth and then discarded. This is known as \*(L"pure boolean context\*(R". In contrast, in the loop:</p><p>    while (my $data = get_data()) {         ...     }</p><p>the value returned by \*(C`get_data()\*(C' is first assigned to $data, then tested for truth. Because of the assignment, the return value is <em>not</em> discarded after the boolean test. This is ordinary \*(L"boolean context\*(R".</p><p>In Perl, pure boolean context is often associated with a special side-effect, that does not occur in regular boolean contexts. For example:</p><p>    while (&lt;&gt;) {...}         # $_ set as side-effect of pure boolean context</p><p>    while ($v = &lt;&gt;) {...}    # $_ NOT set in ordinary boolean context</p><p>Contextual::Return supports this with a special subcase of \*(C`BOOL\*(C' named &lt;\s-1PUREBOOL\s0&gt;. In pure boolean contexts, Contextual::Return will call a \*(C`PUREBOOL\*(C' handler if one has been defined, or fall back to a \*(C`BOOL\*(C' or \*(C`SCALAR\*(C' handler if no \*(C`PUREBOOL\*(C' handler exists. In ordinary boolean contexts only the \*(C`BOOL\*(C' or \*(C`SCALAR\*(C' handlers are tried, even if a \*(C`PUREBOOL\*(C' handler is also defined.</p><p>Typically \*(C`PUREBOOL\*(C' handlers are set up to have some side-effect (most commonly: setting $_ or &lt;$@&gt;), like so:</p><p>    sub get_data {         my ($succeeded, @data) = _go_and_get_data();</p><p>        return             PUREBOOL { $_ = $data[0]; $succeeded; }                 BOOL {                $succeeded; }               SCALAR {                $data[0];   }                 LIST {                @data;      }     }</p><p>However, there is no requirement that they have side-effects. For example, they can also be used to implement \*(L"look-but-don't-retrieve-yet\*(R" checking:</p><p>    sub get_data {         my $data;         return             PUREBOOL {        _check_for_but_dont_get_data();   }                 BOOL { defined( $data ||= _go_and_get_data() ); }                  REF {          $data ||= _go_and_get_data();   }     }</p>
<h3>Self-reference within handlers</h3>
<p>Any handler can refer to the contextual return object it is part of, by calling the \*(C`RETOBJ()\*(C' function. This is particularly useful for \*(C`PUREBOOL\*(C' and \*(C`LIST\*(C' handlers. For example:</p><p>    return         PUREBOOL { $_ = RETOBJ; next handler; }             BOOL { !$failed;                  }          DEFAULT { $data;                     };</p>
<h3>Referential contexts</h3>
<p>The other major kind of scalar return value is a reference. Contextual::Return provides contextual return blocks that allow you to specify what to (lazily) return when the return value of a subroutine is used as a reference to a scalar (\*(C`SCALARREF {...}\*(C'), to an array (\*(C`ARRAYREF {...}\*(C'), to a hash (\*(C`HASHREF {...}\*(C'), to a subroutine (\*(C`CODEREF {...}\*(C'), or to a typeglob (\*(C`GLOBREF {...}\*(C').</p><p>For example, the server status subroutine shown earlier could be extended to allow it to return a hash reference, thereby supporting \*(L"named return values\*(R":</p><p>    sub get_server_status {         my ($server_ID) = @_;</p><p>        # Acquire server data somehow...         my %server_data = _ascertain_server_status($server_ID);</p><p>        # Return different components of that data         # depending on call context...         return (                LIST { @server_data{ qw(name uptime load users) }  }                BOOL { $server_data{uptime} &gt; 0                    }                 NUM { $server_data{load}                          }                 STR { "$server_data{name}: $server_data{uptime}"  }                VOID { print "$server_data{load}&#92;n"                }             HASHREF { return &#92;%server_data                        }             DEFAULT { croak q{Bad context! No biscuit!}           }         );     }</p><p>    # and later...</p><p>    my $users = get_server_status-&gt;{users};</p><p>    # or, lazily...</p><p>    my $server = get_server_status();</p><p>    print "$server-&gt;{name} load = $server-&gt;{load}&#92;n";</p>
<h3>Interpolative referential contexts</h3>
<p>The \*(C`SCALARREF {...}\*(C' and \*(C`ARRAYREF {...}\*(C' context blocks are especially useful when you need to interpolate a subroutine into strings. For example, if you have a subroutine like:</p><p>    sub get_todo_tasks {         return (             SCALAR { scalar @todo_list }      # How many?             LIST   { @todo_list        }      # What are they?         );     }</p><p>    # and later...</p><p>    print "There are ", scalar(get_todo_tasks()), " tasks:&#92;n",             get_todo_tasks();</p><p>then you could make it much easier to interpolate calls to that subroutine by adding:</p><p>    sub get_todo_tasks {         return (             SCALAR { scalar @todo_list }      # How many?             LIST   { @todo_list        }      # What are they?</p><p>            SCALARREF { &#92;scalar @todo_list }  # Ref to how many             ARRAYREF  { &#92;@todo_list        }  # Ref to them         );     }</p><p>    # and then...</p><p>    print "There are ${get_todo_tasks()} tasks:&#92;n@{get_todo_tasks()}";</p><p>In fact, this behaviour is so useful that it's the default. If you don't provide an explicit \*(C`SCALARREF {...}\*(C' block, Contextual::Return automatically provides an implicit one that simply returns a reference to whatever would have been returned in scalar context. Likewise, if no \*(C`ARRAYREF {...}\*(C' block is specified, the module supplies one that returns the list-context return value wrapped up in an array reference.</p><p>So you could just write:</p><p>    sub get_todo_tasks {         return (             SCALAR { scalar @todo_list }      # How many?             LIST   { @todo_list        }      # What are they?         );     }</p><p>    # and still do this...</p><p>    print "There are ${get_todo_tasks()} tasks:&#92;n@{get_todo_tasks()}";</p>
<h3>Fallback contexts</h3>
<p>As the previous sections imply, the \*(C`BOOL {...}\*(C', \*(C`NUM {...}\*(C', \*(C`STR {...}\*(C', and various \*(C`*REF {...}\*(C' blocks, are special cases of the general \*(C`SCALAR {...}\*(C' context block. If a subroutine is called in one of these specialized contexts but does not use the corresponding context block, then the more general \*(C`SCALAR {...}\*(C' block is used instead (if it has been specified).</p><p>So, for example:</p><p>    sub read_value_from {         my ($fh) = @_;</p><p>        my $value = &lt;$fh&gt;;         chomp $value;</p><p>        return (             BOOL   { defined $value }             SCALAR { $value         }         );     }</p><p>ensures that the \*(C`read_value_from()\*(C' subroutine returns true in boolean contexts if the read was successful. But, because no specific \*(C`NUM {...}\*(C' or \*(C`STR {...}\*(C' return behaviours were specified, the subroutine falls back on using its generic \*(C`SCALAR {...}\*(C' block in all other scalar contexts.</p><p>Another way to think about this behaviour is that the various kinds of scalar context blocks form a hierarchy:</p><p>    SCALAR          ^          |          |--&lt; BOOL          |          |--&lt; NUM          |          &#96;--&lt; STR</p><p>Contextual::Return uses this hierarchical relationship to choose the most specific context block available to handle any particular return context, working its way up the tree from the specific type it needs, to the more general type, if that's all that is available.</p><p>There are two slight complications to this picture. The first is that Perl treats strings and numbers as interconvertable so the diagram (and the Contextual::Return module) also has to allow these interconversions as a fallback strategy:</p><p>    SCALAR          ^          |          |--&lt; BOOL          |          |--&lt; NUM          |    : ^          |    v :          &#96;--&lt; STR</p><p>The dotted lines are meant to indicate that this intraconversion is secondary to the main hierarchical fallback. That is, in a numeric context, a \*(C`STR {...}\*(C' block will only be used if there is no \*(C`NUM {...}\*(C' block <em>and</em> no \*(C`SCALAR {...}\*(C' block. In other words, the generic context type is always used in preference to string&lt;-&gt;number conversion.</p><p>The second slight complication is that the above diagram only shows a small part of the complete hierarchy of contexts supported by Contextual::Return. The full fallback hierarchy (including dotted interconversions) is:</p><p>      DEFAULT          ^          |          |--&lt; VOID          |          &#96;--&lt; NONVOID                  ^                  |                  |--&lt; VALUE &lt;...............                  |      ^                   :                  |      |                   :                  |      |--&lt; SCALAR &lt;.......:...                  |      |           ^           :                  |      |           |           :                  |      |           |--&lt; BOOL   :                  |      |           |     ^     :                  |      |           |     |     :                  |      |           |  PUREBOOL :                  |      |           |           :                  |      |           |--&lt; NUM &lt;..:.                  |      |           |    : ^      :                  |      |           |    v :      :                  |      |           &#96;--&lt; STR &lt;....:..                  |      |                           :                  |      |                          ::                  |      &#96;--&lt; LIST ................: :                  |            : ^                   :                  |            : :                   :                  &#96;--- REF     : :                   :                        ^      : :                   :                        |      v :                   :                        |--&lt; ARRAYREF                :                        |                            :                        |--&lt; SCALARREF .............:                        |                        |--&lt; HASHREF                        |                        |--&lt; CODEREF                        |                        |--&lt; GLOBREF                        |                        &#96;--&lt; OBJREF &lt;....... METHOD                                ^                                :........... BLESSED</p><p>As before, each dashed arrow represents a fallback relationship. That is, if the required context specifier isn't available, the arrows are followed until a more generic one is found. The dotted arrows again represent the interconversion of return values, which is attempted only after the normal hierarchical fallback fails.</p><p>For example, if a subroutine is called in a context that expects a scalar reference, but no \*(C`SCALARREF {...}\*(C' block is provided, then Contextual::Return tries the following blocks in order:</p><p>        REF {...}     NONVOID {...}     DEFAULT {...}         STR {...} (automatically taking a reference to the result)         NUM {...} (automatically taking a reference to the result)      SCALAR {...} (automatically taking a reference to the result)       VALUE {...} (automatically taking a reference to the result)</p><p>Likewise, in a list context, if there is no \*(C`LIST {...}\*(C' context block, the module tries:</p><p>       VALUE {...}      NONVOID {...}      DEFAULT {...}     ARRAYREF {...} (automatically dereferencing the result)          STR {...} (treating it as a list of one element)          NUM {...} (treating it as a list of one element)       SCALAR {...} (treating it as a list of one element)</p><p>The more generic context blocks are especially useful for intercepting unexpected and undesirable call contexts. For example, to turn <em>off</em> the automatic scalar-ref and array-ref interpolative behaviour described in \*(L"Interpolative referential contexts\*(R", you could intercept <em>all</em> referential contexts using a generic \*(C`REF {...}\*(C' context block:</p><p>    sub get_todo_tasks {         return (             SCALAR { scalar @todo_list }      # How many?             LIST   { @todo_list        }      # What are they?</p><p>            REF { croak q{get_todo_task() can&apos;t be used as a reference} }         );     }</p><p>    print &apos;There are &apos;, get_todo_tasks(), &apos;...&apos;;    # Still okay     print "There are ${get_todo_tasks()}...";       # Throws an exception</p>
<h3>Treating return values as objects</h3>
<p>Normally, when a return value is treated as an object (i.e. has a method called on it), Contextual::Return invokes any \*(C`OBJREF\*(C' handler that was specified in the contextual return list, and delegates the method call to the object returned by that handler.</p><p>However, you can also be more specific, by specifying a \*(C`METHOD\*(C' context handler in the contextual return list. The block of this handler is expected to return one or more method-name/method-handler pairs, like so:</p><p>    return         METHOD {             get_count =&gt; sub { my $n = shift; $data[$n]{count} },             get_items =&gt; sub { my $n = shift; $data[$n]{items} },             clear     =&gt; sub { @data = (); },             reset     =&gt; sub { @data = (); },         }</p><p>Then, whenever one of the specified methods is called on the return value, the corresponding subroutine will be called to implement it.</p><p>The method handlers must always be subroutine references, but the method-name specifiers may be strings (as in the previous example) or they may be specified generically, as either regexes or array references. Generic method names are used to call the same handler for two or more distinct method names. For example, the previous example could be simplified to:</p><p>    return         METHOD {             qr/get_(&#92;w+)/     =&gt; sub { my $n = shift; $data[$n]{$1} },             [&apos;clear&apos;,&apos;reset&apos;] =&gt; sub { @data = (); },         }</p><p>A method name specified by regex will invoke the corresponding handler for any method call request that the regex matches. A method name specified by array ref will invoke the corresponding handler if the method requested matches any of the elements of the array (which may themselves be strings or regexes).</p><p>When the method handler is invoked, the name of the method requested is passed to the handler in $_, and the method's argument list is passed (as usual) via @_.</p><p>Note that any methods not explicitly handled by the \*(C`METHOD\*(C' handlers will still be delegated to the object returned by the \*(C`OBJREF\*(C' handler (if it is also specified).</p>
<h3>Not treating return values as objects</h3>
<p>The use of \*(C`OBJREF\*(C' and \*(C`METHOD\*(C' are slightly complicated by the fact that contextual return values are themselves objects.</p><p>For example, prior to version 0.4.4 of the module, if you passed a contextual return value to \*(C`Scalar::Util::blessed()\*(C', it always returned a true value (namely, the string: 'Contextual::Return::Value'), even if the return value had not specified handlers for \*(C`OBJREF\*(C' or \*(C`METHOD\*(C'.</p><p>In other words, the <em>implementation</em> of contextual return values (as objects) was getting in the way of the <em>use</em> of contextual return values (as non-objects).</p><p>So the module now also provides a \*(C`BLESSED\*(C' handler, which allows you to explicitly control how contextual return values interact with \*(C`Scalar::Util::blessed()\*(C'.</p><p>If $crv is a contextual return value, by default \*(C`Scalar::Util::blessed($crv)\*(C' will now only return true if that return value has a \*(C`OBJREF\*(C', \*(C`LAZY\*(C', \*(C`REF\*(C', \*(C`SCALAR\*(C', \*(C`VALUE\*(C', \*(C`NONVOID\*(C', or \*(C`DEFAULT\*(C' handler that in turn returns a blessed object.</p><p>However if $crv also provides a \*(C`BLESSED\*(C' handler, \*(C`blessed()\*(C' will return whatever that handler returns.</p><p>This means:</p><p>    sub simulate_non_object {         return BOOL { 1 }                 NUM { 42 }     }</p><p>    sub simulate_real_object {         return OBJREF { bless {}, &apos;My::Class&apos; }                  BOOL { 1 }                   NUM { 42 }     }</p><p>    sub simulate_faked_object {         return BLESSED { &apos;Foo&apos; }                   BOOL { 1 }                    NUM { 42 }     }</p><p>    sub simulate_previous_behaviour {         return BLESSED { &apos;Contextual::Return::Value&apos; }                   BOOL { 1 }                    NUM { 42 }     }</p><p>    say blessed( simulate_non_object()         );   # undef     say blessed( simulate_real_object()        );   # My::Class     say blessed( simulate_faked_object()       );   # Foo     say blessed( simulate_previous_behaviour() );   # Contextual::Return::Value</p><p>Typically, you either want no \*(C`BLESSED\*(C' handler (in which case contextual return values pretend not to be blessed objects), or you want \*(C`BLESSED { &apos;Contextual::Return::Value&apos; }\*(C' for backwards compatibility with pre-v0.4.7 behaviour.</p><p><em>Preventing fallbacks</em></p><p>Sometimes fallbacks can be too helpful. Or sometimes you want to impose strict type checking on a return value.</p><p>Contextual::Returns allows that via the \*(C`STRICT\*(C' specifier. If you include \*(C`STRICT\*(C' anywhere in your return statement, the module disables all fallbacks and will therefore through an exception if the return value is used in any way not explicitly specified in the contextual return sequence.</p><p>For example, to create a subroutine that returns only a string:</p><p>    sub get_name {         return STRICT STR { &apos;Bruce&apos; }     }</p><p>If the return value of the subroutine is used in any other way than as a string, an exception will be thrown.</p><p>You can still specify handlers for more than a single kind of context when using \*(C`STRICT\*(C':</p><p>    sub get_name {         return STRICT             STR  { &apos;Bruce&apos; }             BOOL { 0 }     }</p><p>...but these will still be the only contexts in which the return value can be used:</p><p>    my $n = get_name() ? 1 : 2;  # Okay because BOOL handler specified</p><p>    my $n = &apos;Dr&apos; . get_name();   # Okay because STR handler specified</p><p>    my $n = 1 + get_name();      # Exception thrown because no NUM handler</p><p>In other words, \*(C`STRICT\*(C' allows you to impose strict type checking on your contextual return value.</p>
<h3>Deferring handlers</h3>
<p>Because the various handlers form a hierarchy, it's possible to implement more specific handlers by falling back on (\*(L"deferring to\*(R") more general ones. For example, a \*(C`PUREBOOL\*(C' handler is almost always identical in its basic behaviour to the corresponding \*(C`BOOL\*(C' handler, except that it adds some side-effect. For example:</p><p>    return         PUREBOOL { $_ = $return_val; defined $return_val && $return_val &gt; 0 }             BOOL {                   defined $return_val && $return_val &gt; 0 }           SCALAR {                   $return_val;                           }</p><p>So Contextual::Return allows you to have a handler perform some action and then defer to a more general handler to supply the actual return value. To fall back to a more general case in this way, you simply write:</p><p>    next handler;</p><p>at the end of the handler in question, after which Contextual::Return will find the next-most-specific handler and execute it as well. So the previous example, could be re-written:</p><p>    return         PUREBOOL { $_ = $return_val; next handler;        }             BOOL { defined $return_val && $return_val &gt; 0 }           SCALAR { $return_val;                           }</p><p>Note that <em>any</em> specific handler can defer to a more general one in this same way. For example, you could provide consistent and maintainable type-checking for a subroutine that returns references by providing \*(C`ARRAYREF\*(C', \*(C`HASHREF\*(C', and \*(C`SCALARREF\*(C' handlers that all defer to a generic \*(C`REF\*(C' handler, like so:</p><p>    my $retval = _get_ref();</p><p>    return        SCALARREF { croak &apos;Type mismatch&apos; if ref($retval) ne &apos;SCALAR&apos;;                    next handler;                  }         ARRAYREF { croak &apos;Type mismatch&apos; if ref($retval) ne &apos;ARRAY&apos;;                    next handler;                  }          HASHREF { croak &apos;Type mismatch&apos; if ref($retval) ne &apos;HASH&apos;;                    next handler;                  }              REF { $retval }</p><p>If, at a later time, the process of returning a reference became more complex, only the \*(C`REF\*(C' handler would have to be updated.</p>
<h3>Nested handlers</h3>
<p>Another way of factoring out return behaviour is to nest more specific handlers inside more general ones. For instance, in the final example given in \*(L"Boolean vs Pure Boolean contexts\*(R":</p><p>    sub get_data {         my $data;         return             PUREBOOL {        _check_for_but_dont_get_data();   }                 BOOL { defined( $data ||= _go_and_get_data() ); }                  REF {          $data ||= _go_and_get_data();   }     }</p><p>you could factor out the repeated calls to \*(C`_go_and_get_data()\*(C' like so:</p><p>    sub get_data {         return             PUREBOOL { _check_for_but_dont_get_data(); }              DEFAULT {                 my $data = _go_and_get_data();</p><p>                BOOL { defined $data; }                  REF {         $data; }              }     }</p><p>Here, the \*(C`DEFAULT\*(C' handler deals with every return context except pure boolean. Within that \*(C`DEFAULT\*(C' handler, the data is first retrieved, and then two \*(L"sub-handlers\*(R" deal with the ordinary boolean and referential contexts.</p><p>Typically nested handlers are used in precisely this way: to optimize for inexpensive special cases (such as pure boolean or integer or void return contexts) and only do extra work for those other cases that require it.</p>
<h3>Failure contexts</h3>
<p>Two of the most common ways to specify that a subroutine has failed are to return a false value, or to throw an exception. The Contextual::Return module provides a mechanism that allows the subroutine writer to support <em>both</em> of these mechanisms at the same time, by using the \*(C`FAIL\*(C' specifier.</p><p>A return statement of the form:</p><p>    return FAIL;</p><p>causes the surrounding subroutine to return \*(C`undef\*(C' (i.e. false) in boolean contexts, and to throw an exception in any other context. For example:</p><p>    use Contextual::Return;</p><p>    sub get_next_val {         my $next_val = &lt;&gt;;         return FAIL if !defined $next_val;         chomp $next_val;         return $next_val;     }</p><p>If the \*(C`return FAIL\*(C' statement is executed, it will either return false in a boolean context:</p><p>    if (my $val = get_next_val()) {      # returns undef if no next val         print "[$val]&#92;n";     }</p><p>or else throw an exception if the return value is used in any other context:</p><p>    print get_next_val();       # throws exception if no next val</p><p>    my $next_val = get_next_val();     print "[$next_val]&#92;n";      # throws exception if no next val</p><p>The exception that is thrown is of the form:</p><p>    Call to main::get_next_val() failed at demo.pl line 42</p><p>but you can change that message by providing a block to the \*(C`FAIL\*(C', like so:</p><p>    return FAIL { "No more data" } if !defined $next_val;</p><p>in which case, the final value of the block becomes the exception message:</p><p>    No more data at demo.pl line 42</p><p>A failure value can be interrogated for its error message, by calling its \*(C`error()\*(C' method, like so:</p><p>    my $val = get_next_val();     if ($val) {         print "[$val]&#92;n";     }     else {         print $val-&gt;error, "&#92;n";     }</p>
<h3>Configurable failure contexts</h3>
<p>The default \*(C`FAIL\*(C' behaviour\*(--false in boolean context, fatal in all others\*(--works well in most situations, but violates the Platinum Rule ("Do unto others as <em>they</em> would have done unto them").</p><p>So it may be user-friendlier if the user of a module is allowed decide how the module's subroutines should behave on failure. For example, one user might prefer that failing subs always return undef; another might prefer that they always throw an exception; a third might prefer that they always log the problem and return a special Failure object; whilst a fourth user might want to get back 0 in scalar contexts, an empty list in list contexts, and an exception everywhere else.</p><p>You could create a module that allows the user to specify all these alternatives, like so:</p><p>    package MyModule;     use Contextual::Return;     use Log::StdLog;</p><p>    sub import {         my ($package, @args) = @_;</p><p>        Contextual::Return::FAIL_WITH {             &apos;:false&apos; =&gt; sub { return undef },             &apos;:fatal&apos; =&gt; sub { croak @_       },             &apos;:filed&apos; =&gt; sub {                             print STDLOG &apos;Sub &apos;, (caller 1)[3], &apos; failed&apos;;                             return Failure-&gt;new();                         },             &apos;:fussy&apos; =&gt; sub {                             SCALAR  { undef      }                             LIST    { ()         }                             DEFAULT { croak @_ }                         },         }, @args;     }</p><p>This configures Contextual::Return so that, instead of the usual false-or-fatal semantics, every \*(C`return FAIL\*(C' within MyModule's namespace is implemented by one of the four subroutines specified in the hash that was passed to \*(C`FAIL_WITH\*(C'.</p><p>Which of those four subs implements the \*(C`FAIL\*(C' is determined by the arguments passed after the hash (i.e. by the contents of @args). \*(C`FAIL_WITH\*(C' walks through that list of arguments and compares them against the keys of the hash. If a key matches an argument, the corresponding value is used as the implementation of \*(C`FAIL\*(C'. Note that, if subsequent arguments also match a key, their subroutine overrides the previously installed implementation, so only the final override has any effect. Contextual::Return generates warnings when multiple overrides are specified.</p><p>All of which mean that, if a user loaded the MyModule module like this:</p><p>    use MyModule qw( :fatal other args here );</p><p>then every \*(C`FAIL\*(C' within MyModule would be reconfigured to throw an exception in all circumstances, since the presence of the &apos;:fatal&apos; in the argument list will cause \*(C`FAIL_WITH\*(C' to select the hash entry whose key is &apos;:fatal&apos;.</p><p>On the other hand, if they loaded the module:</p><p>    use MyModule qw( :fussy other args here );</p><p>then each \*(C`FAIL\*(C' within MyModule would return undef or empty list or throw an exception, depending on context, since that's what the subroutine whose key is &apos;:fussy&apos; does.</p><p>Many people prefer module interfaces with a \*(C`<strong>flag =&gt; </strong><strong>value\*(C'</strong> format, and \*(C`FAIL_WITH\*(C' supports this too. For example, if you wanted your module to take a \*(C`-fail\*(C' flag, whose associated value could be any of "undefined", "exception", "logged", or "context", then you could implement that simply by specifying the flag as the first argument (i.e. <em>before</em> the hash) like so:</p><p>    sub import {         my $package = shift;</p><p>        Contextual::Return::FAIL_WITH -fail =&gt; {             &apos;undefined&apos; =&gt; sub { return undef },             &apos;exception&apos; =&gt; sub { croak @_ },             &apos;logged&apos;    =&gt; sub {                             print STDLOG &apos;Sub &apos;, (caller 1)[3], &apos; failed&apos;;                             return Failure-&gt;new();                         },             &apos;context&apos; =&gt; sub {                             SCALAR  { undef      }                             LIST    { ()         }                             DEFAULT { croak @_ }                         },         }, @_;</p><p>and then load the module:</p><p>    use MyModule qw( other args here ), -fail=&gt;&apos;undefined&apos;;</p><p>or:</p><p>    use MyModule qw( other args here ), -fail=&gt;&apos;exception&apos;;</p><p>In this case, \*(C`FAIL_WITH\*(C' scans the argument list for a pair of values: its flag string, followed by some other selector value. Then it looks up the selector value in the hash, and installs the corresponding subroutine as its local \*(C`FAIL\*(C' handler.</p><p>If this \*(L"flagged\*(R" interface is used, the user of the module can also specify their own handler directly, by passing a subroutine reference as the selector value instead of a string:</p><p>    use MyModule qw( other args here ), -fail=&gt;sub{ die &apos;horribly&apos;};</p><p>If this last example were used, any call to \*(C`FAIL\*(C' within MyModule would invoke the specified anonymous subroutine (and hence throw a 'horribly' exception).</p><p>Note that, any overriding of a \*(C`FAIL\*(C' handler is specific to the namespace and file from which the subroutine that calls \*(C`FAIL_WITH\*(C' is itself called. Since \*(C`FAIL_WITH\*(C' is designed to be called from within a module's \*(C`import()\*(C' subroutine, that generally means that the \*(C`FAIL\*(C's within a given module X are only overridden for the current namespace within the particular file from module X is loaded. This means that two separate pieces of code (in separate files or separate namespaces) can each independently overide a module's \*(C`FAIL\*(C' behaviour, without interfering with each other.</p>
<h3>Lvalue contexts</h3>
<p>Recent versions of Perl offer (limited) support for lvalue subroutines: subroutines that return a modifiable variable, rather than a simple constant value.</p><p>Contextual::Return can make it easier to create such subroutines, within the limitations imposed by Perl itself. The limitations that Perl places on lvalue subs are:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>The subroutine must be declared with an \*(C`:lvalue\*(C' attribute:     sub foo :lvalue {...}</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>The subroutine must not return via an explicit \*(C`return\*(C'. Instead, the last statement must evaluate to a variable, or must be a call to another lvalue subroutine call.     my ($foo, $baz);</p><p>    sub foo :lvalue {         $foo;               # last statement evals to a var     }</p><p>    sub bar :lvalue {         foo();              # last statement is lvalue sub call     }</p><p>    sub baz :lvalue {         my ($arg) = @_;</p><p>        $arg &gt; 0            # last statement evals...             ? $baz          # ...to a var             : bar();        # ...or to an lvalue sub call     }</p>
  </dd>

</dl>
<p>Thereafter, any call to the lvalue subroutine produces a result that can be assigned to:</p><p>    <strong>baz</strong>(0) = 42;            # same as: $baz = 42</p><p>    <strong>baz</strong>(1) = 84;            # same as:                  bar() = 84                             #  which is the same as:    foo() = 84                             #   which is the same as:   $foo  = 84</p><p>Ultimately, every lvalue subroutine must return a scalar variable, which is then used as the lvalue of the assignment (or whatever other lvalue operation is applied to the subroutine call). Unfortunately, because the subroutine has to return this variable <em>before</em> the assignment can take place, there is no way that a normal lvalue subroutine can get access to the value that will eventually be assigned to its return value.</p><p>This is occasionally annoying, so the Contextual::Return module offers a solution: in addition to all the context blocks described above, it provides three special contextual return blocks specifically for use in lvalue subroutines: \*(C`LVALUE\*(C', \*(C`RVALUE\*(C', and \*(C`NVALUE\*(C'.</p><p>Using these blocks you can specify what happens when an lvalue subroutine is used in lvalue and non-lvalue (rvalue) context. For example:</p><p>    my $verbosity_level = 1;</p><p>    # Verbosity values must be between 0 and 5...     sub verbosity :lvalue {         LVALUE { $verbosity_level = max(0, min($_, 5)) }         RVALUE { $verbosity_level                      }     }</p><p>The \*(C`LVALUE\*(C' block is executed whenever \*(C`verbosity\*(C' is called as an lvalue:</p><p>    verbosity() = 7;</p><p>The block has access to the value being assigned, which is passed to it as $_. So, in the above example, the assigned value of 7 would be aliased to $_ within the \*(C`LVALUE\*(C' block, would be reduced to 5 by the \*(L"min-of-max\*(R" expression, and then assigned to $verbosity_level.</p><p>(If you need to access the caller's $_, it's also still available: as $CALLER::_.)</p><p>When the subroutine isn't used as an lvalue:</p><p>    print verbosity();</p><p>the \*(C`RVALUE\*(C' block is executed instead and its final value returned. Within an \*(C`RVALUE\*(C' block you can use any of the other features of Contextual::Return. For example:</p><p>    sub verbosity :lvalue {         LVALUE { $verbosity_level = int max(0, min($_, 5)) }         RVALUE {             NUM  { $verbosity_level               }             STR  { $description[$verbosity_level] }             BOOL { $verbosity_level &gt; 2           }         }     }</p><p>but the context sequence must be nested inside an \*(C`RVALUE\*(C' block.</p><p>You can also specify what an lvalue subroutine should do when it is used neither as an lvalue nor as an rvalue (i.e. in void context), by using an \*(C`NVALUE\*(C' block:</p><p>    sub verbosity :lvalue {         my ($level) = @_;</p><p>        NVALUE { $verbosity_level = int max(0, min($level, 5)) }         LVALUE { $verbosity_level = int max(0, min($_,     5)) }         RVALUE {             NUM  { $verbosity_level               }             STR  { $description[$verbosity_level] }             BOOL { $verbosity_level &gt; 2           }         }     }</p><p>In this example, a call to \*(C`verbosity()\*(C' in void context sets the verbosity level to whatever argument is passed to the subroutine:</p><p>    <strong>verbosity</strong>(1);</p><p>Note that you <em>cannot</em> get the same effect by nesting a \*(C`VOID\*(C' block within an \*(C`RVALUE\*(C' block:</p><p>        LVALUE { $verbosity_level = int max(0, min($_, 5)) }         RVALUE {             NUM  { $verbosity_level               }             STR  { $description[$verbosity_level] }             BOOL { $verbosity_level &gt; 2           }             VOID { $verbosity_level = $level      }  # Wrong!         }</p><p>That's because, in a void context the return value is never evaluated, so it is never treated as an rvalue, which means the \*(C`RVALUE\*(C' block never executes.</p>
<h3>Result blocks</h3>
<p>Occasionally, it's convenient to calculate a return value <em>before</em> the end of a contextual return block. For example, you may need to clean up external resources involved in the calculation after it's complete. Typically, this requirement produces a slightly awkward code sequence like this:</p><p>    return         VALUE {             $db-&gt;start_work();             my $result = $db-&gt;retrieve_query($query);             $db-&gt;commit();             $result;         }</p><p>Such code sequences become considerably more awkward when you want the return value to be context sensitive, in which case you have to write either:</p><p>    return         LIST {             $db-&gt;start_work();             my @result = $db-&gt;retrieve_query($query);             $db-&gt;commit();             @result;         }         SCALAR {             $db-&gt;start_work();             my $result = $db-&gt;retrieve_query($query);             $db-&gt;commit();             $result;         }</p><p>or, worse:</p><p>    return         VALUE {             $db-&gt;start_work();             my $result = LIST ? [$db-&gt;retrieve_query($query)]                               :  $db-&gt;retrieve_query($query);             $db-&gt;commit();             LIST ? @{$result} : $result;         }</p><p>To avoid these infelicities, Contextual::Return provides a second way of setting the result of a context block; a way that doesn't require that the result be the last statement in the block:</p><p>    return         LIST {             $db-&gt;start_work();             RESULT { $db-&gt;retrieve_query($query) };             $db-&gt;commit();         }         SCALAR {             $db-&gt;start_work();             RESULT { $db-&gt;retrieve_query($query) };             $db-&gt;commit();         }</p><p>The presence of a \*(C`RESULT\*(C' block inside a contextual return block causes that block to return the value of the final statement of the \*(C`RESULT\*(C' block as the handler's return value, rather than returning the value of the handler's own final statement. In other words, the presence of a \*(C`RESULT\*(C' block overrides the normal return value of a context handler.</p><p>Better still, the \*(C`RESULT\*(C' block always evaluates its final statement in the same context as the surrounding \*(C`return\*(C', so you can just write:</p><p>    return         VALUE {             $db-&gt;start_work();             RESULT { $db-&gt;retrieve_query($query) };             $db-&gt;commit();         }</p><p>and the \*(C`retrieve_query()\*(C' method will be called in the appropriate context in all cases.</p><p>A \*(C`RESULT\*(C' block can appear anywhere inside any contextual return block, but may not be used outside a context block. That is, this is an error:</p><p>    if ($db-&gt;closed) {         RESULT { undef }; # Error: not in a context block     }     return         VALUE {             $db-&gt;start_work();             RESULT { $db-&gt;retrieve_query($query) };             $db-&gt;commit();         }</p>
<h3>Post-handler clean-up</h3>
<p>If a subroutine uses an external resource, it's often necessary to close or clean-up that resource after the subroutine ends...regardless of whether the subroutine exits normally or via an exception.</p><p>Typically, this is done by encapsulating the resource in a lexically scoped object whose destructor does the clean-up. However, if the clean-up doesn't involve deallocation of an object (as in the \*(C`$db-&gt;commit()\*(C' example in the previous section), it can be annoying to have to create a class and allocate a container object, merely to mediate the clean-up.</p><p>To make it easier to manage such resources, Contextual::Return supplies a special labelled block: the \*(C`RECOVER\*(C' block. If a \*(C`RECOVER\*(C' block is specified as part of a contextual return sequence, that block is executed after any context handler, even if the context handler exits via an exception.</p><p>So, for example, you could implement a simple commit-or-revert policy like so:</p><p>    return         LIST    { $db-&gt;retrieve_all($query)  }         SCALAR  { $db-&gt;retrieve_next($query) }         RECOVER {             if ($@) {                 $db-&gt;revert();             }             else {                 $db-&gt;commit();             }         }</p><p>The presence of a \*(C`RECOVER\*(C' block also intercepts all exceptions thrown in any other context block in the same contextual return sequence. Any such exception is passed into the \*(C`RECOVER\*(C' block in the usual manner: via the $@ variable. The exception may be rethrown out of the \*(C`RECOVER\*(C' block by calling \*(C`die\*(C':</p><p>    return         LIST    { $db-&gt;retrieve_all($query) }         DEFAULT { croak "Invalid call (not in list context)" }         RECOVER {             die $@ if $@;    # Propagate any exception             $db-&gt;commit();   # Otherwise commit the changes         }</p><p>A \*(C`RECOVER\*(C' block can also access or replace the returned value, by invoking a \*(C`RESULT\*(C' block. For example:</p><p>    return         LIST    { attempt_to_generate_list_for(@_)  }         SCALAR  { attempt_to_generate_count_for(@_) }         RECOVER {             if ($@) {                # On any exception...                 warn "Replacing return value. Previously: ", RESULT;                 RESULT { undef }     # ...return undef             }         }</p>
<h3>Post-return clean-up</h3>
<p>Occasionally it's necessary to defer the clean-up of resources until after the return value has been used. Once again, this is usually done by returning an object with a suitable destructor.</p><p>Using Contextual::Return you can get the same effect, by providing a \*(C`CLEANUP\*(C' block in the contextual return sequence:</p><p>    return         LIST    { $db-&gt;retrieve_all($query)  }         SCALAR  { $db-&gt;retrieve_next($query) }         CLEANUP { $db-&gt;commit()              }</p><p>In this example, the \*(C`commit\*(C' method call is only performed after the return value has been used by the caller. Note that this is quite different from using a \*(C`RECOVER\*(C' block, which is called as the subroutine returns its value; a \*(C`CLEANUP\*(C' is called when the returned value is garbage collected.</p><p>A \*(C`CLEANUP\*(C' block is useful for controlling resources allocated to support an \*(C`ACTIVE\*(C' return value. For example:</p><p>    my %file;</p><p>    # Return an active value that is always the next line from a file...     sub readline_from {         my ($file_name) = @_;</p><p>        # Open the file, if not already open...         if (!$file{$file_name}) {             open $file{$file_name}{handle}, &apos;&lt;&apos;, $file_name;         }</p><p>        # Track how many active return values are using this file...         $file{$file_name}{count}++;</p><p>        return ACTIVE             # Evaluating the return value returns the next line...             VALUE   { readline $file{$file_name}{handle} }</p><p>            # Once the active value is finished with, clean up the filehandle...             CLEANUP {                 delete $file{$file_name}                     if --$file{$file_name}{count} == 0;             }     }</p>
<h3>Debugging contextual return values</h3>
<p>Contextual return values are implemented as opaque objects (using the \*(L"inside-out\*(R" technique). This means that passing such values to Data::Dumper produces an uninformative output like:</p><p>    $VAR1 = bless( do{&#92;(my $o = undef)}, &apos;Contextual::Return::Value&apos; );</p><p>So the module provides two methods that allow contextual return values to be correctly reported: either directly, or when dumped by Data::Dumper.</p><p>To dump a contextual return value directly, call the module's \*(C`DUMP()\*(C' method explicitly and print the result:</p><p>    print $crv-&gt;Contextual::Return::DUMP();</p><p>This produces an output something like:</p><p>    [      { FROM       =&gt; &apos;main::foo&apos;                                       },      { NO_HANDLER =&gt; [ &apos;VOID&apos;, &apos;CODEREF&apos;, &apos;HASHREF&apos;, &apos;GLOBREF&apos; ]       },      { FALLBACKS  =&gt; [ &apos;VALUE&apos; ]                                       },      { LIST       =&gt; [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]                 },      { STR        =&gt; &apos;&lt;&lt;&lt;Throws exception: Died at demo.pl line 7.&gt;&gt;&gt;&apos; },      { NUM        =&gt; 42                                                },      { BOOL       =&gt; -1                                                },      { SCALARREF  =&gt; &apos;&lt;&lt;&lt;self-reference&gt;&gt;&gt;&apos;                            },      { ARRAYREF   =&gt; [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]                 },     ];</p><p>The \*(C`FROM\*(C' hash entry names the subroutine that produced the return value. The \*(C`NO_HANDLER\*(C' hash entry lists those contexts for which no handler was defined (and which would therefore normally produce \*(L"can't call\*(R" exceptions such as: "Can&apos;t call main::foo in VOID context"). The \*(C`FALLBACKS\*(C' hash entry lists any \*(L"generic\*(R" contexts such as \*(C`VALUE\*(C', \*(C`NONVOID\*(C', \*(C`REF\*(C', \*(C`DEFAULT\*(C', etc. that the contextual return value can also handle. After these, all the remaining hash entries are actual contexts in which the return value could successfully be evaluated, and the value it would produce in each of those contexts.</p><p>The Data::Dumper module also has a mechanism by which you can tell it how to produce a similar listing automatically whenever a contextual return value is passed to its \*(C`Dumper\*(C' method. Data::Dumper allows you to register a \*(L"freezer\*(R" method, that is called prior to dumping, and which can be used to adapt an opaque object to make it dumpable. Contextual::Return provides just such a method (\*(C`Contextual::Return::FREEZE()\*(C') for you to register, like so:</p><p>    use Data::Dumper &apos;Dumper&apos;;</p><p>    local $Data::Dumper::Freezer = &apos;Contextual::Return::FREEZE&apos;;</p><p>    print Dumper $foo;</p><p>The output is then precisely the same as \*(C`Contextual::Return::DUMP()\*(C' would produce.</p><p>Note that, with both of the above dumping mechanisms, it is essential to use the full name of the method. That is:</p><p>    print $crv-&gt;Contextual::Return::DUMP();</p><p>rather than:</p><p>    print $crv-&gt;DUMP();</p><p>This is because the shorter version is interpreted as calling the \*(C`DUMP()\*(C' method on the object returned by the return value's \*(C`OBJREF\*(C' context block (see \*(L"Scalar reference contexts\*(R")</p><p>For the same reason, you must write:</p><p>    local $Data::Dumper::Freezer = &apos;Contextual::Return::FREEZE&apos;;</p><p>not:</p><p>    local $Data::Dumper::Freezer = &apos;FREEZE&apos;;</p>
<h3>Namespace controls</h3>
<p>By default the module exports a large number of return context markers:</p><p>    DEFAULT    REF          LAZY     VOID       SCALARREF    FIXED     NONVOID    ARRAYREF     ACTIVE     LIST       CODEREF      RESULT     SCALAR     HASHREF      RECOVER     VALUE      GLOBREF      CLEANUP     STR        OBJREF       RVALUE     NUM        METHOD       LVALUE     BOOL                    NVALUE     PUREBOOL</p><p>These are exported as subroutines, and so can conflict with existing subroutines in your namespace, or with subroutines imported from other modules.</p><p>Contextual::Return allows you to control which contextual return blocks are exported into any namespace that uses the module. It also allows you to rename blocks to avoid namespace conflicts with existing subroutines.</p><p>Both these features are controlled by passing arguments to the \*(C`use\*(C' statement that loads the module as follows:</p><ul>
<li><p>Any string passed as an argument to \*(C`use Contextual::Return\*(C', exports only the block name it specifies;</p></li><li><p>Any regex passed as an argument to \*(C`use Contextual::Return\*(C' exports every block name it matches;</p></li><li><p>Any array ref (recursively) exports each of its elements</p></li><li><p>Any string that appears immediately after one of the above three specifiers, and which is not itself a block name, renames the handlers exported by that preceding specifier by filtering each handler name through \*(C`sprintf()\*(C'</p></li>
</ul><p>That is, you can specify handlers to be exported by exact name (as a string), by general pattern (as a regex), or collectively (in an array). And after any of these export specifications, you can append a template in which any &apos;%s&apos; will be replaced by the original name of the handler. For example:</p><p>    # Selectively export specific sets of handlers...     use Contextual::Return  qr/[NLR]VALUE/;     use Contextual::Return  qr/.*REF/;</p><p>    # Selective export specific sets and add a suffix to each...     use Contextual::Return  qr/[NLR]VALUE/ =&gt; &apos;%s_CONTEXT&apos;;</p><p>    # Selective export specific sets and add a prefix to each...     use Contextual::Return  qr/.*REF/ =&gt; &apos;CR_%s&apos;;</p><p>    # Export a list of handlers...     use Contextual::Return    &apos;NUM&apos;, &apos;STR&apos;, &apos;BOOL&apos; ;     use Contextual::Return qw&lt; NUM    STR    BOOL &gt;;     use Contextual::Return   [&apos;NUM&apos;, &apos;STR&apos;, &apos;BOOL&apos;];</p><p>    # Export a list of handlers, renaming them individually...     use Contextual::Return  NUM =&gt; &apos;NUMERIC&apos;, STR =&gt; &apos;TEXT&apos;, BOOL =&gt; &apos;CR_%s&apos;;</p><p>    # Export a list of handlers, renaming them collectively...     use Contextual::Return  [&apos;NUM&apos;, &apos;STR&apos;, &apos;BOOL&apos;] =&gt; &apos;%s_CONTEXT&apos;;</p><p>    # Mixed exports and renames...     use Contextual::Return (         STR =&gt; &apos;TEXT&apos;,         [&apos;NUM&apos;, &apos;BOOL&apos;] =&gt; &apos;CR_%s&apos;,         [&apos;LIST&apos;, &apos;SCALAR&apos;, &apos;VOID&apos;, qr/^[NLR]VALUE/] =&gt; &apos;%s_CONTEXT&apos;,     );</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INTERFACE</h2>
        <div class="sectioncontent">
<h3>Context tests</h3>
<p>Returns true if the current subroutine was called in list context. A cleaner way of writing: \*(C`wantarray()\*(C' Returns true if the current subroutine was called in scalar context. A cleaner way of writing: \*(C`defined wantarray() && ! wantarray()\*(C' Returns true if the current subroutine was called in void context. A cleaner way of writing: \*(C`!defined wantarray()\*(C' Returns true if the current subroutine was called in list or scalar context. A cleaner way of writing: \*(C`defined wantarray()\*(C'</p>
<h3>Standard contexts</h3>
<p>The block specifies what the context sequence should evaluate to when called in list context. The block specifies what the context sequence should evaluate to in scalar contexts, unless some more-specific specifier scalar context specifier (see below) also occurs in the same context sequence. The block specifies what the context sequence should do when called in void context.</p>
<h3>Scalar value contexts</h3>
<p>The block specifies what the context sequence should evaluate to when treated as a boolean value. The block specifies what the context sequence should evaluate to when treated as a numeric value. The block specifies what the context sequence should evaluate to when treated as a string value. Another name for \*(C`SCALAR {...}\*(C'. Usefully self-documenting when the primary purpose of the contextual return is to defer evaluation of the return value until it's actually required.</p>
<h3>Scalar reference contexts</h3>
<p>The block specifies what the context sequence should evaluate to when treated as a reference to a scalar. The block specifies what the context sequence should evaluate to when treated as a reference to an array. The block specifies what the context sequence should evaluate to when treated as a reference to a hash. Note that a common error here is to write: \s-1HASHREF\s0 { a=&gt;1, b=&gt;2, c=&gt;3 } The curly braces there are a block, not a hash constructor, so the block doesn't return a hash reference and the interpreter throws an exception. What's needed is: \s-1HASHREF\s0 { {a=&gt;1, b=&gt;2, c=&gt;3} } in which the inner braces <em>are</em> a hash constructor. The block specifies what the context sequence should evaluate to when treated as a reference to a subroutine. The block specifies what the context sequence should evaluate to when treated as a reference to a typeglob. The block specifies what the context sequence should evaluate to when treated as a reference to an object. The block can be used to specify particular handlers for specific method calls when the return value is treated as an object reference. It should return a list of methodname/methodbody pairs. Each method name can be specified as a string, a regex, or an array of strings or regexes. The method bodies must be specified as subroutine references (usually anonymous subs). The first method name that matches the actual method call selects the corresponding handler, which is then called.</p>
<h3>Generic contexts</h3>
<p>The block specifies what the context sequence should evaluate to when treated as a non-referential value (as a boolean, numeric, string, scalar, or list). Only used if there is no more-specific value context specifier in the context sequence. The block specifies what the context sequence should evaluate to when treated as a reference of any kind. Only used if there is no more-specific referential context specifier in the context sequence. The block specifies what the context sequence should evaluate to when used in a non-void context of any kind. Only used if there is no more-specific context specifier in the context sequence. The block specifies what the context sequence should evaluate to when used in a void or non-void context of any kind. Only used if there is no more-specific context specifier in the context sequence.</p>
<h3>Failure context</h3>
<p>This block is executed unconditionally and is used to indicate failure. In a Boolean context it return false. In all other contexts it throws an exception consisting of the final evaluated value of the block. That is, using \*(C`FAIL\*(C': return \s-1FAIL\s0 { \*(L"Could not defenestrate the widget\*(R" } is exactly equivalent to writing: return \s-1BOOL\s0 { 0 } \s-1DEFAULT\s0 { croak \*(L"Could not defenestrate the widget\*(R" } except that the reporting of errors is a little smarter under \*(C`FAIL\*(C'. If \*(C`FAIL\*(C' is called without specifying a block: return \s-1FAIL\s0; it is equivalent to: return \s-1FAIL\s0 { croak \*(L"Call to &lt;subname&gt; failed\*(R" } (where \*(C`&lt;subname&gt;\*(C' is replaced with the name of the surrounding subroutine). Note that, because \*(C`FAIL\*(C' implicitly covers every possible return context, it cannot be chained with other context specifiers. This subroutine is not exported, but may be called directly to reconfigure \*(C`FAIL\*(C' behaviour in the caller's namespace. The subroutine is called with an optional string (the <em>flag</em>), followed by a mandatory hash reference (the <em>configurations hash</em>), followed by a list of zero-or-more strings (the <em>selector list</em>). The values of the configurations hash must all be subroutine references. If the optional flag is specified, \*(C`FAIL_WITH\*(C' searches the selector list looking for that string, then uses the <em>following</em> item in the selector list as its <em>selector value</em>. If that selector value is a string, \*(C`FAIL_WITH\*(C' looks up that key in the hash, and installs the corresponding subroutine as the namespace's \*(C`FAIL\*(C' handler (an exception is thrown if the selector string is not a valid key of the configurations hash). If the selector value is a subroutine reference, \*(C`FAIL_WITH\*(C' installs that subroutine as the \*(C`FAIL\*(C' handler. If the optional flag is <em>not</em> specified, \*(C`FAIL_WITH\*(C' searches the entire selector list looking for the last element that matches any key in the configurations hash. It then looks up that key in the hash, and installs the corresponding subroutine as the namespace's \*(C`FAIL\*(C' handler. See \*(L"Configurable failure contexts\*(R" for examples of using this feature.</p>
<h3>Lvalue contexts</h3>
<p>This block is executed when the result of an \*(C`:lvalue\*(C' subroutine is assigned to. The assigned value is passed to the block as $_. To access the caller's $_ value, use $CALLER::_. This block is executed when the result of an \*(C`:lvalue\*(C' subroutine is used as an rvalue. The final value that is evaluated in the block becomes the rvalue. This block is executed when an \*(C`:lvalue\*(C' subroutine is evaluated in void context.</p>
<h3>Explicit result blocks</h3>
<p>This block may only appear inside a context handler block. It causes the surrounding handler to return the final value of the \*(C`RESULT\*(C''s block, rather than the final value of the handler's own block. This override occurs regardless of the location to the \*(C`RESULT\*(C' block within the handler. If called without a trailing \*(C`{...}\*(C', it simply returns the current result value in scalar contexts, or the list of result values in list context.</p>
<h3>Recovery blocks</h3>
<p>If present in a context return sequence, this block grabs control after any context handler returns or exits via an exception. If an exception was thrown it is passed to the \*(C`RECOVER\*(C' block via the $@ variable.</p>
<h3>Clean-up blocks</h3>
<p>If present in a context return sequence, this block grabs control when a return value is garbage collected.</p>
<h3>Modifiers</h3>
<p>This specifies that the scalar value will only be evaluated once, the first time it is used, and that the value will then morph into that evaluated value. This specifies that the scalar value's originating block will be re- evaluated every time the return value is used.</p>
<h3>Debugging support</h3>
<p>Dump a representation of the return value in all viable contexts Configure Data::Dumper to correctly dump a representation of the return value.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DIAGNOSTICS</h2>
        <div class="sectioncontent">
<p>In your \*(C`use Contextual::Return\*(C' statement you specified something (such as a hash or coderef) that can't be used to select what the module exports. Make sure the list of selectors includes only strings, regexes, or references to arrays of strings or regexes. In your \*(C`use Contextual::Return\*(C' statement you specified a regex to select which handlers to support, but the regex didn't select any handlers. Check that the regex you're using actually does match at least one of the names of the modules many handlers. In your \*(C`use Contextual::Return\*(C' statement you specified a string as the name of a context handler to be exported, but the module doesn't export a handler of that name. Check the spelling for the requested export. The subroutine you called uses a contextual return, but doesn't specify what to return in the particular context in which you called it. You either need to change the context in which you're calling the subroutine, or else add a context block corresponding to the offending context (or perhaps a \*(C`DEFAULT {...}\*(C' block). You specified a handler (such as \*(C`VOID {...}\*(C' or \*(C`LIST {...}\*(C') outside any subroutine, and in a context that it can't handle. Did you mean to place the handler outside of a subroutine? If so, then you need to put it in a context it can actually handle. Otherwise, perhaps you need to replace the trailing block with parens (that is: \*(C`VOID()\*(C' or \*(C`LIST()\*(C'). You called the subroutine in a context that expected to get back a reference of some kind but the subroutine didn't specify the corresponding \*(C`SCALARREF\*(C', \*(C`ARRAYREF\*(C', \*(C`HASHREF\*(C', \*(C`CODEREF\*(C', \*(C`GLOBREF\*(C', or generic \*(C`REF\*(C', \*(C`NONVOID\*(C', or \*(C`DEFAULT\*(C' handlers. You need to specify the appropriate one of these handlers in the subroutine. You called the subroutine and then tried to call a method on the return value, but the subroutine returned a classname or object that doesn't have that method. This probably means that the subroutine didn't return the classname or object you expected. Or perhaps you need to specify an \*(C`OBJREF {...}\*(C' context block. You attempted to specify two context blocks of the same name in the same return context, which is ambiguous. For example:     sub foo: lvalue {         LVALUE { $foo = $_ }         RVALUE { $foo }         LVALUE { $foo = substr($_,1,10) }     } or:     sub bar {         return             BOOL { 0 }             NUM  { 1 }             STR  { "two" }             BOOL { 1 };     } Did you cut-and-paste wrongly, or mislabel one of the blocks? If you specify any of \*(C`LVALUE\*(C', \*(C`RVALUE\*(C', or \*(C`NVALUE\*(C', then you can only specify \*(C`LVALUE\*(C', \*(C`RVALUE\*(C', or \*(C`NVALUE\*(C' blocks in the same return context. If you need to specify other contexts (like \*(C`BOOL\*(C', or \*(C`STR\*(C', or \*(C`REF\*(C', etc.), put them inside an \*(C`RVALUE\*(C' block. See \*(L"Lvalue contexts\*(R" for an example. This is the default exception that a \*(C`FAIL\*(C' throws in a non-scalar context. Which means that the subroutine you called has signalled failure by throwing an exception, and you didn't catch that exception. You should either put the call in an \*(C`eval {...}\*(C' block or else call the subroutine in boolean context instead. This is the default exception that a \*(C`FAIL\*(C' throws when a failure value is captured in a scalar variable and later used in a non-boolean context. That means that the subroutine you called must have failed, and you didn't check the return value for that failure, so when you tried to use that invalid value it killed your program. You should either put the original call in an \*(C`eval {...}\*(C' or else test the return value in a boolean context and avoid using it if it's false. The \*(C`FAIL_WITH\*(C' subroutine expects an optional flag, followed by a reference to a configuration hash, followed by a list or selector arguments. You gave it something else. See \*(L"Configurable Failure Contexts\*(R". You passed a configuration hash to \*(C`FAIL_WITH\*(C' that specified non- subroutines as possible \*(C`FAIL\*(C' handlers. Since non-subroutines can't possibly be handlers, maybe you forgot the \*(C`sub\*(C' keyword somewhere? The \*(C`FAIL_WITH\*(C' subroutine was passed a flag/selector pair, but the selector was not one of those allowed by the configuration hash. A warning that the \*(C`FAIL\*(C' handler for a particular package was reconfigured more than once. Typically that's because the module was loaded in two places with difference configurations specified. You can't reasonably expect two different sets of behaviours from the one module within the one namespace.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONFIGURATION AND ENVIRONMENT</h2>
        <div class="sectioncontent">
<p>Contextual::Return requires no configuration files or environment variables.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DEPENDENCIES</h2>
        <div class="sectioncontent">
<p>Requires version.pm and Want.pm.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INCOMPATIBILITIES</h2>
        <div class="sectioncontent">
<p>\*(C`LVALUE\*(C', \*(C`RVALUE\*(C', and \*(C`NVALUE\*(C' do not work correctly under the Perl debugger. This seems to be because the debugger injects code to capture the return values from subroutines, which interferes destructively with the optional final arguments that allow \*(C`LVALUE\*(C', \*(C`RVALUE\*(C', and \*(C`NVALUE\*(C' to cascade within a single return.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS AND LIMITATIONS</h2>
        <div class="sectioncontent">
<p>No bugs have been reported.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Damian Conway  \*(C`&lt;DCONWAY@cpan.org&gt;\*(C'</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LICENCE AND COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright (c) 2005-2011, Damian Conway \*(C`&lt;DCONWAY@cpan.org&gt;\*(C'. All rights reserved.</p><p>This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DISCLAIMER OF WARRANTY</h2>
        <div class="sectioncontent">
<p>\s-1BECAUSE\s0 \s-1THIS\s0 \s-1SOFTWARE\s0 \s-1IS\s0 \s-1LICENSED\s0 \s-1FREE\s0 \s-1OF\s0 \s-1CHARGE\s0, \s-1THERE\s0 \s-1IS\s0 \s-1NO\s0 \s-1WARRANTY\s0 \s-1FOR\s0 \s-1THE\s0 \s-1SOFTWARE\s0, \s-1TO\s0 \s-1THE\s0 \s-1EXTENT\s0 \s-1PERMITTED\s0 \s-1BY\s0 \s-1APPLICABLE\s0 \s-1LAW\s0. \s-1EXCEPT\s0 \s-1WHEN\s0 \s-1OTHERWISE\s0 \s-1STATED\s0 \s-1IN\s0 \s-1WRITING\s0 \s-1THE\s0 \s-1COPYRIGHT\s0 \s-1HOLDERS\s0 \s-1AND/OR\s0 \s-1OTHER\s0 \s-1PARTIES\s0 \s-1PROVIDE\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \*(L"\s-1AS\s0 \s-1IS\s0\*(R" \s-1WITHOUT\s0 \s-1WARRANTY\s0 \s-1OF\s0 \s-1ANY\s0 \s-1KIND\s0, \s-1EITHER\s0 \s-1EXPRESSED\s0 \s-1OR\s0 \s-1IMPLIED\s0, \s-1INCLUDING\s0, \s-1BUT\s0 \s-1NOT\s0 \s-1LIMITED\s0 \s-1TO\s0, \s-1THE\s0 \s-1IMPLIED\s0 \s-1WARRANTIES\s0 \s-1OF\s0 \s-1MERCHANTABILITY\s0 \s-1AND\s0 \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0. \s-1THE\s0 \s-1ENTIRE\s0 \s-1RISK\s0 \s-1AS\s0 \s-1TO\s0 \s-1THE\s0 \s-1QUALITY\s0 \s-1AND\s0 \s-1PERFORMANCE\s0 \s-1OF\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1IS\s0 \s-1WITH\s0 \s-1YOU\s0. \s-1SHOULD\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1PROVE\s0 \s-1DEFECTIVE\s0, \s-1YOU\s0 \s-1ASSUME\s0 \s-1THE\s0 \s-1COST\s0 \s-1OF\s0 \s-1ALL\s0 \s-1NECESSARY\s0 \s-1SERVICING\s0, \s-1REPAIR\s0, \s-1OR\s0 \s-1CORRECTION\s0.</p><p>\s-1IN\s0 \s-1NO\s0 \s-1EVENT\s0 \s-1UNLESS\s0 \s-1REQUIRED\s0 \s-1BY\s0 \s-1APPLICABLE\s0 \s-1LAW\s0 \s-1OR\s0 \s-1AGREED\s0 \s-1TO\s0 \s-1IN\s0 \s-1WRITING\s0 \s-1WILL\s0 \s-1ANY\s0 \s-1COPYRIGHT\s0 \s-1HOLDER\s0, \s-1OR\s0 \s-1ANY\s0 \s-1OTHER\s0 \s-1PARTY\s0 \s-1WHO\s0 \s-1MAY\s0 \s-1MODIFY\s0 \s-1AND/OR\s0 \s-1REDISTRIBUTE\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1AS\s0 \s-1PERMITTED\s0 \s-1BY\s0 \s-1THE\s0 \s-1ABOVE\s0 \s-1LICENCE\s0, \s-1BE\s0 \s-1LIABLE\s0 \s-1TO\s0 \s-1YOU\s0 \s-1FOR\s0 \s-1DAMAGES\s0, \s-1INCLUDING\s0 \s-1ANY\s0 \s-1GENERAL\s0, \s-1SPECIAL\s0, \s-1INCIDENTAL\s0, \s-1OR\s0 \s-1CONSEQUENTIAL\s0 \s-1DAMAGES\s0 \s-1ARISING\s0 \s-1OUT\s0 \s-1OF\s0 \s-1THE\s0 \s-1USE\s0 \s-1OR\s0 \s-1INABILITY\s0 \s-1TO\s0 \s-1USE\s0 \s-1THE\s0 \s-1SOFTWARE\s0 (\s-1INCLUDING\s0 \s-1BUT\s0 \s-1NOT\s0 \s-1LIMITED\s0 \s-1TO\s0 \s-1LOSS\s0 \s-1OF\s0 \s-1DATA\s0 \s-1OR\s0 \s-1DATA\s0 \s-1BEING\s0 \s-1RENDERED\s0 \s-1INACCURATE\s0 \s-1OR\s0 \s-1LOSSES\s0 \s-1SUSTAINED\s0 \s-1BY\s0 \s-1YOU\s0 \s-1OR\s0 \s-1THIRD\s0 \s-1PARTIES\s0 \s-1OR\s0 A \s-1FAILURE\s0 \s-1OF\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1TO\s0 \s-1OPERATE\s0 \s-1WITH\s0 \s-1ANY\s0 \s-1OTHER\s0 \s-1SOFTWARE\s0), \s-1EVEN\s0 \s-1IF\s0 \s-1SUCH\s0 \s-1HOLDER\s0 \s-1OR\s0 \s-1OTHER\s0 \s-1PARTY\s0 \s-1HAS\s0 \s-1BEEN\s0 \s-1ADVISED\s0 \s-1OF\s0 \s-1THE\s0 \s-1POSSIBILITY\s0 \s-1OF\s0 \s-1SUCH\s0 \s-1DAMAGES\s0.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Context::Preserve.3pm.html"><span aria-hidden="true">&larr;</span> Context::Preserve.3pm: Run code after a subroutine call, preserving the context the subroutine would have seen if it were the last statement in the caller</a></li>
   <li class="next"><a href="Contextual::Return::Failure.3pm.html">Contextual::Return::Failure.3pm: Utility module for contextual::return <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

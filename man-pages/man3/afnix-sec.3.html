<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>afnix-sec: Standard security module</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Standard security module">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="afnix-sec (3) manual">
  <meta name="twitter:description" content="Standard security module">
  <meta name="twitter:image" content="https://www.carta.tech/images/afnix-afnix-sec-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/afnix-sec.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="afnix-sec (3) manual" />
  <meta property="og:description" content="Standard security module" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/afnix-afnix-sec-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">afnix-sec<small> (3)</small></h1>
        <p class="lead">Standard security module</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/afnix-sec.3.html">
      <span itemprop="name">afnix-sec: Standard security module</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/afnix/">
      <span itemprop="name">afnix</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/afnix-sec.3.html">
      <span itemprop="name">afnix-sec: Standard security module</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">STANDARD SECURITY MODULE</h2>
        <div class="sectioncontent">
<p>The Standard Security module is an original implementation of several standards and techniques used in the field of cryptography. The module provides the objects than enables message hashing, symetric and assymetric ciphers and digital signature computation. The implementation follows the recommendation from NIST and PKCS and the standard reference that it implements is always attached to the underlying object.</p><p><strong>Hash objects</strong></p><p>Hashing is the ability to generate an almost unique representation from a string. Although, there is no guarantee that two different string will not produce the same result -- known as a collision -- the sophistication of the hashing function attempt to minimize such eventuality. The hashing process is not reversible. There are several hashing functions available in the public domain. To name a few, MD5 is the message digest 5, and SHA is the secure hash algorithm. The following table illustrates the size of the result with different hashing functions.</p><table class="table table-striped">
<tr>
<th>Function</th>
<th>Result size</th></tr>

<tr>
<td>MD-2</td>
<td>128 bits</td></tr>

<tr>
<td>MD-4</td>
<td>128 bits</td></tr>

<tr>
<td>MD-5</td>
<td>128 bits</td></tr>

<tr>
<td>SHA-1</td>
<td>160 bits</td></tr>

<tr>
<td>SHA-224</td>
<td>224 bits</td></tr>

<tr>
<td>SHA-256</td>
<td>256 bits</td></tr>

<tr>
<td>SHA-384</td>
<td>384 bits</td></tr>

<tr>
<td>SHA-512</td>
<td>512 bits</td></tr>
</table><p><em>Hasher object</em></p><p>The Hasher class is a text hashing computation class. The class computes a hash value  from a literal object, a buffer or an input stream. Once computed, the hash value is stored as an array of bytes that can be retrieved one by one or at all in the form of a string representation.</p><p><em>Creating a hasher</em></p><p>Several hasher objects are available in the module. For example, the Md5 object is the hasher object that implements the MD-5 algorithm. The constructor does not take any argument.</p>
<pre>
# get a  MD-5 hasher
const md (afnix:sec:Md5)
# check the object
afnix:sec:hasher-p md # true
</pre>
<p>The compute method computes the hash value. For example, the string "abc" returns the value "900150983CD24FB0D6963F7D28E17F72" which is 16 bytes long.</p>
<pre>
const hval (md:compute "abc")
</pre>
<p><em>Creating a SHA hasher</em></p><p>There are several SHA objects that produces results of different size as indicated in the next table.</p><table class="table table-striped">
<tr>
<th>Hasher</th>
<th>Size</th>
<th>Constructor</th></tr>

<tr>
<td>SHA-1</td>
<td>160 bits</td>
<td>Sha1</td></tr>

<tr>
<td>SHA-224</td>
<td>224 bits</td>
<td>Sha224</td></tr>

<tr>
<td>SHA-256</td>
<td>256 bits</td>
<td>Sha256</td></tr>

<tr>
<td>SHA-384</td>
<td>384 bits</td>
<td>Sha384</td></tr>

<tr>
<td>SHA-512</td>
<td>512 bits</td>
<td>Sha512</td></tr>
</table><p>The compute method computes the hash value. For example, the string "abc" returns with SHA-1 the 20 bytes long value: "A9993E364706816ABA3E25717850C26C9CD0D89D"</p><p><strong>Cipher key principles</strong></p><p>Cipher key management is an important concept in the ciphering land. In a simple mode, a key is used by a cipher to encode some data. Although the key can be any sequence of bytes, it is preferable to have the key built from a specific source such like a pass-phrase. A cipher key comes basically into two flavors: keys for symmetric ciphers and keys for asymmetric ciphers. A key for a symmetric cipher is easy to derive and generally follows a standard process which is independent of the cipher itself. A key for an asymmetric cipher is more complex to derive and is generally dependent on the cipher itself.</p><p><em>Key operations</em></p><p>The basic operations associated with a key are the key identification by type and size. The key type is an item that identifies the key nature. The get-type method returns the key type as specified by the table below.</p><table class="table table-striped">
<tr>
<th>Key</th>
<th>Description</th></tr>

<tr>
<td>KSYM</td>
<td>Symmetric cipher key</td></tr>

<tr>
<td>KRSA</td>
<td>Asymmetric RSA cipher key</td></tr>

<tr>
<td>KMAC</td>
<td>Message authentication key</td></tr>

<tr>
<td>KDSA</td>
<td>Message signature key</td></tr>
</table><p>The message authentication key as represented by the KMAC symbol is similar to the symmetric key. The key type can be obtained with the get-type method.</p>
<pre>
# get the key type
const type (key:get-type)
</pre>
<p>The key size is the canonical size as specified by the key or the cipher specification. The get-bits returns the key size in bits. The get-size returns the key size in bytes rounded to the nearest value. The table below describes the nature of the key size returned.</p><table class="table table-striped">
<tr>
<th>Key</th>
<th>Type</th>
<th>Description</th></tr>

<tr>
<td>KSYM</td>
<td>byte</td>
<td>Byte array size</td></tr>

<tr>
<td>KRSA</td>
<td>bits</td>
<td>Modulus size</td></tr>

<tr>
<td>KMAC</td>
<td>byte</td>
<td>Byte array size</td></tr>

<tr>
<td>KDSA</td>
<td>bits</td>
<td>Signature size</td></tr>
</table>
<pre>
const bits (key:get-bits)
const size (key:get-size)
</pre>
<p><em>Key representation</em></p><p>Unfortunately, it is not easy to represent a key, since the representation depends on the key's type. For example, a symmetric key can be formatted as a simple octet string. On the other hand, a RSA key has two components; namely the modulus and the exponent, which needs to be distinguished and therefore making the representation more difficult. Other cipher keys are even more complicated. For this reason, the representation model is a relaxed one. The format method can be called without argument to obtain an unique octet string representation if this representation is possible. If the key representation requires some parameters, the format method may accept one or several arguments to distinguish the key components.</p><table class="table table-striped">
<tr>
<th>Key</th>
<th>Argument</th>
<th>Description</th></tr>

<tr>
<td>KSYM</td>
<td>none</td>
<td>Symmetric key octet string</td></tr>

<tr>
<td>KRSA</td>
<td>RSA-MODULUS</td>
<td>RSA modulus octet string</td></tr>

<tr>
<td>KRSA</td>
<td>RSA-PUBLIC-EXPONENT</td>
<td>RSA public exponent octet string</td></tr>

<tr>
<td>KRSA</td>
<td>RSA-SECRET-EXPONENT</td>
<td>RSA secret exponent octet string</td></tr>

<tr>
<td>KMAC</td>
<td>none</td>
<td>Message authentication key octet string</td></tr>

<tr>
<td>KDSA</td>
<td>DSA-P-PRIME</td>
<td>DSA secret prime octet string</td></tr>

<tr>
<td>KDSA</td>
<td>DSA-Q-PRIME</td>
<td>DSA secret prime octet string</td></tr>

<tr>
<td>KDSA</td>
<td>DSA-SECRET-KEY</td>
<td>DSA secret key</td></tr>

<tr>
<td>KDSA</td>
<td>DSA-PUBLIC-KEY</td>
<td>DSA public key</td></tr>

<tr>
<td>KDSA</td>
<td>DSA-PUBLIC-GENERATOR</td>
<td>DSA public generator</td></tr>
</table>
<pre>
# get a simple key representation
println (key:format)
# get a rsa modulus key representation
println (key:format afnix:sec:Key:RSA-MODULUS)
</pre>
<p>There are other key representations. The natural one is the byte representation for a symmetric key, while a number based representation is generally more convenient with asymmetric keys. The get-byte method returns a key byte by index if possible. The get-relatif-key returns a key value by relatif number if possible.</p><p><strong>Symmetric cipher key</strong></p><p><em>Creating a symmetric cipher key</em></p><p>The Key class can be used to create a cipher key suitable for a symmetric cipher. By default a 128 bits random key is generated, but the key can be also generated from an octet string.</p>
<pre>
const  key  (afnix:sec:Key)
assert true (afnix:sec:key-p key)
</pre>
<p>The constructor also supports the use of an octet string representation of the key.</p>
<pre>
# create an octet string key
const  key  (afnix:sec:Key "0123456789ABCDEF")
assert true (afnix:sec:key-p key)
</pre>
<p><em>Symmetric key functions</em></p><p>The basic operation associated with a symmetric key is the byte extraction. The get-size method can be used to determine the byte key size. Once the key size has been obtained, the key byte can be accessed by index with the get-byte method.</p>
<pre>
# create a 256 random symmetric key
const key  (afnix:sec:Key afnix:sec:Key:KSYM 256)
# get the key size
const size (key:get-size)
# get the first byte
const byte (key:get-byte 0)
</pre>
<p><strong>Asymmetric cipher key</strong></p><p>An asymmetric cipher key can be generated for a particular asymmetric cipher, such like RSA. Generally, the key contains several components identified as the public and secret key components. These components are highly dependent on the cipher type. Under some circumstances, all components might not be available.</p><p><em>Creating an asymmetric cipher key</em></p><p>The Key class can be used to create a specific asymmetric cipher key. Generally, the key is created by type and and bits size.</p>
<pre>
# create a 1024 bits rsa key
const  key  (afnix:sec:Key afnix:sec:Key:KRSA 1024)
</pre>
<p>An asymmetric cipher key constructor is extremely dependent on the cipher type. For this reason, there is no constructor that can operate with a pass-phrase.</p><p><em>Asymmetric key functions</em></p><p>The basic operation associated with a asymmetric key is the relatif based representation which is generally available for all key components. For example, in the case of the RSA cipher, the modulus, the public and secret exponents can be obtained in a relatif number based representation with the help of the get-relatif-key method.</p>
<pre>
# create a 512 rsa key
const key  (afnix:sec:Key afnix:sec:Key:KRSA 512)
# get the key modulus
const kmod (
  key:get-relatif-key afnix:sec:Key:RSA-MODULUS)
# get the public exponent
const pexp (
  key:get-relatif-key afnix:sec:Key:RSA-PUBLIC-EXPONENT)
# get the secret exponent
const sexp (
  key:get-relatif-key afnix:sec:Key:RSA-SECRET-EXPONENT)
</pre>
<p><strong>Message authentication key</strong></p><p><em>Creating a message authentication key</em></p><p>The Key class can also be used to create a message authentication key suitable for a message authentication code generator or validator. By default a 128 bits random key is generated, but the key can be also generated from an octet string.</p>
<pre>
const  key  (afnix:sec:Key afnix:sec:Key:KMAC)
assert true (afnix:sec:key-p key)
</pre>
<p>The constructor also supports the use of an octet string as a key representation.</p>
<pre>
# create an octet string key
const key (
  afnix:sec:Key afnix:sec:Key:KMAC "0123456789ABCDEF")
assert true (afnix:sec:key-p key)
</pre>
<p><em>Message authentication key functions</em></p><p>The basic operation associated with a message authentication key is the byte extraction. The get-size method can be used to determine the byte key size. Once the key size has been obtained, the key byte can be accessed by index with the get-byte method.</p>
<pre>
# create a 256 random message authentication key
const key  (afnix:sec:Key afnix:sec:Key:KMAC 256)
# get the key size
const size (key:get-size)
# get the first byte
const byte (key:get-byte 0)
</pre>
<p><em>Signature key functions</em></p><p>The basic operation associated with a signature key is the relatif based representation which is generally available for all key components. For example, in the case of the DSA signer, the prime numbers, the public and secret components can be obtained in a relatif number based representation with the help of the get-relatif-key method.</p>
<pre>
# create a 1024 dsa key
const key  (afnix:sec:Key afnix:sec:Key:KDSA)
# get the key size
const size (key:get-size)
# get the secret component
const sexp (
  key:get-relatif-key afnix:sec:Key:DSA-SECRET-KEY)
</pre>
<p><strong>Stream cipher</strong></p><p>A stream cipher is an object that encodes an input stream into an output stream. The data are read from the input stream, encoded and transmitted onto the output stream. There are basically two types of stream ciphers known as symmetric cipher and asymmetric cipher.</p><p><em>Symmetric cipher</em></p><p>A symmetric cipher is a cipher that encodes and decode data with the same key. Normally, the key is kept secret, and the data are encoded by block. For this reason, symmetric cipher are also called block cipher. In normal mode, a symmetric cipher is created with key and the data are encoded from an input stream as long as they are available. The block size depends on the nature of the cipher. As of today, the recommended symmetric cipher is the Advanced Encryption Standard or AES, also known as Rijndael.</p><p><em>Asymmetric cipher</em></p><p>An asymmetric cipher is a cipher that encodes and decode data with two keys. Normally, the data are encoded with a public key and decoded with a private key. In this model, anybody can encode a data stream, but only one person can read them. Obviously, the model can be reverse to operate in a kind of signature mode, where only one person can encode the data stream and anybody can read them. Asymmetric cipher are particularly useful when operating on unsecured channels. In this model, one end can send its public key as a mean for other people to crypt data that can only be read by the sender who is supposed to have the private key. As of today, the recommended asymmetric ciphers are RSA and DH.</p><p><em>Serial cipher</em></p><p>A serial cipher is a cipher that encodes and decode data on a byte basis. Normally, the data are encoded and decoded with the same key, thus making the symmetric cipher key, the ideal candidate for a serial cipher key. Since the data is encoded on a byte basis, it can be used efficiently with a stream. However, the serial cipher does not define a block size and therefore require some mechanism to prevent a buffer overrun when reading bytes from a stream. For this reason, the serial cipher defines a default serial block size that can be used to buffer the stream data. A method is provided in the class to control the buffer size and is by default set to 4Kib bytes.</p><p><em>Cipher base class</em></p><p>The Cipher base class is an abstract class that supports the symmetric, asymmetric and serial cipher models. A cipher object has a name and is bound to a key that is used by the cipher. The class provides some base methods that can be used to retrieve some information about the cipher. The get-name method returns the cipher name. The set-key and get-key methods are both used to set or retrieve the cipher key. The cipher operating mode can be found with the get-reverse method. If the get-reverse method returns true, the cipher is operating in decoding mode. Note that a set-reverse method also exists.</p><p><strong>Block cipher</strong></p><p>A block cipher is an object that encodes an input stream with a symmetric cipher bound to a unique key. Since a block cipher is symmetric, the data can be coded and later decoded to their original form. The difference with the Cipher base class is that the BlockCipher class provides a get-block-size method which returns the cipher block size.</p><p><em>Block Cipher base</em></p><p>The BlockCipher class is a base class for the block cipher engine. The class implements the stream method that reads from an input stream and write into an output stream. The BlockCipher class is an abstract class and cannot be instantiated by itself. The object is actually created by using a cipher algorithm class such like the Aes class.</p>
<pre>
trans count (cipher:stream os is)
</pre>
<p>The stream method returns the number of characters that have been encoded. Care should be taken that most of the stream cipher operates by block and therefore, will block until a complete block has been read from the input stream, unless the end of stream is read. The block cipher is always associated with a padding scheme. By default, the NIST 800-38A recommendation is associated with the block cipher, but can be changed with the set-padding-mode.</p><p><em>Creating a block cipher</em></p><p>A BlockCipher object can be created with a cipher constructor. As of today, the Advanced Encryption Standard or AES is the recommended symmetric cipher. The Aes class creates a new block cipher that conforms to the AES standard.</p>
<pre>
const cipher (afnix:sec:Aes)
</pre>
<p>A block cipher can be created with a key and eventually a reverse flag. With one argument, the block cipher key is associated with the cipher. Such key can be created as indicated in the previous section. The reverse flag is used to determine if the cipher operate in encoding or decoding mode. By default, the cipher operates in coding mode.</p>
<pre>
# create a 256 bits random key
const key (afnix:sec:Key afnix:sec:KSYM 256)
# create an aes block cipher
const aes (afnix:sec:Aes key)
</pre>
<p><em>Block cipher information</em></p><p>The BlockCipher class is derived from the Cipher class and contains several methods that provide information about the cipher. This include the cipher block size with the get-block-size method.</p>
<pre>
println (aes:get-block-size)
</pre>
<p><strong>Input cipher</strong></p><p>In the presence of a Cipher object, it is difficult to read an input stream and encode the character of a block basis. Furthermore, the existence of various method for block padding makes the coding operation even more difficult. For this reason, the InputCipher class provides the necessary method to code or decode an input stream in various mode of operations.</p><p><em>Input cipher mode</em></p><p>The InputCipher class is an input stream that binds an input stream with a cipher. The class acts like an input stream, read the character from the bounded input stream and encode or decode them from the bended cipher. The InputCipher defines several modes of operations. In electronic codebook mode or ECB, the character are encoded in a block basis. In cipher block chaining mode, the block are encoded by doing an XOR operation with the previous block. Other modes are also available such like cipher feedback mode and output feedback mode.</p><p><em>Creating an input cipher</em></p><p>By default an input cipher is created with a cipher object. Eventually, an input stream and/or the input mode can be specified at the object construction.</p>
<pre>
# create a key
const key (afnix:sec:Key "hello world")
# create a direct cipher
const aes (afnix:sec:Aes key)
# create an input cipher
const ic (afnix:sec:InputCipher aes)
</pre>
<p>In this example, the input cipher is created in ECB mode. The input stream is later associated with the set-is method.</p><p><em>Input cipher operation</em></p><p>The InputCipher class operates with one or several input streams. The set-is method sets the input stream. Read operation can be made with the help of the valid-p predicate.</p>
<pre>
while (ic:valid-p) (os:write (ic:read))
</pre>
<p>Since the InputCipher operates like an input stream, the stream can be read as long as the valid-p predicate returns true. Note that the InputCipher manages automatically the padding operations with the mode associated with the block cipher.</p><p><strong>Asymmetric cipher</strong></p><p>A public cipher is an object that encodes an input stream with a asymmetric cipher bound to a public and secret key. In theory, there is no difference between a block cipher and a public cipher. Furthermore, the interface provided by the engine is the same for both objects.</p><p><em>Public cipher</em></p><p>A public cipher is an asymmetric stream cipher which operates with an asymmetric key. The main difference between a block cipher and a public cipher is the key nature as well as the encoded block size. With an asymmetric cipher, the size of the message to encode is generally not the same as the encoded block, because a message padding operation must occurs for each message block.</p>
<pre>
trans count (cipher:stream os is)
</pre>
<p>The stream method returns the number of characters that have been encoded. Like the block cipher, the stream method encodes an input stream or a buffer object. The number of encoded bytes is returned by the method.</p><p><em>Creating a public cipher</em></p><p>A PublicCipher object can be created with a cipher constructor. The RSA asymmetric cipher is the typical example of public cipher. It is created by binding a RSA key to it. For security reasons, the key size must be large enough, typically with a size of at lease 1024 bits.</p>
<pre>
const key (afnix:sec:Key afnix:sec:Key:KRSA 1024)
const rsa (afnix:sec:Rsa key)
</pre>
<p>A block cipher can be created with a key and eventually a reverse flag. Additional constructors are available to support various padding mode. Such padding mode depends on the cipher type. For example, the RSA cipher supports the ISO 18033-2 padding mode with a KDF1 or KDF2 object. Such constructor requires a hasher object as well.</p>
<pre>
# create a 1024 bits rsa key
const key (afnix:sec:Key afnix:sec:KRSA 1024)
# create a SHA-1 hasher
const ash (afnix:sec:Sha1)
# create a rsa public cipher
const rsa (afnix:sec:Rsa key ash "Demo")
# set the padding mode
rsa:set-padding-mode afnix:sec:Rsa:PAD-OAEP-K1
</pre>
<p><em>Public cipher padding mode</em></p><p>Like any cipher, a padding mode can be associated with the cipher. The set-padding-mode method can be used to set or change the padding mode. Depending on the padding mode type, additional objects might be needed at construction.</p><table class="table table-striped">
<tr>
<th>Cipher</th>
<th>Padding mode</th>
<th>Default</th></tr>

<tr>
<td>RSA</td>
<td>PKCS 1.5, PKCS 2.1, ISO/IEC 18033-2</td>
<td>PKCS 1.5</td></tr>
</table><p>The default padding mode depends on the cipher type. For RSA, the default padding mode is set to PKCS 1.5 for compatibility reason.</p><p><strong>Signature objects</strong></p><p>A digital signature is a unique representation, supposedly non forgeable, designed to authenticate a document, in whatever form it is represented. For example, a signature is used to sign a certificate which is used during the process of establish a secured connection over the Internet. A signature can also be used to sign a courrier or keys as it is in the Openssh protocol. Digital signatures come into several flavors eventually associated with the signed document. Sometimes, the signature acts as a container and permits to retrieve the document itself. Whatever the method, the principle remains the same. As of today technology, there are two standards used to sign document as indicated below.</p><table class="table table-striped">
<tr>
<th>Standard</th>
<th>Name</th></tr>

<tr>
<td>DSS</td>
<td>Digital Signature Standard</td></tr>

<tr>
<td>RSA</td>
<td>RSA based signature</td></tr>
</table><p><em>Signer and signature objects</em></p><p>The process of generating a signature is done with the help of a Signer object. A signer object is a generic object, similar in functionality to the hasher object. The result produced by a signer object is a Signature object which holds the generated signature.</p><p><em>Signature key</em></p><p>The process of generating a signature often requires the use of a key. Such key can be generated with the help of the Key object. The nature of the key will depend on the target signature. The following table is a resume of the supported keys.</p><table class="table table-striped">
<tr>
<th>Standard</th>
<th>Key</th>
<th>Signer</th></tr>

<tr>
<td>DSS</td>
<td>KDSA</td>
<td>Dsa</td></tr>
</table><p>In the case of DSS, a key can be generated automatically, although this process is time consuming. The default key size is 1024 bits.</p>
<pre>
const key (afnix:sec:Key afnix:sec:Key:KDSA)
assert 1024 (key:get-bits)
</pre>
<p><em>Creating a signer</em></p><p>A Signer object is created with a particular signature object such like DSA. The Dsa object is a signer object that implements the Digital Signature Algorithm as specified by the Digital Signature Standard (DSS) in FIPS-PUB 186-3.</p>
<pre>
# create a dsa signer
const dsa (afnix:sec:Dsa key)
assert true (afnix:sec:dsa-p dsa)
</pre>
<p><em>Creating a signature</em></p><p>A signature is created with the help of the compute method. The Signature object is similar to the Hasher and operates with string or streams.</p>
<pre>
# create a signature object
const sgn   (dsa:compute "afnix")
assert true (afnix:sec:signature-p sgn)
</pre>
<p>Once the signature is created, each data can be accessed directly with the associated component mapper. In the case of DSS, there are two components as show below.</p>
<pre>
# get the DSS S component
sgn:get-relatif-component
afnix:sec:Signature:DSA-S-COMPONENT
# get the DSS R component
sgn:get-relatif-component
afnix:sec:Signature:DSA-R-COMPONENT
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">STANDARD SECURITY REFERENCE</h2>
        <div class="sectioncontent">
<p><strong>Hasher</strong></p><p>The Hasher class is a base class that is used to build a message hash. The hash result is stored in an array of bytes and can be retrieved byte by byte or as a formatted printable string. This class does not have a constructor.</p><p><em>Predicate</em></p><p>hasher-p</p><p><em>Inheritance</em></p><p>Nameable</p><p><em>Methods</em></p><p><strong>reset -&gt; none (none)</strong></p><p>The reset method reset the hasher object with its associated internal states.</p><p><strong>hash-p -&gt; Boolean (String)</strong></p><p>The hash-p predicate returns true if the string argument is potentially a hash value. It is not possible, with our current technology, to reverse a hash value to one or several representations, nor it is possible to assert that such value exists.</p><p><strong>get-byte -&gt; Byte (Integer)</strong></p><p>The get-byte method returns the hash byte value by index. The argument is the byte index which must be in the range of the hash result length.</p><p><strong>format -&gt; String (none)</strong></p><p>The format method return a string representation of the hash value.</p><p><strong>compute -&gt; String (Literal|Buffer|InputStream)</strong></p><p>The compute method computes the hash value from a string, a buffer or an input stream. The method returns a string representation of the result hash value. When the argument is a buffer object or an input stream, the characters are consumed from the object.</p><p><strong>derive -&gt; String (String)</strong></p><p>The derive method computes the hash value from an octet string which is converted before the hash computation. The method returns a string representation of the result hash value.</p><p><strong>get-hash-length -&gt; Integer (none)</strong></p><p>The get-hash-length method returns the hasher length in bytes.</p><p><strong>get-result-length -&gt; Integer (none)</strong></p><p>The get-result-length method returns the hasher result length in bytes. The result length is less or equal to the hasher length and is set at construction.</p><p><strong>Md2</strong></p><p>The Md2 class is a hashing class that implements the MD-2 algorithm.</p><p><em>Predicate</em></p><p>md2-p</p><p><em>Inheritance</em></p><p>Hasher</p><p><em>Constructors</em></p><p><strong>Md2 (none)</strong></p><p>The Md2 constructor creates a default hashing object that implements the MD-2 algorithm.</p><p><strong>Md2 (Integer)</strong></p><p>The Md2 constructor creates a MD-2 hashing object with a result length. The argument is the hasher result length that must be less or equal to the hasher length.</p><p><strong>Md4</strong></p><p>The Md4 class is a hashing class that implements the MD-4 algorithm.</p><p><em>Predicate</em></p><p>md4-p</p><p><em>Inheritance</em></p><p>Hasher</p><p><em>Constructors</em></p><p><strong>Md4 (none)</strong></p><p>The Md4 constructor creates a default hashing object that implements the MD-4 algorithm.</p><p><strong>Md4 (Integer)</strong></p><p>The Md4 constructor creates a MD-4 hashing object with a result length. The argument is the hasher result length that must be less or equal to the hasher length.</p><p><strong>Md5</strong></p><p>The Md5 class is a hashing class that implements the MD-5 algorithm.</p><p><em>Predicate</em></p><p>md5-p</p><p><em>Inheritance</em></p><p>Hasher</p><p><em>Constructors</em></p><p><strong>Md5 (none)</strong></p><p>The Md5 constructor creates a default hashing object that implements the MD-5 algorithm.</p><p><strong>Md5 (Integer)</strong></p><p>The Md5 constructor creates a MD-5 hashing object with a result length. The argument is the hasher result length that must be less or equal to the hasher length.</p><p><strong>Sha1</strong></p><p>The Sha1 class is a hashing class that implements the SHA-1 algorithm.</p><p><em>Predicate</em></p><p>sha1-p</p><p><em>Inheritance</em></p><p>Hasher</p><p><em>Constructors</em></p><p><strong>Sha1 (none)</strong></p><p>The Sha1 constructor creates a default hashing object that implements the SHA-1 algorithm.</p><p><strong>Sha1 (Integer)</strong></p><p>The Sha1 constructor creates a SHA-1 hashing object with a result length. The argument is the hasher result length that must be less or equal to the hasher length.</p><p><strong>Sha224</strong></p><p>The Sha224 class is a hashing class that implements the SHA-224 algorithm.</p><p><em>Predicate</em></p><p>sha224-p</p><p><em>Inheritance</em></p><p>Hasher</p><p><em>Constructors</em></p><p><strong>Sha224 (none)</strong></p><p>The Sha224 constructor creates a default hashing object that implements the SHA-224 algorithm.</p><p><strong>Sha224 (Integer)</strong></p><p>The Sha224 constructor creates a SHA-224 hashing object with a result length. The argument is the hasher result length that must be less or equal to the hasher length.</p><p><strong>Sha256</strong></p><p>The Sha256 class is a hashing class that implements the SHA-256 algorithm.</p><p><em>Predicate</em></p><p>sha256-p</p><p><em>Inheritance</em></p><p>Hasher</p><p><em>Constructors</em></p><p><strong>Sha256 (none)</strong></p><p>The Sha256 constructor creates a default hashing object that implements the SHA-256 algorithm.</p><p><strong>Sha256 (Integer)</strong></p><p>The Sha256 constructor creates a SHA-256 hashing object with a result length. The argument is the hasher result length that must be less or equal to the hasher length.</p><p><strong>Sha384</strong></p><p>The Sha384 class is a hashing class that implements the SHA-384 algorithm.</p><p><em>Predicate</em></p><p>sha384-p</p><p><em>Inheritance</em></p><p>Hasher</p><p><em>Constructors</em></p><p><strong>Sha384 (none)</strong></p><p>The Sha384 constructor creates a default hashing object that implements the SHA-384 algorithm.</p><p><strong>Sha384 (Integer)</strong></p><p>The Sha384 constructor creates a SHA-384 hashing object with a result length. The argument is the hasher result length that must be less or equal to the hasher length.</p><p><strong>Sha512</strong></p><p>The Sha512 class is a hashing class that implements the SHA-512 algorithm.</p><p><em>Predicate</em></p><p>sha512-p</p><p><em>Inheritance</em></p><p>Hasher</p><p><em>Constructors</em></p><p><strong>Sha512 (none)</strong></p><p>The Sha512 constructor creates a default hashing object that implements the SHA-512 algorithm.</p><p><strong>Sha512 (Integer)</strong></p><p>The Sha512 constructor creates a SHA-512 hashing object with a result length. The argument is the hasher result length that must be less or equal to the hasher length.</p><p><strong>Key</strong></p><p>The Key class is an original class used to store a particular key or to generate one. A key is designed to operate with a variety of cipher that can be either symmetric or asymmetric. In the symmetric case, the key is generally an array of bytes. Asymmetric key are generally stored in the form of number list that can be computed or loaded by value. By default, a random 128 bit symmetric key is created.</p><p><em>Predicate</em></p><p>key-p</p><p><em>Inheritance</em></p><p>Object</p><p><em>Constructors</em></p><p><strong>Key (none)</strong></p><p>The Key constructor creates a default cipher key. The key is generated with random bytes and is 128 bits long.</p><p><strong>Key (String)</strong></p><p>The Key constructor creates a symmetric key from an octet string. The octet string argument determines the size of the key. The octet string argument is compatible with the string obtained from the format method.</p><p><strong>Key (Item)</strong></p><p>The Key constructor creates a key by type. If the key type is KSYM, a symmetric 128 bytes random key is generated. If the key type is KRSA, a 1024 bits RSA random key is generated.</p><p><strong>Key (Item Integer|String|Vector)</strong></p><p>The Key constructor creates a key by type. The first argument is the key type to generate. The second argument is either the key size, the key octet string or the key byte values. In the first form, an integer argument specifies the key size in bytes or bits depending on the key nature. In the second form, a string is used as octet string to represent the key. In the third form, a vector of byte values can be used to load the key.</p><p><em>Constants</em></p><p><strong>KSYM</strong></p><p>The KSYM constant indicates that the key is a symmetric key.</p><p><strong>KRSA</strong></p><p>The KRSA constant indicates that the key is a asymmetric RSA key.</p><p><strong>KMAC</strong></p><p>The KMAC constant indicates that the key is a message authentication (MAC) key.</p><p><strong>RSA-MODULUS</strong></p><p>The RSA-MODULUS constant corresponds to the RSA modulus value.</p><p><strong>RSA-PUBLIC-EXPONENT</strong></p><p>The RSA-PUBLIC-EXPONENT constant corresponds to the RSA public exponent value which is generally 65537.</p><p><strong>RSA-SECRET-EXPONENT</strong></p><p>The RSA-SECRET-EXPONENT constant corresponds to the RSA secret exponent value.</p><p><em>Methods</em></p><p><strong>get-byte -&gt; Byte (Integer)</strong></p><p>The get-byte method returns a key byte value by index. The index must be in the key range or an exception is raised. This method is primarily used with symmetric key.</p><p><strong>get-type -&gt; Item (none)</strong></p><p>The get-type method returns the key type in the form of an item object.</p><p><strong>get-bits -&gt; Integer (none)</strong></p><p>The get-bits method returns the key size in bits.</p><p><strong>get-size -&gt; Integer (none)</strong></p><p>The get-size method returns the key size in bytes.</p><p><strong>format -&gt; String (none|Item)</strong></p><p>The format method returns a string representation of the key. In the first form, without argument, the key is returned as an octet string if possible. In the second form, the key value is returned as an octet string based on the key element to access.</p><p><strong>get-relatif-key -&gt; Relatif (Item)</strong></p><p>The get-relatif-key method returns a relatif representation of a key element. This method is well suited for asymmetric key. The key value is returned as a relatif based on the key element to access.</p><p><strong>Kdf</strong></p><p>The Kdf class is an abstract class used to model key derivation function. The class provides only a byte buffer which can be accessed by index. In the key derivation functions land, there are numerous standards, such like PKCS 2.1, IEEE P1363-2000, ISO/IEC 18033-2. All of these standards have sometimes conflicting definitions.</p><p><em>Predicate</em></p><p>kdf-p</p><p><em>Inheritance</em></p><p>Nameable</p><p><em>Methods</em></p><p><strong>reset -&gt; none (none)</strong></p><p>The reset method reset the internal state of the kdf object.</p><p><strong>get-size -&gt; Integer (none)</strong></p><p>The get-size method returns the kdf size in bytes.</p><p><strong>get-byte -&gt; Byte (Integer)</strong></p><p>The get-byte method returns a kdf byte value by index. The index must be in the key range or an exception is raised.</p><p><strong>format -&gt; String (none)</strong></p><p>The format method returns a string representation of the derived key.</p><p><strong>derive -&gt; String (String)</strong></p><p>The derive method returns a string representation of a derived key computed from the octet string argument.</p><p><strong>compute -&gt; String (String)</strong></p><p>The compute method returns a string representation of a derived key computed from the string argument.</p><p><strong>Hkdf</strong></p><p>The Hkdf class is an abstract class used to model key derivation function based on hash function. The class maintains a hasher object that is used to derive the key from an octet string.</p><p><em>Predicate</em></p><p>hashed-kdf-p</p><p><em>Inheritance</em></p><p>Kdf</p><p><em>Methods</em></p><p><strong>get-hasher -&gt; none (none)</strong></p><p>The get-hasher method returns the hasher object associated with the key derivation function object. object.</p><p><strong>Kdf1</strong></p><p>The Kdf1 class is a hashed key derivation function class that implements the KDF1 specification as defined by ISO/IEC 18033-2. The class is strictly equivalent to the mask generation function (MGF1) defined in PKCS 2.1. On the other hand, this implementation does not conform to the KDF1 specification of IEEE 1363-2000 which is somehow rather bizarre. The class operates in theory with any type of hasher object as long as the octet string is not too long.</p><p><em>Predicate</em></p><p>kdf1-p</p><p><em>Inheritance</em></p><p>Hkdf</p><p><em>Constructors</em></p><p><strong>Kdf1 (Hasher Integer)</strong></p><p>The Kdf1 constructor creates a KDF1 key derivation function object. The first argument is the hasher object to bind and the second argument is the kdf size.</p><p><strong>Kdf2</strong></p><p>The Kdf2 class is a hashed key derivation function class that implements the KDF2 specification as defined by ISO/IEC 18033-2. The class is strictly equivalent to the key function derivation (KDF1) except that the internal counter runs from 1 to k instead of 0 to k-1. The class operates in theory with any type of hasher object as long as the octet string is not too long.</p><p><em>Predicate</em></p><p>kdf2-p</p><p><em>Inheritance</em></p><p>Hkdf</p><p><em>Constructors</em></p><p><strong>Kdf2 (Hasher Integer)</strong></p><p>The Kdf2 constructor creates a KDF2 key derivation function object. The first argument is the hasher object to bind and the second argument is the kdf size.</p><p><strong>Cipher</strong></p><p>The Cipher class is a base class that is used to implement a cipher. A cipher is used to encrypt or decrypt a message. There are basically two types of ciphers, namely symmetric cipher and asymmetric cipher. For the base class operation, only the cipher name and key is needed. A reverse flag controls whether or not an encryption operation must be reversed. A reset method can also be used to reset the internal cipher state.</p><p><em>Predicate</em></p><p>cipher-p</p><p><em>Inheritance</em></p><p>Nameable</p><p><em>Methods</em></p><p><strong>reset -&gt; none (none)</strong></p><p>The reset method reset the cipher internal state.</p><p><strong>stream -&gt; Integer (OutputStream InputStream)</strong></p><p>The stream method process an input stream and write into an output stream. The method returns the number of character processed. The first argument is the output stream used to write the coded characters. The second argument is the input stream used to read the characters.</p><p><strong>set-key -&gt; none (Key)</strong></p><p>The set-key method sets the cipher key. The first argument is the key to set.</p><p><strong>get-key -&gt; Key (none)</strong></p><p>The get-key method returns the cipher key.</p><p><strong>set-reverse -&gt; none (Boolean)</strong></p><p>The set-reverse method sets the cipher reverse flag. The first argument is the flag to set. If the flag is true, the cipher operates in reverse mode. If the flag is false, the cipher operates in direct mode.</p><p><strong>get-reverse -&gt; Boolean (none)</strong></p><p>The get-reverse method returns the cipher reverse flag. If the flag is true, the cipher operates in reverse mode. If the flag is false, the cipher operates in direct mode.</p><p><strong>BlockCipher</strong></p><p>The BlockCipher class is an abstract class that is used to implement a symmetric block cipher. By default the cipher operates in encryption mode. When the reverse flag is set, the decryption mode is activated. For a block cipher, a block size controls the cipher operations. The class also defines the constants that control the block padding with the associated methods.</p><p><em>Predicate</em></p><p>block-cipher-p</p><p><em>Inheritance</em></p><p>Cipher</p><p><em>Constants</em></p><p><strong>PAD-NONE</strong></p><p>The PAD-NONE constant indicates that the block should not be padded.</p><p><strong>PAD-BIT-MODE</strong></p><p>The PAD-BIT constant indicates that the block should be padded in bit mode.</p><p><strong>PAD-ANSI-X923</strong></p><p>The PAD-ANSI-X923 constant indicates that the block should be padded according to ANSI X 923 standard.</p><p><strong>PAD-NIST-800</strong></p><p>The PAD-NIST-800 constant indicates that the block should be padded according to NIST 800-38A recommendations. This is the default mode.</p><p><em>Methods</em></p><p><strong>get-block-size -&gt; Integer (none)</strong></p><p>The get-block-size method returns the cipher block size.</p><p><strong>set-padding-mode -&gt; none (Item)</strong></p><p>The set-padding-mode method sets the cipher padding mode.</p><p><strong>get-padding-mode -&gt; Item (none)</strong></p><p>The get-padding-mode method returns the cipher padding mode.</p><p><strong>InputCipher</strong></p><p>The InputCipher class is an stream interface that can stream out an input stream from a cipher. In other word, an input stream is read and block are encoded as long as the input stream read characters. If the cipher is nil, the input cipher simply read the input stream and is therefore transparent. The class acts like an input stream, read the character from the bounded input stream and encode or decode them from the bounded cipher. The InputCipher defines several modes of operations. In electronic codebook mode or ECB, the character are encoded in a block basis. In cipher block chaining mode, the block are encoded by doing an XOR operation with the previous block. Other modes such like cipher feedback mode and output feedback mode are also defined.</p><p><em>Predicate</em></p><p>input-cipher-p</p><p><em>Inheritance</em></p><p>Input</p><p><em>Constructors</em></p><p><strong>InputCipher (Cipher)</strong></p><p>The InputCipher constructor creates an input cipher with a cipher object. The first argument is the cipher to used for processing.</p><p><strong>InputCipher (Cipher Input)</strong></p><p>The InputCipher constructor creates an input cipher with a cipher object and an input stream. The first argument is the cipher to used for processing. The second argument is the input stream object used for the character reading.</p><p><strong>InputCipher (Cipher InputStream Item)</strong></p><p>The InputCipher constructor creates an input cipher with a cipher object, an input stream and a mode. The first argument is the cipher to used for processing. The second argument is the input stream object used for the character reading. The third argument is the input cipher mode which can be either ECB, CBC, CFB or OFB.</p><p><em>Constants</em></p><p><strong>ECB</strong></p><p>The ECB constant indicates that the input cipher is to operate in electronic codebook mode. This mode is the default mode.</p><p><strong>CBC</strong></p><p>The CBC constant indicates that the input cipher is to operate in cipher chaining block mode.</p><p><strong>CFB</strong></p><p>The CFB constant indicates that the input cipher is to operate in cipher feedback block mode.</p><p><strong>OFB</strong></p><p>The OFB constant indicates that the input cipher is to operate in output feedback block mode.</p><p><em>Methods</em></p><p><strong>reset -&gt; none (none)</strong></p><p>The reset method reset the input cipher object.</p><p><strong>get-mode -&gt; Item (none)</strong></p><p>The get-mode method returns the input cipher operating mode.</p><p><strong>set-iv -&gt; none (String|Buffer)</strong></p><p>The set-iv method sets the input cipher initial vector. In the first form, the initial vector is set from an octet string. In the second form, the initial vector is set from a buffer object.</p><p><strong>get-iv -&gt; String (none)</strong></p><p>The get-iv method returns the input cipher initial vector as an octet string.</p><p><strong>set-is -&gt; none (InputStream)</strong></p><p>The set-is method sets the input cipher input stream. This method can be used to chain multiple input streams in a unique coding session.</p><p><strong>Aes</strong></p><p>The Aes class is a block cipher class that implements the advanced encryption standard (AES), originally known as Rijndael. This is an original implementation that conforms to the standard FIPS PUB 197. It should be noted that the AES standard, unlike Rijndael, defines a fixed block size of 16 bytes (4 words) and 3 keys sizes (128, 192, 256).</p><p><em>Predicate</em></p><p>aes-p</p><p><em>Inheritance</em></p><p>BlockCipher</p><p><em>Constructors</em></p><p><strong>Aes (Key)</strong></p><p>The Aes constructor creates a direct cipher with a key. The first argument is the key used by the cipher.</p><p><strong>Aes (Key Boolean)</strong></p><p>The Aes constructor creates a cipher with a key and a reverse flag. The first argument is the key used by the cipher. The second argument is the reverse flag.</p><p><strong>PublicCipher</strong></p><p>The PublicCipher class is an abstract class that is used to implement an asymmetric cipher. An asymmetric cipher or public key cipher is designed to operate with a public key and a secret key. Depending on the use model, the public key might be used to crypt the data, and the secret key to decrypt. The basic assumption around a public cipher is that the secret key cannot be derived from the public key.</p><p><em>Predicate</em></p><p>public-cipher-p</p><p><em>Inheritance</em></p><p>Cipher</p><p><em>Methods</em></p><p><strong>get-message-size -&gt; Integer (none)</strong></p><p>The get-message-size method returns the cipher message size.</p><p><strong>get-crypted-size -&gt; Integer (none)</strong></p><p>The get-crypted-size method returns the cipher crypted block size.</p><p><strong>Rsa</strong></p><p>The Rsa class is a public cipher class that implements the RSA algorithm as described by PKCS 2.1, RFC 2437 and ISO 18033-2. The class implements also some padding mechanism described in PKCS 1.5, 2.1 and ISO 18033-2. The RSA algorithm is a public cryptographic cipher based on a secret and public keys. The class operates in crypting mode by default and uses the public key to do the encryption while the secret key is used in reverse (decryption) mode. By default, the PKCS 1.5 type 2 padding is used. The ISO RSA-REM1 padding with a key derivation function (KDF1) is equivalent to PKCS 2.1 padding with the mask generation function (MGF1). The ISO RSA-REM1 padding with KDF2 is not described in the PKCS 2.1.</p><p><em>Predicate</em></p><p>rsa-p</p><p><em>Inheritance</em></p><p>PublicCipher</p><p><em>Constructors</em></p><p><strong>Rsa (none)</strong></p><p>The Rsa constructor creates a default RSA public cipher by binding a 1024 bits random key.</p><p><strong>Rsa (Key)</strong></p><p>The Rsa constructor creates a RSA public cipher by binding the key argument.</p><p><strong>Rsa (Key Boolean)</strong></p><p>The Rsa constructor creates a RSA public cipher by binding the key argument and the reverse flag. The first argument is the key to bind. The second argument is the reverse flag to set.</p><p><strong>Rsa (Key Hasher String)</strong></p><p>The Rsa constructor creates a RSA public cipher by binding the key argument and OAEP padding objects. The first argument is the key to bind. The second argument is hasher object to use with the OAEP padding mode. The third argument is an optional label to be used by the KDF object.</p><p><em>Constants</em></p><p><strong>PAD-PKCS-11</strong></p><p>The PAD-PKCS-11 constant indicates that the PKCS 1.5 type 1 block should be used to pad the message.</p><p><strong>PAD-PKCS-12</strong></p><p>The PAD-PKCS-12 constant indicates that the PKCS 1.5 type 3 block should be used to pad the message.</p><p><strong>PAD-OAEP-K1</strong></p><p>The PAD-OAEP-K1 constant indicates that the ISO/IEC 18033-2 OAEP with KDF1 should be used to pad the message.</p><p><strong>PAD-OAEP-K2</strong></p><p>The PAD-OAEP-K2 constant indicates that the ISO/IEC 18033-2 OAEP with KDF2 should be used to pad the message.</p><p><em>Methods</em></p><p><strong>get-hasher -&gt; Hasher (none)</strong></p><p>The get-hasher method returns the hasher object used by the OAEP padding mode.</p><p><strong>set-hasher -&gt; none (Hasher)</strong></p><p>The set-hasher method sets the hasher object used by the OAEP padding mode.</p><p><strong>get-padding-mode -&gt; Item (none)</strong></p><p>The get-padding-mode method returns the cipher padding mode.</p><p><strong>set-padding-mode -&gt; none (Item)</strong></p><p>The set-padding-mode method sets the cipher padding mode.</p><p><strong>get-padding-label -&gt; String (none)</strong></p><p>The get-padding-label method returns the cipher padding label.</p><p><strong>set-padding-label -&gt; none (String)</strong></p><p>The set-padding-mode method sets the cipher padding label.</p><p><strong>get-padding-seed -&gt; String (none)</strong></p><p>The get-padding-seed method returns the cipher padding seed.</p><p><strong>set-padding-seed -&gt; none (String)</strong></p><p>The set-padding-seed method sets the cipher padding seed.</p><p><strong>pkcs-primitive -&gt; Relatif (Integer|Relatif)</strong></p><p>The pkcs-primitive method compute a relatif value from a relatif argument by either crypting or decrypting the argument. seed.</p><p><strong>Signer</strong></p><p>The Signer class is a base class that is used to build a message signature. The signature result is stored in a special signature object which is algorithm dependent.</p><p><em>Predicate</em></p><p>signer-p</p><p><em>Inheritance</em></p><p>Nameable</p><p><em>Methods</em></p><p><strong>reset -&gt; none (none)</strong></p><p>The reset method reset the signer object with its associated internal states.</p><p><strong>compute -&gt; Signature (Literal|Buffer|InputStream)</strong></p><p>The compute method computes the signature from a string, a buffer or an input stream. The method returns a signature object. When the argument is a buffer object or an input stream, the characters are consumed from the object.</p><p><strong>derive -&gt; Signature (String)</strong></p><p>The derive method computes the signature from an octet string which is converted before the signature computation. The method returns a signature object.</p><p><strong>Signature</strong></p><p>The Signature class is a container class designed to store a message signature. The signature object is produced by a signing process, implemented in the form of a digital signature algorithm such like RSA or DSA.</p><p><em>Predicate</em></p><p>signature-p</p><p><em>Inheritance</em></p><p>Object</p><p><em>Constructors</em></p><p><strong>Signature (none)</strong></p><p>The Signature constructor creates an empty signature.</p><p><em>Constants</em></p><p><strong>NIL</strong></p><p>The NIL constant indicates that the signature is a null signature.</p><p><strong>DSA</strong></p><p>The DSA constant indicates that the signature is conforming to DSS.</p><p><strong>DSA-S-COMPONENT</strong></p><p>The DSA-S-COMPONENT constant corresponds to the DSA S component value.</p><p><strong>DSA-R-COMPONENT</strong></p><p>The DSA-R-COMPONENT constant corresponds to the DSA R component value.</p><p><em>Methods</em></p><p><strong>reset -&gt; none (none)</strong></p><p>The reset method reset the signature object to a null signature.</p><p><strong>format -&gt; String (Item)</strong></p><p>The format method returns a string representation of the signature component. The signature component is returned as an octet string based on the signature component to access.</p><p><strong>get-relatif-component -&gt; Relatif (Item)</strong></p><p>The get-relatif-component method returns a relatif representation of a signature component.</p><p><strong>Dsa</strong></p><p>The Dsa class is an original implementation of the Digital Signature Standard (DSS) as published in FIPS PUB 186-3. This class implements the Digital Signature Algorithm (DSA) with an approved key length of 1024, 2048 and 3072 bits with a 160, 224 and 256 bits hash function which is part of the SHA family.</p><p><em>Predicate</em></p><p>dsa-p</p><p><em>Inheritance</em></p><p>Signer</p><p><em>Constructors</em></p><p><strong>Dsa (none)</strong></p><p>The Dsa constructor creates a signer object with a default DSA key.</p><p><strong>Dsa (Key)</strong></p><p>The Dsa constructor creates a signer object with a DSA key as its argument.</p><p><strong>Dsa (Key Relatif)</strong></p><p>The Dsa constructor creates a signer object with a DSA key as its first argument and a fixed k argument as specified by DSS.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="afnix-nwg.3.html"><span aria-hidden="true">&larr;</span> afnix-nwg.3: Standard network working group module</a></li>
   <li class="next"><a href="afnix-sio.3.html">afnix-sio.3: Standard input/output module <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

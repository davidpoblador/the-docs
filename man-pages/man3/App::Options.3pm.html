<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>App::Options: Combine command line options, environment vars, and option file values (for program configuration)</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Combine command line options, environment vars, and option file values (for program configuration)">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="App::Options (3pm) manual">
  <meta name="twitter:description" content="Combine command line options, environment vars, and option file values (for program configuration)">
  <meta name="twitter:image" content="https://www.carta.tech/images/libapp-options-perl-App::Options-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/App::Options.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="App::Options (3pm) manual" />
  <meta property="og:description" content="Combine command line options, environment vars, and option file values (for program configuration)" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libapp-options-perl-App::Options-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">App::Options<small> (3pm)</small></h1>
        <p class="lead">Combine command line options, environment vars, and option file values (for program configuration)</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/App::Options.3pm.html">
      <span itemprop="name">App::Options: Combine command line options, environment vars, and option file values (for program configuration)</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libapp-options-perl/">
      <span itemprop="name">libapp-options-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/App::Options.3pm.html">
      <span itemprop="name">App::Options: Combine command line options, environment vars, and option file values (for program configuration)</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
    #!/usr/bin/perl -w
    use strict;

    use App::Options;   # reads option values into %App::options by default

    # do something with the options (in %App::options)
    use DBI;
    $dsn = "dbi:mysql:database=$App::options{dbname}";
    $dbh = DBI-&gt;connect($dsn, $App::options{dbuser}, $App::options{dbpass});
    ...

  Get help from the command line (assuming program is named "prog") ...

    prog -?
    prog --help

  Option values may be provided on the command line, in environment
  variables, and option files.  (i.e. $ENV{APP_DBNAME} would set
  the value of %App::options{dbname} by default.)

  The "dbname" and other options could also be set in one of the
  following configuration files

    /etc/app/policy.conf
    $HOME/.app/prog.conf
    $HOME/.app/app.conf
    $PROGDIR/prog.conf
    $PROGDIR/app.conf
    $PREFIX/etc/app/prog.conf
    $PREFIX/etc/app/app.conf
    /etc/app/app.conf

  with a file format like

    [prog]
    dbname = prod
    dbuser = scott
    dbpass = tiger

  See below for a more detailed explanation of these and other
  advanced features.
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>App::Options combines command-line arguments, environment variables, option files, and program defaults to produce a hash of option values.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATION TO OTHER CONFIGURATION/OPTION PARSING MODULES</h2>
        <div class="sectioncontent">
<p>A number of modules are posted on \s-1CPAN\s0 which do command-line processing.</p><p> http://search.cpan.org/modlist/Option_Parameter_Config_Processing</p><p>App::Options is different than most of the Getopt::* modules because it integrates the processing of command line options, environment variables, and config files.</p><p>Furthermore, its special treatment of the \*(L"perlinc\*(R" option facilitates the inclusion (\*(L"use\*(R") of application-specific perl modules from special places to enable the installation of multiple versions of an application on the same system (i.e. /usr/myproduct/version).</p><p>The description of the AppConfig distribution sounds similar to what is described here.  However, the following are some key differences.</p><p> * App::Options does its option processing in the BEGIN block.    This allows for the @INC variable to be modified in time    for subsequent "use" and "require" statements.</p><p> * App::Options "sections" (i.e. "[cleanup]") are conditional.    It is conditional in App::Options, allowing you to use one    set of option files to configure an entire suite of programs    and scripts.  In AppConfig, the section name is simply a    prefix which gets prepended to subsequest option names.</p><p> * App::Options consults a cascading set of option files.    These files include those which are system global, project    global, and user private.  This allows for system    administrators, project developers, and individual    users to all have complementary roles in defining    the configuration values.</p><p> * App::Options is not a toolkit but a standardized way of    doing option processing.  With AppConfig, you still have    to decide where to put config files, and you still have to    code the "--help" feature.  With App::Options, you simply    "use App::Options;" and all the hard work is done.    Advanced options can be added later as necessary as args    to the "use App::Options;" statement.</p><p>App::Options is also the easiest command-line processing system that I have found anywhere. It then provides a smooth transition to more advanced features only as they are needed.  Every single quick and dirty script I ever write from now on can afford to use App::Options.</p><p>The documentation of App::Options takes three forms below.</p><p>  API Reference - describing the API (methods, args)   Logic Flow - describing the order and logic of processing   Usage Tutorial - describing how to use the API in practical situations</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATION TO THE P5EE PROJECT</h2>
        <div class="sectioncontent">
<p>App::Options was motivated by and supports the P5EE/App-Context variant of the Perl 5 Enterprise Environment (P5EE).  However, App::Options has no dependency on any other module in the P5EE project, and it is very useful without any knowledge or use of other elements of the P5EE project.</p><p>See the P5EE web sites for more information on the P5EE project.</p><p>    http://www.officevision.com/pub/p5ee/index.html</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">API REFERENCE: Methods</h2>
        <div class="sectioncontent">
<h3>\fIinit()\fP</h3>
<p>    * Signature: App::Options-&gt;init();     * Signature: App::Options-&gt;init(%named);     * Signature: App::Options-&gt;init($myvalues);     * Signature: App::Options-&gt;init($myvalues, %named);      (NOTE: %named represents a list of name/value pairs used as named args.             Params listed below without a $ are named args.)     * Param:  $myvalues     HASH               specify a hash reference other than %App::options to put               configuration values in.     * Param:  values        HASH               specify a hash reference other than %App::options to put               configuration values in.     * Param:  options       ARRAY               specify a limited, ordered list of options to be displayed               when the "--help" or "-?" options are invoked     * Param:  option        HASH               specify additional attributes of any of               the various options to the program (see below)     * Param:  no_cmd_args               do not process command line arguments     * Param:  no_env_vars               do not read environment variables     * Param:  no_option_file               do not read in the option file(s)     * Param:  print_usage               provide an alternate print_usage() function     * Return: void     * Throws: "App::Options-&gt;init(): must have an even number of vars/values for named args"     * Throws: "App::Options-&gt;init(): &apos;values&apos; arg must be a hash reference"     * Throws: "App::Options-&gt;init(): &apos;option&apos; arg must be a hash reference"     * Throws: "App::Options-&gt;init(): &apos;options&apos; arg must be an array reference"     * Since:  0.60</p><p>    Sample Usage: (normal)</p><p>    use App::Options;       # invokes init() automatically via import()</p><p>    This is functionally equivalent to the following, but that&apos;s not     near as nice to write at the top of your programs.</p><p>    BEGIN {         use App::Options qw(:none); # import() does not call init()         App::Options-&gt;init();       # we call init() manually     }</p><p>    Or we could have used a more full-featured version ...</p><p>    use App::Options (         values =&gt; &#92;%MyPackage::options,         options =&gt; [ "option_file", "prefix", "app",                      "perlinc", "debug_options", "import", ],         option =&gt; {             option_file   =&gt; { default =&gt; "~/.app/app.conf" },         # set default             app           =&gt; { default =&gt; "app", type =&gt; "string" }, # default & type             prefix        =&gt; { type =&gt; "string", required =&gt; 1; env =&gt; "PREFIX" },             perlinc       =&gt; undef,         # no default             debug_options =&gt; { type =&gt; "int" },             import        =&gt; { type =&gt; "string" },             flush_imports =&gt; 1,         },         no_cmd_args =&gt; 1,         no_env_vars =&gt; 1,         no_option_file =&gt; 1,         print_usage =&gt; sub { my ($values, $init_args) = @_; print "Use it right!&#92;n"; },     );</p><p>The <em>init()</em> method is usually called during the <em>import()</em> operation when the normal usage (\*(L"use App::Options;\*(R") is invoked.</p><p>The <em>init()</em> method reads the command line args (@ARGV), then finds an options file, and loads it, all in a way which can be done in a \s-1BEGIN\s0 block (minimal dependencies).  This is important to be able to modify the @INC array so that normal \*(L"use\*(R" and \*(L"require\*(R" statements will work with the configured @INC path.</p><p>The following named arguments are understood by the <em>init()</em> method.</p><p>    values - specify a hash reference other than %App::options to              put option values in.     options - specify a limited, ordered list of options to be               displayed when the "--help" or "-?" options are invoked     option - specify optional additional information about any of              the various options to the program (see below)     no_cmd_args - do not process command line arguments     no_env_vars - do not read environment variables     no_option_file - do not read in the option file     show_all - force showing all options in "--help" even when              "options" list specified     print_usage - provide an alternate print_usage() function     args_description - provide descriptive text for what the args              of the program are (command line args after the options).              This is printed in the usage page (--help or -?).              By default, it is simply "[args]".</p><p>The additional information that can be specified about any individual option variable using the \*(L"option\*(R" arg above is as follows.</p><p>    default - the default value if none supplied on the command         line, in an environment variable, or in an option file     required - the program will not run unless a value is provided         for this option     type - if a value is provided, the program will not run unless         the value matches the type ("string", "integer", "float",         "boolean", "date", "time", "datetime", "/regexp/").     env - a list of semicolon-separated environment variable names         to be used to find the value instead of "APP_{VARNAME}".     description - printed next to the option in the "usage" page     secure - identifies an option as being "secure" (i.e. a password)         and that it should never be printed in plain text in a help         message (-?).  All options which end in "pass", "passwd", or         "password" are also assumed to be secure unless a secure =&gt; 0         setting exists. If the value of the "secure" attribute is greater         than 1, a heightened security level is enforced: 2=ensure that         the value can never be supplied on a command line or from the         environment but only from a file that only the user running the         program has read/write access to.  This value will also never be         read from the environment or the command line because these are         visible to other users.  If the security_policy_level variable         is set, any true value for the "secure" attribute will result in         the value being set to the "security_policy_level" value.     value_description - printed within angle brackets ("&lt;&gt;") in the         "usage" page as the description of the option value         (i.e. --option_name=&lt;value_description&gt;)</p><p>The <em>init()</em> method stores command line options and option file values all in the global %App::options hash (unless the \*(L"values\*(R" argument specifies another reference to a hash to use).</p><p>The special options are as follows.</p><p>    option_file - specifies the exact file name of the option file to be        used (i.e. "app --option_file=/path/to/app.conf").</p><p>    app - specifies the tag that will be used when searching for        an option file. (i.e. "app --app=myapp" will search for "myapp.conf"        before it searches for "app.conf")        "app" is automatically set with the stem of the program file that        was run (or the first part of PATH_INFO) if it is not supplied at        the outset as an argument.</p><p>    prefix - This represents the base directory of the software        installation (i.e. "/usr/myproduct/1.3.12").  If it is not        set explicitly, it is detected from the following places:           1. PREFIX environment variable           2. the real path of the program with /bin or /cgi-bin stripped           3. /usr/local (or whatever "prefix" perl was compiled with)        If it is autodetected from one of those three places, that is        only provisional, in order to find the "option_file".  The "prefix"        variable should be set authoritatively in the "option_file" if it        is desired to be in the $values structure.</p><p>    perlinc - a path of directories to prepend to the @INC search path.        This list of directories is separated by any combination of        [,; ] characters.</p><p>    debug_options - if this is set, a variety of debug information is        printed out during the option processing.  This helps in debugging        which option files are being used and what the resulting variable        values are.  The following numeric values are defined.</p><p>          1 = print the basic steps of option processing           2 = print each option file searched, final values, and resulting @INC           3 = print each value as it is set in the option hash           4 = print overrides from ENV and variable substitutions           5 = print each line of each file with exclude_section indicator           6 = print option file section tags, condition evaluation, and               each value found (even if it is not set in the final values)           7 = print final values</p><p>    import - a list of additional option files to be processed.        An imported file goes on the head of the queue of files to be        processed.</p><p>    hostname - the hostname as returned by the hostname() function        provided by Sys::Hostname (may or may not include domain        qualifiers as a fully qualified domain name).</p><p>    host - same as hostname, but with any trailing domain name removed.        (everything after the first ".")</p><p>    flush_imports - flush all pending imported option files.</p><p>    security_policy_level - When set, this enforces that whenever secure        attributes are applied, they are set to the same level. When set        0, all of the security features are disabled (passwords can be        viewed with "--security_policy_level=0 --help").  When set to 2,        all secure options can only be read from files which do not have        read/write permission by any other user except the one running the        program.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LOGIC FLOW: OPTION PROCESSING DETAILS</h2>
        <div class="sectioncontent">
<p>Basic Concept - By calling App::Options-&gt;<em>init()</em>, your program parses the command line, environment variables, and option files, and puts var/value pairs into a global option hash, %App::options. Just include the following at the top of your program in order to imbue it with many valuable option-setting capabilities.</p><p>    use App::Options;</p><p>When you \*(L"use\*(R" the App::Options module, the <em>import()</em> method is called automatically.  This calls the <em>init()</em> method, passing along all of its parameters.</p><p>One of the args to <em>init()</em> is the \*(L"values\*(R" arg, which allows for a different hash to be specified as the target of all option variables and values.</p><p>    use App::Options (values =&gt; &#92;%Mymodule::opts);</p><p>Throughout the following description of option processing, the %App::options hash may be referred to as the \*(L"options hash\*(R". However it will be understood that some other hash (as specified by the \*(L"values\*(R" arg) may actually be used.</p><h3>Command Line Arguments</h3>
<p>Unless the \*(L"no_cmd_args\*(R" arg is specified to <em>init()</em>, the first source of option values is the command line.</p><p>Each command line argument that begins with a \*(L"-\*(R" or a \*(L"--\*(R" is considered to be an option.  It may take any form such as</p><p>    --verbose      # long option, no arg     --verbose=5    # long option, with arg     --city=ATL     # long option, with arg     -x             # short option, no arg     -t=12:30       # short option, with arg</p><p>All detected options are shifted out of @ARGV and the values are set in the options hash (%App::options).  Options without args are understood to have a value of \*(L"1\*(R".  So \*(L"--verbose\*(R" is identical to \*(L"--verbose=1\*(R".</p><p>Naturally, the \*(L"--\*(R" option terminates command line option processing.</p>
<h3>Command Line Argument Variable Substitution</h3>
<p>Any value which includes a variable undergoes variable substitution before it is placed in the option hash. i.e.</p><p>    logdir = ${prefix}/log</p><p>This line will be expanded properly. (Of course, the variable and its value should be already set in the option hash.)</p><p>Variable substitution is also performed to interpolate values from the environment.</p><p>    port = $ENV{HTTP_PORT} If the special option, \*(L"app\*(R", was not given on the command line, it is initialized.  This option is useful for including or excluding different sections of the option files.</p><p>To handle the special case that the program is running in a \s-1CGI\s0 environment, the \s-1PATH_INFO\s0 variable is checked first. The first segment of the \s-1PATH_INFO\s0 is stripped off, and that becomes the value of the \*(L"app\*(R" option.</p><p>Otherwise, the stem of the program name becomes the value of the \*(L"app\*(R" option.  The stem is the program name without any trailing extension (i.e. \*(L".exe\*(R", \*(L".pl\*(R", etc.).</p>
<h3>The Program Directory</h3>
<p>One of the places that will be searched for option files is the directory in which the program exists on the file system. This directory is known internally as \*(L"$prog_dir\*(R". The special option, \*(L"prefix\*(R", represents the root directory of the software installation.  On a Unix system, a suite of software might by installed at \*(L"/usr/myproduct/thisversion\*(R", and that would be the \*(L"prefix\*(R".  Under this directory, you would expect to find the \*(L"src\*(R", \*(L"bin\*(R", \*(L"lib\*(R", and \*(L"etc\*(R" directories, as well as perhaps \*(L"cgi-bin\*(R", \*(L"htdocs\*(R", and others.</p><p>If the \*(L"prefix\*(R" option is not specified on the command line, the $PREFIX environment variable is used.</p><p>If that is not set, the $prog_dir with the trailing \*(L"/bin\*(R" or \*(L"/cgi-bin\*(R" stripped off is used.</p>
<h3>Option Files</h3>
<p>Unless the \*(L"no_option_file\*(R" arg is specified to <em>init()</em>, the next source of option values is the option files.</p><p>By default, a cascading set of option files are all consulted to allow individual users to specify values that override the normal values for certain programs.  Furthermore, the values for individual programs can override the values configured generally system-wide.</p><p>The resulting value for an option variable comes from the first place that it is ever seen.  Subsequent mentions of the option variable within the same or other option files will be ignored.</p><p>The following files are consulted in order.</p><p>    $ENV{HOME}/.app/$app.conf     $ENV{HOME}/.app/app.conf     $prog_dir/$app.conf     $prog_dir/app.conf     $prefix/etc/app/$app.conf     $prefix/etc/app/app.conf     /etc/app/app.conf</p><p>Thus, a system administrator might set up the $prefix/etc/app/app.conf file with system-wide defaults.  All option configuration could be done in this single file, separating the relevant variables into different sections for each different program to be configured.</p><p>However, if the administrator decided that there were too many parameters for a single program such that it cluttered this file, he might put the option values for that program into the $prefix/etc/app/$app.conf file. This distinction is a matter of preference, as both methods are equally functional.</p><p>A program developer may decide to override some of the system-wide option values for everyone by putting option files in the program's own directory.</p><p>Furthermore, a user may decide to override some of the resulting option values by putting some option files in the appropriate place under his home directory.</p><p>This separation of config files also allows for secure information (such as database passwords) to be required to be provided in the user's own (secured) option files rather than in read-only system-wide option files.</p><p>Specifying the \*(L"--debug_options\*(R" option on the command line will assist in figuring out which files App::Options is looking at.</p>
<h3>Option File Format</h3>
<p>In general an option file takes the form of lines with \*(L"var = value\*(R".</p><p>   dbname   = prod     # this is the production database    dbuser   = scott    dbpass   = tiger</p><p>Trailing comments (preceded by a \*(L"#\*(R") are trimmed off. Spaces before and after the variable, and before and after the value are all trimmed off.  Then enclosing double-quotes (\*(L") are trimmed off.  Variables can be any of the characters in [a-zA-Z0-9_.-].  Values can be any printable characters or the empty string.  Any lines which aren't recognizable as \*(R"var = value" lines or section headers (see below) are ignored.</p><p>If certain variables should be set only for certain programs (or under certain other conditions), section headers may be introduced. The special section headers \*(L"[\s-1ALL\s0]\*(R" and \*(L"[]\*(R" specify the end of a conditional section and the resumption of unconditional option variables.</p><p>   [progtest]    dbname   = test     # this is the test database    [ALL]    dbname   = prod     # this is the production database    dbuser   = scott    dbpass   = tiger</p><p>In this case, the \*(L"progtest\*(R" program will get \*(L"dbname = test\*(R" while all other programs will get \*(L"dbname = prod\*(R".</p><p>Note that you would not get the desired results if the \*(L"dbname = prod\*(R" statement was above the \*(L"[progtest]\*(R" header.  Once an option variable is set, no other occurrence of that variable in any option file will override it.</p><p>For the special case where you want to specify a section for only one variable as above, the following shortcut is provided.</p><p>   [progtest] dbname = test # this is the test database    dbname   = prod          # this is the production database    dbuser   = scott    dbpass   = tiger</p><p>The \*(L"[progtest]\*(R" section header applied for only the single line.</p><p>Furthermore, if it were desired to make this override for all programs containing \*(L"test\*(R" in them, you would use the following syntax.</p><p>   [/test/] dbname = test   # this is the test database    dbname   = prod          # this is the production database    dbuser   = scott    dbpass   = tiger</p><p>The \*(L"[/test/]\*(R" section header tested the \*(L"app\*(R" option using an arbitrary regular expression.</p><p>The section headers can create a condition for inclusion based on any of the variables currently in the option hash.  In fact, \*(L"[progtest]\*(R" is just a synonym for \*(L"[app=progtest]\*(R" and \*(L"[/test/]\*(R" is a synonym for \*(L"[app=/test/]\*(R".</p><p>If, for instance, the usernames and passwords were different for the different databases, you might have the following.</p><p>   [/test/] dbname = test   # progs with "test" go to test database    dbname   = prod          # other progs go to the production database    [dbname=test]            # progs    dbuser   = scott    dbpass   = tiger    [dbname=prod]    dbuser   = mike    dbpass   = leopard</p><p>The conditions created by a section header may be the result of more than a single condition.</p><p>   [dbname=test;dbuser=scott]    dbpass = tiger    [dbname=test;dbuser=ken]    dbpass = ocelot    [dbname=prod;dbuser=scott]    dbpass = tiger62    [dbname=prod;dbuser=ken]    dbpass = 3.ocelot_</p><p>Any number of conditions can be included with semicolons separating them.</p><p>Each time a variable/value pair is found in an option file, it is only included in the option hash if that variable is currently not defined in the option hash.  Therefore, option files never override command line parameters.</p>
<h3>Option Environment Variables and Variable Substitution</h3>
<p>For each variable/value pair that is to be inserted into the option hash from the option files, the corresponding environment variables are searched to see if they are defined.  The environment always overrides an option file value.  (If the \*(L"no_env_vars\*(R" arg was given to the <em>init()</em> method, this whole step of checking the environment is skipped.)</p><p>By default, the environment variable for an option variable named \*(L"dbuser\*(R" would be \*(L"\s-1APP_DBUSER\s0\*(R".  However, if the \*(L"env\*(R" attribute of the \*(L"dbuser\*(R" option is set, a different environment variable may be checked instead (see the Tutorial below for examples).</p><p>After checking the environment for override values, any value which includes a variable undergoes variable substitution before it is placed in the option hash.</p>
<h3>Setting Environment Variables from Option Files</h3>
<p>Any variable of the form \*(L"ENV{\s-1XYZ\s0}\*(R" will set the variable \s-1XYZ\s0 in the environment rather than in the options hash.  Thus, the syntax</p><p>  ENV{LD_LIBRARY_PATH} = ${prefix}/lib</p><p>will enhance the \s-1LD_LIBRARY_PATH\s0 appropriately.</p><p>Note that this only works for options set in an options file. It does not work for options set on the command line, from the environment itself, or from the program-supplied default.</p><p>Under some circumstances, the perl interpreter will need to be restarted in order to pick up the new \s-1LD_LIBRARY_PATH\s0. In that case, you can include the special option</p><p>  perl_restart = 1</p><p>An example of where this might be useful is for \s-1CGI\s0 scripts that use the \s-1DBI\s0 and DBD::Oracle because the Oracle libraries are dynamically linked at runtime.</p><p>\s-1NOTE:\s0 The other standard way to handle \s-1CGI\s0 scripts which require special environment variables to be set is with Apache directives in the httpd.conf or .htaccess files. i.e.</p><p>  SetEnv LD_LIBRARY_PATH /home/oracle/oracle/product/10.2.0/oraclient/lib   SetEnv ORACLE_HOME /home/oracle/oracle/product/10.2.0/oraclient</p><p>\s-1NOTE:\s0 Yet another standard way to handle \s-1CGI\s0 scripts which require an enhanced \s-1LD_LIBRARY_PATH\s0 specifically is to use the /etc/ld.so.conf file.  Edit /etc/ld.so.conf and then run ldconfig (as root). This adds your specific path to the \*(L"standard system places\*(R" that are searched for shared libraries.  This has nothing to do with App::Options or environment variables of course.</p>
<h3>import and flush_imports</h3>
<p>After each option file is read, the special option \*(L"flush_imports\*(R" is checked.  If set, the list of pending option files to be parsed is cleared, and the flush_imports option is also cleared.</p><p>This is useful if you do not want to inherit any of the option values defined in system-wide option files.</p><p>The special option \*(L"import\*(R" is checked next.  If it is set, it is understood to be a list of option files (separated by /[,; ]+/) to be prepended to the list of pending option files. The import option itself is cleared.</p>
<h3>Other Environment Variables and Defaults</h3>
<p>After command line options and option files have been parsed, all of the other options which are known to the program are checked for environment variables and defaults.</p><p>Options can be defined for the program with either the \*(L"options\*(R" arg or the \*(L"option\*(R" arg to the <em>init()</em> method (or a combination of both).</p><p>    use App::Options (         options =&gt; [ "dbname", "dbuser", "dbpass" ],         option =&gt; {             dbname =&gt; {                 env =&gt; "DBNAME",                 default =&gt; "devel",             },             dbuser =&gt; {                 env =&gt; "DBUSER;DBI_USER",             },             dbpass =&gt; {                 env =&gt; "", # password in %ENV is security breach             },         },     );</p><p>For each option variable known, if the value is not already set, then the environment is checked, the default is checked, variable expansion is performed, and the value is entered into the option hash.</p>
<h3>Special Option prefix</h3>
<p>The special option \*(L"prefix\*(R" is reconciled and finalized next.</p><p>Unless it was specified on the command line, the original \*(L"prefix\*(R" was autodetected.  This may have resulted in a path which was technically correct but was different than intended due to symbolic linking on the file system.</p><p>Since the \*(L"prefix\*(R" variable may also be set in an option file, there may be a difference between the auto-detected \*(L"prefix\*(R" and the option file \*(L"prefix\*(R".  If this case occurs, the option file \*(L"prefix\*(R" is the one that is accepted as authoritative.</p>
<h3>Special Option perlinc</h3>
<p>One of the primary design goals of App::Options was to be able to support multiple installations of software on a single machine.</p><p>Thus, you might have different versions of software installed under various directories such as</p><p>    /usr/product1/1.0.0     /usr/product1/1.1.0     /usr/product1/2.1.5</p><p>Naturally, slightly different versions of your perl modules will be installed under each different \*(L"prefix\*(R" directory. When a program runs from /usr/product1/1.1.0/bin, the \*(L"prefix\*(R" will by \*(L"/usr/product1/1.1.0\*(R" and we want the @INC variable to be modified so that the appropriate perl modules are included from $prefix/lib/*.</p><p>This is where the \*(L"perlinc\*(R" option comes in.</p><p>If \*(L"perlinc\*(R" is set, it is understood to be a list of paths (separated by /[ ,;]+/) to be prepended to the @INC variable.</p><p>If \*(L"perlinc\*(R" is not set, \*(L"$prefix/lib/perl5/$perlversion\*(R" and \*(L"$prefix/lib/perl5/site_perl/$perlversion\*(R" are automatically prepended to the @INC variable as a best guess.</p>
<h3>Special Option debug_options</h3>
<p>If the \*(L"debug_options\*(R" variable is set (often on the command line), the list of option files that was searched is printed out, the resulting list of variable values is printed out, and the resulting list of include directories (@INC) is printed out.</p>
<h3>Version</h3>
<p>After all values have been parsed, various conditions are checked to see if the program should print diagnostic information rather than continue running.  Two of these examples are --version and --help.</p><p>If the \*(L"--version\*(R" option is set on the command line, the version information for all loaded modules is printed, and the program is exited.  (The version of a package/module is assumed to be the value of the $VERSION variable in that package. i.e. The version of the XYZ::Foo package is $XYZ::Foo::VERSION.)</p><p> prog --version</p><p>Of course, this is all done implicitly in the \s-1BEGIN\s0 block (during \*(L"use App::Options;\*(R").  If your program tried to set $main::VERSION, it may not be set unless it is set explicitly in the \s-1BEGIN\s0 block.</p><p> #!/usr/bin/perl  BEGIN {    $VERSION = "1.12";  }  use App::Options;</p><p>This can be integrated with \s-1CVS\s0 file versioning using something like the following.</p><p> #!/usr/bin/perl  BEGIN {    $VERSION = do { my @r=(q$Revision: 14478 $=~/&#92;d+/g); sprintf "%d."."%02d"x$#r,@r};  }  use App::Options;</p><p>Furthermore, the version information about some modules that you might expect to have seen will not be printed because those modules have not yet been loaded.  To fix this, use the --version_packages option (or set it in an option file).  This option contains a comma-separated list of modules and/or module regular expressions. The modules are loaded, and the version information from all resulting packages that match any of the patterns is printed.</p><p> prog --version --version_packages=CGI  prog --version --version_packages=CGI,Template</p><p>This also cuts down on the miscellaneous modules (and pragmas) which might have cluttered up your view of the version information you were interested in. If you really wish to see version information for all modules, use the --version=all option.</p><p> prog --version=all --version_packages=CGI,Template</p>
<h3>Help and Validations</h3>
<p>If the \*(L"-?\*(R" or \*(L"--help\*(R" options were set on the command line, the usage statement is printed, and the program is exited.</p><p>Then each of the options which is defined may be validated.</p><p>If an option is designated as \*(L"required\*(R", its value must be defined somewhere (although it may be the empty string). (If it is also required to be a non-empty string, a regex may be provided for the type, i.e. type =&gt; \*(L"/./\*(R".)</p><p>If an option is designated as having a \*(L"type\*(R", its value must either be undefined or match a specific regular expression.</p><p>    Type       Regular Expression     =========  =========================================     string     (any)     integer    /^-?[0-9_]+$/     float      /^-?[0-9_]+&#92;.?[0-9_]*([eE][+-]?[0-9_]+)?$/           (or) /^-?&#92;.[0-9_]+([eE][+-]?[0-9_]+)?$/     boolean    /^[01]$/     date       /^[0-9]{4}-[01][0-9]-[0-3][0-9]$/     datetime   /^[0-9]{4}-[01][0-9]-[0-3][0-9] [0-2][0-9]:[0-5][0-9]:[0-5][0-9]$/     time       /^[0-2][0-9]:[0-5][0-9]:[0-5][0-9]$/     /regexp/   /regexp/</p><p>Note that an arbitrary regular expression may be designated as the \*(L"type\*(R" by enclosing it in slashes (i.e. \*(L"/^[\s-1YN\s0]$/\*(R").</p><p>If the options fail any of the \*(L"required\*(R" or \*(L"type\*(R" validation tests, the <em>App::Options::print_usage()</em> function is called to print out a usage statement and the program is exited.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">USAGE TUTORIAL</h2>
        <div class="sectioncontent">
<h3>Getting Started</h3>
<p>Create a perl program called \*(L"demo1\*(R".</p><p>    #!/usr/bin/perl     use App::Options;     print "Wow. Here are the options...&#92;n";     foreach (sort keys %App::options) {  # options appear here!         printf("%-20s =&gt; %s&#92;n", $_, $App::options{$_});     }</p><p>Run it different kinds of ways to see how it responds.</p><p>    demo1     demo1 -x     demo1 -x --verbose     demo1 --x -verbose     demo1 -x=5 --verbose=10 --foo=bar     demo1 --help     demo1 -x=8 --help     demo1 -?     demo1 --debug_options -?     demo1 -x=5 --verbose=10 --foo=bar --debug_options -?</p><p>    demo1 --version     demo1 --version --version_packages=CGI</p><p>Now create a copy of the program.</p><p>    cp demo1 demo2</p><p>Start putting entries like the following</p><p>    x = 7     hello = world     [demo2]     verbose=3     [/demo/]     baz = foo</p><p>in the following files</p><p>    $HOME/.app/demo1.conf     $HOME/.app/demo2.conf     $HOME/.app/app.conf     demo1.conf  (same directory as the demo* programs)     demo2.conf  (same directory as the demo* programs)     app.conf    (same directory as the demo* programs)     $PREFIX/etc/app/demo1.conf     $PREFIX/etc/app/demo2.conf     $PREFIX/etc/app/app.conf     /etc/app/app.conf</p><p>and see how the programs respond in each different case.</p><p>Next set environment variables like the following and see how the programs respond.</p><p>    export APP_X=14     export APP_VERBOSE=7     export APP_FOO=xyzzy     export APP_HELLO=Plugh!</p><p>You are well on your way.</p>
<h3>A Development Scenario</h3>
<p>Now let's imagine that we are writing a suite of programs which operate on a relational database.  These programs are part of a larger system which goes through a development cycle of development, test, and production.  Each step in the development cycle, the programs will run against different databases, but we don't want that to affect the code.</p><p>Let's suppose that we write a program which lists the customers in a customer table.</p><p>    create table person (         person_id      integer       not null auto_increment primary key,         first_name     varchar(99)   null,         last_name      varchar(99)   null,         birth_dt       date          null,         company_id     integer       null,         wholesale_ind  <strong>char</strong>(1)       null,         change_dttm    datetime      not null,     );</p><p>We call this program \*(L"listcust\*(R".</p><p>    #!/usr/bin/perl -e     use strict;     use App::Options;     use DBI;     my $dsn = "dbi:$App::options{dbdriver}:database=$App::options{dbname}";     my $dbh = DBI-&gt;connect($dsn, $App::options{dbuser}, $App::options{dbpass});     my $sql = "select first_name, last_name, birth_dt, company_id, wholesale_ind, change_dttm from person";     my $cust = $dbh-&gt;selectall_arrayref($sql);     foreach my $row (@$cust) {         printf("%-24 %-24 %s %9d %s&#92;n", @$row);     }     $dbh-&gt;disconnect();</p><p>Then you can invoke this program with all of the command line options and everything works fine.</p><p>    listcust --dbdriver=mysql --dbname=prod --dbuser=scott --dbpass=tiger</p><p>However, if you don't use all of the options, you will get a \s-1DBI\s0 error. Furthermore, \*(L"listcust --help\*(R" doesn't help very much.  A system administrator confronting this problem would put the following lines into \*(L"$PREFIX/etc/app/app.conf\*(R" or \*(L"$PREFIX/etc/app/listcust.conf\*(R".</p><p>    dbdriver = mysql     dbname   = prod     dbuser   = scott     dbpass   = tiger</p><p>If, however, your projects were not in the habit of using the \s-1PREFIX\s0 environment variable and the program is not installed in $PREFIX/bin, he would have to put the above lines in either the \*(L"app.conf\*(R" file or the \*(L"listcust.conf\*(R" file in the same directory as \*(L"listcust\*(R" or in the global \*(L"/etc/app/app.conf\*(R" option file.</p><p>A user (without privileges to the \*(L"$PREFIX/etc/app\*(R" directory or the directory in which \*(L"listcust\*(R" lives) would have to put the described lines into \*(L"$HOME/.app/app.conf\*(R" or \*(L"$HOME/.app/listcust.conf\*(R".</p><p>Putting the options in any of those files would make \*(L"--help\*(R" print something intelligent.</p><p>A developer, however, might decide that the program should have some defaults.</p><p>    use App::Options (         option =&gt; {             dbdriver =&gt; "mysql",             dbname   =&gt; "prod",             dbuser   =&gt; "scott",             dbpass   =&gt; "tiger",         },     );</p><p>(This supplies defaults and also makes \*(L"--help\*(R" print something intelligent, regardless of whether there are any configuration files.)</p><p>If all you wanted to do was provide defaults for options, this format would be fine.  However, there are other useful attributes of an option besides just the \*(L"default\*(R". To use those, you generally would use the more complete form of the \*(L"option\*(R" arg.</p><p>    use App::Options (         option =&gt; {             dbdriver =&gt; { default =&gt; "mysql", },             dbname   =&gt; { default =&gt; "prod",  },             dbuser   =&gt; { default =&gt; "scott", },             dbpass   =&gt; { default =&gt; "tiger", },         },     );</p><p>Then we can indicate that these options are all required. If they are not provided, the program will not run.</p><p>Meanwhile, it makes no sense to provide a \*(L"default\*(R" for a password.  We can remove the default, but if we ever tried to run the program without providing the password, it would not get past printing a \*(L"usage\*(R" statement.</p><p>    use App::Options (         option =&gt; {             dbdriver =&gt; { required =&gt; 1, default =&gt; "mysql", },             dbname   =&gt; { required =&gt; 1, default =&gt; "prod",  },             dbuser   =&gt; { required =&gt; 1, default =&gt; "scott", },             dbpass   =&gt; { required =&gt; 1, },         },     );</p><p>We now might enhance the code in order to list only the customers which had certain attributes.</p><p>    my $sql = "select first_name, last_name, birth_dt, company_id, wholesale_ind, change_dttm from person";     my (@where);     push(@where, "first_name like &apos;%$App::options{first_name}%&apos;")         if ($App::options{first_name});     push(@where, "last_name like &apos;%$App::options{last_name}%&apos;")         if ($App::options{last_name});     push(@where, "birth_dt = &apos;$App::options{birth_dt}&apos;")         if ($App::options{birth_dt});     push(@where, "company_id = $App::options{company_id}")         if ($App::options{company_id});     push(@where, "wholesale_ind = &apos;$App::options{wholesale_ind}&apos;")         if ($App::options{wholesale_ind});     push(@where, "change_dttm &gt;= &apos;$App::options{change_dttm}&apos;")         if ($App::options{change_dttm});     if ($#where &gt; -1) {         $sql .= "&#92;nwhere " . join("&#92;n  and ", @where) . "&#92;n";     }     my $cust = $dbh-&gt;selectall_arrayref($sql);</p><p>The <em>init()</em> method call might be enhanced to look like this. Also, the order that the options are printed by \*(L"--help\*(R" can be set with the \*(L"options\*(R" argument.  (Otherwise, they would print in alphabetical order.)</p><p>    use App::Options (         options =&gt; [ "dbdriver", "dbname", "dbuser", "dbpass",             "first_name", "last_name", "birth_dt", "company_id",             "wholesale_ind", "change_dttm",         ],         option =&gt; {             dbdriver =&gt; {                 description =&gt; "dbi driver name",                 default =&gt; "mysql",                 env =&gt; "DBDRIVER",  # use a different env variable                 required =&gt; 1,             },             dbname   =&gt; {                 description =&gt; "database name",                 default =&gt; "prod",                 env =&gt; "DBNAME",  # use a different env variable                 required =&gt; 1,             },             dbuser   =&gt; {                 description =&gt; "database user",                 default =&gt; "scott",                 env =&gt; "DBUSER;DBI_USER",  # check both                 required =&gt; 1,             },             dbpass   =&gt; {                 description =&gt; "database password",                 env =&gt; "",  # disable env for password (insecure)                 required =&gt; 1,                 secure =&gt; 1,   # FYI. This is inferred by the fact that "dbpass"                                # ends in "pass", so it is not necessary.             },             first_name =&gt; {                 description =&gt; "portion of customer&apos;s first name",             },             last_name  =&gt; {                 description =&gt; "portion of customer&apos;s last name",             },             birth_dt   =&gt; {                 description =&gt; "customer&apos;s birth date",                 type =&gt; "date",             },             company_id =&gt; {                 description =&gt; "customer&apos;s company ID",                 type =&gt; "integer",             },             wholesale_ind =&gt; {                 description =&gt; "indicator of wholesale customer",                 type =&gt; "/^[YN]$/",             },             change_dttm =&gt; {                 description =&gt; "changed-since date/time",                 type =&gt; "datetime",             },         },     );</p><p>It should be noted in the example above that the default environment variable name (\*(L"APP_${varname}\*(R") has been overridden for some of the options.  The \*(L"dbname\*(R" variable will be set from \*(L"\s-1DBNAME\s0\*(R" instead of \*(L"\s-1APP_DBNAME\s0\*(R".  The \*(L"dbuser\*(R" variable will be set from either \*(L"\s-1DBUSER\s0\*(R" or \*(L"\s-1DBI_USER\s0\*(R".</p><p>It should also be noted that if only the order of the options rather than all of their attributes were desired, the following could have been used.</p><p>    use App::Options (         options =&gt; [ "dbdriver", "dbname", "dbuser", "dbpass",             "first_name", "last_name", "birth_dt", "company_id",             "wholesale_ind", "change_dttm",         ],     );</p><p>Using the \*(L"options\*(R" arg causes the options to be printed in the order given in the \*(L"--help\*(R" output.  Then the remaining options defined in the \*(L"option\*(R" arg are printed in alphabetical order.  All other options which are set on the command line or in option files are printed if the \*(L"show_all\*(R" option is set.  This option is off by default if either the \*(L"options\*(R" arg or the \*(L"option\*(R" arg are supplied and on if neither are supplied.</p><p>If, for some reason, the program needed to put the options into a different option hash (instead of %App::options) or directly specify the option file to use (disregarding the standard option file search path), it may do so using the following syntax.</p><p>    use App::Options (         values =&gt; &#92;%Mymodule::opts,         option_file =&gt; "/path/to/options.conf",     );</p><p>If, for some reason, the program needs to inhibit one or more of the sources for options, it can do so with one of the following arguments.  Of course, inhibiting all three would be a bit silly.</p><p>    use App::Options (         no_cmd_args =&gt; 1,         no_option_file =&gt; 1,         no_env_vars =&gt; 1,     );</p>
<h3>A Deployment Scenario</h3>
<p>Sometimes a software system gets deployed across many machines. You may wish to have a single option file set different values when it is deployed to different machines.</p><p>For this purpose, the automatic \*(L"host\*(R" and \*(L"hostname\*(R" values are useful.  Suppose you have four servers named \*(L"foo1\*(R", \*(L"foo2\*(R", \*(L"foo3\*(R", and \*(L"foo4\*(R".  You may wish the software to use different databases on each server.  So app.conf might look like this.</p><p>    [host=foo1] dbname = devel     [host=foo2]     dbname = test     [host=foo3]     dbname = prod     [ALL]     dbname = prod</p><p>Hopefully, that's enough to get you going.</p><p>I welcome all feedback, bug reports, and feature requests.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ACKNOWLEDGEMENTS</h2>
        <div class="sectioncontent">
<p> * (c) 2010 Stephen Adkins  * Author:  Stephen Adkins &lt;spadkins@gmail.com&gt;  * License: This is free software. It is licensed under the same terms as Perl itself.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO App::Options&hellip;</h2>
        <div class="sectioncontent">

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="App::Control.3pm.html"><span aria-hidden="true">&larr;</span> App::Control.3pm: Perl module for apachectl style control of another script or executable</a></li>
   <li class="next"><a href="App::Prolix.3pm.html">App::Prolix.3pm: Trim chatty command outputs <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

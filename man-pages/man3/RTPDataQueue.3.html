<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RTPDataQueue: A packet queue handler for building different kinds of rtp protocol systems.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="A packet queue handler for building different kinds of rtp protocol systems.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="RTPDataQueue (3) manual">
  <meta name="twitter:description" content="A packet queue handler for building different kinds of rtp protocol systems.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libccrtp-doc-RTPDataQueue-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/RTPDataQueue.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="RTPDataQueue (3) manual" />
  <meta property="og:description" content="A packet queue handler for building different kinds of rtp protocol systems." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libccrtp-doc-RTPDataQueue-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">RTPDataQueue<small> (3)</small></h1>
        <p class="lead">A packet queue handler for building different kinds of rtp protocol systems.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/RTPDataQueue.3.html">
      <span itemprop="name">RTPDataQueue: A packet queue handler for building different kinds of rtp protocol systems.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libccrtp-doc/">
      <span itemprop="name">libccrtp-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/RTPDataQueue.3.html">
      <span itemprop="name">RTPDataQueue: A packet queue handler for building different kinds of rtp protocol systems.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;ioqueue.h&gt;</p><p>Inherits <strong>IncomingDataQueue</strong>, and <strong>OutgoingDataQueue</strong>.</p><p>Inherited by <strong>QueueRTCPManager</strong>, and <strong>RTPDuplex</strong>.</p><h3>Public Types</h3>
<p>enum <strong>Tos</strong> { <strong>tosBestEffort</strong>, <strong>tosEnhanced</strong> }</p><p><em></em><strong>rtp.h</strong><em> cc++/rtp.h </em><strong></strong></p>
<h3>Public Member Functions</h3>
<p>void <strong>setTypeOfService</strong> (<strong>Tos</strong> tos)</p><p><em>Specify the kind of service the application expects to use. </em> void <strong>enableStack</strong> ()</p><p><em>Enable packet queue processing in the stack. </em> void <strong>disableStack</strong> ()</p><p><em>Disable packet queue processing in the stack. </em> bool <strong>isActive</strong> () const </p><p><em>Get active connection state flag. </em> uint32 <strong>getCurrentTimestamp</strong> () const </p><p><em>Get the timestamp that should be given for a packet whose payload sampling instant corresponds to the current system time. </em> void <strong>setSessionBandwidth</strong> (uint32 bw)</p><p><em>Specify the bandwidth of the current session. </em> uint32 <strong>getDefaultSessionBandwidth</strong> () const </p><p>uint32 <strong>getSessionBandwidth</strong> () const </p><p>void <strong>setTimeclock</strong> ()</p><p><em>Set the packet timeclock for synchronizing timestamps. </em> timeout_t <strong>getTimeclock</strong> () const </p><p><em>Get the packet timeclock for synchronizing timestamps. </em></p>
<h3>Protected Member Functions</h3>
<p><strong>RTPDataQueue</strong> (uint32 size=<strong>defaultMembersHashSize</strong>)</p><p><em>Constructor. </em> <strong>RTPDataQueue</strong> (uint32 *ssrc, uint32 size=<strong>defaultMembersHashSize</strong>)</p><p><em>Using this constructor you can start a session with the given ssrc, instead of the usual randomly generated one. </em> virtual <strong>~RTPDataQueue</strong> ()</p><p><em>The queue destructor flushes the queue and stops all services. </em> virtual void <strong>timerTick</strong> ()</p><p><em>A plugin point for timer tick driven events. </em> void <strong>renewLocalSSRC</strong> ()</p><p>void <strong>endQueue</strong> ()</p><p><em>This method ends the queue. </em> virtual bool <strong>isPendingData</strong> (<strong>microtimeout_t</strong> timeout)=0</p><p><em>This function is used to check for and schedule against arriving packets based on the derived connection type. </em></p>
<h3>Additional Inherited Members</h3>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>A packet queue handler for building different kinds of RTP protocol systems.</p><p>The queue manages both incoming and outgoing RTP packets, as well as synchronization and transmission/reception timers. By making the queue handler a seperate base class it becomes possible to define RTP classes for RTP profiles and sessions of different types.</p><p>Outgoing packets are sent via the <strong>OutgoingDataQueue::putData</strong> method.</p><p>Incoming packets can be retrieved via <strong>IncomingDataQueue::getData</strong> method.</p><p><strong>Author:</strong></p><p>David Sugar dyfet@ostel.com RTP data queue handler.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Enumeration Documentation</h2>
        <div class="sectioncontent">
<h3>enum \fBRTPDataQueue::Tos\fP</h3>
<p><strong>rtp.h</strong> cc++/rtp.h Type of network service the application uses.</p><p>If the application uses enhanced network service, for instance Integrated Services or Differentiated Services, it <em>has not</em> to ensure fair competition with TCP, provided that the requested service is actually being delivered. Whenever the application uses best-effort service or the requested enhanced service is not actually being delivered, it <em>has</em> to ensure fair competition with TCP. By default, best-effot is assumed.</p><p><strong>Note:</strong></p><p>Although not required, RTP packets are always sent on top of UDP segments. No other underlying transport protocol is supported at present.</p><p><strong>Enumerator</strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><em>tosBestEffort </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Best-effort network service.</p>
  </dd>
  <dt>
    <p><strong></strong><em>tosEnhanced </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Enhanced network service.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>RTPDataQueue::RTPDataQueue (uint32size = \fC\fBdefaultMembersHashSize\fP\fP)\fC [protected]\fP</h3>
<p>Constructor. This will generate a random application SSRC identifier.</p><p><strong>Parameters:</strong></p><p><em>size</em> an estimation of the number of participants in the session</p>
<h3>RTPDataQueue::RTPDataQueue (uint32 *ssrc, uint32size = \fC\fBdefaultMembersHashSize\fP\fP)\fC [protected]\fP</h3>
<p>Using this constructor you can start a session with the given ssrc, instead of the usual randomly generated one. This is necessary when you need to initiate several sessions having the same SSRC identifier, for instance, to implement layered encoding, in which case each layer is managed through a different session but all sessions share the same SSRC identifier.</p><p><strong>Warning:</strong></p><p>This doesn't seem to be a good solution</p><p><strong>Parameters:</strong></p><p><em>ssrc</em> Synchronization SouRCe identifier for this session</p><p><em>size</em> an estimation of the number of participants in the session</p>
<h3>virtual RTPDataQueue::~RTPDataQueue ()\fC [inline]\fP, \fC [protected]\fP, \fC [virtual]\fP</h3>
<p>The queue destructor flushes the queue and stops all services.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>void RTPDataQueue::disableStack ()\fC [inline]\fP</h3>
<p>Disable packet queue processing in the stack.</p>
<h3>void RTPDataQueue::enableStack ()\fC [inline]\fP</h3>
<p>Enable packet queue processing in the stack. This method will not any thread of execution.</p>
<h3>void RTPDataQueue::endQueue ()\fC [protected]\fP</h3>
<p>This method ends the queue.</p>
<h3>uint32 RTPDataQueue::getCurrentTimestamp () const</h3>
<p>Get the timestamp that should be given for a packet whose payload sampling instant corresponds to the current system time. The timestamp applications should provide for each packet represents the sampling instant of its payload and should not be a reading of the system clock. Nevertheless, the internal operation of the RTP stack relies on the accuracy of the provided timestamp, since several computations assume that there is a certain degree of correspondence between the timestamp and the system clock.</p><p>It is recommended that applications use this method in order to <em>periodically adjust the RTP timestamp</em>.</p><p>In particular, it is advisable getting the timestamp corresponding to the first sampling instant or any instant after a period of inactivity through a call to this method.</p><p>Applications should use the nominal sampling or any other value provided by the coder in order to compute the next timestamps with minimum computational requirement.</p><p>For instance, an application using an RTP profile that specifies a fixed sampling rate of 8 Khz with eight bits per sample, continuously transmitting audio blocks 80 octets long, would transmit 100 packets every second. Every packet would carry a timestamp 80 units greater than the previous one. So, the first timestamp would be obtained from this method, whereas the following ones would be computed adding 80 every time. Also the timestamp should be increased for every block whether it is put in the queue or dropped.</p><p>The aforementioned increment can be obtained from the RTPDataQueue::getTimestampIncrement() method rather than computing it by hand in the application.</p><p><strong>Note:</strong></p><p>Frame based applications must follow a specific timestamping method, probably specified in a profile.</p><p>You should take into account that by default ccRTP assumes that the application begins sampling at the queue creation time. Moreover, the first sampling instant is assigned a 'user visible' timestamp of 0, although the RTP stack will then add internally a ramdom offset unknown to the application. That is to say, the application may count samples from 0 in order to get the timestamp for the next packet, provided that the first sampling instant is the same as the queue creation time. Nevertheless, this simpler way of starting will not be as accurate as it would be if the application got at least the first timestamp through getCurrentTimestamp. <em>We provide this option since ccRTP interface is evolving, but we admit that it is ugly, we could remove this option or even replace uint32 timestamps with a restrictively regulated object; suggestions are gladly welcomed</em></p>
<h3>uint32 RTPDataQueue::getDefaultSessionBandwidth () const\fC [inline]\fP</h3>

<h3>uint32 RTPDataQueue::getSessionBandwidth () const\fC [inline]\fP</h3>

<h3>timeout_t RTPDataQueue::getTimeclock () const\fC [inline]\fP</h3>
<p>Get the packet timeclock for synchronizing timestamps.</p><p><strong>Returns:</strong></p><p>runtime in milliseconds since last set.</p>
<h3>bool RTPDataQueue::isActive () const\fC [inline]\fP</h3>
<p>Get active connection state flag.</p><p><strong>Returns:</strong></p><p>true if connection 'active'.</p>
<h3>virtual bool RTPDataQueue::isPendingData (\fBmicrotimeout_t\fPtimeout)\fC [protected]\fP, \fC [pure virtual]\fP</h3>
<p>This function is used to check for and schedule against arriving packets based on the derived connection type.</p><p><strong>Returns:</strong></p><p>true if packet waiting for processing.</p><p><strong>Parameters:</strong></p><p><em>number</em> of microseconds to wait.</p><p>Implemented in <strong>RTPDuplex</strong>.</p>
<h3>void RTPDataQueue::renewLocalSSRC ()\fC [inline]\fP, \fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Reimplemented from <strong>RTPQueueBase</strong>.</p>
<h3>void RTPDataQueue::setSessionBandwidth (uint32bw)\fC [inline]\fP</h3>
<p>Specify the bandwidth of the current session.</p><p><strong>Parameters:</strong></p><p><em>bw</em> bandwidth of the current session, in bits/s.</p><p><strong>See also:</strong></p><p><strong>AVPQueue::setControlBandwidth()</strong></p>
<h3>void RTPDataQueue::setTimeclock ()\fC [inline]\fP</h3>
<p>Set the packet timeclock for synchronizing timestamps.</p>
<h3>void RTPDataQueue::setTypeOfService (\fBTos\fPtos)\fC [inline]\fP</h3>
<p>Specify the kind of service the application expects to use.</p><p><strong>Parameters:</strong></p><p><em>tos</em> type of service the application expects to use</p><p><strong>Note:</strong></p><p>If enhanced service is specified but packet loss is high (the requested service does not appear to actually be delivered) ccRTP defaults to best-effort suitable behaviour: guarantee fair competition with TCP.</p>
<h3>virtual void RTPDataQueue::timerTick ()\fC [inline]\fP, \fC [protected]\fP, \fC [virtual]\fP</h3>
<p>A plugin point for timer tick driven events.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for ccRTP from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="RTPBaseUDPIPv4Socket.3.html"><span aria-hidden="true">&larr;</span> RTPBaseUDPIPv4Socket.3: A udp/ipv4 socket class targeted at rtp stacks.</a></li>
   <li class="next"><a href="RTPDuplex.3.html">RTPDuplex.3: A peer associated rtp socket pair for physically connected peer hosts. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

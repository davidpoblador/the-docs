<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Data::Rmap: Recursive map, apply a block to a data structure</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Recursive map, apply a block to a data structure">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Data::Rmap (3pm) manual">
  <meta name="twitter:description" content="Recursive map, apply a block to a data structure">
  <meta name="twitter:image" content="https://www.carta.tech/images/libdata-rmap-perl-Data::Rmap-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Data::Rmap.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Data::Rmap (3pm) manual" />
  <meta property="og:description" content="Recursive map, apply a block to a data structure" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libdata-rmap-perl-Data::Rmap-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Data::Rmap<small> (3pm)</small></h1>
        <p class="lead">Recursive map, apply a block to a data structure</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Data::Rmap.3pm.html">
      <span itemprop="name">Data::Rmap: Recursive map, apply a block to a data structure</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libdata-rmap-perl/">
      <span itemprop="name">libdata-rmap-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Data::Rmap.3pm.html">
      <span itemprop="name">Data::Rmap: Recursive map, apply a block to a data structure</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
 $ perl -MData::Rmap -e &apos;print rmap { $_ } 1, [2,3], &#92;&#92;4, "&#92;n"&apos;
 1234

 $ perl -MData::Rmap=:all
 rmap_all { print (ref($_) || "?") ,"&#92;n" } &#92;@array, &#92;%hash, &#92;*glob;

 # OUTPUT (Note: a GLOB always has a SCALAR, hence the last two items)
 # ARRAY
 # HASH
 # GLOB
 # SCALAR
 # ?


 # Upper-case your leaves in-place
 $array = [ "a", "b", "c" ];
 $hash  = { key =&gt; "a value" };
 rmap { $_ = uc $_; } $array, $hash;

 use Data::Dumper; $Data::Dumper::Terse=1; $Data::Dumper::Indent=0;
 print Dumper($array), " ", Dumper($hash), "&#92;n";

 # OUTPUT
 # [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;] {&apos;key&apos; =&gt; &apos;A VALUE&apos;}


 # Simple array dumper.
 # Uses $self-&gt;recurse method to alter traversal order
 ($dump) = rmap_to {

    return "&apos;$_&apos;" unless ref($_); # scalars are quoted and returned

    my $self = shift;
    # use $self-&gt;recurse to grab results and wrap them
    return &apos;[ &apos; . join(&apos;, &apos;, $self-&gt;recurse() ) . &apos; ]&apos;;

  } ARRAY|VALUE,  [ 1, [ 2, [ [ 3 ], 4 ] ], 5 ];

 print "$dump&#92;n";
 # OUTPUT
 # [ &apos;1&apos;, [ &apos;2&apos;, [ [ &apos;3&apos; ], &apos;4&apos; ] ], &apos;5&apos; ]
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p> rmap BLOCK LIST</p><p>Recursively evaluate a \s-1BLOCK\s0 over a list of data structures (locally setting $_ to each element) and return the list composed of the results of such evaluations.  $_ can be used to modify the elements.</p><p>Data::Rmap currently traverses \s-1HASH\s0, \s-1ARRAY\s0, \s-1SCALAR\s0 and \s-1GLOB\s0 reference types and ignores others.  Depending on which rmap_* wrapper is used, the \s-1BLOCK\s0 is called for only scalar values, arrays, hashes, references, all elements or a customizable combination.</p><p>The list of data structures is traversed pre-order in a depth-first fashion. That is, the \s-1BLOCK\s0 is called for the container reference before is it called for it's elements (although see \*(L"recurse\*(R" below for post-order). The values of a hash are traversed in the usual \*(L"values\*(R" order which may affect some applications.</p><p>If the \*(L"cut\*(R" subroutine is called in the \s-1BLOCK\s0 then the traversal stops for that branch, say if you \*(L"cut\*(R" an array then the code is never called for it's elements (or their sub-elements). To simultaneously return values and cut, simply pass the return list to cut:  \*(C`cut(&apos;add&apos;,&apos;to&apos;,&apos;returned&apos;);\*(C'</p><p>The first parameter to the \s-1BLOCK\s0 is an object which maintains the state of the traversal.  Methods available on this object are described in \*(L"State Object\*(R" below.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">
<p>By default:</p><p> rmap, rmap_all, cut</p><p>Optionally:</p><p> rmap_scalar rmap_hash rmap_array rmap_ref rmap_to  :types =&gt; [ qw(NONE VALUE HASH ARRAY SCALAR REF OBJECT ALL) ],  :all =&gt; ... # everything</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Functions</h2>
        <div class="sectioncontent">
<p>The various names are just wrappers which select when to call the code \s-1BLOCK\s0.  rmap_all always calls it, the others are more selective while rmap_to takes an extra parameter permitting you to provide selection criteria.  Furthermore, you can always just rmap_all and skip nodes which are not of interest. Most general first. Recurse the @data_structures and apply the \s-1BLOCK\s0 to elements selected by $want.  The $want parameter is the bitwise \*(L"or\*(R" of whatever types you choose (imported with :types):  VALUE  - non-reference scalar, eg. 1  HASH   - hash reference  ARRAY  - array reference  SCALAR - scalar refernce, eg. &#92;1  REF    - higher-level reference, eg. &#92;&#92;1, &#92;&#92;{}           B&lt;NOT&gt; any reference type, see &lt;Scalar::Util&gt;&apos;s reftype:           perl -MScalar::Util=reftype -le &apos;print map reftype($_), &#92;1, &#92;&#92;1&apos;  GLOB   - glob reference, eg. &#92;*x           (scalar, hash and array recursed)  ALL    - all of the above  NONE   - none of the above So to call the block for arrays and scalar values do:  use Data::Rmap &apos;:all&apos;;         # or qw(:types rmap_to)  rmap { ... } ARRAY|VALUE, @data_structures; (\s-1ALL\s0 & !GLOB) might also be handy. The remainder of the wrappers are given in terms of the $want for rmap_to. Recurse and call the \s-1BLOCK\s0 on non-reference scalar values.  $want = \s-1VALUE\s0</p>
<dl class='dl-vertical'>
  <dt>
    rmap_all \s-1BLOCK\s0 \s-1LIST\s0
  </dt>
  <dd>
    <p>Recurse and call the \s-1BLOCK\s0 on everything.  $want = \s-1ALL\s0 Recurse and call the \s-1BLOCK\s0 on non-collection scalars. $want = VALUE|SCALAR|REF</p>
  </dd>
  <dt>
    rmap_hash
  </dt>
  <dd>
    <p>Recurse and call the \s-1BLOCK\s0 on hash refs.  $want = \s-1HASH\s0</p>
  </dd>
  <dt>
    rmap_array
  </dt>
  <dd>
    <p>Recurse and call the \s-1BLOCK\s0 on array refs.  $want = \s-1ARRAY\s0</p>
  </dd>
  <dt>
    rmap_ref
  </dt>
  <dd>
    <p>Recurse and call the \s-1BLOCK\s0 on all references (not \s-1GLOBS\s0). $want = HASH|ARRAY|SCALAR|REF Note: rmap_ref isn't the same as rmap_to {} \s-1REF\s0</p>
  </dd>
  <dt>
    cut(@list)
  </dt>
  <dd>
    <p>Don't traverse sub-elements and return the @list immediately. For example, if $_ is an \s-1ARRAY\s0 reference, then the array's elements are not traversed. If there's two paths to an element, both will need to be cut.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">State Object</h2>
        <div class="sectioncontent">
<p>The first parameter to the \s-1BLOCK\s0 is an object which maintains most of the traversal state (except current node, which is $_). <em>You will ignore it most of the time</em>. The \*(L"recurse\*(R" method may be useful. Other methods should only be used in throw away tools, see \s-1TODO\s0</p><p>Methods:</p>
<dl class='dl-vertical'>
  <dt>
    recurse
  </dt>
  <dd>
    <p>Process child nodes of $_ now and return the result. This makes it easier to perform post-order and in-order processing of a structure.  Note that since the same \*(L"seen list\*(R" is used, the child nodes aren't reprocessed.</p>
  </dd>
  <dt>
    code
  </dt>
  <dd>
    <p>The code reference of the \s-1BLOCK\s0 itself.  Possible useful in some situations.</p>
  </dd>
  <dt>
    seen
  </dt>
  <dd>
    <p>(Warning: I'm undecided whether this method should be public) Reference to the \s-1HASH\s0 used to track where we have visited. You may want to modify it in some situations (though I haven't yet). Beware circular references.  The (current) convention used for the key is in the source.</p>
  </dd>
  <dt>
    want
  </dt>
  <dd>
    <p>(Warning: I'm undecided whether this method should be public) The $want state described in rmap_to.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p> # command-line play  $ perl -MData::Rmap -le &apos;print join ":", rmap { $_ } 1,2,[3..5],&#92;&#92;6&apos;  1:2:3:4:5:6</p><p> # Linearly number questions on a set of pages  my $qnum = 1;  rmap_hash {      $_-&gt;{qnum} = $qnum++ if($_-&gt;{qn});  } @pages;</p><p> # Grep recursively, finding ALL objects  use Scalar::Util qw(blessed);  my @objects = rmap_ref {      blessed($_) ? $_ : ();  } $data_structure;</p><p> # Grep recursively, finding public objects (note the cut)  use Scalar::Util qw(blessed);  my @objects = rmap_ref {      blessed($_) ?  cut($_) : ();  } $data_structure;</p><p> # Return a modified structure  # (result flattening means we must cheat by cloning then modifying)  use Storable qw(dclone);  use Lingua::EN::Numbers::Easy;</p><p> $words = [ 1, &#92;2, { key =&gt; 3 } ];  $nums = dclone $words;  rmap { $_ = $N{$_} || $_ } $nums;</p><p> # Make an assertion about a structure  use Data::Dump;  rmap_ref {     blessed($_) && $_-&gt;isa(&apos;Question&apos;) && defined($_-&gt;name)         or die "Question doesn&apos;t have a name:", dump($_);  } @pages;</p><p> # Traverse a tree using localize state  $tree = [      one =&gt;      two =&gt;      [          three_one =&gt;          three_two =&gt;          [              three_three_one =&gt;          ],          three_four =&gt;      ],      four =&gt;      [          [              five_one_one =&gt;          ],      ],  ];</p><p> @path = (&apos;q&apos;);  rmap_to {      if(ref $_) {          local(@path) = (@path, 1); # ARRAY adds a new level to the path          $_[0]-&gt;recurse(); # does stuff within local(@path)&apos;s scope      } else {          print join(&apos;.&apos;, @path), " = $_ &#92;n"; # show the scalar&apos;s path      }      $path[-1]++; # bump last element (even when it was an aref)  } ARRAY|VALUE, $tree;</p><p> # OUTPUT  # q.1 = one  # q.2 = two  # q.3.1 = three_one  # q.3.2 = three_two  # q.3.3.1 = three_three_one  # q.3.4 = three_four  # q.4 = four  # q.5.1.1 = five_one_one</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Troubleshooting</h2>
        <div class="sectioncontent">
<p>Beware comma after block:</p><p> rmap { print }, 1..3;                ^-------- bad news, you get and empty list:  rmap(sub { print $_; }), 1..3;</p><p>If you don't import a function, perl's confusion may produce:</p><p> $ perl -MData::Rmap -le &apos;rmap_scalar { print } 1&apos;  Can&apos;t call method "rmap_scalar" without a package or object reference...</p><p> $ perl -MData::Rmap -le &apos;rmap_scalar { $_++ } 1&apos;  Can&apos;t call method "rmap_scalar" without a package or object reference...</p><p>If there's two paths to an element, both will need to be cut.</p><p>If there's two paths to an element, one will be taken randomly when there is an intervening hash.</p><p>Autovivification can lead to \*(L"Deep recursion\*(R" warnings if you test \*(C`exists $_-\*(C'{this}{that}&gt; instead of \*(C`exists $_-\*(C'{this} && exists $_-&gt;{this}{that}&gt; as you may follow a long chain of \*(L"this\*(R"s</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TODO</h2>
        <div class="sectioncontent">
<p>put for @_ iin wrapper to allow parameters in a different wrapper, solve localizing problem.</p><p>Note that the package/class name of the \*(L"State Object\*(R" is subject to change.</p><p>The want and seen accessors may change or become useful dynamic mutators.</p><p>Store custom localized data about the traversal. Seems too difficult and ugly when compare to doing it at the call site. Should support multiple reentrancy so avoid the symbol table.</p><p>\*(C`rmap_args { } $data_structure, @args\*(C' form to pass parameters. Could potentially help localizing needs.  (Maybe only recurse last item)</p><p>Benchmark.  Use array based object and/or direct access internally.</p><p>rmap_objects shortcut for Scalar::Utils::blessed (Let me know of other useful rmap_??? wrappers)</p><p>Think about permitting different callback for different types. The prototype syntax is a bit too flaky....</p><p>Ensure that no memory leaks are possible, leaking the closure.</p><p>Read http://www.cs.vu.nl/boilerplate/</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Data::Rmap&hellip;</h2>
        <div class="sectioncontent">
<p>map, grep, Storable's dclone, Scalar::Util's reftype and blessed</p><p>Faint traces of treemap:</p><p> http://www.perlmonks.org/index.pl?node_id=60829</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Brad Bowman &lt;rmap@bereft.net&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LICENCE AND COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright (c) 2004-2008 Brad Bowman (&lt;rmap@bereft.net&gt;). All rights reserved.</p><p>This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself. See perlartistic and perlgpl.</p><p>This program is distributed in the hope that it will be useful, but \s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of \s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Data::Report::Base.3pm.html"><span aria-hidden="true">&larr;</span> Data::Report::Base.3pm: Base class for reporter plugins</a></li>
   <li class="next"><a href="Data::Sorting.3pm.html">Data::Sorting.3pm: Multi-key sort using function results <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

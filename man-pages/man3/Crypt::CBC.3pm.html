<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Crypt::CBC: Encrypt data with cipher block chaining mode</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Encrypt data with cipher block chaining mode">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Crypt::CBC (3pm) manual">
  <meta name="twitter:description" content="Encrypt data with cipher block chaining mode">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcrypt-cbc-perl-Crypt::CBC-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Crypt::CBC.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Crypt::CBC (3pm) manual" />
  <meta property="og:description" content="Encrypt data with cipher block chaining mode" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcrypt-cbc-perl-Crypt::CBC-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Crypt::CBC<small> (3pm)</small></h1>
        <p class="lead">Encrypt data with cipher block chaining mode</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Crypt::CBC.3pm.html">
      <span itemprop="name">Crypt::CBC: Encrypt data with cipher block chaining mode</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcrypt-cbc-perl/">
      <span itemprop="name">libcrypt-cbc-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Crypt::CBC.3pm.html">
      <span itemprop="name">Crypt::CBC: Encrypt data with cipher block chaining mode</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  use Crypt::CBC;
  $cipher = Crypt::CBC-&gt;new( -key    =&gt; &apos;my secret key&apos;,
                             -cipher =&gt; &apos;Blowfish&apos;
                            );

  $ciphertext = $cipher-&gt;encrypt("This data is hush hush");
  $plaintext  = $cipher-&gt;decrypt($ciphertext);

  $cipher-&gt;start(&apos;encrypting&apos;);
  open(F,"./BIG_FILE");
  while (read(F,$buffer,1024)) {
      print $cipher-&gt;crypt($buffer);
  }
  print $cipher-&gt;finish;

  # do-it-yourself mode -- specify key, initialization vector yourself
  $key    = Crypt::CBC-&gt;<strong>random_bytes</strong>(8);  # assuming a 8-byte block cipher
  $iv     = Crypt::CBC-&gt;<strong>random_bytes</strong>(8);
  $cipher = Crypt::CBC-&gt;new(-literal_key =&gt; 1,
                            -key         =&gt; $key,
                            -iv          =&gt; $iv,
                            -header      =&gt; &apos;none&apos;);

  $ciphertext = $cipher-&gt;encrypt("This data is hush hush");
  $plaintext  = $cipher-&gt;decrypt($ciphertext);

  # RANDOMIV-compatible mode
  $cipher = Crypt::CBC-&gt;new(-key         =&gt; &apos;Super Secret!&apos;
                            -header      =&gt; &apos;randomiv&apos;);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module is a Perl-only implementation of the cryptographic cipher block chaining mode (\s-1CBC\s0).  In combination with a block cipher such as \s-1DES\s0 or \s-1IDEA\s0, you can encrypt and decrypt messages of arbitrarily long length.  The encrypted messages are compatible with the encryption format used by the <strong>OpenSSL</strong> package.</p><p>To use this module, you will first create a Crypt::CBC cipher object with <em>new()</em>.  At the time of cipher creation, you specify an encryption key to use and, optionally, a block encryption algorithm.  You will then call the <em>start()</em> method to initialize the encryption or decryption process, <em>crypt()</em> to encrypt or decrypt one or more blocks of data, and lastly <em>finish()</em>, to pad and encrypt the final block.  For your convenience, you can call the <em>encrypt()</em> and <em>decrypt()</em> methods to operate on a whole data value at once.</p><h3>\fInew()\fP</h3>
<p>  $cipher = Crypt::CBC-&gt;new( -key    =&gt; &apos;my secret key&apos;,                              -cipher =&gt; &apos;Blowfish&apos;,                            );</p><p>  # or (for compatibility with versions prior to 2.13)   $cipher = Crypt::CBC-&gt;new( {                               key    =&gt; &apos;my secret key&apos;,                               cipher =&gt; &apos;Blowfish&apos;                              }                            );</p><p>  # or (for compatibility with versions prior to 2.0)   $cipher = new Crypt::CBC(&apos;my secret key&apos; =&gt; &apos;Blowfish&apos;);</p><p>The <em>new()</em> method creates a new Crypt::CBC object. It accepts a list of -argument =&gt; value pairs selected from the following list:</p><p>  Argument        Description   --------        -----------</p><p>  -key            The encryption/decryption key (required)</p><p>  -cipher         The cipher algorithm (defaults to Crypt::DES), or                      a preexisting cipher object.</p><p>  -salt           Enables OpenSSL-compatibility. If equal to a value                     of "1" then causes a random salt to be generated                     and used to derive the encryption key and IV. Other                     true values are taken to be the literal salt.</p><p>  -iv             The initialization vector (IV)</p><p>  -header         What type of header to prepend to ciphertext. One of                     &apos;salt&apos;   -- use OpenSSL-compatible salted header                     &apos;randomiv&apos; -- Randomiv-compatible "RandomIV" header                     &apos;none&apos;   -- prepend no header at all</p><p>  -padding        The padding method, one of "standard" (default),                      "space", "oneandzeroes", "rijndael_compat",                      "null", or "none" (default "standard").</p><p>  -literal_key    If true, the key provided by "key" is used directly                       for encryption/decryption.  Otherwise the actual                       key used will be a hash of the provided key.                       (default false)</p><p>  -pcbc           Whether to use the PCBC chaining algorithm rather than                     the standard CBC algorithm (default false).</p><p>  -keysize        Force the cipher keysize to the indicated number of bytes.</p><p>  -blocksize      Force the cipher blocksize to the indicated number of bytes.</p><p>  -insecure_legacy_decrypt                   Allow decryption of data encrypted using the "RandomIV" header                     produced by pre-2.17 versions of Crypt::CBC.</p><p>  -add_header     [deprecated; use -header instread]                    Whether to add the salt and IV to the header of the output                     cipher text.</p><p>  -regenerate_key [deprecated; use literal_key instead]                   Whether to use a hash of the provided key to generate                     the actual encryption key (default true)</p><p>  -prepend_iv     [deprecated; use add_header instead]                   Whether to prepend the IV to the beginning of the                     encrypted stream (default true)</p><p>Crypt::CBC requires three pieces of information to do its job. First it needs the name of the block cipher algorithm that will encrypt or decrypt the data in blocks of fixed length known as the cipher's \*(L"blocksize.\*(R" Second, it needs an encryption/decryption key to pass to the block cipher. Third, it needs an initialization vector (\s-1IV\s0) that will be used to propagate information from one encrypted block to the next. Both the key and the \s-1IV\s0 must be exactly the same length as the chosen cipher's blocksize.</p><p>Crypt::CBC can derive the key and the \s-1IV\s0 from a passphrase that you provide, or can let you specify the true key and \s-1IV\s0 manually. In addition, you have the option of embedding enough information to regenerate the \s-1IV\s0 in a short header that is emitted at the start of the encrypted stream, or outputting a headerless encryption stream. In the first case, Crypt::CBC will be able to decrypt the stream given just the original key or passphrase. In the second case, you will have to provide the original \s-1IV\s0 as well as the key/passphrase.</p><p>The <strong>-cipher</strong> option specifies which block cipher algorithm to use to encode each section of the message.  This argument is optional and will default to the quick-but-not-very-secure \s-1DES\s0 algorithm unless specified otherwise. You may use any compatible block encryption algorithm that you have installed. Currently, this includes Crypt::DES, Crypt::DES_EDE3, Crypt::IDEA, Crypt::Blowfish, Crypt::CAST5 and Crypt::Rijndael. You may refer to them using their full names (\*(L"Crypt::IDEA\*(R") or in abbreviated form (\*(L"\s-1IDEA\s0\*(R").</p><p>Instead of passing the name of a cipher class, you may pass an already-created block cipher object. This allows you to take advantage of cipher algorithms that have parameterized <em>new()</em> methods, such as Crypt::Eksblowfish:</p><p>  my $eksblowfish = Crypt::Eksblowfish-&gt;new(8,$salt,$key);   my $cbc         = Crypt::CBC-&gt;new(-cipher=&gt;$eksblowfish);</p><p>The <strong>-key</strong> argument provides either a passphrase to use to generate the encryption key, or the literal value of the block cipher key. If used in passphrase mode (which is the default), <strong>-key</strong> can be any number of characters; the actual key will be derived by passing the passphrase through a series of \s-1MD5\s0 hash operations. To take full advantage of a given block cipher, the length of the passphrase should be at least equal to the cipher's blocksize. To skip this hashing operation and specify the key directly, pass a true value to the <strong>-literal_key</strong> option. In this case, you should choose a key of length exactly equal to the cipher's key length. You should also specify the \s-1IV\s0 yourself and a -header mode of 'none'.</p><p>If you pass an existing Crypt::* object to <em>new()</em>, then the -key argument is ignored and the module will generate a warning.</p><p>The <strong>-header</strong> argument specifies what type of header, if any, to prepend to the beginning of the encrypted data stream. The header allows Crypt::CBC to regenerate the original \s-1IV\s0 and correctly decrypt the data without your having to provide the same \s-1IV\s0 used to encrypt the data. Valid values for the <strong>-header</strong> are:</p><p> "salt" -- Combine the passphrase with an 8-byte random value to            generate both the block cipher key and the IV from the            provided passphrase. The salt will be appended to the            beginning of the data stream allowing decryption to            regenerate both the key and IV given the correct passphrase.            This method is compatible with current versions of OpenSSL.</p><p> "randomiv" -- Generate the block cipher key from the passphrase, and            choose a random 8-byte value to use as the IV. The IV will            be prepended to the data stream. This method is compatible            with ciphertext produced by versions of the library prior to            2.17, but is incompatible with block ciphers that have non            8-byte block sizes, such as Rijndael. Crypt::CBC will exit            with a fatal error if you try to use this header mode with a            non 8-byte cipher.</p><p> "none"   -- Do not generate a header. To decrypt a stream encrypted            in this way, you will have to provide the original IV            manually.</p><p><strong>The \*(L"salt\*(R" header is now the default as of Crypt::CBC version 2.17. In</strong> all earlier versions \*(L"randomiv\*(R" was the default.</p><p>When using a \*(L"salt\*(R" header, you may specify your own value of the salt, by passing the desired 8-byte salt to the <strong>-salt</strong> argument. Otherwise, the module will generate a random salt for you. Crypt::CBC will generate a fatal error if you specify a salt value that isn't exactly 8 bytes long. For backward compatibility reasons, passing a value of \*(L"1\*(R" will generate a random salt, the same as if no <strong>-salt</strong> argument was provided.</p><p>The <strong>-padding</strong> argument controls how the last few bytes of the encrypted stream are dealt with when they not an exact multiple of the cipher block length. The default is \*(L"standard\*(R", the method specified in PKCS#5.</p><p>The <strong>-pcbc</strong> argument, if true, activates a modified chaining mode known as \s-1PCBC\s0. It provides better error propagation characteristics than the default \s-1CBC\s0 encryption and is required for authenticating to Kerberos4 systems (see \s-1RFC\s0 2222).</p><p>The <strong>-keysize</strong> and <strong>-blocksize</strong> arguments can be used to force the cipher's keysize and/or blocksize. This is only currently useful for the Crypt::Blowfish module, which accepts a variable length keysize. If -keysize is not specified, then Crypt::CBC will use the maximum length Blowfish key size of 56 bytes (448 bits). The Openssl library defaults to 16 byte Blowfish key sizes, so for compatibility with Openssl you may wish to set -keysize=&gt;16. There are currently no Crypt::* modules that have variable block sizes, but an option to change the block size is provided just in case.</p><p>For compatibility with earlier versions of this module, you can provide <em>new()</em> with a hashref containing key/value pairs. The key names are the same as the arguments described earlier, but without the initial hyphen.  You may also call <em>new()</em> with one or two positional arguments, in which case the first argument is taken to be the key and the second to be the optional block cipher algorithm.</p><p><strong>\s-1IMPORTANT\s0 \s-1NOTE:\s0</strong> Versions of this module prior to 2.17 were incorrectly using 8-byte IVs when generating the \*(L"randomiv\*(R" style of header, even when the chosen cipher's blocksize was greater than 8 bytes. This primarily affects the Rijndael algorithm. Such encrypted data streams were <strong>not secure</strong>. From versions 2.17 onward, Crypt::CBC will refuse to encrypt or decrypt using the \*(L"randomiv\*(R" header and non-8 byte block ciphers. To decrypt legacy data encrypted with earlier versions of the module, you can override the check using the <strong>-insecure_legacy_decrypt</strong> option. It is not possible to override encryption. Please use the default \*(L"salt\*(R" header style, or no headers at all.</p>
<h3>\fIstart()\fP</h3>
<p>   $cipher-&gt;start(&apos;encrypting&apos;);    $cipher-&gt;start(&apos;decrypting&apos;);</p><p>The <em>start()</em> method prepares the cipher for a series of encryption or decryption steps, resetting the internal state of the cipher if necessary.  You must provide a string indicating whether you wish to encrypt or decrypt.  \*(L"E\*(R" or any word that begins with an \*(L"e\*(R" indicates encryption.  \*(L"D\*(R" or any word that begins with a \*(L"d\*(R" indicates decryption.</p>
<h3>\fIcrypt()\fP</h3>
<p>   $ciphertext = $cipher-&gt;crypt($plaintext);</p><p>After calling <em>start()</em>, you should call <em>crypt()</em> as many times as necessary to encrypt the desired data.</p>
<h3>\fIfinish()\fP</h3>
<p>   $ciphertext = $cipher-&gt;finish();</p><p>The \s-1CBC\s0 algorithm must buffer data blocks internally until they are even multiples of the encryption algorithm's blocksize (typically 8 bytes).  After the last call to <em>crypt()</em> you should call <em>finish()</em>. This flushes the internal buffer and returns any leftover ciphertext.</p><p>In a typical application you will read the plaintext from a file or input stream and write the result to standard output in a loop that might look like this:</p><p>  $cipher = new Crypt::CBC(&apos;hey jude!&apos;);   $cipher-&gt;start(&apos;encrypting&apos;);   print $cipher-&gt;crypt($_) while &lt;&gt;;   print $cipher-&gt;finish();</p>
<h3>\fIencrypt()\fP</h3>
<p>  $ciphertext = $cipher-&gt;encrypt($plaintext)</p><p>This convenience function runs the entire sequence of <em>start()</em>, <em>crypt()</em> and <em>finish()</em> for you, processing the provided plaintext and returning the corresponding ciphertext.</p>
<h3>\fIdecrypt()\fP</h3>
<p>  $plaintext = $cipher-&gt;decrypt($ciphertext)</p><p>This convenience function runs the entire sequence of <em>start()</em>, <em>crypt()</em> and <em>finish()</em> for you, processing the provided ciphertext and returning the corresponding plaintext.</p>
<h3>\fIencrypt_hex()\fP, \fIdecrypt_hex()\fP</h3>
<p>  $ciphertext = $cipher-&gt;encrypt_hex($plaintext)   $plaintext  = $cipher-&gt;decrypt_hex($ciphertext)</p><p>These are convenience functions that operate on ciphertext in a hexadecimal representation.  <strong>encrypt_hex($plaintext)</strong> is exactly equivalent to <strong>unpack('H*',encrypt($plaintext))</strong>.  These functions can be useful if, for example, you wish to place the encrypted in an email message.</p>
<h3>\fIget_initialization_vector()\fP</h3>
<p>  $iv = $cipher-&gt;get_initialization_vector()</p><p>This function will return the \s-1IV\s0 used in encryption and or decryption. The \s-1IV\s0 is not guaranteed to be set when encrypting until <em>start()</em> is called, and when decrypting until <em>crypt()</em> is called the first time. Unless the \s-1IV\s0 was manually specified in the <em>new()</em> call, the \s-1IV\s0 will change with every complete encryption operation.</p>
<h3>\fIset_initialization_vector()\fP</h3>
<p>  $cipher-&gt;set_initialization_vector(&apos;76543210&apos;)</p><p>This function sets the \s-1IV\s0 used in encryption and/or decryption. This function may be useful if the \s-1IV\s0 is not contained within the ciphertext string being decrypted, or if a particular \s-1IV\s0 is desired for encryption.  Note that the \s-1IV\s0 must match the chosen cipher's blocksize bytes in length.</p>
<h3>\fIiv()\fP</h3>
<p>  $iv = $cipher-&gt;iv();   $cipher-&gt;iv($new_iv);</p><p>As above, but using a single method call.</p>
<h3>\fIkey()\fP</h3>
<p>  $key = $cipher-&gt;key();   $cipher-&gt;key($new_key);</p><p>Get or set the block cipher key used for encryption/decryption.  When encrypting, the key is not guaranteed to exist until <em>start()</em> is called, and when decrypting, the key is not guaranteed to exist until after the first call to <em>crypt()</em>. The key must match the length required by the underlying block cipher.</p><p>When salted headers are used, the block cipher key will change after each complete sequence of encryption operations.</p>
<h3>\fIsalt()\fP</h3>
<p>  $salt = $cipher-&gt;salt();   $cipher-&gt;salt($new_salt);</p><p>Get or set the salt used for deriving the encryption key and \s-1IV\s0 when in OpenSSL compatibility mode.</p>
<h3>\fIpassphrase()\fP</h3>
<p>  $passphrase = $cipher-&gt;passphrase();   $cipher-&gt;passphrase($new_passphrase);</p><p>This gets or sets the value of the <strong>key</strong> passed to <em>new()</em> when <strong>literal_key</strong> is false. Return $numbytes worth of random data. On systems that support the \*(L"/dev/urandom\*(R" device file, this data will be read from the device. Otherwise, it will be generated by repeated calls to the Perl <em>rand()</em> function.</p>
<h3>\fIcipher()\fP, \fIpadding()\fP, \fIkeysize()\fP, \fIblocksize()\fP, \fIpcbc()\fP</h3>
<p>These read-only methods return the identity of the chosen block cipher algorithm, padding method, key and block size of the chosen block cipher, and whether \s-1PCBC\s0 chaining is in effect.</p>
<h3>Padding methods</h3>
<p>Use the 'padding' option to change the padding method.</p><p>When the last block of plaintext is shorter than the block size, it must be padded. Padding methods include: \*(L"standard\*(R" (i.e., PKCS#5), \*(L"oneandzeroes\*(R", \*(L"space\*(R", \*(L"rijndael_compat\*(R", \*(L"null\*(R", and \*(L"none\*(R".</p><p>   standard: (default) Binary safe       pads with the number of bytes that should be truncated. So, if       blocksize is 8, then "0A0B0C" will be padded with "05", resulting       in "0A0B0C0505050505". If the final block is a full block of 8       bytes, then a whole block of "0808080808080808" is appended.</p><p>   oneandzeroes: Binary safe       pads with "80" followed by as many "00" necessary to fill the       block. If the last block is a full block and blocksize is 8, a       block of "8000000000000000" will be appended.</p><p>   rijndael_compat: Binary safe, with caveats       similar to oneandzeroes, except that no padding is performed if       the last block is a full block. This is provided for       compatibility with Crypt::Rijndael only and can only be used       with messages that are a multiple of the Rijndael blocksize       of 16 bytes.</p><p>   null: text only       pads with as many "00" necessary to fill the block. If the last       block is a full block and blocksize is 8, a block of       "0000000000000000" will be appended.</p><p>   space: text only       same as "null", but with "20".</p><p>   none:       no padding added. Useful for special-purpose applications where       you wish to add custom padding to the message.</p><p>Both the standard and oneandzeroes paddings are binary safe.  The space and null paddings are recommended only for text data.  Which type of padding you use depends on whether you wish to communicate with an external (non Crypt::CBC library).  If this is the case, use whatever padding method is compatible.</p><p>You can also pass in a custom padding function.  To do this, create a function that takes the arguments:</p><p>   $padded_block = function($block,$blocksize,$direction);</p><p>where $block is the current block of data, $blocksize is the size to pad it to, $direction is \*(L"e\*(R" for encrypting and \*(L"d\*(R" for decrypting, and $padded_block is the result after padding or depadding.</p><p>When encrypting, the function should always return a string of &lt;blocksize&gt; length, and when decrypting, can expect the string coming in to always be that length. See <em>_standard_padding()</em>, <em>_space_padding()</em>, <em>_null_padding()</em>, or <em>_oneandzeroes_padding()</em> in the source for examples.</p><p>Standard and oneandzeroes padding are recommended, as both space and null padding can potentially truncate more characters than they should.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>Two examples, des.pl and idea.pl can be found in the eg/ subdirectory of the Crypt-CBC distribution.  These implement command-line \s-1DES\s0 and \s-1IDEA\s0 encryption algorithms.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LIMITATIONS</h2>
        <div class="sectioncontent">
<p>The encryption and decryption process is about a tenth the speed of the equivalent SSLeay programs (compiled C).  This could be improved by implementing this module in C.  It may also be worthwhile to optimize the \s-1DES\s0 and \s-1IDEA\s0 block algorithms further.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>Please report them.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Lincoln Stein, lstein@cshl.org</p><p>This module is distributed under the \s-1ARTISTIC\s0 \s-1LICENSE\s0 using the same terms as Perl itself.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Crypt::CBC&hellip;</h2>
        <div class="sectioncontent">
<p><em>perl</em>\|(1), <em>Crypt::DES</em>\|(3), <em>Crypt::IDEA</em>\|(3), rfc2898 (PKCS#5)</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Courier::Message.3pm.html"><span aria-hidden="true">&larr;</span> Courier::Message.3pm: Class implementing an interface to a mail message in the courier mta's message queue.</a></li>
   <li class="next"><a href="Crypt::CipherSaber.3pm.html">Crypt::CipherSaber.3pm: Perl module implementing ciphersaber encryption. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

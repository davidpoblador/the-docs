<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Object::Pluggable: A base class for creating plugin-enabled objects</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="A base class for creating plugin-enabled objects">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Object::Pluggable (3pm) manual">
  <meta name="twitter:description" content="A base class for creating plugin-enabled objects">
  <meta name="twitter:image" content="https://www.carta.tech/images/libobject-pluggable-perl-Object::Pluggable-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Object::Pluggable.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Object::Pluggable (3pm) manual" />
  <meta property="og:description" content="A base class for creating plugin-enabled objects" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libobject-pluggable-perl-Object::Pluggable-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Object::Pluggable<small> (3pm)</small></h1>
        <p class="lead">A base class for creating plugin-enabled objects</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Object::Pluggable.3pm.html">
      <span itemprop="name">Object::Pluggable: A base class for creating plugin-enabled objects</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libobject-pluggable-perl/">
      <span itemprop="name">libobject-pluggable-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Object::Pluggable.3pm.html">
      <span itemprop="name">Object::Pluggable: A base class for creating plugin-enabled objects</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
 # A simple POE Component that sends ping events to registered sessions
 # and plugins every second.

 {
     package SimplePoCo;

     use strict;
     use warnings;
     use base qw(Object::Pluggable);
     use POE;
     use Object::Pluggable::Constants qw(:ALL);

     sub spawn {
         my ($package, %opts) = @_;
         my $self = bless &#92;%opts, $package;

         $self-&gt;_pluggable_init(
             prefix =&gt; &apos;simplepoco_&apos;,
             types  =&gt; [qw(EXAMPLE)],
             debug  =&gt; 1,
         );

         POE::Session-&gt;create(
             object_states =&gt; [
                 $self =&gt; { shutdown =&gt; &apos;_shutdown&apos; },
                 $self =&gt; [qw(_send_ping _start register unregister _\|_send_event)],
             ],
         );

         return $self;
     }

     sub shutdown {
         my ($self) = @_;
         $poe_kernel-&gt;post($self-&gt;{session_id}, &apos;shutdown&apos;);
     }

     sub _pluggable_event {
         my ($self) = @_;
         $poe_kernel-&gt;post($self-&gt;{session_id}, &apos;_\|_send_event&apos;, @_);
     }

     sub _start {
         my ($kernel, $self) = @_[KERNEL, OBJECT];
         $self-&gt;{session_id} = $_[SESSION]-&gt;ID();

         if ($self-&gt;{alias}) {
             $kernel-&gt;alias_set($self-&gt;{alias});
         }
         else {
             $kernel-&gt;refcount_increment($self-&gt;{session_id}, _\|_PACKAGE_\|_);
         }

         $kernel-&gt;delay(_send_ping =&gt; $self-&gt;{time} || 300);
         return;
     }

     sub _shutdown {
          my ($kernel, $self) = @_[KERNEL, OBJECT];

          $self-&gt;_pluggable_destroy();
          $kernel-&gt;alarm_remove_all();
          $kernel-&gt;alias_remove($_) for $kernel-&gt;alias_list();
          $kernel-&gt;refcount_decrement($self-&gt;{session_id}, _\|_PACKAGE_\|_) if !$self-&gt;{alias};
          $kernel-&gt;refcount_decrement($_, _\|_PACKAGE_\|_) for keys %{ $self-&gt;{sessions} };

          return;
     }

     sub register {
         my ($kernel, $sender, $self) = @_[KERNEL, SENDER, OBJECT];
         my $sender_id = $sender-&gt;ID();
         $self-&gt;{sessions}-&gt;{$sender_id}++;

         if ($self-&gt;{sessions}-&gt;{$sender_id} == 1) {
             $kernel-&gt;refcount_increment($sender_id, _\|_PACKAGE_\|_);
             $kernel-&gt;yield(_\|_send_event =&gt; &apos;simplepoco_registered&apos;, $sender_id);
         }

         return;
     }

     sub unregister {
         my ($kernel, $sender, $self) = @_[KERNEL, SENDER, OBJECT];
         my $sender_id = $sender-&gt;ID();
         my $record = delete $self-&gt;{sessions}-&gt;{$sender_id};

         if ($record) {
             $kernel-&gt;refcount_decrement($sender_id, _\|_PACKAGE_\|_);
             $kernel-&gt;yield(_\|_send_event =&gt; &apos;simplepoco_unregistered&apos;, $sender_id);
         }

         return;
     }

     sub _\|_send_event {
         my ($kernel, $self, $event, @args) = @_[KERNEL, OBJECT, ARG0..$#_];

         return 1 if $self-&gt;_pluggable_process(EXAMPLE =&gt; $event, &#92;@args) == PLUGIN_EAT_ALL;
         $kernel-&gt;post($_, $event, @args) for keys %{ $self-&gt;{sessions} };
     }

     sub _send_ping {
         my ($kernel, $self) = @_[KERNEL, OBJECT];

         $kernel-&gt;yield(_\|_send_event =&gt; &apos;simplepoco_ping&apos;, &apos;Wake up sleepy&apos;);
         $kernel-&gt;delay(_send_ping =&gt; $self-&gt;{time} || 1);
         return;
     }
 }

 {
     package SimplePoCo::Plugin;
     use strict;
     use warnings;
     use Object::Pluggable::Constants qw(:ALL);

     sub new {
         my $package = shift;
         return bless { @_ }, $package;
     }

     sub plugin_register {
         my ($self, $pluggable) = splice @_, 0, 2;
         print "Plugin added&#92;n";
         $pluggable-&gt;plugin_register($self, &apos;EXAMPLE&apos;, &apos;all&apos;);
         return 1;
     }

     sub plugin_unregister {
         print "Plugin removed&#92;n";
         return 1;
     }

     sub EXAMPLE_ping {
         my ($self, $pluggable) = splice @_, 0, 2;
         my $text = ${ $_[0] };
         print "Plugin got &apos;$text&apos;&#92;n";
         return PLUGIN_EAT_NONE;
     }
 }

 use strict;
 use warnings;
 use POE;

 my $pluggable = SimplePoCo-&gt;spawn(
     alias =&gt; &apos;pluggable&apos;,
     time  =&gt; 1,
 );

 POE::Session-&gt;create(
     package_states =&gt; [
         main =&gt; [qw(_start simplepoco_registered simplepoco_ping)],
     ],
 );

 $poe_kernel-&gt;run();

 sub _start {
     my $kernel = $_[KERNEL];
     $kernel-&gt;post(pluggable =&gt; &apos;register&apos;);
     return;
 }

 sub simplepoco_registered {
     print "Main program registered for events&#92;n";
     my $plugin = SimplePoCo::Plugin-&gt;new();
     $pluggable-&gt;plugin_add(&apos;TestPlugin&apos;, $plugin);
     return;
 }

 sub simplepoco_ping {
     my ($heap, $text) = @_[HEAP, ARG0];
     print "Main program got &apos;$text&apos;&#92;n";
     $heap-&gt;{got_ping}++;
     $pluggable-&gt;shutdown() if $heap-&gt;{got_ping} == 3;
     return;
 }
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Object::Pluggable is a base class for creating plugin enabled objects. It is a generic port of POE::Component::IRC's plugin system.</p><p>If your object dispatches events to listeners, then Object::Pluggable may be a good fit for you.</p><p>Basic use would involve subclassing Object::Pluggable, then overriding \*(C`_pluggable_event()\*(C' and inserting \*(C`_pluggable_process()\*(C' wherever you dispatch events from.</p><p>Users of your object can then load plugins using the plugin methods provided to handle events generated by the object.</p><p>You may also use plugin style handlers within your object as \*(C`_pluggable_process()\*(C' will attempt to process any events with local method calls first. The return value of these handlers has the same significance as the return value of 'normal' plugin handlers.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PRIVATE METHODS</h2>
        <div class="sectioncontent">
<p>Subclassing Object::Pluggable gives your object the following 'private' methods: This should be called on your object after initialisation, but before you want to start processing plugins. It accepts a number of argument/value pairs:</p><p> &apos;types&apos;, an arrayref of the types of events that your poco will support,           OR a hashref with the event types as keys and their abbrevations           (used as plugin event method prefixes) as values. This argument is           mandatory.</p><p> &apos;prefix&apos;, the prefix for your events (default: &apos;pluggable_&apos;);  &apos;reg_prefix&apos;, the prefix for the register()/unregister() plugin methods                (default: &apos;plugin_&apos;);  &apos;debug&apos;, a boolean, if true, will cause a warning to be printed every time a           plugin call fails.</p><p>Notes: 'prefix' should probably end with a '_'. The types specify the prefixes for plugin handlers. You can specify as many different types as you require. This should be called from any shutdown handler that your poco has. The method unloads any loaded plugins. This should be called before events are dispatched to interested sessions. This gives pluggable a chance to discard events if requested to by a plugin.</p><p>The first argument is a type, as specified to \*(C`_pluggable_init()\*(C'.</p><p> sub _dispatch {      my ($self, $event, $type, @args) = @_;</p><p>     # stuff</p><p>     my $type = ...</p><p>     return 1 if $self-&gt;_pluggable_process($type, $event, &#92;@args)) == PLUGIN_EAT_ALL;</p><p>     # dispatch event to interested sessions.  }</p><p>A reference to the argument array is passed. This allows the plugin system to mangle the arguments or even add new ones. This method should be overridden in your class so that pipeline can dispatch events through your event dispatcher. Pipeline sends a prefixed 'plugin_add' and 'plugin_del' event whenever plugins are added or removed, respectively. A prefixed 'plugin_error' event will be sent if a plugin a) raises an exception, b) fails to return a true value from its register/unregister methods, or c) fails to return a valid \s-1EAT\s0 constant from a handler.</p><p> sub _pluggable_event {      my $self = shift;      $poe_kernel-&gt;post($self-&gt;{session_id}, &apos;_\|_send_event&apos;, @_);  }</p><p>There is an example of this in the \s-1SYNOPSIS\s0.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PUBLIC METHODS</h2>
        <div class="sectioncontent">
<p>Subclassing Object::Pluggable gives your object the following public methods: Returns the Object::Pluggable::Pipeline object. Accepts two arguments:</p><p> The alias for the plugin  The actual plugin object  Any number of extra arguments</p><p>The alias is there for the user to refer to it, as it is possible to have multiple plugins of the same kind active in one Object::Pluggable object.</p><p>This method goes through the pipeline's \*(C`push()\*(C' method, which will call \*(C`$plugin-&gt;plugin_register($pluggable, @args)\*(C'.</p><p>Returns the number of plugins now in the pipeline if plugin was initialized, \*(C`undef\*(C'/an empty list if not. Accepts the following arguments:</p><p> The alias for the plugin or the plugin object itself  Any number of extra arguments</p><p>This method goes through the pipeline's \*(C`remove()\*(C' method, which will call \*(C`$plugin-&gt;plugin_unregister($pluggable, @args)\*(C'.</p><p>Returns the plugin object if the plugin was removed, \*(C`undef\*(C'/an empty list if not. Accepts the following arguments:</p><p> The alias for the plugin</p><p>This method goes through the pipeline's \*(C`get()\*(C' method.</p><p>Returns the plugin object if it was found, \*(C`undef\*(C'/an empty list if not. Takes no arguments.</p><p>Returns a hashref of plugin objects, keyed on alias, or an empty list if there are no plugins loaded. Takes no arguments.</p><p>Returns an arrayref of plugin objects, in the order which they are encountered in the pipeline. Accepts the following arguments:</p><p> The plugin object  The type of the hook (the hook types are specified with _pluggable_init()&apos;s &apos;types&apos;)  The event name[s] to watch</p><p>The event names can be as many as possible, or an arrayref. They correspond to the prefixed events and naturally, arbitrary events too.</p><p>You do not need to supply events with the prefix in front of them, just the names.</p><p>It is possible to register for all events by specifying 'all' as an event.</p><p>Returns 1 if everything checked out fine, \*(C`undef\*(C'/an empty list if something is seriously wrong. Accepts the following arguments:</p><p> The plugin object  The type of the hook (the hook types are specified with _pluggable_init()&apos;s &apos;types&apos;)  The event name[s] to unwatch</p><p>The event names can be as many as possible, or an arrayref. They correspond to the prefixed events and naturally, arbitrary events too.</p><p>You do not need to supply events with the prefix in front of them, just the names.</p><p>It is possible to register for all events by specifying 'all' as an event.</p><p>Returns 1 if all the event name[s] was unregistered, undef if some was not found.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PLUGINS</h2>
        <div class="sectioncontent">
<p>The basic anatomy of a pluggable plugin is:</p><p> # Import the constants, of course you could provide your own  # constants as long as they map correctly.  use Object::Pluggable::Constants qw( :ALL );</p><p> # Our constructor  sub new {      ...  }</p><p> # Required entry point for pluggable plugins  sub plugin_register {      my($self, $pluggable) = @_;</p><p>     # Register events we are interested in      $pluggable-&gt;plugin_register($self, &apos;SERVER&apos;, qw(something whatever));</p><p>     # Return success      return 1;  }</p><p> # Required exit point for pluggable  sub plugin_unregister {      my($self, $pluggable) = @_;</p><p>     # Pluggable will automatically unregister events for the plugin</p><p>     # Do some cleanup...</p><p>     # Return success      return 1;  }</p><p> sub _default {      my($self, $pluggable, $event) = splice @_, 0, 3;</p><p>     print "Default called for $event&#92;n";</p><p>     # Return an exit code      return PLUGIN_EAT_NONE;  }</p><p>As shown in the example above, a plugin's \*(C`_default\*(C' subroutine (if present) is called if the plugin receives an event for which it has no handler.</p><p>The special exit code \s-1CONSTANTS\s0 are documented in Object::Pluggable::Constants. You could provide your own as long as the values match up, though.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TODO</h2>
        <div class="sectioncontent">
<p>Better documentation &gt;:]</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Chris 'BinGOs' Williams &lt;chris@bingosnet.co.uk&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LICENSE</h2>
        <div class="sectioncontent">
<p>Copyright \*(C`(c)\*(C' Chris Williams, Apocalypse, Hinrik O\*:rn Sigur\*(d-sson and Jeff Pinyan</p><p>This module may be used, modified, and distributed under the same terms as Perl itself. Please see the license that came with your Perl distribution for details.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">KUDOS</h2>
        <div class="sectioncontent">
<p>\s-1APOCAL\s0 for writing the original POE::Component::IRC plugin system.</p><p>japhy for writing POE::Component::IRC::Pipeline which improved on it.</p><p>All the happy chappies who have contributed to POE::Component::IRC over the years (yes, it has been years) refining and tweaking the plugin system.</p><p>The initial idea was heavily borrowed from X-Chat, \s-1BIG\s0 thanks go out to the genius that came up with the EAT_* system :)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Object::Pluggable&hellip;</h2>
        <div class="sectioncontent">
<p>POE::Component::IRC</p><p>Object::Pluggable::Pipeline</p><p>Both POE::Component::Client::NNTP and POE::Component::Server::NNTP use this module as a base, examination of their source may yield further understanding.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Object::MultiType.3pm.html"><span aria-hidden="true">&larr;</span> Object::MultiType.3pm: Perl objects as hash, array, scalar, code and glob at the same time.</a></li>
   <li class="next"><a href="Object::Pluggable::Constants.3pm.html">Object::Pluggable::Constants.3pm: Importable constants for object::pluggable <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

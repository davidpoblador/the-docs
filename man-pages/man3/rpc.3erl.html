<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>rpc: Remote procedure call services</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Remote procedure call services">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="rpc (3erl) manual">
  <meta name="twitter:description" content="Remote procedure call services">
  <meta name="twitter:image" content="https://www.carta.tech/images/erlang-manpages-rpc-3erl.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3erl/rpc.3erl.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="rpc (3erl) manual" />
  <meta property="og:description" content="Remote procedure call services" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/erlang-manpages-rpc-3erl.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">rpc<small> (3erl)</small></h1>
        <p class="lead">Remote procedure call services</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/rpc.3erl.html">
      <span itemprop="name">rpc: Remote procedure call services</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/erlang-manpages/">
      <span itemprop="name">erlang-manpages</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/rpc.3erl.html">
      <span itemprop="name">rpc: Remote procedure call services</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module contains services which are similar to remote procedure calls. It also contains broadcast facilities and parallel evaluators. A remote procedure call is a method to call a function on a remote node and collect the answer. It is used for collecting information on a remote node, or for running a function with some specific side effects on the remote node.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DATA TYPES</h2>
        <div class="sectioncontent">

<pre>
<strong>key()</strong>

</pre>
<p>As returned by <strong></strong><em>async_call/4</em>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">

<pre>
<strong></strong>
call(Node, Module, Function, Args) -&gt; Res | {badrpc, Reason}

</pre>
<p>Types:</p><p>Node = node()</p><p>Module = module()</p><p>Function = atom()</p><p>Args = [term()]</p><p>Res = Reason = term()</p><p>Evaluates <em>apply(Module, Function, Args)</em> on the node <em>Node</em> and returns the corresponding value <em>Res</em>, or <em>{badrpc, Reason}</em> if the call fails.</p>
<pre>
<strong></strong>
call(Node, Module, Function, Args, Timeout) -&gt;
<strong></strong>
        Res | {badrpc, Reason}

</pre>
<p>Types:</p><p>Node = node()</p><p>Module = module()</p><p>Function = atom()</p><p>Args = [term()]</p><p>Res = Reason = term()</p><p>Timeout = timeout()</p><p>Evaluates <em>apply(Module, Function, Args)</em> on the node <em>Node</em> and returns the corresponding value <em>Res</em>, or <em>{badrpc, Reason}</em> if the call fails. <em>Timeout</em> is a timeout value in milliseconds. If the call times out, <em>Reason</em> is <em>timeout</em>.</p><p>If the reply arrives after the call times out, no message will contaminate the caller's message queue, since this function spawns off a middleman process to act as (a void) destination for such an orphan reply. This feature also makes this function more expensive than <em>call/4</em> at the caller's end.</p>
<pre>
<strong></strong>
block_call(Node, Module, Function, Args) -&gt; Res | {badrpc, Reason}

</pre>
<p>Types:</p><p>Node = node()</p><p>Module = module()</p><p>Function = atom()</p><p>Args = [term()]</p><p>Res = Reason = term()</p><p>Like <em>call/4</em>, but the RPC server at <em>Node</em> does not create a separate process to handle the call. Thus, this function can be used if the intention of the call is to block the RPC server from any other incoming requests until the request has been handled. The function can also be used for efficiency reasons when very small fast functions are evaluated, for example BIFs that are guaranteed not to suspend.</p>
<pre>
<strong></strong>
block_call(Node, Module, Function, Args, Timeout) -&gt;
<strong></strong>
              Res | {badrpc, Reason}

</pre>
<p>Types:</p><p>Node = node()</p><p>Module = module()</p><p>Function = atom()</p><p>Args = [term()]</p><p>Res = Reason = term()</p><p>Timeout = timeout()</p><p>Like <em>block_call/4</em>, but with a timeout value in the same manner as <em>call/5</em>.</p>
<pre>
<strong></strong>
async_call(Node, Module, Function, Args) -&gt; Key

</pre>
<p>Types:</p><p>Node = node()</p><p>Module = module()</p><p>Function = atom()</p><p>Args = [term()]</p><p>Key = <strong>key()</strong></p><p>Implements <em>call streams with promises</em>, a type of RPC which does not suspend the caller until the result is finished. Instead, a key is returned which can be used at a later stage to collect the value. The key can be viewed as a promise to deliver the answer.</p><p>In this case, the key <em>Key</em> is returned, which can be used in a subsequent call to <em>yield/1</em> or <em>nb_yield/1,2</em> to retrieve the value of evaluating <em>apply(Module, Function, Args)</em> on the node <em>Node</em>.</p>
<pre>
<strong></strong>
yield(Key) -&gt; Res | {badrpc, Reason}

</pre>
<p>Types:</p><p>Key = <strong>key()</strong></p><p>Res = Reason = term()</p><p>Returns the promised answer from a previous <em>async_call/4</em>. If the answer is available, it is returned immediately. Otherwise, the calling process is suspended until the answer arrives from <em>Node</em>.</p>
<pre>
<strong></strong>
nb_yield(Key) -&gt; {value, Val} | timeout

</pre>
<p>Types:</p><p>Key = <strong>key()</strong></p><p>Val = (Res :: term()) | {badrpc, Reason :: term()}</p><p>Equivalent to <em>nb_yield(Key, 0)</em>.</p>
<pre>
<strong></strong>
nb_yield(Key, Timeout) -&gt; {value, Val} | timeout

</pre>
<p>Types:</p><p>Key = <strong>key()</strong></p><p>Timeout = timeout()</p><p>Val = (Res :: term()) | {badrpc, Reason :: term()}</p><p>This is a non-blocking version of <em>yield/1</em>. It returns the tuple <em>{value, Val}</em> when the computation has finished, or <em>timeout</em> when <em>Timeout</em> milliseconds has elapsed.</p>
<pre>
<strong></strong>
multicall(Module, Function, Args) -&gt; {ResL, BadNodes}

</pre>
<p>Types:</p><p>Module = module()</p><p>Function = atom()</p><p>Args = ResL = [term()]</p><p>BadNodes = [node()]</p><p>Equivalent to <em>multicall([node()|nodes()], Module, Function, Args, infinity)</em>.</p>
<pre>
<strong></strong>
multicall(Nodes, Module, Function, Args) -&gt; {ResL, BadNodes}

</pre>
<p>Types:</p><p>Nodes = [node()]</p><p>Module = module()</p><p>Function = atom()</p><p>Args = ResL = [term()]</p><p>BadNodes = [node()]</p><p>Equivalent to <em>multicall(Nodes, Module, Function, Args, infinity)</em>.</p>
<pre>
<strong></strong>
multicall(Module, Function, Args, Timeout) -&gt; {ResL, BadNodes}

</pre>
<p>Types:</p><p>Module = module()</p><p>Function = atom()</p><p>Args = [term()]</p><p>Timeout = timeout()</p><p>ResL = [term()]</p><p>BadNodes = [node()]</p><p>Equivalent to <em>multicall([node()|nodes()], Module, Function, Args, Timeout)</em>.</p>
<pre>
<strong></strong>
multicall(Nodes, Module, Function, Args, Timeout) -&gt;
<strong></strong>
             {ResL, BadNodes}

</pre>
<p>Types:</p><p>Nodes = [node()]</p><p>Module = module()</p><p>Function = atom()</p><p>Args = [term()]</p><p>Timeout = timeout()</p><p>ResL = [term()]</p><p>BadNodes = [node()]</p><p>In contrast to an RPC, a multicall is an RPC which is sent concurrently from one client to multiple servers. This is useful for collecting some information from a set of nodes, or for calling a function on a set of nodes to achieve some side effects. It is semantically the same as iteratively making a series of RPCs on all the nodes, but the multicall is faster as all the requests are sent at the same time and are collected one by one as they come back.</p><p>The function evaluates <em>apply(Module, Function, Args)</em> on the specified nodes and collects the answers. It returns <em>{ResL, BadNodes}</em>, where <em>BadNodes</em> is a list of the nodes that terminated or timed out during computation, and <em>ResL</em> is a list of the return values. <em>Timeout</em> is a time (integer) in milliseconds, or <em>infinity</em>.</p><p>The following example is useful when new object code is to be loaded on all nodes in the network, and also indicates some side effects RPCs may produce:</p>
<pre>
%% Find object code for module Mod
{Mod, Bin, File} = code:get_object_code(Mod),

%% and load it on all nodes including this one
{ResL, _} = rpc:multicall(code, load_binary, [Mod, File, Bin]),

%% and then maybe check the ResL list.
</pre>

<pre>
<strong></strong>
cast(Node, Module, Function, Args) -&gt; true

</pre>
<p>Types:</p><p>Node = node()</p><p>Module = module()</p><p>Function = atom()</p><p>Args = [term()]</p><p>Evaluates <em>apply(Module, Function, Args)</em> on the node <em>Node</em>. No response is delivered and the calling process is not suspended until the evaluation is complete, as is the case with <em>call/4,5</em>.</p>
<pre>
<strong></strong>
eval_everywhere(Module, Function, Args) -&gt; abcast

</pre>
<p>Types:</p><p>Module = module()</p><p>Function = atom()</p><p>Args = [term()]</p><p>Equivalent to <em>eval_everywhere([node()|nodes()], Module, Function, Args)</em>.</p>
<pre>
<strong></strong>
eval_everywhere(Nodes, Module, Function, Args) -&gt; abcast

</pre>
<p>Types:</p><p>Nodes = [node()]</p><p>Module = module()</p><p>Function = atom()</p><p>Args = [term()]</p><p>Evaluates <em>apply(Module, Function, Args)</em> on the specified nodes. No answers are collected.</p>
<pre>
<strong></strong>
abcast(Name, Msg) -&gt; abcast

</pre>
<p>Types:</p><p>Name = atom()</p><p>Msg = term()</p><p>Equivalent to <em>abcast([node()|nodes()], Name, Msg)</em>.</p>
<pre>
<strong></strong>
abcast(Nodes, Name, Msg) -&gt; abcast

</pre>
<p>Types:</p><p>Nodes = [node()]</p><p>Name = atom()</p><p>Msg = term()</p><p>Broadcasts the message <em>Msg</em> asynchronously to the registered process <em>Name</em> on the specified nodes.</p>
<pre>
<strong></strong>
sbcast(Name, Msg) -&gt; {GoodNodes, BadNodes}

</pre>
<p>Types:</p><p>Name = atom()</p><p>Msg = term()</p><p>GoodNodes = BadNodes = [node()]</p><p>Equivalent to <em>sbcast([node()|nodes()], Name, Msg)</em>.</p>
<pre>
<strong></strong>
sbcast(Nodes, Name, Msg) -&gt; {GoodNodes, BadNodes}

</pre>
<p>Types:</p><p>Name = atom()</p><p>Msg = term()</p><p>Nodes = GoodNodes = BadNodes = [node()]</p><p>Broadcasts the message <em>Msg</em> synchronously to the registered process <em>Name</em> on the specified nodes.</p><p>Returns <em>{GoodNodes, BadNodes}</em>, where <em>GoodNodes</em> is the list of nodes which have <em>Name</em> as a registered process.</p><p>The function is synchronous in the sense that it is known that all servers have received the message when the call returns. It is not possible to know that the servers have actually processed the message.</p><p>Any further messages sent to the servers, after this function has returned, will be received by all servers after this message.</p>
<pre>
<strong></strong>
server_call(Node, Name, ReplyWrapper, Msg) -&gt;
<strong></strong>
               Reply | {error, Reason}

</pre>
<p>Types:</p><p>Node = node()</p><p>Name = atom()</p><p>ReplyWrapper = Msg = Reply = term()</p><p>Reason = nodedown</p><p>This function can be used when interacting with a server called <em>Name</em> at node <em>Node</em>. It is assumed that the server receives messages in the format <em>{From, Msg}</em> and replies using <em>From ! {ReplyWrapper, Node, Reply}</em>. This function makes such a server call and ensures that the entire call is packed into an atomic transaction which either succeeds or fails. It never hangs, unless the server itself hangs.</p><p>The function returns the answer <em>Reply</em> as produced by the server <em>Name</em>, or <em>{error, Reason}</em>.</p>
<pre>
<strong></strong>
multi_server_call(Name, Msg) -&gt; {Replies, BadNodes}

</pre>
<p>Types:</p><p>Name = atom()</p><p>Msg = term()</p><p>Replies = [Reply :: term()]</p><p>BadNodes = [node()]</p><p>Equivalent to <em>multi_server_call([node()|nodes()], Name, Msg)</em>.</p>
<pre>
<strong></strong>
multi_server_call(Nodes, Name, Msg) -&gt; {Replies, BadNodes}

</pre>
<p>Types:</p><p>Nodes = [node()]</p><p>Name = atom()</p><p>Msg = term()</p><p>Replies = [Reply :: term()]</p><p>BadNodes = [node()]</p><p>This function can be used when interacting with servers called <em>Name</em> on the specified nodes. It is assumed that the servers receive messages in the format <em>{From, Msg}</em> and reply using <em>From ! {Name, Node, Reply}</em>, where <em>Node</em> is the name of the node where the server is located. The function returns <em>{Replies, BadNodes}</em>, where <em>Replies</em> is a list of all <em>Reply</em> values and <em>BadNodes</em> is a list of the nodes which did not exist, or where the server did not exist, or where the server terminated before sending any reply.</p>
<pre>
<strong></strong>
safe_multi_server_call(Name, Msg) -&gt; {Replies, BadNodes}

</pre>

<pre>
<strong></strong>
safe_multi_server_call(Nodes, Name, Msg) -&gt; {Replies, BadNodes}

</pre>
<p>Types:</p><p>Nodes = [node()]</p><p>Name = atom()</p><p>Msg = term()</p><p>Replies = [Reply :: term()]</p><p>BadNodes = [node()]</p><p><strong></strong> Warning:</p><p>This function is deprecated. Use <em>multi_server_call/2,3</em> instead.</p><p>In Erlang/OTP R6B and earlier releases, <em>multi_server_call/2,3</em> could not handle the case where the remote node exists, but there is no server called <em>Name</em>. Instead this function had to be used. In Erlang/OTP R7B and later releases, however, the functions are equivalent, except for this function being slightly slower.</p>
<pre>
<strong></strong>
parallel_eval(FuncCalls) -&gt; ResL

</pre>
<p>Types:</p><p>FuncCalls = [{Module, Function, Args}]</p><p>Module = module()</p><p>Function = atom()</p><p>Args = ResL = [term()]</p><p>For every tuple in <em>FuncCalls</em>, evaluates <em>apply(Module, Function, Args)</em> on some node in the network. Returns the list of return values, in the same order as in <em>FuncCalls</em>.</p>
<pre>
<strong></strong>
pmap(FuncSpec, ExtraArgs, List1) -&gt; List2

</pre>
<p>Types:</p><p>FuncSpec = {Module, Function}</p><p>Module = module()</p><p>Function = atom()</p><p>ExtraArgs = [term()]</p><p>List1 = [Elem :: term()]</p><p>List2 = [term()]</p><p>Evaluates <em>apply(Module, Function, [Elem|ExtraArgs])</em>, for every element <em>Elem</em> in <em>List1</em>, in parallel. Returns the list of return values, in the same order as in <em>List1</em>.</p>
<pre>
<strong></strong>
pinfo(Pid) -&gt; [{Item, Info}] | undefined

</pre>
<p>Types:</p><p>Pid = pid()</p><p>Item = atom()</p><p>Info = term()</p><p>Location transparent version of the BIF <strong></strong><em>process_info/1</em>.</p>
<pre>
<strong></strong>
pinfo(Pid, Item) -&gt; {Item, Info} | undefined | []

</pre>
<p>Types:</p><p>Pid = pid()</p><p>Item = atom()</p><p>Info = term()</p><p>Location transparent version of the BIF <strong></strong><em>process_info/2</em>.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="reltool.3erl.html"><span aria-hidden="true">&larr;</span> reltool.3erl: Main api of the reltool application</a></li>
   <li class="next"><a href="seq_trace.3erl.html">seq_trace.3erl: Sequential tracing of messages <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

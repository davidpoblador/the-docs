<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>qblog.h: The logging api provides four main parts (basics, filtering, threading & blackbox).</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The logging api provides four main parts (basics, filtering, threading & blackbox).">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="qblog.h (3) manual">
  <meta name="twitter:description" content="The logging api provides four main parts (basics, filtering, threading & blackbox).">
  <meta name="twitter:image" content="https://www.carta.tech/images/libqb-dev-qblog.h-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/qblog.h.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="qblog.h (3) manual" />
  <meta property="og:description" content="The logging api provides four main parts (basics, filtering, threading & blackbox)." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libqb-dev-qblog.h-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">qblog.h<small> (3)</small></h1>
        <p class="lead">The logging api provides four main parts (basics, filtering, threading & blackbox).</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/qblog.h.3.html">
      <span itemprop="name">qblog.h: The logging api provides four main parts (basics, filtering, threading & blackbox).</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libqb-dev/">
      <span itemprop="name">libqb-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/qblog.h.3.html">
      <span itemprop="name">qblog.h: The logging api provides four main parts (basics, filtering, threading & blackbox).</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;stdint.h&gt;</p><p>#include &lt;stdlib.h&gt;</p><p>#include &lt;stdio.h&gt;</p><p>#include &lt;stdarg.h&gt;</p><p>#include &lt;errno.h&gt;</p><p>#include &lt;syslog.h&gt;</p><p>#include &lt;string.h&gt;</p><p>#include &lt;qb/qbutil.h&gt;</p><p>#include &lt;qb/qbconfig.h&gt;</p><h3>Data Structures</h3>
<p>struct <strong>qb_log_callsite</strong></p><p><em>An instance of this structure is created in a special ELF section at every dynamic debug callsite. </em></p>
<h3>Defines</h3>
<p>#define <strong>LOG_TRACE</strong>   (LOG_DEBUG + 1)</p><p>#define <strong>QB_LOG_MAX_LEN</strong>   512</p><p>#define <strong>QB_LOG_STRERROR_MAX_LEN</strong>   128</p><p>#define <strong>QB_LOG_INIT_DATA</strong>(name)</p><p>#define <strong>QB_LOG_TAG_LIBQB_MSG_BIT</strong>   31</p><p>#define <strong>QB_LOG_TAG_LIBQB_MSG</strong>   (1 &lt;&lt; <strong>QB_LOG_TAG_LIBQB_MSG_BIT</strong>)</p><p>#define <strong>qb_logt</strong>(<strong>priority</strong>, <strong>tags</strong>, fmt, args...)</p><p><em>This is the function to generate a log message if you want to manually add tags. </em> #define <strong>qb_log</strong>(<strong>priority</strong>, fmt, args...)   <strong>qb_logt</strong>(<strong>priority</strong>, 0, fmt, ##args)</p><p><em>This is the main function to generate a log message. </em> #define <strong>qb_perror</strong>(<strong>priority</strong>, fmt, args...)</p><p><em>This is similar to perror except it goes into the logging system. </em> #define <strong>qb_enter</strong>()   <strong>qb_log</strong>(<strong>LOG_TRACE</strong>, 'ENTERING %s()', __func__)</p><p>#define <strong>qb_leave</strong>()   <strong>qb_log</strong>(<strong>LOG_TRACE</strong>, 'LEAVING %s()', __func__)</p><p>#define <strong>QB_LOG_SYSLOG</strong>   0</p><p>#define <strong>QB_LOG_STDERR</strong>   1</p><p>#define <strong>QB_LOG_BLACKBOX</strong>   2</p><p>#define <strong>QB_LOG_STDOUT</strong>   3</p><p>#define <strong>QB_LOG_TARGET_MAX</strong>   32</p>
<h3>Typedefs</h3>
<p>typedef const char *(* <strong>qb_log_tags_stringify_fn</strong> )(uint32_t <strong>tags</strong>)</p><p>typedef void(* <strong>qb_log_filter_fn</strong> )(struct <strong>qb_log_callsite</strong> *cs)</p><p>typedef void(* <strong>qb_log_logger_fn</strong> )(int32_t t, struct <strong>qb_log_callsite</strong> *cs, time_t timestamp, const char *msg)</p><p>typedef void(* <strong>qb_log_vlogger_fn</strong> )(int32_t t, struct <strong>qb_log_callsite</strong> *cs, time_t timestamp, va_list ap)</p><p>typedef void(* <strong>qb_log_close_fn</strong> )(int32_t t)</p><p>typedef void(* <strong>qb_log_reload_fn</strong> )(int32_t t)</p>
<h3>Enumerations</h3>
<p>enum <strong>qb_log_target_state</strong> { <strong>QB_LOG_STATE_UNUSED</strong> =  1, <strong>QB_LOG_STATE_DISABLED</strong> =  2, <strong>QB_LOG_STATE_ENABLED</strong> =  3 }</p><p>enum <strong>qb_log_conf</strong> { <strong>QB_LOG_CONF_ENABLED</strong>, <strong>QB_LOG_CONF_FACILITY</strong>, <strong>QB_LOG_CONF_DEBUG</strong>, <strong>QB_LOG_CONF_SIZE</strong>, <strong>QB_LOG_CONF_THREADED</strong>, <strong>QB_LOG_CONF_PRIORITY_BUMP</strong>, <strong>QB_LOG_CONF_STATE_GET</strong> }</p><p>enum <strong>qb_log_filter_type</strong> { <strong>QB_LOG_FILTER_FILE</strong>, <strong>QB_LOG_FILTER_FUNCTION</strong>, <strong>QB_LOG_FILTER_FORMAT</strong> }</p><p>enum <strong>qb_log_filter_conf</strong> { <strong>QB_LOG_FILTER_ADD</strong>, <strong>QB_LOG_FILTER_REMOVE</strong>, <strong>QB_LOG_FILTER_CLEAR_ALL</strong>, <strong>QB_LOG_TAG_SET</strong>, <strong>QB_LOG_TAG_CLEAR</strong>, <strong>QB_LOG_TAG_CLEAR_ALL</strong> }</p>
<h3>Functions</h3>
<p>struct <strong>qb_log_callsite</strong> <strong>__attribute__</strong> ((<strong>aligned</strong>(8)))</p><p>void <strong>qb_log_real_</strong> (struct <strong>qb_log_callsite</strong> *cs,...)</p><p><em>Internal function: use </em><strong>qb_log()</strong><em> or </em><strong>qb_logt()</strong><em> </em><strong></strong> void <strong>qb_log_real_va_</strong> (struct <strong>qb_log_callsite</strong> *cs, va_list ap)</p><p>void <strong>qb_log_from_external_source</strong> (const char *<strong>function</strong>, const char *<strong>filename</strong>, const char *<strong>format</strong>, uint8_t <strong>priority</strong>, uint32_t <strong>lineno</strong>, uint32_t <strong>tags</strong>,...)</p><p><em>This function is to import logs from other code (like libraries) that provide a callback with their logs. </em> struct <strong>qb_log_callsite</strong> * <strong>qb_log_callsite_get</strong> (const char *<strong>function</strong>, const char *<strong>filename</strong>, const char *<strong>format</strong>, uint8_t <strong>priority</strong>, uint32_t <strong>lineno</strong>, uint32_t <strong>tags</strong>)</p><p><em>Get or create a callsite at the give position. </em> void <strong>qb_log_from_external_source_va</strong> (const char *<strong>function</strong>, const char *<strong>filename</strong>, const char *<strong>format</strong>, uint8_t <strong>priority</strong>, uint32_t <strong>lineno</strong>, uint32_t <strong>tags</strong>, va_list ap)</p><p>void <strong>qb_log_init</strong> (const char *name, int32_t facility, uint8_t <strong>priority</strong>)</p><p><em>Init the logging system. </em> void <strong>qb_log_fini</strong> (void)</p><p><em>Logging system finalization function. </em> int32_t <strong>qb_log_callsites_register</strong> (struct <strong>qb_log_callsite</strong> *_start, struct <strong>qb_log_callsite</strong> *_stop)</p><p><em>If you are using dynamically loadable modules via dlopen() and you load them after </em><strong>qb_log_init()</strong><em> then after you load the module you will need to do the following to get the filters to work in that module. </em><strong></strong> void <strong>qb_log_callsites_dump</strong> (void)</p><p><em>Dump the callsite info to stdout. </em> int32_t <strong>qb_log_ctl</strong> (int32_t target, enum <strong>qb_log_conf</strong> conf_type, int32_t arg)</p><p><em>Main logging control function. </em> int32_t <strong>qb_log_filter_ctl</strong> (int32_t value, enum <strong>qb_log_filter_conf</strong> c, enum <strong>qb_log_filter_type</strong> type, const char *text, uint8_t low_priority)</p><p><em>This allows you modify the 'tags' and 'targets' callsite fields at runtime. </em> int32_t <strong>qb_log_filter_ctl2</strong> (int32_t value, enum <strong>qb_log_filter_conf</strong> c, enum <strong>qb_log_filter_type</strong> type, const char *text, uint8_t high_priority, uint8_t low_priority)</p><p><em>This extends </em><strong>qb_log_filter_ctl()</strong><em> by been able to provide a high_priority. </em><strong></strong> int32_t <strong>qb_log_filter_fn_set</strong> (<strong>qb_log_filter_fn</strong> fn)</p><p><em>Instead of using the </em><strong>qb_log_filter_ctl()</strong><em> functions you can apply the filters manually by defining a callback and setting the targets field using </em><strong>qb_bit_set()</strong><em> and </em><strong>qb_bit_clear()</strong><em> like the following below. </em><strong></strong> void <strong>qb_log_tags_stringify_fn_set</strong> (<strong>qb_log_tags_stringify_fn</strong> fn)</p><p><em>Set the callback to map the 'tags' bit map to a string. </em> void <strong>qb_log_format_set</strong> (int32_t t, const char *<strong>format</strong>)</p><p><em>Set the format specifiers. </em> int32_t <strong>qb_log_file_open</strong> (const char *<strong>filename</strong>)</p><p><em>Open a log file. </em> void <strong>qb_log_file_close</strong> (int32_t t)</p><p><em>Close a log file and release is resources. </em> int32_t <strong>qb_log_thread_priority_set</strong> (int32_t policy, int32_t <strong>priority</strong>)</p><p><em>When using threaded logging set the pthread policy and priority. </em> int32_t <strong>qb_log_thread_start</strong> (void)</p><p><em>Start the logging pthread. </em> ssize_t <strong>qb_log_blackbox_write_to_file</strong> (const char *<strong>filename</strong>)</p><p><em>Write the blackbox to file. </em> void <strong>qb_log_blackbox_print_from_file</strong> (const char *<strong>filename</strong>)</p><p><em>Read the blackbox for file and print it out. </em> int32_t <strong>qb_log_custom_open</strong> (<strong>qb_log_logger_fn</strong> log_fn, <strong>qb_log_close_fn</strong> close_fn, <strong>qb_log_reload_fn</strong> reload_fn, void *user_data)</p><p><em>Open a custom log target. </em> void <strong>qb_log_custom_close</strong> (int32_t t)</p><p><em>Close a custom log target and release is resources. </em> void * <strong>qb_log_target_user_data_get</strong> (int32_t t)</p><p><em>Retrieve the user data set by either qb_log_custom_open or qb_log_target_user_data_set. </em> int32_t <strong>qb_log_target_user_data_set</strong> (int32_t t, void *user_data)</p><p><em>Associate user data with this log target. </em> void <strong>qb_log_target_format</strong> (int32_t target, struct <strong>qb_log_callsite</strong> *cs, time_t timestamp, const char *formatted_message, char *output_buffer)</p><p><em>format the callsite and timestamp info according to the format set using </em><strong>qb_log_format_set()</strong><em> It is intended to be used from your custom logger function. </em><strong></strong> int32_t <strong>qb_log_facility2int</strong> (const char *fname)</p><p><em>Convert string 'auth' to equivalent number 'LOG_AUTH' etc. </em> const char * <strong>qb_log_facility2str</strong> (int32_t fnum)</p><p><em>Convert number 'LOG_AUTH' to equivalent string 'auth' etc. </em></p>
<h3>Variables</h3>
<p>const char * <strong>function</strong></p><p>const char * <strong>filename</strong></p><p>const char * <strong>format</strong></p><p>uint8_t <strong>priority</strong></p><p>uint32_t <strong>lineno</strong></p><p>uint32_t <strong>targets</strong></p><p>uint32_t <strong>tags</strong></p><p>struct <strong>qb_log_callsite</strong> <strong>__start___verbose</strong> []</p><p>struct <strong>qb_log_callsite</strong> <strong>__stop___verbose</strong> []</p><p>enum <strong>qb_log_target_state</strong> <strong>__attribute__</strong></p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>The logging API provides four main parts (basics, filtering, threading & blackbox).</p><p>The idea behind this logging system is not to be prescriptive but to provide a set of tools to help the developer achieve what they want quickly and easily.</p><p><strong>Basic logging API.</strong></p><p>Call <strong>qb_log()</strong> to generate a log message. Then to write the message somewhere meaningful call <strong>qb_log_ctl()</strong> to configure the targets.</p><p>Simplist possible use:</p>
<pre>
 main() {
        qb_log_init('simple-log', LOG_DAEMON, LOG_INFO);
        // ...
        qb_log(LOG_WARNING, 'watch out');
        // ...
        qb_log_fini();
 }

</pre>
<p><strong>Configuring log targets.</strong></p><p>A log target can by syslog, stderr, the blackbox or a text file. By default only syslog is enabled.</p><p>To enable a target do the following</p>
<pre>
        qb_log_ctl(QB_LOG_BLACKBOX, QB_LOG_CONF_ENABLED, QB_TRUE);

</pre>
<p>syslog, stderr and the blackbox are static (they don't need to be created, just enabled or disabled. However you can open multiple logfiles (32 - QB_LOG_BLACKBOX). To do this use the following code.</p>
<pre>
        mytarget = qb_log_file_open('/var/log/mylogfile');
        qb_log_ctl(mytarget, QB_LOG_CONF_ENABLED, QB_TRUE);

</pre>
<p>Once your targets are enabled/opened you can configure them as follows: Configure the size of blackbox</p>
<pre>
        qb_log_ctl(QB_LOG_BLACKBOX, QB_LOG_CONF_SIZE, 1024*10);

</pre>
<p>Make logging to file threaded:</p>
<pre>
        qb_log_ctl(mytarget, QB_LOG_CONF_THREADED, QB_TRUE);

</pre>
<p>To workaround your syslog daemon filtering all messages &gt; LOG_INFO</p>
<pre>
        qb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_PRIORITY_BUMP,
                   LOG_INFO - LOG_DEBUG);

</pre>
<p><strong>Filtering messages.</strong></p><p>To have more power over what log messages go to which target you can apply filters to the targets. What happens is the desired callsites have the correct bit set. Then when the log message is generated it gets sent to the targets based on which bit is set in the callsite's 'target' bitmap. Messages can be filtered based on the:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>filename + priority</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>function name + priority</p>
  </dd>
  <dt>
    3.
  </dt>
  <dd>
    <p>format string + priority</p>
  </dd>

</dl>
<p>So to make all logs from evil_fnunction() go to stderr do the following:</p>
<pre>
        qb_log_filter_ctl(QB_LOG_STDERR, QB_LOG_FILTER_ADD,
                          QB_LOG_FILTER_FUNCTION, 'evil_fnunction', LOG_TRACE);

</pre>
<p>So to make all logs from totem* (with a priority &lt;= LOG_INFO) go to stderr do the following:</p>
<pre>
        qb_log_filter_ctl(QB_LOG_STDERR, QB_LOG_FILTER_ADD,
                          QB_LOG_FILTER_FILE, 'totem', LOG_INFO);

</pre>
<p>So to make all logs with the substring 'ringbuffer' go to stderr do the following:</p>
<pre>
        qb_log_filter_ctl(QB_LOG_STDERR, QB_LOG_FILTER_ADD,
                          QB_LOG_FILTER_FORMAT, 'ringbuffer', LOG_TRACE);

</pre>
<p><strong>Threaded logging.</strong></p><p>To achieve non-blocking logging you can use threaded logging. So any calls to write() or syslog() will not hold up your program.</p><p>Threaded logging use:</p>
<pre>
 main() {
        qb_log_init('simple-log', LOG_DAEMON, LOG_INFO);
        qb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_THREADED, QB_TRUE);
        // ...
        daemonize();
        // call this after you fork()
        qb_log_thread_start();
        // ...
        qb_log(LOG_WARNING, 'watch out');
        // ...
        qb_log_fini();
 }

</pre>
<p><strong>A blackbox for in-field diagnosis.</strong></p><p>This stores log messages in a ringbuffer so they can be written to file if the program crashes (you will need to catch SIGSEGV). These can then be easily printed out later.</p><p><strong>Note:</strong></p><p>the blackbox is not enabled by default.</p><p>Blackbox usage:</p>
<pre>
 static void sigsegv_handler(int sig)
 {
        (void)signal (SIGSEGV, SIG_DFL);
        qb_log_blackbox_write_to_file('simple-log.fdata');
        qb_log_fini();
        raise(SIGSEGV);
 }

 main() {

        signal(SIGSEGV, sigsegv_handler);

        qb_log_init('simple-log', LOG_DAEMON, LOG_INFO);
        qb_log_filter_ctl(QB_LOG_BLACKBOX, QB_LOG_FILTER_ADD,
                          QB_LOG_FILTER_FILE, '*', LOG_DEBUG);
        qb_log_ctl(QB_LOG_BLACKBOX, QB_LOG_CONF_SIZE, 1024*10);
        qb_log_ctl(QB_LOG_BLACKBOX, QB_LOG_CONF_ENABLED, QB_TRUE);
        // ...
        qb_log(LOG_WARNING, 'watch out');
        // ...
        qb_log_fini();
 }

</pre>
<p><strong>Tagging messages.</strong></p><p>You can tag messages using the second argument to <strong>qb_logt()</strong> or by using <strong>qb_log_filter_ctl()</strong>. This can be used to add feature or sub-system information to the logs.</p>
<pre>
 const char* my_tags_stringify(uint32_t tags) {
        if (qb_bit_is_set(tags, QB_LOG_TAG_LIBQB_MSG_BIT) {
                return 'libqb';
        } else if (tags == 3) {
                return 'three';
        } else {
                return 'MAIN';
        }
 }
 main() {
        // ...
        qb_log_tags_stringify_fn_set(my_tags_stringify);
        qb_log_format_set(QB_LOG_STDERR, '[%5g] %p %b');
        // ...
        qb_logt(LOG_INFO, 3, 'hello');
        qb_logt(LOG_INFO, 0, 'hello');
 }
</pre>
<p> The code above will produce:</p>
<pre>
 [libqb] some message
 [three] info hello
 [MAIN ] info hello

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Define Documentation</h2>
        <div class="sectioncontent">
<h3>#define \fBLOG_TRACE\fP   (LOG_DEBUG + 1)</h3>

<h3>#define \fBqb_enter\fP()   \fBqb_log\fP(\fBLOG_TRACE\fP, 'ENTERING %s()', __func__)</h3>

<h3>#define \fBqb_leave\fP()   \fBqb_log\fP(\fBLOG_TRACE\fP, 'LEAVING %s()', __func__)</h3>

<h3>#define \fBqb_log\fP(\fBpriority\fP, fmt, args...)   \fBqb_logt\fP(\fBpriority\fP, 0, fmt, ##args)</h3>
<p>This is the main function to generate a log message. <strong>Parameters:</strong></p><p><em>priority</em> this takes syslog priorities.</p><p><em>fmt</em> usual printf style format specifiers</p><p><em>args</em> usual printf style args</p>
<h3>#define \fBQB_LOG_BLACKBOX\fP   2</h3>

<h3>#define \fBQB_LOG_INIT_DATA\fP(name) \fBValue:\fP</h3>

<pre>
void name(void);                                                        void name(void) { if (__start___verbose != __stop___verbose) {<strong>assert</strong>(1);} }      void __attribute__ ((constructor)) name(void);
</pre>

<h3>#define \fBQB_LOG_MAX_LEN\fP   512</h3>

<h3>#define \fBQB_LOG_STDERR\fP   1</h3>

<h3>#define \fBQB_LOG_STDOUT\fP   3</h3>

<h3>#define \fBQB_LOG_STRERROR_MAX_LEN\fP   128</h3>

<h3>#define \fBQB_LOG_SYSLOG\fP   0</h3>

<h3>#define \fBQB_LOG_TAG_LIBQB_MSG\fP   (1 &lt;&lt; \fBQB_LOG_TAG_LIBQB_MSG_BIT\fP)</h3>

<h3>#define \fBQB_LOG_TAG_LIBQB_MSG_BIT\fP   31</h3>

<h3>#define \fBQB_LOG_TARGET_MAX\fP   32</h3>

<h3>#define \fBqb_logt\fP(\fBpriority\fP, \fBtags\fP, fmt, args...) \fBValue:\fP</h3>

<pre>
do {                              static struct qb_log_callsite descriptor                                 __attribute__((section('__verbose'), <strong>aligned</strong>(8))) =                      { __func__, __FILE__, fmt, priority, __LINE__, 0, tags };                qb_log_real_(&descriptor, ##args);                                   } <strong>while</strong>(0)
</pre>
<p>This is the function to generate a log message if you want to manually add tags. <strong>Parameters:</strong></p><p><em>priority</em> this takes syslog priorities.</p><p><em>tags</em> this is a uint32_t that you can use with <strong>qb_log_tags_stringify_fn_set()</strong> to 'tag' a log message with a feature or sub-system then you can use '%g' in the format specifer to print it out.</p><p><em>fmt</em> usual printf style format specifiers</p><p><em>args</em> usual printf style args</p>
<h3>#define \fBqb_perror\fP(\fBpriority\fP, fmt, args...) \fBValue:\fP</h3>

<pre>
do {                                       char _perr_buf_[QB_LOG_STRERROR_MAX_LEN];                                const char *_perr_str_ = qb_strerror_r(errno, _perr_buf_, sizeof(_perr_buf_));           qb_logt(priority, 0, fmt ': %s (%d)', ##args, _perr_str_, errno);                    } <strong>while</strong>(0)
</pre>
<p>This is similar to perror except it goes into the logging system. <strong>Parameters:</strong></p><p><em>priority</em> this takes syslog priorities.</p><p><em>fmt</em> usual printf style format specifiers</p><p><em>args</em> usual printf style args</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Typedef Documentation</h2>
        <div class="sectioncontent">
<h3>typedef void(* \fBqb_log_close_fn\fP)(int32_t t)</h3>

<h3>typedef void(* \fBqb_log_filter_fn\fP)(struct \fBqb_log_callsite\fP *cs)</h3>

<h3>typedef void(* \fBqb_log_logger_fn\fP)(int32_t t, struct \fBqb_log_callsite\fP *cs, time_t timestamp, const char *msg)</h3>

<h3>typedef void(* \fBqb_log_reload_fn\fP)(int32_t t)</h3>

<h3>typedef const char*(* \fBqb_log_tags_stringify_fn\fP)(uint32_t \fBtags\fP)</h3>

<h3>typedef void(* \fBqb_log_vlogger_fn\fP)(int32_t t, struct \fBqb_log_callsite\fP *cs, time_t timestamp, va_list ap)</h3>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Enumeration Type Documentation</h2>
        <div class="sectioncontent">
<h3>enum \fBqb_log_conf\fP</h3>
<p><strong>Enumerator: </strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><em>QB_LOG_CONF_ENABLED </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>QB_LOG_CONF_FACILITY </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>QB_LOG_CONF_DEBUG </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>QB_LOG_CONF_SIZE </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>QB_LOG_CONF_THREADED </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>QB_LOG_CONF_PRIORITY_BUMP </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>QB_LOG_CONF_STATE_GET </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>

</dl>

<h3>enum \fBqb_log_filter_conf\fP</h3>
<p><strong>Enumerator: </strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><em>QB_LOG_FILTER_ADD </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>QB_LOG_FILTER_REMOVE </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>QB_LOG_FILTER_CLEAR_ALL </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>QB_LOG_TAG_SET </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>QB_LOG_TAG_CLEAR </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>QB_LOG_TAG_CLEAR_ALL </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>

</dl>

<h3>enum \fBqb_log_filter_type\fP</h3>
<p><strong>Enumerator: </strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><em>QB_LOG_FILTER_FILE </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>QB_LOG_FILTER_FUNCTION </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>QB_LOG_FILTER_FORMAT </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>

</dl>

<h3>enum \fBqb_log_target_state\fP</h3>
<p><strong>Enumerator: </strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><em>QB_LOG_STATE_UNUSED </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>QB_LOG_STATE_DISABLED </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <p><strong></strong><em>QB_LOG_STATE_ENABLED </em><strong></strong><em></em></p>
  </dt>
  <dd>
    
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Function Documentation</h2>
        <div class="sectioncontent">
<h3>struct \fBqb_log_callsite\fP \fB__attribute__\fP ((<strong>aligned</strong>(8)))</h3>

<h3>void \fBqb_log_blackbox_print_from_file\fP (const char *filename)</h3>
<p>Read the blackbox for file and print it out.</p>
<h3>ssize_t \fBqb_log_blackbox_write_to_file\fP (const char *filename)</h3>
<p>Write the blackbox to file.</p>
<h3>struct \fBqb_log_callsite\fP* \fBqb_log_callsite_get\fP (const char *function, const char *filename, const char *format, uint8_tpriority, uint32_tlineno, uint32_ttags)\fC [read]\fP</h3>
<p>Get or create a callsite at the give position. The result can then be passed into <strong>qb_log_real_()</strong></p><p><strong>Parameters:</strong></p><p><em>function</em> originating function name</p><p><em>filename</em> originating filename</p><p><em>format</em> format string</p><p><em>priority</em> this takes syslog priorities.</p><p><em>lineno</em> file line number</p><p><em>tags</em> the tag</p>
<h3>void \fBqb_log_callsites_dump\fP (void)</h3>
<p>Dump the callsite info to stdout.</p>
<h3>int32_t \fBqb_log_callsites_register\fP (struct \fBqb_log_callsite\fP *_start, struct \fBqb_log_callsite\fP *_stop)</h3>
<p>If you are using dynamically loadable modules via dlopen() and you load them after <strong>qb_log_init()</strong> then after you load the module you will need to do the following to get the filters to work in that module. .PP</p>
<pre>
  _start = dlsym (dl_handle, '__start___verbose');
        _stop = dlsym (dl_handle, '__stop___verbose');
        qb_log_callsites_register(_start, _stop);
</pre>

<h3>int32_t \fBqb_log_ctl\fP (int32_ttarget, enum \fBqb_log_conf\fPconf_type, int32_targ)</h3>
<p>Main logging control function. <strong>Parameters:</strong></p><p><em>target</em> QB_LOG_SYSLOG, QB_LOG_STDERR or result from <strong>qb_log_file_open()</strong></p><p><em>conf_type</em> what to configure</p><p><em>arg</em> the new value</p><p><strong>See also:</strong></p><p><strong>qb_log_conf</strong></p><p><strong>Return values:</strong></p><p><em>-errno</em> on error</p><p><em>0</em> on success</p><p><em>qb_log_target_state</em> for QB_LOG_CONF_STATE_GET</p>
<h3>void \fBqb_log_custom_close\fP (int32_tt)</h3>
<p>Close a custom log target and release is resources.</p>
<h3>int32_t \fBqb_log_custom_open\fP (\fBqb_log_logger_fn\fPlog_fn, \fBqb_log_close_fn\fPclose_fn, \fBqb_log_reload_fn\fPreload_fn, void *user_data)</h3>
<p>Open a custom log target. <strong>Return values:</strong></p><p><em>-errno</em> on error</p><p><em>3</em> to 31 (to be passed into other qb_log_* functions)</p>
<h3>int32_t \fBqb_log_facility2int\fP (const char *fname)</h3>
<p>Convert string 'auth' to equivalent number 'LOG_AUTH' etc.</p>
<h3>const char* \fBqb_log_facility2str\fP (int32_tfnum)</h3>
<p>Convert number 'LOG_AUTH' to equivalent string 'auth' etc.</p>
<h3>void \fBqb_log_file_close\fP (int32_tt)</h3>
<p>Close a log file and release is resources.</p>
<h3>int32_t \fBqb_log_file_open\fP (const char *filename)</h3>
<p>Open a log file. <strong>Return values:</strong></p><p><em>-errno</em> on error</p><p><em>3</em> to 31 (to be passed into other qb_log_* functions)</p>
<h3>int32_t \fBqb_log_filter_ctl\fP (int32_tvalue, enum \fBqb_log_filter_conf\fPc, enum \fBqb_log_filter_type\fPtype, const char *text, uint8_tlow_priority)</h3>
<p>This allows you modify the 'tags' and 'targets' callsite fields at runtime.</p>
<h3>int32_t \fBqb_log_filter_ctl2\fP (int32_tvalue, enum \fBqb_log_filter_conf\fPc, enum \fBqb_log_filter_type\fPtype, const char *text, uint8_thigh_priority, uint8_tlow_priority)</h3>
<p>This extends <strong>qb_log_filter_ctl()</strong> by been able to provide a high_priority.</p>
<h3>int32_t \fBqb_log_filter_fn_set\fP (\fBqb_log_filter_fn\fPfn)</h3>
<p>Instead of using the <strong>qb_log_filter_ctl()</strong> functions you can apply the filters manually by defining a callback and setting the targets field using <strong>qb_bit_set()</strong> and <strong>qb_bit_clear()</strong> like the following below. .PP</p>
<pre>
 static void
 m_filter(struct qb_log_callsite *cs)
 {
        if ((cs-&gt;priority &gt;= LOG_ALERT &&
             cs-&gt;priority &lt;= LOG_DEBUG) &&
             strcmp(cs-&gt;filename, 'my_c_file.c') == 0) {
                qb_bit_set(cs-&gt;targets, QB_LOG_SYSLOG);
        } else {
                qb_bit_clear(cs-&gt;targets, QB_LOG_SYSLOG);
        }
 }
</pre>

<h3>void \fBqb_log_fini\fP (void)</h3>
<p>Logging system finalization function. It releases any shared memory. Stops the logging thread if running. Flushes the last message to their destinations.</p>
<h3>void \fBqb_log_format_set\fP (int32_tt, const char *format)</h3>
<p>Set the format specifiers. n FUNCTION NAME f FILENAME l FILELINE p PRIORITY t TIMESTAMP b BUFFER g TAGS N name (passed into qb_log_init) P PID H hostname</p><p>any number between % and character specify field length to pad or chop</p>
<h3>void \fBqb_log_from_external_source\fP (const char *function, const char *filename, const char *format, uint8_tpriority, uint32_tlineno, uint32_ttags, ...)</h3>
<p>This function is to import logs from other code (like libraries) that provide a callback with their logs. <strong>Note:</strong></p><p>the performance of this will not impress you, as the filtering is done on each log message, not before hand. So try doing basic pre-filtering.</p><p><strong>Parameters:</strong></p><p><em>function</em> originating function name</p><p><em>filename</em> originating filename</p><p><em>format</em> format string</p><p><em>priority</em> this takes syslog priorities.</p><p><em>lineno</em> file line number</p><p><em>tags</em> this is a uint32_t that you can use with <strong>qb_log_tags_stringify_fn_set()</strong> to 'tag' a log message with a feature or sub-system then you can use '%g' in the format specifer to print it out.</p>
<h3>void \fBqb_log_from_external_source_va\fP (const char *function, const char *filename, const char *format, uint8_tpriority, uint32_tlineno, uint32_ttags, va_listap)</h3>

<h3>void \fBqb_log_init\fP (const char *name, int32_tfacility, uint8_tpriority)</h3>
<p>Init the logging system. <strong>Parameters:</strong></p><p><em>name</em> will be passed into openlog()</p><p><em>facility</em> default for all new targets.</p><p><em>priority</em> a basic filter with this priority will be added.</p>
<h3>void \fBqb_log_real_\fP (struct \fBqb_log_callsite\fP *cs, ...)</h3>
<p>Internal function: use <strong>qb_log()</strong> or <strong>qb_logt()</strong></p>
<h3>void \fBqb_log_real_va_\fP (struct \fBqb_log_callsite\fP *cs, va_listap)</h3>

<h3>void \fBqb_log_tags_stringify_fn_set\fP (\fBqb_log_tags_stringify_fn\fPfn)</h3>
<p>Set the callback to map the 'tags' bit map to a string.</p>
<h3>void \fBqb_log_target_format\fP (int32_ttarget, struct \fBqb_log_callsite\fP *cs, time_ttimestamp, const char *formatted_message, char *output_buffer)</h3>
<p>format the callsite and timestamp info according to the format set using <strong>qb_log_format_set()</strong> It is intended to be used from your custom logger function.</p>
<h3>void* \fBqb_log_target_user_data_get\fP (int32_tt)</h3>
<p>Retrieve the user data set by either qb_log_custom_open or qb_log_target_user_data_set.</p>
<h3>int32_t \fBqb_log_target_user_data_set\fP (int32_tt, void *user_data)</h3>
<p>Associate user data with this log target. <strong>Note:</strong></p><p>only use this with custom targets</p>
<h3>int32_t \fBqb_log_thread_priority_set\fP (int32_tpolicy, int32_tpriority)</h3>
<p>When using threaded logging set the pthread policy and priority. <strong>Return values:</strong></p><p><em>-errno</em> on error</p><p><em>0</em> success</p>
<h3>int32_t \fBqb_log_thread_start\fP (void)</h3>
<p>Start the logging pthread.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Variable Documentation</h2>
        <div class="sectioncontent">
<h3>enum \fBqb_log_target_state\fP  \fB__attribute__\fP</h3>

<h3>struct \fBqb_log_callsite\fP \fB__start___verbose\fP[]</h3>

<h3>struct \fBqb_log_callsite\fP \fB__stop___verbose\fP[]</h3>

<h3>const char* \fBfilename\fP</h3>

<h3>const char* \fBformat\fP</h3>

<h3>const char* \fBfunction\fP</h3>

<h3>uint32_t \fBlineno\fP</h3>

<h3>uint8_t \fBpriority\fP</h3>

<h3>uint32_t \fBtags\fP</h3>

<h3>uint32_t \fBtargets\fP</h3>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for libqb from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="qblist.h.3.html"><span aria-hidden="true">&larr;</span> qblist.h.3: This is a kernel style list implementation.</a></li>
   <li class="next"><a href="qbloop.h.3.html">qbloop.h.3: Main loop manages timers, jobs and polling sockets. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

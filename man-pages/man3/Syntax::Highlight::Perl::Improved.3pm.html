<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Syntax::Highlight::Perl::Improved: Highlighting of perl syntactical structures</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Highlighting of perl syntactical structures">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Syntax::Highlight::Perl::Improved (3pm) manual">
  <meta name="twitter:description" content="Highlighting of perl syntactical structures">
  <meta name="twitter:image" content="https://www.carta.tech/images/libsyntax-highlight-perl-improved-perl-Syntax::Highlight::Perl::Improved-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Syntax::Highlight::Perl::Improved.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Syntax::Highlight::Perl::Improved (3pm) manual" />
  <meta property="og:description" content="Highlighting of perl syntactical structures" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libsyntax-highlight-perl-improved-perl-Syntax::Highlight::Perl::Improved-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Syntax::Highlight::Perl::Improved<small> (3pm)</small></h1>
        <p class="lead">Highlighting of perl syntactical structures</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Syntax::Highlight::Perl::Improved.3pm.html">
      <span itemprop="name">Syntax::Highlight::Perl::Improved: Highlighting of perl syntactical structures</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libsyntax-highlight-perl-improved-perl/">
      <span itemprop="name">libsyntax-highlight-perl-improved-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Syntax::Highlight::Perl::Improved.3pm.html">
      <span itemprop="name">Syntax::Highlight::Perl::Improved: Highlighting of perl syntactical structures</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">VERSION</h2>
        <div class="sectioncontent">
<p>This file documents Syntax::Highlight::Perl::Improved version <strong>1.0</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
    # simple procedural
    use Syntax::Highlight::Perl::Improved &apos;:BASIC&apos;;  # or &apos;:FULL&apos;
</pre>
<p>    print format_string($my_string);</p><p>    # OO     use Syntax::Highlight::Perl::Improved;</p><p>    my $formatter = new Syntax::Highlight::Perl::Improved;     print $formatter-&gt;format_string($my_string);</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module provides syntax highlighting for Perl code.  The design bias is roughly line-oriented and streamed (ie, processing a file line-by-line in a single pass).  Provisions <em>may</em> be made in the future for tasks related to \*(L"back-tracking\*(R" (ie, re-doing a single line in the middle of a stream) such as speeding up state copying.</p><p><strong>&#92;$1</strong></p><p>The only constructor provided is \*(C`new()\*(C'.  When called on an existing object, \*(C`new()\*(C' will create a new <em></em><strong>copy</strong><em></em> of that object.  Otherwise, \*(C`new()\*(C' creates a new copy of the (internal) <em>Default Object</em>.  Note that the use of the procedural syntax modifies the <em>Default Object</em> and that those changes <em>will</em> be reflected in any subsequent \*(C`new()\*(C' calls. Formatting is done using the \*(C`format_string()\*(C' method.  Call \*(C`format_string()\*(C' with one or more strings to format, or it will default to using $_. You can set the text used for formatting a syntax element using \*(C`set_format()\*(C' (or set the start and end format individually using \*(C`set_start_format()\*(C' and \*(C`set_end_format()\*(C', respectively). You can also retrieve the text used for formatting for an element via \*(C`get_start_format()\*(C' or \*(C`get_end_format\*(C'.  Bulk retrieval of the names or values of defined formats is possible via \*(C`get_format_names_list()\*(C' (names), \*(C`get_start_format_values_list()\*(C' and \*(C`get_end_format_values_list()\*(C'. See \*(L"\s-1FORMAT\s0 \s-1TYPES\s0\*(R" later in this document for information on what format elements can be used. You can check certain aspects of the state of the formatter via the methods: \*(C`in_heredoc()\*(C', \*(C`in_string()\*(C', \*(C`in_pod()\*(C', \*(C`was_pod()\*(C', \*(C`in_data()\*(C', and \*(C`line_count()\*(C'. You can reset all of the above states (and a few other internal ones) using \*(C`reset()\*(C'. You can set or check the stability of formatting via \*(C`unstable()\*(C'. In unstable (\s-1TRUE\s0) mode, formatting is not considered to be persistent with nested formats. Or, put another way, when unstable, the formatter can only \*(L"remember\*(R" one format at a time and must reinstate formatting for each token.  An example of unstable formatting is using \s-1ANSI\s0 color escape sequences in a terminal. In stable (\s-1FALSE\s0) mode (the default), formatting is considered persistent within arbitrarily nested formats.  Even in stable mode, however, formatting is never allowed to span multiple lines; it is always fully closed at the end of the line and reinstated at the beginning of a new line, if necessary.  This is to ensure properly balanced tags when only formatting a partial code snippet. An example of stable formatting is \s-1HTML\s0. Using \*(C`define_substitution()\*(C', you can have the formatter substitute certain strings with others, after the original string has been parsed (but before formatting is applied).  This is useful for escaping characters special to the output mode (eg, &gt; and &lt; in \s-1HTML\s0) without them affecting the way the code is parsed. You can retrieve the current substitutions (as a hash-ref) via \*(C`substitutions()\*(C'.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FORMAT TYPES</h2>
        <div class="sectioncontent">
<p>The Syntax::Highlight::Perl::Improved formatter recognizes and differentiates between many Perl syntactical elements.  Each type of syntactical element has a Format Type associated with it.  There is also a '\s-1DEFAULT\s0' type that is applied to any element who's Format Type does not have a value.</p><p>Several of the Format Types have underscores in their name.  This underscore is special, and indicates that the Format Type can be \*(L"generalized.\*(R"  This means that you can assign a value to just the first part of the Format Type name (the part before the underscore) and that value will be applied to all Format Types with the same first part.  For example, the Format Types for all types of variables begin with \*(L"Variable_\*(R".  Thus, if you assign a value to the Format Type \*(L"Variable\*(R", it will be applied to any type of variable.  Generalized Format Types take precedence over non-generalized Format Types.  So the value assigned to \*(L"Variable\*(R" would be applied to \*(L"Variable_Scalar\*(R", even if \*(L"Variable_Scalar\*(R" had a value explicitly assigned to it.</p><p>You can also define a \*(L"short-cut\*(R" name for each Format Type that can be generalized.  The short-cut name would be the part of the Format Type name after the underscore.  For example, the short-cut for \*(L"Variable_Scalar\*(R" would be \*(L"Scalar\*(R".  Short-cut names have the least precedence and are only assigned if neither the generalized Type name, nor the full Type name have values.</p><p>Following is a list of all the syntactical elements that Syntax::Highlight::Perl::Improved currently recognizes, along with a short description of what each would be applied to.</p>
<dl class='dl-vertical'>
  <dt>
    Comment_Normal
  </dt>
  <dd>
    <p>A normal Perl comment.  Starts with '#' and goes until the end of the line.</p>
  </dd>
  <dt>
    Comment_POD
  </dt>
  <dd>
    <p>Inline documentation.  Starts with a line beginning with an equal sign ('=') followed by a word (eg: '=pod') and continuing until a line beginning with '=cut'.</p>
  </dd>
  <dt>
    Directive
  </dt>
  <dd>
    <p>Either the \*(L"she-bang\*(R" line at the beginning of the file, or a line directive altering what the compiler thinks the current line and file is.</p>
  </dd>
  <dt>
    Label
  </dt>
  <dd>
    <p>A loop or statement label (to be the target of a goto, next, last or redo).</p>
  </dd>
  <dt>
    Quote
  </dt>
  <dd>
    <p>Any string or character that begins or ends a String.  Including, but not necessarily limited to: quote-like regular expression operators (\*(C`m//\*(C', \*(C`s///\*(C', \*(C`tr///\*(C', etc), a Here-Document terminating line, the lone period terminating a format, and, of course, normal quotes (\*(C`'\*(C', \*(C`"\*(C', \*(C``\*(C', \*(C`q{}\*(C', \*(C`qq{}\*(C', \*(C`qr{}\*(C', \*(C`qx{}\*(C').</p>
  </dd>
  <dt>
    String
  </dt>
  <dd>
    <p>Any text within quotes, \*(C`format\*(C's, Here-Documents, Regular Expressions, and the like.</p>
  </dd>
  <dt>
    Subroutine
  </dt>
  <dd>
    <p>The identifier used to define, identify, or call a subroutine (or method).  Note that Syntax::Highlight::Perl::Improved cannot recognize a subroutine if it is called without using parentheses or an ampersand, or methods called using the indirect object syntax.  It formats those as barewords.</p>
  </dd>
  <dt>
    Variable_Scalar
  </dt>
  <dd>
    <p>A scalar variable. Note that (theoretically) this format is not applied to non-scalar variables that are being used as scalars (ie: array or hash lookups, nor references to anything other than scalars). Syntax::Highlight::Perl::Improved figures out (or at least tries to) the actual <em>type</em> of the variable being used (by looking at how you're subscripting it) and formats it accordingly.  The first character of the variable (ie, the \*(C`$\*(C', \*(C`@\*(C', \*(C`%\*(C', or \*(C`*\*(C') tells you the type of value being used, and the color (hopefully) tells you the type of variable being used to get that value. (See \*(L"\s-1KNOWN\s0 \s-1ISSUES\s0\*(R" for information about when this doesn't work quite right.)</p>
  </dd>
  <dt>
    Variable_Array
  </dt>
  <dd>
    <p>An array variable (but not usually a slice; see above).</p>
  </dd>
  <dt>
    Variable_Hash
  </dt>
  <dd>
    <p>A hash variable.</p>
  </dd>
  <dt>
    Variable_Typeglob
  </dt>
  <dd>
    <p>A typeglob.  Note that typeglobs not beginning with an asterisk (*) (eg: filehandles) are formatted as barewords.  This is because, well, they are.</p>
  </dd>
  <dt>
    Whitespace
  </dt>
  <dd>
    <p>Whitespace.  Not usually formatted but it can be.</p>
  </dd>
  <dt>
    Character
  </dt>
  <dd>
    <p>A special, or backslash-escaped, character.  For example: \*(C`&#92;n\*(C' (newline), or \*(C`&#92;d\*(C' (digits). Only occurs within strings or regular expressions.</p>
  </dd>
  <dt>
    Keyword
  </dt>
  <dd>
    <p>A Perl keyword.  Some examples include: my, local, sub, next. Note that Perl does not make any distinction between keywords and built-in functions (at least not in the documentation).  Thus I had to make a subjective call as to what would be considered keywords and what would be built-in functions. The list of keywords can be found (and overloaded) in the variable $Syntax::Highlight::Perl::Improved::keyword_list_re as a pre-compiled regular expression.</p>
  </dd>
  <dt>
    Builtin_Function
  </dt>
  <dd>
    <p>A Perl built-in function, called as a function (ie, using parentheses). The list of built-in functions can be found (and overloaded) in the variable $Syntax::Highlight::Perl::Improved::builtin_list_re as a pre-compiled regular expression.</p>
  </dd>
  <dt>
    Builtin_Operator
  </dt>
  <dd>
    <p>A Perl built-in function, called as a list or unary operator (ie, without using parentheses). The list of built-in functions can be found (and overloaded) in the variable $Syntax::Highlight::Perl::Improved::builtin_list_re as a pre-compiled regular expression.</p>
  </dd>
  <dt>
    Operator
  </dt>
  <dd>
    <p>A Perl operator. The list of operators can be found (and overloaded) in the variable $Syntax::Highlight::Perl::Improved::operator_list_re as a pre-compiled regular expression.</p>
  </dd>
  <dt>
    Bareword
  </dt>
  <dd>
    <p>A bareword.  This can be user-defined subroutine called without parentheses, a typeglob used without an asterisk (*), or just a plain old bareword.</p>
  </dd>
  <dt>
    Package
  </dt>
  <dd>
    <p>The name of a package or pragmatic module. Note that this does not apply to the package portion of a fully qualified variable name.</p>
  </dd>
  <dt>
    Number
  </dt>
  <dd>
    <p>A numeric literal.</p>
  </dd>
  <dt>
    Symbol
  </dt>
  <dd>
    <p>A symbol (ie, non-operator punctuation).</p>
  </dd>
  <dt>
    CodeTerm
  </dt>
  <dd>
    <p>The special tokens that signal the end of executable code and the begining of the \s-1DATA\s0 section.  Specifically, '\*(C`_\|_END_\|_\*(C'' and '\*(C`_\|_DATA_\|_\*(C''.</p>
  </dd>
  <dt>
    \s-1DATA\s0
  </dt>
  <dd>
    <p>Anything in the \s-1DATA\s0 section (see \*(C`CodeTerm\*(C').</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PROCEDURAL vs. OBJECT ORIENTED</h2>
        <div class="sectioncontent">
<p>Syntax::Highlight::Perl::Improved uses \s-1OO\s0 method-calls internally (and actually defines a Default Object that is used when the functions are invoked procedurally) so you will not gain anything (efficiency-wise) by using the procedural interface.  It is just a matter of style.</p><p>It is actually recommended that you use the \s-1OO\s0 interface, as this allows you to instantiate multiple, concurrent-yet-separate formatters.  Though I cannot think of <em>why</em> you would <em>need</em> multiple formatters instantiated. :-)</p><p>One point to note: the \*(C`new()\*(C' method uses the Default Object to initialize new objects.  This means that any changes to the state of the Default Object (including Format definitions) made by using the procedural interface will be reflected in any subsequently created objects.  This can be useful in some cases (eg, call \*(C`set_format()\*(C' procedurally just before creating a batch of new objects to define default Formats for them all) but will most likely lead to trouble.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    new \s-1PACKAGE\s0
  </dt>
  <dd>
    
  </dd>
  <dt>
    new \s-1OBJECT\s0
  </dt>
  <dd>
    <p>Creates a new object.  If called on an existing object, creates a new copy of that object (which is thenceforth totally separate from the original).</p>
  </dd>
  <dt>
    reset
  </dt>
  <dd>
    <p>Resets the object's internal state.  This breaks out of strings and here-docs, ends PODs, resets the line-count, and otherwise gets the object back into a \*(L"normal\*(R" state to begin processing a new stream. Note that this does <strong></strong><strong>not</strong><strong></strong> reset any user options (including formats and format stability).</p>
  </dd>
  <dt>
    unstable \s-1EXPR\s0
  </dt>
  <dd>
    
  </dd>
  <dt>
    unstable
  </dt>
  <dd>
    <p>Returns true if the formatter is in unstable mode. If called with a non-zero number, puts the formatter into unstable formatting mode. In unstable mode, it is assumed that formatting is not persistent one token to the next and that each token must be explicitly formatted.</p>
  </dd>
  <dt>
    in_heredoc
  </dt>
  <dd>
    <p>Returns true if the next string to be formatted will be inside a Here-Document.</p>
  </dd>
  <dt>
    in_string
  </dt>
  <dd>
    <p>Returns true if the next string to be formatted will be inside a multi-line string.</p>
  </dd>
  <dt>
    in_pod
  </dt>
  <dd>
    <p>Returns true if the formatter would consider the next string passed to it as begin within a \s-1POD\s0 structure.  This is false immediately before any \s-1POD\s0 instigators (\*(C`=pod\*(C', \*(C`=head1\*(C', \*(C`=item\*(C', etc), true immediately after an instigator, throughout the \s-1POD\s0 and immediately before the \s-1POD\s0 terminator (\*(C`=cut\*(C'), and false immediately after the \s-1POD\s0 terminator.</p>
  </dd>
  <dt>
    was_pod
  </dt>
  <dd>
    <p>Returns true if the last line of the string just formatted was part of a \s-1POD\s0 structure. This includes the \*(C`/^=&#92;w+/\*(C' \s-1POD\s0 instigators and terminators.</p>
  </dd>
  <dt>
    in_data
  </dt>
  <dd>
    <p>Returns true if the next string to be formatted will be inside the \s-1DATA\s0 section (ie, follows a \*(C`_\|_DATA_\|_\*(C' or \*(C`_\|_END_\|_\*(C' tag).</p>
  </dd>
  <dt>
    line_count
  </dt>
  <dd>
    <p>Returns the number of lines processed by the formatter.</p>
  </dd>
  <dt>
    substitutions
  </dt>
  <dd>
    <p>Returns a reference to the substitution table used.  The substitution table is a hash whose keys are the strings to be replaced, and whose values are what to replace them with.</p>
  </dd>
  <dt>
    define_substitution \s-1HASH_REF\s0
  </dt>
  <dd>
    
  </dd>
  <dt>
    define_substitution \s-1LIST\s0
  </dt>
  <dd>
    <p>Allows user to define certain characters that will be substituted before formatting is done (but after they have been processed for meaning). If the first parameter is a reference to a hash, the formatter will replace it's own hash with the given one, and subsequent changes to the hash outside the formatter will be reflected. Otherwise, it will copy the arguments passed into it's own hash, and any substitutions already defined (but not in the parameter list) will be preserved. (ie, the new substitutions will be added, without destroying what was there already.)</p>
  </dd>
  <dt>
    set_start_format \s-1HASH_REF\s0
  </dt>
  <dd>
    
  </dd>
  <dt>
    set_start_format \s-1LIST\s0
  </dt>
  <dd>
    <p>Given either a list of keys/values, or a reference to a hash of keys/values, copy them into the object's Formats list.</p>
  </dd>
  <dt>
    set_end_format \s-1HASH_REF\s0
  </dt>
  <dd>
    
  </dd>
  <dt>
    set_end_format \s-1LIST\s0
  </dt>
  <dd>
    <p>Given either a list of keys/values, or a reference to a hash of keys/values, copy them into the object's Formats list.</p>
  </dd>
  <dt>
    set_format \s-1LIST\s0
  </dt>
  <dd>
    <p>Sets the formatting string for one or more formats. You should pass a list of keys/values where the keys are the format names and the values are references to arrays containing the starting and ending formatting strings (in that order) for that format.</p>
  </dd>
  <dt>
    get_start_format \s-1LIST\s0
  </dt>
  <dd>
    <p>Retrieve the string that is inserted to begin a given format type (starting format string). The names are looked for in the following order: <strong>First:</strong> Prefer the names joined by underscore, from most general to least.  For example, given (\*(L"Variable\*(R", \*(L"Scalar\*(R"): \*(L"Variable\*(R" then \*(L"Variable_Scalar\*(R". <strong>Second:</strong> Then try each name singly, in reverse order.  For example, \*(L"Scalar\*(R" then \*(L"Variable\*(R". See \*(L"\s-1FORMAT\s0 \s-1TYPES\s0\*(R" for more information.</p>
  </dd>
  <dt>
    get_end_format \s-1LIST\s0
  </dt>
  <dd>
    <p>Retrieve the string that is inserted to end a given format type (ending format string).</p>
  </dd>
  <dt>
    get_format_names_list
  </dt>
  <dd>
    <p>Returns a list of the <em>names</em> of all the Formats defined.</p>
  </dd>
  <dt>
    get_start_format_values_list
  </dt>
  <dd>
    <p>Returns a list of the <em>values</em> of all the start Formats defined (in the same order as the names returned by \*(C`get_format_names_list()\*(C').</p>
  </dd>
  <dt>
    get_end_format_values_list
  </dt>
  <dd>
    <p>Returns a list of the <em>values</em> of all the end Formats defined (in the same order as the names returned by \*(C`get_format_names_list()\*(C').</p>
  </dd>
  <dt>
    format_string \s-1LIST\s0
  </dt>
  <dd>
    <p>Formats one or more strings of Perl code.  If no strings are specified, defaults to $_. Returns the list of formatted strings (or the first string formatted if called in scalar context). <strong>Note:</strong>  The end of the string is considered to be the end of a line, regardless of whether or not there is a trailing line-break (but trailing line-breaks will <em>not</em> cause an extra, empty line). <strong>Another Note:</strong>  The function actually uses $/ to determine line-breaks, unless $/ is set to \*(C`&#92;n\*(C' (newline).  If $/ <em>is</em> \*(C`&#92;n\*(C', then it looks for the first match of \*(C`m/&#92;r?&#92;n|&#92;n?&#92;r/\*(C' in the string and uses that to determine line-breaks.  This is to make it easy to handle non-unix text.  Whatever characters it ends up using as line-breaks are preserved.</p>
  </dd>
  <dt>
    format_token \s-1TOKEN\s0, \s-1LIST\s0
  </dt>
  <dd>
    <p>Returns \s-1TOKEN\s0 wrapped in the start and end Formats corresponding to \s-1LIST\s0 (as would be returned by \*(C`get_start_format( LIST )\*(C' and \*(C`get_end_format( LIST )\*(C', respectively). No syntax checking is done on \s-1TOKEN\s0 but substitutions defined with \*(C`define_substitution()\*(C' are performed.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">KNOWN ISSUES or LIMITATIONS</h2>
        <div class="sectioncontent">
<ul>
<li><p>Barewords used as keys to a hash are formatted as strings.  This is Good.  They should not be, however, if they are not the only thing within the curly braces.  That can be fixed.</p></li><li><p>This version does not handle formats (see <em>perlform</em>\|(1)) very well.  It treats them as Here-Documents and ignores the rules for comment lines, as well as the fact that picture lines are not supposed to be interpolated.  Thus, your picture lines will look strange with the '@'s being formatted as array variables (albeit, invalid ones). Ideally, it would also treat value lines as normal Perl code and format accordingly. I think I'll get to the comment lines and non-interpolating picture lines first. If/When I do get this fixed, I will most likely add a format type of 'Format' or something, so that they can be formatted differently, if so desired.</p></li><li><p>This version does not handle Regular Expression significant characters.  It simply treats Regular Expressions as interpolated strings.</p></li><li><p>User-defined subroutines, called without parentheses, are formatted as barewords. This is because there is no way to tell them apart from barewords without parsing the code, and would require us to go as far as perl does when doing the \*(C`-c\*(C' check (ie, executing \s-1BEGIN\s0 and \s-1END\s0 blocks and the like).  That's not going to happen.</p></li><li><p>If you are indexing (subscripting) an array or hash, the formatter tries to figure out the \*(L"real\*(R" variable class by looking at how you index the variable.  However, if you do something funky (but legal in Perl) and put line-breaks or comments between the variable class character ($) and your identifier, the formatter will get confused and treat your variable as a scalar.  Until it finds the index character.  Then it will format the scalar class character ($) as a scalar and your identifier as the \*(L"correct\*(R" class.</p></li><li><p>If you put a line-break between your variable identifier and it's indexing character (see above), which is also legal in Perl, the formatter will never find it and treat your variable as a scalar.</p></li><li><p>If you put a line-break between a bareword hash-subscript and the hash variable, or between a bareword and its associated \*(C`=&gt;\*(C' operator, the bareword will not be formatted correctly (as a string).  <em>(Noticing a pattern here?)</em></p></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>Bug reports are always welcome. Email me at b&lt;davidcyl@cpan.org&gt;.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>David C.Y. Liu b&lt;davidcyl@cpan.org&gt;</p><p>based on code by Cory Johns <strong>darkness@yossman.net</strong></p><p>Copyright (c) 2004 David C.Y. Liu.  This library is free software; you can redistribute and/or modify it under the same conditions as Perl itself.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TO DO</h2>
        <div class="sectioncontent">
<p><em>Note:</em> This is Cory John's todo list, not mine. Currently none of these features are planned for the near future.</p>
<dl class='dl-vertical'>
  <dt>
    1
  </dt>
  <dd>
    <p>Improve handling of regular expressions.  Add support for regexp-special characters. Recognize the /e option to the substitution operator (maybe).</p>
  </dd>
  <dt>
    2
  </dt>
  <dd>
    <p>Improve handling of formats.  Don't treat format definitions as interpolating.  Handle format-comments.  Possibly format value lines as normal Perl code.</p>
  </dd>
  <dt>
    3
  </dt>
  <dd>
    <p>Create in-memory deep-copy routine to replace \*(C`eval(Data::Dumper)\*(C' deep-copy.</p>
  </dd>
  <dt>
    4
  </dt>
  <dd>
    <p>Generalize state transitions (\*(C`reset()\*(C' and, in the future, \*(C`copy_state()\*(C') to use non-hard-coded keys and values for state variables.  Probably will extrapolate them into an overloadable hash, and use the aforementioned deep-copy to assign them.</p>
  </dd>
  <dt>
    5
  </dt>
  <dd>
    <p>Create a method to save or copy states between objects (\*(C`copy_state()\*(C').  Would be useful for using this module in an editor.</p>
  </dd>
  <dt>
    6
  </dt>
  <dd>
    <p>Add support for greater-than-one length special characters.  Specifically, octal, hexidecimal, and control character codes.  For example, \*(C`&#92;644\*(C', \*(C`&#92;x1a4\*(C' or \*(C`&#92;c[\*(C'.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REVISIONS</h2>
        <div class="sectioncontent">
<ul>
<li><p>Added 'our' to the keywords list.</p></li><li><p>Fixed bug that prevented interpolation inside <em>qq()</em> quotes.</p></li><li><p>Renamed to Syntax::Highlight::Perl::Improved.</p></li><li><p>Fixed problem with special characters not formatting inside of Here-Documents.</p></li><li><p>Fixed bug causing hash variables to format inside of Here-Documents.</p></li><li><p>Fixed bug where quote-terminators were checked for inside of Here-Documents.</p></li><li><p>Moved token processing tests from <em>_format_line()</em> into <em>_process_token()</em> (where they should've been all along), generally making <em>_format_line()</em> more logical.  Contemplating extrapolating the tokenizing and token loop into its own subroutine to avoid all the recursive calls.</p></li><li><p>Fixed bug that caused special characters to be recognized outside of strings.</p></li><li><p>Added $VERSION variable.</p></li><li><p>Added support for different types of literal numbers: floating point, exponential notation (eg: 1.3e10), hexidecimal, and underscore-separated.</p></li><li><p>Added the \*(C`CodeTerm\*(C' and \*(C`DATA\*(C' Formats.</p></li><li><p>Added <em>was_pod()</em> and updated the documentation for <em>in_pod()</em>.</p></li><li><p>Added support for Perl formats (ie, `\*(C`format = ...\*(C'').</p></li>
</ul>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Syntax::Highlight::Engine::Simple::Perl.3pm.html"><span aria-hidden="true">&larr;</span> Syntax::Highlight::Engine::Simple::Perl.3pm: (experimental) perl code highlighting class</a></li>
   <li class="next"><a href="Sys::Statistics::Linux.3pm.html">Sys::Statistics::Linux.3pm: Front-end module to collect system statistics <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

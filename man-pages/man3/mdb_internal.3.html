<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>mdb_internal: Lmdb internals -</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Lmdb internals -">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="mdb_internal (3) manual">
  <meta name="twitter:description" content="Lmdb internals -">
  <meta name="twitter:image" content="https://www.carta.tech/images/lmdb-doc-mdb_internal-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/mdb_internal.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="mdb_internal (3) manual" />
  <meta property="og:description" content="Lmdb internals -" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/lmdb-doc-mdb_internal-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">mdb_internal<small> (3)</small></h1>
        <p class="lead">Lmdb internals -</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/mdb_internal.3.html">
      <span itemprop="name">mdb_internal: Lmdb internals -</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/lmdb-doc/">
      <span itemprop="name">lmdb-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/mdb_internal.3.html">
      <span itemprop="name">mdb_internal: Lmdb internals -</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Data Structure Documentation</h2>
        <div class="sectioncontent">

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">struct MDB_page</h2>
        <div class="sectioncontent">
<p>Common header for all page types. Overflow records occupy a number of contiguous pages with no headers on any page after the first.</p><p><strong>Data Fields</strong></p><p>union {</p>
<pre>
   <strong>pgno_t</strong> <strong>p_pgno</strong>
</pre>

<pre>
   struct <strong>MDB_page</strong> * <strong>p_next</strong>
</pre>
<p>} <strong>mp_p</strong></p><p>uint16_t <strong>mp_pad</strong></p><p>uint16_t <strong>mp_flags</strong></p><p>union {</p>
<pre>
   struct {
</pre>

<pre>
      <strong>indx_t</strong> <strong>pb_lower</strong>
</pre>

<pre>
      <strong>indx_t</strong> <strong>pb_upper</strong>
</pre>

<pre>
   } <strong>pb</strong>
</pre>

<pre>
   uint32_t <strong>pb_pages</strong>
</pre>
<p>} <strong>mp_pb</strong></p><p><strong>indx_t</strong> <strong>mp_ptrs</strong> [1]</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Field Documentation</h2>
        <div class="sectioncontent">
<h3>\fBpgno_t\fP MDB_page::p_pgno</h3>
<p>page number</p>
<h3>struct \fBMDB_page\fP* MDB_page::p_next</h3>
<p>for in-memory list of freed pages</p>
<h3>uint16_t MDB_page::mp_flags</h3>
<p><strong>Page Flags</strong></p>
<h3>\fBindx_t\fP MDB_page::pb_lower</h3>
<p>lower bound of free space</p>
<h3>\fBindx_t\fP MDB_page::pb_upper</h3>
<p>upper bound of free space</p>
<h3>uint32_t MDB_page::pb_pages</h3>
<p>number of overflow pages</p>
<h3>\fBindx_t\fP MDB_page::mp_ptrs[1]</h3>
<p>dynamic size</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">struct MDB_node</h2>
        <div class="sectioncontent">
<p>Header for a single key/data pair within a page. Used in pages of type <strong>P_BRANCH</strong> and <strong>P_LEAF</strong> without <strong>P_LEAF2</strong>. We guarantee 2-byte alignment for '<strong>MDB_node</strong>'s.</p><p><strong>Data Fields</strong></p><p>unsigned short <strong>mn_lo</strong></p><p>unsigned short <strong>mn_hi</strong></p><p>unsigned short <strong>mn_flags</strong></p><p>unsigned short <strong>mn_ksize</strong></p><p>char <strong>mn_data</strong> [1]</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Field Documentation</h2>
        <div class="sectioncontent">
<h3>unsigned short MDB_node::mn_lo</h3>
<p>lo and hi are used for data size on leaf nodes and for child pgno on branch nodes. On 64 bit platforms, flags is also used for pgno. (Branch nodes have no flags). They are in host byte order in case that lets some accesses be optimized into a 32-bit word access.</p>
<h3>unsigned short MDB_node::mn_hi</h3>
<p>part of data size or pgno</p>
<h3>unsigned short MDB_node::mn_flags</h3>
<p><strong>Node Flags</strong></p>
<h3>unsigned short MDB_node::mn_ksize</h3>
<p>key size</p>
<h3>char MDB_node::mn_data[1]</h3>
<p>key and data are appended here</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">struct MDB_db</h2>
        <div class="sectioncontent">
<p>Information about a single database in the environment.</p><p><strong>Data Fields</strong></p><p>uint32_t <strong>md_pad</strong></p><p>uint16_t <strong>md_flags</strong></p><p>uint16_t <strong>md_depth</strong></p><p><strong>pgno_t</strong> <strong>md_branch_pages</strong></p><p><strong>pgno_t</strong> <strong>md_leaf_pages</strong></p><p><strong>pgno_t</strong> <strong>md_overflow_pages</strong></p><p>size_t <strong>md_entries</strong></p><p><strong>pgno_t</strong> <strong>md_root</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Field Documentation</h2>
        <div class="sectioncontent">
<h3>uint32_t MDB_db::md_pad</h3>
<p>also ksize for LEAF2 pages</p>
<h3>uint16_t MDB_db::md_flags</h3>
<p><strong>Database Flags</strong></p>
<h3>uint16_t MDB_db::md_depth</h3>
<p>depth of this tree</p>
<h3>\fBpgno_t\fP MDB_db::md_branch_pages</h3>
<p>number of internal pages</p>
<h3>\fBpgno_t\fP MDB_db::md_leaf_pages</h3>
<p>number of leaf pages</p>
<h3>\fBpgno_t\fP MDB_db::md_overflow_pages</h3>
<p>number of overflow pages</p>
<h3>size_t MDB_db::md_entries</h3>
<p>number of data items</p>
<h3>\fBpgno_t\fP MDB_db::md_root</h3>
<p>the root page of this tree</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">struct MDB_meta</h2>
        <div class="sectioncontent">
<p>Meta page content. A meta page is the start point for accessing a database snapshot. Pages 0-1 are meta pages. Transaction N writes meta page #(N % 2).</p><p><strong>Data Fields</strong></p><p>uint32_t <strong>mm_magic</strong></p><p>uint32_t <strong>mm_version</strong></p><p>void * <strong>mm_address</strong></p><p>size_t <strong>mm_mapsize</strong></p><p><strong>MDB_db</strong> <strong>mm_dbs</strong> [2]</p><p><strong>pgno_t</strong> <strong>mm_last_pg</strong></p><p><strong>txnid_t</strong> <strong>mm_txnid</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Field Documentation</h2>
        <div class="sectioncontent">
<h3>uint32_t MDB_meta::mm_magic</h3>
<p>Stamp identifying this as an LMDB file. It must be set to <strong>MDB_MAGIC</strong>.</p>
<h3>uint32_t MDB_meta::mm_version</h3>
<p>Version number of this lock file. Must be set to <strong>MDB_DATA_VERSION</strong>.</p>
<h3>void* MDB_meta::mm_address</h3>
<p>address for fixed mapping</p>
<h3>size_t MDB_meta::mm_mapsize</h3>
<p>size of mmap region</p>
<h3>\fBMDB_db\fP MDB_meta::mm_dbs[2]</h3>
<p>first is free space, 2nd is main db</p>
<h3>\fBpgno_t\fP MDB_meta::mm_last_pg</h3>
<p>last used page in file</p>
<h3>\fBtxnid_t\fP MDB_meta::mm_txnid</h3>
<p>txnid that committed this page</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">union MDB_metabuf</h2>
        <div class="sectioncontent">
<p>Buffer for a stack-allocated meta page. The members define size and alignment, and silence type aliasing warnings. They are not used directly; that could mean incorrectly using several union members in parallel.</p><p><strong>Data Fields</strong></p><p><strong>MDB_page</strong> <strong>mb_page</strong></p><p>struct {</p>
<pre>
   char <strong>mm_pad</strong> [<strong>PAGEHDRSZ</strong>]
</pre>

<pre>
   <strong>MDB_meta</strong> <strong>mm_meta</strong>
</pre>
<p>} <strong>mb_metabuf</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">struct MDB_dbx</h2>
        <div class="sectioncontent">
<p>Auxiliary DB info. The information here is mostly static/read-only. There is only a single copy of this record in the environment.</p><p><strong>Data Fields</strong></p><p><strong>MDB_val</strong> <strong>md_name</strong></p><p><strong>MDB_cmp_func</strong> * <strong>md_cmp</strong></p><p><strong>MDB_cmp_func</strong> * <strong>md_dcmp</strong></p><p><strong>MDB_rel_func</strong> * <strong>md_rel</strong></p><p>void * <strong>md_relctx</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Field Documentation</h2>
        <div class="sectioncontent">
<h3>\fBMDB_val\fP MDB_dbx::md_name</h3>
<p>name of the database</p>
<h3>\fBMDB_cmp_func\fP* MDB_dbx::md_cmp</h3>
<p>function for comparing keys</p>
<h3>\fBMDB_cmp_func\fP* MDB_dbx::md_dcmp</h3>
<p>function for comparing data items</p>
<h3>\fBMDB_rel_func\fP* MDB_dbx::md_rel</h3>
<p>user relocate function</p>
<h3>void* MDB_dbx::md_relctx</h3>
<p>user-provided context for md_rel</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">struct MDB_txn</h2>
        <div class="sectioncontent">
<p>Opaque structure for a transaction handle.</p><p>A database transaction. Every operation requires a transaction handle.</p><p>All database operations require a transaction handle. Transactions may be read-only or read-write.</p><p><strong>Data Fields</strong></p><p><strong>MDB_txn</strong> * <strong>mt_parent</strong></p><p><strong>MDB_txn</strong> * <strong>mt_child</strong></p><p><strong>pgno_t</strong> <strong>mt_next_pgno</strong></p><p><strong>txnid_t</strong> <strong>mt_txnid</strong></p><p><strong>MDB_env</strong> * <strong>mt_env</strong></p><p><strong>MDB_IDL</strong> <strong>mt_free_pgs</strong></p><p><strong>MDB_page</strong> * <strong>mt_loose_pgs</strong></p><p>int <strong>mt_loose_count</strong></p><p><strong>MDB_IDL</strong> <strong>mt_spill_pgs</strong></p><p>union {</p>
<pre>
   <strong>MDB_ID2L</strong> <strong>dirty_list</strong>
</pre>

<pre>
   <strong>MDB_reader</strong> * <strong>reader</strong>
</pre>
<p>} <strong>mt_u</strong></p><p><strong>MDB_dbx</strong> * <strong>mt_dbxs</strong></p><p><strong>MDB_db</strong> * <strong>mt_dbs</strong></p><p>unsigned int * <strong>mt_dbiseqs</strong></p><p><strong>MDB_cursor</strong> ** <strong>mt_cursors</strong></p><p>unsigned char * <strong>mt_dbflags</strong></p><p><strong>MDB_dbi</strong> <strong>mt_numdbs</strong></p><p>unsigned int <strong>mt_flags</strong></p><p>unsigned int <strong>mt_dirty_room</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Field Documentation</h2>
        <div class="sectioncontent">
<h3>\fBMDB_txn\fP* MDB_txn::mt_parent</h3>
<p>parent of a nested txn</p>
<h3>\fBMDB_txn\fP* MDB_txn::mt_child</h3>
<p>nested txn under this txn</p>
<h3>\fBpgno_t\fP MDB_txn::mt_next_pgno</h3>
<p>next unallocated page</p>
<h3>\fBtxnid_t\fP MDB_txn::mt_txnid</h3>
<p>The ID of this transaction. IDs are integers incrementing from 1. Only committed write transactions increment the ID. If a transaction aborts, the ID may be re-used by the next writer.</p>
<h3>\fBMDB_env\fP* MDB_txn::mt_env</h3>
<p>the DB environment</p>
<h3>\fBMDB_IDL\fP MDB_txn::mt_free_pgs</h3>
<p>The list of pages that became unused during this transaction.</p>
<h3>\fBMDB_page\fP* MDB_txn::mt_loose_pgs</h3>
<p>The list of loose pages that became unused and may be reused in this transaction, linked through <strong>NEXT_LOOSE_PAGE(page)</strong>.</p>
<h3>\fBMDB_IDL\fP MDB_txn::mt_spill_pgs</h3>
<p>The sorted list of dirty pages we temporarily wrote to disk because the dirty list was full. page numbers in here are shifted left by 1, deleted slots have the LSB set.</p>
<h3>\fBMDB_ID2L\fP MDB_txn::dirty_list</h3>
<p>For write txns: Modified pages. Sorted when not MDB_WRITEMAP.</p>
<h3>\fBMDB_reader\fP* MDB_txn::reader</h3>
<p>For read txns: This thread/txn's reader table slot, or NULL.</p>
<h3>\fBMDB_dbx\fP* MDB_txn::mt_dbxs</h3>
<p>Array of records for each DB known in the environment.</p>
<h3>\fBMDB_db\fP* MDB_txn::mt_dbs</h3>
<p>Array of <strong>MDB_db</strong> records for each known DB</p>
<h3>unsigned int* MDB_txn::mt_dbiseqs</h3>
<p>Array of sequence numbers for each DB handle</p>
<h3>\fBMDB_cursor\fP** MDB_txn::mt_cursors</h3>
<p>In write txns, array of cursors for each DB</p>
<h3>unsigned char* MDB_txn::mt_dbflags</h3>
<p>Array of flags for each DB</p>
<h3>\fBMDB_dbi\fP MDB_txn::mt_numdbs</h3>
<p>Number of DB records in use. This number only ever increments; we don't decrement it when individual DB handles are closed.</p>
<h3>unsigned int MDB_txn::mt_flags</h3>
<p><strong>Transaction Flags</strong></p>
<h3>unsigned int MDB_txn::mt_dirty_room</h3>
<p><strong>dirty_list</strong> room: Array size - #dirty pages visible to this txn. Includes ancestor txns' dirty pages not hidden by other txns' dirty/spilled pages. Thus commit(nested txn) has room to merge dirty_list into mt_parent after freeing hidden mt_parent pages.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">struct MDB_cursor</h2>
        <div class="sectioncontent">
<p>Opaque structure for navigating through a database.</p><p>Cursors are used for all DB operations. A cursor holds a path of (page pointer, key index) from the DB root to a position in the DB, plus other state. <strong>MDB_DUPSORT</strong> cursors include an xcursor to the current data item. Write txns track their cursors and keep them up to date when data moves. Exception: An xcursor's pointer to a <strong>P_SUBP</strong> page can be stale. (A node with <strong>F_DUPDATA</strong> but no <strong>F_SUBDATA</strong> contains a subpage).</p><p><strong>Data Fields</strong></p><p><strong>MDB_cursor</strong> * <strong>mc_next</strong></p><p><strong>MDB_cursor</strong> * <strong>mc_backup</strong></p><p>struct <strong>MDB_xcursor</strong> * <strong>mc_xcursor</strong></p><p><strong>MDB_txn</strong> * <strong>mc_txn</strong></p><p><strong>MDB_dbi</strong> <strong>mc_dbi</strong></p><p><strong>MDB_db</strong> * <strong>mc_db</strong></p><p><strong>MDB_dbx</strong> * <strong>mc_dbx</strong></p><p>unsigned char * <strong>mc_dbflag</strong></p><p>unsigned short <strong>mc_snum</strong></p><p>unsigned short <strong>mc_top</strong></p><p>unsigned int <strong>mc_flags</strong></p><p><strong>MDB_page</strong> * <strong>mc_pg</strong> [<strong>CURSOR_STACK</strong>]</p><p><strong>indx_t</strong> <strong>mc_ki</strong> [<strong>CURSOR_STACK</strong>]</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Field Documentation</h2>
        <div class="sectioncontent">
<h3>\fBMDB_cursor\fP* MDB_cursor::mc_next</h3>
<p>Next cursor on this DB in this txn</p>
<h3>\fBMDB_cursor\fP* MDB_cursor::mc_backup</h3>
<p>Backup of the original cursor if this cursor is a shadow</p>
<h3>struct \fBMDB_xcursor\fP* MDB_cursor::mc_xcursor</h3>
<p>Context used for databases with <strong>MDB_DUPSORT</strong>, otherwise NULL</p>
<h3>\fBMDB_txn\fP* MDB_cursor::mc_txn</h3>
<p>The transaction that owns this cursor</p>
<h3>\fBMDB_dbi\fP MDB_cursor::mc_dbi</h3>
<p>The database handle this cursor operates on</p>
<h3>\fBMDB_db\fP* MDB_cursor::mc_db</h3>
<p>The database record for this cursor</p>
<h3>\fBMDB_dbx\fP* MDB_cursor::mc_dbx</h3>
<p>The database auxiliary record for this cursor</p>
<h3>unsigned char* MDB_cursor::mc_dbflag</h3>
<p>The <strong>Transaction DB Flags</strong> for this database</p>
<h3>unsigned short MDB_cursor::mc_snum</h3>
<p>number of pushed pages</p>
<h3>unsigned short MDB_cursor::mc_top</h3>
<p>index of top page, normally mc_snum-1</p>
<h3>unsigned int MDB_cursor::mc_flags</h3>
<p><strong>Cursor Flags</strong></p>
<h3>\fBMDB_page\fP* MDB_cursor::mc_pg[\fBCURSOR_STACK\fP]</h3>
<p>stack of pushed pages</p>
<h3>\fBindx_t\fP MDB_cursor::mc_ki[\fBCURSOR_STACK\fP]</h3>
<p>stack of page indices</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">struct MDB_xcursor</h2>
        <div class="sectioncontent">
<p>Context for sorted-dup records. We could have gone to a fully recursive design, with arbitrarily deep nesting of sub-databases. But for now we only handle these levels - main DB, optional sub-DB, sorted-duplicate DB.</p><p><strong>Data Fields</strong></p><p><strong>MDB_cursor</strong> <strong>mx_cursor</strong></p><p><strong>MDB_db</strong> <strong>mx_db</strong></p><p><strong>MDB_dbx</strong> <strong>mx_dbx</strong></p><p>unsigned char <strong>mx_dbflag</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Field Documentation</h2>
        <div class="sectioncontent">
<h3>\fBMDB_cursor\fP MDB_xcursor::mx_cursor</h3>
<p>A sub-cursor for traversing the Dup DB</p>
<h3>\fBMDB_db\fP MDB_xcursor::mx_db</h3>
<p>The database record for this Dup DB</p>
<h3>\fBMDB_dbx\fP MDB_xcursor::mx_dbx</h3>
<p>The auxiliary DB record for this Dup DB</p>
<h3>unsigned char MDB_xcursor::mx_dbflag</h3>
<p>The <strong>Transaction DB Flags</strong> for this Dup DB</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">struct MDB_pgstate</h2>
        <div class="sectioncontent">
<p>State of FreeDB old pages, stored in the <strong>MDB_env</strong></p><p><strong>Data Fields</strong></p><p><strong>pgno_t</strong> * <strong>mf_pghead</strong></p><p><strong>txnid_t</strong> <strong>mf_pglast</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Field Documentation</h2>
        <div class="sectioncontent">
<h3>\fBpgno_t\fP* MDB_pgstate::mf_pghead</h3>
<p>Reclaimed freeDB pages, or NULL before use</p>
<h3>\fBtxnid_t\fP MDB_pgstate::mf_pglast</h3>
<p>ID of last used record, or 0 if !mf_pghead</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">struct MDB_env</h2>
        <div class="sectioncontent">
<p>Opaque structure for a database environment.</p><p>The database environment.</p><p>A DB environment supports multiple databases, all residing in the same shared-memory map.</p><p><strong>Data Fields</strong></p><p><strong>HANDLE</strong> <strong>me_fd</strong></p><p><strong>HANDLE</strong> <strong>me_lfd</strong></p><p><strong>HANDLE</strong> <strong>me_mfd</strong></p><p>uint32_t <strong>me_flags</strong></p><p>unsigned int <strong>me_psize</strong></p><p>unsigned int <strong>me_os_psize</strong></p><p>unsigned int <strong>me_maxreaders</strong></p><p>unsigned int <strong>me_numreaders</strong></p><p><strong>MDB_dbi</strong> <strong>me_numdbs</strong></p><p><strong>MDB_dbi</strong> <strong>me_maxdbs</strong></p><p>MDB_PID_T <strong>me_pid</strong></p><p>char * <strong>me_path</strong></p><p>char * <strong>me_map</strong></p><p><strong>MDB_txninfo</strong> * <strong>me_txns</strong></p><p><strong>MDB_meta</strong> * <strong>me_metas</strong> [2]</p><p>void * <strong>me_pbuf</strong></p><p><strong>MDB_txn</strong> * <strong>me_txn</strong></p><p><strong>MDB_txn</strong> * <strong>me_txn0</strong></p><p>size_t <strong>me_mapsize</strong></p><p>off_t <strong>me_size</strong></p><p><strong>pgno_t</strong> <strong>me_maxpg</strong></p><p><strong>MDB_dbx</strong> * <strong>me_dbxs</strong></p><p>uint16_t * <strong>me_dbflags</strong></p><p>unsigned int * <strong>me_dbiseqs</strong></p><p>pthread_key_t <strong>me_txkey</strong></p><p><strong>txnid_t</strong> <strong>me_pgoldest</strong></p><p><strong>MDB_pgstate</strong> <strong>me_pgstate</strong></p><p><strong>MDB_page</strong> * <strong>me_dpages</strong></p><p><strong>MDB_IDL</strong> <strong>me_free_pgs</strong></p><p><strong>MDB_ID2L</strong> <strong>me_dirty_list</strong></p><p>int <strong>me_maxfree_1pg</strong></p><p>unsigned int <strong>me_nodemax</strong></p><p>int <strong>me_live_reader</strong></p><p>void * <strong>me_userctx</strong></p><p><strong>MDB_assert_func</strong> * <strong>me_assert_func</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Field Documentation</h2>
        <div class="sectioncontent">
<h3>\fBHANDLE\fP MDB_env::me_fd</h3>
<p>The main data file</p>
<h3>\fBHANDLE\fP MDB_env::me_lfd</h3>
<p>The lock file</p>
<h3>\fBHANDLE\fP MDB_env::me_mfd</h3>
<p>just for writing the meta pages</p>
<h3>uint32_t MDB_env::me_flags</h3>
<p><strong>Environment Flags</strong></p>
<h3>unsigned int MDB_env::me_psize</h3>
<p>DB page size, inited from me_os_psize</p>
<h3>unsigned int MDB_env::me_os_psize</h3>
<p>OS page size, from <strong>GET_PAGESIZE</strong></p>
<h3>unsigned int MDB_env::me_maxreaders</h3>
<p>size of the reader table</p>
<h3>unsigned int MDB_env::me_numreaders</h3>
<p>max numreaders set by this env</p>
<h3>\fBMDB_dbi\fP MDB_env::me_numdbs</h3>
<p>number of DBs opened</p>
<h3>\fBMDB_dbi\fP MDB_env::me_maxdbs</h3>
<p>size of the DB table</p>
<h3>MDB_PID_T MDB_env::me_pid</h3>
<p>process ID of this env</p>
<h3>char* MDB_env::me_path</h3>
<p>path to the DB files</p>
<h3>char* MDB_env::me_map</h3>
<p>the memory map of the data file</p>
<h3>\fBMDB_txninfo\fP* MDB_env::me_txns</h3>
<p>the memory map of the lock file or NULL</p>
<h3>\fBMDB_meta\fP* MDB_env::me_metas[2]</h3>
<p>pointers to the two meta pages</p>
<h3>void* MDB_env::me_pbuf</h3>
<p>scratch area for DUPSORT put()</p>
<h3>\fBMDB_txn\fP* MDB_env::me_txn</h3>
<p>current write transaction</p>
<h3>\fBMDB_txn\fP* MDB_env::me_txn0</h3>
<p>prealloc'd write transaction</p>
<h3>size_t MDB_env::me_mapsize</h3>
<p>size of the data memory map</p>
<h3>off_t MDB_env::me_size</h3>
<p>current file size</p>
<h3>\fBpgno_t\fP MDB_env::me_maxpg</h3>
<p>me_mapsize / me_psize</p>
<h3>\fBMDB_dbx\fP* MDB_env::me_dbxs</h3>
<p>array of static DB info</p>
<h3>uint16_t* MDB_env::me_dbflags</h3>
<p>array of flags from <strong>MDB_db.md_flags</strong></p>
<h3>unsigned int* MDB_env::me_dbiseqs</h3>
<p>array of dbi sequence numbers</p>
<h3>pthread_key_t MDB_env::me_txkey</h3>
<p>thread-key for readers</p>
<h3>\fBtxnid_t\fP MDB_env::me_pgoldest</h3>
<p>ID of oldest reader last time we looked</p>
<h3>\fBMDB_pgstate\fP MDB_env::me_pgstate</h3>
<p>state of old pages from freeDB</p>
<h3>\fBMDB_page\fP* MDB_env::me_dpages</h3>
<p>list of malloc'd blocks for re-use</p>
<h3>\fBMDB_IDL\fP MDB_env::me_free_pgs</h3>
<p>IDL of pages that became unused in a write txn</p>
<h3>\fBMDB_ID2L\fP MDB_env::me_dirty_list</h3>
<p>ID2L of pages written during a write txn. Length MDB_IDL_UM_SIZE.</p>
<h3>int MDB_env::me_maxfree_1pg</h3>
<p>Max number of freelist items that can fit in a single overflow page</p>
<h3>unsigned int MDB_env::me_nodemax</h3>
<p>Max size of a node on a page</p>
<h3>int MDB_env::me_live_reader</h3>
<p>have liveness lock in reader table</p>
<h3>void* MDB_env::me_userctx</h3>
<p>User-settable context</p>
<h3>\fBMDB_assert_func\fP* MDB_env::me_assert_func</h3>
<p>Callback for assertion failures</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">struct MDB_ntxn</h2>
        <div class="sectioncontent">
<p>Nested transaction</p><p><strong>Data Fields</strong></p><p><strong>MDB_txn</strong> <strong>mnt_txn</strong></p><p><strong>MDB_pgstate</strong> <strong>mnt_pgstate</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Field Documentation</h2>
        <div class="sectioncontent">
<h3>\fBMDB_txn\fP MDB_ntxn::mnt_txn</h3>
<p>the transaction</p>
<h3>\fBMDB_pgstate\fP MDB_ntxn::mnt_pgstate</h3>
<p>parent transaction's saved freestate</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">struct mdb_copy</h2>
        <div class="sectioncontent">
<p>State needed for a compacting copy.</p><p><strong>Data Fields</strong></p><p>pthread_mutex_t <strong>mc_mutex</strong></p><p>pthread_cond_t <strong>mc_cond</strong></p><p>char * <strong>mc_wbuf</strong> [2]</p><p>char * <strong>mc_over</strong> [2]</p><p><strong>MDB_env</strong> * <strong>mc_env</strong></p><p><strong>MDB_txn</strong> * <strong>mc_txn</strong></p><p>int <strong>mc_wlen</strong> [2]</p><p>int <strong>mc_olen</strong> [2]</p><p><strong>pgno_t</strong> <strong>mc_next_pgno</strong></p><p><strong>HANDLE</strong> <strong>mc_fd</strong></p><p>int <strong>mc_status</strong></p><p>volatile int <strong>mc_new</strong></p><p>int <strong>mc_toggle</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Macro Definition Documentation</h2>
        <div class="sectioncontent">
<h3>#define MDB_DSYNC   O_DSYNC</h3>
<p>A flag for opening a file and requesting synchronous data writes. This is only used when writing a meta page. It's not strictly needed; we could just do a normal write and then immediately perform a flush. But if this flag is available it saves us an extra system call.</p><p><strong>Note:</strong></p><p>If O_DSYNC is undefined but exists in /usr/include, preferably set some compiler flag to get the definition. Otherwise compile with the less efficient -DMDB_DSYNC=O_SYNC.</p>
<h3>#define MDB_FDATASYNC   fdatasync</h3>
<p>Function for flushing the data of a file. Define this to fsync if fdatasync() is not supported.</p>
<h3>#define MAX_PAGESIZE   (\fBPAGEBASE\fP ? 0x10000 : 0x8000)</h3>
<p>The maximum size of a database page. It is 32k or 64k, since value-PAGEBASE must fit in <strong>MDB_page</strong>.mp_upper.</p><p>LMDB will use database pages &lt; OS pages if needed. That causes more I/O in write transactions: The OS must know (read) the whole page before writing a partial page.</p><p>Note that we don't currently support Huge pages. On Linux, regular data files cannot use Huge pages, and in general Huge pages aren't actually pageable. We rely on the OS demand-pager to read our data and page it out when memory pressure from other processes is high. So until OSs have actual paging support for Huge pages, they're not viable.</p>
<h3>#define MDB_MINKEYS   2</h3>
<p>The minimum number of keys required in a database page. Setting this to a larger value will place a smaller bound on the maximum size of a data item. Data items larger than this size will be pushed into overflow pages instead of being stored directly in the B-tree node. This value used to default to 4. With a page size of 4096 bytes that meant that any item larger than 1024 bytes would go into an overflow page. That also meant that on average 2-3KB of each overflow page was wasted space. The value cannot be lower than 2 because then there would no longer be a tree structure. With this value, items larger than 2KB will go into overflow pages, and on average only 1KB will be wasted.</p>
<h3>#define MDB_MAGIC   0xBEEFC0DE</h3>
<p>A stamp that identifies a file as an LMDB file. There's nothing special about this value other than that it is easily recognizable, and it will reflect any byte order mismatches.</p>
<h3>#define MDB_DATA_VERSION   ((\fBMDB_DEVEL\fP) ? 999 : 1)</h3>
<p>The version number for a database's datafile format.</p>
<h3>#define MDB_LOCK_VERSION   1</h3>
<p>The version number for a database's lockfile format.</p>
<h3>#define MDB_MAXKEYSIZE   ((\fBMDB_DEVEL\fP) ? 0 : 511)</h3>
<p>The max size of a key we can write, or 0 for dynamic max. Define this as 0 to compute the max from the page size. 511 is default for backwards compat: liblmdb &lt;= 0.9.10 can break when modifying a DB with keys/dupsort data bigger than its max. <strong>MDB_DEVEL</strong> sets the default to 0.</p><p>Data items in an <strong>MDB_DUPSORT</strong> database are also limited to this size, since they're actually keys of a sub-DB. Keys and <strong>MDB_DUPSORT</strong> data items must fit on a node in a regular page.</p>
<h3>#define ENV_MAXKEY(env)   (\fBMDB_MAXKEYSIZE\fP)</h3>
<p>The maximum size of a key we can write to the environment.</p>
<h3>#define MAXDATASIZE   0xffffffffUL</h3>
<p>The maximum size of a data item. We only store a 32 bit value for node sizes.</p>
<h3>#define P_INVALID   (~(\fBpgno_t\fP)0)</h3>
<p>An invalid page number. Mainly used to denote an empty tree.</p>
<h3>#define F_ISSET(w, f)   (((w) & (f)) == (f))</h3>
<p>Test if the flags <strong>f</strong> are set in a flag word <strong>w</strong>.</p>
<h3>#define EVEN(n)   (((n) + 1U) & -2) /* sign-extending -2 to match n+1U */</h3>
<p>Round <strong>n</strong> up to an even number.</p>
<h3>#define DEFAULT_MAPSIZE   1048576</h3>
<p>Default size of memory map. This is certainly too small for any actual applications. Apps should always set the size explicitly using <strong>mdb_env_set_mapsize()</strong>.</p>
<h3>#define PAGEHDRSZ   ((unsigned) offsetof(\fBMDB_page\fP, mp_ptrs))</h3>
<p>Size of the page header, excluding dynamic data at the end</p>
<h3>#define METADATA(p)   ((void *)((char *)(p) + \fBPAGEHDRSZ\fP))</h3>
<p>Address of first usable data byte in a page, after the header</p>
<h3>#define PAGEBASE   ((\fBMDB_DEVEL\fP) ? \fBPAGEHDRSZ\fP : 0)</h3>
<p>ITS#7713, change PAGEBASE to handle 65536 byte pages</p>
<h3>#define NUMKEYS(p)   (((p)-&gt;mp_lower - (\fBPAGEHDRSZ\fP-\fBPAGEBASE\fP)) &gt;&gt; 1)</h3>
<p>Number of nodes on a page</p>
<h3>#define SIZELEFT(p)   (\fBindx_t\fP)((p)-&gt;mp_upper - (p)-&gt;mp_lower)</h3>
<p>The amount of space remaining in the page</p>
<h3>#define PAGEFILL(env, p)</h3>
<p><strong>Value:</strong></p>
<pre>
(1000L * ((env)-&gt;me_psize - PAGEHDRSZ - SIZELEFT(p)) /                  ((env)-&gt;me_psize - PAGEHDRSZ))
</pre>
<p>The percentage of space used in the page, in tenths of a percent.</p>
<h3>#define FILL_THRESHOLD   250</h3>
<p>The minimum page fill factor, in tenths of a percent. Pages emptier than this are candidates for merging.</p>
<h3>#define IS_LEAF(p)   \fBF_ISSET\fP((p)-&gt;mp_flags, \fBP_LEAF\fP)</h3>
<p>Test if a page is a leaf page</p>
<h3>#define IS_LEAF2(p)   \fBF_ISSET\fP((p)-&gt;mp_flags, \fBP_LEAF2\fP)</h3>
<p>Test if a page is a LEAF2 page</p>
<h3>#define IS_BRANCH(p)   \fBF_ISSET\fP((p)-&gt;mp_flags, \fBP_BRANCH\fP)</h3>
<p>Test if a page is a branch page</p>
<h3>#define IS_OVERFLOW(p)   \fBF_ISSET\fP((p)-&gt;mp_flags, \fBP_OVERFLOW\fP)</h3>
<p>Test if a page is an overflow page</p>
<h3>#define IS_SUBP(p)   \fBF_ISSET\fP((p)-&gt;mp_flags, \fBP_SUBP\fP)</h3>
<p>Test if a page is a sub page</p>
<h3>#define OVPAGES(size, psize)   ((\fBPAGEHDRSZ\fP-1 + (size)) / (psize) + 1)</h3>
<p>The number of overflow pages needed to store the given size.</p>
<h3>#define NEXT_LOOSE_PAGE(p)   (*(\fBMDB_page\fP **)((p) + 2))</h3>
<p>Link in <strong>MDB_txn</strong>.mt_loose_pgs list</p>
<h3>#define NODESIZE   offsetof(\fBMDB_node\fP, mn_data)</h3>
<p>Size of the node header, excluding dynamic data at the end</p>
<h3>#define PGNO_TOPWORD   ((\fBpgno_t\fP)-1 &gt; 0xffffffffu ? 32 : 0)</h3>
<p>Bit position of top word in page number, for shifting mn_flags</p>
<h3>#define INDXSIZE(k)   (\fBNODESIZE\fP + ((k) == NULL ? 0 : (k)-&gt;mv_size))</h3>
<p>Size of a node in a branch page with a given key. This is just the node header plus the key, there is no data.</p>
<h3>#define LEAFSIZE(k, d)   (\fBNODESIZE\fP + (k)-&gt;mv_size + (d)-&gt;mv_size)</h3>
<p>Size of a node in a leaf page with a given key and data. This is node header plus key plus data size.</p>
<h3>#define NODEPTR(p, i)   ((\fBMDB_node\fP *)((char *)(p) + (p)-&gt;mp_ptrs[i] + \fBPAGEBASE\fP))</h3>
<p>Address of node <strong>i</strong> in page <strong>p</strong></p>
<h3>#define NODEKEY(node)   (void *)((node)-&gt;mn_data)</h3>
<p>Address of the key for the node</p>
<h3>#define NODEDATA(node)   (void *)((char *)(node)-&gt;mn_data + (node)-&gt;mn_ksize)</h3>
<p>Address of the data for a node</p>
<h3>#define NODEPGNO(node)</h3>
<p><strong>Value:</strong></p>
<pre>
((node)-&gt;mn_lo | ((pgno_t) (node)-&gt;mn_hi &lt;&lt; 16) |       (PGNO_TOPWORD ? ((pgno_t) (node)-&gt;mn_flags &lt;&lt; PGNO_TOPWORD) : 0))
</pre>
<p>Get the page number pointed to by a branch node</p>
<h3>#define SETPGNO(node, pgno)</h3>
<p><strong>Value:</strong></p>
<pre>
do {      (node)-&gt;mn_lo = (pgno) & 0xffff; (node)-&gt;mn_hi = (pgno) &gt;&gt; 16;      if (PGNO_TOPWORD) (node)-&gt;mn_flags = (pgno) &gt;&gt; PGNO_TOPWORD; } <strong>while</strong>(0)
</pre>
<p>Set the page number in a branch node</p>
<h3>#define NODEDSZ(node)   ((node)-&gt;mn_lo | ((unsigned)(node)-&gt;mn_hi &lt;&lt; 16))</h3>
<p>Get the size of the data in a leaf node</p>
<h3>#define SETDSZ(node, size)</h3>
<p><strong>Value:</strong></p>
<pre>
do {      (node)-&gt;mn_lo = (size) & 0xffff; (node)-&gt;mn_hi = (size) &gt;&gt; 16;} <strong>while</strong>(0)
</pre>
<p>Set the size of the data for a leaf node</p>
<h3>#define NODEKSZ(node)   ((node)-&gt;mn_ksize)</h3>
<p>The size of a key in a node</p>
<h3>#define COPY_PGNO(dst, src)</h3>
<p><strong>Value:</strong></p>
<pre>
do {      unsigned short *s, *d;       s = (unsigned short *)&(src);        d = (unsigned short *)&(dst);        *d++ = *s++;         *d = *s;     } while (0)
</pre>
<p>Copy a page number from src to dst</p>
<h3>#define LEAF2KEY(p, i, ks)   ((char *)(p) + \fBPAGEHDRSZ\fP + ((i)*(ks)))</h3>
<p>The address of a key in a LEAF2 page. LEAF2 pages are used for <strong>MDB_DUPFIXED</strong> sorted-duplicate sub-DBs. There are no node headers, keys are stored contiguously.</p>
<h3>#define MDB_GET_KEY(node, keyptr)</h3>
<p><strong>Value:</strong></p>
<pre>
{ if ((keyptr) != NULL) {      (keyptr)-&gt;mv_size = NODEKSZ(node); (keyptr)-&gt;mv_data = NODEKEY(node); } }
</pre>
<p>Set the <strong>node's</strong> key into <strong>keyptr</strong>, if requested.</p>
<h3>#define MDB_GET_KEY2(node, key)   { key.mv_size = \fBNODEKSZ\fP(node); key.mv_data = \fBNODEKEY\fP(node); }</h3>
<p>Set the <strong>node's</strong> key into <strong>key</strong>.</p>
<h3>#define MDB_VALID   0x8000</h3>
<p>mdb_dbi_open flags DB handle is valid, for me_dbflags</p>
<h3>#define VALID_FLAGS</h3>
<p><strong>Value:</strong></p>
<pre>
(MDB_REVERSEKEY|MDB_DUPSORT|MDB_INTEGERKEY|MDB_DUPFIXED|&#92;
	MDB_INTEGERDUP|MDB_REVERSEDUP|MDB_CREATE)
</pre>

<h3>#define FREE_DBI   0</h3>
<p>Handle for the DB used to track free pages.</p>
<h3>#define MAIN_DBI   1</h3>
<p>Handle for the default DB.</p>
<h3>#define CURSOR_STACK   32</h3>
<p>Enough space for 2^32 nodes with minimum of 2 keys per node. I.e., plenty. At 4 keys per node, enough for 2^64 nodes, so there's probably no need to raise this on a 64 bit machine.</p>
<h3>#define MDB_COMMIT_PAGES   64</h3>
<p>max number of pages to commit in one writev() call</p>
<h3>#define MAX_WRITE   (0x80000000U &gt;&gt; (sizeof(ssize_t) == 4))</h3>
<p>max bytes to write in one call</p>
<h3>#define TXN_DBI_EXIST(txn, dbi)   ((txn) && (dbi) &lt; (txn)-&gt;mt_numdbs && ((txn)-&gt;mt_dbflags[dbi] & \fBDB_VALID\fP))</h3>
<p>Check <strong>txn</strong> and <strong>dbi</strong> arguments to a function</p>
<h3>#define TXN_DBI_CHANGED(txn, dbi)   ((txn)-&gt;mt_dbiseqs[dbi] != (txn)-&gt;mt_env-&gt;me_dbiseqs[dbi])</h3>
<p>Check for misused <strong>dbi</strong> handles</p>
<h3>#define MDB_SPLIT_REPLACE   \fBMDB_APPENDDUP\fP</h3>
<p>newkey is not new</p>
<h3>#define mdb_cassert(mc, expr)   mdb_assert0((mc)-&gt;mc_txn-&gt;mt_env, expr, #expr)</h3>
<p><a href="../man3/assert.3.html"><strong>assert</strong>(3)</a> variant in cursor context</p>
<h3>#define mdb_tassert(mc, expr)   mdb_assert0((txn)-&gt;mt_env, expr, #expr)</h3>
<p><a href="../man3/assert.3.html"><strong>assert</strong>(3)</a> variant in transaction context</p>
<h3>#define mdb_eassert(env, expr)   mdb_assert0(env, expr, #expr)</h3>
<p><a href="../man3/assert.3.html"><strong>assert</strong>(3)</a> variant in environment context</p>
<h3>#define mdb_assert0(env, expr, expr_txt)</h3>
<p><strong>Value:</strong></p>
<pre>
((expr) ? (void)0 :          mdb_assert_fail(env, expr_txt, mdb_func_, __FILE__, __LINE__))
</pre>

<h3>#define LOCKNAME   '/lock.mdb'</h3>
<p>The name of the lock file in the DB environment</p>
<h3>#define DATANAME   '/data.mdb'</h3>
<p>The name of the data file in the DB environment</p>
<h3>#define LOCKSUFF   '-lock'</h3>
<p>The suffix of the lock file when no subdir is used</p>
<h3>#define CHANGEABLE   (\fBMDB_NOSYNC\fP|\fBMDB_NOMETASYNC\fP|\fBMDB_MAPASYNC\fP|\fBMDB_NOMEMINIT\fP)</h3>
<p>Only a subset of the <strong>Environment Flags</strong> flags can be changed at runtime. Changing other flags requires closing the environment and re-opening it with the new flags.</p>
<h3>#define CHANGELESS</h3>
<p><strong>Value:</strong></p>
<pre>
(MDB_FIXEDMAP|MDB_NOSUBDIR|MDB_RDONLY|MDB_WRITEMAP| &#92;
	MDB_NOTLS|MDB_NOLOCK|MDB_NORDAHEAD)
</pre>

<h3>#define mdb_cmp_clong   \fBmdb_cmp_cint\fP</h3>
<p>Compare two items pointing at size_t's of unknown alignment.</p>
<h3>#define MDB_NOSPILL   0x8000</h3>
<p>Do not spill pages to disk if txn is getting full, may fail instead</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Typedef Documentation</h2>
        <div class="sectioncontent">
<h3>typedef \fBMDB_ID\fP \fBpgno_t\fP</h3>
<p>A page number in the database. Note that 64 bit page numbers are overkill, since pages themselves already represent 12-13 bits of addressable memory, and the OS will always limit applications to a maximum of 63 bits of address space.</p><p><strong>Note:</strong></p><p>In the <strong>MDB_node</strong> structure, we only store 48 bits of this value, which thus limits us to only 60 bits of addressable data.</p>
<h3>typedef \fBMDB_ID\fP \fBtxnid_t\fP</h3>
<p>A transaction ID. See struct <strong>MDB_txn.mt_txnid</strong> for details.</p>
<h3>typedef uint16_t \fBindx_t\fP</h3>
<p>Used for offsets within a single page. Since memory pages are typically 4 or 8KB in size, 12-13 bits, this is plenty.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Function Documentation</h2>
        <div class="sectioncontent">
<h3>static int mdb_page_alloc (\fBMDB_cursor\fP *mc, intnum, \fBMDB_page\fP **mp)\fC [static]\fP</h3>
<p>Allocate page numbers and memory for writing. Maintain me_pglast, me_pghead and mt_next_pgno.</p><p>If there are free pages available from older transactions, they are re-used first. Otherwise allocate a new page at mt_next_pgno. Do not modify the freedB, just merge freeDB records into me_pghead[] and move me_pglast to say which records were consumed. Only this function can create me_pghead and move me_pglast/mt_next_pgno.</p><p><strong>Parameters:</strong></p><p><em>mc</em> cursor A cursor handle identifying the transaction and database for which we are allocating.</p><p><em>num</em> the number of pages to allocate.</p><p><em>mp</em> Address of the allocated page(s). Requests for multiple pages will always be satisfied by a single contiguous chunk of memory.</p><p><strong>Returns:</strong></p><p>0 on success, non-zero on failure.</p>
<h3>static int mdb_page_new (\fBMDB_cursor\fP *mc, uint32_tflags, intnum, \fBMDB_page\fP **mp)\fC [static]\fP</h3>
<p>Allocate and initialize new pages for a database.</p><p><strong>Parameters:</strong></p><p><em>mc</em> a cursor on the database being added to.</p><p><em>flags</em> flags defining what type of page is being allocated.</p><p><em>num</em> the number of pages to allocate. This is usually 1, unless allocating overflow pages for a large record.</p><p><em>mp</em> Address of a page, or NULL on failure.</p><p><strong>Returns:</strong></p><p>0 on success, non-zero on failure.</p>
<h3>static int mdb_page_touch (\fBMDB_cursor\fP *mc)\fC [static]\fP</h3>
<p>Touch a page: make it dirty and re-insert into tree with updated pgno.</p><p><strong>Parameters:</strong></p><p><em>mc</em> cursor pointing to the page to be touched</p><p><strong>Returns:</strong></p><p>0 on success, non-zero on failure.</p>
<h3>static int mdb_page_get (\fBMDB_txn\fP *txn, \fBpgno_t\fPpgno, \fBMDB_page\fP **ret, int *lvl)\fC [static]\fP</h3>
<p>Find the address of the page corresponding to a given page number.</p><p><strong>Parameters:</strong></p><p><em>txn</em> the transaction for this access.</p><p><em>pgno</em> the page number for the page to retrieve.</p><p><em>ret</em> address of a pointer where the page's address will be stored.</p><p><em>lvl</em> dirty_list inheritance level of found page. 1=current txn, 0=mapped page.</p><p><strong>Returns:</strong></p><p>0 on success, non-zero on failure.</p>
<h3>static int mdb_page_search_root (\fBMDB_cursor\fP *mc, \fBMDB_val\fP *key, intflags)\fC [static]\fP</h3>
<p>Finish <strong>mdb_page_search()</strong> / <strong>mdb_page_search_lowest()</strong>. The cursor is at the root page, set up the rest of it.</p>
<h3>static int mdb_page_search (\fBMDB_cursor\fP *mc, \fBMDB_val\fP *key, intflags)\fC [static]\fP</h3>
<p>Search for the page a given key should be in. Push it and its parent pages on the cursor stack.</p><p><strong>Parameters:</strong></p><p><em>mc</em> the cursor for this operation.</p><p><em>key</em> the key to search for, or NULL for first/last page.</p><p><em>flags</em> If MDB_PS_MODIFY is set, visited pages in the DB are touched (updated with new page numbers). If MDB_PS_FIRST or MDB_PS_LAST is set, find first or last leaf. This is used by <strong>mdb_cursor_first()</strong> and <strong>mdb_cursor_last()</strong>. If MDB_PS_ROOTONLY set, just fetch root node, no further lookups.</p><p><strong>Returns:</strong></p><p>0 on success, non-zero on failure.</p>
<h3>static int mdb_page_merge (\fBMDB_cursor\fP *csrc, \fBMDB_cursor\fP *cdst)\fC [static]\fP</h3>
<p>Merge one page into another. The nodes from the page pointed to by <strong>csrc</strong> will be copied to the page pointed to by <strong>cdst</strong> and then the <strong>csrc</strong> page will be freed.</p><p><strong>Parameters:</strong></p><p><em>csrc</em> Cursor pointing to the source page.</p><p><em>cdst</em> Cursor pointing to the destination page.</p><p><strong>Returns:</strong></p><p>0 on success, non-zero on failure.</p>
<h3>static int mdb_page_split (\fBMDB_cursor\fP *mc, \fBMDB_val\fP *newkey, \fBMDB_val\fP *newdata, \fBpgno_t\fPnewpgno, unsigned intnflags)\fC [static]\fP</h3>
<p>Split a page and insert a new node.</p><p><strong>Parameters:</strong></p><p><em>mc</em> Cursor pointing to the page and desired insertion index. The cursor will be updated to point to the actual page and index where the node got inserted after the split.</p><p><em>newkey</em> The key for the newly inserted node.</p><p><em>newdata</em> The data for the newly inserted node.</p><p><em>newpgno</em> The page number, if the new node is a branch node.</p><p><em>nflags</em> The <strong>NODE_ADD_FLAGS</strong> for the new node.</p><p><strong>Returns:</strong></p><p>0 on success, non-zero on failure.</p>
<h3>static int \fBESECT\fP mdb_env_read_header (\fBMDB_env\fP *env, \fBMDB_meta\fP *meta)\fC [static]\fP</h3>
<p>Read the environment parameters of a DB environment before mapping it into memory.</p><p><strong>Parameters:</strong></p><p><em>env</em> the environment handle</p><p><em>meta</em> address of where to store the meta information</p><p><strong>Returns:</strong></p><p>0 on success, non-zero on failure.</p>
<h3>static int mdb_env_pick_meta (const \fBMDB_env\fP *env)\fC [static]\fP</h3>
<p>Check both meta pages to see which one is newer.</p><p><strong>Parameters:</strong></p><p><em>env</em> the environment handle</p><p><strong>Returns:</strong></p><p>meta toggle (0 or 1).</p>
<h3>static int mdb_env_write_meta (\fBMDB_txn\fP *txn)\fC [static]\fP</h3>
<p>Update the environment info to commit a transaction.</p><p><strong>Parameters:</strong></p><p><em>txn</em> the transaction that's being committed</p><p><strong>Returns:</strong></p><p>0 on success, non-zero on failure.</p>
<h3>static void \fBESECT\fP mdb_env_close0 (\fBMDB_env\fP *env, intexcl)\fC [static]\fP</h3>
<p>Destroy resources from <strong>mdb_env_open()</strong>, clear our readers & DBIs</p>
<h3>static \fBMDB_node\fP * mdb_node_search (\fBMDB_cursor\fP *mc, \fBMDB_val\fP *key, int *exactp)\fC [static]\fP</h3>
<p>Search for key within a page, using binary search. Returns the smallest entry larger or equal to the key. If exactp is non-null, stores whether the found entry was an exact match in *exactp (1 or 0). Updates the cursor index with the index of the found entry. If no entry larger or equal to the key is found, returns NULL.</p>
<h3>static int mdb_node_add (\fBMDB_cursor\fP *mc, \fBindx_t\fPindx, \fBMDB_val\fP *key, \fBMDB_val\fP *data, \fBpgno_t\fPpgno, unsigned intflags)\fC [static]\fP</h3>
<p>Add a node to the page pointed to by the cursor.</p><p><strong>Parameters:</strong></p><p><em>mc</em> The cursor for this operation.</p><p><em>indx</em> The index on the page where the new node should be added.</p><p><em>key</em> The key for the new node.</p><p><em>data</em> The data for the new node, if any.</p><p><em>pgno</em> The page number, if adding a branch node.</p><p><em>flags</em> Flags for the node.</p><p><strong>Returns:</strong></p><p>0 on success, non-zero on failure. Possible errors are:</p><ul>
<li><p>ENOMEM - failed to allocate overflow pages for the node.</p></li><li><p>MDB_PAGE_FULL - there is insufficient room in the page. This error should never happen since all callers already calculate the page's free space before calling this function.</p></li>
</ul>
<h3>static void mdb_node_del (\fBMDB_cursor\fP *mc, intksize)\fC [static]\fP</h3>
<p>Delete the specified node from a page.</p><p><strong>Parameters:</strong></p><p><em>mc</em> Cursor pointing to the node to delete.</p><p><em>ksize</em> The size of a node. Only used if the page is part of a <strong>MDB_DUPFIXED</strong> database.</p>
<h3>static void mdb_node_shrink (\fBMDB_page\fP *mp, \fBindx_t\fPindx)\fC [static]\fP</h3>
<p>Compact the main page after deleting a node on a subpage.</p><p><strong>Parameters:</strong></p><p><em>mp</em> The main page to operate on.</p><p><em>indx</em> The index of the subpage on the main page.</p>
<h3>static int mdb_node_move (\fBMDB_cursor\fP *csrc, \fBMDB_cursor\fP *cdst)\fC [static]\fP</h3>
<p>Move a node from csrc to cdst.</p>
<h3>static int mdb_node_read (\fBMDB_txn\fP *txn, \fBMDB_node\fP *leaf, \fBMDB_val\fP *data)\fC [static]\fP</h3>
<p>Return the data associated with a given node.</p><p><strong>Parameters:</strong></p><p><em>txn</em> The transaction for this operation.</p><p><em>leaf</em> The node being read.</p><p><em>data</em> Updated to point to the node's data.</p><p><strong>Returns:</strong></p><p>0 on success, non-zero on failure.</p>
<h3>static size_t mdb_leaf_size (\fBMDB_env\fP *env, \fBMDB_val\fP *key, \fBMDB_val\fP *data)\fC [static]\fP</h3>
<p>Calculate the size of a leaf node. The size depends on the environment's page size; if a data item is too large it will be put onto an overflow page and the node size will only include the key and not the data. Sizes are always rounded up to an even number of bytes, to guarantee 2-byte alignment of the <strong>MDB_node</strong> headers.</p><p><strong>Parameters:</strong></p><p><em>env</em> The environment handle.</p><p><em>key</em> The key for the node.</p><p><em>data</em> The data for the node.</p><p><strong>Returns:</strong></p><p>The number of bytes needed to store the node.</p>
<h3>static size_t mdb_branch_size (\fBMDB_env\fP *env, \fBMDB_val\fP *key)\fC [static]\fP</h3>
<p>Calculate the size of a branch node. The size should depend on the environment's page size but since we currently don't support spilling large keys onto overflow pages, it's simply the size of the <strong>MDB_node</strong> header plus the size of the key. Sizes are always rounded up to an even number of bytes, to guarantee 2-byte alignment of the <strong>MDB_node</strong> headers.</p><p><strong>Parameters:</strong></p><p><em>env</em> The environment handle.</p><p><em>key</em> The key for the node.</p><p><strong>Returns:</strong></p><p>The number of bytes needed to store the node.</p>
<h3>static int mdb_rebalance (\fBMDB_cursor\fP *mc)\fC [static]\fP</h3>
<p>Rebalance the tree after a delete operation.</p><p><strong>Parameters:</strong></p><p><em>mc</em> Cursor pointing to the page where rebalancing should begin.</p><p><strong>Returns:</strong></p><p>0 on success, non-zero on failure.</p>
<h3>static int mdb_update_key (\fBMDB_cursor\fP *mc, \fBMDB_val\fP *key)\fC [static]\fP</h3>
<p>Replace the key for a branch node with a new key.</p><p><strong>Parameters:</strong></p><p><em>mc</em> Cursor pointing to the node to operate on.</p><p><em>key</em> The new key to use.</p><p><strong>Returns:</strong></p><p>0 on success, non-zero on failure.</p>
<h3>static void mdb_cursor_pop (\fBMDB_cursor\fP *mc)\fC [static]\fP</h3>
<p>Pop a page off the top of the cursor's stack.</p>
<h3>static int mdb_cursor_push (\fBMDB_cursor\fP *mc, \fBMDB_page\fP *mp)\fC [static]\fP</h3>
<p>Push a page onto the top of the cursor's stack.</p>
<h3>static int mdb_cursor_del0 (\fBMDB_cursor\fP *mc)\fC [static]\fP</h3>
<p>Complete a delete operation started by <strong>mdb_cursor_del()</strong>.</p>
<h3>static int mdb_cursor_sibling (\fBMDB_cursor\fP *mc, intmove_right)\fC [static]\fP</h3>
<p>Find a sibling for a page. Replaces the page at the top of the cursor's stack with the specified sibling, if one exists.</p><p><strong>Parameters:</strong></p><p><em>mc</em> The cursor for this operation.</p><p><em>move_right</em> Non-zero if the right sibling is requested, otherwise the left sibling.</p><p><strong>Returns:</strong></p><p>0 on success, non-zero on failure.</p>
<h3>static int mdb_cursor_next (\fBMDB_cursor\fP *mc, \fBMDB_val\fP *key, \fBMDB_val\fP *data, \fBMDB_cursor_op\fPop)\fC [static]\fP</h3>
<p>Move the cursor to the next data item.</p>
<h3>static int mdb_cursor_prev (\fBMDB_cursor\fP *mc, \fBMDB_val\fP *key, \fBMDB_val\fP *data, \fBMDB_cursor_op\fPop)\fC [static]\fP</h3>
<p>Move the cursor to the previous data item.</p>
<h3>static int mdb_cursor_set (\fBMDB_cursor\fP *mc, \fBMDB_val\fP *key, \fBMDB_val\fP *data, \fBMDB_cursor_op\fPop, int *exactp)\fC [static]\fP</h3>
<p>Set the cursor on a specific data item.</p>
<h3>static int mdb_cursor_first (\fBMDB_cursor\fP *mc, \fBMDB_val\fP *key, \fBMDB_val\fP *data)\fC [static]\fP</h3>
<p>Move the cursor to the first item in the database.</p>
<h3>static int mdb_cursor_last (\fBMDB_cursor\fP *mc, \fBMDB_val\fP *key, \fBMDB_val\fP *data)\fC [static]\fP</h3>
<p>Move the cursor to the last item in the database.</p>
<h3>static void mdb_cursor_init (\fBMDB_cursor\fP *mc, \fBMDB_txn\fP *txn, \fBMDB_dbi\fPdbi, \fBMDB_xcursor\fP *mx)\fC [static]\fP</h3>
<p>Initialize a cursor for a given transaction and database.</p>
<h3>static void mdb_xcursor_init0 (\fBMDB_cursor\fP *mc)\fC [static]\fP</h3>
<p>Initial setup of a sorted-dups cursor. Sorted duplicates are implemented as a sub-database for the given key. The duplicate data items are actually keys of the sub-database. Operations on the duplicate data items are performed using a sub-cursor initialized when the sub-database is first accessed. This function does the preliminary setup of the sub-cursor, filling in the fields that depend only on the parent DB.</p><p><strong>Parameters:</strong></p><p><em>mc</em> The main cursor whose sorted-dups cursor is to be initialized.</p>
<h3>static void mdb_xcursor_init1 (\fBMDB_cursor\fP *mc, \fBMDB_node\fP *node)\fC [static]\fP</h3>
<p>Final setup of a sorted-dups cursor. Sets up the fields that depend on the data from the main cursor.</p><p><strong>Parameters:</strong></p><p><em>mc</em> The main cursor whose sorted-dups cursor is to be initialized.</p><p><em>node</em> The data containing the <strong>MDB_db</strong> record for the sorted-dup database.</p>
<h3>static int mdb_drop0 (\fBMDB_cursor\fP *mc, intsubs)\fC [static]\fP</h3>
<p>Add all the DB's pages to the free list.</p><p><strong>Parameters:</strong></p><p><em>mc</em> Cursor on the DB to free.</p><p><em>subs</em> non-Zero to check for sub-DBs in this DB.</p><p><strong>Returns:</strong></p><p>0 on success, non-zero on failure.</p>
<h3>static void mdb_default_cmp (\fBMDB_txn\fP *txn, \fBMDB_dbi\fPdbi)\fC [static]\fP</h3>
<p>Set the default comparison functions for a database. Called immediately after a database is opened to set the defaults. The user can then override them with <strong>mdb_set_compare()</strong> or <strong>mdb_set_dupsort()</strong>.</p><p><strong>Parameters:</strong></p><p><em>txn</em> A transaction handle returned by <strong>mdb_txn_begin()</strong></p><p><em>dbi</em> A database handle returned by <strong>mdb_dbi_open()</strong></p>
<h3>char* mdb_version (int *major, int *minor, int *patch)</h3>
<p>Return the LMDB library version information. Return the library version info.</p>
<h3>char* mdb_strerror (interr)</h3>
<p>Return a string describing a given error code. This function is a superset of the ANSI C X3.159-1989 (ANSI C) <a href="../man3/strerror.3.html"><strong>strerror</strong>(3)</a> function. If the error code is greater than or equal to 0, then the string returned by the system function <a href="../man3/strerror.3.html"><strong>strerror</strong>(3)</a> is returned. If the error code is less than 0, an error string corresponding to the LMDB library error is returned. See <strong>Return Codes</strong> for a list of LMDB-specific error codes.</p><p><strong>Parameters:</strong></p><p><em>err</em> The error code</p><p><strong>Return values:</strong></p><p><em>error message</em> The description of the error</p>
<h3>int mdb_cmp (\fBMDB_txn\fP *txn, \fBMDB_dbi\fPdbi, const \fBMDB_val\fP *a, const \fBMDB_val\fP *b)</h3>
<p>Compare two data items according to a particular database. This returns a comparison as if the two data items were keys in the specified database.</p><p><strong>Parameters:</strong></p><p><em>txn</em> A transaction handle returned by <strong>mdb_txn_begin()</strong></p><p><em>dbi</em> A database handle returned by <strong>mdb_dbi_open()</strong></p><p><em>a</em> The first item to compare</p><p><em>b</em> The second item to compare</p><p><strong>Returns:</strong></p><p>&lt; 0 if a &lt; b, 0 if a == b, &gt; 0 if a &gt; b</p>
<h3>int mdb_dcmp (\fBMDB_txn\fP *txn, \fBMDB_dbi\fPdbi, const \fBMDB_val\fP *a, const \fBMDB_val\fP *b)</h3>
<p>Compare two data items according to a particular database. This returns a comparison as if the two items were data items of the specified database. The database must have the <strong>MDB_DUPSORT</strong> flag.</p><p><strong>Parameters:</strong></p><p><em>txn</em> A transaction handle returned by <strong>mdb_txn_begin()</strong></p><p><em>dbi</em> A database handle returned by <strong>mdb_dbi_open()</strong></p><p><em>a</em> The first item to compare</p><p><em>b</em> The second item to compare</p><p><strong>Returns:</strong></p><p>&lt; 0 if a &lt; b, 0 if a == b, &gt; 0 if a &gt; b</p>
<h3>static \fBMDB_page\fP* mdb_page_malloc (\fBMDB_txn\fP *txn, unsignednum)\fC [static]\fP</h3>
<p>Allocate memory for a page. Re-use old malloc'd pages first for singletons, otherwise just malloc.</p>
<h3>static void mdb_page_free (\fBMDB_env\fP *env, \fBMDB_page\fP *mp)\fC [static]\fP</h3>
<p>Free a single page. Saves single pages to a list, for future reuse. (This is not used for multi-page overflow pages.)</p>
<h3>static void mdb_dpage_free (\fBMDB_env\fP *env, \fBMDB_page\fP *dp)\fC [static]\fP</h3>
<p>Free a dirty page</p>
<h3>static void mdb_dlist_free (\fBMDB_txn\fP *txn)\fC [static]\fP</h3>
<p>Return all dirty pages to dpage list</p>
<h3>static int mdb_page_loose (\fBMDB_cursor\fP *mc, \fBMDB_page\fP *mp)\fC [static]\fP</h3>
<p>Loosen or free a single page. Saves single pages to a list for future reuse in this same txn. It has been pulled from the freeDB and already resides on the dirty list, but has been deleted. Use these pages first before pulling again from the freeDB.</p><p>If the page wasn't dirtied in this txn, just add it to this txn's free list.</p>
<h3>static int mdb_pages_xkeep (\fBMDB_cursor\fP *mc, unsignedpflags, intall)\fC [static]\fP</h3>
<p>Set or clear P_KEEP in dirty, non-overflow, non-sub pages watched by txn.</p><p><strong>Parameters:</strong></p><p><em>mc</em> A cursor handle for the current operation.</p><p><em>pflags</em> Flags of the pages to update: P_DIRTY to set P_KEEP, P_DIRTY|P_KEEP to clear it.</p><p><em>all</em> No shortcuts. Needed except after a full <strong>mdb_page_flush()</strong>.</p><p><strong>Returns:</strong></p><p>0 on success, non-zero on failure.</p>
<h3>static int mdb_page_flush (\fBMDB_txn\fP *txn, intkeep)\fC [static]\fP</h3>
<p>Flush (some) dirty pages to the map, after clearing their dirty flag.</p><p><strong>Parameters:</strong></p><p><em>txn</em> the transaction that's being committed</p><p><em>keep</em> number of initial pages in dirty_list to keep dirty.</p><p><strong>Returns:</strong></p><p>0 on success, non-zero on failure.</p>
<h3>static int mdb_page_spill (\fBMDB_cursor\fP *m0, \fBMDB_val\fP *key, \fBMDB_val\fP *data)\fC [static]\fP</h3>
<p>Spill pages from the dirty list back to disk. This is intended to prevent running into <strong>MDB_TXN_FULL</strong> situations, but note that they may still occur in a few cases: 1) our estimate of the txn size could be too small. Currently this seems unlikely, except with a large number of <strong>MDB_MULTIPLE</strong> items. 2) child txns may run out of space if their parents dirtied a lot of pages and never spilled them. TODO: we probably should do a preemptive spill during <strong>mdb_txn_begin()</strong> of a child txn, if the parent's dirty_room is below a given threshold.</p><p>Otherwise, if not using nested txns, it is expected that apps will not run into <strong>MDB_TXN_FULL</strong> any more. The pages are flushed to disk the same way as for a txn commit, e.g. their P_DIRTY flag is cleared. If the txn never references them again, they can be left alone. If the txn only reads them, they can be used without any fuss. If the txn writes them again, they can be dirtied immediately without going thru all of the work of <strong>mdb_page_touch()</strong>. Such references are handled by <strong>mdb_page_unspill()</strong>.</p><p>Also note, we never spill DB root pages, nor pages of active cursors, because we'll need these back again soon anyway. And in nested txns, we can't spill a page in a child txn if it was already spilled in a parent txn. That would alter the parent txns' data even though the child hasn't committed yet, and we'd have no way to undo it if the child aborted.</p><p><strong>Parameters:</strong></p><p><em>m0</em> cursor A cursor handle identifying the transaction and database for which we are checking space.</p><p><em>key</em> For a put operation, the key being stored.</p><p><em>data</em> For a put operation, the data being stored.</p><p><strong>Returns:</strong></p><p>0 on success, non-zero on failure.</p>
<h3>static \fBtxnid_t\fP mdb_find_oldest (\fBMDB_txn\fP *txn)\fC [static]\fP</h3>
<p>Find oldest txnid still referenced. Expects txn-&gt;mt_txnid &gt; 0.</p>
<h3>static void mdb_page_dirty (\fBMDB_txn\fP *txn, \fBMDB_page\fP *mp)\fC [static]\fP</h3>
<p>Add a page to the txn's dirty list</p>
<h3>static void mdb_page_copy (\fBMDB_page\fP *dst, \fBMDB_page\fP *src, unsigned intpsize)\fC [static]\fP</h3>
<p>Copy the used portions of a non-overflow page.</p><p><strong>Parameters:</strong></p><p><em>dst</em> page to copy into</p><p><em>src</em> page to copy from</p><p><em>psize</em> size of a page</p>
<h3>static int mdb_page_unspill (\fBMDB_txn\fP *txn, \fBMDB_page\fP *mp, \fBMDB_page\fP **ret)\fC [static]\fP</h3>
<p>Pull a page off the txn's spill list, if present. If a page being referenced was spilled to disk in this txn, bring it back and make it dirty/writable again.</p><p><strong>Parameters:</strong></p><p><em>txn</em> the transaction handle.</p><p><em>mp</em> the page being referenced. It must not be dirty.</p><p><em>ret</em> the writable page, if any. ret is unchanged if mp wasn't spilled.</p>
<h3>int mdb_env_sync (\fBMDB_env\fP *env, intforce)</h3>
<p>Flush the data buffers to disk. Data is always written to disk when <strong>mdb_txn_commit()</strong> is called, but the operating system may keep it buffered. LMDB always flushes the OS buffers upon commit as well, unless the environment was opened with <strong>MDB_NOSYNC</strong> or in part <strong>MDB_NOMETASYNC</strong>.</p><p><strong>Parameters:</strong></p><p><em>env</em> An environment handle returned by <strong>mdb_env_create()</strong></p><p><em>force</em> If non-zero, force a synchronous flush. Otherwise if the environment has the <strong>MDB_NOSYNC</strong> flag set the flushes will be omitted, and with <strong>MDB_MAPASYNC</strong> they will be asynchronous.</p><p><strong>Returns:</strong></p><p>A non-zero error value on failure and 0 on success. Some possible errors are:</p><ul>
<li><p>EINVAL - an invalid parameter was specified.</p></li><li><p>EIO - an error occurred during synchronization.</p></li>
</ul>
<h3>static int mdb_cursor_shadow (\fBMDB_txn\fP *src, \fBMDB_txn\fP *dst)\fC [static]\fP</h3>
<p>Back up parent txn's cursors, then grab the originals for tracking</p>
<h3>static void mdb_cursors_close (\fBMDB_txn\fP *txn, unsignedmerge)\fC [static]\fP</h3>
<p>Close this write txn's cursors, give parent txn's cursors back to parent.</p><p><strong>Parameters:</strong></p><p><em>txn</em> the transaction handle.</p><p><em>merge</em> true to keep changes to parent cursors, false to revert.</p><p><strong>Returns:</strong></p><p>0 on success, non-zero on failure.</p>
<h3>static void mdb_txn_reset0 (\fBMDB_txn\fP *txn, const char *act)\fC [static]\fP</h3>
<p>Common code for <strong>mdb_txn_reset()</strong> and <strong>mdb_txn_abort()</strong>. May be called twice for readonly txns: First reset it, then abort.</p><p><strong>Parameters:</strong></p><p><em>txn</em> the transaction handle to reset</p><p><em>act</em> why the transaction is being reset</p>
<h3>static int mdb_reader_pid (\fBMDB_env\fP *env, enum Pidlock_opop, MDB_PID_Tpid)\fC [static]\fP</h3>
<p>Set or check a pid lock. Set returns 0 on success. Check returns 0 if the process is certainly dead, nonzero if it may be alive (the lock exists or an error happened so we do not know).</p><p>On Windows Pidset is a no-op, we merely check for the existence of the process with the given pid. On POSIX we use a single byte lock on the lockfile, set at an offset equal to the pid.</p>
<h3>static int mdb_txn_renew0 (\fBMDB_txn\fP *txn)\fC [static]\fP</h3>
<p>Common code for <strong>mdb_txn_begin()</strong> and <strong>mdb_txn_renew()</strong>.</p><p><strong>Parameters:</strong></p><p><em>txn</em> the transaction handle to initialize</p><p><strong>Returns:</strong></p><p>0 on success, non-zero on failure.</p>
<h3>int mdb_txn_renew (\fBMDB_txn\fP *txn)</h3>
<p>Renew a read-only transaction. This acquires a new reader lock for a transaction handle that had been released by <strong>mdb_txn_reset()</strong>. It must be called before a reset transaction may be used again.</p><p><strong>Parameters:</strong></p><p><em>txn</em> A transaction handle returned by <strong>mdb_txn_begin()</strong></p><p><strong>Returns:</strong></p><p>A non-zero error value on failure and 0 on success. Some possible errors are:</p><ul>
<li><p><strong>MDB_PANIC</strong> - a fatal error occurred earlier and the environment must be shut down.</p></li><li><p>EINVAL - an invalid parameter was specified.</p></li>
</ul>
<h3>int mdb_txn_begin (\fBMDB_env\fP *env, \fBMDB_txn\fP *parent, unsigned intflags, \fBMDB_txn\fP **txn)</h3>
<p>Create a transaction for use with the environment. The transaction handle may be discarded using <strong>mdb_txn_abort()</strong> or <strong>mdb_txn_commit()</strong>.</p><p><strong>Note:</strong></p><p>A transaction and its cursors must only be used by a single thread, and a thread may only have a single transaction at a time. If <strong>MDB_NOTLS</strong> is in use, this does not apply to read-only transactions.</p><p>Cursors may not span transactions.</p><p><strong>Parameters:</strong></p><p><em>env</em> An environment handle returned by <strong>mdb_env_create()</strong></p><p><em>parent</em> If this parameter is non-NULL, the new transaction will be a nested transaction, with the transaction indicated by <strong>parent</strong> as its parent. Transactions may be nested to any level. A parent transaction and its cursors may not issue any other operations than mdb_txn_commit and mdb_txn_abort while it has active child transactions.</p><p><em>flags</em> Special options for this transaction. This parameter must be set to 0 or by bitwise OR'ing together one or more of the values described here.</p><ul>
<li><p><strong>MDB_RDONLY</strong> This transaction will not perform any write operations.</p></li>
</ul><p><em>txn</em> Address where the new <strong>MDB_txn</strong> handle will be stored</p><p><strong>Returns:</strong></p><p>A non-zero error value on failure and 0 on success. Some possible errors are:</p><ul>
<li><p><strong>MDB_PANIC</strong> - a fatal error occurred earlier and the environment must be shut down.</p></li><li><p><strong>MDB_MAP_RESIZED</strong> - another process wrote data beyond this <strong>MDB_env</strong>'s mapsize and this environment's map must be resized as well. See <strong>mdb_env_set_mapsize()</strong>.</p></li><li><p><strong>MDB_READERS_FULL</strong> - a read-only transaction was requested and the reader lock table is full. See <strong>mdb_env_set_maxreaders()</strong>.</p></li><li><p>ENOMEM - out of memory.</p></li>
</ul>
<h3>\fBMDB_env\fP* mdb_txn_env (\fBMDB_txn\fP *txn)</h3>
<p>Returns the transaction's <strong>MDB_env</strong>.</p><p><strong>Parameters:</strong></p><p><em>txn</em> A transaction handle returned by <strong>mdb_txn_begin()</strong></p>
<h3>static void mdb_dbis_update (\fBMDB_txn\fP *txn, intkeep)\fC [static]\fP</h3>
<p>Export or close DBI handles opened in this txn.</p>
<h3>void mdb_txn_reset (\fBMDB_txn\fP *txn)</h3>
<p>Reset a read-only transaction. Abort the transaction like <strong>mdb_txn_abort()</strong>, but keep the transaction handle. <strong>mdb_txn_renew()</strong> may reuse the handle. This saves allocation overhead if the process will start a new read-only transaction soon, and also locking overhead if <strong>MDB_NOTLS</strong> is in use. The reader table lock is released, but the table slot stays tied to its thread or <strong>MDB_txn</strong>. Use <strong>mdb_txn_abort()</strong> to discard a reset handle, and to free its lock table slot if MDB_NOTLS is in use. Cursors opened within the transaction must not be used again after this call, except with <strong>mdb_cursor_renew()</strong>. Reader locks generally don't interfere with writers, but they keep old versions of database pages allocated. Thus they prevent the old pages from being reused when writers commit new data, and so under heavy load the database size may grow much more rapidly than otherwise.</p><p><strong>Parameters:</strong></p><p><em>txn</em> A transaction handle returned by <strong>mdb_txn_begin()</strong></p>
<h3>void mdb_txn_abort (\fBMDB_txn\fP *txn)</h3>
<p>Abandon all the operations of the transaction instead of saving them. The transaction handle is freed. It and its cursors must not be used again after this call, except with <strong>mdb_cursor_renew()</strong>.</p><p><strong>Note:</strong></p><p>Earlier documentation incorrectly said all cursors would be freed. Only write-transactions free cursors.</p><p><strong>Parameters:</strong></p><p><em>txn</em> A transaction handle returned by <strong>mdb_txn_begin()</strong></p>
<h3>static int mdb_freelist_save (\fBMDB_txn\fP *txn)\fC [static]\fP</h3>
<p>Save the freelist as of this transaction to the freeDB. This changes the freelist. Keep trying until it stabilizes.</p>
<h3>int mdb_txn_commit (\fBMDB_txn\fP *txn)</h3>
<p>Commit all the operations of a transaction into the database. The transaction handle is freed. It and its cursors must not be used again after this call, except with <strong>mdb_cursor_renew()</strong>.</p><p><strong>Note:</strong></p><p>Earlier documentation incorrectly said all cursors would be freed. Only write-transactions free cursors.</p><p><strong>Parameters:</strong></p><p><em>txn</em> A transaction handle returned by <strong>mdb_txn_begin()</strong></p><p><strong>Returns:</strong></p><p>A non-zero error value on failure and 0 on success. Some possible errors are:</p><ul>
<li><p>EINVAL - an invalid parameter was specified.</p></li><li><p>ENOSPC - no more disk space.</p></li><li><p>EIO - a low-level I/O error occurred while writing.</p></li><li><p>ENOMEM - out of memory.</p></li>
</ul>
<h3>static int \fBESECT\fP mdb_env_init_meta (\fBMDB_env\fP *env, \fBMDB_meta\fP *meta)\fC [static]\fP</h3>
<p>Write the environment parameters of a freshly created DB environment.</p><p><strong>Parameters:</strong></p><p><em>env</em> the environment handle</p><p><em>meta</em> address of where to store the meta information</p><p><strong>Returns:</strong></p><p>0 on success, non-zero on failure.</p>
<h3>int \fBESECT\fP mdb_env_create (\fBMDB_env\fP **env)</h3>
<p>Create an LMDB environment handle. This function allocates memory for a <strong>MDB_env</strong> structure. To release the allocated memory and discard the handle, call <strong>mdb_env_close()</strong>. Before the handle may be used, it must be opened using <strong>mdb_env_open()</strong>. Various other options may also need to be set before opening the handle, e.g. <strong>mdb_env_set_mapsize()</strong>, <strong>mdb_env_set_maxreaders()</strong>, <strong>mdb_env_set_maxdbs()</strong>, depending on usage requirements.</p><p><strong>Parameters:</strong></p><p><em>env</em> The address where the new handle will be stored</p><p><strong>Returns:</strong></p><p>A non-zero error value on failure and 0 on success.</p>
<h3>int \fBESECT\fP mdb_env_set_mapsize (\fBMDB_env\fP *env, size_tsize)</h3>
<p>Set the size of the memory map to use for this environment. The size should be a multiple of the OS page size. The default is 10485760 bytes. The size of the memory map is also the maximum size of the database. The value should be chosen as large as possible, to accommodate future growth of the database. This function should be called after <strong>mdb_env_create()</strong> and before <strong>mdb_env_open()</strong>. It may be called at later times if no transactions are active in this process. Note that the library does not check for this condition, the caller must ensure it explicitly.</p><p>The new size takes effect immediately for the current process but will not be persisted to any others until a write transaction has been committed by the current process. Also, only mapsize increases are persisted into the environment.</p><p>If the mapsize is increased by another process, and data has grown beyond the range of the current mapsize, <strong>mdb_txn_begin()</strong> will return <strong>MDB_MAP_RESIZED</strong>. This function may be called with a size of zero to adopt the new size.</p><p>Any attempt to set a size smaller than the space already consumed by the environment will be silently changed to the current size of the used space.</p><p><strong>Parameters:</strong></p><p><em>env</em> An environment handle returned by <strong>mdb_env_create()</strong></p><p><em>size</em> The size in bytes</p><p><strong>Returns:</strong></p><p>A non-zero error value on failure and 0 on success. Some possible errors are:</p><ul>
<li><p>EINVAL - an invalid parameter was specified, or the environment has an active write transaction.</p></li>
</ul>
<h3>int \fBESECT\fP mdb_env_set_maxdbs (\fBMDB_env\fP *env, \fBMDB_dbi\fPdbs)</h3>
<p>Set the maximum number of named databases for the environment. This function is only needed if multiple databases will be used in the environment. Simpler applications that use the environment as a single unnamed database can ignore this option. This function may only be called after <strong>mdb_env_create()</strong> and before <strong>mdb_env_open()</strong>.</p><p>Currently a moderate number of slots are cheap but a huge number gets expensive: 7-120 words per transaction, and every <strong>mdb_dbi_open()</strong> does a linear search of the opened slots.</p><p><strong>Parameters:</strong></p><p><em>env</em> An environment handle returned by <strong>mdb_env_create()</strong></p><p><em>dbs</em> The maximum number of databases</p><p><strong>Returns:</strong></p><p>A non-zero error value on failure and 0 on success. Some possible errors are:</p><ul>
<li><p>EINVAL - an invalid parameter was specified, or the environment is already open.</p></li>
</ul>
<h3>int \fBESECT\fP mdb_env_set_maxreaders (\fBMDB_env\fP *env, unsigned intreaders)</h3>
<p>Set the maximum number of threads/reader slots for the environment. This defines the number of slots in the lock table that is used to track readers in the the environment. The default is 126. Starting a read-only transaction normally ties a lock table slot to the current thread until the environment closes or the thread exits. If MDB_NOTLS is in use, <strong>mdb_txn_begin()</strong> instead ties the slot to the <strong>MDB_txn</strong> object until it or the <strong>MDB_env</strong> object is destroyed. This function may only be called after <strong>mdb_env_create()</strong> and before <strong>mdb_env_open()</strong>.</p><p><strong>Parameters:</strong></p><p><em>env</em> An environment handle returned by <strong>mdb_env_create()</strong></p><p><em>readers</em> The maximum number of reader lock table slots</p><p><strong>Returns:</strong></p><p>A non-zero error value on failure and 0 on success. Some possible errors are:</p><ul>
<li><p>EINVAL - an invalid parameter was specified, or the environment is already open.</p></li>
</ul>
<h3>int \fBESECT\fP mdb_env_get_maxreaders (\fBMDB_env\fP *env, unsigned int *readers)</h3>
<p>Get the maximum number of threads/reader slots for the environment.</p><p><strong>Parameters:</strong></p><p><em>env</em> An environment handle returned by <strong>mdb_env_create()</strong></p><p><em>readers</em> Address of an integer to store the number of readers</p><p><strong>Returns:</strong></p><p>A non-zero error value on failure and 0 on success. Some possible errors are:</p><ul>
<li><p>EINVAL - an invalid parameter was specified.</p></li>
</ul>
<h3>static int \fBESECT\fP mdb_env_open2 (\fBMDB_env\fP *env)\fC [static]\fP</h3>
<p>Further setup required for opening an LMDB environment</p>
<h3>static void mdb_env_reader_dest (void *ptr)\fC [static]\fP</h3>
<p>Release a reader thread's slot in the reader lock table. This function is called automatically when a thread exits.</p><p><strong>Parameters:</strong></p><p><em>ptr</em> This points to the slot in the reader lock table.</p>
<h3>static int \fBESECT\fP mdb_env_share_locks (\fBMDB_env\fP *env, int *excl)\fC [static]\fP</h3>
<p>Downgrade the exclusive lock on the region back to shared</p>
<h3>static int \fBESECT\fP mdb_env_excl_lock (\fBMDB_env\fP *env, int *excl)\fC [static]\fP</h3>
<p>Try to get exlusive lock, otherwise shared. Maintain *excl = -1: no/unknown lock, 0: shared, 1: exclusive.</p>
<h3>static int \fBESECT\fP mdb_env_setup_locks (\fBMDB_env\fP *env, char *lpath, intmode, int *excl)\fC [static]\fP</h3>
<p>Open and/or initialize the lock region for the environment.</p><p><strong>Parameters:</strong></p><p><em>env</em> The LMDB environment.</p><p><em>lpath</em> The pathname of the file used for the lock region.</p><p><em>mode</em> The Unix permissions for the file, if we create it.</p><p><em>excl</em> Resulting file lock type: -1 none, 0 shared, 1 exclusive</p><p><em>excl</em> In -1, out lock type: -1 none, 0 shared, 1 exclusive</p><p><strong>Returns:</strong></p><p>0 on success, non-zero on failure.</p>
<h3>int \fBESECT\fP mdb_env_open (\fBMDB_env\fP *env, const char *path, unsigned intflags, \fBmdb_mode_t\fPmode)</h3>
<p>Open an environment handle. If this function fails, <strong>mdb_env_close()</strong> must be called to discard the <strong>MDB_env</strong> handle.</p><p><strong>Parameters:</strong></p><p><em>env</em> An environment handle returned by <strong>mdb_env_create()</strong></p><p><em>path</em> The directory in which the database files reside. This directory must already exist and be writable.</p><p><em>flags</em> Special options for this environment. This parameter must be set to 0 or by bitwise OR'ing together one or more of the values described here. Flags set by <strong>mdb_env_set_flags()</strong> are also used.</p><ul>
<li><p><strong>MDB_FIXEDMAP</strong> use a fixed address for the mmap region. This flag must be specified when creating the environment, and is stored persistently in the environment. If successful, the memory map will always reside at the same virtual address and pointers used to reference data items in the database will be constant across multiple invocations. This option may not always work, depending on how the operating system has allocated memory to shared libraries and other uses. The feature is highly experimental.</p></li><li><p><strong>MDB_NOSUBDIR</strong> By default, LMDB creates its environment in a directory whose pathname is given in <strong>path</strong>, and creates its data and lock files under that directory. With this option, <strong>path</strong> is used as-is for the database main data file. The database lock file is the <strong>path</strong> with '-lock' appended.</p></li><li><p><strong>MDB_RDONLY</strong> Open the environment in read-only mode. No write operations will be allowed. LMDB will still modify the lock file - except on read-only filesystems, where LMDB does not use locks.</p></li><li><p><strong>MDB_WRITEMAP</strong> Use a writeable memory map unless MDB_RDONLY is set. This is faster and uses fewer mallocs, but loses protection from application bugs like wild pointer writes and other bad updates into the database. Incompatible with nested transactions. Processes with and without MDB_WRITEMAP on the same environment do not cooperate well.</p></li><li><p><strong>MDB_NOMETASYNC</strong> Flush system buffers to disk only once per transaction, omit the metadata flush. Defer that until the system flushes files to disk, or next non-MDB_RDONLY commit or <strong>mdb_env_sync()</strong>. This optimization maintains database integrity, but a system crash may undo the last committed transaction. I.e. it preserves the ACI (atomicity, consistency, isolation) but not D (durability) database property. This flag may be changed at any time using <strong>mdb_env_set_flags()</strong>.</p></li><li><p><strong>MDB_NOSYNC</strong> Don't flush system buffers to disk when committing a transaction. This optimization means a system crash can corrupt the database or lose the last transactions if buffers are not yet flushed to disk. The risk is governed by how often the system flushes dirty buffers to disk and how often <strong>mdb_env_sync()</strong> is called. However, if the filesystem preserves write order and the <strong>MDB_WRITEMAP</strong> flag is not used, transactions exhibit ACI (atomicity, consistency, isolation) properties and only lose D (durability). I.e. database integrity is maintained, but a system crash may undo the final transactions. Note that (<strong>MDB_NOSYNC</strong> | <strong>MDB_WRITEMAP</strong>) leaves the system with no hint for when to write transactions to disk, unless <strong>mdb_env_sync()</strong> is called. (<strong>MDB_MAPASYNC</strong> | <strong>MDB_WRITEMAP</strong>) may be preferable. This flag may be changed at any time using <strong>mdb_env_set_flags()</strong>.</p></li><li><p><strong>MDB_MAPASYNC</strong> When using <strong>MDB_WRITEMAP</strong>, use asynchronous flushes to disk. As with <strong>MDB_NOSYNC</strong>, a system crash can then corrupt the database or lose the last transactions. Calling <strong>mdb_env_sync()</strong> ensures on-disk database integrity until next commit. This flag may be changed at any time using <strong>mdb_env_set_flags()</strong>.</p></li><li><p><strong>MDB_NOTLS</strong> Don't use Thread-Local Storage. Tie reader locktable slots to <strong>MDB_txn</strong> objects instead of to threads. I.e. <strong>mdb_txn_reset()</strong> keeps the slot reseved for the <strong>MDB_txn</strong> object. A thread may use parallel read-only transactions. A read-only transaction may span threads if the user synchronizes its use. Applications that multiplex many user threads over individual OS threads need this option. Such an application must also serialize the write transactions in an OS thread, since LMDB's write locking is unaware of the user threads.</p></li><li><p><strong>MDB_NOLOCK</strong> Don't do any locking. If concurrent access is anticipated, the caller must manage all concurrency itself. For proper operation the caller must enforce single-writer semantics, and must ensure that no readers are using old transactions while a writer is active. The simplest approach is to use an exclusive lock so that no readers may be active at all when a writer begins.</p></li><li><p><strong>MDB_NORDAHEAD</strong> Turn off readahead. Most operating systems perform readahead on read requests by default. This option turns it off if the OS supports it. Turning it off may help random read performance when the DB is larger than RAM and system RAM is full. The option is not implemented on Windows.</p></li><li><p><strong>MDB_NOMEMINIT</strong> Don't initialize malloc'd memory before writing to unused spaces in the data file. By default, memory for pages written to the data file is obtained using malloc. While these pages may be reused in subsequent transactions, freshly malloc'd pages will be initialized to zeroes before use. This avoids persisting leftover data from other code (that used the heap and subsequently freed the memory) into the data file. Note that many other system libraries may allocate and free memory from the heap for arbitrary uses. E.g., stdio may use the heap for file I/O buffers. This initialization step has a modest performance cost so some applications may want to disable it using this flag. This option can be a problem for applications which handle sensitive data like passwords, and it makes memory checkers like Valgrind noisy. This flag is not needed with <strong>MDB_WRITEMAP</strong>, which writes directly to the mmap instead of using malloc for pages. The initialization is also skipped if <strong>MDB_RESERVE</strong> is used; the caller is expected to overwrite all of the memory that was reserved in that case. This flag may be changed at any time using <strong>mdb_env_set_flags()</strong>.</p></li>
</ul><p><em>mode</em> The UNIX permissions to set on created files. This parameter is ignored on Windows.</p><p><strong>Returns:</strong></p><p>A non-zero error value on failure and 0 on success. Some possible errors are:</p><ul>
<li><p><strong>MDB_VERSION_MISMATCH</strong> - the version of the LMDB library doesn't match the version that created the database environment.</p></li><li><p><strong>MDB_INVALID</strong> - the environment file headers are corrupted.</p></li><li><p>ENOENT - the directory specified by the path parameter doesn't exist.</p></li><li><p>EACCES - the user didn't have permission to access the environment files.</p></li><li><p>EAGAIN - the environment was locked by another process.</p></li>
</ul>
<h3>void \fBESECT\fP mdb_env_close (\fBMDB_env\fP *env)</h3>
<p>Close the environment and release the memory map. Only a single thread may call this function. All transactions, databases, and cursors must already be closed before calling this function. Attempts to use any such handles after calling this function will cause a SIGSEGV. The environment handle will be freed and must not be used again after this call.</p><p><strong>Parameters:</strong></p><p><em>env</em> An environment handle returned by <strong>mdb_env_create()</strong></p>
<h3>static int mdb_cmp_long (const \fBMDB_val\fP *a, const \fBMDB_val\fP *b)\fC [static]\fP</h3>
<p>Compare two items pointing at aligned size_t's</p>
<h3>static int mdb_cmp_int (const \fBMDB_val\fP *a, const \fBMDB_val\fP *b)\fC [static]\fP</h3>
<p>Compare two items pointing at aligned unsigned int's</p>
<h3>static int mdb_cmp_cint (const \fBMDB_val\fP *a, const \fBMDB_val\fP *b)\fC [static]\fP</h3>
<p>Compare two items pointing at unsigned ints of unknown alignment. Nodes and keys are guaranteed to be 2-byte aligned.</p>
<h3>static int mdb_cmp_memn (const \fBMDB_val\fP *a, const \fBMDB_val\fP *b)\fC [static]\fP</h3>
<p>Compare two items lexically</p>
<h3>static int mdb_cmp_memnr (const \fBMDB_val\fP *a, const \fBMDB_val\fP *b)\fC [static]\fP</h3>
<p>Compare two items in reverse byte order</p>
<h3>static int mdb_page_search_lowest (\fBMDB_cursor\fP *mc)\fC [static]\fP</h3>
<p>Search for the lowest key under the current branch page. This just bypasses a NUMKEYS check in the current page before calling <strong>mdb_page_search_root()</strong>, because the callers are all in situations where the current page is known to be underfilled.</p>
<h3>int mdb_get (\fBMDB_txn\fP *txn, \fBMDB_dbi\fPdbi, \fBMDB_val\fP *key, \fBMDB_val\fP *data)</h3>
<p>Get items from a database. This function retrieves key/data pairs from the database. The address and length of the data associated with the specified <strong>key</strong> are returned in the structure to which <strong>data</strong> refers. If the database supports duplicate keys (<strong>MDB_DUPSORT</strong>) then the first data item for the key will be returned. Retrieval of other items requires the use of <strong>mdb_cursor_get()</strong>.</p><p><strong>Note:</strong></p><p>The memory pointed to by the returned values is owned by the database. The caller need not dispose of the memory, and may not modify it in any way. For values returned in a read-only transaction any modification attempts will cause a SIGSEGV.</p><p>Values returned from the database are valid only until a subsequent update operation, or the end of the transaction.</p><p><strong>Parameters:</strong></p><p><em>txn</em> A transaction handle returned by <strong>mdb_txn_begin()</strong></p><p><em>dbi</em> A database handle returned by <strong>mdb_dbi_open()</strong></p><p><em>key</em> The key to search for in the database</p><p><em>data</em> The data corresponding to the key</p><p><strong>Returns:</strong></p><p>A non-zero error value on failure and 0 on success. Some possible errors are:</p><ul>
<li><p><strong>MDB_NOTFOUND</strong> - the key was not in the database.</p></li><li><p>EINVAL - an invalid parameter was specified.</p></li>
</ul>
<h3>int mdb_cursor_get (\fBMDB_cursor\fP *cursor, \fBMDB_val\fP *key, \fBMDB_val\fP *data, \fBMDB_cursor_op\fPop)</h3>
<p>Retrieve by cursor. This function retrieves key/data pairs from the database. The address and length of the key are returned in the object to which <strong>key</strong> refers (except for the case of the <strong>MDB_SET</strong> option, in which the <strong>key</strong> object is unchanged), and the address and length of the data are returned in the object to which <strong>data</strong> refers. See <strong>mdb_get()</strong> for restrictions on using the output values.</p><p><strong>Parameters:</strong></p><p><em>cursor</em> A cursor handle returned by <strong>mdb_cursor_open()</strong></p><p><em>key</em> The key for a retrieved item</p><p><em>data</em> The data of a retrieved item</p><p><em>op</em> A cursor operation <strong>MDB_cursor_op</strong></p><p><strong>Returns:</strong></p><p>A non-zero error value on failure and 0 on success. Some possible errors are:</p><ul>
<li><p><strong>MDB_NOTFOUND</strong> - no matching key found.</p></li><li><p>EINVAL - an invalid parameter was specified.</p></li>
</ul>
<h3>static int mdb_cursor_touch (\fBMDB_cursor\fP *mc)\fC [static]\fP</h3>
<p>Touch all the pages in the cursor stack. Set mc_top. Makes sure all the pages are writable, before attempting a write operation.</p><p><strong>Parameters:</strong></p><p><em>mc</em> The cursor to operate on.</p>
<h3>int mdb_cursor_put (\fBMDB_cursor\fP *cursor, \fBMDB_val\fP *key, \fBMDB_val\fP *data, unsigned intflags)</h3>
<p>Store by cursor. This function stores key/data pairs into the database. The cursor is positioned at the new item, or on failure usually near it.</p><p><strong>Note:</strong></p><p>Earlier documentation incorrectly said errors would leave the state of the cursor unchanged.</p><p><strong>Parameters:</strong></p><p><em>cursor</em> A cursor handle returned by <strong>mdb_cursor_open()</strong></p><p><em>key</em> The key operated on.</p><p><em>data</em> The data operated on.</p><p><em>flags</em> Options for this operation. This parameter must be set to 0 or one of the values described here.</p><ul>
<li><p><strong>MDB_CURRENT</strong> - replace the item at the current cursor position. The <strong>key</strong> parameter must still be provided, and must match it. If using sorted duplicates (<strong>MDB_DUPSORT</strong>) the data item must still sort into the same place. This is intended to be used when the new data is the same size as the old. Otherwise it will simply perform a delete of the old record followed by an insert.</p></li><li><p><strong>MDB_NODUPDATA</strong> - enter the new key/data pair only if it does not already appear in the database. This flag may only be specified if the database was opened with <strong>MDB_DUPSORT</strong>. The function will return <strong>MDB_KEYEXIST</strong> if the key/data pair already appears in the database.</p></li><li><p><strong>MDB_NOOVERWRITE</strong> - enter the new key/data pair only if the key does not already appear in the database. The function will return <strong>MDB_KEYEXIST</strong> if the key already appears in the database, even if the database supports duplicates (<strong>MDB_DUPSORT</strong>).</p></li><li><p><strong>MDB_RESERVE</strong> - reserve space for data of the given size, but don't copy the given data. Instead, return a pointer to the reserved space, which the caller can fill in later. This saves an extra memcpy if the data is being generated later.</p></li><li><p><strong>MDB_APPEND</strong> - append the given key/data pair to the end of the database. No key comparisons are performed. This option allows fast bulk loading when keys are already known to be in the correct order. Loading unsorted keys with this flag will cause data corruption.</p></li><li><p><strong>MDB_APPENDDUP</strong> - as above, but for sorted dup data.</p></li><li><p><strong>MDB_MULTIPLE</strong> - store multiple contiguous data elements in a single request. This flag may only be specified if the database was opened with <strong>MDB_DUPFIXED</strong>. The <strong>data</strong> argument must be an array of two MDB_vals. The mv_size of the first <strong>MDB_val</strong> must be the size of a single data element. The mv_data of the first <strong>MDB_val</strong> must point to the beginning of the array of contiguous data elements. The mv_size of the second <strong>MDB_val</strong> must be the count of the number of data elements to store. On return this field will be set to the count of the number of elements actually written. The mv_data of the second <strong>MDB_val</strong> is unused.</p></li>
</ul><p><strong>Returns:</strong></p><p>A non-zero error value on failure and 0 on success. Some possible errors are:</p><ul>
<li><p><strong>MDB_MAP_FULL</strong> - the database is full, see <strong>mdb_env_set_mapsize()</strong>.</p></li><li><p><strong>MDB_TXN_FULL</strong> - the transaction has too many dirty pages.</p></li><li><p>EACCES - an attempt was made to modify a read-only database.</p></li><li><p>EINVAL - an invalid parameter was specified.</p></li>
</ul>
<h3>int mdb_cursor_del (\fBMDB_cursor\fP *cursor, unsigned intflags)</h3>
<p>Delete current key/data pair. This function deletes the key/data pair to which the cursor refers.</p><p><strong>Parameters:</strong></p><p><em>cursor</em> A cursor handle returned by <strong>mdb_cursor_open()</strong></p><p><em>flags</em> Options for this operation. This parameter must be set to 0 or one of the values described here.</p><ul>
<li><p><strong>MDB_NODUPDATA</strong> - delete all of the data items for the current key. This flag may only be specified if the database was opened with <strong>MDB_DUPSORT</strong>.</p></li>
</ul><p><strong>Returns:</strong></p><p>A non-zero error value on failure and 0 on success. Some possible errors are:</p><ul>
<li><p>EACCES - an attempt was made to modify a read-only database.</p></li><li><p>EINVAL - an invalid parameter was specified.</p></li>
</ul>
<h3>int mdb_cursor_open (\fBMDB_txn\fP *txn, \fBMDB_dbi\fPdbi, \fBMDB_cursor\fP **cursor)</h3>
<p>Create a cursor handle. A cursor is associated with a specific transaction and database. A cursor cannot be used when its database handle is closed. Nor when its transaction has ended, except with <strong>mdb_cursor_renew()</strong>. It can be discarded with <strong>mdb_cursor_close()</strong>. A cursor in a write-transaction can be closed before its transaction ends, and will otherwise be closed when its transaction ends. A cursor in a read-only transaction must be closed explicitly, before or after its transaction ends. It can be reused with <strong>mdb_cursor_renew()</strong> before finally closing it.</p><p><strong>Note:</strong></p><p>Earlier documentation said that cursors in every transaction were closed when the transaction committed or aborted.</p><p><strong>Parameters:</strong></p><p><em>txn</em> A transaction handle returned by <strong>mdb_txn_begin()</strong></p><p><em>dbi</em> A database handle returned by <strong>mdb_dbi_open()</strong></p><p><em>cursor</em> Address where the new <strong>MDB_cursor</strong> handle will be stored</p><p><strong>Returns:</strong></p><p>A non-zero error value on failure and 0 on success. Some possible errors are:</p><ul>
<li><p>EINVAL - an invalid parameter was specified.</p></li>
</ul>
<h3>int mdb_cursor_renew (\fBMDB_txn\fP *txn, \fBMDB_cursor\fP *cursor)</h3>
<p>Renew a cursor handle. A cursor is associated with a specific transaction and database. Cursors that are only used in read-only transactions may be re-used, to avoid unnecessary malloc/free overhead. The cursor may be associated with a new read-only transaction, and referencing the same database handle as it was created with. This may be done whether the previous transaction is live or dead.</p><p><strong>Parameters:</strong></p><p><em>txn</em> A transaction handle returned by <strong>mdb_txn_begin()</strong></p><p><em>cursor</em> A cursor handle returned by <strong>mdb_cursor_open()</strong></p><p><strong>Returns:</strong></p><p>A non-zero error value on failure and 0 on success. Some possible errors are:</p><ul>
<li><p>EINVAL - an invalid parameter was specified.</p></li>
</ul>
<h3>int mdb_cursor_count (\fBMDB_cursor\fP *cursor, size_t *countp)</h3>
<p>Return count of duplicates for current key. This call is only valid on databases that support sorted duplicate data items <strong>MDB_DUPSORT</strong>.</p><p><strong>Parameters:</strong></p><p><em>cursor</em> A cursor handle returned by <strong>mdb_cursor_open()</strong></p><p><em>countp</em> Address where the count will be stored</p><p><strong>Returns:</strong></p><p>A non-zero error value on failure and 0 on success. Some possible errors are:</p><ul>
<li><p>EINVAL - cursor is not initialized, or an invalid parameter was specified.</p></li>
</ul>
<h3>void mdb_cursor_close (\fBMDB_cursor\fP *cursor)</h3>
<p>Close a cursor handle. The cursor handle will be freed and must not be used again after this call. Its transaction must still be live if it is a write-transaction.</p><p><strong>Parameters:</strong></p><p><em>cursor</em> A cursor handle returned by <strong>mdb_cursor_open()</strong></p>
<h3>\fBMDB_txn\fP* mdb_cursor_txn (\fBMDB_cursor\fP *cursor)</h3>
<p>Return the cursor's transaction handle.</p><p><strong>Parameters:</strong></p><p><em>cursor</em> A cursor handle returned by <strong>mdb_cursor_open()</strong></p>
<h3>\fBMDB_dbi\fP mdb_cursor_dbi (\fBMDB_cursor\fP *cursor)</h3>
<p>Return the cursor's database handle.</p><p><strong>Parameters:</strong></p><p><em>cursor</em> A cursor handle returned by <strong>mdb_cursor_open()</strong></p>
<h3>static void mdb_cursor_copy (const \fBMDB_cursor\fP *csrc, \fBMDB_cursor\fP *cdst)\fC [static]\fP</h3>
<p>Copy the contents of a cursor.</p><p><strong>Parameters:</strong></p><p><em>csrc</em> The cursor to copy from.</p><p><em>cdst</em> The cursor to copy to.</p>
<h3>int mdb_del (\fBMDB_txn\fP *txn, \fBMDB_dbi\fPdbi, \fBMDB_val\fP *key, \fBMDB_val\fP *data)</h3>
<p>Delete items from a database. This function removes key/data pairs from the database. If the database does not support sorted duplicate data items (<strong>MDB_DUPSORT</strong>) the data parameter is ignored. If the database supports sorted duplicates and the data parameter is NULL, all of the duplicate data items for the key will be deleted. Otherwise, if the data parameter is non-NULL only the matching data item will be deleted. This function will return <strong>MDB_NOTFOUND</strong> if the specified key/data pair is not in the database.</p><p><strong>Parameters:</strong></p><p><em>txn</em> A transaction handle returned by <strong>mdb_txn_begin()</strong></p><p><em>dbi</em> A database handle returned by <strong>mdb_dbi_open()</strong></p><p><em>key</em> The key to delete from the database</p><p><em>data</em> The data to delete</p><p><strong>Returns:</strong></p><p>A non-zero error value on failure and 0 on success. Some possible errors are:</p><ul>
<li><p>EACCES - an attempt was made to write in a read-only transaction.</p></li><li><p>EINVAL - an invalid parameter was specified.</p></li>
</ul>
<h3>int mdb_put (\fBMDB_txn\fP *txn, \fBMDB_dbi\fPdbi, \fBMDB_val\fP *key, \fBMDB_val\fP *data, unsigned intflags)</h3>
<p>Store items into a database. This function stores key/data pairs in the database. The default behavior is to enter the new key/data pair, replacing any previously existing key if duplicates are disallowed, or adding a duplicate data item if duplicates are allowed (<strong>MDB_DUPSORT</strong>).</p><p><strong>Parameters:</strong></p><p><em>txn</em> A transaction handle returned by <strong>mdb_txn_begin()</strong></p><p><em>dbi</em> A database handle returned by <strong>mdb_dbi_open()</strong></p><p><em>key</em> The key to store in the database</p><p><em>data</em> The data to store</p><p><em>flags</em> Special options for this operation. This parameter must be set to 0 or by bitwise OR'ing together one or more of the values described here.</p><ul>
<li><p><strong>MDB_NODUPDATA</strong> - enter the new key/data pair only if it does not already appear in the database. This flag may only be specified if the database was opened with <strong>MDB_DUPSORT</strong>. The function will return <strong>MDB_KEYEXIST</strong> if the key/data pair already appears in the database.</p></li><li><p><strong>MDB_NOOVERWRITE</strong> - enter the new key/data pair only if the key does not already appear in the database. The function will return <strong>MDB_KEYEXIST</strong> if the key already appears in the database, even if the database supports duplicates (<strong>MDB_DUPSORT</strong>). The <strong>data</strong> parameter will be set to point to the existing item.</p></li><li><p><strong>MDB_RESERVE</strong> - reserve space for data of the given size, but don't copy the given data. Instead, return a pointer to the reserved space, which the caller can fill in later - before the next update operation or the transaction ends. This saves an extra memcpy if the data is being generated later. LMDB does nothing else with this memory, the caller is expected to modify all of the space requested.</p></li><li><p><strong>MDB_APPEND</strong> - append the given key/data pair to the end of the database. No key comparisons are performed. This option allows fast bulk loading when keys are already known to be in the correct order. Loading unsorted keys with this flag will cause data corruption.</p></li><li><p><strong>MDB_APPENDDUP</strong> - as above, but for sorted dup data.</p></li>
</ul><p><strong>Returns:</strong></p><p>A non-zero error value on failure and 0 on success. Some possible errors are:</p><ul>
<li><p><strong>MDB_MAP_FULL</strong> - the database is full, see <strong>mdb_env_set_mapsize()</strong>.</p></li><li><p><strong>MDB_TXN_FULL</strong> - the transaction has too many dirty pages.</p></li><li><p>EACCES - an attempt was made to write in a read-only transaction.</p></li><li><p>EINVAL - an invalid parameter was specified.</p></li>
</ul>
<h3>static THREAD_RET \fBESECT\fP mdb_env_copythr (void *arg)\fC [static]\fP</h3>
<p>Dedicated writer thread for compacting copy.</p>
<h3>static int \fBESECT\fP mdb_env_cthr_toggle (\fBmdb_copy\fP *my, intst)\fC [static]\fP</h3>
<p>Tell the writer thread there's a buffer ready to write</p>
<h3>static int \fBESECT\fP mdb_env_cwalk (\fBmdb_copy\fP *my, \fBpgno_t\fP *pg, intflags)\fC [static]\fP</h3>
<p>Depth-first tree traversal for compacting copy.</p>
<h3>static int \fBESECT\fP mdb_env_copyfd1 (\fBMDB_env\fP *env, \fBHANDLE\fPfd)\fC [static]\fP</h3>
<p>Copy environment with compaction.</p>
<h3>static int \fBESECT\fP mdb_env_copyfd0 (\fBMDB_env\fP *env, \fBHANDLE\fPfd)\fC [static]\fP</h3>
<p>Copy environment as-is.</p>
<h3>int \fBESECT\fP mdb_env_copy2 (\fBMDB_env\fP *env, const char *path, unsigned intflags)</h3>
<p>Copy an LMDB environment to the specified path, with options. This function may be used to make a backup of an existing environment. No lockfile is created, since it gets recreated at need.</p><p><strong>Note:</strong></p><p>This call can trigger significant file size growth if run in parallel with write transactions, because it employs a read-only transaction. See long-lived transactions under <strong>Caveats</strong>.</p><p><strong>Parameters:</strong></p><p><em>env</em> An environment handle returned by <strong>mdb_env_create()</strong>. It must have already been opened successfully.</p><p><em>path</em> The directory in which the copy will reside. This directory must already exist and be writable but must otherwise be empty.</p><p><em>flags</em> Special options for this operation. This parameter must be set to 0 or by bitwise OR'ing together one or more of the values described here.</p><ul>
<li><p><strong>MDB_CP_COMPACT</strong> - Perform compaction while copying: omit free pages and sequentially renumber all pages in output. This option consumes more CPU and runs more slowly than the default.</p></li>
</ul><p><strong>Returns:</strong></p><p>A non-zero error value on failure and 0 on success.</p>
<h3>int \fBESECT\fP mdb_env_copy (\fBMDB_env\fP *env, const char *path)</h3>
<p>Copy an LMDB environment to the specified path. This function may be used to make a backup of an existing environment. No lockfile is created, since it gets recreated at need.</p><p><strong>Note:</strong></p><p>This call can trigger significant file size growth if run in parallel with write transactions, because it employs a read-only transaction. See long-lived transactions under <strong>Caveats</strong>.</p><p><strong>Parameters:</strong></p><p><em>env</em> An environment handle returned by <strong>mdb_env_create()</strong>. It must have already been opened successfully.</p><p><em>path</em> The directory in which the copy will reside. This directory must already exist and be writable but must otherwise be empty.</p><p><strong>Returns:</strong></p><p>A non-zero error value on failure and 0 on success.</p>
<h3>int \fBESECT\fP mdb_env_set_flags (\fBMDB_env\fP *env, unsigned intflags, intonoff)</h3>
<p>Set environment flags. This may be used to set some flags in addition to those from <strong>mdb_env_open()</strong>, or to unset these flags. If several threads change the flags at the same time, the result is undefined.</p><p><strong>Parameters:</strong></p><p><em>env</em> An environment handle returned by <strong>mdb_env_create()</strong></p><p><em>flags</em> The flags to change, bitwise OR'ed together</p><p><em>onoff</em> A non-zero value sets the flags, zero clears them.</p><p><strong>Returns:</strong></p><p>A non-zero error value on failure and 0 on success. Some possible errors are:</p><ul>
<li><p>EINVAL - an invalid parameter was specified.</p></li>
</ul>
<h3>int \fBESECT\fP mdb_env_get_flags (\fBMDB_env\fP *env, unsigned int *flags)</h3>
<p>Get environment flags.</p><p><strong>Parameters:</strong></p><p><em>env</em> An environment handle returned by <strong>mdb_env_create()</strong></p><p><em>flags</em> The address of an integer to store the flags</p><p><strong>Returns:</strong></p><p>A non-zero error value on failure and 0 on success. Some possible errors are:</p><ul>
<li><p>EINVAL - an invalid parameter was specified.</p></li>
</ul>
<h3>int \fBESECT\fP mdb_env_set_userctx (\fBMDB_env\fP *env, void *ctx)</h3>
<p>Set application information associated with the <strong>MDB_env</strong>.</p><p><strong>Parameters:</strong></p><p><em>env</em> An environment handle returned by <strong>mdb_env_create()</strong></p><p><em>ctx</em> An arbitrary pointer for whatever the application needs.</p><p><strong>Returns:</strong></p><p>A non-zero error value on failure and 0 on success.</p>
<h3>void* \fBESECT\fP mdb_env_get_userctx (\fBMDB_env\fP *env)</h3>
<p>Get the application information associated with the <strong>MDB_env</strong>.</p><p><strong>Parameters:</strong></p><p><em>env</em> An environment handle returned by <strong>mdb_env_create()</strong></p><p><strong>Returns:</strong></p><p>The pointer set by <strong>mdb_env_set_userctx()</strong>.</p>
<h3>int \fBESECT\fP mdb_env_set_assert (\fBMDB_env\fP *env, \fBMDB_assert_func\fP *func)</h3>
<p>Set or reset the assert() callback of the environment. Disabled if liblmdb is buillt with NDEBUG.</p><p><strong>Note:</strong></p><p>This hack should become obsolete as lmdb's error handling matures.</p><p><strong>Parameters:</strong></p><p><em>env</em> An environment handle returned by <strong>mdb_env_create()</strong>.</p><p><em>func</em> An <strong>MDB_assert_func</strong> function, or 0.</p><p><strong>Returns:</strong></p><p>A non-zero error value on failure and 0 on success.</p>
<h3>int \fBESECT\fP mdb_env_get_path (\fBMDB_env\fP *env, const char **path)</h3>
<p>Return the path that was used in <strong>mdb_env_open()</strong>.</p><p><strong>Parameters:</strong></p><p><em>env</em> An environment handle returned by <strong>mdb_env_create()</strong></p><p><em>path</em> Address of a string pointer to contain the path. This is the actual string in the environment, not a copy. It should not be altered in any way.</p><p><strong>Returns:</strong></p><p>A non-zero error value on failure and 0 on success. Some possible errors are:</p><ul>
<li><p>EINVAL - an invalid parameter was specified.</p></li>
</ul>
<h3>int \fBESECT\fP mdb_env_get_fd (\fBMDB_env\fP *env, \fBmdb_filehandle_t\fP *fd)</h3>
<p>Return the filedescriptor for the given environment.</p><p><strong>Parameters:</strong></p><p><em>env</em> An environment handle returned by <strong>mdb_env_create()</strong></p><p><em>fd</em> Address of a mdb_filehandle_t to contain the descriptor.</p><p><strong>Returns:</strong></p><p>A non-zero error value on failure and 0 on success. Some possible errors are:</p><ul>
<li><p>EINVAL - an invalid parameter was specified.</p></li>
</ul>
<h3>static int \fBESECT\fP mdb_stat0 (\fBMDB_env\fP *env, \fBMDB_db\fP *db, \fBMDB_stat\fP *arg)\fC [static]\fP</h3>
<p>Common code for <strong>mdb_stat()</strong> and <strong>mdb_env_stat()</strong>.</p><p><strong>Parameters:</strong></p><p><em>env</em> the environment to operate in.</p><p><em>db</em> the <strong>MDB_db</strong> record containing the stats to return.</p><p><em>arg</em> the address of an <strong>MDB_stat</strong> structure to receive the stats.</p><p><strong>Returns:</strong></p><p>0, this function always succeeds.</p>
<h3>int \fBESECT\fP mdb_env_stat (\fBMDB_env\fP *env, \fBMDB_stat\fP *stat)</h3>
<p>Return statistics about the LMDB environment.</p><p><strong>Parameters:</strong></p><p><em>env</em> An environment handle returned by <strong>mdb_env_create()</strong></p><p><em>stat</em> The address of an <strong>MDB_stat</strong> structure where the statistics will be copied</p>
<h3>int \fBESECT\fP mdb_env_info (\fBMDB_env\fP *env, \fBMDB_envinfo\fP *stat)</h3>
<p>Return information about the LMDB environment.</p><p><strong>Parameters:</strong></p><p><em>env</em> An environment handle returned by <strong>mdb_env_create()</strong></p><p><em>stat</em> The address of an <strong>MDB_envinfo</strong> structure where the information will be copied</p>
<h3>int mdb_dbi_open (\fBMDB_txn\fP *txn, const char *name, unsigned intflags, \fBMDB_dbi\fP *dbi)</h3>
<p>Open a database in the environment. A database handle denotes the name and parameters of a database, independently of whether such a database exists. The database handle may be discarded by calling <strong>mdb_dbi_close()</strong>. The old database handle is returned if the database was already open. The handle may only be closed once. The database handle will be private to the current transaction until the transaction is successfully committed. If the transaction is aborted the handle will be closed automatically. After a successful commit the handle will reside in the shared environment, and may be used by other transactions. This function must not be called from multiple concurrent transactions. A transaction that uses this function must finish (either commit or abort) before any other transaction may use this function.</p><p>To use named databases (with name != NULL), <strong>mdb_env_set_maxdbs()</strong> must be called before opening the environment. Database names are kept as keys in the unnamed database.</p><p><strong>Parameters:</strong></p><p><em>txn</em> A transaction handle returned by <strong>mdb_txn_begin()</strong></p><p><em>name</em> The name of the database to open. If only a single database is needed in the environment, this value may be NULL.</p><p><em>flags</em> Special options for this database. This parameter must be set to 0 or by bitwise OR'ing together one or more of the values described here.</p><ul>
<li><p><strong>MDB_REVERSEKEY</strong> Keys are strings to be compared in reverse order, from the end of the strings to the beginning. By default, Keys are treated as strings and compared from beginning to end.</p></li><li><p><strong>MDB_DUPSORT</strong> Duplicate keys may be used in the database. (Or, from another perspective, keys may have multiple data items, stored in sorted order.) By default keys must be unique and may have only a single data item.</p></li><li><p><strong>MDB_INTEGERKEY</strong> Keys are binary integers in native byte order. Setting this option requires all keys to be the same size, typically sizeof(int) or sizeof(size_t).</p></li><li><p><strong>MDB_DUPFIXED</strong> This flag may only be used in combination with <strong>MDB_DUPSORT</strong>. This option tells the library that the data items for this database are all the same size, which allows further optimizations in storage and retrieval. When all data items are the same size, the <strong>MDB_GET_MULTIPLE</strong> and <strong>MDB_NEXT_MULTIPLE</strong> cursor operations may be used to retrieve multiple items at once.</p></li><li><p><strong>MDB_INTEGERDUP</strong> This option specifies that duplicate data items are also integers, and should be sorted as such.</p></li><li><p><strong>MDB_REVERSEDUP</strong> This option specifies that duplicate data items should be compared as strings in reverse order.</p></li><li><p><strong>MDB_CREATE</strong> Create the named database if it doesn't exist. This option is not allowed in a read-only transaction or a read-only environment.</p></li>
</ul><p><em>dbi</em> Address where the new <strong>MDB_dbi</strong> handle will be stored</p><p><strong>Returns:</strong></p><p>A non-zero error value on failure and 0 on success. Some possible errors are:</p><ul>
<li><p><strong>MDB_NOTFOUND</strong> - the specified database doesn't exist in the environment and <strong>MDB_CREATE</strong> was not specified.</p></li><li><p><strong>MDB_DBS_FULL</strong> - too many databases have been opened. See <strong>mdb_env_set_maxdbs()</strong>.</p></li>
</ul>
<h3>int mdb_stat (\fBMDB_txn\fP *txn, \fBMDB_dbi\fPdbi, \fBMDB_stat\fP *stat)</h3>
<p>Retrieve statistics for a database.</p><p><strong>Parameters:</strong></p><p><em>txn</em> A transaction handle returned by <strong>mdb_txn_begin()</strong></p><p><em>dbi</em> A database handle returned by <strong>mdb_dbi_open()</strong></p><p><em>stat</em> The address of an <strong>MDB_stat</strong> structure where the statistics will be copied</p><p><strong>Returns:</strong></p><p>A non-zero error value on failure and 0 on success. Some possible errors are:</p><ul>
<li><p>EINVAL - an invalid parameter was specified.</p></li>
</ul>
<h3>void mdb_dbi_close (\fBMDB_env\fP *env, \fBMDB_dbi\fPdbi)</h3>
<p>Close a database handle. Normally unnecessary. Use with care: This call is not mutex protected. Handles should only be closed by a single thread, and only if no other threads are going to reference the database handle or one of its cursors any further. Do not close a handle if an existing transaction has modified its database. Doing so can cause misbehavior from database corruption to errors like MDB_BAD_VALSIZE (since the DB name is gone).</p><p>Closing a database handle is not necessary, but lets <strong>mdb_dbi_open()</strong> reuse the handle value. Usually it's better to set a bigger <strong>mdb_env_set_maxdbs()</strong>, unless that value would be large.</p><p><strong>Parameters:</strong></p><p><em>env</em> An environment handle returned by <strong>mdb_env_create()</strong></p><p><em>dbi</em> A database handle returned by <strong>mdb_dbi_open()</strong></p>
<h3>int mdb_dbi_flags (\fBMDB_txn\fP *txn, \fBMDB_dbi\fPdbi, unsigned int *flags)</h3>
<p>Retrieve the DB flags for a database handle.</p><p><strong>Parameters:</strong></p><p><em>txn</em> A transaction handle returned by <strong>mdb_txn_begin()</strong></p><p><em>dbi</em> A database handle returned by <strong>mdb_dbi_open()</strong></p><p><em>flags</em> Address where the flags will be returned.</p><p><strong>Returns:</strong></p><p>A non-zero error value on failure and 0 on success.</p>
<h3>int mdb_drop (\fBMDB_txn\fP *txn, \fBMDB_dbi\fPdbi, intdel)</h3>
<p>Empty or delete+close a database. See <strong>mdb_dbi_close()</strong> for restrictions about closing the DB handle.</p><p><strong>Parameters:</strong></p><p><em>txn</em> A transaction handle returned by <strong>mdb_txn_begin()</strong></p><p><em>dbi</em> A database handle returned by <strong>mdb_dbi_open()</strong></p><p><em>del</em> 0 to empty the DB, 1 to delete it from the environment and close the DB handle.</p><p><strong>Returns:</strong></p><p>A non-zero error value on failure and 0 on success.</p>
<h3>int mdb_set_compare (\fBMDB_txn\fP *txn, \fBMDB_dbi\fPdbi, \fBMDB_cmp_func\fP *cmp)</h3>
<p>Set a custom key comparison function for a database. The comparison function is called whenever it is necessary to compare a key specified by the application with a key currently stored in the database. If no comparison function is specified, and no special key flags were specified with <strong>mdb_dbi_open()</strong>, the keys are compared lexically, with shorter keys collating before longer keys.</p><p><strong>Warning:</strong></p><p>This function must be called before any data access functions are used, otherwise data corruption may occur. The same comparison function must be used by every program accessing the database, every time the database is used.</p><p><strong>Parameters:</strong></p><p><em>txn</em> A transaction handle returned by <strong>mdb_txn_begin()</strong></p><p><em>dbi</em> A database handle returned by <strong>mdb_dbi_open()</strong></p><p><em>cmp</em> A <strong>MDB_cmp_func</strong> function</p><p><strong>Returns:</strong></p><p>A non-zero error value on failure and 0 on success. Some possible errors are:</p><ul>
<li><p>EINVAL - an invalid parameter was specified.</p></li>
</ul>
<h3>int mdb_set_dupsort (\fBMDB_txn\fP *txn, \fBMDB_dbi\fPdbi, \fBMDB_cmp_func\fP *cmp)</h3>
<p>Set a custom data comparison function for a <strong>MDB_DUPSORT</strong> database. This comparison function is called whenever it is necessary to compare a data item specified by the application with a data item currently stored in the database. This function only takes effect if the database was opened with the <strong>MDB_DUPSORT</strong> flag. If no comparison function is specified, and no special key flags were specified with <strong>mdb_dbi_open()</strong>, the data items are compared lexically, with shorter items collating before longer items.</p><p><strong>Warning:</strong></p><p>This function must be called before any data access functions are used, otherwise data corruption may occur. The same comparison function must be used by every program accessing the database, every time the database is used.</p><p><strong>Parameters:</strong></p><p><em>txn</em> A transaction handle returned by <strong>mdb_txn_begin()</strong></p><p><em>dbi</em> A database handle returned by <strong>mdb_dbi_open()</strong></p><p><em>cmp</em> A <strong>MDB_cmp_func</strong> function</p><p><strong>Returns:</strong></p><p>A non-zero error value on failure and 0 on success. Some possible errors are:</p><ul>
<li><p>EINVAL - an invalid parameter was specified.</p></li>
</ul>
<h3>int mdb_set_relfunc (\fBMDB_txn\fP *txn, \fBMDB_dbi\fPdbi, \fBMDB_rel_func\fP *rel)</h3>
<p>Set a relocation function for a <strong>MDB_FIXEDMAP</strong> database.</p><p><strong>Todo</strong></p><p>The relocation function is called whenever it is necessary to move the data of an item to a different position in the database (e.g. through tree balancing operations, shifts as a result of adds or deletes, etc.). It is intended to allow address/position-dependent data items to be stored in a database in an environment opened with the <strong>MDB_FIXEDMAP</strong> option. Currently the relocation feature is unimplemented and setting this function has no effect.</p><p><strong>Parameters:</strong></p><p><em>txn</em> A transaction handle returned by <strong>mdb_txn_begin()</strong></p><p><em>dbi</em> A database handle returned by <strong>mdb_dbi_open()</strong></p><p><em>rel</em> A <strong>MDB_rel_func</strong> function</p><p><strong>Returns:</strong></p><p>A non-zero error value on failure and 0 on success. Some possible errors are:</p><ul>
<li><p>EINVAL - an invalid parameter was specified.</p></li>
</ul>
<h3>int mdb_set_relctx (\fBMDB_txn\fP *txn, \fBMDB_dbi\fPdbi, void *ctx)</h3>
<p>Set a context pointer for a <strong>MDB_FIXEDMAP</strong> database's relocation function. See <strong>mdb_set_relfunc</strong> and <strong>MDB_rel_func</strong> for more details.</p><p><strong>Parameters:</strong></p><p><em>txn</em> A transaction handle returned by <strong>mdb_txn_begin()</strong></p><p><em>dbi</em> A database handle returned by <strong>mdb_dbi_open()</strong></p><p><em>ctx</em> An arbitrary pointer for whatever the application needs. It will be passed to the callback function set by <strong>mdb_set_relfunc</strong> as its <strong>relctx</strong> parameter whenever the callback is invoked.</p><p><strong>Returns:</strong></p><p>A non-zero error value on failure and 0 on success. Some possible errors are:</p><ul>
<li><p>EINVAL - an invalid parameter was specified.</p></li>
</ul>
<h3>int \fBESECT\fP mdb_env_get_maxkeysize (\fBMDB_env\fP *env)</h3>
<p>Get the maximum size of keys and <strong>MDB_DUPSORT</strong> data we can write. Depends on the compile-time constant <strong>MDB_MAXKEYSIZE</strong>. Default 511. See <strong>MDB_val</strong>.</p><p><strong>Parameters:</strong></p><p><em>env</em> An environment handle returned by <strong>mdb_env_create()</strong></p><p><strong>Returns:</strong></p><p>The maximum size of a key we can write</p>
<h3>int \fBESECT\fP mdb_reader_list (\fBMDB_env\fP *env, \fBMDB_msg_func\fP *func, void *ctx)</h3>
<p>Dump the entries in the reader lock table.</p><p><strong>Parameters:</strong></p><p><em>env</em> An environment handle returned by <strong>mdb_env_create()</strong></p><p><em>func</em> A <strong>MDB_msg_func</strong> function</p><p><em>ctx</em> Anything the message function needs</p><p><strong>Returns:</strong></p><p>&lt; 0 on failure, &gt;= 0 on success.</p>
<h3>static int \fBESECT\fP mdb_pid_insert (MDB_PID_T *ids, MDB_PID_Tpid)\fC [static]\fP</h3>
<p>Insert pid into list if not already present. return -1 if already present.</p>
<h3>int \fBESECT\fP mdb_reader_check (\fBMDB_env\fP *env, int *dead)</h3>
<p>Check for stale entries in the reader lock table.</p><p><strong>Parameters:</strong></p><p><em>env</em> An environment handle returned by <strong>mdb_env_create()</strong></p><p><em>dead</em> Number of stale slots that were cleared</p><p><strong>Returns:</strong></p><p>0 on success, non-zero on failure.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Variable Documentation</h2>
        <div class="sectioncontent">
<h3>char* const mdb_errstr[]\fC [static]\fP</h3>
<p><strong>Initial value:</strong></p>
<pre>
= {
    "MDB_KEYEXIST: Key/data pair already exists",
    "MDB_NOTFOUND: No matching key/data pair found",
    "MDB_PAGE_NOTFOUND: Requested page not found",
    "MDB_CORRUPTED: Located page was wrong type",
    "MDB_PANIC: Update of meta page failed",
    "MDB_VERSION_MISMATCH: Database environment version mismatch",
    "MDB_INVALID: File is not an LMDB file",
    "MDB_MAP_FULL: Environment mapsize limit reached",
    "MDB_DBS_FULL: Environment maxdbs limit reached",
    "MDB_READERS_FULL: Environment maxreaders limit reached",
    "MDB_TLS_FULL: Thread-local storage keys full - too many environments open",
    "MDB_TXN_FULL: Transaction has too many dirty pages - transaction too big",
    "MDB_CURSOR_FULL: Internal error - cursor stack limit reached",
    "MDB_PAGE_FULL: Internal error - page has no more space",
    "MDB_MAP_RESIZED: Database contents grew beyond environment mapsize",
    "MDB_INCOMPATIBLE: Operation and DB incompatible, or DB flags changed",
    "MDB_BAD_RSLOT: Invalid reuse of reader locktable slot",
    "MDB_BAD_TXN: Transaction cannot recover - it must be aborted",
    "MDB_BAD_VALSIZE: Unsupported size of key/DB name/data, or wrong DUPFIXED size",
    "MDB_BAD_DBI: The specified DBI handle was closed/changed unexpectedly",
}
</pre>
<p>Table of descriptions for LMDB <strong>Return Codes</strong></p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for LMDB from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="mdb_idls.3.html"><span aria-hidden="true">&larr;</span> mdb_idls.3: Id list management -</a></li>
   <li class="next"><a href="mdb_lmdb.h.3.html">mdb_lmdb.h.3: Lightning memory-mapped database library. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

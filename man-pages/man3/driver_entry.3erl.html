<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>driver_entry: The driver-entry structure used by erlang drivers.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The driver-entry structure used by erlang drivers.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="driver_entry (3erl) manual">
  <meta name="twitter:description" content="The driver-entry structure used by erlang drivers.">
  <meta name="twitter:image" content="https://www.carta.tech/images/erlang-manpages-driver_entry-3erl.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3erl/driver_entry.3erl.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="driver_entry (3erl) manual" />
  <meta property="og:description" content="The driver-entry structure used by erlang drivers." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/erlang-manpages-driver_entry-3erl.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">driver_entry<small> (3erl)</small></h1>
        <p class="lead">The driver-entry structure used by erlang drivers.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/driver_entry.3erl.html">
      <span itemprop="name">driver_entry: The driver-entry structure used by erlang drivers.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/erlang-manpages/">
      <span itemprop="name">erlang-manpages</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/driver_entry.3erl.html">
      <span itemprop="name">driver_entry: The driver-entry structure used by erlang drivers.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><strong></strong> Warning:</p><p><em>Use this functionality with extreme care!</em></p><p>A driver callback is executed as a direct extension of the native code of the VM. Execution is not made in a safe environment. The VM can <em>not</em> provide the same services as provided when executing Erlang code, such as preemptive scheduling or memory protection. If the driver callback function doesn't behave well, the whole VM will misbehave.</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>A driver callback that crash will crash the whole VM.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>An erroneously implemented driver callback might cause a VM internal state inconsistency which may cause a crash of the VM, or miscellaneous misbehaviors of the VM at any point after the call to the driver callback.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>A driver callback that do <strong>lengthy work</strong> before returning will degrade responsiveness of the VM, and may cause miscellaneous strange behaviors. Such strange behaviors include, but are not limited to, extreme memory usage, and bad load balancing between schedulers. Strange behaviors that might occur due to lengthy work may also vary between OTP releases.</p>
  </dd>

</dl>
<p>As of erts version 5.9 (OTP release R15B) the driver interface has been changed with larger types for the callbacks <strong>output</strong>, <strong>control</strong> and <strong>call</strong>. See driver <strong> version management</strong> in <strong>erl_driver</strong>.</p><p><strong></strong> Note:</p><p>Old drivers (compiled with an <em>erl_driver.h</em> from an earlier erts version than 5.9) have to be updated and have to use the extended interface (with <strong>version management </strong>).</p><p>The <em>driver_entry</em> structure is a C struct that all erlang drivers define. It contains entry points for the erlang driver that are called by the erlang emulator when erlang code accesses the driver.</p><p>The <strong>erl_driver</strong> driver API functions need a port handle that identifies the driver instance (and the port in the emulator). This is only passed to the <em>start</em> function, but not to the other functions. The <em>start</em> function returns a driver-defined handle that is passed to the other functions. A common practice is to have the <em>start</em> function allocate some application-defined structure and stash the <em>port</em> handle in it, to use it later with the driver API functions.</p><p>The driver call-back functions are called synchronously from the erlang emulator. If they take too long before completing, they can cause timeouts in the emulator. Use the queue or asynchronous calls if necessary, since the emulator must be responsive.</p><p>The driver structure contains the name of the driver and some 15 function pointers. These pointers are called at different times by the emulator.</p><p>The only exported function from the driver is <em>driver_init</em>. This function returns the <em>driver_entry</em> structure that points to the other functions in the driver. The <em>driver_init</em> function is declared with a macro <em>DRIVER_INIT(drivername)</em>. (This is because different OS's have different names for it.)</p><p>When writing a driver in C++, the driver entry should be of <em>"C"</em> linkage. One way to do this is to put this line somewhere before the driver entry: <em>extern "C" DRIVER_INIT(drivername);</em>.</p><p>When the driver has passed the <em>driver_entry</em> over to the emulator, the driver is <em>not</em> allowed to modify the <em>driver_entry</em>.</p><p>If compiling a driver for static inclusion via --enable-static-drivers you have to define STATIC_ERLANG_DRIVER before the DRIVER_INIT declaration.</p><p><strong></strong> Note:</p><p>Do <em>not</em> declare the <em>driver_entry</em> <em>const</em>. This since the emulator needs to modify the <em>handle</em>, and the <em>handle2</em> fields. A statically allocated, and <em>const</em> declared <em>driver_entry</em> may be located in read only memory which will cause the emulator to crash.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DATA TYPES</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><strong>ErlDrvEntry</strong> :</p>
  </dd>

</dl>

<pre>
typedef struct erl_drv_entry {
    int (*init)(void);          /* called at system start up for statically
                                   linked drivers, and after loading for
                                   dynamically loaded drivers */

#ifndef ERL_SYS_DRV
    ErlDrvData (*start)(ErlDrvPort port, char *command);
                                /* called when open_port/2 is invoked.
                                   return value -1 means failure. */
#else
    ErlDrvData (*start)(ErlDrvPort port, char *command, SysDriverOpts* opts);
                                /* special options, only for system driver */
#endif
    void (*stop)(ErlDrvData drv_data);
                                /* called when port is closed, and when the
                                   emulator is halted. */
    void (*output)(ErlDrvData drv_data, char *buf, ErlDrvSizeT len);
                                /* called when we have output from erlang to
                                   the port */
    void (*ready_input)(ErlDrvData drv_data, ErlDrvEvent event);
                                /* called when we have input from one of
                                   the driver's handles */
    void (*ready_output)(ErlDrvData drv_data, ErlDrvEvent event);
                                /* called when output is possible to one of
                                   the driver's handles */
    char *driver_name;          /* name supplied as command
                                   in open_port XXX ? */
    void (*finish)(void);       /* called before unloading the driver -
                                   DYNAMIC DRIVERS ONLY */
    void *handle;               /* Reserved -- Used by emulator internally */
    ErlDrvSSizeT (*control)(ErlDrvData drv_data, unsigned int command,
                            char *buf, ErlDrvSizeT len,
			    char **rbuf, ErlDrvSizeT rlen);
                                /* "ioctl" for drivers - invoked by
                                   port_control/3 */
    void (*timeout)(ErlDrvData drv_data);        /* Handling of timeout in driver */
    void (*outputv)(ErlDrvData drv_data, ErlIOVec *ev);
                                /* called when we have output from erlang
                                   to the port */
    void (*ready_async)(ErlDrvData drv_data, ErlDrvThreadData thread_data);
    void (*flush)(ErlDrvData drv_data);
                                /* called when the port is about to be
                                   closed, and there is data in the
                                   driver queue that needs to be flushed
                                   before 'stop' can be called */
    ErlDrvSSizeT (*call)(ErlDrvData drv_data, unsigned int command,
                         char *buf, ErlDrvSizeT len,
			 char **rbuf, ErlDrvSizeT rlen, unsigned int *flags);
                                /* Works mostly like 'control', a synchronous
                                   call into the driver. */
    void (*event)(ErlDrvData drv_data, ErlDrvEvent event,
                  ErlDrvEventData event_data);
                                /* Called when an event selected by
                                   driver_event() has occurred */
    int extended_marker;        /* ERL_DRV_EXTENDED_MARKER */
    int major_version;          /* ERL_DRV_EXTENDED_MAJOR_VERSION */
    int minor_version;          /* ERL_DRV_EXTENDED_MINOR_VERSION */
    int driver_flags;           /* ERL_DRV_FLAGs */
    void *handle2;              /* Reserved -- Used by emulator internally */
    void (*process_exit)(ErlDrvData drv_data, ErlDrvMonitor *monitor);
                                /* Called when a process monitor fires */
    void (*stop_select)(ErlDrvEvent event, void* reserved);
                                /* Called to close an event object */
 } ErlDrvEntry;

</pre>

<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>int (*init)(void): This is called directly after the driver has been loaded by <em>erl_ddll:load_driver/2</em>. (Actually when the driver is added to the driver list.) The driver should return 0, or if the driver can't initialize, -1.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>ErlDrvData (*start)(ErlDrvPort port, char* command): This is called when the driver is instantiated, when <em>open_port/2</em> is called. The driver should return a number &gt;= 0 or a pointer, or if the driver can't be started, one of three error codes should be returned:</p><p>ERL_DRV_ERROR_GENERAL - general error, no error code</p><p>ERL_DRV_ERROR_ERRNO - error with error code in erl_errno</p><p>ERL_DRV_ERROR_BADARG - error, badarg</p><p>If an error code is returned, the port isn't started.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>void (*stop)(ErlDrvData drv_data): This is called when the port is closed, with <em>port_close/1</em> or <em>Port ! {self(), close}</em>. Note that terminating the port owner process also closes the port. If <em>drv_data</em> is a pointer to memory allocated in <em>start</em>, then <em>stop</em> is the place to deallocate that memory.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>void (*output)(ErlDrvData drv_data, char *buf, ErlDrvSizeT len): This is called when an erlang process has sent data to the port. The data is pointed to by <em>buf</em>, and is <em>len</em> bytes. Data is sent to the port with <em>Port ! {self(), {command, Data}}</em>, or with <em>port_command/2</em>. Depending on how the port was opened, it should be either a list of integers 0...255 or a binary. See <em>open_port/3</em> and <em>port_command/2</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>void (*ready_input)(ErlDrvData drv_data, ErlDrvEvent event):</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>void (*ready_output)(ErlDrvData drv_data, ErlDrvEvent event): This is called when a driver event (given in the <em>event</em> parameter) is signaled. This is used to help asynchronous drivers "wake up" when something happens.</p><p>On unix the <em>event</em> is a pipe or socket handle (or something that the <em>select</em> system call understands).</p><p>On Windows the <em>event</em> is an Event or Semaphore (or something that the <em>WaitForMultipleObjects</em> API function understands). (Some trickery in the emulator allows more than the built-in limit of 64 <em>Events</em> to be used.)</p><p>On Enea OSE the <em>event</em> is one or more signals that can be retrieved using <strong>erl_drv_ose_get_signal</strong>.</p><p>To use this with threads and asynchronous routines, create a pipe on unix, an Event on Windows or a unique signal number on Enea OSE. When the routine completes, write to the pipe (use <em>SetEvent</em> on Windows or send a message to the emulator process on Enea OSE), this will make the emulator call <em>ready_input</em> or <em>ready_output</em>.</p><p>Spurious events may happen. That is, calls to <em>ready_input</em> or <em>ready_output</em> even though no real events are signaled. In reality it should be rare (and OS dependant), but a robust driver must nevertheless be able to handle such cases.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>char *driver_name: This is the name of the driver, it must correspond to the atom used in <em>open_port</em>, and the name of the driver library file (without the extension).</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>void (*finish)(void): This function is called by the <em>erl_ddll</em> driver when the driver is unloaded. (It is only called in dynamic drivers.)</p><p>The driver is only unloaded as a result of calling <em>unload_driver/1</em>, or when the emulator halts.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>void *handle: This field is reserved for the emulator's internal use. The emulator will modify this field; therefore, it is important that the <em>driver_entry</em> isn't declared <em>const</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>ErlDrvSSizeT (*control)(ErlDrvData drv_data, unsigned int command, char *buf, ErlDrvSizeT len, char **rbuf, ErlDrvSizeT rlen): This is a special routine invoked with the erlang function <em>port_control/3</em>. It works a little like an "ioctl" for erlang drivers. The data given to <em>port_control/3</em> arrives in <em>buf</em> and <em>len</em>. The driver may send data back, using <em>*rbuf</em> and <em>rlen</em>.</p><p>This is the fastest way of calling a driver and get a response. It won't make any context switch in the erlang emulator, and requires no message passing. It is suitable for calling C function to get faster execution, when erlang is too slow.</p><p>If the driver wants to return data, it should return it in <em>rbuf</em>. When <em>control</em> is called, <em>*rbuf</em> points to a default buffer of <em>rlen</em> bytes, which can be used to return data. Data is returned different depending on the port control flags (those that are set with <strong>set_port_control_flags</strong>).</p><p>If the flag is set to <em>PORT_CONTROL_FLAG_BINARY</em>, a binary will be returned. Small binaries can be returned by writing the raw data into the default buffer. A binary can also be returned by setting <em>*rbuf</em> to point to a binary allocated with <strong>driver_alloc_binary</strong>. This binary will be freed automatically after <em>control</em> has returned. The driver can retain the binary for <em>read only</em> access with <strong>driver_binary_inc_refc</strong> to be freed later with <strong>driver_free_binary</strong>. It is never allowed to alter the binary after <em>control</em> has returned. If <em>*rbuf</em> is set to NULL, an empty list will be returned.</p><p>If the flag is set to <em>0</em>, data is returned as a list of integers. Either use the default buffer or set <em>*rbuf</em> to point to a larger buffer allocated with <strong>driver_alloc</strong>. The buffer will be freed automatically after <em>control</em> has returned.</p><p>Using binaries is faster if more than a few bytes are returned.</p><p>The return value is the number of bytes returned in <em>*rbuf</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>void (*timeout)(ErlDrvData drv_data): This function is called any time after the driver's timer reaches 0. The timer is activated with <em>driver_set_timer</em>. There are no priorities or ordering among drivers, so if several drivers time out at the same time, any one of them is called first.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>void (*outputv)(ErlDrvData drv_data, ErlIOVec *ev): This function is called whenever the port is written to. If it is <em>NULL</em>, the <em>output</em> function is called instead. This function is faster than <em>output</em>, because it takes an <em>ErlIOVec</em> directly, which requires no copying of the data. The port should be in binary mode, see <em>open_port/2</em>.</p><p>The <em>ErlIOVec</em> contains both a <em>SysIOVec</em>, suitable for <em>writev</em>, and one or more binaries. If these binaries should be retained, when the driver returns from <em>outputv</em>, they can be queued (using <strong>driver_enq_bin</strong> for instance), or if they are kept in a static or global variable, the reference counter can be incremented.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>void (*ready_async)(ErlDrvData drv_data, ErlDrvThreadData thread_data): This function is called after an asynchronous call has completed. The asynchronous call is started with <strong>driver_async</strong>. This function is called from the erlang emulator thread, as opposed to the asynchronous function, which is called in some thread (if multithreading is enabled).</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>ErlDrvSSizeT (*call)(ErlDrvData drv_data, unsigned int command, char *buf, ErlDrvSizeT len, char **rbuf, ErlDrvSizeT rlen, unsigned int *flags): This function is called from <em>erlang:port_call/3</em>. It works a lot like the <em>control</em> call-back, but uses the external term format for input and output.</p><p><em>command</em> is an integer, obtained from the call from erlang (the second argument to <em>erlang:port_call/3</em>).</p><p><em>buf</em> and <em>len</em> provide the arguments to the call (the third argument to <em>erlang:port_call/3</em>). They can be decoded using <em>ei</em> functions.</p><p><em>rbuf</em> points to a return buffer, <em>rlen</em> bytes long. The return data should be a valid erlang term in the external (binary) format. This is converted to an erlang term and returned by <em>erlang:port_call/3</em> to the caller. If more space than <em>rlen</em> bytes is needed to return data, <em>*rbuf</em> can be set to memory allocated with <em>driver_alloc</em>. This memory will be freed automatically after <em>call</em> has returned.</p><p>The return value is the number of bytes returned in <em>*rbuf</em>. If <em>ERL_DRV_ERROR_GENERAL</em> is returned (or in fact, anything &lt; 0), <em>erlang:port_call/3</em> will throw a <em>BAD_ARG</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>void (*event)(ErlDrvData drv_data, ErlDrvEvent event, ErlDrvEventData event_data): Intentionally left undocumented.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>int extended_marker: This field should either be equal to <em>ERL_DRV_EXTENDED_MARKER</em> or <em>0</em>. An old driver (not aware of the extended driver interface) should set this field to <em>0</em>. If this field is equal to <em>0</em>, all the fields following this field also <em>have</em> to be <em>0</em>, or <em>NULL</em> in case it is a pointer field.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>int major_version: This field should equal <em>ERL_DRV_EXTENDED_MAJOR_VERSION</em> if the <em>extended_marker</em> field equals <em>ERL_DRV_EXTENDED_MARKER</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>int minor_version: This field should equal <em>ERL_DRV_EXTENDED_MINOR_VERSION</em> if the <em>extended_marker</em> field equals <em>ERL_DRV_EXTENDED_MARKER</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>int driver_flags: This field is used to pass driver capability and other information to the runtime system. If the <em>extended_marker</em> field equals <em>ERL_DRV_EXTENDED_MARKER</em>, it should contain <em>0</em> or driver flags (<em>ERL_DRV_FLAG_*</em>) ored bitwise. Currently the following driver flags exist:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>ERL_DRV_FLAG_USE_PORT_LOCKING</em>:  The runtime system will use port level locking on all ports executing this driver instead of driver level locking when the driver is run in a runtime system with SMP support. For more information see the <strong>erl_driver</strong> documentation.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>ERL_DRV_FLAG_SOFT_BUSY</em>:  Marks that driver instances can handle being called in the <strong>output</strong> and/or <strong>outputv</strong> callbacks even though a driver instance has marked itself as busy (see <strong>set_busy_port()</strong>). Since erts version 5.7.4 this flag is required for drivers used by the Erlang distribution (the behaviour has always been required by drivers used by the distribution).</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>ERL_DRV_FLAG_NO_BUSY_MSGQ</em>: Disable busy port message queue functionality. For more information, see the documentation of the <strong>erl_drv_busy_msgq_limits()</strong> function.</p>
  </dd>

</dl>

  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>void *handle2: This field is reserved for the emulator's internal use. The emulator will modify this field; therefore, it is important that the <em>driver_entry</em> isn't declared <em>const</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>void (*process_exit)(ErlDrvData drv_data, ErlDrvMonitor *monitor): This callback is called when a monitored process exits. The <em>drv_data</em> is the data associated with the port for which the process is monitored (using <strong>driver_monitor_process</strong>) and the <em>monitor</em> corresponds to the <em>ErlDrvMonitor</em> structure filled in when creating the monitor. The driver interface function <strong>driver_get_monitored_process</strong> can be used to retrieve the process id of the exiting process as an <em>ErlDrvTermData</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>void (*stop_select)(ErlDrvEvent event, void* reserved): This function is called on behalf of <strong>driver_select</strong> when it is safe to close an event object.</p><p>A typical implementation on Unix is to do <em>close((int)event)</em>.</p><p>Argument <em>reserved</em> is intended for future use and should be ignored.</p><p>In contrast to most of the other call-back functions, <em>stop_select</em> is called independent of any port. No <em>ErlDrvData</em> argument is passed to the function. No driver lock or port lock is guaranteed to be held. The port that called <em>driver_select</em> might even be closed at the time <em>stop_select</em> is called. But it could also be the case that <em>stop_select</em> is called directly by <em>driver_select</em>.</p><p>It is not allowed to call any functions in the <strong>driver API</strong> from <em>stop_select</em>. This strict limitation is due to the volatile context that <em>stop_select</em> may be called.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO driver_entry&hellip;</h2>
        <div class="sectioncontent">
<p><strong>erl_driver(3erl)</strong>, <strong>erl_ddll(3erl)</strong>, <strong>erlang(3erl)</strong>, kernel(3erl)</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="disksup.3erl.html"><span aria-hidden="true">&larr;</span> disksup.3erl: A disk supervisor process</a></li>
   <li class="next"><a href="dyntrace.3erl.html">dyntrace.3erl: Interface to dynamic tracing <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

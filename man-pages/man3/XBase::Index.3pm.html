<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>XBase::Index: Base class for the index files for dbf</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Base class for the index files for dbf">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="XBase::Index (3pm) manual">
  <meta name="twitter:description" content="Base class for the index files for dbf">
  <meta name="twitter:image" content="https://www.carta.tech/images/libdbd-xbase-perl-XBase::Index-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/XBase::Index.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="XBase::Index (3pm) manual" />
  <meta property="og:description" content="Base class for the index files for dbf" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libdbd-xbase-perl-XBase::Index-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">XBase::Index<small> (3pm)</small></h1>
        <p class="lead">Base class for the index files for dbf</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/XBase::Index.3pm.html">
      <span itemprop="name">XBase::Index: Base class for the index files for dbf</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libdbd-xbase-perl/">
      <span itemprop="name">libdbd-xbase-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/XBase::Index.3pm.html">
      <span itemprop="name">XBase::Index: Base class for the index files for dbf</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
        use XBase;
        my $table = new XBase "data.dbf";
        my $cur = $table-&gt;prepare_select_with_index("id.ndx",
                "ID", "NAME);
        $cur-&gt;find_eq(1097);

        while (my @data = $cur-&gt;fetch()) {
                last if $data[0] != 1097;
                print "@data&#92;n";
        }
</pre>
<p>This is a snippet of code to print \s-1ID\s0 and \s-1NAME\s0 fields from dbf data.dbf where \s-1ID\s0 equals 1097. Provided you have index on \s-1ID\s0 in file id.ndx. You can use the same code for ntx and idx index files. For the cdx and mdx, the prepare_select call would be</p><p>        prepare_select_with_index([&apos;rooms.cdx&apos;, &apos;ROOMNAME&apos;])</p><p>so instead of plain filename you specify an arrayref with filename and an index tag in that file. The reason is that cdx and mdx can contain multiple indexes in one file and you have to distinguish, which you want to use.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The module XBase::Index is a collection of packages to provide index support for XBase-like dbf database files.</p><p>An index file is generaly a file that holds values of certain database field or expression in sorted order, together with the record number that the record occupies in the dbf file. So when you search for a record with some value, you first search in this sorted list and once you have the record number in the dbf, you directly fetch the record from dbf.</p><h3>What indexes do</h3>
<p>To make the searching in this ordered list fast, it's generally organized as a tree \*(-- it starts with a root page with records that point to pages at lower level, etc., until leaf pages where the pointer is no longer a pointer to the index but to the dbf. When you search for a record in the index file, you fetch the root page and scan it (lineary) until you find key value that is equal or grater than that you are looking for. That way you've avoided reading all pages describing the values that are lower. Here you descend one level, fetch the page and again search the list of keys in that page. And you repeat this process until you get to the leaf (lowest) level and here you finaly find a pointer to the dbf. XBase::Index does this for you.</p><p>Some of the formats also support multiple indexes in one file \*(-- usually there is one top level index that for different field values points to different root pages in the index file (so called tags).</p><p>XBase::Index supports (or aims to support) the following index formats: ndx, ntx, mdx, cdx and idx. They differ in a way they store the keys and pointers but the idea is always the same: make a tree of pages, where the page contains keys and pointer either to pages at lower levels, or to dbf (or both). XBase::Index only supports read only access to the index fields at the moment (and if you need writing them as well, follow reading because we need to have the reading support stable before I get to work on updating the indexes).</p>
<h3>Testing your index file (and XBase::Index)</h3>
<p>You can test your index using the index_dump script (I mean test XBase::Index on correct index data, not testing corrupted index file, of course ;-)</p><p>Just run</p><p>        index_dump ~/path/index.ndx         index_dump ~/path/index.cdx tag_name</p><p>or</p><p>        perl -Ilib &#96;which index_dump&#96; ~/path/index.cdx tag_name</p><p>if you haven't installed this version of XBase.pm/DBD::XBase yet. You should get the content of the index file. On each row, there is the key value and a record number of the record in the dbf file. Let me know if you get results different from those you expect. I'd probably ask you to send me the index file (and possibly the dbf file as well), so that I can debug the problem.</p><p>The index file is (as already noted) a complement to a dbf file. Index file without a dbf doesn't make much sense because the only thing that you can get from it is the record number in the dbf file, not the actual data. But it makes sense to test \*(-- dump the content of the index to see if the sequence is \s-1OK\s0.</p><p>The index formats usually distinguish between numeric and character data. Some of the file formats include the information about the type in the index file, other depend on the dbf file. Since with index_dump we only look at the index file, you may need to specify the -type option to index_dump if it complains that it doesn't know the data type of the values (this is the case with cdx at least). The possible values are num, char and date and the call would be like</p><p>        index_dump -type=num ~/path/index.cdx tag_name</p><p>(this -type option may not work with all index formats at the moment \*(-- will be fixed and patches always welcome).</p><p>You can use \*(C`-ddebug\*(C' option to index_dump to see how pages are fetched and decoded, or run debugger to see the calls and parsing.</p>
<h3>Using the index files to speed up searches in dbf</h3>
<p>The syntax for using the index files to access data in the dbf file is generally</p><p>        my $table = new XBase "tablename";                 # or any other arguments to get the XBase object                 # see <strong>XBase</strong>(3)         my $cur = $table-&gt;prepare_select_with_index("indexfile",                 "list", "of", "fields", "to", "return");</p><p>or</p><p>        my $cur = $table-&gt;prepare_select_with_index(                 [ "indexfile_with_tags", "tag_name" ],                 "list", "of", "fields", "to", "return");</p><p>where we specify the tag in the index file (this is necessary with cdx and mdx). After we have the cursor, we can search to given record and start fetching the data:</p><p>        $cur-&gt;find_eq(&apos;jezek&apos;);         while (my @data = $cur-&gt;fetch) { # do something</p>
<h3>Supported index formats</h3>
<p>The following table summarizes which formats are supproted by XBase::Index. If the field says something else that Yes, I welcome testers and offers of example index files.</p><p>  Reading of index files -- types supported by XBase::Index</p><p>  type  string          numeric         date   ----------------------------------------------------------   ndx   Yes             Yes             Yes (you need to                                         convert to Julian)</p><p>  ntx   Yes             Yes             Untested</p><p>  idx   Untested        Untested        Untested         (but should be pretty usable)</p><p>  mdx   Untested        Untested        Untested</p><p>  cdx   Yes             Yes             Untested</p><p>  Writing of index files -- not supported untill the reading   is stable enough.</p><p>So if you have access to an index file that is untested or unsupported and you care about support of these formats, contact me. If you are able to actually generate those files on request, the better because I may need specific file size or type to check something. If the file format you work with is supported, I still appreciate a report that it really works for you.</p><p><strong>Please note</strong> that there is very little documentation about the file formats and the work on XBase::Index is heavilly based on making assumption based on real life data. Also, the documentation is often wrong or only describing some format variations but not the others. I personally do not need the index support but am more than happy to make it a reality for you. So I need your help \*(-- contact me if it doesn't work for you and offer me your files for testing. Mentioning word XBase somewhere in the Subject line will get you (hopefully ;-) fast response. Mentioning work Help or similar stupidity will probably make my filters to consider your email as spam. Help yourself by making my life easier in helping you.</p>
<h3>Programmer's notes</h3>
<p>Programmers might find the following information useful when trying to debug XBase::Index from their files:</p><p>The XBase::Index module contains the basic XBase::Index package and also packages XBase::ndx, XBase::ntx, XBase::idx, XBase::mdx and XBase::cdx, and for each of these also a package XBase::index_type::Page. Reading the file goes like this: you create as object calling either new XBase::Index or new XBase::ndx (or whatever the index type is). This can also be done behind the scenes, for example XBase::prepare_select_with_index calls new XBase::Index. The index file is opened using the XBase::Base::new/open and then the XBase::index_type::read_header is called. This function fills the basic data fields of the object from the header of the file. The new method returns the object corresponding to the index type.</p><p>Then you probably want to do $index-&gt;prepare_select or $index-&gt;prepare_select_eq, that would possition you just before record equal or greater than the parameter (record in the index file, that is). Then you do a series of fetch'es that return next pair of (key, pointer_to_dbf). Behind the scenes, prepare_select_eq or fetch call XBase::Index::get_record which in turn calls XBase::index_type::Page::new. From the index file perspective, the atomic item in the file is one index page (or block, or whatever you call it). The XBase::index_type::Page::new reads the block of data from the file and parses the information in the page \*(-- pages have more or less complex structures. Page::new fills the structure, so that the fetch calls can easily check what values are in the page.</p><p>For some examples, please see eg/use_index in the distribution directory.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">VERSION</h2>
        <div class="sectioncontent">
<p>1.05</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AVAILABLE FROM</h2>
        <div class="sectioncontent">
<p>http://www.adelton.com/perl/DBD-XBase/</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>(c) 1998--2013 Jan Pazdziora.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO XBase::Index&hellip;</h2>
        <div class="sectioncontent">
<p><em>XBase</em>\|(3), <em>XBase::FAQ</em>\|(3)</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="XBase::FAQ.3pm.html"><span aria-hidden="true">&larr;</span> XBase::FAQ.3pm: Frequently asked questions about the xbase.pm/dbd::xbase modules</a></li>
   <li class="next"><a href="XBase::Memo.3pm.html">XBase::Memo.3pm: Generic support for various memo formats <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

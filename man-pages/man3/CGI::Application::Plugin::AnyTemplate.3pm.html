<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>CGI::Application::Plugin::AnyTemplate: Use any templating system from within cgi::application using a unified interface</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Use any templating system from within cgi::application using a unified interface">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="CGI::Application::Plugin::AnyTemplate (3pm) manual">
  <meta name="twitter:description" content="Use any templating system from within cgi::application using a unified interface">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcgi-application-plugin-anytemplate-perl-CGI::Application::Plugin::AnyTemplate-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/CGI::Application::Plugin::AnyTemplate.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="CGI::Application::Plugin::AnyTemplate (3pm) manual" />
  <meta property="og:description" content="Use any templating system from within cgi::application using a unified interface" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcgi-application-plugin-anytemplate-perl-CGI::Application::Plugin::AnyTemplate-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">CGI::Application::Plugin::AnyTemplate<small> (3pm)</small></h1>
        <p class="lead">Use any templating system from within cgi::application using a unified interface</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/CGI::Application::Plugin::AnyTemplate.3pm.html">
      <span itemprop="name">CGI::Application::Plugin::AnyTemplate: Use any templating system from within cgi::application using a unified interface</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcgi-application-plugin-anytemplate-perl/">
      <span itemprop="name">libcgi-application-plugin-anytemplate-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/CGI::Application::Plugin::AnyTemplate.3pm.html">
      <span itemprop="name">CGI::Application::Plugin::AnyTemplate: Use any templating system from within cgi::application using a unified interface</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">VERSION</h2>
        <div class="sectioncontent">
<p>Version 0.18</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>In your CGI::Application-based webapp:</p>
<pre>
    use base &apos;CGI::Application&apos;;
    use CGI::Application::Plugin::AnyTemplate;

    sub cgiapp_init {
        my $self = shift;

        # Set template options
        $self-&gt;template-&gt;config(
            default_type =&gt; &apos;TemplateToolkit&apos;,
        );
    }
</pre>
<p>Later on, in a runmode:</p><p>    sub my_runmode {         my $self = shift;</p><p>        my %template_params = (             name     =&gt; &apos;Winston Churchill&apos;,             age      =&gt; 7,         );</p><p>        $self-&gt;template-&gt;fill(&apos;some_template&apos;, &#92;%template_params);     }</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<h3>Template-Independence</h3>
<p>\*(C`CGI::Application::Plugin::AnyTemplate\*(C' allows you to use any supported Perl templating system using a single consistent interface.</p><p>Currently supported templating systems include HTML::Template, HTML::Template::Expr, HTML::Template::Pluggable, Template::Toolkit and Petal.</p><p>You can access any of these templating systems using the same interface. In this way, you can use the same code and switch templating systems on the fly.</p><p>This approach has many uses.  For instance, it can be useful in migrating your application from one templating system to another.</p>
<h3>Embedded Components</h3>
<p>In addition to template abstraction, \*(C`AnyTemplate\*(C' also provides a <em>embedded component mechanism</em>.  For instance, you might include a <em>header</em> component at the top of every page and a <em>footer</em> component at the bottom of every page.</p><p>These components are actually full CGI::Application run modes, and can do anything normal run mode can do, including processing form parameters and filling in their own templates.  See below under \*(L"\s-1EMBEDDED\s0 \s-1COMPONENTS\s0\*(R" for details.</p>
<h3>Multiple Named Template Configurations</h3>
<p>You can set up multiple named template configurations and select between them at run time.</p><p>    sub cgiapp_init {         my $self = shift;</p><p>        # Can&apos;t use Template::Toolkit any more -         # The boss wants everything has to be XML,         # so we switch to Petal</p><p>        # Set old-style template options (legacy scripts)         $self-&gt;template(&apos;oldstyle&apos;)-&gt;config(             default_type =&gt; &apos;TemplateToolkit&apos;,             TemplateToolkit =&gt; {                 POST_CHOMP =&gt; 1,             }         );         # Set new-style template options as default         $self-&gt;template-&gt;config(             default_type =&gt; &apos;Petal&apos;,             auto_add_template_extension =&gt; 0,         );     }</p><p>    sub old_style_runmode {         my $self = shift;</p><p>        # ...</p><p>        # use TemplateToolkit to fill template edit_user.tmpl         $self-&gt;template(&apos;oldstyle&apos;)-&gt;fill(&apos;edit_user&apos;, &#92;%params);</p><p>    }</p><p>    sub new_style_runmode {         my $self = shift;</p><p>        # ...</p><p>        # use Petal to fill template edit_user.xhml         $self-&gt;template-&gt;fill(&apos;edit_user.xhtml&apos;, &#92;%params);</p><p>    }</p>
<h3>Flexible Syntax</h3>
<p>The syntax is pretty flexible.  Pick a style that's most comfortable for you.</p><p><em>CGI::Application::Plugin::TT style syntax</em></p><p>    $self-&gt;template-&gt;process(&apos;edit_user&apos;, &#92;%params);</p><p>or (with slightly less typing):</p><p>    $self-&gt;template-&gt;fill(&apos;edit_user&apos;, &#92;%params);</p><p><em>CGI::Application load_tmpl style syntax</em></p><p>    my $template = $self-&gt;template-&gt;load(&apos;edit_user&apos;);     $template-&gt;param(&apos;foo&apos; =&gt; &apos;bar&apos;);     $template-&gt;output;</p><p><em>Verbose syntax (for complete control)</em></p><p>    my $template = $self-&gt;template(&apos;named_config&apos;)-&gt;load(         file              =&gt; &apos;edit_user&apos;         type              =&gt; &apos;TemplateToolkit&apos;         add_include_paths =&gt; &apos;.&apos;,     );</p><p>    $template-&gt;param(&apos;foo&apos; =&gt; &apos;bar&apos;);     $template-&gt;output;</p><p>See also below under \*(L"\s-1CHANGING\s0 \s-1THE\s0 \s-1NAME\s0 \s-1OF\s0 \s-1THE\s0 'template' \s-1METHOD\s0\*(R".</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">
<h3>config</h3>
<p>Initialize the \*(C`AnyTemplate\*(C' system and provide the default configuration.</p><p>    $self-&gt;template-&gt;config(         default_type =&gt; &apos;HTMLTemplate&apos;,     );</p><p>You can keep multiple configurations handy at the same time by passing a value to \*(C`template\*(C':</p><p>    $self-&gt;template(&apos;oldstyle&apos;)-&gt;config(         default_type =&gt; &apos;HTML::Template&apos;,     );     $self-&gt;template(&apos;newstyle&apos;)-&gt;config(         default_type =&gt; &apos;HTML::Template::Expr&apos;,     );</p><p>Then in a runmode you can mix and match configurations:</p><p>    $self-&gt;template(&apos;oldstyle&apos;)-&gt;load  # loads an HTML::Template driver object     $self-&gt;template(&apos;newstyle&apos;)-&gt;load  # loads an HTML::Template::Expr driver object</p><p>The configuration passed to \*(C`config\*(C' is divided into three areas: <em>plugin configuration</em>, <em>driver configuration</em>, and <em>native</em> configuration:</p><p>    Config Type       What it Configures     -----------       ------------------     Plugin Config     AnyTemplate itself     Driver Config     AnyTemplate Driver (e.g. HTMLTemplate)     Native Config     Actual template module (e.g. HTML::Template)</p><p>These are described in more detail below.</p><p><em>Plugin Configuration</em></p><p>These configuration params are specific to the \*(C`CGI::Application::Plugin::AnyTemplate\*(C' itself. They are included at the top level of the configuration hash passed to \*(C`config\*(C'.  For instance:</p><p>    $self-&gt;template-&gt;config(         default_type                =&gt; &apos;HTMLTemplate&apos;,         auto_add_template_extension =&gt; 0,     );</p><p>The <em>plugin configuration</em> parameters and their defaults are as follows:</p>
<dl class='dl-vertical'>
  <dt>
    default_type
  </dt>
  <dd>
    
  </dd>
  <dt>
    type
  </dt>
  <dd>
    <p>The default type of template for this named configuration.  Should be the name of a driver in the \*(C`CGI::Application::Plugin::AnyTemplate::Driver\*(C' namespace:     Type                Driver     ----                ------     HTMLTemplate        CGI::Application::Plugin::AnyTemplate::Driver::HTMLTemplate     HTMLTemplateExpr    CGI::Application::Plugin::AnyTemplate::Driver::HTMLTemplateExpr     TemplateToolkit     CGI::Application::Plugin::AnyTemplate::Driver::TemplateToolkit     Petal               CGI::Application::Plugin::AnyTemplate::Driver::Petal</p>
  </dd>
  <dt>
    include_paths
  </dt>
  <dd>
    <p>Include Paths (sometimes called search paths) are used by the various template backends to find filenames that aren't fully qualified by an absolute path.  Each directory is searched in turn until the template file is found. Can be a single string or a reference to a list.</p>
  </dd>
  <dt>
    auto_add_template_extension
  </dt>
  <dd>
    <p>Add a template-system specific extension to template filenames. So, if this feature is enabled and you provide the filename \*(C`myfile\*(C', then the actual filename will depend on the current template driver:     Driver                 Template     ------                 --------     HTMLTemplate           myfile.html     HTMLTemplateExpr       myfile.html     TemplateToolkit        myfile.tmpl     Petal                  myfile.xhtml The per-type extension is controlled by the driver config for each \*(C`AnyTemplate\*(C' driver (see below under \*(L"Driver and Native Configuration\*(R" for how to set this). The \*(C`auto_add_template_extension\*(C' feature is on by default.  To disable it, pass a value of zero:     $self-&gt;template-&gt;config(         auto_add_template_extension =&gt; 0,     ); The automatic extension feature is not just there to save typing - it's actually there so you can have templates of different types sitting in the same directory.     sub my_runmode {         my $self = shift;         $self-&gt;template-&gt;fill;     } Then in your template path you can have three files:     my_runmode.html     my_runmode.tmpl     my_runmode.xhtml Then you can change which templates is used by changing the value of \*(C`type\*(C' that you pass to \*(C`$self-&gt;template-&gt;config\*(C'. For applications that want to dynamically choose their template system without changing app code, it's a cleaner solution to use the extensions than trying to swap template paths at runtime.  Even if you keep each type of template in its own directory, it's simpler to include all the directories all the time and use different extensions for different template types.</p>
  </dd>
  <dt>
    template_filename_generator
  </dt>
  <dd>
    <p>If you don't pass a filename to \*(C`load\*(C', one will be generated for you based on the current run mode.  If you want to customize this process, you can pass a reference to a subroutine to do the translation.  This subroutine will be passed a reference to the CGI::Application $self object. Here is a subroutine that emulates the built-in behaviour of \*(C`AnyTemplate\*(C':     $self-&gt;template-&gt;config(         template_filename_generator =&gt; sub {             my ($self, $calling_method_name) = @_;                 return $self-&gt;get_current_runmode;             }         }     ); Here is an example of using a template filename generator to make full templates with full paths based on the module name as well as the current run mode (this is similar to how CGI::Application::Plugin::TT generates its template filenames):     package My::WebApp;     use File::Spec;</p><p>    sub cgiapp_init {         my $self = shift;</p><p>        $self-&gt;template-&gt;config(             template_filename_generator =&gt; sub {                 my $self     = shift;                 my $run_mode = $self-&gt;get_current_runmode;                 my $module   = ref $self;</p><p>                my @segments = split /::/, $module;</p><p>                return File::Spec-&gt;catfile(@segments, $run_mode);             }         );     }</p><p>    sub run_mode {         my $self = shift;         $self-&gt;template-&gt;load;  # loads My/WebApp/run_mode.html     }</p><p>    sub other_run_mode {         my $self = shift;         $self-&gt;template-&gt;load;  # loads My/WebApp/other_run_mode.html     } Note that if the \*(C`auto_add_template_extension\*(C' option is on (which it is by default), then the extension will be added to your generated filename after you return it.  If you do not want this to happen, then set \*(C`auto_add_template_extension\*(C' to a false value.</p>
  </dd>
  <dt>
    component_handler_class
  </dt>
  <dd>
    <p>Normally, component embedding is handled by CGI::Application::Plugin::AnyTemplate::ComponentHandler.  If you want to use a different class for this purpose, specify the class name as the value of this parameter. It still has to provide the same interface as CGI::Application::Plugin::AnyTemplate::ComponentHandler.  See the source code of that module for details.</p>
  </dd>
  <dt>
    return_references
  </dt>
  <dd>
    <p>When true (the default), \*(C`output\*(C' will return a reference to a string rather than a copy.  Normally this won't matter.  For instance, \*(C`CGI::Application\*(C' doesn't care whether you return a string or a reference to a string from your run modes. However, if you want to manipulate the output of the $html returned from the template, you may find it convenient to make \*(C`output\*(C' return a string instead of a reference.  Especially if you are converting old code based on HTML::Template which expects \*(C`output\*(C' to return a string.</p>
  </dd>

</dl>
<p><em>Driver and Native Configuration</em></p><p>You can configure all the drivers at once with a single call to \*(C`config\*(C', by including subsections for each driver type:</p><p>    $self-&gt;template-&gt;config(         default_type =&gt; &apos;HTMLTemplate&apos;,         HTMLTemplate =&gt; {             cache              =&gt; 1,             global_vars        =&gt; 1,             die_on_bad_params  =&gt; 0,             template_extension =&gt; &apos;.html&apos;,         },         HTMLTemplateExpr =&gt; {             cache              =&gt; 1,             global_vars        =&gt; 1,             die_on_bad_params  =&gt; 0,             template_extension =&gt; &apos;.html&apos;,         },         HTMLTemplatePluggable =&gt; {             cache              =&gt; 1,             global_vars        =&gt; 1,             die_on_bad_params  =&gt; 0,             template_extension =&gt; &apos;.html&apos;,         },         TemplateToolkit =&gt; {             POST_CHOMP         =&gt; 1,             template_extension =&gt; &apos;.tmpl&apos;,         },         Petal =&gt; {             error_on_undef     =&gt; 0,             template_extension =&gt; &apos;.xhtml&apos;,         },     );</p><p>Each driver knows how to separate its own configuration from the configuration belonging to the underlying template system.</p><p>For instance in the example above, the \*(C`HTMLTemplate\*(C' driver knows that \*(C`template_extension\*(C' is a driver config parameter, but \*(C`cache_global_vars\*(C' and \*(C`die_on_bad_params\*(C' are all HTML::Template configuration parameters.</p><p>Similarly, The \*(C`TemplateToolkit\*(C' driver knows that template_extension is a driver config parameter, but \*(C`POST_CHOMP\*(C' is a \*(C`Template::Toolkit\*(C' configuration parameter.</p><p>For details on driver configuration, see the docs for the individual drivers:</p>
<dl class='dl-vertical'>
  <dt>
    CGI::Application::Plugin::AnyTemplate::Driver::HTMLTemplate
  </dt>
  <dd>
    
  </dd>
  <dt>
    CGI::Application::Plugin::AnyTemplate::Driver::HTMLTemplateExpr
  </dt>
  <dd>
    
  </dd>
  <dt>
    CGI::Application::Plugin::AnyTemplate::Driver::HTMLTemplatePluggable
  </dt>
  <dd>
    
  </dd>
  <dt>
    CGI::Application::Plugin::AnyTemplate::Driver::TemplateToolkit
  </dt>
  <dd>
    
  </dd>
  <dt>
    CGI::Application::Plugin::AnyTemplate::Driver::Petal
  </dt>
  <dd>
    
  </dd>

</dl>
<p><em>Copying Query data into Templates</em></p><p><strong>This feature is now deprecated and will be removed in a future release.</strong></p><p>When you enable this feature all data in \*(C`$self-&gt;query\*(C' are copied into the template object before the template is processed.</p><p>For the \*(C`HTMLTemplate\*(C', \*(C`HTMLTemplateExpr\*(C' and \*(C`HTMLTemplatePluggable\*(C' drivers this is done with the \*(C`associate\*(C' feature of HTML::Template and HTML::Template::Expr, respectively:</p><p>    my $template = HTML::Template-&gt;new(         associate =&gt; $self-&gt;query,     );</p><p>For the other systems, this feature is emulated, by copying the query params into the template params before the template is processed.</p><p>To enable this feature, pass a true value to \*(C`associate_query\*(C' or \*(C`emulate_associate_query\*(C' (depending on the template system):</p>
<pre>
    $self-&gt;template-&gt;config(
        default_type =&gt; 'HTMLTemplate',
        HTMLTemplate =&gt; {
            associate_query =&gt; 1,
        },
        HTMLTemplateExpr =&gt; {
            associate_query =&gt; 1,
        },
        HTMLTemplatePluggable =&gt; {
            associate_query =&gt; 1,
        },
        TemplateToolkit =&gt; {
            emulate_associate_query =&gt; 1,
        },
        Petal =&gt; {
            emulate_associate_query =&gt; 1,
        },
    );
</pre>
<p>The reason this feature is now disabled by default is that it poses a potential \s-1XSS\s0 (Cross Site Scripting) security risk.</p><p>The reason this feature is now deprecated is that in an ideal world developers shouldn't have to flatten objects and hashes in order to make them available to their templates. They should be able to pass the query object (or another object such as a config object) directly into the template:</p><p>    $template-&gt;param(         &apos;query&apos; =&gt; $self-&gt;query,         &apos;cfg&apos;   =&gt; $self-&gt;cfg,         &apos;ENV&apos;   =&gt; $ENV,     );</p><p>And in the template retrieve parameters directly:</p><p>    your username: [% query.param(&apos;username&apos;) %]     administrator: [% cfg.admin %]     hostname:      [% ENV.SERVER_NAME %]</p><p>This approach works with Template::Toolkit, Petal, and HTML::Template::Pluggable (via the HTML::Template::Plugin::Dot plugin).</p><p>Note that \*(C`associate\*(C' and \*(C`associate_query\*(C' are not compatible.  So if you want to associate the query and an additional object, pass a list to \*(C`associate\*(C':</p><p>    $template-&gt;config(         HTMLTemplate =&gt; {             associate =&gt; [$self-&gt;query, $self-&gt;conf]         }     );</p>
<h3>load</h3>
<p>Create a new template object and configure it.</p><p>This can be as simple (and magical) as:</p><p>    my $template = $self-&gt;template-&gt;load;</p><p>When you call \*(C`load\*(C' with no parameters, it uses the default template type, the default template configuration, and it determines the name of the template based on the name of the current run mode.  It determines the current run mode by calling \*(C`$self-&gt;get_current_runmode\*(C'.</p><p>If you want to have the current runmode updated when you pass control to another runmode, use the CGI::Application::Plugin::Forward module:</p><p>    use CGI::Application::Plugin::Forward;</p><p>    sub first_runmode {         my $self = shift;         return $self-&gt;forward(&apos;second_runmode&apos;);     }     sub second_runmode {         my $self = shift;         my $template = $self-&gt;template-&gt;load;  # loads &apos;second_runmode.html&apos;     }</p><p>If instead you call \*(C`$self-&gt;other_method\*(C' directly, the value of \*(C`$self-&gt;get_current_runmode\*(C' will not be updated:</p><p>    sub first_runmode {         my $self = shift;         return $self-&gt;other_method;     }     sub other_method {         my $self = shift;         my $template = $self-&gt;template-&gt;load;  # loads &apos;first_runmode.html&apos;     }</p><p>If you want to override the way the default template filename is generated, you can do so with the \*(C`template_filename_generator\*(C' configuration parameter.</p><p>If you call \*(C`load\*(C' with one parameter, it is taken to be either the filename or a reference to a string containing the template text:</p><p>    my $template = $self-&gt;template-&gt;load(&apos;somefile&apos;);     my $template = $self-&gt;template-&gt;load(&#92;$some_text);</p><p>If the parameter \*(C`auto_add_template_exension\*(C' is true, then the appropriate extension will be added for this template type.</p><p>If you call \*(C`load\*(C' with more than one parameter, then you can specify filename and configuration parameters directly:</p><p>    my $template = $self-&gt;template-&gt;load(         file                        =&gt; &apos;some_file.tmpl&apos;,         type                        =&gt; &apos;HTMLTemplate&apos;,         auto_add_template_extension =&gt; 0,         add_include_paths           =&gt; &apos;..&apos;,         HTMLTemplate =&gt; {             die_on_bad_params =&gt; 1,         },     );</p><p>To initialize the template from a string rather than a file, use:</p><p>    my $template = $self-&gt;template-&gt;load(         string =&gt;  &#92;$some_text,     );</p><p>The configuration parameters you pass to \*(C`load\*(C' are merged with the configuration that was passed to \*(L"config\*(R".</p><p>You can include any of the configuration parameters that you can pass to config, plus the following extra parameters:</p>
<dl class='dl-vertical'>
  <dt>
    file
  </dt>
  <dd>
    <p>If you are loading the template from a file, then the \*(C`file\*(C' parameter contains the template's filename.</p>
  </dd>
  <dt>
    string
  </dt>
  <dd>
    <p>If you are loading the template from a string, then the \*(C`string\*(C' parameter contains the text of the template.  It can be either a scalar or a reference to a scalar.  Both of the following will work:     # passing a string     my $template = $self-&gt;template-&gt;load(         string =&gt; $some_text,     );</p><p>    # passing a reference to a string     my $template = $self-&gt;template-&gt;load(         string =&gt; &#92;$some_text,     );</p>
  </dd>
  <dt>
    add_include_paths
  </dt>
  <dd>
    <p>Additional include paths.  These will be merged with \*(C`include_paths\*(C' before being passed to the template driver.</p>
  </dd>

</dl>
<p>The \*(C`load\*(C' method returns a template driver object.  See below under \*(C`DRIVER METHODS\*(C', for how to use this object.</p>
<h3>fill</h3>
<p>Fill is a convenience method which in a single step creates the template, fills it with the template parameters and returns its output.</p><p>You can call it with or without a filename (or string ref).</p><p>The code:</p><p>    $self-&gt;template-&gt;fill(&apos;filename&apos;, &#92;%params);</p><p>is equivalent to:</p><p>    my $template = $self-&gt;template-&gt;load(&apos;filename&apos;);     $template-&gt;output(&#92;%params);</p><p>And the code:</p><p>    $self-&gt;template-&gt;fill(&#92;$some_text, &#92;%params);</p><p>is equivalent to:</p><p>    my $template = $self-&gt;template-&gt;load(&#92;$some_text);     $template-&gt;output(&#92;%params);</p><p>And the code:</p><p>    $self-&gt;template-&gt;fill(&#92;%params);</p><p>is equivalent to:</p><p>    my $template = $self-&gt;template-&gt;load;     $template-&gt;output(&#92;%params);</p><p>And the code:</p><p>    $self-&gt;template-&gt;fill(&apos;filename&apos;);</p><p>is equivalent to:</p><p>    my $template = $self-&gt;template-&gt;load(&apos;filename&apos;);     $template-&gt;output;</p><p>And the code:</p><p>    $self-&gt;template-&gt;fill(&#92;$some_text);</p><p>is equivalent to:</p><p>    my $template = $self-&gt;template-&gt;load(&#92;$some_text);     $template-&gt;output;</p><p>And the code:</p><p>    $self-&gt;template-&gt;fill;</p><p>is equivalent to:</p><p>    my $template = $self-&gt;template-&gt;load;     $template-&gt;output;</p>
<h3>process</h3>
<p>"process" is an alias for \*(L"fill\*(R".</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">APPLICATION METHODS</h2>
        <div class="sectioncontent">
<p>These methods are called directly on your application's $self object.</p><h3>load_tmpl</h3>
<p>This is an emulation of CGI::Application's built-in \*(C`load_tmpl\*(C' method.  For instance:</p><p>    $self-&gt;load_tmpl(&apos;some_template.html&apos;);</p><p>It is not exported by default.  To enable it, use:</p><p>    use CGI::Application::Plugin::AnyTemplate qw/:load_tmpl/;</p><p>You can call it the same way as documented in \*(C`CGI::Application\*(C' and it will have the same effect.  However, it will respect the current template \*(C`type\*(C', so you can still use it to fill templates of different backends.</p><p>The idea is that you can take an existing CGI::Application-based webapp which uses \*(C`HTML::Template\*(C' templates, and add the following code to it:</p><p>    use CGI::Application::Plugin::AnyTemplate qw/:load_tmpl/;</p><p>    sub setup {         my $self = shift;         $self-&gt;template-&gt;config(type =&gt; TemplateToolkit);     }</p><p>This will change all existing calls to load_tmpl within your application to use Template::Toolkit based templates.</p><p>Calling:</p><p>    my $template = $self-&gt;load_tmpl(&apos;some_template.html&apos;);</p><p>It is the equivalent of calling:</p><p>    my $template = $self-&gt;template-&gt;load(         file =&gt; &apos;some_template.html&apos;,         auto_add_template_extension =&gt; 0,     );</p><p>If you add extra options to \*(C`load_tmpl\*(C', these will be assumed to be HTML::Template specific options, with the exception of the \*(C`path\*(C' option, which will be extracted and used as 'add_include_paths':</p><p>    my $template = $self-&gt;load_tmpl(&apos;some_template.html&apos;,         cache =&gt; 0,         path  =&gt; &apos;/path/to/templates&apos;,     );</p><p>This will get translated into:</p><p>    my $template = $self-&gt;template-&gt;load(         file =&gt; &apos;some_template.html&apos;,         auto_add_template_extension =&gt; 0,         add_include_paths =&gt; &apos;/path/to/templates&apos;,         HTMLTemplate =&gt; {             cache =&gt; 0,         }     );</p><p>Note that if you specify any HTML::Template-specific options here, they will completely overwrite any options that you passed to config.</p><p>Some notes and caveats about using the \*(C`load_tmpl\*(C' method:</p><ul>
<li><p>This method only works for the default template configuration (i.e. \*(C`$self-&gt;template()\*(C'). If you set up a named configuration (e.g. \*(C`$self-&gt;template(&apos;myconfig&apos;)\*(C') there is no way to access it with \*(C`load_tmpl\*(C'.  Since plugins should be using named configurations, this means that the \*(C`load_tmpl\*(C' method should not be used by plugins.  See \*(L"\s-1NOTES\s0 \s-1FOR\s0 \s-1AUTHORS\s0 \s-1OF\s0 \s-1PLUGINS\s0 \s-1AND\s0 \s-1REUSABLE\s0 \s-1APPLICATIONS\s0\*(R", below.</p></li><li><p>The \*(C`load_tmpl\*(C' method does not automatically add an extension to the filename you pass to it, even if you have \*(C`auto_add_template_extension\*(C' set to a true value in your call to \*(C`$self-&gt;template-&gt;config\*(C'.</p></li><li><p>The \*(C`load_tmpl\*(C' method ignores always returns a string, not a reference to a string.  It ignores the setting of the \*(C`returns_references\*(C' option.</p></li>
</ul>
<h3>tmpl_path</h3>
<p>You can set the template \*(C`include_paths\*(C' by calling \*(C`$self-&gt;tmpl_path(&apos;/path/to/templates&apos;)\*(C'.</p><p>You can also do so by passing a value to the \*(C`TMPL_PATH\*(C' parameter to your application's \*(C`new\*(C' method:</p><p>    my $webapp = App-&gt;new(         TMPL_PATH =&gt; &apos;/path/to/templates&apos;,     );</p><p>Paths that you set via \*(C`tmpl_path\*(C'/\*(C`TMPL_PATH\*(C' will be put <strong>last</strong> in the list of include paths, after \*(C`add_include_paths\*(C' and \*(C`include_paths\*(C'.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DRIVER METHODS</h2>
        <div class="sectioncontent">
<p>These are the most commonly used methods of the \*(C`AnyTemplate\*(C' driver object.  The driver is what you get back from calling \*(C`$self-&gt;template-&gt;load\*(C'.</p><h3>param</h3>
<p>The \*(C`param\*(C' method gets and sets values within the template.</p><p>    my $template = $self-&gt;template-&gt;load;</p><p>    my @param_names = $template-&gt;param();</p><p>    my $value = $template-&gt;param(&apos;name&apos;);</p><p>    $template-&gt;param(&apos;name&apos; =&gt; &apos;value&apos;);     $template-&gt;param(         &apos;name1&apos; =&gt; &apos;value1&apos;,         &apos;name2&apos; =&gt; &apos;value2&apos;     );</p><p>It is designed to behave similarly to the \*(C`param\*(C' method in other modules like \s-1CGI\s0 and HTML::Template.</p>
<h3>get_param_hash</h3>
<p>Returns the template variables as a hash of names and values.</p><p>    my %params     = $self-&gt;template-&gt;get_param_hash;</p><p>In a scalar context, returns a reference to the hash used internally to contain the values:</p><p>    my $params_ref = $self-&gt;template-&gt;get_param_hash;</p><p>    $params_ref-&gt;{&apos;foo&apos;} = &apos;bar&apos;;  # directly change parameter &apos;foo&apos;</p>
<h3>output</h3>
<p>Returns the template with all the values filled in.</p><p>    return $template-&gt;output;</p><p>You can also supply names and values to the template at this stage:</p><p>    return $template-&gt;output(&apos;name&apos; =&gt; &apos;value&apos;, &apos;name2&apos; =&gt; &apos;value2&apos;);</p><p>If \*(C`return_references\*(C' option is set to true, then the return value of \*(C`output\*(C' will be a reference to a string.  If the \*(C`return_references\*(C' option is false, then a copy of the string will be returned.  By default \*(C`return_references\*(C' is true.</p><p>When you call the \*(C`output\*(C' method, any components embedded in the template are run.  See \*(L"\s-1EMBEDDED\s0 \s-1COMPONENTS\s0\*(R", below.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PRE- AND POST- PROCESS</h2>
        <div class="sectioncontent">
<p>There are several ways to customize the template process.  You can modify the template parameters before the template is filled, and you can modify the output of the template after it has been filled.</p><p>Multiple applications and plugins can hook into the template process pipeline, each making changes to the template input and output.</p><p>For instance, it will be possible to make a general-purpose \*(C`CGI::Application\*(C' plugin that adds arbitrary data to each new template (such as query parameters or configuration data).</p><p>Note that the \s-1API\s0 has changed for version 0.10 in a non-backwards-compatible way in order to use the new hook system provided by recent versions of \*(C`CGI::Application\*(C'.</p><h3>The load_tmpl hook</h3>
<p>The \*(C`load_tmpl\*(C' hook is designed to be compatible with the \*(C`load_tmpl\*(C' hook defined by \*(C`CGI::Application\*(C' itself.</p><p>The \*(C`load_tmpl\*(C' hook is called before the template object is created. Any callbacks that you register to this hook will be called before each template is loaded.  Register a \*(C`load_tmpl\*(C' callback with:</p><p>   $self-&gt;add_callback(&apos;load_tmpl&apos;,&#92;&my_load_tmpl);</p><p>When the \*(C`load_tmpl\*(C' callback is executed it will be passed three arguments (<em>adapted from the</em> CGI::Application <em>docs</em>):</p><p> 1. A hash reference of the extra params passed into C&lt;load_tmpl&gt;     (ignored by AnyTemplate with the exception of &apos;path&apos;)</p><p> 2. Followed by a hash reference to template parameters.     You can modify this hash by reference to affect values that are     actually passed to the param() method of the template object.</p><p> 3. The name of the template file.</p><p>Here's an example stub for a <em>load_tmpl()</em> callback:</p><p>    sub my_load_tmpl_callback {         my ($self, $ht_params, $tmpl_params, $tmpl_file) = @_;         # modify $tmpl_params by reference...     }</p><p>Currently, of all the params in $ht_params, all but 'path' are ignored, because these are specific to \*(C`HTML::Template\*(C'.  If you want to write a generic callback that needs to be able to access or modify \*(C`HTML::Template\*(C' parameters then let me know, or add a feature request on &lt;http://rt.cpan.org&gt;.</p><p>The \*(C`path\*(C' param of $ht_params is initially set to the value of \*(C`add_include_paths\*(C' (if set).  Your callback can modify the \*(C`path\*(C' param, and \*(C`add_include_param\*(C' will be set to the result.</p><p>Plugin authors who want to provide template processing features are encouraged to use the 'load_tmpl' hook when possible, since it will work both with AnyTemplate and with CGI::Application's built-in \*(C`load_tmpl\*(C'.</p>
<h3>The template_pre_process and template_post_process hooks</h3>
<p>Before the template output is generated, the \*(C`template_pre_process\*(C' hook is called.  Any callbacks that you register to this hook will be called before each template is processed.  Register a \*(C`template_pre_process\*(C' callback as follows:</p><p>    $self-&gt;add_callback(&apos;template_pre_process&apos;, &#92;&my_tmpl_pre_process);</p><p>Pre-process callbacks will be passed a reference to the $template object, and can can modify the parameters passed into the template by using the \*(C`param\*(C' method:</p><p>    sub my_tmpl_pre_process {         my ($self, $template) = @_;</p><p>        # Change the internal template parameters by reference         my $params = $template-&gt;get_param_hash;</p><p>        foreach my $key (keys %$params) {             $params{$key} = to_piglatin($params{$key});         }</p><p>        # Can also set values using the param method         $template-&gt;param(&apos;foo&apos;, &apos;bar&apos;);</p><p>    }</p><p>After the template output is generated, the \*(C`template_post_process\*(C' hook is called. You can register a \*(C`template_post_process\*(C' callback as follows:</p><p>    $self-&gt;add_callback(&apos;template_post_process&apos;, &#92;&my_tmpl_post_process);</p><p>Any callbacks that you register to this hook will be called after each template is processed, and will be passed both a reference to the template object and a reference to the output generated by the template. This allows you to modify the output of the template:</p><p>    sub my_tmpl_post_process {         my ($self, $template, $output_ref) = @_;</p><p>        $$output_ref =~ s/foo/bar/;     }</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EMBEDDED COMPONENTS</h2>
        <div class="sectioncontent">
<h3>Introduction</h3>
<p>\*(C`CGI::Application::Plugin::AnyTemplate\*(C' allows you to include application components within your templates.</p><p>For instance, you might include a <em>header</em> component a the top of every page and a <em>footer</em> component at the bottom of every page.</p><p>These componenets are actually first-class run modes.  When the template engine finds a special tag marking an embedded component, it passes control to the run mode of that name.  That run mode can then do whatever a normal run mode could do.  But typically it will load its own template and return the template's output.</p><p>This output returned from the embedded run mode is inserted into the containing template.</p><p>The syntax for embed components is specific to each type of template driver.</p>
<h3>Syntax</h3>
<p>HTML::Template syntax:</p><p>    &lt;TMPL_VAR NAME="CGIAPP_embed(&apos;some_run_mode&apos;)"&gt;</p><p>HTML::Template::Expr syntax:</p><p>    &lt;TMPL_VAR EXPR="CGIAPP_embed(&apos;some_run_mode&apos;)"&gt;</p><p>HTML::Template::Pluggable syntax:</p><p>    &lt;TMPL_VAR EXPR="cgiapp.embed(&apos;some_run_mode&apos;)"&gt;</p><p>Template::Toolkit syntax:</p><p>    [% CGIAPP.embed("some_run_mode") %]</p><p>Petal syntax:</p><p>    &lt;span tal:replace="structure CGIAPP/embed &apos;some_run_mode&apos;"&gt;         this text gets replaced by the output of some_run_mode     &lt;/span&gt;</p>
<h3>Getting Template Variables from the Containing Template</h3>
<p>The component run mode is passed a reference to the template object that contained the component.  The component run mode can use this object to access the params that were passed to the containing template.</p><p>For instance:</p><p>    sub header {         my ($self, $containing_template, @other_params) = @_;</p><p>        my %tmplvars = (             &apos;title&apos; =&gt; &apos;My glorious home page&apos;,         );</p><p>        my $template = $self-&gt;template-&gt;load;</p><p>        $template-&gt;param(%tmplvars, $containing_template-&gt;get_param_hash);         return $template-&gt;output;     }</p><p>In this example, the template values of the enclosing template would override any values set by the embedded component.</p>
<h3>Passing Parameters</h3>
<p>The template can pass parameters to the target run mode.  These are passed in after the reference to the containing template object.</p><p>Parameters can either be literal strings, specified within the template text, or they can be keys that will be looked up in the template's params.</p><p>Literal strings are enclosed in double or single quotes.  Param keys are barewords.</p><p>HTML::Template syntax:</p><p>    &lt;TMPL_VAR NAME="CGIAPP_embed(&apos;some_run_mode&apos;, param1, &apos;literal string2&apos;)"&gt;</p><p><em>Note that HTML::Template doesn't support this type of callback natively</em> <em>and that this behaviour is emulated by the HTMLTemplate driver</em> <em>see the docs to</em> CGI::Application::Plugin::AnyTemplate::Driver::HTMLTemplate <em>for limitations to the emulation</em>.</p><p>HTML::Template::Expr syntax:</p><p>    &lt;TMPL_VAR EXPR="CGIAPP_embed(&apos;some_run_mode&apos;, param1, &apos;literal string2&apos;)"&gt;</p><p>HTML::Template::Pluggable syntax:</p><p>    &lt;TMPL_VAR EXPR="cgiapp.embed(&apos;some_run_mode&apos;, param1, &apos;literal string2&apos;)"&gt;</p><p>Template::Toolkit syntax:</p><p>    [% CGIAPP.embed("some_run_mode", param1, &apos;literal string2&apos; ) %]</p><p>Petal syntax:</p><p>    &lt;span tal:replace="structure CGIAPP/embed &apos;some_run_mode&apos; param1 &apos;literal string2&apos; "&gt;         this text gets replaced by the output of some_run_mode     &lt;/span&gt;</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTES FOR AUTHORS OF PLUGINS AND REUSABLE APPLICATIONS</h2>
        <div class="sectioncontent">
<p>If you are writing a CGI::Application plugin module, or you are writing a \*(C`CGI::Application\*(C' program that will be distributed to other people (e.g. on \s-1CPAN\s0), then it's important to take steps to prevent your application's use of CGI::Application::Plugin::AnyTemplate from conflicting with other plugins or with your end users.</p><p>When a plugin that uses CGI::Application::Plugin::AnyTemplate calls:</p><p>   $self-&gt;template-&gt;config(...)</p><p>It overwrites any existing template configuration with the new settings. So if two plugins do that, they probably clobber each other.</p><p>However, CGI::Application::Plugin::AnyTemplate has the feature of named independent configs:</p><p>   $self-&gt;template(&apos;your_module&apos;)-&gt;config(...)    $self-&gt;template(&apos;my_plugin&apos;)-&gt;config(...)</p><p>These configs remain separate from each other.  However, you have to keep using these names throughout your module, even when you load and fill the template.  For instance:</p><p>   sub my_runmode {        my $self = shift;        my $template = $self-&gt;template(&apos;my_plugin&apos;)-&gt;load;        $template-&gt;output;    }</p><p>   sub your_runmode {        my $self = shift;        my %params;        $self-&gt;template(&apos;your_module&apos;)-&gt;fill(&#92;%params);    }</p><p>It's uglier and more verbose, but it also prevents plugins from stepping on each other's toes.</p><p>CGI::Application plugins that use CGI::Application::Plugin::AnyTemplate should default to using their own package name for the AnyTemplate config name:</p><p>   $self-&gt;template(_\|_PACKAGE_\|_)-&gt;config(...);    $self-&gt;template(_\|_PACKAGE_\|_)-&gt;fill(...);</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CHANGING THE NAME OF THE 'template' METHOD</h2>
        <div class="sectioncontent">
<p>If you want to access the features of this module using a method other than \*(C`template\*(C', you can do so via Anno Siegel's Exporter::Renaming module (available on \s-1CPAN\s0).</p><p>For instance, to use syntax similar to CGI::Application::Plugin::TT:</p><p>    use Exporter::Renaming;     use CGI::Application::Plugin::AnyTemplate Renaming =&gt; [ template =&gt; tt];</p><p>    sub cgiapp_init {         my $self = shift;</p><p>        my %params = ( ... );</p><p>        # Set config file and other options         $self-&gt;tt-&gt;config(             default_type =&gt; &apos;TemplateToolkit&apos;,         );</p><p>    }</p><p>    sub my_runmode {         my $self = shift;         $self-&gt;tt-&gt;process(&apos;file&apos;, &#92;%params);     }</p><p>And to use syntax similar to CGI::Application's \*(C`load_tmpl\*(C' mechanism:</p><p>    use Exporter::Renaming;     use CGI::Application::Plugin::AnyTemplate Renaming =&gt; [ template =&gt; tmpl];</p><p>    sub cgiapp_init {         my $self = shift;</p><p>        # Set config file and other options         $self-&gt;tmpl-&gt;config(             default_type =&gt; &apos;HTMLTemplate&apos;,         );</p><p>    }</p><p>    sub my_runmode {         my $self = shift;</p><p>        my %params = ( ... );</p><p>        my $template = $self-&gt;tmpl-&gt;load(&apos;file&apos;);         $template-&gt;param(&#92;%params);         $template-&gt;output;     }</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Michael Graham, \*(C`&lt;mgraham@cpan.org&gt;\*(C'</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ACKNOWLEDGEMENTS</h2>
        <div class="sectioncontent">
<p>I originally wrote this to be a subsystem in Richard Dice's CGI::Application-based framework, before I moved it into its own module.</p><p>Various ideas taken from CGI::Application (Jesse Erlbaum), CGI::Application::Plugin::TT (Cees Hek) and \*(C`Text::Boilerplate\*(C' (Stephen Nelson).</p><p>\*(C`Template::Toolkit\*(C' singleton support code stolen from CGI::Application::Plugin::TT.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>Please report any bugs or feature requests to \*(C`bug-cgi-application-plugin-anytemplate@rt.cpan.org\*(C', or through the web interface at &lt;http://rt.cpan.org&gt;.  I will be notified, and then you'll automatically be notified of progress on your bug as I make changes.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SOURCE</h2>
        <div class="sectioncontent">
<p>The source code repository for this module can be found at http://github.com/mgraham/CAP-AnyTemplate/</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO CGI::Application::Plugin::AnyTemplate&hellip;</h2>
        <div class="sectioncontent">
<p>    CGI::Application::Plugin::AnyTemplate::Base     CGI::Application::Plugin::AnyTemplate::ComponentHandler     CGI::Application::Plugin::AnyTemplate::Driver::HTMLTemplate     CGI::Application::Plugin::AnyTemplate::Driver::HTMLTemplateExpr     CGI::Application::Plugin::AnyTemplate::Driver::HTMLTemplatePluggable     CGI::Application::Plugin::AnyTemplate::Driver::TemplateToolkit     CGI::Application::Plugin::AnyTemplate::Driver::Petal</p><p>    CGI::Application</p><p>    Template::Toolkit     HTML::Template</p><p>    HTML::Template::Pluggable     HTML::Template::Plugin::Dot</p><p>    Petal</p><p>    Exporter::Renaming</p><p>    CGI::Application::Plugin::TT</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT & LICENSE</h2>
        <div class="sectioncontent">
<p>Copyright 2005 Michael Graham, All Rights Reserved.</p><p>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="CGI::Application::Dispatch::Regexp.3pm.html"><span aria-hidden="true">&larr;</span> CGI::Application::Dispatch::Regexp.3pm: Dispatch requests to cgi::application based objects using regular expressions</a></li>
   <li class="next"><a href="CGI::Application::Plugin::AnyTemplate::Base.3pm.html">CGI::Application::Plugin::AnyTemplate::Base.3pm: Base class for templates <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>serd: Serd -</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Serd -">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="serd (3) manual">
  <meta name="twitter:description" content="Serd -">
  <meta name="twitter:image" content="https://www.carta.tech/images/libserd-doc-serd-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/serd.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="serd (3) manual" />
  <meta property="og:description" content="Serd -" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libserd-doc-serd-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">serd<small> (3)</small></h1>
        <p class="lead">Serd -</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/serd.3.html">
      <span itemprop="name">serd: Serd -</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libserd-doc/">
      <span itemprop="name">libserd-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/serd.3.html">
      <span itemprop="name">serd: Serd -</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>A lightweight RDF syntax library.</p><h3>Data Structures</h3>
<p>struct <strong>SerdNode</strong></p><p>struct <strong>SerdChunk</strong></p><p>struct <strong>SerdError</strong></p><p>struct <strong>SerdURI</strong></p>
<h3>Typedefs</h3>
<p>typedef struct SerdEnvImpl <strong>SerdEnv</strong></p><p>typedef struct SerdReaderImpl <strong>SerdReader</strong></p><p>typedef struct SerdWriterImpl <strong>SerdWriter</strong></p><p>typedef uint32_t <strong>SerdStatementFlags</strong></p><p>typedef uint32_t <strong>SerdNodeFlags</strong></p>
<h3>Enumerations</h3>
<p>enum <strong>SerdStatus</strong> { <strong>SERD_SUCCESS</strong>, <strong>SERD_FAILURE</strong>, <strong>SERD_ERR_UNKNOWN</strong>, <strong>SERD_ERR_BAD_SYNTAX</strong>, <strong>SERD_ERR_BAD_ARG</strong>, <strong>SERD_ERR_NOT_FOUND</strong>, <strong>SERD_ERR_ID_CLASH</strong>, <strong>SERD_ERR_BAD_CURIE</strong>, <strong>SERD_ERR_INTERNAL</strong> }</p><p>enum <strong>SerdSyntax</strong> { <strong>SERD_TURTLE</strong> = 1, <strong>SERD_NTRIPLES</strong> = 2 }</p><p>enum <strong>SerdStatementFlag</strong> { <strong>SERD_EMPTY_S</strong> = 1 &lt;&lt; 1, <strong>SERD_EMPTY_O</strong> = 1 &lt;&lt; 2, <strong>SERD_ANON_S_BEGIN</strong> = 1 &lt;&lt; 3, <strong>SERD_ANON_O_BEGIN</strong> = 1 &lt;&lt; 4, <strong>SERD_ANON_CONT</strong> = 1 &lt;&lt; 5, <strong>SERD_LIST_S_BEGIN</strong> = 1 &lt;&lt; 6, <strong>SERD_LIST_O_BEGIN</strong> = 1 &lt;&lt; 7, <strong>SERD_LIST_CONT</strong> = 1 &lt;&lt; 8 }</p><p>enum <strong>SerdType</strong> { <strong>SERD_NOTHING</strong> = 0, <strong>SERD_LITERAL</strong> = 1, <strong>SERD_URI</strong> = 2, <strong>SERD_CURIE</strong> = 3, <strong>SERD_BLANK</strong> = 4 }</p><p>enum <strong>SerdNodeFlag</strong> { <strong>SERD_HAS_NEWLINE</strong> = 1, <strong>SERD_HAS_QUOTE</strong> = 1 &lt;&lt; 1 }</p><p>enum <strong>SerdStyle</strong> { <strong>SERD_STYLE_ABBREVIATED</strong> = 1, <strong>SERD_STYLE_ASCII</strong> = 1 &lt;&lt; 1, <strong>SERD_STYLE_RESOLVED</strong> = 1 &lt;&lt; 2, <strong>SERD_STYLE_CURIED</strong> = 1 &lt;&lt; 3, <strong>SERD_STYLE_BULK</strong> = 1 &lt;&lt; 4 }</p>
<h3>String Utilities</h3>
<p>const uint8_t * <strong>serd_strerror</strong> (<strong>SerdStatus</strong> status)</p><p>size_t <strong>serd_strlen</strong> (const uint8_t *str, size_t *n_bytes, <strong>SerdNodeFlags</strong> *flags)</p><p>double <strong>serd_strtod</strong> (const char *str, char **endptr)</p><p>void * <strong>serd_base64_decode</strong> (const uint8_t *str, size_t len, size_t *size)</p>
<h3>URI</h3>
<p>typedef size_t(* <strong>SerdSink</strong> )(const void *buf, size_t len, void *stream)</p><p>static const <strong>SerdURI</strong> <strong>SERD_URI_NULL</strong> = {{0,0},{0,0},{0,0},{0,0},{0,0},{0,0}}</p><p>const uint8_t * <strong>serd_uri_to_path</strong> (const uint8_t *uri)</p><p>uint8_t * <strong>serd_file_uri_parse</strong> (const uint8_t *uri, uint8_t **hostname)</p><p>bool <strong>serd_uri_string_has_scheme</strong> (const uint8_t *utf8)</p><p><strong>SerdStatus</strong> <strong>serd_uri_parse</strong> (const uint8_t *utf8, <strong>SerdURI</strong> *out)</p><p>void <strong>serd_uri_resolve</strong> (const <strong>SerdURI</strong> *uri, const <strong>SerdURI</strong> *base, <strong>SerdURI</strong> *out)</p><p>size_t <strong>serd_uri_serialise</strong> (const <strong>SerdURI</strong> *uri, <strong>SerdSink</strong> sink, void *stream)</p><p>size_t <strong>serd_uri_serialise_relative</strong> (const <strong>SerdURI</strong> *uri, const <strong>SerdURI</strong> *base, const <strong>SerdURI</strong> *root, <strong>SerdSink</strong> sink, void *stream)</p>
<h3>Node</h3>
<p>static const <strong>SerdNode</strong> <strong>SERD_NODE_NULL</strong> = { 0, 0, 0, 0, <strong>SERD_NOTHING</strong> }</p><p><strong>SerdNode</strong> <strong>serd_node_from_string</strong> (<strong>SerdType</strong> type, const uint8_t *str)</p><p><strong>SerdNode</strong> <strong>serd_node_copy</strong> (const <strong>SerdNode</strong> *node)</p><p>bool <strong>serd_node_equals</strong> (const <strong>SerdNode</strong> *a, const <strong>SerdNode</strong> *b)</p><p><strong>SerdNode</strong> <strong>serd_node_new_uri_from_node</strong> (const <strong>SerdNode</strong> *uri_node, const <strong>SerdURI</strong> *base, <strong>SerdURI</strong> *out)</p><p><strong>SerdNode</strong> <strong>serd_node_new_uri_from_string</strong> (const uint8_t *str, const <strong>SerdURI</strong> *base, <strong>SerdURI</strong> *out)</p><p><strong>SerdNode</strong> <strong>serd_node_new_file_uri</strong> (const uint8_t *path, const uint8_t *hostname, <strong>SerdURI</strong> *out, bool escape)</p><p><strong>SerdNode</strong> <strong>serd_node_new_uri</strong> (const <strong>SerdURI</strong> *uri, const <strong>SerdURI</strong> *base, <strong>SerdURI</strong> *out)</p><p><strong>SerdNode</strong> <strong>serd_node_new_decimal</strong> (double d, unsigned frac_digits)</p><p><strong>SerdNode</strong> <strong>serd_node_new_integer</strong> (int64_t i)</p><p><strong>SerdNode</strong> <strong>serd_node_new_blob</strong> (const void *buf, size_t size, bool wrap_lines)</p><p>void <strong>serd_node_free</strong> (<strong>SerdNode</strong> *node)</p>
<h3>Event Handlers</h3>
<p>typedef <strong>SerdStatus</strong>(* <strong>SerdErrorSink</strong> )(void *handle, const <strong>SerdError</strong> *error)</p><p>typedef <strong>SerdStatus</strong>(* <strong>SerdBaseSink</strong> )(void *handle, const <strong>SerdNode</strong> *uri)</p><p>typedef <strong>SerdStatus</strong>(* <strong>SerdPrefixSink</strong> )(void *handle, const <strong>SerdNode</strong> *name, const <strong>SerdNode</strong> *uri)</p><p>typedef <strong>SerdStatus</strong>(* <strong>SerdStatementSink</strong> )(void *handle, <strong>SerdStatementFlags</strong> flags, const <strong>SerdNode</strong> *graph, const <strong>SerdNode</strong> *subject, const <strong>SerdNode</strong> *predicate, const <strong>SerdNode</strong> *object, const <strong>SerdNode</strong> *object_datatype, const <strong>SerdNode</strong> *object_lang)</p><p>typedef <strong>SerdStatus</strong>(* <strong>SerdEndSink</strong> )(void *handle, const <strong>SerdNode</strong> *node)</p>
<h3>Environment</h3>
<p><strong>SerdEnv</strong> * <strong>serd_env_new</strong> (const <strong>SerdNode</strong> *base_uri)</p><p>void <strong>serd_env_free</strong> (<strong>SerdEnv</strong> *env)</p><p>const <strong>SerdNode</strong> * <strong>serd_env_get_base_uri</strong> (const <strong>SerdEnv</strong> *env, <strong>SerdURI</strong> *out)</p><p><strong>SerdStatus</strong> <strong>serd_env_set_base_uri</strong> (<strong>SerdEnv</strong> *env, const <strong>SerdNode</strong> *uri)</p><p><strong>SerdStatus</strong> <strong>serd_env_set_prefix</strong> (<strong>SerdEnv</strong> *env, const <strong>SerdNode</strong> *name, const <strong>SerdNode</strong> *uri)</p><p><strong>SerdStatus</strong> <strong>serd_env_set_prefix_from_strings</strong> (<strong>SerdEnv</strong> *env, const uint8_t *name, const uint8_t *uri)</p><p>bool <strong>serd_env_qualify</strong> (const <strong>SerdEnv</strong> *env, const <strong>SerdNode</strong> *uri, <strong>SerdNode</strong> *prefix, <strong>SerdChunk</strong> *suffix)</p><p><strong>SerdStatus</strong> <strong>serd_env_expand</strong> (const <strong>SerdEnv</strong> *env, const <strong>SerdNode</strong> *curie, <strong>SerdChunk</strong> *uri_prefix, <strong>SerdChunk</strong> *uri_suffix)</p><p><strong>SerdNode</strong> <strong>serd_env_expand_node</strong> (const <strong>SerdEnv</strong> *env, const <strong>SerdNode</strong> *node)</p><p>void <strong>serd_env_foreach</strong> (const <strong>SerdEnv</strong> *env, <strong>SerdPrefixSink</strong> func, void *handle)</p>
<h3>Reader</h3>
<p><strong>SerdReader</strong> * <strong>serd_reader_new</strong> (<strong>SerdSyntax</strong> syntax, void *handle, void(*free_handle)(void *), <strong>SerdBaseSink</strong> base_sink, <strong>SerdPrefixSink</strong> prefix_sink, <strong>SerdStatementSink</strong> statement_sink, <strong>SerdEndSink</strong> end_sink)</p><p>void <strong>serd_reader_set_error_sink</strong> (<strong>SerdReader</strong> *reader, <strong>SerdErrorSink</strong> error_sink, void *handle)</p><p>void * <strong>serd_reader_get_handle</strong> (const <strong>SerdReader</strong> *reader)</p><p>void <strong>serd_reader_add_blank_prefix</strong> (<strong>SerdReader</strong> *reader, const uint8_t *prefix)</p><p>void <strong>serd_reader_set_default_graph</strong> (<strong>SerdReader</strong> *reader, const <strong>SerdNode</strong> *graph)</p><p><strong>SerdStatus</strong> <strong>serd_reader_read_file</strong> (<strong>SerdReader</strong> *reader, const uint8_t *uri)</p><p><strong>SerdStatus</strong> <strong>serd_reader_start_stream</strong> (<strong>SerdReader</strong> *me, FILE *file, const uint8_t *name, bool bulk)</p><p><strong>SerdStatus</strong> <strong>serd_reader_read_chunk</strong> (<strong>SerdReader</strong> *me)</p><p><strong>SerdStatus</strong> <strong>serd_reader_end_stream</strong> (<strong>SerdReader</strong> *me)</p><p><strong>SerdStatus</strong> <strong>serd_reader_read_file_handle</strong> (<strong>SerdReader</strong> *reader, FILE *file, const uint8_t *name)</p><p><strong>SerdStatus</strong> <strong>serd_reader_read_string</strong> (<strong>SerdReader</strong> *me, const uint8_t *utf8)</p><p>void <strong>serd_reader_free</strong> (<strong>SerdReader</strong> *reader)</p>
<h3>Writer</h3>
<p><strong>SerdWriter</strong> * <strong>serd_writer_new</strong> (<strong>SerdSyntax</strong> syntax, <strong>SerdStyle</strong> style, <strong>SerdEnv</strong> *env, const <strong>SerdURI</strong> *base_uri, <strong>SerdSink</strong> sink, void *stream)</p><p>void <strong>serd_writer_free</strong> (<strong>SerdWriter</strong> *writer)</p><p><strong>SerdEnv</strong> * <strong>serd_writer_get_env</strong> (<strong>SerdWriter</strong> *writer)</p><p>size_t <strong>serd_file_sink</strong> (const void *buf, size_t len, void *stream)</p><p>size_t <strong>serd_chunk_sink</strong> (const void *buf, size_t len, void *stream)</p><p>uint8_t * <strong>serd_chunk_sink_finish</strong> (<strong>SerdChunk</strong> *stream)</p><p>void <strong>serd_writer_set_error_sink</strong> (<strong>SerdWriter</strong> *writer, <strong>SerdErrorSink</strong> error_sink, void *handle)</p><p>void <strong>serd_writer_chop_blank_prefix</strong> (<strong>SerdWriter</strong> *writer, const uint8_t *prefix)</p><p><strong>SerdStatus</strong> <strong>serd_writer_set_base_uri</strong> (<strong>SerdWriter</strong> *writer, const <strong>SerdNode</strong> *uri)</p><p><strong>SerdStatus</strong> <strong>serd_writer_set_root_uri</strong> (<strong>SerdWriter</strong> *writer, const <strong>SerdNode</strong> *uri)</p><p><strong>SerdStatus</strong> <strong>serd_writer_set_prefix</strong> (<strong>SerdWriter</strong> *writer, const <strong>SerdNode</strong> *name, const <strong>SerdNode</strong> *uri)</p><p><strong>SerdStatus</strong> <strong>serd_writer_write_statement</strong> (<strong>SerdWriter</strong> *writer, <strong>SerdStatementFlags</strong> flags, const <strong>SerdNode</strong> *graph, const <strong>SerdNode</strong> *subject, const <strong>SerdNode</strong> *predicate, const <strong>SerdNode</strong> *object, const <strong>SerdNode</strong> *object_datatype, const <strong>SerdNode</strong> *object_lang)</p><p><strong>SerdStatus</strong> <strong>serd_writer_end_anon</strong> (<strong>SerdWriter</strong> *writer, const <strong>SerdNode</strong> *node)</p><p><strong>SerdStatus</strong> <strong>serd_writer_finish</strong> (<strong>SerdWriter</strong> *writer)</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Data Structure Documentation</h2>
        <div class="sectioncontent">

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">struct SerdNode</h2>
        <div class="sectioncontent">
<p>A syntactic RDF node.</p><p><strong>Data Fields:</strong></p><p>const uint8_t * <em>buf</em> Value string.</p><p>size_t <em>n_bytes</em> Size in bytes (not including null)</p><p>size_t <em>n_chars</em> Length in characters (not including null)</p><p><strong>SerdNodeFlags</strong> <em>flags</em> Node flags (e.g. string properties)</p><p><strong>SerdType</strong> <em>type</em> Node type.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">struct SerdChunk</h2>
        <div class="sectioncontent">
<p>An unterminated string fragment.</p><p><strong>Data Fields:</strong></p><p>const uint8_t * <em>buf</em> Start of chunk.</p><p>size_t <em>len</em> Length of chunk in bytes.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">struct SerdError</h2>
        <div class="sectioncontent">
<p>An error description.</p><p><strong>Data Fields:</strong></p><p><strong>SerdStatus</strong> <em>status</em> Error code.</p><p>const uint8_t * <em>filename</em> File where error was encountered, or NULL.</p><p>unsigned <em>line</em> Line where error was encountered, or 0.</p><p>unsigned <em>col</em> Column where error was encountered.</p><p>const char * <em>fmt</em> Message format string (printf style)</p><p>va_list * <em>args</em> Arguments for fmt.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">struct SerdURI</h2>
        <div class="sectioncontent">
<p>A parsed URI.</p><p>This struct directly refers to chunks in other strings, it does not own any memory itself. Thus, URIs can be parsed and/or resolved against a base URI in-place without allocating memory.</p><p><strong>Data Fields:</strong></p><p><strong>SerdChunk</strong> <em>scheme</em> Scheme.</p><p><strong>SerdChunk</strong> <em>authority</em> Authority.</p><p><strong>SerdChunk</strong> <em>path_base</em> Path prefix if relative.</p><p><strong>SerdChunk</strong> <em>path</em> Path suffix.</p><p><strong>SerdChunk</strong> <em>query</em> Query.</p><p><strong>SerdChunk</strong> <em>fragment</em> Fragment.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Typedef Documentation</h2>
        <div class="sectioncontent">
<h3>typedef struct SerdEnvImpl \fBSerdEnv\fP</h3>
<p>Environment. Represents the state required to resolve a CURIE or relative URI, e.g. the base URI and set of namespace prefixes at a particular point.</p>
<h3>typedef struct SerdReaderImpl \fBSerdReader\fP</h3>
<p>RDF reader. Parses RDF by calling user-provided sink functions as input is consumed (much like an XML SAX parser).</p>
<h3>typedef struct SerdWriterImpl \fBSerdWriter\fP</h3>
<p>RDF writer. Provides a number of functions to allow writing RDF syntax out to some stream. These functions are deliberately compatible with the sink functions used by SerdReader, so a reader can be directly connected to a writer to re-serialise a document with minimal overhead.</p>
<h3>typedef uint32_t \fBSerdStatementFlags\fP</h3>
<p>Bitwise OR of SerdNodeFlag values.</p>
<h3>typedef uint32_t \fBSerdNodeFlags\fP</h3>
<p>Bitwise OR of SerdNodeFlag values.</p>
<h3>typedef size_t(* SerdSink)(const void *buf, size_t len, void *stream)</h3>
<p>Sink function for raw string output.</p>
<h3>typedef \fBSerdStatus\fP(* SerdErrorSink)(void *handle, const \fBSerdError\fP *error)</h3>
<p>Sink (callback) for errors.</p><p><strong>Parameters:</strong></p><p><em>handle</em> Handle for user data.</p><p><em>error</em> Error description.</p>
<h3>typedef \fBSerdStatus\fP(* SerdBaseSink)(void *handle, const \fBSerdNode\fP *uri)</h3>
<p>Sink (callback) for base URI changes. Called whenever the base URI of the serialisation changes.</p>
<h3>typedef \fBSerdStatus\fP(* SerdPrefixSink)(void *handle, const \fBSerdNode\fP *name, const \fBSerdNode\fP *uri)</h3>
<p>Sink (callback) for namespace definitions. Called whenever a prefix is defined in the serialisation.</p>
<h3>typedef \fBSerdStatus\fP(* SerdStatementSink)(void *handle, \fBSerdStatementFlags\fP flags, const \fBSerdNode\fP *graph, const \fBSerdNode\fP *subject, const \fBSerdNode\fP *predicate, const \fBSerdNode\fP *object, const \fBSerdNode\fP *object_datatype, const \fBSerdNode\fP *object_lang)</h3>
<p>Sink (callback) for statements. Called for every RDF statement in the serialisation.</p>
<h3>typedef \fBSerdStatus\fP(* SerdEndSink)(void *handle, const \fBSerdNode\fP *node)</h3>
<p>Sink (callback) for anonymous node end markers. This is called to indicate that the anonymous node with the given value will no longer be referred to by any future statements (i.e. the anonymous serialisation of the node is finished).</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Enumeration Type Documentation</h2>
        <div class="sectioncontent">
<h3>enum \fBSerdStatus\fP</h3>
<p>Return status code.</p><p><strong>Enumerator</strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><em>SERD_SUCCESS </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>No error.</p>
  </dd>
  <dt>
    <p><strong></strong><em>SERD_FAILURE </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Non-fatal failure.</p>
  </dd>
  <dt>
    <p><strong></strong><em>SERD_ERR_UNKNOWN </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Unknown error.</p>
  </dd>
  <dt>
    <p><strong></strong><em>SERD_ERR_BAD_SYNTAX </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Invalid syntax.</p>
  </dd>
  <dt>
    <p><strong></strong><em>SERD_ERR_BAD_ARG </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Invalid argument.</p>
  </dd>
  <dt>
    <p><strong></strong><em>SERD_ERR_NOT_FOUND </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Not found.</p>
  </dd>
  <dt>
    <p><strong></strong><em>SERD_ERR_ID_CLASH </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Encountered clashing blank node IDs.</p>
  </dd>
  <dt>
    <p><strong></strong><em>SERD_ERR_BAD_CURIE </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Invalid CURIE (e.g. prefix does not exist)</p>
  </dd>
  <dt>
    <p><strong></strong><em>SERD_ERR_INTERNAL </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Unexpected internal error (should not happen)</p>
  </dd>

</dl>

<h3>enum \fBSerdSyntax\fP</h3>
<p>RDF syntax type.</p><p><strong>Enumerator</strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><em>SERD_TURTLE </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Turtle - Terse RDF Triple Language (UTF-8).</p>
  </dd>

</dl>
<p><strong>See also:</strong></p><p>Turtle</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><em>SERD_NTRIPLES </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>NTriples - Line-based RDF triples (ASCII).</p>
  </dd>

</dl>
<p><strong>See also:</strong></p><p>NTriples</p>
<h3>enum \fBSerdStatementFlag\fP</h3>
<p>Flags indication inline abbreviation information for a statement.</p><p><strong>Enumerator</strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><em>SERD_EMPTY_S </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Empty blank node subject.</p>
  </dd>
  <dt>
    <p><strong></strong><em>SERD_EMPTY_O </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Empty blank node object.</p>
  </dd>
  <dt>
    <p><strong></strong><em>SERD_ANON_S_BEGIN </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Start of anonymous subject.</p>
  </dd>
  <dt>
    <p><strong></strong><em>SERD_ANON_O_BEGIN </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Start of anonymous object.</p>
  </dd>
  <dt>
    <p><strong></strong><em>SERD_ANON_CONT </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Continuation of anonymous node.</p>
  </dd>
  <dt>
    <p><strong></strong><em>SERD_LIST_S_BEGIN </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Start of list subject.</p>
  </dd>
  <dt>
    <p><strong></strong><em>SERD_LIST_O_BEGIN </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Start of list object.</p>
  </dd>
  <dt>
    <p><strong></strong><em>SERD_LIST_CONT </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Continuation of list.</p>
  </dd>

</dl>

<h3>enum \fBSerdType\fP</h3>
<p>Type of a syntactic RDF node. This is more precise than the type of an abstract RDF node. An abstract node is either a resource, literal, or blank. In syntax there are two ways to refer to a resource (by URI or CURIE) and two ways to refer to a blank (by ID or anonymously). Anonymous (inline) blank nodes are expressed using SerdStatementFlags rather than this type.</p><p><strong>Enumerator</strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><em>SERD_NOTHING </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>The type of a nonexistent node. This type is useful as a sentinel, but is never emitted by the reader.</p>
  </dd>
  <dt>
    <p><strong></strong><em>SERD_LITERAL </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Literal value. A literal optionally has either a language, or a datatype (not both).</p>
  </dd>
  <dt>
    <p><strong></strong><em>SERD_URI </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>URI (absolute or relative). Value is an unquoted URI string, which is either a relative reference with respect to the current base URI (e.g. 'foo/bar'), or an absolute URI (e.g. 'http://example.org/foo').</p>
  </dd>

</dl>
<p><strong>See also:</strong></p><p>RFC3986.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><em>SERD_CURIE </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>CURIE, a shortened URI. Value is an unquoted CURIE string relative to the current environment, e.g. 'rdf:type'.</p>
  </dd>

</dl>
<p><strong>See also:</strong></p><p>CURIE Syntax 1.0</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><em>SERD_BLANK </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>A blank node. Value is a blank node ID, e.g. 'id3', which is meaningful only within this serialisation.</p>
  </dd>

</dl>
<p><strong>See also:</strong></p><p>Turtle nodeID</p>
<h3>enum \fBSerdNodeFlag\fP</h3>
<p>Flags indicating certain string properties relevant to serialisation.</p><p><strong>Enumerator</strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><em>SERD_HAS_NEWLINE </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Contains line breaks ('&#92;n' or '&#92;r')</p>
  </dd>
  <dt>
    <p><strong></strong><em>SERD_HAS_QUOTE </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Contains quotes (''')</p>
  </dd>

</dl>

<h3>enum \fBSerdStyle\fP</h3>
<p>Syntax style options. The style of the writer output can be controlled by ORing together values from this enumeration. Note that some options are only supported for some syntaxes (e.g. NTriples does not support abbreviation and is always ASCII).</p><p><strong>Enumerator</strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><em>SERD_STYLE_ABBREVIATED </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Abbreviate triples when possible.</p>
  </dd>
  <dt>
    <p><strong></strong><em>SERD_STYLE_ASCII </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Escape all non-ASCII characters.</p>
  </dd>
  <dt>
    <p><strong></strong><em>SERD_STYLE_RESOLVED </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Resolve URIs against base URI.</p>
  </dd>
  <dt>
    <p><strong></strong><em>SERD_STYLE_CURIED </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Shorten URIs into CURIEs.</p>
  </dd>
  <dt>
    <p><strong></strong><em>SERD_STYLE_BULK </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Write output in pages.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Function Documentation</h2>
        <div class="sectioncontent">
<h3>const uint8_t* serd_strerror (\fBSerdStatus\fPstatus)</h3>
<p>Return a string describing a status code.</p>
<h3>size_t serd_strlen (const uint8_t *str, size_t *n_bytes, \fBSerdNodeFlags\fP *flags)</h3>
<p>Measure a UTF-8 string.</p><p><strong>Returns:</strong></p><p>Length of str in characters (except NULL).</p><p><strong>Parameters:</strong></p><p><em>str</em> A null-terminated UTF-8 string.</p><p><em>n_bytes</em> (Output) Set to the size of str<em> in bytes (except NULL).</em></p><p><em>flags</em> (Output) Set to the applicable flags.</p>
<h3>double serd_strtod (const char *str, char **endptr)</h3>
<p>Parse a string to a double. The API of this function is identical to the standard C strtod function, except this function is locale-independent and always matches the lexical format used in the Turtle grammar (the decimal point is always '.').</p>
<h3>void* serd_base64_decode (const uint8_t *str, size_tlen, size_t *size)</h3>
<p>Decode a base64 string. This function can be used to deserialise a blob node created with <strong>serd_node_new_blob()</strong>.</p><p><strong>Parameters:</strong></p><p><em>str</em> Base64 string to decode.</p><p><em>len</em> The length of str<em>.</em></p><p><em>size</em> Set to the size of the returned blob in bytes.</p><p><strong>Returns:</strong></p><p>A newly allocated blob which must be freed with free().</p>
<h3>const uint8_t* serd_uri_to_path (const uint8_t *uri)</h3>
<p>Return the local path for uri, or NULL if uri is not a file URI. Note this (inappropriately named) function only removes the file scheme if necessary, and returns uri unmodified if it is an absolute path. Percent encoding and other issues are not handled, to properly convert a file URI to a path, use <strong>serd_file_uri_parse()</strong>.</p>
<h3>uint8_t* serd_file_uri_parse (const uint8_t *uri, uint8_t **hostname)</h3>
<p>Get the unescaped path and hostname from a file URI.</p><p><strong>Parameters:</strong></p><p><em>uri</em> A file URI.</p><p><em>hostname</em> If non-NULL, set to the hostname, if present.</p><p><strong>Returns:</strong></p><p>The path component of the URI.</p><p>Both the returned path and hostname (if applicable) are owned by the caller and must be freed with free().</p>
<h3>bool serd_uri_string_has_scheme (const uint8_t *utf8)</h3>
<p>Return true iff utf8 starts with a valid URI scheme.</p>
<h3>\fBSerdStatus\fP serd_uri_parse (const uint8_t *utf8, \fBSerdURI\fP *out)</h3>
<p>Parse utf8, writing result to out.</p>
<h3>void serd_uri_resolve (const \fBSerdURI\fP *uri, const \fBSerdURI\fP *base, \fBSerdURI\fP *out)</h3>
<p>Set out to uri resolved against base.</p>
<h3>size_t serd_uri_serialise (const \fBSerdURI\fP *uri, \fBSerdSink\fPsink, void *stream)</h3>
<p>Serialise uri with a series of calls to sink.</p>
<h3>size_t serd_uri_serialise_relative (const \fBSerdURI\fP *uri, const \fBSerdURI\fP *base, const \fBSerdURI\fP *root, \fBSerdSink\fPsink, void *stream)</h3>
<p>Serialise uri relative to base with a series of calls to sink. The uri is written as a relative URI iff if it a child of base and root. The optional root parameter must be a prefix of base and can be used keep up-references ('../') within a certain namespace.</p>
<h3>\fBSerdNode\fP serd_node_from_string (\fBSerdType\fPtype, const uint8_t *str)</h3>
<p>Make a (shallow) node from str. This measures, but does not copy, str. No memory is allocated.</p>
<h3>\fBSerdNode\fP serd_node_copy (const \fBSerdNode\fP *node)</h3>
<p>Make a deep copy of node.</p><p><strong>Returns:</strong></p><p>a node that the caller must free with <strong>serd_node_free()</strong>.</p>
<h3>bool serd_node_equals (const \fBSerdNode\fP *a, const \fBSerdNode\fP *b)</h3>
<p>Return true iff a is equal to b.</p>
<h3>\fBSerdNode\fP serd_node_new_uri_from_node (const \fBSerdNode\fP *uri_node, const \fBSerdURI\fP *base, \fBSerdURI\fP *out)</h3>
<p>Simple wrapper for serd_node_new_uri to resolve a URI node.</p>
<h3>\fBSerdNode\fP serd_node_new_uri_from_string (const uint8_t *str, const \fBSerdURI\fP *base, \fBSerdURI\fP *out)</h3>
<p>Simple wrapper for serd_node_new_uri to resolve a URI string.</p>
<h3>\fBSerdNode\fP serd_node_new_file_uri (const uint8_t *path, const uint8_t *hostname, \fBSerdURI\fP *out, boolescape)</h3>
<p>Create a new file URI node from a file system path and optional hostname. Backslashes in Windows paths will be converted and '' will always be percent encoded. If escape is true, all other invalid characters will be percent encoded as well.</p><p>If path is relative, hostname is ignored. If out is not NULL, it will be set to the parsed URI.</p>
<h3>\fBSerdNode\fP serd_node_new_uri (const \fBSerdURI\fP *uri, const \fBSerdURI\fP *base, \fBSerdURI\fP *out)</h3>
<p>Create a new node by serialising uri into a new string.</p><p><strong>Parameters:</strong></p><p><em>uri</em> The URI to parse and serialise.</p><p><em>base</em> Base URI to resolve uri<em> against (or NULL for no resolution).</em></p><p><em>out</em> Set to the parsing of the new URI (i.e. points only to memory owned by the new returned node).</p>
<h3>\fBSerdNode\fP serd_node_new_decimal (doubled, unsignedfrac_digits)</h3>
<p>Create a new node by serialising d into an xsd:decimal string. The resulting node will always contain a `.', start with a digit, and end with a digit (i.e. will have a leading and/or trailing `0' if necessary). It will never be in scientific notation. A maximum of frac_digits digits will be written after the decimal point, but trailing zeros will automatically be omitted (except one if d is a round integer).</p><p>Note that about 16 and 8 fractional digits are required to precisely represent a double and float, respectively.</p><p><strong>Parameters:</strong></p><p><em>d</em> The value for the new node.</p><p><em>frac_digits</em> The maximum number of digits after the decimal place.</p>
<h3>\fBSerdNode\fP serd_node_new_integer (int64_ti)</h3>
<p>Create a new node by serialising i into an xsd:integer string.</p>
<h3>\fBSerdNode\fP serd_node_new_blob (const void *buf, size_tsize, boolwrap_lines)</h3>
<p>Create a node by serialising buf into an xsd:base64Binary string. This function can be used to make a serialisable node out of arbitrary binary data, which can be decoded using <strong>serd_base64_decode()</strong>.</p><p><strong>Parameters:</strong></p><p><em>buf</em> Raw binary input data.</p><p><em>size</em> Size of buf<em>.</em></p><p><em>wrap_lines</em> Wrap lines at 76 characters to conform to RFC 2045.</p>
<h3>void serd_node_free (\fBSerdNode\fP *node)</h3>
<p>Free any data owned by node. Note that if node is itself dynamically allocated (which is not the case for nodes created internally by serd), it will not be freed.</p>
<h3>\fBSerdEnv\fP* serd_env_new (const \fBSerdNode\fP *base_uri)</h3>
<p>Create a new environment.</p>
<h3>void serd_env_free (\fBSerdEnv\fP *env)</h3>
<p>Free ns.</p>
<h3>const \fBSerdNode\fP* serd_env_get_base_uri (const \fBSerdEnv\fP *env, \fBSerdURI\fP *out)</h3>
<p>Get the current base URI.</p>
<h3>\fBSerdStatus\fP serd_env_set_base_uri (\fBSerdEnv\fP *env, const \fBSerdNode\fP *uri)</h3>
<p>Set the current base URI.</p>
<h3>\fBSerdStatus\fP serd_env_set_prefix (\fBSerdEnv\fP *env, const \fBSerdNode\fP *name, const \fBSerdNode\fP *uri)</h3>
<p>Set a namespace prefix.</p>
<h3>\fBSerdStatus\fP serd_env_set_prefix_from_strings (\fBSerdEnv\fP *env, const uint8_t *name, const uint8_t *uri)</h3>
<p>Set a namespace prefix.</p>
<h3>bool serd_env_qualify (const \fBSerdEnv\fP *env, const \fBSerdNode\fP *uri, \fBSerdNode\fP *prefix, \fBSerdChunk\fP *suffix)</h3>
<p>Qualify uri into a CURIE if possible.</p>
<h3>\fBSerdStatus\fP serd_env_expand (const \fBSerdEnv\fP *env, const \fBSerdNode\fP *curie, \fBSerdChunk\fP *uri_prefix, \fBSerdChunk\fP *uri_suffix)</h3>
<p>Expand curie.</p>
<h3>\fBSerdNode\fP serd_env_expand_node (const \fBSerdEnv\fP *env, const \fBSerdNode\fP *node)</h3>
<p>Expand node, which must be a CURIE or URI, to a full URI.</p>
<h3>void serd_env_foreach (const \fBSerdEnv\fP *env, \fBSerdPrefixSink\fPfunc, void *handle)</h3>
<p>Call func for each prefix defined in env.</p>
<h3>\fBSerdReader\fP* serd_reader_new (\fBSerdSyntax\fPsyntax, void *handle, void(*)(void *)free_handle, \fBSerdBaseSink\fPbase_sink, \fBSerdPrefixSink\fPprefix_sink, \fBSerdStatementSink\fPstatement_sink, \fBSerdEndSink\fPend_sink)</h3>
<p>Create a new RDF reader.</p>
<h3>void serd_reader_set_error_sink (\fBSerdReader\fP *reader, \fBSerdErrorSink\fPerror_sink, void *handle)</h3>
<p>Set a function to be called when errors occur during reading. The error_sink will be called with handle as its first argument. If no error function is set, errors are printed to stderr in GCC style.</p>
<h3>void* serd_reader_get_handle (const \fBSerdReader\fP *reader)</h3>
<p>Return the handle passed to <strong>serd_reader_new()</strong>.</p>
<h3>void serd_reader_add_blank_prefix (\fBSerdReader\fP *reader, const uint8_t *prefix)</h3>
<p>Set a prefix to be added to all blank node identifiers. This is useful when multiple files are to be parsed into the same output (e.g. a store, or other files). Since Serd preserves blank node IDs, this could cause conflicts where two non-equivalent blank nodes are merged, resulting in corrupt data. By setting a unique blank node prefix for each parsed file, this can be avoided, while preserving blank node names.</p>
<h3>void serd_reader_set_default_graph (\fBSerdReader\fP *reader, const \fBSerdNode\fP *graph)</h3>
<p>Set the URI of the default graph. If this is set, the reader will emit quads with the graph set to the given node for any statements that are not in a named graph (which is currently all of them since Serd currently does not support any graph syntaxes).</p>
<h3>\fBSerdStatus\fP serd_reader_read_file (\fBSerdReader\fP *reader, const uint8_t *uri)</h3>
<p>Read a file at a given uri.</p>
<h3>\fBSerdStatus\fP serd_reader_start_stream (\fBSerdReader\fP *me, FILE *file, const uint8_t *name, boolbulk)</h3>
<p>Start an incremental read from a file handle. Iff bulk is true, file will be read a page at a time. This is more efficient, but uses a page of memory and means that an entire page of input must be ready before any callbacks will fire. To react as soon as input arrives, set bulk to false.</p>
<h3>\fBSerdStatus\fP serd_reader_read_chunk (\fBSerdReader\fP *me)</h3>
<p>Read a single 'chunk' of data during an incremental read. This function will read a single top level description, and return. This may be a directive, statement, or several statements; essentially it reads until a '.' is encountered. This is particularly useful for reading directly from a pipe or socket.</p>
<h3>\fBSerdStatus\fP serd_reader_end_stream (\fBSerdReader\fP *me)</h3>
<p>Finish an incremental read from a file handle.</p>
<h3>\fBSerdStatus\fP serd_reader_read_file_handle (\fBSerdReader\fP *reader, FILE *file, const uint8_t *name)</h3>
<p>Read file.</p>
<h3>\fBSerdStatus\fP serd_reader_read_string (\fBSerdReader\fP *me, const uint8_t *utf8)</h3>
<p>Read utf8.</p>
<h3>void serd_reader_free (\fBSerdReader\fP *reader)</h3>
<p>Free reader.</p>
<h3>\fBSerdWriter\fP* serd_writer_new (\fBSerdSyntax\fPsyntax, \fBSerdStyle\fPstyle, \fBSerdEnv\fP *env, const \fBSerdURI\fP *base_uri, \fBSerdSink\fPsink, void *stream)</h3>
<p>Create a new RDF writer.</p>
<h3>void serd_writer_free (\fBSerdWriter\fP *writer)</h3>
<p>Free writer.</p>
<h3>\fBSerdEnv\fP* serd_writer_get_env (\fBSerdWriter\fP *writer)</h3>
<p>Return the env used by writer.</p>
<h3>size_t serd_file_sink (const void *buf, size_tlen, void *stream)</h3>
<p>A convenience sink function for writing to a FILE*. This function can be used as a SerdSink when writing to a FILE*. The stream parameter must be a FILE* opened for writing.</p>
<h3>size_t serd_chunk_sink (const void *buf, size_tlen, void *stream)</h3>
<p>A convenience sink function for writing to a string. This function can be used as a SerdSink to write to a <strong>SerdChunk</strong> which is resized as necessary with realloc(). The stream<strong> parameter must point to an initialized </strong><strong>SerdChunk</strong><strong>. When the write is finished, the string should be retrieved with </strong><strong>serd_chunk_sink_finish()</strong><strong>.</strong></p>
<h3>uint8_t* serd_chunk_sink_finish (\fBSerdChunk\fP *stream)</h3>
<p>Finish a serialisation to a chunk with <strong>serd_chunk_sink()</strong>. The returned string is the result of the serialisation, which is NULL terminated (by this function) and owned by the caller.</p>
<h3>void serd_writer_set_error_sink (\fBSerdWriter\fP *writer, \fBSerdErrorSink\fPerror_sink, void *handle)</h3>
<p>Set a function to be called when errors occur during writing. The error_sink will be called with handle as its first argument. If no error function is set, errors are printed to stderr.</p>
<h3>void serd_writer_chop_blank_prefix (\fBSerdWriter\fP *writer, const uint8_t *prefix)</h3>
<p>Set a prefix to be removed from matching blank node identifiers.</p>
<h3>\fBSerdStatus\fP serd_writer_set_base_uri (\fBSerdWriter\fP *writer, const \fBSerdNode\fP *uri)</h3>
<p>Set the current output base URI (and emit directive if applicable). Note this function can be safely casted to SerdBaseSink.</p>
<h3>\fBSerdStatus\fP serd_writer_set_root_uri (\fBSerdWriter\fP *writer, const \fBSerdNode\fP *uri)</h3>
<p>Set the current root URI. The root URI should be a prefix of the base URI. The path of the root URI is the highest path any relative up-reference can refer to. For example, with root file:///foo/root and base file:///foo/root/base, file:///foo/root will be written as &lt;../&gt;, but file:///foo will be written non-relatively as file:///foo. If the root is not explicitly set, it defaults to the base URI, so no up-references will be created at all.</p>
<h3>\fBSerdStatus\fP serd_writer_set_prefix (\fBSerdWriter\fP *writer, const \fBSerdNode\fP *name, const \fBSerdNode\fP *uri)</h3>
<p>Set a namespace prefix (and emit directive if applicable). Note this function can be safely casted to SerdPrefixSink.</p>
<h3>\fBSerdStatus\fP serd_writer_write_statement (\fBSerdWriter\fP *writer, \fBSerdStatementFlags\fPflags, const \fBSerdNode\fP *graph, const \fBSerdNode\fP *subject, const \fBSerdNode\fP *predicate, const \fBSerdNode\fP *object, const \fBSerdNode\fP *object_datatype, const \fBSerdNode\fP *object_lang)</h3>
<p>Write a statement. Note this function can be safely casted to SerdStatementSink.</p>
<h3>\fBSerdStatus\fP serd_writer_end_anon (\fBSerdWriter\fP *writer, const \fBSerdNode\fP *node)</h3>
<p>Mark the end of an anonymous node's description. Note this function can be safely casted to SerdEndSink.</p>
<h3>\fBSerdStatus\fP serd_writer_finish (\fBSerdWriter\fP *writer)</h3>
<p>Finish a write.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Variable Documentation</h2>
        <div class="sectioncontent">
<h3>const \fBSerdURI\fP SERD_URI_NULL = {{0,0},{0,0},{0,0},{0,0},{0,0},{0,0}}\fC [static]\fP</h3>

<h3>const \fBSerdNode\fP SERD_NODE_NULL = { 0, 0, 0, 0, \fBSERD_NOTHING\fP }\fC [static]\fP</h3>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for Serd from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="sepol_genusers.3.html"><span aria-hidden="true">&larr;</span> sepol_genusers.3: Generate a new binary policy image with a customized user configuration</a></li>
   <li class="next"><a href="serial.h.3.html">serial.h.3: Serial i/o services. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

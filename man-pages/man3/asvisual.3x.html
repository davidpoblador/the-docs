<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>asvisual: Asvisual- abstraction layer on top of x visuals, focusing on color handling libafterimage/asvisual.h</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Asvisual- abstraction layer on top of x visuals, focusing on color handling libafterimage/asvisual.h">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="asvisual (3x) manual">
  <meta name="twitter:description" content="Asvisual- abstraction layer on top of x visuals, focusing on color handling libafterimage/asvisual.h">
  <meta name="twitter:image" content="https://www.carta.tech/images/libafterimage-dev-asvisual-3x.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3x/asvisual.3x.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="asvisual (3x) manual" />
  <meta property="og:description" content="Asvisual- abstraction layer on top of x visuals, focusing on color handling libafterimage/asvisual.h" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libafterimage-dev-asvisual-3x.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">asvisual<small> (3x)</small></h1>
        <p class="lead">Asvisual- abstraction layer on top of x visuals, focusing on color handling libafterimage/asvisual.h</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3x/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3x/asvisual.3x.html">
      <span itemprop="name">asvisual: Asvisual- abstraction layer on top of x visuals, focusing on color handling libafterimage/asvisual.h</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libafterimage-dev/">
      <span itemprop="name">libafterimage-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3x/asvisual.3x.html">
      <span itemprop="name">asvisual: Asvisual- abstraction layer on top of x visuals, focusing on color handling libafterimage/asvisual.h</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">NAMEasvisual</h2>
        <div class="sectioncontent">
<p>- Defines abstraction layer on top of X Visuals, as well as several fundamental color datatypes.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO asvisual&hellip;</h2>
        <div class="sectioncontent">
<p>Structures:</p>
<pre>
        ColorPair
        ASVisual
</pre>
<p>Functions :</p>
<pre>
  ASVisual initialization :
        query_screen_visual(), setup_truecolor_visual(),
        setup_pseudo_visual(), setup_as_colormap(),create_asvisual(),
        destroy_asvisual()
</pre>

<pre>
  ASVisual encoding/decoding :
        visual2visual_prop(), visual_prop2visual()
</pre>

<pre>
  ASVisual convenience functions :
        create_visual_window(), create_visual_pixmap(),
        create_visual_ximage()
</pre>
<p>Other libAfterImage modules :</p>
<pre>
         ascmap.h asfont.h asimage.h asvisual.h blender.h export.h
         import.h transform.h ximage.h
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Sasha Vasko &lt;sasha at aftercode dot net&gt; libAfterImage/alpha</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FUNCTION</h2>
        <div class="sectioncontent">
<p>Alpha channel adds visibility parameter to color value. Alpha channel's value of 0xFF signifies complete visibility, while 0 makes pixel completely transparent.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SOURCE</h2>
        <div class="sectioncontent">
<p>#define ALPHA_TRANSPARENT       0x00 #define ALPHA_SEMI_TRANSPARENT  0x7F #define ALPHA_SOLID             0xFF</p><p>libAfterImage/ARGB32</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEARGB32</h2>
        <div class="sectioncontent">
<p>- main color datatype</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FUNCTION</h2>
        <div class="sectioncontent">
<p>ARGB32 is fundamental datatype that hold 32bit value corresponding to pixels color and transparency value (alpha channel) in ARGB colorspace. It is encoded as follows : Lowermost 8 bits - Blue channel bits 8 to 15     - Green channel bits 16 to 23    - Red channel bits 24 to 31    - Alpha channel</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLE</h2>
        <div class="sectioncontent">
<p>ASTile.1</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SOURCE</h2>
        <div class="sectioncontent">
<p>typedef CARD32 ARGB32; #define ARGB32_White            0xFFFFFFFF #define ARGB32_Black            0xFF000000 /* default background color is #FF000000 : */ #define ARGB32_DEFAULT_BACK_COLOR   ARGB32_Black</p><p>#define ARGB32_ALPHA_CHAN       3 #define ARGB32_RED_CHAN         2 #define ARGB32_GREEN_CHAN       1 #define ARGB32_BLUE_CHAN        0 #define ARGB32_CHANNELS         4</p><p>#define MAKE_ARGB32(a,r,g,b)    ((( (CARD32)a)        &lt;&lt;24)| &#92;</p>
<pre>
                                 ((((CARD32)r)&0x00FF)&lt;&lt;16)| &#92;
                                 ((((CARD32)g)&0x00FF)&lt;&lt;8 )| &#92;
                                 (( (CARD32)b)&0x00FF))
</pre>
<p>#define MAKE_ARGB32_GREY8(a,l)  (((a)&lt;&lt;24)|(((l)&0x00FF)&lt;&lt;16)| &#92;</p>
<pre>
                                 (((l)&0x00FF)&lt;&lt;8)|((l)&0x00FF))
</pre>
<p>#define ARGB32_ALPHA8(c)        (((c)&gt;&gt;24)&0x00FF) #define ARGB32_RED8(c)          (((c)&gt;&gt;16)&0x00FF) #define ARGB32_GREEN8(c)        (((c)&gt;&gt;8 )&0x00FF) #define ARGB32_BLUE8(c)         ( (c)     &0x00FF) #define ARGB32_CHAN8(c,i)       (((c)&gt;&gt;((i)&lt;&lt;3))&0x00FF) #define MAKE_ARGB32_CHAN8(v,i)  (((v)&0x0000FF)&lt;&lt;((i)&lt;&lt;3))</p><p>#ifdef __GNUC__ #define ARGB32_ALPHA16(c)       ({ CARD32 __c = ARGB32_ALPHA8(c); __c | (__c&lt;&lt;8);}) #define ARGB32_RED16(c)         ({ CARD32 __c = ARGB32_RED8(c); __c | (__c&lt;&lt;8);}) #define ARGB32_GREEN16(c)       ({ CARD32 __c = ARGB32_GREEN8(c); __c | (__c&lt;&lt;8);}) #define ARGB32_BLUE16(c)        ({ CARD32 __c = ARGB32_BLUE8(c); __c | (__c&lt;&lt;8);}) #define ARGB32_CHAN16(c,i)      ({ CARD32 __c = ARGB32_CHAN8(c,i); __c | (__c&lt;&lt;8);}) #else #define ARGB32_ALPHA16(c)       ((((c)&gt;&gt;16)&0x00FF00)|(((c)&gt;&gt;24)&0x0000FF)) #define ARGB32_RED16(c)         ((((c)&gt;&gt;8 )&0x00FF00)|(((c)&gt;&gt;16)&0x0000FF)) #define ARGB32_GREEN16(c)       (( (c)     &0x00FF00)|(((c)&gt;&gt;8 )&0x0000FF)) #define ARGB32_BLUE16(c)        ((((c)&lt;&lt;8) &0x00FF00)|(((c)    )&0x0000FF)) #define ARGB32_CHAN16(c,i)      ((ARGB32_CHAN8(c,i)&lt;&lt;8)|ARGB32_CHAN8(c,i)) #endif</p><p>#define MAKE_ARGB32_CHAN16(v,i) ((((v)&0x00FF00)&gt;&gt;8)&lt;&lt;((i)&lt;&lt;3))</p><p>libAfterImage/ARGB32_manhattan_distance()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEARGB32_manhattan_distance()</h2>
        <div class="sectioncontent">
<p>- This function can be used to evaluate closeness of two colors.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>long ARGB32_manhattan_distance (long a, long b);</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    a,
  </dt>
  <dd>
    <p>b - ARGB32 color values to calculate Manhattan distance in between</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>returns calculated Manhattan distance. libAfterImage/ColorPart</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEIC_RED</h2>
        <div class="sectioncontent">
<p>- red channel IC_GREEN - green channel IC_BLUE - blue channel IC_ALPHA - alpha channel IC_NUM_CHANNELS - number of supported channels</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FUNCTION</h2>
        <div class="sectioncontent">
<p>Ids of the channels. These are basically synonyms to related ARGB32 channel numbers</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SOURCE</h2>
        <div class="sectioncontent">
<p>typedef enum {</p>
<pre>
  IC_BLUE   = ARGB32_BLUE_CHAN ,
  IC_GREEN  = ARGB32_GREEN_CHAN,
  IC_RED    = ARGB32_RED_CHAN  ,
  IC_ALPHA  = ARGB32_ALPHA_CHAN,
  IC_NUM_CHANNELS = ARGB32_CHANNELS
</pre>
<p>} ColorPart;</p><p>libAfterImage/ColorPair</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEColorPair</h2>
        <div class="sectioncontent">
<p>- convenient structure to hold pair of colors.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SOURCE</h2>
        <div class="sectioncontent">
<p>typedef struct ColorPair {</p>
<pre>
  ARGB32 fore;
  ARGB32 back;
</pre>
<p>}ColorPair;</p><p>libAfterImage/ASVisual</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEASVisual</h2>
        <div class="sectioncontent">
<p>- an abstraction layer on top of X Server Visual.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This structure has been introduced in order to compensate for the fact that X may have so many different types of Visuals. It provides shortcuts to most Visual data, compensated for differences in Visuals. For PseudoColor visual it also contains preallocated set of colors. This colormap allows us to write XImages very fast and without exhausting available X colors. This colormap consist of 8, 64, or 4096 colors and constitutes fraction of colors available in particular colordepth. This colors are allocated to be evenly spread around RGB spectrum. Thus when converting from internal presentation - all we need to do is to discard unused bits, and use rest of them bits as an index in our colormap. Opposite conversion is much trickier and we engage into nasty business of having hash table mapping pixel values into colors, or straight table doing same in lower colordepths. Idea is that we do all internal processing in 32bit colordepth, and ASVisual provides us with means to convert it to actual X display format. Respectively ASVisual has methods to write out XImage lines and read XImage lines. ASVisual creation is a tricky process. Basically first we have to go through the list of available Visuals and choose the best suitable. Then based on the type of this Visual we have to setup our data members and method hooks. Several functions provided for that :  query_screen_visual()    - will lookup best suitable visual  setup_truecolor_visual() - will setup hooks if visual is TrueColor  setup_pseudo_visual()   - will setup hooks and data if Visual is</p>
<pre>
                            PseudoColor.
</pre>
<p> setup_as_colormap()      - will preallocate colors for PseudoColor. Alternative to the above is :  create_asvisual()        - it encapsulates all of the above</p>
<pre>
                            functionality, and returns completely set
                            up ASVisual object.
</pre>
<p>Since Visual selected for ASVisual may differ from default ( we choose the best suitable ), all the window creation function must provide colormap and some other parameters, like border color for example. Thus we created some convenience functions. These should be used instead of standard Xlib calls :  create_visual_window() - to create window  create_visual_pixmap() - to create pixmap  create_visual_ximage() - to create XImage ASVisual could be dealolocated and its resources freed with :  destroy_asvisual()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLE</h2>
        <div class="sectioncontent">
<p>asview.c: ASView</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SOURCE</h2>
        <div class="sectioncontent">
<p>typedef struct ASVisual {</p>
<pre>
    Display      *dpy;
</pre>

<pre>
    /* This envvar will be used to determine what X Visual
     * (in hex) to use. If unset then best possible will
     * be selected automagically : */
</pre>
<p>#define ASVISUAL_ID_ENVVAR "AFTERIMAGE_VISUAL_ID"</p>
<pre>
    XVisualInfo   visual_info;
    /* this things are calculated based on Visual : */
    unsigned long rshift, gshift, bshift;
    unsigned long rbits,  gbits,  bbits;
    unsigned long true_depth;   /* could be 15 when X reports 16 */
    Bool          BGR_mode;
    Bool          msb_first;
    /* we must have colormap so that we can safely create windows
     * with different visuals even if we are in TrueColor mode : */
    Colormap      colormap;
    Bool          own_colormap; /* tells us to free colormap when we
                                 * done */
    unsigned long black_pixel, white_pixel;
    /* for PseudoColor mode we need some more stuff : */
    enum {
        ACM_None = 0,
        ACM_3BPP,
        ACM_6BPP,
        ACM_12BPP
    } as_colormap_type ;    /* there can only be 64 or 4096 entries
                             * so far ( 6 or 12 bpp) */
    unsigned long *as_colormap; /* array of preallocated colors for
                                 * PseudoColor mode */
    union                       /* reverse color lookup tables : */
    {
        ARGB32              *xref;
        struct ASHashTable  *hash;
    }as_colormap_reverse ;
</pre>

<pre>
    /* different useful callbacks : */
    CARD32 (*color2pixel_func)    ( struct ASVisual *asv,
                                    CARD32 encoded_color,
                                    unsigned long *pixel);
    void   (*pixel2color_func)    ( struct ASVisual *asv,
                                    unsigned long pixel,
                                    CARD32 *red, CARD32 *green,
                                    CARD32 *blue);
    void   (*ximage2scanline_func)( struct ASVisual *asv,
                                    XImage *xim,
                                    struct ASScanline *sl, int y,
                                    unsigned char *xim_data );
    void   (*scanline2ximage_func)( struct ASVisual *asv,
                                    XImage *xim,
                                    struct ASScanline *sl, int y,
                                    unsigned char *xim_data );
</pre>
<p>#define ASGLX_Unavailable           0 #define ASGLX_Available             (0x01&lt;&lt;0) #define ASGLX_DoubleBuffer          (0x01&lt;&lt;1) #define ASGLX_RGBA                  (0x01&lt;&lt;2) #define ASGLX_UseForImageTx         (0x01&lt;&lt;3)</p>
<pre>
    ASFlagType glx_support ;    /* one of the above flags */
</pre>

<pre>
    void *glx_scratch_gc_indirect ; /* (GLXContext) */
    void *glx_scratch_gc_direct ;   /* (GLXContext) */
</pre>

<pre>
    Window scratch_window;
</pre>
<p>#ifndef X_DISPLAY_MISSING #define ARGB2PIXEL(asv,argb,pixel)         &#92;</p>
<pre>
    (asv)-&gt;color2pixel_func((asv),(argb),(pixel))
</pre>
<p>#define GET_SCANLINE(asv,xim,sl,y,xim_data) &#92;</p>
<pre>
    (asv)-&gt;ximage2scanline_func((asv),(xim),(sl),(y),(xim_data))
</pre>
<p>#define PUT_SCANLINE(asv,xim,sl,y,xim_data) &#92;</p>
<pre>
    (asv)-&gt;scanline2ximage_func((asv),(xim),(sl),(y),(xim_data))
</pre>
<p>#else #define ARGB2PIXEL(asv,argb,pixel)         &#92;</p>
<pre>
    do{ break; }<strong>while</strong>(0)
</pre>
<p>#define GET_SCANLINE(asv,xim,sl,y,xim_data) &#92;</p>
<pre>
    do{ break; }<strong>while</strong>(0)
</pre>
<p>#define PUT_SCANLINE(asv,xim,sl,y,xim_data) &#92;</p>
<pre>
    do{ break; }<strong>while</strong>(0)
</pre>
<p>#endif }ASVisual;</p><p>libAfterImage/query_screen_visual()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEquery_screen_visual_id()</h2>
        <div class="sectioncontent">
<p>query_screen_visual()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>Bool query_screen_visual_id( ASVisual *asv, Display *dpy, int screen,</p>
<pre>
                          Window root, int default_depth,
                             VisualID visual_id, Colormap cmap );
</pre>
<p>Bool query_screen_visual( ASVisual *asv, Display *dpy, int screen,</p>
<pre>
                          Window root, int default_depth );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    asv
  </dt>
  <dd>
    <p>- preallocated ASVisual structure.</p>
  </dd>
  <dt>
    dpy
  </dt>
  <dd>
    <p>- valid pointer to opened X display.</p>
  </dd>
  <dt>
    screen
  </dt>
  <dd>
    <p>- screen number on which to query visuals.</p>
  </dd>
  <dt>
    root
  </dt>
  <dd>
    <p>- root window on that screen.</p>
  </dd>
  <dt>
    default_depth-
  </dt>
  <dd>
    <p>default colordepth of the screen.</p>
  </dd>
  <dt>
    visual_id
  </dt>
  <dd>
    <p>- optional ID of preferred Visual.</p>
  </dd>
  <dt>
    cmap
  </dt>
  <dd>
    <p>- optional colormap to be used.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>True on success, False on failure ASVisual structure pointed by asv will have the following data members set on success : dpy, visual_info, colormap, own_colormap, black_pixel, white_pixel.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>query_screen_visual_id() will go though prioritized list of possible Visuals and attempt to match those to what is available on the specified screen. If all items from list fail, then it goes about querying default visual. query_screen_visual is identical to query_screen_visual_id with visual_id and cmap set to 0. Once X Visual has been identified, we create X colormap and allocate white and black pixels from it. libAfterImage/setup_truecolor_visual()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEsetup_truecolor_visual()</h2>
        <div class="sectioncontent">

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>Bool setup_truecolor_visual( ASVisual *asv );</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    asv
  </dt>
  <dd>
    <p>- preallocated ASVisual structure.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>True on success, False if visual is not TrueColor.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>setup_truecolor_visual() checks if Visual is indeed TrueColor and if so it goes about querying color masks, deducing real XImage colordepth, and whether we work in BGR mode. It then goes about setting up correct hooks to X IO functions. libAfterImage/setup_pseudo_visual()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEsetup_pseudo_visual()</h2>
        <div class="sectioncontent">

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>void setup_pseudo_visual( ASVisual *asv  );</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    asv
  </dt>
  <dd>
    <p>- preallocated ASVisual structure.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>setup_pseudo_visual() assumes that Visual is PseudoColor. It then tries to decide as to how many colors preallocate, and goes about setting up correct X IO hooks and possibly initialization of reverse colormap in case ASVisual already has colormap preallocated. libAfterImage/setup_as_colormap()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEsetup_as_colormap()</h2>
        <div class="sectioncontent">

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>void setup_as_colormap( ASVisual *asv );</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    asv
  </dt>
  <dd>
    <p>- preallocated ASVisual structure.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>That has to be called in order to pre-allocate sufficient number of colors. It uses colormap size identification supplied in ASVisual structure. If colors where preallocated successfully - it will also create reverse lookup colormap. libAfterImage/create_asvisual_for_id()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEcreate_asvisual_for_id()</h2>
        <div class="sectioncontent">

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>ASVisual *create_asvisual_for_id( Display *dpy, int screen,</p>
<pre>
                                  int default_depth,
                                  VisualID visual_id, Colormap cmap,
                                  ASVisual *reusable_memory );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    dpy
  </dt>
  <dd>
    <p>- valid pointer to opened X display.</p>
  </dd>
  <dt>
    screen
  </dt>
  <dd>
    <p>- screen number on which to query visuals.</p>
  </dd>
  <dt>
    root
  </dt>
  <dd>
    <p>- root window on that screen.</p>
  </dd>
  <dt>
    default_depth-
  </dt>
  <dd>
    <p>default colordepth of the screen.</p>
  </dd>
  <dt>
    visual_id
  </dt>
  <dd>
    <p>- ID of X visual to use.</p>
  </dd>
  <dt>
    cmap
  </dt>
  <dd>
    <p>- optional ID of the colormap to be used.</p>
  </dd>
  <dt>
    reusable_memory
  </dt>
  <dd>
    <p>- pointer to preallocated ASVisual structure.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>Pointer to ASVisual structure initialized with enough information to be able to deal with current X Visual.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This function calls all the needed functions in order to setup new ASVisual structure for the specified screen and visual. If reusable_memory is not null - it will not allocate new ASVisual structure, but instead will use supplied one. Useful for allocating ASVisual on stack. This particular function will not do any autodetection and will use Visual ID supplied. That is useful when libAfterImage is used with an app that has its own approach to Visual handling, and since Visuals on all Windows, Pixmaps and colormaps must match, there is a need to synchronise visuals used by an app and libAfterImage. libAfterImage/create_asvisual()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEcreate_asvisual()</h2>
        <div class="sectioncontent">

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>ASVisual *create_asvisual( Display *dpy, int screen,</p>
<pre>
                           int default_depth,
                           ASVisual *reusable_memory );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    dpy
  </dt>
  <dd>
    <p>- valid pointer to opened X display.</p>
  </dd>
  <dt>
    screen
  </dt>
  <dd>
    <p>- screen number on which to query visuals.</p>
  </dd>
  <dt>
    root
  </dt>
  <dd>
    <p>- root window on that screen.</p>
  </dd>
  <dt>
    default_depth-
  </dt>
  <dd>
    <p>default colordepth of the screen.</p>
  </dd>
  <dt>
    reusable_memory
  </dt>
  <dd>
    <p>- pointer to preallocated ASVisual structure.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>Pointer to ASVisual structure initialized with enough information to be able to deal with current X Visual.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This function calls all the needed functions in order to setup new ASVisual structure for the specified screen. If reusable_memory is not null - it will not allocate new ASVisual structure, but instead will use supplied one. Useful for allocating ASVisual on stack. It is different from create_asvisualfor_id() in that it will attempt to autodetect best possible visual for the screen. For example on some SUN Solaris X servers there will be both 8bpp pseudocolor and 24bpp truecolor, and default will be 8bpp. In this scenario libAfterImage will detect and use 24bpp true color visual, thus producing much better results. libAfterImage/destroy_asvisual()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEdestroy_asvisual()</h2>
        <div class="sectioncontent">

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>void destroy_asvisual( ASVisual *asv, Bool reusable );</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    asv
  </dt>
  <dd>
    <p>- valid ASVisual structure.</p>
  </dd>
  <dt>
    reusable
  </dt>
  <dd>
    <p>- if True it will cause function to not free object itself.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Cleanup function. Frees all the memory and deallocates all the resources. If reusable is False it will also free the object, pointed to by asv.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLE</h2>
        <div class="sectioncontent">
<p>asview.c: ASView.2 libAfterImage/visual2visual_prop()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEvisual2visual_prop()</h2>
        <div class="sectioncontent">

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>Bool visual2visual_prop( ASVisual *asv, size_t *size,</p>
<pre>
                         unsigned long *version, unsigned long **data );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    asv
  </dt>
  <dd>
    <p>- valid ASVisual structure.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>size         - size of the encoded memory block. version      - version of the encoding data         - actual encoded memory block True on success, False on failure</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This function will encode ASVisual structure into memory block of 32 bit values, suitable for storing in X property. libAfterImage/visual_prop2visual()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEvisual_prop2visual()</h2>
        <div class="sectioncontent">

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>Bool visual_prop2visual( ASVisual *asv, Display *dpy, int screen,</p>
<pre>
                         size_t size,
                         unsigned long version, unsigned long *data );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    asv
  </dt>
  <dd>
    <p>- valid ASVisual structure.</p>
  </dd>
  <dt>
    dpy
  </dt>
  <dd>
    <p>- valid pointer to open X display.</p>
  </dd>
  <dt>
    screen
  </dt>
  <dd>
    <p>- screen number.</p>
  </dd>
  <dt>
    size
  </dt>
  <dd>
    <p>- encoded memory block's size.</p>
  </dd>
  <dt>
    version
  </dt>
  <dd>
    <p>- version of encoding.</p>
  </dd>
  <dt>
    data
  </dt>
  <dd>
    <p>- actual encoded memory block.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>True on success, False on failure</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>visual_prop2visual() will read ASVisual data from the memory block encoded by visual2visual_prop(). It could be used to read data from X property and convert it into usable information - such as colormap, visual info, etc. Note: setup_truecolor_visual() or setup_pseudo_visual() has to be invoked in order to complete ASVisual setup. libAfterImage/create_visual_window()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEcreate_visual_window()</h2>
        <div class="sectioncontent">

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>Window  create_visual_window( ASVisual *asv, Window parent,</p>
<pre>
                              int x, int y,
                              unsigned int width, unsigned int height,
                              unsigned int border_width,
                              unsigned int wclass,
                              unsigned long mask,
                              XSetWindowAttributes *attributes );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    asv
  </dt>
  <dd>
    <p>- pointer to the valid ASVisual structure.</p>
  </dd>
  <dt>
    parent
  </dt>
  <dd>
    <p>- Window ID of the parent the window.</p>
  </dd>
  <dt>
    x,
  </dt>
  <dd>
    <p>y - initial position of the new window.</p>
  </dd>
  <dt>
    width,
  </dt>
  <dd>
    <p>height - initial size of the new window.</p>
  </dd>
  <dt>
    border_width
  </dt>
  <dd>
    <p>- initial border width of the new window.</p>
  </dd>
  <dt>
    wclass
  </dt>
  <dd>
    <p>- Window class - InputOnly or InputOutput.</p>
  </dd>
  <dt>
    mask
  </dt>
  <dd>
    <p>- defines what attributes are set.</p>
  </dd>
  <dt>
    attributes
  </dt>
  <dd>
    <p>- different window attributes.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>ID of the newly created window on success. None on failure.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>create_visual_window() will do sanity checks on passed parameters, it will then add mandatory attributes if needed, and attempt to create window for the specified ASVisual. libAfterImage/create_visual_gc()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEcreate_visual_gc()</h2>
        <div class="sectioncontent">

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>GC      create_visual_gc( ASVisual *asv, Window root,</p>
<pre>
                          unsigned long mask, XGCValues *gcvalues );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    asv
  </dt>
  <dd>
    <p>- pointer to the valid ASVisual structure.</p>
  </dd>
  <dt>
    root
  </dt>
  <dd>
    <p>- Window ID of the root window of destination screen</p>
  </dd>
  <dt>
    mask,
  </dt>
  <dd>
    <p>gcvalues - values for creation of new GC - see XCreateGC() for details.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>New GC created for regular window on success. NULL on failure.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>create_visual_gc() will create temporary window for the ASVisual specific depth and Visual and it will then create GC for such window. Obtained GC should be good to be used for manipulation of windows and Pixmaps created for the same ASVisual. libAfterImage/create_visual_pixmap()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEcreate_visual_pixmap()</h2>
        <div class="sectioncontent">

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>Pixmap  create_visual_pixmap( ASVisual *asv, Window root,</p>
<pre>
                              unsigned int width, unsigned int height,
                              unsigned int depth );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    asv
  </dt>
  <dd>
    <p>- pointer to the valid ASVisual structure.</p>
  </dd>
  <dt>
    root
  </dt>
  <dd>
    <p>- Window ID of the root window of destination screen</p>
  </dd>
  <dt>
    width,
  </dt>
  <dd>
    <p>height - size of the pixmap to create.</p>
  </dd>
  <dt>
    depth
  </dt>
  <dd>
    <p>- depth of the pixmap to create. If 0 asv-&gt;true_depth will be used.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>ID of the newly created pixmap on success. None on failure.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>create_visual_pixmap() will perform sanity checks on passed parameters, and attempt to create pixmap for the specified ASVisual, root and depth. libAfterImage/create_visual_ximage()</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMEcreate_visual_ximage()</h2>
        <div class="sectioncontent">

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>XImage* create_visual_ximage( ASVisual *asv,</p>
<pre>
                              unsigned int width, unsigned int height,
                              unsigned int depth );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INPUTS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    asv
  </dt>
  <dd>
    <p>- pointer to the valid ASVisual structure.</p>
  </dd>
  <dt>
    width,
  </dt>
  <dd>
    <p>height - size of the XImage to create.</p>
  </dd>
  <dt>
    depth
  </dt>
  <dd>
    <p>- depth of the XImage to create. If 0 asv-&gt;true_depth will be used.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>pointer to newly created XImage on success. NULL on failure.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>create_visual_ximage() will perform sanity checks on passed parameters, and it will attempt to create XImage of sufficient size, and specified colordepth. It will also setup hooks for XImage deallocation to be handled by custom function.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="asview.3x.html"><span aria-hidden="true">&larr;</span> asview.3x: Asview- demonstrates loading and displaying of images libafterimage/tutorials/asview</a></li>
   <li class="next"><a href="blender.3x.html">blender.3x: Blender- functionality for blending of image data using diofferent algorithms libafterimage/blender.h <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

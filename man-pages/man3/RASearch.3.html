<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RASearch: The rasearch class: this class provides a generic manner to perform rank-approximate search via random-sampling.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The rasearch class: this class provides a generic manner to perform rank-approximate search via random-sampling.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="RASearch (3) manual">
  <meta name="twitter:description" content="The rasearch class: this class provides a generic manner to perform rank-approximate search via random-sampling.">
  <meta name="twitter:image" content="https://www.carta.tech/images/mlpack-doc-RASearch-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/RASearch.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="RASearch (3) manual" />
  <meta property="og:description" content="The rasearch class: this class provides a generic manner to perform rank-approximate search via random-sampling." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/mlpack-doc-RASearch-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">RASearch<small> (3)</small></h1>
        <p class="lead">The rasearch class: this class provides a generic manner to perform rank-approximate search via random-sampling.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/RASearch.3.html">
      <span itemprop="name">RASearch: The rasearch class: this class provides a generic manner to perform rank-approximate search via random-sampling.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/mlpack-doc/">
      <span itemprop="name">mlpack-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/RASearch.3.html">
      <span itemprop="name">RASearch: The rasearch class: this class provides a generic manner to perform rank-approximate search via random-sampling.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<h3>Public Member Functions</h3>
<p><strong>RASearch</strong> (const typename TreeType::Mat &<strong>referenceSet</strong>, const typename TreeType::Mat &<strong>querySet</strong>, const bool <strong>naive</strong>=false, const bool <strong>singleMode</strong>=false, const MetricType <strong>metric</strong>=MetricType())</p><p><em>Initialize the </em><strong>RASearch</strong><em> object, passing both a query and reference dataset. </em><strong></strong> <strong>RASearch</strong> (const typename TreeType::Mat &<strong>referenceSet</strong>, const bool <strong>naive</strong>=false, const bool <strong>singleMode</strong>=false, const MetricType <strong>metric</strong>=MetricType())</p><p><em>Initialize the </em><strong>RASearch</strong><em> object, passing only one dataset, which is used as both the query and the reference dataset. </em><strong></strong> <strong>RASearch</strong> (TreeType *<strong>referenceTree</strong>, TreeType *<strong>queryTree</strong>, const typename TreeType::Mat &<strong>referenceSet</strong>, const typename TreeType::Mat &<strong>querySet</strong>, const bool <strong>singleMode</strong>=false, const MetricType <strong>metric</strong>=MetricType())</p><p><em>Initialize the </em><strong>RASearch</strong><em> object with the given datasets and pre-constructed trees. </em><strong></strong> <strong>RASearch</strong> (TreeType *<strong>referenceTree</strong>, const typename TreeType::Mat &<strong>referenceSet</strong>, const bool <strong>singleMode</strong>=false, const MetricType <strong>metric</strong>=MetricType())</p><p><em>Initialize the </em><strong>RASearch</strong><em> object with the given reference dataset and pre-constructed tree. </em><strong></strong> <strong>~RASearch</strong> ()</p><p><em>Delete the </em><strong>RASearch</strong><em> object. </em><strong></strong> void <strong>ResetQueryTree</strong> ()</p><p><em>This function recursively resets the RAQueryStat of the queryTree to set 'bound' to WorstDistance and the 'numSamplesMade' to 0. </em> void <strong>Search</strong> (const size_t k, arma::Mat&lt; size_t &gt; &resultingNeighbors, arma::mat &distances, const double tau=5, const double <strong>alpha</strong>=0.95, const bool sampleAtLeaves=false, const bool firstLeafExact=false, const size_t singleSampleLimit=20)</p><p><em>Compute the rank approximate nearest neighbors and store the output in the given matrices. </em> std::string <strong>ToString</strong> () const </p>
<h3>Private Member Functions</h3>
<p>void <strong>ResetRAQueryStat</strong> (TreeType *treeNode)</p>
<h3>Private Attributes</h3>
<p>bool <strong>hasQuerySet</strong></p><p><em>Indicates if a separate query set was passed. </em> MetricType <strong>metric</strong></p><p><em>Instantiation of kernel. </em> bool <strong>naive</strong></p><p><em>Indicates if naive random sampling on the set is being used. </em> size_t <strong>numberOfPrunes</strong></p><p><em>Total number of pruned nodes during the neighbor search. </em> std::vector&lt; size_t &gt; <strong>oldFromNewQueries</strong></p><p><em>Permutations of query points during tree building. </em> std::vector&lt; size_t &gt; <strong>oldFromNewReferences</strong></p><p><em>Permutations of reference points during tree building. </em> arma::mat <strong>queryCopy</strong></p><p><em>Copy of query dataset (if we need it, because tree building modifies it). </em> const arma::mat & <strong>querySet</strong></p><p><em>Query dataset (may not be given). </em> TreeType * <strong>queryTree</strong></p><p><em>Pointer to the root of the query tree (might not exist). </em> arma::mat <strong>referenceCopy</strong></p><p><em>Copy of reference dataset (if we need it, because tree building modifies it). </em> const arma::mat & <strong>referenceSet</strong></p><p><em>Reference dataset. </em> TreeType * <strong>referenceTree</strong></p><p><em>Pointer to the root of the reference tree. </em> bool <strong>singleMode</strong></p><p><em>Indicates if single-tree search is being used (opposed to dual-tree). </em> bool <strong>treeOwner</strong></p><p><em>If true, this object created the trees and is responsible for them. </em></p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<h3>template&lt;typename SortPolicy = NearestNeighborSort, typename MetricType = mlpack::metric::SquaredEuclideanDistance, typename TreeType = tree::BinarySpaceTree&lt;bound::HRectBound&lt;2, false&gt;,                                                   RAQueryStat&lt;SortPolicy&gt; &gt;&gt;class RASearch&lt; SortPolicy, MetricType, TreeType &gt;</h3>
<p>The <strong>RASearch</strong> class: This class provides a generic manner to perform rank-approximate search via random-sampling.</p><p>If the 'naive' option is chosen, this rank-approximate search will be done by randomly sampled from the whole set. If the 'naive' option is not chosen, the sampling is done in a stratified manner in the tree as mentioned in the algorithms in Figure 2 of the following paper:</p><p>{ram2009rank, title={{Rank-Approximate Nearest Neighbor Search: Retaining Meaning and Speed in High Dimensions}}, author={{Ram, P. and Lee, D. and Ouyang, H. and Gray, A. G.}}, booktitle={{Advances of Neural Information Processing Systems}}, year={2009} }</p><p><strong>RASearch</strong> is currently known to not work with ball trees (#356).</p><p><strong>Template Parameters:</strong></p><p><em>SortPolicy</em> The sort policy for distances; see NearestNeighborSort.</p><p><em>MetricType</em> The metric to use for computation.</p><p><em>TreeType</em> The tree type to use.</p><p>Definition at line 71 of file ra_search.hpp.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>template&lt;typename SortPolicy  = NearestNeighborSort, typename MetricType  = mlpack::metric::SquaredEuclideanDistance, typename TreeType  = tree::BinarySpaceTree&lt;bound::HRectBound&lt;2, false&gt;,                                                   RAQueryStat&lt;SortPolicy&gt; &gt;&gt; \fBRASearch\fP&lt; SortPolicy, MetricType, TreeType &gt;::\fBRASearch\fP (const typename TreeType::Mat &referenceSet, const typename TreeType::Mat &querySet, const boolnaive = \fCfalse\fP, const boolsingleMode = \fCfalse\fP, const MetricTypemetric = \fCMetricType()\fP)</h3>
<p>Initialize the <strong>RASearch</strong> object, passing both a query and reference dataset. Optionally, perform the computation in naive mode or single-tree mode, and set the leaf size used for tree-building. An initialized distance metric can be given, for cases where the metric has internal data (i.e. the distance::MahalanobisDistance class).</p><p>This method will copy the matrices to internal copies, which are rearranged during tree-building. You can avoid this extra copy by pre-constructing the trees and passing them using a diferent constructor.</p><p><strong>Parameters:</strong></p><p><em>referenceSet</em> Set of reference points.</p><p><em>querySet</em> Set of query points.</p><p><em>naive</em> If true, the rank-approximate search will be performed by directly sampling the whole set instead of using the stratified sampling on the tree.</p><p><em>singleMode</em> If true, single-tree search will be used (as opposed to dual-tree search).</p><p><em>leafSize</em> Leaf size for tree construction (ignored if tree is given).</p><p><em>metric</em> An optional instance of the MetricType class.</p>
<h3>template&lt;typename SortPolicy  = NearestNeighborSort, typename MetricType  = mlpack::metric::SquaredEuclideanDistance, typename TreeType  = tree::BinarySpaceTree&lt;bound::HRectBound&lt;2, false&gt;,                                                   RAQueryStat&lt;SortPolicy&gt; &gt;&gt; \fBRASearch\fP&lt; SortPolicy, MetricType, TreeType &gt;::\fBRASearch\fP (const typename TreeType::Mat &referenceSet, const boolnaive = \fCfalse\fP, const boolsingleMode = \fCfalse\fP, const MetricTypemetric = \fCMetricType()\fP)</h3>
<p>Initialize the <strong>RASearch</strong> object, passing only one dataset, which is used as both the query and the reference dataset. Optionally, perform the computation in naive mode or single-tree mode, and set the leaf size used for tree-building. An initialized distance metric can be given, for cases where the metric has internal data (i.e. the distance::MahalanobisDistance class).</p><p>If naive mode is being used and a pre-built tree is given, it may not work: naive mode operates by building a one-node tree (the root node holds all the points). If that condition is not satisfied with the pre-built tree, then naive mode will not work.</p><p><strong>Parameters:</strong></p><p><em>referenceSet</em> Set of reference points.</p><p><em>naive</em> If true, the rank-approximate search will be performed by directly sampling the whole set instead of using the stratified sampling on the tree.</p><p><em>singleMode</em> If true, single-tree search will be used (as opposed to dual-tree search).</p><p><em>leafSize</em> Leaf size for tree construction (ignored if tree is given).</p><p><em>metric</em> An optional instance of the MetricType class.</p>
<h3>template&lt;typename SortPolicy  = NearestNeighborSort, typename MetricType  = mlpack::metric::SquaredEuclideanDistance, typename TreeType  = tree::BinarySpaceTree&lt;bound::HRectBound&lt;2, false&gt;,                                                   RAQueryStat&lt;SortPolicy&gt; &gt;&gt; \fBRASearch\fP&lt; SortPolicy, MetricType, TreeType &gt;::\fBRASearch\fP (TreeType *referenceTree, TreeType *queryTree, const typename TreeType::Mat &referenceSet, const typename TreeType::Mat &querySet, const boolsingleMode = \fCfalse\fP, const MetricTypemetric = \fCMetricType()\fP)</h3>
<p>Initialize the <strong>RASearch</strong> object with the given datasets and pre-constructed trees. It is assumed that the points in referenceSet and querySet correspond to the points in referenceTree and queryTree, respectively. Optionally, choose to use single-tree mode. Naive mode is not available as an option for this constructor; instead, to run naive computation, construct a tree with all of the points in one leaf (i.e. leafSize = number of points). Additionally, an instantiated distance metric can be given, for cases where the distance metric holds data.</p><p>There is no copying of the data matrices in this constructor (because tree-building is not necessary), so this is the constructor to use when copies absolutely must be avoided.</p><p><strong>Note:</strong></p><p>Because tree-building (at least with BinarySpaceTree) modifies the ordering of a matrix, be sure you pass the modified matrix to this object! In addition, mapping the points of the matrix back to their original indices is not done when this constructor is used.</p><p><strong>Parameters:</strong></p><p><em>referenceTree</em> Pre-built tree for reference points.</p><p><em>queryTree</em> Pre-built tree for query points.</p><p><em>referenceSet</em> Set of reference points corresponding to referenceTree.</p><p><em>querySet</em> Set of query points corresponding to queryTree.</p><p><em>singleMode</em> Whether single-tree computation should be used (as opposed to dual-tree computation).</p><p><em>metric</em> Instantiated distance metric.</p>
<h3>template&lt;typename SortPolicy  = NearestNeighborSort, typename MetricType  = mlpack::metric::SquaredEuclideanDistance, typename TreeType  = tree::BinarySpaceTree&lt;bound::HRectBound&lt;2, false&gt;,                                                   RAQueryStat&lt;SortPolicy&gt; &gt;&gt; \fBRASearch\fP&lt; SortPolicy, MetricType, TreeType &gt;::\fBRASearch\fP (TreeType *referenceTree, const typename TreeType::Mat &referenceSet, const boolsingleMode = \fCfalse\fP, const MetricTypemetric = \fCMetricType()\fP)</h3>
<p>Initialize the <strong>RASearch</strong> object with the given reference dataset and pre-constructed tree. It is assumed that the points in referenceSet correspond to the points in referenceTree. Optionally, choose to use single-tree mode. Naive mode is not available as an option for this constructor; instead, to run naive computation, construct a tree with all the points in one leaf (i.e. leafSize = number of points). Additionally, an instantiated distance metric can be given, for the case where the distance metric holds data.</p><p>There is no copying of the data matrices in this constructor (because tree-building is not necessary), so this is the constructor to use when copies absolutely must be avoided.</p><p><strong>Note:</strong></p><p>Because tree-building (at least with BinarySpaceTree) modifies the ordering of a matrix, be sure you pass the modified matrix to this object! In addition, mapping the points of the matrix back to their original indices is not done when this constructor is used.</p><p><strong>Parameters:</strong></p><p><em>referenceTree</em> Pre-built tree for reference points.</p><p><em>referenceSet</em> Set of reference points corresponding to referenceTree.</p><p><em>singleMode</em> Whether single-tree computation should be used (as opposed to dual-tree computation).</p><p><em>metric</em> Instantiated distance metric.</p>
<h3>template&lt;typename SortPolicy  = NearestNeighborSort, typename MetricType  = mlpack::metric::SquaredEuclideanDistance, typename TreeType  = tree::BinarySpaceTree&lt;bound::HRectBound&lt;2, false&gt;,                                                   RAQueryStat&lt;SortPolicy&gt; &gt;&gt; \fBRASearch\fP&lt; SortPolicy, MetricType, TreeType &gt;::~\fBRASearch\fP ()</h3>
<p>Delete the <strong>RASearch</strong> object. The tree is the only member we are responsible for deleting. The others will take care of themselves.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>template&lt;typename SortPolicy  = NearestNeighborSort, typename MetricType  = mlpack::metric::SquaredEuclideanDistance, typename TreeType  = tree::BinarySpaceTree&lt;bound::HRectBound&lt;2, false&gt;,                                                   RAQueryStat&lt;SortPolicy&gt; &gt;&gt; void \fBRASearch\fP&lt; SortPolicy, MetricType, TreeType &gt;::ResetQueryTree ()</h3>
<p>This function recursively resets the RAQueryStat of the queryTree to set 'bound' to WorstDistance and the 'numSamplesMade' to 0. This allows a user to perform multiple searches on the same pair of trees, possibly with different levels of approximation without requiring to build a new pair of trees for every new (approximate) search.</p>
<h3>template&lt;typename SortPolicy  = NearestNeighborSort, typename MetricType  = mlpack::metric::SquaredEuclideanDistance, typename TreeType  = tree::BinarySpaceTree&lt;bound::HRectBound&lt;2, false&gt;,                                                   RAQueryStat&lt;SortPolicy&gt; &gt;&gt; void \fBRASearch\fP&lt; SortPolicy, MetricType, TreeType &gt;::ResetRAQueryStat (TreeType *treeNode)\fC [private]\fP</h3>
<p><strong>Parameters:</strong></p><p><em>treeNode</em> The node of the tree whose RAQueryStat is reset and whose children are to be explored recursively.</p>
<h3>template&lt;typename SortPolicy  = NearestNeighborSort, typename MetricType  = mlpack::metric::SquaredEuclideanDistance, typename TreeType  = tree::BinarySpaceTree&lt;bound::HRectBound&lt;2, false&gt;,                                                   RAQueryStat&lt;SortPolicy&gt; &gt;&gt; void \fBRASearch\fP&lt; SortPolicy, MetricType, TreeType &gt;::Search (const size_tk, arma::Mat&lt; size_t &gt; &resultingNeighbors, arma::mat &distances, const doubletau = \fC5\fP, const doublealpha = \fC0.95\fP, const boolsampleAtLeaves = \fCfalse\fP, const boolfirstLeafExact = \fCfalse\fP, const size_tsingleSampleLimit = \fC20\fP)</h3>
<p>Compute the rank approximate nearest neighbors and store the output in the given matrices. The matrices will be set to the size of n columns by k rows, where n is the number of points in the query dataset and k is the number of neighbors being searched for.</p><p>Note that tau, the rank-approximation parameter, specifies that we are looking for k neighbors with probability alpha of being in the top tau percent of nearest neighbors. So, as an example, if our dataset has 1000 points, and we want 5 nearest neighbors with 95% probability of being in the top 5% of nearest neighbors (or, the top 50 nearest neighbors), we set k = 5, tau = 5, and alpha = 0.95.</p><p>The method will fail (and issue a failure message) if the value of tau is too low: tau must be set such that the number of points in the corresponding percentile of the data is greater than k. Thus, if we choose tau = 0.1 with a dataset of 1000 points and k = 5, then we are attempting to choose 5 nearest neighbors out of the closest 1 point -- this is invalid.</p><p><strong>Parameters:</strong></p><p><em>k</em> Number of neighbors to search for.</p><p><em>resultingNeighbors</em> Matrix storing lists of neighbors for each query point.</p><p><em>distances</em> Matrix storing distances of neighbors for each query point.</p><p><em>tau</em> The rank-approximation in percentile of the data. The default value is 5%.</p><p><em>alpha</em> The desired success probability. The default value is 0.95.</p><p><em>sampleAtLeaves</em> Sample at leaves for faster but less accurate computation. This defaults to 'false'.</p><p><em>firstLeafExact</em> Traverse to the first leaf without approximation. This can ensure that the query definitely finds its (near) duplicate if there exists one. This defaults to 'false' for now.</p><p><em>singleSampleLimit</em> The limit on the largest node that can be approximated by sampling. This defaults to 20.</p>
<h3>template&lt;typename SortPolicy  = NearestNeighborSort, typename MetricType  = mlpack::metric::SquaredEuclideanDistance, typename TreeType  = tree::BinarySpaceTree&lt;bound::HRectBound&lt;2, false&gt;,                                                   RAQueryStat&lt;SortPolicy&gt; &gt;&gt; std::string \fBRASearch\fP&lt; SortPolicy, MetricType, TreeType &gt;::ToString () const</h3>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Data Documentation</h2>
        <div class="sectioncontent">
<h3>template&lt;typename SortPolicy  = NearestNeighborSort, typename MetricType  = mlpack::metric::SquaredEuclideanDistance, typename TreeType  = tree::BinarySpaceTree&lt;bound::HRectBound&lt;2, false&gt;,                                                   RAQueryStat&lt;SortPolicy&gt; &gt;&gt; bool \fBRASearch\fP&lt; SortPolicy, MetricType, TreeType &gt;::hasQuerySet\fC [private]\fP</h3>
<p>Indicates if a separate query set was passed.</p><p>Definition at line 279 of file ra_search.hpp.</p>
<h3>template&lt;typename SortPolicy  = NearestNeighborSort, typename MetricType  = mlpack::metric::SquaredEuclideanDistance, typename TreeType  = tree::BinarySpaceTree&lt;bound::HRectBound&lt;2, false&gt;,                                                   RAQueryStat&lt;SortPolicy&gt; &gt;&gt; MetricType \fBRASearch\fP&lt; SortPolicy, MetricType, TreeType &gt;::metric\fC [private]\fP</h3>
<p>Instantiation of kernel.</p><p>Definition at line 287 of file ra_search.hpp.</p>
<h3>template&lt;typename SortPolicy  = NearestNeighborSort, typename MetricType  = mlpack::metric::SquaredEuclideanDistance, typename TreeType  = tree::BinarySpaceTree&lt;bound::HRectBound&lt;2, false&gt;,                                                   RAQueryStat&lt;SortPolicy&gt; &gt;&gt; bool \fBRASearch\fP&lt; SortPolicy, MetricType, TreeType &gt;::naive\fC [private]\fP</h3>
<p>Indicates if naive random sampling on the set is being used.</p><p>Definition at line 282 of file ra_search.hpp.</p>
<h3>template&lt;typename SortPolicy  = NearestNeighborSort, typename MetricType  = mlpack::metric::SquaredEuclideanDistance, typename TreeType  = tree::BinarySpaceTree&lt;bound::HRectBound&lt;2, false&gt;,                                                   RAQueryStat&lt;SortPolicy&gt; &gt;&gt; size_t \fBRASearch\fP&lt; SortPolicy, MetricType, TreeType &gt;::numberOfPrunes\fC [private]\fP</h3>
<p>Total number of pruned nodes during the neighbor search.</p><p>Definition at line 295 of file ra_search.hpp.</p>
<h3>template&lt;typename SortPolicy  = NearestNeighborSort, typename MetricType  = mlpack::metric::SquaredEuclideanDistance, typename TreeType  = tree::BinarySpaceTree&lt;bound::HRectBound&lt;2, false&gt;,                                                   RAQueryStat&lt;SortPolicy&gt; &gt;&gt; std::vector&lt;size_t&gt; \fBRASearch\fP&lt; SortPolicy, MetricType, TreeType &gt;::oldFromNewQueries\fC [private]\fP</h3>
<p>Permutations of query points during tree building.</p><p>Definition at line 292 of file ra_search.hpp.</p>
<h3>template&lt;typename SortPolicy  = NearestNeighborSort, typename MetricType  = mlpack::metric::SquaredEuclideanDistance, typename TreeType  = tree::BinarySpaceTree&lt;bound::HRectBound&lt;2, false&gt;,                                                   RAQueryStat&lt;SortPolicy&gt; &gt;&gt; std::vector&lt;size_t&gt; \fBRASearch\fP&lt; SortPolicy, MetricType, TreeType &gt;::oldFromNewReferences\fC [private]\fP</h3>
<p>Permutations of reference points during tree building.</p><p>Definition at line 290 of file ra_search.hpp.</p>
<h3>template&lt;typename SortPolicy  = NearestNeighborSort, typename MetricType  = mlpack::metric::SquaredEuclideanDistance, typename TreeType  = tree::BinarySpaceTree&lt;bound::HRectBound&lt;2, false&gt;,                                                   RAQueryStat&lt;SortPolicy&gt; &gt;&gt; arma::mat \fBRASearch\fP&lt; SortPolicy, MetricType, TreeType &gt;::queryCopy\fC [private]\fP</h3>
<p>Copy of query dataset (if we need it, because tree building modifies it).</p><p>Definition at line 264 of file ra_search.hpp.</p>
<h3>template&lt;typename SortPolicy  = NearestNeighborSort, typename MetricType  = mlpack::metric::SquaredEuclideanDistance, typename TreeType  = tree::BinarySpaceTree&lt;bound::HRectBound&lt;2, false&gt;,                                                   RAQueryStat&lt;SortPolicy&gt; &gt;&gt; const arma::mat& \fBRASearch\fP&lt; SortPolicy, MetricType, TreeType &gt;::querySet\fC [private]\fP</h3>
<p>Query dataset (may not be given).</p><p>Definition at line 269 of file ra_search.hpp.</p>
<h3>template&lt;typename SortPolicy  = NearestNeighborSort, typename MetricType  = mlpack::metric::SquaredEuclideanDistance, typename TreeType  = tree::BinarySpaceTree&lt;bound::HRectBound&lt;2, false&gt;,                                                   RAQueryStat&lt;SortPolicy&gt; &gt;&gt; TreeType* \fBRASearch\fP&lt; SortPolicy, MetricType, TreeType &gt;::queryTree\fC [private]\fP</h3>
<p>Pointer to the root of the query tree (might not exist).</p><p>Definition at line 274 of file ra_search.hpp.</p>
<h3>template&lt;typename SortPolicy  = NearestNeighborSort, typename MetricType  = mlpack::metric::SquaredEuclideanDistance, typename TreeType  = tree::BinarySpaceTree&lt;bound::HRectBound&lt;2, false&gt;,                                                   RAQueryStat&lt;SortPolicy&gt; &gt;&gt; arma::mat \fBRASearch\fP&lt; SortPolicy, MetricType, TreeType &gt;::referenceCopy\fC [private]\fP</h3>
<p>Copy of reference dataset (if we need it, because tree building modifies it).</p><p>Definition at line 262 of file ra_search.hpp.</p>
<h3>template&lt;typename SortPolicy  = NearestNeighborSort, typename MetricType  = mlpack::metric::SquaredEuclideanDistance, typename TreeType  = tree::BinarySpaceTree&lt;bound::HRectBound&lt;2, false&gt;,                                                   RAQueryStat&lt;SortPolicy&gt; &gt;&gt; const arma::mat& \fBRASearch\fP&lt; SortPolicy, MetricType, TreeType &gt;::referenceSet\fC [private]\fP</h3>
<p>Reference dataset.</p><p>Definition at line 267 of file ra_search.hpp.</p>
<h3>template&lt;typename SortPolicy  = NearestNeighborSort, typename MetricType  = mlpack::metric::SquaredEuclideanDistance, typename TreeType  = tree::BinarySpaceTree&lt;bound::HRectBound&lt;2, false&gt;,                                                   RAQueryStat&lt;SortPolicy&gt; &gt;&gt; TreeType* \fBRASearch\fP&lt; SortPolicy, MetricType, TreeType &gt;::referenceTree\fC [private]\fP</h3>
<p>Pointer to the root of the reference tree.</p><p>Definition at line 272 of file ra_search.hpp.</p>
<h3>template&lt;typename SortPolicy  = NearestNeighborSort, typename MetricType  = mlpack::metric::SquaredEuclideanDistance, typename TreeType  = tree::BinarySpaceTree&lt;bound::HRectBound&lt;2, false&gt;,                                                   RAQueryStat&lt;SortPolicy&gt; &gt;&gt; bool \fBRASearch\fP&lt; SortPolicy, MetricType, TreeType &gt;::singleMode\fC [private]\fP</h3>
<p>Indicates if single-tree search is being used (opposed to dual-tree).</p><p>Definition at line 284 of file ra_search.hpp.</p>
<h3>template&lt;typename SortPolicy  = NearestNeighborSort, typename MetricType  = mlpack::metric::SquaredEuclideanDistance, typename TreeType  = tree::BinarySpaceTree&lt;bound::HRectBound&lt;2, false&gt;,                                                   RAQueryStat&lt;SortPolicy&gt; &gt;&gt; bool \fBRASearch\fP&lt; SortPolicy, MetricType, TreeType &gt;::treeOwner\fC [private]\fP</h3>
<p>If true, this object created the trees and is responsible for them.</p><p>Definition at line 277 of file ra_search.hpp.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for MLPACK from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="libqwt5-doc-QwtWheel.3.html"><span aria-hidden="true">&larr;</span> QwtWheel.3: Qwtwheel -</a></li>
   <li class="next"><a href="RTCPCompoundHandler.3.html">RTCPCompoundHandler.3: Low level structs and rtcp packet parsing and building methods. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Log::Dispatch::Config: Log4j for perl</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Log4j for perl">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Log::Dispatch::Config (3pm) manual">
  <meta name="twitter:description" content="Log4j for perl">
  <meta name="twitter:image" content="https://www.carta.tech/images/liblog-dispatch-config-perl-Log::Dispatch::Config-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Log::Dispatch::Config.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Log::Dispatch::Config (3pm) manual" />
  <meta property="og:description" content="Log4j for perl" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/liblog-dispatch-config-perl-Log::Dispatch::Config-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Log::Dispatch::Config<small> (3pm)</small></h1>
        <p class="lead">Log4j for perl</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Log::Dispatch::Config.3pm.html">
      <span itemprop="name">Log::Dispatch::Config: Log4j for perl</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/liblog-dispatch-config-perl/">
      <span itemprop="name">liblog-dispatch-config-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Log::Dispatch::Config.3pm.html">
      <span itemprop="name">Log::Dispatch::Config: Log4j for perl</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  use Log::Dispatch::Config;
  Log::Dispatch::Config-&gt;configure(&apos;/path/to/log.conf&apos;);

  my $dispatcher = Log::Dispatch::Config-&gt;instance;
  $dispatcher-&gt;debug(&apos;this is debug message&apos;);
  $dispatcher-&gt;emergency(&apos;something *bad* happened!&apos;);

  # automatic reloading conf file, when modified
  Log::Dispatch::Config-&gt;configure_and_watch(&apos;/path/to/log.conf&apos;);

  # or if you write your own config parser:
  use Log::Dispatch::Configurator::XMLSimple;

  my $config = Log::Dispatch::Configurator::XMLSimple-&gt;new(&apos;log.xml&apos;);
  Log::Dispatch::Config-&gt;configure($config);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Log::Dispatch::Config is a subclass of Log::Dispatch and provides a way to configure Log::Dispatch object with configulation file (default, in AppConfig format). I mean, this is log4j for Perl, not with all \s-1API\s0 compatibility though.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHOD</h2>
        <div class="sectioncontent">
<p>This module has a class method \*(C`configure\*(C' which parses config file for later creation of the Log::Dispatch::Config singleton instance. (Actual construction of the object is done in the first \*(C`instance\*(C' call).</p><p>So, what you should do is call \*(C`configure\*(C' method once in somewhere (like \*(C`startup.pl\*(C' in mod_perl), then you can get configured dispatcher instance via \*(C`Log::Dispatch::Config-&gt;instance\*(C'.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONFIGURATION</h2>
        <div class="sectioncontent">
<p>Here is an example of the config file:</p><p>  dispatchers = file screen</p><p>  file.class = Log::Dispatch::File   file.min_level = debug   file.filename = /path/to/log   file.mode = append   file.format = [%d] [%p] %m at %F line %L%n</p><p>  screen.class = Log::Dispatch::Screen   screen.min_level = info   screen.stderr = 1   screen.format = %m</p><p>In this example, config file is written in AppConfig format. See Log::Dispatch::Configurator::AppConfig for details.</p><p>See \*(L"\s-1PLUGGABLE\s0 \s-1CONFIGURATOR\s0\*(R" for other config parsing scheme.</p><h3>\s-1GLOBAL\s0 \s-1PARAMETERS\s0</h3>

<dl class='dl-vertical'>
  <dt>
    dispatchers
  </dt>
  <dd>
    <p>  dispatchers = file screen \*(C`dispatchers\*(C' defines logger names, which will be split by spaces. If this parameter is unset, no logging is done.</p>
  </dd>
  <dt>
    format
  </dt>
  <dd>
    <p>  format = [%d] [%p] %m at %F line %L%n \*(C`format\*(C' defines log format. Possible conversions format are   %d    datetime string (<a href="../man3/ctime.3.html"><strong>ctime</strong>(3)</a>)   %p    priority (debug, info, warning ...)   %m    message string   %F    filename   %L    line number   %P    package   %n    newline (&#92;n)   %%    % itself Note that datetime (%d) format is configurable by passing \*(C`strftime\*(C' fmt in braket after %d. (I know it looks quite messy, but its compatible with Java Log4j ;)   format = [%d{%Y%m%d}] %m  # datetime is now strftime "%Y%m%d" If you have Time::Piece, this module uses its \*(C`strftime\*(C' implementation, otherwise \s-1POSIX\s0. \*(C`format\*(C' defined here would apply to all the log messages to dispatchers. This parameter is <strong>optional</strong>. See \*(L"\s-1CALLER\s0 \s-1STACK\s0\*(R" for details about package, line number and filename.</p>
  </dd>

</dl>

<h3>\s-1PARAMETERS\s0 \s-1FOR\s0 \s-1EACH\s0 \s-1DISPATCHER\s0</h3>
<p>Parameters for each dispatcher should be prefixed with \*(L"name.\*(R", where \*(L"name\*(R" is the name of each one, defined in global \*(C`dispatchers\*(C' parameter.</p><p>You can also use \*(C`.ini\*(C' style grouping like:</p><p>  [foo]   class = Log::Dispatch::File   min_level = debug</p><p>See Log::Dispatch::Configurator::AppConfig for details.</p>
<dl class='dl-vertical'>
  <dt>
    class
  </dt>
  <dd>
    <p>  screen.class = Log::Dispatch::Screen \*(C`class\*(C' defines class name of Log::Dispatch subclasses. This parameter is <strong>essential</strong>.</p>
  </dd>
  <dt>
    format
  </dt>
  <dd>
    <p>  screen.format = -- %m -- \*(C`format\*(C' defines log format which would be applied only to the dispatcher. Note that if you define global \*(C`format\*(C' also, %m is double formated (first global one, next each dispatcher one). This parameter is <strong>optional</strong>.</p>
  </dd>
  <dt>
    (others)
  </dt>
  <dd>
    <p>  screen.min_level = info   screen.stderr = 1 Other parameters would be passed to the each dispatcher construction. See Log::Dispatch::* manpage for the details.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SINGLETON</h2>
        <div class="sectioncontent">
<p>Declared \*(C`instance\*(C' method would make \*(C`Log::Dispatch::Config\*(C' class singleton, so multiple calls of \*(C`instance\*(C' will all result in returning same object.</p><p>  my $one = Log::Dispatch::Config-&gt;instance;   my $two = Log::Dispatch::Config-&gt;instance; # same as $one</p><p>See GoF Design Pattern book for Singleton Pattern.</p><p>But in practice, in persistent environment like mod_perl, lifetime of Singleton instance becomes sometimes messy. If you want to reload singleton object manually, call \*(C`reload\*(C' method.</p><p>  Log::Dispatch::Config-&gt;reload;</p><p>And, if you want to reload object on the fly, as you edit \*(C`log.conf\*(C' or something like that, what you should do is to call \*(C`configure_and_watch\*(C' method on Log::Dispatch::Config instead of \*(C`configure\*(C'. Then \*(C`instance\*(C' call will check mtime of configuration file, and compares it with instanciation time of singleton object. If config file is newer than last instanciation, it will automatically reload object.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NAMESPACE COLLISION</h2>
        <div class="sectioncontent">
<p>If you use Log::Dispatch::Config in multiple projects on the same perl interpreter (like mod_perl), namespace collision would be a problem. Bizzare thing will happen when you call \*(C`Log::Dispatch::Config-&gt;configure\*(C' multiple times with differenct argument.</p><p>In such cases, what you should do is to define your own logger class.</p><p>  package My::Logger;   use Log::Dispatch::Config;   use base qw(Log::Dispatch::Config);</p><p>Or make wrapper for it. See POE::Component::Logger implementation by Matt Sergeant.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PLUGGABLE CONFIGURATOR</h2>
        <div class="sectioncontent">
<p>If you pass filename to \*(C`configure\*(C' method call, this module handles the config file with AppConfig. You can change config parsing scheme by passing another pluggable configurator object.</p><p>Here is a way to declare new configurator class. The example below is hardwired version equivalent to the one above in \*(L"\s-1CONFIGURATION\s0\*(R".</p><ul>
<li><p>Inherit from Log::Dispatch::Configurator.   package Log::Dispatch::Configurator::Hardwired;   use base qw(Log::Dispatch::Configurator); Declare your own \*(C`new\*(C' constructor. Stub \*(C`new\*(C' method is defined in Configurator base class, but you want to put parsing method in your own constructor. In this example, we just bless reference. Note that your object should be blessed hash.   sub new { bless {}, shift }</p></li><li><p>Implement two required object methods \*(C`get_attrs_global\*(C' and \*(C`get_attrs\*(C'. \*(C`get_attrs_global\*(C' should return hash reference of global parameters. \*(C`dispatchers\*(C' should be an array reference of names of dispatchers.   sub get_attrs_global {       my $self = shift;       return {           format =&gt; undef,           dispatchers =&gt; [ qw(file screen) ],       };   } \*(C`get_attrs\*(C' accepts name of a dispatcher and should return hash reference of parameters associated with the dispatcher.   sub get_attrs {       my($self, $name) = @_;       if ($name eq &apos;file&apos;) {           return {               class     =&gt; &apos;Log::Dispatch::File&apos;,               min_level =&gt; &apos;debug&apos;,               filename  =&gt; &apos;/path/to/log&apos;,               mode      =&gt; &apos;append&apos;,               format  =&gt; &apos;[%d] [%p] %m at %F line %L%n&apos;,           };       }       elsif ($name eq &apos;screen&apos;) {           return {               class     =&gt; &apos;Log::Dispatch::Screen&apos;,               min_level =&gt; &apos;info&apos;,               stderr    =&gt; 1,               format  =&gt; &apos;%m&apos;,           };       }       else {           die "invalid dispatcher name: $name";       }   }</p></li><li><p>Implement optional \*(C`needs_reload\*(C' and \*(C`reload\*(C' methods. \*(C`needs_reload\*(C' should return boolean value if the object is stale and needs reloading itself. This method will be triggered when you configure logging object with \*(C`configure_and_watch\*(C' method. Stub config file mtime based \*(C`needs_reload\*(C' method is declared in Log::Dispatch::Configurator, so if your config class is based on filesystem files, you do not need to reimplement this. If you do not need <em>singleton-ness</em> at all, always return true.   sub needs_reload { 1 } \*(C`reload\*(C' method should redo parsing of the config file. Configurator base class has a stub null \*(C`reload\*(C' method, so you should better override it. See Log::Dispatch::Configurator::AppConfig source code for details.</p></li><li><p>That's all. Now you can plug your own configurator (Hardwired) into Log::Dispatch::Config. What you should do is to pass configurator object to \*(C`configure\*(C' method call instead of config file name.   use Log::Dispatch::Config;   use Log::Dispatch::Configurator::Hardwired;</p><p>  my $config = Log::Dispatch::Configurator::Hardwired-&gt;new;   Log::Dispatch::Config-&gt;configure($config);</p></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CALLER STACK</h2>
        <div class="sectioncontent">
<p>When you call logging method from your subroutines / methods, caller stack would increase and thus you can't see where the log really comes from.</p><p>  package Logger;   my $Logger = Log::Dispatch::Config-&gt;instance;</p><p>  sub logit {       my($class, $level, $msg) = @_;       $Logger-&gt;$level($msg);   }</p><p>  package main;   Logger-&gt;logit(&apos;debug&apos;, &apos;foobar&apos;);</p><p>You can adjust package variable $Log::Dispatch::Config::CallerDepth to increase the caller stack depth. The default value is 0.</p><p>  sub logit {       my($class, $level, $msg) = @_;       local $Log::Dispatch::Config::CallerDepth = 1;       $Logger-&gt;$level($msg);   }</p><p>Note that your log caller's namespace should not match against \*(C`/^Log::Dispatch/\*(C', which makes this module confusing.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Tatsuhiko Miyagawa &lt;miyagawa@bulknews.net&gt; with much help from Matt Sergeant &lt;matt@sergeant.org&gt;.</p><p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Log::Dispatch::Config&hellip;</h2>
        <div class="sectioncontent">
<p>Log::Dispatch::Configurator::AppConfig, Log::Dispatch, AppConfig, POE::Component::Logger</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Log::Any::Test.3pm.html"><span aria-hidden="true">&larr;</span> Log::Any::Test.3pm: Test what you're logging with log::any</a></li>
   <li class="next"><a href="Log::Dispatch::Configurator.3pm.html">Log::Dispatch::Configurator.3pm: Abstract configurator class <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RPC::pServer: Perl extension for writing prpc servers</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Perl extension for writing prpc servers">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="RPC::pServer (3pm) manual">
  <meta name="twitter:description" content="Perl extension for writing prpc servers">
  <meta name="twitter:image" content="https://www.carta.tech/images/libprpc-perl-RPC::pServer-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/RPC::pServer.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="RPC::pServer (3pm) manual" />
  <meta property="og:description" content="Perl extension for writing prpc servers" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libprpc-perl-RPC::pServer-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">RPC::pServer<small> (3pm)</small></h1>
        <p class="lead">Perl extension for writing prpc servers</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/RPC::pServer.3pm.html">
      <span itemprop="name">RPC::pServer: Perl extension for writing prpc servers</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libprpc-perl/">
      <span itemprop="name">libprpc-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/RPC::pServer.3pm.html">
      <span itemprop="name">RPC::pServer: Perl extension for writing prpc servers</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  use RPC::pServer;

  $sock = IO::Socket::INET-&gt;new(&apos;LocalPort&apos; =&gt; 9000,
                                &apos;Proto&apos; =&gt; &apos;tcp&apos;,
                                &apos;Listen&apos; = 5,
                                &apos;Reuse&apos; =&gt; 1);

  $connection = new RPC::pServer(&apos;sock&apos; =&gt; $sock,
                                      &apos;configFile&apos; =&gt; $file,
                                      &apos;funcTable&apos; =&gt; $funcTableRef,
                                      # other attributes #
                                     );

  while ($running) {
      $connection-&gt;Loop();
      if ($connection-&gt;error) {
          # Do something
      }
  }
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>pRPC (Perl \s-1RPC\s0) is a package that simplifies the writing of Perl based client/server applications. RPC::pServer is the package used on the server side, and you guess what Net::pRPC::Client is for. See <em>Net::pRPC::Client</em>\|(3) for this part.</p><p>pRPC works by defining a set of of functions that may be executed by the client. For example, the server might offer a function \*(L"multiply\*(R" to the client. Now a function call</p><p>    @result = $con-&gt;Call(&apos;multiply&apos;, $a, $b);</p><p>on the client will be mapped to a corresponding call</p><p>    multiply($con, $data, $a, $b);</p><p>on the server. (See the <em>funcTable</em> description below for $data.) The function call's result will be returned to the client and stored in the array @result. Simple, eh? :-)</p><h3>Server methods</h3>

<dl class='dl-vertical'>
  <dt>
    new
  </dt>
  <dd>
    <p>The server constructor. Unlike the usual constructors, this one will in general not return immediately, at least not for a server running as a daemon. Instead it will return if a connection is established with a connection object as result. The result will be an error string or the connection object, thus you will typically do a     $con = RPC::pServer-&gt;new ( ...);     if (!ref($con)) {         print "Error $con.&#92;n";     } else {         # Accept connection         ...     }</p>
  </dd>
  <dt>
    Accept
  </dt>
  <dd>
    
  </dd>
  <dt>
    Deny
  </dt>
  <dd>
    <p>After a connection is established, the server should call either of these methods. If he calls <em>Accept()</em>, he should continue with calling the <em>Loop()</em> method for processing the clients requests.</p>
  </dd>
  <dt>
    Loop
  </dt>
  <dd>
    <p>When a connection is established, the Loop method must be called. It will process the client's requests. If <em>Loop()</em> returns \s-1FALSE\s0, an error occurred. It is the main programs task to decide what to do in that case.</p>
  </dd>
  <dt>
    Encrypt
  </dt>
  <dd>
    <p>This method can be used to get or set the <em>cipher</em> attribute, thus the encryption mode. If the method is passed an argument, the argument will be used as the new encryption mode. ('undef' for no encryption.) In either case the current encryption mode will be returned. Example:     # Get the current encryption mode     $mode = $server-&gt;Encrypt();</p><p>    # Currently disable encryption     $server-&gt;Encrypt(undef);</p><p>    # Switch back to the old mode     $server-&gt;Encrypt($mode);</p>
  </dd>

</dl>

<h3>Server attributes</h3>
<p>Server attributes will typically be supplied with the \*(C`new\*(C' constructor.</p>
<dl class='dl-vertical'>
  <dt>
    configFile
  </dt>
  <dd>
    <p>RPC::pServer has a builtin authorization mechanism based on a configuration file. If you want to use this mechanism, just supply the name of a configuration file with the attribute configFile and the server will accept or deny connections based on the configuration file. The authorization scheme is host based, but you may add user based functionality with the user and password attributes. See \*(L"\s-1CONFIGURATION\s0 \s-1FILE\s0\*(R" below.</p>
  </dd>
  <dt>
    client
  </dt>
  <dd>
    <p>This attribute is useful in conjunction with the <em>configFile</em>. If the server has authorized a client by using the config file, he will create a hash ref with all the client attributes and store a reference to this hash under the key <em>client</em>. Thus you can easily extend the configuration file for your own purposes, at least as long as host based configuration is sufficient for you.</p>
  </dd>
  <dt>
    sock
  </dt>
  <dd>
    <p>An object of type IO::Socket, if this program is running as a daemon. An <em>accept()</em> call will be executed on this socket in order to wait for connections. See <em>IO::Socket</em>\|(3). An inetd based server should leave this attribute empty: The method will use \s-1STDIN\s0 and \s-1STDOUT\s0 instead. <strong>Note:</strong> The latter is not yet functionable, I first need to work out how to create an object of type IO::socket for an inetd based server's \s-1STDIN\s0 and \s-1STDOUT\s0. It seems this is currently not supported by IO::Socket.</p>
  </dd>
  <dt>
    cipher
  </dt>
  <dd>
    <p>This attribute can be used to add encryption quite easily. pRPC is not bound to a certain encryption method, but to a block encryption \s-1API\s0. The attribute is an object supporting the methods <em>blocksize</em>, <em>encrypt</em> and <em>decrypt</em>. For example, the modules Crypt::DES and Crypt::IDEA support such an interface. Do <strong>not</strong> modify this attribute directly, use the <em>encrypt</em> method instead!  However, it is legal to pass the attribute to the constructor. Example:     use Crypt::DES;     $crypt = DES-&gt;new(pack("H*", "0123456789abcdef"));     $client-&gt;Encrypt($crypt);</p><p>    # or, to stop encryption     $client-&gt;Encrypt(undef); You might prefer encryption being client dependent, so there is the additional possibility to setup encryption in the server configuration file. See \*(L"\s-1CONFIGURATION\s0 \s-1FILE\s0\*(R". Client encryption definitions take precedence over the <em>cipher</em> attribute. However, you can set or remove encryption on the fly (putting \*(C`undef\*(C' as attribute value will stop encryption), but you have to be sure, that both sides change the encryption mode.</p>
  </dd>
  <dt>
    funcTable
  </dt>
  <dd>
    <p>This attribute is a hash reference. The hash keys are the names of methods, that the client may execute on the server. The hash values are hash references (again). The RPC::pServer module will use the key 'code' only: It contains a code reference to the function performing the clients function call. The first argument of the function call will be the connection object itself, the second will be the 'funcTable' value. You are free to use this hash reference in any way you want, the exception being the 'code' key. The function must return a list: In case of errors the results will be the values 0, followed by a textual error message. In case of success, it ought to return nonzero, followed by the result list being sent to the client.</p>
  </dd>
  <dt>
    stderr
  </dt>
  <dd>
    <p>a value of \s-1TRUE\s0 will enable logging messages to \s-1STDERR\s0, the default is using <em>syslog()</em>; if the stderr attribute is \s-1FALSE\s0, you might call <em>openlog()</em> to configure the application name and facility. See <em>Sys::Syslog</em>\|(3).</p>
  </dd>
  <dt>
    debug
  </dt>
  <dd>
    <p>this will cause the server to log debugging information about client requests using the <em>Log</em> method. A value of 0 disables debugging.</p>
  </dd>
  <dt>
    application
  </dt>
  <dd>
    
  </dd>
  <dt>
    version
  </dt>
  <dd>
    
  </dd>
  <dt>
    user
  </dt>
  <dd>
    
  </dd>
  <dt>
    password
  </dt>
  <dd>
    <p>it is part of the pRPC authorization process, that the client must obeye a login procedure where he will pass an application name, a protocol version and optionally a user name and password. These are not used by pRPC, but when the new method returns with a connection object, the main program may use these for additional authorization. These attributes are read-only.</p>
  </dd>
  <dt>
    io
  </dt>
  <dd>
    <p>this attribute is a Storable object created for communication with the client. You may use this, for example, when you want to change the encryption mode with <em>Storable::Encrypt()</em>. See <em>Storable</em>\|(3).</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONFIGURATION FILE</h2>
        <div class="sectioncontent">
<p>The server configuration file is currently not much more than a collection of client names or ip numbers that should be permitted or denied to connect to the server. Any client is represented by a definition like the following:</p><p>        accept .*&#92;.neckar-alb&#92;.de             encryption    DES             key           063fde7982defabc             encryptModule Crypt::DES</p><p>        deny .*</p><p>In other words a client definition begins with either \*(C`accept pattern\*(C' or \*(C`deny pattern\*(C', followed by some client attributes, each of the attributes being on a separate line, followed by the attribute value. The \*(C`pattern\*(C' is a perl regular expression matching either the clients host name or \s-1IP\s0 number. In particular this means that you have to escape dots, for example a client with \s-1IP\s0 number 194.77.118.1 is represented by the pattern \*(C`194&#92;.77&#92;.118&#92;.1\*(C'.</p><p>Currently known attributes are:</p>
<dl class='dl-vertical'>
  <dt>
    encryption
  </dt>
  <dd>
    
  </dd>
  <dt>
    key
  </dt>
  <dd>
    
  </dd>
  <dt>
    encryptionModule
  </dt>
  <dd>
    <p>These will be used for creating an encryption object which is used for communication with the client, see <em>Storable</em>\|(3) for details. The object is created with a sequence like         use $encryptionModule;         $cipher = $encryption-&gt;new(pack("H*", $key)); <em>encryptionModule</em> defaults to <em>encryption</em>, the reason why we need both is the brain damaged design of the Crypt::IDEA and Crypt::DES modules, which use different module and package names without any obvious reason.</p>
  </dd>

</dl>
<p>You may add any other attribute you want, thus extending your authorization file. The RPC::pServer module will simply ignore them, but your main program will find them in the <em>client</em> attribute of the RPC::pServer object. This can be used for additional client dependent configuration.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PREDEFINED FUNCTIONS</h2>
        <div class="sectioncontent">
<p>RPC::pServer offers some predefined methods which are designed for ease in work with objects. In short they allow creation of objects on the server, passing handles to the client and working with these handles in a fashion similar to the use of the true objects.</p><p>The handle functions need to share some common data, namely a hash array of object handles (keys) and objects (values). The problem is, how to allocate these variables. By keeping a multithreaded environment in mind, we suggest to store the hash on the stack of the server's main loop.</p><p>The handle functions get access to this loop, by looking into the 'handles' attribute of the respective entry in the 'funcTables' hash. See above for a description of the 'funcTables' hash.</p><p>See below for an example of using the handle functions.</p>
<dl class='dl-vertical'>
  <dt>
    NewHandle
  </dt>
  <dd>
    <p>This method can be inserted into the servers function table. The client may call this function to create objects and receive handles to the objects. The corresponding entry in the function table must have a key <em>classes</em>: This is a list reference with class names. The client is restricted to create objects of these classes only. The <em>NewHandle</em> function expects, that the constructor returns an object in case of success or 'undef' otherwise. Note, that this isn't true in all cases, for example the RPC::pServer and Net::pRPC::Client classes behave different. In that cases you have to write your own constructor with a special error handling. The <em>StoreHandle</em> method below will help you. Constructors with a different name than <em>new</em> are another example when you need <em>StoreHandle</em> directly.</p>
  </dd>
  <dt>
    StoreHandle
  </dt>
  <dd>
    <p>After you have created an object on behave of the clients request, you'd like to store it for later use. This is what <em>StoreHandle</em> does for you. It returns an object handle which may be passed back to the client. The client can pass the objects back to the server for use in <em>CallMethod</em> or <em>UseHandle</em>.</p>
  </dd>
  <dt>
    NewHandle
  </dt>
  <dd>
    <p>The <em>NewHandle</em> is mainly a wrapper for <em>StoreHandle</em>. It creates an object of the given class, passes it to <em>StoreHandle</em> and returns the result. The <em>NewHandle</em> method is designed for direct use within the servers function table.</p>
  </dd>
  <dt>
    UseHandle
  </dt>
  <dd>
    <p>This is the counterpart of <em>StoreHandle</em>: It gets an object handle, passed by the client, as argument and returns the corresponding object, if any. An 'undef' value will be returned for an invalid handle.</p>
  </dd>
  <dt>
    CallMethod
  </dt>
  <dd>
    <p>This function receives an object handle as argument and the name of a method being executed. The method will be invoked on the corresponding object and the result will be returned. A special method is '\s-1DESTROY\s0', valid for any object handle. It disposes the object, the handle becomes invalid.</p>
  </dd>

</dl>
<p>All handle functions are demonstrated in the following example.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLE</h2>
        <div class="sectioncontent">
<p>Enough wasted time, spread the example, not the word. :-) Let's write a simple server, say a spreadsheet server. Of course we are not interested in the details of the spreadsheet part (which could well be implemented in a separate program), the spreadsheet example is chosen, because it is obvious, that such a server is dealing with complex data structures. For example, a \*(L"sum\*(R" method should be able to add over complete rows, columns or even rectangular regions of the spreadsheet. And another thing, obviously a spread- sheet could easily be represented by perl data structures: The spreadsheet itself could be a list of lists, the elements of the latter lists being hash references, each describing one column. You see, such a spreadsheet is an ideal object for the <em>Storable</em>\|(3) class. But now, for something completely different:</p><p>    #!/usr/local/bin/perl -wT # Note the -T switch! I mean it!     use 5.0004;               # Yes, this really *is* required.     use strict;               # Always a good choice.</p><p>    use IO::Socket();     use RPC::pServer;</p><p>    # Constants     $MY_APPLICATION = "Test Application";     $MY_VERSION = 1.0;</p><p>    # Functions that the clients may execute; for simplicity     # these aren&apos;t designed in an object oriented manner.</p><p>    # Function returning a simple scalar     sub sum ($$$$$) {         my($con, $data, $spreadsheet, $from, $to) = @_;         # Example: $from = A3, $to = B5         my($sum) = SpreadSheet::Sum($spreadsheet, $from, $to);         return (1, $sum);     }</p><p>    # Function returning another spreadsheet, thus a complex object     sub double ($$$$$) {         my($con, $data, $spreadsheet, $from, $to);         # Doubles the region given by $from and $to, returns         # a spreadsheet         my($newSheet) = SpreadSheet::Double($spreadsheet, $from, $to);         (1, $newSheet);     }</p><p>    # Quit function; showing the use of $data     sub quit ($$) {         my($con, $data) = @_;         $$data = 0;   # Tell the server&apos;s Loop() method, that we                       # are done.         (1, "Bye!");     }</p><p>    # Now we give the handle functions a try. First of all, a     # spreadsheet constructor:     sub spreadsheet ($$$$) {         my ($con, $data, $rows, $cols) = @_;         my ($sheet, $handle);         if (!defined($sheet = SpreadSheet::Empty($rows, $cols))) {             $con-&gt;error = "Cannot create spreadsheet";             return (0, $con-&gt;error);         }         if (!defined($handle = StoreHandle($con, $data, $sheet))) {             return (0, $con-&gt;error); # StoreHandle stored error message         }         (1, $handle);     }</p><p>    # Now a similar function to "double", except that a spreadsheet     # is doubled, which is stored locally on the server and not     # remotely on the client     sub rdouble ($$$$$) {         my($con, $data, $sHandle, $from, $to);         my($spreadsheet) = UseHandle($con, $data, $sHandle);         if (!defined($spreadsheet)) {             return (0, $con-&gt;error); # UseHandle stored an error message         }         # Doubles the region given by $from and $to, returns         # a spreadsheet         my($newSheet) = SpreadSheet::Double($spreadsheet, $from, $to);         my($handle);         if (!defined($handle = StoreHandle($con, $data, $newSheet))) {             return (0, $con-&gt;error); # StoreHandle stored error message         }         (1, $newSheet);     }</p><p>    # This function is called for any valid connection to a client     # In a loop it processes the clients requests.     #     # Note, that we are using local data only, thus we should be     # safe in a multithreaded environment. (Of course, noone knows     # about the spreadsheet functions ... ;-)     sub Server ($) {         my($con) = shift;         my($con, $configFile, %funcTable);         my($running) = 1;         my(%handles) = (); # Note: handle hash is on the local stack</p><p>        # First, create the servers function table. Note the         # references to the handle hash in entries that access         # the handle functions.         %funcTable = {             &apos;sum&apos;         =&gt; { &apos;code&apos; =&gt; &sum },             &apos;double&apos;      =&gt; { &apos;code&apos; =&gt; &list },             &apos;quit&apos;        =&gt; { &apos;code&apos; =&gt; &quit,                                &apos;data&apos; = &#92;$running }             &apos;spreadsheet&apos; =&gt; { &apos;code&apos; =&gt; &#92;&spreadsheet,                                &apos;handles&apos; =&gt; &#92;%handles },             &apos;rdouble&apos;     =&gt; { &apos;code&apos; =&gt; &#92;&rdouble,                                &apos;handles&apos; = &#92;%handles },</p><p>            # An alternative to the &apos;spreadsheet&apos; entry above;             &apos;NewHandle&apos;   =&gt; { &apos;code&apos; =&gt; &#92;&RPC::pServer::NewHandle,                                &apos;handles&apos; =&gt; &#92;%handles,                                &apos;classes&apos; =&gt; [ &apos;Spreadsheet&apos; ] },</p><p>            # Give client access to *all* (!) spreadsheet methods             &apos;CallMethod&apos;  =&gt; { &apos;code&apos; =&gt; &#92;&RPC::pServer::CallMethod,                                &apos;handles&apos; =&gt; &#92;%handles }         };</p><p>        $con-&gt;{&apos;funcTable&apos;} = &#92;%funcTable;</p><p>        while($running) {             if (!$con-&gt;Loop()) {                 $con-&gt;Log(&apos;err&apos;, "Exiting.&#92;n"); # Error already logged                 exit 10;             }         }         $con-&gt;Log(&apos;notice&apos;, "Client quits.&#92;n");         exit 0;     }</p><p>    # Avoid Zombie ball ...     sub childGone { my $pid = wait; $SIG{CHLD} = &#92;&childGone; }</p><p>    # Now for main     {         my ($iAmDaemon, $sock);</p><p>        # Process command line arguments ...         ...</p><p>        # If running as daemon: Create a socket object.         if ($iAmDaemon) {             $sock = IO::Socket-&gt;new(&apos;Proto&apos; =&gt; &apos;tcp&apos;,                                     &apos;Listen&apos; =&gt; SOMAXCONN,                                     &apos;LocalPort&apos; =&gt; &apos;wellKnownPort(42)&apos;,                                     &apos;LocalAddr&apos; =&gt; Socket::INADDR_ANY                                    );         } else {             $sock = undef; # Let RPC::pServer create a sock object         }</p><p>        while (1) {             # Wait for a client establishing a connection             my $con = RPC::pServer(&apos;sock&apos; =&gt; $sock,                                    &apos;configFile&apos; =&gt; &apos;testapp.conf&apos;);             if (!ref($con)) {                 print STDERR "Cannot create server: $con&#92;n";             } else {                 if ($con-&gt;{&apos;application&apos;} ne $MY_APPLICATION) {                     # Whatever this client wants to connect to:                     # It&apos;s not us :-)                     $con-&gt;Deny("This is a $MY_APPLICATION server. Go away");                 } elsif ($con-&gt;{&apos;version&apos;} &gt; $MY_VERSION) {                     # We are running an old version of the protocol :-(                     $con-&gt;Deny("Sorry, but this is version $MY_VERSION");                 } elsif (!IsAuthorizedUser($con-&gt;{&apos;user&apos;},                                            $con-&gt;{&apos;password&apos;})) {                     $con-&gt;Deny("Access denied");                 } else {                     # Ok, we accept the client. Spawn a child and let                     # the child do anything else.                     my $pid = fork();                     if (!defined($pid)) {                         $con-&gt;Deny("Cannot fork: $!");                     } elsif ($pid == 0) {                         # I am the child                         $con-&gt;Accept("Welcome to the pleasure dome ...");                         Server();                     }                 }             }         }     }</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SECURITY</h2>
        <div class="sectioncontent">
<p>It has to be said: pRPC based servers are a potential security problem! I did my best to avoid security problems, but it is more than likely, that I missed something. Security was a design goal, but not *the* design goal. (A well known problem ...)</p><p>I highly recommend the following design principles:</p>
<dl class='dl-vertical'>
  <dt>
    perlsec
  </dt>
  <dd>
    <p>Read the perl security \s-1FAQ\s0 (\*(C`perldoc perlsec\*(C') and use the \*(C`-T\*(C' switch.</p>
  </dd>
  <dt>
    taintperl
  </dt>
  <dd>
    <p><strong>Use</strong> the \*(C`-T\*(C' switch. I mean it!</p>
  </dd>
  <dt>
    Verify data
  </dt>
  <dd>
    <p>Never untaint strings withouth verification, better verify twice. For example the <em>CallMethod</em> function first checks, whether an object handle is in a a proper format (currently integer numbers, but don't rely on that, it could change). If it is, then it will still be verified, that an object with the given handle exists.</p>
  </dd>
  <dt>
    Be restrictive
  </dt>
  <dd>
    <p>Think twice, before you give a client access to a function. In particular, think twice, before you give a client access to objects via the handle methods: If a client can coerce <em>CallMethod()</em> on an object, he has access to *all* methods of that object!</p>
  </dd>
  <dt>
    perlsec
  </dt>
  <dd>
    <p>And just in case I forgot it: Read the \*(C`perlsec\*(C' man page. :-)</p>
  </dd>

</dl>
<h3>Protection against untrusted users</h3>

<dl class='dl-vertical'>
  <dt>
    Host based authorization
  </dt>
  <dd>
    <p>pRPC has a builtin host based authorization scheme; use it! See \*(L"\s-1CONFIGURATION\s0 \s-1FILE\s0\*(R".</p>
  </dd>
  <dt>
    User based authorization
  </dt>
  <dd>
    <p>pRPC has no builtin user based authorization scheme; that doesn't mean, that you should not implement one.</p>
  </dd>
  <dt>
    Encryption
  </dt>
  <dd>
    <p>Using encryption with pRPC is extremely easy. There is absolutely no reason for communicating unencrypted with the clients. Even more: I recommend two phase encryption: The first phase is the login phase, where to use a host based key. As soon as the user has authorized, you should switch to a user based key. See the DBD::pNET agent for an example.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Jochen Wiedmann, wiedmann@neckar-alb.de</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO RPC::pServer&hellip;</h2>
        <div class="sectioncontent">
<p><em>Net::pRPC::Client</em>\|(3), <em>Storable</em>\|(3), <em>Sys::Syslog</em>\|(3)</p><p>See <em>DBD::pNET</em>\|(3) for an example application.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="RPC::pClient.3pm.html"><span aria-hidden="true">&larr;</span> RPC::pClient.3pm: Perl extension for writing prpc clients</a></li>
   <li class="next"><a href="RRD::Simple.3pm.html">RRD::Simple.3pm: Simple interface to create and store data in rrd files <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

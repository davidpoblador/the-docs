<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>AnyData: Easy access to data in many formats</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Easy access to data in many formats">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="AnyData (3pm) manual">
  <meta name="twitter:description" content="Easy access to data in many formats">
  <meta name="twitter:image" content="https://www.carta.tech/images/libanydata-perl-AnyData-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/AnyData.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="AnyData (3pm) manual" />
  <meta property="og:description" content="Easy access to data in many formats" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libanydata-perl-AnyData-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">AnyData<small> (3pm)</small></h1>
        <p class="lead">Easy access to data in many formats</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/AnyData.3pm.html">
      <span itemprop="name">AnyData: Easy access to data in many formats</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libanydata-perl/">
      <span itemprop="name">libanydata-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/AnyData.3pm.html">
      <span itemprop="name">AnyData: Easy access to data in many formats</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
 use AnyData;
 my $table = adTie( &apos;CSV&apos;,&apos;my_db.csv&apos;,&apos;o&apos;,            # create a table
                 {col_names=&gt;&apos;name,country,sex&apos;}
               );
 $table-&gt;{Sue} = {country=&gt;&apos;de&apos;,sex=&gt;&apos;f&apos;};         # insert a row
 delete $table-&gt;{Tom};                             # delete a single row
 $str  = $table-&gt;{Sue}-&gt;{country};                 # select a single value
 while ( my $row = each %$table ) {                # loop through table
   print $row-&gt;{name} if $row-&gt;{sex} eq &apos;f&apos;;
 }
 $rows = $table-&gt;{{age=&gt;&apos;&gt; 25&apos;}};                  # select multiple rows
 delete $table-&gt;{{country=&gt;qr/us|mx|ca/}};         # delete multiple rows
 $table-&gt;{{country=&gt;&apos;Nz&apos;}}={country=&gt;&apos;nz&apos;};        # update multiple rows
 my $num = adRows( $table, age=&gt;&apos;&lt; 25&apos; );          # count matching rows
 my @names = adNames( $table );                    # get column names
 my @cars = adColumn( $table, &apos;cars&apos; );            # group a column
 my @formats = adFormats();                        # list available parsers
 adExport( $table, $format, $file, $flags );       # save in specified format
 print adExport( $table, $format, $flags );        # print to screen in format
 print adDump($table);                             # dump table to screen
 undef $table;                                     # close the table

 #adConvert( $format1, $file1, $format2, $file2 );  # convert btwn formats
 #print adConvert( $format1, $file1, $format2 );    # convert to screen
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The rather wacky idea behind this module and its sister module DBD::AnyData is that any data, regardless of source or format should be accessible and modifiable with the same simple set of methods. This module provides a multidimensional tied hash interface to data in a dozen different formats. The DBD::AnyData module adds a \s-1DBI/SQL\s0 interface for those same formats.</p><p>Both modules provide built-in protections including appropriate <em>flocking()</em> for all I/O and (in most cases) record-at-a-time access to files rather than slurping of entire files.</p><p>Currently supported formats include general format flat files (\s-1CSV\s0, Fixed Length, etc.), specific formats (passwd files, httpd logs, etc.), and a variety of other kinds of formats (\s-1XML\s0, Mp3, \s-1HTML\s0 tables).  The number of supported formats will continue to grow rapidly since there is an open \s-1API\s0 making it easy for any author to create additional format parsers which can be plugged in to AnyData itself and thereby be accessible by either the tiedhash or \s-1DBI/SQL\s0 interface.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PREREQUISITES</h2>
        <div class="sectioncontent">
<p>The AnyData.pm module itself is pure Perl and does not depend on anything other than modules that come standard with Perl.  Some formats and some advanced features require additional modules: to use the remote ftp/http features, you must have the \s-1LWP\s0 bundle installed; to use the \s-1XML\s0 format, you must have XML::Parser and XML::Twig installed; to use the HTMLtable format for reading, you must have HTML::Parser and HTML::TableExtract installed but you can use the HTMLtable for writing with just the standard \s-1CGI\s0 module.  To use \s-1DBI/SQL\s0 commands, you must have \s-1DBI\s0, DBD::AnyData, SQL::Statement and DBD::File installed.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">USAGE</h2>
        <div class="sectioncontent">
<p>The AnyData module imports eight methods (functions):</p><p>  adTie()     -- create a new table or open an existing table   adExport()  -- save an existing table in a specified format   adConvert() -- convert data in one format into another format   adFormats() -- list available formats   adNames()   -- get the column names of a table   adRows()    -- get the number of rows in a table or query   adDump()    -- display the data formatted as an array of rows   adColumn()  -- group values in a single column</p><p>The <em>adTie()</em> command returns a special tied hash.  The tied hash can then be used to access and/or modify data.  See below for details</p><p>With the exception of the \s-1XML\s0, HTMLtable, and \s-1ARRAY\s0 formats, the <em>adTie()</em> command saves all modifications of the data directly to file as they are made.  With \s-1XML\s0 and HTMLtable, you must make your modifications in memory and then explicitly save them to file with <em>adExport()</em>.</p><h3>\fIadTie()\fP</h3>
<p> my $table = adTie( $format, $data, $open_mode, $flags );</p><p>The <em>adTie()</em> command creates a reference to a multidimensional tied hash. In its simplest form, it simply reads a file in a specified format into the tied hash:</p><p> my $table = adTie( $format, $file );</p><p>$format is the name of any supported format '\s-1CSV\s0','Fixed','Passwd', etc. $file is the name of a relative or absolute path to a local file</p><p>e.g.</p>
<pre>
     my $table = adTie( '\s-1CSV\s0', '/usr/me/myfile.csv' );
</pre>
<p>this creates a tied hash called $table by reading data in the \s-1CSV\s0 (comma separated values) format from the file 'myfile.csv'.</p><p>The hash reference resulting from <em>adTie()</em> can be accessed and modified as follows:</p><p> use AnyData;  my $table = adTie( $format, $file );  $table-&gt;{$key}-&gt;{$column};                       # select a value  $table-&gt;{$key} = {$col1=&gt;$val1,$col2=&gt;$val2...}; # update a row  delete $table-&gt;{$key};                           # delete a row  while(my $row = each %$table) {                  # loop through rows    print $row-&gt;{$col1} if $row-&gt;{$col2} ne &apos;baz&apos;;  }</p><p>The thing returned by adTie ($table in the example) is not an object, it is a reference to a tied hash. This means that hash operations such as exists, values, keys, may be used, keeping in mind that this is a *reference* to a tied hash so the syntax would be</p><p>    for( keys %$table ) {...}     for( values %$table ) {...}</p><p>Also keep in mind that if the table is really large, you probably do not want to use keys and values because they create arrays in memory containing data from every row in the table.  Instead use 'each' as shown above since that cycles through the file one record at a time and never puts the entire table into memory.</p><p>It is also possible to use more advanced searching on the hash, see \*(L"Multiple Row Operations\*(R" below.</p><p>In addition to the simple adTie($format,$file), there are other ways to specify additional information in the <em>adTie()</em> command.  The full syntax is:</p><p> my $table = adTie( $format, $data, $open_mode, $flags );</p><p> The $data parameter allows you to read data from remote files accessible by  http or ftp, see "Using Remote Files" below.  It also allows you to treat  strings and arrays as data sources without needing a file at all, see  "Working with Strings and Arrays" below.</p><p>The optional $mode parameter defaults to 'r' if none is supplied or must be one of</p><p> &apos;r&apos; read      # read only access  &apos;u&apos; update    # read/write access  &apos;c&apos; create    # create a new file unless it already exists  &apos;o&apos; overwrite # create a new file, overwriting any that already exist</p><p>The $flags parameter allows you to specify additional information such as column names.  See the sections in \*(L"Further Details\*(R" below.</p><p>With the exception of the \s-1XML\s0, HTMLtable, and \s-1ARRAY\s0 formats, the <em>adTie()</em> command saves all modifications of the data directly to file as they are made.  With \s-1XML\s0 and HTMLtable, you must make your modifications in memory and then explicitly save them to file with <em>adExport()</em>.</p>
<h3>\fIadConvert()\fP</h3>
<p> adConvert( $format1, $data1, $format2, $file2, $flags1, $flags2 );</p><p> or</p><p> print adConvert( $format1, $data1, $format2, undef, $flags1, $flags2 );</p><p> or</p><p> my $aryref = adConvert( $format1, $data1, &apos;ARRAY&apos;, undef, $flags1 );</p><p> This method converts data in any supported format into any other supported  format.  The resulting data may either be saved to a file (if $file2 is  supplied as a parameter) or sent back as  a string to e.g. print the data  to the screen in the new format (if no $file2 is supplied), or sent back  as an array reference if $format2 is &apos;ARRAY&apos;.</p><p> Some examples:</p><p>   # convert a CSV file into an XML file    #    adConvert(&apos;CSV&apos;,&apos;foo.csv&apos;,&apos;XML&apos;,&apos;foo.xml&apos;);</p><p>   # convert a CSV file into an HTML table and print it to the screen    #    print adConvert(&apos;CSV&apos;,&apos;foo.csv&apos;,&apos;HTMLtable&apos;);</p><p>   # convert an XML string into a CSV file    #    adConvert(&apos;XML&apos;, ["&lt;x&gt;&lt;motto id=&apos;perl&apos;&gt;TIMTOWTDI&lt;/motto&gt;&lt;/x&gt;"],              &apos;CSV&apos;,&apos;foo.csv&apos;             );</p><p>   # convert an array reference into an XML file    #    adConvert(&apos;ARRAY&apos;, [[&apos;id&apos;,&apos;motto&apos;],[&apos;perl&apos;,&apos;TIMTOWTDI&apos;]],              &apos;XML&apos;,&apos;foo.xml&apos;             );</p><p>   # convert an XML file into an array reference    #    my $aryref = adConvert(&apos;XML&apos;,&apos;foo.xml&apos;,&apos;ARRAY&apos;);</p><p> See section below "Using strings and arrays" for details.</p>
<h3>\fIadExport()\fP</h3>
<p> adExport( $table, $format, $file, $flags );</p><p> or</p><p> print adExport( $table, $format );</p><p> or</p><p> my $aryref = adExport( $table, &apos;ARRAY&apos; );</p><p> This method converts an existing tied hash into another format and/or  saves the tied hash as a file in the specified format.</p><p> Some examples:</p><p>   all assume a previous call to my $table= adTie(...);</p><p>   # export table to an XML file    #    adExport($table&apos;,&apos;XML&apos;,&apos;foo.xml&apos;);</p><p>   # export table to an HTML string and print it to the screen    #    print adExport($table,&apos;HTMLtable&apos;);</p><p>   # export the table to an array reference    #    my $aryref = adExport($table,&apos;ARRAY&apos;);</p><p> See section below "Using strings and arrays" for details.</p>
<h3>\fIadNames()\fP</h3>
<p> my $table = adTie(...);  my @column_names = adNames($table);</p><p>This method returns an array of the column names for the specified table.</p>
<h3>\fIadRows()\fP</h3>
<p> my $table = adTie(...);  adRows( $table, %search_hash );</p><p>This method takes an AnyData tied hash created with <em>adTie()</em> and counts the rows in the table that match the search hash.</p><p>For example, this snippet returns a count of the rows in the file that contain the specified page in the request column</p><p>  my $hits = adTie( &apos;Weblog&apos;, &apos;access.log&apos;);   print adRows( $hits , request =&gt; &apos;mypage.html&apos; );</p><p>The search hash may contain multiple search criteria, see the section on multiple row operations below.</p><p>If the search_hash is omitted, it returns a count of all rows.</p>
<h3>\fIadColumn()\fP</h3>
<p> my @col_vals = adColumn( $table, $column_name, $distinct_flag );</p><p>This method returns an array of values taken from the specified column. If there is a distinct_flag parameter, duplicates will be eliminated from the list.</p><p>For example, this snippet returns a unique list of the values in the 'player' column of the table.</p><p>  my $game = adTie( &apos;Pipe&apos;,&apos;games.db&apos; );   my @players  = adColumn( $game, &apos;player&apos;, 1 );</p>
<h3>\fIadDump()\fP</h3>
<p>  my $table = adTie(...);   print adDump($table);</p><p>This method prints the raw data in the table.  Column names are printed inside angle brackets and separated by colons on the first line, then each row is printed as a list of values inside square brackets.</p>
<h3>\fIadFormats()\fP</h3>
<p>  print "$_&#92;n for adFormats();</p><p>This method shows the available format parsers, e.g. '\s-1CSV\s0', '\s-1XML\s0', etc.  It looks in your @INC for the .../AnyData/Format directory and prints the names of format parsing files there.  If the parser requires further modules (e.g. \s-1XML\s0 requires XML::Parser) and you do not have the additional modules installed, the format will not work even if listed by this command.  Otherwise, all formats should work as described in this documentation.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FURTHER DETAILS</h2>
        <div class="sectioncontent">
<h3>Column Names</h3>
<p>Column names may be assigned in three ways:</p><p> * pre  -- The format parser preassigns column            names (e.g. Passwd files automatically have            columns named &apos;username&apos;, &apos;homedir&apos;, &apos;GID&apos;, etc.).</p><p> * user -- The user specifies the column names as a comma            separated string associated with the key &apos;cols&apos;:</p><p>           my $table = adTie( $format,                               $file,                               $mode,                               {cols=&gt;&apos;name,age,gender&apos;}                             );</p><p> * auto -- If there is no preassigned list of column names            and none defined by the user, the first line of            the file is treated as a list of column names;            the line is parsed according to the specific            format (e.g. CSV column names are a comma-separated            list, Tab column names are a tab separated list);</p><p>When creating a new file in a format that does not preassign column names, the user *must* manually assign them as shown above.</p><p>Some formats have special rules for assigning column names (\s-1XML\s0,Fixed,HTMLtable), see the sections below on those formats.</p>
<h3>Key Columns</h3>
<p>The AnyData modules support tables that have a single key column that uniquely identifies each row as well as tables that do not have such keys.  For tables where there is a unique key, that key may be assigned in three ways:</p><p> * pre --  The format parser automatically preassigns the            key column name e.g. Passwd files automatically            have &apos;username&apos; as the key column.</p><p> * user -- The user specifies the key column name:</p><p>           my $table = adTie( $format,                               $file,                               $mode,                               {key=&gt;&apos;country&apos;}                             );</p><p> * auto    If there is no preassigned key column and the user            does not define one, the first column becomes the            default key column</p>
<h3>Format Specific Details</h3>
<p> For full details, see the documentation for AnyData::Format::Foo  where Foo is any of the formats listed in the adFormats() command  e.g. &apos;CSV&apos;, &apos;XML&apos;, etc.</p><p> Included below are only some of the more important details of the  specific parsers.</p>
<dl class='dl-vertical'>
  <dt>
    Fixed Format
  </dt>
  <dd>
    <p>When using the Fixed format for fixed length records you must always specify a pattern indicating the lengths of the fields. This should be a string as would be passed to the <em>unpack()</em> function to unpack the records in your Fixed length definition:  my $t = adTie( &apos;Fixed&apos;, $file, &apos;r&apos;, {pattern=&gt;&apos;A3 A7 A9&apos;} ); If you want the column names to appear on the first line of a Fixed file, they should be in comma-separated format, not in Fixed format. This is different from other formats which use their own format to display the column names on the first line.  This is necessary because the name of the column might be longer than the length of the column.</p>
  </dd>
  <dt>
    \s-1XML\s0 Format
  </dt>
  <dd>
    <p> The XML format does not allow you to specify column names as a flag,  rather you specify a "record_tag" and the column names are determined  from the contents of the tag.  If no record_tag is specified, the  record tag will be assumed to be the first child of the root of the  XML tree.  That child and its structure will be determined from the  DTD if there is one, or from the first occurring record if there is  no DTD. For simple \s-1XML\s0, no flags are necessary:  &lt;table&gt;     &lt;row row_id="1"&gt;&lt;name&gt;Joe&lt;/name&gt;&lt;location&gt;Seattle&lt;/location&gt;&lt;/row&gt;     &lt;row row_id="2"&gt;&lt;name&gt;Sue&lt;/name&gt;&lt;location&gt;Portland&lt;/location&gt;&lt;/row&gt;  &lt;/table&gt; The record_tag will default to the first child, namely \*(L"row\*(R".  The column names will be generated from the attributes of the record tag and all of the tags included under the record tag, so the column names in this example will be \*(L"row_id\*(R",\*(L"name\*(R",\*(L"location\*(R". If the record_tag is not the first child, you will need to specify it.  For example:  &lt;db&gt;    &lt;table table_id="1"&gt;      &lt;row row_id="1"&gt;&lt;name&gt;Joe&lt;/name&gt;&lt;location&gt;Seattle&lt;/location&gt;&lt;/row&gt;      &lt;row row_id="2"&gt;&lt;name&gt;Sue&lt;/name&gt;&lt;location&gt;Portland&lt;/location&gt;&lt;/row&gt;    &lt;/table&gt;    &lt;table table_id="2"&gt;      &lt;row row_id="1"&gt;&lt;name&gt;Bob&lt;/name&gt;&lt;location&gt;Boise&lt;/location&gt;&lt;/row&gt;      &lt;row row_id="2"&gt;&lt;name&gt;Bev&lt;/name&gt;&lt;location&gt;Billings&lt;/location&gt;&lt;/row&gt;    &lt;/table&gt;  &lt;/db&gt; In this case you will need to specify \*(L"row\*(R" as the record_tag since it is not the first child of the tree.  The column names will be generated from the attributes of row's parent (if the parent is not the root), from row's attributes and sub tags, i.e. \*(L"table_id\*(R",\*(L"row_id\*(R",\*(L"name\*(R",\*(L"location\*(R". When exporting \s-1XML\s0, you can specify a \s-1DTD\s0 to control the output.  For example, if you import a table from \s-1CSV\s0 or from an Array, you can output as \s-1XML\s0 and specify which of the columns become tags and which become attributes and also specify the nesting of the tags in your \s-1DTD\s0. The \s-1XML\s0 format parser is built on top of Michel Rodriguez's excellent XML::Twig which is itself based on XML::Parser.  Parameters to either of those modules may be passed in the flags for <em>adTie()</em> and the other commands including the \*(L"prettyPrint\*(R" flag to specify how the output \s-1XML\s0 is displayed and things like ProtocolEncoding.  ProtocolEncoding defaults to '\s-1ISO-8859-1\s0', all other flags keep the defaults of XML::Twig and XML::Parser.  See the documentation of those modules for details;  CAUTION: Unlike other formats, the XML format does not save changes to  the file as they are entered, but only saves the changes when you explicitly  request them to be saved with the adExport() command.</p>
  </dd>
  <dt>
    HTMLtable Format
  </dt>
  <dd>
    <p> This format is based on Matt Sisk&apos;s excelletn HTML::TableExtract.</p><p> It can be used to read an existing table from an html page, or to  create a new HTML table from any data source.</p><p> You may control which table in an HTML page is used with the column_names,  depth and count flags.</p><p> If a column_names flag is passed, the first table that contains those names  as the cells in a row will be selected.</p><p> If depth and or count parameters are passed, it will look for tables as  specified in the HTML::TableExtract documentation.</p><p> If none of column_names, depth, or count flags are passed, the first table  encountered in the file will be the table selected and its first row will  be used to determine the column names for the table.</p><p> When exporting to an HTMLtable, you may pass flags to specify properties  of the whole table (table_flags), the top row containing the column names  (top_row_flags), and the data rows (data_row_flags).  These flags follow  the syntax of CGI.pm table constructors, e.g.:</p><p> print adExport( $table, &apos;HTMLtable&apos;, {      table_flags    =&gt; {Border=&gt;3,bgColor=&gt;&apos;blue&apos;};      top_row_flags  =&gt; {bgColor=&gt;&apos;red&apos;};      data_row_flags =&gt; {valign=&apos;top&apos;};  });</p><p> The table_flags will default to {Border=&gt;1,bgColor=&gt;&apos;white&apos;} if none  are specified.</p><p> The top_row_flags will default to {bgColor=&gt;&apos;#c0c0c0&apos;} if none are  specified;</p><p> The data_row_flags will be empty if none are specified.</p><p> In other words, if no flags are specified the table will print out with  a border of 1, the column headings in gray, and the data rows in white.</p><p> CAUTION: This module will *not* preserve anything in the html file except  the selected table so if your file contains more than the selected table,  you will want to use adTie() to read the table and then adExport() to write  the table to a different file.  When using the HTMLtable format, this is the  only way to preserve changes to the data, the adTie() command will *not*  write to a file.</p>
  </dd>

</dl>

<h3>Multiple Row Operations</h3>
<p>The AnyData hash returned by <em>adTie()</em> may use either single values as keys, or a reference to a hash of comparisons as a key.  If the key to the hash is a single value, the hash operates on a single row but if the key to the hash is itself a hash reference, the hash operates on a group of rows.</p><p> my $num_deleted = delete $table-&gt;{Sue};</p><p>This example deletes a single row where the key column has the value 'Sue'.  If multiple rows have the value 'Sue' in that column, only the first is deleted.  It uses a simple string as a key, therefore it operates on only a single row.</p><p> my $num_deleted = delete $table-&gt;{ {name=&gt;&apos;Sue&apos;} };</p><p>This example deletes all rows where the column 'name' is equal to 'Sue'.  It uses a hashref as a key and therefore operates on multiple rows.</p><p>The hashref used in this example is a single column comparison but the hashref could also include multiple column comparisons.  This deletes all rows where the the values listed for the country, gender, and age columns are equal to those specified:</p><p>  my $num_deleted = delete $table-&gt;{{ country =&gt; &apos;us&apos;,                                        gender =&gt; &apos;m&apos;,                                           age =&gt; &apos;25&apos;                                    }}</p><p>In addition to simple strings, the values may be specified as regular expressions or as numeric or alphabetic comparisons.  This will delete all North American males under the age of 25:</p><p>  my $num_deleted = delete $table-&gt;{{ country =&gt; qr/mx|us|ca/,                                       gender  =&gt; &apos;m&apos;,                                       age     =&gt; &apos;&lt; 25&apos;                                    }}</p><p>If numeric or alphabetic comparisons are used, they should be a string with the comparison operator separated from the value by a space, e.g. '&gt; 4' or 'lt b'.</p><p>This kind of search hashref can be used not only to delete multiple rows, but also to update rows.  In fact you *must* use a hashref key in order to update your table.  Updating is the only operation that can not be done with a single string key.</p><p>The search hashref can be used with a select statement, in which case it returns a reference to an array of rows matching the criteria:</p><p> my $male_players = $table-&gt;{{gender=&gt;&apos;m&apos;}};  for my $player( @$male_players ) { print $player-&gt;{name},"&#92;n" }</p><p>This should be used with caution with a large table since it gathers all of the selected rows into an array in memory.  Again, 'each' is a much better way for large tables.  This accomplishes the same thing as the example above, but without ever pulling more than a row into memory at a time:</p><p> while( my $row= each %$table ) {    print $row-&gt;{name}, "&#92;n" if $row-&gt;{gender}=&gt;&apos;m&apos;;  }</p><p>Search criteria for multiple rows can also be used with the <em>adRows()</em> function:</p><p>  my $num_of_women = adRows( $table, gender =&gt; &apos;w&apos; );</p><p>That does *not* pull the entire table into memory, it counts the rows a record at a time.</p>
<h3>Using Remote Files</h3>
<p>If the first file parameter of <em>adTie()</em> or <em>adConvert()</em> begins with \*(L"http://\*(R" or \*(L"ftp://\*(R", the file is treated as a remote \s-1URL\s0 and the \s-1LWP\s0 module is called behind the scenes to fetch the file.  If the files are in an area that requires authentication, that may be supplied in the $flags parameter.</p><p>For example:</p><p>  # read a remote file and access it via a tied hash   #   my $table = adTie( &apos;XML&apos;, &apos;http://www.foo.edu/bar.xml&apos; );</p><p>  # same with username/password   #   my $table = ( &apos;XML&apos;, &apos;ftp://www.foo.edu/pub/bar.xml&apos;, &apos;r&apos;                 { user =&gt; &apos;me&apos;, pass =&gt; &apos;x7dy4&apos;               );</p><p>  # read a remote file, convert it to an HTML table, and print it   #   print adConvert( &apos;XML&apos;, &apos;ftp://www.foo.edu/pub/bar.xml&apos;, &apos;HTMLtable&apos; );</p>
<h3>Using Strings and Arrays</h3>
<p>Strings and arrays may be used as either the source of data input or as the target of data output.  Strings should be passed as the only element of an array reference (in other words, inside square brackets).  Arrays should be a reference to an array whose first element is a reference to an array of column names and whose succeeding elements are references to arrays of row values.</p><p>For example:</p><p>  my $table = adTie( &apos;XML&apos;, ["&lt;x&gt;&lt;motto id=&apos;perl&apos;&gt;TIMTOWTDI&lt;/motto&gt;&lt;/x&gt;"] );</p><p>  This uses the XML format to parse the supplied string and returns a tied   hash to the resulting table.</p><p>  my $table = adTie( &apos;ARRAY&apos;, [[&apos;id&apos;,&apos;motto&apos;],[&apos;perl&apos;,&apos;TIMTOWTDI&apos;]] );</p><p>  This uses the column names "id" and "motto" and the supplied row values   and returns a tied hash to the resulting table.</p><p>It is also possible to use an empty array to create a new empty tied hash in any format, for example:</p><p>  my $table = adTie(&apos;XML&apos;,[],&apos;c&apos;);</p><p>  creates a new empty tied hash;</p><p>See <em>adConvert()</em> and <em>adExport()</em> for further examples of using strings and arrays.</p>
<h3>Ties, Flocks, I/O, and Atomicity</h3>
<p>AnyData provides flocking which works under the limitations of flock \*(-- that it only works if other processes accessing the files are also using flock and only on platforms that support flock.  See the <em>flock()</em> man page for details.</p><p>Here is what the user supplied open modes actually do:</p><p> r = read only  (LOCK_SH)  O_RDONLY  u = update     (LOCK_EX)  O_RDWR  c = create     (LOCK_EX)  O_CREAT | O_RDWR | O_EXCL  o = overwrite  (LOCK_EX)  O_CREAT | O_RDWR | O_TRUNC</p><p>When you use something like \*(L"my $table = adTie(...)\*(R", it opens the file with a lock and leaves the file and lock open until 1) the hash variable ($table) goes out of scope or 2) the hash is undefined (e.g. \*(L"undef $table\*(R") or 3) the hash is re-assigned to another tie.  In all cases the file is closed and the lock released.</p><p>If adTie is called without creating a tied hash variable, the file is closed and the lock released immediately after the call to adTie.</p><p> For example:  print adTie(&apos;XML&apos;,&apos;foo.xml&apos;)-&gt;{main_office}-&gt;{phone}.</p><p> That obtains a shared lock, opens the file, retrieves the one value  requested, closes the file and releases the lock.</p><p>These two examples accomplish the same thing but the first example opens the file once, does all of the deletions, keeping the exclusive lock in place until they are all done, then closes the file.  The second example opens and closes the file three times, once for each deletion and releases the exclusive lock between each deletion:</p><p> 1. my $t = adTie(&apos;Pipe&apos;,&apos;games.db&apos;,&apos;u&apos;);     delete $t-&gt;{"user$_"} for (0..3);     undef $t; # closes file and releases lock</p><p> 2. delete adTie(&apos;Pipe&apos;,&apos;games.db&apos;,&apos;u&apos;)-&gt;{"user$_"} for (0..3);     # no undef needed since no hash variable created</p>
<h3>Deletions and Packing</h3>
<p>In order to save time and to prevent having to do writes anywhere except at the end of the file, deletions and updates are *not* done at the time of issuing a delete command.  Rather when the user does a delete, the position of the deleted record is stored in a hash and when the file is saved to disk, the deletions are only then physically removed by packing the entire database.  Updates are done by inserting the new record at the end of the file and marking the old record for deletion.  In the normal course of events, all of this should be transparent and you'll never need to worry about it.  However, if your server goes down after you've made updates or deletions but before you've saved the file, then the deleted rows will remain in the database and for updates there will be duplicate rows \*(-- the old non updated row and the new updated row.  If you are worried about this kind of event, then use atomic deletes and updates as shown in the section above.  There's still a very small possibility of a crash in between the deletion and the save, but in this case it should impact at most a single row.  (\s-1BIG\s0 thanks to Matthew Wickline for suggestions on handling deletes)</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MORE HELP</h2>
        <div class="sectioncontent">
<p>See the \s-1README\s0 file and the test.pl included with the module for further examples.</p><p>See the AnyData/Format/*.pm PODs for further details of specific formats.</p><p>For further support, please use comp.lang.perl.modules</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ACKNOWLEDGEMENTS</h2>
        <div class="sectioncontent">
<p>Special thanks to Andy Duncan, Tom Lowery, Randal Schwartz, Michel Rodriguez, Jochen Wiedmann, Tim Bunce, Alligator Descartes, Mathew Persico, Chris Nandor, Malcom Cook and to many others on the \s-1DBI\s0 mailing lists and the clp* newsgroups.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR & COPYRIGHT</h2>
        <div class="sectioncontent">
<p> Jeff Zucker &lt;jeff@vpservices.com&gt;</p><p> This module is copyright (c), 2000 by Jeff Zucker.  Some changes (c) 2012 Sven Dowideit L&lt;mailto:SvenDowideit@fosiki.com&gt;  It may be freely distributed under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Any::Template::ProcessDir.3pm.html"><span aria-hidden="true">&larr;</span> Any::Template::ProcessDir.3pm: Process a directory of templates</a></li>
   <li class="next"><a href="AnyData::Format::CSV.3pm.html">AnyData::Format::CSV.3pm:  <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

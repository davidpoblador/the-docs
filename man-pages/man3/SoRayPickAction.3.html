<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SoRayPickAction: The soraypickaction class does ray intersection with scene graphs.  for interaction with the scene graph geometry, it is necessary to be able to do intersection testing for rays. this functionality is provided by the soraypickaction class.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The soraypickaction class does ray intersection with scene graphs.  for interaction with the scene graph geometry, it is necessary to be able to do intersection testing for rays. this functionality is provided by the soraypickaction class.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="SoRayPickAction (3) manual">
  <meta name="twitter:description" content="The soraypickaction class does ray intersection with scene graphs.  for interaction with the scene graph geometry, it is necessary to be able to do intersection testing for rays. this functionality is provided by the soraypickaction class.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcoin80-doc-SoRayPickAction-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/SoRayPickAction.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="SoRayPickAction (3) manual" />
  <meta property="og:description" content="The soraypickaction class does ray intersection with scene graphs.  for interaction with the scene graph geometry, it is necessary to be able to do intersection testing for rays. this functionality is provided by the soraypickaction class." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcoin80-doc-SoRayPickAction-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">SoRayPickAction<small> (3)</small></h1>
        <p class="lead">The soraypickaction class does ray intersection with scene graphs.  for interaction with the scene graph geometry, it is necessary to be able to do intersection testing for rays. this functionality is provided by the soraypickaction class.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoRayPickAction.3.html">
      <span itemprop="name">SoRayPickAction: The soraypickaction class does ray intersection with scene graphs.  for interaction with the scene graph geometry, it is necessary to be able to do intersection testing for rays. this functionality is provided by the soraypickaction class.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcoin80-doc/">
      <span itemprop="name">libcoin80-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoRayPickAction.3.html">
      <span itemprop="name">SoRayPickAction: The soraypickaction class does ray intersection with scene graphs.  for interaction with the scene graph geometry, it is necessary to be able to do intersection testing for rays. this functionality is provided by the soraypickaction class.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;Inventor/actions/SoRayPickAction.h&gt;</p><p>Inherits <strong>SoPickAction</strong>.</p><h3>Public Member Functions</h3>
<p>virtual <strong>SoType</strong> <strong>getTypeId</strong> (void) const </p><p><strong>SoRayPickAction</strong> (const <strong>SbViewportRegion</strong> &viewportregion)</p><p>virtual <strong>~SoRayPickAction</strong> ()</p><p>void <strong>setPoint</strong> (const <strong>SbVec2s</strong> &viewportPoint)</p><p>void <strong>setNormalizedPoint</strong> (const <strong>SbVec2f</strong> &normpoint)</p><p>void <strong>setRadius</strong> (const float radiusinpixels)</p><p>void <strong>setRay</strong> (const <strong>SbVec3f</strong> &start, const <strong>SbVec3f</strong> &direction, float neardistance=-1.0, float fardistance=-1.0)</p><p>void <strong>setPickAll</strong> (const SbBool flag)</p><p>SbBool <strong>isPickAll</strong> (void) const </p><p>const <strong>SoPickedPointList</strong> & <strong>getPickedPointList</strong> (void) const </p><p><strong>SoPickedPoint</strong> * <strong>getPickedPoint</strong> (const int index=0) const </p><p>void <strong>computeWorldSpaceRay</strong> (void)</p><p>SbBool <strong>hasWorldSpaceRay</strong> (void) const </p><p>void <strong>setObjectSpace</strong> (void)</p><p>void <strong>setObjectSpace</strong> (const <strong>SbMatrix</strong> &matrix)</p><p>SbBool <strong>intersect</strong> (const <strong>SbVec3f</strong> &v0, const <strong>SbVec3f</strong> &v1, const <strong>SbVec3f</strong> &v2, <strong>SbVec3f</strong> &intersection, <strong>SbVec3f</strong> &barycentric, SbBool &front) const </p><p>SbBool <strong>intersect</strong> (const <strong>SbVec3f</strong> &v0, const <strong>SbVec3f</strong> &v1, <strong>SbVec3f</strong> &intersection) const </p><p>SbBool <strong>intersect</strong> (const <strong>SbVec3f</strong> &point) const </p><p>SbBool <strong>intersect</strong> (const <strong>SbBox3f</strong> &box, const SbBool usefullviewvolume=TRUE)</p><p>SbBool <strong>intersect</strong> (const <strong>SbBox3f</strong> &box, <strong>SbVec3f</strong> &intersection, const SbBool usefullviewvolume=TRUE)</p><p>const <strong>SbViewVolume</strong> & <strong>getViewVolume</strong> (void)</p><p>const <strong>SbLine</strong> & <strong>getLine</strong> (void)</p><p>SbBool <strong>isBetweenPlanes</strong> (const <strong>SbVec3f</strong> &intersection) const </p><p><strong>SoPickedPoint</strong> * <strong>addIntersection</strong> (const <strong>SbVec3f</strong> &objectspacepoint, SbBool frontpick=TRUE)</p><p>void <strong>reset</strong> (void)</p>
<h3>Static Public Member Functions</h3>
<p>static <strong>SoType</strong> <strong>getClassTypeId</strong> (void)</p><p>static void <strong>addMethod</strong> (const <strong>SoType</strong> type, SoActionMethod method)</p><p>static void <strong>enableElement</strong> (const <strong>SoType</strong> type, const int stackindex)</p><p>static void <strong>initClass</strong> (void)</p>
<h3>Protected Member Functions</h3>
<p>virtual const</p><p><strong>SoEnabledElementsList</strong> & <strong>getEnabledElements</strong> (void) const "</p><p>virtual void <strong>beginTraversal</strong> (<strong>SoNode</strong> *node)</p>
<h3>Static Protected Member Functions</h3>
<p>static <strong>SoEnabledElementsList</strong> * <strong>getClassEnabledElements</strong> (void)</p><p>static <strong>SoActionMethodList</strong> * <strong>getClassActionMethods</strong> (void)</p>
<h3>Additional Inherited Members</h3>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>The <strong>SoRayPickAction</strong> class does ray intersection with scene graphs.</p><p>For interaction with the scene graph geometry, it is necessary to be able to do intersection testing for rays. This functionality is provided by the <strong>SoRayPickAction</strong> class.</p><p><strong>SoRayPickAction</strong> can be used to pass arbitrary rays through the scene for intersection detections, by using the <strong>setRay()</strong> method.</p><p>Because a very common operation is to check for intersections along the ray from the mousecursor upon mouseclicks, it also contains convenience methods for setting up a ray from the near plane to the far plane from the 2D mousecursor coordinates. See the <strong>setPoint()</strong> and <strong>setNormalizedPoint()</strong> methods. A simple usage example for this case is presented below.</p><p>Note that one common mistake when using a raypick action to intersect from a point under the mousecursor after a mouseclick is that one tries to apply it to a scenegraph that does not contain a camera <em>explicitly</em> set up by the application programmer. Without a camera as part of the traversal, the raypick action does not know which view volume to send the ray through.</p><p>In this regard, be aware that the getSceneGraph() call in the So*-libraries' viewer classes will return the root of the user-supplied scenegraph, not the 'real' internal scenegraph root used by the viewer (which should always contain a camera node). So raypicks done from the application code will fail when doing this:</p>
<pre>
// initializing viewer scenegraph
SoSeparator * root = new SoSeparator;
root-&gt;ref();

SoEventCallback * ecb = new SoEventCallback;
ecb-&gt;addEventCallback(SoMouseButtonEvent::getClassTypeId(), event_cb, viewer);
root-&gt;addChild(ecb);

root-&gt;addChild(new SoCone);

viewer-&gt;setSceneGraph( root );
// -- [snip] -------------------------

// attempting raypick in the event_cb() callback method
SoRayPickAction rp( viewer-&gt;getViewportRegion() );
rp.setPoint(mouseevent-&gt;getPosition());
rp.apply(viewer-&gt;getSceneGraph());
// BUG: results will not be what you expected, as no camera was
// part of the "user's scenegraph"
</pre>
<p>While this is the correct way to do it:</p>
<pre>
// initializing viewer scenegraph
SoSeparator * root = new SoSeparator;
root-&gt;ref();

// Need to set up our own camera in the "user scenegraph", or else
// the raypick action will fail because the camera is hidden in the
// viewer-specific root of the scenegraph.
SoPerspectiveCamera * pcam = new SoPerspectiveCamera;
root-&gt;addChild(pcam);

SoEventCallback * ecb = new SoEventCallback;
ecb-&gt;addEventCallback(SoMouseButtonEvent::getClassTypeId(), event_cb, viewer);
root-&gt;addChild(ecb);

root-&gt;addChild(new SoCone);

viewer-&gt;setSceneGraph( root );
pcam-&gt;viewAll( root, viewer-&gt;getViewportRegion() );
// -- [snip] -------------------------

// attempting raypick in the event_cb() callback method
SoRayPickAction rp( viewer-&gt;getViewportRegion() );
rp.setPoint(mouseevent-&gt;getPosition());
rp.apply(viewer-&gt;getSceneGraph());
</pre>
<p>Or if you do want the convenience of having the viewer set up a camera for you implicitly, you can get hold of the root-node of the 'complete' scenegraph by simply calling:</p>
<pre>
SoNode * realroot = viewer-&gt;getSceneManager()-&gt;getSceneGraph();
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>SoRayPickAction::SoRayPickAction (const \fBSbViewportRegion\fP &viewportregion)</h3>
<p>Constructor.</p><p>Some node types need a <em>viewportregion</em> to know exactly how they are positioned within the scene. For an in-depth explanation of why the <em>viewportregion</em> argument is needed, see the documentation of SoGetBoundingBox::SoGetBoundingBox(const SbViewportRegion &).</p>
<h3>SoRayPickAction::~SoRayPickAction (void)\fC [virtual]\fP</h3>
<p>Destructor, free temporary resources used by action.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>\fBSoType\fP SoRayPickAction::getTypeId (void) const\fC [virtual]\fP</h3>
<p>Returns the type identification of an action derived from a class inheriting <strong>SoAction</strong>. This is used for run-time type checking and 'downward' casting.</p><p>Usage example:</p>
<pre>
void bar(SoAction * action)
{
  if (action-&gt;getTypeId() == SoGLRenderAction::getClassTypeId()) {
    // safe downward cast, know the type
    SoGLRenderAction * glrender = (SoGLRenderAction *)action;
  }
  return; // ignore if not renderaction
}
</pre>
<p>For application programmers wanting to extend the library with new actions: this method needs to be overridden in <em>all</em> subclasses. This is typically done as part of setting up the full type system for extension classes, which is usually accomplished by using the pre-defined macros available through Inventor/nodes/SoSubAction.h: SO_ACTION_SOURCE, SO_ACTION_INIT_CLASS and SO_ACTION_CONSTRUCTOR.</p><p>For more information on writing Coin extensions, see the <strong>SoAction</strong> class documentation.</p><p>Returns the actual type id of an object derived from a class inheriting <strong>SoAction</strong>. Needs to be overridden in <em>all</em> subclasses.</p><p>Reimplemented from <strong>SoPickAction</strong>.</p>
<h3>void SoRayPickAction::addMethod (const \fBSoType\fPtype, SoActionMethodmethod)\fC [static]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>void SoRayPickAction::enableElement (const \fBSoType\fPtype, const intstackindex)\fC [static]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>const \fBSoEnabledElementsList\fP & SoRayPickAction::getEnabledElements (void) const\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>Returns a list of the elements used by action instances of this class upon traversal operations.</p><p>Reimplemented from <strong>SoPickAction</strong>.</p>
<h3>void SoRayPickAction::setPoint (const \fBSbVec2s\fP &viewportpoint)</h3>
<p>Sets the viewport-space point. This point is calculated into a line from the near clipping plane to the far clipping plane, and the intersection ray follows the line.</p><p>This is a convenient way to detect object intersection below the cursor.</p>
<h3>void SoRayPickAction::setNormalizedPoint (const \fBSbVec2f\fP &normpoint)</h3>
<p>Sets the viewport-space point which the ray is sent through. The coordinate is normalized, ranging from (0, 0) to (1, 1).</p><p><strong>See also:</strong></p><p><strong>setPoint()</strong></p>
<h3>void SoRayPickAction::setRadius (const floatradiusinpixels)</h3>
<p>Sets the radius of the picking ray, in screen pixels. Default value is 5.0.</p><p>The radius of the intersection ray will only influence the pick operation's behavior versus lines and points, and has no effect on picking of shapes / polygons.</p>
<h3>void SoRayPickAction::setRay (const \fBSbVec3f\fP &start, const \fBSbVec3f\fP &direction, floatneardistance = \fC-1.0\fP, floatfardistance = \fC-1.0\fP)</h3>
<p>Sets the intersection ray in world-space coordinates.</p><p>Use this method if you want to send any ray through the scene to detect intersections, independently of mouse cursor position upon clicks and scene graph camera settings.</p>
<h3>void SoRayPickAction::setPickAll (const SbBoolflag)</h3>
<p>Lets you decide whether or not all the objects the ray intersects with should be picked. If not, only the intersection point of the object closest to the camera will be picked.</p><p>Default value of the 'pick all' flag is FALSE.</p>
<h3>SbBool SoRayPickAction::isPickAll (void) const</h3>
<p>Returns whether only the closest object or all the objects the ray intersects with is picked.</p><p><strong>See also:</strong></p><p><strong>setPickAll()</strong></p>
<h3>const \fBSoPickedPointList\fP & SoRayPickAction::getPickedPointList (void) const</h3>
<p>Returns a list of the picked points.</p>
<h3>\fBSoPickedPoint\fP * SoRayPickAction::getPickedPoint (const intindex = \fC0\fP) const</h3>
<p>Returns the picked point with <em>index</em> in the list of picked points.</p><p>Returns NULL if less than <em>index</em> + 1 points where picked during the last raypick action.</p>
<h3>void SoRayPickAction::computeWorldSpaceRay (void)</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>SbBool SoRayPickAction::hasWorldSpaceRay (void) const</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>void SoRayPickAction::setObjectSpace (void)</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>void SoRayPickAction::setObjectSpace (const \fBSbMatrix\fP &matrix)</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>SbBool SoRayPickAction::intersect (const \fBSbVec3f\fP &v0_in, const \fBSbVec3f\fP &v1_in, const \fBSbVec3f\fP &v2_in, \fBSbVec3f\fP &intersection, \fBSbVec3f\fP &barycentric, SbBool &front) const</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>SbBool SoRayPickAction::intersect (const \fBSbVec3f\fP &v0_in, const \fBSbVec3f\fP &v1_in, \fBSbVec3f\fP &intersection) const</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>SbBool SoRayPickAction::intersect (const \fBSbVec3f\fP &point_in) const</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>SbBool SoRayPickAction::intersect (const \fBSbBox3f\fP &box, const SbBoolusefullviewvolume = \fCTRUE\fP)</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>SbBool SoRayPickAction::intersect (const \fBSbBox3f\fP &box, \fBSbVec3f\fP &intersection, const SbBoolusefullviewvolume = \fCTRUE\fP)</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>const \fBSbViewVolume\fP & SoRayPickAction::getViewVolume (void)</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>const \fBSbLine\fP & SoRayPickAction::getLine (void)</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>SbBool SoRayPickAction::isBetweenPlanes (const \fBSbVec3f\fP &intersection_in) const</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>\fBSoPickedPoint\fP * SoRayPickAction::addIntersection (const \fBSbVec3f\fP &objectspacepoint_in, SbBoolfrontpick = \fCTRUE\fP)</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>void SoRayPickAction::reset (void)</h3>
<p>Truncates the internal picked points list.</p><p><strong>Since:</strong></p><p>Coin 2.2</p>
<h3>void SoRayPickAction::beginTraversal (\fBSoNode\fP *node)\fC [protected]\fP, \fC [virtual]\fP</h3>
<p>This virtual method is called from <strong>SoAction::apply()</strong>, and is the entry point for the actual scenegraph traversal.</p><p>It can be overridden to initialize the action at traversal start, for specific initializations in the action subclasses inheriting <strong>SoAction</strong>.</p><p>Default method just calls <strong>traverse()</strong>, which any overridden implementation of the method must do too (or call <strong>SoAction::beginTraversal()</strong>) to trigger the scenegraph traversal.</p><p>Reimplemented from <strong>SoPickAction</strong>.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for Coin from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="SoQuadMesh.3.html"><span aria-hidden="true">&larr;</span> SoQuadMesh.3: The soquadmesh class is used to render and optimize a quadrilateral mesh.  this node uses the coordinates in order, either from the state or from the soquadmesh::vertexproperty node, to construct a quadrilateral mesh.</a></li>
   <li class="next"><a href="SoReadError.3.html">SoReadError.3: The soreaderror class is used during model import operations.  during model file import, this class will be used to output any error or warning messages. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>globus_gsi_gssapi: Gsi implementation details.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Gsi implementation details.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="globus_gsi_gssapi (3) manual">
  <meta name="twitter:description" content="Gsi implementation details.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libglobus-gssapi-gsi-doc-globus_gsi_gssapi-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/globus_gsi_gssapi.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="globus_gsi_gssapi (3) manual" />
  <meta property="og:description" content="Gsi implementation details." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libglobus-gssapi-gsi-doc-globus_gsi_gssapi-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">globus_gsi_gssapi<small> (3)</small></h1>
        <p class="lead">Gsi implementation details.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/globus_gsi_gssapi.3.html">
      <span itemprop="name">globus_gsi_gssapi: Gsi implementation details.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libglobus-gssapi-gsi-doc/">
      <span itemprop="name">libglobus-gssapi-gsi-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/globus_gsi_gssapi.3.html">
      <span itemprop="name">globus_gsi_gssapi: Gsi implementation details.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>GSI Implementation Details.</p><p>The Globus GSI GSSAPI is an implementation of GSS API C Bindings using OpenSSL. This API documentation is intended to explain implementation-specific behavior of this GSSAPI implementation, as well as GSSAPI extensions.</p><p>The API documentation is divided into sections covering:</p><ul>
<li><p><strong>Globus GSSAPI</strong></p></li><li><p><strong>Activation</strong></p></li><li><p><strong>Constants</strong></p></li><li><p><strong>Request Flags</strong></p></li><li><p><strong>Return Flags</strong></p></li><li><p><strong>GSSAPI Extensions</strong></p></li><li><p><strong>Delegation</strong></p></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Function Documentation</h2>
        <div class="sectioncontent">
<h3>OM_uint32 GSS_CALLCONV gss_accept_sec_context (OM_uint32 *minor_status, gss_ctx_id_t *context_handle_P, const gss_cred_id_tacceptor_cred_handle, const gss_buffer_tinput_token, const gss_channel_bindings_tinput_chan_bindings, gss_name_t *src_name_P, gss_OID *mech_type, gss_buffer_toutput_token, OM_uint32 *ret_flags, OM_uint32 *time_rec, gss_cred_id_t *delegated_cred_handle_P)</h3>
<p>GSS Accept Security Context.</p><p><strong>Parameters:</strong></p><p><em>minor_status</em></p><p><em>context_handle_P</em></p><p><em>acceptor_cred_handle</em></p><p><em>input_token</em></p><p><em>input_chan_bindings</em></p><p><em>src_name_P</em></p><p><em>mech_type</em></p><p><em>output_token</em></p><p><em>ret_flags</em> Also used as req_flags for other functions</p><p><em>time_rec</em></p><p><em>delegated_cred_handle_P</em></p><p><strong>Returns:</strong></p>
<h3>OM_uint32 GSS_CALLCONV gss_acquire_cred (OM_uint32 *minor_status, const gss_name_tdesired_name_P, OM_uint32time_req, const gss_OID_setdesired_mechs, gss_cred_usage_tcred_usage, gss_cred_id_t *output_cred_handle_P, gss_OID_set *actual_mechs, OM_uint32 *time_rec)</h3>
<p>Acquire Credential. GSSAPI routine to acquire the local credential. See the latest IETF draft/RFC on the GSSAPI C bindings.</p><p>Gets the local credentials. The proxy_init_cred does most of the work of setting up the SSL_ctx, getting the user's cert, key, etc.</p><p>The globusid will be obtained from the certificate. (Minus and /CN=proxy entries.)</p><p><strong>Parameters:</strong></p><p><em>minor_status</em> Mechanism specific status code. In this implementation, the minor_status is a cast from a globus_result_t value, which is either GLOBUS_SUCCESS or a globus error object ID if an error occurred.</p><p><em>desired_name_P</em> Name of principle whose credentials should be acquired This parameter maps to the desired subject of the cert to be acquired as the credential. Possible values are:</p><ul>
<li><p>For a service cert: <em>service name</em>@<em>fqdn</em></p></li><li><p>For a host cert: <em>fqdn</em></p></li><li><p>For a proxy cert: <em>subject name</em></p></li><li><p>For a user cert: <em>subject name</em> This parameter can be NULL, in which case the cert is chosen using a default search order of: host, proxy, user, service</p></li>
</ul><p><em>time_req</em> Number of seconds that credentials should remain valid. This value can be GSS_C_INDEFINITE for an unlimited lifetime. NOTE: in the current implementation, this parameter is ignored, since you can't change the expiration of a signed cert.</p><p><em>desired_mechs</em></p><p><em>cred_usage</em></p><p><em>output_cred_handle_P</em></p><p><em>actual_mechs</em></p><p><em>time_rec</em></p>
<h3>OM_uint32 GSS_CALLCONV gss_add_oid_set_member (OM_uint32 *minor_status, const gss_OIDmember_oid, gss_OID_set *oid_set)</h3>
<p>Add OID Set Member. Adds an Object Identifier to an Object Identifier set. This routine is intended for use in conjunction with GSS_Create_empty_OID_set() when constructing a set of mechanism OIDs for input to GSS_Acquire_cred().</p><p><strong>Parameters:</strong></p><p><em>minor_status</em></p><p><em>member_oid</em></p><p><em>oid_set</em></p><p><strong>Return values:</strong></p><p><em>GSS_S_COMPLETE</em> Success</p><p><em>GSS_S_FAILURE</em> Operation failed</p>
<h3>OM_uint32 GSS_CALLCONV gss_compare_name (OM_uint32 *minor_status, const gss_name_tname1_P, const gss_name_tname2_P, int *name_equal)</h3>
<p>Compare Name. Compare two names. GSSAPI names in this implementation are pointers to X.509 names.</p><p><strong>Parameters:</strong></p><p><em>minor_status</em> currently is always set to GLOBUS_SUCCESS</p><p><em>name1_P</em></p><p><em>name2_P</em></p><p><em>name_equal</em></p><p><strong>Returns:</strong></p><p>currently always returns GSS_S_COMPLETE</p>
<h3>OM_uint32 GSS_CALLCONV gss_context_time (OM_uint32 *minor_status, const gss_ctx_id_tcontext_handle, OM_uint32 *time_rec)</h3>
<p>Context Time.</p><p><strong>Parameters:</strong></p><p><em>minor_status</em></p><p><em>context_handle</em></p><p><em>time_rec</em></p><p><strong>Returns:</strong></p>
<h3>OM_uint32 GSS_CALLCONV gss_create_empty_oid_set (OM_uint32 *minor_status, gss_OID_set *oid_set)</h3>
<p>Create Empty OID Set</p><p>Creates an object identifier set containing no object identifiers, to which members may be subsequently added using the GSS_Add_OID_set_member() routine. These routines are intended to be used to construct sets of mechanism object identifiers, for input to GSS_Acquire_cred().</p><p><strong>Parameters:</strong></p><p><em>minor_status</em></p><p><em>oid_set</em></p><p><strong>Return values:</strong></p><p><em>GSS_S_COMPLETE</em> Success</p><p><em>GSS_S_FAILURE</em> Operation failed</p>
<h3>OM_uint32 GSS_CALLCONV gss_delete_sec_context (OM_uint32 *minor_status, gss_ctx_id_t *context_handle_P, gss_buffer_toutput_token)</h3>
<p>Delete Security Context. Delete the GSS Security Context</p><p><strong>Parameters:</strong></p><p><em>minor_status</em> The minor status result - this is a globus_result_t cast to a OM_uint32.</p><p><em>context_handle_P</em> The context handle to be deleted</p><p><em>output_token</em> A token created upon destroying the context. If non-empty, this should be sent to the peer of the context to indicate that the context is closed.</p><p><strong>Returns:</strong></p><p>This function always returns GSS_S_COMPLETE</p>
<h3>OM_uint32 GSS_CALLCONV gss_display_name (OM_uint32 *minor_status, const gss_name_tinput_name_P, gss_buffer_toutput_name, gss_OID *output_name_type)</h3>
<p>Display Name. Produces a single line version of the internal X.509 name</p><p><strong>Parameters:</strong></p><p><em>minor_status</em></p><p><em>input_name_P</em></p><p><em>output_name</em></p><p><em>output_name_type</em></p><p><strong>Returns:</strong></p>
<h3>OM_uint32 GSS_CALLCONV gss_display_status (OM_uint32 *minor_status, OM_uint32status_value, intstatus_type, const gss_OIDmech_type, OM_uint32 *message_context, gss_buffer_tstatus_string)</h3>
<p>Display Status</p><p>Calls the OpenSSL error print routines to produce a printable message. This may need some work, as the OpenSSL error messages are more of a trace, and my not be the best for the user. Also don't take advantage of being called in a loop.</p><p><strong>Parameters:</strong></p><p><em>minor_status</em></p><p><em>status_value</em></p><p><em>status_type</em></p><p><em>mech_type</em></p><p><em>message_context</em></p><p><em>status_string</em></p><p><strong>Returns:</strong></p>
<h3>OM_uint32 GSS_CALLCONV gss_duplicate_name (OM_uint32 *minor_status, const gss_name_tsrc_name, gss_name_t *dest_name)</h3>
<p>Duplicate Name. Copy a GSSAPI name.</p><p><strong>Parameters:</strong></p><p><em>minor_status</em></p><p><em>src_name</em></p><p><em>dest_name</em></p><p><strong>Returns:</strong></p>
<h3>OM_uint32 GSS_CALLCONV gss_export_name (OM_uint32 *minor_status, const gss_name_tinput_name_P, gss_buffer_texported_name)</h3>
<p>Export Name. Produces a mechanism-independent exported name object. See section 3.2 of RFC 2743.</p>
<h3>OM_uint32 GSS_CALLCONV gss_export_sec_context (OM_uint32 *minor_status, gss_ctx_id_t *context_handle_P, gss_buffer_tinterprocess_token)</h3>
<p>Export Security Context. Saves the important info about the session, converts it to a token, then deletes the context.</p><p><strong>Parameters:</strong></p><p><em>minor_status</em></p><p><em>context_handle_P</em></p><p><em>interprocess_token</em></p><p><strong>Returns:</strong></p><p>For SSL handle We need to save: version of this routine. cred_usage, i.e. are we accept or initiate target/source or name Session: Protocol, cipher, and Master-Key Client-Random Server-Random tmp.key_block: client and server Mac_secrets write_sequence read_sequence write iv read iv</p><p>see SSL 3.0 draft http://wp.netscape.com/eng/ssl3/index.html</p>
<h3>OM_uint32 GSS_CALLCONV gss_get_mic (OM_uint32 *minor_status, const gss_ctx_id_tcontext_handle, gss_qop_tqop_req, const gss_buffer_tmessage_buffer, gss_buffer_tmessage_token)</h3>
<p>Get MIC</p><p>Calculates a cryptographic MIC (message integrity check) over an application message, and returns that MIC in the token. The token and message can then be passed to the peer application which calls <strong>gss_verify_mic</strong> to verify the MIC.</p><p><strong>Parameters:</strong></p><p><em>minor_status</em></p><p><em>context_handle</em></p><p><em>qop_req</em></p><p><em>message_buffer</em></p><p><em>message_token</em></p><p><strong>Returns:</strong></p>
<h3>OM_uint32 GSS_CALLCONV gss_import_name (OM_uint32 *minor_status, const gss_buffer_tinput_name_buffer, const gss_OIDinput_name_type, gss_name_t *output_name_P)</h3>
<p>Import a name into a gss_name_t</p><p>Creates a new gss_name_t which contains a mechanism-specific representation of the input name. GSSAPI OpenSSL implements the following name types, based on the input_name_type OID:</p><ul>
<li><p>GSS_C_NT_ANONYMOUS (input_name_buffer is ignored)</p></li><li><p>GSS_C_NT_HOSTBASED_SERVICE (input_name_buffer contains a string 'service@FQN' which will match /CN=service/FQDN)</p></li><li><p>GSS_C_NT_EXPORT_NAME (input_name_buffer contains a string with the X509_oneline representation of a name) like '/X=Y/Z=A...')</p></li><li><p>GSS_C_NO_OID or GSS_C_NT_USER_NAME (input_name_buffer contains an X.500 name formatted like '/X=Y/Z=A...')</p></li><li><p>GLOBUS_GSS_C_NT_HOST_IP (input_name_buffer contains a string 'FQDN/ip-address' which will match names with the FQDN or the IP address)</p></li><li><p>GLOBUS_SSS_C_NT_X509 (input buffer is an X509 struct from OpenSSL)</p></li>
</ul><p><strong>Parameters:</strong></p><p><em>minor_status</em> Minor status</p><p><em>input_name_buffer</em> Input name buffer which is interpreted based on the <em>input_name_type</em></p><p><em>input_name_type</em> OID of the name</p><p><em>output_name_P</em> New gss_name_t value containing the name</p><p><strong>Return values:</strong></p><p><em>GSS_S_COMPLETE</em> indicates that a valid name representation is output in output_name and described by the type value in output_name_type.</p><p><em>GSS_S_BAD_NAMETYPE</em> indicates that the input_name_type is unsupported by the applicable underlying GSS-API mechanism(s), so the import operation could not be completed.</p><p><em>GSS_S_BAD_NAME</em> indicates that the provided input_name_string is ill-formed in terms of the input_name_type, so the import operation could not be completed.</p><p><em>GSS_S_BAD_MECH</em> indicates that the input presented for import was an exported name object and that its enclosed mechanism type was not recognized or was unsupported by the GSS-API implementation.</p><p><em>GSS_S_FAILURE</em> indicates that the requested operation could not be performed for reasons unspecified at the GSS-API level.</p>
<h3>OM_uint32 GSS_CALLCONV gss_indicate_mechs (OM_uint32 *minor_status, gss_OID_set *mech_set)</h3>
<p>Indicate Mechs. Passes back the mech set of available mechs. We only have one for now.</p><p><strong>Parameters:</strong></p><p><em>minor_status</em></p><p><em>mech_set</em></p>
<h3>OM_uint32 GSS_CALLCONV gss_inquire_context (OM_uint32 *minor_status, const gss_ctx_id_tcontext_handle_P, gss_name_t *src_name_P, gss_name_t *targ_name_P, OM_uint32 *lifetime_rec, gss_OID *mech_type, OM_uint32 *ctx_flags, int *locally_initiated, int *open)</h3>
<p>Inquire Context.</p><p><strong>Parameters:</strong></p><p><em>minor_status</em></p><p><em>context_handle_P</em></p><p><em>src_name_P</em></p><p><em>targ_name_P</em></p><p><em>lifetime_rec</em></p><p><em>mech_type</em></p><p><em>ctx_flags</em></p><p><em>locally_initiated</em></p><p><em>open</em></p><p><strong>Returns:</strong></p>
<h3>OM_uint32 GSS_CALLCONV gss_inquire_cred (OM_uint32 *minor_status, const gss_cred_id_tcred_handle_P, gss_name_t *name, OM_uint32 *lifetime, gss_cred_usage_t *cred_usage, gss_OID_set *mechanisms)</h3>
<p>Inquire Cred. We will also allow the return of the proxy file name, if the minor_status is set to a value of 57056 0xdee0 This is done since there is no way to pass back the delegated credential file name.</p><p>When 57056 is seen, this will cause a new copy of this credential to be written, and it is the user's responsibility to free the file when done. The name will be a pointer to a char * of the file name which must be freeed. The minor_status will be set to 57057 0xdee1 to indicate this.</p><p>DEE - this is a kludge, till the GSSAPI get a better way to return the name.</p><p>If the minor status is not changed from 57056 to 57057 assume it is not this gssapi, and a gss name was returned.</p><p><strong>Parameters:</strong></p><p><em>minor_status</em></p><p><em>cred_handle_P</em></p><p><em>name</em></p><p><em>lifetime</em></p><p><em>cred_usage</em></p><p><em>mechanisms</em></p><p><strong>Returns:</strong></p>
<h3>OM_uint32 GSS_CALLCONV gss_release_buffer (OM_uint32 *minor_status, gss_buffer_tbuffer)</h3>
<p>Release Buffer.</p><p><strong>Parameters:</strong></p><p><em>minor_status</em></p><p><em>buffer</em></p><p><strong>Return values:</strong></p><p><em>GSS_S_COMPLETE</em> Success</p>
<h3>OM_uint32 GSS_CALLCONV gss_release_cred (OM_uint32 *minor_status, gss_cred_id_t *cred_handle_P)</h3>
<p>Release Credential. Release the GSSAPI credential handle</p><p><strong>Parameters:</strong></p><p><em>minor_status</em> The minor status result - this is a globus_result_t cast to a OM_uint32. To access the globus error object use: globus_error_get((globus_result_t) *minor_status)</p><p><em>cred_handle_P</em> The gss cred handle to be released</p><p><strong>Return values:</strong></p><p><em>GSS_S_COMPLETE</em> Success</p>
<h3>OM_uint32 GSS_CALLCONV gss_release_name (OM_uint32 *minor_status, gss_name_t *name_P)</h3>
<p>GSS Release Name. Release the GSS Name</p><p><strong>Parameters:</strong></p><p><em>minor_status</em> The minor status result - this is a globus_result_t cast to a (OM_uint32 *).</p><p><em>name_P</em> The GSSAPI name to be released</p><p><strong>Return values:</strong></p><p><em>GSS_S_COMPLETE</em> Success</p><p><em>GSS_S_FAILURE</em> Failure</p>
<h3>OM_uint32 GSS_CALLCONV gss_release_oid_set (OM_uint32 *minor_status, gss_OID_set *mech_set)</h3>
<p>Release OID Set. Release the OID set.</p><p><strong>Parameters:</strong></p><p><em>minor_status</em></p><p><em>mech_set</em></p><p><strong>Return values:</strong></p><p><em>GSS_S_COMPLETE</em> Success</p>
<h3>OM_uint32 GSS_CALLCONV gss_seal (OM_uint32 *minor_status, gss_ctx_id_tcontext_handle, intconf_req_flag, intqop_req, gss_buffer_tinput_message_buffer, int *conf_state, gss_buffer_toutput_message_buffer)</h3>
<p>Seal. Obsolete variant of gss_wrap for V1 compatibility</p><p><strong>Parameters:</strong></p><p><em>minor_status</em></p><p><em>context_handle</em></p><p><em>conf_req_flag</em></p><p><em>qop_req</em></p><p><em>input_message_buffer</em></p><p><em>conf_state</em></p><p><em>output_message_buffer</em></p><p><strong>Returns:</strong></p>
<h3>OM_uint32 GSS_CALLCONV gss_sign (OM_uint32 *minor_status, gss_ctx_id_tcontext_handle, intqop_req, gss_buffer_tmessage_buffer, gss_buffer_tmessage_token)</h3>
<p>Sign. Deprecated. Does the same thing as gss_get_mic for V1 compatibility.</p><p><strong>Parameters:</strong></p><p><em>minor_status</em></p><p><em>context_handle</em></p><p><em>qop_req</em></p><p><em>message_buffer</em></p><p><em>message_token</em></p><p><strong>Returns:</strong></p>
<h3>OM_uint32 GSS_CALLCONV gss_test_oid_set_member (OM_uint32 *minor_status, const gss_OIDmember, const gss_OID_setset, int *present)</h3>
<p>Test OID Set Member. Interrogates an Object Identifier set to determine whether a specified Object Identifier is a member. This routine is intended to be used with OID sets returned by GSS_Indicate_mechs(), GSS_Acquire_cred(), and GSS_Inquire_cred().</p><p><strong>Parameters:</strong></p><p><em>minor_status</em></p><p><em>member</em></p><p><em>set</em></p><p><em>present</em></p><p><strong>Return values:</strong></p><p><em>GSS_S_COMPLETE</em> Success</p><p><em>GSS_S_FAILURE</em> Operation failed</p>
<h3>OM_uint32 GSS_CALLCONV gss_unseal (OM_uint32 *minor_status, gss_ctx_id_tcontext_handle, gss_buffer_tinput_message_buffer, gss_buffer_toutput_message_buffer, int *conf_state, int *qop_state)</h3>
<p>Unseal. Obsolete variant of gss_wrap for V1 compatibility allow for non 32 bit integer in qop_state.</p><p>Return the data from the wrapped buffer. There may also be errors, such as integrity errors. Since we can not communicate directly with our peer, we can not do everything SSL could, i.e. return a token for example.</p><p><strong>Parameters:</strong></p><p><em>minor_status</em></p><p><em>context_handle</em></p><p><em>input_message_buffer</em></p><p><em>output_message_buffer</em></p><p><em>conf_state</em></p><p><em>qop_state</em></p>
<h3>OM_uint32 GSS_CALLCONV gss_unwrap (OM_uint32 *minor_status, const gss_ctx_id_tcontext_handle, const gss_buffer_tinput_message_buffer, gss_buffer_toutput_message_buffer, int *conf_state, gss_qop_t *qop_state)</h3>
<p>Unwrap. GSSAPI routine to unwrap a buffer which may have been received and wraped by wrap.c</p><p>Return the data from the wrapped buffer. There may also be errors, such as integrity errors. Since we can not communicate directly with our peer, we can not do everything SSL could, i.e. return a token for example.</p><p><strong>Parameters:</strong></p><p><em>minor_status</em></p><p><em>context_handle</em></p><p><em>input_message_buffer</em></p><p><em>output_message_buffer</em></p><p><em>conf_state</em></p><p><em>qop_state</em></p>
<h3>OM_uint32 GSS_CALLCONV gss_verify (OM_uint32 *minor_status, gss_ctx_id_tcontext_handle, gss_buffer_tmessage_buffer, gss_buffer_ttoken_buffer, int *qop_state)</h3>
<p>Verify. Obsolete variant of gss_verify for V1 compatibility Check a MIC of the date</p><p><strong>Parameters:</strong></p><p><em>minor_status</em></p><p><em>context_handle</em></p><p><em>message_buffer</em></p><p><em>token_buffer</em></p><p><em>qop_state</em></p><p><strong>Returns:</strong></p>
<h3>OM_uint32 GSS_CALLCONV gss_verify_mic (OM_uint32 *minor_status, const gss_ctx_id_tcontext_handle, const gss_buffer_tmessage_buffer, const gss_buffer_ttoken_buffer, gss_qop_t *qop_state)</h3>
<p>Verify MIC. Check a MIC of the data</p><p><strong>Parameters:</strong></p><p><em>minor_status</em></p><p><em>context_handle</em></p><p><em>message_buffer</em></p><p><em>token_buffer</em></p><p><em>qop_state</em></p><p><strong>Returns:</strong></p>
<h3>OM_uint32 GSS_CALLCONV gss_wrap (OM_uint32 *minor_status, const gss_ctx_id_tcontext_handle, intconf_req_flag, gss_qop_tqop_req, const gss_buffer_tinput_message_buffer, int *conf_state, gss_buffer_toutput_message_buffer)</h3>
<p>Wrap. Wrap a message for integrity and protection. We do this using the SSLv3 routines, by writing to the SSL bio, and pulling off the buffer from the back of the write BIO. But we can't do everything SSL might want, such as control messages, or segment the messages here, since we are forced to using the GSSAPI tokens, and can not communicate directly with our peer. So there maybe some failures which would work with true SSL.</p><p><strong>Parameters:</strong></p><p><em>minor_status</em></p><p><em>context_handle</em></p><p><em>conf_req_flag</em></p><p><em>qop_req</em></p><p><em>input_message_buffer</em></p><p><em>conf_state</em></p><p><em>output_message_buffer</em></p><p><strong>Returns:</strong></p>
<h3>OM_uint32 GSS_CALLCONV gss_wrap_size_limit (OM_uint32 *minor_status, const gss_ctx_id_tcontext_handle, intconf_req_flag, gss_qop_tqop_req, OM_uint32req_output_size, OM_uint32 *max_input_size)</h3>
<p>Wrap Size Limit. GSSAPI routine to take a buffer, calculate a MIC which is returned as a token. We will use the SSL protocol here.</p><p><strong>Parameters:</strong></p><p><em>minor_status</em></p><p><em>context_handle</em></p><p><em>conf_req_flag</em></p><p><em>qop_req</em></p><p><em>req_output_size</em></p><p><em>max_input_size</em></p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for globus_gssapi_gsi from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="globus_gsi_gss_returned_context_flags.3.html"><span aria-hidden="true">&larr;</span> globus_gsi_gss_returned_context_flags.3: Return flags.</a></li>
   <li class="next"><a href="globus_gsi_gssapi_activation.3.html">globus_gsi_gssapi_activation.3: Module activation. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

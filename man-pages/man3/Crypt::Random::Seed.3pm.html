<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Crypt::Random::Seed: Simple method to get strong randomness</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Simple method to get strong randomness">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Crypt::Random::Seed (3pm) manual">
  <meta name="twitter:description" content="Simple method to get strong randomness">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcrypt-random-seed-perl-Crypt::Random::Seed-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Crypt::Random::Seed.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Crypt::Random::Seed (3pm) manual" />
  <meta property="og:description" content="Simple method to get strong randomness" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcrypt-random-seed-perl-Crypt::Random::Seed-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Crypt::Random::Seed<small> (3pm)</small></h1>
        <p class="lead">Simple method to get strong randomness</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Crypt::Random::Seed.3pm.html">
      <span itemprop="name">Crypt::Random::Seed: Simple method to get strong randomness</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcrypt-random-seed-perl/">
      <span itemprop="name">libcrypt-random-seed-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Crypt::Random::Seed.3pm.html">
      <span itemprop="name">Crypt::Random::Seed: Simple method to get strong randomness</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">VERSION</h2>
        <div class="sectioncontent">
<p>Version 0.03</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  use Crypt::Random::Seed;

  my $source = new Crypt::Random::Seed;
  die "No strong sources exist" unless defined $source;
  my $seed_string = $source-&gt;<strong>random_bytes</strong>(4);
  my @seed_values = $source-&gt;<strong>random_values</strong>(4);

  # Only non-blocking sources
  my $nonblocking_source = Crypt::Random::Seed-&gt;new( NonBlocking=&gt;1 );

  # Blacklist sources (never choose the listed sources)
  my $nowin32_source = Crypt::Random::Seed-&gt;new( Never=&gt;[&apos;Win32&apos;] );

  # Whitelist sources (only choose from these sources)
  my $devr_source = Crypt::Random::Seed-&gt;new( Only=&gt;[&apos;TESHA2&apos;] );

  # Supply a custom source.
  my $user_src = Crypt::Random::Seed-&gt;new( Source=&gt;sub { myfunc(shift) } );
  # Or supply a list of [name, sub, is_blocking, is_strong]
  $user_src = Crypt::Random::Seed-&gt;new(
     Source=&gt;[&apos;MyRandomFunction&apos;,sub {myfunc(shift)},0,1] );

  # Given a source there are a few things we can do:
  say "My randomness source is ", $source-&gt;name();
  say "I am a blocking source" if $source-&gt;is_blocking();
  say "I am a strong randomness source" if $source-&gt;is_strong()
  say "Four 8-bit numbers:",
      join(",", map { ord $source-&gt;<strong>random_bytes</strong>(1) } 1..4);&apos;
  say "Four 32-bit numbers:", join(",", $source-&gt;<strong>random_values</strong>(4));
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>A simple mechanism to get strong randomness.  The main purpose of this module is to provide a simple way to generate a seed for a \s-1PRNG\s0 such as Math::Random::ISAAC, for use in cryptographic key generation, or as the seed for an upstream module such as Bytes::Random::Secure.  Flags for requiring non-blocking sources are allowed, as well as a very simple method for plugging in a source.</p><p>The randomness sources used are, in order:</p>
<dl class='dl-vertical'>
  <dt>
    User supplied.
  </dt>
  <dd>
    <p>If the constructor is called with a Source defined, then it is used.  It is not checked vs. other flags (NonBlocking, Never, Only).</p>
  </dd>
  <dt>
    Win32 Crypto \s-1API\s0.
  </dt>
  <dd>
    <p>This will use \*(C`CryptGenRandom\*(C' on Windows 2000 and \*(C`RtlGenRand\*(C' on Windows \s-1XP\s0 and newer.  According to \s-1MSDN\s0, these are well-seeded CSPRNGs (\s-1FIPS\s0 186-2 or AES-CTR), so will be non-blocking.</p>
  </dd>
  <dt>
    \s-1EGD\s0 / \s-1PRNGD\s0.
  </dt>
  <dd>
    <p>This looks for sockets that speak the \s-1EGD\s0 &lt;http://egd.sourceforge.net/&gt; protocol, including \s-1PRNGD\s0 &lt;http://prngd.sourceforge.net/&gt;.  These are userspace entropy daemons that are commonly used by OpenSSL, OpenSSH, and GnuGP.  The locations searched are \*(C`/var/run/egd-pool\*(C', \*(C`/dev/egd-pool\*(C', \*(C`/etc/egd-pool\*(C', and \*(C`/etc/entropy\*(C'.  \s-1EGD\s0 is blocking, while \s-1PRNGD\s0 is non-blocking (like the Win32 \s-1API\s0, it is really a seeded \s-1CSPRNG\s0).  However there is no way to tell them apart, so we treat it as blocking.  If your O/S supports /dev/random, consider \s-1HAVEGED\s0 &lt;http://www.issihosts.com/haveged/&gt; as an alternative (a system daemon that refills /dev/random as needed).</p>
  </dd>
  <dt>
    /dev/random.
  </dt>
  <dd>
    <p>The strong source of randomness on most UNIX-like systems.  Cygwin uses this, though it maps to the Win32 \s-1API\s0.  On almost all systems this is a blocking source of randomness \*(-- if it runs out of estimated entropy, it will hang until more has come into the system.  If this is an issue, which it often is on embedded devices, running a tool such as \s-1HAVEGED\s0 &lt;http://www.issihosts.com/haveged/&gt; will help immensely.</p>
  </dd>
  <dt>
    /dev/urandom.
  </dt>
  <dd>
    <p>A nonblocking source of randomness that we label as weak, since it will continue providing output even if the actual entropy has been exhausted.</p>
  </dd>
  <dt>
    \s-1TESHA2\s0.
  </dt>
  <dd>
    <p>Crypt::Random::TESHA2 is a Perl module that generates random bytes from an entropy pool fed with timer/scheduler variations.  Measurements and tests are performed on installation to determine whether the source is considered strong or weak.  This is entirely in portable userspace, which is good for ease of use, but really requires user verification that it is working as expected if we expect it to be strong.  The concept is similar to Math::TrulyRandom though updated to something closer to what TrueRand 2.1 does vs. the obsolete version 1 that Math::TrulyRandom implements.  It is very slow and has wide speed variability across platforms : I've seen numbers ranging from 40 to 150,000 bits per second.</p>
  </dd>

</dl>
<p>A source can also be supplied in the constructor.  Each of these sources will have its debatable points about perceived strength.  E.g. Why is /dev/urandom considered weak while Win32 is strong?  Can any userspace method such as TrueRand or \s-1TESHA2\s0 be considered strong?</p><h3>\s-1SOURCE\s0 \s-1TABLE\s0</h3>
<p>This table summarizes the default sources:</p><p>  +------------------+-------------+------------+--------------------+   |      SOURCE      |  STRENGTH   |  BLOCKING  |       NOTE         |   |------------------+-------------+------------+--------------------|   | RtlGenRandom     |   <strong>Strong</strong>(1) |     No     | Default WinXP+     |   |------------------+-------------+------------+--------------------|   | CryptGenRandom   |   <strong>Strong</strong>(1) |     No     | Default Win2000    |   |------------------+-------------+------------+--------------------|   | EGD              |   Strong    |    <strong>Yes</strong>(2)  | also PRNGD, etc.   |   |------------------+-------------+------------+--------------------|   | /dev/random      |   Strong    |    Yes     | Typical UNIX       |   |------------------+-------------+------------+--------------------|   | /dev/urandom     |    Weak     |     No     | Typical UNIX NB    |   |------------------+-------------+------------+--------------------|   | TESHA2-strong    |   Strong    |     No     |                    |   |------------------+-------------+------------+--------------------|   | TESHA2-weak      |    Weak     |     No     |                    |   +------------------+-------------+------------+--------------------+</p><p>The alias 'Win32' can be used in whitelist and blacklist and will match both the Win32 sources \*(C`RtlGenRandom\*(C' and \*(C`CryptGenRandom\*(C'.  The alias '\s-1TESHA2\s0' may be similarly used and matches both the weak and strong sources.</p><p>  1) Both CryptGenRandom and RtlGenRandom are considered strong by this      package, even though both are seeded CSPRNGs so should be the equal of      /dev/urandom in this respect.  The CryptGenRandom function used in      Windows 2000 has some known issues so should be considered weaker.</p><p>  2) EGD is blocking, PRNGD is not.  We cannot tell the two apart.  There are      other software products that use the same protocol, and each will act      differently.  E.g. EGD mixes in system entropy on every request, while      PRNGD mixes on a time schedule.</p>
<h3>\s-1STRENGTH\s0</h3>
<p>In theory, a strong generator will provide true entropy.  Even if a third party knew a previous result and the entire state of the generator at any time up to when their value was returned, they could still not effectively predict the result of the next returned value.  This implies the generator must either be blocking to wait for entropy (e.g. /dev/random) or go through some possibly time-consuming process to gather it (\s-1TESHA2\s0, \s-1EGD\s0, the \s-1HAVEGE\s0 daemon refilling /dev/random).  Note: strong in this context means practically strong, as most computers don't have a true hardware entropy generator.  The goal is to make all the attackers ill-gotten knowledge give them no better solution than if they did not have the information.</p><p>Creating a satisfactory strength measurement is problematic.  The Win32 Crypto \s-1API\s0 is considered \*(L"strong\*(R" by most customers and every other Perl module, however it is a well seeded \s-1CSPRNG\s0 according to the \s-1MSDN\s0 docs, so is not a strong source based on the definition in the previous paragraph. Similarly, almost all sources consider /dev/urandom to be weak, as once it runs out of entropy it returns a deterministic function based on its state (albeit one that cannot be run either direction from a returned result if the internal state is not known).</p><p>Because of this confusion, I have removed the \*(C`Weak\*(C' configuration option that was present in version 0.01.  It will now be ignored.  You should be able to use a combination of whitelist, blacklist, and the source's \*(C`is_strong\*(C' return value to decide if this meets your needs.  On Win32, you really only have a choice of Win32 and \s-1TESHA2\s0.  The former is going to be what most people want, and can be chosen even with non-blocking set.  On most \s-1UNIX\s0 systems, \*(C`/dev/random\*(C' will be chosen for blocking and \*(C`/dev/urandom\*(C' for non-blocking, which is what should be done in most cases.</p>
<h3>\s-1BLOCKING\s0</h3>
<p>\s-1EGD\s0 and /dev/random are blocking sources.  This means that if they run out of estimated entropy, they will pause until they've collected more.  This means your program also pauses.  On typical workstations this may be a few seconds or even minutes.  On an isolated network server this may cause a delay of hours or days.  \s-1EGD\s0 is proactive about gathering more entropy as fast as it can.  Running a tool such as the \s-1HAVEGE\s0 daemon or timer_entropyd can make /dev/random act like a non-blocking source, as the entropy daemon will wake up and refill the pool almost instantly.</p><p>Win32, \s-1PRNGD\s0, and /dev/urandom are fast nonblocking sources.  When they run out of entropy, they use a \s-1CSPRNG\s0 to keep supplying data at high speed. However this means that there is no additional entropy being supplied.</p><p>\s-1TESHA2\s0 is nonblocking, but can be very slow.  /dev/random can be faster if run on a machine with lots of activity.  On an isolated server, \s-1TESHA2\s0 may be much faster.  Also note that the blocking sources such as \s-1EGD\s0 and /dev/random both try to maintain reasonably large entropy pools, so small requests can be supplied without blocking.</p>
<h3>\s-1IN\s0 \s-1PRACTICE\s0</h3>
<p>Use the default to get the best source known.  If you know more about the sources available, you can use a whitelist, blacklist, or a custom source. In general, to get the best source (typically Win32 or /dev/random):</p><p>  my $source = Crypt::Random::Seed-&gt;new();</p><p>To get a good non-blocking source (Win32 or /dev/urandom):</p><p>  my $source = Crypt::Random::Seed-&gt;new(NonBlocking =&gt; 1);</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">
<h3>new</h3>
<p>The constructor with no arguments will find the first available source in its fixed list and return an object that performs the defined methods.  If no sources could be found (quite unusual) then the returned value will be undef.</p><p>Optional parameters are passed in as a hash and may be mixed.</p><p><em>NonBlocking =&gt; </em><em>boolean</em><em></em></p><p>Only non-blocking sources will be allowed.  In practice this means \s-1EGD\s0 and /dev/random will not be chosen (except on FreeBSD where it is non-blocking).</p><p><em>Only =&gt; [</em><em>list of strings</em><em>]</em></p><p>Takes an array reference containing one or more string source names.  No source whose name does not match one of these strings will be chosen.  The string 'Win32' will match either of the Win32 sources, and '\s-1TESHA2\s0' will match both the strong and weak versions.</p><p><em>Never =&gt; [</em><em>list of strings</em><em>]</em></p><p>Takes an array reference containing one or more string source names.  No source whose name matches one of these strings will be chosen.  The string 'Win32' will match either of the Win32 sources, and '\s-1TESHA2\s0' will match both the strong and weak versions.</p><p><em>Source =&gt; sub { </em><em>...</em><em> }</em></p><p>Uses the given anonymous subroutine as the generator.  The subroutine will be given an integer (the argument to \*(C`random_bytes\*(C') and should return random data in a string of the given length.  For the purposes of the other object methods, the returned object will have the name 'User', and be considered non-blocking and non-strong.</p><p><em>Source =&gt; ['</em><em>name</em><em>', sub { </em><em>...</em><em> }, </em><em>is_blocking</em><em>, </em><em>is_strong</em><em>]</em></p><p>Similar to the simpler source routine, but also allows the other source parameters to be defined.  The name may not be one of the standard names listed in the \*(L"name\*(R" section.</p>
<h3>random_bytes($n)</h3>
<p>Takes an integer and returns a string of that size filled with random data. Returns an empty string if the argument is not defined or is not more than zero.</p>
<h3>random_values($n)</h3>
<p>Takes an integer and returns an array of that many random 32-bit values. Returns an empty array if the argument is not defined or is not more than zero.</p>
<h3>name</h3>
<p>Returns the text name of the random source.  This will be one of: \*(C`User\*(C' for user defined, \*(C`CryptGenRandom\*(C' for Windows 2000 Crypto \s-1API\s0, \*(C`RtlGenRand\*(C' for Windows \s-1XP\s0 and newer Crypto \s-1API\s0, \*(C`EGD\*(C' for a known socket speaking the \s-1EGD\s0 protocol, \*(C`/dev/random\*(C' for the UNIX-like strong randomness source, \*(C`/dev/urandom\*(C' for the UNIX-like non-blocking randomness source, \*(C`TESHA2-strong\*(C' for the userspace entropy method when considered strong, \*(C`TESHA2-weak\*(C' for the userspace entropy method when considered weak. Other methods may be supported in the future.  User supplied sources may be named anything other than one of the defined names.</p>
<h3>is_strong</h3>
<p>Returns 1 or 0 indicating whether the source is considered a strong source of randomness.  See the \*(L"\s-1STRENGTH\s0\*(R" section for more discussion of what this means, and the source table for what we think of each source.</p>
<h3>is_blocking</h3>
<p>Returns 1 or 0 indicating whether the source can block on read.  Be aware that even if a source doesn't block, it may be extremely slow.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p>Dana Jacobsen &lt;dana@acm.org&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ACKNOWLEDGEMENTS</h2>
        <div class="sectioncontent">
<p>To the best of my knowledge, Max Kanat-Alexander was the original author of the Perl code that uses the Win32 \s-1API\s0.  I used his code as a reference.</p><p>David Oswald gave me a lot of help with \s-1API\s0 discussions and code reviews.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Crypt::Random::Seed&hellip;</h2>
        <div class="sectioncontent">
<p>The first question one may ask is \*(L"Why yet another module of this type?\*(R" None of the modules on \s-1CPAN\s0 quite fit my needs, hence this.  Some alternatives:</p><h3>Crypt::Random::Source</h3>
<p>A comprehensive system using multiple plugins.  It has a nice \s-1API\s0, but uses Any::Moose which means you're loading up Moose or Mouse just to read a few bytes from /dev/random.  It also has a very long dependency chain, with on the order of 40 modules being installed as prerequisites (depending of course on whether you use any of them on other projects).  Lastly, it requires at least Perl 5.8, which may or may not matter to you.  But it matters to some other module builders who end up with the restriction in their modules.</p>
<h3>Crypt::URandom</h3>
<p>A great little module that is almost what I was looking for. Crypt::Random::Seed will act the same if given the constructor:</p><p>  my $source = Crypt::Random::Seed-&gt;new(      NonBlocking =&gt; 1,      Only =&gt; [qw(/dev/random /dev/urandom Win32)]   );   croak "No randomness source available" unless defined $source;</p><p>Or you can leave out the \*(C`Only\*(C' and have \s-1TESHA2\s0 as a backup.</p>
<h3>Crypt::Random</h3>
<p>Requires Math::Pari which makes it unacceptable in some environments. Has more features (numbers in arbitrary bigint intervals or bit sizes). Crypt::Random::Seed is taking a simpler approach, just handling returning octets and letting upstream modules handle the rest.</p>
<h3>Data::Entropy</h3>
<p>An interesting module that contains a source encapsulation (defaults to system rand, but has many plugins), a good \s-1CSPRNG\s0 (\s-1AES\s0 in counter mode), and the Data::Entropy::Algorithms module with many ways to get bits, ints, bigints, floats, bigfloats, shuffles, and so forth.  From my perspective, the algorithms module is the highlight, with a lot of interesting code.</p>
<h3>Upstream modules</h3>
<p>Some modules that could use this module to help them: Bytes::Random::Secure, Math::Random::ISAAC, Math::Random::Secure, and Math::Random::MT to name a few.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright 2013 by Dana Jacobsen &lt;dana@acm.org&gt;</p><p>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p><p>The software is provided \*(L"\s-1AS\s0 \s-1IS\s0\*(R", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the software or the use or other dealings in the software.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Crypt::RC4.3pm.html"><span aria-hidden="true">&larr;</span> Crypt::RC4.3pm: Perl implementation of the rc4 encryption algorithm</a></li>
   <li class="next"><a href="Crypt::SaltedHash.3pm.html">Crypt::SaltedHash.3pm: Perl interface to functions that assist in working with salted hashes. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

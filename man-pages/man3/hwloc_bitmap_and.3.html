<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>hwloc_bitmap_and: The bitmap api -</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The bitmap api -">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="hwloc_bitmap_and (3) manual">
  <meta name="twitter:description" content="The bitmap api -">
  <meta name="twitter:image" content="https://www.carta.tech/images/libhwloc-doc-hwloc_bitmap_and-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/hwloc_bitmap_and.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="hwloc_bitmap_and (3) manual" />
  <meta property="og:description" content="The bitmap api -" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libhwloc-doc-hwloc_bitmap_and-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">hwloc_bitmap_and<small> (3)</small></h1>
        <p class="lead">The bitmap api -</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/hwloc_bitmap_and.3.html">
      <span itemprop="name">hwloc_bitmap_and: The bitmap api -</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libhwloc-doc/">
      <span itemprop="name">libhwloc-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/hwloc_bitmap_and.3.html">
      <span itemprop="name">hwloc_bitmap_and: The bitmap api -</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>The <strong>hwloc_bitmap_t</strong> type represents a set of objects, typically OS processors -- which may actually be hardware threads (represented by <strong>hwloc_cpuset_t</strong>, which is a typedef for <strong>hwloc_bitmap_t</strong>) -- or memory nodes (represented by <strong>hwloc_nodeset_t</strong>, which is also a typedef for <strong>hwloc_bitmap_t</strong>).</p><p><em>Both CPU and node sets are always indexed by OS physical number.</em></p><p><strong>Note:</strong></p><p>CPU sets and nodesets are described in <strong>Object Sets (hwloc_cpuset_t and hwloc_nodeset_t)</strong>.</p><p>A bitmap may be of infinite size.</p><p><strong>Note:</strong></p><p>Several examples of using the bitmap API are available under the doc/examples/ directory in the source tree. Regression tests such as tests/hwloc_bitmap*.c also make intensive use of this API.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Macro Definition Documentation</h2>
        <div class="sectioncontent">
<h3>#define hwloc_bitmap_foreach_begin(id, bitmap)</h3>
<p>Loop macro iterating on bitmap bitmap. index is the loop variable; it should be an unsigned int. The first iteration will set index to the lowest index in the bitmap. Successive iterations will iterate through, in order, all remaining indexes that in the bitmap. To be specific: each iteration will return a value for index such that hwloc_bitmap_isset(bitmap, index) is true.</p><p>The assert prevents the loop from being infinite if the bitmap is infinite.</p>
<h3>#define hwloc_bitmap_foreach_end()</h3>
<p><strong>Value:</strong></p>
<pre>
}  } while (0)
</pre>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Typedef Documentation</h2>
        <div class="sectioncontent">
<h3>typedef struct hwloc_bitmap_s* \fBhwloc_bitmap_t\fP</h3>
<p>Set of bits represented as an opaque pointer to an internal bitmap.</p>
<h3>typedef const struct hwloc_bitmap_s* \fBhwloc_const_bitmap_t\fP</h3>
<p>a non-modifiable <strong>hwloc_bitmap_t</strong></p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Function Documentation</h2>
        <div class="sectioncontent">
<h3>void hwloc_bitmap_allbut (\fBhwloc_bitmap_t\fPbitmap, unsignedid)</h3>
<p>Fill the bitmap and clear the index id.</p>
<h3>\fBhwloc_bitmap_t\fP hwloc_bitmap_alloc (void)</h3>
<p>Allocate a new empty bitmap.</p><p><strong>Returns:</strong></p><p>A valid bitmap or NULL.</p><p>The bitmap should be freed by a corresponding call to <strong>hwloc_bitmap_free()</strong>.</p>
<h3>\fBhwloc_bitmap_t\fP hwloc_bitmap_alloc_full (void)</h3>
<p>Allocate a new full bitmap.</p>
<h3>void hwloc_bitmap_and (\fBhwloc_bitmap_t\fPres, \fBhwloc_const_bitmap_t\fPbitmap1, \fBhwloc_const_bitmap_t\fPbitmap2)</h3>
<p>And bitmaps bitmap1 and bitmap2 and store the result in bitmap res. res can be the same as bitmap1 or bitmap2</p>
<h3>void hwloc_bitmap_andnot (\fBhwloc_bitmap_t\fPres, \fBhwloc_const_bitmap_t\fPbitmap1, \fBhwloc_const_bitmap_t\fPbitmap2)</h3>
<p>And bitmap bitmap1 and the negation of bitmap2 and store the result in bitmap res. res can be the same as bitmap1 or bitmap2</p>
<h3>int hwloc_bitmap_asprintf (char **strp, \fBhwloc_const_bitmap_t\fPbitmap)</h3>
<p>Stringify a bitmap into a newly allocated string.</p>
<h3>void hwloc_bitmap_clr (\fBhwloc_bitmap_t\fPbitmap, unsignedid)</h3>
<p>Remove index id from bitmap bitmap.</p>
<h3>void hwloc_bitmap_clr_range (\fBhwloc_bitmap_t\fPbitmap, unsignedbegin, intend)</h3>
<p>Remove indexes from begin to end in bitmap bitmap. If end is -1, the range is infinite.</p>
<h3>int hwloc_bitmap_compare (\fBhwloc_const_bitmap_t\fPbitmap1, \fBhwloc_const_bitmap_t\fPbitmap2)</h3>
<p>Compare bitmaps bitmap1 and bitmap2 using their highest index. Higher most significant bit is higher. The empty bitmap is considered lower than anything.</p>
<h3>int hwloc_bitmap_compare_first (\fBhwloc_const_bitmap_t\fPbitmap1, \fBhwloc_const_bitmap_t\fPbitmap2)</h3>
<p>Compare bitmaps bitmap1 and bitmap2 using their lowest index. Smaller least significant bit is smaller. The empty bitmap is considered higher than anything.</p>
<h3>void hwloc_bitmap_copy (\fBhwloc_bitmap_t\fPdst, \fBhwloc_const_bitmap_t\fPsrc)</h3>
<p>Copy the contents of bitmap src into the already allocated bitmap dst.</p>
<h3>\fBhwloc_bitmap_t\fP hwloc_bitmap_dup (\fBhwloc_const_bitmap_t\fPbitmap)</h3>
<p>Duplicate bitmap bitmap by allocating a new bitmap and copying bitmap contents. If bitmap is NULL, NULL is returned.</p>
<h3>void hwloc_bitmap_fill (\fBhwloc_bitmap_t\fPbitmap)</h3>
<p>Fill bitmap bitmap with all possible indexes (even if those objects don't exist or are otherwise unavailable)</p>
<h3>int hwloc_bitmap_first (\fBhwloc_const_bitmap_t\fPbitmap)</h3>
<p>Compute the first index (least significant bit) in bitmap bitmap.</p><p><strong>Returns:</strong></p><p>-1 if no index is set.</p>
<h3>void hwloc_bitmap_free (\fBhwloc_bitmap_t\fPbitmap)</h3>
<p>Free bitmap bitmap. If bitmap is NULL, no operation is performed.</p>
<h3>void hwloc_bitmap_from_ith_ulong (\fBhwloc_bitmap_t\fPbitmap, unsignedi, unsigned longmask)</h3>
<p>Setup bitmap bitmap from unsigned long mask used as i -th subset.</p>
<h3>void hwloc_bitmap_from_ulong (\fBhwloc_bitmap_t\fPbitmap, unsigned longmask)</h3>
<p>Setup bitmap bitmap from unsigned long mask.</p>
<h3>int hwloc_bitmap_intersects (\fBhwloc_const_bitmap_t\fPbitmap1, \fBhwloc_const_bitmap_t\fPbitmap2)</h3>
<p>Test whether bitmaps bitmap1 and bitmap2 intersects.</p>
<h3>int hwloc_bitmap_isequal (\fBhwloc_const_bitmap_t\fPbitmap1, \fBhwloc_const_bitmap_t\fPbitmap2)</h3>
<p>Test whether bitmap bitmap1 is equal to bitmap bitmap2.</p>
<h3>int hwloc_bitmap_isfull (\fBhwloc_const_bitmap_t\fPbitmap)</h3>
<p>Test whether bitmap bitmap is completely full.</p>
<h3>int hwloc_bitmap_isincluded (\fBhwloc_const_bitmap_t\fPsub_bitmap, \fBhwloc_const_bitmap_t\fPsuper_bitmap)</h3>
<p>Test whether bitmap sub_bitmap is part of bitmap super_bitmap.</p>
<h3>int hwloc_bitmap_isset (\fBhwloc_const_bitmap_t\fPbitmap, unsignedid)</h3>
<p>Test whether index id is part of bitmap bitmap.</p>
<h3>int hwloc_bitmap_iszero (\fBhwloc_const_bitmap_t\fPbitmap)</h3>
<p>Test whether bitmap bitmap is empty.</p>
<h3>int hwloc_bitmap_last (\fBhwloc_const_bitmap_t\fPbitmap)</h3>
<p>Compute the last index (most significant bit) in bitmap bitmap.</p><p><strong>Returns:</strong></p><p>-1 if no index is bitmap, or if the index bitmap is infinite.</p>
<h3>int hwloc_bitmap_list_asprintf (char **strp, \fBhwloc_const_bitmap_t\fPbitmap)</h3>
<p>Stringify a bitmap into a newly allocated list string.</p>
<h3>int hwloc_bitmap_list_snprintf (char *restrictbuf, size_tbuflen, \fBhwloc_const_bitmap_t\fPbitmap)</h3>
<p>Stringify a bitmap in the list format. Lists are comma-separated indexes or ranges. Ranges are dash separated indexes. The last range may not have a ending indexes if the bitmap is infinite.</p><p>Up to buflen characters may be written in buffer buf.</p><p>If buflen is 0, buf may safely be NULL.</p><p><strong>Returns:</strong></p><p>the number of character that were actually written if not truncating, or that would have been written (not including the ending &#92;0).</p>
<h3>int hwloc_bitmap_list_sscanf (\fBhwloc_bitmap_t\fPbitmap, const char *restrictstring)</h3>
<p>Parse a list string and stores it in bitmap bitmap.</p>
<h3>int hwloc_bitmap_next (\fBhwloc_const_bitmap_t\fPbitmap, intprev)</h3>
<p>Compute the next index in bitmap bitmap which is after index prev. If prev is -1, the first index is returned.</p><p><strong>Returns:</strong></p><p>-1 if no index with higher index is bitmap.</p>
<h3>void hwloc_bitmap_not (\fBhwloc_bitmap_t\fPres, \fBhwloc_const_bitmap_t\fPbitmap)</h3>
<p>Negate bitmap bitmap and store the result in bitmap res. res can be the same as bitmap</p>
<h3>void hwloc_bitmap_only (\fBhwloc_bitmap_t\fPbitmap, unsignedid)</h3>
<p>Empty the bitmap bitmap and add bit id.</p>
<h3>void hwloc_bitmap_or (\fBhwloc_bitmap_t\fPres, \fBhwloc_const_bitmap_t\fPbitmap1, \fBhwloc_const_bitmap_t\fPbitmap2)</h3>
<p>Or bitmaps bitmap1 and bitmap2 and store the result in bitmap res. res can be the same as bitmap1 or bitmap2</p>
<h3>void hwloc_bitmap_set (\fBhwloc_bitmap_t\fPbitmap, unsignedid)</h3>
<p>Add index id in bitmap bitmap.</p>
<h3>void hwloc_bitmap_set_ith_ulong (\fBhwloc_bitmap_t\fPbitmap, unsignedi, unsigned longmask)</h3>
<p>Replace i -th subset of bitmap bitmap with unsigned long mask.</p>
<h3>void hwloc_bitmap_set_range (\fBhwloc_bitmap_t\fPbitmap, unsignedbegin, intend)</h3>
<p>Add indexes from begin to end in bitmap bitmap. If end is -1, the range is infinite.</p>
<h3>void hwloc_bitmap_singlify (\fBhwloc_bitmap_t\fPbitmap)</h3>
<p>Keep a single index among those set in bitmap bitmap. May be useful before binding so that the process does not have a chance of migrating between multiple logical CPUs in the original mask.</p>
<h3>int hwloc_bitmap_snprintf (char *restrictbuf, size_tbuflen, \fBhwloc_const_bitmap_t\fPbitmap)</h3>
<p>Stringify a bitmap. Up to buflen characters may be written in buffer buf.</p><p>If buflen is 0, buf may safely be NULL.</p><p><strong>Returns:</strong></p><p>the number of character that were actually written if not truncating, or that would have been written (not including the ending &#92;0).</p>
<h3>int hwloc_bitmap_sscanf (\fBhwloc_bitmap_t\fPbitmap, const char *restrictstring)</h3>
<p>Parse a bitmap string and stores it in bitmap bitmap.</p>
<h3>int hwloc_bitmap_taskset_asprintf (char **strp, \fBhwloc_const_bitmap_t\fPbitmap)</h3>
<p>Stringify a bitmap into a newly allocated taskset-specific string.</p>
<h3>int hwloc_bitmap_taskset_snprintf (char *restrictbuf, size_tbuflen, \fBhwloc_const_bitmap_t\fPbitmap)</h3>
<p>Stringify a bitmap in the taskset-specific format. The taskset command manipulates bitmap strings that contain a single (possible very long) hexadecimal number starting with 0x.</p><p>Up to buflen characters may be written in buffer buf.</p><p>If buflen is 0, buf may safely be NULL.</p><p><strong>Returns:</strong></p><p>the number of character that were actually written if not truncating, or that would have been written (not including the ending &#92;0).</p>
<h3>int hwloc_bitmap_taskset_sscanf (\fBhwloc_bitmap_t\fPbitmap, const char *restrictstring)</h3>
<p>Parse a taskset-specific bitmap string and stores it in bitmap bitmap.</p>
<h3>unsigned long hwloc_bitmap_to_ith_ulong (\fBhwloc_const_bitmap_t\fPbitmap, unsignedi)</h3>
<p>Convert the i -th subset of bitmap bitmap into unsigned long mask.</p>
<h3>unsigned long hwloc_bitmap_to_ulong (\fBhwloc_const_bitmap_t\fPbitmap)</h3>
<p>Convert the beginning part of bitmap bitmap into unsigned long mask.</p>
<h3>int hwloc_bitmap_weight (\fBhwloc_const_bitmap_t\fPbitmap)</h3>
<p>Compute the 'weight' of bitmap bitmap (i.e., number of indexes that are in the bitmap).</p><p><strong>Returns:</strong></p><p>the number of indexes that are in the bitmap.</p>
<h3>void hwloc_bitmap_xor (\fBhwloc_bitmap_t\fPres, \fBhwloc_const_bitmap_t\fPbitmap1, \fBhwloc_const_bitmap_t\fPbitmap2)</h3>
<p>Xor bitmaps bitmap1 and bitmap2 and store the result in bitmap res. res can be the same as bitmap1 or bitmap2</p>
<h3>void hwloc_bitmap_zero (\fBhwloc_bitmap_t\fPbitmap)</h3>
<p>Empty the bitmap bitmap.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for Hardware Locality (hwloc) from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="hwloc_bitmap_alloc_full.3.html"><span aria-hidden="true">&larr;</span> hwloc_bitmap_alloc_full.3: The bitmap api -</a></li>
   <li class="next"><a href="hwloc_bitmap_andnot.3.html">hwloc_bitmap_andnot.3: The bitmap api - <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

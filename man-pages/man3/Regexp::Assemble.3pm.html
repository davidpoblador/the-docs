<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Regexp::Assemble: Assemble multiple regular expressions into a single re</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Assemble multiple regular expressions into a single re">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Regexp::Assemble (3pm) manual">
  <meta name="twitter:description" content="Assemble multiple regular expressions into a single re">
  <meta name="twitter:image" content="https://www.carta.tech/images/libregexp-assemble-perl-Regexp::Assemble-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Regexp::Assemble.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Regexp::Assemble (3pm) manual" />
  <meta property="og:description" content="Assemble multiple regular expressions into a single re" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libregexp-assemble-perl-Regexp::Assemble-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Regexp::Assemble<small> (3pm)</small></h1>
        <p class="lead">Assemble multiple regular expressions into a single re</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Regexp::Assemble.3pm.html">
      <span itemprop="name">Regexp::Assemble: Assemble multiple regular expressions into a single re</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libregexp-assemble-perl/">
      <span itemprop="name">libregexp-assemble-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Regexp::Assemble.3pm.html">
      <span itemprop="name">Regexp::Assemble: Assemble multiple regular expressions into a single re</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">VERSION</h2>
        <div class="sectioncontent">
<p>This document describes version 0.35 of Regexp::Assemble, released 2011-04-07.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  use Regexp::Assemble;

  my $ra = Regexp::Assemble-&gt;new;
  $ra-&gt;add( &apos;ab+c&apos; );
  $ra-&gt;add( &apos;ab+-&apos; );
  $ra-&gt;add( &apos;a&#92;w&#92;d+&apos; );
  $ra-&gt;add( &apos;a&#92;d+&apos; );
  print $ra-&gt;re; # prints a(?:&#92;w?&#92;d+|b+[-c])
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Regexp::Assemble takes an arbitrary number of regular expressions and assembles them into a single regular expression (or \s-1RE\s0) that matches all that the individual REs match.</p><p>As a result, instead of having a large list of expressions to loop over, a target string only needs to be tested against one expression. This is interesting when you have several thousand patterns to deal with. Serious effort is made to produce the smallest pattern possible.</p><p>It is also possible to track the original patterns, so that you can determine which, among the source patterns that form the assembled pattern, was the one that caused the match to occur.</p><p>You should realise that large numbers of alternations are processed in perl's regular expression engine in O(n) time, not O(1). If you are still having performance problems, you should look at using a trie. Note that Perl's own regular expression engine will implement trie optimisations in perl 5.10 (they are already available in perl 5.9.3 if you want to try them out). \*(C`Regexp::Assemble\*(C' will do the right thing when it knows it's running on a trie'd perl. (At least in some version after this one).</p><p>Some more examples of usage appear in the accompanying \s-1README\s0. If that file isn't easy to access locally, you can find it on a web repository such as http://search.cpan.org/dist/Regexp-Assemble/README &lt;http://search.cpan.org/dist/Regexp-Assemble/README&gt; or http://cpan.uwinnipeg.ca/htdocs/Regexp-Assemble/README.html &lt;http://cpan.uwinnipeg.ca/htdocs/Regexp-Assemble/README.html&gt;.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    new
  </dt>
  <dd>
    <p>Creates a new \*(C`Regexp::Assemble\*(C' object. The following optional key/value parameters may be employed. All keys have a corresponding method that can be used to change the behaviour later on. As a general rule, especially if you're just starting out, you don't have to bother with any of these. <strong>anchor_*</strong>, a family of optional attributes that allow anchors (\*(C`^\*(C', \*(C`&#92;b\*(C', \*(C`&#92;Z\*(C'...) to be added to the resulting pattern. <strong>flags</strong>, sets the \*(C`imsx\*(C' flags to add to the assembled regular expression.  Warning: no error checking is done, you should ensure that the flags you pass are understood by the version of Perl you are using. <strong>modifiers</strong> exists as an alias, for users familiar with Regexp::List. <strong>chomp</strong>, controls whether the pattern should be chomped before being lexed. Handy if you are reading patterns from a file. By default, \*(C`chomp\*(C'ing is performed (this behaviour changed as of version 0.24, prior versions did not chomp automatically). See also the \*(C`file\*(C' attribute and the \*(C`add_file\*(C' method. <strong>file</strong>, slurp the contents of the specified file and add them to the assembly. Multiple files may be processed by using a list.   my $r = Regexp::Assemble-&gt;new(file =&gt; &apos;re.list&apos;);</p><p>  my $r = Regexp::Assemble-&gt;new(file =&gt; [&apos;re.1&apos;, &apos;re.2&apos;]); If you really don't want chomping to occur, you will have to set the \*(C`chomp\*(C' attribute to 0 (zero). You may also want to look at the \*(C`input_record_separator\*(C' attribute, as well. <strong>input_record_separator</strong>, controls what constitutes a record separator when using the \*(C`file\*(C' attribute or the \*(C`add_file\*(C' method. May be abbreviated to <strong>rs</strong>. See the $/ variable in perlvar. <strong>lookahead</strong>, controls whether the pattern should contain zero-width lookahead assertions (For instance: (?=[abc])(?:bob|alice|charles). This is not activated by default, because in many circumstances the cost of processing the assertion itself outweighs the benefit of its faculty for short-circuiting a match that will fail. This is sensitive to the probability of a match succeeding, so if you're worried about performance you'll have to benchmark a sample population of targets to see which way the benefits lie. <strong>track</strong>, controls whether you want know which of the initial patterns was the one that matched. See the \*(C`matched\*(C' method for more details. Note for version 5.8 of Perl and below, in this mode of operation \s-1YOU\s0 \s-1SHOULD\s0 \s-1BE\s0 \s-1AWARE\s0 \s-1OF\s0 \s-1THE\s0 \s-1SECURITY\s0 \s-1IMPLICATIONS\s0 that this entails. Perl 5.10 does not suffer from any such restriction. <strong>indent</strong>, the number of spaces used to indent nested grouping of a pattern. Use this to produce a pretty-printed pattern. See the \*(C`as_string\*(C' method for a more detailed explanation. <strong>pre_filter</strong>, allows you to add a callback to enable sanity checks on the pattern being loaded. This callback is triggered before the pattern is split apart by the lexer. In other words, it operates on the entire pattern. If you are loading patterns from a file, this would be an appropriate place to remove comments. <strong>filter</strong>, allows you to add a callback to enable sanity checks on the pattern being loaded. This callback is triggered after the pattern has been split apart by the lexer. <strong>unroll_plus</strong>, controls whether to unroll, for example, \*(C`x+\*(C' into \*(C`x\*(C', \*(C`x*\*(C', which may allow additional reductions in the resulting assembled pattern. <strong>reduce</strong>, controls whether tail reduction occurs or not. If set, patterns like \*(C`a(?:bc+d|ec+d)\*(C' will be reduced to \*(C`a[be]c+d\*(C'. That is, the end of the pattern in each part of the b... and d... alternations is identical, and hence is hoisted out of the alternation and placed after it. On by default. Turn it off if you're really pressed for short assembly times. <strong>lex</strong>, specifies the pattern used to lex the input lines into tokens. You could replace the default pattern by a more sophisticated version that matches arbitrarily nested parentheses, for example. <strong>debug</strong>, controls whether copious amounts of output is produced during the loading stage or the reducing stage of assembly.   my $ra = Regexp::Assemble-&gt;new;   my $rb = Regexp::Assemble-&gt;new( chomp =&gt; 1, debug =&gt; 3 ); <strong>mutable</strong>, controls whether new patterns can be added to the object after the assembled pattern is generated. \s-1DEPRECATED\s0. This method/attribute will be removed in a future release. It doesn't really serve any purpose, and may be more effectively replaced by cloning an existing \*(C`Regexp::Assemble\*(C' object and spinning out a pattern from that instead. A more detailed explanation of these attributes follows.</p>
  </dd>
  <dt>
    clone
  </dt>
  <dd>
    <p>Clones the contents of a Regexp::Assemble object and creates a new object (in other words it performs a deep copy). If the Storable module is installed, its dclone method will be used, otherwise the cloning will be performed using a pure perl approach. You can use this method to take a snapshot of the patterns that have been added so far to an object, and generate an assembly from the clone. Additional patterns may to be added to the original object afterwards.   my $re = $main-&gt;clone-&gt;re();   $main-&gt;add( &apos;another-pattern-&#92;&#92;d+&apos; );</p>
  </dd>
  <dt>
    add(\s-1LIST\s0)
  </dt>
  <dd>
    <p>Takes a string, breaks it apart into a set of tokens (respecting meta characters) and inserts the resulting list into the \*(C`R::A\*(C' object. It uses a naive regular expression to lex the string that may be fooled complex expressions (specifically, it will fail to lex nested parenthetical expressions such as \*(C`ab(cd(ef)?gh)ij\*(C' correctly). If this is the case, the end of the string will not be tokenised correctly and returned as one long string. On the one hand, this may indicate that the patterns you are trying to feed the \*(C`R::A\*(C' object are too complex. Simpler patterns might allow the algorithm to work more effectively and perform more reductions in the resulting pattern. On the other hand, you can supply your own pattern to perform the lexing if you need. The test suite contains an example of a lexer pattern that will match one level of nested parentheses. Note that there is an internal optimisation that will bypass a much of the lexing process. If a string contains no \*(C`&#92;\*(C' (backslash), \*(C`[\*(C' (open square bracket), \*(C`(\*(C' (open paren), \*(C`?\*(C' (question mark), \*(C`+\*(C' (plus), \*(C`*\*(C' (star) or \*(C`{\*(C' (open curly), a character split will be performed directly. A list of strings may be supplied, thus you can pass it a file handle of a file opened for reading:     $re-&gt;add( &apos;&#92;d+-&#92;d+-&#92;d+-&#92;d+&#92;.example&#92;.com&apos; );     $re-&gt;add( &lt;IN&gt; ); If the file is very large, it may be more efficient to use a \*(C`while\*(C' loop, to read the file line-by-line:     $re-&gt;add($_) while &lt;IN&gt;; The \*(C`add\*(C' method will chomp the lines automatically. If you do not want this to occur (you want to keep the record separator), then disable \*(C`chomp\*(C'ing.     $re-&gt;<strong>chomp</strong>(0);     $re-&gt;add($_) while &lt;IN&gt;; This method is chainable.</p>
  </dd>
  <dt>
    add_file(\s-1FILENAME\s0 [...])
  </dt>
  <dd>
    <p>Takes a list of file names. Each file is opened and read line by line. Each line is added to the assembly.   $r-&gt;add_file( &apos;file.1&apos;, &apos;file.2&apos; ); If a file cannot be opened, the method will croak. If you cannot afford to let this happen then you should wrap the call in a \*(C`eval\*(C' block. Chomping happens automatically unless you the <strong>chomp</strong>(0) method to disable it. By default, input lines are read according to the value of the \*(C`input_record_separator\*(C' attribute (if defined), and will otherwise fall back to the current setting of the system $/ variable. The record separator may also be specified on each call to \*(C`add_file\*(C'. Internally, the routine \*(C`local\*(C'ises the value of $/ to whatever is required, for the duration of the call. An alternate calling mechanism using a hash reference is available.  The recognised keys are:</p>
<dl class='dl-vertical'>
  <dt>
    file
  </dt>
  <dd>
    <p>Reference to a list of file names, or the name of a single file.   $r-&gt;add_file({file =&gt; [&apos;file.1&apos;, &apos;file.2&apos;, &apos;file.3&apos;]});   $r-&gt;add_file({file =&gt; &apos;file.n&apos;});</p>
  </dd>
  <dt>
    input_record_separator
  </dt>
  <dd>
    <p>If present, indicates what constitutes a line   $r-&gt;add_file({file =&gt; &apos;data.txt&apos;, input_record_separator =&gt; &apos;:&apos; });</p>
  </dd>
  <dt>
    rs
  </dt>
  <dd>
    <p>An alias for input_record_separator (mnemonic: same as the English variable names).</p>
  </dd>

</dl>
<p>  $r-&gt;add_file( {     file =&gt; [ &apos;pattern.txt&apos;, &apos;more.txt&apos; ],     input_record_separator  =&gt; "&#92;r&#92;n",   });</p>
  </dd>
  <dt>
    insert(\s-1LIST\s0)
  </dt>
  <dd>
    <p>Takes a list of tokens representing a regular expression and stores them in the object. Note: you should not pass it a bare regular expression, such as \*(C`ab+c?d*e\*(C'. You must pass it as a list of tokens, <em>e.g.</em> \*(C`(&apos;a&apos;, &apos;b+&apos;, &apos;c?&apos;, &apos;d*&apos;, &apos;e&apos;)\*(C'. This method is chainable, <em>e.g.</em>:   my $ra = Regexp::Assemble-&gt;new     -&gt;insert( qw[ a b+ c? d* e ] )     -&gt;insert( qw[ a c+ d+ e* f ] ); Lexing complex patterns with metacharacters and so on can consume a significant proportion of the overall time to build an assembly. If you have the information available in a tokenised form, calling \*(C`insert\*(C' directly can be a big win.</p>
  </dd>
  <dt>
    lexstr
  </dt>
  <dd>
    <p>Use the \*(C`lexstr\*(C' method if you are curious to see how a pattern gets tokenised. It takes a scalar on input, representing a pattern, and returns a reference to an array, containing the tokenised pattern. You can recover the original pattern by performing a \*(C`join\*(C':   my @token = $re-&gt;lexstr($pattern);   my $new_pattern = join( &apos;&apos;, @token ); If the original pattern contains unnecessary backslashes, or \*(C`&#92;x4b\*(C' escapes, or quotemeta escapes (\*(C`&#92;Q\*(C'...\*(C`&#92;E\*(C') the resulting pattern may not be identical. Call \*(C`lexstr\*(C' does not add the pattern to the object, it is merely for exploratory purposes. It will, however, update various statistical counters.</p>
  </dd>
  <dt>
    pre_filter(\s-1CODE\s0)
  </dt>
  <dd>
    <p>Allows you to install a callback to check that the pattern being loaded contains valid input. It receives the pattern as a whole to be added, before it been tokenised by the lexer. It may to return 0 or \*(C`undef\*(C' to indicate that the pattern should not be added, any true value indicates that the contents are fine. A filter to strip out trailing comments (marked by #):   $re-&gt;pre_filter( sub { $_[0] =~ s/&#92;s*#.*$//; 1 } ); A filter to ignore blank lines:   $re-&gt;pre_filter( sub { length(shift) } ); If you want to remove the filter, pass \*(C`undef\*(C' as a parameter.   $ra-&gt;pre_filter(undef); This method is chainable.</p>
  </dd>
  <dt>
    filter(\s-1CODE\s0)
  </dt>
  <dd>
    <p>Allows you to install a callback to check that the pattern being loaded contains valid input. It receives a list on input, after it has been tokenised by the lexer. It may to return 0 or undef to indicate that the pattern should not be added, any true value indicates that the contents are fine. If you know that all patterns you expect to assemble contain a restricted set of of tokens (e.g. no spaces), you could do the following:   $ra-&gt;filter(sub { not grep { / / } @_ }); or   sub only_spaces_and_digits {     not grep { ![&#92;d ] } @_   }   $ra-&gt;filter( &#92;&only_spaces_and_digits ); These two examples will silently ignore faulty patterns, If you want the user to be made aware of the problem you should raise an error (via \*(C`warn\*(C' or \*(C`die\*(C'), log an error message, whatever is best. If you want to remove a filter, pass \*(C`undef\*(C' as a parameter.   $ra-&gt;filter(undef); This method is chainable.</p>
  </dd>
  <dt>
    as_string
  </dt>
  <dd>
    <p>Assemble the expression and return it as a string. You may want to do this if you are writing the pattern to a file. The following arguments can be passed to control the aspect of the resulting pattern: <strong>indent</strong>, the number of spaces used to indent nested grouping of a pattern. Use this to produce a pretty-printed pattern (for some definition of \*(L"pretty\*(R"). The resulting output is rather verbose. The reason is to ensure that the metacharacters \*(C`(?:\*(C' and \*(C`)\*(C' always occur on otherwise empty lines. This allows you grep the result for an even more synthetic view of the pattern:   egrep -v &apos;^ *[()]&apos; &lt;regexp.file&gt; The result of the above is quite readable. Remember to backslash the spaces appearing in your own patterns if you wish to use an indented pattern in an \*(C`m/.../x\*(C' construct. Indenting is ignored if tracking is enabled. The <strong>indent</strong> argument takes precedence over the \*(C`indent\*(C' method/attribute of the object. Calling this method will drain the internal data structure. Large numbers of patterns can eat a significant amount of memory, and this lets perl recover the memory used for other purposes. If you want to reduce the pattern <em>and</em> continue to add new patterns, clone the object and reduce the clone, leaving the original object intact.</p>
  </dd>
  <dt>
    re
  </dt>
  <dd>
    <p>Assembles the pattern and return it as a compiled \s-1RE\s0, using the \*(C`qr//\*(C' operator. As with \*(C`as_string\*(C', calling this method will reset the internal data structures to free the memory used in assembling the \s-1RE\s0. The <strong>indent</strong> attribute, documented in the \*(C`as_string\*(C' method, can be used here (it will be ignored if tracking is enabled). With method chaining, it is possible to produce a \s-1RE\s0 without having a temporary \*(C`Regexp::Assemble\*(C' object lying around, <em>e.g.</em>:   my $re = Regexp::Assemble-&gt;new     -&gt;add( q[ab+cd+e] )     -&gt;add( q[ac&#92;&#92;d+e] )     -&gt;add( q[c&#92;&#92;d+e] )     -&gt;re; The $re variable now contains a Regexp object that can be used directly:   while( &lt;&gt; ) {     /$re/ and print "Something in [$_] matched&#92;n";   ) The \*(C`re\*(C' method is called when the object is used in string context (hence, within an \*(C`m//\*(C' operator), so by and large you do not even need to save the \s-1RE\s0 in a separate variable. The following will work as expected:   my $re = Regexp::Assemble-&gt;new-&gt;add( qw[ fee fie foe fum ] );   while( &lt;IN&gt; ) {     if( /($re)/ ) {       print "Here be giants: $1&#92;n";     }   } This approach does not work with tracked patterns. The \*(C`match\*(C' and \*(C`matched\*(C' methods must be used instead, see below.</p>
  </dd>
  <dt>
    match(\s-1SCALAR\s0)
  </dt>
  <dd>
    <p>The following information applies to Perl 5.8 and below. See the section that follows for information on Perl 5.10. If pattern tracking is in use, you must \*(C`use re &apos;eval&apos;\*(C' in order to make things work correctly. At a minimum, this will make your code look like this:     my $did_match = do { use re &apos;eval&apos;; $target =~ /$ra/ }     if( $did_match ) {         print "matched ", $ra-&gt;matched, "&#92;n";     } (The main reason is that the $^R variable is currently broken and an ugly workaround that runs some Perl code during the match is required, in order to simulate what $^R should be doing. See Perl bug #32840 for more information if you are curious. The \s-1README\s0 also contains more information). This bug has been fixed in 5.10. The important thing to note is that with \*(C`use re &apos;eval&apos;\*(C', \s-1THERE\s0 \s-1ARE\s0 \s-1SECURITY\s0 \s-1IMPLICATIONS\s0 \s-1WHICH\s0 \s-1YOU\s0 \s-1IGNORE\s0 \s-1AT\s0 \s-1YOUR\s0 \s-1PERIL\s0. The problem is this: if you do not have strict control over the patterns being fed to \*(C`Regexp::Assemble\*(C' when tracking is enabled, and someone slips you a pattern such as \*(C`/^(?{system &apos;rm -rf /&apos;})/\*(C' and you attempt to match a string against the resulting pattern, you will know Fear and Loathing. What is more, the $^R workaround means that that tracking does not work if you perform a bare \*(C`/$re/\*(C' pattern match as shown above. You have to instead call the \*(C`match\*(C' method, in order to supply the necessary context to take care of the tracking housekeeping details.    if( defined( my $match = $ra-&gt;match($_)) ) {        print "  $_ matched by $match&#92;n";    } In the case of a successful match, the original matched pattern is returned directly. The matched pattern will also be available through the \*(C`matched\*(C' method. (Except that the above is not true for 5.6.0: the \*(C`match\*(C' method returns true or undef, and the \*(C`matched\*(C' method always returns undef). If you are capturing parts of the pattern <em>e.g.</em> \*(C`foo(bar)rat\*(C' you will want to get at the captures. See the \*(C`mbegin\*(C', \*(C`mend\*(C', \*(C`mvar\*(C' and \*(C`capture\*(C' methods. If you are not using captures then you may safely ignore this section. In 5.10, since the bug concerning $^R has been resolved, there is no need to use \*(C`re &apos;eval&apos;\*(C' and the assembled pattern does not require any Perl code to be executed during the match.</p>
  </dd>
  <dt>
    source
  </dt>
  <dd>
    <p>When using tracked mode, after a successful match is made, returns the original source pattern that caused the match. In Perl 5.10, the $^R variable can be used to as an index to fetch the correct pattern from the object. If no successful match has been performed, or the object is not in tracked mode, this method returns \*(C`undef\*(C'.   my $r = Regexp::Assemble-&gt;new-&gt;<strong>track</strong>(1)-&gt;add(qw(foo? bar{2} [Rr]at));</p><p>  for my $w (qw(this food is rather barren)) {     if ($w =~ /$r/) {       print "$w matched by ", $r-&gt;source($^R), $/;     }     else {       print "$w no match&#92;n";     }   }</p>
  </dd>
  <dt>
    mbegin
  </dt>
  <dd>
    <p>This method returns a copy of \*(C`@-\*(C' at the moment of the last match. You should ordinarily not need to bother with this, \*(C`mvar\*(C' should be able to supply all your needs.</p>
  </dd>
  <dt>
    mend
  </dt>
  <dd>
    <p>This method returns a copy of \*(C`@+\*(C' at the moment of the last match.</p>
  </dd>
  <dt>
    mvar(\s-1NUMBER\s0)
  </dt>
  <dd>
    <p>The \*(C`mvar\*(C' method returns the captures of the last match. <strong>mvar</strong>(1) corresponds to $1, <strong>mvar</strong>(2) to $2, and so on. <strong>mvar</strong>(0) happens to return the target string matched, as a byproduct of walking down the \*(C`@-\*(C' and \*(C`@+\*(C' arrays after the match. If called without a parameter, \*(C`mvar\*(C' will return a reference to an array containing all captures.</p>
  </dd>
  <dt>
    capture
  </dt>
  <dd>
    <p>The \*(C`capture\*(C' method returns the the captures of the last match as an array. Unlink \*(C`mvar\*(C', this method does not include the matched string. It is equivalent to getting an array back that contains \*(C`$1, $2, $3, ...\*(C'. If no captures were found in the match, an empty array is returned, rather than \*(C`undef\*(C'. You are therefore guaranteed to be able to use \*(C`for my $c ($re-&gt;capture) { ...\*(C' without have to check whether anything was captured.</p>
  </dd>
  <dt>
    matched
  </dt>
  <dd>
    <p>If pattern tracking has been set, via the \*(C`track\*(C' attribute, or through the \*(C`track\*(C' method, this method will return the original pattern of the last successful match. Returns undef match has yet been performed, or tracking has not been enabled. See below in the \s-1NOTES\s0 section for additional subtleties of which you should be aware of when tracking patterns. Note that this method is not available in 5.6.0, due to limitations in the implementation of \*(C`(?{...})\*(C' at the time.</p>
  </dd>

</dl>
<h3>Statistics/Reporting routines</h3>

<dl class='dl-vertical'>
  <dt>
    stats_add
  </dt>
  <dd>
    <p>Returns the number of patterns added to the assembly (whether by \*(C`add\*(C' or \*(C`insert\*(C'). Duplicate patterns are not included in this total.</p>
  </dd>
  <dt>
    stats_dup
  </dt>
  <dd>
    <p>Returns the number of duplicate patterns added to the assembly. If non-zero, this may be a sign that something is wrong with your data (or at the least, some needless redundancy). This may occur when you have two patterns (for instance, \*(C`a&#92;-b\*(C' and \*(C`a-b\*(C') which map to the same result.</p>
  </dd>
  <dt>
    stats_raw
  </dt>
  <dd>
    <p>Returns the raw number of bytes in the patterns added to the assembly. This includes both original and duplicate patterns. For instance, adding the two patterns \*(C`ab\*(C' and \*(C`ab\*(C' will count as 4 bytes.</p>
  </dd>
  <dt>
    stats_cooked
  </dt>
  <dd>
    <p>Return the true number of bytes added to the assembly. This will not include duplicate patterns. Furthermore, it may differ from the raw bytes due to quotemeta treatment. For instance, \*(C`abc&#92;,def\*(C' will count as 7 (not 8) bytes, because \*(C`&#92;,\*(C' will be stored as \*(C`,\*(C'. Also, \*(C`&#92;Qa.b&#92;E\*(C' is 7 bytes long, however, after the quotemeta directives are processed, \*(C`a&#92;.b\*(C' will be stored, for a total of 4 bytes.</p>
  </dd>
  <dt>
    stats_length
  </dt>
  <dd>
    <p>Returns the length of the resulting assembled expression. Until \*(C`as_string\*(C' or \*(C`re\*(C' have been called, the length will be 0 (since the assembly will have not yet been performed). The length includes only the pattern, not the additional (\*(C`(?-xism...\*(C') fluff added by the compilation.</p>
  </dd>
  <dt>
    dup_warn(NUMBER|CODEREF)
  </dt>
  <dd>
    <p>Turns warnings about duplicate patterns on or off. By default, no warnings are emitted. If the method is called with no parameters, or a true parameter, the object will carp about patterns it has already seen. To turn off the warnings, use 0 as a parameter.   $r-&gt;dup_warn(); The method may also be passed a code block. In this case the code will be executed and it will receive a reference to the object in question, and the lexed pattern.   $r-&gt;dup_warn(     sub {       my $self = shift;       print $self-&gt;stats_add, " patterns added at line $.&#92;n",           join( &apos;&apos;, @_ ), " added previously&#92;n";     }   )</p>
  </dd>

</dl>

<h3>Anchor routines</h3>
<p>Suppose you wish to assemble a series of patterns that all begin with \*(C`^\*(C'  and end with \*(C`$\*(C' (anchor pattern to the beginning and end of line). Rather than add the anchors to each and every pattern (and possibly forget to do so when a new entry is added), you may specify the anchors in the object, and they will appear in the resulting pattern, and you no longer need to (or should) put them in your source patterns. For example, the two following snippets will produce identical patterns:</p><p>  $r-&gt;add(qw(^this ^that ^them))-&gt;as_string;</p><p>  $r-&gt;add(qw(this that them))-&gt;anchor_line_begin-&gt;as_string;</p><p>  # both techniques will produce ^th(?:at|em|is)</p><p>All anchors are possible word (\*(C`&#92;b\*(C') boundaries, line boundaries (\*(C`^\*(C' and \*(C`$\*(C') and string boundaries (\*(C`&#92;A\*(C' and \*(C`&#92;Z\*(C' (or \*(C`&#92;z\*(C' if you absolutely need it)).</p><p>The shortcut \*(C`anchor_<strong>mumble\*(C'</strong> implies both \*(C`anchor_<strong>mumble_begin\*(C'</strong> \*(C`anchor_<strong>mumble_end\*(C'</strong> is also available. If different anchors are specified the most specific anchor wins. For instance, if both \*(C`anchor_word_begin\*(C' and \*(C`anchor_line_begin\*(C' are specified, \*(C`anchor_word_begin\*(C' takes precedence.</p><p>All the anchor methods are chainable.</p>
<dl class='dl-vertical'>
  <dt>
    anchor_word_begin
  </dt>
  <dd>
    <p>The resulting pattern will be prefixed with a \*(C`&#92;b\*(C' word boundary assertion when the value is true. Set to 0 to disable.   $r-&gt;add(&apos;pre&apos;)-&gt;anchor_word_begin-&gt;as_string;   # produces &apos;&#92;bpre&apos;</p>
  </dd>
  <dt>
    anchor_word_end
  </dt>
  <dd>
    <p>The resulting pattern will be suffixed with a \*(C`&#92;b\*(C' word boundary assertion when the value is true. Set to 0 to disable.   $r-&gt;add(qw(ing tion))     -&gt;anchor_word_end     -&gt;as_string; # produces &apos;(?:tion|ing)&#92;b&apos;</p>
  </dd>
  <dt>
    anchor_word
  </dt>
  <dd>
    <p>The resulting pattern will be have \*(C`&#92;b\*(C' word boundary assertions at the beginning and end of the pattern when the value is true. Set to 0 to disable.   $r-&gt;add(qw(cat carrot)     -&gt;<strong>anchor_word</strong>(1)     -&gt;as_string; # produces &apos;&#92;bca(?:rro)t&#92;b&apos;</p>
  </dd>
  <dt>
    anchor_line_begin
  </dt>
  <dd>
    <p>The resulting pattern will be prefixed with a \*(C`^\*(C' line boundary assertion when the value is true. Set to 0 to disable.   $r-&gt;anchor_line_begin;   # or   $r-&gt;<strong>anchor_line_begin</strong>(1);</p>
  </dd>
  <dt>
    anchor_line_end
  </dt>
  <dd>
    <p>The resulting pattern will be suffixed with a \*(C`$\*(C' line boundary assertion when the value is true. Set to 0 to disable.   # turn it off   $r-&gt;<strong>anchor_line_end</strong>(0);</p>
  </dd>
  <dt>
    anchor_line
  </dt>
  <dd>
    <p>The resulting pattern will be have the \*(C`^\*(C' and \*(C`$\*(C' line boundary assertions at the beginning and end of the pattern, respectively, when the value is true. Set to 0 to disable.   $r-&gt;add(qw(cat carrot)     -&gt;anchor_line     -&gt;as_string; # produces &apos;^ca(?:rro)t$&apos;</p>
  </dd>
  <dt>
    anchor_string_begin
  </dt>
  <dd>
    <p>The resulting pattern will be prefixed with a \*(C`&#92;A\*(C' string boundary assertion when the value is true. Set to 0 to disable.   $r-&gt;<strong>anchor_string_begin</strong>(1);</p>
  </dd>
  <dt>
    anchor_string_end
  </dt>
  <dd>
    <p>The resulting pattern will be suffixed with a \*(C`&#92;Z\*(C' string boundary assertion when the value is true. Set to 0 to disable.   # disable the string boundary end anchor   $r-&gt;<strong>anchor_string_end</strong>(0);</p>
  </dd>
  <dt>
    anchor_string_end_absolute
  </dt>
  <dd>
    <p>The resulting pattern will be suffixed with a \*(C`&#92;z\*(C' string boundary assertion when the value is true. Set to 0 to disable.   # disable the string boundary absolute end anchor   $r-&gt;<strong>anchor_string_end_absolute</strong>(0); If you don't understand the difference between \*(C`&#92;Z\*(C' and \*(C`&#92;z\*(C', the former will probably do what you want.</p>
  </dd>
  <dt>
    anchor_string
  </dt>
  <dd>
    <p>The resulting pattern will be have the \*(C`&#92;A\*(C' and \*(C`&#92;Z\*(C' string boundary assertions at the beginning and end of the pattern, respectively, when the value is true. Set to 0 to disable.   $r-&gt;add(qw(cat carrot)     -&gt;anchor_string     -&gt;as_string; # produces &apos;&#92;Aca(?:rro)t&#92;Z&apos;</p>
  </dd>
  <dt>
    anchor_string_absolute
  </dt>
  <dd>
    <p>The resulting pattern will be have the \*(C`&#92;A\*(C' and \*(C`&#92;z\*(C' string boundary assertions at the beginning and end of the pattern, respectively, when the value is true. Set to 0 to disable.   $r-&gt;add(qw(cat carrot)     -&gt;anchor_string_absolute     -&gt;as_string; # produces &apos;&#92;Aca(?:rro)t&#92;z&apos;</p>
  </dd>
  <dt>
    debug(\s-1NUMBER\s0)
  </dt>
  <dd>
    <p>Turns debugging on or off. Statements are printed to the currently selected file handle (\s-1STDOUT\s0 by default). If you are already using this handle, you will have to arrange to select an output handle to a file of your own choosing, before call the \*(C`add\*(C', \*(C`as_string\*(C' or \*(C`re\*(C') functions, otherwise it will scribble all over your carefully formatted output.</p>
<dl class='dl-vertical'>
  <dt>
    0
  </dt>
  <dd>
    <p>Off. Turns off all debugging output.</p>
  </dd>
  <dt>
    1
  </dt>
  <dd>
    <p>Add. Trace the addition of patterns.</p>
  </dd>
  <dt>
    2
  </dt>
  <dd>
    <p>Reduce. Trace the process of reduction and assembly.</p>
  </dd>
  <dt>
    4
  </dt>
  <dd>
    <p>Lex. Trace the lexing of the input patterns into its constituent tokens.</p>
  </dd>
  <dt>
    8
  </dt>
  <dd>
    <p>Time. Print to \s-1STDOUT\s0 the time taken to load all the patterns. This is nothing more than the difference between the time the object was instantiated and the time reduction was initiated.   # load=&lt;num&gt; Any lengthy computation performed in the client code will be reflected in this value. Another line will be printed after reduction is complete.   # reduce=&lt;num&gt; The above output lines will be changed to \*(C`load-epoch\*(C' and \*(C`reduce-epoch\*(C' if the internal state of the object is corrupted and the initial timestamp is lost. The code attempts to load Time::HiRes in order to report fractional seconds. If this is not successful, the elapsed time is displayed in whole seconds.</p>
  </dd>

</dl>
<p>Values can be added (or or'ed together) to trace everything   $r-&gt;<strong>debug</strong>(7)-&gt;add( &apos;&#92;&#92;d+abc&apos; ); Calling \*(C`debug\*(C' with no arguments turns debugging off.</p>
  </dd>
  <dt>
    dump
  </dt>
  <dd>
    <p>Produces a synthetic view of the internal data structure. How to interpret the results is left as an exercise to the reader.   print $r-&gt;dump;</p>
  </dd>
  <dt>
    chomp(0|1)
  </dt>
  <dd>
    <p>Turns chomping on or off. \s-1IMPORTANT:\s0 As of version 0.24, chomping is now on by default as it makes \*(C`add_file\*(C' Just Work. The only time you may run into trouble is with \*(C`add("&#92;&#92;$/")\*(C'. So don't do that, or else explicitly turn off chomping. To avoid incorporating (spurious) record separators (such as \*(L"&#92;n\*(R" on Unix) when reading from a file, \*(C`add()\*(C' \*(C`chomp\*(C's its input. If you don't want this to happen, call \*(C`chomp\*(C' with a false value.   $re-&gt;<strong>chomp</strong>(0); # really want the record separators   $re-&gt;add(&lt;DATA&gt;);</p>
  </dd>
  <dt>
    fold_meta_pairs(\s-1NUMBER\s0)
  </dt>
  <dd>
    <p>Determines whether \*(C`&#92;s\*(C', \*(C`&#92;S\*(C' and \*(C`&#92;w\*(C', \*(C`&#92;W\*(C' and \*(C`&#92;d\*(C', \*(C`&#92;D\*(C' are folded into a \*(C`.\*(C' (dot). Folding happens by default (for reasons of backwards compatibility, even though it is wrong when the \*(C`/s\*(C' expression modifier is active). Call this method with a false value to prevent this behaviour (which is only a problem when dealing with \*(C`&#92;n\*(C' if the \*(C`/s\*(C' expression modifier is also set).   $re-&gt;add( &apos;&#92;&#92;w&apos;, &apos;&#92;&#92;W&apos; );   my $clone = $re-&gt;clone;</p><p>  $clone-&gt;<strong>fold_meta_pairs</strong>(0);   print $clone-&gt;as_string; # prints &apos;.&apos;   print $re-&gt;as_string;    # print &apos;[&#92;W&#92;w]&apos;</p>
  </dd>
  <dt>
    indent(\s-1NUMBER\s0)
  </dt>
  <dd>
    <p>Sets the level of indent for pretty-printing nested groups within a pattern. See the \*(C`as_string\*(C' method for more details. When called without a parameter, no indenting is performed.   $re-&gt;indent( 4 );   print $re-&gt;as_string;</p>
  </dd>
  <dt>
    lookahead(0|1)
  </dt>
  <dd>
    <p>Turns on zero-width lookahead assertions. This is usually beneficial when you expect that the pattern will usually fail. If you expect that the pattern will usually match you will probably be worse off.</p>
  </dd>
  <dt>
    flags(\s-1STRING\s0)
  </dt>
  <dd>
    <p>Sets the flags that govern how the pattern behaves (for versions of Perl up to 5.9 or so, these are \*(C`imsx\*(C'). By default no flags are enabled.</p>
  </dd>
  <dt>
    modifiers(\s-1STRING\s0)
  </dt>
  <dd>
    <p>An alias of the \*(C`flags\*(C' method, for users familiar with \*(C`Regexp::List\*(C'.</p>
  </dd>
  <dt>
    track(0|1)
  </dt>
  <dd>
    <p>Turns tracking on or off. When this attribute is enabled, additional housekeeping information is inserted into the assembled expression using \*(C`({...}\*(C' embedded code constructs. This provides the necessary information to determine which, of the original patterns added, was the one that caused the match.   $re-&gt;track( 1 );   if( $target =~ /$re/ ) {     print "$target matched by ", $re-&gt;matched, "&#92;n";   } Note that when this functionality is enabled, no reduction is performed and no character classes are generated. In other words, \*(C`brag|tag\*(C' is not reduced down to \*(C`(?:br|t)ag\*(C' and \*(C`dig|dim\*(C' is not reduced to \*(C`di[gm]\*(C'.</p>
  </dd>
  <dt>
    unroll_plus(0|1)
  </dt>
  <dd>
    <p>Turns the unrolling of plus metacharacters on or off. When a pattern is broken up, \*(C`a+\*(C' becomes \*(C`a\*(C', \*(C`a*\*(C' (and \*(C`b+?\*(C' becomes \*(C`b\*(C', \*(C`b*?\*(C'. This may allow the freed \*(C`a\*(C' to assemble with other patterns. Not enabled by default.</p>
  </dd>
  <dt>
    lex(\s-1SCALAR\s0)
  </dt>
  <dd>
    <p>Change the pattern used to break a string apart into tokens. You can examine the \*(C`eg/naive\*(C' script as a starting point.</p>
  </dd>
  <dt>
    reduce(0|1)
  </dt>
  <dd>
    <p>Turns pattern reduction on or off. A reduced pattern may be considerably shorter than an unreduced pattern. Consider \*(C`/sl(?:ip|op|ap)/\*(C' <em>versus</em> \*(C`/sl[aio]p/\*(C'. An unreduced pattern will be very similar to those produced by \*(C`Regexp::Optimizer\*(C'. Reduction is on by default. Turning it off speeds assembly (but assembly is pretty fast \*(-- it's the breaking up of the initial patterns in the lexing stage that can consume a non-negligible amount of time).</p>
  </dd>
  <dt>
    mutable(0|1)
  </dt>
  <dd>
    <p>This method has been marked as \s-1DEPRECATED\s0. It will be removed in a future release. See the \*(C`clone\*(C' method for a technique to replace its functionality.</p>
  </dd>
  <dt>
    reset
  </dt>
  <dd>
    <p>Empties out the patterns that have been \*(C`add\*(C'ed or \*(C`insert\*(C'-ed into the object. Does not modify the state of controller attributes such as \*(C`debug\*(C', \*(C`lex\*(C', \*(C`reduce\*(C' and the like.</p>
  </dd>
  <dt>
    Default_Lexer
  </dt>
  <dd>
    <p><strong>Warning:</strong> the \*(C`Default_Lexer\*(C' function is a class method, not an object method. It is a fatal error to call it as an object method. The \*(C`Default_Lexer\*(C' method lets you replace the default pattern used for all subsequently created \*(C`Regexp::Assemble\*(C' objects. It will not have any effect on existing objects. (It is also possible to override the lexer pattern used on a per-object basis). The parameter should be an ordinary scalar, not a compiled pattern. If the pattern fails to match all parts of the string, the missing parts will be returned as single chunks. Therefore the following pattern is legal (albeit rather cork-brained):     Regexp::Assemble::Default_Lexer( &apos;&#92;&#92;d&apos; ); The above pattern will split up input strings digit by digit, and all non-digit characters as single chunks.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DIAGNOSTICS</h2>
        <div class="sectioncontent">
<p>  "Cannot pass a C&lt;refname&gt; to Default_Lexer"</p><p>You tried to replace the default lexer pattern with an object instead of a scalar. Solution: You probably tried to call \*(C`$obj-&gt;Default_Lexer\*(C'. Call the qualified class method instead \*(C`Regexp::Assemble::Default_Lexer\*(C'.</p><p>  "filter method not passed a coderef"</p><p>  "pre_filter method not passed a coderef"</p><p>A reference to a subroutine (anonymous or otherwise) was expected. Solution: read the documentation for the \*(C`filter\*(C' method.</p><p>  "duplicate pattern added: /.../"</p><p>The \*(C`dup_warn\*(C' attribute is active, and a duplicate pattern was added (well duh!). Solution: clean your data.</p><p>  "cannot open [file] for input: [reason]"</p><p>The \*(C`add_file\*(C' method was unable to open the specified file for whatever reason. Solution: make sure the file exists and the script has the required privileges to read it.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTES</h2>
        <div class="sectioncontent">
<p>This module has been tested successfully with a range of versions of perl, from 5.005_03 to 5.9.3. Use of 5.6.0 is not recommended.</p><p>The expressions produced by this module can be used with the \s-1PCRE\s0 library.</p><p>Remember to \*(L"double up\*(R" your backslashes if the patterns are hard-coded as constants in your program. That is, you should literally \*(C`add(&apos;a&#92;&#92;d+b&apos;)\*(C' rather than \*(C`add(&apos;a&#92;d+b&apos;)\*(C'. It usually will work either way, but it's good practice to do so.</p><p>Where possible, supply the simplest tokens possible. Don't add \*(C`X(?-&#92;d+){2})Y\*(C' when \*(C`X-&#92;d+-&#92;d+Y\*(C' will do. The reason is that if you also add \*(C`X&#92;d+Z\*(C' the resulting assembly changes dramatically: \*(C`X(?:(?:-&#92;d+){2}Y|-&#92;d+Z)\*(C' <em>versus</em> \*(C`X-&#92;d+(?:-&#92;d+Y|Z)\*(C'. Since R::A doesn't perform enough analysis, it won't \*(L"unroll\*(R" the \*(C`{2}\*(C' quantifier, and will fail to notice the divergence after the first \*(C`-d&#92;d+\*(C'.</p><p>Furthermore, when the string 'X-123000P' is matched against the first assembly, the regexp engine will have to backtrack over each alternation (the one that ends in Y <strong>and</strong> the one that ends in Z) before determining that there is no match. No such backtracking occurs in the second pattern: as soon as the engine encounters the 'P' in the target string, neither of the alternations at that point (\*(C`-&#92;d+Y\*(C' or \*(C`Z\*(C') could succeed and so the match fails.</p><p>\*(C`Regexp::Assemble\*(C' does, however, know how to build character classes. Given \*(C`a-b\*(C', \*(C`axb\*(C' and \*(C`a&#92;db\*(C', it will assemble these into \*(C`a[-&#92;dx]b\*(C'. When \*(C`-\*(C' (dash) appears as a candidate for a character class it will be the first character in the class. When \*(C`^\*(C' (circumflex) appears as a candidate for a character class it will be the last character in the class.</p><p>It also knows about meta-characters than can \*(L"absorb\*(R" regular characters. For instance, given \*(C`X&#92;d\*(C' and \*(C`X5\*(C', it knows that 5 can be represented by \*(C`&#92;d\*(C' and so the assembly is just \*(C`X&#92;d\*(C'. The \*(L"absorbent\*(R" meta-characters it deals with are \*(C`.\*(C', \*(C`&#92;d\*(C', \*(C`&#92;s\*(C' and \*(C`&#92;W\*(C' and their complements. It will replace \*(C`&#92;d\*(C'/\*(C`&#92;D\*(C', \*(C`&#92;s\*(C'/\*(C`&#92;S\*(C' and \*(C`&#92;w\*(C'/\*(C`&#92;W\*(C' by \*(C`.\*(C' (dot), and it will drop \*(C`&#92;d\*(C' if \*(C`&#92;w\*(C' is also present (as will \*(C`&#92;D\*(C' in the presence of \*(C`&#92;W\*(C').</p><p>\*(C`Regexp::Assemble\*(C' deals correctly with \*(C`quotemeta\*(C''s propensity to backslash many characters that have no need to be. Backslashes on non-metacharacters will be removed. Similarly, in character classes, a number of characters lose their magic and so no longer need to be backslashed within a character class. Two common examples are \*(C`.\*(C' (dot) and \*(C`$\*(C'. Such characters will lose their backslash.</p><p>At the same time, it will also process \*(C`&#92;Q...&#92;E\*(C' sequences. When such a sequence is encountered, the inner section is extracted and \*(C`quotemeta\*(C' is applied to the section. The resulting quoted text is then used in place of the original unquoted text, and the \*(C`&#92;Q\*(C' and \*(C`&#92;E\*(C' metacharacters are thrown away. Similar processing occurs with the \*(C`&#92;U...&#92;E\*(C' and \*(C`&#92;L...&#92;E\*(C' sequences. This may have surprising effects when using a dispatch table. In this case, you will need to know exactly what the module makes of your input. Use the \*(C`lexstr\*(C' method to find out what's going on:</p><p>  $pattern = join( &apos;&apos;, @{$re-&gt;lexstr($pattern)} );</p><p>If all the digits 0..9 appear in a character class, \*(C`Regexp::Assemble\*(C' will replace them by \*(C`&#92;d\*(C'. I'd do it for letters as well, but thinking about accented characters and other glyphs hurts my head.</p><p>In an alternation, the longest paths are chosen first (for example, \*(C`horse|bird|dog\*(C'). When two paths have the same length, the path with the most subpaths will appear first. This aims to put the \*(L"busiest\*(R" paths to the front of the alternation. For example, the list \*(C`bad\*(C', \*(C`bit\*(C', \*(C`few\*(C', \*(C`fig\*(C' and \*(C`fun\*(C' will produce the pattern \*(C`(?:f(?:ew|ig|un)|b(?:ad|it))\*(C'. See <em>eg/tld</em> for a real-world example of how alternations are sorted. Once you have looked at that, everything should be crystal clear.</p><p>When tracking is in use, no reduction is performed. nor are character classes formed. The reason is that it is too difficult to determine the original pattern afterwards. Consider the two patterns \*(C`pale\*(C' and \*(C`palm\*(C'. These should be reduced to \*(C`pal[em]\*(C'. The final character matches one of two possibilities. To resolve whether it matched an &apos;e&apos; or &apos;m&apos; would require keeping track of the fact that the pattern finished up in a character class, which would the require a whole lot more work to figure out which character of the class matched. Without character classes it becomes much easier. Instead, \*(C`pal(?:e|m)\*(C' is produced, which lets us find out more simply where we ended up.</p><p>Similarly, \*(C`dogfood\*(C' and \*(C`seafood\*(C' should form \*(C`(?:dog|sea)food\*(C'. When the pattern is being assembled, the tracking decision needs to be made at the end of the grouping, but the tail of the pattern has not yet been visited. Deferring things to make this work correctly is a vast hassle. In this case, the pattern becomes merely \*(C`(?:dogfood|seafood\*(C'. Tracked patterns will therefore be bulkier than simple patterns.</p><p>There is an open bug on this issue:</p><p>&lt;http://rt.perl.org/rt3/Ticket/Display.html?id=32840&gt;</p><p>If this bug is ever resolved, tracking would become much easier to deal with (none of the \*(C`match\*(C' hassle would be required - you could just match like a regular \s-1RE\s0 and it would Just Work).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Regexp::Assemble&hellip;</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    perlre
  </dt>
  <dd>
    <p>General information about Perl's regular expressions.</p>
  </dd>
  <dt>
    re
  </dt>
  <dd>
    <p>Specific information about \*(C`use re &apos;eval&apos;\*(C'.</p>
  </dd>
  <dt>
    Regex::PreSuf
  </dt>
  <dd>
    <p>\*(C`Regex::PreSuf\*(C' takes a string and chops it itself into tokens of length 1. Since it can't deal with tokens of more than one character, it can't deal with meta-characters and thus no regular expressions. Which is the main reason why I wrote this module.</p>
  </dd>
  <dt>
    Regexp::Optimizer
  </dt>
  <dd>
    <p>\*(C`Regexp::Optimizer\*(C' produces regular expressions that are similar to those produced by R::A with reductions switched off. It's biggest drawback is that it is exponentially slower than Regexp::Assemble on very large sets of patterns.</p>
  </dd>
  <dt>
    Regexp::Parser
  </dt>
  <dd>
    <p>Fine grained analysis of regular expressions.</p>
  </dd>
  <dt>
    Regexp::Trie
  </dt>
  <dd>
    <p>Funnily enough, this was my working name for \*(C`Regexp::Assemble\*(C' during its development. I changed the name because I thought it was too obscure. Anyway, \*(C`Regexp::Trie\*(C' does much the same as \*(C`Regexp::Optimizer\*(C' and \*(C`Regexp::Assemble\*(C' except that it runs much faster (according to the author). It does not recognise meta characters (that is, 'a+b' is interpreted as 'a&#92;+b').</p>
  </dd>
  <dt>
    Text::Trie
  </dt>
  <dd>
    <p>\*(C`Text::Trie\*(C' is well worth investigating. Tries can outperform very bushy (read: many alternations) patterns.</p>
  </dd>
  <dt>
    Tree::Trie
  </dt>
  <dd>
    <p>\*(C`Tree::Trie\*(C' is another module that builds tries. The algorithm that \*(C`Regexp::Assemble\*(C' uses appears to be quite similar to the algorithm described therein, except that \*(C`R::A\*(C' solves its end-marker problem without having to rewrite the leaves.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LIMITATIONS</h2>
        <div class="sectioncontent">
<p>\*(C`Regexp::Assemble\*(C' does not attempt to find common substrings. For instance, it will not collapse \*(C`/cabababc/\*(C' down to \*(C`/c(?:ab){3}c/\*(C'. If there's a module out there that performs this sort of string analysis I'd like to know about it. But keep in mind that the algorithms that do this are very expensive: quadratic or worse.</p><p>\*(C`Regexp::Assemble\*(C' does not interpret meta-character modifiers. For instance, if the following two patterns are given: \*(C`X&#92;d\*(C' and \*(C`X&#92;d+\*(C', it will not determine that \*(C`&#92;d\*(C' can be matched by \*(C`&#92;d+\*(C'. Instead, it will produce \*(C`X(?:&#92;d|&#92;d+)\*(C'. Along a similar line of reasoning, it will not determine that \*(C`Z\*(C' and \*(C`Z&#92;d+\*(C' is equivalent to \*(C`Z&#92;d*\*(C' (It will produce \*(C`Z(?:&#92;d+)?\*(C' instead).</p><p>You cannot remove a pattern that has been added to an object. You'll just have to start over again. Adding a pattern is difficult enough, I'd need a solid argument to convince me to add a \*(C`remove\*(C' method. If you need to do this you should read the documentation for the \*(C`clone\*(C' method.</p><p>\*(C`Regexp::Assemble\*(C' does not (yet)? employ the \*(C`(?&gt;...)\*(C' construct.</p><p>The module does not produce POSIX-style regular expressions. This would be quite easy to add, if there was a demand for it.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>Patterns that generate look-ahead assertions sometimes produce incorrect patterns in certain obscure corner cases. If you suspect that this is occurring in your pattern, disable lookaheads.</p><p>Tracking doesn't really work at all with 5.6.0. It works better in subsequent 5.6 releases. For maximum reliability, the use of a 5.8 release is strongly recommended. Tracking barely works with 5.005_04. Of note, using \*(C`&#92;d\*(C'-style meta-characters invariably causes panics. Tracking really comes into its own in Perl 5.10.</p><p>If you feed \*(C`Regexp::Assemble\*(C' patterns with nested parentheses, there is a chance that the resulting pattern will be uncompilable due to mismatched parentheses (not enough closing parentheses). This is normal, so long as the default lexer pattern is used. If you want to find out which pattern among a list of 3000 patterns are to blame (speaking from experience here), the <em>eg/debugging</em> script offers a strategy for pinpointing the pattern at fault. While you may not be able to use the script directly, the general approach is easy to implement.</p><p>The algorithm used to assemble the regular expressions makes extensive use of mutually-recursive functions (that is, A calls B, B calls A, ...) For deeply similar expressions, it may be possible to provoke \*(L"Deep recursion\*(R" warnings.</p><p>The module has been tested extensively, and has an extensive test suite (that achieves close to 100% statement coverage), but you never know...  A bug may manifest itself in two ways: creating a pattern that cannot be compiled, such as \*(C`a&#92;(bc)\*(C', or a pattern that compiles correctly but that either matches things it shouldn't, or doesn't match things it should. It is assumed that Such problems will occur when the reduction algorithm encounters some sort of edge case. A temporary work-around is to disable reductions:</p><p>  my $pattern = $assembler-&gt;<strong>reduce</strong>(0)-&gt;re;</p><p>A discussion about implementation details and where bugs might lurk appears in the \s-1README\s0 file. If this file is not available locally, you should be able to find a copy on the Web at your nearest \s-1CPAN\s0 mirror.</p><p>Seriously, though, a number of people have been using this module to create expressions anywhere from 140Kb to 600Kb in size, and it seems to be working according to spec. Thus, I don't think there are any serious bugs remaining.</p><p>If you are feeling brave, extensive debugging traces are available to figure out where assembly goes wrong.</p><p>Please report all bugs at http://rt.cpan.org/NoAuth/Bugs.html?Dist=Regexp-Assemble &lt;http://rt.cpan.org/NoAuth/Bugs.html?Dist=Regexp-Assemble&gt;</p><p>Make sure you include the output from the following two commands:</p><p>  perl -MRegexp::Assemble -le &apos;print $Regexp::Assemble::VERSION&apos;   perl -V</p><p>There is a mailing list for the discussion of \*(C`Regexp::Assemble\*(C'. Subscription details are available at http://listes.mongueurs.net/mailman/listinfo/regexp-assemble &lt;http://listes.mongueurs.net/mailman/listinfo/regexp-assemble&gt;.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ACKNOWLEDGEMENTS</h2>
        <div class="sectioncontent">
<p>This module grew out of work I did building access maps for Postfix, a modern \s-1SMTP\s0 mail transfer agent. See &lt;http://www.postfix.org/&gt; for more information. I used Perl to build large regular expressions for blocking dynamic/residential \s-1IP\s0 addresses to cut down on spam and viruses. Once I had the code running for this, it was easy to start adding stuff to block really blatant spam subject lines, bogus \s-1HELO\s0 strings, spammer mailer-ids and more...</p><p>I presented the work at the French Perl Workshop in 2004, and the thing most people asked was whether the underlying mechanism for assembling the REs was available as a module. At that time it was nothing more that a twisty maze of scripts, all different. The interest shown indicated that a module was called for. I'd like to thank the people who showed interest. Hey, it's going to make <em>my</em> messy scripts smaller, in any case.</p><p>Thomas Drugeon was a valuable sounding board for trying out early ideas. Jean Forget and Philippe Blayo looked over an early version. H.Merijn Brandt stopped over in Paris one evening, and discussed things over a few beers.</p><p>Nicholas Clark pointed out that while what this module does (?:c|sh)ould be done in perl's core, as per the 2004 \s-1TODO\s0, he encouraged me to continue with the development of this module. In any event, this module allows one to gauge the difficulty of undertaking the endeavour in C. I'd rather gouge my eyes out with a blunt pencil.</p><p>Paul Johnson settled the question as to whether this module should live in the Regex:: namespace, or Regexp:: namespace. If you're not convinced, try running the following one-liner:</p><p>  perl -le &apos;print ref qr//&apos;</p><p>Philippe Bruhat found a couple of corner cases where this module could produce incorrect results. Such feedback is invaluable, and only improves the module's quality.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>David Landgren</p><p>Copyright (C) 2004-2011. All rights reserved.</p><p>  http://www.landgren.net/perl/</p><p>If you use this module, I'd love to hear about what you're using it for. If you want to be informed of updates, send me a note.</p><p>You can look at the latest working copy in the following Subversion repository:</p><p>  http://svnweb.mongueurs.net/Regexp-Assemble</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LICENSE</h2>
        <div class="sectioncontent">
<p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="RefDB::SRUserver.3pm.html"><span aria-hidden="true">&larr;</span> RefDB::SRUserver.3pm: Lightweight sru server for refdb</a></li>
   <li class="next"><a href="Regexp::Common.3pm.html">Regexp::Common.3pm: Provide commonly requested regular expressions <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

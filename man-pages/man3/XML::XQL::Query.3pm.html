<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>XML::XQL::Query: Creates an xql query evaluater from a xql expression</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Creates an xql query evaluater from a xql expression">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="XML::XQL::Query (3pm) manual">
  <meta name="twitter:description" content="Creates an xql query evaluater from a xql expression">
  <meta name="twitter:image" content="https://www.carta.tech/images/libxml-xql-perl-XML::XQL::Query-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/XML::XQL::Query.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="XML::XQL::Query (3pm) manual" />
  <meta property="og:description" content="Creates an xql query evaluater from a xql expression" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libxml-xql-perl-XML::XQL::Query-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">XML::XQL::Query<small> (3pm)</small></h1>
        <p class="lead">Creates an xql query evaluater from a xql expression</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/XML::XQL::Query.3pm.html">
      <span itemprop="name">XML::XQL::Query: Creates an xql query evaluater from a xql expression</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libxml-xql-perl/">
      <span itemprop="name">libxml-xql-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/XML::XQL::Query.3pm.html">
      <span itemprop="name">XML::XQL::Query: Creates an xql query evaluater from a xql expression</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
 use XML::XQL;
 use XML::XQL::DOM;

 $parser = new XML::DOM::Parser;
 $doc = $parser-&gt;parsefile ("file.xml");

 # Return all elements with tagName=&apos;title&apos; under the root element &apos;book&apos;
 $query = new XML::XQL::Query (Expr =&gt; "book/title");
 @result = $query-&gt;solve ($doc);

 # Or (to save some typing)
 @result = XML::XQL::solve ("book/title", $doc);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>To perform \s-1XQL\s0 queries on an \s-1XML::DOM\s0 document (or, in the future, on other \s-1XML\s0 storage structures), you first have to create an XML::XQL::Query object and pass it a valid \s-1XQL\s0 query expression. You can then perform queries on one or more documents by calling the <em>solve()</em> method.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">XML::XQL::Query constructor</h2>
        <div class="sectioncontent">
<p>Usage, e.g:</p><p> $query = new XML::XQL::Query(         Expr =&gt; "book/author",         Func =&gt; [ myfunc =&gt; &#92;&my_func,          # define 2 functions                   myfunc2 =&gt; &#92;&my_func2 ],         FuncArgCount =&gt; [ myfunc2 =&gt; [2, -1] ], # myfunc2 has 2 or more args         AllowedOutSideSubquery =&gt; [ myfunc =&gt; 1 ],         ConstFunc =&gt; [ myfunc2 =&gt; 1],         CompareOper =&gt; [ mycmp =&gt; &#92;&mycmp ],    # define comparison operator         q =&gt; "str");                            # use str// as string delim</p>
<dl class='dl-vertical'>
  <dt>
    Expr =&gt; \s-1STRING\s0
  </dt>
  <dd>
    <p>The query expression to be evaluated.</p>
  </dd>
  <dt>
    NodeQuery =&gt; \s-1BOOLEAN\s0
  </dt>
  <dd>
    <p>If set to 1, the query is a <em>Node Query</em> as opposed to a <em>Full Query</em> (which is the default.) A node query is a query that is only capable of returning Nodes. A full query is capable of returning Node values and non-Node values. Non-Node values include \s-1XML\s0 Primitives, element type names, namespace \s-1URI\s0's, concatenated text nodes, and node type names. The distinction is significant because node queries may appear as \s-1XSL\s0 match and select patterns, while full queries have use in other applications. The difference between the two forms of queries is trivial and exists only as constraints on the syntax of node queries. Node queries may contain nested full queries.</p>
  </dd>
  <dt>
    Func =&gt; [ \s-1FUNCNAME\s0 =&gt; \s-1FUNCREF\s0, ...]
  </dt>
  <dd>
    <p>Defines one or more functions. \s-1FUNCNAME\s0 is the name as used in the query expression. \s-1FUNCREF\s0 can be either a function reference like &#92;&my_func or an anonymous sub. See also: defineFunction</p>
  </dd>
  <dt>
    Method =&gt; [ \s-1FUNCNAME\s0 =&gt; \s-1FUNCREF\s0, ...]
  </dt>
  <dd>
    <p>Defines one or more methods. \s-1FUNCNAME\s0 is the name as used in the query expression. \s-1FUNCREF\s0 can be either a function reference like &#92;&my_func or an anonymous sub. See also: defineMethod</p>
  </dd>
  <dt>
    FuncArgCount =&gt; [ \s-1FUNCNAME\s0 =&gt; \s-1ARGCOUNT\s0, ...]
  </dt>
  <dd>
    <p>Defines the number of arguments for one or more functions or methods. \s-1FUNCNAME\s0 is the name as used in the query expression. See also: defineFunction and defineMethod</p>
  </dd>
  <dt>
    AllowedOutsideSubquery =&gt; [ \s-1FUNCNAME\s0 =&gt; \s-1BOOLEAN\s0, ...]
  </dt>
  <dd>
    <p>Defines whether the specified function or method is allowed outside subqueries. \s-1FUNCNAME\s0 is the name as used in the query expression. See also: defineFunction and defineMethod</p>
  </dd>
  <dt>
    ConstFunc =&gt; [ \s-1FUNCNAME\s0 =&gt; \s-1BOOLEAN\s0, ...]
  </dt>
  <dd>
    <p>Defines whether the function (not method!) is a \*(L"constant\*(R" function. \s-1FUNCNAME\s0 is the name as used in the query expression. See \*(L"Constant Function Invocations\*(R" for a definition of \*(L"constant\*(R" See also: defineFunction and defineMethod</p>
  </dd>
  <dt>
    CompareOper =&gt; [ \s-1OPERNAME\s0 =&gt; \s-1FUNCREF\s0, ...]
  </dt>
  <dd>
    <p>Defines the comparison operator with the specified \s-1OPERNAME\s0, e.g. if \s-1OPERNAME\s0 is \*(L"contains\*(R", you can use \*(L"$contains$\*(R" in the query. See also: defineComparisonOperators</p>
  </dd>
  <dt>
    q =&gt; \s-1TOKEN\s0
  </dt>
  <dd>
    <p>Defines the q// token. See also: defineTokenQ</p>
  </dd>
  <dt>
    qq =&gt; \s-1TOKEN\s0
  </dt>
  <dd>
    <p>Defines the qq// token. See also: defineTokenQQ</p>
  </dd>
  <dt>
    Error =&gt; \s-1FUNCREF\s0
  </dt>
  <dd>
    <p>Defines the function that is called when errors occur during parsing the query expression. The default function prints an error message to \s-1STDERR\s0.</p>
  </dd>
  <dt>
    Debug =&gt; \s-1FLAGS\s0
  </dt>
  <dd>
    <p>Sets the debug level for the Yapp parser that parses the query expression. Default value is 0 (don't print anything). The maximum value is 0x17, which prints a lot of stuff. See the Parse::Yapp manpage for the meaning of the individual bits.</p>
  </dd>
  <dt>
    Reserved hash keys
  </dt>
  <dd>
    <p>Users may add their own (key, value) pairs to the Query constructor. Beware that the key 'Tree' is used internally.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">XML::XQL::Query methods</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    solve (\s-1INPUT_LIST\s0...)
  </dt>
  <dd>
    <p>Note that solve takes a list of nodes which are assumed to be in document order and must belong to the same document. E.g:  $query = new XML::XQL::Query (Expr =&gt; "doc//book");  @result = $query-&gt;solve ($doc);  @result2 = $query-&gt;solve ($node1, $node2, $node3);</p>
  </dd>

</dl>
<p>The following functions are also available at the query level, i.e. when called on a Query object they only affect this Query and no others:</p><p> defineFunction, defineMethod, defineComparisonOperators,  defineTokenQ, defineTokenQQ</p><p>See Global functions for details. Another way to define these features for a particular Query is by passing the appropriate values to the XML::XQL::Query constructor.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO XML::XQL::Query&hellip;</h2>
        <div class="sectioncontent">
<p>\s-1XML::XQL\s0 for general information about the \s-1XML::XQL\s0 module</p><p>XML::XQL::Tutorial which describes the \s-1XQL\s0 syntax</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="XML::XQL::Date.3pm.html"><span aria-hidden="true">&larr;</span> XML::XQL::Date.3pm: Adds an xql::node type for representing and comparing dates and times</a></li>
   <li class="next"><a href="XML::XQL::Tutorial.3pm.html">XML::XQL::Tutorial.3pm: Describes the xql query syntax <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

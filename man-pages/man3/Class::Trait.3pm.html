<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Class::Trait: Deprecated.  please use moose::role.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Deprecated.  please use moose::role.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Class::Trait (3pm) manual">
  <meta name="twitter:description" content="Deprecated.  please use moose::role.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libclass-trait-perl-Class::Trait-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Class::Trait.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Class::Trait (3pm) manual" />
  <meta property="og:description" content="Deprecated.  please use moose::role." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libclass-trait-perl-Class::Trait-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Class::Trait<small> (3pm)</small></h1>
        <p class="lead">Deprecated.  please use moose::role.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Class::Trait.3pm.html">
      <span itemprop="name">Class::Trait: Deprecated.  please use moose::role.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libclass-trait-perl/">
      <span itemprop="name">libclass-trait-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Class::Trait.3pm.html">
      <span itemprop="name">Class::Trait: Deprecated.  please use moose::role.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
    # to turn on debugging (do this before
    # any other traits are loaded)
    use Class::Trait &apos;debug&apos;;

    # nothing happens, but the module is loaded
    use Class::Trait;

    # loads these two traits and flatten them
    # into the current package
    use Class::Trait qw(TPrintable TComparable);

    # loading a trait and performing some
    # trait operations (alias, exclude) first
    use Class::Trait (
        &apos;TPrintable&apos; =&gt; {
            alias   =&gt; { "stringValue" =&gt; "strVal" },
            exclude =&gt; "stringValue",
         },
     );

    # loading two traits and performing
    # a trait operation (exclude) on one
    # module to avoid method conflicts
    use Class::Trait
        &apos;TComparable&apos; =&gt; {
            # exclude the basic equality method
            # from TComparable and use the ones
            # in TEquality instead.
            exclude =&gt; [ "notEqualTo", "equalTo" ]
        },
        &apos;TEquality&apos; # &lt;- use equalTo and notEqualTo from here
    );

    # when building a trait, you need it
    # to inherit from the trait meta/base-class
    # so do this ...
    use Class::Trait &apos;base&apos;;
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This document attempts to explain Traits in terms of Perl.</p><h3>Trait composition</h3>
<p>A Trait can be defined as a package containing:</p><ul>
<li><p>A set of methods</p></li><li><p>A hash of overloaded operators mapped to the method labels</p></li><li><p>An array of required method labels</p></li>
</ul><p>Here is an example of the syntax for a very basic trait:</p><p>    package TPrintable;</p><p>    use Class::Trait &apos;base&apos;;</p><p>    our @REQUIRES = qw(toString);</p><p>    our %OVERLOADS = (&apos;""&apos; =&gt; toString);</p><p>    sub stringValue {         my ($self) = @_;         require overload;         return overload::StrVal($self);     }</p><p>    1;</p><p>The above example requires the user of the trait to implement a \*(C`toString\*(C' method, which the overloaded "" operator then utilizes. The trait also provides a \*(C`stringValue\*(C' method to the consuming class.</p>
<h3>Trait usage</h3>
<p>When a class uses a Trait:</p><ul>
<li><p>Requirements All requirements of the traits (or composite trait) must be meet either by the class itself or by one of its base classes.</p></li><li><p>Flattening All the non-conflicting trait (or composite trait) methods are flattened into the class, meaning an entry is created directly in the class's symbol table and aliased to the original trait method.  Only methods defined in the trait are used.  Subroutines imported into the trait are not used.</p></li><li><p>Conflicts If a method label in a class conflicts with a method label in the trait (or composite trait), the class method is chosen and the trait method is discarded. This only applies to methods defined directly in the class's symbol table, methods inherited from a base class are overridden by the trait method.</p></li>
</ul><p>Here is a simple example of the usage of the above trait in a class.</p><p>    package MyClass;</p><p>    use Class::Trait (         &apos;TPrintable&apos; =&gt; {             alias   =&gt; { "strVal" =&gt; "stringValue" }             exclude =&gt; "stringValue",         }     );</p><p>    sub stringValue { ... }</p><p>The above example would use the \*(C`TPrintable\*(C' trait, aliasing \*(C`stringValue\*(C' to the method label \*(C`strVal\*(C', and then excluding \*(C`stringValue\*(C'. This is done to avoid a conflict with \*(C`stringValue\*(C' method implemented in the class that uses the trait.</p>
<h3>Trait operations</h3>
<p>When using a trait, the class can make changes to the structure of a trait through the following methods.</p><ul>
<li><p>Exclusion An array of method labels to exclude from trait.  If only a single method needs to be excluded, you may provide the method name without an array.</p></li><li><p>Alias A hash of old method labels to new method labels.</p></li><li><p>Summation A number of traits can be combined into one.</p></li>
</ul><p><em>Exclusion</em></p><p>This excludes a method from inclusion in the class which is using the trait. It does however cause the method to be added to the traits required methods. This is done because it is possible that other methods within the trait rely on the excluded method, and therefore it must be implemented somewhere in order for the other method to work.</p><p><em>Aliasing</em></p><p>Aliasing is not renaming or redefining, it does not remove the old method, but instead just introduces another label for that method. The old method label can be overridden or excluded without affecting the new method label.</p><p>One special note is that aliasing does move any entry in the overloaded operators to use the new method name, rather than the old method name. This is done since many times aliasing is used in conjunction with exclusion to pre-resolve conflicts. This avoids the orphaning of the operator.</p><p><em>Summation</em></p><p>When two or more traits are used by a class (or another trait), the traits are first compiled into a composite trait. The resulting composite trait is:</p><ul>
<li><p>Methods A union of all non-conflicting methods of all traits.</p></li><li><p>Operators A union of all non-conflicting operators of all traits.</p></li><li><p>Requirements A union of all unsatisfied requirements of all traits.</p></li>
</ul><p>Method conflicts</p><p>Method equality if determined by two conditions, the first being method label string equality, the second being the hex address of the code reference (found by stringifying the subroutine reference).</p><p>If a method in one of the traits is deemed to be in conflict with a method in another trait, the result is the exclusion of that method from the composite trait. The method label is then added to the requirements array for the composite trait.</p><p>Method conflict can be avoided by using exclusion or a combination of aliasing and exclusion.</p><p>Operator conflicts</p><p>Operator conflicts also result in the exclusion of the operator from the composite trait and the operator then becomes a requirement.</p><p>Requirement satisfaction</p><p>One trait may satisfy the requirements of another trait when they are combined into a composite trait. This results in the removal of the requirement from the requirements array in the composite trait.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RUNTIME TRAIT APPLICATION</h2>
        <div class="sectioncontent">
<p>As of \*(C`Class::Trait\*(C' version 0.20, you can now apply traits at runtime to both classes and instances by using the \*(C`apply()\*(C' method.  Applying a trait at runtime is similar to using the trait as a mixin because existing methods will be overwritten.</p><p>The syntax is:</p><p> Class::Trait-&gt;apply($class_or_instance, @list_of_traits);</p><h3>Classes</h3>
<p>Applying a trait at runtime to a class:</p><p> if ($secure) {     Class::Trait-&gt;apply($class_name, &apos;TSecureConnection&apos;);  }  else {     warn "Using insecure connections";     Class::Trait-&gt;apply($class_name, &apos;TInsecureConnection&apos;);  }</p><p>Now all instances of $class_name will have the methods provided by the trait applied.  If the trait applied at runtime provides methods already defined in $class_name, the $class_name methods will be silently redefined with the trait's methods.</p>
<h3>Instances</h3>
<p>Applying a trait at runtime to an instance:</p><p> if ($secure) {     Class::Trait-&gt;apply($instance, &apos;TSecureConnection&apos;);  }  else {     warn "Using insecure connections";     Class::Trait-&gt;apply($instance, &apos;TInsecureConnection&apos;);  }</p><p>When applying a trait (or set of traits) to an instance of a class, <strong>only</strong> that instance gets the new methods.  If you want numerous instances to receive the new methods, either apply the trait to all instances or consider applying it to the class.</p><p>Note that the instance is blessed into a new, anonymous class and it's this class which contains the new methods.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">WHEN TO USE TRAITS</h2>
        <div class="sectioncontent">
<p>For a relatively simple class heirarchy you may need traits.  There are, however, several key indicators that traits may be beneficial for you.</p><ul>
<li><p>Duplicated behavior Whenever you've duplicated behavior across unrelated classes.</p></li><li><p>Multiple inheritance Any time you might think about \s-1MI\s0 and it's only for code reuse (in other words, the subclass is not a more specific type of a super class)</p></li><li><p>Interfaces Any time you might want a Java-style interface but you also want an implementation to go with that.</p></li><li><p>Mixins Any time you might want to use mixins (have you ever considered exporting methods?)</p></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">
<ul>
<li><p><strong></strong><strong>$TRAITS</strong><strong></strong> While not really exported, Class::Trait leaves the actual Class::Trait::Config object applied to the package stored as scalar in the package variable at $TRAITS.</p></li><li><p><strong>does</strong> Class::Trait will export this method into any object which uses traits. By calling this method you can query the kind of traits the object has implemented. The method works much like the perl \*(C`isa\*(C' method in that it performs a depth-first search of the traits hierarchy and  returns true (1) if the object implements the trait, and false (0) otherwise.   $my_object_with_traits-&gt;does(&apos;TPrintable&apos;); Calling \*(C`does\*(C' without arguments will return all traits an ojbect does.</p></li><li><p><strong>is</strong> Class::Trait used to export this method to any object which uses traits, but it was found to conflict with Test::More::is. The recommended way is to use \*(C`does\*(C'. To use \*(C`is\*(C' instead of \*(C`does\*(C', one trait must use the following syntax for inheritance:  use Class::Trait qw/base is/; Instead of:  use Class::Trait &apos;base&apos;; It is recommended that all traits use this syntax if necessary as the mysterious \*(L"action at a distance\*(R" of renaming this method can be confusing. As an alternative, you can also simply use the following in any code which uses traits:  BEGIN {     require Class::Trait;     Class::Trait-&gt;rename_does(&apos;is&apos;);  } This is generally not recommended in test suites as <em>Test::More::is()</em> conflicts with this method.</p></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <strong>initialize</strong>
  </dt>
  <dd>
    <p>Class::Trait uses the \s-1INIT\s0 phase of the perl compiler, which will not run under mod_perl or if a package is loaded at runtime with \*(C`require\*(C'. In order to insure that all traits a properly verified, this method must be called. However, you may still use Class::Trait without doing this, for more details see the \s-1CAVEAT\s0 section.</p>
  </dd>
  <dt>
    <strong>rename_does</strong>
  </dt>
  <dd>
    <p>Note:  You probably do not want to use this method. Class::Trait uses \*(C`does()\*(C' to determine if a class can \*(L"do\*(R" a particular trait.  However, your package may already have a \*(C`does()\*(C' method defined or you may be migrating from an older version of Class::Trait which uses \*(C`is()\*(C' to perform this function.  To rename \*(C`does()\*(C' to something more suitable, you can use this at the top of your code:  BEGIN {     require Class::Trait; # we do not want to call import()     Class::Trait-&gt;rename_does($some_other_method_name);  }</p><p> use Class::Trait &apos;some_trait&apos;; If you wish to shield your users from seeing this, you can declare any trait with:  use Class::Trait qw/base performs/; # &apos;performs&apos; can be any valid method name You only need to do that in one trait and all traits will pick up the new method name.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TRAIT LIBRARY</h2>
        <div class="sectioncontent">
<p>I have moved some of the traits in the test suite to be used outside of this, and put them in what I am calling the trait library. This trait library will hopefully become a rich set of base level traits to use when composing your own traits. Currently there are the following pre-defined traits.</p><ul>
<li><p>TPrintable</p></li><li><p>TEquality</p></li><li><p>TComparable</p></li>
</ul><p>These can be loaded as normal traits would be loaded, Class::Trait will know where to find them. For more information about them, see their own documenation.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DEBUGGING</h2>
        <div class="sectioncontent">
<p>Class::Trait is really an experimental module. It is not ready yet to be used seriously in production systems. That said, about half of the code in this module is dedicated to formatting and printing out debug statements to \s-1STDERR\s0 when the debug flag is turned on.</p><p>  use Class::Trait &apos;debug&apos;;</p><p>The debug statements prints out pretty much every action taken during the traits compilation process and on occasion dump out <strong>Data::Dumper</strong> output of trait structures. If you are at all interested in traits or in this module, I recommend doing this, it will give you lots of insight as to what is going on behind the scences.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CAVEAT</h2>
        <div class="sectioncontent">
<p>This module uses the \s-1INIT\s0 phase of the perl compiler to do a final check of the of the traits. Mostly it checkes that the traits requirements are fufilled and that your class is safe to use. This presents a problem in two specific cases.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>Under mod_perl</strong>
  </dt>
  <dd>
    <p>mod_perl loads <strong>all</strong> code through some form of eval. It does this <em>after</em> the normal compilation phases are complete. This means we cannot run \s-1INIT\s0.</p>
  </dd>
  <dt>
    <strong>Runtime loading</strong>
  </dt>
  <dd>
    <p>If you load code with \*(C`require\*(C' or \*(C`eval "use Module"\*(C' the result is the same as with mod_perl. It is post-compilation, and the \s-1INIT\s0 phase cannot be run.</p>
  </dd>

</dl>
<p>However, this does not mean you cannot use Class::Trait in these two scenarios. Class::Trait will just not check its requirements, these routines will simply throw an error if called.</p><p>The best way to avoid this is to call the class method \*(C`initialize\*(C', after you have loaded all your classes which utilize traits, or after you specifically load a class with traits at runtime.</p><p>  Class::Trait-&gt;initialize();</p><p>This will result in the final checking over of your classes and traits, and throw an exception if there is a problem.</p><p>Some people may not object to this not-so-strict behavior, the smalltalk implementation of traits, written by the authors of the original papers behaves in a similar way. Here is a quote from a discussion I had with Nathanael Scharli, about the Smalltalk versions behavior:</p><p>    Well, in Squeak (as in the other Smalltalk dialects), the difference     between runtime and compile time is not as clear as in most other     programming languages. The reason for this is that programming in     Smalltalk is very interactive and there is no explicit compile phase.     This means that whenever a Smalltalk programmer adds or modifies a method,     it gets immediately (and automatically) compiled and installed in the     class. (Since Smalltalk is not statically typed, there are no type checks     performed at compile time, and this is why compiling a method simply means     creating and installing the byte-code of that method).</p><p>    However, I actually like if the programmer gets as much static information     bout the code as possible. Therefore, my implementation automaticelly     checks the open requirements whenever a method gets     added/removed/modified. This means that in my implementation, the     programmer gets interactive feedback about which requirements are still to     be satisfied while he is composing the traits together. In particular, I     also indicate when all the requirements of a class/trait are fulfilled. In     case of classes, this means for the programmer that it is now possible to     actually use the class without running into open requirements.</p><p>    However, according to the Smalltalk tradition, I do not prevent a     programmer from instantiating a class that still has open requirements.     (This can be useful if a programmer wants to test a certain functionality     of a class before it is actually complete). Of course, there is then     always the risk that there will be a runtime error because of an     unsatisfied requirement.</p><p>    As a summary, I would say that my implementation of traits keeps track of     the requirements at compile time. However, if an incomplete class (i.e., a     class with open requirements) is instantiated, unfulfilled requirements     result in a runtime error when they are called.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TO DO</h2>
        <div class="sectioncontent">
<p>I consider this implementation of Traits to be pretty much feature complete in terms of the description found in the papers. Of course improvements can always be made, below is a list of items on my to do list:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>Tests</strong>
  </dt>
  <dd>
    <p>I have revamped the test suite alot this time around. But it could always use more. Currently we have 158 tests in the suite. I ran it through Devel::Cover and found that the coverage is pretty good, but can use some help:  ---------------------------- ------ ------ ------ ------ ------ ------ ------  File                           stmt branch   cond    sub    pod   time  total  ---------------------------- ------ ------ ------ ------ ------ ------ ------  /Class/Trait.pm                91.4   58.6   50.0   95.7    6.2    8.9   80.0  /Class/Trait/Base.pm           90.5   50.0    n/a  100.0    n/a    0.1   83.9  /Class/Trait/Config.pm        100.0    n/a    n/a  100.0  100.0    2.9  100.0  ---------------------------- ------ ------ ------ ------ ------ ------ ------ Obviously Class::Trait::Config is fine. To start with Class::Trait::Reflection is not even tested at all. I am not totally happy with this \s-1API\s0 yet, so I am avoiding doing this for now. The pod coverage is really low in Class::Trait since virtually none of the methods are documented (as they are not public and have no need to be documented). The branch coverage is low too because of all the debug statements that are not getting execute (since we do not have \s-1DEBUG\s0 on). The branch coverage in Class::Trait::Base is somwhat difficult. Those are mostly rare error conditions and edge cases, none the less I would still like to test them. Mostly what remains that I would like to test is the error cases. I need to test that Class::Traits blows up in the places I expect it to.</p>
  </dd>
  <dt>
    <strong>Improve mod_perl/INIT phase solution</strong>
  </dt>
  <dd>
    <p>Currently the work around for the mod_perl/INIT phase issue (see \s-1CAVEAT\s0) is to just let the unfufilled requirement routines fail normally with perl. Maybe I am a control freak, but I would like to be able to make these unfufilled methods throw my own exceptions instead. My solution was to make a bunch of stub routines for all the requirements. The problem is that I get a bunch of \*(L"subroutine redeined\*(R" warnings coming up when the local method definitions are installed by perl normally. Also, since we are installing our methods and our overloads into the class in the \s-1BEGIN\s0 phase now, it is possible that we will get subroutine redefinition errors if there is a local implementation of a method or operator. This is somewhat rare, so I am not as concerned about that now. Ideally I would like to find a way around the \s-1INIT\s0 issue, which will still have the elegance of using \s-1INIT\s0.</p>
  </dd>
  <dt>
    <strong>Reflection \s-1API\s0</strong>
  </dt>
  <dd>
    <p>The class Class::Traits::Reflection gives a basic \s-1API\s0 to access to the traits used by a class. Improvements can be made to this \s-1API\s0 as well as the information it supplies.</p>
  </dd>
  <dt>
    <strong>Tools</strong>
  </dt>
  <dd>
    <p>Being a relatively new concept, Traits can be difficult to digest and understand. The original papers does a pretty good job, but even they stress the usefulness of tools to help in the development and understanding of Traits. The 'debug' setting of Class::Trait gives a glut of information on every step of the process, but is only useful to a point. A Traits 'browser' is something I have been toying with, both as a command line tool and a Tk based tool.</p>
  </dd>
  <dt>
    <strong>Trait Lib</strong>
  </dt>
  <dd>
    <p>In this release I have added some pre-built traits that can be used; TEquality, TComparable, TPrintable. I want to make more of these, it will only help.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PRIVATE METHODS IN TRAITS</h2>
        <div class="sectioncontent">
<p>Sometimes a trait will want to define private methods that only it can see. Any subroutine imported into the trait from outside of the trait will automatically be excluded.  However, a trait can define private methods by using anonymous subroutines.</p><p> package TSomeTrait;  use Class::Trait &apos;base&apos;;</p><p> my $private = sub { ... };</p><p> sub public {      my $self = shift;      my $data = $self-&gt;$private;      ...  }</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ACKNOWLEDGEMENTS</h2>
        <div class="sectioncontent">
<ul>
<li><p>Curtis \*(L"Ovid\*(R" Poe Initial idea and code for this module.</p></li><li><p>Nathanael Scharli and the Traits research group. Answering some of my questions.</p></li><li><p>Yuval Kogman Spotting the problem with loading traits with :: in them. Thanks to Curtis \*(L"Ovid\*(R" Poe for bringing it up again, and prompting me to release the fix.</p></li><li><p>Roman Daniel Fixing \s-1SUPER::\s0 handling.</p></li><li><p>Curtis \*(L"Ovid\*(R" Poe The code to change \*(C`is\*(C' to \*(C`does\*(C'.</p></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Class::Trait&hellip;</h2>
        <div class="sectioncontent">
<p>Class::Trait is an implementation of Traits as described in the the documents found on this site &lt;http://www.iam.unibe.ch/~scg/Research/Traits/&gt;. In particular the paper \*(L"Traits - A Formal Model\*(R", as well as another paper on statically-typed traits (which is found here : http://www.cs.uchicago.edu/research/publications/techreports/TR-2003-13 &lt;http://www.cs.uchicago.edu/research/publications/techreports/TR-2003-13&gt;).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ERROR MESSAGES</h2>
        <div class="sectioncontent">
<h3>Redefined subroutine warnings</h3>
<p>If a class using a trait has a method which the trait defines, the class's method is assumed to be the correct method.  However, you should get a \*(L"Subroutine redefined\*(R" warning.  To avoid this, explicitly exclude the method:</p><p> use Class::Trait TSomeTrait =&gt; { exclude =&gt; &apos;foo&apos; };</p><p> sub foo {}</p><p>Sometimes you will see strange warnings such as:</p><p> Subroutine Circle::(== redefined at /usr/lib/perl5/5.8.7/overload.pm at ...</p><p>This is because traits can support overloading.  To avoid this warning, define your overloaded methods prior to using Class::Trait.</p><p> use overload ( &apos;==&apos; =&gt; &#92;&equalTo );</p><p> use Class::Trait    "TCircle" =&gt; { exclude =&gt; &apos;equalTo&apos; },    "TColor"  =&gt; { exclude =&gt; &apos;equalTo&apos; };</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<h3>does</h3>
<p>When applying traits at runtime to instances, the following works:</p><p> $object-&gt;does($some_trait_name);</p><p>However, normally we should be able to do the following and get a list of all traits the instance does:</p><p> my @does = $object-&gt;does;</p><p>Currently, this returns no traits.  It will be fixed in a future release.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MAINTAINER</h2>
        <div class="sectioncontent">
<p>Curtis \*(L"Ovid\*(R" Poe, \*(C`&lt;ovid [at] cpan [dot] org&gt;\*(C'</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>stevan little, &lt;stevan@iinteractive.com&gt;</p><p>The development of this module was initially begun by Curtis \*(L"Ovid\*(R" Poe, &lt;poec@yahoo.com&gt;.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT AND LICENSE</h2>
        <div class="sectioncontent">
<p>Copyright 2004, 2005 by Infinity Interactive, Inc.</p><p>&lt;http://www.iinteractive.com&gt;</p><p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Class::Throwable.3pm.html"><span aria-hidden="true">&larr;</span> Class::Throwable.3pm: A minimal lightweight exception class</a></li>
   <li class="next"><a href="Class::Trait::Base.3pm.html">Class::Trait::Base.3pm: Base class for all traits <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

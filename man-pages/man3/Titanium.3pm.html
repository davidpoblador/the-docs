<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Titanium: A strong, lightweight web application framework</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="A strong, lightweight web application framework">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Titanium (3pm) manual">
  <meta name="twitter:description" content="A strong, lightweight web application framework">
  <meta name="twitter:image" content="https://www.carta.tech/images/libtitanium-perl-Titanium-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Titanium.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Titanium (3pm) manual" />
  <meta property="og:description" content="A strong, lightweight web application framework" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libtitanium-perl-Titanium-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Titanium<small> (3pm)</small></h1>
        <p class="lead">A strong, lightweight web application framework</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Titanium.3pm.html">
      <span itemprop="name">Titanium: A strong, lightweight web application framework</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libtitanium-perl/">
      <span itemprop="name">libtitanium-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Titanium.3pm.html">
      <span itemprop="name">Titanium: A strong, lightweight web application framework</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<h3>Coding</h3>

<pre>
  # In "WebApp.pm"...
  package WebApp;
  use base &apos;Titanium&apos;;

  sub setup {
        my $c = shift;

        $c-&gt;start_mode(&apos;form_display&apos;);
        $c-&gt;run_modes([qw/
        form_display
        form_process
        /]);
  }
  sub form_display {
        my $c = shift;
        my $errs = shift;

        my $t = $c-&gt;load_tmpl;
        $t-&gt;param($errs) if $errs;
        return $t-&gt;output;
  }
  sub form_process {
       my $c = shift;

       # Validate the form against a profile. If it fails validation, re-display
       # the form for the user with their data pre-filled and the errors highlighted.
       my ($results, $err_page) = $c-&gt;check_rm(&apos;form_display&apos;,&apos;_form_profile&apos;);
       return $err_page if $err_page;

       return $c-&gt;forward(&apos;form_success&apos;);
  }

  # Return a Data::FormValidator profile
  sub _form_profile {
    my $c = shift;
    return {
        required =&gt; &apos;email&apos;,
    };
  }

  sub form_success { ... }

  1;

  ### In "webapp.cgi"...
  use WebApp;
  my $c = WebApp-&gt;new();
  $c-&gt;run();
</pre>
<p>Inside the run modes, the following methods are available:</p><p>    $c-&gt;query;                               # A query object. CGI.pm by default.     $c-&gt;redirect(&apos;http://othersite.com&apos;);    # Basic redirection     $c-&gt;dbh;                                 # DBI database handle     $c-&gt;session();                           # A CGI::Session object     $c-&gt;check_rm;                            # Form validation with Data::FormValidator     $c-&gt;cfg(&apos;root_uri&apos;);                     # Config file access (YAML, Perl or INI formats)     $c-&gt;fill_form;                           # Form filling with HTML::FillInForm     $c-&gt;error( title =&gt; &apos;..&apos;, msg =&gt; &apos;..&apos; ); # Easy error page generation     $c-&gt;stream_file($file);                  # file streaming     $c-&gt;log;                                 # A Log::Dispatch object</p>
<h3>Development and Testing</h3>
<p>Easily setup the project skeleton using the bundled cgiapp-starter script.</p><p>In development you can turn on a debugging screen and a developer pop-up to quickly catch code, html and performance issues, thanks to CGI::Application::Plugin::DebugScreen and CGI::Application::Plugin::DevPopup.</p><p>For automated testing, Test::WWW::Mechanize::CGIApp is bundled, allowing you to functionally test your web application without involving a full web server. If you'd rather test against full web server, Test::WWW::Mechanize is there, too.</p>
<h3>Dispatching with Clean URIs</h3>
<p>Modern web frameworks dispense with cruft in URIs. Instead of:</p><p> /cgi-bin/item.cgi?rm=view&id=15</p><p>A clean \s-1URI\s0 to describe the same resource might be:</p><p> /item/15/view</p><p>The process of mapping these URIs to run modes is called dispatching and is handled by CGI::Application::Dispatch. It comes with a default dispatch table that automatically creates URLs in this pattern for you:</p><p> /app/module_name/run_mode</p><p>There's plenty of flexibility to design your own URIs if you'd like.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Elements of Titanium</h2>
        <div class="sectioncontent">
<p>* <strong>Titanium is solid and mature</strong>. While it has a new name, the reality is that Titanium is simply a more user-friendly packaging of the mature CGI::Application framework and some useful plugins. These packages have already been refined and vetted.  The seed framework was first released in 2000 and by 2005 was mature.  Titanium contains no real code of its own, and there is no intention to do so in the future. Instead, we may select other mature plugins to include in the future.  Other \*(L"Titanium alloys\*(R" in the \*(L"Titanium::Alloy::\*(R" name space may also come to exist, following the same philosophy, but choosing to bundle a different combination of plugins.</p><p>* <strong>Titanium is lightweight</strong>. Titanium has a very light core and the plugins it uses employ lazy-loading whenever possible. That means that while we have built-in database plugin, we don't have to load \s-1DBI\s0 or make a database connection until you actually use the database connection. Titanium runs well in a plain \s-1CGI\s0 environment and provides excellent performance in a persistent environment such as FastCGI or mod_perl. Titanium apps are compatible with the dozens of published plugins for CGI::Application, so you can add additional features as your needs evolve.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>It is intended that your Application Module will be implemented as a sub-class of Titanium. This is done simply as follows:</p><p>    package My::App;     use base &apos;Titanium&apos;;</p><p><strong>Notation and Conventions</strong></p><p>For the purpose of this document, we will refer to the following conventions:</p><p>  WebApp.pm  : The Perl module which implements your Application Module class.   WebApp     : Your Application Module class; a sub-class of Titanium.   webapp.cgi : The Instance Script which implements your Application Module.   $c         : Used in instance methods to pass around the                current object. (Sometimes referred as "$self" in other projects.)                Think of the "$c" as short for "controller".</p><h3>Script/Dispatching Methods</h3>
<p>By inheriting from Titanium you have access to a number of built-in methods. The following are those which are expected to be called from your Instance Script or through your CGI::Application::Dispatch dispatcher.</p><p><em></em><em>new()</em><em></em></p><p>The <em>new()</em> method is the constructor for a Titanium.  It returns a blessed reference to your Application Module class.  Optionally, <em>new()</em> may take a set of parameters as key =&gt; value pairs:</p><p>    my $c = WebApp-&gt;new(                 TMPL_PATH =&gt; &apos;App/&apos;,                 PARAMS =&gt; {                         &apos;custom_thing_1&apos; =&gt; &apos;some val&apos;,                         &apos;another_custom_thing&apos; =&gt; [qw/123 456/]                 }     );</p><p>This method may take some specific parameters:</p><p><strong>\s-1TMPL_PATH\s0</strong> - This optional parameter defines a path to a directory of templates. This is used by the <em>load_tmpl()</em> method (specified below), and may also be used for the same purpose by other template plugins.  This run-time parameter allows you to further encapsulate instantiating templates, providing potential for more re-usability.  It can be either a scalar or an array reference of multiple paths.</p><p><strong>\s-1QUERY\s0</strong> - This optional parameter allows you to specify an already-created \s-1CGI\s0 query object.  Under normal use, Titanium will instantiate its own \s-1CGI\s0.pm query object.  Under certain conditions, it might be useful to be able to use one which has already been created.</p><p><strong>\s-1PARAMS\s0</strong> - This parameter, if used, allows you to set a number of custom parameters at run-time.  By passing in different values in different instance scripts which use the same application module you can achieve a higher level of re-usability.  For instance, imagine an application module, \*(L"Mailform.pm\*(R".  The application takes the contents of a \s-1HTML\s0 form and emails it to a specified recipient. You could have multiple instance scripts throughout your site which all use this \*(L"Mailform.pm\*(R" module, but which set different recipients or different forms.</p><p>One common use of instance scripts is to provide a path to a config file.  This design allows you to define project wide configuration objects used by many several instance scripts. There are several plugins which simplify the syntax for this and provide lazy loading. Here's an example using CGI::Application::Plugin::ConfigAuto, which uses Config::Auto to support many configuration file formats.</p><p> my $app = WebApp-&gt;new(PARAMS =&gt; { cfg_file =&gt; &apos;config.pl&apos; });</p><p> # Later in your app:  my %cfg = $c-&gt;cfg()  # or ... $c-&gt;cfg(&apos;HTML_ROOT_DIR&apos;);</p><p>See the list of of plugins below for more config file integration solutions.</p><p><em></em><em>run()</em><em></em></p><p>The <em>run()</em> method is called upon your Application Module object, from your Instance Script.  When called, it executes the functionality in your Application Module.</p><p>    my $c = WebApp-&gt;new;     $c-&gt;run;</p><p>This method determines the application state by looking at the dispatch table, as described in CGI::Application::Dispatch.</p><p>Once the mode has been determined, <em>run()</em> looks at the hash stored in <em>run_modes()</em> and finds the subroutine which is tied to a specific hash key.  If found, the function is called and the data returned is <em>print()</em>'ed to \s-1STDOUT\s0 and to the browser.  If the specified mode is not found in the <em>run_modes()</em> table, <em>run()</em> will <em>croak()</em>. This 'death' can possibly be captured and handled using \*(C`error_mode()\*(C', described below.</p>
<h3>Essential Method to Override</h3>
<p>Titanium implements some methods which are expected to be overridden by implementing them in your sub-class module.  One of these is essential to do:</p><p><em></em><em>setup()</em><em></em></p><p>This method is called by the inherited <em>new()</em> constructor method.  The <em>setup()</em> method should be used to define the following property/methods:</p><p>    start_mode() - string containing the default run mode.     run_modes()  - hash table containing mode =&gt; function mappings.</p><p>    error_mode() - string containing the error mode.     tmpl_path()  - string or array reference containing path(s) to template directories.</p><p>Your <em>setup()</em> method may call any of the instance methods of your application. This function is a good place to define properties specific to your application via the $c-&gt;<em>param()</em> method.</p><p>Your <em>setup()</em> method might be implemented something like this:</p><p>        sub setup {                 my $c = shift;                 $c-&gt;start_mode(&apos;putform&apos;);                 $c-&gt;run_modes([qw/                 form                 form_process                 /]);         }</p>
<h3>Essential Application Methods</h3>
<p>The following methods are inherited from Titanium, and are available to be called by your application within your Application Module. They are called essential because you will use all are most of them to get any application up and running.  These functions are listed in alphabetical order.</p><p><em></em><em>load_tmpl()</em><em></em></p><p>    my $tmpl_obj = $c-&gt;load_tmpl;     my $tmpl_obj = $c-&gt;load_tmpl(&apos;some.html&apos;);     my $tmpl_obj = $c-&gt;load_tmpl( &#92;$template_content );     my $tmpl_obj = $c-&gt;load_tmpl( FILEHANDLE );</p><p>This method takes the name of a template file, a reference to template data or a \s-1FILEHANDLE\s0 and returns an HTML::Template object. If the filename is undefined or missing, Titanium will default to trying to use the current run mode name, plus the extension \*(L".html\*(R".</p><p>If you use the default template naming system, you should also use CGI::Application::Plugin::Forward, which simply helps to keep the current name accurate when you pass control from one run mode to another.</p><p>( For integration with other template systems and automated template names, see "Alternatives to <em>load_tmpl()</em> below. )</p><p>When you pass in a filename, the HTML::Template-&gt;<em>new_file()</em> constructor is used for create the object.  When you pass in a reference to the template content, the HTML::Template-&gt;<em>new_scalar_ref()</em> constructor is used and when you pass in a filehandle, the HTML::Template-&gt;<em>new_filehandle()</em> constructor is used.</p><p>Refer to HTML::Template for specific usage of HTML::Template.</p><p>If <em>tmpl_path()</em> has been specified, <em>load_tmpl()</em> will set the HTML::Template \*(C`path\*(C' option to the path(s) provided.  This further assists in encapsulating template usage.</p><p>The <em>load_tmpl()</em> method will pass any extra parameters sent to it directly to HTML::Template-&gt;<em>new_file()</em> (or <em>new_scalar_ref()</em> or <em>new_filehandle()</em>). This will allow the HTML::Template object to be further customized:</p><p>    my $tmpl_obj = $c-&gt;load_tmpl(&apos;some_other.html&apos;,          die_on_bad_params =&gt; 0,          cache =&gt; 1     );</p><p>Note that if you want to pass extra arguments but use the default template name, you still need to provide a name of \*(C`undef\*(C':</p><p>    my $tmpl_obj = $c-&gt;load_tmpl(undef&apos;,          die_on_bad_params =&gt; 0,          cache =&gt; 1     );</p><p><strong>Alternatives to </strong><strong>load_tmpl()</strong><strong></strong></p><p>If your application requires more specialized behavior than this, you can always replace it by overriding <em>load_tmpl()</em> by implementing your own <em>load_tmpl()</em> in your Titanium sub-class application module.</p><p>First, you may want to check out the template related plugins.</p><p>CGI::Application::Plugin::TT focuses just on Template Toolkit integration, and features pre-and-post features, singleton support and more.</p><p><em></em><em>param()</em><em></em></p><p>    $c-&gt;param(&apos;pname&apos;, $somevalue);</p><p>The <em>param()</em> method provides a facility through which you may set application instance properties which are accessible throughout your application.</p><p>The <em>param()</em> method may be used in two basic ways.  First, you may use it to get or set the value of a parameter:</p><p>    $c-&gt;param(&apos;scalar_param&apos;, &apos;123&apos;);     my $scalar_param_values = $c-&gt;param(&apos;some_param&apos;);</p><p>Second, when called in the context of an array, with no parameter name specified, <em>param()</em> returns an array containing all the parameters which currently exist:</p><p>    my @all_params = $c-&gt;param();</p><p>The <em>param()</em> method also allows you to set a bunch of parameters at once by passing in a hash (or hashref):</p><p>    $c-&gt;param(         &apos;key1&apos; =&gt; &apos;val1&apos;,         &apos;key2&apos; =&gt; &apos;val2&apos;,         &apos;key3&apos; =&gt; &apos;val3&apos;,     );</p><p>The <em>param()</em> method enables a very valuable system for customizing your applications on a per-instance basis.  One Application Module might be instantiated by different Instance Scripts.  Each Instance Script might set different values for a set of parameters.  This allows similar applications to share a common code-base, but behave differently.  For example, imagine a mail form application with a single Application Module, but multiple Instance Scripts.  Each Instance Script might specify a different recipient.  Another example would be a web bulletin boards system.  There could be multiple boards, each with a different topic and set of administrators.</p><p>The <em>new()</em> method provides a shortcut for specifying a number of run-time parameters at once.  Internally, Titanium calls the <em>param()</em> method to set these properties.  The <em>param()</em> method is a powerful tool for greatly increasing your application's re-usability.</p><p><em></em><em>query()</em><em></em></p><p>    my $q = $c-&gt;query();     my $remote_user = $q-&gt;remote_user();</p><p>This method retrieves the \s-1CGI\s0.pm query object which has been created by instantiating your Application Module.  For details on usage of this query object, refer to \s-1CGI\s0.  Titanium is built on the \s-1CGI\s0 module.  Generally speaking, you will want to become very familiar with \s-1CGI\s0.pm, as you will use the query object whenever you want to interact with form data.</p><p>When the <em>new()</em> method is called, a \s-1CGI\s0 query object is automatically created. If, for some reason, you want to use your own \s-1CGI\s0 query object, the <em>new()</em> method supports passing in your existing query object on construction using the \s-1QUERY\s0 attribute.</p><p><em></em><em>run_modes()</em><em></em></p><p>    # The common usage: an arrayref of run mode names that exactly match subroutine names     $c-&gt;run_modes([qw/         form_display         form_process     /]);</p><p>   # With a hashref, use a different name or a code ref    $c-&gt;run_modes(            &apos;mode1&apos; =&gt; &apos;some_sub_by_name&apos;,            &apos;mode2&apos; =&gt; &#92;&some_other_sub_by_ref     );</p><p>This accessor/mutator specifies a lookup table for the application states, using the syntax examples above. It returns the dispatch table as a hash.</p><p>The <em>run_modes()</em> method may be called more than once.  Additional values passed into <em>run_modes()</em> will be added to the run modes table.  In the case that an existing run mode is re-defined, the new value will override the existing value. This behavior might be useful for applications which are created via inheritance from another application, or some advanced application which modifies its own capabilities based on user input.</p><p>The <em>run()</em> method uses the data in this table to send the application to the correct function as determined by the dispatcher, as described in CGI::Application::Dispatch.  These functions are referred to as \*(L"run mode methods\*(R".</p><p>The hash table set by this method is expected to contain the mode name as a key.  The value should be either a hard reference (a subref) to the run mode method which you want to be called when the application enters the specified run mode, or the name of the run mode method to be called:</p><p>    &apos;mode_name_by_ref&apos;  =&gt; &#92;&mode_function     &apos;mode_name_by_name&apos; =&gt; &apos;mode_function&apos;</p><p>The run mode method specified is expected to return a block of text (e.g.: \s-1HTML\s0) which will eventually be sent back to the web browser.  The run mode method may return its block of text as a scalar or a scalar-ref.</p><p>An advantage of specifying your run mode methods by name instead of by reference is that you can more easily create derivative applications using inheritance.  For instance, if you have a new application which is exactly the same as an existing application with the exception of one run mode, you could simply inherit from that other application and override the run mode method which is different.  If you specified your run mode method by reference, your child class would still use the function from the parent class.</p><p>An advantage of specifying your run mode methods by reference instead of by name is performance.  Dereferencing a subref is faster than <em>eval()</em>-ing a code block.  If run-time performance is a critical issue, specify your run mode methods by reference and not by name.  The speed differences are generally small, however, so specifying by name is preferred.</p><p>Specifying the run modes by array reference:</p><p>    $c-&gt;run_modes([ &apos;mode1&apos;, &apos;mode2&apos;, &apos;mode3&apos; ]);</p><p>Is is the same as using a hash, with keys equal to values</p><p>    $c-&gt;run_modes(         &apos;mode1&apos; =&gt; &apos;mode1&apos;,         &apos;mode2&apos; =&gt; &apos;mode2&apos;,         &apos;mode3&apos; =&gt; &apos;mode3&apos;     );</p><p>Often, it makes good organizational sense to have your run modes map to methods of the same name.  The array-ref interface provides a shortcut to that behavior while reducing verbosity of your code.</p><p>Note that another importance of specifying your run modes in either a hash or array-ref is to assure that only those Perl methods which are specifically designated may be called via your application.  Application environments which don't specify allowed methods and disallow all others are insecure, potentially opening the door to allowing execution of arbitrary code.  Titanium maintains a strict \*(L"default-deny\*(R" stance on all method invocation, thereby allowing secure applications to be built upon it.</p><p><strong>\s-1IMPORTANT\s0 \s-1NOTE\s0 \s-1ABOUT\s0 \s-1RUN\s0 \s-1MODE\s0 \s-1METHODS\s0</strong></p><p>Your application should *NEVER* <em>print()</em> to \s-1STDOUT\s0. Using <em>print()</em> to send output to \s-1STDOUT\s0 (including \s-1HTTP\s0 headers) is exclusively the domain of the inherited <em>run()</em> method.  Breaking this rule is a common source of errors.  If your program is erroneously sending content before your \s-1HTTP\s0 header, you are probably breaking this rule.</p><p><strong>\s-1THE\s0 \s-1RUN\s0 \s-1MODE\s0 \s-1OF\s0 \s-1LAST\s0 \s-1RESORT:\s0 \*(L"\s-1AUTOLOAD\s0\*(R"</strong></p><p>If Titanium is asked to go to a run mode which doesn't exist, by default it will return an error page to the user, implemented like this:</p><p>  return $c-&gt;error(     title =&gt; &apos;The requested page was not found.&apos;,     msg =&gt; "(The page tried was: ".$c-&gt;get_current_runmode.")"   );</p><p>See CGI::Application::Plugin::ErrorPage for more details on the built-in error page system.  If this is not your desired behavior for handling unknown run mode requests, implement your own run mode with the reserved name \*(L"\s-1AUTOLOAD\s0\*(R":</p><p>  $c-&gt;run_modes(         "AUTOLOAD" =&gt; &#92;&catch_my_exception   );</p><p>Before Titanium invokes its own error page handling it will check for the existence of a run mode called \*(L"\s-1AUTOLOAD\s0\*(R".  If specified, this run mode will in invoked just like a regular run mode, with one exception:  It will receive, as an argument, the name of the run mode which invoked it:</p><p>  sub catch_my_exception {         my $c = shift;         my $intended_runmode = shift;</p><p>        my $output = "Looking for &apos;$intended_runmode&apos;, but found &apos;AUTOLOAD&apos; instead";         return $output;   }</p><p>This functionality could be for more sophisticated application behaviors.</p><p><em></em><em>start_mode()</em><em></em></p><p>    $c-&gt;start_mode(&apos;mode1&apos;);</p><p>The start_mode contains the name of the mode as specified in the <em>run_modes()</em> table.  Default mode is \*(L"start\*(R".  The mode key specified here will be used whenever the value of the \s-1CGI\s0 form parameter specified by <em>mode_param()</em> is not defined.  Generally, this is the first time your application is executed.</p><p><em></em><em>tmpl_path()</em><em></em></p><p>    $c-&gt;tmpl_path(&apos;/path/to/some/templates/&apos;);</p><p>This access/mutator method sets the file path to the directory (or directories) where the templates are stored.  It is used by <em>load_tmpl()</em> to find the template files, using HTML::Template's \*(C`path\*(C' option. To set the path you can either pass in a text scalar or an array reference of multiple paths.</p>
<h3>More Methods to override</h3>
<p>Several more non-essential methods are useful to declare in your application class, or in a project \*(L"super class\*(R" that inherits from your Titanium only to serve in turn as a base class for project modules. These additional methods are as follows:</p><p><em></em><em>teardown()</em><em></em></p><p>If implemented, this method is called automatically after your application runs.  It can be used to clean up after your operations.  A typical use of the <em>teardown()</em> function is to disconnect a database connection which was established in the <em>setup()</em> function, or flush open session data.  You could also use the <em>teardown()</em> method to store state information about the application to the server.</p><p><em></em><em>cgiapp_init()</em><em></em></p><p>If implemented, this method is called automatically right before the <em>setup()</em> method is called.  The <em>cgiapp_init()</em> method receives, as its parameters, all the arguments which were sent to the <em>new()</em> method.</p><p>An example of the benefits provided by utilizing this hook is creating a custom \*(L"application super-class\*(R" from which which all your web applications would inherit, instead of directly from Titanium.</p><p>Consider the following:</p><p>  # In MySuperclass.pm:   package MySuperclass;   use base &apos;Titanium&apos;;   sub cgiapp_init {         my $c = shift;         # Perform some project-specific init behavior         # such as to load settings from a database or file.   }</p><p>  # In MyApplication.pm:   package MyApplication;   use base &apos;MySuperclass&apos;;   sub setup { ... }   sub teardown { ... }   # The rest of your Titanium-based follows...</p><p>By using Titanium and the <em>cgiapp_init()</em> method as illustrated, a suite of applications could be designed to share certain characteristics, creating cleaner code.</p><p><em></em><em>cgiapp_prerun()</em><em></em></p><p>If implemented, this method is called automatically right before the selected run mode method is called.  This method provides an optional pre-runmode hook, which permits functionality to be added at the point right before the run mode method is called.  The value of the run mode is passed into <em>cgiapp_prerun()</em>.</p><p>This could be used by a custom \*(L"application super-class\*(R" from which all your web applications would inherit, instead of Titanium.</p><p>Consider the following:</p><p>  # In MySuperclass.pm:   package MySuperclass;   use base &apos;Titanium&apos;;   sub cgiapp_prerun {         my $c = shift;         # Perform some project-specific init behavior         # such as to implement run mode specific         # authorization functions.   }</p><p>  # In MyApplication.pm:   package MyApplication;   use base &apos;MySuperclass&apos;;   sub setup { ... }   sub teardown { ... }   # The rest of your Titanium-based follows...</p><p>It is also possible, within your <em>cgiapp_prerun()</em> method, to change the run mode of your application.  This can be done via the <em>prerun_mode()</em> method, which is discussed elsewhere.</p><p><em></em><em>cgiapp_postrun()</em><em></em></p><p>If implemented, this hook will be called after the run mode method has returned its output, but before \s-1HTTP\s0 headers are generated.  This will give you an opportunity to modify the body and headers before they are returned to the web browser.</p><p>A typical use for this hook is pipelining the output of a CGI-Application through a series of \*(L"filter\*(R" processors.  For example:</p><p>  * You want to enclose the output of all your CGI-Applications in     an HTML table in a larger page.</p><p>  * Your run modes return structured data (such as XML), which you     want to transform using a standard mechanism (such as XSLT).</p><p>  * You want to post-process CGI-App output through another system,     such as HTML::Mason.</p><p>  * You want to modify HTTP headers in a particular way across all     run modes, based on particular criteria.</p><p>The <em>cgiapp_postrun()</em> hook receives a reference to the output from your run mode method, in addition to the CGI-App object.  A typical <em>cgiapp_postrun()</em> method might be implemented as follows:</p><p>  sub cgiapp_postrun {     my $c = shift;     my $output_ref = shift;</p><p>    # Enclose output HTML table     my $new_output = "&lt;table border=1&gt;";     $new_output .= "&lt;tr&gt;&lt;td&gt; Hello, World! &lt;/td&gt;&lt;/tr&gt;";     $new_output .= "&lt;tr&gt;&lt;td&gt;". $$output_ref ."&lt;/td&gt;&lt;/tr&gt;";     $new_output .= "&lt;/table&gt;";</p><p>    # Replace old output with new output     $$output_ref = $new_output;   }</p><p>Obviously, with access to the CGI-App object you have full access to use all the methods normally available in a run mode.  You could, for example, use \*(C`load_tmpl()\*(C' to replace the static \s-1HTML\s0 in this example with HTML::Template.  You could change the \s-1HTTP\s0 headers (via \*(C`header_add()\*(C' ). You could also use the objects properties to apply changes only under certain circumstance, such as a in only certain run modes, and when a \*(C`param()\*(C' is a particular value.</p><p><em></em><em>cgiapp_get_query()</em><em></em></p><p> my $q = $c-&gt;cgiapp_get_query;</p><p>Override this method to retrieve the query object if you wish to use a different query interface instead of \s-1CGI\s0.pm.</p><p>\s-1CGI\s0.pm is only loaded to provided query object is only loaded if it used on a given request.</p><p>If you can use an alternative to \s-1CGI\s0.pm, it needs to have some compatibility with the \s-1CGI\s0.pm \s-1API\s0. For normal use, just having a compatible \*(C`param\*(C' method should be sufficient.</p><p>If use the \*(C`path_info\*(C' option to the <em>mode_param()</em> method, then we will call the \*(C`path_info()\*(C' method on the query object.</p><p>If you use the \*(C`Dump\*(C' method in Titanium, we will call the \*(C`Dump\*(C' and \*(C`escapeHTML\*(C' methods on the query object.</p>
<h3>More Application Methods</h3>
<p>You can skip this section if you are just getting started.</p><p>The following additional methods are inherited from Titanium, and are available to be called by your application within your Application Module. These functions are listed in alphabetical order.</p><p><em></em><em>error_mode()</em><em></em></p><p>    $c-&gt;error_mode(&apos;my_error_rm&apos;);</p><p>If the runmode dies for whatever reason, \*(C`run() will\*(C' see if you have set a value for \*(C`error_mode()\*(C'. If you have, \*(C`run()\*(C' will call that method as a run mode, passing $@ as the only parameter.</p><p>No \*(C`error_mode\*(C' is defined by default.  The death of your \*(C`error_mode()\*(C' run mode is not trapped, so you can also use it to die in your own special way.</p><p>For a complete integrated logging solution, check out CGI::Application::Plugin::LogDispatch.</p><p><em></em><em>header_add()</em><em></em></p><p>    # add or replace the &apos;type&apos; header     $c-&gt;header_add( -type =&gt; &apos;image/png&apos; );</p><p>    - or -</p><p>    # add an additional cookie     $c-&gt;header_add(-cookie=&gt;[$extra_cookie]);</p><p>The \*(C`header_add()\*(C' method is used to add one or more headers to the outgoing response headers.  The parameters will eventually be passed on to the \s-1CGI\s0.pm <em>header()</em> method, so refer to the \s-1CGI\s0 docs for exact usage details.</p><p>Unlike calling \*(C`header_props()\*(C', \*(C`header_add()\*(C' will preserve any existing headers. If a scalar value is passed to \*(C`header_add()\*(C' it will replace the existing value for that key.</p><p>If an array reference is passed as a value to \*(C`header_add()\*(C', values in that array ref will be appended to any existing values values for that key. This is primarily useful for setting an additional cookie after one has already been set.</p><p><em></em><em>header_props()</em><em></em></p><p>    $c-&gt;header_props(-type=&gt;&apos;image/gif&apos;,-expires=&gt;&apos;+3d&apos;);</p><p>The \*(C`header_props()\*(C' method expects a hash of \s-1CGI\s0.pm-compatible \s-1HTTP\s0 header properties.  These properties will be passed directly to \s-1CGI\s0.pm's \*(C`header()\*(C' or \*(C`redirect()\*(C' methods.  Refer to \s-1CGI\s0 for exact usage details.</p><p>Calling header_props any arguments will clobber any existing headers that have previously set.</p><p>\*(C`header_props()\*(C' return a hash of all the headers that have currently been set. It can be called with no arguments just to get the hash current headers back.</p><p>To add additional headers later without clobbering the old ones, see \*(C`header_add()\*(C'.</p><p><strong>\s-1IMPORTANT\s0 \s-1NOTE\s0 \s-1REGARDING\s0 \s-1HTTP\s0 \s-1HEADERS\s0</strong></p><p>It is through the \*(C`header_props()\*(C' and \*(C`header_add()\*(C' method that you may modify the outgoing \s-1HTTP\s0 headers.  This is necessary when you want to set a cookie, set the mime type to something other than \*(L"text/html\*(R", or perform a redirect.  Understanding this relationship is important if you wish to manipulate the \s-1HTTP\s0 header properly.</p><p><em></em><em>redirect()</em><em></em></p><p>  return $c-&gt;redirect(&apos;http://www.example.com/&apos;);</p><p>Redirect to another \s-1URL\s0.</p><p><em></em><em>forward()</em><em></em></p><p>  return $c-&gt;forward(&apos;rm_name&apos;);</p><p>Pass control to another run mode and return its output.  This is equivalent to calling $self-&gt;$other_runmode, except that the internal value of the current run mode is updated. This bookkeeping is important to <em>load_tmpl()</em> when called with no arguments and some other plugins.</p><p><em></em><em>dbh()</em><em></em></p><p>  sub cgiapp_init  {       my $c = shift;</p><p>      # use the same args as DBI-&gt;connect();       $c-&gt;dbh_config($data_source, $username, $auth, &#92;%attr);</p><p>  }</p><p> sub form_process {     my $c = shift;</p><p>    my $dbh = $c-&gt;dbh;  }</p><p>Easy access to a \s-1DBI\s0 database handle. The database connection is not created until the first call to \*(C`dbh()\*(C'. See CGI::Application::Plugin::DBH for more features and details.</p><p><em></em><em>session()</em><em></em></p><p> # in cgiapp_init()  $c-&gt;session_config(           CGI_SESSION_OPTIONS =&gt; [ "driver:PostgreSQL;serializer:Storable", $self-&gt;query, {Handle=&gt;$dbh} ],  );</p><p> # in a run mode  my $ses = $c-&gt;session-&gt;param(&apos;foo&apos;);</p><p>Easy access to a CGI::Session object, so you can store user data between requests. The session is not accessed or created until the first call to <em>session()</em> in a given request. See CGI::Application::Plugin::Session for more features and details.</p><p><em></em><em>cfg()</em><em></em></p><p>    $c-&gt;cfg(&apos;root_uri&apos;);</p><p>Easy access to parameters loaded from a config file, which can be stored in one of several formats, including \s-1YAML\s0 and Pure Perl. For more features and details see CGI::Application::Plugin::ConfigAuto.</p><p><em></em><em>log()</em><em></em></p><p>   $c-&gt;log-&gt;info(&apos;Information message&apos;);    $c-&gt;log-&gt;debug(&apos;Debug message&apos;);</p><p>Easy access to a Log::Dispatch logging object, allowing you to log to different locations with different locations of severity. By adjusting the logging level for your application, you make \*(L"debug\*(R" messages appear or disappear from your logs without making pervasive code changes. See CGI::Application::Plugin::LogDispatch for more features and details.</p><p><em></em><em>check_rm()</em><em></em></p><p>  my ($results, $err_page) = $c-&gt;check_rm(&apos;form_display&apos;,&apos;_form_profile&apos;);   return $err_page if $err_page;</p><p>Easy form validation with Data::FormValidator. If the validation fails, we'll re-display the form for the user with their data pre-filled and the errors highlighted. You'll have full control over the design of the errors with \s-1HTML\s0 and \s-1CSS\s0 in your templates, although we provide some intelligent defaults. See CGI::Application::Plugin::ValidateRM for features and details.</p><p><em></em><em>fill_form()</em><em></em></p><p> # fill an HTML form with data in a hashref or from an object with with a param() method  my $filled_html = $self-&gt;fill_form($html, $data);</p><p> # ...or default to getting data from $self-&gt;query()  my $filled_html = $self-&gt;fill_form($html);</p><p>HTML::FillInForm is a useful when you want to fill in a web form with default values from a database table. Like many \s-1CPAN\s0 modules, you can use directly from CGI::Application without any special plugin. The value of this plugin is that it defaults to finding values through $self-&gt;<em>query()</em>. Besides that, it is just a bit of synatic sugar that was mostly created work-around weaknesses in the HTML::FillInForm 1.x interface, which were fixed with HTML::FillInForm 2.0 release. See CGI::Application::Plugin::FillInForm for details.</p><p><em></em><em>error()</em><em></em></p><p>  $c-&gt;error( title =&gt; &apos;..&apos;, msg =&gt; &apos;..&apos; );</p><p>Provide quick error messages back to the user for exceptional cases. You can provide your own custom designed template or use the default one built-in.  See CGI::Application::Plugin::ErrorPage.</p><p><em></em><em>stream_file()</em><em></em></p><p> $c-&gt;stream_file($file);</p><p>If your run mode is outputing an image or a spreadsheet instead of an \s-1HTML\s0 page, you may want to stream the output. This method takes care of the boring details of buffering, headers and \s-1MIME\s0 types. See CGI::Application::Plugin::Stream for details.</p><p><em></em><em>prerun_mode()</em><em></em></p><p>    $c-&gt;prerun_mode(&apos;new_run_mode&apos;);</p><p>The <em>prerun_mode()</em> method is an accessor/mutator which can be used within your <em>cgiapp_prerun()</em> method to change the run mode which is about to be executed. For example, consider:</p><p>  # In WebApp.pm:   package WebApp;   use base &apos;Titanium&apos;;   sub cgiapp_prerun {         my $c = shift;</p><p>        # Get the web user name, if any         my $q = $c-&gt;query();         my $user = $q-&gt;remote_user();</p><p>        # Redirect to login, if necessary         unless ($user) {                 $c-&gt;prerun_mode(&apos;login&apos;);         }   }</p><p>In this example, the web user will be forced into the \*(L"login\*(R" run mode unless they have already logged in.  The <em>prerun_mode()</em> method permits a scalar text string to be set which overrides whatever the run mode would otherwise be.</p><p>The <em>prerun_mode()</em> method should be used in cases where you want to use Titanium's normal run mode switching facility, but you want to make selective changes to the mode under specific conditions.</p><p><strong>Note:</strong>  The <em>prerun_mode()</em> method may \s-1ONLY\s0 be called in the context of a <em>cgiapp_prerun()</em> method.  Your application will <em>die()</em> if you call <em>prerun_mode()</em> elsewhere, such as in <em>setup()</em> or a run mode method.</p>
<h3>Dispatching Clean URIs to run modes</h3>
<p>Modern web frameworks dispense with cruft in URIs, providing in clean URIs instead. Instead of:</p><p> /cgi-bin/item.cgi?rm=view&id=15</p><p>A clean \s-1URI\s0 to describe the same resource might be:</p><p> /item/15/view</p><p>The process of mapping these URIs to run modes is called dispatching and is handled by CGI::Application::Dispatch. Dispatching is not required and is a layer you can fairly easily add to an application later.</p>
<h3>Offline website development</h3>
<p>You can work on your Titanium project on your desktop or laptop without installing a full-featured web-server like Apache. Instead, install CGI::Application::Server from \s-1CPAN\s0. After a few minutes of setup, you'll have your own private application server up and running.</p>
<h3>Automated Testing</h3>
<p>There a couple of testing modules specifically made for Titanium.</p><p>Test::WWW::Mechanize::CGIApp allows functional testing of a CGI::App-based project without starting a web server. Test::WWW::Mechanize could be used to test the app through a real web server.</p><p>Test::WWW::Selenium is similar, but uses Selenium for the testing, meaning that a local web-browser would be used, allowing testing of websites that contain JavaScript.</p><p>Direct testing is also easy. Titanium will normally print the output of it's run modes directly to \s-1STDOUT\s0. This can be surprised with an environment variable, \s-1CGI_APP_RETURN_ONLY\s0. For example:</p><p>  $ENV{CGI_APP_RETURN_ONLY} = 1;   $output = $c-&gt;run;   like($output, qr/good/, "output is good");</p><p>Examples of this style can be seen in our own test suite.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PLUGINS</h2>
        <div class="sectioncontent">
<p>Titanium has a plug-in architecture that is easy to use and easy to develop new plug-ins for.  Plugins made for CGI::Application are directly compatible. The CGI::Application should be referenced for those who wish to write plugins.</p><p>Select plugins are listed below. For a current complete list, please consult \s-1CPAN:\s0</p><p>http://search.cpan.org/search?m=dist&q=CGI%2DApplication%2DPlugin</p><ul>
<li><p>CGI::Application::Plugin::Apache - Use Apache::* modules without interference</p></li><li><p>CGI::Application::Plugin::AutoRunmode - Automatically register runmodes</p></li><li><p>CGI::Application::Plugin::CompressGzip - Add Gzip compression</p></li><li><p>CGI::Application::Plugin::TT - Use Template::Toolkit as an alternative to HTML::Template.</p></li>
</ul><p>Consult each plug-in for the exact usage syntax.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COMMUNITY</h2>
        <div class="sectioncontent">
<p>Therese are primary resources available for those who wish to learn more about Titanium and discuss it with others.</p><p><strong>Wiki</strong></p><p>This is a community built and maintained resource that anyone is welcome to contribute to. It contains a number of articles of its own and links to many other Titanium related pages. It is currently branded as CGI::Application, but the code is the same.</p><p>http://www.cgi-app.org &lt;http://www.cgi-app.org&gt;</p><p><strong>Support Mailing List</strong></p><p>If you have any questions, comments, bug reports or feature suggestions, post them to the support mailing list!  To join the mailing list, simply send a blank message to \*(L"cgiapp-subscribe@lists.erlbaum.net\*(R".</p><p><strong>\s-1IRC\s0</strong></p><p>You can also drop by \*(C`#cgiapp\*(C' on \*(C`irc.perl.org\*(C' with a good chance of finding some people involved with the project there.</p><p><strong>Source Code</strong></p><p>This project is managed using the darcs source control system ( http://www.darcs.net/ ). The darcs archive is here: http://mark.stosberg.com/darcs_hive/titanium</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TODO</h2>
        <div class="sectioncontent">
<p>* I would like Titanium to be easier to install and get started with.  Rather than depending on the large \s-1CPAN\s0 dependency chain being installed, I would like an option for users to download the full stack of dependencies, so that you can just unpack a single file and go.</p><p>* I'd like a plugin to cope with the URI-encoding that Dreamweaver does to templates that may just mean packing and releasing the following code as a plug-in:</p><p>  CGI::Application-&gt;add_callback(&apos;load_tmpl&apos;,sub {         my ($c, $ht_params, $tmpl_params, $tmpl_file) = @_;</p><p>        require HTML::Template::Filter::URIdecode;         import HTML::Template::Filter::URIdecode &apos;ht_uri_decode&apos;;</p><p>        # If you already have a filter defined, don&apos;t do anything.         # If you want to add more of your own filters later, be mindful         # about whether you add to this arrayref, or replace it.         unless ($ht_params-&gt;{filter}) {                 $ht_params-&gt;{filter} = [&#92;&ht_uri_decode]         }   });</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Titanium&hellip;</h2>
        <div class="sectioncontent">
<ul>
<li><p>CGI::Application</p></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MORE READING</h2>
        <div class="sectioncontent">
<p>If you're interested in finding out more about Titanium, the following articles are available on Perl.com, providing context about the underlying CGI::Application framework</p><p>    Using CGI::Application     http://www.perl.com/pub/a/2001/06/05/cgi.html</p><p>    Rapid Website Development with CGI::Application     http://www.perl.com/pub/a/2006/10/19/cgi_application.html</p><p>Thanks to O'Reilly for publishing these articles, and for the incredible value they provide to the Perl community!</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p>Many.</p><p>Mark Stosberg, \*(C`mark@summersault.com\*(C' published the original Titanium module, while many another contributed to CGI::Application and the related plugins.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LICENSE</h2>
        <div class="sectioncontent">
<p>Copyright (C) 2008, Mark Stosberg.</p><p>This module is free software; you can redistribute it and/or modify it under the terms of either:</p><p>a) the \s-1GNU\s0 General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version,</p><p>or</p><p>b) the \*(L"Artistic License\*(R".</p><p>This program is distributed in the hope that it will be useful, but \s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of \s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.  See either the \s-1GNU\s0 General Public License or the Artistic License for more details.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Time::Stopwatch.3pm.html"><span aria-hidden="true">&larr;</span> Time::Stopwatch.3pm: Use tied scalars as timers</a></li>
   <li class="next"><a href="Tk::DirSelect.3pm.html">Tk::DirSelect.3pm: Cross-platform directory selection widget. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

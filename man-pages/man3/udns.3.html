<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>udns: Stub dns resolver library</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Stub dns resolver library">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="udns (3) manual">
  <meta name="twitter:description" content="Stub dns resolver library">
  <meta name="twitter:image" content="https://www.carta.tech/images/libudns-dev-udns-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/udns.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="udns (3) manual" />
  <meta property="og:description" content="Stub dns resolver library" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libudns-dev-udns-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">udns<small> (3)</small></h1>
        <p class="lead">Stub dns resolver library</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/udns.3.html">
      <span itemprop="name">udns: Stub dns resolver library</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libudns-dev/">
      <span itemprop="name">libudns-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/udns.3.html">
      <span itemprop="name">udns: Stub dns resolver library</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSYS</h2>
        <div class="sectioncontent">

<pre>
#include &lt;udns.h&gt;
struct <strong>dns_ctx</strong>;
struct <strong>dns_query</strong>;
extern struct dns_ctx <strong>dns_defctx</strong>;
struct dns_ctx *<em>ctx</em>;
typedef void <strong>dns_query_fn</strong>(<em>ctx</em>, void *<em>result</em>, void *<em>data</em>);
typedef int
<strong>dns_parse_fn</strong>(const unsigned char *<em>qnd</em>,
       const unsigned char *<em>pkt</em>,
       const unsigned char *<em>cur</em>,
       const unsigned char *<em>end</em>,
       void **<em>resultp</em>);

<strong>cc</strong> ... -l<strong>udns</strong>
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The DNS library, <strong>udns</strong>, implements thread-safe stub DNS resolver functionality, which may be used both traditional, syncronous way and asyncronously, with application-supplied event loop.</p><p>While DNS works with both TCP and UDP, performing UDP query first and if the result does not fit in UDP buffer (512 bytes max for original DNS protocol), retrying the query over TCP, the library uses UDP only, but uses EDNS0 (RFC2671) extensions which allows larger UDP buffers.</p><p>The library uses single UDP socket to perform all operations even when asking multiple nameservers.  This way, it is very simple to use the library in asyncronous event-loop applications: an application should add only single socket to the set of filedescriptors it monitors for I/O.</p><p>The library uses two main objects, <em>resolver context</em> of type <strong>struct&nbsp;dns_ctx</strong>, and <em>query structure</em> of type <strong>struct&nbsp;dns_query</strong>, both are opaque for an application. Resolver context holds global information about the resolver, such as list of nameservers to use, list of active requests and the like. Query objects holds information about a single DNS query in progress and are allocated/processed/freed by the library.   Pointer to query structure may be treated as an identifier of an in-progress query and may be used to cancel the asyncronous query or to wait for it to complete.</p><p>Asyncronous interface works as follows.  An application initializes resolver context, submits any number of queries for it using one of supplied <strong>dns_submit_</strong><em>XXX</em>() routines (each return the query identifier as pointer to query structure), waits for input on the UDP socket used by the library, and gives some control to the library by calling <strong>dns_ioevent</strong>() and <strong>dns_timeouts</strong>() routines when appropriate.  The library performs all necessary processing and executes application supplied callback routine when a query completes (either successefully or not), giving it the result if any, pointer to the resolver context (from which completion status may be obtained), and the data pointer supplied by an application when the query has been submitted.  When submitting a query, an application requests how to handle the reply -- to either return raw DNS reply packet for its own low-level processing, or it may provide an address of <em>parsing</em> routine of type <strong>dns_parse_fn</strong> to perform conversion of on-wire format into easy to use data structure (the library provides parsing routines for several commonly used resource record types, as well as type-safe higher-level inteface that requests parsing automatically). The I/O monitoring and timeout handling may be either traditional select() or poll() based, or any callback-driven technique may be used.</p><p>Additionally, the library provides traditional syncronous interface, which may be intermixed with asyncronous calls (during syncronous query processing, other asyncronous queries for the same resolver context continued to be processed as usual).  An application uses one of numerous <strong>dns_resolve_</strong><em>XXX</em>() routines provided by the library to perform a query.  As with asyncronous interface, an application may either request to return raw DNS packet or type-specific data structure by providing the parsing routine to handle the reply. Every routine from <strong>dns_resolve_</strong><em>XXX</em>() series return pointer to result or NULL in case of any error.  Query completion status (or length of the raw DNS packet) is available from the resolver context using <strong>dns_status</strong>() routine, the same way as for the asyncronous interface.</p><p>Internally, library uses on-wire format of domain names, referred to as <em>DN format</em> in this manual page.  This is a series of domain <em>labels</em> whith preceeding length byte, terminated by zero-length label wich is integral part of the DN format.  There are several routines provided to convert from traditional asciiz string to DN and back. Higher-level type-specific query interface hides the DN format from an application.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COMMON DEFINITIONS</h2>
        <div class="sectioncontent">
<p>Every DNS Resource Record (RR) has a <em>type</em> and a <em>class</em>. The library defines several integer constants, <strong>DNS_C_</strong><em>XXX</em> and <strong>DNS_T_</strong><em>XXX</em>, to use as symbolic names for RR classes and types, such as <strong>DNS_C_IN</strong> for Internet class, <strong>DNS_T_A</strong> for IPv4 address record type and so on.  See udns.h header file for complete list of all such constants.</p><p>The following constants are defined in udns.h header file:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>DNS_MAXDN</strong> (255 bytes)
  </dt>
  <dd>
    <p>Maximum length of the domain name in internal (on-wire) DN format.</p>
  </dd>
  <dt>
    <strong>DNS_MAXLABEL</strong> (63 bytes)
  </dt>
  <dd>
    <p>Maximum length of a single label in DN format.</p>
  </dd>
  <dt>
    <strong>DNS_MAXNAME</strong> (1024 bytes)
  </dt>
  <dd>
    <p>Maximum length of asciiz format of a domain name.</p>
  </dd>
  <dt>
    <strong>DNS_HSIZE</strong> (12 bytes)
  </dt>
  <dd>
    <p>Size of header in DNS packet.</p>
  </dd>
  <dt>
    <strong>DNS_PORT</strong> (53)
  </dt>
  <dd>
    <p>Default port to use when contacting a DNS server.</p>
  </dd>
  <dt>
    <strong>DNS_MAXSERV</strong> (6 servers)
  </dt>
  <dd>
    <p>Maximum number of DNS servers to use.</p>
  </dd>
  <dt>
    <strong>DNS_MAXPACKET</strong> (512 bytes)
  </dt>
  <dd>
    <p>Maximum length of DNS UDP packet as specified by original DNS protocol</p>
  </dd>
  <dt>
    <strong>DNS_EDNS0PACKET</strong> (4096 bytes)
  </dt>
  <dd>
    <p>Default length of DNS UDP packet (with EDNS0 extensions) the library uses. Note that recursive nameservers usually resides near the client asking them to resolve names, e.g. on the same LAN segment or even on the same host, so UDP packet fragmentation isn't a problem in most cases.  Note also that the size of actual packets will be as many bytes as actual reply size requires, which is smaller than this value in almost all cases.</p>
  </dd>

</dl>
<p>Additionally, several constants are defined to simplify work with raw DNS packets, such as DNS response codes (<strong>DNS_R_</strong><em>XXX</em>), DNS header layout (<strong>DNS_H_</strong><em>XXX</em>) and others.  Again, see udns.h for complete list. Library error codes (<strong>DNS_E_</strong><em>XXX</em>) are described later in this manual page.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RESOLVER CONTEXT</h2>
        <div class="sectioncontent">
<p>Resolver context, of type <strong>struct&nbsp;dns_ctx</strong>, is an object which is opaque to an application.  Several routines provided by the library to initialize, copy and free resolver contexts.  Most other high-level routines in this library expects a pointer to resolver context, <em>ctx</em>, as the first argument.  There is a default resolver context available, named <strong>dns_defctx</strong>.  When the context pointer <em>ctx</em> passed to a routine is NULL, <strong>dns_defctx</strong> is used.  Several resolver contexts may be active at the same time, for example, when an application is multi-threaded and each thread uses resolver.</p><p>In order to use the library, an application should initialize and open one or more resolver context objects.  These are two separate actions, performed by <strong>dns_init</strong>() (or <strong>dns_reset</strong>()), and <strong>dns_open</strong>(). Between the two calls, an application is free to pefrorm additional initialisation, such as setting custom nameservers, options or domain search lists.  Optionally, in case no additional custom initialisation is required, <strong>dns_init</strong>() may open the context if <em>do_open</em> argument (see below) is non-zero.</p><p>When initializing resolver context, the library uses information from system file /etc/resolv.conf (see <a href="../man5/resolv.conf.5.html"><strong>resolv.conf</strong>(5)</a>), consults environment variables <strong>$LOCALDOMAIN</strong>, <strong>$NSCACHEIP</strong>, <strong>$NAMESERVERS</strong> and <strong>$RES_OPTIONS</strong>, and local host name to obtain list of local nameservers, domain name search list and various resolver options.</p><p>The following routines to initialize resolver context are available:</p>
<pre>
void <strong>dns_reset</strong>(<em>ctx</em>)
int <strong>dns_init</strong>(<em>ctx</em>, int <em>do_open</em>)
</pre>
<p><strong>dns_reset</strong>() resets a given resolver context to default values, preparing it to be opened by <strong>dns_open</strong>(). It is ok to call this routine against opened and active context - all active queries will be dropped, sockets will be closed and so on.  This routine does not initialize any parameters from system configuration files, use <strong>dns_init</strong>() for this.  There's no error return - operation always succeeds.  <strong>dns_init</strong>() does everything <strong>dns_reset</strong>() does, plus initializes various parameters of the context according to system configuration and process environment variables.  If <em>do_open</em> is non-zero, <strong>dns_init</strong>() calls <em>dns_open</em>(), so that the whole library initialisation is performed in a single step.</p>
<pre>
struct dns_ctx *<strong>dns_new</strong>(struct dns_ctx *<em>copy</em>)
void <strong>dns_free</strong>(<em>ctx</em>)
</pre>
<p><strong>dns_new</strong>() allocates new resolver context and copies all parameters for a given resolver context <em>copy</em>, or default context if <em>copy</em> is NULL, and returns pointer to the newly allocated context.  The context being copied should be initialized. <strong>dns_new</strong>() may fail if there's no memory available to make a copy of <em>copy</em>, in which case the routine will return NULL pointer. <strong>dns_free</strong>() is used to close assotiated socket and free resolver context resources and cancelling (abandoming) all active queries assotiated with it.  It's an error to free <strong>dns_defctx</strong>, only dynamically allocated contexts returned by <strong>dns_new</strong>() are allowed to be freed by <strong>dns_free</strong>().</p>
<pre>
int <strong>dns_add_serv</strong>(<em>ctx</em>, const char *<em>servaddr</em>)
int <strong>dns_add_serv_s</strong>(<em>ctx</em>, const struct sockaddr *<em>sa</em>)
int <strong>dns_add_srch</strong>(<em>ctx</em>, const char *<em>srch</em>)
</pre>
<p>Add an element to list of nameservers (<strong>dns_add_serv</strong>(), as asciiz-string <em>servaddr</em> with an IP address of the nameserver, and <strong>dns_add_serv_s</strong>(), as initialized socket address <em>sa</em>), or search list (<strong>dns_add_srch</strong>(), as a pointer to domain name) for the given context <em>ctx</em>.  If the last argument is a NULL pointer, the corresponding list (search or nameserver) is reset instead.  Upon successeful completion, each routine returns new number of elements in the list in question.  On error, negative value is returned and global variable <strong>errno</strong> is set appropriately. It is an error to call any of this functions if the context is opened (after <strong>dns_open</strong>() or <strong>dns_init</strong>() with non-zero argument).</p>
<pre>
int <strong>dns_set_opts</strong>(<em>ctx</em>, const char *<em>opts</em>)
</pre>
<p>set resolver context options from <em>opts</em> string, in the same way as processing <strong>options</strong> statement in resolv.conf and <strong>$RES_OPTIONS</strong> environment variable.  Return number of unrecognized/invalid options found (all recognized and valid options gets processed).</p>
<pre>
void <strong>dns_set_opt</strong>(<em>ctx</em>, int <em>opt</em>, <em>val</em>)
</pre>
<p><strong>TODO</strong> The <em>flags</em> argument is a bitmask with the following bits defined:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>DNS_NOSRCH</strong>
  </dt>
  <dd>
    <p>do not perform domain name search in search list.</p>
  </dd>
  <dt>
    <strong>DNS_NORD</strong>
  </dt>
  <dd>
    <p>do not request recursion when performing queries (i.e. don't set RD flag in querues).</p>
  </dd>
  <dt>
    <strong>DNS_AAONLY</strong>
  </dt>
  <dd>
    <p>request authoritative answers only (i.e. set AA flag in queries).</p>
  </dd>

</dl>

<pre>
int <strong>dns_open</strong>(<em>ctx</em>)
int <strong>dns_sock</strong>(const <em>ctx</em>)
void <strong>dns_close</strong>(<em>ctx</em>)
</pre>
<p><strong>dns_open</strong>() opens the UDP socket used for queries if not already open, and return assotiated filedescriptor (or negative value in case of error).  Before any query can be submitted, the context should be opened using this routine.  And before opening, the context should be initialized. <strong>dns_sock</strong>() return the UDP socket if open, or -1 if not. <strong>dns_close</strong>() closes the UDP socket if it was open, and drops all active queries if any.</p>
<pre>
int <strong>dns_active</strong>(const <em>ctx</em>)
</pre>
<p>return number of active queries queued for the given context <em>ctx</em>, or zero if none.</p>
<pre>
int <strong>dns_status</strong>(const <em>ctx</em>)
</pre>
<p>return status code from last operation.  When using syncronous interface, this is the query completion status of the last query. With asyncronous interface, from within the callback routine, this is the query completion status of the query for which the callback is being called.  When query submission fails, this is the error code indicating failure reason.  All error codes are negative and are represented by <strong>DNS_E_</strong><em>XXX</em> constants described below.</p>
<pre>
void <strong>dns_ioevent</strong>(<em>ctx</em>, time_t <em>now</em>)
</pre>
<p>this routine may be called by an application to process I/O events on the UDP socket used by the library, as returned by <strong>dns_sock</strong>().  The routine tries to receive incoming UDP datagram from the socket and process it.  The socket is set up to be non-blocking, so it is safe to call the routine even if there's no data to read.  The routine will process as many datagrams as are queued for the socket, so it is safe to use it with either level-triggered or edge-triggered I/O monitoring model.  The <em>now</em> argument is either a current time as returned by <strong>time</strong>(), or 0, in which case the routine will obtain current time by it's own.</p>
<pre>
int <strong>dns_timeouts</strong>(<em>ctx</em>, int <em>maxwait</em>, time_t <em>now</em>)
</pre>
<p>process any pending timeouts and return number of secounds from current time (<em>now</em> if it is not 0) to the time when the library wants the application to pass it control to process more queued requests.  In case when there are no requests pending, this time is -1.  The routine will not request a time larger than <em>maxwait</em> secounds if it is greather or equal to zero.  If <em>now</em> is 0, the routine will obtain current time by it's own; when it is not 0, it should contain current time as returned by <strong>time</strong>().</p>
<pre>
typedef void <strong>dns_utm_fn</strong>(<em>ctx</em>, int <em>timeout</em>, void *<em>data</em>)
void <strong>dns_set_tmcbck</strong>(<em>ctx</em>, dns_utm_fn *<em>utmfn</em>, void *<em>data</em>)
</pre>
<p>An application may use custom callback-based I/O multiplexing mechanism. Usually such a mechanism have concept of a <em>timer</em>, and an ability to register a timer event in a form of a callback routine which will be executed after certain amount of time.  In order to use such an event mechanism, udns provides an ability to register and de-register timer events necessary for internal processing using whatever event mechanism an application uses.  For this to work, it is possible to assotiate a pointer to a routine that will perform necessary work for (de)registering timer events with a given resolver context, and udns will call that routine at appropriate times.  Prototype of such a routine is shown by <strong>dns_utm_fn</strong> typedef above.  Libudns assotiates single timer with resolver context.  User-supplied <em>utmfn</em> routine will be called by the library with the following arguments:</p>
<dl class='dl-vertical'>
  <dt>
    <em>ctx</em> == NULL
  </dt>
  <dd>
    <p>delete user timer, at context free time or when an application changes user timer request routine using <strong>dns_set_tmcbck</strong>();</p>
  </dd>
  <dt>
    <em>ctx</em> != NULL, <em>timeout</em> &lt; 0
  </dt>
  <dd>
    <p>don't fire timer anymore, when there are no active requests;</p>
  </dd>
  <dt>
    <em>ctx</em> != NULL, <em>timeout</em> == 0
  </dt>
  <dd>
    <p>fire timer at the next possibility, but not immediately;</p>
  </dd>
  <dt>
    <em>ctx</em> != NULL, <em>timeout</em> &gt; 0
  </dt>
  <dd>
    <p>fire timer after <em>timeout</em> seconds after now.</p>
  </dd>

</dl>
<p>The <em>data</em> argument passed to the routine will be the same as passed to <strong>dns_set_tmcbck</strong>().</p><p>When a timer expires, an application should call <strong>dns_timeouts</strong>() routine (see below).  Non-callback timer usage is provided too.</p><p><strong>XXXX TODO: some more resolver context routines, like dns_set_dbgfn() etc.</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">QUERY INTERFACE</h2>
        <div class="sectioncontent">
<p>There are two ways to perform DNS queries: traditional syncronous way, when udns performs all the necessary processing and return control to the application only when the query completes, and asyncronous way, when an application submits one or more queries to the library using given resolver context, and waits for completion by monitoring filedescriptor used by library and calling library routines to process input on that filedescriptor.  Asyncronous mode works with callback routines: an application supplies an address of a routine to execute when the query completes, and a data pointer, which is passed to the callback routine.</p><p>Queries are submitted to the library in a form of <strong>struct&nbsp;dns_query</strong>. To perform asyncronous query, an application calls one of the <strong>dns_submit_</strong><em>XXX</em>() rounines, and provides necessary information for a callback, together with all the query parameters. When the query completes, library will call application-supplied callback routine, giving it the resolver context (wich holds query completion status), dynamically allocated result (which will be either raw DNS packet or, if applicatin requested parsing the result by specifying non-NULL parse routine, ready-to-use type-specific structure), and a data pointer provided by an application when it submitted the query.  It is the application who's responsible for freeing the result memory.</p><p>Generic query callback routine looks like this:</p>
<pre>
typedef void
<strong>dns_query_fn</strong>(<em>ctx</em>, void *<em>result</em>, void *<em>data</em>)
</pre>
<p>Type-specific query interface expects similar form of callback routine with the only difference in type of <strong>result</strong> argument, which will be pointer to specific data structure (decoded reply) instead of this void pointer to raw DNS packet data.</p><p>Result parsing routine looks like this:</p>
<pre>
typedef int
<strong>dns_parse_fn</strong>(const unsigned char *<em>qdn</em>,
      const unsigned char *<em>pkt</em>,
      const unsigned char *<em>cur</em>,
      const unsigned char *<em>end</em>,
      void **<em>resultp</em>);
</pre>
<p>When called by the library, the arguments are as follows: <em>pkt</em> points to the start of the packet received; <em>end</em> points past the end of the packet received; <em>cur</em> points past the query DN in the query section of the packet; <em>qdn</em> points to the original query DN. The routine should allocate a single buffer to hold the result, parse the reply filling in the buffer, and return the buffer using <em>resultp</em> argument.  It returns 0 in case of error, or udns error code (<strong>DNS_E_</strong><em>XXX</em> constants) in case of error. Note that by the time when the parse routine is called by the library, packet is already verified to be a reply to the original query, by matching query DN, query class and query type.</p><p>Type-specific query inteface supplies necessary parsing routines automatically.</p><p>In case of error, query completion status as returned by <strong>dns_status</strong>(<em>ctx</em>), will contain one of the following values:</p>
<dl class='dl-vertical'>
  <dt>
    positive value
  </dt>
  <dd>
    <p>length of raw DNS packet if parsing is not requested.</p>
  </dd>
  <dt>
    0
  </dt>
  <dd>
    <p>the query was successeful and the <em>reply</em> points to type-specific data structure.</p>
  </dd>
  <dt>
    <strong>DNS_E_TEMPFAIL</strong>
  </dt>
  <dd>
    <p>temporary error, the resolver nameserver was not able to process our query or timed out.</p>
  </dd>
  <dt>
    <strong>DNS_E_PROTOCOL</strong>
  </dt>
  <dd>
    <p>protocol error, a nameserver returned malformed reply.</p>
  </dd>
  <dt>
    <strong>DNS_E_NXDOMAIN</strong>
  </dt>
  <dd>
    <p>the domain name does not exist.</p>
  </dd>
  <dt>
    <strong>DNS_E_NODATA</strong>
  </dt>
  <dd>
    <p>there is no data of requested type found.</p>
  </dd>
  <dt>
    <strong>DNS_E_NOMEM</strong>
  </dt>
  <dd>
    <p>out of memory while processing request.</p>
  </dd>
  <dt>
    <strong>DNS_E_BADQUERY</strong>
  </dt>
  <dd>
    <p>some aspect of the query (most common is the domain name in question) is invalid, and the library can't even start a query.</p>
  </dd>

</dl>
<p>Library provides two series of routines which uses similar interface -- one for asyncronous queries and another for syncronous queries.  There are two general low-level routines in each series to submit (asyncronous interface) and resolve (syncronous interface) queries, as well as several type-specific routines with more easy-to-use interfaces.  To submit an asyncronous query, use one of <strong>dns_submit_</strong><em>XXX</em>() routine, each of which accepts query parameters, pointers to callback routine and to callback data, and optional current time hint.  Note type-specific <strong>dns_submit_</strong><em>XXX</em>() routines expects specific type of the callback routine as well, which accepts reply as a pointer to corresponding structure, not a void pointer).  Every <strong>dns_submit_</strong><em>XXX</em>() routine return pointer to internal query structure of type struct&nbsp;dns_query, used as an identifier for the given query.</p><p>To resolve a query syncronously, use one of <strong>dns_resolve_</strong><em>XXX</em>() routines, which accepts the same query parameters (but not the callback pointers) as corresponding <strong>dns_submit_</strong><em>XXX</em>(), and return the query result, which is the same as passed to the callback routine in case of asyncronous interface.</p><p>In either case, the result memory (if the query completed successefully) is dynamically allocated and should be freed by an application.  If the query failed for any reason, the result will be NULL, and error status will be available from <strong>dns_status</strong>(<em>ctx</em>) routine as shown above.</p>
<pre>
struct dns_query *
<strong>dns_submit_dn</strong>(<em>ctx</em>,
     const unsigned char *<em>dn</em>, <em>qcls</em>, <em>qtyp</em>, <em>flags</em>,
     <em>parse</em>, <em>cbck</em>, <em>data</em>)
struct dns_query *
<strong>dns_submit_p</strong>(<em>ctx</em>,
     const char *<em>name</em>, <em>qcls</em>, <em>qtyp</em>, <em>flags</em>,
     <em>parse</em>, <em>cbck</em>, <em>data</em>)
   enum dns_class <em>qcls</em>;
   enum dns_type <em>qtyp</em>;
   int <em>flags</em>;
   dns_parse_fn *<em>parse</em>;
   dns_query_fn *<em>cbck</em>;
   void *<em>data</em>;
</pre>
<p>submit a query for processing for the given resolver context <em>ctx</em>. Two routines differs only in 3rd argument, which is domain name in DN format (<em>dn</em>) or asciiz string (<em>name</em>).  The query will be performed for the given domain name, with type <em>qtyp</em> in class <em>qcls</em>, using option bits in <em>flags</em>, using RR parsing routine pointed by <em>parse</em> if not-NULL, and upon completion, <em>cbck</em> function will be called with the <em>data</em> argument. In case of successeful query submission, the routine return pointer to internal query structure which may be treated as an identifier of the query as used by the library, and may be used as an argument for <strong>dns_cancel</strong>() routine.  In case of error, NULL will be returned, and context error status (available using <em>dns_status</em>() routine) will be set to corresponding error code, which in this case may be DNS_E_BADQUERY if the <em>name</em> of <em>dn</em> is invalid, DNS_E_NOMEM if there's no memory available to allocate query structure, or DNS_E_TEMPFAIL if an internal error occured.</p>
<pre>
void *<strong>dns_resolve_dn</strong>(<em>ctx</em>,
     const unsigned char *<em>dn</em>, <em>qcls</em>, <em>qtyp</em>, <em>flags</em>, <em>parse</em>);
void *<strong>dns_resolve_p</strong>(<em>ctx</em>,
     const char *<em>name</em>, <em>qcls</em>, <em>qtyp</em>, <em>flags</em>, <em>parse</em>)
   enum dns_class <em>qcls</em>;
   enum dns_type <em>qtyp</em>;
   int <em>flags</em>;
   dns_parse_fn *<em>parse</em>;
</pre>
<p>syncronous interface.  The routines perform all the steps necessary to resolve the given query and return the result.  If there's no positive result for any reason, all the routines return NULL, and set context error status (available using <strong>dns_status</strong>() routine) to indicate the error code.  If the query was successeful, context status code will contain either the length of the raw DNS reply packet if <em>parse</em> argument was NULL (in which case the return value is pointer to the reply DNS packet), or 0 (in which case the return value is the result of <em>parse</em> routine).  If the query successeful (return value is not NULL), the memory returned was dynamically allocated by the library and should be free()d by application after use.</p>
<pre>
void *<strong>dns_resolve</strong>(<em>ctx</em>, struct dns_query *<em>q</em>)
</pre>
<p>wait for the given query <em>q</em>, as returned by one of <strong>dns_submit_</strong><em>XXX</em>() routines, for completion, and return the result.  The callback routine will not be called for this query.  After completion, the query identifier <em>q</em> is not valid. Both <strong>dns_resolve_dn</strong>() and <strong>dns_resolve_p</strong>() are just wrappers around corresponding submit routines and this <strong>dns_resolve</strong>() routine.</p>
<pre>
void <strong>dns_cancel</strong>(<em>ctx</em>, struct dns_query *<em>q</em>)
</pre>
<p>cancel an active query <em>q</em>, without calling a callback routine. After completion, the query identifier <em>q</em> is not valid.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TYPE-SPECIFIC QUERIES</h2>
        <div class="sectioncontent">
<p>In addition to the generic low-level query interface, the library provides a set of routines to perform specific queries in a type-safe manner, as well as parsers for several well-known resource record types.  The library implements high-level interface for A, AAAA, PTR, MX and TXT records and DNSBL and RHSBL functionality.  These routines returns specific types as result of a query, instead of raw DNS packets.  The following types and routines are available.</p>
<pre>
struct <strong>dns_rr_null</strong> {
  char *<strong>dnsn_qname</strong>;     /* original query name */
  char *<strong>dnsn_cname</strong>;     /* canonical name */
  unsigned <strong>dnsn_ttl</strong>;    /* Time-To-Live (TTL) value */
  int <strong>dnsn_nrr</strong>;         /* number of records in the set */
};
</pre>
<p>NULL RR set, used as a base for all other RR type structures. Every RR structure as used by the library have four standard fields as in struct&nbsp;<strong>dns_rr_null</strong>.</p><h3>IN A Queries</h3>

<pre>
struct <strong>dns_rr_a4</strong> {       /* IN A RRset */
  char *<strong>dnsa4_qname</strong>;     /* original query name */
  char *<strong>dnsa4_cname</strong>;     /* canonical name */
  unsigned <strong>dnsa4_ttl</strong>;    /* Time-To-Live (TTL) value */
  int <strong>dnsa4_nrr</strong>;         /* number of addresses in the set */
  struct in_addr <strong>dnsa4_addr</strong>[]; /* array of addresses */
};
typedef void
  <strong>dns_query_a4_fn</strong>(<em>ctx</em>, struct dns_rr_a4 *<em>result</em>, <em>data</em>)
dns_parse_fn <strong>dns_parse_a4</strong><strong>;</strong>
struct dns_query *
<strong>dns_submit_a4</strong><strong>(</strong><em>ctx</em>, const char *<em>name</em>, int <em>flags</em>,
   dns_query_a4_fn *<em>cbck</em>, <em>data</em>);
struct dns_rr_a4 *
<strong>dns_resolve_a4</strong><strong>(</strong><em>ctx</em>, const char *<em>name</em>, int <em>flags</em>);
</pre>
<p>The <strong>dns_rr_a4</strong> structure holds a result of an <strong>IN A</strong> query, which is an array of IPv4 addresses.  Callback routine for IN A queries expected to be of type <strong>dns_query_a4_fn</strong>, which expects pointer to <strong>dns_rr_a4</strong> structure as query result instead of raw DNS packet. The <strong>dns_parse_a4</strong>() is used to convert raw DNS reply packet into <strong>dns_rr_a4</strong> structure (it is used internally and may be used directly too with generic query interface).  Routines <strong>dns_submit_a4</strong>() and <strong>dns_resolve_a4</strong>() are used to perform A IN queries in a type-safe manner.  The <em>name</em> parameter is the domain name in question, and <em>flags</em> is query flags bitmask, with one bit, DNS_NOSRCH, of practical interest (if the <em>name</em> is absolute, that is, it ends up with a dot, DNS_NOSRCH flag will be set automatically).</p>
<h3>IN AAAA Queries</h3>

<pre>
struct <strong>dns_rr_a6</strong> {       /* IN AAAA RRset */
  char *<strong>dnsa6_qname</strong>;     /* original query name */
  char *<strong>dnsa6_cname</strong>;     /* canonical name */
  unsigned <strong>dnsa6_ttl</strong>;    /* Time-To-Live (TTL) value */
  int <strong>dnsa6_nrr</strong>;         /* number of addresses in the set */
  struct in6_addr <strong>dnsa6_addr</strong>[]; /* array of addresses */
};
typedef void
  <strong>dns_query_a6_fn</strong>(<em>ctx</em>, struct dns_rr_a6 *<em>result</em>, <em>data</em>)
dns_parse_fn <strong>dns_parse_a6</strong><strong>;</strong>
struct dns_query *
<strong>dns_submit_a6</strong><strong>(</strong><em>ctx</em>, const char *<em>name</em>, int <em>flags</em>,
   dns_query_a6_fn *<em>cbck</em>, <em>data</em>);
struct dns_rr_a6 *
<strong>dns_resolve_a6</strong><strong>(</strong><em>ctx</em>, const char *<em>name</em>, int <em>flags</em>);
</pre>
<p>The <strong>dns_rr_a6</strong> structure holds a result of an <strong>IN AAAA</strong> query, which is an array of IPv6 addresses.  Callback routine for IN AAAA queries expected to be of type <strong>dns_query_a6_fn</strong>, which expects pointer to <strong>dns_rr_a6</strong> structure as query result instead of raw DNS packet. The <strong>dns_parse_a6</strong>() is used to convert raw DNS reply packet into <strong>dns_rr_a6</strong> structure (it is used internally and may be used directly too with generic query interface).  Routines <strong>dns_submit_a6</strong>() and <strong>dns_resolve_a6</strong>() are used to perform AAAA IN queries in a type-safe manner.  The <em>name</em> parameter is the domain name in question, and <em>flags</em> is query flags bitmask, with one bit, DNS_NOSRCH, of practical interest (if the <em>name</em> is absolute, that is, it ends up with a dot, DNS_NOSRCH flag will be set automatically).</p>
<h3>IN PTR Queries</h3>

<pre>
struct <strong>dns_rr_ptr</strong> {       /* IN PTR RRset */
  char *<strong>dnsptr_qname</strong>;     /* original query name */
  char *<strong>dnsptr_cname</strong>;     /* canonical name */
  unsigned <strong>dnsptr_ttl</strong>;    /* Time-To-Live (TTL) value */
  int <strong>dnsptr_nrr</strong>;         /* number of domain name pointers */
  char *<strong>dnsptr_ptr</strong>[];     /* array of domain name pointers */
};
typedef void
  <strong>dns_query_ptr_fn</strong>(<em>ctx</em>, struct dns_rr_ptr *<em>result</em>, <em>data</em>)
dns_parse_fn <strong>dns_parse_ptr</strong><strong>;</strong>
struct dns_query *
<strong>dns_submit_a4ptr</strong><strong>(</strong><em>ctx</em>, const struct in_addr *<strong>addr</strong>,
   dns_query_ptr_fn *<em>cbck</em>, <em>data</em>);
struct dns_rr_ptr *
<strong>dns_resolve_a4ptr</strong><strong>(</strong><em>ctx</em>, const struct in_addr *<strong>addr</strong>);
struct dns_query *
<strong>dns_submit_a6ptr</strong><strong>(</strong><em>ctx</em>, const struct in6_addr *<strong>addr</strong>,
   dns_query_ptr_fn *<em>cbck</em>, <em>data</em>);
struct dns_rr_ptr *
<strong>dns_resolve_a6ptr</strong><strong>(</strong><em>ctx</em>, const struct in6_addr *<strong>addr</strong>);
</pre>
<p>The <strong>dns_rr_ptr</strong> structure holds a result of an IN PTR query, which is an array of domain name pointers for a given IPv4 or IPv6 address. Callback routine for IN PTR queries expected to be of type <strong>dns_query_ptr_fn</strong>, which expects pointer to <strong>dns_rr_ptr</strong> structure as query result instead of raw DNS packet.  The <strong>dns_parse_ptr</strong>() is used to convert raw DNS reply packet into <strong>dns_rr_ptr</strong> structure (it is used internally and may be used directly too with generic query interface).  Routines <strong>dns_submit_a4ptr</strong>() and <strong>dns_resolve_a4ptr</strong>() are used to perform IN PTR queries for IPv4 addresses in a type-safe manner. Routines <strong>dns_submit_a6ptr</strong>() and <strong>dns_resolve_a6ptr</strong>() are used to perform IN PTR queries for IPv6 addresses.</p>
<h3>IN MX Queries</h3>

<pre>
struct <strong>dns_mx</strong> {          /* single MX record */
  int <strong>priority</strong>;          /* priority value of this MX */
  char *<strong>name</strong>;            /* domain name of this MX */
};
struct <strong>dns_rr_mx</strong> {       /* IN MX RRset */
  char *<strong>dnsmx_qname</strong>;     /* original query name */
  char *<strong>dnsmx_cname</strong>;     /* canonical name */
  unsigned <strong>dnsmx_ttl</strong>;    /* Time-To-Live (TTL) value */
  int <strong>dnsmx_nrr</strong>;         /* number of mail exchangers in the set */
  struct dns_mx <strong>dnsmx_mx</strong>[]; /* array of mail exchangers */
};
typedef void
  <strong>dns_query_mx_fn</strong>(<em>ctx</em>, struct dns_rr_mx *<em>result</em>, <em>data</em>)
dns_parse_fn <strong>dns_parse_mx</strong><strong>;</strong>
struct dns_query *
<strong>dns_submit_mx</strong><strong>(</strong><em>ctx</em>, const char *<em>name</em>, int <em>flags</em>,
   dns_query_mx_fn *<em>cbck</em>, <em>data</em>);
struct dns_rr_mx *
<strong>dns_resolve_mx</strong><strong>(</strong><em>ctx</em>, const char *<em>name</em>, int <em>flags</em>);
</pre>
<p>The <strong>dns_rr_mx</strong> structure holds a result of an IN MX query, which is an array of mail exchangers for a given domain.  Callback routine for IN MX queries expected to be of type <strong>dns_query_mx_fn</strong>, which expects pointer to <strong>dns_rr_mx</strong> structure as query result instead of raw DNS packet. The <strong>dns_parse_mx</strong>() is used to convert raw DNS reply packet into <strong>dns_rr_mx</strong> structure (it is used internally and may be used directly too with generic query interface).  Routines <strong>dns_submit_mx</strong>() and <strong>dns_resolve_mx</strong>() are used to perform IN MX queries in a type-safe manner.  The <em>name</em> parameter is the domain name in question, and <em>flags</em> is query flags bitmask, with one bit, DNS_NOSRCH, of practical interest (if the <em>name</em> is absolute, that is, it ends up with a dot, DNS_NOSRCH flag will be set automatically).</p>
<h3>TXT Queries</h3>

<pre>
struct <strong>dns_txt</strong> {          /* single TXT record */
  int <strong>len</strong>;                /* length of the text */
  unsigned char *<strong>txt</strong>;     /* pointer to the text */
};
struct <strong>dns_rr_txt</strong> {       /* TXT RRset */
  char *<strong>dnstxt_qname</strong>;     /* original query name */
  char *<strong>dnstxt_cname</strong>;     /* canonical name */
  unsigned <strong>dnstxt_ttl</strong>;    /* Time-To-Live (TTL) value */
  int <strong>dnstxt_nrr</strong>;         /* number of text records in the set */
  struct dns_txt <strong>dnstxt_txt</strong>[]; /* array of TXT records */
};
typedef void
  <strong>dns_query_txt_fn</strong>(<em>ctx</em>, struct dns_rr_txt *<em>result</em>, <em>data</em>)
dns_parse_fn <strong>dns_parse_txt</strong><strong>;</strong>
struct dns_query *
<strong>dns_submit_txt</strong><strong>(</strong><em>ctx</em>, const char *<em>name</em>, enum dns_class <em>qcls</em>,
   int <em>flags</em>, dns_query_txt_fn *<em>cbck</em>, <em>data</em>);
struct dns_rr_txt *
<strong>dns_resolve_txt</strong><strong>(</strong><em>ctx</em>, const char *<em>name</em>,
             enum dns_class <em>qcls</em>, int <em>flags</em>);
</pre>
<p>The <strong>dns_rr_txt</strong> structure holds a result of a TXT query, which is an array of text records for a given domain name.  Callback routine for TXT queries expected to be of type <strong>dns_query_txt_fn</strong>, which expects pointer to <strong>dns_rr_txt</strong> structure as query result instead of raw DNS packet. The <strong>dns_parse_txt</strong>() is used to convert raw DNS reply packet into <strong>dns_rr_txt</strong> structure (it is used internally and may be used directly too with generic query interface).  Routines <strong>dns_submit_txt</strong>() and <strong>dns_resolve_txt</strong>() are used to perform IN MX queries in a type-safe manner.  The <em>name</em> parameter is the domain name in question, and <em>flags</em> is query flags bitmask, with one bit, DNS_NOSRCH, of practical interest (if the <em>name</em> is absolute, that is, it ends up with a dot, DNS_NOSRCH flag will be set automatically).  Note that each TXT string is represented by <strong>struct&nbsp;dns_txt</strong>, while zero-terminated (and the len field of the structure does not include the terminator), may contain embedded null characters -- content of TXT records is not interpreted by the library in any way.</p>
<h3>SRV Queries</h3>

<pre>
struct <strong>dns_srv</strong> {          /* single SRV record */
  int <strong>priority</strong>;           /* priority of the record */
  int <strong>weight</strong>;             /* weight of the record */
  int <strong>port</strong>;               /* the port number to connect to */
  char *<strong>name</strong>;             /* target host name */
};
struct <strong>dns_rr_srv</strong> {       /* SRV RRset */
  char *<strong>dnssrv_qname</strong>;     /* original query name */
  char *<strong>dnssrv_cname</strong>;     /* canonical name */
  unsigned <strong>dnssrv_ttl</strong>;    /* Time-To-Live (TTL) value */
  int <strong>dnssrv_nrr</strong>;         /* number of text records in the set */
  struct dns_srv <strong>dnssrv_srv</strong>[]; /* array of SRV records */
};
typedef void
  <strong>dns_query_srv_fn</strong>(<em>ctx</em>, struct dns_rr_srv *<em>result</em>, <em>data</em>)
dns_parse_fn <strong>dns_parse_srv</strong><strong>;</strong>
struct dns_query *
<strong>dns_submit_srv</strong><strong>(</strong><em>ctx</em>, const char *<em>name</em>, const char *<em>service</em>, const char *<em>protocol</em>,
   int <em>flags</em>, dns_query_txt_fn *<em>cbck</em>, <em>data</em>);
struct dns_rr_srv *
<strong>dns_resolve_srv</strong><strong>(</strong><em>ctx</em>, const char *<em>name</em>, const char *<em>service</em>, const char *<em>protocol</em>,
             int <em>flags</em>);
</pre>
<p>The <strong>dns_rr_srv</strong> structure holds a result of an IN SRV (rfc2782) query, which is an array of servers (together with port numbers) which are performing operations for a given <em>service</em> using given <em>protocol</em> on a target domain <em>name</em>.  Callback routine for IN SRV queries expected to be of type <strong>dns_query_srv_fn</strong>, which expects pointer to <strong>dns_rr_srv</strong> structure as query result instead of raw DNS packet.  The <strong>dns_parse_srv</strong>() is used to convert raw DNS reply packet into <strong>dns_rr_srv</strong> structure (it is used internally and may be used directly too with generic query interface). Routines <strong>dns_submit_srv</strong>() and <strong>dns_resolve_srv</strong>() are used to perform IN SRV queries in a type-safe manner.  The <em>name</em> parameter is the domain name in question, <em>service</em> and protocl specifies the service and the protocol in question (the library will construct query DN according to rfc2782 rules) and may be NULL (in this case the library assumes <em>name</em> parameter holds the complete SRV query), and <em>flags</em> is query flags bitmask, with one bit, DNS_NOSRCH, of practical interest (if the <em>name</em> is absolute, that is, it ends up with a dot, DNS_NOSRCH flag will be set automatically).</p>
<h3>NAPTR Queries</h3>

<pre>
struct <strong>dns_naptr</strong> {        /* single NAPTR record */
  int <strong>order</strong>;              /* record order */
  int <strong>preference</strong>;         /* preference of this record */
  char *<strong>flags</strong>;            /* application-specific flags */
  char *<strong>service</strong>;          /* service parameter */
  char *<strong>regexp</strong>;           /* substitutional regular expression */
  char *<strong>replacement</strong>;      /* replacement string */
};
struct <strong>dns_rr_naptr</strong> {     /* NAPTR RRset */
  char *<strong>dnsnaptr_qname</strong>;   /* original query name */
  char *<strong>dnsnaptr_cname</strong>;   /* canonical name */
  unsigned <strong>dnsnaptr_ttl</strong>;  /* Time-To-Live (TTL) value */
  int <strong>dnsnaptr_nrr</strong>;       /* number of text records in the set */
  struct dns_naptr <strong>dnsnaptr_naptr</strong>[]; /* array of NAPTR records */
};
typedef void
  <strong>dns_query_naptr_fn</strong>(<em>ctx</em>, struct dns_rr_naptr *<em>result</em>, <em>data</em>)
dns_parse_fn <strong>dns_parse_naptr</strong><strong>;</strong>
struct dns_query *
<strong>dns_submit_naptr</strong><strong>(</strong><em>ctx</em>, const char *<em>name</em>, int <em>flags</em>,
   dns_query_txt_fn *<em>cbck</em>, <em>data</em>);
struct dns_rr_naptr *
<strong>dns_resolve_naptr</strong><strong>(</strong><em>ctx</em>, const char *<em>name</em>, int <em>flags</em>);
</pre>
<p>The <strong>dns_rr_naptr</strong> structure holds a result of an IN NAPTR (rfc3403) query. Callback routine for IN NAPTR queries expected to be of type <strong>dns_query_naptr_fn</strong>, expects pointer to <strong>dns_rr_naptr</strong> structure as query result instead of raw DNS packet. The <strong>dns_parse_naptr</strong>() is used to convert raw DNS reply packet into <strong>dns_rr_naptr</strong> structure (it is used internally and may be used directly too with generic query interface). Routines <strong>dns_submit_naptr</strong>() and <strong>dns_resolve_naptr</strong>() are used to perform IN NAPTR queries in a type-safe manner.  The <em>name</em> parameter is the domain name in question, and <em>flags</em> is query flags bitmask, with one bit, DNS_NOSRCH, of practical interest (if the <em>name</em> is absolute, that is, it ends up with a dot, DNS_NOSRCH flag will be set automatically).</p>
<h3>DNSBL Interface</h3>
<p>A DNS-based blocklists, or a DNSBLs, are in wide use nowadays, especially to protect mailservers from spammers.  The library provides DNSBL interface, a set of routines to perform queries against DNSBLs.  Routines accepts an IP address (IPv4 and IPv6 are both supported) and a base DNSBL zone as query parameters, and returns either <strong>dns_rr_a4</strong> or <strong>dns_rr_txt</strong> structure.  Note that IPv6 interface return IPv4 RRset.</p>
<pre>
struct dns_query *
<strong>dns_submit_a4dnsbl</strong>(<em>ctx</em>,
  const struct in_addr *<em>addr</em>, const char *<em>dnsbl</em>,
  dns_query_a4_fn *<em>cbck</em>, void *<em>data</em>);
struct dns_query *
<strong>dns_submit_a4dnsbl_txt</strong>(<em>ctx</em>,
  const struct in_addr *<em>addr</em>, const char *<em>dnsbl</em>,
  dns_query_txt_fn *<em>cbck</em>, void *<em>data</em>);
struct dns_query *
<strong>dns_submit_a6dnsbl</strong>(<em>ctx</em>,
  const struct in6_addr *<em>addr</em>, const char *<em>dnsbl</em>,
  dns_query_a4_fn *<em>cbck</em>, void *<em>data</em>);
struct dns_query *
<strong>dns_submit_a6dnsbl_txt</strong>(<em>ctx</em>,
  const struct in6_addr *<em>addr</em>, const char *<em>dnsbl</em>,
  dns_query_txt_fn *<em>cbck</em>, void *<em>data</em>);
struct dns_rr_a4 *<strong>dns_resolve_a4dnsbl</strong>(<em>ctx</em>,
  const struct in_addr *<em>addr</em>, const char *<em>dnsbl</em>)
struct dns_rr_txt *<strong>dns_resolve_a4dnsbl_txt</strong>(<em>ctx</em>,
  const struct in_addr *<em>addr</em>, const char *<em>dnsbl</em>)
struct dns_rr_a4 *<strong>dns_resolve_a6dnsbl</strong>(<em>ctx</em>,
  const struct in6_addr *<em>addr</em>, const char *<em>dnsbl</em>)
struct dns_rr_txt *<strong>dns_resolve_a6dnsbl_txt</strong>(<em>ctx</em>,
  const struct in6_addr *<em>addr</em>, const char *<em>dnsbl</em>)
</pre>
<p>Perform (submit or resolve) a DNSBL query for the given <em>dnsbl</em> domain and an IP <em>addr</em> in question, requesting either A or TXT records.</p>
<h3>RHSBL Interface</h3>
<p>RHSBL is similar to DNSBL, but instead of an IP address, the parameter is a domain name.</p>
<pre>
struct dns_query *
<strong>dns_submit_rhsbl</strong>(<em>ctx</em>, const char *<em>name</em>, const char *<em>rhsbl</em>,
  dns_query_a4_fn *<em>cbck</em>, void *<em>data</em>);
struct dns_query *
<strong>dns_submit_rhsbl_txt</strong>(<em>ctx</em>, const char *<em>name</em>, const char *<em>rhsbl</em>,
  dns_query_txt_fn *<em>cbck</em>, void *<em>data</em>);
struct dns_rr_a4 *
<strong>dns_resolve_rhsbl</strong>(<em>ctx</em>, const char *<em>name</em>, const char *<em>rhsbl</em>);
struct dns_rr_txt *
<strong>dns_resolve_rhsbl_txt</strong>(<em>ctx</em>, const char *<em>name</em>, const char *<em>rhsbl</em>);
</pre>
<p>Perform (submit or resolve) a RHSBL query for the given <em>rhsbl</em> domain and <em>name</em> in question, requesting either A or TXT records.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LOW-LEVEL INTERFACE</h2>
        <div class="sectioncontent">
<h3>Domain Names (DNs)</h3>
<p>A DN is a series of domain name labels each starts with length byte, followed by empty label (label with zero length).  The following routines to work with DNs are provided.</p>
<pre>
unsigned <strong>dns_dnlen</strong>(const unsigned char *<em>dn</em>)
</pre>
<p>return length of the domain name <em>dn</em>, including the terminating label.</p>
<pre>
unsigned <strong>dns_dnlabels</strong>(const unsigned char *<em>dn</em>)
</pre>
<p>return number of non-zero labels in domain name <em>dn</em>.</p>
<pre>
unsigned <strong>dns_dnequal</strong>(<em>dn1</em>, <em>dn2</em>)
  const unsigned char *<em>dn1</em>, *<em>dn2</em>;
</pre>
<p>test whenever the two domain names, <em>dn1</em> and <em>dn2</em>, are equal (case-insensitive).  Return domain name length if equal or 0 if not.</p>
<pre>
unsigned <strong>dns_dntodn</strong>(<em>sdn</em>, <em>ddn</em>, <em>dnsiz</em>)
  const unsigned char *<em>sdn</em>;
  unsigned char *<em>ddn</em>;
  unsigned <em>dnsiz</em>;
</pre>
<p>copies the source domain name <em>sdn</em> to destination buffer <em>ddn</em> of size <em>dnsiz</em>.  Return domain name length or 0 if <em>ddn</em> is too small.</p>
<pre>
int <strong>dns_ptodn</strong>(<em>name</em>, <em>namelen</em>, <em>dn</em>, <em>dnsiz</em>, <em>isabs</em>)
int <strong>dns_sptodn</strong>(<em>name</em>, <em>dn</em>, <em>dnsiz</em>)
  const char *<em>name</em>; unsigned <em>namelen</em>;
  unsigned char *<em>dn</em>; unsigned <em>dnsiz</em>;
  int *<em>isabs</em>;
</pre>
<p>convert asciiz name <em>name</em> of length <em>namelen</em> to DN format, placing result into buffer <em>dn</em> of size <em>dnsiz</em>.  Return length of the DN if successeful, 0 if the <em>dn</em> buffer supplied is too small, or negative value if <em>name</em> is invalid.  If <em>isabs</em> is non-NULL and conversion was successeful, *<em>isabs</em> will be set to either 1 or 0 depending whenever <em>name</em> was absolute (i.e. ending with a dot) or not.  Name length, <em>namelength</em>, may be zero, in which case strlen(<em>name</em>) will be used.  Second form, <strong>dns_sptodn</strong>(), is a simplified form of <strong>dns_ptodn</strong>(), equivalent to</p>
<pre>
<strong>dns_ptodn</strong>(<em>name</em>, 0, <em>dn</em>, <em>dnlen</em>, 0).
</pre>

<pre>
extern const unsigned char <strong>dns_inaddr_arpa_dn</strong>[]
int <strong>dns_a4todn</strong>(const struct in_addr *<em>addr</em>, const unsigned char *<em>tdn</em>,
      unsigned char *<em>dn</em>, unsigned <em>dnsiz</em>)
int <strong>dns_a4ptodn</strong>(const struct in_addr *<em>addr</em>, const char *<em>tname</em>,
      unsigned char *<em>dn</em>, unsigned <em>dnsiz</em>)
extern const unsigned char <strong>dns_ip6_arpa_dn</strong>[]
int <strong>dns_a6todn</strong>(const struct in6_addr *<em>addr</em>, const unsigned char *<em>tdn</em>,
      unsigned char *<em>dn</em>, unsigned <em>dnsiz</em>)
int <strong>dns_a6ptodn</strong>(const struct in6_addr *<em>addr</em>, const char *<em>tname</em>,
      unsigned char *<em>dn</em>, unsigned <em>dnsiz</em>)
</pre>
<p>several variants of routines to convert IPv4 and IPv6 address <em>addr</em> into reverseDNS-like domain name in DN format, storing result in <em>dn</em> of size <em>dnsiz</em>.  <em>tdn</em> (or <em>tname</em>) is the base zone name, like in-addr.arpa for IPv4 or in6.arpa for IPv6.  If <em>tdn</em> (or <em>tname</em>) is NULL, <strong>dns_inaddr_arpa_dn</strong> (or <strong>dns_ip6_arpa_dn</strong>) will be used. The routines may be used to construct a DN for a DNSBL lookup for example. All routines return length of the resulting DN on success, -1 if resulting DN is invalid, or 0 if the <em>dn</em> buffer (<em>dnsiz</em>) is too small. To hold standard rDNS DN, a buffer of size <strong>DNS_A4RSIZE</strong> (30 bytes) for IPv4 address, or <strong>DNS_A6RSIZE</strong> (74 bytes) for IPv6 address, is sufficient.</p>
<pre>
int <strong>dns_dntop</strong>(<em>dn</em>, <em>name</em>, <em>namesiz</em>)
   const unsigned char *<em>dn</em>;
   const char *<em>name</em>; unsigned <em>namesiz</em>;
</pre>
<p>convert domain name <em>dn</em> in DN format to asciiz string, placing result into <em>name</em> buffer of size <em>namesiz</em>.  Maximum length of asciiz representation of domain name is <strong>DNS_MAXNAME</strong> (1024) bytes.  Root domain is represented as empty string.  Return length of the resulting name (including terminating character, i.e. strlen(name)+1) on success, 0 if the <em>name</em> buffer is too small, or negative value if <em>dn</em> is invalid (last case should never happen since all routines in this library which produce domain names ensure the DNs generated are valid).</p>
<pre>
const char *<strong>dns_dntosp</strong>(const unsigned char *<em>dn</em>)
</pre>
<p>convert domain name <em>dn</em> in DN format to asciiz string using static buffer.  Return the resulting asciiz string on success or NULL on failure. Note since this routine uses static buffer, it is not thread-safe.</p>
<pre>
unsigned <strong>dns_dntop_size</strong>(const unsigned char *<em>dn</em>)
</pre>
<p>return the buffer size needed to convert the <em>dn</em> domain name in DN format to asciiz string, for <strong>dns_dntop</strong>().  The routine return either the size of buffer required, including the trailing zero byte, or 0 if <em>dn</em> is invalid.</p>
<h3>Working with DNS Packets</h3>
<p>The following routines are provided to encode and decode DNS on-wire packets.  This is low-level interface.</p><p>DNS response codes (returned by <strong>dns_rcode</strong>() routine) are defined as constants prefixed with <strong>DNS_R_</strong>.  See udns.h header file for the complete list.  In particular, constants <strong>DNS_R_NOERROR</strong> (0), <strong>DNS_R_SERVFAIL</strong>, <strong>DNS_R_NXDOMAIN</strong> may be of interest to an application.</p>
<pre>
unsigned <strong>dns_get16</strong>(const unsigned char *<em>p</em>)
unsigned <strong>dns_get32</strong>(const unsigned char *<em>p</em>)
</pre>
<p>helper routines, convert 16-bit or 32-bit integer in on-wire format pointed to by <em>p</em> to unsigned.</p>
<pre>
unsigned char *<strong>dns_put16</strong>(unsigned char *<em>d</em>, unsigned <em>n</em>)
unsigned char *<strong>dns_put32</strong>(unsigned char *<em>d</em>, unsigned <em>n</em>)
</pre>
<p>helper routine, convert unsigned 16-bit or 32-bit integer <em>n</em> to on-wire format to buffer pointed to by <em>d</em>, return <em>d</em>+2 or <em>d</em>+4.</p>
<pre>
<strong>DNS_HSIZE</strong> (12)
</pre>
<p>defines size of DNS header.  Data section in the DNS packet immediately follows the header.  In the header, there are query identifier (id), various flags and codes, and number of resource records in various data sections. See udns.h header file for complete list of DNS header definitions.</p>
<pre>
unsigned <strong>dns_qid</strong>(const unsigned char *<em>pkt</em>)
int <strong>dns_rd</strong>(const unsigned char *<em>pkt</em>)
int <strong>dns_tc</strong>(const unsigned char *<em>pkt</em>)
int <strong>dns_aa</strong>(const unsigned char *<em>pkt</em>)
int <strong>dns_qr</strong>(const unsigned char *<em>pkt</em>)
int <strong>dns_ra</strong>(const unsigned char *<em>pkt</em>)
unsigned <strong>dns_opcode</strong>(const unsigned char *<em>pkt</em>)
unsigned <strong>dns_rcode</strong>(const unsigned char *<em>pkt</em>)
unsigned <strong>dns_numqd</strong>(const unsigned char *<em>pkt</em>)
unsigned <strong>dns_numan</strong>(const unsigned char *<em>pkt</em>)
unsigned <strong>dns_numns</strong>(const unsigned char *<em>pkt</em>)
unsigned <strong>dns_numar</strong>(const unsigned char *<em>pkt</em>)
const unsigned char *<strong>dns_payload</strong>(const unsigned char *<em>pkt</em>)
</pre>
<p>return various parts from the DNS packet header <em>pkt</em>: query identifier (qid), recursion desired (rd) flag, truncation occured (tc) flag, authoritative answer (aa) flag, query response (qr) flag, recursion available (ra) flag, operation code (opcode), result code (rcode), number of entries in question section (numqd), number of answers (numan), number of authority records (numns), number of additional records (numar), and the pointer to the packet data (payload).</p>
<pre>
int <strong>dns_getdn</strong>(<em>pkt</em>, <em>curp</em>, <em>pkte</em>, <em>dn</em>, <em>dnsiz</em>)
const unsigned char *<strong>dns_skipdn</strong>(<em>cur</em>, <em>pkte</em>)
   const unsigned char *<em>pkt</em>, *<em>pkte</em>, **<em>curp</em>, *<em>cur</em>;
   unsigned char *<em>dn</em>; unsigned <em>dnsiz</em>;
</pre>
<p><strong>dns_getdn</strong>() extract DN from DNS packet <em>pkt</em> which ends before <em>pkte</em> starting at position *<em>curp</em> into buffer pointed to by <em>dn</em> of size <em>dnsiz</em>.  Upon successeful completion, *<em>curp</em> will point to the next byte in the packet after the extracted domain name. It return positive number (length of the DN if <em>dn</em>) upon successeful completion, negative value on error (when the packet contains invalid data), or zero if the <em>dnsiz</em> is too small (maximum length of a domain name is <strong>DNS_MAXDN</strong>).  <strong>dns_skipdn</strong>() return pointer to the next byte in DNS packet which ends up before <em>pkte</em> after a domain name which starts at the <em>cur</em> byte, or NULL if the packet is invalid.  <strong>dns_skipdn</strong>() is more or less equivalent to what <strong>dns_getdn</strong>() does, except it does not actually extract the domain name in question, and uses simpler interface.</p>
<pre>
struct <strong>dns_rr</strong> {
  unsigned char <strong>dnsrr_dn</strong>[DNS_MAXDN]; /* the RR DN name */
  enum dns_class <strong>dnsrr_cls</strong>;          /* class of the RR */
  enum dns_type  <strong>dnsrr_typ</strong>;          /* type of the RR */
  unsigned <strong>dnsrr_ttl</strong>;                /* TTL value */
  unsigned <strong>dnsrr_dsz</strong>;                /* size of data in bytes */
  const unsigned char *<strong>dnsrr_dptr</strong>;   /* pointer to the first data byte */
  const unsigned char *<strong>dnsrr_dend</strong>;   /* next byte after RR */
};
</pre>
<p>The <strong>dns_rr</strong> structure is used to hold information about single DNS Resource Record (RR) in an easy to use form.</p>
<pre>
struct <strong>dns_parse</strong> {
  const unsigned char *<strong>dnsp_pkt</strong>; /* pointer to the packet being parsed */
  const unsigned char *<strong>dnsp_end</strong>; /* end of the packet pointer */
  const unsigned char *<strong>dnsp_cur</strong>; /* current packet positionn */
  const unsigned char *<strong>dnsp_ans</strong>; /* pointer to the answer section */
  int <strong>dnsp_rrl</strong>;                  /* number of RRs left */
  int <strong>dnsp_nrr</strong>;                  /* number of relevant RRs seen so far */
  unsigned <strong>dnsp_ttl</strong>;             /* TTL value so far */
  const unsigned char *<strong>dnsp_qdn</strong>; /* the domain of interest or NULL */
  enum dns_class <strong>dnsp_qcls</strong>;      /* class of interest or 0 for any */
  enum dns_type  <strong>dnsp_qtyp</strong>;      /* type of interest or 0 for any */
  unsigned char <strong>dnsp_dnbuf</strong>[DNS_MAXDN]; /* domain name buffer */
};
</pre>
<p>The <strong>dns_parse</strong> structure is used to parse DNS reply packet. It holds information about the packet being parsed (dnsp_pkt, dnsp_end and dnsp_cur fields), number of RRs in the current section left to do, and the information about specific RR which we're looking for (dnsp_qdn, dnsp_qcls and dnsp_qtyp fields).</p>
<pre>
int <strong>dns_initparse</strong>(struct dns_parse *<em>p</em>,
  const unsigned char *<em>qdn</em>,
  const unsigned char *<em>pkt</em>,
  const unsigned char *<em>cur</em>,
  const unsigned char *<em>end</em>)
</pre>
<p>initializes the RR parsing structure <em>p</em>.  Arguments <em>pkt</em>, <em>cur</em> and <em>end</em> should describe the received packet: <em>pkt</em> is the start of the packet, <em>end</em> points to the next byte after the end of the packet, and <em>cur</em> points past the query DN in query section (to query class+type information).  And <em>qdn</em> points to the query DN.  This is the arguments passed to <strong>dns_parse_fn</strong>() routine. <strong>dns_initparse</strong>() initializes <strong>dnsp_pkt</strong>, <strong>dnsp_end</strong> and <strong>dnsp_qdn</strong> fields to the corresponding arguments, extracts and initializes <strong>dnsp_qcls</strong> and <strong>dnsp_qtyp</strong> fields to the values found at <em>cur</em> pointer, initializes <strong>dnsp_cur</strong> and <strong>dnsp_ans</strong> fields to be <em>cur</em>+4 (to the start of answer section), and initializes <strong>dnsp_rrl</strong> field to be number of entries in answer section. <strong>dnsp_ttl</strong> will be set to max TTL value, 0xffffffff, and <strong>dnsp_nrr</strong> to 0.</p>
<pre>
int <strong>dns_nextrr</strong>(struct dns_parse *<em>p</em>, struct dns_rr *<em>rr</em>);
</pre>
<p>searches for next RR in the packet based on the criteria provided in the <em>p</em> structure, filling in the <em>rr</em> structure and advancing <em>p</em>-&gt;<strong>dnsp_cur</strong> to the next RR in the packet. RR selection is based on dnsp_qdn, dnsp_qcls and dnsp_qtyp fields in the dns_parse structure.  Any (or all) of the 3 fields may be 0, which means any actual value from the packet is acceptable.  In case the field isn't 0 (or NULL for dnsp_qdn), only RRs with corresponding characteristics are acceptable.  Additionally, when dnsp_qdn is non-NULL, <strong>dns_nextrr</strong>() performs automatic CNAME expansion. Routine will return positive value on success, 0 in case it reached the end of current section in the packet (<em>p</em>-&gt;<strong>dnsp_rrl</strong> is zero), or negative value if next RR can not be decoded (packet format is invalid). The routine updates <em>p</em>-&gt;<strong>dnsp_qdn</strong> automatically when this field is non-NULL and it encounters appropriate CNAME RRs (saving CNAME target in <em>p</em>-&gt;<strong>dnsp_dnbuf</strong>), so after end of the process, <em>p</em>-&gt;<strong>dnsp_qdn</strong> will point to canonical name of the domain in question.  The routine updates <em>p</em>-&gt;<strong>dnsp_ttl</strong> value to be the minimum TTL of all RRs found.</p>
<pre>
void <strong>dns_rewind</strong>(struct dns_parse *<em>p</em>, const unsigned char *<em>qdn</em>)
</pre>
<p>this routine "rewinds" the packet parse state structure to be at the same state as after a call to <strong>dns_initparse</strong>(), i.e. reposition the parse structure <em>p</em> to the start of answer section and initialize <em>p</em>-&gt;<strong>dnsp_rrl</strong> to the number of entries in answer section.</p>
<pre>
int <strong>dns_stdrr_size</strong>(const struct dns_parse *<em>p</em>);
</pre>
<p>return size to hold standard RRset structure information, as shown in <strong>dns_rr_null</strong> structure (for the query and canonical names).  Used to calculate amount of memory to allocate for common part of type-specific RR structures in parsing routines.</p>
<pre>
void *<strong>dns_stdrr_finish</strong>(struct dns_rr_null *<em>ret</em>, char *<em>cp</em>,
  const struct dns_parse *<em>p</em>);
</pre>
<p>initializes standard RRset fields in <em>ret</em> structure using buffer pointed to by <em>cp</em>, which should have at least as many bytes as <strong>dns_stdrr_size</strong>(<em>p</em>) returned.  Used to finalize common part of type-specific RR structures in parsing routines.</p><p>See library source for usage examples of all the above low-level routines, especially source of the parsing routines.</p>
<h3>Auxilary Routines</h3>

<pre>
int <strong>dns_pton</strong>(int <em>af</em>, const char *<em>src</em>, void *<em>dst</em>);
</pre>
<p>privides functionality similar to standard <strong>inet_pton</strong>() routine, to convert printable representation of an IP address of family <em>af</em> (either <strong>AF_INET</strong> or <strong>AF_INET6</strong>) pointed to by <em>src</em> into binary form suitable for socket addresses and transmission over network, in buffer pointed to by <em>dst</em>.  The destination buffer should be of size 4 for <strong>AF_INET</strong> family or 16 for <strong>AF_INET6</strong>. The return value is positive on success, 0 if <em>src</em> is not a valid text representation of an address of family <em>af</em>, or negative if the given address family is not supported.</p>
<pre>
const char *<strong>dns_ntop</strong>(int <em>af</em>, const void *<em>src</em>,
    char *<em>dst</em>, int <em>dstsize</em>)
</pre>
<p>privides functionality similar to standard <strong>inet_ntop</strong>() routine, to convert binary representation of an IP address of family <em>af</em> (either <strong>AF_INET</strong> or <strong>AF_INET6</strong>) pointed to by <em>src</em> (either 4 or 16 bytes) into printable form in buffer in buffer pointed to by <em>dst</em> of size <em>dstsize</em>.  The destination buffer should be at least of size 16 bytes for <strong>AF_INET</strong> family or 46 bytes for <strong>AF_INET6</strong>.  The return value is either <em>dst</em>, or NULL pointer if <em>dstsize</em> is too small to hold this address or if the given address family is not supported.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>The <strong>udns</strong> library has been written by Michael Tokarev, mjt+udns@tls.msk.ru.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">VERSION</h2>
        <div class="sectioncontent">
<p>This manual page corresponds to udns version 0.4, released Jan-2014.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="uderrmsg.3.html"><span aria-hidden="true">&larr;</span> uderrmsg.3: Unidata error-messaging package</a></li>
   <li class="next"><a href="uint16_pack.3.html">uint16_pack.3: Write an unsigned little-endian 16-bit integer <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

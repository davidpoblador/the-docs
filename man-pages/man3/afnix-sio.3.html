<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>afnix-sio: Standard input/output module</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Standard input/output module">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="afnix-sio (3) manual">
  <meta name="twitter:description" content="Standard input/output module">
  <meta name="twitter:image" content="https://www.carta.tech/images/afnix-afnix-sio-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/afnix-sio.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="afnix-sio (3) manual" />
  <meta property="og:description" content="Standard input/output module" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/afnix-afnix-sio-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">afnix-sio<small> (3)</small></h1>
        <p class="lead">Standard input/output module</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/afnix-sio.3.html">
      <span itemprop="name">afnix-sio: Standard input/output module</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/afnix/">
      <span itemprop="name">afnix</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/afnix-sio.3.html">
      <span itemprop="name">afnix-sio: Standard input/output module</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">STANDARD INPUT/OUTPUT MODULE</h2>
        <div class="sectioncontent">
<p>The Standard Input/Output module is an orginal implementation that provides objects for i/o operations. Although input and output files are the standard objects that one might expect, the module facilities for directory access, path manipulation and i/o event management. At the heart of this module is the concept of stream associated with the transcoding object which enable the passage between one coding system to another. It is also this module which provides the stream selector object.</p><p><strong>Input and output streams</strong></p><p>The afnix-sio module is based on facilities provided by two base classes, namely, the InputStream stream and the OutputStream stream. Both classes have associated predicates with the name input-stream-p and output-stream-p. The base class associated is the Stream class those sole purpose is to define the stream coding mode.</p><p><em>Stream base class</em></p><p>The Stream class is the base class for the InputStream and OutputStream classes. The Stream class is used to define the stream coding mode that affects how characters are read or written. When a stream operates in byte mode, each character is assumed to be encoded in one byte. In that case, the input stream methods read and getu are equivalent and no transformation is performed when writing characters. This behavior is the default stream behavior. For certain stream, like terminal, this behavior is changed depending on the current localization settings. For instance, if the current locale is operating with an UTF-8 codeset, the Terminal stream coding mode is automatically adjusted to reflect this situation. Since the US-ASCII codeset is predominant and the default steam coding mode is the byte mode, there should be no conflict during the read and write operations.</p><p><em>Stream transcoding</em></p><p>The Stream class provides the support for the transcoding of different codesets. All ISO-8859 codesets are supported. Since the engine operates internally with Unicode characters, the transcoding operation takes care of changing a character in one particular codeset into its equivalent Unicode representation. This operation is done for an input stream that operates in byte mode. For an output stream, the opposite operation is done. An internal Unicode characters representation is therefore mapped into a particular codeset. Note that only the codeset characters can be mapped.</p><table class="table table-striped">
<tr>
<th>Codeset</th>
<th>Description</th></tr>

<tr>
<td>DEFAULT</td>
<td>Default codeset, i.e US-ASCII</td></tr>

<tr>
<td>ISO-01</td>
<td>ISO-8859-1 codeset</td></tr>

<tr>
<td>ISO-02</td>
<td>ISO-8859-2 codeset</td></tr>

<tr>
<td>ISO-03</td>
<td>ISO-8859-3 codeset</td></tr>

<tr>
<td>ISO-04</td>
<td>ISO-8859-4 codeset</td></tr>

<tr>
<td>ISO-05</td>
<td>ISO-8859-5 codeset</td></tr>

<tr>
<td>ISO-06</td>
<td>ISO-8859-6 codeset</td></tr>

<tr>
<td>ISO-07</td>
<td>ISO-8859-7 codeset</td></tr>

<tr>
<td>ISO-08</td>
<td>ISO-8859-8 codeset</td></tr>

<tr>
<td>ISO-09</td>
<td>ISO-8859-9 codeset</td></tr>

<tr>
<td>ISO-10</td>
<td>ISO-8859-10 codeset</td></tr>

<tr>
<td>ISO-11</td>
<td>ISO-8859-11 codeset</td></tr>

<tr>
<td>ISO-13</td>
<td>ISO-8859-13 codeset</td></tr>

<tr>
<td>ISO-14</td>
<td>ISO-8859-14 codeset</td></tr>

<tr>
<td>ISO-15</td>
<td>ISO-8859-15 codeset</td></tr>

<tr>
<td>ISO-16</td>
<td>ISO-8859-16 codeset</td></tr>

<tr>
<td>UTF-08</td>
<td>Unicode UTF-8 codeset</td></tr>
</table><p>The set-encoding-mode can be used to set the stream encoding codeset. The method operates either by enumeration or string. The get-encoding-mode returns the stream encoding mode. There are some time good reasons to force a stream encoding mode. For example, a file encoded in UTF-8 that is read will require this call since the default stream mode is to work in byte mode. It should be noted that there is a difference between the enumeration and the string encoding mode. The enumeration mode defines whether the stream operates in byte or UTF-8 mode. When the stream operates in byte mode, it is also necessary to define the transcoding mode with the set-transcoding-mode method. For simplicity, the string version of the set-encoding-mode takes care of setting both the stream mode and the transcoding mode. It is also worth to note that internally, the Stream class is derived from the Transcoder class.</p><p><em>Input stream</em></p><p>The InputStream base class has several method for reading and testing for byte availability. Moreover, the class provides a push-back buffer. Reading bytes is in the form of three methods. The read method without argument returns the next available byte or the end-of-streameos. With an integer argument, the read method returns a Buffer with at most the number of requested bytes. The readln method returns the next available line. When it is necessary to read characters instead of bytes, the getu is more appropriate since it returns an Unicode character.</p><p><em>Output stream</em></p><p>The OutputStream base class provides the base methods to write to an output stream. The write method takes literal objects which are automatically converted to string representation and then written to the output stream. Note that for the case of a Buffer object, it is the buffer itself that take a stream argument and not the opposite.</p><p><em>The valid-p predicate</em></p><p>The input stream provides a general mechanism to test and read for bytes. The base method is the valid-p predicate that returns true if a byte can be read from the stream. It is important to understand its behavior which depends on the stream type. Without argument, the valid-p predicate checks for an available byte from the input stream. This predicate will block if no byte is available. On the other end, for a bounded stream like an input file, the method will not block at the end of file. With one integer argument, the valid-p predicate will timeout after the specified time specified in milliseconds. This second behavior is particularly useful with unbound stream like socket stream.</p><p><em>The eos-p predicate</em></p><p>The eos-p predicate does not take argument. The predicate behaves like not (valid-p 0). However, there are more subtle behaviors. For an input file, the predicate will return true if and only if a byte cannot be read. If a byte has been pushed-back and the end-of-stream marker is reached, the method will return false. For an input terminal, the method returns true if the user and entered the end-of-stream byte. Once again, the method reacts to the contents of the push-back buffer. For certain input stream, like a tcp socket, the method will return true when no byte can be read, that is here, the connection has been closed. For an udp socket, the method will return true when all datagram bytes have be read.</p><p><em>The read method</em></p><p>The read method is sometimes disturbing. Nevertheless, the method is a blocking one and will return a byte when completed. The noticeable exception is the returned byte when an end-of-stream marker has been reached. The method returns the ctrl-d byte. Since a binary file might contains valid byte like ctrl-d it is necessary to use the valid-p or eos-p predicate to check for a file reading completion. This remark apply also to bounded streams like a tcp socket. For some type of streams like a udp socket, the method will block when all datagram bytes have been consumed and no more datagram has arrived. With this kind of stream, there is no end-of-stream condition and therefore care should be taken to properly assert the stream content. This last remark is especially true for the readln method. The method will return when the end-of-stream marker is reached, even if a newline byte has not been read. With an udp socket, such behavior will not happen.</p><p><em>Buffer read mode</em></p><p>The read method with an integer argument, returns a buffer with at least the number of bytes specified as an argument. This method is particularly useful when the contents has a precise size. The method returns a Buffer object which can later be used to read, or transform bytes. Multi-byte conversion to number should use such approach. The read method does not necessarily returns the number of requested bytes. Once the buffer is returned, the length method can be used to check the buffer size. Note also the existence of the to-string method which returns a string representation of the buffer.</p>
<pre>
# try to read 256 bytes
const buf (is:read 256)
# get the buffer size
println (buf:length)
# get a string representation
println (buf:to-string)
</pre>
<p><strong>File stream</strong></p><p>The afnix-sio module provides two classes for file access. The InputFile class open a file for input. The OutputFile class opens a file for output. The InputFile class is derived from the InputStream base class. The OutputFile class is derived from the OutputStream class. By default an output file is created if it does not exist. If the file already exist, the file is truncated to 0. Another constructor for the output file gives more control about this behavior. It takes two boolean flags that defines the truncate and append mode.</p>
<pre>
# load the module
interp:library "afnix-sio"
# create an input file by name
const if (afnix:sio:InputFile "orig.txt")
# create an output file by name
const of (afnix:sio:OutputFile "copy.txt")
</pre>
<p><em>Stream information</em></p><p>Both InputFile and OutputFile supports the get-name method which returns the file name.</p>
<pre>
println (if:get-name)
println (of:get-name)
</pre>
<p>Predicates are also available for these classes. The input-file-p returns true for an input file object.The output-file-p returns true for an output file object.</p>
<pre>
afnix:sio:input-stream-p  if
afnix:sio:output-stream-p of
afnix:sio:input-file-p    if
afnix:sio:output-file-p   of
</pre>
<p><em>Reading and writing</em></p><p>The read method reads a byte on an input stream. The write method writes one or more literal arguments on the output stream. The writeln method writes one or more literal arguments followed by a newline byte on the output stream. The newline method write a newline byte on the output stream. The eos-p predicate returns true for an input stream, if the stream is at the end. The valid-p predicate returns true if an input stream is in a valid state. With these methods, copying a file is a simple operation.</p>
<pre>
# load the module and open the files
interp:library "afnix-sio"
const if (afnix:sio:InputFile "orig.txt")
const of (afnix:sio:OutputFile "copy.txt")
# loop in the input file and write
while (if:valid-p) (of:write (if:read))
</pre>
<p>The use of the readln method can be more effective. The example below is a simple cat program which take the file name an argument.</p>
<pre>
# cat a file on the output terminal
# usage: axi 0601.als file
# get the io module
interp:library "afnix-sio"
# cat a file
const cat (name) {
  const f (afnix:sio:InputFile name)
  while (f:valid-p) (println (f:readln))
  f:close
}
# get the file
if (== 0 (interp:argv:length)) {
  errorln "usage: axi 0601.als file"
} {
  cat (interp:argv:get 0)
}
</pre>
<p><strong>Multiplexing</strong></p><p>I/O multiplexing is the ability to manipulate several streams at the same time and process one at a time. Although the use of threads reduce the needs for i/o multiplexing, there is still situations where they are needed. In other words, I/O multiplexing is identical to the valid-p predicate, except that it works with several stream objects.</p><p><em>Selector object</em></p><p>I/O multiplexing is accomplished with the Selector class. The constructor takes 0 or several stream arguments. The class manages automatically to differentiate between InputStream stream and OutputStream streams. Once the class is constructed, it is possible to get the first stream ready for reading or writing or all of them. We assume in the following example that is and os are respectively an input and an output stream.</p>
<pre>
# create a selector
const slt (afnix:sio:Selector is)
# at this stage the selector has one stream
# the add method can add more streams
slt:add os
</pre>
<p>The add method adds a new stream to the selector. The stream must be either an InputStream and OutputStream stream or an exception is raised. If the stream is both an input and an output stream, the preference is given to the input stream. If this preference is not acceptable, the input-add or the output-add methods might be preferable. The input-length method returns the number of input streams in this selector. The output-length method returns the number of output streams in this selector. The input-get method returns the selector input stream by index. The output-get method returns the selector output stream by index.</p><p><em>Waiting for i/o event</em></p><p>The wait and wait-all methods can be used to detect a status change in the selector. Without argument both methods will block indefinitely until one stream change. With one integer argument, both method blocks until one stream change or the integer argument timeout expires. The timeout is expressed in milliseconds. Note that 0 indicates an immediate return. The wait method returns the first stream which is ready either for reading or writing depending whether it is an input or output stream. The wait-all method returns a vector with all streams that have changed their status. The wait method returns nil if the no stream have changed. Similarly, the wait-all method returns an empty vector.</p>
<pre>
# wait for a status change
const is (slt:wait)
# is is ready for reading - make sure it is an input one
if (afnix:sio:input-stream-p is) (is:read)
</pre>
<p>A call to the wait method will always returns the first input stream.</p><p><em>Marking mode</em></p><p>When used with several input streams in a multi-threaded context, the selector behavior can becomes quite complicated. For this reason, the selector can be configured to operate in marking mode. In such mode, the selector can be marked as ready by a thread independently of the bounded streams. This is a useful mechanism which can be used to cancel a select loop. The mark method is designed to mark the selector while the marked-p predicate returns true if the stream has been marked.</p><p><strong>Terminal streams</strong></p><p>Terminal streams are another kind of streams available in the standard i/o module. The InputTerm, OutputTerm and ErrorTerm classes are low level classes used to read or write from or to the standard streams. The basic methods to read or write are the same as the file streams. Reading from the input terminal is not a good idea, since the class does not provide any formatting capability. One may prefer to use the Terminal class. The use of the output terminal or error terminal streams is convenient when the interpreter standard streams have been changed but one still need to print to the terminal.</p><p><em>Terminal class</em></p><p>The Terminal class combines an input stream and an output stream with some line editing capabilities. When the class is created, the constructed attempts to detect if the input and output streams are bounded to a terminal (i.e tty). If the line editing capabilities can be loaded (i.e non canonical mode), the terminal is initialized for line editing. Arrows, backspace, delete and other control sequences are available when using the read-line method. The standard methods like read or readln do not use the line editing features. When using a terminal, the prompt can be set to whatever the user wishes with the methods set-primary-prompt or set-secondary-prompt. A secondary prompt is displayed when the read-line method is called with the boolean argument false.</p>
<pre>
const term (Terminal)
term:set-primary-prompt "demo:"
const line (term:read-line)
errorln line
</pre>
<p><em>Using the error terminal</em></p><p>The ErrorTerm class is the most frequently used class for printing data on the standard error stream. The reserved keywords error or errorln are available to write on the interpreter error stream. If the interpreter error stream has been changed, the use of the ErrorTerm will provide the facility required to print directly on the terminal. The cat program can be rewritten to do exactly this.</p>
<pre>
# cat a file on the error terminal
# get the io module
interp:library "afnix-sio"
# cat a file
const cat (name es) {
  const f (afnix:sio:InputFile name)
  while (f:valid-p) (es:writeln (f:readln))
  f:close
}
</pre>
<p><strong>Directory</strong></p><p>The Directory class provides a facility to manipulate directories. A directory object is created either by name or without argument by considering the current working directory. Once the directory object is created, it is possible to retrieve its contents, create new directory or remove empty one.</p><p><em>Reading a directory</em></p><p>A Directory object is created either by name or without argument. With no argument, the current directory is opened. When the current directory is opened, its full name is computed internally and can be retrieved with the get-name method.</p>
<pre>
# print the current directory
const pwd (afnix:sio:Directory)
println   (pwd:get-name)
</pre>
<p>Once the directory object is opened, it is possible to list its contents. The get-list method returns the full contents of the directory object. The get-files method returns a list of files in this directory. The get-subdirs method returns a list of sub directories in this directory.</p>
<pre>
# print a list of files
const pwd (afnix:sio:Directory)
const lsf (d:get-files)
for (name) (lsf) (println name)
</pre>
<p><em>Creating and removing directories</em></p><p>The mkdir and rmdir methods can be used to create or remove a directory. Both methods take a string argument and construct a full path name from the directory name and the argument. This approach has the advantage of being file system independent. If the directory already exists, the mkdir methods succeeds. The rmdir method requires the directory to be empty.</p>
<pre>
const tmp (afnix:sio:Directory (
    afnix:sio:absolute-path "tmp"))
const exp (tmp:mkdir "examples")
const lsf (exp:get-files)
println   (lsf:length)
tmp:rmdir "examples"
</pre>
<p>The function absolute-path constructs an absolute path name from the argument list. If relative path needs to be constructed, the function relative-path might be used instead.</p><p><strong>Logtee</strong></p><p>The Logtee class is a message logger facility associated with an output stream. When a message is added to the logger object, the message is also sent to the output stream, depending on the controlling flags. The name "logtee" comes from the contraction of "logger" and "tee". One particularity of the class is that without a stream, the class behaves like a regular logger.</p><p><em>Creating a logger</em></p><p>The Logtee default constructor creates a standard logger object without an output stream. The instance can also be created by size or with an output stream or both. A third method can also attach an information string.</p>
<pre>
# create a logger with the interpreter stream
const log (Logtee (interp:get-output-stream))
assert true (logger-p log)
</pre>
<p><em>Adding messages</em></p><p>The process of adding messages is similar to the regular logger. The only difference is that the message is placed on the output stream if a control flag is set and the message level is less or equal the report level. In the other word, the control flag controls the message display -- the tee operation -- while the report level filters some of the messages.</p>
<pre>
log:add 2 "a level 2 message"
</pre>
<p>The set-tee method sets the control flag. The set-report-level method sets the report level. Note that the set-report-level and its associated get-report-level method is part of the base Logger class.</p><p><strong>Path name</strong></p><p>The Pathname class is a base class designed to ease the manipulation of system path. It is particularly useful when it come to manipulate directory component.</p><p><em>Creating a path name</em></p><p>A path name is created either by file name or by file and directory name. In the first case, only the file name is used. In the second case, the full path name is characterized.</p>
<pre>
# create a new path name
const path (afnix:sio:Pathname "axi")
</pre>
<p><em>Adding a directory path</em></p><p>The best way to add a directory path is to use the absolute-path or the relative-path functions.</p>
<pre>
# adding a directory path
const name (afnix:sio:absolute-path "usr" "bin")
path:set-directory-name name
</pre>
<p><em>Getting the path information</em></p><p>The path information can be obtained individually or globally. The get-file-name and get-directory-name methods return respectively the file and directory name. The get-root method returns the root component of the directory name. The get-full method returns the full path name.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">STANDARD INPUT/OUTPUT REFERENCE</h2>
        <div class="sectioncontent">
<p><strong>Transcoder</strong></p><p>The Transcoder class is a codeset transcoder class. The class is responsible to map a byte character in a given codeset into its associated Unicode character. It should be noted that not all characters can be transcoded.</p><p><em>Predicate</em></p><p>transcoder-p</p><p><em>Inheritance</em></p><p>Object</p><p><em>Constants</em></p><p><strong>DEFAULT</strong></p><p>The DEFAULT constant is used by the set-transcoding-mode method to specify the class transcoding mode. In default mode, each character is not transcoded. This mode is the identity mode.</p><p><strong>I8859-01</strong></p><p>The I8859-01 constant is used by the set-transcoding-mode method to specify the class transcoding mode that corresponds to the ISO-8859-6 codeset.</p><p><strong>I8859-02</strong></p><p>The I8859-02 constant is used by the set-transcoding-mode method to specify the class transcoding mode that corresponds to the ISO-8859-2 codeset.</p><p><strong>I8859-03</strong></p><p>The I8859-03 constant is used by the set-transcoding-mode method to specify the class transcoding mode that corresponds to the ISO-8859-3 codeset.</p><p><strong>I8859-04</strong></p><p>The I8859-04 constant is used by the set-transcoding-mode method to specify the class transcoding mode that corresponds to the ISO-8859-4 codeset.</p><p><strong>I8859-05</strong></p><p>The I8859-05 constant is used by the set-transcoding-mode method to specify the class transcoding mode that corresponds to the ISO-8859-5 codeset.</p><p><strong>I8859-06</strong></p><p>The I8859-06 constant is used by the set-transcoding-mode method to specify the class transcoding mode that corresponds to the ISO-8859-6 codeset.</p><p><strong>I8859-07</strong></p><p>The I8859-07 constant is used by the set-transcoding-mode method to specify the class transcoding mode that corresponds to the ISO-8859-7 codeset.</p><p><strong>I8859-08</strong></p><p>The I8859-08 constant is used by the set-transcoding-mode method to specify the class transcoding mode that corresponds to the ISO-8859-8 codeset.</p><p><strong>I8859-09</strong></p><p>The I8859-09 constant is used by the set-transcoding-mode method to specify the class transcoding mode that corresponds to the ISO-8859-9 codeset.</p><p><strong>I8859-10</strong></p><p>The I8859-10 constant is used by the set-transcoding-mode method to specify the class transcoding mode that corresponds to the ISO-8859-10 codeset.</p><p><strong>I8859-11</strong></p><p>The I8859-11 constant is used by the set-transcoding-mode method to specify the class transcoding mode that corresponds to the ISO-8859-11 codeset.</p><p><strong>I8859-13</strong></p><p>The I8859-13 constant is used by the set-transcoding-mode method to specify the class transcoding mode that corresponds to the ISO-8859-13 codeset.</p><p><strong>I8859-14</strong></p><p>The I8859-14 constant is used by the set-transcoding-mode method to specify the class transcoding mode that corresponds to the ISO-8859-14 codeset.</p><p><strong>I8859-15</strong></p><p>The I8859-15 constant is used by the set-transcoding-mode method to specify the class transcoding mode that corresponds to the ISO-8859-15 codeset.</p><p><strong>I8859-16</strong></p><p>The I8859-16 constant is used by the set-transcoding-mode method to specify the class transcoding mode that corresponds to the ISO-8859-16 codeset.</p><p><em>Constructors</em></p><p><strong>Transcoder (none)</strong></p><p>The Transcoder constructor creates a default transcoder that operates in default mode by using the identity function.</p><p><strong>Transcoder (constant)</strong></p><p>The Transcoder constructor creates a transcoder with the argument mode.</p><p><em>Methods</em></p><p><strong>set-transcoding-mode -&gt; none (constant)</strong></p><p>The set-transcoding-mode method sets the class transcoding mode.</p><p><strong>get-transcoding-mode -&gt; constant (none)</strong></p><p>The get-transcoding-mode method returns the class transcoding mode.</p><p><strong>valid-p -&gt; Byte|Character (Boolean)</strong></p><p>The valid-p predicate returns true if character can be transcoded. If the argument is a byte, the method returns true if the byte can be transcoded to a character. If the argument is a character, the method returns true if the character can be transcoded to a byte.</p><p><strong>encode -&gt; Byte (Character)</strong></p><p>The encode method encodes a byte into a character. If the character cannot be encoded, an exception is raised.</p><p><strong>decode -&gt; Character (Byte)</strong></p><p>The decode method decodes a character into a byte. If the character cannot be decoded, an exception is raised.</p><p><strong>Stream</strong></p><p>The Stream class is a base class for the standard streams. The class is automatically constructed by a derived class and provides the common methods for all streams.</p><p><em>Predicate</em></p><p>stream-p</p><p><em>Inheritance</em></p><p>Transcoder</p><p><em>Constants</em></p><p><strong>BYTE</strong></p><p>The BYTE constant is used by the set-coding-mode method to specify the stream coding mode. In byte mode, each character is assumed to be coded with one byte. This value affects the getu and write methods</p><p><strong>UTF-8</strong></p><p>The UTF-8 constant is used by the set-coding-mode method to specify the stream coding mode. In UTF-8 mode, each character is assumed to be coded in the UTF-8 representation. This value affects the getu and write methods</p><p><em>Methods</em></p><p><strong>set-encoding-mode -&gt; none (constant|String)</strong></p><p>The set-encoding-mode method sets the stream coding mode that affects how characters are read or written. In the enumeration form, the method only sets the stream coding mode which is either byte or UTF-8 mode. In the string mode, the method sets the stream encoding mode and the transcoding mode.</p><p><strong>get-encoding-mode -&gt; constant (none)</strong></p><p>The get-coding-mode method returns the stream coding mode which affects how characters are read or written.</p><p><strong>InputStream</strong></p><p>The InputStream class is a base class for the standard i/o module. The class is automatically constructed by a derived class and provides the common methods for all input streams. The input stream is associated with a timeout value which is used for read operation. By default, timeout is infinite, meaning that any read without data will be a blocking one.</p><p><em>Predicate</em></p><p>input-stream-p</p><p><em>Inheritance</em></p><p>Stream</p><p><em>Methods</em></p><p><strong>flush -&gt; none|Character (none)</strong></p><p>The flush method the input stream buffer. In the first form, without argument, the input stream buffer is entirely flushed. In the second form, the input stream buffer is flushed until the character argument is found.</p><p><strong>get-timeout -&gt; Integer (none)</strong></p><p>The get-timeout method returns the input stream timeout. A negative value is a blocking timeout.</p><p><strong>set-timeout -&gt; none (Integer)</strong></p><p>The set-timeout method sets the input stream timeout. A negative value is a blocking timeout. Changing the stream timeout does not cancel any pending read operation.</p><p><strong>read -&gt; Byte (none)</strong></p><p>The read method returns the next byte available from the input stream. If the stream has been closed or consumed, the end-of-stream byte is returned.</p><p><strong>read -&gt; Buffer (Integer)</strong></p><p>The read method returns a buffer object with at most the number of bytes specified as an argument. The buffer length method should be used to check how many bytes have been placed in the buffer.</p><p><strong>readln -&gt; String (none)</strong></p><p>The readln method returns the next line available from the input stream. If the stream has been closed or consumed, the end-of-stream character is returned.</p><p><strong>getu -&gt; Character (none)</strong></p><p>The getu method returns the next available Unicode character from the input stream. If the stream has been closed or consumed, the end-of-stream character is returned. During the read process, if the character decoding operation fails, an exception is raised.</p><p><strong>valid-p -&gt; Boolean (none|Integer)</strong></p><p>The valid-p method returns true if the input stream is in a valid state. By valid state, we mean that the input stream can return a byte with a call to the read method. With one argument, the method timeout after the specified time in milliseconds. If the timeout is null, the method returns immediately. With -1, the method blocks indefinitely if no byte is available.</p><p><strong>eos-p -&gt; Boolean (none)</strong></p><p>The eos-p predicate returns true if the input stream has been closed or all bytes consumed.</p><p><strong>pushback -&gt; Integer (Byte|Character|String)</strong></p><p>The pushback method push-back a byte, an Unicode character or a string in the input stream. Subsequent calls to read will return the last pushed bytes. Pushing a string is equivalent to push each encoded bytes of the string. The method returns the number of bytes pushed back.</p><p><strong>get-buffer-length -&gt; Integer (none)</strong></p><p>The get-buffer-length method returns the length of the push-back buffer.</p><p><strong>to-string -&gt; String (none)</strong></p><p>The to-string method returns a string representation of the input stream buffer.</p><p><strong>InputFile</strong></p><p>The InputFile class provide the facility for an input file stream. An input file instance is created with a file name. If the file does not exist or cannot be opened, an exception is raised. The InputFile class is derived from the InputStream class.</p><p><em>Predicate</em></p><p>input-file-p</p><p><em>Inheritance</em></p><p>InputStreamNameable</p><p><em>Constructors</em></p><p><strong>InputFile (String)</strong></p><p>The InputFile constructor create an input file by name. If the file cannot be created, an exception is raised. The first argument is the file name to open.</p><p><strong>InputFile (String String)</strong></p><p>The InputFile constructor create an input file by name and encoding mode. If the file cannot be created, an exception is raised. The first argument is the file name to open.The second argument is the encoding mode to use.</p><p><em>Methods</em></p><p><strong>close -&gt; Boolean (none)</strong></p><p>The close method close the input file and returns true on success, false otherwise. In case of success, multiple calls return true.</p><p><strong>lseek -&gt; none (Integer)</strong></p><p>The lseek set the input file position to the integer argument. Note that the push-back buffer is reset after this call.</p><p><strong>length -&gt; Integer (none)</strong></p><p>The length method returns the length of the input file. The length is expressed in bytes.</p><p><strong>get-modification-time -&gt; Integer (none)</strong></p><p>The get-modification-time method returns the modification time of the file. The returned argument is suitable for the Time and Date system classes.</p><p><strong>InputMapped</strong></p><p>The InputMapped class is an input stream class that provides the facility for reading a mapped input stream. The input stream is mapped at construction given a file name, a size and a file offset. An anonymous mapped input stream can also be designed with a buffer object. Finally, without any information an always valid null input stream is constructed.</p><p><em>Predicate</em></p><p>input-mapped-p</p><p><em>Inheritance</em></p><p>InputStream</p><p><em>Constructors</em></p><p><strong>InputMapped (none)</strong></p><p>The InputMapped constructor create a null input stream. This stream acts as a null character generator.</p><p><strong>InputMapped (String|Buffer)</strong></p><p>The InputMapped constructor create a mapped input stream by name or buffer. In the first form, a string is used as file name to be mapped an input stream. In the second form, a buffer is mapped as an input stream.</p><p><strong>InputMapped (String Integer Integer)</strong></p><p>The InputMapped constructor create a mapped input stream by name, size and offset. The string argument is the file name to map. The second argument is the desired mapped size. The third argument is the offset inside the file before mapping it.</p><p><em>Methods</em></p><p><strong>lseek -&gt; none (Integer)</strong></p><p>The lseek set the input mapped file position to the integer argument. Note that the push-back buffer is reset after this call.</p><p><strong>length -&gt; Integer (none)</strong></p><p>The length method returns the length of the input mapped file. The length is expressed in bytes.</p><p><strong>InputString</strong></p><p>The InputString class provide the facility for an input string stream. The class is initialized or set with a string and then behaves like a stream. This class is very useful to handle generic stream method without knowing what kind of stream is behind it.</p><p><em>Predicate</em></p><p>input-string-p</p><p><em>Inheritance</em></p><p>InputStream</p><p><em>Constructors</em></p><p><strong>InputString (none)</strong></p><p>The InputString constructor creates an empty input string.</p><p><strong>InputString (String)</strong></p><p>The InputString constructor creates an input string by value.</p><p><em>Methods</em></p><p><strong>get -&gt; Byte (none)</strong></p><p>The get method returns the next available byte from the input stream but do not remove it.</p><p><strong>set -&gt; none (String)</strong></p><p>The set method sets the input string by first resetting the push-back buffer and then initializing the input string with the argument value.</p><p><strong>InputTerm</strong></p><p>The InputTerm class provide the facility for an input terminal stream. The input terminal reads byte from the standard input stream. No line editing facility is provided with this class This is a low level class, and normally, the Terminal class should be used instead.</p><p><em>Predicate</em></p><p>input-term-p</p><p><em>Inheritance</em></p><p>InputStreamOutputStream</p><p><em>Constructors</em></p><p><strong>InputTerm (none)</strong></p><p>The InputTerm constructor creates a default input terminal.</p><p><em>Methods</em></p><p><strong>set-ignore-eos -&gt; none (Boolean)</strong></p><p>The set-ignore-eos method set the input terminal end-of-stream ignore flag. When the flag is on, any character that match a ctrl-d is changed to the end-of-stream mapped character returned by a read. This method is useful to prevent a reader to exit when the ctrl-d byte is generated.</p><p><strong>set-mapped-eos -&gt; none (Byte)</strong></p><p>The set-mapped-eos method set the input terminal end-of-stream mapped character. By default the character is set to end-of-line. This method should be used in conjunction with the set-ignore-eos method.</p><p><strong>OutputStream</strong></p><p>The OutputStream class is a base class for the standard i/o module. The class is automatically constructed by a derived class and provide the common methods for all output streams.</p><p><em>Predicate</em></p><p>output-stream-p</p><p><em>Inheritance</em></p><p>Stream</p><p><em>Methods</em></p><p><strong>write -&gt; Integer (Literal+)</strong></p><p>The write method write one or more literal arguments on the output stream. This method returns the number of characters written.</p><p><strong>writeln -&gt; none (Literal+)</strong></p><p>The writeln method write one or more literal argument to the output stream and finish with a newline. This method return nil.</p><p><strong>errorln -&gt; none (Literal+)</strong></p><p>The errorln method write one or more literal argument to the associated output error stream and finish with a newline. Most of the time, the output stream and error stream are the same except for an output terminal.</p><p><strong>newline -&gt; none (none)</strong></p><p>The newline method writes a new line byte to the output stream. The method returns nil.</p><p><strong>write-soh -&gt; none (none)</strong></p><p>The write-soh method writes a start-of-heading character to the output stream.</p><p><strong>write-stx -&gt; none (none)</strong></p><p>The write-stx method writes a start-of-transmission character to the output stream.</p><p><strong>write-etx -&gt; none (none)</strong></p><p>The write-etx method writes an end-of-transmission character to the output stream.</p><p><strong>write-eos -&gt; none (none)</strong></p><p>The write-eos method writes an end-of-stream character to the output stream.</p><p><strong>OutputFile</strong></p><p>The OutputFile class provide the facility for an output file stream. An output file instance is created with a file name. If the file does not exist, it is created. If the file cannot be created, an exception is raised. Once the file is created, it is possible to write literals. The class is derived from the OutputStream class. By default an output file is created if it does not exist. If the file already exist, the file is truncated to 0. Another constructor for the output file gives more control about this behavior. It takes two boolean flags that defines the truncate and append mode. The t-flag is the truncate flag. The a-flag is the append flag.</p><p><em>Predicate</em></p><p>output-file-p</p><p><em>Inheritance</em></p><p>OutputStreamNameable</p><p><em>Constructors</em></p><p><strong>OutputFile (String)</strong></p><p>The OutputFile constructor create an output file by name. If the file cannot be created, an exception is raised. The first argument is the file name to create.</p><p><strong>OutputFile (String String)</strong></p><p>The OutputFile constructor create an output file by name and encoding mode. If the file cannot be created, an exception is raised. The first argument is the file name to create. The second argument is the encoding mode to use.</p><p><strong>OutputFile (String Boolean Boolean)</strong></p><p>The OutputFile constructor create an output file by name. If the file cannot be created, an exception is raised. The first argument is the file name to create. The second argument is the truncate flag. If the file already exists and the truncate flag is set, the file is truncated to 0. The third argument is the append mode. If set to true, the file is open in append mode.</p><p><em>Methods</em></p><p><strong>close -&gt; Boolean (none)</strong></p><p>The close method closes the output file and returns true on success, false otherwise. In case of success, multiple calls returns true.</p><p><strong>OutputString</strong></p><p>The OutputString class provide the facility for an output string stream. The class is initially empty and acts as a buffer which accumulate the write method bytes. The to-string method can be used to retrieve the buffer content.</p><p><em>Predicate</em></p><p>output-string-p</p><p><em>Inheritance</em></p><p>OutputStream</p><p><em>Constructors</em></p><p><strong>OutputString (none)</strong></p><p>The OutputString constructor creates a default output string.</p><p><strong>OutputString (String)</strong></p><p>The OutputString constructor creates an output string by value. The output string stream is initialized with the string value.</p><p><em>Methods</em></p><p><strong>flush -&gt; none (none)</strong></p><p>The flush method flushes the output stream by resetting the stream buffer.</p><p><strong>length -&gt; Integer (none)</strong></p><p>The length method returns the length of the output string buffer.</p><p><strong>to-string -&gt; String (none)</strong></p><p>The to-string method returns a string representation of the output string buffer.</p><p><strong>OutputBuffer</strong></p><p>The OutputBuffer class provide the facility for an output byte stream. The class is initially empty and acts as a buffer which accumulate the write method bytes. The to-string method can be used to retrieve the buffer content as a string. The format method can be used to retrieve the buffer content as an octet string. content.</p><p><em>Predicate</em></p><p>output-buffer-p</p><p><em>Inheritance</em></p><p>OutputStream</p><p><em>Constructors</em></p><p><strong>OutputBuffer (none)</strong></p><p>The OutputBuffer constructor creates a default output buffer.</p><p><strong>OutputBuffer (String)</strong></p><p>The OutputBuffer constructor creates an output buffer by value. The output buffer stream is initialized with the string value.</p><p><em>Methods</em></p><p><strong>flush -&gt; none (none)</strong></p><p>The flush method flushes the output stream by resetting the stream buffer.</p><p><strong>length -&gt; Integer (none)</strong></p><p>The length method returns the length of the output buffer.</p><p><strong>to-string -&gt; String (none)</strong></p><p>The to-string method returns a string representation of the output buffer.</p><p><strong>format -&gt; String (none)</strong></p><p>The format method returns an octet string representation of the output buffer.</p><p><strong>OutputTerm</strong></p><p>The OutputTerm class provide the facility for an output terminal. The output terminal is defined as the standard output stream. If the standard error stream needs to be used, the ErrorTerm class is more appropriate.</p><p><em>Predicate</em></p><p>output-term-p</p><p><em>Inheritance</em></p><p>OutputStream</p><p><em>Constructors</em></p><p><strong>OutputTerm (none)</strong></p><p>The OutputTerm constructor creates a default output terminal</p><p><strong>ErrorTerm (none)</strong></p><p>The ErrorTerm constructor creates a default error terminal</p><p><strong>Terminal</strong></p><p>The Terminal class provides the facility for an i/o terminal with line editing capability. The class combines the InputTerm and OutputTerm methods.</p><p><em>Predicate</em></p><p>terminal-p</p><p><em>Inheritance</em></p><p>InputTermOutputTerm</p><p><em>Constructors</em></p><p><strong>Terminal (none)</strong></p><p>The Terminal constructor creates a default terminal which combines an input and output terminal with line editing capabilities.</p><p><em>Methods</em></p><p><strong>set-primary-prompt -&gt; none (String)</strong></p><p>The set-primary-prompt method sets the terminal primary prompt which is used when the read-line method is called.</p><p><strong>set-secondary-prompt -&gt; none (String)</strong></p><p>The set-secondary-prompt method sets the terminal secondary prompt which is used when the read-line method is called.</p><p><strong>get-primary-prompt -&gt; String (none)</strong></p><p>The get-primary-prompt method returns the terminal primary prompt.</p><p><strong>get-secondary -&gt; String (none)</strong></p><p>The get-secondary-prompt method returns the terminal secondary prompt.</p><p><strong>Intercom</strong></p><p>The Intercom class is the interpreter communication class. The class operates with two streams. One output stream is used to send serialized data while the input stream is used to deserialize data. The send method can be used to send the data, while the recv can be used to receive them.</p><p><em>Predicate</em></p><p>intercom-p</p><p><em>Inheritance</em></p><p>Object</p><p><em>Constructors</em></p><p><strong>Intercom (none)</strong></p><p>The Intercom constructor creates a default interpreter communication object. There is no stream attached to it.</p><p><strong>Intercom (InputStream|OutputStream)</strong></p><p>The Intercom constructor creates an interpreter communication object with an input or an output stream. In the first form, the input stream object is used by the recv method to read data object. In the second form, the output stream object is used by the send method to send data object.</p><p><strong>Intercom (InputStream OutputStream)</strong></p><p>The Intercom constructor creates an interpreter communication object with an input and an output stream.</p><p><em>Methods</em></p><p><strong>send -&gt; none (Object)</strong></p><p>The send method serialize the object argument with the help of the output stream bound to the interpreter communication object. If there is no output stream, nothing is sent.</p><p><strong>recv -&gt; Object (none)</strong></p><p>The recv method deserialize an object with the help of the input stream bound to the interpreter communication object. If there is no output stream, nil is returned.</p><p><strong>request -&gt; Object (Object)</strong></p><p>The request method perform an atomic send receive operation.</p><p><strong>set-input-stream -&gt; none (InputStream)</strong></p><p>The set-input-stream method binds an input stream to the interpreter communication object.</p><p><strong>get-input-stream -&gt; InputStream (none)</strong></p><p>The get-input-stream method returns the input stream bound to the interpreter communication object.</p><p><strong>set-output-stream -&gt; none (OutputStream)</strong></p><p>The set-output-stream method binds an output stream to the interpreter communication object.</p><p><strong>get-output-stream -&gt; OutputStream (none)</strong></p><p>The get-output-stream method returns the output stream bound to the interpreter communication object.</p><p><strong>InputOutput</strong></p><p>The InputOutput class implements an input-output stream with a buffer which holds character during the processing of transit between the output stream to the input stream. The theory of operation goes as follow. The internal buffer is filled with characters with the help of the output stream. The characters are consumed from the buffer with the help of the input stream (read method). If the buffer becomes empty the eos-p predicate returns true, the valid-p predicate false and the read method will return the eos character. The InputOutput buffer can also be initialized with a buffer. This provides a nice mechanism to use a buffer like an input stream. The i/o operations implemented by this class are non-blocking. As a consequence, it is not possible to suspend a thread with this class and have it awaken when some characters are available in the input stream.</p><p><em>Predicate</em></p><p>input-output-p</p><p><em>Inheritance</em></p><p>InputStreamOutputStream</p><p><em>Constructors</em></p><p><strong>InputOutput (none)</strong></p><p>The InputOutput constructor creates a default input/output stream.</p><p><strong>InputOutput (String)</strong></p><p>The InputOutput constructor creates an input/output stream initialized with the string argument. The string argument is used to fill the string buffer.</p><p><em>Methods</em></p><p><strong>get -&gt; Byte (none)</strong></p><p>The get method returns the next available byte from the input stream but do not remove it.</p><p><strong>set -&gt; none (String)</strong></p><p>The set method sets the input string by first resetting the push-back buffer and then initializing the input string with the argument value.</p><p><strong>Selector</strong></p><p>The Selector class provides some facilities to perform i/o multiplexing. The constructor takes 0 or several stream arguments.The class manages automatically the differentiation between the InputStream and the OutputStream objects. Once the class is constructed, it is possible to get the first stream ready for reading or writing or all of them. It is also possible to add more steams after construction with the add method. When a call to the wait method succeeds, the method returns the first available stream. If the waitall method is called, the method returns a vector with all ready steams. The selector can be configured to operate in marking mode. In such mode, the selector can be marked as ready by a thread independently of the bounded streams. This is a useful mechanism which can be used to cancel a select loop. The mark method is designed to mark the selector while the marked-p predicate returns true if the stream has been marked.</p><p><em>Predicate</em></p><p>selector</p><p><em>Inheritance</em></p><p>Object</p><p><em>Constructors</em></p><p><strong>Selector (none)</strong></p><p>The Selector constructor creates a default stream selector.</p><p><strong>Selector ([Boolean] [InputStream|OutputStream]*)</strong></p><p>The Selector constructor creates a stream selector with 0 or more stream arguments. If the first argument is a boolean, the selector is constructed marked mode.</p><p><em>Methods</em></p><p><strong>add -&gt; none (InputStream|OutputStream)</strong></p><p>The add method adds an input or output stream to the selector. If the stream is both an input and an output stream, the preference is given to the input stream. If this preference is not acceptable, the input-add or the output-add methods might be preferable.</p><p><strong>input-add -&gt; none (InputStream)</strong></p><p>The input-add method adds an input stream to the selector.</p><p><strong>output-add -&gt; none (OutputStream)</strong></p><p>The output-add method adds an output stream to the selector.</p><p><strong>wait -&gt; Stream (none|Integer)</strong></p><p>The wait method waits for a status change in the selector and returns the first stream that has change status. With one argument, the selector time-out after the specified time in milliseconds. Note that at the time of the return, several streams may have changed status.</p><p><strong>wait-all -&gt; Vector (none|Integer)</strong></p><p>The wait method waits for a status change in the selector and returns all streams that has change status in a vector object. With one argument, the selector time-out after the specified time in milliseconds. If the selector has timed-out, the vector is empty.</p><p><strong>input-get -&gt; InputStream (Integer)</strong></p><p>The input-get method returns the input streams in the selector by index. If the index is out of bound, an exception is raised.</p><p><strong>output-get -&gt; OutputStream (Integer)</strong></p><p>The output-get method returns the output streams in the selector by index. If the index is out of bound, an exception is raised.</p><p><strong>input-length -&gt; Integer (none)</strong></p><p>The input-length method returns the number of input streams in the selector.</p><p><strong>output-length -&gt; Integer (none)</strong></p><p>The output-length method returns the number of output streams in the selector.</p><p><strong>mark -&gt; none (none)</strong></p><p>The mark method marks a selector object.</p><p><strong>marked-p -&gt; Boolean (none)</strong></p><p>The marked-p predicate returns true if the selector has been marked.</p><p><strong>Logtee</strong></p><p>The Logtee class provides the facility of a logger object associated with an output stream. When a message is added, the message is written to the output stream depending on an internal flag. By default the tee mode is false and can be activated with the set-tee method.</p><p><em>Predicate</em></p><p>logtee-p</p><p><em>Inheritance</em></p><p>Logger</p><p><em>Constructors</em></p><p><strong>Logtee (none)</strong></p><p>The Logtee constructor creates a default logger without an output stream.</p><p><strong>Logtee (Integer)</strong></p><p>The Logtee constructor creates a logger with a specific size without an output stream. terminal</p><p><strong>Logtee (OutputStream)</strong></p><p>The Logtee constructor creates a logger with an output stream. The object is initialized to operate in write mode.</p><p><strong>Logtee (Integer OutputStream)</strong></p><p>The Logtee constructor creates a logger with a specific size with an output stream. The first argument is the logger size. The second argument is the output stream.</p><p><strong>Logtee (Integer String OutputStream)</strong></p><p>The Logtee constructor creates a logger with a specific size, an information string and an output stream. The first argument is the logger size. The second argument is information string. The third argument is the output stream.</p><p><em>Methods</em></p><p><strong>set-tee-stream -&gt; none (OutputStream)</strong></p><p>The set-tee-stream method sets the tee output stream. This stream is different from the logger output stream</p><p><strong>get-tee-stream -&gt; OutputStream (none)</strong></p><p>The get-tee-stream method returns the object output stream.</p><p><strong>set-tee -&gt; none (Boolean)</strong></p><p>The set-tee method sets the object tee flag. When the flag is true, the logger writes the added message on the output stream.</p><p><strong>get-tee -&gt; Boolean (none)</strong></p><p>The get-tee method returns the object tee flag. When the flag is true, the logger writes the added message on the output stream.</p><p><strong>Pathname</strong></p><p>The Pathname class is a base class designed to manipulate system i/o paths. The class operates with a directory name and a file name. Both names are kept separated to ease the path manipulation. The path components can be extracted individually. However, it shall be noted that the first component has a special treatment to process the root directory name.</p><p><em>Predicate</em></p><p>pathname-p</p><p><em>Inheritance</em></p><p>Object</p><p><em>Constructors</em></p><p><strong>Pathname (none)</strong></p><p>The Pathname constructor creates a default path name without file and directory names.</p><p><strong>Pathname (String)</strong></p><p>The Pathname constructor creates a path name with a file name. The first string argument is the file name.</p><p><strong>Pathname (String String)</strong></p><p>The Pathname constructor creates a pathname with a file and directory name. The first string argument is the file name. The second string argument is the directory name.</p><p><em>Methods</em></p><p><strong>reset -&gt; none (none)</strong></p><p>The reset method reset the path name by removing all path and file information.</p><p><strong>dir-p -&gt; Boolean (none)</strong></p><p>The dir-p predicate returns true if the path is a directory.</p><p><strong>file-p -&gt; Boolean (none)</strong></p><p>The file-p predicate returns true if the path is a file.</p><p><strong>set-file-name -&gt; none (String)</strong></p><p>The set-file-name method set the path name file name. The string argument is the file name.</p><p><strong>get-file-name -&gt; String (none)</strong></p><p>The get-file-name method returns the path name file name.</p><p><strong>add-directory-name -&gt; none (String)</strong></p><p>The add-directory-name method add the directory name to the directory path component. The string argument is the directory name.</p><p><strong>set-directory-name -&gt; none (String)</strong></p><p>The set-directory-name method set the directory name file name. The string argument is the directory name.</p><p><strong>get-directory-name -&gt; String (none)</strong></p><p>The get-directory-name method returns the path name directory name.</p><p><strong>length -&gt; Integer (none)</strong></p><p>The length method returns the number of directory path elements.</p><p><strong>get-path -&gt; String (Integer)</strong></p><p>The get-path method returns a directory path element by index.</p><p><strong>get-root -&gt; String (none)</strong></p><p>The get-root method returns the root component of a directory name.</p><p><strong>get-full -&gt; String (none)</strong></p><p>The get-full method returns the full path name by combining the directory name with the file name.</p><p><strong>add-path -&gt; none (String)</strong></p><p>The add-path method add a new path component by name. The path is separated into individual component and added to the directory path unless it is a root path. If the file name is set, the file name is added as a directory component. If the path is a root path, a new path name is rebuilt. This last case is equivalent to a call to set-file-name.</p><p><strong>normalize -&gt; none (none)</strong></p><p>The normalize method rebuild the path name by determining the full path nature if possible. In case of success, the path structure reflects the actual path type.</p><p><strong>Pathlist</strong></p><p>The Pathlist class is a base class designed to ease the manipulation of a file search path. The class acts like a list of search paths and various facilities are provided to find a valid path for a given name. The path list can be manipulated like any other list.</p><p><em>Predicate</em></p><p>pathlist-p</p><p><em>Inheritance</em></p><p>Object</p><p><em>Constructors</em></p><p><strong>Pathlist (none)</strong></p><p>The Pathlist constructor creates a default path list.</p><p><strong>Pathlist (Boolean|String)</strong></p><p>The Pathlist constructor creates a path list with a local search flag or with an initial path component. In the first form, a boolean argument controls the local search flag. In the second for, a string argument is used as the initial path component.</p><p><em>Methods</em></p><p><strong>reset -&gt; none (none)</strong></p><p>The reset method resets the path list by clearing the local search flag and removing all path components.</p><p><strong>local-p -&gt; Boolean (none)</strong></p><p>The local-p predicate returns true if the local search flag is set.</p><p><strong>set-local-search -&gt; none (Boolean)</strong></p><p>The set-local-search method sets the local search flag.</p><p><strong>length -&gt; Integer (none)</strong></p><p>The length method returns the number of directory path elements.</p><p><strong>get-path -&gt; String (Integer)</strong></p><p>The get-path method returns a directory path element by index.</p><p><strong>add-path -&gt; none (String)</strong></p><p>The add-path method add a new path component by name. The string argument is the name to add.</p><p><strong>file-p -&gt; Boolean (String)</strong></p><p>The file-p predicate returns true if the file name argument can be resolved. If the local search flag is set, the local directory is check first.</p><p><strong>resolve -&gt; String (String)</strong></p><p>The resolve method returns a string representation of the resolved file path. If the local search flag is set and the file name is found locally, the initial name argument is returned.</p><p><em>Functions</em></p><p><strong>dir-p -&gt; Boolean (String)</strong></p><p>The dir-p function returns true if the argument name is a directory name, false otherwise.</p><p><strong>file-p -&gt; Boolean (String)</strong></p><p>The file-p function returns true if the argument name is a regular file name, false otherwise.</p><p><strong>tmp-name -&gt; String (String?)</strong></p><p>The tmp-name function returns a name suitable for the use as a temporary file name. Without argument, a default prefix is used to build the name. An optional string prefix can control the original name.</p><p><strong>tmp-path -&gt; String (String?)</strong></p><p>The tmp-path function returns a path suitable for the use as a temporary file name. Without argument, a default prefix is used to build the path. An optional string prefix can control the original name.</p><p><strong>absolute-path -&gt; String (String+)</strong></p><p>The absolute-path function returns an absolute path name from an argument list. Without argument, the command returns the root directory name. With one or several argument, the absolute path is computed from the root directory.</p><p><strong>relative-path -&gt; String (String+)</strong></p><p>The relative-path function returns a relative path name from an argument list. With one argument, the function returns it. With two or more arguments, the relative path is computed by joining each argument with the previous one.</p><p><strong>rmfile -&gt; none (String+)</strong></p><p>The rmfile function removes one or several files specified as the arguments. If one file fails to be removed, an exception is raised.</p><p><strong>mkdir -&gt; none (String+)</strong></p><p>The mkdir function creates one or several directories specified as the arguments. If one directory fails to be created, an exception is raised.</p><p><strong>mhdir -&gt; none (String+)</strong></p><p>The mhdir function creates hierarchically one or several directories specified as the arguments. If one directory fails to be created, an exception is raised.</p><p><strong>rmdir -&gt; none (String+)</strong></p><p>The rmdir function removes one or several directories specified as the arguments. If one directory fails to be removed, an exception is raised.</p><p><strong>get-base-name -&gt; String (String)</strong></p><p>The get-base-name function returns the base name from a path. The base name can be either a file name or a directory name. By definition, a path is made of a base path and a base name.</p><p><strong>get-base-path -&gt; String (String)</strong></p><p>The get-base-path function returns the base path from a path. The base path is a directory name. By definition, a path is made of a base path and a base name.</p><p><strong>get-extension -&gt; String (String)</strong></p><p>The get-extension function returns the extension from a path.</p><p><strong>remove-extension -&gt; String (String)</strong></p><p>The remove-extension function returns the extension from a path. In order to get a base file name from a path, the get-base-name function must be called first.</p><p><strong>Directory</strong></p><p>The Directory class provides some facilities to access a directory. By default, a directory object is constructed to represent the current directory. With one argument, the object is constructed from the directory name. Once the object is constructed, it is possible to retrieve its content.</p><p><em>Predicate</em></p><p>directory-p</p><p><em>Inheritance</em></p><p>Object</p><p><em>Constructors</em></p><p><strong>Directory (none)</strong></p><p>The Directory constructor creates a directory object those location is the current directory. If the directory cannot be opened, an exception is raised.</p><p><strong>Directory (String)</strong></p><p>The Directory constructor create a directory object by name. If the directory cannot be opened, an exception is raised. The first argument is the directory name to open.</p><p><em>Methods</em></p><p><strong>mkdir -&gt; Directory (String)</strong></p><p>The mkdir method creates a new directory in the current one. The full path is constructed by taking the directory name and adding the argument. Once the directory is created, the method returns a directory object of the newly constructed directory. An exception is thrown if the directory cannot be created.</p><p><strong>rmdir -&gt; none (String)</strong></p><p>The rmdir method removes an empty directory. The full path is constructed by taking the directory name and adding the argument. An exception is thrown if the directory cannot be removed.</p><p><strong>rmfile -&gt; none (String)</strong></p><p>The rmfile method removes a file in the current directory. The full path is constructed by taking the directory name and adding the argument. An exception is thrown if the file cannot be removed.</p><p><strong>get-name -&gt; String (none)</strong></p><p>The get-name method returns the directory name. If the default directory was created, the method returns the full directory path.</p><p><strong>get-list -&gt; List (none)</strong></p><p>The get-list method returns the directory contents. The method returns a list of strings. The list contains all valid names at the time of the call, including the current directory and the parent directory.</p><p><strong>get-files -&gt; List (none)</strong></p><p>The get-files method returns the directory contents. The method returns a list of strings of files. The list contains all valid names at the time of the call.</p><p><strong>get-subdirs -&gt; List (none)</strong></p><p>The get-subdirs method returns the sub directories. The method returns a list of strings of sub-directories. The list contains all valid names at the time of the call, including the current directory and the parent directory.</p><p><strong>next-name -&gt; String (none)</strong></p><p>The next-name method returns the next available name from the directory stream. This method is useful when operating with a large number of elements.</p><p><strong>next-path -&gt; String (none)</strong></p><p>The next-path method returns the next available path name from the directory stream. This method is useful when operating with a large number of elements.</p><p><strong>next-file-name -&gt; String (none)</strong></p><p>The next-file-name method returns the next available file name from the directory stream. This method is useful when operating with a large number of elements.</p><p><strong>next-file-path -&gt; String (none)</strong></p><p>The next-file-path method returns the next available file path name from the directory stream. This method is useful when operating with a large number of elements.</p><p><strong>next-dir-name -&gt; String (none)</strong></p><p>The next-dir-name method returns the next available directory name from the directory stream. This method is useful when operating with a large number of elements.</p><p><strong>next-dir-path -&gt; String (none)</strong></p><p>The next-dir-path method returns the next available directory path name from the directory stream. This method is useful when operating with a large number of elements.</p><p><strong>Logtee</strong></p><p>The Logtee class is a message logger facility associated with an output stream. When a message is added to the logger object, the message is also sent to the output stream, depending on the controlling flags. The name "logtee" comes from the contraction of "logger" and "tee". One particularity of the class is that without a stream, the class behaves like a regular logger.</p><p><em>Predicate</em></p><p>logtee-p</p><p><em>Inheritance</em></p><p>Logger</p><p><em>Constructors</em></p><p><strong>Logtee (none)</strong></p><p>The Logtee constructor creates a default logger without an output stream</p><p><strong>Logtee (Integer)</strong></p><p>The Logtee constructor creates a logger object with a specific size without an output stream.</p><p><strong>Logtee (Output)</strong></p><p>The Logtee constructor creates a logger object with an output stream.</p><p><strong>Logtee (Integer Output)</strong></p><p>The Logtee constructor creates a logger object with a specific size and an output stream. The first argument is the logger window size. The second argument is the output stream.</p><p><strong>Logtee (Integer String Output)</strong></p><p>The Logtee constructor creates a logger object with a specific size, an information string and an output stream. The first argument is the logger window size. The second argument is the logger information string. The third argument is the output stream.</p><p><em>Methods</em></p><p><strong>set-output-stream -&gt; none (Output)</strong></p><p>The set-output-stream method attaches the output stream to the logtee object.</p><p><strong>get-output-stream -&gt; Output (none)</strong></p><p>The get-output-stream method returns the logtee output stream.</p><p><strong>set-tee -&gt; none (Boolean)</strong></p><p>The set-tee method sets the logtee control flag. The control flag controls the message display to the output stream.</p><p><strong>get-tee -&gt; Boolean (none)</strong></p><p>The get-tee method returns the logtee output stream.</p><p><strong>NamedFifo</strong></p><p>The NameFifo class is a string vector designed to operate as a stream fifo object. The class provides the facility to read or write the fifo content from a stream. The stream can be created by name for writing, in which case the named fifo operates as a backup object.</p><p><em>Predicate</em></p><p>named-fifo-p</p><p><em>Inheritance</em></p><p>StrvecNameable</p><p><em>Constructors</em></p><p><strong>NamedFifo (none)</strong></p><p>The NamedFifo constructor creates a default named fifo without a backing name. In this case the fifo cannot be read or written by stream.</p><p><strong>NamedFifo (String)</strong></p><p>The NamedFifo constructor creates a named fifo by name. The name is used as a file name for reading or writing the fifo.</p><p><strong>NamedFifo (String Boolean)</strong></p><p>The NamedFifo constructor creates a named fifo by name. The name is used as a file name for reading or writing the fifo.If the boolean argument is true, the fifo is read.</p><p><em>Methods</em></p><p><strong>read -&gt; none (none)</strong></p><p>The read method reads the fifo file name and fill the fifo.</p><p><strong>write -&gt; none (none)</strong></p><p>The write method writes the fifo contents to the fifo file name.</p><p><strong>set-name -&gt; none (String)</strong></p><p>The set-name method sets the fifo file name.</p><p><strong>FileInfo</strong></p><p>The FileInfo is a file information class that holds the primary information related to a file, such like its size or its modification time. The file information is set at construction but can be updated with the help of the update method.</p><p><em>Predicate</em></p><p>file-info-p</p><p><em>Inheritance</em></p><p>Nameable</p><p><em>Constructors</em></p><p><strong>(String)</strong></p><p>The FileInfo constructor creates a file information by name. The string argument is the file name to query.</p><p><em>Methods</em></p><p><strong>length -&gt; Integer (none)</strong></p><p>The length method returns the file size information.</p><p><strong>get-modification-time -&gt; Integer (none)</strong></p><p>The get-modification-time method returns the file modification time. The time can be used as an argument to the Time or Date object.</p><p><strong>update -&gt; none (none)</strong></p><p>The update method the file information data.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="afnix-sec.3.html"><span aria-hidden="true">&larr;</span> afnix-sec.3: Standard security module</a></li>
   <li class="next"><a href="afnix-sys.3.html">afnix-sys.3: Standard system access module <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

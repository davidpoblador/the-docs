<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>hspell: Hebrew spellchecker (c api)</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Hebrew spellchecker (c api)">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="hspell (3) manual">
  <meta name="twitter:description" content="Hebrew spellchecker (c api)">
  <meta name="twitter:image" content="https://www.carta.tech/images/hspell-hspell-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/hspell.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="hspell (3) manual" />
  <meta property="og:description" content="Hebrew spellchecker (c api)" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/hspell-hspell-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">hspell<small> (3)</small></h1>
        <p class="lead">Hebrew spellchecker (c api)</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/hspell.3.html">
      <span itemprop="name">hspell: Hebrew spellchecker (c api)</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/hspell/">
      <span itemprop="name">hspell</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/hspell.3.html">
      <span itemprop="name">hspell: Hebrew spellchecker (c api)</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>#include &lt;hspell.h&gt;</strong></p><p><strong>int hspell_init(struct dict_radix **</strong>dictp<strong>, int </strong>flags<strong>);</strong></p><p><strong>void hspell_uninit(struct dict_radix *</strong>dictp<strong>);</strong></p><p><strong>int hspell_check_word(struct dict_radix *</strong>dict<strong>, const char *</strong>word<strong>, int *</strong>preflen<strong>);</strong></p><p><strong>void hspell_trycorrect(struct dict_radix *</strong>dict<strong>, const char *</strong>word<strong>, struct corlist *</strong>cl<strong>);</strong></p><p><strong>int corlist_init(struct corlist *</strong>cl<strong>);</strong></p><p><strong>int corlist_free(struct corlist *</strong>cl<strong>);</strong></p><p><strong>int corlist_n(struct corlist *</strong>cl<strong>);</strong></p><p><strong>char *corlist_str(struct corlist *</strong>cl<strong>, int </strong>i<strong>);</strong></p><p><strong>unsigned int hspell_is_canonic_gimatria(const char *</strong>word<strong>);</strong></p><p>typedef int hspell_word_split_callback_func(const char *word, const char *baseword, int preflen, int prefspec);</p><p><strong>int hspell_enum_splits(struct dict_radix *</strong>dict<strong>, const char *</strong>word<strong>, hspell_word_split_callback_func *</strong>enumf<strong>);</strong></p><p><strong>void hspell_set_dictionary_path(const char *</strong>path<strong>);</strong></p><p><strong>const char *hspell_get_dictionary_path(void);</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This manual describes the C API of the Hspell Hebrew spellchecker. Please refer to <a href="../man1/hspell.1.html"><strong>hspell</strong>(1)</a> for a description of the Hspell project, its spelling standard, and how it works.</p><p>The <strong>hspell_init()</strong> function must be called first to initialize the Hspell library. It sets up some global structures (see CAVEATS section) and then reads the necessary dictionary files (whose places are fixed when the library is built). The <em>'dictp'</em> parameter is a pointer to a <em>struct dict_radix*</em> object, which is modified to point to a newly allocated dictionary. A typical <strong>hspell_init()</strong> call therefore looks like</p>
<pre>
   struct dict_radix *dict;
   hspell_init(&dict, flags);
</pre>
<p>Note that the (struct dict_radix*) type is an opaque pointer - the library user has no access to the separate fields in this structure.</p><p>The <em>'flags'</em> parameter can contain a bitwise or'ing of several flags that modify Hspell's default behavior; Turning on HSPELL_OPT_HE_SHEELA allows Hspell to recognize the interrogative He prefix (he ha-she'ela). HSPELL_OPT_DEFAULT is a synonym for turning on no special flag, i.e., it evaluates to 0.</p><p><strong>hspell_init()</strong> returns 0 on success, or negative numbers on errors. Currently, the only error is -1, meaning the dictionary files could not be read.</p><p>The <strong>hspell_uninit()</strong> function undoes the effects of <strong>hspell_init()</strong>, freeing any memory that was allocated during initialization.</p><p>The <strong>hspell_check_word()</strong> function checks whether a certain word is a correct Hebrew word (possibly with prefix particles attached in a syntacticly-correct manner). 1 is returned if the word is correct, or 0 if it is incorrect.</p><p>The <em>'word'</em> parameter should be a single Hebrew word, in the iso8859-8 encoding, possibly containing the ASCII quote or double-quote characters (signifying the geresh and gershayim used in Hebrew for abbreviations, acronyms, and a few foreign sounds). If the calling programs works with other encodings, it must convert the word to iso8859-8 first. In particular cp1255 (the MS-Windows Hebrew encoding) extensions to iso8859-8 like niqqud characters, geresh or gershayim, are currently not recognized and must be removed from the word prior to calling <strong>hspell_check_word()</strong>.</p><p>Into the <em>'preflen'</em> parameter, the function writes back the number of characters it recognized as a prefix particle - the rest of the 'word' is a stand-alone word. Because Hebrew words typically can be read in several different ways, this feature (of getting just one prefix from one possible reading) is usually not very useful, and it is likely to be removed in a future version.</p><p>The <strong>hspell_enum_splits()</strong> function provides a way to get all possible splitting of the given <em>'word'</em> into an optional prefix particle and a stand-alone word. For each possible (and legal, as some words cannot accept certain prefixes) split, a user-defined callback function is called. This callback function is given the whole word, the length of the prefix, the stand-alone word, and a bitfield which describes what types of words this prefix can get. Note that in some cases, a word beginning with the letter waw gets this waw doubled before a prefix, so sometimes strlen(word)!=strlen(baseword)+preflen.</p><p>The <strong>hspell_trycorrect()</strong> tries to find a list of possible corrections for an incorrect word. Because in Hebrew the word density is high (a random string of letters, especially if short, has a high probability of being a correct word), this function attempts to try corrections based on the assumption of a spelling error (replacement of letters that sound alike, missing or spurious immot qri'a), not typo (slipped finger on the keyboard, etc.) - see also CAVEATS.</p><p><strong>hspell_trycorrect()</strong> returns the correction list into a structure of type <em>struct corlist</em>. This structure must be first allocated with a call to <strong>corlist_init()</strong> and subsequently freed with <strong>corlist_free()</strong>. The <strong>corlist_n()</strong> macro returns the number of words held in an allocated corlist, and <strong>corlist_str()</strong> returns the i'th word. Accordingly, here is an example usage of <strong>hspell_trycorrect()</strong>:</p>
<pre>
   struct corlist cl;
   printf ("Found misspelled word %s. Possible corrections:&#92;n", w);
   corlist_init (&cl);
   hspell_trycorrect (dict, w, &cl);
   for (i=0; i&lt;corlist_n(&cl); i++) {
       printf ("%s&#92;n", corlist_str(&cl, i));
   }
</pre>
<p>The <strong>hspell_is_canonic_gimatria()</strong> function checks whether the given word is a <em>canonic</em> gimatria - i.e., the proper way to write in gimatria the number it represents. The caller might want to accept canonic gimatria as proper Hebrew words, even if <strong>hspell_check_word()</strong> previously reported such word to be a non-existent word. <strong>hspell_is_canonic_gimatria()</strong> returns the number represented as gimatria in 'word' if it is indeed proper gimatria (in canonic form), or 0 otherwise.</p><p><strong>hspell_init()</strong> normally reads the dictionary files from a path compiled into the library. This makes sense when the library's code and the dictionaries are distributed together, but in some scenarios the library user might want to use the Hspell dictionaries that are already present on the system in an arbitrary path. The function <strong>hspell_set_dictionary_path()</strong> can be used to set this path, and should be used before calling <strong>hspell_init()</strong>. The given path is that of the word list, and other input files have that path with an appended prefix. <strong>hspell_get_dictionary_path()</strong> can be used to find the current path. On many installations, this defaults to "/usr/local/share/hspell/hebrew.wgz".</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LINKING</h2>
        <div class="sectioncontent">
<p>On most systems, the Hspell library is compiled to use the Zlib library for reading the compressed dictionaries. Therefore, a program linking with the Hspell library must also be linked with the Zlib library (usually, by adding "-lz" to the compilation line).</p><p>Programs that use <em>autoconf</em> to search for the Hspell library, should remember to tell AC_CHECK_LIB to also link with the -lz library when checking for -lhspell.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CAVEATS</h2>
        <div class="sectioncontent">
<p>While the API described here has been stable for years, it may change in the future. Users are encouraged to compare the values of the integer macros <strong>HSPELL_VERSION_MAJOR</strong> and <strong>HSPELL_VERSION_MINOR</strong> to those expected by the writer of the program. A third macro, <strong>HSPELL_VERSION_EXTRA</strong> contains a string which can describe subrelease modifications (e.g., beta versions).</p><p>The current Hspell C API is very low-level, in the sense that it leaves the user to implement many features that some users take for granted that a spell-checker should provide. For example it doesn't provide any facilities for a user-defined personal dictionary. It also has separate functions for checking valid Hebrew words and valid gimatria, and no function to do both. It is assumed that the caller - a bigger spell-checking library or word processor (for example), will already have these facilities. If not, you may wish to look at the sources of <a href="../man1/hspell.1.html"><strong>hspell</strong>(1)</a> for an example implementation.</p><p>Currently there is no concept of separate Hspell "contexts" in an application. Some of the context is now global for the entire application: currently, a single list of legal prefix-particles is kept, and the dictionary read by <strong>hspell_init()</strong> is always read from the global default place. This may be solved in a later version, e.g., by switching to an API like:</p>
<pre>
   context = hspell_new_context();
   hspell_set_dictionary_path(context, "/some/path/hebrew.wgz");
   hspell_init(context, flags);
   ...
   hspell_check_word(context, word, preflenp);
</pre>
<p>Note that despite the global context mentioned above, after initialization all functions described here are <em>thread-safe</em>, because they only read the dictionary data, not write to it.</p><p><strong>hspell_trycorrect()</strong> is not as powerful as it could have been, with typos or certain kinds of spelling mistakes not giving useful correction suggestions. Along with more types of corrections, <strong>hspell_trycorrect()</strong> needs a better way to order the likelihood of the corrections, as an unordered list of 100 corrections would be just as useful (or rather, useless) as none.</p><p>In some cases of errors during <strong>hspell_init()</strong>, warning messages are printed to the standard errors. This is a bad thing for a library to do.</p><p>There are too many CAVEATS in this manual.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">VERSION</h2>
        <div class="sectioncontent">
<p>The version of <strong>hspell</strong> described by this manual page is 1.2.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright (C) 2000-2012, Nadav Har'El &lt;nyh@math.technion.ac.il&gt; and Dan Kenigsberg &lt;danken@cs.technion.ac.il&gt;.</p><p>Hspell is free software, released under the GNU Affero General Public License (AGPL) version 3. Note that not only the programs in the distribution, but also the dictionary files and the generated word lists, are licensed under the AGPL. There is no warranty of any kind.</p><p>See the LICENSE file for more information and the exact license terms.</p><p>The latest version of this software can be found in <strong>http://hspell.ivrix.org.il/</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO hspell&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man1/hspell.1.html"><strong>hspell</strong>(1)</a></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="hsearch_r.3.html"><span aria-hidden="true">&larr;</span> hsearch_r.3: Hash table management</a></li>
   <li class="next"><a href="hstrerror.3.html">hstrerror.3: Get network host entry <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

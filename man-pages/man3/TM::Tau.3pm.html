<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>TM::Tau: Topic maps, tau expressions</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Topic maps, tau expressions">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="TM::Tau (3pm) manual">
  <meta name="twitter:description" content="Topic maps, tau expressions">
  <meta name="twitter:image" content="https://www.carta.tech/images/libtm-perl-TM::Tau-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/TM::Tau.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="TM::Tau (3pm) manual" />
  <meta property="og:description" content="Topic maps, tau expressions" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libtm-perl-TM::Tau-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">TM::Tau<small> (3pm)</small></h1>
        <p class="lead">Topic maps, tau expressions</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/TM::Tau.3pm.html">
      <span itemprop="name">TM::Tau: Topic maps, tau expressions</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libtm-perl/">
      <span itemprop="name">libtm-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/TM::Tau.3pm.html">
      <span itemprop="name">TM::Tau: Topic maps, tau expressions</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  use TM::Tau;
  # read a map from an XTM file
  $tm = new TM::Tau (&apos;test.xtm&apos;);        # or
  $tm = new TM::Tau (&apos;file:test.xtm&apos;);   # or
  $tm = new TM::Tau (&apos;file:test.xtm &gt;&apos;); # or
  $tm = new TM::Tau (&apos;file:test.xtm &gt; null:&apos;);

  # read it now and write it back to the file when object goes out of scope
  $tm = new TM::Tau (&apos;test.xtm &gt; test.xtm&apos;);

  # create empty map at start and then let it automatically flush onto file
  $tm = new TM::Tau (&apos;null: &gt; test.xtm&apos;); # or
  $tm = new TM::Tau (&apos;&gt; test.xtm&apos;);

  # read-in at the start (i.e. constructor time) and then flush it back
  $tm = new TM::Tau (&apos;&gt; test.xtm &gt;&apos;);

  # load and merge maps at constructor time
  $tm = new TM::Tau (&apos;file:test.xtm + http://..../test.atm&apos;);

  # load map and filter it with a constraint at constructor time
  $tm = new TM::Tau (&apos;mymap.atm * myontology.ont&apos;);

  # convert between different formats
  $tm = new TM::Tau (&apos;test.xtm &gt; test.atm&apos;);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>When you need to make maps persistent, then you can resort to either using the prefabricated packages TM::Materialized::*, or you can build your own persistent forms using any of the available synchronizable traits.  In either case your application will have to invoke methods like \*(C`sync_in\*(C' and \*(C`sync_out\*(C' to copy content from the resource into memory and back.</p><p>While this gives you great flexibility, in some cases your needs may be much simpler:</p>
<dl class='dl-vertical'>
  <dt>
    consumer model:
  </dt>
  <dd>
    <p>A map should be sourced into memory when the map object is created. A typical use case is a web server application which accesses the map on disk with every request and which returns parts of the map to an \s-1HTTP\s0 client.</p>
  </dd>
  <dt>
    producer model:
  </dt>
  <dd>
    <p>A map is created first in memory and is flushed onto disk at destruction time. One example here is a script which extracts content from a relational database, puts it into a map in memory. At the end all map content is copied onto disk.</p>
  </dd>
  <dt>
    maintainer model:
  </dt>
  <dd>
    <p>A map is sourced from the disk at map object creation time, you update it and it will be flushed back to the same disk location at object destruction. Your application may be started with with new content to be put into an existing map. So first the map will be loaded, the new content added, and after that the map will be written back from where it came.</p>
  </dd>
  <dt>
    translator model:
  </dt>
  <dd>
    <p>A map is sourced from the disk, is translated into some other representation and is written back to disk to another location or format. As an example, you might want to convert between \s-1XTM\s0 and \s-1CTM\s0 format.</p>
  </dd>
  <dt>
    filter model:
  </dt>
  <dd>
    <p>A map is sourced from some backend, is transformed and/or filtered before being used. Your application could be one which only needs a particular portion of the map. So before processing the map is filtered down to the necessary parts.</p>
  </dd>
  <dt>
    integration model:
  </dt>
  <dd>
    <p>One or more maps are sourced from backends and are merged before processing. If you want to provide a consolidated view over several different data resources, you could first bring them all into topic map form, and then merge them before handing it to the application.</p>
  </dd>

</dl>
<p>What is common to all these cases is that there is a <em>breath-in</em> phase when the map object is constructed, and a <em>breath-out</em> phase when it is destroyed. In between theses phases the map object is just a normal instance of \s-1TM\s0.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TAU EXPRESSIONS</h2>
        <div class="sectioncontent">
<h3>Overview</h3>
<p>To control what happens in these two phases, this package provides a simple expression language, call <strong>Tau</strong>. With it you can control</p><ul>
<li><p>where maps are supposed to come from, or go to, Here the language provides a \s-1URI\s0 mechanism for addressing, such as    file:tm.atm or    http://topicmaps/some/map.xtm</p></li><li><p>when (or how) they should be merged, To merge two (manifested or virtual) topic maps together the \*(C`+\*(C' operator can be used    file:tm.atm + http://topicmaps/some/map.xtm</p></li><li><p>when (or how) they should be transformed, To transform product data to only something a customer is supposed to see, the \*(C`*\*(C' can be used:    product_data.atm * file:customer_view.tmql</p></li><li><p>when (or whether at all) they should be loaded oder saved</p></li>
</ul><p><strong>\s-1NOTE\s0</strong>: Later versions of this package will heavily overload the operators to also operate on other objects.</p>
<h3>Syntax</h3>
<p>The Tau expression language supports two binary operators, \*(C`+\*(C' and \*(C`*\*(C'. The \*(C`+\*(C' operator intuitively puts things together, the \*(C`*\*(C' applies the right-hand operand to the left-hand operand and behaves as a transformer or a filter. The exact semantics depends on the operands. In any case, the \*(C`*\*(C' binds stronger than the \*(C`+\*(C', and that precedence order can be overridden with parentheses.</p><p>The parser understands the following syntax for Tau expression:</p><p>   tau_expr    -&gt; mul_expr</p><p>   mul_expr    -&gt; source { (&apos;&gt;&apos; | &apos;*&apos;) filter }</p><p>   source      -&gt; &apos;(&apos; add_expr &apos;)&apos; | primitive</p><p>   add_expr    -&gt; mul_expr { &apos;+&apos; mul_expr }</p><p>   filter      -&gt; &apos;(&apos; filter &apos;)&apos; | primitive</p><p>   primitive   -&gt; uri [ module_spec ]</p><p>   module_spec -&gt; &apos;{&apos; name &apos;}&apos;</p><p>Terms in quotes are terminals, terms inside {} can appear any number of times (also zero), terms inside [] are optional. All other terms are non-terminals.</p><p><strong>\s-1NOTE\s0</strong>: Filters are planned to be composite, hence the optional bracketing in the grammar.</p><p>The (pre)parser supports the following shortcuts (I hate unnecessary typing):</p><ul>
<li><p>\*(L"whatever\*(R" is interpreted as \*(L"(whatever) &gt; -\*(R"</p></li><li><p>\*(L"whatever &gt;\*(R" is interpreted as \*(L"(whatever) &gt; -\*(R"</p></li><li><p>\*(L"&gt; whatever\*(R" is interpreted as  \*(L"- &gt; (whatever)\*(R"</p></li><li><p>\*(L"&lt; whatever &gt;\*(R" is interpreted as \*(L"whatever &gt; whatever\*(R", sync_in =&gt; 0</p></li><li><p>\*(L"&gt; whatever &lt;\*(R" is interpreted as \*(L"whatever &gt; whatever\*(R", sync_out =&gt; 0</p></li><li><p>\*(L"&gt; whatever &gt;\*(R" is interpreted as \*(L"whatever &gt; whatever\*(R"</p></li><li><p>\*(L"&lt; whatever &lt;\*(R" is interpreted as \*(L"whatever &gt; whatever\*(R", sync_in =&gt; 0, sync_out =&gt; 0</p></li><li><p>The \s-1URI\s0 \*(C`-\*(C' as source is interpreted as \s-1STDIN\s0 (via the TM::Serializable::AsTMa trait). Unless you override that.</p></li><li><p>The \s-1URI\s0 \*(C`-\*(C' as filter is interpreted as \s-1STDOUT\s0 (via the TM::Serializable::Dumper trait). Unless you override that.</p></li>
</ul>
<h3>Examples</h3>
<p>  # memory-only map   null: &gt; null:</p><p>  # read at startup, sync out when map goes out of scope   file:test.atm &gt; file:test.atm</p><p>  # copy AsTMa= to XTM   file:test.atm &gt; file:test.xtm</p><p>  # using a dedicated driver to load a map, store it onto a file   dns:my.dns.server { My::DNS::Driver } &gt; file:dns_snapshot.atm   # this will only work if the My::DNS::Driver supports to materialize   # the whole map</p><p>  # read a map and compute the statistics   file:test.atm * http://psi.tm.bond.edu.au/queries/1.0/statistics</p>
<h3>Map Source URLs</h3>
<p>URIs are used to address maps. An \s-1XTM\s0 map, for example, stored in the file system might be addressed as</p><p>  file:mydir/somemap.xtm</p><p>for a relative \s-1URL\s0 (relative to an application's current working directory), or via an absolute \s-1URI\s0 such as</p><p>  http://myserver/somemap.atm</p><p>The package supports all those access methods (file:, http:, ...) which \s-1LWP\s0 supports.</p>
<h3>Drivers</h3>
<p>Obviously a different deserializer package has to be used for an \s-1XTM\s0 file than for an AsTMa or \s-1LTM\s0 file. Some topic map content may be in a \s-1TM\s0 backend database, some content may only exist virtually, being emulated by a dedicated package.  While you may be mostly fine with system defaults, in some cases you may want to have precise control on how files and other external sources are to be interpreted. By their nature, drivers for sources must be subclasses of \s-1TM\s0.</p><p>A similar consideration applies to filters. Also here the specified \s-1URI\s0 determines which filter actually has to be applied. It also can define where the content eventually is stored to. Drivers for filters must be either subclasses of TM::Tau::Filter, or alternatively must be a trait providing a method \*(C`sync_out\*(C'.</p>
<h3>Binding by Schemes (implicit)</h3>
<p>When a Tau expression is parsed, the parser tries to identify which driver to use for which part of that composite map denoted by the expression. For this purpose a pattern matching approach is used to map regular expression patterns to driver package names. If you would like to learn about the current state of affairs do a</p><p>   use Data::Dumper;    print Dumper &#92;%TM::Tau::sources;    print Dumper &#92;%TM::Tau::filters;</p><p>Obviously, there is a distinction made between the namespace of resources (residing data) and filters (and transformers).</p><p>Each entry in any of the hashes contains as key a regular expression and as value the name of the driver to be used. That key is matched against the parsed \s-1URI\s0 and the first match wins. Since the keys in a hash are not naturally ordered, that is undefined.</p><p>At any time you can override values there:</p><p>   $TM::Tau::sources{&apos;null:&apos;}          = &apos;TM&apos;;    $TM::Tau::sources{&apos;tm:server&#92;.com&apos;} = &apos;My::Private::TopicMap::Driver&apos;;</p><p>or delete existing ones. The only constraint is that the driver package must already be \*(C`require\*(C'd into your Perl program.</p><p>During parsing of a Tau expression, two cases are distinguished:</p><ul>
<li><p>If the \s-1URI\s0 specifies a <em>source</em>, then this \s-1URI\s0 will be matched against the regexps in the \*(C`TM::Tau::sources\*(C' hash. The value of that entry will be used as class name to instantiate an object whereby one component (\*(C`uri\*(C') will be passed as parameter like this: <em></em><strong>$this_class_name</strong><em></em>-&gt;new (uri =&gt; <em></em><strong>$this_uri</strong><em></em>, baseuri =&gt; <em></em><strong>$this_uri</strong><em></em>) This class should be a subclass of \s-1TM\s0.</p></li><li><p>If the \s-1URI\s0 specifies a <em>filter</em>, then you have two options: Either you use as entry the name of a subclass of TM::Tau::Filter. Then an object is created like above. Alternatively, the entry is a list reference containing names of traits. Then a generic TM::Tau::Filter node is generated first and each of the traits are applied like this: Class::Trait-&gt;apply ( $node =&gt; <em></em><strong>$trait</strong><em></em> =&gt; {</p>
<pre>
                               exclude =&gt; [ 'mtime',
                                            'sync_out',
                                            'source_in' ]
                               } );
</pre>
</li>
</ul><p>If there is no match, this results in an exception.</p>
<h3>Binding by Package Pragmas (Explicit)</h3>
<p>Another way to define which package should be used for a particular map is to specify this directly in the <em>tau</em> expression:</p><p>   http://.../map.xtm { My::BrokenXTM }</p><p>In this case the resource is loaded and is processed using \*(C`My::BrokenXTM\*(C' as package to parse it (see TM::Materialized::Stream on how to write such a driver).</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INTERFACE</h2>
        <div class="sectioncontent">
<h3>Constructor</h3>
<p>The constructor accepts a string following the <em>Tau expression</em> \*(L"Syntax\*(R".  If that string is missing, \*(C`null:\*(C' will be assumed. An appropriate exception will be raised if the syntax is violated or one of the mentioned drivers is not preloaded.</p><p>Examples:</p><p>   # map only existing in memory    my $map = new TM::Tau;</p><p>   # map will be loaded as result of this tau expression    my $map = new TM::Tau (&apos;file:music.atm * file:beatles.tmql&apos;);</p><p>Apart from the Tau expression the constructor optionally interprets a hash with the following keys: If non-zero, in-synchronisation at constructor time will happen, otherwise it is suppressed. In that case you can trigger in-synchronisation explicitly with the method \*(C`sync_in\*(C'. If non-zero, out-synchronisation at destruction time will happen, otherwise it is suppressed.</p><p>Example:</p><p>   my $map = new TM::Tau (&apos;test.xtm&apos;,                           sync_in =&gt; 0); # dont want to let it happen now    ....                                  # time passes    $map-&gt;sync_in;                        # but now is a good time</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO TM::Tau&hellip;</h2>
        <div class="sectioncontent">
<p>\s-1TM\s0, TM::Tau::Filter</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Copyright 200[0-68], Robert Barta &lt;drrho@cpan.org&gt;, All rights reserved.</p><p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.  http://www.perl.com/perl/misc/Artistic.html</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="TM::Synchronizable::MapSphere.3pm.html"><span aria-hidden="true">&larr;</span> TM::Synchronizable::MapSphere.3pm: Topic maps, trait for a syncing a hierarchical tm repository</a></li>
   <li class="next"><a href="TM::Tau::Filter.3pm.html">TM::Tau::Filter.3pm: Topic maps, abstract filter class <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

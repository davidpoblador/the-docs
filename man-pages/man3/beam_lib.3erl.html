<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>beam_lib: An interface to the beam file format</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="An interface to the beam file format">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="beam_lib (3erl) manual">
  <meta name="twitter:description" content="An interface to the beam file format">
  <meta name="twitter:image" content="https://www.carta.tech/images/erlang-manpages-beam_lib-3erl.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3erl/beam_lib.3erl.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="beam_lib (3erl) manual" />
  <meta property="og:description" content="An interface to the beam file format" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/erlang-manpages-beam_lib-3erl.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">beam_lib<small> (3erl)</small></h1>
        <p class="lead">An interface to the beam file format</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/beam_lib.3erl.html">
      <span itemprop="name">beam_lib: An interface to the beam file format</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/erlang-manpages/">
      <span itemprop="name">erlang-manpages</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/beam_lib.3erl.html">
      <span itemprop="name">beam_lib: An interface to the beam file format</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p><em>beam_lib</em> provides an interface to files created by the BEAM compiler ("BEAM files"). The format used, a variant of "EA IFF 1985" Standard for Interchange Format Files, divides data into chunks.</p><p>Chunk data can be returned as binaries or as compound terms. Compound terms are returned when chunks are referenced by names (atoms) rather than identifiers (strings). The names recognized and the corresponding identifiers are:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>abstract_code ("Abst")</em></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>attributes ("Attr")</em></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>compile_info ("CInf")</em></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>exports ("ExpT")</em></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>labeled_exports ("ExpT")</em></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>imports ("ImpT")</em></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>indexed_imports ("ImpT")</em></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>locals ("LocT")</em></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>labeled_locals ("LocT")</em></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p><em>atoms ("Atom")</em></p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DEBUG INFORMATION/ABSTRACT CODE</h2>
        <div class="sectioncontent">
<p>The option <em>debug_info</em> can be given to the compiler (see <strong>compile(3erl)</strong>) in order to have debug information in the form of abstract code (see <strong>The Abstract Format</strong> in ERTS User's Guide) stored in the <em>abstract_code</em> chunk. Tools such as Debugger and Xref require the debug information to be included.</p><p><strong></strong> Warning:</p><p>Source code can be reconstructed from the debug information. Use encrypted debug information (see below) to prevent this.</p><p>The debug information can also be removed from BEAM files using <strong>strip/1</strong>, <strong>strip_files/1</strong> and/or <strong>strip_release/1</strong>.</p><h3>Reconstructing source code</h3>
<p>Here is an example of how to reconstruct source code from the debug information in a BEAM file <em>Beam</em>:</p>
<pre>
      {ok,{_,[{abstract_code,{_,AC}}]}} = beam_lib:chunks(Beam,[abstract_code]).
      io:fwrite("~s~n", [erl_prettypr:format(erl_syntax:form_list(AC))]).
</pre>

<h3>Encrypted debug information</h3>
<p>The debug information can be encrypted in order to keep the source code secret, but still being able to use tools such as Xref or Debugger.</p><p>To use encrypted debug information, a key must be provided to the compiler and <em>beam_lib</em>. The key is given as a string and it is recommended that it contains at least 32 characters and that both upper and lower case letters as well as digits and special characters are used.</p><p>The default type -- and currently the only type -- of crypto algorithm is <em>des3_cbc</em>, three rounds of DES. The key string will be scrambled using <em>erlang:md5/1</em> to generate the actual keys used for <em>des3_cbc</em>.</p><p><strong></strong> Note:</p><p>As far as we know by the time of writing, it is infeasible to break <em>des3_cbc</em> encryption without any knowledge of the key. Therefore, as long as the key is kept safe and is unguessable, the encrypted debug information <em>should</em> be safe from intruders.</p><p>There are two ways to provide the key:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>Use the compiler option <em>{debug_info,Key}</em>, see <strong>compile(3erl)</strong>, and the function <strong>crypto_key_fun/1</strong> to register a fun which returns the key whenever <em>beam_lib</em> needs to decrypt the debug information.</p><p>If no such fun is registered, <em>beam_lib</em> will instead search for a <em>.erlang.crypt</em> file, see below.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>Store the key in a text file named <em>.erlang.crypt</em>.</p><p>In this case, the compiler option <em>encrypt_debug_info</em> can be used, see <strong>compile(3erl)</strong>.</p>
  </dd>

</dl>

<h3>.erlang.crypt</h3>
<p><em>beam_lib</em> searches for <em>.erlang.crypt</em> in the current directory and then the home directory for the current user. If the file is found and contains a key, <em>beam_lib</em> will implicitly create a crypto key fun and register it.</p><p>The <em>.erlang.crypt</em> file should contain a single list of tuples:</p>
<pre>
      {debug_info, Mode, Module, Key}
</pre>
<p><em>Mode</em> is the type of crypto algorithm; currently, the only allowed value thus is <em>des3_cbc</em>. <em>Module</em> is either an atom, in which case <em>Key</em> will only be used for the module <em>Module</em>, or <em>[]</em>, in which case <em>Key</em> will be used for all modules. <em>Key</em> is the non-empty key string.</p><p>The <em>Key</em> in the first tuple where both <em>Mode</em> and <em>Module</em> matches will be used.</p><p>Here is an example of an <em>.erlang.crypt</em> file that returns the same key for all modules:</p>
<pre>
[{debug_info, des3_cbc, [], "%&gt;7}|pc/DM6Cga*68$Mw]L#&_Gejr]G^"}].
</pre>
<p>And here is a slightly more complicated example of an <em>.erlang.crypt</em> which provides one key for the module <em>t</em>, and another key for all other modules:</p>
<pre>
[{debug_info, des3_cbc, t, "My KEY"},
 {debug_info, des3_cbc, [], "%&gt;7}|pc/DM6Cga*68$Mw]L#&_Gejr]G^"}].
</pre>
<p><strong></strong> Note:</p><p>Do not use any of the keys in these examples. Use your own keys.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DATA TYPES</h2>
        <div class="sectioncontent">

<pre>
<strong>beam()</strong> = module() | <strong>file:filename()</strong> | binary()

</pre>
<p>Each of the functions described below accept either the module name, the filename, or a binary containing the beam module.</p>
<pre>
<strong>chunkdata()</strong> = {<strong>chunkid()</strong>, <strong>dataB()</strong>}

            | {abstract_code, <strong>abst_code()</strong>}

            | {attributes, [<strong>attrib_entry()</strong>]}

            | {compile_info, [<strong>compinfo_entry()</strong>]}

            | {exports, [{atom(), arity()}]}

            | {labeled_exports, [<strong>labeled_entry()</strong>]}

            | {imports, [mfa()]}

            | {indexed_imports,

               [{<strong>index()</strong>,

                 module(),

                 Function :: atom(),

                 arity()}]}

            | {locals, [{atom(), arity()}]}

            | {labeled_locals, [<strong>labeled_entry()</strong>]}

            | {atoms, [{integer(), atom()}]}

</pre>
<p>The list of attributes is sorted on <em>Attribute</em> (in attrib_entry()), and each attribute name occurs once in the list. The attribute values occur in the same order as in the file. The lists of functions are also sorted.</p>
<pre>
<strong>chunkid()</strong> = nonempty_string()

</pre>
<p>"Abst" | "Attr" | "CInf" | "ExpT" | "ImpT" | "LocT" | "Atom"</p>
<pre>
<strong>dataB()</strong> = binary()

</pre>

<pre>
<strong>abst_code()</strong> = {AbstVersion :: atom(), <strong>forms()</strong>}

            | no_abstract_code

</pre>
<p>It is not checked that the forms conform to the abstract format indicated by <em>AbstVersion</em>. <em>no_abstract_code</em> means that the <em>"Abst"</em> chunk is present, but empty.</p>
<pre>
<strong>forms()</strong> = [<strong>erl_parse:abstract_form()</strong>]

</pre>

<pre>
<strong>compinfo_entry()</strong> = {InfoKey :: atom(), term()}

</pre>

<pre>
<strong>attrib_entry()</strong> =

    {Attribute :: atom(), [AttributeValue :: term()]}

</pre>

<pre>
<strong>labeled_entry()</strong> = {Function :: atom(), arity(), <strong>label()</strong>}

</pre>

<pre>
<strong>index()</strong> = integer() &gt;= 0

</pre>

<pre>
<strong>label()</strong> = integer()

</pre>

<pre>
<strong>chunkref()</strong> = <strong>chunkname()</strong> | <strong>chunkid()</strong>

</pre>

<pre>
<strong>chunkname()</strong> = abstract_code

            | attributes

            | compile_info

            | exports

            | labeled_exports

            | imports

            | indexed_imports

            | locals

            | labeled_locals

            | atoms

</pre>

<pre>
<strong>chnk_rsn()</strong> = {unknown_chunk, <strong>file:filename()</strong>, atom()}

           | {key_missing_or_invalid,

              <strong>file:filename()</strong>,

              abstract_code}

           | <strong>info_rsn()</strong>

</pre>

<pre>
<strong>info_rsn()</strong> = {chunk_too_big,

              <strong>file:filename()</strong>,

              <strong>chunkid()</strong>,

              ChunkSize :: integer() &gt;= 0,

              FileSize :: integer() &gt;= 0}

           | {invalid_beam_file,

              <strong>file:filename()</strong>,

              Position :: integer() &gt;= 0}

           | {invalid_chunk, <strong>file:filename()</strong>, <strong>chunkid()</strong>}

           | {missing_chunk, <strong>file:filename()</strong>, <strong>chunkid()</strong>}

           | {not_a_beam_file, <strong>file:filename()</strong>}

           | {file_error, <strong>file:filename()</strong>, <strong>file:posix()</strong>}

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">

<pre>
<strong></strong>
chunks(Beam, ChunkRefs) -&gt;
<strong></strong>
          {ok, {module(), [chunkdata()]}} |
<strong></strong>
          {error, beam_lib, chnk_rsn()}

</pre>
<p>Types:</p><p>Beam = <strong>beam()</strong></p><p>ChunkRefs = [<strong>chunkref()</strong>]</p><p>Reads chunk data for selected chunks refs. The order of the returned list of chunk data is determined by the order of the list of chunks references.</p>
<pre>
<strong></strong>
chunks(Beam, ChunkRefs, Options) -&gt;
<strong></strong>
          {ok, {module(), [ChunkResult]}} |
<strong></strong>
          {error, beam_lib, chnk_rsn()}

</pre>
<p>Types:</p><p>Beam = <strong>beam()</strong></p><p>ChunkRefs = [<strong>chunkref()</strong>]</p><p>Options = [allow_missing_chunks]</p><p>ChunkResult = <strong>chunkdata()</strong></p>
<pre>
            | {ChunkRef :: <strong>chunkref()</strong>, missing_chunk}
</pre>
<p>Reads chunk data for selected chunks refs. The order of the returned list of chunk data is determined by the order of the list of chunks references.</p><p>By default, if any requested chunk is missing in <em>Beam</em>, an <em>error</em> tuple is returned. However, if the option <em>allow_missing_chunks</em> has been given, a result will be returned even if chunks are missing. In the result list, any missing chunks will be represented as <em>{ChunkRef,missing_chunk}</em>. Note, however, that if the <em>"Atom"</em> chunk if missing, that is considered a fatal error and the return value will be an <em>error</em> tuple.</p>
<pre>
<strong></strong>
version(Beam) -&gt;
<strong></strong>
           {ok, {module(), [Version :: term()]}} |
<strong></strong>
           {error, beam_lib, chnk_rsn()}

</pre>
<p>Types:</p><p>Beam = <strong>beam()</strong></p><p>Returns the module version(s). A version is defined by the module attribute <em>-vsn(Vsn)</em>. If this attribute is not specified, the version defaults to the checksum of the module. Note that if the version <em>Vsn</em> is not a list, it is made into one, that is <em>{ok,{Module,[Vsn]}}</em> is returned. If there are several <em>-vsn</em> module attributes, the result is the concatenated list of versions. Examples:</p>
<pre>
1&gt; beam_lib:version(a). % -<strong>vsn</strong>(1).
{ok,{a,[1]}}
2&gt; beam_lib:version(b). % -vsn([1]).
{ok,{b,[1]}}
3&gt; beam_lib:version(c). % -vsn([1]). -<strong>vsn</strong>(2).
{ok,{c,[1,2]}}
4&gt; beam_lib:version(d). % no -vsn attribute
{ok,{d,[275613208176997377698094100858909383631]}}
</pre>

<pre>
<strong></strong>
md5(Beam) -&gt; {ok, {module(), MD5}} | {error, beam_lib, chnk_rsn()}

</pre>
<p>Types:</p><p>Beam = <strong>beam()</strong></p><p>MD5 = binary()</p><p>Calculates an MD5 redundancy check for the code of the module (compilation date and other attributes are not included).</p>
<pre>
<strong></strong>
info(Beam) -&gt; [InfoPair] | {error, beam_lib, info_rsn()}

</pre>
<p>Types:</p><p>Beam = <strong>beam()</strong></p><p>InfoPair = {file, Filename :: <strong>file:filename()</strong>}</p>
<pre>
         | {binary, Binary :: binary()}
</pre>

<pre>
         | {module, Module :: module()}
</pre>

<pre>
         | {chunks,
</pre>

<pre>
            [{ChunkId :: <strong>chunkid()</strong>,
</pre>

<pre>
              Pos :: integer() &gt;= 0,
</pre>

<pre>
              Size :: integer() &gt;= 0}]}
</pre>
<p>Returns a list containing some information about a BEAM file as tuples <em>{Item, Info}</em>:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{file, Filename} | {binary, Binary}</em>: The name (string) of the BEAM file, or the binary from which the information was extracted.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{module, Module}</em>: The name (atom) of the module.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{chunks, [{ChunkId, Pos, Size}]}</em>: For each chunk, the identifier (string) and the position and size of the chunk data, in bytes.</p>
  </dd>

</dl>

<pre>
<strong></strong>
cmp(Beam1, Beam2) -&gt; ok | {error, beam_lib, cmp_rsn()}

</pre>
<p>Types:</p><p>Beam1 = Beam2 = <strong>beam()</strong></p>
<pre>
<strong>cmp_rsn()</strong> = {modules_different, module(), module()}

          | {chunks_different, <strong>chunkid()</strong>}

          | different_chunks

          | <strong>info_rsn()</strong>
</pre>
<p>Compares the contents of two BEAM files. If the module names are the same, and all chunks except for the <em>"CInf"</em> chunk (the chunk containing the compilation information which is returned by <em>Module:module_info(compile)</em>) have the same contents in both files, <em>ok</em> is returned. Otherwise an error message is returned.</p>
<pre>
<strong></strong>
cmp_dirs(Dir1, Dir2) -&gt;
<strong></strong>
            {Only1, Only2, Different} | {error, beam_lib, Reason}

</pre>
<p>Types:</p><p>Dir1 = Dir2 = atom() | <strong>file:filename()</strong></p><p>Only1 = Only2 = [<strong>file:filename()</strong>]</p><p>Different =</p>
<pre>
    [{Filename1 :: <strong>file:filename()</strong>, Filename2 :: <strong>file:filename()</strong>}]
</pre>
<p>Reason = {not_a_directory, term()} | <strong>info_rsn()</strong></p><p>The <em>cmp_dirs/2</em> function compares the BEAM files in two directories. Only files with extension <em>".beam"</em> are compared. BEAM files that exist in directory <em>Dir1</em> (<em>Dir2</em>) only are returned in <em>Only1</em> (<em>Only2</em>). BEAM files that exist on both directories but are considered different by <em>cmp/2</em> are returned as pairs {<em>Filename1</em>, <em>Filename2</em>} where <em>Filename1</em> (<em>Filename2</em>) exists in directory <em>Dir1</em> (<em>Dir2</em>).</p>
<pre>
<strong></strong>
diff_dirs(Dir1, Dir2) -&gt; ok | {error, beam_lib, Reason}

</pre>
<p>Types:</p><p>Dir1 = Dir2 = atom() | <strong>file:filename()</strong></p><p>Reason = {not_a_directory, term()} | <strong>info_rsn()</strong></p><p>The <em>diff_dirs/2</em> function compares the BEAM files in two directories the way <em>cmp_dirs/2</em> does, but names of files that exist in only one directory or are different are presented on standard output.</p>
<pre>
<strong></strong>
strip(Beam1) -&gt;
<strong></strong>
         {ok, {module(), Beam2}} | {error, beam_lib, info_rsn()}

</pre>
<p>Types:</p><p>Beam1 = Beam2 = <strong>beam()</strong></p><p>The <em>strip/1</em> function removes all chunks from a BEAM file except those needed by the loader. In particular, the debug information (<em>abstract_code</em> chunk) is removed.</p>
<pre>
<strong></strong>
strip_files(Files) -&gt;
<strong></strong>
               {ok, [{module(), Beam}]} |
<strong></strong>
               {error, beam_lib, info_rsn()}

</pre>
<p>Types:</p><p>Files = [<strong>beam()</strong>]</p><p>Beam = <strong>beam()</strong></p><p>The <em>strip_files/1</em> function removes all chunks except those needed by the loader from BEAM files. In particular, the debug information (<em>abstract_code</em> chunk) is removed. The returned list contains one element for each given file name, in the same order as in <em>Files</em>.</p>
<pre>
<strong></strong>
strip_release(Dir) -&gt;
<strong></strong>
                 {ok, [{module(), file:filename()}]} |
<strong></strong>
                 {error, beam_lib, Reason}

</pre>
<p>Types:</p><p>Dir = atom() | <strong>file:filename()</strong></p><p>Reason = {not_a_directory, term()} | <strong>info_rsn()</strong></p><p>The <em>strip_release/1</em> function removes all chunks except those needed by the loader from the BEAM files of a release. <em>Dir</em> should be the installation root directory. For example, the current OTP release can be stripped with the call <em>beam_lib:strip_release(code:root_dir())</em>.</p>
<pre>
<strong></strong>
format_error(Reason) -&gt; io_lib:chars()

</pre>
<p>Types:</p><p>Reason = term()</p><p>Given the error returned by any function in this module, the function <em>format_error</em> returns a descriptive string of the error in English. For file errors, the function <em>file:format_error(Posix)</em> should be called.</p>
<pre>
<strong></strong>
crypto_key_fun(CryptoKeyFun) -&gt; ok | {error, Reason}

</pre>
<p>Types:</p><p>CryptoKeyFun = <strong>crypto_fun()</strong></p><p>Reason = badfun | exists | term()</p>
<pre>
<strong>crypto_fun()</strong> = fun((<strong>crypto_fun_arg()</strong>) -&gt; term())
</pre>

<pre>
<strong>crypto_fun_arg()</strong> = init

                 | clear

                 | {debug_info,

                    <strong>mode()</strong>,

                    module(),

                    <strong>file:filename()</strong>}
</pre>

<pre>
<strong>mode()</strong> = des3_cbc
</pre>
<p>The <em>crypto_key_fun/1</em> function registers a unary fun that will be called if <em>beam_lib</em> needs to read an <em>abstract_code</em> chunk that has been encrypted. The fun is held in a process that is started by the function.</p><p>If there already is a fun registered when attempting to register a fun, <em>{error, exists}</em> is returned.</p><p>The fun must handle the following arguments:</p>
<pre>
          CryptoKeyFun(init) -&gt; ok | {ok, NewCryptoKeyFun} | {error, Term}
</pre>
<p>Called when the fun is registered, in the process that holds the fun. Here the crypto key fun can do any necessary initializations. If <em>{ok, NewCryptoKeyFun}</em> is returned then <em>NewCryptoKeyFun</em> will be registered instead of <em>CryptoKeyFun</em>. If <em>{error, Term}</em> is returned, the registration is aborted and <em>crypto_key_fun/1</em> returns <em>{error, Term}</em> as well.</p>
<pre>
          CryptoKeyFun({debug_info, Mode, Module, Filename}) -&gt; Key
</pre>
<p>Called when the key is needed for the module <em>Module</em> in the file named <em>Filename</em>. <em>Mode</em> is the type of crypto algorithm; currently, the only possible value thus is <em>des3_cbc</em>. The call should fail (raise an exception) if there is no key available.</p>
<pre>
          CryptoKeyFun(clear) -&gt; term()
</pre>
<p>Called before the fun is unregistered. Here any cleaning up can be done. The return value is not important, but is passed back to the caller of <em>clear_crypto_key_fun/0</em> as part of its return value.</p>
<pre>
<strong></strong>
clear_crypto_key_fun() -&gt; undefined | {ok, Result}

</pre>
<p>Types:</p><p>Result = undefined | term()</p><p>Unregisters the crypto key fun and terminates the process holding it, started by <em>crypto_key_fun/1</em>.</p><p>The <em>clear_crypto_key_fun/1</em> either returns <em>{ok, undefined}</em> if there was no crypto key fun registered, or <em>{ok, Term}</em>, where <em>Term</em> is the return value from <em>CryptoKeyFun(clear)</em>, see <em>crypto_key_fun/1</em>.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="base64.3erl.html"><span aria-hidden="true">&larr;</span> base64.3erl: Implements base 64 encode and decode, see rfc2045.</a></li>
   <li class="next"><a href="binary.3erl.html">binary.3erl: Library for handling binary data <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

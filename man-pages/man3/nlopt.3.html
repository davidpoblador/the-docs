<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>nlopt: Nonlinear optimization library</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Nonlinear optimization library">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="nlopt (3) manual">
  <meta name="twitter:description" content="Nonlinear optimization library">
  <meta name="twitter:image" content="https://www.carta.tech/images/libnlopt-dev-nlopt-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/nlopt.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="nlopt (3) manual" />
  <meta property="og:description" content="Nonlinear optimization library" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libnlopt-dev-nlopt-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">nlopt<small> (3)</small></h1>
        <p class="lead">Nonlinear optimization library</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/nlopt.3.html">
      <span itemprop="name">nlopt: Nonlinear optimization library</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libnlopt-dev/">
      <span itemprop="name">libnlopt-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/nlopt.3.html">
      <span itemprop="name">nlopt: Nonlinear optimization library</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
<strong>#include &lt;nlopt.h&gt;</strong>

<strong>nlopt_opt </strong><em>opt</em><strong> = nlopt_create(</strong><em>algorithm</em><strong>,</strong><em> n</em><strong>);</strong>
<strong>nlopt_set_min_objective(</strong><em>opt</em><strong>,</strong><em> f</em><strong>,</strong><em> f_data</em><strong>);</strong>
<strong>nlopt_set_ftol_rel(</strong><em>opt</em><strong>,</strong><em> tol</em><strong>);</strong>
<strong>...</strong>
<strong>nlopt_optimize(</strong><em>opt</em><strong>,</strong><em> x </em><strong>,</strong><em> &opt_f</em><strong>);</strong>
<strong>nlopt_destroy(</strong><em>opt</em><strong>);</strong>

The "..." indicates any number of calls to NLopt functions, below, to
set parameters of the optimization, constraints, and stopping
criteria.  Here, <strong>nlopt_set_ftol_rel</strong> is merely an example of a
possible stopping criterion.  You should link the resulting program
with the linker flags -lnlopt -lm on Unix.
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>NLopt is a library for nonlinear optimization.  It attempts to minimize (or maximize) a given nonlinear objective function <em>f</em> of <em>n</em> design variables, using the specified <em>algorithm</em>, possibly subject to linear or nonlinear constraints.  The optimum function value found is returned in <em>opt_f</em> (type double) with the corresponding design variable values returned in the (double) array <em>x</em> of length <em>n</em>. The input values in <em>x</em> should be a starting guess for the optimum.</p><p>The parameters of the optimization are controlled via the object <em>opt</em> of type <strong>nlopt_opt</strong>, which is created by the function <strong>nlopt_create</strong> and disposed of by <strong>nlopt_destroy</strong>. By calling various functions in the NLopt library, one can specify stopping criteria (e.g., a relative tolerance on the objective function value is specified by <strong>nlopt_set_ftol_rel</strong>), upper and/or lower bounds on the design parameters <em>x</em>, and even arbitrary nonlinear inequality and equality constraints.</p><p>By changing the parameter <em>algorithm</em> among several predefined constants described below, one can switch easily between a variety of minimization algorithms.  Some of these algorithms require the gradient (derivatives) of the function to be supplied via <em>f</em>, and other algorithms do not require derivatives.  Some of the algorithms attempt to find a global optimum within the given bounds, and others find only a local optimum.  Most of the algorithms only handle the case where there are no nonlinear constraints.  The NLopt library is a wrapper around several free/open-source minimization packages, as well as some new implementations of published optimization algorithms.  You could, of course, compile and call these packages separately, and in some cases this will provide greater flexibility than is available via NLopt.  However, depending upon the specific function being optimized, the different algorithms will vary in effectiveness.  The intent of NLopt is to allow you to quickly switch between algorithms in order to experiment with them for your problem, by providing a simple unified interface to these subroutines.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OBJECTIVE FUNCTION</h2>
        <div class="sectioncontent">
<p>The objective function is specified by calling one of:</p><p><strong>  nlopt_result nlopt_set_min_objective(nlopt_opt </strong><em>opt</em><strong>,</strong></p><p><strong>                                       nlopt_func </strong><em>f</em><strong>,</strong></p><p><strong>                                       void* </strong><em>f_data</em><strong>);</strong></p><p><strong>  nlopt_result nlopt_set_max_objective(nlopt_opt </strong><em>opt</em><strong>,</strong></p><p><strong>                                       nlopt_func </strong><em>f</em><strong>,</strong></p><p><strong>                                       void* </strong><em>f_data</em><strong>);</strong></p><p>depending on whether one wishes to minimize or maximize the objective function <em>f</em>, respectively.  The function <em>f</em> should be of the form:</p><p><strong>  double f(unsigned </strong><em>n</em><strong>,</strong></p><p><strong>           const double* </strong><em>x</em><strong>,</strong></p><p><strong>           double* </strong><em>grad</em><strong>,</strong></p><p><strong>           void* </strong><em>f_data</em><strong>);</strong></p><p>The return value should be the value of the function at the point <em>x</em>, where <em>x</em> points to an array of length <em>n</em> of the design variables.  The dimension <em>n</em> is identical to the one passed to <strong>nlopt_create</strong>.</p><p>In addition, if the argument <em>grad</em> is not NULL, then <em>grad</em> points to an array of length <em>n</em> which should (upon return) be set to the gradient of the function with respect to the design variables at <em>x</em>. That is, <em>grad[i]</em> should upon return contain the partial derivative df/dx[i], for 0 &lt;= i &lt; n, if <em>grad</em> is non-NULL. Not all of the optimization algorithms (below) use the gradient information: for algorithms listed as "derivative-free," the <em>grad</em> argument will always be NULL and need never be computed.  (For algorithms that do use gradient information, however, <em>grad</em> may still be NULL for some calls.)</p><p>The <em>f_data</em> argument is the same as the one passed to <strong>nlopt_set_min_objective</strong> or <strong>nlopt_set_max_objective</strong>, and may be used to pass any additional data through to the function. (That is, it may be a pointer to some caller-defined data structure/type containing information your function needs, which you convert from void* by a typecast.)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BOUND CONSTRAINTS</h2>
        <div class="sectioncontent">
<p>Most of the algorithms in NLopt are designed for minimization of functions with simple bound constraints on the inputs.  That is, the input vectors x[i] are constrainted to lie in a hyperrectangle lb[i] &lt;= x[i] &lt;= ub[i] for 0 &lt;= i &lt; n.  These bounds are specified by passing arrays <em>lb</em> and <em>ub</em> of length <em>n</em> to one or both of the functions:</p><p><strong>  nlopt_result nlopt_set_lower_bounds(nlopt_opt </strong><em>opt</em><strong>,</strong></p><p><strong>                                      const double* </strong><em>lb</em><strong>);</strong></p><p><strong>  nlopt_result nlopt_set_upper_bounds(nlopt_opt </strong><em>opt</em><strong>,</strong></p><p><strong>                                      const double* </strong><em>ub</em><strong>);</strong></p><p>If a lower/upper bound is not set, the default is no bound (unconstrained, i.e. a bound of infinity); it is possible to have lower bounds but not upper bounds or vice versa.  Alternatively, the user can call one of the above functions and explicitly pass a lower bound of -HUGE_VAL and/or an upper bound of +HUGE_VAL for some design variables to make them have no lower/upper bound, respectively. (HUGE_VAL is the standard C constant for a floating-point infinity, found in the math.h header file.)</p><p>Note, however, that some of the algorithms in NLopt, in particular most of the global-optimization algorithms, do not support unconstrained optimization and will return an error if you do not supply finite lower and upper bounds.</p><p>For convenience, the following two functions are supplied in order to set the lower/upper bounds for all design variables to a single constant (so that you don't have to fill an array with a constant value):</p><p><strong>  nlopt_result nlopt_set_lower_bounds1(nlopt_opt </strong><em>opt</em><strong>,</strong></p><p><strong>                                       double </strong><em>lb</em><strong>);</strong></p><p><strong>  nlopt_result nlopt_set_upper_bounds1(nlopt_opt </strong><em>opt</em><strong>,</strong></p><p><strong>                                       double </strong><em>ub</em><strong>);</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NONLINEAR CONSTRAINTS</h2>
        <div class="sectioncontent">
<p>Several of the algorithms in NLopt (MMA and ORIG_DIRECT) also support arbitrary nonlinear inequality constraints, and some also allow nonlinear equality constraints (COBYLA, SLSQP, ISRES, and AUGLAG). For these algorithms, you can specify as many nonlinear constraints as you wish by calling the following functions multiple times.</p><p>In particular, a nonlinear inequality constraint of the form <em>fc</em>(<em>x</em>) &lt;= 0, where the function <em>fc</em> is of the same form as the objective function described above, can be specified by calling:</p><p><strong>  nlopt_result nlopt_add_inequality_constraint(nlopt_opt </strong><em>opt</em><strong>,</strong></p><p><strong>                                               nlopt_func </strong><em>fc</em><strong>,</strong></p><p><strong>                                               void* </strong><em>fc_data</em><strong>,</strong></p><p><strong>                                               double </strong><em>tol</em><strong>);</strong></p><p>Just as for the objective function, <em>fc_data</em> is a pointer to arbitrary user data that will be passed through to the <em>fc</em> function whenever it is called.  The parameter <em>tol</em> is a tolerance that is used for the purpose of stopping criteria only: a point <em>x</em> is considered feasible for judging whether to stop the optimization if <em>fc</em>(<em>x</em>) &lt;= <em>tol</em>.  A tolerance of zero means that NLopt will try not to consider any <em>x</em> to be converged unless <em>fc</em> is strictly non-positive; generally, at least a small positive tolerance is advisable to reduce sensitivity to rounding errors.</p><p>A nonlinear equality constraint of the form <em>h</em>(<em>x</em>) = 0, where the function <em>h</em> is of the same form as the objective function described above, can be specified by calling:</p><p><strong>  nlopt_result nlopt_add_equality_constraint(nlopt_opt </strong><em>opt</em><strong>,</strong></p><p><strong>                                             nlopt_func </strong><em>h</em><strong>,</strong></p><p><strong>                                             void* </strong><em>h_data</em><strong>,</strong></p><p><strong>                                             double </strong><em>tol</em><strong>);</strong></p><p>Just as for the objective function, <em>h_data</em> is a pointer to arbitrary user data that will be passed through to the <em>h</em> function whenever it is called.  The parameter <em>tol</em> is a tolerance that is used for the purpose of stopping criteria only: a point <em>x</em> is considered feasible for judging whether to stop the optimization if |<em>h</em>(<em>x</em>)| &lt;= <em>tol</em>.  For equality constraints, a small positive tolerance is strongly advised in order to allow NLopt to converge even if the equality constraint is slightly nonzero.</p><p>(For any algorithm listed as "derivative-free" below, the <em>grad</em> argument to <em>fc</em> or <em>h</em> will always be NULL and need never be computed.)</p><p>To remove all of the inequality and/or equality constraints from a given problem <em>opt</em>, you can call the following functions:</p><p><strong>  nlopt_result nlopt_remove_inequality_constraints(nlopt_opt </strong><em>opt</em><strong>);</strong></p><p><strong>  nlopt_result nlopt_remove_equality_constraints(nlopt_opt </strong><em>opt</em><strong>);</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ALGORITHMS</h2>
        <div class="sectioncontent">
<p>The <em>algorithm</em> parameter specifies the optimization algorithm (for more detail on these, see the README files in the source-code subdirectories), and can take on any of the following constant values.</p><p>Constants with <strong>_G{N,D}_</strong> in their names refer to global optimization methods, whereas <strong>_L{N,D}_</strong> refers to local optimization methods (that try to find a local optimum starting from the starting guess <em>x</em>). Constants with <strong>_{G,L}N_</strong> refer to non-gradient (derivative-free) algorithms that do not require the objective function to supply a gradient, whereas <strong>_{G,L}D_</strong> refers to derivative-based algorithms that require the objective function to supply a gradient.  (Especially for local optimization, derivative-based algorithms are generally superior to derivative-free ones: the gradient is good to have <em>if</em> you can compute it cheaply, e.g. via an adjoint method.)</p><p>The algorithm specified for a given problem <em>opt</em> is returned by the function:</p><p><strong>  nlopt_algorithm nlopt_get_algorithm(nlopt_opt </strong><em>opt</em><strong>);</strong></p><p>The available algorithms are:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>NLOPT_GN_DIRECT_L</strong></p>
  </dt>
  <dd>
    <p>Perform a global (G) derivative-free (N) optimization using the DIRECT-L search algorithm by Jones et al. as modified by Gablonsky et al. to be more weighted towards local search.  Does not support unconstrainted optimization.  There are also several other variants of the DIRECT algorithm that are supported: <strong>NLOPT_GLOBAL_DIRECT</strong>, which is the original DIRECT algorithm; <strong>NLOPT_GLOBAL_DIRECT_L_RAND</strong>, a slightly randomized version of DIRECT-L that may be better in high-dimensional search spaces; <strong>NLOPT_GLOBAL_DIRECT_NOSCAL</strong>, <strong>NLOPT_GLOBAL_DIRECT_L_NOSCAL</strong>, and <strong>NLOPT_GLOBAL_DIRECT_L_RAND_NOSCAL</strong>, which are versions of DIRECT where the dimensions are not rescaled to a unit hypercube (which means that dimensions with larger bounds are given more weight).</p>
  </dd>
  <dt>
    <p><strong>NLOPT_GN_ORIG_DIRECT_L</strong></p>
  </dt>
  <dd>
    <p>A global (G) derivative-free optimization using the DIRECT-L algorithm as above, along with <strong>NLOPT_GN_ORIG_DIRECT</strong> which is the original DIRECT algorithm.  Unlike <strong>NLOPT_GN_DIRECT_L</strong> above, these two algorithms refer to code based on the original Fortran code of Gablonsky et al., which has some hard-coded limitations on the number of subdivisions etc. and does not support all of the NLopt stopping criteria, but on the other hand it supports arbitrary nonlinear inequality constraints.</p>
  </dd>
  <dt>
    <p><strong>NLOPT_GD_STOGO</strong></p>
  </dt>
  <dd>
    <p>Global (G) optimization using the StoGO algorithm by Madsen et al.  StoGO exploits gradient information (D) (which must be supplied by the objective) for its local searches, and performs the global search by a branch-and-bound technique.  Only bound-constrained optimization is supported.  There is also another variant of this algorithm, <strong>NLOPT_GD_STOGO_RAND</strong>, which is a randomized version of the StoGO search scheme.  The StoGO algorithms are only available if NLopt is compiled with C++ code enabled, and should be linked via -lnlopt_cxx instead of -lnlopt (via a C++ compiler, in order to link the C++ standard libraries).</p>
  </dd>
  <dt>
    <p><strong>NLOPT_LN_NELDERMEAD</strong></p>
  </dt>
  <dd>
    <p>Perform a local (L) derivative-free (N) optimization, starting at <em>x</em>, using the Nelder-Mead simplex algorithm, modified to support bound constraints.  Nelder-Mead, while popular, is known to occasionally fail to converge for some objective functions, so it should be used with caution.  Anecdotal evidence, on the other hand, suggests that it works fairly well for some cases that are hard to handle otherwise, e.g. noisy/discontinuous objectives.  See also <strong>NLOPT_LN_SBPLX</strong> below.</p>
  </dd>
  <dt>
    <p><strong>NLOPT_LN_SBPLX</strong></p>
  </dt>
  <dd>
    <p>Perform a local (L) derivative-free (N) optimization, starting at <em>x</em>, using an algorithm based on the Subplex algorithm of Rowan et al., which is an improved variant of Nelder-Mead (above).  Our implementation does not use Rowan's original code, and has some minor modifications such as explicit support for bound constraints.  (Like Nelder-Mead, Subplex often works well in practice, even for noisy/discontinuous objectives, but there is no rigorous guarantee that it will converge.)</p>
  </dd>
  <dt>
    <p><strong>NLOPT_LN_PRAXIS</strong></p>
  </dt>
  <dd>
    <p>Local (L) derivative-free (N) optimization using the principal-axis method, based on code by Richard Brent.  Designed for unconstrained optimization, although bound constraints are supported too (via the inefficient method of returning +Inf when the constraints are violated).</p>
  </dd>
  <dt>
    <p><strong>NLOPT_LD_LBFGS</strong></p>
  </dt>
  <dd>
    <p>Local (L) gradient-based (D) optimization using the limited-memory BFGS (L-BFGS) algorithm.  (The objective function must supply the gradient.)  Unconstrained optimization is supported in addition to simple bound constraints (see above).  Based on an implementation by Luksan et al.</p>
  </dd>
  <dt>
    <p><strong>NLOPT_LD_VAR2</strong></p>
  </dt>
  <dd>
    <p>Local (L) gradient-based (D) optimization using a shifted limited-memory variable-metric method based on code by Luksan et al., supporting both unconstrained and bound-constrained optimization. <strong>NLOPT_LD_VAR2</strong> uses a rank-2 method, while <strong>.B NLOPT_LD_VAR1</strong> is another variant using a rank-1 method.</p>
  </dd>
  <dt>
    <p><strong>NLOPT_LD_TNEWTON_PRECOND_RESTART</strong></p>
  </dt>
  <dd>
    <p>Local (L) gradient-based (D) optimization using an LBFGS-preconditioned truncated Newton method with steepest-descent restarting, based on code by Luksan et al., supporting both unconstrained and bound-constrained optimization.  There are several other variants of this algorithm: <strong>NLOPT_LD_TNEWTON_PRECOND</strong> (same without restarting), <strong>NLOPT_LD_TNEWTON_RESTART</strong> (same without preconditioning), and <strong>NLOPT_LD_TNEWTON</strong> (same without restarting or preconditioning).</p>
  </dd>
  <dt>
    <p><strong>NLOPT_GN_CRS2_LM</strong></p>
  </dt>
  <dd>
    <p>Global (G) derivative-free (N) optimization using the controlled random search (CRS2) algorithm of Price, with the "local mutation" (LM) modification suggested by Kaelo and Ali.</p>
  </dd>
  <dt>
    <p><strong>NLOPT_GN_ISRES</strong></p>
  </dt>
  <dd>
    <p>Global (G) derivative-free (N) optimization using a genetic algorithm (mutation and differential evolution), using a stochastic ranking to handle nonlinear inequality and equality constraints as suggested by Runarsson and Yao.</p>
  </dd>
  <dt>
    <p><strong>NLOPT_G_MLSL_LDS</strong>, <strong>NLOPT_G_MLSL</strong></p>
  </dt>
  <dd>
    <p>Global (G) optimization using the multi-level single-linkage (MLSL) algorithm with a low-discrepancy sequence (LDS) or pseudorandom numbers, respectively.  This algorithm executes a low-discrepancy or pseudorandom sequence of local searches, with a clustering heuristic to avoid multiple local searches for the same local optimum. The local search algorithm must be specified, along with termination criteria/tolerances for the local searches, by <em>nlopt_set_local_optimizer</em>.  (This subsidiary algorithm can be with or without derivatives, and determines whether the objective function needs gradients.)</p>
  </dd>
  <dt>
    <p><strong>NLOPT_LD_MMA</strong>, <strong>NLOPT_LD_CCSAQ</strong></p>
  </dt>
  <dd>
    <p>Local (L) gradient-based (D) optimization using the method of moving asymptotes (MMA), or rather a refined version of the algorithm as published by Svanberg (2002).  (NLopt uses an independent free-software/open-source implementation of Svanberg's algorithm.) CCSAQ is a related algorithm from Svanberg's paper which uses a local quadratic approximation rather than the more-complicated MMA model; the two usually have similar convergence rates. The <strong>NLOPT_LD_MMA</strong> algorithm supports both bound-constrained and unconstrained optimization, and also supports an arbitrary number (<em>m</em>) of nonlinear inequality (not equality) constraints as described above.</p>
  </dd>
  <dt>
    <p><strong>NLOPT_LD_SLSQP</strong></p>
  </dt>
  <dd>
    <p>Local (L) gradient-based (D) optimization using sequential quadratic programming and BFGS updates, supporting arbitrary nonlinear inequality and equality constraints, based on the code by Dieter Kraft (1988) adapted for use by the SciPy project.  Note that this algorithm uses dense-matrix methods requiring O(<em>n</em>^2) storage and O(<em>n</em>^3) time, making it less practical for problems involving more than a few thousand parameters.</p>
  </dd>
  <dt>
    <p><strong>NLOPT_LN_COBYLA</strong></p>
  </dt>
  <dd>
    <p>Local (L) derivative-free (N) optimization using the COBYLA algorithm of Powell (Constrained Optimization BY Linear Approximations). The <strong>NLOPT_LN_COBYLA</strong> algorithm supports both bound-constrained and unconstrained optimization, and also supports an arbitrary number (<em>m</em>) of nonlinear inequality/equality constraints as described above.</p>
  </dd>
  <dt>
    <p><strong>NLOPT_LN_NEWUOA</strong></p>
  </dt>
  <dd>
    <p>Local (L) derivative-free (N) optimization using a variant of the NEWUOA algorithm of Powell, based on successive quadratic approximations of the objective function. We have modified the algorithm to support bound constraints.  The original NEWUOA algorithm is also available, as <strong>NLOPT_LN_NEWUOA</strong>, but this algorithm ignores the bound constraints <em>lb</em> and <em>ub</em>, and so it should only be used for unconstrained problems.  Mostly superseded by BOBYQA.</p>
  </dd>
  <dt>
    <p><strong>NLOPT_LN_BOBYQA</strong></p>
  </dt>
  <dd>
    <p>Local (L) derivative-free (N) optimization using the BOBYQA algorithm of Powell, based on successive quadratic approximations of the objective function, supporting bound constraints.</p>
  </dd>
  <dt>
    <p><strong>NLOPT_AUGLAG</strong></p>
  </dt>
  <dd>
    <p>Optimize an objective with nonlinear inequality/equality constraints via an unconstrained (or bound-constrained) optimization algorithm, using a gradually increasing "augmented Lagrangian" penalty for violated constraints.  Requires you to specify another optimization algorithm for optimizing the objective+penalty function, using <em>nlopt_set_local_optimizer</em>.  (This subsidiary algorithm can be global or local and with or without derivatives, but you must specify its own termination criteria.)  A variant, <strong>NLOPT_AUGLAG_EQ</strong>, only uses the penalty approach for equality constraints, while inequality constraints are handled directly by the subsidiary algorithm (restricting the choice of subsidiary algorithms to those that can handle inequality constraints).</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">STOPPING CRITERIA</h2>
        <div class="sectioncontent">
<p>Multiple stopping criteria for the optimization are supported, as specified by the functions to modify a given optimization problem <strong>opt</strong>. The optimization halts whenever any one of these criteria is satisfied.  In some cases, the precise interpretation of the stopping criterion depends on the optimization algorithm above (although we have tried to make them as consistent as reasonably possible), and some algorithms do not support all of the stopping criteria.</p><p>Important: you do not need to use all of the stopping criteria!  In most cases, you only need one or two, and can omit the remainder (all criteria are disabled by default).</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>nlopt_result nlopt_set_stopval(nlopt_opt </strong><em>opt</em><strong>,</strong></p>
  </dt>
  <dd>
    <p><strong>                        double </strong><em>stopval</em><strong>);</strong></p><p>Stop when an objective value of at least <em>stopval</em> is found: stop minimizing when a value &lt;= <em>stopval</em> is found, or stop maximizing when a value &gt;= <em>stopval</em> is found.  (Setting <em>stopval</em> to -HUGE_VAL for minimizing or +HUGE_VAL for maximizing disables this stopping criterion.)</p>
  </dd>
  <dt>
    <p><strong>nlopt_result nlopt_set_ftol_rel(nlopt_opt </strong><em>opt</em><strong>,</strong></p>
  </dt>
  <dd>
    <p><strong>                         double </strong><em>tol</em><strong>);</strong></p><p>Set relative tolerance on function value: stop when an optimization step (or an estimate of the optimum) changes the function value by less than <em>tol</em> multiplied by the absolute value of the function value.  (If there is any chance that your optimum function value is close to zero, you might want to set an absolute tolerance with <strong>nlopt_set_ftol_abs</strong> as well.)  Criterion is disabled if <em>tol</em> is non-positive.</p>
  </dd>
  <dt>
    <p><strong>nlopt_result nlopt_set_ftol_abs(nlopt_opt </strong><em>opt</em><strong>,</strong></p>
  </dt>
  <dd>
    <p><strong>                         double </strong><em>tol</em><strong>);</strong></p><p>Set absolute tolerance on function value: stop when an optimization step (or an estimate of the optimum) changes the function value by less than <em>tol</em>. Criterion is disabled if <em>tol</em> is non-positive.</p>
  </dd>
  <dt>
    <p><strong>nlopt_result nlopt_set_xtol_rel(nlopt_opt </strong><em>opt</em><strong>,</strong></p>
  </dt>
  <dd>
    <p><strong>                         double </strong><em>tol</em><strong>);</strong></p><p>Set relative tolerance on design variables: stop when an optimization step (or an estimate of the optimum) changes every design variable by less than <em>tol</em> multiplied by the absolute value of the design variable.  (If there is any chance that an optimal design variable is close to zero, you might want to set an absolute tolerance with <strong>nlopt_set_xtol_abs</strong> as well.)  Criterion is disabled if <em>tol</em> is non-positive.</p>
  </dd>
  <dt>
    <p><strong>nlopt_result nlopt_set_xtol_abs(nlopt_opt </strong><em>opt</em><strong>,</strong></p>
  </dt>
  <dd>
    <p><strong>                         const double* </strong><em>tol</em><strong>);</strong></p><p>Set absolute tolerances on design variables.  <em>tol</em> is a pointer to an array of length <em></em> n giving the tolerances: stop when an optimization step (or an estimate of the optimum) changes every design variable <em>x</em>[i] by less than <em>tol</em>[i].</p><p>For convenience, the following function may be used to set the absolute tolerances in all <em>n</em> design variables to the same value:</p><p><strong>  nlopt_result nlopt_set_xtol_abs1(nlopt_opt </strong><em>opt</em><strong>,</strong></p><p><strong>                                   double </strong><em>tol</em><strong>);</strong></p><p>Criterion is disabled if <em>tol</em> is non-positive.</p>
  </dd>
  <dt>
    <p><strong>nlopt_result nlopt_set_maxeval(nlopt_opt </strong><em>opt</em><strong>,</strong></p>
  </dt>
  <dd>
    <p><strong>                        int </strong><em>maxeval</em><strong>);</strong></p><p>Stop when the number of function evaluations exceeds <em>maxeval</em>. (This is not a strict maximum: the number of function evaluations may exceed <em>maxeval</em> slightly, depending upon the algorithm.)  Criterion is disabled if <em>maxeval</em> is non-positive.</p>
  </dd>
  <dt>
    <p><strong>nlopt_result nlopt_set_maxtime(nlopt_opt </strong><em>opt</em><strong>,</strong></p>
  </dt>
  <dd>
    <p><strong>                        double </strong><em>maxtime</em><strong>);</strong></p><p>Stop when the optimization time (in seconds) exceeds <em>maxtime</em>. (This is not a strict maximum: the time may exceed <em>maxtime</em> slightly, depending upon the algorithm and on how slow your function evaluation is.)  Criterion is disabled if <em>maxtime</em> is non-positive.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>Most of the NLopt functions return an enumerated constant of type <strong>nlopt_result</strong>, which takes on one of the following values:</p><h3>Successful termination (positive return values):</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong>NLOPT_SUCCESS</strong></p>
  </dt>
  <dd>
    <p>Generic success return value.</p>
  </dd>
  <dt>
    <p><strong>NLOPT_STOPVAL_REACHED</strong></p>
  </dt>
  <dd>
    <p>Optimization stopped because <em>stopval</em> (above) was reached.</p>
  </dd>
  <dt>
    <p><strong>NLOPT_FTOL_REACHED</strong></p>
  </dt>
  <dd>
    <p>Optimization stopped because <em>ftol_rel</em> or <em>ftol_abs</em> (above) was reached.</p>
  </dd>
  <dt>
    <p><strong>NLOPT_XTOL_REACHED</strong></p>
  </dt>
  <dd>
    <p>Optimization stopped because <em>xtol_rel</em> or <em>xtol_abs</em> (above) was reached.</p>
  </dd>
  <dt>
    <p><strong>NLOPT_MAXEVAL_REACHED</strong></p>
  </dt>
  <dd>
    <p>Optimization stopped because <em>maxeval</em> (above) was reached.</p>
  </dd>
  <dt>
    <p><strong>NLOPT_MAXTIME_REACHED</strong></p>
  </dt>
  <dd>
    <p>Optimization stopped because <em>maxtime</em> (above) was reached.</p>
  </dd>

</dl>

<h3>Error codes (negative return values):</h3>

<dl class='dl-vertical'>
  <dt>
    <p><strong>NLOPT_FAILURE</strong></p>
  </dt>
  <dd>
    <p>Generic failure code.</p>
  </dd>
  <dt>
    <p><strong>NLOPT_INVALID_ARGS</strong></p>
  </dt>
  <dd>
    <p>Invalid arguments (e.g. lower bounds are bigger than upper bounds, an unknown algorithm was specified, etcetera).</p>
  </dd>
  <dt>
    <p><strong>NLOPT_OUT_OF_MEMORY</strong></p>
  </dt>
  <dd>
    <p>Ran out of memory.</p>
  </dd>
  <dt>
    <p><strong>NLOPT_ROUNDOFF_LIMITED</strong></p>
  </dt>
  <dd>
    <p>Halted because roundoff errors limited progress.</p>
  </dd>
  <dt>
    <p><strong>NLOPT_FORCED_STOP</strong></p>
  </dt>
  <dd>
    <p>Halted because the user called <strong>nlopt_force_stop</strong>(<em>opt</em>) on the optimization's <strong>nlopt_opt</strong> object <em>opt</em> from the user's objective function.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LOCAL OPTIMIZER</h2>
        <div class="sectioncontent">
<p>Some of the algorithms, especially MLSL and AUGLAG, use a different optimization algorithm as a subroutine, typically for local optimization.  You can change the local search algorithm and its tolerances by calling:</p><p><strong>  nlopt_result nlopt_set_local_optimizer(nlopt_opt </strong><em>opt</em><strong>,</strong></p><p><strong>                                         const nlopt_opt </strong><em>local_opt</em><strong>);</strong></p><p>Here, <em>local_opt</em> is another <strong>nlopt_opt</strong> object whose parameters are used to determine the local search algorithm and stopping criteria.  (The objective function, bounds, and nonlinear-constraint parameters of <em>local_opt</em> are ignored.)  The dimension <em>n</em> of <em>local_opt</em> must match that of <em>opt</em>.</p><p>This function makes a copy of the <em>local_opt</em> object, so you can freely destroy your original <em>local_opt</em> afterwards.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INITIAL STEP SIZE</h2>
        <div class="sectioncontent">
<p>For derivative-free local-optimization algorithms, the optimizer must somehow decide on some initial step size to perturb <em>x</em> by when it begins the optimization.  This step size should be big enough that the value of the objective changes significantly, but not too big if you want to find the local optimum nearest to <em>x</em>.  By default, NLopt chooses this initial step size heuristically from the bounds, tolerances, and other information, but this may not always be the best choice.</p><p>You can modify the initial step size by calling:</p><p><strong>  nlopt_result nlopt_set_initial_step(nlopt_opt </strong><em>opt</em><strong>,</strong></p><p><strong>                                      const double* </strong><em>dx</em><strong>);</strong></p><p>Here, <em>dx</em> is an array of length <em>n</em> containing the (nonzero) initial step size for each component of the design parameters <em>x</em>. For convenience, if you want to set the step sizes in every direction to be the same value, you can instead call:</p><p><strong>  nlopt_result nlopt_set_initial_step1(nlopt_opt </strong><em>opt</em><strong>,</strong></p><p><strong>                                       double </strong><em>dx</em><strong>);</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">STOCHASTIC POPULATION</h2>
        <div class="sectioncontent">
<p>Several of the stochastic search algorithms (e.g., CRS, MLSL, and ISRES) start by generating some initial "population" of random points <em>x</em>.  By default, this initial population size is chosen heuristically in some algorithm-specific way, but the initial population can by changed by calling:</p><p><strong>  nlopt_result nlopt_set_population(nlopt_opt </strong><em>opt</em><strong>,</strong></p><p><strong>                                    unsigned </strong><em>pop</em><strong>);</strong></p><p>(A <em>pop</em> of zero implies that the heuristic default will be used.)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PSEUDORANDOM NUMBERS</h2>
        <div class="sectioncontent">
<p>For stochastic optimization algorithms, we use pseudorandom numbers generated by the Mersenne Twister algorithm, based on code from Makoto Matsumoto. By default, the seed for the random numbers is generated from the system time, so that they will be different each time you run the program.  If you want to use deterministic random numbers, you can set the seed by calling:</p><p><strong>            void nlopt_srand(unsigned long </strong><em>seed</em><strong>);</strong></p><p>Some of the algorithms also support using low-discrepancy sequences (LDS), sometimes known as quasi-random numbers.  NLopt uses the Sobol LDS, which is implemented for up to 1111 dimensions.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p>Written by Steven G. Johnson.</p><p>Copyright (c) 2007-2014 Massachusetts Institute of Technology.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO nlopt&hellip;</h2>
        <div class="sectioncontent">
<p><strong>nlopt_minimize</strong>(3)</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="nl_langinfo.3.html"><span aria-hidden="true">&larr;</span> nl_langinfo.3: Query language and locale information</a></li>
   <li class="next"><a href="nmf_als.hpp.3.html">nmf_als.hpp.3: Src/mlpack/methods/amf/update_rules/nmf_als.hpp - <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

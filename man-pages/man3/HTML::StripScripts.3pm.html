<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>HTML::StripScripts: Strip scripting constructs out of html</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Strip scripting constructs out of html">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="HTML::StripScripts (3pm) manual">
  <meta name="twitter:description" content="Strip scripting constructs out of html">
  <meta name="twitter:image" content="https://www.carta.tech/images/libhtml-stripscripts-perl-HTML::StripScripts-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/HTML::StripScripts.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="HTML::StripScripts (3pm) manual" />
  <meta property="og:description" content="Strip scripting constructs out of html" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libhtml-stripscripts-perl-HTML::StripScripts-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">HTML::StripScripts<small> (3pm)</small></h1>
        <p class="lead">Strip scripting constructs out of html</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/HTML::StripScripts.3pm.html">
      <span itemprop="name">HTML::StripScripts: Strip scripting constructs out of html</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libhtml-stripscripts-perl/">
      <span itemprop="name">libhtml-stripscripts-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/HTML::StripScripts.3pm.html">
      <span itemprop="name">HTML::StripScripts: Strip scripting constructs out of html</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  use HTML::StripScripts;

  my $hss = HTML::StripScripts-&gt;new({ Context =&gt; &apos;Inline&apos; });

  $hss-&gt;input_start_document;

  $hss-&gt;input_start(&apos;&lt;i&gt;&apos;);
  $hss-&gt;input_text(&apos;hello, world!&apos;);
  $hss-&gt;input_end(&apos;&lt;/i&gt;&apos;);

  $hss-&gt;input_end_document;

  print $hss-&gt;filtered_document;
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module strips scripting constructs out of \s-1HTML\s0, leaving as much non-scripting markup in place as possible.  This allows web applications to display \s-1HTML\s0 originating from an untrusted source without introducing \s-1XSS\s0 (cross site scripting) vulnerabilities.</p><p>You will probably use HTML::StripScripts::Parser rather than using this module directly.</p><p>The process is based on whitelists of tags, attributes and attribute values.  This approach is the most secure against disguised scripting constructs hidden in malicious \s-1HTML\s0 documents.</p><p>As well as removing scripting constructs, this module ensures that there is a matching end for each start tag, and that the tags are properly nested.</p><p>Previously, in order to customise the output, you needed to subclass \*(C`HTML::StripScripts\*(C' and override methods.  Now, most customisation can be done through the \*(C`Rules\*(C' option provided to \*(C`new()\*(C'. (See examples/declaration/ and examples/tags/ for cases where subclassing is necessary.)</p><p>The \s-1HTML\s0 document must be parsed into start tags, end tags and text before it can be filtered by this module.  Use either HTML::StripScripts::Parser or HTML::StripScripts::Regex instead if you want to input an unparsed \s-1HTML\s0 document.</p><p>See examples/direct/ for an example of how to feed tokens directly to  HTML::StripScripts.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONSTRUCTORS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    new ( \s-1CONFIG\s0 )
  </dt>
  <dd>
    <p>Creates a new \*(C`HTML::StripScripts\*(C' filter object, bound to a particular filtering policy.  If present, the \s-1CONFIG\s0 parameter must be a hashref.  The following keys are recognized (unrecognized keys will be silently ignored).     $s = HTML::Stripscripts-&gt;new({         Context         =&gt; &apos;Document|Flow|Inline|NoTags&apos;,         BanList         =&gt; [qw( br img )] | {br =&gt; &apos;1&apos;, img =&gt; &apos;1&apos;},         BanAllBut       =&gt; [qw(p div span)],         AllowSrc        =&gt; 0|1,         AllowHref       =&gt; 0|1,         AllowRelURL     =&gt; 0|1,         AllowMailto     =&gt; 0|1,         EscapeFiltered  =&gt; 0|1,         Rules           =&gt; { See below for details },     });</p><p>A string specifying the context in which the filtered document will be used.  This influences the set of tags that will be allowed. If present, the \*(C`Context\*(C' value must be one of:</p><p>If \*(C`Context\*(C' is \*(C`Document\*(C' then the filter will allow a full \s-1HTML\s0 document, including the \*(C`HTML\*(C' tag and \*(C`HEAD\*(C' and \*(C`BODY\*(C' sections. If \*(C`Context\*(C' is \*(C`Flow\*(C' then most of the cosmetic tags that one would expect to find in a document body are allowed, including lists and tables but not including forms. If \*(C`Context\*(C' is \*(C`Inline\*(C' then only inline tags such as \*(C`B\*(C' and \*(C`FONT\*(C' are allowed. If \*(C`Context\*(C' is \*(C`NoTags\*(C' then no tags are allowed.</p><p>The default \*(C`Context\*(C' value is \*(C`Flow\*(C'.</p><p>If present, this option must be an arrayref or a hashref.  Any tag that would normally be allowed (because it presents no \s-1XSS\s0 hazard) will be blocked if the lowercase name of the tag is in this list. For example, in a guestbook application where \*(C`HR\*(C' tags are used to separate posts, you may wish to prevent posts from including \*(C`HR\*(C' tags, even though \*(C`HR\*(C' is not an \s-1XSS\s0 risk. If present, this option must be reference to an array holding a list of lowercase tag names.  This has the effect of adding all but the listed tags to the ban list, so that only those tags listed will be allowed. By default, the filter won't allow constructs that cause the browser to fetch things automatically, such as \*(C`SRC\*(C' attributes in \*(C`IMG\*(C' tags. If this option is present and true then those constructs will be allowed. By default, the filter won't allow constructs that cause the browser to fetch things if the user clicks on something, such as the \*(C`HREF\*(C' attribute in \*(C`A\*(C' tags.  Set this option to a true value to allow this type of construct. By default, the filter won't allow relative URLs such as \*(C`../foo.html\*(C' in \*(C`SRC\*(C' and \*(C`HREF\*(C' attribute values.  Set this option to a true value to allow them. \*(C`AllowHref\*(C' and / or \*(C`AllowSrc\*(C' also need to be set to true for this to have any effect. By default, \*(C`mailto:\*(C' links are not allowed. If \*(C`AllowMailto\*(C' is set to a true value, then this construct will be allowed. This can be enabled separately from AllowHref. By default, any filtered tags are outputted as \*(C`&lt;!--filtered--&gt;\*(C'. If \*(C`EscapeFiltered\*(C' is set to a true value, then the filtered tags are converted to \s-1HTML\s0 entities. For instance:   &lt;br&gt;  --&gt;  &lt;br&gt; The \*(C`Rules\*(C' option provides a very flexible way of customising the filter. The focus is safety-first, so it is applied after all of the previous validation. This means that you cannot all malicious data should already have been cleared. Rules can be specified for tags and for attributes. Any tag or attribute not explicitly listed will be handled by the default \*(C`*\*(C' rules. The following is a synopsis of all of the options that you can use to configure rules.  Below, an example is broken into sections and explained.  Rules =&gt; {</p><p>     tag =&gt; 0 | 1 | sub { tag_callback }             | {                 attr      =&gt; 0 | 1 | &apos;regex&apos; | qr/regex/ | sub { attr_callback},                 &apos;*&apos;       =&gt; 0 | 1 | &apos;regex&apos; | qr/regex/ | sub { attr_callback},                 required  =&gt; [qw(attrname attrname)],                 tag       =&gt; sub { tag_callback }               },</p><p>    &apos;*&apos; =&gt; 0 | 1 | sub { tag_callback }            | {                attr =&gt; 0 | 1 | &apos;regex&apos; | qr/regex/ | sub { attr_callback},                &apos;*&apos;  =&gt; 0 | 1 | &apos;regex&apos; | qr/regex/ | sub { attr_callback},                tag  =&gt; sub { tag_callback }              }</p><p>    } \s-1EXAMPLE:\s0     Rules =&gt; {</p><p>        ##########################         ##### EXPLICIT RULES #####         ##########################</p><p>        ## Allow &lt;br&gt; tags, reject &lt;img&gt; tags         br          =&gt; 1,         img         =&gt; 0,</p><p>        ## Send all &lt;div&gt; tags to a sub         div         =&gt; sub { tag_callback },</p><p>        ## Allow &lt;blockquote&gt; tags,and allow the &apos;cite&apos; attribute         ## All other attributes are handled by the default C&lt;*&gt;         blockquote  =&gt; {             cite    =&gt; 1,         },</p><p>        ## Allow &lt;a&gt; tags, and         a  =&gt; {</p><p>            ## Allow the &apos;title&apos; attribute             title     =&gt; 1,</p><p>            ## Allow the &apos;href&apos; attribute if it matches the regex             href    =&gt;   &apos;^http://yourdomain.com&apos;        OR   href    =&gt; qr{^http://yourdomain.com},</p><p>            ## &apos;style&apos; attributes are handled by a sub             style     =&gt; sub { attr_callback },</p><p>            ## All other attributes are rejected             &apos;*&apos;       =&gt; 0,</p><p>            ## Additionally, the &lt;a&gt; tag should be handled by this sub             tag       =&gt; sub { tag_callback},</p><p>            ## If the &lt;a&gt; tag doesn&apos;t have these attributes, filter the tag             required  =&gt; [qw(href title)],</p><p>        },</p><p>        ##########################         ##### DEFAULT RULES #####         ##########################</p><p>        ## The default &apos;*&apos; rule - accepts all the same options as above.         ## If a tag or attribute is not mentioned above, then the default         ## rule is applied:</p><p>        ## Reject all tags         &apos;*&apos;         =&gt; 0,</p><p>        ## Allow all tags and all attributes         &apos;*&apos;         =&gt; 1,</p><p>        ## Send all tags to the sub         &apos;*&apos;         =&gt; sub { tag_callback },</p><p>        ## Allow all tags, reject all attributes         &apos;*&apos;         =&gt; { &apos;*&apos;  =&gt; 0 },</p><p>        ## Allow all tags, and         &apos;*&apos; =&gt; {</p><p>            ## Allow the &apos;title&apos; attribute             title   =&gt; 1,</p><p>            ## Allow the &apos;href&apos; attribute if it matches the regex             href    =&gt;   &apos;^http://yourdomain.com&apos;        OR   href    =&gt; qr{^http://yourdomain.com},</p><p>            ## &apos;style&apos; attributes are handled by a sub             style   =&gt; sub { attr_callback },</p><p>            ## All other attributes are rejected             &apos;*&apos;     =&gt; 0,</p><p>            ## Additionally, all tags should be handled by this sub             tag     =&gt; sub { tag_callback},</p><p>        },</p>
<dl class='dl-vertical'>
  <dt>
    Tag Callbacks
  </dt>
  <dd>
    <p>    sub tag_callback {         my ($filter,$element) = (@_);</p><p>        $element = {             tag      =&gt; &apos;tag&apos;,             content  =&gt; &apos;inner_html&apos;,             attr     =&gt; {                 attr_name =&gt; &apos;attr_value&apos;,             }         };         return 0 | 1;     } A tag callback accepts two parameters, the $filter object and the C$element&gt;. It should return 0 to completely ignore the tag and its content (which includes any nested \s-1HTML\s0 tags), or 1 to accept and output the tag. The $element is a hash ref containing the keys: This is the tagname in lowercase, eg \*(C`a\*(C', \*(C`br\*(C', \*(C`img\*(C'. If you set the tag value to an empty string, then the tag will not be outputted, but the tag contents will. This is the equivalent of \s-1DOM\s0's innerHTML. It contains the text content and any \s-1HTML\s0 tags contained within this element. You can change the content or set it to an empty string so that it is not outputted. \*(C`attr\*(C' contains a hashref containing the attribute names and values</p>
  </dd>

</dl>
<p>If for instance, you wanted to replace \*(C`&lt;b&gt;\*(C' tags with \*(C`&lt;span&gt;\*(C' tags, you could do this:     sub b_callback {         my ($filter,$element)   = @_;         $element-&gt;{tag}         = &apos;span&apos;;         $element-&gt;{attr}{style} = &apos;font-weight:bold&apos;;         return 1;     }</p>
<dl class='dl-vertical'>
  <dt>
    Attribute Callbacks
  </dt>
  <dd>
    <p>    sub attr_callback {         my ( $filter, $tag, $attr_name, $attr_val ) = @_;         return undef | &apos;&apos; | &apos;value&apos;;     } Attribute callbacks accept four parameters, the $filter object, the $tag name, the $attr_name and the $attr_value. It should return either \*(C`undef\*(C' to reject the attribute, or the value to be used. An empty string keeps the attribute, but without a value. It is not necessary to use \*(C`BanList\*(C' or \*(C`BanAllBut\*(C' - everything can be done via \*(C`Rules\*(C', however it may be simpler to write:     BanAllBut =&gt; [qw(p div span)] The logic works as follows:    * If BanAllBut exists, then ban everything but the tags in the list    * Add to the ban list any elements in BanList    * Any tags mentioned explicitly in Rules (eg a =&gt; 0, br =&gt; 1)      are added or removed from the BanList    * A default rule of { &apos;*&apos; =&gt; 0 } would ban all tags except      those mentioned in Rules    * A default rule of { &apos;*&apos; =&gt; 1 } would allow all tags except      those disallowed in the ban list, or by explicit rules</p>
  </dd>

</dl>

  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">
<p>This class provides the following methods:</p>
<dl class='dl-vertical'>
  <dt>
    hss_init ()
  </dt>
  <dd>
    <p>This method is called by <em>new()</em> and does the actual initialisation work for the new HTML::StripScripts object.</p>
  </dd>
  <dt>
    input_start_document ()
  </dt>
  <dd>
    <p>This method initializes the filter, and must be called once before starting on each \s-1HTML\s0 document to be filtered.</p>
  </dd>
  <dt>
    input_start ( \s-1TEXT\s0 )
  </dt>
  <dd>
    <p>Handles a start tag from the input document.  \s-1TEXT\s0 must be the full text of the tag, including angle-brackets.</p>
  </dd>
  <dt>
    input_end ( \s-1TEXT\s0 )
  </dt>
  <dd>
    <p>Handles an end tag from the input document.  \s-1TEXT\s0 must be the full text of the end tag, including angle-brackets.</p>
  </dd>
  <dt>
    input_text ( \s-1TEXT\s0 )
  </dt>
  <dd>
    <p>Handles some non-tag text from the input document.</p>
  </dd>
  <dt>
    input_process ( \s-1TEXT\s0 )
  </dt>
  <dd>
    <p>Handles a processing instruction from the input document.</p>
  </dd>
  <dt>
    input_comment ( \s-1TEXT\s0 )
  </dt>
  <dd>
    <p>Handles an \s-1HTML\s0 comment from the input document.</p>
  </dd>
  <dt>
    input_declaration ( \s-1TEXT\s0 )
  </dt>
  <dd>
    <p>Handles an declaration from the input document.</p>
  </dd>
  <dt>
    input_end_document ()
  </dt>
  <dd>
    <p>Call this method to signal the end of the input document.</p>
  </dd>
  <dt>
    filtered_document ()
  </dt>
  <dd>
    <p>Returns the filtered document as a string.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SUBCLASSING</h2>
        <div class="sectioncontent">
<p>The only reason for subclassing this module now is to add to the list of accepted tags, attributes and styles (See \*(L"\s-1WHITELIST\s0 \s-1INITIALIZATION\s0 \s-1METHODS\s0\*(R").  Everything else can be achieved with \*(L"Rules\*(R".</p><p>The \*(C`HTML::StripScripts\*(C' class is subclassable.  Filter objects are plain hashes and \*(C`HTML::StripScripts\*(C' reserves only hash keys that start with \*(C`_hss\*(C'.  The filter configuration can be set up by invoking the <em>hss_init()</em> method, which takes the same arguments as <em>new()</em>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OUTPUT METHODS</h2>
        <div class="sectioncontent">
<p>The filter outputs a stream of start tags, end tags, text, comments, declarations and processing instructions, via the following \*(C`output_*\*(C' methods.  Subclasses may override these to intercept the filter output.</p><p>The default implementations of the \*(C`output_*\*(C' methods pass the text on to the <em>output()</em> method.  The default implementation of the <em>output()</em> method appends the text to a string, which can be fetched with the <em>filtered_document()</em> method once processing is complete.</p><p>If the <em>output()</em> method or the individual \*(C`output_*\*(C' methods are overridden in a subclass, then <em>filtered_document()</em> will not work in that subclass.</p>
<dl class='dl-vertical'>
  <dt>
    output_start_document ()
  </dt>
  <dd>
    <p>This method gets called once at the start of each \s-1HTML\s0 document passed through the filter.  The default implementation does nothing.</p>
  </dd>
  <dt>
    output_end_document ()
  </dt>
  <dd>
    <p>This method gets called once at the end of each \s-1HTML\s0 document passed through the filter.  The default implementation does nothing.</p>
  </dd>
  <dt>
    output_start ( \s-1TEXT\s0 )
  </dt>
  <dd>
    <p>This method is used to output a filtered start tag.</p>
  </dd>
  <dt>
    output_end ( \s-1TEXT\s0 )
  </dt>
  <dd>
    <p>This method is used to output a filtered end tag.</p>
  </dd>
  <dt>
    output_text ( \s-1TEXT\s0 )
  </dt>
  <dd>
    <p>This method is used to output some filtered non-tag text.</p>
  </dd>
  <dt>
    output_declaration ( \s-1TEXT\s0 )
  </dt>
  <dd>
    <p>This method is used to output a filtered declaration.</p>
  </dd>
  <dt>
    output_comment ( \s-1TEXT\s0 )
  </dt>
  <dd>
    <p>This method is used to output a filtered \s-1HTML\s0 comment.</p>
  </dd>
  <dt>
    output_process ( \s-1TEXT\s0 )
  </dt>
  <dd>
    <p>This method is used to output a filtered processing instruction.</p>
  </dd>
  <dt>
    output ( \s-1TEXT\s0 )
  </dt>
  <dd>
    <p>This method is invoked by all of the default \*(C`output_*\*(C' methods.  The default implementation appends the text to the string that the <em>filtered_document()</em> method will return.</p>
  </dd>
  <dt>
    output_stack_entry ( \s-1TEXT\s0 )
  </dt>
  <dd>
    <p>This method is invoked when a tag plus all text and nested \s-1HTML\s0 content within the tag has been processed. It adds the tag plus its content to the content for its parent tag.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REJECT METHODS</h2>
        <div class="sectioncontent">
<p>When the filter encounters something in the input document which it cannot transform into an acceptable construct, it invokes one of the following \*(C`reject_*\*(C' methods to put something in the output document to take the place of the unacceptable construct.</p><p>The \s-1TEXT\s0 parameter is the full text of the unacceptable construct.</p><p>The default implementations of these methods output an \s-1HTML\s0 comment containing the text \*(C`filtered\*(C'. If \*(L"EscapeFiltered\*(R" is set to true, then the rejected text is \s-1HTML\s0 escaped instead.</p><p>Subclasses may override these methods, but should exercise caution. The \s-1TEXT\s0 parameter is unfiltered input and may contain malicious constructs.</p>
<dl class='dl-vertical'>
  <dt>
    reject_start ( \s-1TEXT\s0 )
  </dt>
  <dd>
    
  </dd>
  <dt>
    reject_end ( \s-1TEXT\s0 )
  </dt>
  <dd>
    
  </dd>
  <dt>
    reject_text ( \s-1TEXT\s0 )
  </dt>
  <dd>
    
  </dd>
  <dt>
    reject_declaration ( \s-1TEXT\s0 )
  </dt>
  <dd>
    
  </dd>
  <dt>
    reject_comment ( \s-1TEXT\s0 )
  </dt>
  <dd>
    
  </dd>
  <dt>
    reject_process ( \s-1TEXT\s0 )
  </dt>
  <dd>
    
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">WHITELIST INITIALIZATION METHODS</h2>
        <div class="sectioncontent">
<p>The filter refers to various whitelists to determine which constructs are acceptable.  To modify these whitelists, subclasses can override the following methods.</p><p>Each method is called once at object initialization time, and must return a reference to a nested data structure.  These references are installed into the object, and used whenever the filter needs to refer to a whitelist.</p><p>The default implementations of these methods can be invoked as class methods.</p><p>See examples/tags/ and examples/declaration/ for examples of how to override these methods.</p>
<dl class='dl-vertical'>
  <dt>
    init_context_whitelist ()
  </dt>
  <dd>
    <p>Returns a reference to the \*(C`Context\*(C' whitelist, which determines which tags may appear at each point in the document, and which other tags may be nested within them. It is a hash, and the keys are context names, such as \*(C`Flow\*(C' and \*(C`Inline\*(C'. The values in the hash are hashrefs.  The keys in these subhashes are lowercase tag names, and the values are context names, specifying the context that the tag provides to any other tags nested within it. The special context \*(C`EMPTY\*(C' as a value in a subhash indicates that nothing can be nested within that tag.</p>
  </dd>
  <dt>
    init_attrib_whitelist ()
  </dt>
  <dd>
    <p>Returns a reference to the \*(C`Attrib\*(C' whitelist, which determines which attributes each tag can have and the values that those attributes can take. It is a hash, and the keys are lowercase tag names. The values in the hash are hashrefs.  The keys in these subhashes are lowercase attribute names, and the values are attribute value class names, which are short strings describing the type of values that the attribute can take, such as \*(C`color\*(C' or \*(C`number\*(C'.</p>
  </dd>
  <dt>
    init_attval_whitelist ()
  </dt>
  <dd>
    <p>Returns a reference to the \*(C`AttVal\*(C' whitelist, which is a hash that maps attribute value class names from the \*(C`Attrib\*(C' whitelist to coderefs to subs to validate (and optionally transform) a particular attribute value. The filter calls the attribute value validation subs with the following parameters:</p><p>A reference to the filter object. The lowercase name of the tag in which the attribute appears. The name of the attribute. The attribute value found in the input document, in canonical form (see \*(L"\s-1CANONICAL\s0 \s-1FORM\s0\*(R").</p><p>The validation sub can return undef to indicate that the attribute should be removed from the tag, or it can return the new value for the attribute, in canonical form.</p>
  </dd>
  <dt>
    init_style_whitelist ()
  </dt>
  <dd>
    <p>Returns a reference to the \*(C`Style\*(C' whitelist, which determines which \s-1CSS\s0 style directives are permitted in \*(C`style\*(C' tag attributes.  The keys are value names such as \*(C`color\*(C' and \*(C`background-color\*(C', and the values are class names to be used as keys into the \*(C`AttVal\*(C' whitelist.</p>
  </dd>
  <dt>
    init_deinter_whitelist
  </dt>
  <dd>
    <p>Returns a reference to the \*(C`DeInter\*(C' whitelist, which determines which inline tags the filter should attempt to automatically de-interleave if they are encountered interleaved.  For example, the filter will transform:   &lt;b&gt;hello &lt;i&gt;world&lt;/b&gt; !&lt;/i&gt; Into:   &lt;b&gt;hello &lt;i&gt;world&lt;/i&gt;&lt;/b&gt;&lt;i&gt; !&lt;/i&gt; because both \*(C`b\*(C' and \*(C`i\*(C' appear as keys in the \*(C`DeInter\*(C' whitelist.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CHARACTER DATA PROCESSING</h2>
        <div class="sectioncontent">
<p>These methods transform attribute values and non-tag text from the input document into canonical form (see \*(L"\s-1CANONICAL\s0 \s-1FORM\s0\*(R"), and transform text in canonical form into a suitable form for the output document.</p>
<dl class='dl-vertical'>
  <dt>
    text_to_canonical_form ( \s-1TEXT\s0 )
  </dt>
  <dd>
    <p>This method is used to reduce non-tag text from the input document to canonical form before passing it to the <em>filter_text()</em> method. The default implementation unescapes all entities that map to \*(C`US-ASCII\*(C' characters other than ampersand, and replaces any ampersands that don't form part of valid entities with \*(C`&amp;\*(C'.</p>
  </dd>
  <dt>
    quoted_to_canonical_form ( \s-1VALUE\s0 )
  </dt>
  <dd>
    <p>This method is used to reduce attribute values quoted with doublequotes or singlequotes to canonical form before passing it to the handler subs in the \*(C`AttVal\*(C' whitelist. The default behavior is the same as that of \*(C`text_to_canonical_form()\*(C', plus it converts any \s-1CR\s0, \s-1LF\s0 or \s-1TAB\s0 characters to spaces.</p>
  </dd>
  <dt>
    unquoted_to_canonical_form ( \s-1VALUE\s0 )
  </dt>
  <dd>
    <p>This method is used to reduce attribute values without quotes to canonical form before passing it to the handler subs in the \*(C`AttVal\*(C' whitelist. The default implementation simply replaces all ampersands with \*(C`&amp;\*(C', since that corresponds with the way most browsers treat entities in unquoted values.</p>
  </dd>
  <dt>
    canonical_form_to_text ( \s-1TEXT\s0 )
  </dt>
  <dd>
    <p>This method is used to convert the text in canonical form returned by the <em>filter_text()</em> method to a form suitable for inclusion in the output document. The default implementation runs anything that doesn't look like a valid entity through the <em>escape_html_metachars()</em> method.</p>
  </dd>
  <dt>
    canonical_form_to_attval ( \s-1ATTVAL\s0 )
  </dt>
  <dd>
    <p>This method is used to convert the text in canonical form returned by the \*(C`AttVal\*(C' handler subs to a form suitable for inclusion in doublequotes in the output tag. The default implementation converts \s-1CR\s0, \s-1LF\s0 and \s-1TAB\s0 characters to a single space, and runs anything that doesn't look like a valid entity through the <em>escape_html_metachars()</em> method.</p>
  </dd>
  <dt>
    validate_href_attribute ( \s-1TEXT\s0 )
  </dt>
  <dd>
    <p>If the \*(C`AllowHref\*(C' filter configuration option is set, then this method is used to validate \*(C`href\*(C' type attribute values.  \s-1TEXT\s0 is the attribute value in canonical form.  Returns a possibly modified attribute value (in canonical form) or \*(C`undef\*(C' to reject the attribute. The default implementation allows only absolute \*(C`http\*(C' and \*(C`https\*(C' URLs, permits port numbers and query strings, and imposes reasonable length limits. It does not \s-1URI\s0 escape the query string, and it does not guarantee properly formatted URIs, it just tries to give safe URIs. You can always use an attribute callback (see \*(L"Attribute Callbacks\*(R") to provide stricter handling.</p>
  </dd>
  <dt>
    validate_mailto ( \s-1TEXT\s0 )
  </dt>
  <dd>
    <p>If the \*(C`AllowMailto\*(C' filter configuration option is set, then this method is used to validate \*(C`href\*(C' type attribute values which begin with \*(C`mailto:\*(C'.  \s-1TEXT\s0 is the attribute value in canonical form. Returns a possibly modified attribute value (in canonical form) or \*(C`undef\*(C' to reject the attribute. This uses a lightweight regex and does not guarantee that email addresses are properly formatted. You can always use an attribute callback (see \*(L"Attribute Callbacks\*(R") to provide stricter handling.</p>
  </dd>
  <dt>
    validate_src_attribute ( \s-1TEXT\s0 )
  </dt>
  <dd>
    <p>If the \*(C`AllowSrc\*(C' filter configuration option is set, then this method is used to validate \*(C`src\*(C' type attribute values.  \s-1TEXT\s0 is the attribute value in canonical form.  Returns a possibly modified attribute value (in canonical form) or \*(C`undef\*(C' to reject the attribute. The default implementation behaves as <em>validate_href_attribute()</em>.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OTHER METHODS TO OVERRIDE</h2>
        <div class="sectioncontent">
<p>As well as the output, reject, init and cdata methods listed above, it might make sense for subclasses to override the following methods:</p>
<dl class='dl-vertical'>
  <dt>
    filter_text ( \s-1TEXT\s0 )
  </dt>
  <dd>
    <p>This method will be invoked to filter blocks of non-tag text in the input document.  Both input and output are in canonical form, see \*(L"\s-1CANONICAL\s0 \s-1FORM\s0\*(R". The default implementation does no filtering.</p>
  </dd>
  <dt>
    escape_html_metachars ( \s-1TEXT\s0 )
  </dt>
  <dd>
    <p>This method is used to escape all \s-1HTML\s0 metacharacters in \s-1TEXT\s0. The return value must be a copy of \s-1TEXT\s0 with metacharacters escaped. The default implementation escapes a minimal set of metacharacters for security against \s-1XSS\s0 vulnerabilities.  The set of characters to escape is a compromise between the need for security and the need to ensure that the filter will work for documents in as many different character sets as possible. Subclasses which make strong assumptions about the document character set will be able to escape much more aggressively.</p>
  </dd>
  <dt>
    strip_nonprintable ( \s-1TEXT\s0 )
  </dt>
  <dd>
    <p>Returns a copy of \s-1TEXT\s0 with runs of nonprintable characters replaced with spaces or some other harmless string.  Avoids replacing anything with the empty string, as that can lead to other security issues. The default implementation strips out only \s-1NULL\s0 characters, in order to avoid scrambling text for as many different character sets as possible. Subclasses which make some sort of assumption about the character set in use will be able to have a much wider definition of a nonprintable character, and hence a more secure <em>strip_nonprintable()</em> implementation.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ATTRIBUTE VALUE HANDLER SUBS</h2>
        <div class="sectioncontent">
<p>References to the following subs appear in the \*(C`AttVal\*(C' whitelist returned by the <em>init_attval_whitelist()</em> method.</p>
<dl class='dl-vertical'>
  <dt>
    _hss_attval_style( \s-1FILTER\s0, \s-1TAGNAME\s0, \s-1ATTRNAME\s0, \s-1ATTRVAL\s0 )
  </dt>
  <dd>
    <p>Attribute value hander for the \*(C`style\*(C' attribute.</p>
  </dd>
  <dt>
    _hss_attval_size ( \s-1FILTER\s0, \s-1TAGNAME\s0, \s-1ATTRNAME\s0, \s-1ATTRVAL\s0 )
  </dt>
  <dd>
    <p>Attribute value handler for attributes who's values are some sort of size or length.</p>
  </dd>
  <dt>
    _hss_attval_number ( \s-1FILTER\s0, \s-1TAGNAME\s0, \s-1ATTRNAME\s0, \s-1ATTRVAL\s0 )
  </dt>
  <dd>
    <p>Attribute value handler for attributes who's values are a simple integer.</p>
  </dd>
  <dt>
    _hss_attval_color ( \s-1FILTER\s0, \s-1TAGNAME\s0, \s-1ATTRNAME\s0, \s-1ATTRVAL\s0 )
  </dt>
  <dd>
    <p>Attribute value handler for color attributes.</p>
  </dd>
  <dt>
    _hss_attval_text ( \s-1FILTER\s0, \s-1TAGNAME\s0, \s-1ATTRNAME\s0, \s-1ATTRVAL\s0 )
  </dt>
  <dd>
    <p>Attribute value handler for text attributes.</p>
  </dd>
  <dt>
    _hss_attval_word ( \s-1FILTER\s0, \s-1TAGNAME\s0, \s-1ATTRNAME\s0, \s-1ATTRVAL\s0 )
  </dt>
  <dd>
    <p>Attribute value handler for attributes who's values must consist of a single short word, with minus characters permitted.</p>
  </dd>
  <dt>
    _hss_attval_wordlist ( \s-1FILTER\s0, \s-1TAGNAME\s0, \s-1ATTRNAME\s0, \s-1ATTRVAL\s0 )
  </dt>
  <dd>
    <p>Attribute value handler for attributes who's values must consist of one or more words, separated by spaces and/or commas.</p>
  </dd>
  <dt>
    _hss_attval_wordlistq ( \s-1FILTER\s0, \s-1TAGNAME\s0, \s-1ATTRNAME\s0, \s-1ATTRVAL\s0 )
  </dt>
  <dd>
    <p>Attribute value handler for attributes who's values must consist of one or more words, separated by commas, with optional doublequotes around words and spaces allowed within the doublequotes.</p>
  </dd>
  <dt>
    _hss_attval_href ( \s-1FILTER\s0, \s-1TAGNAME\s0, \s-1ATTRNAME\s0, \s-1ATTRVAL\s0 )
  </dt>
  <dd>
    <p>Attribute value handler for \*(C`href\*(C' type attributes.  If the \*(C`AllowHref\*(C' or \*(C`AllowMailto\*(C' configuration options are set, uses the <em>validate_href_attribute()</em> method to check the attribute value.</p>
  </dd>
  <dt>
    _hss_attval_src ( \s-1FILTER\s0, \s-1TAGNAME\s0, \s-1ATTRNAME\s0, \s-1ATTRVAL\s0 )
  </dt>
  <dd>
    <p>Attribute value handler for \*(C`src\*(C' type attributes.  If the \*(C`AllowSrc\*(C' configuration option is set, uses the <em>validate_src_attribute()</em> method to check the attribute value.</p>
  </dd>
  <dt>
    _hss_attval_stylesrc ( \s-1FILTER\s0, \s-1TAGNAME\s0, \s-1ATTRNAME\s0, \s-1ATTRVAL\s0 )
  </dt>
  <dd>
    <p>Attribute value handler for \*(C`src\*(C' type style pseudo attributes.</p>
  </dd>
  <dt>
    _hss_attval_novalue ( \s-1FILTER\s0, \s-1TAGNAME\s0, \s-1ATTRNAME\s0, \s-1ATTRVAL\s0 )
  </dt>
  <dd>
    <p>Attribute value handler for attributes that have no value or a value that is ignored.  Just returns the attribute name as the value.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CANONICAL FORM</h2>
        <div class="sectioncontent">
<p>Many of the methods described above deal with text from the input document, encoded in what I call \*(C`canonical form\*(C', defined as follows:</p><p>All characters other than ampersands represent themselves.  Literal ampersands are encoded as \*(C`&amp;\*(C'.  Non \*(C`US-ASCII\*(C' characters may appear as literals in whatever character set is in use, or they may appear as named or numeric \s-1HTML\s0 entities such as \*(C`&aelig;\*(C', \*(C`&#31337;\*(C' and \*(C`&#xFF;\*(C'.  Unknown named entities such as \*(C`&foo;\*(C' may appear.</p><p>The idea is to be able to be able to reduce input text to a minimal form, without making too many assumptions about the character set in use.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PRIVATE METHODS</h2>
        <div class="sectioncontent">
<p>The following methods are internal to this class, and should not be invoked from elsewhere.  Subclasses should not use or override these methods.</p>
<dl class='dl-vertical'>
  <dt>
    _hss_prepare_ban_list (\s-1CFG\s0)
  </dt>
  <dd>
    <p>Returns a hash ref representing all the banned tags, based on the values of BanList and BanAllBut</p>
  </dd>
  <dt>
    _hss_prepare_rules (\s-1CFG\s0)
  </dt>
  <dd>
    <p>Returns a hash ref representing the tag and attribute rules (See \*(L"Rules\*(R"). Returns undef if no filters are specified, in which case the attribute filter code has very little performance impact. If any rules are specified, then every tag and attribute is checked.</p>
  </dd>
  <dt>
    _hss_get_attr_filter ( \s-1DEFAULT_FILTERS\s0 \s-1TAG_FILTERS\s0 \s-1ATTR_NAME\s0)
  </dt>
  <dd>
    <p>Returns the attribute filter rule to apply to this particular attribute. Checks for:   - a named attribute rule in a named tag   - a default * attribute rule in a named tag   - a named attribute rule in the default * rules   - a default * attribute rule in the default * rules</p>
  </dd>
  <dt>
    _hss_join_attribs (\s-1FILTERED_ATTRIBS\s0)
  </dt>
  <dd>
    <p>Accepts a hash ref containing the attribute names as the keys, and the attribute values as the values.  Escapes them and returns a string ready for output to \s-1HTML\s0</p>
  </dd>
  <dt>
    _hss_decode_numeric ( \s-1NUMERIC\s0 )
  </dt>
  <dd>
    <p>Returns the string that should replace the numeric entity \s-1NUMERIC\s0 in the <em>text_to_canonical_form()</em> method.</p>
  </dd>
  <dt>
    _hss_tag_is_banned ( \s-1TAGNAME\s0 )
  </dt>
  <dd>
    <p>Returns true if the lower case tag name \s-1TAGNAME\s0 is on the list of harmless tags that the filter is configured to block, false otherwise.</p>
  </dd>
  <dt>
    _hss_get_to_valid_context ( \s-1TAG\s0 )
  </dt>
  <dd>
    <p>Tries to get the filter to a context in which the tag \s-1TAG\s0 is allowed, by introducing extra end tags or start tags if necessary.  \s-1TAG\s0 can be either the lower case name of a tag or the string '\s-1CDATA\s0'. Returns 1 if an allowed context is reached, or 0 if there's no reasonable way to get to an allowed context and the tag should just be rejected.</p>
  </dd>
  <dt>
    _hss_close_innermost_tag ()
  </dt>
  <dd>
    <p>Closes the innermost open tag.</p>
  </dd>
  <dt>
    _hss_context ()
  </dt>
  <dd>
    <p>Returns the current named context of the filter.</p>
  </dd>
  <dt>
    _hss_valid_in_context ( \s-1TAG\s0, \s-1CONTEXT\s0 )
  </dt>
  <dd>
    <p>Returns true if the lowercase tag name \s-1TAG\s0 is valid in context \s-1CONTEXT\s0, false otherwise.</p>
  </dd>
  <dt>
    _hss_valid_in_current_context ( \s-1TAG\s0 )
  </dt>
  <dd>
    <p>Returns true if the lowercase tag name \s-1TAG\s0 is valid in the filter's current context, false otherwise.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS AND LIMITATIONS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    Performance
  </dt>
  <dd>
    <p>This module does a lot of work to ensure that tags are correctly nested and are not left open, causing unnecessary overhead for applications where that doesn't matter. Such applications may benefit from using the more lightweight HTML::Scrubber::StripScripts module instead.</p>
  </dd>
  <dt>
    Strictness
  </dt>
  <dd>
    <p>URIs and email addresses are cleaned up to be safe, but not necessarily accurate.  That would have required adding dependencies. Attribute callbacks can be used to add this functionality if required, or the validation methods can be overriden. By default, filtered \s-1HTML\s0 may not be valid strict \s-1XHTML\s0, for instance empty required attributes may be outputted.  However, with \*(L"Rules\*(R", it should be possible to force the \s-1HTML\s0 to validate.</p>
  </dd>
  <dt>
    \s-1REPORTING\s0 \s-1BUGS\s0
  </dt>
  <dd>
    <p>Please report any bugs or feature requests to bug-html-stripscripts@rt.cpan.org, or through the web interface at &lt;http://rt.cpan.org&gt;.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO HTML::StripScripts&hellip;</h2>
        <div class="sectioncontent">
<p>HTML::Parser, HTML::StripScripts::Parser, HTML::StripScripts::Regex</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Original author Nick Cleaton &lt;nick@cleaton.net&gt;</p><p>New code added and module maintained by Clinton Gormley &lt;clint@traveljury.com&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright (C) 2003 Nick Cleaton.  All Rights Reserved.</p><p>Copyright (C) 2007 Clinton Gormley.  All Rights Reserved.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LICENSE</h2>
        <div class="sectioncontent">
<p>This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="HTML::Stream.3pm.html"><span aria-hidden="true">&larr;</span> HTML::Stream.3pm: Html output stream class, and some markup utilities</a></li>
   <li class="next"><a href="HTML::StripScripts::Parser.3pm.html">HTML::StripScripts::Parser.3pm: Xss filter using html::parser <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

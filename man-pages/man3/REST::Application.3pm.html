<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>REST::Application: A framework for building restful web-applications.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="A framework for building restful web-applications.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="REST::Application (3pm) manual">
  <meta name="twitter:description" content="A framework for building restful web-applications.">
  <meta name="twitter:image" content="https://www.carta.tech/images/librest-application-perl-REST::Application-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/REST::Application.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="REST::Application (3pm) manual" />
  <meta property="og:description" content="A framework for building restful web-applications." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/librest-application-perl-REST::Application-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">REST::Application<small> (3pm)</small></h1>
        <p class="lead">A framework for building restful web-applications.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/REST::Application.3pm.html">
      <span itemprop="name">REST::Application: A framework for building restful web-applications.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/librest-application-perl/">
      <span itemprop="name">librest-application-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/REST::Application.3pm.html">
      <span itemprop="name">REST::Application: A framework for building restful web-applications.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
    # MyRESTApp REST::Application instance / mod_perl handler
    package MyRESTApp;
    use Apache;
    use Apache::Constants qw(:common);

    sub handler {
        _\|_PACKAGE_\|_-&gt;new(request =&gt; $r)-&gt;run();
        return OK;
    }

    sub getMatchText { return Apache-&gt;uri }

    sub setup {
        my $self = shift;
        $self-&gt;resourceHooks(
            qr{/rest/parts/(&#92;d+)} =&gt; &apos;get_part&apos;,
            # ... other handlers here ...
        );
    }

    sub get_part {
        my ($self, $part_num) = @_;
        # Business logic to retrieve part num
    }

    # Apache conf
    &lt;Location /rest&gt;
        perl-script .cgi
        PerlHandler MyRESTApp
    &lt;/Location&gt;
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module acts as a base class for applications which implement a RESTful interface.   When an \s-1HTTP\s0 request is received some dispatching logic in REST::Application is invoked, calling different handlers based on what the kind of \s-1HTTP\s0 request it was (i.e. \s-1GET\s0, \s-1PUT\s0, etc) and what resource it was trying to access.  This module won't ensure that your \s-1API\s0 is RESTful but hopefully it will aid in developing a \s-1REST\s0 \s-1API\s0.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OVERVIEW</h2>
        <div class="sectioncontent">
<p>The following list describes the basic way this module is intended to be used. It does not capture everything the module can do.</p>
<dl class='dl-vertical'>
  <dt>
    1. Subclass
  </dt>
  <dd>
    <p>Subclass REST::Application, i.e. \*(C`use base &apos;REST::Application&apos;\*(C'. Overload the \*(C`setup()\*(C' method and set up some resource hooks with the \*(C`resourceHooks()\*(C' method.  Hooks are mappings of the form:             REGEX =&gt; handler where handler is either a method name, a code reference, an object which supports a method with the same name as the \s-1HTTP\s0 method (or \*(C`getResource\*(C' if no such method), or a reference to an array of the form: \*(C`[$objectRef, "methodName"]\*(C' ($objectRef can be a class name instead). The regular expressions are applied, by default, to the path info of the \s-1HTTP\s0 request.  Anything captured by parens in the regex will be passed into the handler as arguments. For example:     qr{/parts/(&#92;d+)$} =&gt; "getPartByNumber", The above hook will call a method named \*(C`getPartByNumber\*(C' on the current object (i.e. $self, an instance of REST::Application) if the path info of the requested \s-1URI\s0 matches the above regular expression.  The first argument to the method will be the part number, since that's the first element captured in the regular expression.</p>
  </dd>
  <dt>
    3. Write code.
  </dt>
  <dd>
    <p>Write the code for the handler specified above.  So here we'd define the \*(C`getPartByNumber\*(C' method.</p>
  </dd>
  <dt>
    4. Create a handler/loader.
  </dt>
  <dd>
    <p>Create an Apache handler, for example:     use MyRESTApp;     sub handler {         my $r = shift;         my $app = MyRESTApp-&gt;new(request =&gt; $r);         $app-&gt;run();     } or a small \s-1CGI\s0 script with the following code:     #!/usr/bin/perl     use MyRESTApp;     MyRESTApp-&gt;new()-&gt;run(); In the second case, for a \s-1CGI\s0 script, you'll probably need to do something special to get Apache to load up your script unless you give it a .cgi extension.  It would be unRESTful to allow your script to have a .cgi extension, so you should go the extra mile and configure Apache to run your script without it.  For example, it'd be bad to have your users go to:     http://www.foo.tld/parts.cgi/12345.html When the \*(C`run()\*(C' method is called the path info is extracted from the \s-1HTTP\s0 request.  The regexes specified in step 2 are processed, in order, and if one matches then the handler is called.  If the regex had paren. matching then the matched elements are passed into the handler.  A handler is also passed a copy of the REST::Application object instance (except for the case when the handler is a method on the REST::Application object, in that case it'd be redundant).  So, when writing a subroutine handler you'd do:             sub rest_handler {                 my ($rest, @capturedArgs) = @_;                 ...             }</p>
  </dd>
  <dt>
    6. Return a representation of the resource.
  </dt>
  <dd>
    <p>The handler is processed and should return a string or a scalar reference to a string.  Optionally the handler should set any header information via the \*(C`header()\*(C' method on instance object pased in.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CALLING ORDER</h2>
        <div class="sectioncontent">
<p>The REST::Application base class provides a good number of methods, each of which can be overloaded.  By default you only need to overload the \*(C`setup()\*(C' method but you may wish to overload others.  To help with this the following outline is the calling order of the various methods in the base class.  You can find detailed descriptions of each method in the \s-1METHODS\s0 section of this document.</p><p>If a method is followed by the string \s-1NOOP\s0 then that means it does nothing by default and it exists only to be overloaded.</p><p>    new()         setup() - NOOP     run()         preRun() - NOOP         loadResource()             getMatchText()                 getPathInfo()                     query()                         defaultQueryObject()             defaultResourceHandler() - NOOP             resourceHooks()             checkMatch()                 _setLastRegexMatches()             _getHandlerFromHook()                 resourceHooks()                 defaultResourceHandler() - NOOP                 getRequestMethod()                     query()                         defaultQueryObject()                 bestContentType()                     simpleContentNegotiation                         getContentPrefs                             getAcceptHeader                         scoreType()             callHandler()                 getHandlerArgs                     _getLastRegexMatches()                     extraHandlerArgs()                 preHandler() - NOOP                 ... your handler called here ...                 postHandler() - NOOP         postRun() - NOOP         getHeaders()             headerType()             query()                 defaultQueryObject()             header()         addRepresentation()</p><p>The only methods not called as part of the <em>new()</em> or <em>run()</em> methods are the helper methods \*(C`resetHeader()\*(C' and \*(C`setRedirect()\*(C', both of which call the \*(C`header()\*(C' and \*(C`headerType()\*(C' methods.</p><p>For example, if you wanted to have your code branch on the entire \s-1URI\s0 of the \s-1HTTP\s0 request rather than just the path info you'd merely overload \*(C`getMatchText()\*(C' to return the \s-1URI\s0 rather than the path info.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">
<p><strong>&#92;$1</strong></p><p>This method creates a new REST::Application object and returns it.  The arguments passed in via %args, if any, are passed untouched to the \*(C`setup()\*(C' method. This accessor/mutator retrieves the current \s-1CGI\s0 query object or sets it if one is passed in. This method retrieves/sets the default query object.  This method is called if \*(C`query()\*(C' is called for the first time and no query object has been set yet. This method is used to set the resource hooks.  A REST::Application hook is a regex to handler mapping.  The hooks are passed in as a hash (or a reference to one) and the keys are treated as regular expressions while the values are treated as handlers should <strong>\s-1PATH_INFO\s0</strong> match the regex that maps to that handler.</p><p>Handlers can be code references, methods on the current object, methods on other objects, or class methods.  Also, handlers can be differ based on what the <strong>\s-1REQUEST_METHOD\s0</strong> was (e.g. \s-1GET\s0, \s-1PUT\s0, \s-1POST\s0, \s-1DELETE\s0, etc).</p><p>The handler's types are as follows:</p>
<dl class='dl-vertical'>
  <dt>
    string
  </dt>
  <dd>
    <p>The handler is considered to be a method on the current REST::Application instance.</p>
  </dd>
  <dt>
    code ref
  </dt>
  <dd>
    <p>The code ref is considered to be the handler.</p>
  </dd>
  <dt>
    object ref
  </dt>
  <dd>
    <p>The object is considered to have a method the same name as the \s-1HTTP\s0 method. That is, if the object is being called because of \s-1GET\s0 then \*(C`GET()\*(C' is called, if it is called because of a \*(C`DELETE\*(C' then \*(C`DELETE()\*(C' is called. \*(C`getResource()\*(C' method will be used if \*(C`getRequestMethod()\*(C' returns false.</p>
  </dd>
  <dt>
    array ref
  </dt>
  <dd>
    <p>The array is expected to be two elements long, the first element is a class name or object instance.  The 2nd element is a method name on that class/instance.  \s-1IF\s0 the 2nd element is ommitted then the method name is assumed to be the same as the <strong>\s-1REQUEST_METHOD\s0</strong>, e.g. \*(C`GET()\*(C', \*(C`PUT()\*(C', whatever.</p>
  </dd>
  <dt>
    hash ref
  </dt>
  <dd>
    <p>The current <strong>\s-1REQUEST_METHOD\s0</strong> is used as a key to the hash, the value should be one the four above handler types.  In this way you can specify different handlers for each of the request types.  The request method can also be specified as '*', in which case that is used if a more specific match is not found. It is possible for the value of the handler to be another hash ref, rather than one of the four above types.  In this case it is assumed content-negotion is wanted.  The keys of this second hash are \s-1MIME\s0 types and the values are one of the four above types.  For example:     $self-&gt;resourceHooks(         qr{/parts/(&#92;d+)} =&gt; {             GET =&gt; {                 &apos;text/json&apos; =&gt; &apos;get_json&apos;,                 &apos;text/xml&apos;, =&gt; &apos;get_xml&apos;,                 &apos;text/xml&apos; =&gt; &apos;get_html&apos;,                 &apos;*/*&apos; =&gt; &apos;get_html&apos;,             },             &apos;*&apos; =&gt; sub { die "Bad Method!" },         }     );</p>
  </dd>

</dl>
<p>The return value of the handler is expected to be a string, which REST::Application will then send to the browser with the \*(C`sendRepresentation()\*(C' method.</p><p>If no argument is supplied to \*(C`resourceHooks()\*(C' then the current set of hooks is returned.  The returned hash referces is a tied IxHash, so the keys are kept sorted. This method will take the value of <strong>\s-1PATH_INFO\s0</strong>, iterate through the path regex's set in \*(C`resourceHooks()\*(C' and if it finds a match call the associated handler and return the handler's value, which should be a scalar.  If $path is passed in then that is used instead of <strong>\s-1PATH_INFO\s0</strong>. This method calls \*(C`loadResource()\*(C' with no arguments and then takes that output and sends it to the remote client.  Headers are sent with \*(C`sendHeaders()\*(C' and the representation is sent with \*(C`sendRepresentation()\*(C'.</p><p>If the environment variable <strong>\s-1REST_APP_RETURN_ONLY\s0</strong> is set then output isn't sent to the client.  The return value of this method is the text output it sends (or would've sent). This method returns the headers as a string. This method just returns $representation.  It is provided solely for overloading purposes. This accessor/mutator controls the type of header to be returned.  This method returns one of \*(L"header, redirect, or none.\*(R"  If $type is passed in then that is used to set the header type. This accessor/mutator controls the header values sent.  If called without arguments then it simply returns the current header values as a hash, where the keys are the header fields and the values are the header field values.</p><p>If this method is called multiple times then the values of %args are additive. So calling \*(C`$self-&gt;header(-type =&gt; &apos;text/html&apos;)\*(C' and \*(C`$self-&gt;header(-foo =&gt; &apos;bar&apos;)\*(C' results in both the content-type header being set and the \*(L"foo\*(R" header being set. This header causes the current header values to be reset.  The previous values are returned. This method is called by \*(C`loadResource()\*(C' if no regex in \*(C`resourceHooks()\*(C' matches the current <strong>\s-1PATH_INFO\s0</strong>.  It returns undef by default, it exists for overloading. Given a list of \s-1MIME\s0 types this function returns the best matching type considering the Accept header of the current request (as returned by \*(C`getAcceptHeader()\*(C'). Given a list of \s-1MIME\s0 types this function returns the same list sorted from best match to least considering the Accept header as returned by \*(C`getAcceptHeader()\*(C'. Returns the list of \s-1MIME\s0 types in the Accept header form most preferred to least preferred.  Quality weights are taken into account. Returns the value of the Accept header as a single string. Returns an integer, only good for sorting, for where $type fits among the @accept_types.  This method takes wildcards into account.  So \*(C`text/plain\*(C' matches \*(C`text/*\*(C'.  The integer returned is the position in @accept_types of the matching \s-1MIME\s0 type.  It assumped @accept_types is already sorted from best to worst. Returns the last path passed to \*(C`checkMatch()\*(C' which successfully matched against.  Unless you're overloading things in funny ways the value returned will be the path that caused the current handler to be invoked. Similar to \*(C`getLastMatchPath()\*(C' except this is the pattern that was applied to the path. This method tries to be smart and allow tunneling of the other \s-1HTTP\s0 methods over \s-1GET\s0 or \s-1PUT\s0.  You can tunnel three ways with the higher up taking precedence:</p><p>1) Pass an X-HTTP-Method header 2) Pass the 'http_method' query parameter 3) Pass a parameter via \s-1POST\s0</p><p>Only \s-1POST\s0 and \s-1GET\s0, being the most common, can be used to tunnel.  In an attempt to prevent people from being bad, \s-1GET\s0 can only be used to tunnel \s-1GET\s0 or \s-1HEAD\s0. \s-1POST\s0 can be used to tunnel anything.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p>Matthew O'Connor &lt;matthew@canonical.org&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LICENSE</h2>
        <div class="sectioncontent">
<p>This program is free software. It is subject to the same license as Perl itself.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO REST::Application&hellip;</h2>
        <div class="sectioncontent">
<p>\s-1CGI\s0, CGI::Application, Tie::IxHash, CGI::Application::Dispatch</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="README.3pm.html"><span aria-hidden="true">&larr;</span> README.3pm: None</a></li>
   <li class="next"><a href="REST::Application::Routes.3pm.html">REST::Application::Routes.3pm: An implementation of ruby on rails type routes. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

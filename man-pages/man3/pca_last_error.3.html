<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>pca_last_error: Lookup a file in a list of directories</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Lookup a file in a list of directories">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="pca_last_error (3) manual">
  <meta name="twitter:description" content="Lookup a file in a list of directories">
  <meta name="twitter:image" content="https://www.carta.tech/images/libtecla-dev-pca_last_error-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/pca_last_error.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="pca_last_error (3) manual" />
  <meta property="og:description" content="Lookup a file in a list of directories" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libtecla-dev-pca_last_error-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">pca_last_error<small> (3)</small></h1>
        <p class="lead">Lookup a file in a list of directories</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/pca_last_error.3.html">
      <span itemprop="name">pca_last_error: Lookup a file in a list of directories</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libtecla-dev/">
      <span itemprop="name">libtecla-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/pca_last_error.3.html">
      <span itemprop="name">pca_last_error: Lookup a file in a list of directories</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
#include &lt;libtecla.h&gt;

PathCache *new_PathCache(void);

PathCache *del_PathCache(PathCache *pc);

int pca_scan_path(PathCache *pc, const char *path);

void pca_set_check_fn(PathCache *pc, CplCheckFn *check_fn,
                      void *data);

char *pca_lookup_file(PathCache *pc, const char *name,
                      int name_len, int literal);

const char *pca_last_error(PathCache *pc);

CPL_MATCH_FN(pca_path_completions);

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The <strong>PathCache</strong> object is part of the tecla library (see the <a href="../man3/libtecla.3.html"><strong>libtecla</strong>(3)</a> man page).</p><p><strong>PathCache</strong> objects allow an application to search for files in any colon separated list of directories, such as the unix execution PATH environment variable. Files in absolute directories are cached in a <strong>PathCache</strong> object, whereas relative directories are scanned as needed. Using a <strong>PathCache</strong> object, you can look up the full pathname of a simple filename, or you can obtain a list of the possible completions of a given filename prefix. By default all files in the list of directories are targets for lookup and completion, but a versatile mechanism is provided for only selecting specific types of files. The obvious application of this facility is to provide Tab-completion and lookup of executable commands in the unix PATH, so an optional callback which rejects all but executable files, is provided.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AN EXAMPLE</h2>
        <div class="sectioncontent">
<p>Under UNIX, the following example program looks up and displays the full pathnames of each of the command names on the command line.</p>
<pre>
  #include &lt;stdio.h&gt;
  #include &lt;stdlib.h&gt;
  #include &lt;libtecla.h&gt;

  int main(int argc, char *argv[])
  {
    int i;
  /*
   * Create a cache for executable files.
   */
    PathCache *pc = new_PathCache();
    if(!pc)
      <strong>exit</strong>(1);
  /*
   * Scan the user's PATH for executables.
   */
    if(pca_scan_path(pc, getenv("PATH"))) {
      fprintf(stderr, "%s&#92;n", pca_last_error(pc));
      <strong>exit</strong>(1);
    }
  /*
   * Arrange to only report executable files.
   */
   pca_set_check_fn(pc, cpl_check_exe, NULL);
  /*
   * Lookup and display the full pathname of each of the
   * commands listed on the command line.
   */
    for(i=1; i&lt;argc; i++) {
      char *cmd = pca_lookup_file(pc, argv[i], -1, 0);
      printf("The full pathname of '%s' is %s&#92;n", argv[i],
             cmd ? cmd : "unknown");
    }
    pc = del_PathCache(pc);  /* Clean up */
    return 0;
  }
</pre>
<p>The following is an example of what this does on my laptop under linux:</p>
<pre>
  $ ./example less more blob
  The full pathname of 'less' is /usr/bin/less
  The full pathname of 'more' is /bin/more
  The full pathname of 'blob' is unknown
  $
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FUNCTION DESCRIPTIONS</h2>
        <div class="sectioncontent">
<p>In order to use the facilities of this module, you must first allocate a <strong>PathCache</strong> object by calling the <strong>new_PathCache()</strong> constructor function.</p>
<pre>
  PathCache *new_PathCache(void)
</pre>
<p>This function creates the resources needed to cache and lookup files in a list of directories. It returns <strong>NULL</strong> on error.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">POPULATING THE CACHE</h2>
        <div class="sectioncontent">
<p>Once you have created a cache, it needs to be populated with files. To do this, call the <strong>pca_scan_path()</strong> function.</p>
<pre>
  int pca_scan_path(PathCache *pc, const char *path);
</pre>
<p>Whenever this function is called, it discards the current contents of the cache, then scans the list of directories specified in its <strong>path</strong> argument for files. The <strong>path</strong> argument must be a string containing a colon-separated list of directories, such as <strong>"/usr/bin:/home/mcs/bin:."</strong>. This can include directories specified by absolute pathnames such as <strong>"/usr/bin"</strong>, as well as sub-directories specified by relative pathnames such as <strong>"."</strong> or <strong>"bin"</strong>. Files in the absolute directories are immediately cached in the specified <strong>PathCache</strong> object, whereas sub-directories, whose identities obviously change whenever the current working directory is changed, are marked to be scanned on the fly whenever a file is looked up.</p><p>On success this function return <strong>0</strong>. On error it returns <strong>1</strong>, and a description of the error can be obtained by calling <strong>pca_last_error(pc)</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LOOKING UP FILES</h2>
        <div class="sectioncontent">
<p>Once the cache has been populated with files, you can look up the full pathname of a file, simply by specifying its filename to <strong>pca_lookup_file()</strong>.</p>
<pre>
  char *pca_lookup_file(PathCache *pc, const char *name,
                        int name_len, int literal);
</pre>
<p>To make it possible to pass this function a filename which is actually part of a longer string, the <strong>name_len</strong> argument can be used to specify the length of the filename at the start of the <strong>name[]</strong> argument. If you pass <strong>-1</strong> for this length, the length of the string will be determined with <strong>strlen()</strong>. If the <strong>name[]</strong> string might contain backslashes that escape the special meanings of spaces and tabs within the filename, give the <strong>literal</strong> argument, the value <strong>0</strong>. Otherwise, if backslashes should be treated as normal characters, pass <strong>1</strong> for the value of the <strong>literal</strong> argument.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILENAME COMPLETION</h2>
        <div class="sectioncontent">
<p>Looking up the potential completions of a filename-prefix in the filename cache, is achieved by passing the provided <strong>pca_path_completions()</strong> callback function to the <strong>cpl_complete_word()</strong> function (see the <a href="../man3/cpl_complete_word.3.html"><strong>cpl_complete_word</strong>(3)</a></strong> man page).</p>
<pre>
  CPL_MATCH_FN(pca_path_completions);
</pre>
<p>This callback requires that its <strong>data</strong> argument be a pointer to a <strong>PcaPathConf</strong> object. Configuration objects of this type are allocated by calling <strong>new_PcaPathConf()</strong>.</p>
<pre>
  PcaPathConf *new_PcaPathConf(PathCache *pc);
</pre>
<p>This function returns an object initialized with default configuration parameters, which determine how the <strong>cpl_path_completions()</strong> callback function behaves. The functions which allow you to individually change these parameters are discussed below.</p><p>By default, the <strong>pca_path_completions()</strong> callback function searches backwards for the start of the filename being completed, looking for the first un-escaped space or the start of the input line. If you wish to specify a different location, call <strong>ppc_file_start()</strong> with the index at which the filename starts in the input line. Passing <strong>start_index=-1</strong> re-enables the default behavior.</p>
<pre>
  void ppc_file_start(PcaPathConf *ppc, int start_index);
</pre>
<p>By default, when <strong>pca_path_completions()</strong> looks at a filename in the input line, each lone backslash in the input line is interpreted as being a special character which removes any special significance of the character which follows it, such as a space which should be taken as part of the filename rather than delimiting the start of the filename. These backslashes are thus ignored while looking for completions, and subsequently added before spaces, tabs and literal backslashes in the list of completions. To have unescaped backslashes treated as normal characters, call <strong>ppc_literal_escapes()</strong> with a non-zero value in its <strong>literal</strong> argument.</p>
<pre>
  void ppc_literal_escapes(PcaPathConf *ppc, int literal);
</pre>
<p>When you have finished with a <strong>PcaPathConf</strong> variable, you can pass it to the <strong>del_PcaPathConf()</strong> destructor function to reclaim its memory.</p>
<pre>
  PcaPathConf *del_PcaPathConf(PcaPathConf *ppc);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BEING SELECTIVE</h2>
        <div class="sectioncontent">
<p>If you are only interested in certain types or files, such as, for example, executable files, or files whose names end in a particular suffix, you can arrange for the file completion and lookup functions to be selective in the filenames that they return.  This is done by registering a callback function with your <strong>PathCache</strong> object. Thereafter, whenever a filename is found which either matches a filename being looked up, or matches a prefix which is being completed, your callback function will be called with the full pathname of the file, plus any application-specific data that you provide, and if the callback returns <strong>1</strong> the filename will be reported as a match, and if it returns <strong>0</strong>, it will be ignored. Suitable callback functions and their prototypes should be declared with the following macro. The <strong>CplCheckFn</strong> <strong>typedef</strong> is also provided in case you wish to declare pointers to such functions.</p>
<pre>
  #define CPL_CHECK_FN(fn) int (fn)(void *data, &#92;
                                    const char *pathname)
  typedef CPL_CHECK_FN(CplCheckFn);
</pre>
<p>Registering one of these functions involves calling the <strong>pca_set_check_fn()</strong> function. In addition to the callback function, passed via the <strong>check_fn</strong> argument, you can pass a pointer to anything via the <strong>data</strong> argument. This pointer will be passed on to your callback function, via its own <strong>data</strong> argument, whenever it is called, so this provides a way to pass appplication specific data to your callback.</p>
<pre>
  void pca_set_check_fn(PathCache *pc, CplCheckFn *check_fn,
                        void *data);
</pre>
<p>Note that these callbacks are passed the full pathname of each matching file, so the decision about whether a file is of interest can be based on any property of the file, not just its filename. As an example, the provided <strong>cpl_check_exe()</strong> callback function looks at the executable permissions of the file and the permissions of its parent directories, and only returns <strong>1</strong> if the user has execute permission to the file. This callback function can thus be used to lookup or complete command names found in the directories listed in the user's <strong>PATH</strong> environment variable. The example program given earlier in this man page provides a demonstration of this.</p><p>Beware that if somebody tries to complete an empty string, your callback will get called once for every file in the cache, which could number in the thousands. If your callback does anything time consuming, this could result in an unacceptable delay for the user, so callbacks should be kept short.</p><p>To improve performance, whenever one of these callbacks is called, the choice that it makes is cached, and the next time the corresponding file is looked up, instead of calling the callback again, the cached record of whether it was accepted or rejected is used. Thus if somebody tries to complete an empty string, and hits tab a second time when nothing appears to happen, there will only be one long delay, since the second pass will operate entirely from the cached dispositions of the files. These cached dipositions are discarded whenever <strong>pca_scan_path()</strong> is called, and whenever <strong>pca_set_check_fn()</strong> is called with changed callback function or data arguments.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ERROR HANDLING</h2>
        <div class="sectioncontent">
<p>If <strong>pca_scan_path()</strong> reports that an error occurred by returning <strong>1</strong>, you can obtain a terse description of the error by calling <strong>pca_last_error(pc)</strong>. This returns an internal string containing an error message.</p>
<pre>
  const char *pca_last_error(PathCache *pc);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CLEANING UP</h2>
        <div class="sectioncontent">
<p>Once you have finished using a <strong>PathCache</strong> object, you can reclaim its resources by passing it to the <strong>del_PathCache()</strong> destructor function. This takes a pointer to one of these objects, and always returns <strong>NULL</strong>.</p>
<pre>
  PathCache *del_PathCache(PathCache *pc);
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">THREAD SAFETY</h2>
        <div class="sectioncontent">
<p>In multi-threaded programs, you should use the <strong>libtecla_r.a</strong> version of the library. This uses POSIX reentrant functions where available (hence the <strong>_r</strong> suffix), and disables features that rely on non-reentrant system functions. In the case of this module, the only disabled feature is username completion in <strong>~username/</strong> expressions, in <strong>cpl_path_completions()</strong>.</p><p>Using the <strong>libtecla_r.a</strong> version of the library, it is safe to use the facilities of this module in multiple threads, provided that each thread uses a separately allocated <strong>PathCache</strong> object. In other words, if two threads want to do path searching, they should each call <strong>new_PathCache()</strong> to allocate their own caches.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FILES</h2>
        <div class="sectioncontent">

<pre>
libtecla.a    -    The tecla library
libtecla.h    -    The tecla header file.
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO pca_last_error&hellip;</h2>
        <div class="sectioncontent">

<pre>
<a href="../man3/libtecla.3.html"><strong>libtecla</strong>(3)</a>, <a href="../man3/gl_get_line.3.html"><strong>gl_get_line</strong>(3)</a>, <a href="../man3/ef_expand_file.3.html"><strong>ef_expand_file</strong>(3)</a>,
<a href="../man3/cpl_complete_word.3.html"><strong>cpl_complete_word</strong>(3)</a>
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Martin Shepherd  (mcs@astro.caltech.edu)</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="pca.hpp.3.html"><span aria-hidden="true">&larr;</span> pca.hpp.3: Src/mlpack/methods/pca/pca.hpp -</a></li>
   <li class="next"><a href="pca_lookup_file.3.html">pca_lookup_file.3: Lookup a file in a list of directories <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>afnix-nwg: Standard network working group module</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Standard network working group module">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="afnix-nwg (3) manual">
  <meta name="twitter:description" content="Standard network working group module">
  <meta name="twitter:image" content="https://www.carta.tech/images/afnix-afnix-nwg-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/afnix-nwg.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="afnix-nwg (3) manual" />
  <meta property="og:description" content="Standard network working group module" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/afnix-afnix-nwg-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">afnix-nwg<small> (3)</small></h1>
        <p class="lead">Standard network working group module</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/afnix-nwg.3.html">
      <span itemprop="name">afnix-nwg: Standard network working group module</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/afnix/">
      <span itemprop="name">afnix</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/afnix-nwg.3.html">
      <span itemprop="name">afnix-nwg: Standard network working group module</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">STANDARD NETWORK WORKING GROUP MODULE</h2>
        <div class="sectioncontent">
<p>The Standard Network Working Group module is an original implemtation of the recommendations proposed by the NWG and currently found in the form of Request for Comments (RFC). Most of the objects are used with networking application, with the most common one beeing the Universal Resource Identifier (URI) object.</p><p><strong>The uri class</strong></p><p>The Uri class is a base class that parses a Uniform Resource Identifier or uri string and provides methods to access individual component of that uri. The implementation conforms to RFC 3986. The URI components are the scheme, the authority, the path, the query and the fragment. The class also takes care of the character escaping.</p>
<pre>
const uri (afnix:www:Uri "http://www.afnix.org")
</pre>
<p>An uri can be broken into several components called the scheme, the authority, the path, optionally the query and the fragment. The Uri class provide a method to retrieve each component of the parsed uri.</p>
<pre>
const uri (afnix:www:Uri "http://www.afnix.org/")
println (uri:get-scheme)    # http
println (uri:get-authority) # www.afnix.org
println (uri:get-path)      # /
</pre>
<p><em>Character conversion</em></p><p>The Uri class performs automatically the character conversion in the input uri. For example, the + character is replaced by a blank. The % character followed by two hexadecimal values is replaced by the corresponding ASCII character. Note that this conversion does now apply to the query string.</p><p><em>Query string</em></p><p>The get-query method returns the query string of the uri. The query string starts after the ? character. The query string is a series of key-pair values separated by the & character.</p>
<pre>
const uri (afnix:www:Uri
  "http://www.afnix.org?name=hello&value=world")
println (uri:get-query) # name=hello&value=world
</pre>
<p>The module also provides the UriQuery class that parses the query string and store the result in the form of a property list. The query string parse is particularly useful when writing automated scripts.</p>
<pre>
# create a query string object
const qs (afnix:nwg:UriQuery (uri:get-query))
# get the name value
qs:get-value "name"
</pre>
<p><strong>Managing a cgi request</strong></p><p>Managing a cgi request involves primarily the parsing of the requesting uri. The uri generally contains the http referrer as well as parameter which are stored in the form of a query string. However, depending on the cgi method which can be of type GET or POST, the treatment is somewhat different.</p><p><em>Checking the protocol version</em></p><p>In the presence of a cgi protocol, it is always a good idea to check the protocol version, or at least to put an assertion. The protocol version is normally CGI/1.1 and is stored in the GATEWAY_INTERFACE environment variable.</p>
<pre>
# check the cgi protocol
assert "CGI/1.1" (
  afnix:sys:get-env "GATEWAY_INTERFACE")
</pre>
<p><em>Getting the query string</em></p><p>If the request method is GET, then the query string is available in the environment variable QUERY_STRING. If the request method is POST, the query string is available in the input stream. The length of the query string is given by the CONTENT_LENGTH environment variable. The following example illustrates the extraction of the query string.</p>
<pre>
# check the cgi protocol
assert "CGI/.1" (
  afnix:sys:get-env "GATEWAY_INTERFACE")
# initialize the query string
const query (afnix:sys:get-env "QUERY_STRING")
# get the request method
const rqm (afnix:sys:get-env "REQUEST_METHOD")
# check for a post request and update the query string
if (== rqm "POST") {
  # create a buffer from the content length
  const len (
    Integer (afnix:sys:get-env "CONTENT_LENGTH"))
  # get the standard input stream and read content
  const is  (interp:get-input-stream)
  const buf (is:read len)
  # set the query string
  query:= (buf:to-string)
}
</pre>
<p><em>Parsing the query string</em></p><p>The UriQuery class is designed to parse a cgi query string. Once the string has been parsed, it is possible to perform a query by key since the class operates with a property list.</p>
<pre>
const query (
  afnix:www:UriQuery "name=hello&value=world")
query:length      # 2
query:get-value "name"  # hello
query:get-value "value" # world
</pre>
<p>The UriQuery class is the foundation to build cgi script. When the library is combined with the web application management (wam) service, powerful applications can be built easily.</p><p><strong>Special functions</strong></p><p>Several dedicated functions are available in the library as a way to ease the object manipulations. Theses functions operate mostly on uri and files as described below.</p><p><em>Uri functions</em></p><p>Several functions are designed to ease the uri manipulation. Most of them operate on the uri name or their associated system name. The normalize-uri-name function normalizes a string argument by adding a uri scheme if missing in the original string. If the function detects that the name starts with a host name, the http scheme is added. If the function detects that the string starts with a path, the file scheme is added. otherwise, the name argument is left untouched. The system-uri-name function normalizes the string argument by prioritizing the system name. The function attempts to find a file that match the sring argument and eventually build a uri file scheme. If the file is not fond, the normalization process occurs with the normalize-uri-name function.</p>
<pre>
# normalize a uri name
trans  unm "http://www.afnix.org"
assert unm (
  afnix:nwg:normalize-uri-name unm)
assert unm (
  afnix:nwg:normalize-uri-name "www.afnix.org")
assert unm (
  afnix:nwg:normalize-uri-name "//www.afnix.org")
</pre>
<p><em>Mime functions</em></p><p>Mime functions are dedicated to easee the mainpulation of media types or mime. A media type is defined by a string in the form of a type and content value such as text/plain. The mime-value-p predicate returns true if a string mime value is a valid media type. From a file perspective, the mime-extension-p predicate returns true if the string extension has a valid media type associated to it. Finally, the extension-to-mime function can be used to get the string mime value associated with a file extension.</p>
<pre>
# check a media type
assert true (afnix:nwg:mime-value-p "text/plain")
# check the mime extension predicate
assert true (afnix:nwg:mime-extension-p "txt")
# check the extension to mime
assert "text/plain" (
  afnix:nwg:extension-to-mime "txt")
</pre>
<p><strong>HTTP transaction objects</strong></p><p>The concept of HTTP transactions is defined in RFC 2616. In the client/server approach, a client issues a request which is answered with a response. A special case arise when the server is asked to perform some extra works, such like executing a script. In this case, the answer is called a reply which is formatted into a response when the server does its job correctly. The nature of the HTTP objects determines how the associated stream behaves. With a HTTP request, the object is filled by reading an input stream when operating on the server side. On the other hand, the request is filled by data when operating on the client side. With a HTTP response, the opposite situation occurs. The HTTP response is filled by reading an input stream when operating on the client side and filled by data when operating on the server side.</p><p><em>HTTP protocol</em></p><p>The HttpProto class is a base class designed to handle a HTTP header that is found in both HTTP request and response. The class is built around a property list that is filled either by parsing an input stream or by processing specific methods. The HttpProto defines also some methods which are often used with a HTTP request or response.</p><p><strong>HTTP response</strong></p><p>The HttpResponse class is a class designed to handle a HTTP response. When operating on the client side, the response object is built by reading an input stream. When operating on the server side, the response object is built by calling specific methods.</p><p><em>Creating a server response</em></p><p>A server response is created by specifying the response status code. By default, a HTTP response is created with the default media type text/html. If the media type needs to be changed, it can be passed as the second argument to the response constructor. By default, the empty constructor creates an empty constructor with a valid status code.</p>
<pre>
#create a valid response
const hr (afnix:nwg:HttpResponse 200)
</pre>
<p>Once the server response is created, it can be augmented with some headed values. Typically, a server will add some information about the response, such like the content length, the modification time or a tag. The HttpResponse provides several methods that ease the generation of these header values.</p><p><em>Creating a client response</em></p><p>A client response is created by binding an input stream to a response object. During the construction, the input stream is read and the HTTP protocol header is filled. It is also during this phase that the status code is processed. It is therefore important to ensure that a response object is built correctly before attempting to access it.</p>
<pre>
# create a client response by stream
const hr (afnix:nwg:HttpResponse is)
</pre>
<p><em>Reading a client response</em></p><p>When the response has been created, it is important to check its status code. Most of the time, the response is valid and its content can be read directly. The status-ok-p predicate returns true if the status code is valid. In such case, a HTTP stream can be built in order to read the response.</p>
<pre>
# check that a response is valid
if (hr:status-ok-p) {
  # create a http stream
  const rs (afnix:nwg:HttpStream ht is)
  # read the response stream
  while (rs:eos-p) (rs:read)
}
</pre>
<p>Before reading a http stream, it is important to detect and verify the nature of the response content. The media-type-p predicate returns true if the media type is defined and the get-media-type method returns the response type in the form of a mime code such like text/html. Eventually, the character set associated with the media type can also be detected. The encoding-mode-p predicate and the get-encoding-mode method can be used to detect the content encoding mode. However, it is worth to note that the HttpStream object is automatically sets with the proper encoding if it can be found in the response header.</p><p><em>Special client response</em></p><p>Certain response can sometime contains special status codes that require a specific treatment. This is the case when the response corresponds to a http redirection. In this case, the new uri must be fetched to get the desired response. The location-p predicate returns true if the response corresponds to a http redirect and the get-location method can be used to get the new location uri. If this situation arises, it is up to the implementation to decide what to do with the new uri. In most cases, a new request will be sent to the server.</p><p><strong>Cookie object</strong></p><p>The Cookie object is a special object that can be used during a http session, to post data to the http client. The idea behind cookies is to be able to maintain some state, during the user session for some time. A cookie is a name/value pair and eventually an expiration time. By default, the cookie object are defined for one http client session, but this behavior can be changed.</p><p><em>Managing cookies</em></p><p>A cookie is created with a name/value pair and eventually an expiration time. Such expiration time is called the maximum-age and is automatically formatted by the object. With two arguments a session cookie is created. With a third argument as an integer, the constructor set the maximum age in seconds.</p>
<pre>
# create a cookie with name/value
const cookie (afnix:nwg:Cookie "cartid" "123456789")
</pre>
<p>The cookie implementation follows the recommendation of the RFC-2965 for http state management. The most important point to remember is the interpretation of the maximum age that differs from one cookie version to another. With version 1, which is the default, the maximum age is defined relatively in seconds, while it is absolute with version 0.The maximum age is set either at construction or with the set-max-age method. The set-max-age method sets the cookie life time in seconds, in reference to the current time. A negative value is always reset to -1 and defined a session cookie. A 0 value tells the http client to remove the cookie. The set-path method defines the path for which this cookie apply.</p><p><em>Adding a cookie</em></p><p>Once the cookie is defined, the set-cookie method of the HttpResponse object can be used to install the cookie. Combined with the write method, the cookie can be send to the http client.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">STANDARD NETWORK WORKING GROUP REFERENCE</h2>
        <div class="sectioncontent">
<p><strong>Uri</strong></p><p>The Uri class is a base object used to parse or build a uniform resource identifier as defined by RFC 3986. The URI can be built by specifying each component or by parsing a string. When a string is given in the constructor, the class parses the string and extract all components. The uri components are the scheme, the authority, the path, the query and the fragment. The class also takes care of the character escaping.</p><p><em>Predicate</em></p><p>uri-p</p><p><em>Inheritance</em></p><p>Object</p><p><em>Constructors</em></p><p><strong>Uri (none)</strong></p><p>The Uri constructor creates an empty uri object.</p><p><strong>Uri (String)</strong></p><p>The Uri constructor create a uri object by value. The string argument is the uri to parse at the object construction.</p><p><strong>Uri (String String Integer)</strong></p><p>The Uri constructor create a uri object by scheme host and port. The first argument is the uri scheme. The second argument is the uri host name. The third argument is the uri port. The uri base name can be reconstructed from this information.</p><p><em>Methods</em></p><p><strong>parse -&gt; none (String)</strong></p><p>The parse method reset the uri object, parse the string argument and fill the uri object with the result.</p><p><strong>get-scheme -&gt; String (none)</strong></p><p>The get-scheme method returns the scheme of the parsed uri object.</p><p><strong>get-authority -&gt; String (none)</strong></p><p>The get-authority method returns the authority part of the parsed uri.</p><p><strong>get-path -&gt; String (none)</strong></p><p>The get-path method returns the path of the parsed uri.</p><p><strong>get-path-target -&gt; String (none)</strong></p><p>The get-path-target method returns the path target of the parsed uri. The path target is the last element of the uri path.</p><p><strong>get-query -&gt; String (none)</strong></p><p>The get-query method returns the complete query string of the parsed uri. Note that characters are not escaped when getting the string.</p><p><strong>get-fragment -&gt; String (none)</strong></p><p>The get-fragment method returns the complete query string of the parsed uri.</p><p><strong>get-base -&gt; String (none)</strong></p><p>The get-base method returns the combined uri scheme and authority.</p><p><strong>get-rname -&gt; String (none)</strong></p><p>The get-rname method returns the reference uri name with the combined uri scheme, authority and path all percent encoded.</p><p><strong>get-hname -&gt; String (none)</strong></p><p>The get-hname method returns the combined uri scheme, authority and path.</p><p><strong>get-aname -&gt; String (none)</strong></p><p>The get-aname method returns the almost combined uri name with the scheme, authority, path and query.</p><p><strong>add-path -&gt; Uri (String)</strong></p><p>The add-path method adds a path to the calling uri and returns a new uri with the new path added to the old one.</p><p><strong>get-href -&gt; Uri (String)</strong></p><p>The get-href method returns a new uri by eventually combining the string argument. If the string argument correspond to an uri, the corresponding uri is built. Otherwise, the string argument is considered as a path to be added to the current uri in order to build a new uri.</p><p><strong>get-system-path -&gt; String (none)</strong></p><p>The get-system-path method returns the system path representation of the uri path. This function works only if the scheme if a file scheme.</p><p><strong>get-path-encoded -&gt; String (none)</strong></p><p>The get-path-encoded method returns the uri in the encoded form. Normally the get-path removes the percent-encoded characters which might not be appropriate with some protocol such like the http protocol. The get-path-encoded returns the original path. Note that getting the path with getpath and doing a percent coding might result in a different result since the internal representation uses normalized string.</p><p><strong>get-host -&gt; String (none)</strong></p><p>The get-host method returns the authority or path host name if any can be found with respect to the scheme. With a ftp, http or https scheme, the host is extracted from the authority. With a mailto scheme, the host is extracted from the path.</p><p><strong>get-port -&gt; Integer (none)</strong></p><p>The get-port method returns the authority port if any can be found with respect to the scheme.</p><p><strong>UriQuery</strong></p><p>The UriQuery class is a simple class that parses a uri query string and build property list. during the parsing process, a special transliteration process is done as specified by RFC 3986. This class is primarily used with cgi scripts. Note that the string to parse is exactly the one produced by the get-query method of the Uri class.</p><p><em>Predicate</em></p><p>uri-query-p</p><p><em>Inheritance</em></p><p>Plist</p><p><em>Constructors</em></p><p><strong>UriQuery (none)</strong></p><p>The UriQuery constructor creates an empty uri query object.</p><p><strong>UriQuery (String)</strong></p><p>The UriQuery constructor create a uri object by value. The string argument is the uri query string to parse at the object construction. The query string is the one obtained from the get-query method of the Uri class.</p><p><em>Methods</em></p><p><strong>parse -&gt; none (String)</strong></p><p>The parse method reset the uri query object, parses the string argument and fill the property list object with the result.</p><p><strong>get-query -&gt; String (none)</strong></p><p>The get-query method returns the original query string.</p><p><em>Functions</em></p><p><strong>mime-extension-p -&gt; Boolean (String)</strong></p><p>The mime-extension-p predicates returns true if a media type extension - mime extension - is defined. Most of the time, media type extension can be seen as a file extension.</p><p><strong>mime-value-p -&gt; Boolean (String)</strong></p><p>The mime-value-p predicates returns true if a media type - mime value - is defined.</p><p><strong>extension-to-mime -&gt; String (String [Boolean])</strong></p><p>The extension-to-mime function converts a media type extension into a media type. In the first form, without a second argument, if the media type extension does not exist, an exception is raised. In the second form, with the second argument set to true, if the media type extension does not exist, the default media type is returned. If the flag is set to false, an exception is raised like the first form.</p><p><strong>normalize-uri-name -&gt; String (String)</strong></p><p>The normalize-uri-name function normalizes the string argument by adding a uri scheme if missing in the original string. If the function detects that the name starts with a host name, the "http" scheme is added. If the function detects that the string starts with a path, the "file" scheme is added. otherwise, the name argument is left untouched.</p><p><strong>system-uri-name -&gt; String (String)</strong></p><p>The system-uri-name function normalizes the string argument by prioritizing the system name. The function attempts to find a file that match the string argument and eventually build a uri file scheme. If the file is not fond, the normalization process occurs with the normalize-uri-name function.</p><p><strong>HttpProto</strong></p><p>The HttpProto class is a base class that ease the deployment of the http protocol. The base class is built with a property list which is used to define the message header. The class also defines the write methods which are used to write a message either on an output stream or into a buffer.</p><p><em>Predicate</em></p><p>http-proto-p</p><p><em>Inheritance</em></p><p>Object</p><p><em>Methods</em></p><p><strong>reset -&gt; none (none)</strong></p><p>The reset method resets the http protocol object by clearing the protocol version and header.</p><p><strong>parse -&gt; none (none)</strong></p><p>The parse method parse the input stream bound to the http protocol. In order to operate, an input stream must be associated with the protocol object or an exception is raised. After a stream has been parsed, the protocol version and the header are set.</p><p><strong>write -&gt; none (none|OutputStream|Buffer)</strong></p><p>The write method formats and writes the http protocol object to an output stream or a buffer. Without argument, the default output stream is used. With an argument, an output stream or a buffer object can be used.</p><p><strong>header-length -&gt; Integer (none)</strong></p><p>The header-length method returns the number of properties in the header.</p><p><strong>header-exists-p -&gt; Boolean (String)</strong></p><p>The header-exists-p predicate returns true if the property exists in the header. The string argument is the property name.</p><p><strong>header-set -&gt; none (String Literal)</strong></p><p>The header-set method sets a new property to the http header. The first argument is the property name. The second argument is a literal object which is internally converted to a string.</p><p><strong>header-get -&gt; Property (Integer)</strong></p><p>The header-get method returns a property object by index.</p><p><strong>header-map -&gt; String (String)</strong></p><p>The header-map method returns a property value by name. The string argument is the property name.</p><p><strong>header-find -&gt; Property (String)</strong></p><p>The header-find method returns a property object by name. The string argument is the property name. If the property is not found, the nil object is returned.</p><p><strong>header-lookup -&gt; Property (String)</strong></p><p>The header-lookup method returns a property object by name. The string argument is the property name. If the property is not found, an exception is raised.</p><p><strong>header-plist -&gt; Plist (none)</strong></p><p>The header-plist method returns the header in the form of a property list.</p><p><strong>content-length-p -&gt; Boolean (none)</strong></p><p>The content-length-p predicate returns true if the content length is defined in the protocol header.</p><p><strong>get-content-length -&gt; Integer (none)</strong></p><p>The get-content-length method returns the content length defined in the protocol header. If the content length is not defined in the header, the null value is returned.</p><p><strong>media-type-p -&gt; Boolean (none)</strong></p><p>The media-type-p predicate returns true if the content type is defined in the protocol header.</p><p><strong>get-media-type -&gt; String (none)</strong></p><p>The get-media-type method returns the media type defined in the protocol header. If the media type is not defined in the header, the default media type is returned.</p><p><strong>encoding-mode-p -&gt; Boolean (none)</strong></p><p>The encoding-mode-p predicate returns true if the encoding mode is defined in the protocol header.</p><p><strong>get-encoding-mode -&gt; String (none)</strong></p><p>The get-encoding-mode method returns the protocol encoding mode. If the encoding mode is not defined in the protocol header, the default encoding mode is returned.</p><p><strong>HttpRequest</strong></p><p>The HttpRequest class is a base class designed to handle a http request. The class operates with the protocol version 1.1 as defined by RFC 2616. For a server request, the request is built by reading an input stream and setting the request command with its associated header. For a client request, the request is formatted with a request command and a eventually a uri. In both cases, the header is filled automatically depending on the request side.</p><p><em>Predicate</em></p><p>http-request-p</p><p><em>Inheritance</em></p><p>HttpProto</p><p><em>Constructors</em></p><p><strong>HttpRequest (none)</strong></p><p>The HttpRequest constructor creates a default http request. By default, the request object is built with the GET method and the request uri set to the root value.</p><p><strong>HttpRequest (String)</strong></p><p>The HttpRequest constructor creates a http request object with a specific command. By default, the request uri is set to root, except for the OPTIONS method</p><p><strong>HttpRequest (Uri)</strong></p><p>The HttpRequest constructor creates a http request object with a uri. The default request method is GET.</p><p><strong>HttpRequest (InputStream)</strong></p><p>The HttpRequest constructor creates a http request object with a specific input stream. At construction, the request header is cleared and the input stream is bound to the object.</p><p><strong>HttpRequest (String String)</strong></p><p>The HttpRequest constructor creates a http request object with a specific method and a uri name. The first string argument is the request method to use. The second string argument is the uri attached to the command. Note that the term uri should be understood as a request uri.</p><p><strong>HttpRequest (String Uri)</strong></p><p>The HttpRequest constructor creates a http request object with a specific method and a uri. The first string argument is the request method to use. The second argument is the uri attached to the method.</p><p><em>Methods</em></p><p><strong>set-method -&gt; none (String)</strong></p><p>The set-method method sets the request method. This method does not check that the command is a valid HTTP method and thus leaves plenty of room for server development. As a matter of fact, RFC 2616 does not prohibit the existence of such extension.</p><p><strong>get-method -&gt; String (none)</strong></p><p>The get-method method returns the request method string.</p><p><strong>set-uri -&gt; none (String)</strong></p><p>The set-uri method sets the request uri. The argument string does not have to be a valid uri string since some commands might accept special string such like "*" to indicate all applicable uri.</p><p><strong>get-uri -&gt; String (none)</strong></p><p>The get-uri method returns the request uri string.</p><p><strong>HttpResponse</strong></p><p>The HttpResponse class is a base class designed to handle a http response. The class operates with the protocol version 1.1 as defined by RFC 2616. For a client response, the response is built by reading an input stream and setting the response status code with its associated header. For a server response, the response is formatted with a response status and additional header information. In both cases, the header is filled automatically depending on the response side. On the other hand, trying to set some header with an input stream bound to the response object might render the response object unusable.</p><p><em>Predicate</em></p><p>http-response-p</p><p><em>Inheritance</em></p><p>HttpProto</p><p><em>Constructors</em></p><p><strong>HttpResponse (none)</strong></p><p>The HttpResponse constructor creates a default http response object. The response is marked valid with a default text/plain media type.</p><p><strong>HttpResponse (Integer)</strong></p><p>The HttpResponse constructor creates a http response object with a status code. The response code is associated with the default text/plain media type.</p><p><strong>HttpResponse (InputStream)</strong></p><p>The HttpResponse constructor creates a http response object with a specific input stream. At construction, the response header is cleared and the input stream is bound to the object.</p><p><strong>HttpResponse (Integer String)</strong></p><p>The HttpResponse constructor creates a http response object with a status code and a media type. The first argument is the status code. The second argument is the associated media type.</p><p><em>Methods</em></p><p><strong>set-status-code -&gt; none (Integer)</strong></p><p>The set-status-code method sets the response status code.</p><p><strong>get-status-code -&gt; Integer (none)</strong></p><p>The get-status-code method returns the response status code.</p><p><strong>map-status-code -&gt; String (none)</strong></p><p>The map-status-code method returns a string representation of the response status code.</p><p><strong>status-ok-p -&gt; Boolean (none)</strong></p><p>The status-ok-p predicate returns true if the response status code is valid (aka status 200).</p><p><strong>status-error-p -&gt; Boolean (none)</strong></p><p>The status-error-p predicate returns true if the response status code is an error code.</p><p><strong>location-p -&gt; Boolean (none)</strong></p><p>The location-p predicate returns true is the response status code indicates that a request should be made at another location. The location can be found with the get-location method.</p><p><strong>get-location -&gt; String (none)</strong></p><p>The get-location method returns the location uri found in the response header. This method is equivalent to a header query.</p><p><strong>set-location -&gt; none (String)</strong></p><p>The set-location method set the redirect location in the response header. The string argument is the location uri.</p><p><strong>set-cookie -&gt; none (Cookie)</strong></p><p>The set-cookie method sets a cookie object to the http header. The cookie version is properly handled by the method.</p><p><strong>Cookie</strong></p><p>The Cookie class is a special class designed to handle cookie setting within a http transaction. A cookie is name/value pair that is set by the server and stored by the http client. Further connection with the client will result with the cookie value transmitted by the client to the server. A cookie has various parameters that controls its existence and behavior. The most important one is the cookie maximum age that is defined in seconds. A null value tells the client to discard the cookie. A cookie without maximum age is valid only during the http client session. A cookie can be added to the HttpReply object with the set-cookie method. A cookie can be constructed with a name/value pair. An optional third argument is the maximum age. The default cookie version is 1 as specified by RFC 2965. With a version 1, the maximum age is interpreted as the number of seconds before the cookie expires. With version 0, the maximum age is the absolute time.</p><p><em>Predicate</em></p><p>cookie-p</p><p><em>Inheritance</em></p><p>Object</p><p><em>Constructors</em></p><p><strong>Cookie (String String)</strong></p><p>The Cookie constructor creates a cookie with a name value pair. The first argument is the cookie name. The second argument is the cookie value.</p><p><strong>Cookie (String String Integer)</strong></p><p>The Cookie constructor creates a cookie with a name value pair and a maximum age. The first argument is the cookie name. The second argument is the cookie value. The third argument is the cookie maximum age.</p><p><em>Methods</em></p><p><strong>get-version -&gt; Integer (none)</strong></p><p>The get-version method returns the cookie version.</p><p><strong>set-version -&gt; none (Integer)</strong></p><p>The set-version method sets the cookie version. The version number can only be 0 or 1.</p><p><strong>get-name -&gt; String (none)</strong></p><p>The get-name method returns the cookie name. This is the name store on the http client.</p><p><strong>set-name -&gt; none (String)</strong></p><p>The set-name method sets the cookie name. This is the name store on the http client.</p><p><strong>get-value -&gt; String (none)</strong></p><p>The get-value method returns the cookie value. This is the value stored on the http client bounded by the cookie name.</p><p><strong>set-value -&gt; none (String)</strong></p><p>The set-value method sets the cookie value. This is the value store on the http client bounded by the cookie name.</p><p><strong>get-maximum-age -&gt; Integer (none)</strong></p><p>The get-maximum-age method returns the cookie maximum age. The default value is -1, that is, no maximum age is set and the cookie is valid only for the http client session.</p><p><strong>set-maximum-age -&gt; none (Integer)</strong></p><p>The set-maximum-age method sets the cookie maximum age. A negative value is reset to -1. A 0 value tells the http client to discard the cookie. A positive value tells the http client to store the cookie for the remaining seconds.</p><p><strong>get-path -&gt; String (none)</strong></p><p>The get-path method returns the cookie path value. The path determines for which http request the cookie is valid.</p><p><strong>set-path -&gt; none (String)</strong></p><p>The set-path method sets the cookie path value. The path determines for which http request the cookie is valid.</p><p><strong>get-domain -&gt; String (none)</strong></p><p>The get-domain method returns the cookie domain value.</p><p><strong>set-domain -&gt; none (String)</strong></p><p>The set-domain method sets the cookie domain value. It is string recommended to use the originator domain name since many http client can reject cookie those domain name does not match the originator name.</p><p><strong>get-port -&gt; Integer (none)</strong></p><p>The get-port method returns the cookie port number.</p><p><strong>set-port -&gt; none (Integer)</strong></p><p>The set-port method sets the cookie port number. This value is not used with a cookie version 0.</p><p><strong>get-comment -&gt; String (none)</strong></p><p>The get-comment method returns the cookie comment value.</p><p><strong>set-comment -&gt; none (String)</strong></p><p>The set-comment method sets the cookie comment value.</p><p><strong>get-comment-url -&gt; String (none)</strong></p><p>The get-comment-url method returns the cookie comment url value.</p><p><strong>set-comment-url -&gt; none (String)</strong></p><p>The set-comment-url method sets the cookie comment url value. This value is not used with cookie version 0.</p><p><strong>get-discard -&gt; Boolean (none)</strong></p><p>The get-discard method returns the cookie discard flag.</p><p><strong>set-discard -&gt; none (Boolean)</strong></p><p>The set-discard method sets the cookie discard flag. The discard flag the tells the user agent to destroy the cookie when it terminates. This value is not used with cookie version 0.</p><p><strong>get-secure -&gt; Boolean (none)</strong></p><p>The get-secure method returns the cookie secure flag.</p><p><strong>set-secure -&gt; none (Boolean)</strong></p><p>The set-secure method sets the cookie secure flag. When a cookie is secured, it is only returned by the http client if a connection has been secured (i.e use https).</p><p><strong>to-string -&gt; String (none)</strong></p><p>The to-string method returns a string formatted for the http reply header. Normally this method should not be called since the set-cookie method of the httpReply takes care of such thing.</p><p><strong>Session</strong></p><p>The Session class that defines a session to be associated with an http transaction. The session object is designed to be persistent so that its data information can be retrieved at any time. A session object has also the particularity to have a limited lifetime. A session object is created by name with an identifier. If a path is given, such path will be used as the session file name.</p><p><em>Predicate</em></p><p>session-p</p><p><em>Inheritance</em></p><p>Serial</p><p><em>Constructors</em></p><p><strong>Session (String)</strong></p><p>The Session constructor creates a session by name. The string argument is the session name.</p><p><strong>Session (String String)</strong></p><p>The Session constructor creates a session with a name and a user. The first argument is the session name. The second argument is the user name.</p><p><strong>Session (String String String)</strong></p><p>The Session constructor creates a session with a name, a user and a path. The first argument is the session name. The second argument is the session user name. The third argument is the session path.</p><p><em>Methods</em></p><p><strong>expire-p -&gt; Boolean (none)</strong></p><p>The expire-p predicate returns true if the session has expired.</p><p><strong>get-name -&gt; String (none)</strong></p><p>The get-name method returns the session name.</p><p><strong>set-hash-id -&gt; none (String)</strong></p><p>The set-hash-id method sets the session hash identifier. The session hash id must be unique and secured enough so that the session name cannot be derived from it.</p><p><strong>get-hash-id -&gt; String (none)</strong></p><p>The get-hash-id method returns the session hash identifier.</p><p><strong>set-user -&gt; none (String)</strong></p><p>The set-user method sets the session user name.</p><p><strong>get-user -&gt; String (none)</strong></p><p>The get-user method returns the session user name.</p><p><strong>set-path -&gt; none (String)</strong></p><p>The set-path method sets the session path.</p><p><strong>get-path -&gt; String (none)</strong></p><p>The get-path method returns the session path.</p><p><strong>set-maximum-age -&gt; none (Integer)</strong></p><p>The set-max-age method sets the session maximum age. The maximum age is an integer in seconds relative to the current time.</p><p><strong>mark-expired -&gt; none (none)</strong></p><p>The mark-expired method marks the session as expired. This is done by forcing the expiration time to the creation time.q</p><p><strong>get-valid-time -&gt; Integer (none)</strong></p><p>The get-valid-time method returns the remaining valid session time.</p><p><strong>get-expire-time -&gt; Integer (none)</strong></p><p>The get-expire-time method returns the session expiration time in seconds. The expiration time is an absolute time.</p><p><strong>set-expire-time -&gt; none (Integer)</strong></p><p>The set-expire-time method sets the session expiration time. The expiration time is an absolute time in seconds.</p><p><strong>get-creation-time -&gt; Integer (none)</strong></p><p>The get-creation-time method returns the session creation time. The creation time is an absolute time in seconds.</p><p><strong>get-modification-time -&gt; Integer (none)</strong></p><p>The get-modification-time method returns the session creation time. The modification time is an absolute time in seconds.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="afnix-net.3.html"><span aria-hidden="true">&larr;</span> afnix-net.3: Standard networking module</a></li>
   <li class="next"><a href="afnix-sec.3.html">afnix-sec.3: Standard security module <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

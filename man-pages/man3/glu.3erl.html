<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>glu: A part of the standard opengl utility api.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="A part of the standard opengl utility api.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="glu (3erl) manual">
  <meta name="twitter:description" content="A part of the standard opengl utility api.">
  <meta name="twitter:image" content="https://www.carta.tech/images/erlang-manpages-glu-3erl.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3erl/glu.3erl.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="glu (3erl) manual" />
  <meta property="og:description" content="A part of the standard opengl utility api." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/erlang-manpages-glu-3erl.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">glu<small> (3erl)</small></h1>
        <p class="lead">A part of the standard opengl utility api.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/glu.3erl.html">
      <span itemprop="name">glu: A part of the standard opengl utility api.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/erlang-manpages/">
      <span itemprop="name">erlang-manpages</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/glu.3erl.html">
      <span itemprop="name">glu: A part of the standard opengl utility api.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>A part of the standard OpenGL Utility api. See www.opengl.org</p><p>Booleans are represented by integers 0 and 1.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DATA TYPES</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>enum() = non_neg_integer()</em>:</p><p>See wx/include/gl.hrl or glu.hrl</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>matrix() = {float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float()}</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>mem() = binary() | tuple()</em>:</p><p>Memory block</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>vertex() = {float(), float(), float()}</em>:</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">
<p><strong></strong> tesselate(Normal, Vs::[Vs]) -&gt; {Triangles, VertexPos}</p><p>Types:</p><p>Normal = vertex()</p><p>Vs = vertex()</p><p>Triangles = [integer()]</p><p>VertexPos = binary()</p><p>General purpose polygon triangulation. The first argument is the normal and the second a list of vertex positions. Returned is a list of indecies of the vertices and a binary (64bit native float) containing an array of vertex positions, it starts with the vertices in Vs and may contain newly created vertices in the end.</p><p><strong></strong> build1DMipmapLevels(Target, InternalFormat, Width, Format, Type, Level, Base, Max, Data) -&gt; integer()</p><p>Types:</p><p>Target = enum()</p><p>InternalFormat = integer()</p><p>Width = integer()</p><p>Format = enum()</p><p>Type = enum()</p><p>Level = integer()</p><p>Base = integer()</p><p>Max = integer()</p><p>Data = binary()</p><p>Builds a subset of one-dimensional mipmap levels</p><p><em>glu:build1DMipmapLevels</em> builds a subset of prefiltered one-dimensional texture maps of decreasing resolutions called a mipmap. This is used for the antialiasing of texture mapped primitives.</p><p>A return value of zero indicates success, otherwise a GLU error code is returned (see <strong>glu:errorString/1</strong> ).</p><p>A series of mipmap levels from <em>Base</em> to <em>Max</em> is built by decimating <em>Data</em> in half until size 1×1 is reached. At each level, each texel in the halved mipmap level is an average of the corresponding two texels in the larger mipmap level. <strong>gl:texImage1D/8</strong> is called to load these mipmap levels from <em>Base</em> to <em>Max</em> . If <em>Max</em> is larger than the highest mipmap level for the texture of the specified size, then a GLU error code is returned (see <strong>glu:errorString/1</strong> ) and nothing is loaded.</p><p>For example, if <em>Level</em> is 2 and <em>Width</em> is 16, the following levels are possible: 16×1, 8×1, 4×1, 2×1, 1×1. These correspond to levels 2 through 6 respectively. If <em>Base</em> is 3 and <em>Max</em> is 5, then only mipmap levels 8×1, 4×1 and 2×1 are loaded. However, if <em>Max</em> is 7, then an error is returned and nothing is loaded since <em>Max</em> is larger than the highest mipmap level which is, in this case, 6.</p><p>The highest mipmap level can be derived from the formula log 2(width×2 level).</p><p>See the <strong>gl:texImage1D/8</strong> reference page for a description of the acceptable values for <em>Type</em> parameter. See the <strong>gl:drawPixels/5</strong> reference page for a description of the acceptable values for <em>Level</em> parameter.</p><p>See external documentation.</p><p><strong></strong> build1DMipmaps(Target, InternalFormat, Width, Format, Type, Data) -&gt; integer()</p><p>Types:</p><p>Target = enum()</p><p>InternalFormat = integer()</p><p>Width = integer()</p><p>Format = enum()</p><p>Type = enum()</p><p>Data = binary()</p><p>Builds a one-dimensional mipmap</p><p><em>glu:build1DMipmaps</em> builds a series of prefiltered one-dimensional texture maps of decreasing resolutions called a mipmap. This is used for the antialiasing of texture mapped primitives.</p><p>A return value of zero indicates success, otherwise a GLU error code is returned (see <strong>glu:errorString/1</strong> ).</p><p>Initially, the <em>Width</em> of <em>Data</em> is checked to see if it is a power of 2. If not, a copy of <em>Data</em> is scaled up or down to the nearest power of 2. (If <em>Width</em> is exactly between powers of 2, then the copy of <em>Data</em> will scale upwards.) This copy will be used for subsequent mipmapping operations described below. For example, if <em>Width</em> is 57, then a copy of <em>Data</em> will scale up to 64 before mipmapping takes place.</p><p>Then, proxy textures (see <strong>gl:texImage1D/8</strong> ) are used to determine if the implementation can fit the requested texture. If not, <em>Width</em> is continually halved until it fits.</p><p>Next, a series of mipmap levels is built by decimating a copy of <em>Data</em> in half until size 1×1 is reached. At each level, each texel in the halved mipmap level is an average of the corresponding two texels in the larger mipmap level.</p><p><strong>gl:texImage1D/8</strong> is called to load each of these mipmap levels. Level 0 is a copy of <em>Data</em> . The highest level is (log 2)(width). For example, if <em>Width</em> is 64 and the implementation can store a texture of this size, the following mipmap levels are built: 64×1, 32×1, 16×1, 8×1, 4×1, 2×1, and 1×1. These correspond to levels 0 through 6, respectively.</p><p>See the <strong>gl:texImage1D/8</strong> reference page for a description of the acceptable values for the <em>Type</em> parameter. See the <strong>gl:drawPixels/5</strong> reference page for a description of the acceptable values for the <em>Data</em> parameter.</p><p>See external documentation.</p><p><strong></strong> build2DMipmapLevels(Target, InternalFormat, Width, Height, Format, Type, Level, Base, Max, Data) -&gt; integer()</p><p>Types:</p><p>Target = enum()</p><p>InternalFormat = integer()</p><p>Width = integer()</p><p>Height = integer()</p><p>Format = enum()</p><p>Type = enum()</p><p>Level = integer()</p><p>Base = integer()</p><p>Max = integer()</p><p>Data = binary()</p><p>Builds a subset of two-dimensional mipmap levels</p><p><em>glu:build2DMipmapLevels</em> builds a subset of prefiltered two-dimensional texture maps of decreasing resolutions called a mipmap. This is used for the antialiasing of texture mapped primitives.</p><p>A return value of zero indicates success, otherwise a GLU error code is returned (see <strong>glu:errorString/1</strong> ).</p><p>A series of mipmap levels from <em>Base</em> to <em>Max</em> is built by decimating <em>Data</em> in half along both dimensions until size 1×1 is reached. At each level, each texel in the halved mipmap level is an average of the corresponding four texels in the larger mipmap level. (In the case of rectangular images, the decimation will ultimately reach an N×1 or 1×N configuration. Here, two texels are averaged instead.) <strong>gl:texImage2D/9</strong> is called to load these mipmap levels from <em>Base</em> to <em>Max</em> . If <em>Max</em> is larger than the highest mipmap level for the texture of the specified size, then a GLU error code is returned (see <strong>glu:errorString/1</strong> ) and nothing is loaded.</p><p>For example, if <em>Level</em> is 2 and <em>Width</em> is 16 and <em>Height</em> is 8, the following levels are possible: 16×8, 8×4, 4×2, 2×1, 1×1. These correspond to levels 2 through 6 respectively. If <em>Base</em> is 3 and <em>Max</em> is 5, then only mipmap levels 8×4, 4×2, and 2×1 are loaded. However, if <em>Max</em> is 7, then an error is returned and nothing is loaded since <em>Max</em> is larger than the highest mipmap level which is, in this case, 6.</p><p>The highest mipmap level can be derived from the formula log 2(max(width height)×2 level).</p><p>See the <strong>gl:texImage1D/8</strong> reference page for a description of the acceptable values for <em>Format</em> parameter. See the <strong>gl:drawPixels/5</strong> reference page for a description of the acceptable values for <em>Type</em> parameter.</p><p>See external documentation.</p><p><strong></strong> build2DMipmaps(Target, InternalFormat, Width, Height, Format, Type, Data) -&gt; integer()</p><p>Types:</p><p>Target = enum()</p><p>InternalFormat = integer()</p><p>Width = integer()</p><p>Height = integer()</p><p>Format = enum()</p><p>Type = enum()</p><p>Data = binary()</p><p>Builds a two-dimensional mipmap</p><p><em>glu:build2DMipmaps</em> builds a series of prefiltered two-dimensional texture maps of decreasing resolutions called a mipmap. This is used for the antialiasing of texture-mapped primitives.</p><p>A return value of zero indicates success, otherwise a GLU error code is returned (see <strong>glu:errorString/1</strong> ).</p><p>Initially, the <em>Width</em> and <em>Height</em> of <em>Data</em> are checked to see if they are a power of 2. If not, a copy of <em>Data</em> (not <em>Data</em> ), is scaled up or down to the nearest power of 2. This copy will be used for subsequent mipmapping operations described below. (If <em>Width</em> or <em>Height</em> is exactly between powers of 2, then the copy of <em>Data</em> will scale upwards.) For example, if <em>Width</em> is 57 and <em>Height</em> is 23, then a copy of <em>Data</em> will scale up to 64 in <em>Width</em> and down to 16 in depth, before mipmapping takes place.</p><p>Then, proxy textures (see <strong>gl:texImage2D/9</strong> ) are used to determine if the implementation can fit the requested texture. If not, both dimensions are continually halved until it fits. (If the OpenGL version is (&lt;= 1.0, both maximum texture dimensions are clamped to the value returned by <strong>gl:getBooleanv/1</strong> with the argument <em>?GLU_MAX_TEXTURE_SIZE</em> .)</p><p>Next, a series of mipmap levels is built by decimating a copy of <em>Data</em> in half along both dimensions until size 1×1 is reached. At each level, each texel in the halved mipmap level is an average of the corresponding four texels in the larger mipmap level. (In the case of rectangular images, the decimation will ultimately reach an N×1 or 1×N configuration. Here, two texels are averaged instead.)</p><p><strong>gl:texImage2D/9</strong> is called to load each of these mipmap levels. Level 0 is a copy of <em>Data</em> . The highest level is (log 2)(max(width height)). For example, if <em>Width</em> is 64 and <em>Height</em> is 16 and the implementation can store a texture of this size, the following mipmap levels are built: 64×16, 32×8, 16×4, 8×2, 4×1, 2×1, and 1×1 These correspond to levels 0 through 6, respectively.</p><p>See the <strong>gl:texImage1D/8</strong> reference page for a description of the acceptable values for <em>Format</em> parameter. See the <strong>gl:drawPixels/5</strong> reference page for a description of the acceptable values for <em>Type</em> parameter.</p><p>See external documentation.</p><p><strong></strong> build3DMipmapLevels(Target, InternalFormat, Width, Height, Depth, Format, Type, Level, Base, Max, Data) -&gt; integer()</p><p>Types:</p><p>Target = enum()</p><p>InternalFormat = integer()</p><p>Width = integer()</p><p>Height = integer()</p><p>Depth = integer()</p><p>Format = enum()</p><p>Type = enum()</p><p>Level = integer()</p><p>Base = integer()</p><p>Max = integer()</p><p>Data = binary()</p><p>Builds a subset of three-dimensional mipmap levels</p><p><em>glu:build3DMipmapLevels</em> builds a subset of prefiltered three-dimensional texture maps of decreasing resolutions called a mipmap. This is used for the antialiasing of texture mapped primitives.</p><p>A return value of zero indicates success, otherwise a GLU error code is returned (see <strong>glu:errorString/1</strong> ).</p><p>A series of mipmap levels from <em>Base</em> to <em>Max</em> is built by decimating <em>Data</em> in half along both dimensions until size 1×1×1 is reached. At each level, each texel in the halved mipmap level is an average of the corresponding eight texels in the larger mipmap level. (If exactly one of the dimensions is 1, four texels are averaged. If exactly two of the dimensions are 1, two texels are averaged.) <strong>gl:texImage3D/10</strong> is called to load these mipmap levels from <em>Base</em> to <em>Max</em> . If <em>Max</em> is larger than the highest mipmap level for the texture of the specified size, then a GLU error code is returned (see <strong>glu:errorString/1</strong> ) and nothing is loaded.</p><p>For example, if <em>Level</em> is 2 and <em>Width</em> is 16, <em>Height</em> is 8 and <em>Depth</em> is 4, the following levels are possible: 16×8×4, 8×4×2, 4×2×1, 2×1×1, 1×1×1. These correspond to levels 2 through 6 respectively. If <em>Base</em> is 3 and <em>Max</em> is 5, then only mipmap levels 8×4×2, 4×2×1, and 2×1×1 are loaded. However, if <em>Max</em> is 7, then an error is returned and nothing is loaded, since <em>Max</em> is larger than the highest mipmap level which is, in this case, 6.</p><p>The highest mipmap level can be derived from the formula log 2(max(width height depth)×2 level).</p><p>See the <strong>gl:texImage1D/8</strong> reference page for a description of the acceptable values for <em>Format</em> parameter. See the <strong>gl:drawPixels/5</strong> reference page for a description of the acceptable values for <em>Type</em> parameter.</p><p>See external documentation.</p><p><strong></strong> build3DMipmaps(Target, InternalFormat, Width, Height, Depth, Format, Type, Data) -&gt; integer()</p><p>Types:</p><p>Target = enum()</p><p>InternalFormat = integer()</p><p>Width = integer()</p><p>Height = integer()</p><p>Depth = integer()</p><p>Format = enum()</p><p>Type = enum()</p><p>Data = binary()</p><p>Builds a three-dimensional mipmap</p><p><em>glu:build3DMipmaps</em> builds a series of prefiltered three-dimensional texture maps of decreasing resolutions called a mipmap. This is used for the antialiasing of texture-mapped primitives.</p><p>A return value of zero indicates success, otherwise a GLU error code is returned (see <strong>glu:errorString/1</strong> ).</p><p>Initially, the <em>Width</em> , <em>Height</em> and <em>Depth</em> of <em>Data</em> are checked to see if they are a power of 2. If not, a copy of <em>Data</em> is made and scaled up or down to the nearest power of 2. (If <em>Width</em> , <em>Height</em> , or <em>Depth</em> is exactly between powers of 2, then the copy of <em>Data</em> will scale upwards.) This copy will be used for subsequent mipmapping operations described below. For example, if <em>Width</em> is 57, <em>Height</em> is 23, and <em>Depth</em> is 24, then a copy of <em>Data</em> will scale up to 64 in width, down to 16 in height, and up to 32 in depth before mipmapping takes place.</p><p>Then, proxy textures (see <strong>gl:texImage3D/10</strong> ) are used to determine if the implementation can fit the requested texture. If not, all three dimensions are continually halved until it fits.</p><p>Next, a series of mipmap levels is built by decimating a copy of <em>Data</em> in half along all three dimensions until size 1×1×1 is reached. At each level, each texel in the halved mipmap level is an average of the corresponding eight texels in the larger mipmap level. (If exactly one of the dimensions is 1, four texels are averaged. If exactly two of the dimensions are 1, two texels are averaged.)</p><p><strong>gl:texImage3D/10</strong> is called to load each of these mipmap levels. Level 0 is a copy of <em>Data</em> . The highest level is (log 2)(max(width height depth)). For example, if <em>Width</em> is 64, <em>Height</em> is 16, and <em>Depth</em> is 32, and the implementation can store a texture of this size, the following mipmap levels are built: 64×16×32, 32×8×16, 16×4×8, 8×2×4, 4×1×2, 2×1×1, and 1×1×1. These correspond to levels 0 through 6, respectively.</p><p>See the <strong>gl:texImage1D/8</strong> reference page for a description of the acceptable values for <em>Format</em> parameter. See the <strong>gl:drawPixels/5</strong> reference page for a description of the acceptable values for <em>Type</em> parameter.</p><p>See external documentation.</p><p><strong></strong> checkExtension(ExtName, ExtString) -&gt; 0 | 1</p><p>Types:</p><p>ExtName = string()</p><p>ExtString = string()</p><p>Determines if an extension name is supported</p><p><em>glu:checkExtension</em> returns <em>?GLU_TRUE</em> if <em>ExtName</em> is supported otherwise <em>?GLU_FALSE</em> is returned.</p><p>This is used to check for the presence for OpenGL, GLU, or GLX extension names by passing the extension strings returned by <strong>gl:getString/1</strong> , <strong>glu:getString/1</strong> , see <em>glXGetClientString</em> , see <em>glXQueryExtensionsString</em>, or see <em>glXQueryServerString</em>, respectively, as <em>ExtString</em> .</p><p>See external documentation.</p><p><strong></strong> cylinder(Quad, Base, Top, Height, Slices, Stacks) -&gt; ok</p><p>Types:</p><p>Quad = integer()</p><p>Base = float()</p><p>Top = float()</p><p>Height = float()</p><p>Slices = integer()</p><p>Stacks = integer()</p><p>Draw a cylinder</p><p><em>glu:cylinder</em> draws a cylinder oriented along the <em>z</em> axis. The base of the cylinder is placed at <em>z</em> = 0 and the top at z=height. Like a sphere, a cylinder is subdivided around the <em>z</em> axis into slices and along the <em>z</em> axis into stacks.</p><p>Note that if <em>Top</em> is set to 0.0, this routine generates a cone.</p><p>If the orientation is set to <em>?GLU_OUTSIDE</em> (with <strong>glu:quadricOrientation/2</strong> ), then any generated normals point away from the <em>z</em> axis. Otherwise, they point toward the <em>z</em> axis.</p><p>If texturing is turned on (with <strong>glu:quadricTexture/2</strong> ), then texture coordinates are generated so that <em>t</em> ranges linearly from 0.0 at <em>z</em> = 0 to 1.0 at <em>z</em> = <em>Height</em> , and <em>s</em> ranges from 0.0 at the +<em>y</em> axis, to 0.25 at the +<em>x</em> axis, to 0.5 at the -<em>y</em> axis, to 0.75 at the -<em>x</em> axis, and back to 1.0 at the +<em>y</em> axis.</p><p>See external documentation.</p><p><strong></strong> deleteQuadric(Quad) -&gt; ok</p><p>Types:</p><p>Quad = integer()</p><p>Destroy a quadrics object</p><p><em>glu:deleteQuadric</em> destroys the quadrics object (created with <strong>glu:newQuadric/0</strong> ) and frees any memory it uses. Once <em>glu:deleteQuadric</em> has been called, <em>Quad</em> cannot be used again.</p><p>See external documentation.</p><p><strong></strong> disk(Quad, Inner, Outer, Slices, Loops) -&gt; ok</p><p>Types:</p><p>Quad = integer()</p><p>Inner = float()</p><p>Outer = float()</p><p>Slices = integer()</p><p>Loops = integer()</p><p>Draw a disk</p><p><em>glu:disk</em> renders a disk on the <em>z</em> = 0 plane. The disk has a radius of <em>Outer</em> and contains a concentric circular hole with a radius of <em>Inner</em> . If <em>Inner</em> is 0, then no hole is generated. The disk is subdivided around the <em>z</em> axis into slices (like pizza slices) and also about the <em>z</em> axis into rings (as specified by <em>Slices</em> and <em>Loops</em> , respectively).</p><p>With respect to orientation, the +<em>z</em> side of the disk is considered to be <em>outside</em> (see <strong>glu:quadricOrientation/2</strong> ). This means that if the orientation is set to <em>?GLU_OUTSIDE</em> , then any normals generated point along the +<em>z</em> axis. Otherwise, they point along the -<em>z</em> axis.</p><p>If texturing has been turned on (with <strong>glu:quadricTexture/2</strong> ), texture coordinates are generated linearly such that where r=outer, the value at (<em>r</em>, 0, 0) is (1, 0.5), at (0, <em>r</em>, 0) it is (0.5, 1), at (-<em>r</em>, 0, 0) it is (0, 0.5), and at (0, -<em>r</em>, 0) it is (0.5, 0).</p><p>See external documentation.</p><p><strong></strong> errorString(Error) -&gt; string()</p><p>Types:</p><p>Error = enum()</p><p>Produce an error string from a GL or GLU error code</p><p><em>glu:errorString</em> produces an error string from a GL or GLU error code. The string is in ISO Latin 1 format. For example, <em>glu:errorString</em>(<em>?GLU_OUT_OF_MEMORY</em>) returns the string <em>out of memory</em>.</p><p>The standard GLU error codes are <em>?GLU_INVALID_ENUM</em>, <em>?GLU_INVALID_VALUE</em>, and <em>?GLU_OUT_OF_MEMORY</em>. Certain other GLU functions can return specialized error codes through callbacks. See the <strong>gl:getError/0</strong> reference page for the list of GL error codes.</p><p>See external documentation.</p><p><strong></strong> getString(Name) -&gt; string()</p><p>Types:</p><p>Name = enum()</p><p>Return a string describing the GLU version or GLU extensions</p><p><em>glu:getString</em> returns a pointer to a static string describing the GLU version or the GLU extensions that are supported.</p><p>The version number is one of the following forms:</p><p><em>major_number.minor_number</em><em>major_number.minor_number.release_number</em>.</p><p>The version string is of the following form:</p><p><em>version number&lt;space&gt;vendor-specific information</em></p><p>Vendor-specific information is optional. Its format and contents depend on the implementation.</p><p>The standard GLU contains a basic set of features and capabilities. If a company or group of companies wish to support other features, these may be included as extensions to the GLU. If <em>Name</em> is <em>?GLU_EXTENSIONS</em>, then <em>glu:getString</em> returns a space-separated list of names of supported GLU extensions. (Extension names never contain spaces.)</p><p>All strings are null-terminated.</p><p>See external documentation.</p><p><strong></strong> lookAt(EyeX, EyeY, EyeZ, CenterX, CenterY, CenterZ, UpX, UpY, UpZ) -&gt; ok</p><p>Types:</p><p>EyeX = float()</p><p>EyeY = float()</p><p>EyeZ = float()</p><p>CenterX = float()</p><p>CenterY = float()</p><p>CenterZ = float()</p><p>UpX = float()</p><p>UpY = float()</p><p>UpZ = float()</p><p>Define a viewing transformation</p><p><em>glu:lookAt</em> creates a viewing matrix derived from an eye point, a reference point indicating the center of the scene, and an <em>UP</em> vector.</p><p>The matrix maps the reference point to the negative <em>z</em> axis and the eye point to the origin. When a typical projection matrix is used, the center of the scene therefore maps to the center of the viewport. Similarly, the direction described by the <em>UP</em> vector projected onto the viewing plane is mapped to the positive <em>y</em> axis so that it points upward in the viewport. The <em>UP</em> vector must not be parallel to the line of sight from the eye point to the reference point.</p><p>Let</p><p>F=(centerX-eyeX centerY-eyeY centerZ-eyeZ)</p><p>Let <em>UP</em> be the vector (upX upY upZ).</p><p>Then normalize as follows: f=F/(||F||)</p><p>UP"=UP/(||UP||)</p><p>Finally, let s=f×UP", and u=s×f.</p><p>M is then constructed as follows: M=(s[0] s[1] s[2] 0 u[0] u[1] u[2] 0-f[0]-f[1]-f[2] 0 0 0 0 1)</p><p>and <em>glu:lookAt</em> is equivalent to glMultMatrixf(M); glTranslated(-eyex, -eyey, -eyez);</p><p>See external documentation.</p><p><strong></strong> newQuadric() -&gt; integer()</p><p>Create a quadrics object</p><p><em>glu:newQuadric</em> creates and returns a pointer to a new quadrics object. This object must be referred to when calling quadrics rendering and control functions. A return value of 0 means that there is not enough memory to allocate the object.</p><p>See external documentation.</p><p><strong></strong> ortho2D(Left, Right, Bottom, Top) -&gt; ok</p><p>Types:</p><p>Left = float()</p><p>Right = float()</p><p>Bottom = float()</p><p>Top = float()</p><p>Define a 2D orthographic projection matrix</p><p><em>glu:ortho2D</em> sets up a two-dimensional orthographic viewing region. This is equivalent to calling <strong>gl:ortho/6</strong> with near=-1 and far=1.</p><p>See external documentation.</p><p><strong></strong> partialDisk(Quad, Inner, Outer, Slices, Loops, Start, Sweep) -&gt; ok</p><p>Types:</p><p>Quad = integer()</p><p>Inner = float()</p><p>Outer = float()</p><p>Slices = integer()</p><p>Loops = integer()</p><p>Start = float()</p><p>Sweep = float()</p><p>Draw an arc of a disk</p><p><em>glu:partialDisk</em> renders a partial disk on the z=0 plane. A partial disk is similar to a full disk, except that only the subset of the disk from <em>Start</em> through <em>Start</em> + <em>Sweep</em> is included (where 0 degrees is along the +f2yf axis, 90 degrees along the +<em>x</em> axis, 180 degrees along the -<em>y</em> axis, and 270 degrees along the -<em>x</em> axis).</p><p>The partial disk has a radius of <em>Outer</em> and contains a concentric circular hole with a radius of <em>Inner</em> . If <em>Inner</em> is 0, then no hole is generated. The partial disk is subdivided around the <em>z</em> axis into slices (like pizza slices) and also about the <em>z</em> axis into rings (as specified by <em>Slices</em> and <em>Loops</em> , respectively).</p><p>With respect to orientation, the +<em>z</em> side of the partial disk is considered to be outside (see <strong>glu:quadricOrientation/2</strong> ). This means that if the orientation is set to <em>?GLU_OUTSIDE</em>, then any normals generated point along the +<em>z</em> axis. Otherwise, they point along the -<em>z</em> axis.</p><p>If texturing is turned on (with <strong>glu:quadricTexture/2</strong> ), texture coordinates are generated linearly such that where r=outer, the value at (<em>r</em>, 0, 0) is (1.0, 0.5), at (0, <em>r</em>, 0) it is (0.5, 1.0), at (-<em>r</em>, 0, 0) it is (0.0, 0.5), and at (0, -<em>r</em>, 0) it is (0.5, 0.0).</p><p>See external documentation.</p><p><strong></strong> perspective(Fovy, Aspect, ZNear, ZFar) -&gt; ok</p><p>Types:</p><p>Fovy = float()</p><p>Aspect = float()</p><p>ZNear = float()</p><p>ZFar = float()</p><p>Set up a perspective projection matrix</p><p><em>glu:perspective</em> specifies a viewing frustum into the world coordinate system. In general, the aspect ratio in <em>glu:perspective</em> should match the aspect ratio of the associated viewport. For example, aspect=2.0 means the viewer's angle of view is twice as wide in <em>x</em> as it is in <em>y</em>. If the viewport is twice as wide as it is tall, it displays the image without distortion.</p><p>The matrix generated by <em>glu:perspective</em> is multipled by the current matrix, just as if <strong>gl:multMatrixd/1</strong> were called with the generated matrix. To load the perspective matrix onto the current matrix stack instead, precede the call to <em>glu:perspective</em> with a call to <strong>gl:loadIdentity/0</strong> .</p><p>Given <em>f</em> defined as follows:</p><p>f=cotangent(fovy/2) The generated matrix is</p><p>(f/aspect 0 0 0 0 f 0 0 0 0(zFar+zNear)/(zNear-zFar)(2×zFar×zNear)/(zNear-zFar) 0 0 -1 0)</p><p>See external documentation.</p><p><strong></strong> pickMatrix(X, Y, DelX, DelY, Viewport) -&gt; ok</p><p>Types:</p><p>X = float()</p><p>Y = float()</p><p>DelX = float()</p><p>DelY = float()</p><p>Viewport = {integer(), integer(), integer(), integer()}</p><p>Define a picking region</p><p><em>glu:pickMatrix</em> creates a projection matrix that can be used to restrict drawing to a small region of the viewport. This is typically useful to determine what objects are being drawn near the cursor. Use <em>glu:pickMatrix</em> to restrict drawing to a small region around the cursor. Then, enter selection mode (with <strong>gl:renderMode/1</strong> ) and rerender the scene. All primitives that would have been drawn near the cursor are identified and stored in the selection buffer.</p><p>The matrix created by <em>glu:pickMatrix</em> is multiplied by the current matrix just as if <strong>gl:multMatrixd/1</strong> is called with the generated matrix. To effectively use the generated pick matrix for picking, first call <strong>gl:loadIdentity/0</strong> to load an identity matrix onto the perspective matrix stack. Then call <em>glu:pickMatrix</em>, and, finally, call a command (such as <strong>glu:perspective/4</strong> ) to multiply the perspective matrix by the pick matrix.</p><p>When using <em>glu:pickMatrix</em> to pick NURBS, be careful to turn off the NURBS property <em>?GLU_AUTO_LOAD_MATRIX</em>. If <em>?GLU_AUTO_LOAD_MATRIX</em> is not turned off, then any NURBS surface rendered is subdivided differently with the pick matrix than the way it was subdivided without the pick matrix.</p><p>See external documentation.</p><p><strong></strong> project(ObjX, ObjY, ObjZ, Model, Proj, View) -&gt; {integer(), WinX::float(), WinY::float(), WinZ::float()}</p><p>Types:</p><p>ObjX = float()</p><p>ObjY = float()</p><p>ObjZ = float()</p><p>Model = matrix()</p><p>Proj = matrix()</p><p>View = {integer(), integer(), integer(), integer()}</p><p>Map object coordinates to window coordinates</p><p><em>glu:project</em> transforms the specified object coordinates into window coordinates using <em>Model</em> , <em>Proj</em> , and <em>View</em> . The result is stored in <em>WinX</em> , <em>WinY</em> , and <em>WinZ</em> . A return value of <em>?GLU_TRUE</em> indicates success, a return value of <em>?GLU_FALSE</em> indicates failure.</p><p>To compute the coordinates, let v=(objX objY objZ 1.0) represented as a matrix with 4 rows and 1 column. Then <em>glu:project</em> computes v" as follows:</p><p>v"=P×M×v</p><p>where P is the current projection matrix <em>Proj</em> and M is the current modelview matrix <em>Model</em> (both represented as 4×4 matrices in column-major order).</p><p>The window coordinates are then computed as follows:</p><p>winX=<strong>view</strong>(0)+<strong>view</strong>(2)×(v"(0)+1)/2</p><p>winY=<strong>view</strong>(1)+view(3erl)×(v"(1)+1)/2</p><p>winZ=(v"(2)+1)/2</p><p>See external documentation.</p><p><strong></strong> quadricDrawStyle(Quad, Draw) -&gt; ok</p><p>Types:</p><p>Quad = integer()</p><p>Draw = enum()</p><p>Specify the draw style desired for quadrics</p><p><em>glu:quadricDrawStyle</em> specifies the draw style for quadrics rendered with <em>Quad</em> . The legal values are as follows:</p><p><em>?GLU_FILL</em>: Quadrics are rendered with polygon primitives. The polygons are drawn in a counterclockwise fashion with respect to their normals (as defined with <strong>glu:quadricOrientation/2</strong> ).</p><p><em>?GLU_LINE</em>: Quadrics are rendered as a set of lines.</p><p><em>?GLU_SILHOUETTE</em>: Quadrics are rendered as a set of lines, except that edges separating coplanar faces will not be drawn.</p><p><em>?GLU_POINT</em>: Quadrics are rendered as a set of points.</p><p>See external documentation.</p><p><strong></strong> quadricNormals(Quad, Normal) -&gt; ok</p><p>Types:</p><p>Quad = integer()</p><p>Normal = enum()</p><p>Specify what kind of normals are desired for quadrics</p><p><em>glu:quadricNormals</em> specifies what kind of normals are desired for quadrics rendered with <em>Quad</em> . The legal values are as follows:</p><p><em>?GLU_NONE</em>: No normals are generated.</p><p><em>?GLU_FLAT</em>: One normal is generated for every facet of a quadric.</p><p><em>?GLU_SMOOTH</em>: One normal is generated for every vertex of a quadric. This is the initial value.</p><p>See external documentation.</p><p><strong></strong> quadricOrientation(Quad, Orientation) -&gt; ok</p><p>Types:</p><p>Quad = integer()</p><p>Orientation = enum()</p><p>Specify inside/outside orientation for quadrics</p><p><em>glu:quadricOrientation</em> specifies what kind of orientation is desired for quadrics rendered with <em>Quad</em> . The <em>Orientation</em> values are as follows:</p><p><em>?GLU_OUTSIDE</em>: Quadrics are drawn with normals pointing outward (the initial value).</p><p><em>?GLU_INSIDE</em>: Quadrics are drawn with normals pointing inward.</p><p>Note that the interpretation of <em>outward</em> and <em>inward</em> depends on the quadric being drawn.</p><p>See external documentation.</p><p><strong></strong> quadricTexture(Quad, Texture) -&gt; ok</p><p>Types:</p><p>Quad = integer()</p><p>Texture = 0 | 1</p><p>Specify if texturing is desired for quadrics</p><p><em>glu:quadricTexture</em> specifies if texture coordinates should be generated for quadrics rendered with <em>Quad</em> . If the value of <em>Texture</em> is <em>?GLU_TRUE</em>, then texture coordinates are generated, and if <em>Texture</em> is <em>?GLU_FALSE</em>, they are not. The initial value is <em>?GLU_FALSE</em>.</p><p>The manner in which texture coordinates are generated depends upon the specific quadric rendered.</p><p>See external documentation.</p><p><strong></strong> scaleImage(Format, WIn, HIn, TypeIn, DataIn, WOut, HOut, TypeOut, DataOut) -&gt; integer()</p><p>Types:</p><p>Format = enum()</p><p>WIn = integer()</p><p>HIn = integer()</p><p>TypeIn = enum()</p><p>DataIn = binary()</p><p>WOut = integer()</p><p>HOut = integer()</p><p>TypeOut = enum()</p><p>DataOut = mem()</p><p>Scale an image to an arbitrary size</p><p><em>glu:scaleImage</em> scales a pixel image using the appropriate pixel store modes to unpack data from the source image and pack data into the destination image.</p><p>When shrinking an image, <em>glu:scaleImage</em> uses a box filter to sample the source image and create pixels for the destination image. When magnifying an image, the pixels from the source image are linearly interpolated to create the destination image.</p><p>A return value of zero indicates success, otherwise a GLU error code is returned (see <strong>glu:errorString/1</strong> ).</p><p>See the <strong>gl:readPixels/7</strong> reference page for a description of the acceptable values for the <em>Format</em> , <em>TypeIn</em> , and <em>TypeOut</em> parameters.</p><p>See external documentation.</p><p><strong></strong> sphere(Quad, Radius, Slices, Stacks) -&gt; ok</p><p>Types:</p><p>Quad = integer()</p><p>Radius = float()</p><p>Slices = integer()</p><p>Stacks = integer()</p><p>Draw a sphere</p><p><em>glu:sphere</em> draws a sphere of the given radius centered around the origin. The sphere is subdivided around the <em>z</em> axis into slices and along the <em>z</em> axis into stacks (similar to lines of longitude and latitude).</p><p>If the orientation is set to <em>?GLU_OUTSIDE</em> (with <strong>glu:quadricOrientation/2</strong> ), then any normals generated point away from the center of the sphere. Otherwise, they point toward the center of the sphere.</p><p>If texturing is turned on (with <strong>glu:quadricTexture/2</strong> ), then texture coordinates are generated so that <em>t</em> ranges from 0.0 at z=-radius to 1.0 at z=radius (<em>t</em> increases linearly along longitudinal lines), and <em>s</em> ranges from 0.0 at the +<em>y</em> axis, to 0.25 at the +<em>x</em> axis, to 0.5 at the -<em>y</em> axis, to 0.75 at the -<em>x</em> axis, and back to 1.0 at the +<em>y</em> axis.</p><p>See external documentation.</p><p><strong></strong> unProject(WinX, WinY, WinZ, Model, Proj, View) -&gt; {integer(), ObjX::float(), ObjY::float(), ObjZ::float()}</p><p>Types:</p><p>WinX = float()</p><p>WinY = float()</p><p>WinZ = float()</p><p>Model = matrix()</p><p>Proj = matrix()</p><p>View = {integer(), integer(), integer(), integer()}</p><p>Map window coordinates to object coordinates</p><p><em>glu:unProject</em> maps the specified window coordinates into object coordinates using <em>Model</em> , <em>Proj</em> , and <em>View</em> . The result is stored in <em>ObjX</em> , <em>ObjY</em> , and <em>ObjZ</em> . A return value of <em>?GLU_TRUE</em> indicates success; a return value of <em>?GLU_FALSE</em> indicates failure.</p><p>To compute the coordinates (objX objY objZ), <em>glu:unProject</em> multiplies the normalized device coordinates by the inverse of <em>Model</em> * <em>Proj</em> as follows:</p><p>(objX objY objZ W)=INV(P M) ((2(winX-view[0]))/(view[2])-1(2(winY-view[1]))/(view[3])-1 2(winZ)-1 1) INV denotes matrix inversion. W is an unused variable, included for consistent matrix notation.</p><p>See external documentation.</p><p><strong></strong> unProject4(WinX, WinY, WinZ, ClipW, Model, Proj, View, NearVal, FarVal) -&gt; {integer(), ObjX::float(), ObjY::float(), ObjZ::float(), ObjW::float()}</p><p>Types:</p><p>WinX = float()</p><p>WinY = float()</p><p>WinZ = float()</p><p>ClipW = float()</p><p>Model = matrix()</p><p>Proj = matrix()</p><p>View = {integer(), integer(), integer(), integer()}</p><p>NearVal = float()</p><p>FarVal = float()</p><p>See <strong>unProject/6</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p><em></em> &lt;&gt;</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="global_group.3erl.html"><span aria-hidden="true">&larr;</span> global_group.3erl: Grouping nodes to global name registration groups</a></li>
   <li class="next"><a href="gs.3erl.html">gs.3erl: The graphics system for erlang. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

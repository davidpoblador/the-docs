<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>xs_socket: Create crossroads socket</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Create crossroads socket">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="xs_socket (3) manual">
  <meta name="twitter:description" content="Create crossroads socket">
  <meta name="twitter:image" content="https://www.carta.tech/images/libxs-dev-xs_socket-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/xs_socket.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="xs_socket (3) manual" />
  <meta property="og:description" content="Create crossroads socket" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libxs-dev-xs_socket-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">xs_socket<small> (3)</small></h1>
        <p class="lead">Create crossroads socket</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/xs_socket.3.html">
      <span itemprop="name">xs_socket: Create crossroads socket</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libxs-dev/">
      <span itemprop="name">libxs-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/xs_socket.3.html">
      <span itemprop="name">xs_socket: Create crossroads socket</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>void *xs_socket (void </strong><strong></strong><em>*context</em><strong>, int </strong><strong></strong><em>type</em><strong>);</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The <em>xs_socket()</em> function shall create a Crossroads socket within the specified <em>context</em> and return an opaque handle to the newly created socket. The <em>type</em> argument specifies the socket type, which determines the semantics of communication over the socket.</p><p>The newly created socket is initially unbound, and not associated with any endpoints. In order to establish a message flow a socket must first be connected to at least one endpoint with <a href="../man3/xs_connect.3.html"><strong>xs_connect</strong>(3)</a>, or at least one endpoint must be created for accepting incoming connections with <a href="../man3/xs_bind.3.html"><strong>xs_bind</strong>(3)</a>.</p><p><strong>Key differences to conventional sockets</strong>. Generally speaking, conventional sockets present a <em>synchronous</em> interface to either connection-oriented reliable byte streams (SOCK_STREAM), or connection-less unreliable datagrams (SOCK_DGRAM). In comparison, Crossroads sockets present an abstraction of an asynchronous <em>message queue</em>, with the exact queueing semantics depending on the socket type in use. Where conventional sockets transfer streams of bytes or discrete datagrams, Crossroads sockets transfer discrete <em>messages</em>.</p><p>Crossroads sockets being <em>asynchronous</em> means that the timings of the physical connection setup and tear down, reconnect and effective delivery are transparent to the user and organized by Crossroads library itself. Further, messages may be <em>queued</em> in the event that a peer is unavailable to receive them.</p><p>Conventional sockets allow only strict one-to-one (two peers), many-to-one (many clients, one server), or in some cases one-to-many (multicast) relationships. With the exception of <em>XS_PAIR</em>, Crossroads sockets may be connected <strong>to multiple endpoints</strong> using <em>xs_connect()</em>, while simultaneously accepting incoming connections <strong>from multiple endpoints</strong> bound to the socket using <em>xs_bind()</em>, thus allowing many-to-many relationships.</p><p><strong>Thread safety</strong>. Crossroads <em>sockets</em> are <em>not</em> thread safe. Applications MUST NOT use a socket from multiple threads except after migrating a socket from one thread to another with a "full fence" memory barrier.</p><p><strong>Socket types</strong>. Crossroads defines several messaging patterns which encapsulate exact semantics of a particular topology. For example, publish-subscribe pattern defines data distribution trees while request-reply defines networks of shared stateless services. Each pattern defines several socket types (roles in the pattern).</p><p>The following sections present the socket types defined by Crossroads library:</p><h3>Request-reply pattern</h3>
<p>The request-reply pattern is used for sending requests from a <em>client</em> to one or more instances of a stateless <em>service</em>, and receiving subsequent replies to each request sent.</p><p><strong>XS_REQ</strong></p><p>A socket of type <em>XS_REQ</em> is used by a <em>client</em> to send requests to and receive replies from a <em>service</em>. This socket type allows only an alternating sequence of <em>xs_send(request)</em> and subsequent <em>xs_recv(reply)</em> calls. Each request sent is load-balanced among all <em>services</em>, and each reply received is matched with the last issued request.</p><p>When a <em>XS_REQ</em> socket enters an exceptional state due to having reached the high water mark for all <em>services</em>, or if there are no <em>services</em> at all, then any <a href="../man3/xs_send.3.html"><strong>xs_send</strong>(3)</a> operations on the socket shall block until the exceptional state ends or at least one <em>service</em> becomes available for sending; messages are not discarded.</p><p><strong>Table&nbsp;1.&nbsp;Summary of XS_REQ characteristics</strong></p><table class="table table-striped">
<tr>
<th>  Compatible peer sockets </th>
<th>  <em>XS_REP</em> </th></tr>

<tr>
<td>  Send/receive pattern </td>
<td>  Send, Receive, Send, Receive, ... </td></tr>

<tr>
<td>  Outgoing routing strategy </td>
<td>  Load-balanced </td></tr>

<tr>
<td>  Incoming routing strategy </td>
<td>  Last peer </td></tr>

<tr>
<td>  XS_HWM option action </td>
<td>  Block </td></tr>
</table><p><strong>XS_REP</strong></p><p>A socket of type <em>XS_REP</em> is used by a <em>service</em> to receive requests from and send replies to a <em>client</em>. This socket type allows only an alternating sequence of <em>xs_recv(request)</em> and subsequent <em>xs_send(reply)</em> calls. Each request received is fair-queued from among all <em>clients</em>, and each reply sent is routed to the <em>client</em> that issued the last request. If the original requester doesn\(cqt exist any more the reply is silently discarded.</p><p>When a <em>XS_REP</em> socket enters an exceptional state due to having reached the high water mark for a <em>client</em>, then any replies sent to the <em>client</em> in question shall be dropped until the exceptional state ends.</p><p><strong>Table&nbsp;2.&nbsp;Summary of XS_REP characteristics</strong></p><table class="table table-striped">
<tr>
<th>  Compatible peer sockets </th>
<th>  <em>XS_REQ</em> </th></tr>

<tr>
<td>  Send/receive pattern </td>
<td>  Receive, Send, Receive, Send, ... </td></tr>

<tr>
<td>  Incoming routing strategy </td>
<td>  Fair-queued </td></tr>

<tr>
<td>  Outgoing routing strategy </td>
<td>  Last peer </td></tr>

<tr>
<td>  XS_HWM option action </td>
<td>  Drop </td></tr>
</table><p><strong>XS_XREQ</strong></p><p>A socket of type <em>XS_XREQ</em> is a socket type underlying <em>XS_REQ</em>. It doesn\(cqt impose the strict order of sends and recvs as <em>XS_REQ</em> does and it is intended for use in intermediate devices in request-reply topologies.</p><p>Each message sent is load-balanced among all connected peers, and each message received is fair-queued from all connected peers.</p><p>When a <em>XS_XREQ</em> socket enters an exceptional state due to having reached the high water mark for all peers, or if there are no peers at all, then any <a href="../man3/xs_send.3.html"><strong>xs_send</strong>(3)</a> operations on the socket shall block until the exceptional state ends or at least one peer becomes available for sending; messages are not discarded.</p><p><strong>Table&nbsp;3.&nbsp;Summary of XS_XREQ characteristics</strong></p><table class="table table-striped">
<tr>
<th>  Compatible peer sockets </th>
<th>  <em>XS_XREP</em>, <em>XS_REP</em> </th></tr>

<tr>
<td>  Send/receive pattern </td>
<td>  Unrestricted </td></tr>

<tr>
<td>  Outgoing routing strategy </td>
<td>  Load-balanced </td></tr>

<tr>
<td>  Incoming routing strategy </td>
<td>  Fair-queued </td></tr>

<tr>
<td>  XS_HWM option action </td>
<td>  Block </td></tr>
</table><p><strong>XS_XREP</strong></p><p>A socket of type <em>XS_XREP</em> is a socket type underlying <em>XS_REP</em>. It doesn\(cqt impose the strict order of sends and recvs as <em>XS_REQ</em> does and it is intended for use in intermediate devices in request-reply topologies.</p><p>Messages received are fair-queued from among all connected peers. The outbound messages are routed to a specific peer, as explained below.</p><p>When a <em>XS_XREP</em> socket enters an exceptional state due to having reached the high water mark for all peers, or if there are no peers at all, then any messages sent to the socket shall be dropped until the exceptional state ends. Likewise, any messages to be routed to a non-existent peer or a peer for which the individual high water mark has been reached shall also be dropped.</p><p><strong>Table&nbsp;4.&nbsp;Summary of XS_XREP characteristics</strong></p><table class="table table-striped">
<tr>
<th>  Compatible peer sockets </th>
<th>  <em>XS_XREQ</em>, <em>XS_REQ</em> </th></tr>

<tr>
<td>  Send/receive pattern </td>
<td>  Unrestricted </td></tr>

<tr>
<td>  Outgoing routing strategy </td>
<td>  See text </td></tr>

<tr>
<td>  Incoming routing strategy </td>
<td>  Fair-queued </td></tr>

<tr>
<td>  XS_HWM option action </td>
<td>  Drop </td></tr>
</table>
<h3>Publish-subscribe pattern</h3>
<p>The publish-subscribe pattern is used for one-to-many distribution of data from a single <em>publisher</em> to multiple <em>subscribers</em> in a fan out fashion.</p><p><strong>XS_PUB</strong></p><p>A socket of type <em>XS_PUB</em> is used by a <em>publisher</em> to distribute data. Messages sent are distributed in a fan out fashion to all connected peers. The <a href="../man3/xs_recv.3.html"><strong>xs_recv</strong>(3)</a> function is not implemented for this socket type.</p><p>When a <em>XS_PUB</em> socket enters an exceptional state due to having reached the high water mark for a <em>subscriber</em>, then any messages that would be sent to the <em>subscriber</em> in question shall instead be dropped until the exceptional state ends. The <em>xs_send()</em> function shall never block for this socket type.</p><p><strong>Table&nbsp;5.&nbsp;Summary of XS_PUB characteristics</strong></p><table class="table table-striped">
<tr>
<th>  Compatible peer sockets </th>
<th>  <em>XS_SUB</em>, <em>XS_XSUB</em> </th></tr>

<tr>
<td>  Send/receive pattern </td>
<td>  Send only </td></tr>

<tr>
<td>  Incoming routing strategy </td>
<td>  N/A </td></tr>

<tr>
<td>  Outgoing routing strategy </td>
<td>  Fan out </td></tr>

<tr>
<td>  XS_HWM option action </td>
<td>  Drop </td></tr>
</table><p><strong>XS_SUB</strong></p><p>A socket of type <em>XS_SUB</em> is used by a <em>subscriber</em> to subscribe to data distributed by a <em>publisher</em>. Initially a <em>XS_SUB</em> socket is not subscribed to any messages, use the <em>XS_SUBSCRIBE</em> option of <a href="../man3/xs_setsockopt.3.html"><strong>xs_setsockopt</strong>(3)</a> to specify which messages to subscribe to. The <em>xs_send()</em> function is not implemented for this socket type.</p><p><strong>Table&nbsp;6.&nbsp;Summary of XS_SUB characteristics</strong></p><table class="table table-striped">
<tr>
<th>  Compatible peer sockets </th>
<th>  <em>XS_PUB</em>, <em>XS_XPUB</em> </th></tr>

<tr>
<td>  Send/receive pattern </td>
<td>  Receive only </td></tr>

<tr>
<td>  Incoming routing strategy </td>
<td>  Fair-queued </td></tr>

<tr>
<td>  Outgoing routing strategy </td>
<td>  N/A </td></tr>

<tr>
<td>  XS_HWM option action </td>
<td>  Drop </td></tr>
</table><p><strong>XS_XPUB</strong></p><p>Same as XS_PUB except that you can receive subscriptions from the peers in form of incoming messages. Subscription message is a byte 1 (for subscriptions) or byte 0 (for unsubscriptions) followed by the subscription body.</p><p><strong>Table&nbsp;7.&nbsp;Summary of XS_XPUB characteristics</strong></p><table class="table table-striped">
<tr>
<th>  Compatible peer sockets </th>
<th>  <em>XS_SUB</em>, <em>XS_XSUB</em> </th></tr>

<tr>
<td>  Send/receive pattern </td>
<td>  Send messages, receive subscriptions </td></tr>

<tr>
<td>  Incoming routing strategy </td>
<td>  N/A </td></tr>

<tr>
<td>  Outgoing routing strategy </td>
<td>  Fan out </td></tr>

<tr>
<td>  XS_HWM option action </td>
<td>  Drop </td></tr>
</table><p><strong>XS_XSUB</strong></p><p>Same as XS_SUB except that you subscribe by sending subscription messages to the socket. Subscription message is a byte 1 (for subscriptions) or byte 0 (for unsubscriptions) followed by the subscription body.</p><p><strong>Table&nbsp;8.&nbsp;Summary of XS_XSUB characteristics</strong></p><table class="table table-striped">
<tr>
<th>  Compatible peer sockets </th>
<th>  <em>XS_PUB</em>, <em>XS_XPUB</em> </th></tr>

<tr>
<td>  Send/receive pattern </td>
<td>  Receive messages, send subscriptions </td></tr>

<tr>
<td>  Incoming routing strategy </td>
<td>  Fair-queued </td></tr>

<tr>
<td>  Outgoing routing strategy </td>
<td>  N/A </td></tr>

<tr>
<td>  XS_HWM option action </td>
<td>  Drop </td></tr>
</table>
<h3>Pipeline pattern</h3>
<p>The pipeline pattern is used for distributing data to <em>nodes</em> arranged in a pipeline. Data always flows down the pipeline, and each stage of the pipeline is connected to at least one <em>node</em>. When a pipeline stage is connected to multiple <em>nodes</em> data is load-balanced among all connected <em>nodes</em>.</p><p><strong>XS_PUSH</strong></p><p>A socket of type <em>XS_PUSH</em> is used by a pipeline <em>node</em> to send messages to downstream pipeline <em>nodes</em>. Messages are load-balanced to all connected downstream <em>nodes</em>. The <em>xs_recv()</em> function is not implemented for this socket type.</p><p>When a <em>XS_PUSH</em> socket enters an exceptional state due to having reached the high water mark for all downstream <em>nodes</em>, or if there are no downstream <em>nodes</em> at all, then any <a href="../man3/xs_send.3.html"><strong>xs_send</strong>(3)</a> operations on the socket shall block until the exceptional state ends or at least one downstream <em>node</em> becomes available for sending; messages are not discarded.</p><p><strong>Table&nbsp;9.&nbsp;Summary of XS_PUSH characteristics</strong></p><table class="table table-striped">
<tr>
<th>  Compatible peer sockets </th>
<th>  <em>XS_PULL</em> </th></tr>

<tr>
<td>  Direction </td>
<td>  Unidirectional </td></tr>

<tr>
<td>  Send/receive pattern </td>
<td>  Send only </td></tr>

<tr>
<td>  Incoming routing strategy </td>
<td>  N/A </td></tr>

<tr>
<td>  Outgoing routing strategy </td>
<td>  Load-balanced </td></tr>

<tr>
<td>  XS_HWM option action </td>
<td>  Block </td></tr>
</table><p><strong>XS_PULL</strong></p><p>A socket of type <em>XS_PULL</em> is used by a pipeline <em>node</em> to receive messages from upstream pipeline <em>nodes</em>. Messages are fair-queued from among all connected upstream <em>nodes</em>. The <em>xs_send()</em> function is not implemented for this socket type.</p><p><strong>Table&nbsp;10.&nbsp;Summary of XS_PULL characteristics</strong></p><table class="table table-striped">
<tr>
<th>  Compatible peer sockets </th>
<th>  <em>XS_PUSH</em> </th></tr>

<tr>
<td>  Direction </td>
<td>  Unidirectional </td></tr>

<tr>
<td>  Send/receive pattern </td>
<td>  Receive only </td></tr>

<tr>
<td>  Incoming routing strategy </td>
<td>  Fair-queued </td></tr>

<tr>
<td>  Outgoing routing strategy </td>
<td>  N/A </td></tr>

<tr>
<td>  XS_HWM option action </td>
<td>  N/A </td></tr>
</table>
<h3>Survey pattern</h3>
<p>Survey pattern can be used to post a survey to a set of notes and collect responses from them. The survey is distributed from surveyor to all connected respondents. Responses are routed back to the original surveyor.</p><p><strong>XS_SURVEYOR</strong></p><p>XS_SURVEYOR socket type can be used to send surveys to all respondents in the topology and receive the replies from all of them. Each survey sent is distributed to all connected peers, and incoming replies are fair-queue. As you don\(cqt know the number of respondents in the topology you don\(cqt know the number of responses you are going to get, therefore you should use XS_SURVEY_TIMEOUT socket option to set the deadline for the survey.</p><p><strong>Table&nbsp;11.&nbsp;Summary of XS_SURVEYOR characteristics</strong></p><table class="table table-striped">
<tr>
<th>  Compatible peer sockets </th>
<th>  <em>XS_RESPONDENT</em>, <em>XS_XRESPONDENT</em> </th></tr>

<tr>
<td>  Direction </td>
<td>  Bidirectional </td></tr>

<tr>
<td>  Send/receive pattern </td>
<td>  Send one message, receive many messages. </td></tr>

<tr>
<td>  Incoming routing strategy </td>
<td>  Fair-queued </td></tr>

<tr>
<td>  Outgoing routing strategy </td>
<td>  Fan out </td></tr>

<tr>
<td>  XS_HWM option action </td>
<td>  Drop </td></tr>
</table><p><strong>XS_RESPONDENT</strong></p><p>This socket type receives surveys from surveyors and sends responses. Incoming surveys are fair-queued. Outgoing responses are routed back to the original surveyor.</p><p><strong>Table&nbsp;12.&nbsp;Summary of XS_RESPONDENT characteristics</strong></p><table class="table table-striped">
<tr>
<th>  Compatible peer sockets </th>
<th>  <em>XS_SURVEYOR</em>, <em>XS_XSURVEYOR</em> </th></tr>

<tr>
<td>  Direction </td>
<td>  Bidirectional </td></tr>

<tr>
<td>  Send/receive pattern </td>
<td>  Receive a survey, send one response. </td></tr>

<tr>
<td>  Incoming routing strategy </td>
<td>  Fair-queued </td></tr>

<tr>
<td>  Outgoing routing strategy </td>
<td>  Last peer </td></tr>

<tr>
<td>  XS_HWM option action </td>
<td>  Drop </td></tr>
</table><p><strong>XS_XSURVEYOR</strong></p><p>A socket of type <em>XS_XSURVEYOR</em> is a socket type underlying <em>XS_SURVEYOR</em>. It doesn\(cqt impose the strict order of sends and recvs as <em>XS_SURVEYOR</em> does and it is intended for use in intermediate devices in survey topologies.</p><p><strong>Table&nbsp;13.&nbsp;Summary of XS_XSURVEYOR characteristics</strong></p><table class="table table-striped">
<tr>
<th>  Compatible peer sockets </th>
<th>  <em>XS_RESPONDENT</em>, <em>XS_XRESPONDENT</em> </th></tr>

<tr>
<td>  Direction </td>
<td>  Bidirectional </td></tr>

<tr>
<td>  Send/receive pattern </td>
<td>  Send surveys, receive responses. </td></tr>

<tr>
<td>  Incoming routing strategy </td>
<td>  Fair-queued </td></tr>

<tr>
<td>  Outgoing routing strategy </td>
<td>  Fan out </td></tr>

<tr>
<td>  XS_HWM option action </td>
<td>  Drop </td></tr>
</table><p><strong>XS_XRESPONDENT</strong></p><p>A socket of type <em>XS_XRESPONDENT</em> is a socket type underlying <em>XS_RESPONDENT</em>. It doesn\(cqt impose the strict order of sends and recvs as <em>XS_RESPONDENT</em> does and it is intended for use in intermediate devices in survey topologies.</p><p>Incoming surveys are fair-queued. Each survey is prefixed by a message part identifying the surveyor it was received from. Outgoing responses are routed to the original surveyor based on the first message part.</p><p><strong>Table&nbsp;14.&nbsp;Summary of XS_XRESPONDENT characteristics</strong></p><table class="table table-striped">
<tr>
<th>  Compatible peer sockets </th>
<th>  <em>XS_SURVEYOR</em>, <em>XS_XSURVEYOR</em> </th></tr>

<tr>
<td>  Direction </td>
<td>  Bidirectional </td></tr>

<tr>
<td>  Send/receive pattern </td>
<td>  Receive surveys, send responses. </td></tr>

<tr>
<td>  Incoming routing strategy </td>
<td>  Fair-queued </td></tr>

<tr>
<td>  Outgoing routing strategy </td>
<td>  See text </td></tr>

<tr>
<td>  XS_HWM option action </td>
<td>  Drop </td></tr>
</table>
<h3>Exclusive pair pattern</h3>
<p>The exclusive pair is an advanced pattern used for communicating exclusively between two peers.</p><p><strong>XS_PAIR</strong></p><p>A socket of type <em>XS_PAIR</em> can only be connected to a single peer at any one time. No message routing or filtering is performed on messages sent over a <em>XS_PAIR</em> socket.</p><p>When a <em>XS_PAIR</em> socket enters an exceptional state due to having reached the high water mark for the connected peer, or if no peer is connected, then any <a href="../man3/xs_send.3.html"><strong>xs_send</strong>(3)</a> operations on the socket shall block until the peer becomes available for sending; messages are not discarded.</p><p><strong>Note</strong></p><p><em>XS_PAIR</em> sockets are experimental, and are currently missing several features such as auto-reconnection.</p><p><strong>Table&nbsp;15.&nbsp;Summary of XS_PAIR characteristics</strong></p><table class="table table-striped">
<tr>
<th>  Compatible peer sockets </th>
<th>  <em>XS_PAIR</em> </th></tr>

<tr>
<td>  Direction </td>
<td>  Bidirectional </td></tr>

<tr>
<td>  Send/receive pattern </td>
<td>  Unrestricted </td></tr>

<tr>
<td>  Incoming routing strategy </td>
<td>  N/A </td></tr>

<tr>
<td>  Outgoing routing strategy </td>
<td>  N/A </td></tr>

<tr>
<td>  XS_HWM option action </td>
<td>  Block </td></tr>
</table>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>The <em>xs_socket()</em> function shall return an opaque handle to the newly created socket if successful. Otherwise, it shall return NULL and set <em>errno</em> to one of the values defined below.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ERRORS</h2>
        <div class="sectioncontent">
<p><strong>EINVAL</strong></p><p>The requested socket <em>type</em> is invalid.</p><p><strong>EFAULT</strong></p><p>The provided <em>context</em> is invalid.</p><p><strong>EMFILE</strong></p><p>The limit on the total number of open Crossroads sockets has been reached.</p><p><strong>ETERM</strong></p><p>The context specified was terminated.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO xs_socket&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man3/xs_init.3.html"><strong>xs_init</strong>(3)</a> <a href="../man3/xs_setsockopt.3.html"><strong>xs_setsockopt</strong>(3)</a> <a href="../man3/xs_bind.3.html"><strong>xs_bind</strong>(3)</a> <a href="../man3/xs_connect.3.html"><strong>xs_connect</strong>(3)</a> <a href="../man3/xs_send.3.html"><strong>xs_send</strong>(3)</a> <a href="../man3/xs_recv.3.html"><strong>xs_recv</strong>(3)</a> <strong>xs</strong>(7)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p>The Crossroads documentation was written by Martin Sustrik &lt;\m[blue]<strong>sustrik@250bpm.com</strong>\m[]\s-2\u[1]\d\s+2&gt; and Martin Lucina &lt;\m[blue]<strong>martin@lucina.net</strong>\m[]\s-2\u[2]\d\s+2&gt;.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTES</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
     1.
  </dt>
  <dd>
    <p>sustrik@250bpm.com</p><p>mailto:sustrik@250bpm.com</p>
  </dd>
  <dt>
     2.
  </dt>
  <dd>
    <p>martin@lucina.net</p><p>mailto:martin@lucina.net</p>
  </dd>

</dl>

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="xs_shutdown.3.html"><span aria-hidden="true">&larr;</span> xs_shutdown.3: Shut down part of the socket</a></li>
   <li class="next"><a href="xs_strerror.3.html">xs_strerror.3: Get error message string <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

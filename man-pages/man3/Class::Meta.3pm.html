<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Class::Meta: Class automation, introspection, and data validation</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Class automation, introspection, and data validation">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Class::Meta (3pm) manual">
  <meta name="twitter:description" content="Class automation, introspection, and data validation">
  <meta name="twitter:image" content="https://www.carta.tech/images/libclass-meta-perl-Class::Meta-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Class::Meta.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Class::Meta (3pm) manual" />
  <meta property="og:description" content="Class automation, introspection, and data validation" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libclass-meta-perl-Class::Meta-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Class::Meta<small> (3pm)</small></h1>
        <p class="lead">Class automation, introspection, and data validation</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Class::Meta.3pm.html">
      <span itemprop="name">Class::Meta: Class automation, introspection, and data validation</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libclass-meta-perl/">
      <span itemprop="name">libclass-meta-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Class::Meta.3pm.html">
      <span itemprop="name">Class::Meta: Class automation, introspection, and data validation</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>Generate a class:</p>
<pre>
  package MyApp::Thingy;
  use strict;
  use Class::Meta;

  BEGIN {

      # Create a Class::Meta object for this class.
      my $cm = Class::Meta-&gt;new(
          key          =&gt; &apos;thingy&apos;,
          default_type =&gt; &apos;string&apos;,
      );

      # Add a constructor.
      $cm-&gt;add_constructor(
          name   =&gt; &apos;new&apos;,
          create =&gt; 1,
      );

      # Add a couple of attributes with generated methods.
      $cm-&gt;add_attribute(
          name     =&gt; &apos;uuid&apos;,
          authz    =&gt; &apos;READ&apos;,
          required =&gt; 1,
          default  =&gt; sub { Data::UUID-&gt;new-&gt;create_str },
      );
      $cm-&gt;add_attribute(
          name     =&gt; &apos;name&apos;,
          is       =&gt; &apos;string&apos;,
          default  =&gt; undef,
      );
      $cm-&gt;add_attribute(
          name    =&gt; &apos;age&apos;,
          is      =&gt; &apos;integer&apos;,
          default =&gt; undef,
      );

      # Add a custom method.
      $cm-&gt;add_method(
          name =&gt; &apos;chk_pass&apos;,
          view =&gt; &apos;PUBLIC&apos;,
          code =&gt; sub { ... },
      );

      $cm-&gt;build;
  }

  sub chck_pass { ... }
</pre>
<p>Or use Class::Meta::Express for a more pleasant declarative syntax (highly recommended!):</p><p>  package MyApp::Thingy;   use strict;   use Class::Meta::Express;</p><p>  class {       meta thingy =&gt; ( default_type =&gt; &apos;string&apos; );       ctor &apos;new&apos;;       has  uuid =&gt; (         authz    =&gt; &apos;READ&apos;,         required =&gt; 1,         default =&gt; sub { Data::UUID-&gt;new-&gt;create_str },       );       has name =&gt; ( required =&gt; 1         );       has age  =&gt; ( is       =&gt; &apos;integer&apos; );       method chk_pass =&gt; sub { ... }   };</p><p>Now isn't that nicer? Then use the class:</p><p>  use MyApp::Thingy;</p><p>  my $thingy = MyApp::Thingy-&gt;new( id =&gt; 19 );   print "ID: ", $thingy-&gt;id, $/;   $thingy-&gt;name(&apos;Larry&apos;);   print "Name: ", $thingy-&gt;name, $/;   $thingy-&gt;age(42);   print "Age: ", $thingy-&gt;age, $/;</p><p>Or make use of the introspection \s-1API:\s0</p><p>  use MyApp::Thingy;</p><p>  my $class = MyApp::Thingy-&gt;my_class;   my $thingy;</p><p>  print "Examining object of class ", $class-&gt;package, $/;</p><p>  print "&#92;nConstructors:&#92;n";   for my $ctor ($class-&gt;constructors) {       print "  o ", $ctor-&gt;name, $/;       $thingy = $ctor-&gt;call($class-&gt;package);   }</p><p>  print "&#92;nAttributes:&#92;n";   for my $attr ($class-&gt;attributes) {       print "  o ", $attr-&gt;name, " =&gt; ", $attr-&gt;get($thingy), $/;       if ($attr-&gt;authz &gt;= Class::Meta::SET && $attr-&gt;type eq &apos;string&apos;) {           $attr-&gt;get($thingy, &apos;hey there!&apos;);           print "    Changed to: ", $attr-&gt;get($thingy), $/;       }   }</p><p>  print "&#92;nMethods:&#92;n";   for my $meth ($class-&gt;methods) {       print "  o ", $meth-&gt;name, $/;       $meth-&gt;call($thingy);   }</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Class::Meta provides an interface for automating the creation of Perl classes with attribute data type validation. It differs from other such modules in that it includes an introspection \s-1API\s0 that can be used as a unified interface for all Class::Meta-generated classes. In this sense, it is an implementation of the \*(L"Facade\*(R" design pattern.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">USAGE</h2>
        <div class="sectioncontent">
<p>Before we get to the introspection \s-1API\s0, let's take a look at how to create classes with Class::Meta. Unlike many class automation modules for Perl, the classes that Class::Meta builds do not inherit from Class::Meta. This frees you from any dependencies on the interfaces that such a base class might compel. For example, you can create whatever constructors you like, and name them whatever you like.</p><p>First of all, you really want to be using Class::Meta::Express to declare your Class::Meta classes. It provides a much more pleasant class declaration experience than Class::Meta itself does. But since its functions support many of the same arguments as the declaration methods described here, it's worth it to skim the notes here, as well. Or if you're just a masochist and want to use the Class::Meta interface itself, well, read on!</p><p>I recommend that you create your Class::Meta classes in a \*(C`BEGIN\*(C' block. Although this is not strictly necessary, it helps ensure that the classes you're building are completely constructed and ready to go by the time compilation has completed. Creating classes with Class::Meta is easy, using the Class::Meta object oriented interface. Here is an example of a very simple class:</p><p>  package MyApp::Dog;   use strict;   use Class::Meta;   use Class::Meta::Types::Perl;</p><p>  BEGIN {</p><p>      # Create a Class::Meta object for this class.       my $cm = Class::Meta-&gt;new( key =&gt; &apos;dog&apos; );</p><p>      # Add a constructor.       $cm-&gt;add_constructor(           name   =&gt; &apos;new&apos;,           create =&gt; 1,       );</p><p>      # Add an attribute.       $cm-&gt;add_attribute(           name =&gt; &apos;tail&apos;,           type =&gt; &apos;scalar&apos;,       );</p><p>      # Add a custom method.       $cm-&gt;add_method( name =&gt; &apos;wag&apos; );       $cm-&gt;build;   }</p><p>  sub wag {       my $self = shift;       print "Wagging ", $self-&gt;tail;   }</p><p>This simple example shows of the construction of all three types of objects supported by Class::Meta: constructors, attributes, and methods. Here's how it does it:</p><ul>
<li><p>First we load Class::Meta and Class::Meta::Types::Perl. The latter module creates data types that can be used for attributes, including a \*(L"scalar\*(R" data type.</p></li><li><p>Second, we create a Class::Meta object. It's okay to create it within the \*(C`BEGIN\*(C' block, as it won't be needed beyond that. All Class::Meta classes have a \*(C`key\*(C' that uniquely identifies them across an application. If none is provided, the class name will be used, instead.</p></li><li><p>Next, we create a Class::Meta::Constructor object to describe a constructor method for the class. The \*(C`create\*(C' parameter to the \*(C`add_constructor()\*(C' method tells Class::Meta to create the constructor named "\*(C`new()\*(C'".</p></li><li><p>Then we call \*(C`add_attribute()\*(C' to create a single attribute, \*(L"tail\*(R". This is a simple scalar attribute, meaning that any scalar value can be stored in it. Class::Meta will create a Class::Meta::Attribute object that describes this attribute, and will also shortly create accessor methods for the attribute.</p></li><li><p>The \*(C`add_method()\*(C' method constructs a Class::Meta::Method object to describe any methods written for the class. In this case, we've told Class::Meta that there will be a \*(C`wag()\*(C' method.</p></li><li><p>And finally, we tell Class::Meta to build the class. This is the point at which all constructors and accessor methods will be created in the class. In this case, these include the \*(C`new()\*(C' constructor and a \*(C`tail()\*(C' accessor for the \*(L"tail\*(R" attribute. And finally, Class::Meta will install another method, \*(C`my_class()\*(C'. This method will return a Class::Meta::Class object that describes the class, and provides the complete introspection \s-1API\s0.</p></li>
</ul><p>Thus, the class the above code creates has this interface:</p><p>  sub my_class;   sub new;   sub tail;   sub wag;</p><h3>Data Types</h3>
<p>By default, Class::Meta loads no data types. If you attempt to create an attribute without creating or loading the appropriate data type, you will get an error.</p><p>But I didn't want to leave you out in the cold, so I created a whole bunch of data types to get you started. Any of these will automatically be loaded by Class::Meta if it is used to create an attribute. They can also be loaded simply by \*(C`use\*(C'ing the appropriate module. The modules are:</p>
<dl class='dl-vertical'>
  <dt>
    Class::Meta::Types::Perl
  </dt>
  <dd>
    <p>Typical Perl data types.</p>
<dl class='dl-vertical'>
  <dt>
    scalar
  </dt>
  <dd>
    <p>Any scalar value.</p>
  </dd>
  <dt>
    scalarref
  </dt>
  <dd>
    <p>A scalar reference.</p>
  </dd>
  <dt>
    array
  </dt>
  <dd>
    
  </dd>
  <dt>
    arrayref
  </dt>
  <dd>
    <p>An array reference.</p>
  </dd>
  <dt>
    hash
  </dt>
  <dd>
    
  </dd>
  <dt>
    hashref
  </dt>
  <dd>
    <p>A hash reference.</p>
  </dd>
  <dt>
    code
  </dt>
  <dd>
    
  </dd>
  <dt>
    coderef
  </dt>
  <dd>
    
  </dd>
  <dt>
    closure
  </dt>
  <dd>
    <p>A code reference.</p>
  </dd>

</dl>

  </dd>
  <dt>
    Class::Meta::Types::String
  </dt>
  <dd>
    
<dl class='dl-vertical'>
  <dt>
    string
  </dt>
  <dd>
    <p>Attributes of this type must contain a string value. Essentially, this means anything other than a reference.</p>
  </dd>

</dl>

  </dd>
  <dt>
    Class::Meta::Types::Boolean
  </dt>
  <dd>
    
<dl class='dl-vertical'>
  <dt>
    boolean
  </dt>
  <dd>
    
  </dd>
  <dt>
    bool
  </dt>
  <dd>
    <p>Attributes of this type store a boolean value. Implementation-wise, this means either a 1 or a 0.</p>
  </dd>

</dl>

  </dd>
  <dt>
    Class::Meta::Types::Numeric
  </dt>
  <dd>
    <p>These data types are validated by the functions provided by Data::Types.</p>
<dl class='dl-vertical'>
  <dt>
    whole
  </dt>
  <dd>
    <p>A whole number.</p>
  </dd>
  <dt>
    integer
  </dt>
  <dd>
    <p>An integer.</p>
  </dd>
  <dt>
    decimal
  </dt>
  <dd>
    <p>A decimal number.</p>
  </dd>
  <dt>
    real
  </dt>
  <dd>
    <p>A real number.</p>
  </dd>
  <dt>
    float
  </dt>
  <dd>
    <p>a floating point number.</p>
  </dd>

</dl>

  </dd>

</dl>
<p>Other data types may be added in the future. See the individual data type modules for more information.</p>
<h3>Accessors</h3>
<p>Class::Meta supports the creation of three different types of attribute accessors: typical Perl single-method accessors, \*(L"affordance\*(R" accessors, and \*(L"semi-affordance\*(R" accessors. The single accessors are named for their attributes, and typically tend to look like this:</p><p>  sub tail {       my $self = shift;       return $self-&gt;{tail} unless @_;       return $self-&gt;{tail} = shift;   }</p><p>Although this can be an oversimplification if the data type has associated validation checks.</p><p>Affordance accessors provide at up to two accessors for every attribute: One to set the value and one to retrieve the value. They tend to look like this:</p><p>  sub get_tail { shift-&gt;{tail} }</p><p>  sub set_tail { shift-&gt;{tail} = shift }</p><p>These accessors offer a bit less overhead than the traditional Perl accessors, in that they don't have to check whether they're called to get or set a value. They also have the benefit of creating a psychological barrier to misuse. Since traditional Perl accessors <em>can</em> be created as read-only or write-only accessors, one can't tell just by looking at them which is the case. The affordance accessors make this point moot, as they make clear what their purpose is.</p><p>Semi-affordance accessors are similar to affordance accessors in that they provide at least two accessors for every attribute. However, the accessor that fetches the value is named for the attribute. Thus, they tend to look like this:</p><p>  sub tail { shift-&gt;{tail} }</p><p>  sub set_tail { shift-&gt;{tail} = shift }</p><p>To get Class::Meta's data types to create affordance accessors, simply pass the string \*(L"affordance\*(R" to them when you load them:</p><p>  use Class::Meta::Types::Perl &apos;affordance&apos;;</p><p>Likewise, to get them to create semi-affordance accessors, pass the string \*(L"semi-affordance\*(R":</p><p>  use Class::Meta::Types::Perl &apos;semi-affordance&apos;;</p><p>The boolean data type is the only one that uses a slightly different approach to the creation of affordance accessors: It creates three of them. Assuming you're creating a boolean attribute named \*(L"alive\*(R", it will create these accessors:</p><p>  sub is_alive      { shift-&gt;{alive} }   sub set_alive_on  { shift-&gt;{alive} = 1 }   sub set_alive_off { shift-&gt;{alive} = 0 }</p><p>Incidentally, I stole the term \*(L"affordance\*(R" from Damian Conway's \*(L"Object Oriented Perl,\*(R" pp 83-84, where he borrows it from Donald Norman.</p><p>See Class::Meta::Type for details on creating new data types.</p>
<h3>Introspection \s-1API\s0</h3>
<p>Class::Meta provides four classes the make up the introspection \s-1API\s0 for Class::Meta-generated classes. Those classes are:</p><p><em>Class::Meta::Class</em></p><p>Describes the class. Each Class::Meta-generated class has a single constructor object that can be retrieved by calling a class' \*(C`my_class()\*(C' class method. Using the Class::Meta::Class object, you can get access to all of the other objects that describe the class. The relevant methods are:</p>
<dl class='dl-vertical'>
  <dt>
    constructors
  </dt>
  <dd>
    <p>Provides access to all of the Class::Meta::Constructor objects that describe the class' constructors, and provide indirect access to those constructors.</p>
  </dd>
  <dt>
    attributes
  </dt>
  <dd>
    <p>Provides access to all of the Class::Meta::Attribute objects that describe the class' attributes, and provide methods for indirectly getting and setting their values.</p>
  </dd>
  <dt>
    methods
  </dt>
  <dd>
    <p>Provides access to all of the Class::Meta::Method objects that describe the class' methods, and provide indirect execution of those constructors.</p>
  </dd>

</dl>
<p><em>Class::Meta::Constructor</em></p><p>Describes a class constructor. Typically a class will have only a single constructor, but there could be more, and client code doesn't necessarily know its name. Class::Meta::Constructor objects resolve these issues by describing all of the constructors in a class. The most useful methods are:</p>
<dl class='dl-vertical'>
  <dt>
    name
  </dt>
  <dd>
    <p>Returns the name of the constructor, such as \*(L"new\*(R".</p>
  </dd>
  <dt>
    call
  </dt>
  <dd>
    <p>Calls the constructor on an object, passing in the arguments passed to \*(C`call()\*(C' itself.</p>
  </dd>

</dl>
<p><em>Class::Meta::Attribute</em></p><p>Describes a class attribute, including its name and data type. Attribute objects are perhaps the most useful Class::Meta objects, in that they can provide a great deal of information about the structure of a class. The most interesting methods are:</p>
<dl class='dl-vertical'>
  <dt>
    name
  </dt>
  <dd>
    <p>Returns the name of the attribute.</p>
  </dd>
  <dt>
    type
  </dt>
  <dd>
    <p>Returns the name of the attribute's data type.</p>
  </dd>
  <dt>
    required
  </dt>
  <dd>
    <p>Returns true if the attribute is required to have a value.</p>
  </dd>
  <dt>
    once
  </dt>
  <dd>
    <p>Returns true if the attribute value can be set to a defined value only once.</p>
  </dd>
  <dt>
    set
  </dt>
  <dd>
    <p>Sets the value of an attribute on an object.</p>
  </dd>
  <dt>
    get
  </dt>
  <dd>
    <p>Returns the value of an attribute on an object.</p>
  </dd>

</dl>
<p><em>Class::Meta::Method</em></p><p>Describes a method of a class, including its name and context (class vs. instance). The relevant methods are:</p>
<dl class='dl-vertical'>
  <dt>
    name
  </dt>
  <dd>
    <p>The method name.</p>
  </dd>
  <dt>
    context
  </dt>
  <dd>
    <p>The context of the method indicated by a value corresponding to either Class::Meta::OBJECT or Class::Meta::CLASS.</p>
  </dd>
  <dt>
    call
  </dt>
  <dd>
    <p>Calls the method, passing in the arguments passed to \*(C`call()\*(C' itself.</p>
  </dd>

</dl>
<p>Consult the documentation of the individual classes for a complete description of their interfaces.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">INTERFACE</h2>
        <div class="sectioncontent">
<h3>Class Methods</h3>
<p><em>default_error_handler</em></p><p>  Class::Meta-&gt;default_error_handler($code);   my $default_error_handler = Class::Meta-&gt;default_error_handler;</p><p>Sets the default error handler for Class::Meta classes. If no \*(C`error_handler\*(C' attribute is passed to new, then this error handler will be associated with the new class. The default default error handler uses \*(C`Carp::croak()\*(C' to handle errors.</p><p>Note that if other modules are using Class::Meta that they will use your default error handler unless you reset the default error handler to its original value before loading them.</p><p><em>handle_error</em></p><p>  Class::Meta-&gt;handle_error($err);</p><p>Uses the code reference returned by \*(C`default_error_handler()\*(C' to handle an error. Used internally Class::Meta classes when no Class::Meta::Class object is available. Probably not useful outside of Class::Meta unless you're creating your own accessor generation class. Use the \*(C`handle_error()\*(C' instance method in Class::Meta::Class, instead.</p><p><em>for_key</em></p><p>  my $class = Class::Meta-&gt;for_key($key);</p><p>Returns the Class::Meta::Class object for a class by its key name. This can be useful in circumstances where the key has been used to track a class, and you need to get a handle on that class. With the class package name, you can of course simply call \*(C`$pkg-&gt;my_class\*(C'; this method is the solution for getting the class object for a class key.</p><p><em>keys</em></p><p>  my @keys = Class::Meta-&gt;keys;</p><p>Returns the keys for all Class::Meta::Class objects.  The order of keys is not guaranteed.  In scalar context, this method returns an array reference containing the keys.</p><p><em>clear</em></p><p>  Class::Meta-&gt;clear;   Class::Meta-&gt;clear($key);</p><p>Called without arguments, \*(C`clear\*(C' will remove all Class::Meta::Class objects from memory. Called with an argument, \*(C`clear\*(C' attempts to remove only that key from memory. Calling it with a non-existent key is a no-op.</p><p>In general, you probably won't want to use this method, except perhaps in tests, when you might need to do funky things with your classes.</p>
<h3>Constructors</h3>
<p><em>new</em></p><p>  my $cm = Class::Meta-&gt;new( key =&gt; $key );</p><p>Constructs and returns a new Class::Meta object that can then be used to define and build the complete interface of a class. Many of the supported parameters values will default to values specified for the most immediate Class::Meta-built parent class, if any. The supported parameters are:</p>
<dl class='dl-vertical'>
  <dt>
    package
  </dt>
  <dd>
    <p>The package that defines the class. Defaults to the package of the code that calls \*(C`new()\*(C'.</p>
  </dd>
  <dt>
    key
  </dt>
  <dd>
    <p>A key name that uniquely identifies a class within an application. Defaults to the value of the \*(C`package\*(C' parameter if not specified.</p>
  </dd>
  <dt>
    name
  </dt>
  <dd>
    <p>The human name to use for the class. Defaults to the value of \*(C`key\*(C' with underscores replaced with spaces and each word capitalized by the \*(C`ucfirst\*(C' operator. So \*(L"foo\*(R" will become \*(L"Foo\*(R" and \*(L"contact_type\*(R" will become \*(L"Contact Type\*(R".</p>
  </dd>
  <dt>
    abstract
  </dt>
  <dd>
    <p>A boolean indicating whether the class being defined is an abstract class. An abstract class, also known as a \*(L"virtual\*(R" class, is not intended to be used directly. No objects of an abstract class should every be created. Instead, classes that inherit from an abstract class must be implemented.</p>
  </dd>
  <dt>
    default_type
  </dt>
  <dd>
    <p>A data type to use for attributes added to the class with no explicit data type. See \*(L"Data Types\*(R" for some possible values for this parameter. Inheritable from parent class.</p>
  </dd>
  <dt>
    trust
  </dt>
  <dd>
    <p>An array reference of key names or packages that are trusted by the class.   trust =&gt; [&apos;Foo::Bar&apos;, &apos;Foo::Bat&apos;], Trusted packages and the classes that inherit from them can retrieve trusted attributes and methods of the class. Trusted packages need not be Class::Meta classes. Trusted classes do not include the declaring class by default, so if you want the class that declares an attribute to be able to use trusted attribute accessors, be sure to include it in the list of trusted packages:   trust =&gt; [_\|_PACKAGE_\|_, &apos;Foo::Bar&apos;, &apos;Foo::Bat&apos;], If you need to trust a single class, you may pass in the key name or package of that class rather than an array reference:   trust =&gt; &apos;Foo::Bar&apos;,</p>
  </dd>
  <dt>
    class_class
  </dt>
  <dd>
    <p>The name of a class that inherits from Class::Meta::Class to be used to create all of the class objects for the class. Defaults to Class::Meta::Class. Inheritable from parent class.</p>
  </dd>
  <dt>
    constructor_class
  </dt>
  <dd>
    <p>The name of a class that inherits from Class::Meta::Constructor to be used to create all of the constructor objects for the class. Defaults to Class::Meta::Constructor. Inheritable from parent class.</p>
  </dd>
  <dt>
    attribute_class
  </dt>
  <dd>
    <p>The name of a class that inherits from Class::Meta::Attribute to be used to create all of the attribute objects for the class. Defaults to Class::Meta::Attribute. Inheritable from parent class.</p>
  </dd>
  <dt>
    method_class
  </dt>
  <dd>
    <p>The name of a class that inherits from Class::Meta::Method to be used to create all of the method objects for the class. Defaults to Class::Meta::Method. Inheritable from parent class.</p>
  </dd>
  <dt>
    error_handler
  </dt>
  <dd>
    <p>A code reference that will be used to handle errors thrown by the methods created for the new class. Defaults to the value returned by \*(C`Class::Meta-&gt;default_error_handler\*(C'. Inheritable from parent class.</p>
  </dd>

</dl>
<p><em>add_constructor</em></p><p>  $cm-&gt;add_constructor(       name   =&gt; &apos;construct&apos;,       create =&gt; 1,   );</p><p>Creates and returns a Class::Meta::Constructor object that describes a constructor for the class. The supported parameters are:</p>
<dl class='dl-vertical'>
  <dt>
    name
  </dt>
  <dd>
    <p>The name of the constructor. The name must consist of only alphanumeric characters or \*(L"_\*(R". Required.</p>
  </dd>
  <dt>
    create
  </dt>
  <dd>
    <p>When true, Class::Meta::Constructor will automatically create and install a constructor named for the \*(C`name\*(C' parameter. Defaults to true unless \*(C`code\*(C' is passed. In general you won't need to specify this parameter unless you've written your own constructor in the package, in which case you'll want to specify \*(C`create =&gt; 0\*(C'.</p>
  </dd>
  <dt>
    label
  </dt>
  <dd>
    <p>A label for the constructor. Generally used for displaying its name in a user interface. Optional.</p>
  </dd>
  <dt>
    desc
  </dt>
  <dd>
    <p>A description of the constructor. Possibly useful for displaying help text in a user interface. Optional.</p>
  </dd>
  <dt>
    code
  </dt>
  <dd>
    <p>You can implicitly define the constructor in your class by passing a code reference via the \*(C`code\*(C' parameter. Once \*(C`build()\*(C' is called, Kinetic::Meta::Constructor will install the constructor into the package for which the Class::Meta object was defined, and with the name specified via the \*(C`name\*(C' parameter. Note that if the constructor view is \s-1PRIVATE\s0 or \s-1PROTECTED\s0, the constructor will be wrapped in extra code to constrain the view. Optional.</p>
  </dd>
  <dt>
    view
  </dt>
  <dd>
    <p>The visibility of the constructor. The possible values are defined by the following constants:</p>
<dl class='dl-vertical'>
  <dt>
    Class::Meta::PUBLIC
  </dt>
  <dd>
    <p>Can be used by any client.</p>
  </dd>
  <dt>
    Class::Meta::PRIVATE
  </dt>
  <dd>
    <p>Can only be used by the declaring class.</p>
  </dd>
  <dt>
    Class::Meta::TRUSTED
  </dt>
  <dd>
    <p>Can only be used by the classes specified by the \*(C`trust\*(C' parameter to \*(C`new()\*(C'.</p>
  </dd>
  <dt>
    Class::Meta::PROTECTED
  </dt>
  <dd>
    <p>Can only be used by the declaring class or by classes that inherit from it.</p>
  </dd>

</dl>
<p>Defaults to Class::Meta::PUBLIC if not defined. You can also use strings aliases to the above constants, although the constant values will actually be stored in the Class::Meta::Constructor object, rather than the string. The supported strings are \*(L"\s-1PUBLIC\s0\*(R", \*(L"\s-1PRIVATE\s0\*(R", \*(L"\s-1TRUSTED\s0\*(R", and \*(L"\s-1PROTECTED\s0\*(R".</p>
  </dd>
  <dt>
    caller
  </dt>
  <dd>
    <p>A code reference that calls the constructor. Defaults to a code reference that calls a method with the name provided by the \*(C`name\*(C' attribute on the class being defined.</p>
  </dd>

</dl>
<p>If Class::Meta creates the constructor, it will be a simple parameter-list constructor, wherein attribute values can be passed as a list of attribute-name/value pairs, e.g.:</p><p>  my $thingy = MyApp::Thingy-&gt;new(       name =&gt; &apos;Larry&apos;,       age  =&gt; 32,   );</p><p>Required attributes must have a value passed to the constructor, with one exception: You can pass an optional subroutine reference as the last argument to the constructor. After all parameter values and default values have been set on the object, but before any exceptions are thrown for undefined required attributes, the constructor will execute this subroutine reference, passing in the object being constructed as the sole argument. So, for example, if \*(C`name\*(C' is required but, for some reason, could not be set before constructing the object, you could set it like so:</p><p>  my $thingy = MyApp::Thingy-&gt;new(       age  =&gt; 32,       sub {           my $thingy = shift;           # age and attributes with default values are already set.           my $name = calculate_name( $thingy );           $thingy-&gt;name($name);       },   );</p><p>This allows developers to have a scope-limited context in which to work before required constraints are enforced.</p><p><em>add_attribute</em></p><p>  $cm-&gt;add_attribute(       name =&gt; &apos;tail&apos;,       type =&gt; &apos;scalar&apos;,   );</p><p>Creates and returns a Class::Meta::Attribute object that describes an attribute of the class. The supported parameters are:</p>
<dl class='dl-vertical'>
  <dt>
    name
  </dt>
  <dd>
    <p>The name of the attribute. The name must consist of only alphanumeric characters or \*(L"_\*(R". Required.</p>
  </dd>
  <dt>
    type
  </dt>
  <dd>
    
  </dd>
  <dt>
    is
  </dt>
  <dd>
    <p>The data type of the attribute. See \*(L"Data Types\*(R" for some possible values for this parameter. If the type name corresponds to a data type in a package in the Class::Meta::Types name space, that package will automatically be loaded and configured with Perl-style accessors, so that the data type can simply be used. If both \*(C`type\*(C' and \*(C`is\*(C' are passed, \*(C`is\*(C' will be used. Required unless the class was declared with a \*(C`default_type\*(C'.</p>
  </dd>
  <dt>
    required
  </dt>
  <dd>
    <p>A boolean value indicating whether the attribute is required to have a value. Defaults to false.</p>
  </dd>
  <dt>
    once
  </dt>
  <dd>
    <p>A boolean value indicating whether the attribute can be set to a defined value only once. Defaults to false.</p>
  </dd>
  <dt>
    label
  </dt>
  <dd>
    <p>A label for the attribute. Generally used for displaying its name in a user interface. Optional.</p>
  </dd>
  <dt>
    desc
  </dt>
  <dd>
    <p>A description of the attribute. Possibly useful for displaying help text in a user interface. Optional.</p>
  </dd>
  <dt>
    view
  </dt>
  <dd>
    <p>The visibility of the attribute. See the description of the \*(C`view\*(C' parameter to \*(C`add_constructor\*(C' for a description of its value.</p>
  </dd>
  <dt>
    authz
  </dt>
  <dd>
    <p>The authorization of the attribute. This value indicates whether it is read-only, write-only, read/write, or inaccessible. The possible values are defined by the following constants:</p>
<dl class='dl-vertical'>
  <dt>
    Class::Meta::READ
  </dt>
  <dd>
    
  </dd>
  <dt>
    Class::Meta::WRITE
  </dt>
  <dd>
    
  </dd>
  <dt>
    Class::Meta::RDWR
  </dt>
  <dd>
    
  </dd>
  <dt>
    Class::Meta::NONE
  </dt>
  <dd>
    
  </dd>

</dl>
<p>Defaults to Class::Meta::RDWR if not defined. You can also use strings aliases to the above constants, although the constant values will actually be stored in the Class::Meta::Attribute object, rather than the string. The supported strings are \*(L"\s-1READ\s0\*(R", \*(L"\s-1WRITE\s0\*(R", \*(L"\s-1RDWR\s0\*(R", and \*(L"\s-1NONE\s0\*(R".</p>
  </dd>
  <dt>
    create
  </dt>
  <dd>
    <p>Indicates what type of accessor or accessors are to be created for the attribute.</p>
<dl class='dl-vertical'>
  <dt>
    Class::Meta::GET
  </dt>
  <dd>
    <p>Create read-only accessor(s).</p>
  </dd>
  <dt>
    Class::Meta::SET
  </dt>
  <dd>
    <p>Create write-only accessor(s).</p>
  </dd>
  <dt>
    Class::Meta::GETSET
  </dt>
  <dd>
    <p>Create read/write accessor(s).</p>
  </dd>
  <dt>
    Class::Meta::NONE
  </dt>
  <dd>
    <p>Create no accessors.</p>
  </dd>

</dl>
<p>You can also use strings aliases to the above constants, although the constant values will actually be stored in the Class::Meta::Attribute object, rather than the string. The supported strings are \*(L"\s-1GET\s0\*(R", \*(L"\s-1SET\s0\*(R", \*(L"\s-1GETSET\s0\*(R", and \*(L"\s-1NONE\s0\*(R". If not unspecified, the value of the \*(C`create\*(C' parameter will correspond to the value of the \*(C`authz\*(C' parameter like so:   authz       create   ------------------   READ   =&gt;   GET   WRITE  =&gt;   SET   RDWR   =&gt;   GETSET   NONE   =&gt;   NONE The \*(C`create\*(C' parameter differs from the \*(C`authz\*(C' parameter in case you've taken it upon yourself to create some accessors, and therefore don't need Class::Meta to do so. For example, if you were using standard Perl-style accessors, and needed to do something a little different by coding your own accessor, you'd specify it like this:   $cm-&gt;add_attribute(       name   =&gt; $name,       type   =&gt; $type,       authz  =&gt; Class::Meta::RDWR,       create =&gt; Class::Meta::NONE   ); Just be sure that your custom accessor compiles before you call \*(C`$cm-&gt;build\*(C' so that Class::Meta::Attribute can get a handle on it for its \*(C`get()\*(C' and/or \*(C`set()\*(C' methods.</p>
  </dd>
  <dt>
    context
  </dt>
  <dd>
    <p>The context of the attribute. This indicates whether it's a class attribute or an object attribute. The possible values are defined by the following constants:</p>
<dl class='dl-vertical'>
  <dt>
    Class::Meta::CLASS
  </dt>
  <dd>
    
  </dd>
  <dt>
    Class::Meta::OBJECT
  </dt>
  <dd>
    
  </dd>

</dl>
<p>You can also use strings aliases to the above constants, although the constant values will actually be stored in the Class::Meta::Attribute object, rather than the string. The supported strings are \*(L"\s-1CLASS\s0\*(R", and \*(L"\s-1OBJECT\s0\*(R".</p>
  </dd>
  <dt>
    default
  </dt>
  <dd>
    <p>The default value for the attribute, if any. This may be either a literal value or a code reference that will be executed to generate a default value.</p>
  </dd>
  <dt>
    override
  </dt>
  <dd>
    <p>If an attribute being added to a class has the same name as an attribute in a parent class, Class::Meta will normally throw an exception. However, in some cases you might want to override an attribute in a parent class to change its properties. In such a case, pass a true value to the \*(C`override\*(C' parameter to override the attribute and avoid the exception.</p>
  </dd>

</dl>
<p><em>add_method</em></p><p>  $cm-&gt;add_method( name =&gt; &apos;wag&apos; );</p><p>Creates and returns a Class::Meta::Method object that describes a method of the class. The supported parameters are:</p>
<dl class='dl-vertical'>
  <dt>
    name
  </dt>
  <dd>
    <p>The name of the method. The name must consist of only alphanumeric characters or \*(L"_\*(R".</p>
  </dd>
  <dt>
    label
  </dt>
  <dd>
    <p>A label for the method. Generally used for displaying its name in a user interface. Optional.</p>
  </dd>
  <dt>
    desc
  </dt>
  <dd>
    <p>A description of the method. Possibly useful for displaying help text in a user interface. Optional.</p>
  </dd>
  <dt>
    view
  </dt>
  <dd>
    <p>The visibility of the method. See the description of the \*(C`view\*(C' parameter to \*(C`add_constructor\*(C' for a description of its value. Class::Meta only enforces the \*(C`view\*(C' if the \*(C`code\*(C' parameter is used to define the method body. Otherwise, it's up to the class implementation itself to do the job.</p>
  </dd>
  <dt>
    code
  </dt>
  <dd>
    <p>You can implicitly define the method in your class by passing a code reference via the \*(C`code\*(C' parameter. Once \*(C`build()\*(C' is called, Kinetic::Meta::Method will install the method into the package for which the Class::Meta object was defined, and with the name specified via the \*(C`name\*(C' parameter. If the \*(C`view\*(C' is anything other than \s-1PUBLIC\s0, it will be enforced.</p>
  </dd>
  <dt>
    context
  </dt>
  <dd>
    <p>The context of the method. This indicates whether it's a class method or an object method. See the description of the \*(C`context\*(C' parameter to \*(C`add_attribute\*(C' for a description of its value.</p>
  </dd>
  <dt>
    caller
  </dt>
  <dd>
    <p>A code reference that calls the method. This code reference will be be used by the \*(C`call()\*(C' method of Class::Meta::Method to execute the method on behalf of an object. Defaults to a code reference that calls a method with the name provided by the \*(C`name\*(C' attribute on the class being defined.</p>
  </dd>
  <dt>
    args
  </dt>
  <dd>
    <p>A description of the arguments to the method. This can be anything you like, but I recommend something like a string for a single argument, an array reference for a list of arguments, or a hash reference for parameter arguments.</p>
  </dd>
  <dt>
    returns
  </dt>
  <dd>
    <p>A string describing the return value or values of the method.</p>
  </dd>

</dl>

<h3>Instance Methods</h3>
<p><em>class</em></p><p>  my $class = $cm-&gt;class;</p><p>Returns the instance of the Class::Meta::Class object that will be used to provide the introspection \s-1API\s0 for the class being generated.</p><p><em>build</em></p><p>  $cm-&gt;build;</p><p>Builds the class defined by the Class::Meta object, including the \*(C`my_class()\*(C' class method, and all requisite constructors and accessors.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">JUSTIFICATION</h2>
        <div class="sectioncontent">
<p>One might argue that there are already too many class automation and parameter validation modules on \s-1CPAN\s0. And one would be right. They range from simple accessor generators, such as Class::Accessor, to simple parameter validators, such as Params::Validate, to more comprehensive systems, such as Class::Contract and Class::Tangram. But, naturally, none of them could do exactly what I needed.</p><p>What I needed was an implementation of the \*(L"Facade\*(R" design pattern. Okay, this isn't a facade like the \*(L"Gang of Four\*(R" meant it, but it is in the respect that it creates classes with a common \s-1API\s0 so that objects of these classes can all be used identically, calling the same methods on each. This is done via the implementation of an introspection \s-1API\s0. So the process of creating classes with Class::Meta not only creates attributes and accessors, but also creates objects that describe those classes. Using these descriptive objects, client applications can determine what to do with objects of Class::Meta-generated classes. This is particularly useful for user interface code.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TO DO</h2>
        <div class="sectioncontent">
<ul>
<li><p>Add support for an \*(C`accessor\*(C' parameter to \*(C`add_attribute()\*(C' that will be used for the accessor instead of generating one.</p></li><li><p>Make class attribute accessors behave as they do in Class::Data::Inheritable.</p></li><li><p>Modify class attribute accessors so that they are thread safe. This will involve sharing the attributes across threads, and locking them before changing their values. If they've also been made to behave as they do in Class::Data::Inheritable, we'll have to figure out a way to make it so that newly generated accessors for subclasses are shared between threads, too. This may not be easy.</p></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SUPPORT</h2>
        <div class="sectioncontent">
<p>This module is stored in an open GitHub repository &lt;http://github.com/theory/class-meta/&gt;. Feel free to fork and contribute!</p><p>Please file bug reports via GitHub Issues &lt;http://github.com/theory/class-meta/issues/&gt; or by sending mail to bug-Class-Meta@rt.cpan.org &lt;mailto:bug-Class-Meta@rt.cpan.org&gt;.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>David E. Wheeler &lt;david@justatheory.com&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Class::Meta&hellip;</h2>
        <div class="sectioncontent">
<p>First of all, use Class::Meta::Express instead of Class::Meta to declare your classes. I hope I've made that clear enough by now.</p><p>Other classes of interest within the Class::Meta distribution include:</p>
<dl class='dl-vertical'>
  <dt>
    Class::Meta::Class
  </dt>
  <dd>
    
  </dd>
  <dt>
    Class::Meta::Constructor
  </dt>
  <dd>
    
  </dd>
  <dt>
    Class::Meta::Attribute
  </dt>
  <dd>
    
  </dd>
  <dt>
    Class::Meta::Method
  </dt>
  <dd>
    
  </dd>
  <dt>
    Class::Meta::Type
  </dt>
  <dd>
    
  </dd>
  <dt>
    Class::Meta::Types::Perl
  </dt>
  <dd>
    
  </dd>
  <dt>
    Class::Meta::Types::String
  </dt>
  <dd>
    
  </dd>
  <dt>
    Class::Meta::Types::Boolean
  </dt>
  <dd>
    
  </dd>
  <dt>
    Class::Meta::Types::Numeric
  </dt>
  <dd>
    
  </dd>

</dl>
<p>For comparative purposes, you might also want to check out these fine modules:</p>
<dl class='dl-vertical'>
  <dt>
    Class::Accessor
  </dt>
  <dd>
    <p>Accessor and constructor automation.</p>
  </dd>
  <dt>
    Params::Validate
  </dt>
  <dd>
    <p>Parameter validation.</p>
  </dd>
  <dt>
    Class::Contract
  </dt>
  <dd>
    <p>Design by contract.</p>
  </dd>
  <dt>
    Class::Tangram
  </dt>
  <dd>
    <p>Accessor automation and data validation for Tangram applications.</p>
  </dd>
  <dt>
    Class::Maker
  </dt>
  <dd>
    <p>An ambitious yet under-documented module that also manages accessor and constructor generation, data validation, and provides a reflection \s-1API\s0. It also supports serialization.</p>
  </dd>
  <dt>
    Class::MOP
  </dt>
  <dd>
    <p>Stevan Little's application of Perl 6 meta classes to Perl 5.</p>
  </dd>
  <dt>
    Moose
  </dt>
  <dd>
    <p>\*(L"It's the new camel.\*(R" Another extension of the Perl 5 object system, built on Class::MOP.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT AND LICENSE</h2>
        <div class="sectioncontent">
<p>Copyright (c) 2002-2011, David E. Wheeler. Some Rights Reserved.</p><p>This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Class::MakeMethods::Utility::TextBuilder.3pm.html"><span aria-hidden="true">&larr;</span> Class::MakeMethods::Utility::TextBuilder.3pm: Basic text substitutions</a></li>
   <li class="next"><a href="Class::Meta::AccessorBuilder.3pm.html">Class::Meta::AccessorBuilder.3pm: Perl style accessor generation <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

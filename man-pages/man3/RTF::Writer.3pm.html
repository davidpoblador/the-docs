<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RTF::Writer: For generating documents in rich text format</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="For generating documents in rich text format">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="RTF::Writer (3pm) manual">
  <meta name="twitter:description" content="For generating documents in rich text format">
  <meta name="twitter:image" content="https://www.carta.tech/images/librtf-writer-perl-RTF::Writer-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/RTF::Writer.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="RTF::Writer (3pm) manual" />
  <meta property="og:description" content="For generating documents in rich text format" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/librtf-writer-perl-RTF::Writer-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">RTF::Writer<small> (3pm)</small></h1>
        <p class="lead">For generating documents in rich text format</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/RTF::Writer.3pm.html">
      <span itemprop="name">RTF::Writer: For generating documents in rich text format</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/librtf-writer-perl/">
      <span itemprop="name">librtf-writer-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/RTF::Writer.3pm.html">
      <span itemprop="name">RTF::Writer: For generating documents in rich text format</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  use RTF::Writer;
  my $rtf = RTF::Writer-&gt;new_to_file("greetings.rtf");
  $rtf-&gt;prolog( &apos;title&apos; =&gt; "Greetings, hyoomon" );
  $rtf-&gt;number_pages;
  $rtf-&gt;paragraph(
    &#92;&apos;&#92;fs40&#92;b&#92;i&apos;,  # 20pt, bold, italic
    "Hi there!"
  );
  $rtf-&gt;close;
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module is for generating documents in Rich Text Format.</p><p>This module is a class; an object belonging to this class acts like an output filehandle, and calling methods on it causes \s-1RTF\s0 text to be written.</p><p>Incidentally, this module also exports a few useful functions, upon request.</p><p>The following documentation assumes some familiarity with the \s-1RTF\s0 Specification.  Users not already intimately familiar with \s-1RTF\s0 should look at RTF::Cookbook and/or my book <em>\s-1RTF\s0 Pocket Guide</em> from O'Reilly, &lt;http://www.oreilly.com/catalog/rtfpg/&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">
<p>This creates a new \s-1RTF\s0 output stream object, such that sending text to this object will write to the filespec given.  This is basically a wrapper around new_to_handle.  If opening a write-handle to $filename fails (or if $filename is undef or zero-length), then a fatal error results. This creates a new \s-1RTF\s0 output stream object, such that sending text to this object will write to the filehandle given.  The filehandle can be a glob (*FH) or a filehandle object (*FH{\s-1IO\s0} or the value from \*(C`IO::File-&gt;new(...)\*(C'). This creates a new \s-1RTF\s0 output stream object, such that sending text to this object will append to the string that you've passed a reference to. This is the basic method for writing text to an \s-1RTF\s0 stream.  This takes a list of items.  Each item is either:</p><p>In this case, the value is imputed to be a plaintext string, and an rtf-escaped version of it is written.  For example "Stuff&#92;n&#92;t&#92;tUmmm&#92;n" causes &apos;Stuff&#92;line &#92;tab &#92;tab Umm&#92;line &apos; to be written.  See rtfesc(x) for further details of escaping.</p>
<dl class='dl-vertical'>
  <dt>
    a scalar-reference, like &#92;'&#92;ul'
  </dt>
  <dd>
    <p>In this case, the value is imputed to be a reference to <em>already escaped</em> text.  This is the basic way to emit \s-1RTF\s0 codes.  Text passed this way will be written without any additional escaping. Unless $RTF::Writer::AUTO_NL (normally on) has been turned off, the item written will be followed with a (presumably harmless) newline character to delimit any code in there from any following text, <em>if</em> the last character of this string is a digit or a lowercase letter.  This is so that \*(C`(&#92;&apos;&#92;i&apos;, "foo!")\*(C' emits \*(C`&#92;i[newline]foo!&apos;\*(C' (which does what you expected), instead of &apos;&#92;ifoo!&apos;, which looks like an \s-1RTF\s0 command \*(L"ifoo\*(R" followed by a plaintext \*(L"!\*(R".</p>
  </dd>
  <dt>
    an array-reference, like [ &#92;'&#92;ul', 'foo' ]
  </dt>
  <dd>
    <p>This emits an open-brace \*(L"{\*(R", as \s-1RTF\s0 uses for opening \*(L"groups\*(R" (generally for delimiting the effects of character-formatting commands like '&#92;ul', or a few formatting commands like '&#92;footnote'); then it emits the items in the referred-to array; and then emits a closing \*(L"}\*(R".  I intend this to be useful is making sure that you don't emit more open-braces than close-braces, since that usually makes \s-1RTF\s0 readers immediately reject such a file. You can nest these array-references, like:      $h-&gt;print(        &#92;&apos;&#92;col2&apos;,        [ &#92;&apos;&#92;pard&apos;,          "It is now ",          [ &#92;&apos;&#92;f1&apos;,            scalar(localtime), " local, or ",            scalar(gmtime), " GMT.",          ],          " -- if you&apos;re ",          [ &#92;&apos;&#92;i&apos;,            "keeping track.",          ],        ],        &#92;&apos;&#92;par&#92;page&apos;,      );</p>
  </dd>

</dl>
<p>The return value of the <em>print()</em> method is currently always the value 1, although this may change.</p><p>This writes an \s-1RTF\s0 prolog to $h.  You are free to make your own prolog using just $h-&gt;print(&#92;'...your own code...'), but I find in easier to automate this task, particularly with some sane defaults. Since emitting a prolog opens a \*(L"{\*(R"-group, calling $h-&gt;prolog(...) sets a flag in $h so that when you call $h-&gt;<em>close()</em>, a closing \*(L"}\*(R" will automatically be written before the stream object is actually closed. The options to the <em>prolog()</em> method are passed as a list of keys and values, for controlling the contents of the prolog written.  The options are listed below, roughly with the most important options first. (Be careful with the spelling of these options.  Some are rather odd, because they are (mostly) based on the name of the relevent \s-1RTF\s0 command, and a systematic naming scheme for commands is one thing you won't find in \s-1RTF\s0!)</p><p>This value is for the font table section of the prolog. If the value is an arrayref, then it should be a reference to an array whose items should be either plain text strings, like \*(L"Times Roman\*(R", which are the (unescaped) names of fonts; or the items in the array can be scalar-refs, for expressing \s-1RTF\s0 control words along with the (escaped) font name, as in \*(C`&#92;&apos;&#92;froman Times New Roman&apos;\*(C'.  If the value of the \*(L"fonts\*(R" parameters is a scalar ref, then it is taken to be a reference to code of your own that expresses the whole font table. If you don't specify a value for the \*(L"font\*(R" option, then you get a font table with one entry, \*(L"Times New Roman\*(R". You should be sure to declare all fonts that you switch to in your document (as with &#92;'&#92;f3', to change the current font to what's declared in entry 3 (counting from 0) in the font table).</p>
<dl class='dl-vertical'>
  <dt>
    'deff' =&gt; \s-1INTEGER\s0,
  </dt>
  <dd>
    <p>This is for expressing, in the prolog, the font-table number of the default font for this document.  The default is 0, which is an often useful value.</p>
  </dd>
  <dt>
    'colors' =&gt; [ undef, [0,142,252], [200,32,0], ...],
  </dt>
  <dd>
    <p>This value is for expressing the document's (generally optional) color table.  If you stipulate an arrayref value, then each item of the array should be either an \s-1RGB\s0 triplet expressed as an arrayref like [200,32,0], or undef, for a null color-entry. If you stipulate a scalar-ref value for 'colors', then it is taken to be a reference to code of your own that expresses the whole font table. If you don't stipulate any value for 'colors', then you get a table consisting of three colors: null/default (undef), 100% red ([2550,0,0]), and 100% blue ([0,0,255]). You can freely ignore concerns of color tables if you don't use color-changing codes in your document (like &#92;'&#92;cf2', to switch the text foreground color to what's declared at entry 2 (starting from 0) in the color table).</p>
  </dd>
  <dt>
    'stylesheet' =&gt; \s-1STRING\s0,
  </dt>
  <dd>
    
  </dd>
  <dt>
    'filetbl' =&gt; \s-1STRING\s0,
  </dt>
  <dd>
    
  </dd>
  <dt>
    'listtables' =&gt; \s-1STRING\s0,
  </dt>
  <dd>
    
  </dd>
  <dt>
    'revtbl' =&gt; \s-1STRING\s0,
  </dt>
  <dd>
    <p>These are for expressing, in the prolog, code constituting the document's style sheet, table-of-files, table-of-lists, and table-of-revisions, respectively.  The default value of each of these is empty-string.  None of these are needed by a typical \s-1RTF\s0 document.</p>
  </dd>
  <dt>
    'more_default' =&gt; \s-1STRING\s0,
  </dt>
  <dd>
    <p>This is for inserting any additional code just after the '&#92;deffN' in the start of the prolog, before the font table.  A common useful value here is &#92;'&#92;deflang1033', to express the default language (1033 = RTFese for \s-1US\s0 English) for the document, although my reading of the \s-1RTF\s0 spec leads me to believe that this doesn't need to be in the prolog here (where many writers put it, as apparently accepted by many \s-1RTF\s0 readers), but should (instead?) go just after the prolog, with other \*(L"document formatting\*(R" commands described in the \*(L"Document Formatting Properties\*(R" section of the \s-1RTF\s0 Specification.</p>
  </dd>
  <dt>
    'doccomm' =&gt; \s-1STRING\s0,
  </dt>
  <dd>
    <p>This value is for the \*(L"document comment\*(R" metainformation item in the prolog, which appears as the \*(L"Comment\*(R" field in the \*(L"File Properties\*(R" panel in MSWord, or as the \*(L"Abstract\*(R" field in the \*(L"File Properties\*(R" window in WordPerfect. If no value is specified, then RTF::Writer puts a string noting the value of $0 (typically the filespec to the current Perl program), and the version of RTF::Writer used.</p>
  </dd>
  <dt>
    'title' =&gt; \s-1STRING\s0,
  </dt>
  <dd>
    
  </dd>
  <dt>
    'subject' =&gt; \s-1STRING\s0,
  </dt>
  <dd>
    
  </dd>
  <dt>
    'author' =&gt; \s-1STRING\s0,
  </dt>
  <dd>
    
  </dd>
  <dt>
    'manager' =&gt; \s-1STRING\s0,
  </dt>
  <dd>
    
  </dd>
  <dt>
    'company' =&gt; \s-1STRING\s0,
  </dt>
  <dd>
    
  </dd>
  <dt>
    'operator' =&gt; \s-1STRING\s0,
  </dt>
  <dd>
    
  </dd>
  <dt>
    'category' =&gt; \s-1STRING\s0,
  </dt>
  <dd>
    
  </dd>
  <dt>
    'keywords' =&gt; \s-1STRING\s0,
  </dt>
  <dd>
    
  </dd>
  <dt>
    'hlinkbase' =&gt; \s-1STRING\s0,
  </dt>
  <dd>
    
  </dd>
  <dt>
    'comment' =&gt; \s-1STRING\s0,
  </dt>
  <dd>
    <p>These are for stipulating the string values of these various optional document metainformation items.  'operator' is for the name of the person who last made changes to the document; 'hlinkbase' is which is the \s-1URL\s0 or path that is used for for resolving any all relative hyperlinks in the document; 'comment' is reportedly just ignored (cf. the 'doccomm' attribute, which is <em>not</em> ignored); and you can guess the rest. The meanings of all of these are explained in greater detail in the \s-1RTF\s0 spec.</p>
  </dd>
  <dt>
    'revtim' =&gt; \s-1EPOCH_NUMBER\s0,
  </dt>
  <dd>
    <p>This value is for the document metainformation section of the prolog.  It signifies the last-modified time of the document. \s-1EPOCH_NUMBER\s0 is the number of seconds since the epoch, such as one gets from \*(C`(stat($thing)[9])\*(C' or \*(C`time()\*(C'; or you may pass a reference a timelist, like [localtime($whatever)]. If no defined value for revtime is stipulated in the call to prolog(...) then the current value of <em>time()</em> is used. Explicitly pass a value of undef to suppress emitting any 'creatim' value.</p>
  </dd>
  <dt>
    'creatim' =&gt; \s-1EPOCH_NUMBER\s0,
  </dt>
  <dd>
    <p>This value is for the document metainformation section of the prolog.  It signifies the last-modified time of the document. If no defined value for 'creatim' is stipulated in the call to prolog(...) then the current value of <em>time()</em> is used. Explicitly pass a value of undef to suppress emitting any 'creatim' value.</p>
  </dd>
  <dt>
    'printim' =&gt; \s-1EPOCH_NUMBER\s0,
  </dt>
  <dd>
    <p>This value is for the document metainformation section of the prolog.  It signifies the time when this document was last printed.  If you don't stipulate a defined value here, no 'printim' metainformation is written.</p>
  </dd>
  <dt>
    'buptim' =&gt; \s-1EPOCH_NUMBER\s0,
  </dt>
  <dd>
    <p>This value is for the document metainformation section of the prolog.  It signifies the \*(L"backup time\*(R" of this document.  If you don't stipulate a defined value here, no 'buptim' metainformation is written.</p>
  </dd>
  <dt>
    'version' =&gt; \s-1INTEGER\s0,
  </dt>
  <dd>
    
  </dd>
  <dt>
    'vern' =&gt; \s-1INTEGER\s0,
  </dt>
  <dd>
    
  </dd>
  <dt>
    'edmins' =&gt; \s-1INTEGER\s0,
  </dt>
  <dd>
    
  </dd>
  <dt>
    'nofpages' =&gt; \s-1INTEGER\s0,
  </dt>
  <dd>
    
  </dd>
  <dt>
    'nofwords' =&gt; \s-1INTEGER\s0,
  </dt>
  <dd>
    
  </dd>
  <dt>
    'nofchars' =&gt; \s-1INTEGER\s0,
  </dt>
  <dd>
    
  </dd>
  <dt>
    'nofcharsws' =&gt; \s-1INTEGER\s0,
  </dt>
  <dd>
    
  </dd>
  <dt>
    'id' =&gt; \s-1INTEGER\s0,
  </dt>
  <dd>
    <p>These are for stipulating the integer values of these various optional (and not terribly useful, for most purposes!) document metainformation items.  The meanings of all of these are explained in the \s-1RTF\s0 spec.</p>
  </dd>
  <dt>
    'charset' =&gt; \s-1STRING\s0,
  </dt>
  <dd>
    <p>This is for expressing, in the prolog, \s-1RTF\s0 codename for the character set being used in this document.  The default is \*(L"ansi\*(R", and don't stipulate anything else (like \*(L"mac\*(R", \*(L"pc\*(R", or \*(L"pca\*(R") unless you know what you're doing.</p>
  </dd>
  <dt>
    'rtf_version' =&gt; \s-1INTEGER\s0,
  </dt>
  <dd>
    <p>This is for expressing, in the prolog, what major version of \s-1RTF\s0 is being used in this document.  The default is 1, and don't use anything else unless you really know what you're doing.</p>
  </dd>

</dl>
<p>This is just short for $h-&gt;print(sprintf('format', ...items...) In this case, 'format' is assumed to contain already-escaped \s-1RTF\s0 code.  The items in ...items... are escaped as necessary, and then interpolated.  I.e., this is rather like: $h-&gt;print(&#92;sprintf 'format', map rtfesc($_), ...items...)) except that numeric items don't get escaped (and don't need to be).  Example:     $h-&gt;printf(       &#92;&apos;{&#92;i "%s"} was found in %2.2f percent of matches&#92;par&apos;,       $word, 100 * $count / $total     ); This is just a handy wrapper for some code that turns on page numbering.  If you call this method, you should call it right after you emit a prolog. The page numbering consists of just putting the page number at the top-right of each page.  If you provide items in the list (...), then that is pre-pended to the page number.  Example:     $h-&gt;number_pages("Lexicon, p."); Or:     $h-&gt;number_pages(&#92;&apos;&#92;b&#92;fs30&#92;f2&apos;, "page "); This constructs an object representing a declaration for a table row.  You can have to use it in calls to $h-&gt;row($tabldecl,...), and can reuse it on subsequent calls.  This object is for declaring the dimensions of table rows. The work that a declaration has to do, is best explained in this diagram of a bordered three-cell table (first cell containing \*(L"Foo ya!\*(R"), placed near a left margin (shown as the line of colons).  The things in brackets are not on the page, but just for our reference:   :    [..w1...]   :            [......w2.......]   :                            [...w3....]   [.A..]     [.B.]           [.B.]   :   :    +-------+---------------+---------+   :    |  Foo  |  Bar baz      |  Yee!   |   :    |  ya!  |  quuxi quuxo  |         |   :    |       |  quaqua.      |         |   :    +-------+---------------+---------+   :   [.A..]     [.B.]           [.B.]   [..r1........]   [.....r2.....................]   [........r3............................] Here the horizontal dimensions of the three-celled table are expressed in terms of:  A, the distance from the current left margin; B, the minimum distance between the content of the cells (or you can think of this as twice the internal left or right borders in each cell); and then \s-1EITHER\s0 [w1, w2, w3], expressing the width of each cell, \s-1OR\s0 [r1, r2, r3], expressing each cell's right end's distance from the current left margin.  All distances are, of course, in twips. Options to RTF::Writer::TableRowDecl-&gt;new( ...options... ) are:</p>
<dl class='dl-vertical'>
  <dt>
    left_start =&gt; \s-1TWIPS\s0,
  </dt>
  <dd>
    <p>This declares the distance between the left margin, and the left end of the table.  Default is 0.</p>
  </dd>
  <dt>
    inbetween =&gt; \s-1TWIPS\s0,
  </dt>
  <dd>
    <p>This declares the distance labelled \*(L"B\*(R", above.  Default is 120, which is 6 points, 1/12th-inch, about 2mm.</p>
  </dd>
  <dt>
    widths =&gt; [\s-1TWIPS\s0, \s-1TWIPS\s0, \s-1TWIPS\s0, ... ],
  </dt>
  <dd>
    <p>This expresses the widths of each of the cells in this row, starting from the leftmost.</p>
  </dd>
  <dt>
    reaches =&gt; [\s-1TWIPS\s0, \s-1TWIPS\s0, \s-1TWIPS\s0, ... ],
  </dt>
  <dd>
    <p>This expresses the rightmost extreme of each of the cells in this row.</p>
  </dd>
  <dt>
    align =&gt; <em>alignmentspecs</em>,
  </dt>
  <dd>
    <p>This is explained in detail in the section \*(L"Cell Alignment Syntax\*(R", below.</p>
  </dd>
  <dt>
    borders =&gt; <em>borderspecs</em>,
  </dt>
  <dd>
    <p>This is explained in detail in the section \*(L"Cell Border Syntax\*(R", below.</p>
  </dd>

</dl>
<p>This makes the items in the list (...) into a paragraph.  Basically just a wrapper for $h-&gt;print([ &#92;'{&#92;par', ..., &#92;'&#92;pard}', ]) This emits a table row, with dimensions as stipulated by the $trdecl object, and with row content from the items given. You must provide a value for $trdecl, or a fatal error results. If you provide <em>fewer</em> items than $trdecl declares cells, then you get empty cells to fill out the row.  If you provide <em>more</em> items than $trdecl declares cells, then the width of the last declared row is used in figuring the width of the additional cells for this row. Example:     my $decl = RTF::Writer::TableRowDecl-&gt;new(&apos;widths&apos; =&gt; [1500,1900]);     $h-&gt;row($decl, "Stuff", "Hmmm");     $h-&gt;row($decl, [&#92;&apos;&#92;ul&apos;, &apos;Foo&apos;], &apos;Bar&apos;, &#92;&apos;&#92;bullet&apos;);     $h-&gt;row($decl, "Hooboy."); This creates a table resembing:     +-------------+-------------------+     | Stuff       | Hmm               |     +-------------+-------------------+-------------------+     | _Foo_       | Bar               | *                 |     +-------------+-------------------+-------------------+     | "Hooboy."   |                   |     +-------------+-------------------+ Note that you <em>\s-1MUST\s0 \s-1NOT\s0</em> use '&#92;par' commands in any items you emit in row cells! The $h-&gt;row(...) method is a wrapper for producing elementary tables in \s-1RTF\s0, with the minimum of parameters; the myriad other options that tables can have (for example, changing borders) are not supported. If you really need to generate tables fancier than what $h-&gt;row(...) can produce, start off reading the \s-1RTF\s0 spec, reading the source for <em>row()</em> (and the RTF::Writer::TableRowDecl class), and progress from there.  Note that MSWord has been known to crash when given malformed \s-1RTF\s0 table code. This is a wrapper around $h-&gt;row.  It takes a list of arrayrefs, which are fed to calls to h-&gt;row($tr_decl, @$each_arrayref).  You should provide a $trdecl, but if you don't, then one is <em>crudely</em> guessed at, based on the maximum number of columns in all rows. This returns a scalar-reference to RTF-code representing the given image with given parameters.  For example:   $h-&gt;paragraph(     "See here: ",     $h-&gt;image( &apos;filename&apos; =&gt; "foo.png", ),   ); The legal options are explained below:</p>
<dl class='dl-vertical'>
  <dt>
    filename =&gt; \s-1FILENAME\s0,
  </dt>
  <dd>
    <p>This should be the path to a readable filename.  You have to specify this. If you don't specify this, or if the value isn't a readable file, then a fatal error results.  Currently, only JPEGs and PNGs are allowed; specifying any other kind of file causes a fatal error. (The \*(C`filename\*(C' option above is required, but the following options are all generally optional \*(-- altho some \s-1RTF\s0 processors may be finicky if you set some of the following but not others, for no apparent reason.  When in doubt, test.)</p>
  </dd>
  <dt>
    wgoal =&gt; \s-1TWIPS\s0,
  </dt>
  <dd>
    <p>The desired width of the image</p>
  </dd>
  <dt>
    hgoal =&gt; \s-1TWIPS\s0,
  </dt>
  <dd>
    <p>The desired height of the image</p>
  </dd>
  <dt>
    scalex =&gt; \s-1PERCENT\s0,
  </dt>
  <dd>
    
  </dd>
  <dt>
    scaley =&gt; \s-1PERCENT\s0,
  </dt>
  <dd>
    <p>Respectively, the horizontal (X) or vertical (Y) scaling value. The argument is an integer representing a percentage. (The default is 100 percent)</p>
  </dd>
  <dt>
    cropt =&gt; \s-1TWIPS\s0,
  </dt>
  <dd>
    
  </dd>
  <dt>
    cropb =&gt; \s-1TWIPS\s0,
  </dt>
  <dd>
    
  </dd>
  <dt>
    cropl =&gt; \s-1TWIPS\s0,
  </dt>
  <dd>
    
  </dd>
  <dt>
    cropr =&gt; \s-1TWIPS\s0,
  </dt>
  <dd>
    <p>These specify the top, bottom, left, and right cropping values.  A positive value crops <em>toward</em> the center of the image.  A negative value crops <em>away</em> from the center, adding a padding space around the image. (The default is to do neither, as you'd get from a cropping value of 0.)</p>
  </dd>
  <dt>
    picspecs =&gt; &#92;SCALARVALUE,
  </dt>
  <dd>
    <p>This overrides generation of the normal image values based the image and the above parameters, and instead uses whatever value you pass a reference to.  You normally shouldn't need to use this.</p>
  </dd>

</dl>
<p>This take the same options as \*(C`$h-&gt;image(...)\*(C', but has three differences:  First, it is a shortcut for this:    $h-&gt;paragraph( &#92;&apos;&#92;qc&apos;,      $h-&gt;image( ...params...),    ); Secondly, whereas \*(C`$h-&gt;image(...)\*(C' returns the image data (as an \s-1RTF\s0 scalarref), \*(C`$h-&gt;image_paragraph(...)\*(C' doesn't return much of anything. Thirdly, \*(C`$h-&gt;image_paragraph(...)\*(C' is often much more memory-efficient, since it can write the image data to a file as it's RTF-ified, instead of building it all up in memory. This completes writing to the stream denoted by the object in $h; this generally (assuming you'd called $h-&gt;prolog) involves just writing a final close-brace to $h, and then closing whatever filehandle or file $h writes to (unless we're writing to a string, in which case we just discard $h's reference to it). After you call \*(C`$h-&gt;close\*(C', you should not call any other methods with $h! Note that you don't <em>have</em> to explicitly call \*(C`$h-&gt;close\*(C' \*(-- when an unclosed RTF::Writer object goes out of scope (or, more precisely speaking, when if its refcount hits zero), then something equivalent to calling \*(C`$h-&gt;close\*(C' is done automatically for you.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTOMETHODS</h2>
        <div class="sectioncontent">
<p>In addition to any of the above methods, you can use any \s-1RTF\s0 command (and optional integer arguments) as a valid method name, by just capitalizing its first letter, as shown below: The same as $h-&gt;print( &#92;'&#92;foo' ); For example, $h-&gt;<em>Page()</em> is the same as $h-&gt;print(&#92;'&#92;page') (Where \*(L"...\*(R" is a non-empty list.) The same as $h-&gt;print( [ &#92;'&#92;foo', ... ] ); For example: \*(C`$h-&gt;I(&apos;stuff&apos;)\*(C' is the same as $h-&gt;print([&#92;'&#92;i', 'stuff']) The same as $h-&gt;print( &#92;'&#92;foo123' ).  I.e., command word \*(L"&#92;foo\*(R" with an integer argument of 123. For example: $h-&gt;<em>Cols2()</em> is the same as $h-&gt;print(&#92;'&#92;cols2') (Where \*(L"...\*(R" is a non-empty list.) The same as $h-&gt;print( [ &#92;'&#92;foo123', ... ] ); For example: $h-&gt;F2('stuff') is the same as $h-&gt;print([&#92;'&#92;f2', 'stuff']). The same as $h-&gt;print( &#92;'&#92;foo-123' );, i.e., command word \*(L"&#92;foo\*(R" with an integer argument of negative 123.  (You can't have a \*(L"-\*(R" in a method name, so I use an underscore instead.) For example: $h-&gt;<em>Li_1440()</em> is the same as $h-&gt;print([&#92;'&#92;li-1440', 'stuff']) (Where \*(L"...\*(R" is a non-empty list.) The same as $h-&gt;print( [ &#92;'&#92;foo-123', ... ] );</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FUNCTIONS</h2>
        <div class="sectioncontent">
<p>None of these functions are exported by default, but they can be exported on request, as in:</p><p>  use RTF::Writer qw(inches cm rtfesc);</p>
<dl class='dl-vertical'>
  <dt>
    inch($x), inches($x), in($x)
  </dt>
  <dd>
    <p>These synonymous functions all construe the numeric value in $x as inches, and return the equivalent number of twips.  For example, \*(C`inches(1.5)\*(C' returns 2160, because an inch and a half is exactly 2160 twips.  The return value of these functions is always an integer, as fractions of twips are not used in \s-1RTF\s0.</p>
  </dd>
  <dt>
    point($x), points($x), pt($x)
  </dt>
  <dd>
    <p>These synonymous functions all construe the numeric value in $x as points, and return the equivalent number of twips.  For example, \*(C`points(54)\*(C' returns 1080, because fifty-four points is exactly 1080 twips.  The return value of these functions is always an integer, as fractions of twips are not used in \s-1RTF\s0.</p>
  </dd>
  <dt>
    cm(x)
  </dt>
  <dd>
    <p>This function construes the numeric value in $x as centimeters, and returns the equivalent number of twips.  For example, \*(C`cm(1.5)\*(C' returns 850, because 1.5cm is approximately 850 twips (i.e., it's 850, when rounded to the nearest whole number).  Since twips and points are both are defined in terms of inches (1440 twips = 72 points = 1 inch), conversion between cm and these other units is approximate. The return value of \*(C`cm($x)\*(C' is always an integer, as fractions of twips are not used in \s-1RTF\s0.</p>
  </dd>
  <dt>
    rtfesc($text); # void context
  </dt>
  <dd>
    
  </dd>
  <dt>
    rtfesc(@z); # void context
  </dt>
  <dd>
    <p>This escapes some plaintext so it's good \s-1RTF\s0.  E.g., it turns \*(L"Foo&#92;nBar&#92;&#92;\*(R" into \*(L"Foo&#92;n&#92;&#92;line Bar&#92;&#92;'5c\*(R" (since a plaintext backslash needs to be escaped in \s-1RTF\s0, and a \*(L"&#92;n\*(R"'s \s-1RTF\s0 equivalent is the '&#92;line' command). In void context (i.e., where you aren't capturing the return value), this in-place alters the values you pass it. In scalar or list context, doesn't alter the original(s), but returns an escaped copy of what you pass in.</p>
  </dd>

</dl>
<h3>Cell Alignment Syntax</h3>
<p>To control alignment of cells, specify \*(C`align =&gt; "<strong>direction</strong> direction direction..."\*(C', where each direction is one of these alphametic strings for the given directions (based on the abbreviated English names for map directions and canvas directions):</p><p>    NW  N  NE        TL  T  TR       &#92; | /            &#92; | /     W - C - E        L - C - R       / | &#92;            / | &#92;     SW  S  SE        BL  B  BR</p><p>For example, \*(C`align =&gt; "nw c"\*(C' means that the first cell will be aligned to the <strong></strong><strong>n</strong><strong></strong>orth<strong></strong><strong>w</strong><strong></strong>est (a.k.a. the <strong></strong><strong>t</strong><strong></strong>op-<strong></strong><strong>l</strong><strong></strong>eft), and that the second cell (and any cells thereafter) will be aligned to the <strong></strong><strong>c</strong><strong></strong>enter.</p><p>An acceptable alternate syntax is to \*(C`align =&gt; [&apos;nw&apos;, &apos;c&apos;]\*(C' \*(-- i.e., to pass a reference to an array of <em>'direction'</em> items, instead of just passing a single scalar of whitespace-padded directions.</p><p>(Note that alignment syntax and cell border syntax, may look a bit alike, but are really very different; try not to mix them up.)</p>
<h3>Cell Border Syntax</h3>
<p>To specify what borders occur on cells, use one of the following syntaxes:</p><p>or use this complex syntax for finer control:</p><p>...where each \*(C`cellborders\*(C' is a string in the form "<em>border border border</em>", where, in turn, each <em>border</em> is a substring in the form <em>\*(L"direction-thickness-type\*(R",</em> <em>\*(L"direction-type\*(R"</em> <em>\*(L"direction-thickness\*(R",</em> or <em>\*(L"direction\*(R".</em> Alternately, \*(C`cellborders\*(C' can be one of these shorter values:</p><p><em>direction</em> is either \*(L"all\*(R", or a combination of some of the uppercase or lowercase letters N, S, E, W, T, B, R, L. (Of course, the first four are synonymous with the other four, respectively.)</p><p><em>thickness</em> (by default, 15) is an integer between 1 and 75, specifying the thickness of the border, in twips.</p><p>And <em>type</em> (by default, \*(L"s\*(R") is one of these, as specified in the \s-1RTF\s0 spec:</p><p>           s : Single-thickness border           th : Double-thickness border           sh : Shadowed border           db : Double border          dot : Dotted border         hair : Hairline border</p><p>        dash : Dashed border        inset : Inset border       dashsm : Dashed border (small)        dashd : Dot-dashed border       dashdd : Dot-dot-dashed border       outset : Outset border       triple : Triple border       tnthsg : Thick-thin border (small)       thtnsg : Thin-thick border (small)     tnthtnsg : Thin-thick thin border (small)       tnthmg : Thick-thin border (medium)       thtnmg : Thin-thick border (medium)     tnthtnmg : Thin-thick thin border (medium)       tnthlg : Thick-thin border (large)       thtnlg : Thin-thick border (large)     tnthtnlg : Thin-thick-thin border (large)         wavy : Wavy border       wavydb : Double wavy border   dashdotstr : Striped border       emboss : Embossed border      engrave : Engraved border        frame : Border resembles a "frame"</p><p>Not all of the above are supported by all \s-1RTF\s0 readers.  If you're concerned about portability, consider sticking to the core set of just the first six listed above.</p><p>Also, the syntax \*(C`borders =&gt; cellspec\*(C' is accepted as a synonym for \*(C`borders =&gt; [cellspec]\*(C', for when you're specifying just a single cellspec, for use the the first and all subsequent cells.</p><p>Cell border syntax is best shown by example:</p><p>  borders=&gt; [ "ns-30-db w-25", "all-10-wavy", "none", 13 ],</p><p>That means to that the first cell should have a 30-twip-thick double border on the top and bottom (north and south) and a 25-twip-thick single border on the west (and no border on the east side); the second cell should have a 10-twip-thick wavy border on all sides; the third cell should have no borders on any sides; and the fourth (and any additional) cells should have a 13-twip-thick single border on all sides.</p><p>Incidentally, when a particular <em>cellspec</em> contains apparently contradictory declarations, the last one is the one that has an effect.  For example, consider "all-20-db&nbsp;w-10-s" \*(-- the first part turns on 20-twip double borders on all sides, and the second part turns on a 10-twip single border on the west side.  Since the second part is last, that's the one that has an effect \*(-- so just the north, south, and east sides actually get a 20-twip double border, and the west side gets the 10-twip single border.</p><p>(This means that if you say "w-10-s&nbsp;all-20-db", the first part will have no effect, because the second part will override the west-side declaration.)</p>
<h3>Cell Border Syntax, Formally</h3>
<p>If you'd prefer a more formal grammar for this all, this should help:</p><p>    borderdec :=        &apos;borders&apos; =&gt;  &apos;0&apos;    # no borders at all                    | &apos;1&apos;    # same as ["all-15-s"]                    | [ cellspec, cellspec, ... ]                    | cellspec   # default for one-cell form of the above</p><p>    cellspec :=  "" | undef    # same as "all-15-s"                  | int         # same as "all-INT-s" (note: 2 &lt;= int &lt;= 75)                  | "none"      # no borders on this cell                  | (border ( &apos;, &apos; . border )* )                       # a list of border expressions separated by                       # a comma (and/or whitespace, in fact)</p><p>    border    := direction-thickness-type # For example, "nse-15-s"                  | direction-type         #  same as "DIR-15-TYPE"                  | direction-thickness    #  same as "DIR-THICK-s"                  | direction              #  same as "DIR-15-s"</p><p>    direction := "all" | qr/^[nsewtblrNSEWTBLR]+$/        # Note that "nw" doesn&apos;t mean the direction northwest, but        # simultaneously the north and west sides.</p><p>    thickness := integer in the range 1 - 75</p><p>    type  :=  "s" | "th" | "sh" | "db" | "dot" | "hair" | (etc)</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO RTF::Writer&hellip;</h2>
        <div class="sectioncontent">
<p>RTF::Cookbook</p><p>The book <em>\s-1RTF\s0 Pocket Guide</em> from O'Reilly. &lt;http://www.oreilly.com/catalog/rtfpg/&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT AND DISCLAIMER</h2>
        <div class="sectioncontent">
<p>Copyright 2001,2,3 Sean M. Burke.</p><p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p><p>This program is distributed in the hope that it will be useful, but without any warranty; without even the implied warranty of merchantability or fitness for a particular purpose.</p><p>The author of this document is not affiliated with the Microsoft corporation.</p><p>Product and company names mentioned in this document may be the trademarks or service marks of their respective owners.  Trademarks and service marks are not identified, although this must not be construed as the author's expression of validity or invalidity of each trademark or service mark.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Sean M. Burke, &lt;sburke@cpan.org&gt;</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="RTF::Document.3pm.html"><span aria-hidden="true">&larr;</span> RTF::Document.3pm: Perl extension for generating rich text (rtf) files</a></li>
   <li class="next"><a href="RTF::Writer::TableRowDecl.3pm.html">RTF::Writer::TableRowDecl.3pm: Class for rtf table settings <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ssh_channel: -behaviour(ssh_channel).</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="-behaviour(ssh_channel).">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="ssh_channel (3erl) manual">
  <meta name="twitter:description" content="-behaviour(ssh_channel).">
  <meta name="twitter:image" content="https://www.carta.tech/images/erlang-manpages-ssh_channel-3erl.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3erl/ssh_channel.3erl.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="ssh_channel (3erl) manual" />
  <meta property="og:description" content="-behaviour(ssh_channel)." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/erlang-manpages-ssh_channel-3erl.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">ssh_channel<small> (3erl)</small></h1>
        <p class="lead">-behaviour(ssh_channel).</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/ssh_channel.3erl.html">
      <span itemprop="name">ssh_channel: -behaviour(ssh_channel).</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/erlang-manpages/">
      <span itemprop="name">erlang-manpages</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/ssh_channel.3erl.html">
      <span itemprop="name">ssh_channel: -behaviour(ssh_channel).</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>SSH services (clients and servers) are implemented as channels that are multiplexed over an SSH connection and communicates via the  SSH Connection Protocol. This module provides a callback API that takes care of generic channel aspects such as flow control and close messages and lets the callback functions take care of the service (application) specific parts. This behavior also ensures that the channel process honors the principal of an OTP-process so that it can be part of a supervisor tree. This is a requirement of channel processes implementing a subsystem that will be added to the SSH applications supervisor tree.</p><p><strong></strong> Note:</p><p>When implementing a SSH subsystem use the <em>-behaviour(ssh_daemon_channel).</em> instead of <em>-behaviour(ssh_channel).</em> as the only relevant callback functions for subsystems are init/1, handle_ssh_msg/2, handle_msg/2 and terminate/2, so the ssh_daemon_channel behaviour is limited version of the ssh_channel behaviour.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DATA TYPES </h2>
        <div class="sectioncontent">
<p>Type definitions that are used more than once in this module and/or abstractions to indicate the intended use of the data type:</p><p><em>boolean() = true | false </em></p><p><em>string() = list of ASCII characters</em></p><p><em>timeout() = infinity | integer() - in milliseconds.</em></p><p><em>ssh_connection_ref() - opaque to the user returned by ssh:connect/3 or sent to an SSH channel process</em></p><p><em>ssh_channel_id() = integer() </em></p><p><em>ssh_data_type_code() = 1 ("stderr") | 0 ("normal") are currently valid values see RFC 4254  section 5.2.</em></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">
<p><strong></strong> call(ChannelRef, Msg) -&gt;</p><p><strong></strong> call(ChannelRef, Msg, Timeout) -&gt; Reply | {error, Reason}</p><p>Types:</p><p>ChannelRef = pid()</p><p>As returned by start_link/4</p><p>Msg = term()</p><p>Timeout = timeout()</p><p>Reply = term()</p><p>Reason = closed | timeout</p><p>Makes a synchronous call to the channel process by sending a message and waiting until a reply arrives or a timeout occurs. The channel will call <strong>Module:handle_call/3</strong> to handle the message. If the channel process does not exist <em>{error, closed}</em> is returned.</p><p><strong></strong> cast(ChannelRef, Msg) -&gt; ok</p><p>Types:</p><p>ChannelRef = pid()</p><p>As returned by start_link/4</p><p>Msg = term()</p><p>Sends an asynchronous message to the channel process and returns ok immediately, ignoring if the destination node or channel process does not exist. The channel will call <strong>Module:handle_cast/2</strong> to handle the message.</p><p><strong></strong> enter_loop(State) -&gt; _</p><p>Types:</p><p> State = term() - as returned by <strong>ssh_channel:init/1</strong></p><p>Makes an existing process an <em>ssh_channel</em> process. Does not return, instead the calling process will enter the <em>ssh_channel</em> process receive loop and become an <em>ssh_channel process.</em> The process must have been started using one of the start functions in proc_lib, see <strong>proc_lib(3erl)</strong>. The user is responsible for any initialization of the process and needs to call <strong>ssh_channel:init/1</strong></p><p><strong></strong> init(Options) -&gt; {ok, State} | {ok, State, Timeout} | {stop, Reason}</p><p>Types:</p><p>Options = [{Option, Value}]</p><p>State = term()</p><p>Timeout = timeout()</p><p>Reason = term()</p><p>The following options must be present:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{channel_cb, atom()}</em>: The module that implements the channel behaviour.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{init_args(), list()}</em>:  The list of arguments to the callback module's init function.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{cm, connection_ref()}</em>:  Reference to the ssh connection as returned by <strong>ssh:connect/3</strong></p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{channel_id, channel_id()}</em>:  Id of the SSH channel.</p>
  </dd>

</dl>
<p><strong></strong> Note:</p><p>This function is normally not called by the user. The user only needs to call if for some reason the channel process needs to be started with help of <em>proc_lib</em> instead of calling <em>ssh_channel:start/4</em> or <em>ssh_channel:start_link/4</em></p><p><strong></strong> reply(Client, Reply) -&gt; _</p><p>Types:</p><p>Client - opaque to the user, see explanation below</p><p>Reply = term()</p><p>This function can be used by a channel to explicitly send a reply to a client that called <em>call/[2,3]</em> when the reply cannot be defined in the return value of <strong>Module:handle_call/3</strong>.</p><p><em>Client</em> must be the <em>From</em> argument provided to the callback function <em>handle_call/3</em>. <em>Reply</em> is an arbitrary term, which will be given back to the client as the return value of <strong>ssh_channel:call/[2,3].</strong>&gt;</p><p><strong></strong> start(SshConnection, ChannelId, ChannelCb, CbInitArgs) -&gt;</p><p><strong></strong> start_link(SshConnection, ChannelId, ChannelCb, CbInitArgs) -&gt; {ok, ChannelRef} | {error, Reason}</p><p>Types:</p><p>SshConnection = ssh_connection_ref()</p><p>ChannelId = ssh_channel_id()</p><p> As returned by cannot be defined in the return value of <strong>ssh_connection:session_channel/[2,4]</strong></p><p>ChannelCb = atom()</p><p> The name of the module implementing the service specific parts of the channel.</p><p>CbInitArgs = [term()]</p><p>Argument list for the init function in the callback module.</p><p>ChannelRef = pid()</p><p>Starts a processes that handles an SSH channel. It will be called internally by the SSH daemon or explicitly by the SSH client implementations. The behavior will set the <em>trap_exit</em> flag to true.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple"> CALLBACK TIMEOUTS</h2>
        <div class="sectioncontent">
<p>The timeout values that may be returned by the callback functions has the same semantics as in a <strong>gen_server</strong> If the timeout occurs <strong>handle_msg/2</strong> will be called as <em>handle_msg(timeout, State). </em></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">
<p><strong></strong> Module:code_change(OldVsn, State, Extra) -&gt; {ok, NewState}</p><p>Types:</p><p>OldVsn = term()</p><p>In the case of an upgrade, <em>OldVsn</em> is <em>Vsn</em>, and in the case of a downgrade, <em>OldVsn</em> is <em>{down,Vsn}</em>. <em>Vsn</em> is defined by the <em>vsn</em> attribute(s) of the old version of the callback module <em>Module</em>. If no such attribute is defined, the version is the checksum of the BEAM file.</p><p>State = term()</p><p>The internal state of the channel.</p><p>Extra = term()</p><p>Passed as-is from the <em>{advanced,Extra}</em> part of the update instruction.</p><p>Converts process state when code is changed.</p><p>This function is called by a client side channel when it should update its internal state during a release upgrade/downgrade, i.e. when the instruction <em>{update,Module,Change,...}</em> where <em>Change={advanced,Extra}</em> is given in the <em>appup</em> file. See <strong>OTP Design Principles</strong> for more information.</p><p><strong></strong> Note:</p><p>Soft upgrade according to the OTP release concept is not straight forward for the server side, as subsystem channel processes are spawned by the SSH application and hence added to its supervisor tree. It could be possible to upgrade the subsystem channels, when upgrading the user application, if the callback functions can handle two versions of the state, but this function can not be used in the normal way.</p><p><strong></strong> Module:init(Args) -&gt; {ok, State} | {ok, State, timeout()} | {stop, Reason}</p><p>Types:</p><p> Args = term()</p><p> Last argument to ssh_channel:start_link/4.</p><p> State = term()</p><p> Reason = term()</p><p>Makes necessary initializations and returns the initial channel state if the initializations succeed.</p><p>For more detailed information on timeouts see the section <strong>CALLBACK TIMEOUTS</strong>.</p><p><strong></strong> Module:handle_call(Msg, From, State) -&gt; Result</p><p>Types:</p><p>Msg = term()</p><p>From = opaque to the user should be used as argument to ssh_channel:reply/2</p><p>State = term()</p><p>Result = {reply, Reply, NewState} | {reply, Reply, NewState, timeout()} | {noreply, NewState} | {noreply , NewState, timeout()} | {stop, Reason, Reply, NewState} | {stop, Reason, NewState}</p><p>Reply = term() - will be the return value of ssh_channel:call/[2,3]</p><p>NewState = term()</p><p>Reason = term()</p><p>Handles messages sent by calling <strong>ssh_channel:call/[2,3]</strong></p><p>For more detailed information on timeouts see the section <strong>CALLBACK TIMEOUTS</strong>.</p><p><strong></strong> Module:handle_cast(Msg, State) -&gt; Result</p><p>Types:</p><p>Msg = term()</p><p>State = term()</p><p>Result = {noreply, NewState} | {noreply, NewState, timeout()} | {stop, Reason, NewState}</p><p>NewState = term()</p><p>Reason = term()</p><p>Handles messages sent by calling <em>ssh_channel:cast/2</em></p><p>For more detailed information on timeouts see the section <strong>CALLBACK TIMEOUTS</strong>.</p><p><strong></strong> Module:handle_msg(Msg, State) -&gt; {ok, State} | {stop, ChannelId, State}</p><p>Types:</p><p>Msg = timeout | term()</p><p>ChannelId = ssh_channel_id()</p><p>State = term()</p><p>Handle other messages than ssh connection protocol, call or cast messages sent to the channel.</p><p>Possible erlang 'EXIT'-messages should be handled by this function and all channels should handle the following message.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{ssh_channel_up, ssh_channel_id(), ssh_connection_ref()}</em>: This is the first messages that will be received by the channel, it is sent just before the <strong>ssh_channel:init/1</strong> function returns successfully. This is especially useful if the server wants to send a message to the client without first receiving a message from it. If the message is not useful for your particular scenario just ignore it by immediately returning {ok, State}.</p>
  </dd>

</dl>
<p><strong></strong> Module:handle_ssh_msg(Msg, State) -&gt; {ok, State} | {stop, ChannelId, State}</p><p>Types:</p><p>Msg = <strong> ssh_connection:event() </strong></p><p>ChannelId = ssh_channel_id()</p><p>State = term()</p><p>Handles SSH connection protocol messages that may need service specific attention.</p><p>The following message is completely taken care of by the SSH channel behavior</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{closed, ssh_channel_id()}</em>:  The channel behavior will send a close message to the other side if such a message has not already been sent and then terminate the channel with reason normal.</p>
  </dd>

</dl>
<p><strong></strong> Module:terminate(Reason, State) -&gt; _</p><p>Types:</p><p>Reason = term()</p><p>State = term()</p><p>This function is called by a channel process when it is about to terminate. Before this function is called <strong> ssh_connection:close/2 </strong> will be called if it has not been called earlier. This function should do any necessary cleaning up. When it returns, the channel process terminates with reason <em>Reason</em>. The return value is ignored.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="ssh.3erl.html"><span aria-hidden="true">&larr;</span> ssh.3erl: Main api of the ssh application</a></li>
   <li class="next"><a href="ssh_client_key_api.3erl.html">ssh_client_key_api.3erl: Ssh_client_key_api - <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

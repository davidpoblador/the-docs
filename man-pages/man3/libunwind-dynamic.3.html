<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>libunwind-dynamic: Libunwind-support for runtime-generated code</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Libunwind-support for runtime-generated code">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="libunwind-dynamic (3) manual">
  <meta name="twitter:description" content="Libunwind-support for runtime-generated code">
  <meta name="twitter:image" content="https://www.carta.tech/images/libunwind-dev-libunwind-dynamic-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/libunwind-dynamic.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="libunwind-dynamic (3) manual" />
  <meta property="og:description" content="Libunwind-support for runtime-generated code" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libunwind-dev-libunwind-dynamic-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">libunwind-dynamic<small> (3)</small></h1>
        <p class="lead">Libunwind-support for runtime-generated code</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/libunwind-dynamic.3.html">
      <span itemprop="name">libunwind-dynamic: Libunwind-support for runtime-generated code</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libunwind-dev/">
      <span itemprop="name">libunwind-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/libunwind-dynamic.3.html">
      <span itemprop="name">libunwind-dynamic: Libunwind-support for runtime-generated code</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">INTRODUCTION</h2>
        <div class="sectioncontent">
<p>For libunwind to do its job, it needs to be able to reconstruct the <em>frame state</em> of each frame in a call-chain. The frame state describes the subset of the machine-state that consists of the <em>frame registers</em> (typically the instruction-pointer and the stack-pointer) and all callee-saved registers (preserved registers). The frame state describes each register either by providing its current value (for frame registers) or by providing the location at which the current value is stored (callee-saved registers).</p><p>For statically generated code, the compiler normally takes care of emitting <em>unwind-info</em> which provides the minimum amount of information needed to reconstruct the frame-state for each instruction in a procedure. For dynamically generated code, the runtime code generator must use the dynamic unwind-info interface provided by libunwind to supply the equivalent information. This manual page describes the format of this information in detail.</p><p>For the purpose of this discussion, a <em>procedure</em> is defined to be an arbitrary piece of <em>contiguous</em> code. Normally, each procedure directly corresponds to a function in the source-language but this is not strictly required. For example, a runtime code-generator could translate a given function into two separate (discontiguous) procedures: one for frequently-executed (hot) code and one for rarely-executed (cold) code. Similarly, simple source-language functions (usually leaf functions) may get translated into code for which the default unwind-conventions apply and for such code, it is not strictly necessary to register dynamic unwind-info.</p><p>A procedure logically consists of a sequence of <em>regions</em>. Regions are nested in the sense that the frame state at the end of one region is, by default, assumed to be the frame state for the next region. Each region is thought of as being divided into a <em>prologue</em>, a <em>body</em>, and an <em>epilogue</em>. Each of them can be empty. If non-empty, the prologue sets up the frame state for the body. For example, the prologue may need to allocate some space on the stack and save certain callee-saved registers. The body performs the actual work of the procedure but does not change the frame state in any way. If non-empty, the epilogue restores the previous frame state and as such it undoes or cancels the effect of the prologue. In fact, a single epilogue may undo the effect of the prologues of several (nested) regions.</p><p>We should point out that even though the prologue, body, and epilogue are logically separate entities, optimizing code-generators will generally interleave instructions from all three entities. For this reason, the dynamic unwind-info interface of libunwind makes no distinction whatsoever between prologue and body. Similarly, the exact set of instructions that make up an epilogue is also irrelevant. The only point in the epilogue that needs to be described explicitly by the dynamic unwind-info is the point at which the stack-pointer gets restored. The reason this point needs to be described is that once the stack-pointer is restored, all values saved in the deallocated portion of the stack frame become invalid and hence libunwind needs to know about it. The portion of the frame state not saved on the stack is assume to remain valid through the end of the region. For this reason, there is usually no need to describe instructions which restore the contents of callee-saved registers.</p><p>Within a region, each instruction that affects the frame state in some fashion needs to be described with an operation descriptor. For this purpose, each instruction in the region is assigned a unique index. Exactly how this index is derived depends on the architecture. For example, on RISC and EPIC-style architecture, instructions have a fixed size so it's possible to simply number the instructions. In contrast, most CISC use variable-length instruction encodings, so it is usually necessary to use a byte-offset as the index. Given the instruction index, the operation descriptor specifies the effect of the instruction in an abstract manner. For example, it might express that the instruction stores calle-saved register r1 at offset 16 in the stack frame.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PROCEDURES</h2>
        <div class="sectioncontent">
<p>A runtime code-generator registers the dynamic unwind-info of a procedure by setting up a structure of type unw_dyn_info_t and calling _U_dyn_register(), passing the address of the structure as the sole argument. The members of the unw_dyn_info_t structure are described below:</p>
<dl class='dl-vertical'>
  <dt>
    <p>void *next</p>
  </dt>
  <dd>
    <p> Private to libunwind. Must not be used by the application.</p>
  </dd>
  <dt>
    <p>void *prev</p>
  </dt>
  <dd>
    <p> Private to libunwind. Must not be used by the application.</p>
  </dd>
  <dt>
    <p>unw_word_t start_ip</p>
  </dt>
  <dd>
    <p> The start-address of the instructions of the procedure (remember: procedure are defined to be contiguous pieces of code, so a single code-range is sufficient).</p>
  </dd>
  <dt>
    <p>unw_word_t end_ip</p>
  </dt>
  <dd>
    <p> The end-address of the instructions of the procedure (non-inclusive, that is, end_ip-start_ip is the size of the procedure in bytes).</p>
  </dd>
  <dt>
    <p>unw_word_t gp</p>
  </dt>
  <dd>
    <p> The global-pointer value in use for this procedure. The exact meaing of the global-pointer is architecture-specific and on some architecture, it is not used at all.</p>
  </dd>
  <dt>
    <p>int32_t format</p>
  </dt>
  <dd>
    <p> The format of the unwind-info. This member can be one of UNW_INFO_FORMAT_DYNAMIC, UNW_INFO_FORMAT_TABLE, or UNW_INFO_FORMAT_REMOTE_TABLE.</p>
  </dd>
  <dt>
    <p>union u</p>
  </dt>
  <dd>
    <p> This union contains one sub-member structure for every possible unwind-info format:</p>
<dl class='dl-vertical'>
  <dt>
    <p>unw_dyn_proc_info_t pi</p>
  </dt>
  <dd>
    <p> This member is used for format UNW_INFO_FORMAT_DYNAMIC.</p>
  </dd>
  <dt>
    <p>unw_dyn_table_info_t ti</p>
  </dt>
  <dd>
    <p> This member is used for format UNW_INFO_FORMAT_TABLE.</p>
  </dd>
  <dt>
    <p>unw_dyn_remote_table_info_t rti</p>
  </dt>
  <dd>
    <p> This member is used for format UNW_INFO_FORMAT_REMOTE_TABLE.</p>
  </dd>

</dl>
<p>The format of these sub-members is described in detail below.</p>
  </dd>

</dl>
<h3>PROC-INFO FORMAT</h3>
<p>This is the preferred dynamic unwind-info format and it is generally the one used by full-blown runtime code-generators. In this format, the details of a procedure are described by a structure of type unw_dyn_proc_info_t. This structure contains the following members:</p>
<dl class='dl-vertical'>
  <dt>
    <p>unw_word_t name_ptr</p>
  </dt>
  <dd>
    <p> The address of a (human-readable) name of the procedure or 0 if no such name is available. If non-zero, The string stored at this address must be ASCII NUL terminated. For source languages that use name-mangling (such as C++ or Java) the string stored at this address should be the <em>demangled</em> version of the name.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>unw_word_t handler</p>
  </dt>
  <dd>
    <p> The address of the personality-routine for this procedure. Personality-routines are used in conjunction with exception handling. See the C++ ABI draft (http://www.codesourcery.com/cxx-abi/) for an overview and a description of the personality routine. If the procedure has no personality routine, handler must be set to 0.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>uint32_t flags</p>
  </dt>
  <dd>
    <p> A bitmask of flags. At the moment, no flags have been defined and this member must be set to 0.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>unw_dyn_region_info_t *regions</p>
  </dt>
  <dd>
    <p> A NULL-terminated linked list of region-descriptors. See section ``Region descriptors'' below for more details.</p>
  </dd>

</dl>

<h3>TABLE-INFO FORMAT</h3>
<p>This format is generally used when the dynamically generated code was derived from static code and the unwind-info for the dynamic and the static versions is identical. For example, this format can be useful when loading statically-generated code into an address-space in a non-standard fashion (i.e., through some means other than dlopen()). In this format, the details of a group of procedures is described by a structure of type unw_dyn_table_info. This structure contains the following members:</p>
<dl class='dl-vertical'>
  <dt>
    <p>unw_word_t name_ptr</p>
  </dt>
  <dd>
    <p> The address of a (human-readable) name of the procedure or 0 if no such name is available. If non-zero, The string stored at this address must be ASCII NUL terminated. For source languages that use name-mangling (such as C++ or Java) the string stored at this address should be the <em>demangled</em> version of the name.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>unw_word_t segbase</p>
  </dt>
  <dd>
    <p> The segment-base value that needs to be added to the segment-relative values stored in the unwind-info. The exact meaning of this value is architecture-specific.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>unw_word_t table_len</p>
  </dt>
  <dd>
    <p> The length of the unwind-info (table_data) counted in units of words (unw_word_t).</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>unw_word_t table_data</p>
  </dt>
  <dd>
    <p> A pointer to the actual data encoding the unwind-info. The exact format is architecture-specific (see architecture-specific sections below).</p>
  </dd>

</dl>

<h3>REMOTE TABLE-INFO FORMAT</h3>
<p>The remote table-info format has the same basic purpose as the regular table-info format. The only difference is that when libunwind uses the unwind-info, it will keep the table data in the target address-space (which may be remote). Consequently, the type of the table_data member is unw_word_t rather than a pointer. This implies that libunwind will have to access the table-data via the address-space's access_mem() call-back, rather than through a direct memory reference.</p><p>From the point of view of a runtime-code generator, the remote table-info format offers no advantage and it is expected that such generators will describe their procedures either with the proc-info format or the normal table-info format. The main reason that the remote table-info format exists is to enable the address-space-specific find_proc_info() callback (see <a href="../man3/unw_create_addr_space.3.html"><strong>unw_create_addr_space</strong>(3)</a>) to return unwind tables whose data remains in remote memory. This can speed up unwinding (e.g., for a debugger) because it reduces the amount of data that needs to be loaded from remote memory.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REGIONS DESCRIPTORS</h2>
        <div class="sectioncontent">
<p>A region descriptor is a variable length structure that describes how each instruction in the region affects the frame state. Of course, most instructions in a region usualy do not change the frame state and for those, nothing needs to be recorded in the region descriptor. A region descriptor is a structure of type unw_dyn_region_info_t and has the following members:</p>
<dl class='dl-vertical'>
  <dt>
    <p>unw_dyn_region_info_t *next</p>
  </dt>
  <dd>
    <p> A pointer to the next region. If this is the last region, next is NULL.</p>
  </dd>
  <dt>
    <p>int32_t insn_count</p>
  </dt>
  <dd>
    <p> The length of the region in instructions. Each instruction is assumed to have a fixed size (see architecture-specific sections for details). The value of insn_count may be negative in the last region of a procedure (i.e., it may be negative only if next is NULL). A negative value indicates that the region covers the last <em>N</em> instructions of the procedure, where <em>N</em> is the absolute value of insn_count.</p>
  </dd>
  <dt>
    <p>uint32_t op_count</p>
  </dt>
  <dd>
    <p> The (allocated) length of the op_count array.</p>
  </dd>
  <dt>
    <p>unw_dyn_op_t op</p>
  </dt>
  <dd>
    <p> An array of dynamic unwind directives. See Section ``Dynamic unwind directives'' for a description of the directives.</p>
  </dd>

</dl>
<p>A region descriptor with an insn_count of zero is an <em>empty region</em> and such regions are perfectly legal. In fact, empty regions can be useful to establish a particular frame state before the start of another region.</p><p>A single region list can be shared across multiple procedures provided those procedures share a common prologue and epilogue (their bodies may differ, of course). Normally, such procedures consist of a canned prologue, the body, and a canned epilogue. This could be described by two regions: one covering the prologue and one covering the epilogue. Since the body length is variable, the latter region would need to specify a negative value in insn_count such that libunwind knows that the region covers the end of the procedure (up to the address specified by end_ip).</p><p>The region descriptor is a variable length structure to make it possible to allocate all the necessary memory with a single memory-allocation request. To facilitate the allocation of a region descriptors libunwind provides a helper routine with the following synopsis:</p><p>size_t _U_dyn_region_size(int op_count);</p><p>This routine returns the number of bytes needed to hold a region descriptor with space for op_count unwind directives. Note that the length of the op array does not have to match exactly with the number of directives in a region. Instead, it is sufficient if the op array contains at least as many entries as there are directives, since the end of the directives can always be indicated with the UNW_DYN_STOP directive.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DYNAMIC UNWIND DIRECTIVES</h2>
        <div class="sectioncontent">
<p>A dynamic unwind directive describes how the frame state changes at a particular point within a region. The description is in the form of a structure of type unw_dyn_op_t. This structure has the following members:</p>
<dl class='dl-vertical'>
  <dt>
    <p>int8_t tag</p>
  </dt>
  <dd>
    <p> The operation tag. Must be one of the unw_dyn_operation_t values described below.</p>
  </dd>
  <dt>
    <p>int8_t qp</p>
  </dt>
  <dd>
    <p> The qualifying predicate that controls whether or not this directive is active. This is useful for predicated architecturs such as IA-64 or ARM, where the contents of another (callee-saved) register determines whether or not an instruction is executed (takes effect). If the directive is always active, this member should be set to the manifest constant _U_QP_TRUE (this constant is defined for all architectures, predicated or not).</p>
  </dd>
  <dt>
    <p>int16_t reg</p>
  </dt>
  <dd>
    <p> The number of the register affected by the instruction.</p>
  </dd>
  <dt>
    <p>int32_t when</p>
  </dt>
  <dd>
    <p> The region-relative number of the instruction to which this directive applies. For example, a value of 0 means that the effect described by this directive has taken place once the first instruction in the region has executed.</p>
  </dd>
  <dt>
    <p>unw_word_t val</p>
  </dt>
  <dd>
    <p> The value to be applied by the operation tag. The exact meaning of this value varies by tag. See Section ``Operation tags'' below.</p>
  </dd>

</dl>
<p>It is perfectly legitimate to specify multiple dynamic unwind directives with the same when value, if a particular instruction has a complex effect on the frame state.</p><p>Empty regions by definition contain no actual instructions and as such the directives are not tied to a particular instruction. By convention, the when member should be set to 0, however.</p><p>There is no need for the dynamic unwind directives to appear in order of increasing when values. If the directives happen to be sorted in that order, it may result in slightly faster execution, but a runtime code-generator should not go to extra lengths just to ensure that the directives are sorted.</p><p>IMPLEMENTATION NOTE: should libunwind implementations for certain architectures prefer the list of unwind directives to be sorted, it is recommended that such implementations first check whether the list happens to be sorted already and, if not, sort the directives explicitly before the first use. With this approach, the overhead of explicit sorting is only paid when there is a real benefit and if the runtime code-generator happens to generated sorted lists naturally, the performance penalty is limited to a simple O(N) check.</p><h3>OPERATIONS TAGS</h3>
<p>The possible operation tags are defined by enumeration type unw_dyn_operation_t which defines the following values:</p>
<dl class='dl-vertical'>
  <dt>
    <p>UNW_DYN_STOP</p>
  </dt>
  <dd>
    <p> Marks the end of the dynamic unwind directive list. All remaining entries in the op array of the region-descriptor are ignored. This tag is guaranteed to have a value of 0.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>UNW_DYN_SAVE_REG</p>
  </dt>
  <dd>
    <p> Marks an instruction which saves register reg to register val.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>UNW_DYN_SPILL_FP_REL</p>
  </dt>
  <dd>
    <p> Marks an instruction which spills register reg to a frame-pointer-relative location. The frame-pointer-relative offset is given by the value stored in member val. See the architecture-specific sections for a description of the stack frame layout.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>UNW_DYN_SPILL_SP_REL</p>
  </dt>
  <dd>
    <p> Marks an instruction which spills register reg to a stack-pointer-relative location. The stack-pointer-relative offset is given by the value stored in member val. See the architecture-specific sections for a description of the stack frame layout.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>UNW_DYN_ADD</p>
  </dt>
  <dd>
    <p> Marks an instruction which adds the constant value val to register reg. To add subtract a constant value, store the two's-complement of the value in val. The set of registers that can be specified for this tag is described in the architecture-specific sections below.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>UNW_DYN_POP_FRAMES</p>
  </dt>
  <dd>
    <p> .PP</p>
  </dd>
  <dt>
    <p>UNW_DYN_LABEL_STATE</p>
  </dt>
  <dd>
    <p> .PP</p>
  </dd>
  <dt>
    <p>UNW_DYN_COPY_STATE</p>
  </dt>
  <dd>
    <p> .PP</p>
  </dd>
  <dt>
    <p>UNW_DYN_ALIAS</p>
  </dt>
  <dd>
    <p> .PP unw_dyn_op_t</p>
  </dd>

</dl>
<p>_U_dyn_op_save_reg(); _U_dyn_op_spill_fp_rel(); _U_dyn_op_spill_sp_rel(); _U_dyn_op_add(); _U_dyn_op_pop_frames(); _U_dyn_op_label_state(); _U_dyn_op_copy_state(); _U_dyn_op_alias(); _U_dyn_op_stop();</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">IA-64 SPECIFICS</h2>
        <div class="sectioncontent">
<p>- meaning of segbase member in table-info/table-remote-info format - format of table_data in table-info/table-remote-info format - instruction size: each bundle is counted as 3 instructions, regardless of template (MLX) - describe stack-frame layout, especially with regards to sp-relative and fp-relative addressing - UNW_DYN_ADD can only add to ``sp'' (always a negative value); use POP_FRAMES otherwise</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO libunwind-dynamic&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man3/libunwind.3.html"><strong>libunwind</strong>(3)</a>, <a href="../man3/_U_dyn_register.3.html"><strong>_U_dyn_register</strong>(3)</a>, <a href="../man3/_U_dyn_cancel.3.html"><strong>_U_dyn_cancel</strong>(3)</a></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>David Mosberger-Tang</p><p>Email: <strong>dmosberger@gmail.com</strong></p><p>WWW: <strong>http://www.nongnu.org/libunwind/</strong>.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="libunwind.3.html"><span aria-hidden="true">&larr;</span> libunwind.3: A (mostly) platform-independent unwind api</a></li>
   <li class="next"><a href="libunwind-ia64.3.html">libunwind-ia64.3: Ia-64-specific support in libunwind <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

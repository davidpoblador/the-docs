<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Astro::FITS::Header: Object orientated interface to fits hdus</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Object orientated interface to fits hdus">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Astro::FITS::Header (3pm) manual">
  <meta name="twitter:description" content="Object orientated interface to fits hdus">
  <meta name="twitter:image" content="https://www.carta.tech/images/libastro-fits-header-perl-Astro::FITS::Header-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Astro::FITS::Header.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Astro::FITS::Header (3pm) manual" />
  <meta property="og:description" content="Object orientated interface to fits hdus" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libastro-fits-header-perl-Astro::FITS::Header-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Astro::FITS::Header<small> (3pm)</small></h1>
        <p class="lead">Object orientated interface to fits hdus</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Astro::FITS::Header.3pm.html">
      <span itemprop="name">Astro::FITS::Header: Object orientated interface to fits hdus</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libastro-fits-header-perl/">
      <span itemprop="name">libastro-fits-header-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Astro::FITS::Header.3pm.html">
      <span itemprop="name">Astro::FITS::Header: Object orientated interface to fits hdus</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  $header = new Astro::FITS::Header( Cards =&gt; &#92;@array );
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Stores information about a \s-1FITS\s0 header block in an object. Takes an hash with an array reference as an argument. The array should contain a list of \s-1FITS\s0 header cards as input.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">
<h3>Constructor</h3>

<dl class='dl-vertical'>
  <dt>
    <strong>new</strong>
  </dt>
  <dd>
    <p>Create a new instance from an array of \s-1FITS\s0 header cards.   $item = new Astro::FITS::Header( Cards =&gt; &#92;@header ); returns a reference to a Header object.  If you pass in no cards, you get the (required) first \s-1SIMPLE\s0 card for free.</p>
  </dd>

</dl>

<h3>Accessor Methods</h3>

<dl class='dl-vertical'>
  <dt>
    <strong>tiereturnsref</strong>
  </dt>
  <dd>
    <p>Indicates whether the tied object should return multiple values as a single string joined by newline characters (false) or it should return a reference to an array containing all the values. Only affects the tied interface.   tie %keywords, "Astro::FITS::Header", $header, tiereturnsref =&gt; 1;   $ref = $keywords{COMMENT}; Defaults to returning a single string in all cases (for backwards compatibility)</p>
  </dd>
  <dt>
    <strong>subhdrs</strong>
  </dt>
  <dd>
    <p>Set or return the subheaders for a Header object. Arguments must be given as \*(C`Astro::FITS::Header\*(C' objects.     $header-&gt;subhdrs(@hdrs);     @hdrs = $header-&gt;subhdrs; This method should be used when you have additional header components that should be associated with the primary header but they are not associated with a particular name, just an ordering. \s-1FITS\s0 headers that are associated with a name can be stored directly in the header using an \*(C`Astro::FITS::Header::Item\*(C' of type '\s-1HEADER\s0'.</p>
  </dd>
  <dt>
    <strong>item</strong>
  </dt>
  <dd>
    <p>Returns a FITS::Header:Item object referenced by index, \*(C`undef\*(C' if it does not exist.    $item = $header-&gt;item($index);</p>
  </dd>
  <dt>
    <strong>get_wcs</strong>
  </dt>
  <dd>
    <p>Returns a Starlink::AST FrameSet object representing the \s-1WCS\s0 of the \s-1FITS\s0 Header.    $ast = $header-&gt;get_wcs();</p>
  </dd>
  <dt>
    <strong>keyword</strong>
  </dt>
  <dd>
    <p>Returns keyword referenced by index, \*(C`undef\*(C' if it does not exist.    $keyword = $header-&gt;keyword($index);</p>
  </dd>
  <dt>
    <strong>itembyname</strong>
  </dt>
  <dd>
    <p>Returns an array of Header::Items for the requested keyword if called in list context, or the first matching Header::Item if called in scalar context. Returns \*(C`undef\*(C' if the keyword does not exist.  The keyword may be a regular expression created with the \*(C`qr\*(C' operator.    @items = $header-&gt;itembyname($keyword);    $item = $header-&gt;itembyname($keyword);</p>
  </dd>
  <dt>
    <strong>itembytype</strong>
  </dt>
  <dd>
    <p>Returns an array of Header::Items for the requested type if called in list context, or the first matching Header::Item if called in scalar context. See \*(C`Astro::FITS::Header::Item\*(C' for a list of allowed types.    @items = $header-&gt;itembytype( "COMMENT" );    @items = $header-&gt;itembytype( "HEADER" );    $item = $header-&gt;itembytype( "INT" );</p>
  </dd>
  <dt>
    <strong>index</strong>
  </dt>
  <dd>
    <p>Returns an array of indices for the requested keyword if called in list context, or an empty array if it does not exist.  The keyword may be a regular expression created with the \*(C`qr\*(C' operator.    @index = $header-&gt;index($keyword); If called in scalar context it returns the first item in the array, or \*(C`undef\*(C' if the keyword does not exist.    $index = $header-&gt;index($keyword);</p>
  </dd>
  <dt>
    <strong>value</strong>
  </dt>
  <dd>
    <p>Returns an array of values for the requested keyword if called in list context, or an empty array if it does not exist.  The keyword may be a regular expression created with the \*(C`qr\*(C' operator.    @value = $header-&gt;value($keyword); If called in scalar context it returns the first item in the array, or \*(C`undef\*(C' if the keyword does not exist.</p>
  </dd>
  <dt>
    <strong>comment</strong>
  </dt>
  <dd>
    <p>Returns an array of comments for the requested keyword if called in list context, or an empty array if it does not exist.  The keyword may be a regular expression created with the \*(C`qr\*(C' operator.    @comment = $header-&gt;comment($keyword); If called in scalar context it returns the first item in the array, or \*(C`undef\*(C' if the keyword does not exist.    $comment = $header-&gt;comment($keyword);</p>
  </dd>
  <dt>
    <strong>insert</strong>
  </dt>
  <dd>
    <p>Inserts a \s-1FITS\s0 header card object at position $index    $header-&gt;insert($index, $item); the object $item is not copied, multiple inserts of the same object mean that future modifications to the one instance of the inserted object will modify all inserted copies. The insert position can be negative.</p>
  </dd>
  <dt>
    <strong>replace</strong>
  </dt>
  <dd>
    <p>Replace \s-1FITS\s0 header card at index $index with card $item    $card = $header-&gt;replace($index, $item); returns the replaced card.</p>
  </dd>
  <dt>
    <strong>remove</strong>
  </dt>
  <dd>
    <p>Removes a \s-1FITS\s0 header card object at position $index    $card = $header-&gt;remove($index); returns the removed card.</p>
  </dd>
  <dt>
    <strong>replacebyname</strong>
  </dt>
  <dd>
    <p>Replace \s-1FITS\s0 header cards with keyword $keyword with card $item    $card = $header-&gt;replacebyname($keyword, $item); returns the replaced card. The keyword may be a regular expression created with the \*(C`qr\*(C' operator.</p>
  </dd>
  <dt>
    <strong>removebyname</strong>
  </dt>
  <dd>
    <p>Removes a \s-1FITS\s0 header card object by name   @card = $header-&gt;removebyname($keyword); returns the removed cards.  The keyword may be a regular expression created with the \*(C`qr\*(C' operator.</p>
  </dd>
  <dt>
    <strong>splice</strong>
  </dt>
  <dd>
    <p>Implements a standard splice operation for \s-1FITS\s0 headers    @cards = $header-&gt;splice($offset [,$length [, @list]]);    $last_card = $header-&gt;splice($offset [,$length [, @list]]); Removes the \s-1FITS\s0 header cards from the header designated by $offset and $length, and replaces them with @list (if specified) which must be an array of FITS::Header::Item objects. Returns the cards removed. If offset is negative, counts from the end of the \s-1FITS\s0 header.</p>
  </dd>
  <dt>
    <strong>cards</strong>
  </dt>
  <dd>
    <p>Return the object contents as an array of \s-1FITS\s0 cards.   @array = $header-&gt;cards;</p>
  </dd>
  <dt>
    <strong>sizeof</strong>
  </dt>
  <dd>
    <p>Returns the highest index in use in the \s-1FITS\s0 header. To get the total number of header items, add 1.   $number = $header-&gt;sizeof;</p>
  </dd>
  <dt>
    <strong>allitems</strong>
  </dt>
  <dd>
    <p>Returns the header as an array of FITS::Header:Item objects.    @items = $header-&gt;allitems();</p>
  </dd>

</dl>

<h3>General Methods</h3>

<dl class='dl-vertical'>
  <dt>
    <strong>configure</strong>
  </dt>
  <dd>
    <p>Configures the object, takes an array of \s-1FITS\s0 header cards, an array of Astro::FITS::Header::Item objects or a simple hash as input. If you feed in nothing at all, it uses a default array containing just the \s-1SIMPLE\s0 card required at the top of all \s-1FITS\s0 files.   $header-&gt;configure( Cards =&gt; &#92;@array );   $header-&gt;configure( Items =&gt; &#92;@array );   $header-&gt;configure( Hash =&gt; &#92;%hash ); Does nothing if the array is not supplied. If the hash scheme is used and the hash contains the special key of \s-1SUBHEADERS\s0 pointing to an array of hashes, these will be read as proper sub headers. All other references in the hash will be ignored. Note that the default key order will be retained in the object created via the hash.</p>
  </dd>
  <dt>
    <strong>merge_primary</strong>
  </dt>
  <dd>
    <p>Given the current header and a set of \*(C`Astro::FITS::Header\*(C' objects, return a merged \s-1FITS\s0 header (with the cards that have the same value and comment across all headers) along with, for each input, header objects containing all the header items that differ (including, by default, keys that are not present in all headers). Only the primary headers are merged, subheaders are ignored.  ($clone) = $headerr-&gt;merge_primary();  ($same, @different) = $header-&gt;merge_primary( $fits1, $fits2, ...);  ($same, @different) = $header-&gt;merge_primary( &#92;%options, $fits1, $fits2 ); @different can be empty if all headers match (but see the \*(C`force_return_diffs\*(C' option) but if any headers are different there will always be the same number of headers in @different as supplied to the function (including the reference header). A clone of the input header (stripped of any subheaders) is returned if no comparison headers are supplied. In scalar context, just returns the merged header.   $merged = $header-&gt;merge_primary( @hdrs ); The options hash is itself optional. It contains the following keys:  merge_unique - if an item is identical across multiple headers and only                 exists in those headers, propogate to the merged header rather                 than storing it in the difference headers.</p><p> force_return_diffs - return an empty difference object per input header                       even if there are no diffs</p>
  </dd>
  <dt>
    <strong>freeze</strong>
  </dt>
  <dd>
    <p>Method to return a blessed reference to the object so that we can store ths object on disk using Data::Dumper module.</p>
  </dd>
  <dt>
    <strong>append</strong>
  </dt>
  <dd>
    <p>Append or update a card.   $header-&gt;append( $card ); This method can take either an Astro::FITS::Header::Item object, an Astro::FITS::Header object, or a reference to an array of Astro::FITS::Header::Item objects. In all cases, if the given Astro::FITS::Header::Item keyword exists in the header, then the value will be overwritten with the one passed to the method. Otherwise, the card will be appended to the end of the header. Nothing is returned.</p>
  </dd>

</dl>

<h3>Operator Overloading</h3>
<p>These operators are overloaded: When the object is used in a string context the \s-1FITS\s0 header block is returned as a single string.</p>
<h3>Private methods</h3>
<p>These methods are for internal use only.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>_rebuild_lookup</strong>
  </dt>
  <dd>
    <p>Private function used to rebuild the lookup table after modifying the header block, its easier to do it this way than go through and add one to the indices of all header cards following the modifed card.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">TIED INTERFACE</h2>
        <div class="sectioncontent">
<p>The \*(C`FITS::Header\*(C' object can also be tied to a hash:</p><p>   use Astro::FITS::Header;</p><p>   $header = new Astro::FITS::Header( Cards =&gt; &#92;@array );    tie %hash, "Astro::FITS::Header", $header</p><p>   $value = $hash{$keyword};    $hash{$keyword} = $value;</p><p>   print "keyword $keyword is present" if exists $hash{$keyword};</p><p>   foreach my $key (keys %hash) {       print "$key = $hash{$key}&#92;n";    }</p><h3>Basic hash translation</h3>
<p>Header value type is determined on-the-fly by parsing of the input values. Anything that parses as a number or a logical is converted to that before being put in a card (but see below).</p><p>Per-card comment fields can be accessed using the tied interface by specifying a key name of \*(L"key_COMMENT\*(R". This works because in general \*(L"_COMMENT\*(R" is too long to be confused with a normal key name.</p><p>  $comment = $hdr{CRPIX1_COMMENT};</p><p>will return the comment associated with \s-1CRPIX1\s0 header item. The comment can be modified in the same way:</p><p>  $hdr{CRPIX1_COMMENT} = "An axis";</p><p>You can also modify the comment by slash-delimiting it when setting the associated keyword:</p><p>  $hdr{CRPIX1} = "34 / Set this field manually";</p><p>If you want an actual slash character in your string field you must escape it with a backslash.  (If you're in double quotes you have to use a double backslash):</p><p>  $hdr{SLASHSTR} = &apos;foo&#92;/bar / field contains "foo/bar"&apos;;</p><p>Keywords are CaSE-inNSEnSiTIvE, unlike normal hash keywords.  All keywords are translated to upper case internally, per the \s-1FITS\s0 standard.</p><p>Aside from the \s-1SIMPLE\s0 and \s-1END\s0 keywords, which are automagically placed at the beginning and end of the header respectively, keywords are included in the header in the order received.  This gives you a modicum of control over card order, but if you actually care what order they're in, you probably don't want the tied interface.</p>
<h3>Comment cards</h3>
<p>Comment cards are a special case because they have no normal value and their comment field is treated as the hash value.  The keywords \*(L"\s-1COMMENT\s0\*(R" and \*(L"\s-1HISTORY\s0\*(R" are magic and refer to comment cards; nearly all other keywords create normal valued cards.  (see \*(L"\s-1SIMPLE\s0 and \s-1END\s0 cards\*(R", below).</p>
<h3>Multi-card values</h3>
<p>Multiline string values are broken up, one card per line in the string.  Extra-long string values are handled gracefully: they get split among multiple cards, with a backslash at the end of each card image.  They're transparently reassembled when you access the data, so that there is a strong analogy between multiline string values and multiple cards.</p><p>In general, appending to hash entries that look like strings does what you think it should.  In particular, comment cards have a newline appended automatically on \s-1FETCH\s0, so that</p><p>  $hash{HISTORY} .= "Added multi-line string support";</p><p>adds a new \s-1HISTORY\s0 comment card, while</p><p>  $hash{TELESCOP} .= " dome B";</p><p>only modifies an existing \s-1TELESCOP\s0 card.</p><p>You can make multi-line values by feeding in newline-delimited strings, or by assigning from an array ref.  If you ask for a tag that has a multiline value it's always expanded to a multiline string, even if you fed in an array ref to start with.  That's by design: multiline string expansion often acts as though you are getting just the first value back out, because perl string-to-number conversion stops at the first newline.  So:</p><p>  $hash{CDELT1} = [3,4,5];   print $hash{CDELT1} + 99,"&#92;n$hash{CDELT1}";</p><p>prints \*(L"102&#92;n3&#92;n4&#92;n5\*(R", and then</p><p>  $hash{CDELT1}++;   print $hash{CDELT1};</p><p>prints \*(L"4\*(R".</p><p>In short, most of the time you get what you want.  But you can always fall back on the non-tied interface by calling methods like so:</p><p>  ((tied $hash)-&gt;method())</p><p>If you prefer to have multi-valued items automagically become array refs, then you can get that behavior using the \*(C`tiereturnsref\*(C' method:</p><p>  tie %keywords, "Astro::FITS::Header", $header, tiereturnsref =&gt; 1;</p><p>When tiereturnsref is true, multi-valued items will be returned via a reference to an array (ties do not respect calling context). Note that if this is configured you will have to test each return value to see whether it is returning a real value or a reference to an array if you are not sure whether there will be more than one card with a duplicate name.</p>
<h3>Type forcing</h3>
<p>Because perl uses behind-the-scenes typing, there is an ambiguity between strings and numeric and/or logical values: sometimes you want to create a \s-1STRING\s0 card whose value could parse as a number or as a logical value, and perl kindly parses it into a number for you.  To force string evaluation, feed in a trivial array ref:</p><p>  $hash{NUMSTR} = 123;     # generates an INT card containing 123.   $hash{NUMSTR} = "123";   # generates an INT card containing 123.   $hash{NUMSTR} = ["123"]; # generates a STRING card containing "123".   $hash{NUMSTR} = [123];   # generates a STRING card containing "123".</p><p>  $hash{ALPHA} = "T";      # generates a LOGICAL card containing T.   $hash{ALPHA} = ["T"];    # generates a STRING card containing "T".</p><p>Calls to <em>keys()</em> or <em>each()</em> will, by default, return the keywords in the order in which they appear in the header.</p>
<h3>Sub-headers</h3>
<p>When the key refers to a subheader entry (ie an item of type \*(L"\s-1HEADER\s0\*(R"), a hash reference is returned.  If a hash reference is stored in a value it is converted to a \*(C`Astro::FITS::Header\*(C' object.</p><p>If the special key \*(L"\s-1SUBHEADERS\s0\*(R" is used, it will return the array of subheaders, (as stored using the \*(C`subhdrs\*(C' method) each of which will be tied to a hash. Subheaders can be stored using normal array operations.</p>
<h3>\s-1SIMPLE\s0 and \s-1END\s0 cards</h3>
<p>No \s-1FITS\s0 interface would becomplete without special cases.</p><p>When you assign to \s-1SIMPLE\s0 or \s-1END\s0, the tied interface ensures that they are first or last, respectively, in the deck \*(-- as the \s-1FITS\s0 standard requires.  Other cards are inserted in between the first and last elements, in the order that you define them.</p><p>The \s-1SIMPLE\s0 card is forced to \s-1FITS\s0 \s-1LOGICAL\s0 (boolean) type.  The \s-1FITS\s0 standard forbids you from setting it to F, but you can if you want \*(-- we're not the \s-1FITS\s0 police.</p><p>The \s-1END\s0 card is forced to a null type, so any value you assign to it will fall on the floor.  If present in the deck, the \s-1END\s0 keyword always contains the value \*(L" \*(R", which is both more-or-less invisible when printed and also true \*(-- so you can test the return value to see if an \s-1END\s0 card is present.</p><p>\s-1SIMPLE\s0 and \s-1END\s0 come pre-defined from the constructor.  If for some nefarious reason you want to remove them you must explicitly do so with \*(L"delete\*(R" or the appropriate method call from the object interface.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Astro::FITS::Header&hellip;</h2>
        <div class="sectioncontent">
<p>\*(C`Astro::FITS::Header::Item\*(C', \*(C`Starlink::AST\*(C', \*(C`Astro::FITS::Header::CFITSIO\*(C', \*(C`Astro::FITS::Header::Item::NDF\*(C'.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright (C) 2007-2011 Science and Technology Facilties Council. Copyright (C) 2001-2007 Particle Physics and Astronomy Research Council and portions Copyright (C) 2002 Southwest Research Institute. All Rights Reserved.</p><p>This program is free software; you can redistribute it and/or modify it under the terms of the \s-1GNU\s0 General Public License as published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version.</p><p>This program is distributed in the hope that it will be useful,but \s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of \s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0. See the \s-1GNU\s0 General Public License for more details.</p><p>You should have received a copy of the \s-1GNU\s0 General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place,Suite 330, Boston, \s-1MA\s0  02111-1307, \s-1USA\s0</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p>Alasdair Allan &lt;aa@astro.ex.ac.uk&gt;, Tim Jenness &lt;t.jenness@jach.hawaii.edu&gt;, Craig DeForest &lt;deforest@boulder.swri.edu&gt;, Jim Lewis &lt;jrl@ast.cam.ac.uk&gt;, Brad Cavanagh &lt;b.cavanagh@jach.hawaii.edu&gt;</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Asterisk::Voicemail.3pm.html"><span aria-hidden="true">&larr;</span> Asterisk::Voicemail.3pm: Stuff to deal with asterisk voicemail</a></li>
   <li class="next"><a href="Astro::FITS::Header::AST.3pm.html">Astro::FITS::Header::AST.3pm: Manipulates fits headers from an ast object <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

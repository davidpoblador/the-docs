<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>pmdaeventqueue - utilities for PMDAs managing event queues</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Utilities for pmdas managing event queues">
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">pmdaeventqueue<small> (3)</small></h1>
        <p class="lead">Utilities for pmdas managing event queues</p>
      </div>

    <ol class="breadcrumb">
	<li itemscope itemtype="http://data-vocabulary.org/Breadcrumb" itemref="breadcrumb_section">
		<a itemprop="url" href="/"><span itemprop="title">Carta.tech</span></a>
	</li>
	<li itemscope itemtype="http://data-vocabulary.org/Breadcrumb" itemref="breadcrumb_section">
		<a itemprop="url" href="https://www.carta.tech/man-pages/"><span itemprop="title">man-pages</span></a>
	</li>
	<li id="breadcrumb_section" itemscope itemtype="http://data-vocabulary.org/Breadcrumb" itemref="breadcrumb_page" itemprop="child">
		<a itemprop="url" href="https://www.carta.tech/man-pages/man3/"><span itemprop="title">Library calls</span></a>
	</li>
	<li id="breadcrumb_page" itemscope itemtype="http://data-vocabulary.org/Breadcrumb" itemprop="child" class="active">
		<a itemprop="url" href="https://www.carta.tech/man-pages/man3/pmdaeventqueue.3.html"><span itemprop="title">pmdaeventqueue</span></a>
	</li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">C SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>#include &lt;pcp/pmapi.h&gt;
#include &lt;pcp/pmda.h&gt;</pre>

<p class='spacer'>

<p>int pmdaEventNewQueue(const char *<em>name</em>, size_t <em>maxmem</em>);</p>
<p class='spacer'>

<p>int pmdaEventNewActiveQueue(const char *<em>name</em>, size_t <em>maxmem</em>,  int <em>nclients</em>);</p>
<p class='spacer'>

<p>int pmdaEventQueueHandle(const char *<em>name</em>);</p>
<p class='spacer'>

<p>int pmdaEventQueueAppend(int <em>handle</em>, void *<em>buffer</em>, size_t <em>bytes</em>, struct timeval *<em>tv</em>);</p>
<p class='spacer'>

<p>int pmdaEventQueueShutdown(int <em>handle</em>);</p>
<p class='spacer'>

<p class='spacer'>

<p>typedef int (*pmdaEventDecodeCallBack)(int, void *, int, struct timeval *, void *);</p>
<p class='spacer'>

<p>int pmdaEventQueueRecords(int <em>handle</em>, pmAtomValue *<em>avp</em>, int <em>context</em>, pmdaEventDecodeCallBack <em>decoder</em>, void *<em>data</em>);</p>
<p class='spacer'>

<p>int pmdaEventQueueClients(int <em>handle</em>, pmAtomValue *<em>avp</em>);</p>
<p class='spacer'>

<p>int pmdaEventQueueCounter(int <em>handle</em>, pmAtomValue *<em>avp</em>);</p>
<p class='spacer'>

<p>int pmdaEventQueueBytes(int <em>handle</em>, pmAtomValue *<em>avp</em>);</p>
<p class='spacer'>

<p>int pmdaEventQueueMemory(int <em>handle</em>, pmAtomValue *<em>avp</em>);</p>
<p class='spacer'>

<p>cc ... -lpcp_pmda -lpcp</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">

<p>A Performance Metrics Domain Agent (PMDA) that exports event records must effectively act an event multiplexer. Events consumed by the PMDA may have to be forwarded on to any number of monitoring tools (or "client contexts"). These tools may be requesting events at different sampling intervals, and are very unlikely to request an event at the exact moment it arrives at the PMDA, making some form of event buffering and queueing scheme a necessity. Events must be held by the PMDA until either all registered clients have been sent them, or until a memory limit has been reached by the PMDA at which point it must discard older events as new ones arrive.</p>
<p class='spacer'>

<p>The routines described here are designed to assist the PMDA developer in managing both client contexts and queues of events at a high level. These fit logically above lower level primitives, such as those described in <strong>pmdaEventNewArray</strong>(3), and shield the average PMDA from the details of directly building event record arrays for individual client contexts.</p>
<p class='spacer'>

<p>The PMDA registers a new queue of events using either <strong>pmdaEventNewQueue</strong> or <strong>pmdaEventNewActiveQueue</strong>. These are passed an identifying <em>name</em> (for diagnostic purposes, and for subsequent lookup by <strong>pmdaEventQueueLookup</strong>) and <em>maxmem</em>, an upper bound on the memory (in bytes) that can be consumed by events in this queue, before beginning to discard them (resulting in "missed" events for any client that has not kept up). If a queue is dynamically allocated (such that the PMDA may already have clients connected) the <strong>pmdaEventNewActiveQueue</strong> interface should be used, with the additional <em>numclients</em> parameter indicating the count of active client connections. The return is a negative error code on failure, suitable for decoding by the <strong>pmErrStr</strong>(3) routine. Any non-negative value indicates success, and provides a <em>handle</em> suitable for passing into the other API routines.</p>
<p class='spacer'>

<p>For each new event received by the PMDA, the <strong>pmdaEventQueueAppend</strong> routine should be called, placing that event into the queue identified by <em>handle</em>. The event itself must be contained in the passed in <em>buffer</em>, having <em>bytes</em> length. The timestamp associated with the event (time at which the event occurred) is passed in via the final <em>tv</em> parameter.</p>
<p class='spacer'>

<p>In the PMDAs specific implementation of its fetch callback, when values for an event metric have been requested, the <strong>pmdaEventQueueRecords</strong> routine should be used. It is passed the queue <em>handle</em> and the <em>avp</em> pmAtomValue structure to fill with event records, for the client making that fetch request (identified by the <em>context</em> parameter). Finally, the PMDA must also pass in an event decoding routine, which is responsible for decoding the fields of a single event into the individual event parameters of that event. The <em>data</em> parameter is an opaque cookie that can be used to pass situation-specific information into each <em>decoder</em> invocation.</p>
<p class='spacer'>

<p>Under some situations it is useful for the PMDA to export state about the queues under its control. The accessor routines - <strong>pmdaEventQueueClients</strong>, <strong>pmdaEventQueueCounter</strong>, <strong>pmdaEventQueueBytes</strong> and <strong>pmdaEventQueueMemory</strong> provide a mechanism for querying a queue by its <em>handle</em> and filling in a <strong>pmAtomValue</strong> structure that the <strong>pmdaFetchCallBack</strong> method should return.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SEE ALSO</h2>
        <div class="sectioncontent">

<p><strong>PMAPI</strong>(3), <strong>PMDA</strong>(3), <strong>pmdaEventNewClient</strong>(3) and <strong>pmdaEventNewArray</strong>(3).</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="pmdaeventclient.3.html"><span aria-hidden="true">&larr;</span> pmdaeventclient.3: client context tracking interfaces for event queues</a></li>
   <li class="next"><a href="pmdafetch.3.html">pmdafetch.3: fill a pmResult structure with the requested metric values <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

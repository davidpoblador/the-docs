<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>pmGetOptions: Command line handling for pmapi tools</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Command line handling for pmapi tools">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="pmGetOptions (3) manual">
  <meta name="twitter:description" content="Command line handling for pmapi tools">
  <meta name="twitter:image" content="https://www.carta.tech/images/libpcp3-dev-pmGetOptions-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/pmGetOptions.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="pmGetOptions (3) manual" />
  <meta property="og:description" content="Command line handling for pmapi tools" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libpcp3-dev-pmGetOptions-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">pmGetOptions<small> (3)</small></h1>
        <p class="lead">Command line handling for pmapi tools</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/pmGetOptions.3.html">
      <span itemprop="name">pmGetOptions: Command line handling for pmapi tools</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libpcp3-dev/">
      <span itemprop="name">libpcp3-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/pmGetOptions.3.html">
      <span itemprop="name">pmGetOptions: Command line handling for pmapi tools</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">C SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;pcp/pmapi.h&gt;</p><p>int pmgetopt_r(int <em>argc</em>, char *const *<em>argv</em>, pmOptions *<em>opts</em>);</p><p>int pmGetOptions(int <em>argc</em>, char *const *<em>argv</em>, pmOptions *<em>opts</em>);</p><p>int pmGetContextOptions(int <em>ctx</em>, pmOptions *<em>opts</em>);</p><p>void pmUsageMessage(pmOptions *<em>opts</em>);</p><p>void pmFreeOptions(pmOptions *<em>opts</em>);</p><p>cc ... -lpcp</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The <strong>pmGetOptions</strong> function provides command line option processing services for both monitor and collector <a href="../man3/PMAPI.3.html"><strong>PMAPI</strong>(3)</a> tools. It is modelled on the thread-safe variants of the GNU <a href="../man3/getopt_long.3.html"><strong>getopt_long</strong>(3)</a> API, and primarily differs in its focus on providing generalised processing for the (de-facto) standard PCP command line options described in <a href="../man1/PCPIntro.1.html"><strong>PCPIntro</strong>(1)</a>. These common options include the host and archive specification, time windows, timezones, sample counts, time intervals, and so on.</p><p>The primary interface is <strong>pmGetOptions</strong>, which should be passed the <em>argc</em> argument count and <em>argv</em> array, as passed to the <em>main()</em> function on program invocation. The final <em>opts</em> argument describes the set of long and short options the tools is prepared to process, and other metadata regarding how those options should be processed.</p><p>The <strong>pmgetopt_r</strong> interface, used internally by <strong>pmGetOptions</strong>, behaves in a similar fashion, but it does not perform any common option processing. It is more suited to PCP collector processes, whereas PCP monitor tools tend to use <strong>pmGetOptions</strong>.</p><p>The <em>opts</em> argument consists of an array of <em>pmLongOpts</em> entries describing the arguments, as well as the enclosing <em>pmOptions</em> struct, which are defined as follows (internal fields are not presented, for brevity):</p>
<pre>
typedef struct {
    const char *        long_opt;
    int                 has_arg;
    int                 short_opt;
    const char *        argname;
    const char *        message;
} pmLongOptions;

typedef struct {
    int                 version;
    int                 flags;
    const char *        short_options;
    pmLongOptions *     long_options;
    const char *        short_usage;
    pmOptionOverride    override;

    int                 index;
    int                 optind;
    int                 opterr;
    int                 optopt;
    char                *optarg;
    /* [internal fields, undocumented] */

    int                 errors;
    int                 context; /* PM_CONTEXT_{HOST,ARCHIVE,LOCAL} */
    int                 nhosts;
    int                 narchives;
    char **             hosts;
    char **             archives;
    struct timeval      start;
    struct timeval      finish;
    struct timeval      origin;
    struct timeval      interval;
    char *              align_optarg;
    char *              start_optarg;
    char *              finish_optarg;
    char *              origin_optarg;
    char *              guiport_optarg;
    char *              timezone;
    int                 samples;
    int                 guiport;
    int                 padding;
    unsigned int        guiflag : 1;
    unsigned int        tzflag  : 1;
    unsigned int        nsflag  : 1;
    unsigned int        Lflag   : 1;
    unsigned int        zeroes  : 28;
} pmOptions;
</pre>
<p>The initial <em>flags</em> and <em>version</em> fields describe how the rest of the pmOptions structure is to be interpreted. These fields can be zeroed, specifying a default interpretation. Alternatively, the PMAPI_VERSION macro can be used to specify the API level to use (currently, values of 2 or less are allowed). The <em>flags</em> field can be used to modify option processing behaviour as described in the ``FLAGS VALUES'' section below.</p><p>The array of <em>long_options</em> pmLongOpts structures must be terminated by a sentinel and the PMAPI_OPTIONS_END macro can be used to effect this termination. Individual records within the <em>long_options</em> array can be of two types - options headers, or actual options. An options header is constructed using the PMAPI_OPTIONS_HEADER macro, and is used for usage message option grouping. Free form text can be inserted into the usage message at any point using the PMAPI_OPTIONS_TEXT macro - this is intended for additional explanatory text covering detailed usage that is beyond the scope of the individual headers or options. Otherwise, the array entry specifies an option. These should be named ( .IR long_opt ) if a long-option form is allowed, specify whether or not they take an argument ( .IR has_arg ), specify the single character variant argument ( .IR short_opt ) if a short-option form is allowed, and finally specify how to present the option in the usage message. This latter component consists of a short, one-word description of the optional argument ( .IR argname ) and a one-line description of what the command-line option does ( .IR message ).</p><p>The <em>short_usage</em> string is also used only when constructing the usage message. It forms the component of the usage message that follows the program name (i.e.  .IR argv[0] ).</p><p>The optional <em>short_options</em> string is the normal <em>getopt</em> command-line option specification string, using individual characters (those with arguments are designated as such using the ':' character) - as used by all <em>getopt</em> implementations.</p><p>A facility is provided to extend the existing set of common options with additional options, as well as to re-task the standard options into non-standard roles for individual tools. The latter is achieved using the <em>override</em> method, which allows a callback function to be provided which will be called on receipt of every argument, prior to common processing. If this callback returns a non-zero value the common processing will be short-circuited for that option, otherwise processing continues. Thus, aach client tool is free to choose exactly which of the standard options they wish to support - this can be all, some, or none, and no matter what they choose, each tool always has access to the long option parsing capability and the usage message generation facility.</p><p>The remaining pmOptions structure fields are filled in as a result of processing the arguments, and are largely self-explanatory. Further discussion of these is deferred to the ``FLAGS VALUES'' section below. The <em>error</em> field contains a count of errors detected during option processing. These can be either usage or runtime errors, as indicated by the <em>flags</em> field (set, and passed out to the caller). Typically, a command line tool will fail to start successfully and will produce an error message (e.g. via <strong>pmUsageMessage</strong>) if the <em>error</em> field is non-zero at the end of either <strong>pmGetOptions</strong> or <strong>pmGetContextOptions</strong>.</p><p>Some command line option post-processing can only be performed once the tool has established a PMAPI context via <a href="../man3/pmNewContext.3.html"><strong>pmNewContext</strong>(3)</a>. This processing includes use of context-aware timezones (<strong>-z</strong>), and time window processing (<strong>-A</strong>, <strong>-O</strong>, <strong>-S</strong>, <strong>-T</strong>) that may be affected by the timezone, for example. The <strong>pmGetContextOptions</strong> function is available for such situations, and it completes any remaining processing of <em>opts</em> with respect to the <em>ctx</em> context identifier given.</p><p>The <strong>pmUsageMessage</strong> function generates a usage message for the tool, and included both standard PCP options and custom options for each tool, as specified by the pmLongOptions array. It supports grouping of options (via PMAPI_OPTIONS_HEADER) as well as neat formatting of all options - short and long - their arguments, and individual explanatory messages. It will build this usage message using <a href="../man3/pmprintf.3.html"><strong>pmprintf</strong>(3)</a> upon which it will issue a single <a href="../man3/pmflush.3.html"><strong>pmflush</strong>(3)</a> before returning to the caller, provided the PM_OPTFLAG_USAGE_ERR flag is set in <em>flags</em>, which will happen automatically during option parsing, when usage errors are detected.</p><p>In certain situations, such as recording lists of host specifications or PCP archive paths, the <strong>pmGetOptions</strong> routine may allocate memory, and store pointers to it within <em>opts</em>. Should a program wish to free this memory before exiting, it can use the <strong>pmFreeOptions</strong> routine to do so. This is safe to call irrespective of whether memory was allocated dynamically, provided that <em>opts</em> was zeroed initially.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FLAGS VALUES</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong>PM_OPTFLAG_INIT</strong></p>
  </dt>
  <dd>
    <p>Used internally within the library to indicate initialisation has been done, so that on subsequent calls it will not be done again.</p>
  </dd>
  <dt>
    <p><strong>PM_OPTFLAG_DONE</strong></p>
  </dt>
  <dd>
    <p>Used primarily internally within the library to indicate that the final option processing has been completed. This processing involves cross-referencing a number of the options, to check for mutual exclusion, for example. There may be other post-processing at this stage also, provided it does not require a PMAPI context.</p>
  </dd>
  <dt>
    <p><strong>PM_OPTFLAG_MULTI</strong></p>
  </dt>
  <dd>
    <p>Allow more than one host or archive to be specified. The default is to allow one source of metrics only, however some of the more sophisticated tools permit multiple metric sources. See also <strong>PM_OPTFLAG_MIXED</strong>.</p>
  </dd>
  <dt>
    <p><strong>PM_OPTFLAG_USAGE_ERR</strong></p>
  </dt>
  <dd>
    <p>Indicates that the library has detected a command-line usage error. This is an error such as when an option requires an argument but none is supplied, or conflicting options are specified (such as <strong>-s</strong> and <strong>-T</strong>).</p>
  </dd>
  <dt>
    <p><strong>PM_OPTFLAG_RUNTIME_ERR</strong></p>
  </dt>
  <dd>
    <p>Indicates that the library has detected an error at run time. This is an error such as failing to retrieve timezone information from <strong>pmcd (1)</strong> or failing to load an alternate metric namespace from a local file (via the <strong>-n</strong> option).</p>
  </dd>
  <dt>
    <p><strong>PM_OPTFLAG_EXIT</strong></p>
  </dt>
  <dd>
    <p>Indicates a suggestion from the library that the tool exit cleanly. This is used when the version number is requested, for example (the <strong>-V</strong> option and PMOPT_VERSION macro).</p>
  </dd>
  <dt>
    <p><strong>PM_OPTFLAG_POSIX</strong></p>
  </dt>
  <dd>
    <p>Use strict POSIX command line argument handling. This means options and following arguments will not be reordered, so additional options cannot follow command line arguments. This may be important for tools where the arguments can be negative numbers, for example, as these should not be treated as command line options in this case.</p>
  </dd>
  <dt>
    <p><strong>PM_OPTFLAG_MIXED</strong></p>
  </dt>
  <dd>
    <p>Allow both live and archive metric sources to be specified. The default is to allow one type of metric context only, however some of the more sophisticated tools permit multiple context types. See also <strong>PM_OPTFLAG_MULTI</strong>.</p>
  </dd>
  <dt>
    <p><strong>PM_OPTFLAG_ENV_ONLY</strong></p>
  </dt>
  <dd>
    <p>Many options can be specified through the either the command line or from similarly-named environment variables. This flag disables all argument parsing, and only changes <em>opts</em> based on the environment variables. This may be useful for tools wishing to ensure no command line option conflicts occur between their own set and the standard PCP option set (such as an existing tool, reimplemented using PMAPI services).</p>
  </dd>
  <dt>
    <p><strong>PM_OPTFLAG_LONG_ONLY</strong></p>
  </dt>
  <dd>
    <p>Only process long options, not short options.</p>
  </dd>
  <dt>
    <p><strong>PM_OPTFLAG_BOUNDARIES</strong></p>
  </dt>
  <dd>
    <p>The default <strong>pmGetOptions</strong> behaviour is to parse the time window options (namely, <strong>-A</strong>, <strong>-O</strong>, <strong>-S</strong> and <strong>-T</strong>), only if one of those options has been specified on the command line. However, this flag can be used (particularly with archive contexts) to find the <em>start</em> and <em>finish</em> times associated with the context(s) even if no time window options were specified. In the case of multiple archives, the time window is defined as the time window spanning all of the archives.</p>
  </dd>
  <dt>
    <p><strong>PM_OPTFLAG_STDOUT_TZ</strong></p>
  </dt>
  <dd>
    <p>The timezone being used will be reported on the standard output stream during option parsing. The default behaviour is to not report, but simply return timezone information via the <em>timezone</em> (<strong>-Z</strong>) and <em>tzflag</em> (<strong>-z</strong>) fields in the <em>opts</em> structure.</p>
  </dd>
  <dt>
    <p><strong>PM_OPTFLAG_NOFLUSH</strong></p>
  </dt>
  <dd>
    <p>The final <strong>pmflush</strong> call issued by <strong>pmUsageMessage</strong> will be skipped if this flag is set. This is useful in situations where the caller wishes to append additional test to the generated usage message before flushing.</p>
  </dd>
  <dt>
    <p><strong>PM_OPTFLAG_QUIET</strong></p>
  </dt>
  <dd>
    <p>Suppress messages from <strong>pmgetopt_r</strong> about unrecognised command line options. This is the equivalent to setting the <em>opterr</em> field in the <em>opt</em> parameter (which mimics the <strong>getopt</strong> variable of the same name).</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RETURN VALUE</h2>
        <div class="sectioncontent">
<p>The <strong>pmGetOptions</strong> function returns either when it detects a command-line option that is not one of the standard PCP set, or when the end of the command line options has been reached (at which point -1 is returned). Both the <strong>pmgetopt_r</strong> and <strong>pmGetOptions</strong> routines return control to the caller in the same way that a regular <strong>getopt</strong> call would, with the return value indicating either the end of all processing (-1), or the single character form of the option currently being processed, or zero for the special long-option-only case. For all option-processing cases, the <em>opts</em> structure is returned containing filled out <em>optarg</em>, <em>opterr</em>, <em>optopt</em>, <em>optind</em>, and <em>index</em> fields as normal (do <strong>NOT</strong> use the global optarg or optind from your platform C library, these will <strong>NOT</strong> be modified).</p><p><strong>pmGetOptions</strong> does not return to the caller when any of the standard PCP options are being processed (although the <em>override</em> mechanism can be used to still detect such options if needed).</p><p>The <strong>pmGetContextOptions</strong> function returns zero on success, or a negative PCP error code on failure. The <em>error</em> field within the <em></em> opts parameter will also be non-zero in the latter case.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PCP ENVIRONMENT</h2>
        <div class="sectioncontent">
<p>Environment variables with the prefix <strong>PCP_</strong> are used to parameterize the file and directory names used by PCP. On each installation, the file <em>/etc/pcp.conf</em> contains the local values for these variables. The <strong>$PCP_CONF</strong> variable may be used to specify an alternative configuration file, as described in <a href="../man5/pcp.conf.5.html"><strong>pcp.conf</strong>(5)</a>. Values for these variables may be obtained programmatically using the <a href="../man3/pmGetOptions.3.html"><strong>pmGetOptions</strong>(3)</a> function.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO pmGetOptions&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man1/PCPIntro.1.html"><strong>PCPIntro</strong>(1)</a>, <a href="../man1/pmcd.1.html"><strong>pmcd</strong>(1)</a>, <a href="../man1/pminfo.1.html"><strong>pminfo</strong>(1)</a>, <a href="../man1/pmstat.1.html"><strong>pmstat</strong>(1)</a>, <a href="../man3/getopt.3.html"><strong>getopt</strong>(3)</a>, <a href="../man3/getopt_long.3.html"><strong>getopt_long</strong>(3)</a>, <a href="../man3/pmNewContext.3.html"><strong>pmNewContext</strong>(3)</a>, <strong>pmconfig</strong>(3), <a href="../man3/pmprintf.3.html"><strong>pmprintf</strong>(3)</a>, <a href="../man3/pmflush.3.html"><strong>pmflush</strong>(3)</a> and <a href="../man3/PMAPI.3.html"><strong>PMAPI</strong>(3)</a>.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="pmGetInDomArchive.3.html"><span aria-hidden="true">&larr;</span> pmGetInDomArchive.3: Get instance identifiers for a performance metrics instance domain</a></li>
   <li class="next"><a href="pmGetPMNSLocation.3.html">pmGetPMNSLocation.3: Determine the location of the currently used pmns <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Class::Multimethods: Support multimethods and function overloading in perl</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Support multimethods and function overloading in perl">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Class::Multimethods (3pm) manual">
  <meta name="twitter:description" content="Support multimethods and function overloading in perl">
  <meta name="twitter:image" content="https://www.carta.tech/images/libclass-multimethods-perl-Class::Multimethods-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Class::Multimethods.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Class::Multimethods (3pm) manual" />
  <meta property="og:description" content="Support multimethods and function overloading in perl" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libclass-multimethods-perl-Class::Multimethods-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Class::Multimethods<small> (3pm)</small></h1>
        <p class="lead">Support multimethods and function overloading in perl</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Class::Multimethods.3pm.html">
      <span itemprop="name">Class::Multimethods: Support multimethods and function overloading in perl</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libclass-multimethods-perl/">
      <span itemprop="name">libclass-multimethods-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Class::Multimethods.3pm.html">
      <span itemprop="name">Class::Multimethods: Support multimethods and function overloading in perl</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">VERSION</h2>
        <div class="sectioncontent">
<p>This document describes version 1.70 of Class::Multimethods, released April  9, 2000.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
 # IMPORT THE multimethod DECLARATION SUB...

    use Class::Multimethods;

 # DECLARE VARIOUS MULTIMETHODS CALLED find...

 # 1. DO THIS IF find IS CALLED WITH A Container REF AND A Query REF...

    multimethod find =&gt; (Container, Query)
                     =&gt; sub { $_[0]-&gt;findquery($_[1]) };

 # 2. DO THIS IF find IS CALLED WITH A Container REF AND A Sample REF...

    multimethod find =&gt; (Container, Sample)
                     =&gt; sub { $_[0]-&gt;findlike($_[1]) };

 # 3. DO THIS IF find IS CALLED WITH AN Index REF AND A Word REF...

    multimethod find =&gt; (Index, Word)
                     =&gt; sub { $_[0]-&gt;lookup_word($_[1]) };

 # 4. DO THIS IF find IS CALLED WITH AN Index REF AND A qr// PATTERN

    multimethod find =&gt; (Index, Regexp)
                     =&gt; sub { $_[0]-&gt;lookup_rx($_[1]) };

 # 5. DO THIS IF find IS CALLED WITH AN Index REF AND A NUMERIC SCALAR

    multimethod find =&gt; (Index, &apos;#&apos;)
                     =&gt; sub { $_[0]-&gt;lookup_elem($_[1]) };

 # 6. DO THIS IF find IS CALLED WITH AN Index REF AND A NON-NUMERIC SCALAR

    multimethod find =&gt; (Index, &apos;$&apos;)
                     =&gt; sub { $_[0]-&gt;lookup_str($_[1]) };

 # 7. DO THIS IF find IS CALLED WITH AN Index REF AND AN UNBLESSED ARRAY REF
 #    (NOTE THE RECURSIVE CALL TO THE find MULTIMETHOD)

    multimethod find =&gt; (Index, ARRAY)
                     =&gt; sub { map { find($_[0],$_) } @{$_[1]} };


 # SET UP SOME OBJECTS...

        my $cntr = new Container (&apos;./datafile&apos;);
        my $indx = $cntr-&gt;get_index();

 # ...AND SOME INHERITANCE...

        @BadWord::ISA = qw( Word );
        my $badword = new BadWord("fubar");

 # ...AND EXERCISE THEM...

        print find($cntr, new Query(&apos;cpan OR Perl&apos;));           # CALLS 1.
        print find($cntr, new Example(&apos;by a committee&apos;));       # CALLS 2.

        print find($indx, new Word(&apos;sugar&apos;));                   # CALLS 3.
        print find($indx, $badword);                            # CALLS 3.
        print find($indx, qr/another brick in the Wall/);       # CALLS 4.
        print find($indx, 7);                                   # CALLS 5.
        print find($indx, &apos;But don&apos;t do that.&apos;);                # CALLS 6.
        print find($indx, [1,"one"]);                           # CALLS 7,
                                                                # THEN 5 & 6.
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The Class:Multimethod module exports a subroutine (&multimethod) that can be used to declare other subroutines that are dispatched using a algorithm different from the normal Perl subroutine or method dispatch mechanism.</p><p>Normal Perl subroutines are dispatched by finding the appropriately-named subroutine in the current (or specified) package and calling that. Normal Perl methods are dispatched by attempting to find the appropriately-named subroutine in the package into which the invoking object is blessed or, failing that, recursively searching for it in the packages listed in the appropriate @ISA arrays.</p><p>Class::Multimethods multimethods are dispatched quite differently. The dispatch mechanism looks at the classes or types of each argument to the multimethod (by calling \*(C`ref\*(C' on each) and determines the \*(L"closest\*(R" matching <em>variant</em> of the multimethod, according to the argument types specified in the variants' definitions (see \*(L"Finding the \*(R"nearest\*(L" multimethod\*(R" for a definition of \*(L"closest\*(R").</p><p>The result is something akin to \*(C+'s function overloading, but more intelligent, since multimethods take the inheritance relationships of each argument into account. Another way of thinking of the mechanism is that it performs polymorphic dispatch on <em>every</em> argument of a method, not just the first.</p><p><strong>&#92;$1</strong></p><p>The Class::Multimethods module exports a subroutine called \*(C`multimethod\*(C', which can be used to specify multimethod variants with the dispatch behaviour described above. The \*(C`multimethod\*(C' subroutine takes the name of the desired multimethod, a list of class names, and a subroutine reference, and generates a corresponding multimethod variant within the current package.</p><p>For example, the declaration:</p><p>        package LargeInt;   @ISA = (LargeNumeric);         package LargeFloat; @ISA = (LargeNumeric);</p><p>        package LargeNumeric;         use Class::Multimethods;</p><p>        multimethod divide =&gt; (LargeInt, LargeInt) =&gt; sub         {                 LargeInt::divide($_[0],$_[1]);         };</p><p>        multimethod divide =&gt; (LargeInt, LargeFloat) =&gt; sub         {                 LargeFloat::divide($_[0]-&gt;AsLargeFloat(),$_[1]));         };</p><p>creates a (single!) multimethod &LargeNumeric::divide with two variants. If the multimethod is called with two references to \*(C`LargeInt\*(C' objects as arguments, the first variant (i.e. anonymous subroutine) is invoked. If the multimethod is called with a \*(C`LargeInt\*(C' reference and a \*(C`LargeFloat\*(C' reference, the second variant is called.</p><p>Note that if you're running under \*(C`use strict\*(C', the list of bareword class names in each variant definition will cause problems. In that case you'll need to say:</p><p>        multimethod divide =&gt; (&apos;LargeInt&apos;, &apos;LargeInt&apos;) =&gt; sub         {                 LargeInt::divide($_[0],$_[1]);         };</p><p>        multimethod divide =&gt; (&apos;LargeInt&apos;, &apos;LargeFloat&apos;) =&gt; sub         {                 LargeFloat::divide($_[0]-&gt;AsLargeFloat(),$_[1]));         };</p><p>or better still:</p><p>        multimethod divide =&gt; qw( LargeInt LargeInt ) =&gt; sub         {                 LargeInt::divide($_[0],$_[1]);         };</p><p>        multimethod divide =&gt; qw( LargeInt LargeFloat ) =&gt; sub         {                 LargeFloat::divide($_[0]-&gt;AsLargeFloat(),$_[1]));         };</p><p>or best of all (;-):</p><p>        {             no strict;</p><p>            multimethod divide =&gt; (LargeInt, LargeInt) =&gt; sub             {                 LargeInt::divide($_[0],$_[1]);             };</p><p>            multimethod divide =&gt; (LargeInt, LargeFloat) =&gt; sub             {                 LargeFloat::divide($_[0]-&gt;AsLargeFloat(),$_[1]));             };         }</p><p>Calling the multimethod with any other combination of \*(C`LargeNumeric\*(C' reference arguments (e.g. a reference to a \*(C`LargeFloat\*(C' and a reference to a \*(C`LargeInt\*(C', or two \*(C`LargeFloat\*(C' referencess) results in an exception being thrown, with the message:</p><p>        No viable candidate for call to         multimethod LargeNumeric::divide at ...</p><p>To avoid this, we could provide a \*(L"catch-all\*(R" variant:</p><p>        multimethod divide =&gt; (LargeNumeric, LargeNumeric) =&gt; sub         {                 LargeFloat::divide($_[0]-&gt;AsLargeFloat(),$_[1]-&gt;AsLargeFloat));         }</p><p>Now, calling &LargeNumeric::divide with either a \*(C`LargeFloat\*(C' reference and a \*(C`LargeInt\*(C' reference or two \*(C`LargeFloat\*(C' references results in this third variant being invoked. Note that, adding this third alternative doesn't affect calls to the other two, since Class::Multimethods always selects the \*(L"nearest\*(R" match (see \*(L"Finding the \*(R"nearest\*(L" multimethod\*(R" below for details of what \*(L"nearest\*(R" means).</p><p>This \*(L"best fit\*(R" behaviour is extremely useful, because it means you can code the specific cases you want to handle, and the one or more \*(L"catch-all\*(R" cases to deal with any other combination of arguments. Of course, the usefulness of the entire system depends on how intelligently Class::Multimethods decides which version of a multimethod is \*(L"nearest\*(R" to the set of arguments you provided. This decision process is called \*(L"dispatch resolution\*(R", and Class::Multimethods does it like this:</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>If the types of the arguments given (as determined by \*(C`ref\*(C') exactly match the types specified in any variant of the multimethod, that variant is the one called.</p>
  </dd>
  <dt>
    2.
  </dt>
  <dd>
    <p>Otherwise, Class::Multimethods compiles a list of \*(L"viable targets\*(R". A viable target is a variant of the multimethod with the correct number of parameters, such that for each parameter the specified parameter type is a base class of the actual type of the corresponding argument in the actual call.</p>
  </dd>
  <dt>
    3.
  </dt>
  <dd>
    <p>If there is only one viable target, it is immediately called. if there are no viable targets, an exception is thrown indicating the fact.</p>
  </dd>
  <dt>
    4.
  </dt>
  <dd>
    <p>Otherwise, Class::Multimethod examines each viable target and computes its \*(L"distance\*(R" to the actual set of arguments. The distance of a target is the sum of the distances of each of its parameters. The distance of an individual parameter is the number of inheritance steps between its class and the actual class of the corresponding argument. Hence, if a specific argument is of the same class as the corresponding parameter type, the distance to that parameter is zero. If the argument is of a class that is an immediate child of the parameter type, the distance is 1. If the argument is of a class which is a \*(L"grandchild\*(R" of the parameter type, the distance is 2. Et cetera.</p>
  </dd>
  <dt>
    5.
  </dt>
  <dd>
    <p>Class::Multimethod then chooses the viable target with the smallest \*(L"distance\*(R" as the \*(L"final target\*(R". If there is more than one viable target with an equally smallest distance, an exception is thrown indicating that the call is ambiguous. If there <em>is</em> only a single final target Class::Multimethod records its identity (so the distance computations don't have to be repeated next time the same set of argument types is used), and then calls that final target. Class::Multimethods doesn't care which packages the individual variants of a multimethod are defined in. Every variant of a multimethod is visible to the underlying multimethod dispatcher, no matter where it was defined.</p>
  </dd>

</dl>
<p>For example, the three variants for the \*(C`divide\*(C' multimethod shown above could all be defined in the LargeNumeric package, or the LargeFloat package or the LargeInt package, or in \*(C`main\*(C', or in a separate package of their own.</p><p>Of course, to make a specific multimethod visible within a given package you still need to tell that package about it. That can be done by specifying the name of the multimethod only (i.e. no argument list or variant code):</p><p>        package Some::Other::Package::That::Wants::To::Use::divide;</p><p>        use Class::Multimethods;         multimethod "divide";</p><p>For convenience, the declaration itself can be abbreviated to:</p><p>        package Some::Other::Package::That::Wants::To::Use::divide;</p><p>        use Class::Multimethods "divide";</p><p>Similarly, Class::Multimethod doesn't actually care whether multimethods are called as methods or as regular subroutines. This is quite different from the behaviour of normal Perl methods and subroutines, where how you call them, determines how they are dispatched.</p><p>With multimethods, since all arguments participate in the polymorphic resolution of a call (instead of just the first), it make no difference whether a multimethod is called as a subroutine:</p><p>        numref3 = divide($numref1, $numref2);</p><p>or a method:</p><p>        numref3 = $numref1-&gt;divide($numref2);</p><p>(so long as the multimethod has been <em>declared</em> in the appropriate place: the current package for subroutine-like calls, or the invoking object's package for method-like calls).</p><p>In other words, Class::Multimethods also provides general subroutine overloading. For example:</p><p>        package main;         use IO;         use Class::Multimethods;</p><p>        multimethod debug =&gt; (IO::File) =&gt; sub         {                 print $_[0] "This should go in a file&#92;n";         }</p><p>        multimethod debug =&gt; (IO::Pipe) =&gt; sub         {                 print $_[0] "This should go down a pipe&#92;n";         }</p><p>        multimethod debug =&gt; (IO::Socket) =&gt; sub         {                 print $_[0] "This should go out a socket&#92;n";         }</p><p>        # and later</p><p>        debug($some_io_handle); Yet another thing Class::Multimethods doesn't care about is whether the parameter types for each multimethod variant are the names of \*(L"real\*(R" classes or just the identifiers returned when raw Perl data types are passed to the built-in \*(C`ref\*(C' function. That means you could also define multimethod variants like this:</p><p>        multimethod stringify =&gt; (ARRAY) =&gt; sub         {                 my @arg = @{$_[0]};                 return "[" .  join(", ",@arg) . "]";         }</p><p>        multimethod stringify =&gt; (HASH) =&gt; sub         {                 my %arg = %{$_[0]};                 return "{" . join(", ", map("$_=&gt;$arg{$_}",keys %arg)) . "}";         }</p><p>        multimethod stringify =&gt; (CODE) =&gt; sub         {                 return "sub {???}";         }</p><p>        # and later</p><p>        print stringify( [1,2,3] ), "&#92;n";         print stringify( {a=&gt;1,b=&gt;2,c=&gt;3} ), "&#92;n";         print stringify( $array_or_hash_ref ), "&#92;n";</p><p>Provided you remember that the parameter types \s-1ARRAY\s0, \s-1HASH\s0, and \s-1CODE\s0 really mean \*(L"reference to array\*(R", \*(L"reference to hash\*(R", and \*(L"reference to subroutine\*(R", the names of built-in types (i.e. those returned by \*(C`ref\*(C') are perfectly acceptable as multimethod parameters.</p><p>That's a nice bonus, but there's a problem. Because \*(C`ref\*(C' returns an empty string when given any literal string or numeric value, the following code:</p><p>        print stringify( 2001 ), "&#92;n";         print stringify( "a multiple dispatch oddity" ), "&#92;n";</p><p>will produce a nasty surprise:</p><p>        No viable candidate for call to multimethod stringify() at line 1</p><p>That's because the dispatch resolution process first calls \*(C`ref(2001)\*(C' to get the class name for the first argument, and therefore thinks it's of class "". Since there's no \*(C`stringify\*(C' variant with an empty string as its parameter type, there are no viable targets for the multimethod call. Hence the exception.</p><p>To overcome this limitation, Class::Multimethods allows three special pseudo-type names within the parameter lists of multimethod variants. The first pseudo-type - "$" - is the class that Class::Multimethods pretends that any scalar value (except a reference) belongs to. Hence, you can make the two recalcitrant stringifications of scalars work by defining:</p><p>        multimethod stringify =&gt; ("$")                 =&gt; sub { return qq{"$_[0]"} }</p><p>With that definition in place, the two calls:</p><p>        print stringify( 2001 ), "&#92;n";         print stringify( "a multiple dispatch oddity" ), "&#92;n";</p><p>would produce:</p><p>        "2001"         "a multiple dispatch oddity"</p><p>That solves the problem, but not as elegantly as it might. It would be better if numeric values were left unquoted. To this end, Class::Multimethods offers a second pseudo-type - "#" - which is the class it pretends numeric scalar values belong to (where a scalar value is \*(L"numeric\*(R" if it's truly a numerical value (without implicit coercions):</p><p>        $var = 0        # numeric --&gt; &apos;$&apos;         $var = 0.0      # numeric --&gt; &apos;$&apos;         $var = "0";     # string  --&gt; &apos;#&apos;</p><p>Hence you could now also define:</p><p>        multimethod stringify =&gt; ("#")                 =&gt; sub { return "+$_[0]" }</p><p>the two calls to &stringify now produce:</p><p>        +2001         "a multiple dispatch oddity"</p><p>The final pseudo-type - "*" - is a wild-card or \*(L"don't care\*(R" type specifier, which matches <em>any</em> argument type exactly. For example, we could provide a \*(L"catch-all\*(R" \*(C`stringify\*(C' variant (to handle \*(L"\s-1GLOB\s0\*(R" or \*(L"\s-1IO\s0\*(R" references, for example):</p><p>        multimethod stringify =&gt; ("*")                 =&gt; sub { croak "can&apos;t stringify a " . ref($_[0]) }</p><p>The "*" pseudo-type can also be used in multiple-argument multimethods. For example:</p><p>        # General case...</p><p>            multimethod handle =&gt; (Window, Event, Mode)                 =&gt; sub { ... }</p><p>        # Special cases...</p><p>            multimethod handle =&gt; (MovableWindow, MoveEvent, NormalMode)                 =&gt; sub { ... }</p><p>            multimethod handle =&gt; (ScalableWindow, ResizeEvent, NormalMode)                 =&gt; sub { ... }</p><p>        # Very special case         # (ignore any event in any window in PanicMode)</p><p>            multimethod handle =&gt; ("*", "*", PanicMode)                 =&gt; sub { ... } It's relatively easy to set up a multimethod such that particular combinations of argument types cannot be correctly dispatched. For example, consider the following variants of a multimethod called \*(C`put_peg\*(C':</p><p>        multimethod put_peg =&gt; (RoundPeg,Hole) =&gt; sub         {                 print "a round peg in any old hole&#92;n";         };</p><p>        multimethod put_peg =&gt; (Peg,SquareHole) =&gt; sub         {                 print "any old peg in a square hole&#92;n";         };</p><p>        multimethod put_peg =&gt; (Peg,Hole) =&gt; sub         {                 print "any old peg in any old hole&#92;n";         };</p><p>If \*(C`put_peg\*(C' is called like so:</p><p>        put_peg( RoundPeg-&gt;new(), SquareHole-&gt;new() );</p><p>then Class::Multimethods can't dispatch the call, because it cannot decide between the \*(C`(RoundPeg,Hole)\*(C' and \*(C`(Peg,SquareHole)\*(C' variants, each of which is the same \*(L"distance\*(R" (i.e. 1 derivation) from the actual arguments.</p><p>The default behaviour is to throw an exception (i.e. die) like this:</p><p>        Cannot resolve call to multimethod put_peg(RoundPeg,SquareHole).         The multimethods:                 put_peg(RoundPeg,Hole)                 put_peg(Peg,SquareHole)         are equally viable at ...</p><p>Sometimes, however, the more specialized variants are only optimizations, and a more general case (e.g. the \*(C`(Peg,Hole)\*(C' variant) would suffice as a default where such an ambiguity exists. If that is the case, it's possible to tell Class::Multimethods to resolve the ambiguity by calling that variant, using the \*(C`resolve_ambiguous\*(C' subroutine. \*(C`resolve_ambiguous\*(C' is automatically exported by Class::Multimethods and is used like this:</p><p>        resolve_ambiguous put_peg =&gt; (Peg,Hole);</p><p>That is, you specify the name of the multimethod being disambiguated, and the signature of the variant to be used in ambiguous cases. Of course, the specified variant must actually exist at the time of the call. If it doesn't, Class::Multimethod ignores it and throws the usual exception.</p><p>Alternatively, if no variant is suitable as a default, you can register a reference to a subroutine that is to be called instead:</p><p>        resolve_ambiguous put_peg =&gt; &#92;&disambiguator;</p><p>Now, whenever \*(C`put_peg\*(C' can't dispatch a call because it's ambiguous, \*(C`disambiguator\*(C' will be called instead, with the same argument list as \*(C`put_peg\*(C' was given.</p><p>Of course, \*(C`resolve_ambiguous\*(C' doesn't care what subroutine it's given a reference to, so you can also use an anonymous subroutine:</p><p>        resolve_ambiguous put_peg                 =&gt; sub                    {                         print "can&apos;t put a ", ref($_[0]),                               " into a ", ref($_[1]), "&#92;n";                    };</p><p>Dispatch can also fail if there are <em>no</em> suitable variants available to handle a particular call. For example:</p><p>        put_peg( JPEG-&gt;new(), Loophole-&gt;new() );</p><p>which would normally produce the exception:</p><p>        No viable candidate for call to         multimethod put_peg(JPeg,Loophole) at ...</p><p>since classes \s-1JPEG\s0 and Loophole are't in the Peg and Hole hierarchies, so there's no inheritance path back to a more general variant.</p><p>To handle cases like this, you can use the &lt;resolve_no_match&gt; subroutine, which is also exported from Class::Multimethods. \*(C`resolve_no_match\*(C' registers a multimethod variant, or a reference to some other subroutine, that is then used whenever the dispatch mechanism can't find a suitable variant for a given multimethod call.</p><p>For example:</p><p>        resolve_no_match put_peg                 =&gt; sub                    {                         put_jpeg(@_)                                 if ref($_[0]) eq &apos;JPEG&apos;;                         shift()-&gt;hang(@_)                                 if ref($_[0]) eq &apos;ClothesPeg&apos;;                         hammer(@_)                                 if ref($_[0]) eq &apos;TentPeg&apos;;                         # etc.</p><p>                   };</p><p>As with \*(C`resolve_ambiguous\*(C' the registered variant or subroutine is called with the same set of arguments that were passed to the original multimethod call. Sometimes a polymorphic method in a derived class is used to add functionality to an inherited method. For example, a derived class's \*(C`print_me\*(C' method might call it's base class's \*(C`print_me\*(C', making use of Perl's special \*(C`$obj-\*(C'<em>SUPER::method()</em>&gt; construct:</p><p>        class Base;</p><p>        sub print_me         {                 my ($self) = @_;                 print "Base stuff&#92;n";         }</p><p>        class Derived; @ISA = qw( Base );</p><p>        sub print_me         {                 my ($self) = @_;                 $self-&gt;SUPER::print_me();       # START LOOKING IN ANCESTORS                 print "Derived stuff&#92;n";         }</p><p>If the \*(C`print_me\*(C' methods are implemented as multimethods, it's still possible to reinvoke an \*(L"ancestral\*(R" method, using the automatically exported \*(C`Class::Multimethods::superclass\*(C' subroutine:</p><p>        use Class::Multimethods;</p><p>        multimethod print_me =&gt; (Base) =&gt; sub         {                 my ($self) = @_;                 print "Base stuff&#92;n";         }</p><p>        multimethod print_me =&gt; (Derived) =&gt; sub         {                 my ($self) = @_;                 print_me( superclass($self) );  # START LOOKING IN ANCESTORS                 print "Derived stuff&#92;n";         }         }</p><p>Applying \*(C`superclass\*(C' to the multimethod argument tells Class::Multimethod to start looking for parameter types amongst the ancestors of Derived.</p><p>It's also possible in regular Perl to explcitly tell the polymorphic dispacther where to start looking, by explicitly qualifying the method name:</p><p>        sub Derived::print_me         {                 my ($self) = @_;                 $self-&gt;Base::print_me();        # START LOOKING IN Base CLASS                 print "Derived stuff&#92;n";         }</p><p>The same is possible with multimethods. \*(C`superclass\*(C' takes an optional second argument that tells Class::Multimethods exactly where to start looking:</p><p>        multimethod print_me =&gt; (Derived) =&gt; sub         {                 my ($self) = @_;                 print_me( superclass($self =&gt; Base) );  # START LOOKING IN Base                 print "Derived stuff&#92;n";         }</p><p>Note that, unlike regular method calls, with multimethods you can apply the \*(C`superclass\*(C' subroutine to any or all of a multimethod's arguments. For example:</p><p>        multimethod handle =&gt; (MovableWindow, MoveEvent, NormalMode) =&gt; sub         {                 my ($w, $e, $m) = @_;</p><p>                # Do any special stuff,                 # then redispatch to more general handler...</p><p>                handle(superclass($w), $e, superclass($m =&gt; Mode) );         }</p><p>In this case the redispatch would start looking for variants which matched \*(C`(<strong>any of MovableWindow&apos;s ancestors, MoveEvent, Mode)\*(C'</strong>.</p><p>It's also important to remember that, as with regular methods, the class of the actual arguments doesn't change just because we subverted the dispatch sequence. That means if the above redispatch called the handle variant that takes arguments (Window, MoveEvent, Mode), the actual arguments would still be of types (MovableWindow, MoveEvent, NormalMode).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DIAGNOSTICS</h2>
        <div class="sectioncontent">
<p>If you call \*(C`multimethod\*(C' and forget to provide a code reference as the last argument, it \*(C`die\*(C's with the message:</p><p>        "multimethod: last arg must be a code reference at %s"</p><p>If the dispatch mechanism cannot find any multimethod with a signature matching the actual arguments, it \*(C`die\*(C's with the message:</p><p>        "No viable candidate for call to multimethod %s at %s"</p><p>If the dispatch mechanism finds two or more multimethods with signatures equally \*(L"close\*(R" to the actual arguments (see \*(L"The dispatch resolution process\*(R"), it \*(C`die\*(C's with the message:</p><p>        "Cannot resolve call to multimethod %s. The multimethods:                 %s          are equally viable at %s"</p><p>If you specify two variants with the same parameter lists, Class::Multimethods warns:</p><p>        "Multimethod %s redefined at %s"</p><p>but only if $^W is true (i.e. under the \*(C`-w\*(C' flag).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Damian Conway (damian@conway.org)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS AND IRRITATIONS</h2>
        <div class="sectioncontent">
<p>There are undoubtedly serious bugs lurking somewhere in code this complex :-) Bug reports and other feedback are most welcome.</p><p>Ongoing annoyances include:</p><ul>
<li><p>The module uses qr// constructs to improve performance. Hence it won't run under Perls earlier than 5.005.</p></li><li><p>Multimethod dispatch is much slower than regular dispatch when the resolution has to resort to the more generic cases (though it's actually as very nearly as fast as doing the equivalent type resolution \*(L"by hand\*(R", and certainly more reliable and maintainable)</p></li><li><p>The cache management is far too dumb. Adding any new multimethod clobbers the entire cache, when it should only expunge those entries \*(L"upstream\*(R" from the the new multimethod's actual parameter types. It's unclear, however, under what circumstances the expense of a more careful cache correction algorithm would ever be recouped by the savings in dispatch (well, obviously, when the installion of multimethods is a rare event and multimethod dispatching is frequent, but where is the breakeven point?)</p></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>        Copyright (c) 1998-2000, Damian Conway. All Rights Reserved.       This module is free software. It may be used, redistributed       and/or modified under the terms of the Perl Artistic License            (see http://www.perl.com/perl/misc/Artistic.html)</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Class::MixinFactory::ReadMe.3pm.html"><span aria-hidden="true">&larr;</span> Class::MixinFactory::ReadMe.3pm: About the mixin class factory</a></li>
   <li class="next"><a href="Class::OOorNO.3pm.html">Class::OOorNO.3pm: Give your module classic \s-1and\s0 \s-1oo\s0 interfaces <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

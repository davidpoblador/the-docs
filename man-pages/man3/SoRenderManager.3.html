<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SoRenderManager: The sorendermanager class is used for controlling the rendering of a scene graph.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The sorendermanager class is used for controlling the rendering of a scene graph.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="SoRenderManager (3) manual">
  <meta name="twitter:description" content="The sorendermanager class is used for controlling the rendering of a scene graph.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcoin80-doc-SoRenderManager-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/SoRenderManager.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="SoRenderManager (3) manual" />
  <meta property="og:description" content="The sorendermanager class is used for controlling the rendering of a scene graph." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcoin80-doc-SoRenderManager-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">SoRenderManager<small> (3)</small></h1>
        <p class="lead">The sorendermanager class is used for controlling the rendering of a scene graph.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoRenderManager.3.html">
      <span itemprop="name">SoRenderManager: The sorendermanager class is used for controlling the rendering of a scene graph.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcoin80-doc/">
      <span itemprop="name">libcoin80-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoRenderManager.3.html">
      <span itemprop="name">SoRenderManager: The sorendermanager class is used for controlling the rendering of a scene graph.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;Inventor/SoRenderManager.h&gt;</p><h3>Public Types</h3>
<p>enum <strong>RenderMode</strong> { <strong>AS_IS</strong>, <strong>WIREFRAME</strong>, <strong>POINTS</strong>, <strong>WIREFRAME_OVERLAY</strong>, <strong>HIDDEN_LINE</strong>, <strong>BOUNDING_BOX</strong> }</p><p>enum <strong>StereoMode</strong> { <strong>MONO</strong>, <strong>ANAGLYPH</strong>, <strong>SEPARATE_OUTPUT</strong>, <strong>QUAD_BUFFER</strong> = SEPARATE_OUTPUT, <strong>INTERLEAVED_ROWS</strong>, <strong>INTERLEAVED_COLUMNS</strong> }</p><p>enum <strong>BufferType</strong> { <strong>BUFFER_SINGLE</strong>, <strong>BUFFER_DOUBLE</strong> }</p><p>enum <strong>AutoClippingStrategy</strong> { <strong>NO_AUTO_CLIPPING</strong>, <strong>FIXED_NEAR_PLANE</strong>, <strong>VARIABLE_NEAR_PLANE</strong> }</p>
<h3>Public Member Functions</h3>
<p><strong>SoRenderManager</strong> (void)</p><p>virtual <strong>~SoRenderManager</strong> ()</p><p>virtual void <strong>render</strong> (const SbBool clearwindow=TRUE, const SbBool clearzbuffer=TRUE)</p><p>virtual void <strong>render</strong> (<strong>SoGLRenderAction</strong> *action, const SbBool initmatrices=TRUE, const SbBool clearwindow=TRUE, const SbBool clearzbuffer=TRUE)</p><p>Superimposition * <strong>addSuperimposition</strong> (<strong>SoNode</strong> *scene, uint32_t flags=Superimposition::AUTOREDRAW|Superimposition::ZBUFFERON|Superimposition::CLEARZBUFFER)</p><p>void <strong>removeSuperimposition</strong> (Superimposition *s)</p><p>virtual void <strong>setSceneGraph</strong> (<strong>SoNode</strong> *const sceneroot)</p><p>virtual <strong>SoNode</strong> * <strong>getSceneGraph</strong> (void) const </p><p>void <strong>setCamera</strong> (<strong>SoCamera</strong> *camera)</p><p><strong>SoCamera</strong> * <strong>getCamera</strong> (void) const </p><p>void <strong>setAutoClipping</strong> (<strong>AutoClippingStrategy</strong> autoclipping)</p><p><strong>AutoClippingStrategy</strong> <strong>getAutoClipping</strong> (void) const </p><p>void <strong>setNearPlaneValue</strong> (float value)</p><p>float <strong>getNearPlaneValue</strong> (void) const </p><p>void <strong>setTexturesEnabled</strong> (const SbBool onoff)</p><p>SbBool <strong>isTexturesEnabled</strong> (void) const </p><p>void <strong>setDoubleBuffer</strong> (const SbBool enable)</p><p>SbBool <strong>isDoubleBuffer</strong> (void) const </p><p>void <strong>setRenderMode</strong> (const <strong>RenderMode</strong> mode)</p><p><strong>RenderMode</strong> <strong>getRenderMode</strong> (void) const </p><p>void <strong>setStereoMode</strong> (const <strong>StereoMode</strong> mode)</p><p><strong>StereoMode</strong> <strong>getStereoMode</strong> (void) const </p><p>void <strong>setStereoOffset</strong> (const float offset)</p><p>float <strong>getStereoOffset</strong> (void) const </p><p>void <strong>setRenderCallback</strong> (SoRenderManagerRenderCB *f, void *const userData=NULL)</p><p>SbBool <strong>isAutoRedraw</strong> (void) const </p><p>void <strong>setRedrawPriority</strong> (const uint32_t priority)</p><p>uint32_t <strong>getRedrawPriority</strong> (void) const </p><p>void <strong>scheduleRedraw</strong> (void)</p><p>void <strong>setWindowSize</strong> (const <strong>SbVec2s</strong> &newsize)</p><p>const <strong>SbVec2s</strong> & <strong>getWindowSize</strong> (void) const </p><p>void <strong>setSize</strong> (const <strong>SbVec2s</strong> &newsize)</p><p>const <strong>SbVec2s</strong> & <strong>getSize</strong> (void) const </p><p>void <strong>setOrigin</strong> (const <strong>SbVec2s</strong> &newOrigin)</p><p>const <strong>SbVec2s</strong> & <strong>getOrigin</strong> (void) const </p><p>void <strong>setViewportRegion</strong> (const <strong>SbViewportRegion</strong> &newRegion)</p><p>const <strong>SbViewportRegion</strong> & <strong>getViewportRegion</strong> (void) const </p><p>void <strong>setBackgroundColor</strong> (const <strong>SbColor4f</strong> &color)</p><p>const <strong>SbColor4f</strong> & <strong>getBackgroundColor</strong> (void) const </p><p>void <strong>setOverlayColor</strong> (const <strong>SbColor4f</strong> &color)</p><p><strong>SbColor4f</strong> <strong>getOverlayColor</strong> (void) const </p><p>void <strong>setBackgroundIndex</strong> (const int index)</p><p>int <strong>getBackgroundIndex</strong> (void) const </p><p>void <strong>setRGBMode</strong> (const SbBool onOrOff)</p><p>SbBool <strong>isRGBMode</strong> (void) const </p><p>virtual void <strong>activate</strong> (void)</p><p>virtual void <strong>deactivate</strong> (void)</p><p>void <strong>setAntialiasing</strong> (const SbBool smoothing, const int numPasses)</p><p>void <strong>getAntialiasing</strong> (SbBool &smoothing, int &numPasses) const </p><p>void <strong>setGLRenderAction</strong> (<strong>SoGLRenderAction</strong> *const action)</p><p><strong>SoGLRenderAction</strong> * <strong>getGLRenderAction</strong> (void) const </p><p>void <strong>setAudioRenderAction</strong> (<strong>SoAudioRenderAction</strong> *const action)</p><p><strong>SoAudioRenderAction</strong> * <strong>getAudioRenderAction</strong> (void) const </p><p>void <strong>addPreRenderCallback</strong> (SoRenderManagerRenderCB *cb, void *data)</p><p>void <strong>removePreRenderCallback</strong> (SoRenderManagerRenderCB *cb, void *data)</p><p>void <strong>addPostRenderCallback</strong> (SoRenderManagerRenderCB *cb, void *data)</p><p>void <strong>removePostRenderCallback</strong> (SoRenderManagerRenderCB *cb, void *data)</p><p>void <strong>reinitialize</strong> (void)</p>
<h3>Static Public Member Functions</h3>
<p>static void <strong>enableRealTimeUpdate</strong> (const SbBool flag)</p><p>static SbBool <strong>isRealTimeUpdateEnabled</strong> (void)</p><p>static uint32_t <strong>getDefaultRedrawPriority</strong> (void)</p>
<h3>Protected Member Functions</h3>
<p>int <strong>isActive</strong> (void) const </p><p>void <strong>redraw</strong> (void)</p><p>void <strong>renderScene</strong> (<strong>SoGLRenderAction</strong> *action, <strong>SoNode</strong> *scene, uint32_t clearmask)</p><p>void <strong>actuallyRender</strong> (<strong>SoGLRenderAction</strong> *action, const SbBool initmatrices=TRUE, const SbBool clearwindow=TRUE, const SbBool clearzbuffer=TRUE)</p><p>void <strong>renderSingle</strong> (<strong>SoGLRenderAction</strong> *action, SbBool initmatrices, SbBool clearwindow, SbBool clearzbuffer)</p><p><em>Render once in correct draw style. </em> void <strong>renderStereo</strong> (<strong>SoGLRenderAction</strong> *action, SbBool initmatrices, SbBool clearwindow, SbBool clearzbuffer)</p><p><em>Render scene according to current stereo mode. </em> void <strong>initStencilBufferForInterleavedStereo</strong> (void)</p><p>void <strong>clearBuffers</strong> (SbBool color, SbBool depth)</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>The <strong>SoRenderManager</strong> class is used for controlling the rendering of a scene graph.</p><p>You can use this class to configure things like clipping planes, rendering mode, stereo rendering and the background color. In earlier versions of Coin/Inventor, this was set up in the GUI toolkits, making it quite hard to make a new Coin viewer for another GUI toolkit. With this new class all that is needed is to create one <strong>SoRenderManager</strong> instance per viewer/view.</p><p>This class does not handle events for the scene graph/viewer. To do that you can use the <strong>SoEventManager</strong> class.</p><p><strong>Since:</strong></p><p>Coin 3.0</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Enumeration Documentation</h2>
        <div class="sectioncontent">
<h3>enum \fBSoRenderManager::RenderMode\fP</h3>
<p>Sets how rendering of primitives is done.</p><p><strong>Enumerator</strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><em>AS_IS </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Render primitives as they are described in the scenegraph.</p>
  </dd>
  <dt>
    <p><strong></strong><em>WIREFRAME </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Render polygons as wireframe</p>
  </dd>
  <dt>
    <p><strong></strong><em>POINTS </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Render only the vertices of the polygons and lines.</p>
  </dd>
  <dt>
    <p><strong></strong><em>WIREFRAME_OVERLAY </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Render a wireframe overlay in addition to the AS_IS mode</p>
  </dd>
  <dt>
    <p><strong></strong><em>HIDDEN_LINE </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>As WIREFRAME, but culls lines which would otherwise not be shown due to geometric culling.</p>
  </dd>
  <dt>
    <p><strong></strong><em>BOUNDING_BOX </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Only show the bounding box of each object.</p>
  </dd>

</dl>

<h3>enum \fBSoRenderManager::StereoMode\fP</h3>
<p>Manages how to render steroscopic images.</p><p><strong>Enumerator</strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><em>MONO </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>No stereoscopic rendering</p>
  </dd>
  <dt>
    <p><strong></strong><em>ANAGLYPH </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Anaglyph rendering is used to provide a steroscopic 3D effect, when viewed with 3D glasses. The image is made up of two color layers which are superimposed on each other, and appears as 3 dimensional when viewed through corresponding colored filters(glases)</p>
  </dd>
  <dt>
    <p><strong></strong><em>SEPARATE_OUTPUT </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Send output to separate buffers.</p>
  </dd>
  <dt>
    <p><strong></strong><em>QUAD_BUFFER </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Same as SEPARATE_OUTPUT, SEPARATE_OUTPUT is more commonly known as QUAD_BUFFER, when also using double buffering.</p>
  </dd>
  <dt>
    <p><strong></strong><em>INTERLEAVED_ROWS </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Render every second row as left and right image. If rendered with a polarized projector, polarized filters kan be used to give a 3D effect.</p>
  </dd>
  <dt>
    <p><strong></strong><em>INTERLEAVED_COLUMNS </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Render every second column as left and right image. If rendered with a polarized projector, polarized filters kan be used to give a 3D effect.</p>
  </dd>

</dl>

<h3>enum \fBSoRenderManager::BufferType\fP</h3>
<p>Buffering strategy</p><p><strong>Enumerator</strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><em>BUFFER_SINGLE </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Output to one buffer</p>
  </dd>
  <dt>
    <p><strong></strong><em>BUFFER_DOUBLE </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Alternate between output buffers</p>
  </dd>

</dl>

<h3>enum \fBSoRenderManager::AutoClippingStrategy\fP</h3>
<p>Strategy for adjusting camera near/far clipping plane</p><p><strong>Enumerator</strong></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong><em>NO_AUTO_CLIPPING </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Turn off automatic clipping. The user needs to set the correct values in the camera.</p>
  </dd>
  <dt>
    <p><strong></strong><em>FIXED_NEAR_PLANE </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Keep near plane at a fixed distance from the camera. The far plane is always set at the end of the bounding box.</p>
  </dd>
  <dt>
    <p><strong></strong><em>VARIABLE_NEAR_PLANE </em><strong></strong><em></em></p>
  </dt>
  <dd>
    <p>Variable adjustment of the nearplane relative to the camera.</p>
  </dd>

</dl>


        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>SoRenderManager::SoRenderManager (void)</h3>
<p>Constructor.</p>
<h3>SoRenderManager::~SoRenderManager ()\fC [virtual]\fP</h3>
<p>Destructor.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>void SoRenderManager::render (const SbBoolclearwindow = \fCTRUE\fP, const SbBoolclearzbuffer = \fCTRUE\fP)\fC [virtual]\fP</h3>
<p>Render the scene graph.</p><p>All SbBool arguments should normally be TRUE, but they can be set to FALSE to optimize for special cases (e.g. when doing wireframe rendering one doesn't need a depth buffer).</p><p><strong>Parameters:</strong></p><p><em>clearwindow</em> If set to TRUE<em>, clear the rendering buffer before drawing.</em></p><p><em>clearzbuffer</em> If set to TRUE<em>, clear the depth buffer values before rendering.</em></p>
<h3>void SoRenderManager::render (\fBSoGLRenderAction\fP *action, const SbBoolinitmatrices = \fCTRUE\fP, const SbBoolclearwindow = \fCTRUE\fP, const SbBoolclearzbuffer = \fCTRUE\fP)\fC [virtual]\fP</h3>
<p>Render the scene graph.</p><p>All SbBool arguments should normally be TRUE, but they can be set to FALSE to optimize for special cases (e.g. when doing wireframe rendering one doesn't need a depth buffer).</p><p><strong>Parameters:</strong></p><p><em>clearwindow</em> If set to TRUE<em>, clear the rendering buffer before drawing.</em></p><p><em>clearzbuffer</em> If set to TRUE<em>, clear the depth buffer values before rendering.</em></p><p><em>initmatrices</em> if true, the projection and modelview matrices are reset to identity</p><p><em>action</em> Renders with a user supplied action</p>
<h3>SoRenderManager::Superimposition * SoRenderManager::addSuperimposition (\fBSoNode\fP *scene, uint32_tflags = \fCSuperimposition::AUTOREDRAW | Superimposition::ZBUFFERON | Superimposition::CLEARZBUFFER\fP)</h3>
<p>Add a superimposition for this scene graph. A superimposition can either be a scene rendered in the background, or a scene rendered in the front of the actual scene graph.</p><p>This is useful, for instance, if you want to add a gradient or an image in the background, and for having some HUD info in the foreground.</p><p>Please note that if you use superimpositions, multipass antialiasing have to be handled in the render manager, and not in <strong>SoGLRenderAction</strong>, so the pass update features in <strong>SoGLRenderAction</strong> will be disabled.</p><p><strong>See also:</strong></p><p><strong>SoGLRenderAction::setNumPasses()</strong></p><p><strong>SoGLRenderAction::setPassUpdate()</strong></p><p><strong>SoGLRenderAction::setPassCallback()</strong></p>
<h3>void SoRenderManager::removeSuperimposition (Superimposition *s)</h3>
<p>Removes a superimposition.</p><p><strong>See also:</strong></p><p><strong>addSuperimposition()</strong></p>
<h3>void SoRenderManager::setSceneGraph (\fBSoNode\fP *constsceneroot)\fC [virtual]\fP</h3>
<p>Set the node which is top of the scene graph we're managing. The <em>sceneroot</em> node reference count will be increased by 1, and any previously set scene graph top node will have it's reference count decreased by 1.</p><p><strong>See also:</strong></p><p><strong>getSceneGraph()</strong></p>
<h3>\fBSoNode\fP * SoRenderManager::getSceneGraph (void) const\fC [virtual]\fP</h3>
<p>Returns the pointer to root of scene graph.</p>
<h3>void SoRenderManager::setCamera (\fBSoCamera\fP *camera)</h3>
<p>Sets the camera to be used.</p>
<h3>\fBSoCamera\fP * SoRenderManager::getCamera (void) const</h3>
<p>Returns the current camera.</p>
<h3>void SoRenderManager::setAutoClipping (\fBAutoClippingStrategy\fPautoclipping)</h3>
<p>Sets strategy for adjusting camera clipping plane</p><p><strong>See also:</strong></p><p><strong>SoRenderManager::AutoClippingStrategy</strong></p>
<h3>\fBSoRenderManager::AutoClippingStrategy\fP SoRenderManager::getAutoClipping (void) const</h3>
<p>This method returns the current autoclipping strategy.</p><p><strong>See also:</strong></p><p><strong>setAutoClipping</strong></p>
<h3>void SoRenderManager::setNearPlaneValue (floatvalue)</h3>
<p>When the <strong>SoRenderManager::FIXED_NEAR_PLANE</strong> autoclipping strategy is used, you set the value of the near plane distance with this method.</p><p><strong>See also:</strong></p><p><strong>setAutoClipping</strong>, <strong>getNearPlaneValue</strong>, <strong>SoRenderManager::AutoClippingStrategy</strong></p>
<h3>float SoRenderManager::getNearPlaneValue (void) const</h3>
<p>This method returns the near plane distance value that will be used when the <strong>SoRenderManager::FIXED_NEAR_PLANE</strong> autoclipping strategy is used.</p><p>Default value is 0.6.</p><p><strong>See also:</strong></p><p><strong>setAutoClipping</strong>, <strong>setNearPlaneValue</strong>, <strong>SoRenderManager::AutoClippingStrategy</strong></p>
<h3>void SoRenderManager::setTexturesEnabled (const SbBoolonoff)</h3>
<p>Enable/disable textures when rendering. Defaults to TRUE.</p><p><strong>See also:</strong></p><p><strong>isTexturesEnabled</strong></p>
<h3>SbBool SoRenderManager::isTexturesEnabled (void) const</h3>
<p>Returns whether textures are enabled or not.</p><p><strong>See also:</strong></p><p><strong>setTexturesEnabled</strong></p>
<h3>void SoRenderManager::setDoubleBuffer (const SbBoolenable)</h3>
<p>Tell the scenemanager that double buffering is used</p>
<h3>SbBool SoRenderManager::isDoubleBuffer (void) const</h3>
<p>returns if the scenemanager is double buffered</p>
<h3>void SoRenderManager::setRenderMode (const \fBRenderMode\fPmode)</h3>
<p>Sets the render mode.</p>
<h3>\fBSoRenderManager::RenderMode\fP SoRenderManager::getRenderMode (void) const</h3>
<p>Returns the current render mode.</p>
<h3>void SoRenderManager::setStereoMode (const \fBStereoMode\fPmode)</h3>
<p>Sets the stereo mode.</p>
<h3>\fBSoRenderManager::StereoMode\fP SoRenderManager::getStereoMode (void) const</h3>
<p>Returns the current stereo mode.</p>
<h3>void SoRenderManager::setStereoOffset (const floatoffset)</h3>
<p>Sets the stereo offset used when doing stereo rendering.</p>
<h3>float SoRenderManager::getStereoOffset (void) const</h3>
<p>Returns the current stereo offset.</p>
<h3>void SoRenderManager::setRenderCallback (SoRenderManagerRenderCB *f, void *constuserdata = \fCNULL\fP)</h3>
<p>Set the callback function <em>f</em> to invoke when rendering the scene. <em>userdata</em> will be passed as the first argument of the function.</p>
<h3>SbBool SoRenderManager::isAutoRedraw (void) const</h3>
<p>Returns TRUE if the <strong>SoRenderManager</strong> automatically redraws the scene upon detecting changes in the scene graph.</p><p>The automatic redraw is turned on and off by setting either a valid callback function with <strong>setRenderCallback()</strong>, or by passing NULL<strong>.</strong></p>
<h3>void SoRenderManager::setRedrawPriority (const uint32_tpriority)</h3>
<p>Set up the redraw <em>priority</em> for the <strong>SoOneShotSensor</strong> used to trigger redraws. By setting this lower than for your own sensors, you can make sure some code is always run before redraw happens.</p><p><strong>See also:</strong></p><p><strong>SoDelayQueueSensor</strong></p>
<h3>uint32_t SoRenderManager::getRedrawPriority (void) const</h3>
<p>Returns value of priority on the redraw sensor.</p>
<h3>void SoRenderManager::scheduleRedraw (void)</h3>
<p>Redraw at first opportunity as system becomes idle.</p><p>Multiple calls to this method before an actual redraw has taken place will only result in a single redraw of the scene.</p>
<h3>void SoRenderManager::setWindowSize (const \fBSbVec2s\fP &newsize)</h3>
<p>Update window size of our <strong>SoGLRenderAction</strong>'s viewport settings.</p><p>Note that this will <em>only</em> change the information about window dimensions, the actual viewport size and origin (ie the rectangle which redraws are confined to) will stay the same.</p><p><strong>See also:</strong></p><p><strong>setViewportRegion()</strong></p>
<h3>const \fBSbVec2s\fP & SoRenderManager::getWindowSize (void) const</h3>
<p>Returns the current render action window size.</p><p><strong>See also:</strong></p><p><strong>setWindowSize()</strong></p>
<h3>void SoRenderManager::setSize (const \fBSbVec2s\fP &newsize)</h3>
<p>Set size of rendering area for the viewport within the current window.</p>
<h3>const \fBSbVec2s\fP & SoRenderManager::getSize (void) const</h3>
<p>Returns size of render area.</p>
<h3>void SoRenderManager::setOrigin (const \fBSbVec2s\fP &newOrigin)</h3>
<p>Set <em>only</em> the origin of the viewport region within the rendering window.</p><p><strong>See also:</strong></p><p><strong>setViewportRegion()</strong>, <strong>setWindowSize()</strong></p>
<h3>const \fBSbVec2s\fP & SoRenderManager::getOrigin (void) const</h3>
<p>Returns origin of rendering area viewport.</p><p><strong>See also:</strong></p><p><strong>setOrigin()</strong></p>
<h3>void SoRenderManager::setViewportRegion (const \fBSbViewportRegion\fP &newregion)</h3>
<p>Update our <strong>SoGLRenderAction</strong>'s viewport settings.</p><p>This will change <em>both</em> the information about window dimensions and the actual viewport size and origin.</p><p><strong>See also:</strong></p><p><strong>setWindowSize()</strong></p>
<h3>const \fBSbViewportRegion\fP & SoRenderManager::getViewportRegion (void) const</h3>
<p>Returns current viewport region used by the renderaction and the event handling.</p><p><strong>See also:</strong></p><p><strong>setViewportRegion()</strong></p>
<h3>void SoRenderManager::setBackgroundColor (const \fBSbColor4f\fP &color)</h3>
<p>Sets color of rendering canvas.</p>
<h3>const \fBSbColor4f\fP & SoRenderManager::getBackgroundColor (void) const</h3>
<p>Returns color used for clearing the rendering area before rendering the scene.</p>
<h3>void SoRenderManager::setOverlayColor (const \fBSbColor4f\fP &color)</h3>
<p>Sets color of overlay.</p>
<h3>\fBSbColor4f\fP SoRenderManager::getOverlayColor (void) const</h3>
<p>Returns color used rendering overlay.</p>
<h3>void SoRenderManager::setBackgroundIndex (const intindex)</h3>
<p>Set index of background color in the color lookup table if rendering in colorindex mode.</p><p>Note: colorindex mode is not supported yet in Coin.</p>
<h3>int SoRenderManager::getBackgroundIndex (void) const</h3>
<p>Returns index of colormap for background filling.</p><p><strong>See also:</strong></p><p><strong>setBackgroundIndex()</strong></p>
<h3>void SoRenderManager::setRGBMode (const SbBoolyes)</h3>
<p>Turn RGB truecolor mode on or off. If you turn truecolor mode off, colorindex mode will be used instead.</p>
<h3>SbBool SoRenderManager::isRGBMode (void) const</h3>
<p>Returns the 'truecolor or colorindex' mode flag.</p>
<h3>void SoRenderManager::activate (void)\fC [virtual]\fP</h3>
<p>Activate rendering and event handling. Default is off.</p>
<h3>void SoRenderManager::deactivate (void)\fC [virtual]\fP</h3>
<p>Deactive rendering and event handling.</p>
<h3>void SoRenderManager::setAntialiasing (const SbBoolsmoothing, const intnumpasses)</h3>
<p>Turn antialiased rendering on or off.</p><p>See documentation for <strong>SoGLRenderAction::setSmoothing()</strong> and <strong>SoGLRenderAction::setNumPasses()</strong>.</p>
<h3>void SoRenderManager::getAntialiasing (SbBool &smoothing, int &numpasses) const</h3>
<p>Returns rendering pass information.</p><p><strong>See also:</strong></p><p><strong>setAntialiasing()</strong></p>
<h3>void SoRenderManager::setGLRenderAction (\fBSoGLRenderAction\fP *constaction)</h3>
<p>Set the <em>action</em> to use for rendering. Overrides the default action made in the constructor.</p>
<h3>\fBSoGLRenderAction\fP * SoRenderManager::getGLRenderAction (void) const</h3>
<p>Returns pointer to render action.</p>
<h3>void SoRenderManager::setAudioRenderAction (\fBSoAudioRenderAction\fP *constaction)</h3>
<p>Set the <em>action</em> to use for rendering audio. Overrides the default action made in the constructor.</p>
<h3>\fBSoAudioRenderAction\fP * SoRenderManager::getAudioRenderAction (void) const</h3>
<p>Returns pointer to audio render action.</p>
<h3>void SoRenderManager::enableRealTimeUpdate (const SbBoolflag)\fC [static]\fP</h3>
<p>Set whether or not for <strong>SoRenderManager</strong> instances to 'touch' the global realTime<strong> field after a redraw. If this is not done, redrawing when animating the scene will only happen as fast as the realTime</strong> interval goes (which defaults to 12 times a second).</p><p><strong>See also:</strong></p><p><strong>SoDB::setRealTimeInterval()</strong></p>
<h3>SbBool SoRenderManager::isRealTimeUpdateEnabled (void)\fC [static]\fP</h3>
<p>Returns whether or not we automatically notifies everything connected to the realTime field after a redraw.</p>
<h3>uint32_t SoRenderManager::getDefaultRedrawPriority (void)\fC [static]\fP</h3>
<p>Returns the default priority of the redraw sensor.</p><p><strong>See also:</strong></p><p><strong>SoDelayQueueSensor</strong>, <strong>setRedrawPriority()</strong></p>
<h3>void SoRenderManager::addPreRenderCallback (SoRenderManagerRenderCB *cb, void *data)</h3>
<p>Adds a function to be called before rendering starts</p><p><strong>Parameters:</strong></p><p><em>cb</em> function to be called</p><p><em>data</em> User specified data to supply to callback function</p>
<h3>void SoRenderManager::removePreRenderCallback (SoRenderManagerRenderCB *cb, void *data)</h3>
<p>Removes a prerendercallback.</p><p><strong>Precondition:</strong></p><p>The tuple (cb, data) must exactly match an earlier call to <strong>SoRenderManager::addPreRenderCallback</strong></p><p><strong>Parameters:</strong></p><p><em>cb</em> function to be called</p><p><em>data</em> User specified data to supply to callback function</p>
<h3>void SoRenderManager::addPostRenderCallback (SoRenderManagerRenderCB *cb, void *data)</h3>
<p>Adds a function to be called after rendering is complete</p><p><strong>Parameters:</strong></p><p><em>cb</em> function to be called</p><p><em>data</em> User specified data to supply to callback function</p>
<h3>void SoRenderManager::removePostRenderCallback (SoRenderManagerRenderCB *cb, void *data)</h3>
<p>Removes a postrendercallback.</p><p><strong>Precondition:</strong></p><p>The tuple (cb, data) must exactly match an earlier call to <strong>SoRenderManager::addPostRenderCallback</strong></p><p><strong>Parameters:</strong></p><p><em>cb</em> function to be called</p><p><em>data</em> User specified data to supply to callback function</p>
<h3>void SoRenderManager::reinitialize (void)</h3>
<p>Reinitialize after parameters affecting the OpenGL context has changed.</p>
<h3>int SoRenderManager::isActive (void) const\fC [protected]\fP</h3>
<p>Returns the <em>active</em> flag.</p>
<h3>void SoRenderManager::redraw (void)\fC [protected]\fP</h3>
<p>Do an immediate redraw by calling the redraw callback function.</p>
<h3>void SoRenderManager::renderScene (\fBSoGLRenderAction\fP *action, \fBSoNode\fP *scene, uint32_tclearmask)\fC [protected]\fP</h3>
<p>Renders a scene and applies clear state as given by this renderManager</p><p><strong>Parameters:</strong></p><p><em>action</em> Action to apply</p><p><em>scene</em> Scene to render</p><p><em>clearmask</em> mask to pass to glClear</p>
<h3>void SoRenderManager::actuallyRender (\fBSoGLRenderAction\fP *action, const SbBoolinitmatrices = \fCTRUE\fP, const SbBoolclearwindow = \fCTRUE\fP, const SbBoolclearzbuffer = \fCTRUE\fP)\fC [protected]\fP</h3>
<p>Convenience function for <strong>SoRenderManager::renderScene</strong></p><p><strong>Parameters:</strong></p><p><em>action</em> Renders with a user supplied action</p><p><em>initmatrices</em> if true, the projection and modelview matrices are reset to identity</p><p><em>clearwindow</em> If set to TRUE<em>, clear the rendering buffer before drawing.</em></p><p><em>clearzbuffer</em> If set to TRUE<em>, clear the depth buffer values before rendering.</em></p>
<h3>void SoRenderManager::renderSingle (\fBSoGLRenderAction\fP *action, SbBoolinitmatrices, SbBoolclearwindow, SbBoolclearzbuffer)\fC [protected]\fP</h3>
<p>Render once in correct draw style. Convenience function for <strong>SoRenderManager::renderScene</strong></p><p><strong>Parameters:</strong></p><p><em>action</em> Renders with a user supplied action</p><p><em>initmatrices</em> if true, the projection and modelview matrices are reset to identity</p><p><em>clearwindow</em> If set to TRUE<em>, clear the rendering buffer before drawing.</em></p><p><em>clearzbuffer</em> If set to TRUE<em>, clear the depth buffer values before rendering.</em></p>
<h3>void SoRenderManager::renderStereo (\fBSoGLRenderAction\fP *action, SbBoolinitmatrices, SbBoolclearwindow, SbBoolclearzbuffer)\fC [protected]\fP</h3>
<p>Render scene according to current stereo mode. Convenience function for <strong>SoRenderManager::renderScene</strong></p><p><strong>Parameters:</strong></p><p><em>action</em> Renders with a user supplied action</p><p><em>initmatrices</em> if true, the projection and modelview matrices are reset to identity</p><p><em>clearwindow</em> If set to TRUE<em>, clear the rendering buffer before drawing.</em></p><p><em>clearzbuffer</em> If set to TRUE<em>, clear the depth buffer values before rendering.</em></p>
<h3>void SoRenderManager::initStencilBufferForInterleavedStereo (void)\fC [protected]\fP</h3>
<p>Initializes stencilbuffers for interleaved stereo</p>
<h3>void SoRenderManager::clearBuffers (SbBoolcolor, SbBooldepth)\fC [protected]\fP</h3>
<p>Clears buffers with the backgroundcolor set correctly</p><p><strong>Parameters:</strong></p><p><em>color</em> Set to TRUE<em> if color buffer should be cleared</em></p><p><em>depth</em> Set to TRUE<em> if depth buffer should be cleared</em></p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for Coin from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="SoReadError.3.html"><span aria-hidden="true">&larr;</span> SoReadError.3: The soreaderror class is used during model import operations.  during model file import, this class will be used to output any error or warning messages.</a></li>
   <li class="next"><a href="SoRenderManager.h.3.html">SoRenderManager.h.3: Sorendermanager.h - <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

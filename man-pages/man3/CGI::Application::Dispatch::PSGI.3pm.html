<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>CGI::Application::Dispatch::PSGI: Dispatch requests to cgi::application based objects using psgi</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Dispatch requests to cgi::application based objects using psgi">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="CGI::Application::Dispatch::PSGI (3pm) manual">
  <meta name="twitter:description" content="Dispatch requests to cgi::application based objects using psgi">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcgi-application-dispatch-perl-CGI::Application::Dispatch::PSGI-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/CGI::Application::Dispatch::PSGI.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="CGI::Application::Dispatch::PSGI (3pm) manual" />
  <meta property="og:description" content="Dispatch requests to cgi::application based objects using psgi" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcgi-application-dispatch-perl-CGI::Application::Dispatch::PSGI-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">CGI::Application::Dispatch::PSGI<small> (3pm)</small></h1>
        <p class="lead">Dispatch requests to cgi::application based objects using psgi</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/CGI::Application::Dispatch::PSGI.3pm.html">
      <span itemprop="name">CGI::Application::Dispatch::PSGI: Dispatch requests to cgi::application based objects using psgi</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcgi-application-dispatch-perl/">
      <span itemprop="name">libcgi-application-dispatch-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/CGI::Application::Dispatch::PSGI.3pm.html">
      <span itemprop="name">CGI::Application::Dispatch::PSGI: Dispatch requests to cgi::application based objects using psgi</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<h3>Out of Box</h3>
<p>Under mod_perl:</p>
<pre>
  # change "Apache1" to "Apache2" as needed.

  &lt;Location /&gt;
  SetHandler perl-script
  PerlHandler Plack::Handler::Apache1
  PerlSetVar psgi_app /path/to/app.psgi
  &lt;/Location&gt;

  &lt;Perl&gt;
  use Plack::Handler::Apache1;
  Plack::Handler::Apache1-&gt;preload("/path/to/app.psgi");
  &lt;/Perl&gt;
</pre>
<p>Under \s-1CGI:\s0</p><p>This would be the instance script for your application, such as /cgi-bin/dispatch.cgi:</p><p>    ### in your dispatch.psgi:     # ( in a persistent environment, use FindBin::Real instead. )     use FindBin &apos;Bin&apos;;     use lib "$Bin/../perllib&apos;;     use Your::Application::Dispatch;     Your::Application::Dispatch-&gt;as_psgi;</p><p>    ### In Your::Application::Dispatch;     package Your::Application::Dispatch;     use base &apos;CGI::Application::Dispatch::PSGI&apos;;</p>
<h3>With a dispatch table</h3>
<p>    package MyApp::Dispatch;     use base &apos;CGI::Application::Dispatch::PSGI&apos;;</p><p>    sub dispatch_args {         return {             prefix  =&gt; &apos;MyApp&apos;,             table   =&gt; [                 &apos;&apos;                =&gt; { app =&gt; &apos;Welcome&apos;, rm =&gt; &apos;start&apos; },                 &apos;:app/:rm&apos;        =&gt; { },                 &apos;admin/:app/:rm&apos;  =&gt; { prefix   =&gt; &apos;MyApp::Admin&apos; },             ],         };     }</p><p>The \*(C`.psgi\*(C' file is constructed as above.</p>
<h3>With a custom query object</h3>
<p>If you want to supply your own \s-1PSGI\s0 object, something like this in your .psgi file will work:</p><p>    sub {         my $env = shift;         my $app = CGI::Application::Dispatch::PSGI-&gt;as_psgi(             table =&gt; [                 &apos;/:rm&apos;    =&gt;    { app =&gt; &apos;TestApp&apos; }             ],             args_to_new =&gt; {                 QUERY    =&gt; CGI::PSGI-&gt;new($env)             }         );         return $app-&gt;($env);     }</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module provides a way to look at the path (as returned by \*(C`$env-&gt;{PATH_INFO}\*(C') of the incoming request, parse off the desired module and its run mode, create an instance of that module and run it.</p><p>It will translate a \s-1URI\s0 like this (in a persistent environment)</p><p>    /app/module_name/run_mode</p><p>or this (vanilla \s-1CGI\s0)</p><p>    /app/index.cgi/module_name/run_mode</p><p>into something that will be functionally similar to this</p><p>    my $app = Module::Name-&gt;new(..);     $app-&gt;mode_param(sub {&apos;run_mode&apos;}); #this will set the run mode</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">
<h3>as_psgi(%args)</h3>
<p>This is the primary method used during dispatch.</p><p>    #!/usr/bin/perl     use strict;     use CGI::Application::Dispatch::PSGI;</p><p>    CGI::Application::Dispatch::PSGI-&gt;as_psgi(         prefix  =&gt; &apos;MyApp&apos;,         default =&gt; &apos;module_name&apos;,     );</p><p>This method accepts the following name value pairs:</p>
<dl class='dl-vertical'>
  <dt>
    default
  </dt>
  <dd>
    <p>Specify a value to use for the path if one is not available. This could be the case if the default page is selected (eg: \*(L"/\*(R" ).</p>
  </dd>
  <dt>
    prefix
  </dt>
  <dd>
    <p>This option will set the string that will be prepended to the name of the application module before it is loaded and created. So to use our previous example request of     /app/index.cgi/module_name/run_mode This would by default load and create a module named 'Module::Name'. But let's say that you have all of your application specific modules under the 'My' namespace. If you set this option to 'My' then it would instead load the 'My::Module::Name' application module instead.</p>
  </dd>
  <dt>
    args_to_new
  </dt>
  <dd>
    <p>This is a hash of arguments that are passed into the \*(C`new()\*(C' constructor of the application.</p>
  </dd>
  <dt>
    table
  </dt>
  <dd>
    <p>In most cases, simply using Dispatch with the \*(C`default\*(C' and \*(C`prefix\*(C' is enough to simplify your application and your URLs, but there are many cases where you want more power. Enter the dispatch table. Since this table can be slightly complicated, a whole section exists on its use. Please see the \*(L"\s-1DISPATCH\s0 \s-1TABLE\s0\*(R" section.</p>
  </dd>
  <dt>
    debug
  </dt>
  <dd>
    <p>Set to a true value to send debugging output for this module to \s-1STDERR\s0. Off by default.</p>
  </dd>
  <dt>
    auto_rest
  </dt>
  <dd>
    <p>This tells Dispatch that you are using \s-1REST\s0 by default and that you care about which \s-1HTTP\s0 method is being used. Dispatch will append the \s-1HTTP\s0 method name (upper case by default) to the run mode that is determined after finding the appropriate dispatch rule. So a \s-1GET\s0 request that translates into \*(C`MyApp::Module-&gt;foo\*(C' will become \*(C`MyApp::Module-&gt;foo_GET\*(C'. This can be overridden on a per-rule basis in a custom dispatch table.</p>
  </dd>
  <dt>
    auto_rest_lc
  </dt>
  <dd>
    <p>In combinaion with auto_rest this tells Dispatch that you prefer lower cased \s-1HTTP\s0 method names.  So instead of \*(C`foo_POST\*(C' and \*(C`foo_GET\*(C' you'll have \*(C`foo_post\*(C' and \*(C`foo_get\*(C'.</p>
  </dd>

</dl>

<h3>\fIdispatch_args()\fP</h3>
<p>Returns a hashref of args that will be passed to dispatch(). It will return the following structure by default.</p><p>    {         prefix      =&gt; &apos;&apos;,         args_to_new =&gt; {},         table       =&gt; [             &apos;:app&apos;      =&gt; {},             &apos;:app/:rm&apos;  =&gt; {},         ],     }</p><p>This is the perfect place to override when creating a subclass to provide a richer dispatch table.</p><p>When called, it receives 1 argument, which is a reference to the hash of args passed into dispatch.</p>
<h3>translate_module_name($input)</h3>
<p>This method is used to control how the module name is translated from the matching section of the path (see \*(L"Path Parsing\*(R".  The main reason that this method exists is so that it can be overridden if it doesn't do exactly what you want.</p><p>The following transformations are performed on the input:</p>
<dl class='dl-vertical'>
  <dt>
    The text is split on '_'s (underscores) and each word has its first letter capitalized. The words are then joined back together and each instance of an underscore is replaced by '::'.
  </dt>
  <dd>
    
  </dd>
  <dt>
    The text is split on '-'s (hyphens) and each word has its first letter capitalized. The words are then joined back together and each instance of a hyphen removed.
  </dt>
  <dd>
    
  </dd>

</dl>
<p>Here are some examples to make it even clearer:</p><p>    module_name         =&gt; Module::Name     module-name         =&gt; ModuleName     admin_top-scores    =&gt; Admin::TopScores</p>
<h3>require_module($module_name)</h3>
<p>This class method is used internally to take a module name (supplied by get_module_name) and require it in a secure fashion. It is provided as a public class method so that if you override other functionality of this module, you can still safely require user specified modules. If there are any problems requiring the named module, then we will \*(C`croak\*(C'.</p><p>    CGI::Application::Dispatch::PSGI-&gt;require_module(&apos;MyApp::Module::Name&apos;);</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DISPATCH TABLE</h2>
        <div class="sectioncontent">
<p>Sometimes it's easiest to explain with an example, so here you go:</p><p>  CGI::Application::Dispatch::PSGI-&gt;as_psgi(     prefix      =&gt; &apos;MyApp&apos;,     args_to_new =&gt; {         TMPL_PATH =&gt; &apos;myapp/templates&apos;     },     table       =&gt; [         &apos;&apos;                         =&gt; { app =&gt; &apos;Blog&apos;, rm =&gt; &apos;recent&apos;},         &apos;posts/:category&apos;          =&gt; { app =&gt; &apos;Blog&apos;, rm =&gt; &apos;posts&apos; },         &apos;:app/:rm/:id&apos;             =&gt; { app =&gt; &apos;Blog&apos; },         &apos;date/:year/:month?/:day?&apos; =&gt; {             app         =&gt; &apos;Blog&apos;,             rm          =&gt; &apos;by_date&apos;,             args_to_new =&gt; { TMPL_PATH =&gt; "events/" },         },     ]   );</p><p>So first, this call to as_psgi sets the prefix and passes a \*(C`TMPL_PATH\*(C' into args_to_new. Next it sets the table.</p><h3>\s-1VOCABULARY\s0</h3>
<p>Just so we all understand what we're talking about....</p><p>A table is an array where the elements are gouped as pairs (similar to a hash's key-value pairs, but as an array to preserve order). The first element of each pair is called a \*(C`rule\*(C'. The second element in the pair is called the rule's \*(C`arg list\*(C'.  Inside a rule there are slashes \*(C`/\*(C'. Anything set of characters between slashes is called a \*(C`token\*(C'.</p>
<h3>\s-1URL\s0 \s-1MATCHING\s0</h3>
<p>When a \s-1URL\s0 comes in, Dispatch tries to match it against each rule in the table in the order in which the rules are given. The first one to match wins.</p><p>A rule consists of slashes and tokens. A token can one of the following types:</p>
<dl class='dl-vertical'>
  <dt>
    literal
  </dt>
  <dd>
    <p>Any token which does not start with a colon (\*(C`:\*(C') is taken to be a literal string and must appear exactly as-is in the \s-1URL\s0 in order to match. In the rule     &apos;posts/:category&apos; \*(C`posts\*(C' is a literal token.</p>
  </dd>
  <dt>
    variable
  </dt>
  <dd>
    <p>Any token which begins with a colon (\*(C`:\*(C') is a variable token. These are simply wild-card place holders in the rule that will match anything in the \s-1URL\s0 that isn't a slash. These variables can later be referred to by using the \*(C`$self-&gt;param\*(C' mechanism. In the rule     &apos;posts/:category&apos; \*(C`:category\*(C' is a variable token. If the \s-1URL\s0 matched this rule, then you could the value of that token from whithin your application like so:     my $category = $self-&gt;param(&apos;category&apos;); There are some variable tokens which are special. These can be used to further customize the dispatching.</p>
<dl class='dl-vertical'>
  <dt>
    :app
  </dt>
  <dd>
    <p>This is the module name of the application. The value of this token will be sent to the translate_module_name method and then prefixed with the prefix if there is one.</p>
  </dd>
  <dt>
    :rm
  </dt>
  <dd>
    <p>This is the run mode of the application. The value of this token will be the actual name of the run mode used. The run mode can be optional, as noted below. Example:     /foo/:rm? If no run mode is found, it will default to using the \*(C`start_mode()\*(C', just like invoking CGI::Application directly. Both of these URLs would end up dispatching to the start mode associated with /foo:     /foo/     /foo</p>
  </dd>

</dl>

  </dd>
  <dt>
    optional-variable
  </dt>
  <dd>
    <p>Any token which begins with a colon (\*(C`:\*(C') and ends with a question mark (&lt;?&gt;) is considered optional. If the rest of the \s-1URL\s0 matches the rest of the rule, then it doesn't matter whether it contains this token or not. It's best to only include optional-variable tokens at the end of your rule. In the rule     &apos;date/:year/:month?/:day?&apos; \*(C`:month?\*(C' and \*(C`:day?\*(C' are optional-variable tokens. Just like with variable tokens, optional-variable tokens' values can also be retrieved by the application, if they existed in the \s-1URL\s0.     if( defined $self-&gt;param(&apos;month&apos;) ) {         ...     }</p>
  </dd>
  <dt>
    wildcard
  </dt>
  <dd>
    <p>The wildcard token \*(L"*\*(R" allows for partial matches. The token \s-1MUST\s0 appear at the end of the rule.   &apos;posts/list/*&apos; By default, the \*(C`dispatch_url_remainder\*(C' param is set to the remainder of the \s-1URL\s0 matched by the *. The name of the param can be changed by setting \*(L"*\*(R" argument in the \*(L"\s-1ARG\s0 \s-1LIST\s0\*(R".   &apos;posts/list/*&apos; =&gt; { &apos;*&apos; =&gt; &apos;post_list_filter&apos; }</p>
  </dd>
  <dt>
    method
  </dt>
  <dd>
    <p>You can also dispatch based on \s-1HTTP\s0 method. This is similar to using auto_rest but offers more fine grained control. You include the method (case insensitive) at the end of the rule and enclose it in square brackets.   &apos;:app/news[post]&apos;   =&gt; { rm =&gt; &apos;add_news&apos;    },   &apos;:app/news[get]&apos;    =&gt; { rm =&gt; &apos;news&apos;        },   &apos;:app/news[delete]&apos; =&gt; { rm =&gt; &apos;delete_news&apos; },</p>
  </dd>

</dl>
<p>The main reason that we don't use regular expressions for dispatch rules is that regular expressions provide no mechanism for named back references, like variable tokens do.</p>
<h3>\s-1ARG\s0 \s-1LIST\s0</h3>
<p>Each rule can have an accompanying arg-list. This arg list can contain special arguments that override something set higher up in dispatch for this particular \s-1URL\s0, or just have additional args passed available in \*(C`$self-&gt;param()\*(C'</p><p>For instance, if you want to override prefix for a specific rule, then you can do so.</p><p>    &apos;admin/:app/:rm&apos; =&gt; { prefix =&gt; &apos;MyApp::Admin&apos; },</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Path Parsing</h2>
        <div class="sectioncontent">
<p>This section will describe how the application module and run mode are determined from the path if no \*(L"\s-1DISPATCH\s0 \s-1TABLE\s0\*(R" is present, and what options you have to customize the process.  The value for the path to be parsed is retrieved from \*(C`$env-&gt;{PATH_INFO}\*(C'.</p><h3>Getting the module name</h3>
<p>To get the name of the application module the path is split on backslahes (\*(C`/\*(C').  The second element of the returned list (the first is empty) is used to create the application module. So if we have a path of</p><p>    /module_name/mode1</p><p>then the string 'module_name' is used. This is passed through the translate_module_name method. Then if there is a \*(C`prefix\*(C' (and there should always be a prefix) it is added to the beginning of this new module name with a double colon \*(C`::\*(C' separating the two.</p><p>If you don't like the exact way that this is done, don't fret you do have a couple of options.  First, you can specify a \*(L"\s-1DISPATCH\s0 \s-1TABLE\s0\*(R" which is much more powerful and flexible (in fact this default behavior is actually implemented internally with a dispatch table). Or if you want something a little simpler, you can simply subclass and extend the translate_module_name method.</p>
<h3>Getting the run mode</h3>
<p>Just like the module name is retrieved from splitting the path on slashes, so is the run mode. Only instead of using the second element of the resulting list, we use the third as the run mode. So, using the same example, if we have a path of</p><p>    /module_name/mode2</p><p>Then the string 'mode2' is used as the run mode.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Exception Handling</h2>
        <div class="sectioncontent">
<p>A CGI::Application object can throw an exception up to \*(C`CGI::Application::Dispatch::PSGI\*(C' if no \*(C`error_mode()\*(C' is implemented or if the error_mode itself throws an exception. In these cases we generally return a generic \*(L"500\*(R" response, and log some details for the developer with a warning.</p><p>However, we will check to see if the exception thrown is an HTTP::Exception object. If that's the case, we will rethrow it, and you can handle it yourself using something like Plack::Middleware::HTTPExceptions.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MISC NOTES</h2>
        <div class="sectioncontent">
<ul>
<li><p>\s-1CGI\s0 query strings \s-1CGI\s0 query strings are unaffected by the use of \*(C`PATH_INFO\*(C' to obtain the module name and run mode.  This means that any other modules you use to get access to you query argument (ie, \s-1CGI\s0, Apache::Request) should not be affected. But, since the run mode may be determined by CGI::Application::Dispatch::PSGI having a query argument named 'rm' will be ignored by your application module.</p></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CLEAN URLS WITH MOD_REWRITE</h2>
        <div class="sectioncontent">
<p>With a dispatch script, you can fairly clean \s-1URLS\s0 like this:</p><p> /cgi-bin/dispatch.cgi/module_name/run_mode</p><p>However, including \*(L"/cgi-bin/dispatch.cgi\*(R" in ever \s-1URL\s0 doesn't add any value to the \s-1URL\s0, so it's nice to remove it. This is easily done if you are using the Apache web server with \*(C`mod_rewrite\*(C' available. Adding the following to a \*(C`.htaccess\*(C' file would allow you to simply use:</p><p> /module_name/run_mode</p><p>If you have problems with mod_rewrite, turn on debugging to see exactly what's happening:</p><p> RewriteLog /home/project/logs/alpha-rewrite.log  RewriteLogLevel 9</p><h3>mod_rewrite related code in the dispatch script.</h3>
<p>This seemed necessary to put in the dispatch script to make mod_rewrite happy. Perhaps it's specific to using \*(C`RewriteBase\*(C'.</p><p>  # mod_rewrite alters the PATH_INFO by turning it into a file system path,   # so we repair it.   $ENV{PATH_INFO} =~ s/^$ENV{DOCUMENT_ROOT}// if defined $ENV{PATH_INFO};</p>
<h3>Simple Apache Example</h3>
<p>  RewriteEngine On</p><p>  # You may want to change the base if you are using the dispatcher within a   # specific directory.   RewriteBase /</p><p>  # If an actual file or directory is requested, serve directly   RewriteCond %{REQUEST_FILENAME} !-f   RewriteCond %{REQUEST_FILENAME} !-d</p><p>  # Otherwise, pass everything through to the dispatcher   RewriteRule ^(.*)$ /cgi-bin/dispatch.cgi/$1 [L,QSA] Here is a more complex example that dispatches \*(L"/\*(R", which would otherwise be treated as a directory, and also supports multiple developer directories, so \*(C`/~mark\*(C' has its own separate dispatching system beneath it.</p><p>Note that order matters here! The Location block for \*(L"/\*(R" needs to come before the user blocks.</p><p>  &lt;Location /&gt;     RewriteEngine On     RewriteBase /</p><p>    # Run "/" through the dispatcher     RewriteRule ^home/project/www/$ /cgi-bin/dispatch.cgi [L,QSA]</p><p>    # Don&apos;t apply this rule to the users sub directories.     RewriteCond %{REQUEST_URI} !^/~.*$     # If an actual file or directory is requested, serve directly     RewriteCond %{REQUEST_FILENAME} !-f     RewriteCond %{REQUEST_FILENAME} !-d     # Otherwise, pass everything through to the dispatcher     RewriteRule ^(.*)$ /cgi-bin/dispatch.cgi/$1 [L,QSA]   &lt;/Location&gt;</p><p>  &lt;Location /~mark&gt;     RewriteEngine On     RewriteBase /~mark</p><p>    # Run "/" through the dispatcher     RewriteRule ^/home/mark/www/$ /~mark/cgi-bin/dispatch.cgi [L,QSA]</p><p>    # Otherwise, if an actual file or directory is requested, serve directly     RewriteCond %{REQUEST_FILENAME} !-f     RewriteCond %{REQUEST_FILENAME} !-d</p><p>    # Otherwise, pass everything through to the dispatcher     RewriteRule ^(.*)$ /~mark/cgi-bin/dispatch.cgi/$1 [L,QSA]</p><p>    # These examples may also be helpful, but are unrelated to dispatching.     SetEnv DEVMODE mark     SetEnv PERL5LIB /home/mark/perllib:/home/mark/config     ErrorDocument 404 /~mark/errdocs/404.html     ErrorDocument 500 /~mark/errdocs/500.html   &lt;/Location&gt;</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SUBCLASSING</h2>
        <div class="sectioncontent">
<p>While Dispatch tries to be flexible, it won't be able to do everything that people want. Hopefully we've made it flexible enough so that if it doesn't do <em>The Right Thing</em> you can easily subclass it.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p>Mark Stosberg &lt;mark@summersault.com&gt;</p><p>Heavily based on CGI::Application::Dispatch, written by Michael Peters &lt;mpeters@plusthree.com&gt; and others</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COMMUNITY</h2>
        <div class="sectioncontent">
<p>This module is a part of the larger CGI::Application community. If you have questions or comments about this module then please join us on the cgiapp mailing list by sending a blank message to \*(L"cgiapp-subscribe@lists.erlbaum.net\*(R". There is also a community wiki located at http://www.cgi-app.org/ &lt;http://www.cgi-app.org/&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SOURCE CODE REPOSITORY</h2>
        <div class="sectioncontent">
<p>A public source code repository for this project is hosted here:</p><p>https://github.com/markstos/CGI\*(--Application--Dispatch</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SECURITY</h2>
        <div class="sectioncontent">
<p>Since C::A::Dispatch::PSGI will dynamically choose which modules to use as the content generators, it may give someone the ability to execute random modules on your system if those modules can be found in you path. Of course those modules would have to behave like CGI::Application based modules, but that still opens up the door more than most want. This should only be a problem if you don't use a prefix. By using this option you are only allowing Dispatch to pick from a namespace of modules to run.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Backwards Compatibility</h2>
        <div class="sectioncontent">
<p>Versions 0.2 and earlier of this module injected the \*(L"as_psgi\*(R" method into CGI::Application::Dispatch, creating a syntax like this:</p><p>   ### in your dispatch.psgi:    use Your::Application::Dispatch;    use CGI::Application::Dispatch::PSGI;    Your::Application::Dispatch-&gt;as_psgi;</p><p>   ### In Your::Application::Dispatch;    use base &apos;CGI::Application::Dispatch::PSGI&apos;;</p><p>In the current design, the \*(C`as_pgsi\*(C' method is directly in this module, so a couple of lines of code need to be changed:</p><p>   ### in your dispatch.psgi:    use Your::Application::Dispatch;    Your::Application::Dispatch-&gt;as_psgi;</p><p>   ### In Your::Application::Dispatch;    use base &apos;CGI::Application::Dispatch::PSGI&apos;;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Differences with CGI::Application::Dispatch</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <em>dispatch()</em>
  </dt>
  <dd>
    <p>Use \*(C`as_psgi()\*(C' instead. Note that the \*(C`error_document\*(C' key is not supported here. Use the Plack::Middleware::ErrorDocument or another \s-1PSGI\s0 solution instead.</p>
  </dd>
  <dt>
    <em>dispatch_path()</em>
  </dt>
  <dd>
    <p>The <em>dispatch_path()</em> method is not supported. The alternative is to reference \*(C`$env-&gt;{PATH_INFO}\*(C' which is available per the \s-1PSGI\s0 spec.</p>
  </dd>
  <dt>
    <em>handler()</em>
  </dt>
  <dd>
    <p>This provided an Apache-specific handler. Other \s-1PSGI\s0 components like Plack::Handler::Apache2 provide Apache handlers now instead.</p>
  </dd>
  <dt>
    <em>_http_method()</em>
  </dt>
  <dd>
    <p>This method has been eliminated. Check \*(C`$env-&gt;{REQUEST_METHOD}\*(C' directly instead.</p>
  </dd>
  <dt>
    <em>_parse_path()</em>
  </dt>
  <dd>
    <p>The private <em>_parse_path()</em> method now accepts an additional argument, the \s-1PSGI\s0 $env hash.</p>
  </dd>
  <dt>
    <em>_run_app()</em>
  </dt>
  <dd>
    <p>The private <em>_run_app()</em> method now accepts an additional argument, the \s-1PSGI\s0 $env hash.</p>
  </dd>
  <dt>
    <em>_r()</em>
  </dt>
  <dd>
    <p>This method has been eliminated. It does not apply in \s-1PSGI\s0.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO CGI::Application::Dispatch::PSGI&hellip;</h2>
        <div class="sectioncontent">
<p>CGI::Application, Apache::Dispatch</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT & LICENSE</h2>
        <div class="sectioncontent">
<p>Copyright Michael Peters and Mark Stosberg 2008-2010, all rights reserved.</p><p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="CGI::Application::Dispatch.3pm.html"><span aria-hidden="true">&larr;</span> CGI::Application::Dispatch.3pm: Dispatch requests to cgi::application based objects</a></li>
   <li class="next"><a href="CGI::Application::Dispatch::Regexp.3pm.html">CGI::Application::Dispatch::Regexp.3pm: Dispatch requests to cgi::application based objects using regular expressions <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

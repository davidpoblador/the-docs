<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SoDB: The sodb class keeps track of internal global data.  this class collects various methods for initializing, setting and accessing common global data from the coin library.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The sodb class keeps track of internal global data.  this class collects various methods for initializing, setting and accessing common global data from the coin library.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="SoDB (3) manual">
  <meta name="twitter:description" content="The sodb class keeps track of internal global data.  this class collects various methods for initializing, setting and accessing common global data from the coin library.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcoin80-doc-SoDB-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/SoDB.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="SoDB (3) manual" />
  <meta property="og:description" content="The sodb class keeps track of internal global data.  this class collects various methods for initializing, setting and accessing common global data from the coin library." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcoin80-doc-SoDB-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">SoDB<small> (3)</small></h1>
        <p class="lead">The sodb class keeps track of internal global data.  this class collects various methods for initializing, setting and accessing common global data from the coin library.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoDB.3.html">
      <span itemprop="name">SoDB: The sodb class keeps track of internal global data.  this class collects various methods for initializing, setting and accessing common global data from the coin library.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcoin80-doc/">
      <span itemprop="name">libcoin80-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/SoDB.3.html">
      <span itemprop="name">SoDB: The sodb class keeps track of internal global data.  this class collects various methods for initializing, setting and accessing common global data from the coin library.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;Inventor/SoDB.h&gt;</p><h3>Public Types</h3>
<p>typedef SbBool <strong>ProgressCallbackType</strong> (const <strong>SbName</strong> &itemid, float fraction, SbBool interruptible, void *userdata)</p>
<h3>Static Public Member Functions</h3>
<p>static void <strong>init</strong> (void)</p><p>static void <strong>finish</strong> (void)</p><p>static void <strong>cleanup</strong> (void)</p><p>static const char * <strong>getVersion</strong> (void)</p><p>static SbBool <strong>read</strong> (<strong>SoInput</strong> *input, <strong>SoPath</strong> *&path)</p><p>static SbBool <strong>read</strong> (<strong>SoInput</strong> *input, <strong>SoBase</strong> *&base)</p><p>static SbBool <strong>read</strong> (<strong>SoInput</strong> *input, <strong>SoNode</strong> *&rootnode)</p><p>static <strong>SoSeparator</strong> * <strong>readAll</strong> (<strong>SoInput</strong> *input)</p><p>static <strong>SoVRMLGroup</strong> * <strong>readAllVRML</strong> (<strong>SoInput</strong> *input)</p><p>static SbBool <strong>isValidHeader</strong> (const char *teststring)</p><p>static SbBool <strong>registerHeader</strong> (const <strong>SbString</strong> &headerstring, SbBool isbinary, float ivversion, SoDBHeaderCB *precallback, SoDBHeaderCB *postcallback, void *userdata=NULL)</p><p>static SbBool <strong>getHeaderData</strong> (const <strong>SbString</strong> &headerstring, SbBool &isbinary, float &ivversion, SoDBHeaderCB *&precallback, SoDBHeaderCB *&postcallback, void *&userdata, SbBool substringok=FALSE)</p><p>static int <strong>getNumHeaders</strong> (void)</p><p>static <strong>SbString</strong> <strong>getHeaderString</strong> (const int i)</p><p>static <strong>SoField</strong> * <strong>createGlobalField</strong> (const <strong>SbName</strong> &name, <strong>SoType</strong> type)</p><p>static <strong>SoField</strong> * <strong>getGlobalField</strong> (const <strong>SbName</strong> &name)</p><p>static void <strong>renameGlobalField</strong> (const <strong>SbName</strong> &from, const <strong>SbName</strong> &to)</p><p>static void <strong>setRealTimeInterval</strong> (const <strong>SbTime</strong> &interval)</p><p>static const <strong>SbTime</strong> & <strong>getRealTimeInterval</strong> (void)</p><p>static void <strong>enableRealTimeSensor</strong> (SbBool on)</p><p>static <strong>SoSensorManager</strong> * <strong>getSensorManager</strong> (void)</p><p>static void <strong>setDelaySensorTimeout</strong> (const <strong>SbTime</strong> &t)</p><p>static const <strong>SbTime</strong> & <strong>getDelaySensorTimeout</strong> (void)</p><p>static int <strong>doSelect</strong> (int nfds, void *readfds, void *writefds, void *exceptfds, struct timeval *usertimeout)</p><p>static void <strong>addConverter</strong> (<strong>SoType</strong> from, <strong>SoType</strong> to, <strong>SoType</strong> converter)</p><p>static <strong>SoType</strong> <strong>getConverter</strong> (<strong>SoType</strong> from, <strong>SoType</strong> to)</p><p>static SbBool <strong>isInitialized</strong> (void)</p><p>static void <strong>startNotify</strong> (void)</p><p>static SbBool <strong>isNotifying</strong> (void)</p><p>static void <strong>endNotify</strong> (void)</p><p>static void <strong>addProgressCallback</strong> (<strong>ProgressCallbackType</strong> *func, void *userdata)</p><p>static void <strong>removeProgressCallback</strong> (<strong>ProgressCallbackType</strong> *func, void *userdata)</p><p>static SbBool <strong>isMultiThread</strong> (void)</p><p>static void <strong>readlock</strong> (void)</p><p>static void <strong>readunlock</strong> (void)</p><p>static void <strong>writelock</strong> (void)</p><p>static void <strong>writeunlock</strong> (void)</p><p>static void <strong>createRoute</strong> (<strong>SoNode</strong> *from, const char *eventout, <strong>SoNode</strong> *to, const char *eventin)</p><p>static void <strong>removeRoute</strong> (<strong>SoNode</strong> *from, const char *eventout, <strong>SoNode</strong> *to, const char *eventin)</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>The <strong>SoDB</strong> class keeps track of internal global data.</p><p>This class collects various methods for initializing, setting and accessing common global data from the Coin library.</p><p>All methods on <strong>SoDB</strong> are static.</p><p>Make sure you call <strong>SoDB::init()</strong> (either directly or indirectly through the <strong>init()</strong> method of the GUI glue library) before you use any of the other Coin classes.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Typedef Documentation</h2>
        <div class="sectioncontent">
<h3>SbBool SoDB::ProgressCallbackType</h3>
<p>Client code progress callback function must be static functions of this type.</p><p>The <em>itemid</em> argument is a unique text identifier which says what is being processed (use this for any GUI progress bar informational text), and <em>fraction</em> is a value in the range [0, 1] which indicates how far the process has got. If the task is successfully aborted, the callback will be invoked a last time with <em>fraction</em> set to -1.0.</p><p>The return value is an abort flag indication from the client code. Note that the process that is being run can only be aborted if the <em>interruptible</em> flag is set.</p><p>See <strong>SoDB::addProgressCallback()</strong> for full documentation of how the progress notification mechanism works.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>void SoDB::init (void)\fC [static]\fP</h3>
<p>Initialize the Coin system. This needs to be done as the first thing before you start using the library, or you'll probably see an early crash.</p>
<h3>void SoDB::finish (void)\fC [static]\fP</h3>
<p>Invoke this method as the last call of the application code, to trigger a clean-up of all static resources used by the Coin library.</p><p>This is usually not necessary for stand-alone executable applications, as the operating system will take care of cleaning up after the process as it exits.</p><p>It may be necessary to invoke this method to avoid leaks for 'special' execution environments, though, like if the Coin library is used as e.g. a browser plug-in, or some other type of component which can be started, shut down and restarted multiple times.</p><p><strong>Since:</strong></p><p>Coin 2.4</p><p>TGS Inventor 5.0</p>
<h3>void SoDB::cleanup (void)\fC [static]\fP</h3>
<p>This method was renamed from Coin version 2.4 onwards, to <strong>SoDB::finish()</strong>. Consider this name for the method obsolete.</p><p><strong>Since:</strong></p><p>Coin 2.0</p>
<h3>const char * SoDB::getVersion (void)\fC [static]\fP</h3>
<p>Returns a text string containing the name of the library and version information.</p>
<h3>SbBool SoDB::read (\fBSoInput\fP *in, \fBSoPath\fP *&path)\fC [static]\fP</h3>
<p>Instantiates and reads an <strong>SoPath</strong> object from <em>in</em> and returns a pointer to it in <em>path</em>.</p><p>The reference count of the <strong>SoPath</strong> object will initially be zero.</p><p>Returns FALSE on error. Returns TRUE with <em>path</em> equal to <em>NULL</em> if we hit end of file instead of a new path specification in the file.</p>
<h3>SbBool SoDB::read (\fBSoInput\fP *in, \fBSoBase\fP *&base)\fC [static]\fP</h3>
<p>Instantiates and reads an object of type <strong>SoBase</strong> from <em>in</em> and returns a pointer to it in <em>base</em>. <em>base</em> will be NULL<em> on return if we hit end of file.</em></p><p>The reference count of the base object will initially be zero.</p><p>Returns FALSE on error.</p>
<h3>SbBool SoDB::read (\fBSoInput\fP *in, \fBSoNode\fP *&rootnode)\fC [static]\fP</h3>
<p>Instantiates and reads an object of type <strong>SoNode</strong> from <em>in</em> and returns a pointer to it in <em>rootnode</em>.</p><p>The reference count of the node will initially be zero.</p><p>Returns FALSE on error. Returns TRUE with <em>rootnode</em> equal to NULL<em> if we hit end of file instead of a new node specification in the file.</em></p>
<h3>\fBSoSeparator\fP * SoDB::readAll (\fBSoInput\fP *in)\fC [static]\fP</h3>
<p>Reads all graphs from <em>in</em> and returns them under an <strong>SoSeparator</strong> node. If the file contains only a single graph under an <strong>SoSeparator</strong> node (which is the most common way of constructing and exporting scene graphs), no <em>extra</em> <strong>SoSeparator</strong> root node will be made, but the returned root node will be the top-most node from the file.</p><p>The reference count of the root separator returned from this method will be zero. Other nodes in the returned scene graph will have reference counts according to the number of parent-child relationships, as usual.</p><p>The common layout for how to load, work with and then finally destruct and return memory resources of scenegraphs usually goes like this:</p>
<pre>
// [snip]
SoInput in;
if (!in.openFile(filename)) { <strong>exit</strong>(1); }

SoSeparator * root = SoDB::readAll(&in);
if (!root) { <strong>exit</strong>(1); }

// root-node returned from SoDB::readAll() has initial zero
// ref-count, so reference it before we start using it to
// avoid premature destruction.
root-&gt;ref();

// [do your thing here -- attach the scene to a viewer or whatever]

// Bring ref-count of root-node back to zero to cause the
// destruction of the scene.
root-&gt;unref();
// (Upon self-destructing, the root-node will also de-reference
// it's children nodes, so they also self-destruct, and so on
// recursively down the scenegraph hierarchy until the complete
// scenegraph has self-destructed and thereby returned all
// memory resources it was using.)
</pre>
<p>Returns NULL on any error.</p><p>Tip: a common operation to do after importing a scene graph is to pick out the memory pointers to one or more of the imported nodes for further handling. This can be accomplished by using either the <strong>SoNode::getByName()</strong> function (which is the easier approach) or by using an instance of the <strong>SoSearchAction</strong> class (which is the more complex but also more flexible approach).</p>
<h3>\fBSoVRMLGroup\fP * SoDB::readAllVRML (\fBSoInput\fP *in)\fC [static]\fP</h3>
<p>Same as <strong>SoDB::readAll()</strong>, except it return an <strong>SoVRMLGroup</strong> instead of an <strong>SoSeparator</strong>.</p><p><strong>See also:</strong></p><p><strong>SoDB::readAll()</strong></p><p><strong>Since:</strong></p><p>Coin 2.0</p>
<h3>SbBool SoDB::isValidHeader (const char *teststring)\fC [static]\fP</h3>
<p>Check if <em>testString</em> is a valid file format header identifier string.</p><p><strong>See also:</strong></p><p><strong>getHeaderData()</strong>, <strong>registerHeader()</strong></p>
<h3>SbBool SoDB::registerHeader (const \fBSbString\fP &headerstring, SbBoolisbinary, floativversion, SoDBHeaderCB *precallback, SoDBHeaderCB *postcallback, void *userdata = \fCNULL\fP)\fC [static]\fP</h3>
<p>Register a header string which should be recognized by <strong>SoInput</strong> upon file import. This is a convenient way for library users to register their own VRML or Coin derived file formats.</p><p>Set <em>isbinary</em> to TRUE<em> if the file should be read as binary data, and set </em><em>ivversion</em><em> to indicate which Coin library version is needed to read the file.</em></p><p>Callbacks <em>precallback</em> and <em>postcallback</em> will be called before and after importing the custom format.</p><p>If <em>headerstring</em> can not be accepted as a valid file format header for Coin files, FALSE<em> will be returned. A valid header </em><em>must</em><em> start with a '#' character, and not be more than 80 characters long.</em></p><p><strong>See also:</strong></p><p><strong>getHeaderData()</strong></p>
<h3>SbBool SoDB::getHeaderData (const \fBSbString\fP &headerstring, SbBool &isbinary, float &ivversion, SoDBHeaderCB *&precallback, SoDBHeaderCB *&postcallback, void *&userdata, SbBoolsubstringok = \fCFALSE\fP)\fC [static]\fP</h3>
<p>Returns the settings for the given <em>headerstring</em>, if <em>headerstring</em> is a valid header.</p><p>If <em>substringok</em> is TRUE<em>, ignore trailing characters in </em><em>headerstring</em><em> when checking for validity.</em></p><p>If no valid header string by this name is found, FALSE is returned, otherwise TRUE will be returned, and the other input arguments will be set to their respective values.</p><p><strong>See also:</strong></p><p><strong>isValidHeader()</strong>, <strong>registerHeader()</strong></p>
<h3>int SoDB::getNumHeaders (void)\fC [static]\fP</h3>
<p>Returns number of registered file headers.</p><p><strong>See also:</strong></p><p><strong>getHeaderString()</strong></p>
<h3>\fBSbString\fP SoDB::getHeaderString (const inti)\fC [static]\fP</h3>
<p>Returns the identifier header string of index <em>i</em>.</p><p><strong>See also:</strong></p><p><strong>getNumHeaders()</strong>, <strong>getHeaderData()</strong></p>
<h3>\fBSoField\fP * SoDB::createGlobalField (const \fBSbName\fP &name, \fBSoType\fPtype)\fC [static]\fP</h3>
<p>Create a new global field by the given <em>type</em>, and identified in subsequent accesses to <strong>getGlobalField()</strong> by <em>name</em>. If a global field by the name and type already exists, returns a pointer to it. If a global field with the same name but a different type exists, returns NULL<em>.</em></p><p>A global field can be deallocated by calling <strong>SoDB::renameGlobalField()</strong>, with the second argument set to an empty string.</p><p><strong>See also:</strong></p><p><strong>getGlobalField()</strong>, <strong>renameGlobalField()</strong></p>
<h3>\fBSoField\fP * SoDB::getGlobalField (const \fBSbName\fP &name)\fC [static]\fP</h3>
<p>If there exist a global field with the given <em>name</em>, return a pointer to it. If there is no field with this name, return NULL<em>.</em></p><p>Of particular interest is the realTime global field set up by the library on initialization. This field is used as a source field to all the autonomous animation objects within the library, like for instance the <strong>SoTimeCounter</strong> engine or the <strong>SoRotor</strong> node.</p><p>If you want to control the speed of 'action' of a scene with animating / moving components (for instance for doing fixed frame-time snapshots for generating a movie), grab the global field named 'realTime' and use it in the manner depicted in the class documentation of the <strong>SoOffscreenRenderer</strong> class.</p><p><strong>See also:</strong></p><p><strong>createGlobalField()</strong>, <strong>renameGlobalField()</strong></p>
<h3>void SoDB::renameGlobalField (const \fBSbName\fP &from, const \fBSbName\fP &to)\fC [static]\fP</h3>
<p>Rename a global field. If <em>to</em> is an empty name, the <em>from</em> field gets deleted. If another global field already goes by the name <em>to</em>, that field will get deleted before the rename operation.</p><p><strong>See also:</strong></p><p><strong>getGlobalField()</strong>, <strong>createGlobalField()</strong></p>
<h3>void SoDB::setRealTimeInterval (const \fBSbTime\fP &interval)\fC [static]\fP</h3>
<p>Set the time interval between updates for the realTime global field to <em>interval</em>. Default value is 1/12 s.</p><p>The low update rate is due to historical reasons, to be compatible with application code written for SGI Inventor.</p><p>Setting the interval to a zero time will disable automatic updates of the realTime field.</p><p><strong>See also:</strong></p><p><strong>getRealTimeInterval()</strong>, <strong>getGlobalField()</strong></p>
<h3>const \fBSbTime\fP & SoDB::getRealTimeInterval (void)\fC [static]\fP</h3>
<p>Returns the current trigger interval for the global <em>realTime</em> <strong>SbTime</strong> field.</p><p><strong>See also:</strong></p><p><strong>setRealTimeInterval()</strong>, <strong>getGlobalField()</strong></p>
<h3>void SoDB::enableRealTimeSensor (SbBoolon)\fC [static]\fP</h3>
<p>Turn on or off the realtime sensor.</p><p>The most common use for turning the realtime sensor off is to control the realTime global field from the user application. This is for instance handy when you want to take screen snapshots at fixed intervals. See the class documentation of <strong>SoOffscreenRenderer</strong> for further information.</p><p><strong>See also:</strong></p><p><strong>setRealTimeInterval()</strong>, <strong>getGlobalField()</strong></p>
<h3>\fBSoSensorManager\fP * SoDB::getSensorManager (void)\fC [static]\fP</h3>
<p>Returns a pointer to the global sensor manager. The sensor manager keeps track of the sensor queues.</p>
<h3>void SoDB::setDelaySensorTimeout (const \fBSbTime\fP &t)\fC [static]\fP</h3>
<p>This is just a wrapper for the method in <strong>SoSensorManager</strong> by the same name.</p><p><strong>See also:</strong></p><p><strong>getDelaySensorTimeout()</strong>, <strong>SoSensorManager</strong></p>
<h3>const \fBSbTime\fP & SoDB::getDelaySensorTimeout (void)\fC [static]\fP</h3>
<p>This is just a wrapper for the method in <strong>SoSensorManager</strong> by the same name.</p><p><strong>See also:</strong></p><p><strong>setDelaySensorTimeout()</strong>, <strong>SoSensorManager</strong></p>
<h3>int SoDB::doSelect (intnfds, void *readfds, void *writefds, void *exceptfds, struct timeval *usertimeout)\fC [static]\fP</h3>
<p>NOTE: THIS METHOD IS OBSOLETED. DON'T USE IT.</p><p>This is a wrapper around the POSIX select() call. It is provided so you can do synchronous I/O while Coin continues to handle sensor events, rendering, etc. The parameters are the same as for select(), so check your system documentation on how to use them.</p><p>The void* arguments must be valid pointers to fd_set structures. We've changed this from the original SGI Inventor API to avoid messing up the header file with system-specific includes.</p><p>NOTE: THIS METHOD IS OBSOLETED. DON'T USE IT.</p>
<h3>void SoDB::addConverter (\fBSoType\fPfrom, \fBSoType\fPto, \fBSoType\fPconverter)\fC [static]\fP</h3>
<p>Notify <strong>SoDB</strong> that there exists a way to convert data from the <em>from</em> <strong>SoField</strong> type to the <em>to</em> <strong>SoField</strong> type, by connecting them with an instance of the <em>converter</em> <strong>SoFieldConverter</strong> type.</p><p>By doing this, <strong>SoDB::getConverter()</strong> will later be able to automatically return the type of the correct conversion class when requested.</p><p>Coin internally provides conversion between most field types, so application programmers should usually not need to use this function. The exception is if you are writing your own field type classes, and want to be able to connect them to the internal field types (or other extensions field types).</p><p><strong>See also:</strong></p><p>createConverter(), <strong>SoFieldConverter</strong></p>
<h3>\fBSoType\fP SoDB::getConverter (\fBSoType\fPfrom, \fBSoType\fPto)\fC [static]\fP</h3>
<p>Return the type of an <strong>SoFieldConverter</strong> class which is able to convert data between fields of type <em>from</em> to the data field(s) of field type <em>to</em>.</p><p>If no conversion between the given field types is possible, returns <strong>SoType::badType()</strong>.</p><p><strong>See also:</strong></p><p><strong>addConverter()</strong></p>
<h3>SbBool SoDB::isInitialized (void)\fC [static]\fP</h3>
<p>Returns TRUE if <strong>init()</strong> has been called.</p><p><strong>See also:</strong></p><p><strong>init()</strong></p>
<h3>void SoDB::startNotify (void)\fC [static]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>SbBool SoDB::isNotifying (void)\fC [static]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>void SoDB::endNotify (void)\fC [static]\fP</h3>
<p><em>This API member is considered internal to the library, as it is not likely to be of interest to the application programmer.</em></p>
<h3>void SoDB::addProgressCallback (\fBProgressCallbackType\fP *func, void *userdata)\fC [static]\fP</h3>
<p>The concept behind progress information in Coin is that any internal process which may take a long time to complete (like e.g. file import for huge scenes) can pass on progress information by calling back to a progress callback set up by the code of the client application.</p><p>The client's progress callback's function signature must match the <strong>SoDB::ProgressCallbackType</strong>.</p><p>The mechanism works by enforcing that all progress notification from within Coin must</p>
<dl class='dl-vertical'>
  <dt>
    1.
  </dt>
  <dd>
    <p>Use a unique text id to identify the 'progress-informing' process (e.g. 'File import' for <strong>SoDB::readAll()</strong> / <strong>SoInput</strong> file reading, 'File export' for <strong>SoOutput</strong> / <strong>SoWriteAction</strong>, etc). This is the <em>itemid</em> name passed on to the progress callback.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    2.
  </dt>
  <dd>
    <p>The first invocation of the user callback will be done with an exact 0.0 <em>fraction</em> value.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    3.
  </dt>
  <dd>
    <p>The last invocation will be done with an exact 1.0 fraction value.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    4.
  </dt>
  <dd>
    <p>An exception to the last point is that if the process is aborted, a final invocation with a -1.0 fraction value will be made.</p>
  </dd>

</dl>
<p>One important thing to note about the mechanism is that processes with progress callbacks can be running within <em>other</em> processes using the progress callback functionality. Progress information will then have to be considered to be 'stacked', and client code must be aware of and treat this properly.</p><p>This function is an extension for Coin, and it is not available in the original SGI Open Inventor v2.1 API.</p><p><strong>Since:</strong></p><p>Coin 2.2</p>
<h3>void SoDB::removeProgressCallback (\fBProgressCallbackType\fP *func, void *userdata)\fC [static]\fP</h3>
<p>Removes a progress callback function, which will no longer be invoked.</p>
<h3>SbBool SoDB::isMultiThread (void)\fC [static]\fP</h3>
<p>Returns TRUE if this is a thread safe version of Coin (i.e. it was configured and built with --enable-threadsafe).</p>
<h3>void SoDB::readlock (void)\fC [static]\fP</h3>
<p>Places a read lock on the global <strong>SoDB</strong> mutex. This can be used to synchronize between threads that are reading/writing Coin scene graphs.</p><p>If you call this function, you must make sure that you also call <strong>SoDB::readunlock()</strong>. If you fail to do this, you might experience that your application locks up.</p><p>All Coin actions has a read-lock on the global <strong>SoDB</strong> mutex while traversing the scene graph.</p><p><strong>See also:</strong></p><p><strong>SoDB::readunlock()</strong>, <strong>SoDB::writelock()</strong></p><p><strong>Since:</strong></p><p>Coin 2.3</p><p>TGS Inventor 3.0</p>
<h3>void SoDB::readunlock (void)\fC [static]\fP</h3>
<p>Unlocks the read lock on the global <strong>SoDB</strong> mutex.</p><p><strong>See also:</strong></p><p><strong>SoDB::readlock()</strong></p><p><strong>Since:</strong></p><p>Coin 2.3</p><p>TGS Inventor 3.0</p>
<h3>void SoDB::writelock (void)\fC [static]\fP</h3>
<p>Places a write lock on the global <strong>SoDB</strong> mutex. This can be used to prevent that the scene graph is read or traversed while you modify the scene graph.</p><p>If you call this function, you must make sure that you also call <strong>SoDB::writeunlock()</strong>. If you fail to do this, you might experience that your application locks up.</p><p><strong>See also:</strong></p><p><strong>SoDB::readlock()</strong></p><p><strong>Since:</strong></p><p>Coin 2.3</p><p>TGS Inventor 3.0</p>
<h3>void SoDB::writeunlock (void)\fC [static]\fP</h3>
<p>Unlocks the write lock on the global <strong>SoDB</strong> mutex.</p><p><strong>See also:</strong></p><p><strong>SoDB::writelock()</strong></p><p><strong>Since:</strong></p><p>Coin 2.3</p><p>TGS Inventor 3.0</p>
<h3>void SoDB::createRoute (\fBSoNode\fP *fromnode, const char *eventout, \fBSoNode\fP *tonode, const char *eventin)\fC [static]\fP</h3>
<p>Create a connection from one VRML97 node field to another.</p><p>('Routes' are what field-to-field connections are called for the VRML97 standard.)</p><p>Connections made in this manner will be persistent upon file export.</p><p><strong>See also:</strong></p><p><strong>SoDB::removeRoute()</strong></p><p>SoField::connectFrom(SoField*)</p><p><strong>Since:</strong></p><p>Coin 2.4</p><p>TGS Inventor 2.6</p>
<h3>void SoDB::removeRoute (\fBSoNode\fP *fromnode, const char *eventout, \fBSoNode\fP *tonode, const char *eventin)\fC [static]\fP</h3>
<p>Removes a field-to-field connection.</p><p><strong>See also:</strong></p><p><strong>SoDB::createRoute()</strong></p><p><strong>SoField::disconnect(SoField*)</strong></p><p><strong>Since:</strong></p><p>Coin 2.4</p><p>TGS Inventor 2.6</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for Coin from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="SoCylinderDetail.3.html"><span aria-hidden="true">&larr;</span> SoCylinderDetail.3: The socylinderdetail class contains information about the parts of a socylinder shape.  instances of this class are used for storing information about hit points on cylinder geometry after pick operations, and for storing information returned to tessellation callbacks.</a></li>
   <li class="next"><a href="SoDB.h.3.html">SoDB.h.3: Sodb.h - <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

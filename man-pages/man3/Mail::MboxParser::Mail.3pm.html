<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Mail::MboxParser::Mail: Provide mail-objects and methods upon</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Provide mail-objects and methods upon">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Mail::MboxParser::Mail (3pm) manual">
  <meta name="twitter:description" content="Provide mail-objects and methods upon">
  <meta name="twitter:image" content="https://www.carta.tech/images/libmail-mboxparser-perl-Mail::MboxParser::Mail-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Mail::MboxParser::Mail.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Mail::MboxParser::Mail (3pm) manual" />
  <meta property="og:description" content="Provide mail-objects and methods upon" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libmail-mboxparser-perl-Mail::MboxParser::Mail-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Mail::MboxParser::Mail<small> (3pm)</small></h1>
        <p class="lead">Provide mail-objects and methods upon</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Mail::MboxParser::Mail.3pm.html">
      <span itemprop="name">Mail::MboxParser::Mail: Provide mail-objects and methods upon</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libmail-mboxparser-perl/">
      <span itemprop="name">libmail-mboxparser-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Mail::MboxParser::Mail.3pm.html">
      <span itemprop="name">Mail::MboxParser::Mail: Provide mail-objects and methods upon</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>See Mail::MboxParser for an outline on usage. Examples however are also provided in this manpage further below.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>Mail::MboxParser::Mail objects are usually not created directly though, in theory, they could be. A description of the provided methods can be found in Mail::MboxParser.</p><p>However, go on reading if you want to use methods from MIME::Entity and learn about overloading.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <strong>new(header, body)</strong>
  </dt>
  <dd>
    <p>This is usually not called directly but instead by \*(C`get_messages()\*(C'. You could however create a mail-object manually providing the header and body each as either one string or as an array-ref representing the lines. Here is a common scenario: Retrieving mails from a remote POP-server using Mail::POP3Client and directly feeding each mail to \*(C`Mail::MboxParser::Mail-&gt;new\*(C':</p>
<pre>
    use Mail::POP3Client;
    use Mail::MboxParser::Mail;

    my $pop = new Mail::POP3Client (...);

    for my $i (1 .. $pop-&gt;Count) {
        my $msg = Mail::MboxParser::Mail-&gt;new( [ $pop-&gt;Head($i) ],
                                               [ $pop-&gt;Body($i) ] );
        $msg-&gt;store_all_attachments( path =&gt; &apos;/home/user/dump&apos; );
    }
</pre>
<p>The above effectively behaves like an attachment-only retriever.</p>
  </dd>
  <dt>
    <strong>header</strong>
  </dt>
  <dd>
    <p>Returns the mail-header as a hash-ref with header-fields as keys. All keys are turned to lower-case, so $header{Subject} has to be written as $header{subject}. If a header-field occurs more than once in the header, the value of the key is an array_ref. Example:     my $field = $msg-&gt;header-&gt;{field};     print $field-&gt;[0]; # first occurance of &apos;field&apos;     print $field-&gt;[1]; # second one     ...</p>
  </dd>
  <dt>
    <strong>from_line</strong>
  </dt>
  <dd>
    <p>Returns the \*(L"From \*(R"-line of the message.</p>
  </dd>
  <dt>
    <strong>trace</strong>
  </dt>
  <dd>
    <p>This method returns the \*(L"Received: \*(R"-lines of the message as a list.</p>
  </dd>
  <dt>
    <strong>body</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>body(n)</strong>
  </dt>
  <dd>
    <p>Returns a Mail::MboxParser::Mail::Body object. For methods upon that see further below. When called with the argument n, the n-th body of the message is retrieved. That is, the body of the n-th entity. Sets \*(C`$mail-&gt;error\*(C' if something went wrong.</p>
  </dd>
  <dt>
    <strong>find_body</strong>
  </dt>
  <dd>
    <p>This will return an index number that represents what Mail::MboxParser::Mail considers to be the actual (main)-body of an email. This is useful if you don't know about the structure of a message but want to retrieve the message's signature for instance:         $signature = $msg-&gt;body($msg-&gt;find_body)-&gt;signature; Changes are good that find_body does what it is supposed to do.</p>
  </dd>
  <dt>
    <strong>make_convertable</strong>
  </dt>
  <dd>
    <p>Returns a Mail::MboxParser::Mail::Convertable object. For details on what you can do with it, read Mail::MboxParser::Mail::Convertable.</p>
  </dd>
  <dt>
    <strong>get_field(headerfield)</strong>
  </dt>
  <dd>
    <p>Returns the specified raw field from the message header, that is: the fieldname is not stripped off nor is any decoding done. Returns multiple lines as needed if the field is \*(L"Received\*(R" or another multi-line field.  Not case sensitive. \*(C`get_field()\*(C' always returns one string regardless of how many times the field occured in the header. Multiple occurances are separated by a newline and multiple whitespaces squeezed to one. That means you can process each occurance of the field thusly:     for my $field ( split /&#92;n/, $msg-&gt;get_field(&apos;received&apos;) ) {         # do something with $field     } Sets \*(C`$mail-&gt;error\*(C' if the field was not found in which case \*(C`get_field()\*(C' returns \*(C`undef\*(C'.</p>
  </dd>
  <dt>
    <strong>from</strong>
  </dt>
  <dd>
    <p>Returns a hash-ref with the two fields 'name' and 'email'. Returns \*(C`undef\*(C' if empty. The name-field does not necessarily contain a value either. Example:         print $mail-&gt;from-&gt;{email}; On behalf of suggestions I received from users, <em>from()</em> tries to be smart when 'name'is empty and 'email' has the form 'first.name@host.com'. In this case, 'name' is set to \*(L"First Name\*(R".</p>
  </dd>
  <dt>
    <strong>to</strong>
  </dt>
  <dd>
    <p>Returns an array of hash-references of all to-fields in the mail-header. Fields are the same as those of \*(C`$mail-&gt;from\*(C'. Example:         for my $recipient ($mail-&gt;to) {                 print $recipient-&gt;{name} || "&lt;no name&gt;", "&#92;n";                 print $recipient-&gt;{email};         } The same 'name'-smartness applies here as described under \*(C`from()\*(C'.</p>
  </dd>
  <dt>
    <strong>cc</strong>
  </dt>
  <dd>
    <p>Identical with <em>to()</em> but returning the hash-refed \*(L"Cc: \*(R"-line. The same 'name'-smartness applies here as described under \*(C`from()\*(C'.</p>
  </dd>
  <dt>
    <strong>id</strong>
  </dt>
  <dd>
    <p>Returns the message-id of a message cutting off the leading and trailing '&lt;' and '&gt;' respectively.</p>
  </dd>
  <dt>
    <strong>num_entities</strong>
  </dt>
  <dd>
    <p>Returns the number of MIME-entities. That is, the number of sub-entitities actually. If 0 is returned and you think this is wrong, check \*(C`$mail-&gt;log\*(C'.</p>
  </dd>
  <dt>
    <strong>get_entities</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>get_entities(n)</strong>
  </dt>
  <dd>
    <p>Either returns an array of all MIME::Entity objects or one particular if called with a number. If no entity whatsoever could be found, an empty list is returned. \*(C`$mail-&gt;log\*(C' instantly called after get_entities will give you some information of what internally may have failed. If set, this will be an error raised by MIME::Entity but you don't need to worry about it at all. It's just for the record.</p>
  </dd>
  <dt>
    <strong>get_entity_body(n)</strong>
  </dt>
  <dd>
    <p>Returns the body of the n-th MIME::Entity as a single string, undef otherwise in which case you could check \*(C`$mail-&gt;error\*(C'.</p>
  </dd>
  <dt>
    <strong>store_entity_body(n, handle =&gt; \s-1FILEHANDLE\s0)</strong>
  </dt>
  <dd>
    <p>Stores the stringified body of n-th entity to the specified filehandle. That's basically the same as:  my $body = $mail-&gt;<strong>get_entity_body</strong>(0);  print FILEHANDLE $body; and could be shortened to this:  $mail-&gt;store_entity_body(0, handle =&gt; &#92;*FILEHANDLE); It returns a true value on success and undef on failure. In this case, examine the value of $mail-&gt;error since the entity you specified with 'n' might not exist.</p>
  </dd>
  <dt>
    <strong>store_attachment(n)</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>store_attachment(n, options)</strong>
  </dt>
  <dd>
    <p>It is really just a call to store_entity_body but it will take care that the n-th entity really is a saveable attachment. That is, it wont save anything with a MIME-type of, say, text/html or so. Unless further 'options' have been given, an attachment (if found) is stored into the current directory under the recommended filename given in the MIME-header. 'options' are specified in key/value pairs:     key:       | value:        | description:     ===========|================|===============================     path       | relative or    | directory to store attachment     (".")      | absolute       |                | path           |     -----------|----------------|-------------------------------     encode     | encoding       | Some platforms store files                | suitable for   | in e.g. UTF-8. Specify the                | Encode::encode | appropriate encoding here and                |                | and the filename will be en-                |                | coded accordingly.     -----------|----------------|-------------------------------     store_only | a compiled     | store only files whose file                | regex-pattern  | names match this pattern     -----------|----------------|-------------------------------     code       | an anonym      | first argument will be the                | subroutine     | $msg-object, second one the                |                | index-number of the current                |                | MIME-part                |                | should return a filename for                |                | the attachment     -----------|----------------|-------------------------------     prefix     | prefix for     | all filenames are prefixed                | filenames      | with this value     -----------|----------------|-------------------------------     args       | additional     | this array-ref will be passed                | arguments as   | on to the &apos;code&apos; subroutine                | array-ref      | as a dereferenced array Example:         $msg-&gt;store_attachment(1,                             path =&gt; "/home/ethan/",                             code =&gt; sub {                                         my ($msg, $n, @args) = @_;                                         return $msg-&gt;id."+$n";                                         },                             args =&gt; [ "Foo", "Bar" ]); This will save the attachment found in the second entity under the name that consists of the message-ID and the appendix \*(L"+1\*(R" since the above code works on the second entity (that is, with index = 1). 'args' isn't used in this example but should demonstrate how to pass additional arguments. Inside the 'code' sub, @args equals (\*(L"Foo\*(R", \*(L"Bar\*(R"). If 'path' does not exist, it will try to create the directory for you. You can specify to save only files matching a certain pattern. To do that, use the store-only switch:     $msg-&gt;store_attachment(1, path       =&gt; "/home/ethan/",                               store_only =&gt; qr/&#92;.jpg$/i); The above will only save files that end on '.jpg', not case-sensitive. You could also use a non-compiled pattern if you want, but that would make for instance case-insensitive matching a little cumbersome:     store_only =&gt; &apos;(?i)&#92;.jpg$&apos; If you are working on a platform that requires a certain encoding for filenames on disk, you can use the 'encode' option. This becomes necessary for instance on Mac \s-1OS\s0 X which internally is \s-1UTF-8\s0 based. If the filename contains 8bit characters (like the German umlauts or French accented characters as in 'e\*''), storing the attachment under a non-encoded name will most likely fail. In this case, use something like this:     $msg-&gt;store_attachment(1, path =&gt; &apos;/tmp&apos;, encode =&gt; &apos;utf-8&apos;); See Encode::Supported for a list of encodings that you may use. Returns the filename under which the attachment has been saved. undef is returned in case the entity did not contain a saveable attachment, there was no such entity at all or there was something wrong with the 'path' you specified. Check \*(C`$mail-&gt;error\*(C' to find out which of these possibilities apply.</p>
  </dd>
  <dt>
    <strong>store_all_attachments</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>store_all_attachments(options)</strong>
  </dt>
  <dd>
    <p>Walks through an entire mail and stores all apparent attachments. 'options' are exactly the same as in \*(C`store_attachment()\*(C' with the same behaviour if no options are given. Returns a list of files that have been successfully saved and an empty list if no attachment could be extracted. \*(C`$mail-&gt;error\*(C' will tell you possible failures and a possible explanation for that.</p>
  </dd>
  <dt>
    <strong>get_attachments</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>get_attachments(file)</strong>
  </dt>
  <dd>
    <p>This method returns a mapping from attachment-names (if those are saveable) to index-numbers of the MIME-part that represents this attachment. It returns a hash-reference, the file-names being the key and the index the value:     my $mapping = $msg-&gt;get_attachments;     for my $filename (keys %$mapping) {         print "$filename =&gt; $mapping-&gt;{$filename}&#92;n";     } If called with a string as argument, it tries to look up this filename. If it can't be found, undef is returned. In this case you also should have an error-message patiently awaiting you in the return value of \*(C`$mail-&gt;error\*(C'. Even though it looks tempting, don't do the following:     # BAD!</p><p>    for my $file (qw/file1.ext file2.ext file3.ext file4.ext/) {         print "$file is in message ", $msg-&gt;id, "&#92;n"             if defined $msg-&gt;get_attachments($file);     } The reason is that \*(C`get_attachments()\*(C' is currently <strong>not</strong> optimized to cache the filename mapping. So, each time you call it on (even the same) message, it will scan it from beginning to end. Better would be:     # GOOD!</p><p>    my $mapping = $msg-&gt;get_attachments;     for my $file (qw/file1.ext file2.ext file3.ext file4.ext/) {         print "$file is in message ", $msg-&gt;id, "&#92;n"             if exists $mapping-&gt;{$file};     }</p>
  </dd>
  <dt>
    <strong>as_string</strong>
  </dt>
  <dd>
    <p>Returns the message as one string. This is the method that string overloading depends on, so these two are the same:     print $msg;</p><p>    print $msg-&gt;as_string;</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXTERNAL METHODS</h2>
        <div class="sectioncontent">
<p>Mail::MboxParser::Mail implements an autoloader that will do the appropriate type-casts for you if you invoke methods from external modules. This, however, currently only works with MIME::Entity. Support for other modules will follow. Example:</p><p>        my $mb = Mail::MboxParser-&gt;new("/home/user/Mail/received");         for my $msg ($mb-&gt;get_messages) {                 print $msg-&gt;effective_type, "&#92;n";         }</p><p>\*(C`effective_type()\*(C' is not implemented by Mail::MboxParser::Mail and thus the corresponding method of MIME::Entity is automatically called.</p><p>To learn about what methods might be useful for you, you should read the \*(L"Access\*(R"-part of the section \*(L"\s-1PUBLIC\s0 \s-1INTERFACE\s0\*(R" in the MIME::Entity manpage. It may become handy if you have mails with a lot of MIME-parts and you not just want to handle binary-attachments but any kind of MIME-data.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">OVERLOADING</h2>
        <div class="sectioncontent">
<p>Mail::MboxParser::Mail overloads the \*(L" \*(R" operator. Overloading operators is a fancy feature of Perl and some other languages (\*(C+ for instance) which will change the behaviour of an object when one of those overloaded operators is applied onto it. Here you get the stringified mail when you write $mail while otherwise you'd get the stringified reference: \*(C`Mail::MboxParser::Mail=HASH(...)\*(C'.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">VERSION</h2>
        <div class="sectioncontent">
<p>This is version 0.55.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR AND COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Tassilo von Parseval &lt;tassilo.von.parseval@rwth-aachen.de&gt;</p><p>Copyright (c)  2001-2005 Tassilo von Parseval. This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Mail::MboxParser::Mail&hellip;</h2>
        <div class="sectioncontent">
<p>MIME::Entity</p><p>Mail::MboxParser, Mail::MboxParser::Mail::Body, Mail::MboxParser::Mail::Convertable</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Mail::MboxParser::Base.3pm.html"><span aria-hidden="true">&larr;</span> Mail::MboxParser::Base.3pm: Base clase for all other classes</a></li>
   <li class="next"><a href="Mail::MboxParser::Mail::Body.3pm.html">Mail::MboxParser::Mail::Body.3pm: Rudimentary mail-body object <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>libppm: Functions to support portable pixmap (ppm) programs</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Functions to support portable pixmap (ppm) programs">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="libppm (3) manual">
  <meta name="twitter:description" content="Functions to support portable pixmap (ppm) programs">
  <meta name="twitter:image" content="https://www.carta.tech/images/libnetpbm10-dev-libppm-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/libnetpbm10-dev-libppm.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="libppm (3) manual" />
  <meta property="og:description" content="Functions to support portable pixmap (ppm) programs" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libnetpbm10-dev-libppm-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">libppm<small> (3)</small></h1>
        <p class="lead">Functions to support portable pixmap (ppm) programs</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/libppm.3.html">
      <span itemprop="name">libppm: Functions to support portable pixmap (ppm) programs</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libnetpbm10-dev/">
      <span itemprop="name">libnetpbm10-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/libppm.3.html">
      <span itemprop="name">libppm: Functions to support portable pixmap (ppm) programs</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p><strong>#include &lt;ppm.h&gt;</strong></p><p><strong>void ppm_init(</strong> <strong>int *</strong><em>argcP</em><strong>,</strong> <strong>char *</strong><em>argv</em><strong>[]</strong> <strong>);</strong></p><p><strong>pixel ** ppm_allocarray(</strong> <strong>int </strong><em>cols</em><strong>,</strong> <strong>int </strong><em>rows</em><strong> );</strong></p><p><strong>pixel * ppm_allocrow(</strong> <strong>int </strong><em>cols</em><strong> );</strong></p><p><strong>void ppm_freearray(</strong> <strong>pixel **</strong><em>pixels</em><strong>,</strong> <strong>int </strong><em>rows</em><strong> );</strong></p><p><strong>void ppm_freerow(</strong> <strong>pixel *</strong><em>pixelrow</em><strong>);</strong></p><p><strong>void ppm_readppminit(</strong> <strong>FILE *</strong><em>fp</em><strong>,</strong> <strong>int *</strong><em>colsP</em><strong>,</strong> <strong>int *</strong><em>rowsP</em><strong>,</strong> <strong>pixval *</strong><em>maxvalP</em><strong>,</strong> <strong>int *</strong><em>formatP</em><strong> );</strong></p><p><strong>void ppm_readppmrow(</strong> <strong>FILE *</strong><em>fp</em><strong>,</strong> <strong>pixel *</strong><em>pixelrow</em><strong>,</strong> <strong>int </strong><em>cols</em><strong>,</strong> <strong>pixval </strong><em>maxval</em><strong>,</strong> <strong>int </strong><em>format</em><strong> );</strong></p><p><strong>pixel ** ppm_readppm(</strong> <strong>FILE *</strong><em>fp</em><strong>,</strong> <strong>int *</strong><em>colsP</em><strong>,</strong> <strong>int *</strong><em>rowsP</em><strong>,</strong> <strong>pixvalP *</strong><em>maxvalP</em><strong> );</strong></p><p><strong>void ppm_writeppminit(</strong> <strong>FILE *  fp ,</strong> <strong>int </strong><em>cols</em><strong>,</strong> <strong>int </strong><em>rows</em><strong>,</strong> <strong>pixval </strong><em>maxval</em><strong>,</strong> <strong>int </strong><em>forceplain</em><strong> );</strong></p><p><strong>void ppm_writeppmrow(</strong> <strong>FILE *</strong><em>fp</em><strong>,</strong> <strong>pixel *</strong><em>pixelrow</em><strong>,</strong> <strong>int </strong><em>cols</em><strong>,</strong> <strong>pixval </strong><em>maxval</em><strong>,</strong> <strong>int </strong><em>forceplain</em><strong> );</strong></p><p><strong>void ppm_writeppm(</strong> <strong>FILE *</strong><em>fp</em><strong>,</strong> <strong>pixel ** </strong><em>pixels</em><strong>,</strong> <strong>int </strong><em>cols</em><strong>,</strong> <strong>int </strong><em>rows</em><strong>,</strong> <strong>pixval </strong><em>maxval</em><strong>,</strong> <strong>int </strong><em>forceplain</em><strong> );</strong></p><p><strong>void ppm_writeppm(</strong> <strong>FILE *</strong><em>fp</em><strong>,</strong> <strong>pixel **</strong><em>pixels</em><strong>,</strong> <strong>int </strong><em>cols</em><strong>,</strong> <strong>int </strong><em>rows</em><strong>,</strong> <strong>pixval </strong><em>maxval</em><strong>,</strong> <strong>int </strong><em>forceplain</em><strong> );</strong></p><p><strong>void ppm_nextimage(</strong> <strong>FILE *</strong><em>file</em><strong>,</strong> <strong>int * const </strong><em>eofP</em><strong>);</strong></p><p><strong>void ppm_check(</strong> <strong>FILE * </strong><em>file</em><strong>,</strong> <strong>const enum pm_check_type </strong><em>check_type</em><strong>,</strong> <strong>const int </strong><em>format</em><strong>,</strong> <strong>const int </strong><em>cols</em><strong>,</strong> <strong>const int </strong><em>rows</em><strong>,</strong> <strong>const int </strong><em>maxval</em><strong>,</strong></p><p><strong>enum pm_check_code * const </strong><em>retval</em><strong>);</strong></p><p><strong>typedef ... pixel;</strong> <strong>typedef ... pixval;</strong></p><p><strong>#define PPM_MAXMAXVAL ...</strong></p><p><strong>#define PPM_OVERALLMAXVAL ...</strong></p><p><strong>#define PPM_FORMAT ...</strong></p><p><strong>#define RPPM_FORMAT ...</strong></p><p><strong>#define PPM_TYPE PPM_FORMAT</strong></p><p><strong>#define</strong> <strong>PPM_FORMAT_TYPE(</strong><em>format</em><strong>)</strong> <strong>...</strong></p><p><strong>extern pixval ppm_pbmmaxval;</strong></p><p><strong>pixval PPM_GETR( pixel </strong><em>p</em><strong>)</strong> <strong>pixval PPM_GETG( pixel </strong><em>p</em><strong>)</strong> <strong>pixval PPM_GETB( pixel </strong><em>p</em><strong>)</strong></p><p><strong>void PPM_ASSIGN( pixel </strong><em>p</em><strong>, </strong> <strong>pixval </strong><em>red</em><strong>, pixval </strong><em>grn</em><strong>, pixval </strong><em>blu</em><strong>)</strong></p><p><strong>int PPM_EQUAL( pixel </strong><em>p</em><strong>, pixel </strong><em>q</em><strong>)</strong></p><p><strong>void PPM_DEPTH( pixel </strong><em>newp</em><strong>, pixel </strong><em>p</em><strong>, </strong> <strong>pixval </strong><em>oldmaxval</em><strong>, pixval </strong><em>newmaxval</em><strong>)</strong></p><p><strong>float PPM_LUMIN( pixel </strong><em>p</em><strong>)</strong></p><p><strong>float PPM_CHROM_R( pixel </strong><em>p</em><strong>)</strong></p><p><strong>float PPM_CHROM_B( pixel </strong><em>p</em><strong>)</strong></p><p><strong>pixel ppm_parsecolor( char *</strong><em>colorname</em><strong>, pixval </strong><em>maxval</em><strong>)</strong></p><p><strong>char * ppm_colorname( pixel *</strong><em>colorP</em><strong>, pixval </strong><em>maxval</em><strong>, int </strong><em>hexok</em><strong>)</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<h3>TYPES AND CONSTANTS</h3>
<p>Each <strong>pixel</strong> contains three <strong>pixval</strong>s, each of which should contain only the values between <strong>0</strong> and <strong>PPM_MAXMAXVAL</strong>. <strong>ppm_pbmmaxval</strong> is the maxval used when a PPM program reads a PBM file. Normally it is 1; however, for some programs, a larger value gives better results.</p>
<h3>MANIPULATING PIXELS</h3>
<p>The macros <strong>PPM_GETR</strong>, <strong>PPM_GETG</strong>, and <strong>PPM_GETB</strong> retrieve the red, green, or blue sample, respectively, from the given pixel.</p><p>The <strong>PPM_ASSIGN</strong> macro assigns the given values to the red, green, and blue samples of the given pixel.</p><p>The <strong>PPM_EQUAL</strong> macro tests two pixels for equality.</p><p>The <strong>PPM_DEPTH</strong> macro scales the colors of pixel <em>p</em> according the old and new maxvals and assigns the new values to <em>newp</em>. It is intended to make writing ppmtowhatever easier.</p><p>The <strong>PPM_LUMIN</strong>, <strong>PPM_CHROM_R</strong>, and <strong>PPM_CHROM_B</strong>, macros determine the luminance, red chrominance, and blue chrominance, respectively, of the pixel <em>p</em>. The scale of all these values is the same as the scale of the input samples (i.e. 0 to maxval for luminance, -maxval/2 to maxval/2 for chrominance).</p><p>Note that the macros do it by floating point multiplication.  If you are computing these values over an entire image, it may be significantly faster to do it with multiplication tables instead.  Compute all the possible products once up front, then for each pixel, just look up the products in the tables.</p>
<h3>INITIALIZATION</h3>
<p>All PPM programs must call <strong>ppm_init()</strong> just after invocation, before they process their arguments.</p>
<h3>MEMORY MANAGEMENT</h3>
<p><strong>ppm_allocarray()</strong> allocates an array of pixels.</p><p><strong>ppm_allocrow()</strong> allocates a row of the given number of pixels.</p><p><strong>ppm_freearray()</strong> frees the array allocated with <strong>ppm_allocarray()</strong> containing the given number of rows.</p><p><strong>ppm_freerow()</strong> frees a row of pixelss allocated with <strong>ppm_allocrow()</strong>.</p>
<h3>READING FILES</h3>
<p>If a function in this section is called on a PBM or PGM format file, it translates the PBM or PGM file into a PPM file on the fly and functions as if it were called on the equivalent PPM file.  The <em>format</em> value returned by <strong>ppm_readppminit()</strong> is, however, not translated.  It represents the actual format of the PBM or PGM file.</p><p><strong>ppm_readppminit()</strong> reads the header of a PPM file, returning all the information from the header and leaving the file positioned just after the header.</p><p><strong>ppm_readppmrow()</strong> reads a row of pixels into the <em>pixelrow</em> array. <em>format</em>, <em>cols</em>, and <em>maxval</em> are the values returned by <strong>ppm_readppminit()</strong>.</p><p><strong>ppm_readppm()</strong> reads an entire PPM image into memory, returning the allocated array as its return value and returning the information from the header as <em>rows</em>, <em>cols</em>, and <em>maxval</em>. This function combines <strong>ppm_readppminit()</strong>, <strong>ppm_allocarray()</strong>, and <strong>ppm_readppmrow()</strong>.</p>
<h3>WRITING FILES</h3>
<p><strong>ppm_writeppminit()</strong> writes the header for a PPM file and leaves it positioned just after the header.</p><p><em>forceplain</em> is a logical value that tells <strong>ppm_writeppminit()</strong> to write a header for a plain PPM format file, as opposed to a raw PPM format file.</p><p><strong>ppm_writeppmrow()</strong> writes the row <em>pixelrow</em> to a PPM file.  For meaningful results, <em>cols</em>, <em>maxval</em>, and <em>forceplain</em> must be the same as was used with <strong>ppm_writeppminit()</strong>.</p><p><strong>ppm_writeppm()</strong> write the header and all data for a PPM image.  This function combines <strong>ppm_writeppminit()</strong> and <strong>ppm_writeppmrow()</strong>.</p>
<h3>MISCELLANEOUS</h3>
<p><strong>ppm_nextimage()</strong> positions a PPM input file to the next image in it (so that a subsequent <strong>ppm_readppminit()</strong> reads its header).</p><p><strong>ppm_nextimage()</strong> is analogous to <strong>pbm_nextimage()</strong>, but works on PPM, PGM, and PBM files.</p><p><strong>ppm_check()</strong> checks for the common file integrity error where the file is the wrong size to contain all the image data.</p><p><strong>ppm_check()</strong> is analogous to <strong>pbm_check()</strong>, but works on PPM, PGM, and PBM files.</p>
<h3>COLOR NAMES</h3>
<p><strong>ppm_parsecolor()</strong> Interprets a color specification and returns a pixel of the color that it indicates.  The color specification is ASCII text, in one of three formats:  1) a name, as defined in the system's X11-style color names file (e.g. <strong>rgb.txt</strong>). 2) an X11-style hexadecimal triple: #rgb, #rrggbb, #rrrgggbbb, or #rrrrggggbbbb. 3) A triplet of decimal floating point numbers from 0.0 to 1.0, representing red, green, and blue intensities respectively, separated by commas.  E.g. "1.0, 0.5, .25".</p><p>If the color specification does not conform to any of these formats, including the case that it is a name, but is not in the rgb.txt database, <strong>ppm_parsecolor()</strong> exits the program via <strong>pm_error()</strong>.</p><p><strong>ppm_colorname()</strong> Returns a string that describes the color of the given pixel. If an X11-style color names file (e.g. <strong>rgb.txt</strong>) is available and the color appears in it, <strong>ppm_colorname()</strong> returns the name of the color from the file. If the color does not appear in a X11-style color file and <em>hexok</em> is true, <strong>ppm_colorname()</strong> returns a hexadecimal color specification triple (#rrggbb). If a X11-style color file is available but the color does not appear in it and <em>hexok</em> is false, <strong>ppm_colorname()</strong> returns the name of the closest matching color in the color file. Finally, if their is no X11-style color file available and <em>hexok</em> is false, <strong>ppm_colorname()</strong> fails and exits the program with an error message.</p><p>The string returned is in static libppm library storage which is overwritten by every call to <strong>ppm_colorname()</strong>.</p>
<h3>COLOR INDEXING</h3>
<p>Sometimes in processing images, you want to associate a value with a particular color.  Most often, that's because you're generating a color mapped graphics format.  In a color mapped graphics format, the raster contains small numbers, and the file contains a color map that tells what color each of those small numbers refers to.  If your image has only 256 colors, but each color takes 24 bits to describe, this can make your output file much smaller than a straightforward RGB raster would.</p><p>So, continuing the above example, say you have a <strong>pixel</strong> value for chartreuse and in your output file and you are going to represent chartreuse by the number 12.  You need a data structure that allows your program quickly to find out that the number for a chartreuse <strong>pixel</strong> is 12. Netpbm's color indexing data types and functions give you that.</p><p><strong>colorhash_table</strong> is a C data type that associates an integer with each of an arbitrary number of colors.  It is a hash table, so it uses far less space than an array indexed by the color's RGB values would.</p><p>The problem with a <strong>colorhash_table</strong> is that you can only look things up in it.  You can't find out what colors are in it.  So Netpbm has another data type for representing the same information, the poorly but historically named <strong>colorhist_vector</strong>. A <strong>colorhist_vector</strong> is just an array.  Each entry represents a color and contains the color's value (as a <strong>pixel</strong>) and the integer value associated with it.  The entries are filled in starting with subscript 0 and going consecutively up for the number of colors in the histogram.</p><p>(The reason the name is poor is because a color histogram is only one of many things that could be represented by it).</p><p><strong>colorhash_table ppm_alloccolorhash()</strong></p><p>This creates a <strong>colorhash_table</strong> using dynamically allocated storage.  There are no colors in it.  If there is not enough storage, it exits the program with an error message.</p><p><strong>void ppm_freecolorhash()</strong></p><p>This destroys a <strong>ppm_freecolorhash</strong> and frees all the storage associated with it.</p><p><strong>int ppm_addtocolorhash( colorhash_table cht, const pixel * const colorP,</strong> <strong>const int value)</strong></p><p>This adds the specified color to the specified <strong>colorhash_table</strong> and associates the specified value with it.</p><p>You must ensure that the color you are adding isn't already present in the <strong>colorhash_table</strong>.</p><p>There is no way to update an entry or delete an entry from a <strong>colorhash_table</strong>.</p><p><strong>int ppm_lookupcolor( const colorhash_table cht, const pixel * const colorP )</strong></p><p>This looks up the specified color in the specified <strong>colorhash_table</strong>. It returns the integer value associated with that color.</p><p>If the specified color is not in the hash table, the function returns -1.  (So if you assign the value -1 to a color, the return value is ambiguous).</p><p><strong>colorhist_vector ppm_colorhashtocolorhist( const colorhash_table cht,</strong> <strong>const int ncolors )</strong></p><p>This converts a <strong>colorhash_table</strong> to a <strong>colorhist_vector</strong>. The return value is a new <strong>colorhist_vector</strong> which you must eventually free with <strong>ppm_freecolorhist()</strong>.</p><p><strong>ncolors</strong> is the number of colors in <strong>cht</strong>. If it has more colors than that, <strong>ppm_colorhashtocolorhist</strong> does not create a <strong>colorhist_vector</strong> and returns NULL.</p><p><strong>colorhash_table ppm_colorhisttocolorhash( const colorhist_vector chv,</strong> <strong>const int ncolors )</strong></p><p>This poorly named function does <em>not</em> convert from a <strong>colorhist_vector</strong> to a <strong>colorhash_table</strong>.</p><p>It does create a <strong>colorhash_table</strong> based on a <strong>colorhist_vector</strong> input, but the integer value for a given color in the output is not the same as the integer value for that same color in the input. <strong>ppm_colorhisttocolorhash()</strong> ignores the integer values in the input.  In the output, the integer value for a color is the index in the input <strong>colorhist_vector</strong> for that color.</p><p>You can easily create a color map for an image by running <strong>ppm_computecolorhist()</strong> over the image, then <strong>ppm_colorhisttocolorhash()</strong> over the result.  Now you can use <strong>ppm_lookupcolor()</strong> to find a unique color index for any pixel in the input.</p><p>If the same color appears twice in the input, <strong>ppm_colorhisttocolorhash()</strong> exit the program with an error message.</p><p><strong>ncolors</strong> is the number of colors in <strong>chv</strong>.</p><p>The return value is a new <strong>colorhash_table</strong> which you must eventually free with <strong>ppm_freecolorhash()</strong>.</p>
<h3>COLOR HISTOGRAMS</h3>
<p>The Netpbm libraries give you functions to examine a Netpbm image and determine what colors are in it and how many pixels of each color are in it.  This information is known as a color histogram.  Netpbm uses its <strong>colorhash_table</strong> data type to represent a color histogram.</p><p><strong>colorhash_table ppm_computecolorhash( pixel ** const pixels,</strong> <strong>const int cols, const int rows, const int maxcolors, int* const colorsP )</strong></p><p>This poorly but historically named function generates a <strong>colorhash_table</strong> whose value for each color is the number of pixels in a specified image that have that color.  (I.e. a color histogram).  As a bonus, it returns the number of colors in the image.</p><p>(It's poorly named because not all <strong>colorhash_table</strong>s are color histograms, but that's all it generates).</p><p><strong>pixels</strong>, <strong>cols</strong>, and <strong>rows</strong> describe the input image.</p><p><strong>maxcolors</strong> is the maximum number of colors you want processed.  If there are more colors that that in the input image, <strong>ppm_computecolorhash()</strong> returns NULL as its return value and stops processing as soon as it discovers this.  This makes it run faster and use less memory.  One use for <strong>maxcolors</strong> is when you just want to find out whether or not the image has more than N colors and don't want to wait to generate a huge color table if so. If you don't want any limit on the number of colors, specify <strong>maxcolors</strong>=<strong>0</strong>.</p><p><strong>ppm_computecolorhash()</strong> returns the actual number of colors in the image as <strong>*colorsP</strong>, but only if it is less than or equal to <strong>maxcolors</strong>.</p><p><strong>colorhash_table ppm_computecolorhash2( FILE * const ifp,</strong> <strong>const int cols, const int rows, const pixval maxval, const int format,</strong> <strong>const int maxcolors, int* const colorsP )</strong></p><p>This is the same as <strong>ppm_computecolorhash()</strong> except that instead of feeding it an array of pixels in storage, you give it an open file stream and it reads the image from the file.  The file must be positioned after the header, at the raster.  Upon return, the file is still open, but its position is undefined.</p><p><strong>maxval</strong> and <strong>format</strong> are the values for the image (i.e. information from the file's header).</p><p><strong>colorhist_vector ppm_computecolorhist( pixel ** pixels,</strong> <strong>int cols, int rows, int maxcolors, int * colorsP )</strong></p><p>This is like <strong>ppm_computecolorhash()</strong> except that it creates a <strong>colorhist_vector</strong> instead of a <strong>colorhash_table</strong>.</p><p>If you supply a nonzero <strong>maxcolors</strong> argument, that is the maximum number of colors you expect to find in the input image.  If there are more colors than you say in the image, <strong>ppm_computecolorhist()</strong> returns a null pointer as its return value and nothing meaningful as <strong>*colorsP</strong>.</p><p>If not, the function returns the new <strong>colorhist_vector</strong> as its return value and the actual number of colors in the image as <strong>*colorsP</strong>. The returned array has space allocated for the specified number of colors regardless of how many actually exist.  The extra space is at the high end of the array and is available for your use in expanding the <strong>colorhist_vector</strong>.</p><p>If you specify <strong>maxcolors</strong>=<strong>0</strong>, there is no limit on the number of colors returned and the return array has space for 5 extra colors at the high end for your use in expanding the <strong>colorhist_vector</strong>.</p><p><strong>colorhist_vector ppm_computecolorhist2( FILE * ifp,</strong></p><p><strong>int cols, int rows, int maxcolors, pixval maxval, int format,</strong></p><p><strong>int * colorsP )</strong></p><p>This is the same as <strong>ppm_computecolorhist()</strong> except that instead of feeding it an array of pixels in storage, you give it an open file stream and it reads the image from the file.  The file must be positioned after the header, at the raster.  Upon return, the file is still open, but its position is undefined.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO libppm&hellip;</h2>
        <div class="sectioncontent">
<p><a href="../man5/pbm.5.html"><strong>pbm</strong>(5)</a>, <a href="../man5/pgm.5.html"><strong>pgm</strong>(5)</a>, <strong>libpbm</strong>(3)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Copyright (C) 1989, 1991 by Tony Hansen and Jef Poskanzer.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="libppl_c.3.html"><span aria-hidden="true">&larr;</span> libppl_c.3: The c interface of the parma polyhedra library</a></li>
   <li class="next"><a href="libnetpbm9-dev-libppm.3.html">libppm.3: Functions to support portable pixmap (ppm) programs <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

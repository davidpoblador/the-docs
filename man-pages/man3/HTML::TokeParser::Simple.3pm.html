<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>HTML::TokeParser::Simple: Easy to use "html::tokeparser" interface</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Easy to use "html::tokeparser" interface">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="HTML::TokeParser::Simple (3pm) manual">
  <meta name="twitter:description" content="Easy to use "html::tokeparser" interface">
  <meta name="twitter:image" content="https://www.carta.tech/images/libhtml-tokeparser-simple-perl-HTML::TokeParser::Simple-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/HTML::TokeParser::Simple.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="HTML::TokeParser::Simple (3pm) manual" />
  <meta property="og:description" content="Easy to use "html::tokeparser" interface" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libhtml-tokeparser-simple-perl-HTML::TokeParser::Simple-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">HTML::TokeParser::Simple<small> (3pm)</small></h1>
        <p class="lead">Easy to use "html::tokeparser" interface</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/HTML::TokeParser::Simple.3pm.html">
      <span itemprop="name">HTML::TokeParser::Simple: Easy to use "html::tokeparser" interface</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libhtml-tokeparser-simple-perl/">
      <span itemprop="name">libhtml-tokeparser-simple-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/HTML::TokeParser::Simple.3pm.html">
      <span itemprop="name">HTML::TokeParser::Simple: Easy to use "html::tokeparser" interface</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
 use HTML::TokeParser::Simple;
 my $p = HTML::TokeParser::Simple-&gt;new( $somefile );

 while ( my $token = $p-&gt;get_token ) {
     # This prints all text in an HTML doc (i.e., it strips the HTML)
     next unless $token-&gt;is_text;
     print $token-&gt;as_is;
 }
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>\*(C`HTML::TokeParser\*(C' is an excellent module that's often used for parsing \s-1HTML\s0. However, the tokens returned are not exactly intuitive to parse:</p><p> ["S",  $tag, $attr, $attrseq, $text]  ["E",  $tag, $text]  ["T",  $text, $is_data]  ["C",  $text]  ["D",  $text]  ["PI", $token0, $text]</p><p>To simplify this, \*(C`HTML::TokeParser::Simple\*(C' allows the user ask more intuitive (read: more self-documenting) questions about the tokens returned.</p><p>You can also rebuild some tags on the fly.  Frequently, the attributes associated with start tags need to be altered, added to, or deleted.  This functionality is built in.</p><p>Since this is a subclass of \*(C`HTML::TokeParser\*(C', all \*(C`HTML::TokeParser\*(C' methods are available.  To truly appreciate the power of this module, please read the documentation for \*(C`HTML::TokeParser\*(C' and \*(C`HTML::Parser\*(C'.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONTRUCTORS</h2>
        <div class="sectioncontent">
<p>The constructor for \*(C`HTML::TokeParser::Simple\*(C' can be used just like \*(C`HTML::TokeParser\*(C''s constructor:</p><p>  my $parser = HTML::TokeParser::Simple-&gt;new($filename);   # or   my $parser = HTML::TokeParser::Simple-&gt;new($filehandle);   # or   my $parser = HTML::TokeParser::Simple-&gt;new(&#92;$html_string); If you wish to be more explicit, there is a new style of constructor available.</p><p>  my $parser = HTML::TokeParser::Simple-&gt;new(file   =&gt; $filename);   # or   my $parser = HTML::TokeParser::Simple-&gt;new(handle =&gt; $filehandle);   # or   my $parser = HTML::TokeParser::Simple-&gt;new(string =&gt; $html_string);</p><p>Note that you do not have to provide a reference for the string if using the string constructor.</p><p>As a convenience, you can also attempt to fetch the \s-1HTML\s0 directly from a \s-1URL\s0.</p><p>  my $parser = HTML::TokeParser::Simple-&gt;new(url =&gt; &apos;http://some.url&apos;);</p><p>This method relies on \*(C`LWP::Simple\*(C'.  If this module is not found or the page cannot be fetched, the constructor will \*(C`croak()\*(C'.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PARSER METHODS</h2>
        <div class="sectioncontent">
<h3>get_token</h3>
<p>This method will return the next token that \*(C`HTML::TokeParser::get_token()\*(C' method would return.  However, it will be blessed into a class appropriate which represents the token type.</p>
<h3>get_tag</h3>
<p>This method will return the next token that \*(C`HTML::TokeParser::get_tag()\*(C' method would return.  However, it will be blessed into either the HTML::TokeParser::Simple::Token::Tag::Start or HTML::TokeParser::Simple::Token::Tag::End class.</p>
<h3>peek</h3>
<p>As of version 3.14, you can now \*(C`peek()\*(C' at the upcomings tokens without affecting the state of the parser.  By default, \*(C`peek()\*(C' will return the text of the next token, but specifying an integer $count will return the text of the next $count tokens.</p><p>This is useful when you're trying to debug where you are in a document.</p><p> warn $parser-&gt;<strong>peek</strong>(3); # show the next 3 tokens</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ACCESSORS</h2>
        <div class="sectioncontent">
<p>The following methods may be called on the token object which is returned, not on the parser object.</p><h3>Boolean Accessors</h3>
<p>These accessors return true or false.</p><ul>
<li><p>\*(C`is_tag([$tag])\*(C' Use this to determine if you have any tag.  An optional \*(L"tag type\*(R" may be passed.  This will allow you to match if it's a <em>particular</em> tag.  The supplied tag is case-insensitive.  if ( $token-&gt;is_tag ) { ... } Optionally, you may pass a regular expression as an argument.</p></li><li><p>\*(C`is_start_tag([$tag])\*(C' Use this to determine if you have a start tag.  An optional \*(L"tag type\*(R" may be passed.  This will allow you to match if it's a <em>particular</em> start tag.  The supplied tag is case-insensitive.  if ( $token-&gt;is_start_tag ) { ... }  if ( $token-&gt;is_start_tag( &apos;font&apos; ) ) { ... } Optionally, you may pass a regular expression as an argument.  To match all header (h1, h2, ... h6) tags:  if ( $token-&gt;is_start_tag( qr/^h[123456]$/ ) ) { ... }</p></li><li><p>\*(C`is_end_tag([$tag])\*(C' Use this to determine if you have an end tag.  An optional \*(L"tag type\*(R" may be passed.  This will allow you to match if it's a <em>particular</em> end tag.  The supplied tag is case-insensitive. When testing for an end tag, the forward slash on the tag is optional.  while ( $token = $p-&gt;get_token ) {    if ( $token-&gt;is_end_tag( &apos;form&apos; ) ) { ... }  } Or:  while ( $token = $p-&gt;get_token ) {    if ( $token-&gt;is_end_tag( &apos;/form&apos; ) ) { ... }  } Optionally, you may pass a regular expression as an argument.</p></li><li><p>\*(C`is_text()\*(C' Use this to determine if you have text.  Note that this is <em>not</em> to be confused with the \*(C`return_text\*(C' (<em>deprecated</em>) method described below! \*(C`is_text\*(C' will identify text that the user typically sees display in the Web browser.</p></li><li><p>\*(C`is_comment()\*(C' Are you still reading this?  Nobody reads \s-1POD\s0.  Don't you know you're supposed to go to \s-1CLPM\s0, ask a question that's answered in the \s-1POD\s0 and get flamed?  It's a rite of passage. Really. \*(C`is_comment\*(C' is used to identify comments.  See the HTML::Parser documentation for more information about comments.  There's more than you might think.</p></li><li><p>\*(C`is_declaration()\*(C' This will match the \s-1DTD\s0 at the top of your \s-1HTML\s0. (You <em>do</em> use \s-1DTD\s0's, don't you?)</p></li><li><p>\*(C`is_process_instruction()\*(C' Process Instructions are from \s-1XML\s0.  This is very handy if you need to parse out \s-1PHP\s0 and similar things with a parser. Currently, there appear to be some problems with process instructions.  You can override \*(C`HTML::TokeParser::Simple::Token::ProcessInstruction\*(C' if you need to.</p></li><li><p>\*(C`is_pi()\*(C' This is a shorthand for \*(C`is_process_instruction()\*(C'.</p></li>
</ul>
<h3>Data Accessors</h3>
<p>Some of these were originally \*(C`return_\*(C' methods, but that name was not only unwieldy, but also went against reasonable conventions.  The \*(C`get_\*(C' methods listed below still have \*(C`return_\*(C' methods available for backwards compatibility reasons, but they merely call their \*(C`get_\*(C' counterpart.  For example, calling \*(C`return_tag()\*(C' actually calls \*(C`get_tag()\*(C' internally.</p><ul>
<li><p>\*(C`get_tag()\*(C' Do you have a start tag or end tag?  This will return the type (lower case). Note that this is <em>not</em> the same as the \*(C`get_tag()\*(C' method on the actual parser object.</p></li><li><p>\*(C`get_attr([$attribute])\*(C' If you have a start tag, this will return a hash ref with the attribute names as keys and the values as the values. If you pass in an attribute name, it will return the value for just that attribute. Returns false if the token is not a start tag.</p></li><li><p>\*(C`get_attrseq()\*(C' For a start tag, this is an array reference with the sequence of the attributes, if any. Returns false if the token is not a start tag.</p></li><li><p>\*(C`return_text()\*(C' This method has been heavily deprecated (for a couple of years) in favor of \*(C`as_is\*(C'.  Programmers were getting confused over the difference between \*(C`is_text\*(C', \*(C`return_text\*(C', and some parser methods such as \*(C`HTML::TokeParser::get_text\*(C' and friends. Using this method still succeeds, but will now carp and <strong>will be removed</strong> in the next major release of this module.</p></li><li><p>\*(C`as_is()\*(C' This is the exact text of whatever the token is representing.</p></li><li><p>\*(C`get_token0()\*(C' For processing instructions, this will return the token found immediately after the opening tag.  Example:  For &lt;?php, \*(L"php\*(R" will be the start of the returned string. Note that process instruction handling appears to be incomplete in \*(C`HTML::TokeParser\*(C'. Returns false if the token is not a process instruction.</p></li>
</ul>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MUTATORS</h2>
        <div class="sectioncontent">
<p>The \*(C`delete_attr()\*(C' and \*(C`set_attr()\*(C' methods allow the programmer to rewrite start tag attributes on the fly.  It should be noted that bad \s-1HTML\s0 will be \*(L"corrected\*(R" by this.  Specifically, the new tag will have all attributes lower-cased with the values properly quoted.</p><p>Self-closing tags (e.g. &lt;hr /&gt;) are also handled correctly.  Some older browsers require a space prior to the final slash in a self-closed tag.  If such a space is detected in the original \s-1HTML\s0, it will be preserved.</p><p>Calling a mutator on an token type that does not support that property is a no-op.  For example:</p><p> if ($token-&gt;is_comment) {     $token-&gt;set_attr(foo =&gt; &apos;bar&apos;); # does nothing  }</p><ul>
<li><p>\*(C`delete_attr($name)\*(C' This method attempts to delete the attribute specified.  It will silently fail if called on anything other than a start tag.  The argument is case-insensitive, but must otherwise be an exact match of the attribute you are attempting to delete.  If the attribute is not found, the method will return without changing the tag.  # &lt;body bgcolor="#FFFFFF"&gt;  $token-&gt;delete_attr(&apos;bgcolor&apos;);  print $token-&gt;as_is;  # &lt;body&gt; After this method is called, if successful, the \*(C`as_is()\*(C', \*(C`get_attr()\*(C' and \*(C`get_attrseq()\*(C' methods will all return updated results.</p></li><li><p>\*(C`set_attr($name,$value)\*(C' This method will set the value of an attribute.  If the attribute is not found, then \*(C`get_attrseq()\*(C' will have the new attribute listed at the end.  # &lt;p&gt;  $token-&gt;set_attr(class =&gt; &apos;some_class&apos;);  print $token-&gt;as_is;  # &lt;p class="some_class"&gt;</p><p> # &lt;body bgcolor="#FFFFFF"&gt;  $token-&gt;set_attr(&apos;bgcolor&apos;,&apos;red&apos;);  print $token-&gt;as_is;  # &lt;body bgcolor="red"&gt; After this method is called, if successful, the \*(C`as_is()\*(C', \*(C`get_attr()\*(C' and \*(C`get_attrseq()\*(C' methods will all return updated results.</p></li><li><p>\*(C`set_attr($hashref)\*(C' Under the premise that \*(C`set_\*(C' methods should accept what their corresponding \*(C`get_\*(C' methods emit, the following works:   $tag-&gt;set_attr($tag-&gt;get_attr); Theoretically that's a no-op and for purposes of rendering \s-1HTML\s0, it should be. However, internally this calls \*(C`$tag-&gt;rewrite_tag\*(C', so see that method to understand how this may affect you. Of course, this is useless if you want to actually change the attributes, so you can do this:   my $attrs = {     class  =&gt; &apos;headline&apos;,     valign =&gt; &apos;top&apos;   };   $token-&gt;set_attr($attrs)     if $token-&gt;is_start_tag(&apos;td&apos;) &&  $token-&gt;get_attr(&apos;class&apos;) eq &apos;stories&apos;;</p></li><li><p>\*(C`rewrite_tag()\*(C' This method rewrites the tag.  The tag name and the name of all attributes will be lower-cased.  Values that are not quoted with double quotes will be.  This may be called on both start or end tags.  Note that both \*(C`set_attr()\*(C' and \*(C`delete_attr()\*(C' call this method prior to returning. If called on a token that is not a tag, it simply returns.  Regardless of how it is called, it returns the token.  # &lt;body alink=#0000ff BGCOLOR=#ffffff class=&apos;none&apos;&gt;  $token-&gt;rewrite_tag;  print $token-&gt;as_is;  # &lt;body alink="#0000ff" bgcolor="#ffffff" class="none"&gt; A quick cleanup of sloppy \s-1HTML\s0 is now the following:  my $parser = HTML::TokeParser::Simple-&gt;new( string =&gt; $ugly_html );  while (my $token = $parser-&gt;get_token) {      $token-&gt;rewrite_tag;      print $token-&gt;as_is;  }</p></li>
</ul>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">PARSER VERSUS TOKENS</h2>
        <div class="sectioncontent">
<p>The parser returns tokens that are blessed into appropriate classes.  Some people get confused and try to call parser methods on tokens and token methods on the parser.  To prevent this, \*(C`HTML::TokeParser::Simple\*(C' versions 1.4 and above now bless all tokens into appropriate token classes.  Please keep this in mind while using this module (and many thanks to PodMaster &lt;http://www.perlmonks.org/index.pl?node_id=107642&gt; for pointing out this issue to me.)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<h3>Finding comments</h3>
<p>For some strange reason, your Pointy-Haired Boss (\s-1PHB\s0) is convinced that the graphics department is making fun of him by embedding rude things about him in \s-1HTML\s0 comments.  You need to get all \s-1HTML\s0 comments from the \s-1HTML\s0.</p><p> use strict;  use HTML::TokeParser::Simple;</p><p> my @html_docs = glob( "*.html" );</p><p> open PHB, "&gt; phbreport.txt" or die "Cannot open phbreport for writing: $!";</p><p> foreach my $doc ( @html_docs ) {      print "Processing $doc&#92;n";      my $p = HTML::TokeParser::Simple-&gt;new( file =&gt; $doc );      while ( my $token = $p-&gt;get_token ) {          next unless $token-&gt;is_comment;          print PHB $token-&gt;as_is, "&#92;n";      }  }</p><p> close PHB;</p>
<h3>Stripping Comments</h3>
<p>Uh oh.  Turns out that your \s-1PHB\s0 was right for a change.  Many of the comments in the \s-1HTML\s0 weren't very polite.  Since your entire graphics department was just fired, it falls on you need to strip those comments from the \s-1HTML\s0.</p><p> use strict;  use HTML::TokeParser::Simple;</p><p> my $new_folder = &apos;no_comment/&apos;;  my @html_docs  = glob( "*.html" );</p><p> foreach my $doc ( @html_docs ) {      print "Processing $doc&#92;n";      my $new_file = "$new_folder$doc";</p><p>     open PHB, "&gt; $new_file" or die "Cannot open $new_file for writing: $!";</p><p>     my $p = HTML::TokeParser::Simple-&gt;new( $file =&gt; doc );      while ( my $token = $p-&gt;get_token ) {          next if $token-&gt;is_comment;          print PHB $token-&gt;as_is;      }      close PHB;  }</p>
<h3>Changing form tags</h3>
<p>Your company was foo.com and now is bar.com.  Unfortunately, whoever wrote your \s-1HTML\s0 decided to hardcode \*(L"http://www.foo.com/\*(R" into the \*(C`action\*(C' attribute of the form tags.  You need to change it to \*(L"http://www.bar.com/\*(R".</p><p> use strict;  use HTML::TokeParser::Simple;</p><p> my $new_folder = &apos;new_html/&apos;;  my @html_docs  = glob( "*.html" );</p><p> foreach my $doc ( @html_docs ) {      print "Processing $doc&#92;n";      my $new_file = "$new_folder$doc";</p><p>     open FILE, "&gt; $new_file" or die "Cannot open $new_file for writing: $!";</p><p>     my $p = HTML::TokeParser::Simple-&gt;new( file =&gt; $doc );      while ( my $token = $p-&gt;get_token ) {          if ( $token-&gt;is_start_tag(&apos;form&apos;) ) {              my $action = $token-&gt;get_attr(action);              $action =~ s/www&#92;.foo&#92;.com/www.bar.com/;              $token-&gt;set_attr(&apos;action&apos;, $action);          }          print FILE $token-&gt;as_is;      }      close FILE;  }</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CAVEATS</h2>
        <div class="sectioncontent">
<p>For compatibility reasons with \*(C`HTML::TokeParser\*(C', methods that return references are violating encapsulation and altering the references directly <strong>will</strong> alter the state of the object.  Subsequent calls to \*(C`rewrite_tag()\*(C' can thus have unexpected results.  Do not alter these references directly unless you are following behavior described in these docs.  In the future, certain methods such as \*(C`get_attr\*(C', \*(C`get_attrseq\*(C' and others may return a copy of the reference rather than the original reference.  This behavior has not yet been changed in order to maintain compatibility with previous versions of this module.  At the present time, your author is not aware of anyone taking advantage of this \*(L"feature,\*(R" but it's better to be safe than sorry.</p><p>Use of $HTML::Parser::VERSION which is less than 3.25 may result in incorrect behavior as older versions do not always handle \s-1XHTML\s0 correctly.  It is the programmer's responsibility to verify that the behavior of this code matches the programmer's needs.</p><p>Note that \*(C`HTML::Parser\*(C' processes text in 512 byte chunks.  This sometimes will cause strange behavior and cause text to be broken into more than one token.  You can suppress this behavior with the following command:</p><p> $p-&gt;unbroken_text( [$bool] );</p><p>See the \*(C`HTML::Parser\*(C' documentation and http://www.perlmonks.org/index.pl?node_id=230667 for more information.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUGS</h2>
        <div class="sectioncontent">
<p>There are no known bugs, but that's no guarantee.</p><p>Address bug reports and comments to: &lt;eop_divo_sitruc@yahoo.com&gt;.  When sending bug reports, please provide the version of \*(C`HTML::Parser\*(C', \*(C`HTML::TokeParser\*(C', \*(C`HTML::TokeParser::Simple\*(C', the version of Perl, and the version of the operating system you are using.</p><p>Reverse the name to email the author.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SUBCLASSING</h2>
        <div class="sectioncontent">
<p>You may wish to change the behavior of this module.  You probably do not want to subclass \*(C`HTML::TokeParser::Simple\*(C'.  Instead, you'll want to subclass one of the token classes.  \*(C`HTML::TokeParser::Simple::Token\*(C' is the base class for all tokens.  Global behavioral changes should go there.  Otherwise, see the appropriate token class for the behavior you wish to alter.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO HTML::TokeParser::Simple&hellip;</h2>
        <div class="sectioncontent">
<p>HTML::TokeParser::Simple::Token</p><p>HTML::TokeParser::Simple::Token::Tag</p><p>HTML::TokeParser::Simple::Token::Text</p><p>HTML::TokeParser::Simple::Token::Comment</p><p>HTML::TokeParser::Simple::Token::Declaration</p><p>HTML::TokeParser::Simple::Token::ProcessInstruction</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COPYRIGHT</h2>
        <div class="sectioncontent">
<p>Copyright (c) 2004 by Curtis \*(L"Ovid\*(R" Poe.  All rights reserved.  This program is free software; you may redistribute it and/or modify it under the same terms as Perl itself</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Curtis \*(L"Ovid\*(R" Poe &lt;eop_divo_sitruc@yahoo.com&gt;</p><p>Reverse the name to email the author.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="HTML::Tiny.3pm.html"><span aria-hidden="true">&larr;</span> HTML::Tiny.3pm: Lightweight, dependency free html/xml generation</a></li>
   <li class="next"><a href="HTML::TokeParser::Simple::Token.3pm.html">HTML::TokeParser::Simple::Token.3pm: Base class for "html::tokeparser::simple" tokens. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

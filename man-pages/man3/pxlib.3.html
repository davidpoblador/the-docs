<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>pxlib: Library to read and write paradox databases</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Library to read and write paradox databases">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="pxlib (3) manual">
  <meta name="twitter:description" content="Library to read and write paradox databases">
  <meta name="twitter:image" content="https://www.carta.tech/images/pxlib-dev-pxlib-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/pxlib.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="pxlib (3) manual" />
  <meta property="og:description" content="Library to read and write paradox databases" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/pxlib-dev-pxlib-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">pxlib<small> (3)</small></h1>
        <p class="lead">Library to read and write paradox databases</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/pxlib.3.html">
      <span itemprop="name">pxlib: Library to read and write paradox databases</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/pxlib-dev/">
      <span itemprop="name">pxlib-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/pxlib.3.html">
      <span itemprop="name">pxlib: Library to read and write paradox databases</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>pxlib is a library to read and write Paradox databases. It is far from being complete but should be very helpful for those working on unix and having the need to handle paradox databases, blob files, primary and secondary indexes.</p><p>pxlib is a C-library with bindings for Python and PHP. The later is part of PECL (http://pecl.php.net). This documentation will only describe the functions of the C-library, though most of what is said here can be applied to the other language bindings. The PHP extension of pxlib is documented in PEAR. The extension is called Paradox.</p><p>This library is the base for a gnumeric plugin which has been officially added to gnumeric in version 1.4.0. pxlib is also used by hk_classes which itself is the database access utilized by knoda (http://www.knoda.org).</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">GETTING STARTED</h2>
        <div class="sectioncontent">
<p>Programs which want to use pxlib will have to include the header file paradox.h and link against libpx. If the libgsf file access is to be used paradox-gsf.h has to be included instead of paradox.h. The gsf library cannot be used currently for writing because pxlib requires read access on the database as well, which is not supported by libgsf. In such a case you will have to create a temporary file first and copy it the gsf stream afterwards.</p><p>Before reading or writing a database file the library should be initialized with <strong>PX_boot</strong>(3)</strong>. It will set the locale and selects the messages in your language as defined by the environment variable LC_ALL. The library should be finalized by <strong>PX_shutdown</strong>(3)</strong>.</p><p>A Paradox database is represented by a pointer to pxdoc_t. Such an object can be created with <a href="../man3/PX_new.3.html"><strong>PX_new</strong>(3)</a></strong> and destroyed with <a href="../man3/PX_delete.3.html"><strong>PX_delete</strong>(3)</a></strong>.  You can easily handle several documents at the same time, each represented by its own pointer to pxdoc_t.</p><p>pxdoc_t is a faily large structure with various information about the paradox file. Most of the needed information is stored in a substructure called px_head. px_head is defined as the following:</p>
<pre>
typedef struct px_head pxhead_t;
struct px_head {
  char *px_tablename;
  int px_recordsize;
  char px_filetype;
  int px_fileversion;
  int px_numrecords;
  int px_theonumrecords;
  int px_numfields;
  int px_maxtablesize;
  int px_headersize;
  int px_fileblocks;
  int px_firstblock;
  int px_lastblock;
  int px_indexfieldnumber;
  int px_indexroot;
  int px_numindexlevels;
  int px_writeprotected;
  int px_doscodepage;
  int px_primarykeyfields;
  char px_modifiedflags1;
  char px_modifiedflags2;
  char px_sortorder;
  int px_autoinc;
  int px_fileupdatetime;
  char px_refintegrity;
  struct px_field *px_fields;
};

</pre>
<p>The structure is defined in paradox.h and can be accessed directly, thought it is not encouraged at all, because the structure will disappear in the future. Most header values can already be read with <a href="../man3/PX_get_value.3.html"><strong>PX_get_value</strong>(3)</a></strong> or <a href="../man3/PX_get_parameter.3.html"><strong>PX_get_parameter</strong>(3)</a></strong> and set by <a href="../man3/PX_set_value.3.html"><strong>PX_set_value</strong>(3)</a></strong> respectively <a href="../man3/PX_set_parameter.3.html"><strong>PX_set_parameter</strong>(3)</a></strong></p><p>The following example will do the basic preparation without creating nor opening a document on the disk.</p>
<pre>
...
#include &lt;paradox.h&gt;

main(int argc, char *argv[]) {
	pxdoc_t *pxdoc;

	PX_boot();
	pxdoc = PX_new();
	PX_delete(pxdoc);
	PX_shutdown();
}

</pre>
<p>In order to actually read a Paradox database from disk you will have to call</p><p><strong></strong></p><p>int PX_open_file (pxdoc_t *<em>pxdoc</em><strong>, const char *</strong><em>filename</em><strong>);</strong></p><p>or</p><p><strong></strong></p><p>int PX_open_fp (pxdoc_t *<em>pxdoc</em><strong>, FILE *</strong><em>fp</em><strong>);</strong></p><p><a href="../man3/PX_open_file.3.html"><strong>PX_open_file</strong>(3)</a></strong> will open an existing file with the given file name, while <a href="../man3/PX_open_fp.3.html"><strong>PX_open_fp</strong>(3)</a></strong> will use an already open file. Both require a pointer to pxdoc_t.</p><p>Extending the previous example with one of the former two functions to open a database is just another small step as illustrated in the next example.</p>
<pre>
...
#include &lt;paradox.h&gt;

main(int argc, char *argv[]) {
	pxdoc_t *pxdoc;

	PX_boot();
	pxdoc = PX_new();
	PX_open_file(pxdoc, "test.db");
	PX_close(pxdoc);
	PX_delete(pxdoc);
	PX_shutdown();
}

</pre>
<p>The database has to be closed with <a href="../man3/PX_close.3.html"><strong>PX_close</strong>(3)</a></strong>. <a href="../man3/PX_close.3.html"><strong>PX_close</strong>(3)</a></strong> will only close the file if it was opened by <a href="../man3/PX_open_file.3.html"><strong>PX_open_file</strong>(3)</a></strong>. <a href="../man3/PX_close.3.html"><strong>PX_close</strong>(3)</a></strong> is crucial because it also flushes unwritten blocks to disk.</p><p>There are more sophisticated functions to create the handle for the Paradox database. They are used when error handling and memory management shall be controlled by the calling application. Check the manual pages <a href="../man3/PX_new2.3.html"><strong>PX_new2</strong>(3)</a></strong> and <a href="../man3/PX_new3.3.html"><strong>PX_new3</strong>(3)</a></strong> for a detailed description or read the section about memory management and error handler below.</p><p>If you rather like to create a new Paradox database the above example must call</p><p><strong></strong></p><p>int PX_create_file (pxdoc_t *<em>pxdoc</em><strong>, pxfield_t *</strong><em>fields</em><strong>, int </strong><em>numfields</em><strong>, const char *</strong><em>filename</em><strong>, int </strong><em>type</em><strong>);</strong></p><p>instead of <a href="../man3/PX_open_file.3.html"><strong>PX_open_file</strong>(3)</a></strong>. Creating a Paradox file requires three further parameters to specify the database layout and the file type, e.g. pxfFileTypNonIndexDB. The function can be used to create both databases and primary index files. Secondary index files are not supported before version &lt;= 0.6.0 due to several bugs in pxlib. Since the format of a secondary index file is indentical to a database file there is actually no need for special support of secondary indexes. It is left to the application to create them itself. pxlib &gt;= 0.6.0 can open databases for reading and writing and provide four new functions for this purpose. They will be described in the section `Modifying a database'.</p><p>Each field of the database is described by a structure:</p>
<pre>
typedef struct px_field pxfield_t;
struct px_field {
  char *px_fname;
  char px_ftype;
  int px_flen;
  int px_fdc;
};

</pre>
<p>The memory for the field array must be allocated by the calling application using pxlibs' memory management functions, but will be freed by pxlib. For a list of available file types see the man page of <a href="../man3/PX_create_fp.3.html"><strong>PX_create_fp</strong>(3)</a></strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">READING RECORDS FROM A DATABASE</h2>
        <div class="sectioncontent">
<p>Data in a Paradox database is organized in records containing fields. This is much like in other formats, e.g. dBase or a relational database system. Fields can be of 17 different data types as listed below. Field values are stored in sequential order in a record. A complete record is read by one of the functions</p><p><strong></strong></p><p>int PX_get_record (pxdoc_t *<em>pxdoc</em><strong>, int </strong><em>recno</em><strong>, char *</strong><em>data</em><strong>, int </strong><em>deleted</em><strong>);</strong></p><p>or</p><p><strong></strong></p><p>int PX_get_record2 (pxdoc_t *<em>pxdoc</em><strong>, int </strong><em>recno</em><strong>, char *</strong><em>data</em><strong>, int </strong><em>deleted</em><strong>, pxdatablockinfo_t *</strong><em>pxdbinfo</em><strong>);</strong></p><p>The second function returns additional data about the internal location of the record within the file, which is mostly valueable for debuging or creating a seconday index. Both functions need a record number starting at 0 for the first record and a memory area large enough for the record. The size of that area can be determined by the function <a href="../man3/PX_get_value.3.html"><strong>PX_get_value</strong>(3)</a></strong> when `recordsize' is passed as the value name. The record will read into that piece of memory straight from the database file without modifications.</p><p>Paradox files can be encrypted. pxlib will automatically decrypt a file while reading without the need to supply a password. This is possible because of a very weak encryption algorithmn and the password being stored in the database file itself.</p><p>Once the record data has been read it can be accessed with a number of different functions depending on the field type. The following list contains the field type and the function needed to retrieve the value. Nothing can prevent you from accessing the record data in a different way if you know what you are doing.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong>pxfAlpha</strong></p>
  </dt>
  <dd>
    <p><strong></strong></p><p>int PX_get_data_alpha (pxdoc_t *<em>pxdoc</em><strong>, char *</strong><em>data</em><strong>, int </strong><em>len</em><strong>, char **</strong><em>value</em><strong>);</strong></p><p>The field value will be automatically converted from the encoding used in the database file to the encoding set by <a href="../man3/PX_set_parameter.3.html"><strong>PX_set_parameter</strong>(3)</a></strong> with parameter name set to 'targetencoding`. The string will be null terminated.</p><p>This function allocates memory for the field data which must be freed by the application. The chunk of memory can be different from len when encoding involves conversion from a 1-byte to a 2-byte character representaion. This is also the reason why the application cannot precisly allocate the memory for the data and it must be left to pxlib. Read the section about `Memory allocation' for more details.</p>
  </dd>
  <dt>
    <p><strong>pxfDate</strong></p>
  </dt>
  <dd>
    <p><strong></strong></p><p>int PX_get_data_long (pxdoc_t *<em>pxdoc</em><strong>, char *</strong><em>data</em><strong>, int </strong><em>len</em><strong>, long *</strong><em>value</em><strong>);</strong></p><p>Fields of type date are actually 4 byte integer values counting days since jan-00-0000. In order to convert it into 3 single integers for year, month and day, you will have to add 1721425 to the value and call the function</p><p><strong></strong></p><p>void PX_SdnToGregorian (long int *<em>value</em><strong>, int *</strong><em>year</em><strong>, int *</strong><em>month</em><strong>, int *</strong><em>day</em><strong>);</strong></p><p>in order to get a valid date. The value 1721425 is the number of days between the start of the julian calendar (4714 BC) and jan-00-0000. <em>len</em> must be set to 4.</p>
  </dd>
  <dt>
    <p><strong>pxfShort</strong></p>
  </dt>
  <dd>
    <p><strong></strong></p><p>int PX_get_data_short (pxdoc_t *<em>pxdoc</em><strong>, char *</strong><em>data</em><strong>, int </strong><em>len</em><strong>, short int *</strong><em>value</em><strong>);</strong></p><p>This type is a short integer which is 2 bytes long. <em>len</em> must be set to 2.</p>
  </dd>
  <dt>
    <p><strong>pxfLong, pxfAutoInc</strong></p>
  </dt>
  <dd>
    <p><strong></strong></p><p>int PX_get_data_long (pxdoc_t *<em>pxdoc</em><strong>, char *</strong><em>data</em><strong>, int </strong><em>len</em><strong>, long *</strong><em>value</em><strong>);</strong></p><p>This type is a integer which is 4 bytes long. <em>len</em> must be set to 4.</p>
  </dd>
  <dt>
    <p><strong>pxfNumber, pxfCurrency</strong></p>
  </dt>
  <dd>
    <p><strong></strong></p><p>int PX_get_data_double (pxdoc_t *<em>pxdoc</em><strong>, char *</strong><em>data</em><strong>, int </strong><em>len</em><strong>, double *</strong><em>value</em><strong>);</strong></p><p>These types are floating poing numbers. <em>len</em> must be set to 8.</p>
  </dd>
  <dt>
    <p><strong>pxfLogical</strong></p>
  </dt>
  <dd>
    <p><strong></strong></p><p>int PX_get_data_byte (pxdoc_t *<em>pxdoc</em><strong>, char *</strong><em>data</em><strong>, int </strong><em>len</em><strong>, char *</strong><em>value</em><strong>);</strong></p><p>The extracted value is either 0 (false) or &lt;0 (true). <em>len</em> must be set to 1.</p>
  </dd>
  <dt>
    <p><strong>pxfBLOb, pxfMemoBLOb, pxfFmtMemoBLOb</strong></p>
  </dt>
  <dd>
    <p><strong></strong></p><p>int PX_get_data_blob (pxdoc_t *<em>pxdoc</em><strong>, char *</strong><em>data</em><strong>, int </strong><em>len</em><strong>, int *</strong><em>modnr</em><strong>, int *</strong><em>blobsize</em><strong>, char **</strong><em>value</em><strong>);</strong></p><p>This function may not in any case succed. You should call <a href="../man3/PX_set_blob_file.3.html"><strong>PX_set_blob_file</strong>(3)</a></strong> before to make sure even blobs in a separate blob file can be retrieved. See the section about reading blobs for more information.</p>
  </dd>
  <dt>
    <p><strong>pxfOLE</strong></p>
  </dt>
  <dd>
    <p>This type is not supported because there is too little known about it. Accessing fields of type pxfOLE like fields of type pxfBLOb may work.</p>
  </dd>
  <dt>
    <p><strong>pxfGraphic</strong></p>
  </dt>
  <dd>
    <p><strong></strong></p><p>int PX_get_data_graphic (pxdoc_t *<em>pxdoc</em><strong>, char *</strong><em>data</em><strong>, int </strong><em>len</em><strong>, int *</strong><em>modnr</em><strong>, int *</strong><em>blobsize</em><strong>, char **</strong><em>value</em><strong>);</strong></p><p>This function has not been tested very well.</p>
  </dd>
  <dt>
    <p><strong>pxfTime</strong></p>
  </dt>
  <dd>
    <p>Use <a href="../man3/PX_get_data_long.3.html"><strong>PX_get_data_long</strong>(3)</a></strong> as documented at field type pxfDate. The value is the number of milli seconds since midnight.</p>
  </dd>
  <dt>
    <p><strong>pxfTimestamp</strong></p>
  </dt>
  <dd>
    <p>Use <a href="../man3/PX_get_data_double.3.html"><strong>PX_get_data_double</strong>(3)</a></strong> and convert the timestamp into a string with</p><p><strong></strong></p><p>char *PX_timestamp2string (pxdoc_t *<em>pxdoc</em><strong>, double *</strong><em>value</em><strong>, const char *</strong><em>format</em><strong>);</strong></p><p><a href="../man3/PX_timestamp2string.3.html"><strong>PX_timestamp2string</strong>(3)</a></strong> takes a format string as described in the manual page of the function and returns a string. Alternatively you can process the value itself. It represents the number of seconds since jan-00-0000. Dividing it by 86400 and converting it to an integer produces a value as stored in fields of type pxfTime.</p>
  </dd>
  <dt>
    <p><strong>pxfBCD</strong></p>
  </dt>
  <dd>
    <p><strong></strong></p><p>int PX_get_data_bcd (pxdoc_t *<em>pxdoc</em><strong>, char *</strong><em>data</em><strong>, int </strong><em>len</em><strong>, char **</strong><em>value</em><strong>);</strong></p><p>This function allocates memory for the field data which must be freed by the application.</p>
  </dd>
  <dt>
    <p><strong>pxfBytes</strong></p>
  </dt>
  <dd>
    <p><strong></strong></p><p>int PX_get_data_bytes (pxdoc_t *<em>pxdoc</em><strong>, char *</strong><em>data</em><strong>, int </strong><em>len</em><strong>, char **</strong><em>value</em><strong>);</strong></p><p>This function behaves like <a href="../man3/PX_get_data_alpha.3.html"><strong>PX_get_data_alpha</strong>(3)</a></strong> except for the character conversion which does not take place. It will always copy exactely <em>len</em> bytes. This function allocates memory for the field data which must be freed by the application.</p>
  </dd>

</dl>
<p>Each function takes the current Paradox database object as the first argument.  The second argument is the start of the field data. For the first field this will be the beginning of the whole record. The second field starts at an offset of length(first field), the third field starts at length(first field) plus length(second field) and so on. The <em>len</em> is the size of the field. The last parameter is a pointer to the data converted to an equivalent C type. Each function either returns 0 on success or a value &lt; 0 in case of an error. Nobody prevents you from accessing the data with the wrong function, or pointing towards the wrong position in the record. Check the manual page of each function for a more detailed description.</p><p>Sequencialy reading records and fields from a Paradox database is illustrated in the next simplified example.</p>
<pre>
for(j=0; j&lt;pxh-&gt;px_numrecords; j++) {
  int offset;
  if(PX_get_record(pxdoc, j, data)) {
    offset = 0;
    pxf = pxh-&gt;px_fields;
    for(i=0; i&lt;pxh-&gt;px_numfields; i++) {
      switch(pxf-&gt;px_ftype) {
        case pxfAlpha: {
          char *value;
          if(0 &lt; PX_get_data_alpha(pxdoc, &data[offset], pxf-&gt;px_flen, &value)) {
            // ...
            pxdoc-&gt;free(pxdoc, value);
          } else {
            // ...
          }
          break;
        }
        case pxfDate: {
          long value;
          int year, month, day;
          if(0 &lt; PX_get_data_long(pxdoc, &data[offset], pxf-&gt;px_flen, &value)) {
            PX_SdnToGregorian(value+1721425, &year, &month, &day);
            // ...
          } else {
            // ...
          }
          break;
        }
        case pxfShort: {
          short int value;
          if(0 &lt; PX_get_data_short(pxdoc, &data[offset], pxf-&gt;px_flen, &value)) {
            // ...
          } else {
            // ...
          }
          break;
        }
        case pxfAutoInc:
        case pxfLong: {
          long value;
          if(0 &lt; PX_get_data_long(pxdoc, &data[offset], pxf-&gt;px_flen, &value)) {
            // ...
          } else {
            // ...
          }
          break;
        }
        case pxfTimestamp: {
          double value;
          if(0 &lt; PX_get_data_double(pxdoc, &data[offset], pxf-&gt;px_flen, &value)) {
            char *str = PX_timestamp2string(pxdoc, value, "Y-m-d H:i:s");
            // ...
            pxdoc-&gt;free(pxdoc, str);
          } else {
            // ...
          }
          break;
        }
        case pxfTime: {
          long value;
          if(0 &lt; PX_get_data_long(pxdoc, &data[offset], pxf-&gt;px_flen, &value)) {
            // ...
          } else {
            // ...
          }
          break;
        }
        case pxfCurrency:
        case pxfNumber: {
          double value;
          if(0 &lt; PX_get_data_double(pxdoc, &data[offset], pxf-&gt;px_flen, &value)) {
            // ...
          } else {
            // ...
          }
          break;
        }
        case pxfLogical: {
          char value;
          if(0 &lt; PX_get_data_byte(pxdoc, &data[offset], pxf-&gt;px_flen, &value)) {
            if(value)
              // ...
            else
              // ...
          } else {
            // ...
          }
          break;
        }
        case pxfBLOb:
        case pxfGraphic:
        case pxfOLE:
        case pxfMemoBLOb:
        case pxfFmtMemoBLOb: {
            char *blobdata;
            int mod_nr, size, ret;
            if(pxf-&gt;px_ftype == pxfGraphic)
              ret = PX_get_data_graphic(pxdoc, &data[offset], pxf-&gt;px_flen, &mod_nr, &size, &blobdata);
            else
              ret = PX_get_data_blob(pxdoc, &data[offset], pxf-&gt;px_flen, &mod_nr, &size, &blobdata);
            if(ret &gt; 0) {
              if(blobdata) {
                // ...
                pxdoc-&gt;free(pxdoc, blobdata);
              } else {
                // ...
              }
            }
            break;
        }
        case pxfBCD: {
          char *value;
          int ret;
          if(0 &lt; (ret = PX_get_data_bcd(pxdoc, &data[offset], pxf-&gt;px_fdc, &value))) {
            // ..
            pxdoc-&gt;free(pxdoc, value);
          } else if(ret == 0) {
            // ..
          } else {
            // ..
          }
          break;
        }
        case pxfBytes:
          // ..
          break;
        default:
          break;
      }
    }
    offset += pxf-&gt;px_flen;
    pxf++;
  } else {
    fprintf(stderr, _("Couldn't get record number %d&#92;n"), j);
  }
}

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">WRITING RECORDS INTO A DATABASE</h2>
        <div class="sectioncontent">
<p>Write support has been introduced into pxlib in version 0.1.9 but should be still considered experimental, though there has been reports from users who has successfully used it.</p><p>Writing paradox databases is quite similar to reading them, if you substitute <a href="../man3/PX_open_file.3.html"><strong>PX_open_file</strong>(3)</a></strong> by <a href="../man3/PX_create_file.3.html"><strong>PX_create_file</strong>(3)</a></strong> and <a href="../man3/PX_get_record.3.html"><strong>PX_get_record</strong>(3)</a></strong> by <a href="../man3/PX_put_record.3.html"><strong>PX_put_record</strong>(3)</a></strong>.</p><p>Modifying the above example in order to create a simple database with two columns will result in the following code:</p>
<pre>
...
#include &lt;paradox.h&gt;

main(int argc, char *argv[]) {
	pxdoc_t *pxdoc;
	pxfield_t pxf[2];
	int numfields = 2;

	PX_boot();
	pxdoc = PX_new();
	pxf[0].px_fname = PX_strdup(pxdoc, "column1");
	pxf[0].px_ftype = pxfShort;
	pxf[0].px_flen = 2;
	pxf[0].px_fdc = 0;
	pxf[1].px_fname = PX_strdup(pxdoc, "column2");
	pxf[1].px_ftype = pxfAlpha;
	pxf[1].px_flen = 20;
	pxf[1].px_fdc = 0;
	PX_create_file(pxdoc, pxf, numfields, "test.db", pxfFileTypNonIndexDB);
	PX_close(pxdoc);
	PX_delete(pxdoc);
	PX_shutdown();
}

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MODIFYING A DATABASE</h2>
        <div class="sectioncontent">
<p>Starting from version 0.6.0 pxlib supports to open databases for reading and writing at the same time. If you intend to do so, please ensure to open the file for the database in `w+', `r+', or `a+' mode. You will also have to use a new set of functions as described below.</p><p><strong></strong></p><p>int PX_insert_record (pxdoc_t *<em>pxdoc</em><strong>, pxval_t **</strong><em>data</em><strong>);</strong></p><p><strong>PX_insert_record</strong>(3)</strong> inserts a new record into a database.</p><p><strong></strong></p><p>int PX_update_record (pxdoc_t *<em>pxdoc</em><strong>, pxval_t **</strong><em>data</em><strong>, int </strong><em>recno</em><strong>);</strong></p><p><a href="../man3/PX_update_record.3.html"><strong>PX_update_record</strong>(3)</a></strong> updates an existing record in database.</p><p><strong></strong></p><p>int PX_delete_record (pxdoc_t *<em>pxdoc</em><strong>, int </strong><em>recno</em><strong>);</strong></p><p><strong></strong></p><p>int PX_retrieve_record (pxdoc_t *<em>pxdoc</em><strong>, int </strong><em>recno</em><strong>);</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ENCODING</h2>
        <div class="sectioncontent">
<p>Exchanging text is not problem as long as both parties use the same encoding or stipulate to use plain 7 bit ascii. Paradox allows to use any encoding with a know dos code page and saves the corresponding code page number in the header of the database. You can request this number with <a href="../man3/PX_get_value.3.html"><strong>PX_get_value</strong>(3)</a></strong> by passing `codepage' as the value name. Reading fields of type pxfAlpha will return the unmodified value unless the target encoding has been set by <a href="../man3/PX_set_parameter.3.html"><strong>PX_set_parameter</strong>(3)</a></strong> differently from the one stored in the database header. If the target encoding is set differently <a href="../man3/PX_get_data_alpha.3.html"><strong>PX_get_data_alpha</strong>(3)</a></strong> will automatically convert into the requested encoding. This is either done be the iconv or recode library, depending on which one was found when pxlib was configured. If both were available iconv is preferred.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">READING BLOBS</h2>
        <div class="sectioncontent">
<p>Paradox knows five field types which all represent a type of blob data. Blobs can be stored in the database file but are usually stored in an extra file with the extension .MB. pxlib provides two functions to read blob data.</p><p><strong></strong></p><p>int PX_get_data_blob (pxdoc_t *<em>pxdoc</em><strong>, char *</strong><em>data</em><strong>, int </strong><em>len</em><strong>, int *</strong><em>modnr</em><strong>, int *</strong><em>blobsize</em><strong>, char **</strong><em>value</em><strong>);</strong></p><p>and</p><p><strong></strong></p><p>int PX_get_data_graphic (pxdoc_t *<em>pxdoc</em><strong>, char *</strong><em>data</em><strong>, int </strong><em>len</em><strong>, int *</strong><em>modnr</em><strong>, int *</strong><em>blobsize</em><strong>, char **</strong><em>value</em><strong>);</strong></p><p>The second function must be used for fields of type pxfGraphic, the first function can be savely use for fields of type pxfBLOb, pxfMemoBLOb, and pxfFmtMemoBLOb.</p><p>In order to read blob data from a .MB file one must first associate that file with the database file by calling</p><p><strong></strong></p><p>int PX_set_blob_file (pxdoc_t *<em>pxdoc</em><strong>, const char *</strong><em>filename</em><strong>);</strong></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">WRITING BLOBS</h2>
        <div class="sectioncontent">
<p>Writing blobs is still the most experimental part of pxlib. There has been already success stories but there are also some missing parts in the paradox file format which decreases confidence on those files.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MEMORY MANAGEMENT, ERROR HANDLING</h2>
        <div class="sectioncontent">
<p>pxlib uses by default its on memory management and error handling functions. In many cases the calling application has its own memory management and error handling. pxlib can be told to use those functions by calling <a href="../man3/PX_new3.3.html"><strong>PX_new3</strong>(3)</a></strong> instead of <a href="../man3/PX_new.3.html"><strong>PX_new</strong>(3)</a></strong>.</p><p><strong></strong></p><p>int PX_new3 (pxdoc_t *<em>psdoc</em><strong>, (errorhandler *) </strong><em>(pxdoc_t *p, int type, const char *msg, void *data)</em><strong>, (allocproc *) </strong><em>(pxdoc_t *p, size_t size, const char *caller)</em><strong>, (reallocproc *) </strong><em>(pxdoc_t *p, void *mem, size_t size, const char *caller)</em><strong>, (freeproc *) </strong><em>(pxdoc_t *p, void *mem)</em><strong>, void *</strong><em>errorhandler_user_data</em><strong>);</strong></p><p>The errorhandler and the last parameter <em>errorhandler_user_data</em> allow to pass arbitrary data as the last parameter to its own errorhandler. This is quite often used if errors are being output in a widget of a graphical toolkit. The pointer to that widget can be passed as <em>errorhandler_user_data</em> and pxlib will pass it forward to the error handler.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ENCRYPTION</h2>
        <div class="sectioncontent">
<p>Paradox supports a very weak encryption of the data blocks. The headers are not encrypted. Encryption is accomplished by three static tables with 256 bytes each and a long integer generated from a password. The integer is called the checksum of the password. The checksum is stored in the header of the .db file which makes it feasable to decrypt a file even without knowing the password. pxlib reads encrypted files silently without asking for additional information. Writing an encrypted file requires to supply a password for calculating the checksum. The password can be set with <a href="../man3/PX_set_parameter.3.html"><strong>PX_set_parameter</strong>(3)</a></strong>. Once it is set, encryption is automatically turned on. The password must be set before writing any records. The best place to do this, is right after calling <a href="../man3/PX_create_file.3.html"><strong>PX_create_file</strong>(3)</a></strong> or <a href="../man3/PX_create_fp.3.html"><strong>PX_create_fp</strong>(3)</a></strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO pxlib&hellip;</h2>
        <div class="sectioncontent">
<p>The detailed manual pages for each function of the library.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>This manual page was written by Uwe Steinmann &lt;uwe@steinmann.cx&gt;.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="pvalloc.3.html"><span aria-hidden="true">&larr;</span> pvalloc.3: Allocate aligned memory</a></li>
   <li class="next"><a href="pydhcplib.3.html">pydhcplib.3: Une librarie dhcp en python <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Test::Inter: Framework for more readable interactive test scripts</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Framework for more readable interactive test scripts">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Test::Inter (3pm) manual">
  <meta name="twitter:description" content="Framework for more readable interactive test scripts">
  <meta name="twitter:image" content="https://www.carta.tech/images/libtest-inter-perl-Test::Inter-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Test::Inter.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Test::Inter (3pm) manual" />
  <meta property="og:description" content="Framework for more readable interactive test scripts" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libtest-inter-perl-Test::Inter-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Test::Inter<small> (3pm)</small></h1>
        <p class="lead">Framework for more readable interactive test scripts</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Test::Inter.3pm.html">
      <span itemprop="name">Test::Inter: Framework for more readable interactive test scripts</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libtest-inter-perl/">
      <span itemprop="name">libtest-inter-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Test::Inter.3pm.html">
      <span itemprop="name">Test::Inter: Framework for more readable interactive test scripts</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This is another framework for writing test scripts. It is loosely inspired by Test::More, and has most of it's functionality, but it is not a drop-in replacement.</p><p>Test::More (and other existing test frameworks) suffer from two weaknesses, both of which have prevented me from ever using them:</p>
<pre>
   None offer the ability to access specific tests in
   a reasonably interactive fashion

   None offer the ability to write the tests in
   whatever format would make the tests the most
   readable
</pre>
<p>The way I write and use test scripts, existing Test::* modules are not nearly as useful as they could be.  Test scripts written using Test::More work fine when running as part of the test suite, but debugging an individual test requires extra steps, and the tests themselves are not as readable as they should be.</p><p>I do most of my debugging using test scripts. When I find a bug, I write a test case for it, debug it using the test script, and then leave the test there so the bug won't come back (hopefully).</p><p>Since I use test scripts in two ways (part of a standard test suite and to run the scripts in some interactive way to debug problems), I want to be able to do the follwing trivially:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>Easy access to a specific test or tests</strong>
  </dt>
  <dd>
    <p>If I'm running the test script interactively (perhaps in the debugger), there are several common functions that I want to have available, including:    Run only a single test, or a subset of tests</p><p>   Set a breakpoint in the debugger to run    up to the start of the Nth test</p>
  </dd>
  <dt>
    <strong>Better diagnostics</strong>
  </dt>
  <dd>
    <p>When running a test script as part of a test suite, the pass/fail status is really the only thing of interest. You just want to know if the module passes all the tests. When running interactively, additional information may allow me to quickly track down the problem without even resorting to a debugger. If a test fails, I almost always want to see why it failed if I'm running it interactively.  If reasonable, I want to see a list of what was input, what was output, and what was expected.</p>
  </dd>

</dl>
<p>The other feature that I wanted in a test suite is the ability to define the tests in a readable format. In almost every case, it is best to think of a test script as consisting of two separate parts: a script part, and a test part, and the more you can keep the two separate, the better.</p><p>The script part of a test script is the least important part! It's usually fairly trivial, rarely needs to be changed, and is quite simply not the focus of the test script.</p><p>The tests part of the script \s-1IS\s0 the important part, and these should be expressed in a form that is easy to maintain, easy to read, and easy to modify, and none of these should involve modifying the script portion of the test script in general. As a general rule, if the script portion of the test script obscures the tests in any way, it's not written correctly!</p><p>Compare this to any other systems where you are mixing two \*(L"languages\*(R". For example, a \s-1PHP\s0 script where you have a mixture of \s-1PHP\s0 and \s-1HTML\s0 or a templating system consisting of text and template commands. The more the two languages are interwoven, the less readable both are, and the harder it is to maintain.</p><p>As often as possible, I want the tests to be written in some sort of text format which can be easily read as a table with no perl commands interspersed. I want to the freedom to define the tests in one big string (perhaps a \s-1DATA\s0 section, or even in a separate file) which is easily readable. This may introduce the necessity of parsing it, but it makes it significantly easier to maintain the tests.</p><p>This flexibilty makes it much easier to read the tests (as opposed to the script) which is the fundamental content of a test script.</p><p>To illustrate some of this, in Test::More, a series of tests might be specified as:</p><p>   # test 1    $result = func("apples","bushels");    is($result, "enough");</p><p>   # test 2    $result = func("grapefruit","tons");    is($result, "enough");</p><p>   # test 3    $result = func("oranges","boatloads");    is($result, "insufficient");</p><p>Thinking about the features I want that I listed above, there are several difficulties with this.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>Debugging the script is tedious</strong>
  </dt>
  <dd>
    <p>To debug the 3rd test, you have to open up the file and get the line number of the 3rd test.  You set a breakpoint there and then you can run the script. It's typically not very hard to do this, but if you have to check out the line number every time you want to visit a test, it can break your chain of thought. How much better to be able to say:     break func ($::TI_NUM==3) It would also be nice to be able to skip the first two tests... perhaps they take a long time to run, and I want to get right to work on test 3. You can do this easily too by setting the $::TI_START variable.</p>
  </dd>
  <dt>
    <strong>Way too much perl interspersed with the tests</strong>
  </dt>
  <dd>
    <p>It's difficult to read the tests individually in this script because there is too much perl code among them, and virtually impossible to look at them as a whole. It is true that looking at this as a perl script, it is very simple... but the script \s-1ISN\s0'T the content you're interested in. The \s-1REAL\s0 content of this script are the tests, which consist of the function arguments and the expected result. Although it's not impossible to see each of these in the script above, it's not in a format that is conducive to studying the tests, and especially not for examing the list of tests as a whole.</p>
  </dd>

</dl>
<p>Now, look at an alternate way of specifying the tests using this module:</p><p>   $tests = "</p><p>     apples     bushels   =&gt; enough</p><p>     grapefruit tons      =&gt; enough</p><p>     oranges    boatloads =&gt; insufficient</p><p>   ";</p><p>   $o-&gt;tests(tests =&gt; $tests,              func  =&gt; &#92;&func);</p><p>Here, it's easy to see the list of tests, and adding additional tests is a breeze.</p><p>This module supports a number of methods for defining tests, so you can use whichever one is most convenient (including methods that are identical to Test::More).</p><p>In addition, the following debugger command works as desired:</p><p>   b func ($::TI_NUM==3)</p><p>and you're ready to debug.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CREATING A TEST</h2>
        <div class="sectioncontent">
<p>Every test may have several pieces of information:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>A name</strong>
  </dt>
  <dd>
    <p>Every test is automatically assigned a number, but it may be useful to specify a name of a test (which is actually a short description of the test). Whenever a test result is reported, the name will be given (if one was specified). The name may not have a '#' in it. The name is completely optional, but makes the results more readable.</p>
  </dd>
  <dt>
    <strong>An expected result</strong>
  </dt>
  <dd>
    <p>In order to test something, you need to know what result was expected (or in some cases, what result was \s-1NOT\s0 expected).</p>
  </dd>
  <dt>
    <strong>A function and arguments \s-1OR\s0 a result</strong>
  </dt>
  <dd>
    <p>You also need to know the results that you're comparing to the expected results. This can be obtained by simply working with a set of results, or a function name and a set of arguments to pass to it.</p>
  </dd>
  <dt>
    <strong>Conditions</strong>
  </dt>
  <dd>
    <p>It is useful to be able to specify state information at the start of the test suite (for example, to see if certain features are available), and some tests may only run if those conditions are met. If no conditions are set for a test, it will always run.</p>
  </dd>
  <dt>
    <strong>Todo tests</strong>
  </dt>
  <dd>
    <p>Some tests may be marked as 'todo' tests. These are test which are allowed to fail (meaning that they have been put in place for an as-yet unimplemented feature). Since it is expected that the test will fail, the test suite will still pass, even if these tests fail. The tests will still run and if they pass, a message is issued saying that the feature is now implemented, and the tests should be graduated to non-todo state.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BASE METHODS</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <strong>new</strong>
  </dt>
  <dd>
    <p>   $o = new Test::Inter [$name] [%options]; This creates a new test framework. There are several options which may be used to specify which tests are run, how they are run, and what output is given. The entire test script can be named by passing in $name. Options can be passed in as a hash of ($opt,$val) pairs. Options can be set in four different ways. First, you can pass in an ($opt,$val) pair in the new method. Second, you can set an environment variable (which overrides any value passed to the new method). Third, you can set a global variable (which overrides both the environment variable and options passed to the new method). Fouth, you can call the appropriate method to set the option. This overrides all other methods. Each of the allowed options are described below in the following base methods:    start    end    testnum    plan    abort    quiet    mode    skip_all    width</p>
  </dd>
  <dt>
    <strong>version</strong>
  </dt>
  <dd>
    <p>   $o-&gt;version(); Returns the version of the module.</p>
  </dd>
  <dt>
    <strong>start</strong>
  </dt>
  <dd>
    <p>   $o = new Test::Inter &apos;start&apos; =&gt; $N;    $o-&gt;start($N) To define which test you want to start with, pass in an ($opt,$val) pair of ('start',N), set an environment variable TI_START=N, or a global variable $::TI_START=N. When the start test is defined, most tests numbered less than N are completely ignored. If the tests are being run quietly (see the quiet method below), nothing is printed out for these tests. Otherwise, a skip message is printed out. One class of tests \s-1IS\s0 still executed. Tests run using the require_ok or use_ok methods (to test the loading of modules) are still run. If no value (or a value of 0) is used, it defaults to the first test.</p>
  </dd>
  <dt>
    <strong>end</strong>
  </dt>
  <dd>
    <p>   $o = new Test::Inter &apos;end&apos; =&gt; $M;    $o-&gt;end($M); To define which test you want to end with, pass in an ($opt,$val) pair of ('end',M), set an environment variable TI_END=M, or set a global variable $::TI_END=M. When the end test is defined, all tests numbered more than M are completely ignored. If the tests are being run quietly (see the quiet method below), nothing is printed out for these tests. Otherwise, a skip message is printed out. If no value is given, it defaults to 0 (which means that all reamining tests are run).</p>
  </dd>
  <dt>
    <strong>testnum</strong>
  </dt>
  <dd>
    <p>   $o = new Test::Inter &apos;testnum&apos; =&gt; $N;    $o-&gt;testnum($N); This is used to run only a single test. It is equivalent to setting both the start and end tests to $N.</p>
  </dd>
  <dt>
    <strong>plan</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>done_testing</strong>
  </dt>
  <dd>
    <p>   $o = new Test::Inter &apos;plan&apos; =&gt; $N;    $o-&gt;plan($n);</p><p>   $o-&gt;done_testing();    $o-&gt;done_testing($n); The \s-1TAP\s0 \s-1API\s0 (the 'language' used to run a sequence of tests and see which ones failed and which ones passedd) requires a statement of the number of tests that are expected to run. This statement can appear at the start of the test suite, or at the end. If you know in advance how many tests should run in the test script, you can pass in a non-zero integer in a ('plan',N) pair to the new method, or set the \s-1TI_PLAN\s0 environment variable or the $::TI_PLAN global variable, or call the plan method. If you know how many tests should run at the end of the test script, you can pass in a non-zero integer to the done_testing method. Frequently, you don't really care how many tests are in the script (especially if new tests are added on a regular basis). In this case, you still need to include a statement that says that the number of tests expected is however many were run. To do this, call the done_testing method with no argument. \s-1NOTE:\s0 if the plan method is used, it \s-1MUST\s0 be used before any tests are run (including those that test the loading of modules). If the done_testing method is used, it \s-1MUST\s0 be called after all tests are run. You must specify a plan or use a done_testing statement, but you cannot do both. It is \s-1NOT\s0 strictly required to set a plan if the script is only run interactively, so if for some reason this module is used for test scritps which are not part of a standard perl test suite, the plan and done_testing statements are optional. As a matter of fact, the script will run just fine without them... but a perl installer will report a failure in the test suite.</p>
  </dd>
  <dt>
    <strong>abort</strong>
  </dt>
  <dd>
    <p>   $o = new Test::Inter &apos;abort&apos; =&gt; 0/1/2;    $o-&gt;abort(0/1/2); The abort option can be set using an ('abort',0/1/2) option pair, or by setting the \s-1TI_ABORT\s0 environment variable, or the $::TI_ABORT global variable. If this is set to 1, the test script will run unmodified until a test fails. At that point, all remaining tests will be skipped. If it is set to 2, the test script will run until a test fails at which point it will exit with an error code of 1. In both cases, todo tests will \s-1NOT\s0 trigger the abort behavior.</p>
  </dd>
  <dt>
    <strong>quiet</strong>
  </dt>
  <dd>
    <p>   $o = new Test::Inter &apos;quiet&apos; =&gt; 0/1/2;    $o-&gt;quiet(0/1/2); The quiet option can be set using an ('quiet',0/1/2) option pair, or by setting the \s-1TI_QUIET\s0 environment variable, or the $::TI_QUIET global variable. If this is set to 0 (the default), all information will be printed out. If it is set to 1, some optional information will not be printed. If it is set to 2, all optional information will not be printed.</p>
  </dd>
  <dt>
    <strong>mode</strong>
  </dt>
  <dd>
    <p>   $o = new Test::Inter &apos;mode&apos; =&gt; MODE;    $o-&gt;mode(MODE); The mode option can be set using a ('mode',MODE) option pair, or by setting the \s-1TI_MODE\s0 environment variable, or the $::TI_MODE global variable. Currently, \s-1MODE\s0 can be 'test' or 'inter' meaning that the script is run as part of a test suite, or interactively. When run in test mode, it prints out the results using the \s-1TAP\s0 grammar (i.e. 'ok 1', 'not ok 3', etc.). When run in interactive mode, it prints out results in a more human readable format.</p>
  </dd>
  <dt>
    <strong>width</strong>
  </dt>
  <dd>
    <p>   $o = new Test::Inter &apos;width&apos; =&gt; WIDTH;    $o-&gt;width(WIDTH); The width option can be set using a ('width',WIDTH) option pair, or by setting the \s-1TI_WIDTH\s0 environment variable, or the $::TI_WIDTH global variable. \s-1WIDTH\s0 is the width of the terminal (for printing out failed test information). It defaults to 80, but it can be set to any width (and lines longer then this are truncated). If \s-1WIDTH\s0 is set to 0, no truncation is done.</p>
  </dd>
  <dt>
    <strong>skip_all</strong>
  </dt>
  <dd>
    <p>   $o = new Test::Inter &apos;skip_all&apos; =&gt; REASON;    $o-&gt;skip_all(REASON); The skip_all option can be set using an ('skip_all',REASON) option pair, or by setting the \s-1TI_SKIP_ALL\s0 environment variable, or the $::TI_SKIP_ALL global variable. If this is set, the entire test script will be skipped for the reason given. This must be done before any test is run, and before any plan number is set. The skip_all can also be called at any point during the script (i.e. after tests have been run). In this case, all remaining scripts will be skipped.    $o-&gt;skip_all(REASON,FEATURE,FEATURE,...);    $o-&gt;skip_all(&apos;&apos;,FEATURE,FEATURE,...); This will skip all tests (or all remaining tests) unless all features are available.  \s-1REASON\s0 can be entered as an empty string and the reason the tests are skipped will be a message about the missing feature.</p>
  </dd>
  <dt>
    <strong>feature</strong>
  </dt>
  <dd>
    <p>   $o-&gt;feature($feature,$val); This defines a feature. If $val is non-zero, the feature is available. Otherwise it is not.</p>
  </dd>
  <dt>
    <strong>diag</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>note</strong>
  </dt>
  <dd>
    <p>   $o-&gt;diag($message);    $o-&gt;note($message); Both of these print an optional message. Messages printed with the note method are always optional and will be omitted if the quiet option is set to 1 or 2. Messages printed with the diag method are optional and will not be printed if the quiet option is set to 2, but they will be printed if the quiet method is set to 1.</p>
  </dd>
  <dt>
    <strong>testdir</strong>
  </dt>
  <dd>
    <p>Occasionally, it may be necessary to know the directory where the tests live (for example, there may be a config or data file in there). This method will return the directory.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS FOR LOADING MODULES</h2>
        <div class="sectioncontent">
<p>Test scripts can load other modules (using either the perl 'use' or 'require' commands).  There are three different modes for doing this which determine how this is done.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>required mode</strong>
  </dt>
  <dd>
    <p>By default, this is used to test for a module that is required for all tests in the test script. Loading the module is treated as an actual test in the test suite. The test is to determine whether the module is available and can be loaded. If it can be loaded, it is, and it is reported as a successful test. If it cannot be loaded, it is reported as a failed test. In the result of a failed test, all remaining tests will be skipped automatically (except for other tests which load modules).</p>
  </dd>
  <dt>
    <strong>feature mode</strong>
  </dt>
  <dd>
    <p>In feature mode, loading the module is not treated as a test (i.e. it will not print out an 'ok' or 'not ok' line. Instead, it will set a feature (named the same as the module) which can be used to determine whether other tests should run or not.</p>
  </dd>
  <dt>
    <strong>forbid mode</strong>
  </dt>
  <dd>
    <p>In a few very rare cases, we may want to test for a module but expect that it not be present. This is the exact opposite of the 'required' mode. Successfully loading the module is treated as a test failure. In the event of a failure, all remaining tests will be skipped.</p>
  </dd>

</dl>
<p>The methods available are:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>require_ok</strong>
  </dt>
  <dd>
    <p>   $o-&gt;require_ok($module [,$mode]); This is used to load a module using the perl 'require' function. If $mode is not passed in, the default mode (required) is used to test the existance of the module. If $mode is passed in, it must be either the string 'forbid' or 'feature'. If $mode is 'feature', a feature named $module is set if the module was able to be loaded.</p>
  </dd>
  <dt>
    <strong>use_ok</strong>
  </dt>
  <dd>
    <p>   $o-&gt;use_ok(@args [,$mode]); This is used to load a module with 'use', or check a perl version.    BEGIN { $o-&gt;use_ok(&apos;5.010&apos;); }    BEGIN { $o-&gt;use_ok(&apos;Some::Module&apos;); }    BEGIN { $o-&gt;use_ok(&apos;Some::Module&apos;,2.05); }    BEGIN { $o-&gt;use_ok(&apos;Some::Module&apos;,&apos;foo&apos;,&apos;bar&apos;); }    BEGIN { $o-&gt;use_ok(&apos;Some::Module&apos;,2.05,&apos;foo&apos;,&apos;bar&apos;); } are the same as:    use 5.010;    use Some::Module;    use Some::Module 2.05;    use Some::Module qw(foo bar);    use Some::Module 2.05 qw(foo bar); Putting the use_ok call in a \s-1BEGIN\s0 block allows the functions to be imported at compile-time and prototypes are properly honored. You'll also need to load the Test::Inter module, and create the object in a \s-1BEGIN\s0 block. $mode acts the same as in the require_ok method.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">METHODS FOR RUNNING TEST</h2>
        <div class="sectioncontent">
<p>There are several methods for running tests. The ok, is, and isnt methods are included for those already comfortable with Test::More and wishing to stick with the same format of test script. The tests method is the suggested method though since it makes use of the full power of this module.</p>
<dl class='dl-vertical'>
  <dt>
    <strong>ok</strong>
  </dt>
  <dd>
    <p>   $o-&gt;ok(TESTS); A test run with ok looks at a result, and if it evaluates to 0 (or false), it fails. If it evaluates to non-zero (or true), it passes. These tests do not require you to specify the expected results.  If expected results are given, they will be compared against the result received, and if they differ, a diagnostic message will be printed, but the test will still succeed or fail based only on the actual result produced. These tests require a single result and either zero or one expected results. To run a single test, use any of the following:    $o-&gt;ok();          # always succeeds</p><p>   $o-&gt;ok($result);    $o-&gt;ok($result,$name);    $o-&gt;ok($result,$expected,$name);</p><p>   $o-&gt;ok(&#92;&func);    $o-&gt;ok(&#92;&func,$name);    $o-&gt;ok(&#92;&func,$expected,$name);</p><p>   $o-&gt;ok(&#92;&func,&#92;@args);    $o-&gt;ok(&#92;&func,&#92;@args,$name);    $o-&gt;ok(&#92;&func,&#92;@args,$expected,$name); If $result is a scalar, the test passes if $result is true. If $result is a list reference, and the list is either empty, or the first element is a scalar), the test succeeds if the list contains any values (except for undef). If $result is a hash reference, the test succeeds if the hash contains any key with a value that is not undef. If &#92;&func and &#92;@args are passed in, then $result is generated by passing @args to &func and behaves identically to the calls where $result is passed in.  If &#92;&func is passed in but no arguments, the function takes no arguments, but still produces a result. $result may be a scalar, list reference, or hash reference. If it is a list reference, the test passes is the list contains any defined values. If it is a hash reference, the test passes if any of the keys contain defined values. If an expected value is passed in and the result does not match it, a diagnostic warning will be printed, even if the test passes.</p>
  </dd>
  <dt>
    <strong>is</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>isnt</strong>
  </dt>
  <dd>
    <p>   $o-&gt;is(TESTS);    $o-&gt;isnt(TESTS); A test run with is looks as a result and tests to see if it is identical to an expected result. If it is, the test passes. Otherwise it fails. In the case of a failure, a diagnostic message will show what result was actually obtained and what was expected. A test run with isnt looks at a result and tests to see if the result obtained is different than an expected result. If it is different, the test passes. Otherwise it fails. The is method can be called in any of the following ways:    $o-&gt;is($result,$expected);    $o-&gt;is($result,$expected,$name);</p><p>   $o-&gt;is(&#92;&func,$expected);    $o-&gt;is(&#92;&func,$expected,$name);</p><p>   $o-&gt;is(&#92;&func,&#92;@args,$expected);    $o-&gt;is(&#92;&func,&#92;@args,$expected,$name); The isnt method can be called in exactly the same way. As with the ok method, the result can be a scalar, hashref, or listref. If it is a hashref or listref, the entire structure must match the expected value.</p>
  </dd>
  <dt>
    <strong>tests</strong>
  </dt>
  <dd>
    <p>   $o-&gt;tests($opt=&gt;$val, $opt=&gt;$val, ...) The options available are described in the following section.</p>
  </dd>
  <dt>
    <strong>file</strong>
  </dt>
  <dd>
    <p>   $o-&gt;file($func,$input,$outputdir,$expected,$name [,@args]); Sometimes it may be easiest to store the input, output, and expected output from a series of tests in files. In this case, each line of output will be treated as a single test, so the output and expected output must match up exactly. $func is a reference to a function which will produce a temporary output file. If $input is specified, it is the name of the input file, and it will be passed to the function as the first argument. If $input is left blank, no input file will be used. The input file may be specified as a full path, or just the file name (in which case it will be looked for in the test directory and the current directory). $func also takes a arequired argument which is the output file. The tests method will create a tempoary file containing the output. If $outputdir is passed in, it is the directory where the output file will be written. If $outputdir is left blank, the temporary file will be written to the test directory. If @args is passed in, it is a list of additional arguments which will be passed to $func. $expected is the name of a file which contains the expeccted output. It can be fully specified, or it will be checked for in the test directory.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">USING THE TESTS METHOD</h2>
        <div class="sectioncontent">
<p>It is expected that most tests (except for those that load a module) will be run using the tests method called as:</p><p>   $o-&gt;tests($opt =&gt; $val, $opt =&gt; $val, ...);</p><p>The following options are available:</p>
<dl class='dl-vertical'>
  <dt>
    <strong>name</strong>
  </dt>
  <dd>
    <p>   name =&gt; NAME This sets the name of this set of tests. All tests will be given the same name.</p>
  </dd>
  <dt>
    <strong>tests</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>func</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>expected</strong>
  </dt>
  <dd>
    <p>In order to specify a series of tests, you have to specify either a function and a list of arguments, or a list of results. Specifying the function and list of arguments can be done using the pair:    func  =&gt; &#92;&FUNCTION    tests =&gt; TESTS If the func option is not set, tests contains a list of results. A list of expected results may also be given. They can be included in the    tests =&gt; TESTS option or included separately as:    expected =&gt; RESULTS The way to specify these are covered in the next section \s-1SPECIFYING\s0 \s-1THE\s0 \s-1TESTS\s0.</p>
  </dd>
  <dt>
    <strong>feature</strong>
  </dt>
  <dd>
    
  </dd>
  <dt>
    <strong>disable</strong>
  </dt>
  <dd>
    <p>   feature =&gt; [FEATURE1, FEATURE2, ...]</p><p>   disable =&gt; [FEATURE1, FEATURE2, ...] The default set of tests to run is determined using the start, end, and skip_all methods discussed above. Using those methods, a list of tests is obtained, and it is expected that these will run. The feature and disable options modify the list. If the feature option is included, the tests given in this call will only run if \s-1ALL\s0 of the features listed are available. If the disable option is included, the tests will be run unless \s-1ANY\s0 of the features listed are available.</p>
  </dd>
  <dt>
    <strong>skip</strong>
  </dt>
  <dd>
    <p>   skip =&gt; REASON Skip these tests for the reason given.</p>
  </dd>
  <dt>
    <strong>todo</strong>
  </dt>
  <dd>
    <p>   todo =&gt; 0/1 Setting this to 1 says that these tests are allowed to fail. They represent a feature that is not yet implemented. If the tests succeed, a message will be printed notifying the developer that the tests are now ready to promote to actual use.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SPECIFYING THE TESTS</h2>
        <div class="sectioncontent">
<p>A series of tests can be specified in two different ways. The tests can be written in a very simple string format, or stored as a list.</p><p>Demonstrating how this can be done is best done by example, so let's say that there is a function (func) which takes two arguments, and returns a single value.  Let's say that the expected output (and the actual output) from 3 different sets of arguments is:</p><p>   Input   Expected Output  Actual Output    -----   ---------------  -------------    1,2     a                a    3,4     b                x    5,6     c                c</p><p>(so in this case, the first and third tests pass, but the 2nd one will fail).</p><p>Specifying these tests as lists could be done as:</p><p>   $o-&gt;tests(       func     =&gt; &func,       tests    =&gt; [ [1,2], [3,4], [5,6] ],       expected =&gt; [ [a],   [b],   [c] ],    );</p><p>Here, the tests are stored as a list, and each element in the list is a listref containing the set of arguments.</p><p>If the func option is not passed in, the tests option is set to a list of results to compare with the expected results, so the following is equivalent to the above:</p><p>   $o-&gt;tests(       tests    =&gt; [ [a],   [x],   [c] ],       expected =&gt; [ [a],   [b],   [c] ],    );</p><p>If an argument (or actual result) or an expected result is only a single value, it can be entered as a scalar instead of a list ref, so the following is also equivalent:</p><p>   $o-&gt;tests(       func     =&gt; &func,       tests    =&gt; [ [1,2], [3,4], [5,6] ],       expected =&gt; [ a,     b,     [c] ],    );</p><p>The only exception to this is if the single value is itself a list reference.  In this case it \s-1MUST\s0 be included as a reference. In other words, if you have a single test, and the expected value for this test is a list reference, it must be passed in as:</p><p>   expected =&gt; [ [ &#92;@r ] ]</p><p>\s-1NOT\s0 as:</p><p>   expected =&gt; [ &#92;@r ]</p><p>Passing in a set of expected results is optional. If none are passed in, the tests are treated as if they had been passed to the 'ok' method (i.e. if they return something true, they pass, otherwise they fail).</p><p>The second way to specify tests is as a string. The string is a multi-line string with each tests being separate from the next test by a blank line.  Comments (lines which begin with '#') are allowed, and are ignored. Whitespace at the start and end of the line is ignored.</p><p>The string may contain the results directly, or results may be passed in separately. For example, the following all give the same sets of tests as the example above:</p><p>   $o-&gt;tests(       func     =&gt; &func,       tests    =&gt; "                    # Test 1                    1 2 =&gt; a</p><p>                   # Test 2                    3 4 =&gt; b</p><p>                   5 6 =&gt; c                   ",    );</p><p>   $o-&gt;tests(       func     =&gt; &func,       tests    =&gt; "                    1 2</p><p>                   3 4</p><p>                   5 6                   ",        expected =&gt; [ [a], [b], [c] ]    );</p><p>   $o-&gt;tests(       func     =&gt; &func,       tests    =&gt; [ [1,2], [3,4], [5,6] ],       expected =&gt; "                    a</p><p>                   b</p><p>                   c                   ",    );</p><p>   $o-&gt;tests(       func     =&gt; &func,       tests    =&gt; "                    1 2</p><p>                   3 4</p><p>                   5 6                   ",       expected =&gt; "                    a</p><p>                   b</p><p>                   c                   ",    );</p><p>The expected results may also consist of only a single set of results (in this case, it must be passed in as a listref). In this case, all of the tests are expected to have the same results.</p><p>So, the following are equivalent:</p><p>   $o-&gt;tests(       func     =&gt; &func,       tests    =&gt; "                    1 2 =&gt; a b</p><p>                   3 4 =&gt; a b</p><p>                   5 6 =&gt; a b                   ",    );</p><p>   $o-&gt;tests(       func     =&gt; &func,       tests    =&gt; "                    1 2</p><p>                   3 4</p><p>                   5 6                   ",       expected  =&gt; [ [a, b] ],    );</p><p>   $o-&gt;tests(       func     =&gt; &func,       tests    =&gt; "                    1 2</p><p>                   3 4</p><p>                   5 6                   ",       expected  =&gt; "a b",    );</p><p>The number of expected values must either be 1 (i.e. all of the tests are expected to produce the same value) or exactly the same number as the number of tests.</p><p>The parser is actually quite powerful, and can handle multi-line tests, quoted strings, and nested data structures.</p><p>The test may be split across any number of lines, provided there is not a completely blank line (which signals the end of the test), so the following are eqivalent:</p><p>   tests =&gt; "a b c",    tests =&gt; "a b              c",</p><p>Arguments (or expected results) may include data structures. For example, the following are equivalent:</p><p>   tests =&gt; "[ a b ] { a 1 b 2 }"    tests =&gt; [ [ [a,b], { a=&gt;1, b=&gt;2 } ] ]</p><p>Whitespace is mostly optional, but there is one exception. An item must end with some kind of delimiter, so the following will fail:</p><p>   tests =&gt; "[a b][c d]"</p><p>The first element (the list ref [a b]) must be separated from the second element by the delimiter (which is whitespace in this case), so it must be written as:</p><p>   tests =&gt; "[a b] [c d]"</p><p>As already demonstrated, hashrefs and listrefs may be included and nested. Elements may also be included inside parens, but this is optional since all arguments and expected results are already treated as lists, so the following are equivalent:</p><p>   tests =&gt; "a b c"    tests =&gt; "(a b) c"</p><p>Although parens are optional, they may make things more readable, and allow you to use something other than whitespace as the delimiter.</p><p>If the character immediately following the opening paren, brace, or bracket is a punctuation mark, then it is used as the delimiter instead of whitespace. For example, the following are all equivalent:</p><p>   [ a b c ]    [a b c]    [, a,b,c ]    [, a, b, c ]</p><p>A delimiter is a single character, and the following may not be used as a delimiter:</p><p>   any opening/closing characters () [] {}    single or double quotes    alphanumeric characters    underscore</p><p>Whitespace (including newlines) around the delimiter is ignored, so the following is valid:</p><p>   [, a,       b,       c ]</p><p>Two delimiters next to each other or a trailing delimiter produce an empty string.</p><p>   "(,a,b,)" =&gt; (a, b, &apos;&apos;)    "(,a,,b)" =&gt; (a, &apos;&apos;, b)</p><p>Hashrefs may be specified by braces and the following are equivalent:</p><p>   { a 1 b 2 }    {, a,1,b,2 }    {, a,1,b,2, }</p><p>Note that a trailing delimiter is ignored if there are already an even number of elements, or an empty string otherwise.</p><p>Nested structures are allowed:</p><p>   "[ [1 2] [3 4] ]"</p><p>For example,</p><p>   $o-&gt;tests(       func     =&gt; &func,       tests    =&gt; "a [ b c ] { d 1 e 2 } =&gt; x y"    );</p><p>is equivalent to:</p><p>   $o-&gt;tests(       func     =&gt; &func,       tests    =&gt; [ [a, [b,c], {d=&gt;1,e=&gt;2}] ],       results  =&gt; [ [x,y] ],    );</p><p>Any single value can be surrounded by single or double quotes in order to include the delimiter. So:</p><p>   "(, a,&apos;b,c&apos;,e )"</p><p>is equivalent to:</p><p>   "( a b,c e )"</p><p>Any single value can be the string '_\|_undef_\|_' which will be turned into an actual undef. If the value is '_\|_blank_\|_' it is turned into an empty string (''), though it can also be specified as '' directly. Any value can have an embedded newline by including a _\|_nl_\|_ in the value, but the value must be written on a single line.</p><p>Expected results are separated from arguments by ' =&gt; '.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">ENVIRONMENT VARIABLES</h2>
        <div class="sectioncontent">
<p>To summarize the information above, the following environment variables (and main:: variables) exist.  Each can be set in a perl script as a variable in the main namespace:</p><p>   $::TI_END</p><p>or as an environment variable:</p><p>   $ENV{TI_END}</p>
<dl class='dl-vertical'>
  <dt>
    \s-1TI_START\s0
  </dt>
  <dd>
    <p>Set this to define the test you want to start with. Example: If you have a perl test script (my_test_script) and you want to start running it at test 12, run the following shell commands:    TI_START=12    ./my_test_script.t</p>
  </dd>
  <dt>
    \s-1TI_END\s0
  </dt>
  <dd>
    <p>Set this to define the test you want to end with.</p>
  </dd>
  <dt>
    \s-1TI_TESTNUM\s0
  </dt>
  <dd>
    <p>Set this to run only a single test</p>
  </dd>
  <dt>
    \s-1TI_QUIET\s0
  </dt>
  <dd>
    <p>How verbose the test script is.</p>
  </dd>
  <dt>
    \s-1TI_MODE\s0
  </dt>
  <dd>
    <p>How the output is formatted.</p>
  </dd>
  <dt>
    \s-1TI_WIDTH\s0
  </dt>
  <dd>
    <p>The width of the terminal.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">HISTORY</h2>
        <div class="sectioncontent">
<p>The history of this module dates back to 1996 when I needed to write a test suite for my Date::Manip module. At that time, none of the Test::* modules currently available in \s-1CPAN\s0 existed (the earliest ones didn't come along until 1998), so I was left completely on my own writing my test scripts.</p><p>I wrote a very basic version of my test framework which allowed me to write all of the tests as a string, it would parse the string, count the tests, and then run them.</p><p>Over the years, the functionality I wanted grew, and periodically, I'd go back and reexamine other Test frameworks (primarily Test::More) to see if I could replace my framework with an existing module... and I've always found them wanting, and chosen to extend my existing framework instead.</p><p>As I've written other modules, I've wanted to use the framework in them too, so I've always just copied it in, but this is obviously tedious and error prone. I'm not sure why it took me so long... but in 2010, I finally decided it was time to rework the framework in a module form.</p><p>I loosely based my module on Test::More. I like the functionality of that module, and wanted most of it (and I plan on adding more in future versions).  So this module uses some similar syntax to Test::More (though it allows a great deal more flexibility in how the tests are specified).</p><p>One thing to note is that I may have been able to write this module as an extension to Test::More, but after looking into that possibility, I decided that it would be faster to not do that. I did \*(L"borrow\*(R" a couple of routines from it (though they've been modified quite heavily) as a starting point for a few of the functions in this module, and I thank the authors of Test::More for their work.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">KNOWN BUGS AND LIMITATIONS</h2>
        <div class="sectioncontent">
<p>None known.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Test::Inter&hellip;</h2>
        <div class="sectioncontent">
<p>Test::More - the 'industry standard' of perl test frameworks</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LICENSE</h2>
        <div class="sectioncontent">
<p>This script is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>Sullivan Beck (sbeck@cpan.org)</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Test::Inline::Section.3pm.html"><span aria-hidden="true">&larr;</span> Test::Inline::Section.3pm: Implements a section of tests</a></li>
   <li class="next"><a href="Test::JSON.3pm.html">Test::JSON.3pm: Test json data <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>optimization: Compiler optimization</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Compiler optimization">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="optimization (3avr) manual">
  <meta name="twitter:description" content="Compiler optimization">
  <meta name="twitter:image" content="https://www.carta.tech/images/avr-libc-optimization-3avr.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3avr/optimization.3avr.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="optimization (3avr) manual" />
  <meta property="og:description" content="Compiler optimization" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/avr-libc-optimization-3avr.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">optimization<small> (3avr)</small></h1>
        <p class="lead">Compiler optimization</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3avr/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3avr/optimization.3avr.html">
      <span itemprop="name">optimization: Compiler optimization</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/avr-libc/">
      <span itemprop="name">avr-libc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3avr/optimization.3avr.html">
      <span itemprop="name">optimization: Compiler optimization</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">Problems with reordering code</h2>
        <div class="sectioncontent">
<p><strong>Author:</strong></p><p>Jan Waclawek</p><p>Programs contain sequences of statements, and a naive compiler would execute them exactly in the order as they are written. But an optimizing compiler is free to <em>reorder</em> the statements - or even parts of them - if the resulting 'net effect' is the same. The 'measure' of the 'net effect' is what the standard calls 'side effects', and is accomplished exclusively through accesses (reads and writes) to variables qualified as volatile. So, as long as all volatile reads and writes are to the same addresses and in the same order (and writes write the same values), the program is correct, regardless of other operations in it. (One important point to note here is, that time duration between consecutive volatile accesses is not considered at all.)</p><p>Unfortunately, there are also operations which are not covered by volatile accesses. An example of this in avr-gcc/avr-libc are the <strong>cli()</strong> and <strong>sei()</strong> macros defined in &lt;<strong>avr/interrupt.h</strong>&gt;, which convert directly to the respective assembler mnemonics through the <strong>asm</strong>() statement. These don't constitute a variable access at all, not even volatile, so the compiler is free to move them around. Although there is a 'volatile' qualifier which can be attached to the <strong>asm</strong>() statement, its effect on (re)ordering is not clear from the documentation (and is more likely only to prevent complete removal by the optimiser), as it (among other) states:</p><p><em>Note that even a volatile asm instruction can be moved relative to other code, including across jump instructions. [...] Similarly, you can't expect a sequence of volatile asm instructions to remain perfectly consecutive.</em></p><p><strong>See also:</strong></p><p>http://gcc.gnu.org/onlinedocs/gcc-4.3.4/gcc/Extended-Asm.html</p><p>There is another mechanism which can be used to achieve something similar: <em>memory barriers</em>. This is accomplished through adding a special 'memory' clobber to the inline asm<em> statement, and ensures that all variables are flushed from registers to memory before the statement, and then re-read after the statement. The purpose of memory barriers is slightly different than to enforce code ordering: it is supposed to ensure that there are no variables 'cached' in registers, so that it is safe to change the content of registers e.g. when switching context in a multitasking OS (on 'big' processors with out-of-order execution they also imply usage of special instructions which force the processor into 'in-order' state (this is not the case of AVRs)).</em></p><p>However, memory barrier works well in ensuring that all volatile accesses before and after the barrier occur in the given order with respect to the barrier. However, it does not ensure the compiler moving non-volatile-related statements across the barrier. Peter Dannegger provided a nice example of this effect:</p>
<pre>
#define cli() __asm volatile( "cli" ::: "memory" )
#define sei() __asm volatile( "sei" ::: "memory" )

unsigned int ivar;

void test2( unsigned int val )
{
  val = 65535U / val;

  cli();

  ivar = val;

  sei();
}
</pre>
<p>compiles with optimisations switched on (-Os) to</p>
<pre>
00000112 &lt;test2&gt;:
 112:   bc 01           movw    r22, r24
 114:   f8 94           cli
 116:   8f ef           ldi     r24, 0xFF       ; 255
 118:   9f ef           ldi     r25, 0xFF       ; 255
 11a:   0e 94 96 00     call    0x12c   ; 0x12c &lt;__udivmodhi4&gt;
 11e:   70 93 01 02     sts     0x0201, r23
 122:   60 93 00 02     sts     0x0200, r22
 126:   78 94           sei
 128:   08 95           ret
</pre>
<p>where the potentially slow division is moved across <strong>cli()</strong>, resulting in interrupts to be disabled longer than intended. Note, that the volatile access occurs in order with respect to <strong>cli()</strong> or <strong>sei()</strong>; so the 'net effect' required by the standard is achieved as intended, it is 'only' the timing which is off. However, for most of embedded applications, timing is an important, sometimes critical factor.</p><p><strong>See also:</strong></p><p>https://www.mikrocontroller.net/topic/65923</p><p>Unfortunately, at the moment, in avr-gcc (nor in the C standard), there is no mechanism to enforce complete match of written and executed code ordering - except maybe of switching the optimization completely off (-O0), or writing all the critical code in assembly.</p><p>To sum it up:</p><ul>
<li><p>memory barriers ensure proper ordering of volatile accesses</p></li><li><p>memory barriers don't ensure statements with no volatile accesses to be reordered across the barrier</p></li>
</ul>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="modff.3avr.html"><span aria-hidden="true">&larr;</span> modff.3avr: Math.h: mathematics -</a></li>
   <li class="next"><a href="outb.3avr.html">outb.3avr: Compat/deprecated.h: deprecated items - <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

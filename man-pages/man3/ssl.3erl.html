<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ssl: Interface functions for secure socket layer</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Interface functions for secure socket layer">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="ssl (3erl) manual">
  <meta name="twitter:description" content="Interface functions for secure socket layer">
  <meta name="twitter:image" content="https://www.carta.tech/images/erlang-manpages-ssl-3erl.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3erl/ssl.3erl.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="ssl (3erl) manual" />
  <meta property="og:description" content="Interface functions for secure socket layer" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/erlang-manpages-ssl-3erl.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">ssl<small> (3erl)</small></h1>
        <p class="lead">Interface functions for secure socket layer</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/ssl.3erl.html">
      <span itemprop="name">ssl: Interface functions for secure socket layer</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/erlang-manpages/">
      <span itemprop="name">erlang-manpages</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/ssl.3erl.html">
      <span itemprop="name">ssl: Interface functions for secure socket layer</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module contains interface functions to the Secure Socket Layer.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SSL</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>ssl requires the crypto and public_key applications.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>Supported SSL/TLS-versions are SSL-3.0, TLS-1.0, TLS-1.1 and TLS-1.2.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>For security reasons sslv2 is not supported.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>Ephemeral Diffie-Hellman cipher suites are supported but not Diffie Hellman Certificates cipher suites.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>Elliptic Curve cipher suites are supported if crypto supports it and named curves are used.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>Export cipher suites are not supported as the U.S. lifted its export restrictions in early 2000.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>IDEA cipher suites are not supported as they have become deprecated by the latest TLS spec so there is not any real motivation to implement them.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>CRL and policy certificate extensions are not supported yet. However CRL verification is supported by public_key, only not integrated in ssl yet.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>Support for 'Server Name Indication' extension client side (RFC 6066 section 3).</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">COMMON DATA TYPES</h2>
        <div class="sectioncontent">
<p>The following data types are used in the functions below:</p><p><em>boolean() = true | false</em></p><p><em>option() = socketoption() | ssloption() | transportoption()</em></p><p><em>socketoption() = proplists:property() - The default socket options are [{mode,list},{packet, 0},{header, 0},{active, true}]. </em></p><p>For valid options see <strong>inet(3erl)</strong> and <strong>gen_tcp(3erl)</strong>.</p><p><em>ssloption() = {verify, verify_type()} | {verify_fun, {fun(), term()}} | {fail_if_no_peer_cert, boolean()} {depth, integer()} | {cert, der_encoded()}| {certfile, path()} | {key, {'RSAPrivateKey'| 'DSAPrivateKey' | 'ECPrivateKey' |'PrivateKeyInfo', der_encoded()}} | {keyfile, path()} | {password, string()} | {cacerts, [der_encoded()]} | {cacertfile, path()} | |{dh, der_encoded()} | {dhfile, path()} | {ciphers, ciphers()} | {user_lookup_fun, {fun(), term()}}, {psk_identity, string()}, {srp_identity, {string(), string()}} | {ssl_imp, ssl_imp()} | {reuse_sessions, boolean()} | {reuse_session, fun()} {next_protocols_advertised, [binary()]} | {client_preferred_next_protocols, {client | server, [binary()]} | {client | server, [binary()], binary()}} | {log_alert, boolean()} | {server_name_indication, hostname() | disable} </em></p><p><em>transportoption() = {cb_info, {CallbackModule::atom(), DataTag::atom(), ClosedTag::atom(), ErrTag:atom()}} - defaults to {gen_tcp, tcp, tcp_closed, tcp_error}. Can be used to customize the transport layer. The callback module must implement a reliable transport protocol and behave as gen_tcp and in addition have functions corresponding to inet:setopts/2, inet:getopts/2, inet:peername/1, inet:sockname/1 and inet:port/1. The callback gen_tcp is treated specially and will call inet directly. </em></p><p><em> CallbackModule = atom()</em></p><p><em> DataTag = atom() - tag used in socket data message.</em></p><p><em> ClosedTag = atom() - tag used in socket close message.</em></p><p><em>verify_type() = verify_none | verify_peer</em></p><p><em>path() = string() - representing a file path.</em></p><p><em>der_encoded() = binary() -Asn1 DER encoded entity as an erlang binary.</em></p><p><em>host() = hostname() | ipaddress()</em></p><p><em>hostname() = string()</em></p><p><em> ip_address() = {N1,N2,N3,N4} % IPv4 | {K1,K2,K3,K4,K5,K6,K7,K8} % IPv6 </em></p><p><em>sslsocket() - opaque to the user. </em></p><p><em>protocol() = tlsv1 | 'tlsv1.1' | 'tlsv1.2' </em></p><p><em>ciphers() = [ciphersuite()] | string() (according to old API)</em></p><p><em>ciphersuite() = {key_exchange(), cipher(), hash()}</em></p><p><em>key_exchange() = rsa | dhe_dss | dhe_rsa | dh_anon | psk | dhe_psk | rsa_psk | srp_anon | srp_dss | srp_rsa | ecdh_anon | ecdh_ecdsa | ecdhe_ecdsa | ecdh_rsa | ecdhe_rsa </em></p><p><em>cipher() = rc4_128 | des_cbc | '3des_ede_cbc' | aes_128_cbc | aes_256_cbc </em></p><p><em>hash() = md5 | sha </em></p><p><em>prf_random() = client_random | server_random </em></p><p><em>srp_param_type() = srp_1024 | srp_1536 | srp_2048 | srp_3072 | srp_4096 | srp_6144 | srp_8192</em></p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SSL OPTION DESCRIPTIONS - COMMON FOR SERVER AND CLIENT</h2>
        <div class="sectioncontent">
<p>Options described here are options that are have the same meaning in the client and the server.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{cert, der_encoded()}:  The DER encoded users certificate. If this option is supplied it will override the certfile option.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{certfile, path()}: Path to a file containing the user's certificate.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{key, {'RSAPrivateKey'| 'DSAPrivateKey' | 'ECPrivateKey' |'PrivateKeyInfo', der_encoded()}}:  The DER encoded users private key. If this option is supplied it will override the keyfile option.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{keyfile, path()}: Path to file containing user's private PEM encoded key. As PEM-files may contain several entries this option defaults to the same file as given by certfile option.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{password, string()}: String containing the user's password. Only used if the private keyfile is password protected.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{cacerts, [der_encoded()]}:  The DER encoded trusted certificates. If this option is supplied it will override the cacertfile option.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{ciphers, ciphers()}: The cipher suites that should be supported. The function <em>cipher_suites/0</em> can be used to find all ciphers that are supported by default. <em>cipher_suites(all)</em> may be called to find all available cipher suites. Pre-Shared Key (RFC 4279 and RFC 5487), Secure Remote Password (RFC 5054) and anonymous cipher suites only work if explicitly enabled by this option and they are supported/enabled by the peer also. Note that anonymous cipher suites are supported for testing purposes only and should not be used when security matters.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{ssl_imp, new | old}: No longer has any meaning as the old implementation has been removed, it will be ignored.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{secure_renegotiate, boolean()}: Specifies if to reject renegotiation attempt that does not live up to RFC 5746. By default secure_renegotiate is set to false i.e. secure renegotiation will be used if possible but it will fallback to unsecure renegotiation if the peer does not support RFC 5746.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{depth, integer()}:  The depth is the maximum number of non-self-issued intermediate certificates that may follow the peer certificate in a valid certification path. So if depth is 0 the PEER must be signed by the trusted ROOT-CA directly, if 1 the path can be PEER, CA, ROOT-CA, if it is 2 PEER, CA, CA, ROOT-CA and so on. The default value is 1.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{verify_fun, {Verifyfun :: fun(), InitialUserState :: term()}}: The verification fun should be defined as:</p>
  </dd>

</dl>

<pre>
fun(OtpCert :: #'OTPCertificate'{}, Event :: {bad_cert, Reason :: atom() | {revoked, atom()}} |
	     {extension, #'Extension'{}}, InitialUserState :: term()) -&gt;
	{valid, UserState :: term()} | {valid_peer, UserState :: term()} |
	{fail, Reason :: term()} | {unknown, UserState :: term()}.

</pre>
<p>The verify fun will be called during the X509-path validation when an error or an extension unknown to the ssl application is encountered. Additionally it will be called when a certificate is considered valid by the path validation to allow access to each certificate in the path to the user application. Note that it will differentiate between the peer certificate and CA certificates by using valid_peer or valid as the second argument to the verify fun. See <strong>the public_key User's Guide</strong> for definition of #'OTPCertificate'{} and #'Extension'{}.</p><p>If the verify callback fun returns {fail, Reason}, the verification process is immediately stopped and an alert is sent to the peer and the TLS/SSL handshake is terminated. If the verify callback fun returns {valid, UserState}, the verification process is continued. If the verify callback fun always returns {valid, UserState}, the TLS/SSL handshake will not be terminated with respect to verification failures and the connection will be established. If called with an extension unknown to the user application, the return value {unknown, UserState} should be used.</p><p>The default verify_fun option in verify_peer mode:</p>
<pre>
{fun(_,{bad_cert, _} = Reason, _) -&gt;
	 {fail, Reason};
    (_,{extension, _}, UserState) -&gt;
	 {unknown, UserState};
    (_, valid, UserState) -&gt;
	 {valid, UserState};
    (_, valid_peer, UserState) -&gt;
         {valid, UserState}
 end, []}

</pre>
<p>The default verify_fun option in verify_none mode:</p>
<pre>
{fun(_,{bad_cert, _}, UserState) -&gt;
	 {valid, UserState};
    (_,{extension, _}, UserState) -&gt;
	 {unknown, UserState};
    (_, valid, UserState) -&gt;
	 {valid, UserState};
    (_, valid_peer, UserState) -&gt;
         {valid, UserState}
 end, []}

</pre>
<p>Possible path validation errors are given on the form {bad_cert, Reason} where Reason is:</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>unknown_ca: No trusted CA was found in the trusted store. The trusted CA is normally a so called ROOT CA that is a self-signed cert. Trust may be claimed for an intermediat CA (trusted anchor does not have to be self signed according to X-509) by using the option <em>partial_chain</em></p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>selfsigned_peer: The chain consisted only of one self-signed certificate.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>PKIX X-509-path validation error:  Possible such reasons see <strong> public_key:pkix_path_validation/3 </strong></p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{partial_chain, fun(Chain::[DerCert]) -&gt; {trusted_ca, DerCert} | unknown_ca :  Claim an intermediat CA in the chain as trusted. TLS will then perform the public_key:pkix_path_validation/3 with the selected CA as trusted anchor and the rest of the chain.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{versions, [protocol()]}: TLS protocol versions that will be supported by started clients and servers. This option overrides the application environment option <em>protocol_version</em>. If the environment option is not set it defaults to all versions supported by the SSL application. See also <a href="../man7/ssl.7.html"><strong>ssl</strong>(7)</a></strong></p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{hibernate_after, integer()|undefined}: When an integer-value is specified, the <em>ssl_connection</em> will go into hibernation after the specified number of milliseconds of inactivity, thus reducing its memory footprint. When <em>undefined</em> is specified (this is the default), the process will never go into hibernation.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{user_lookup_fun, {Lookupfun :: fun(), UserState :: term()}}: The lookup fun should be defined as:</p>
  </dd>

</dl>

<pre>
fun(psk, PSKIdentity ::string(), UserState :: term()) -&gt;
	{ok, SharedSecret :: binary()} | error;
fun(srp, Username :: string(), UserState :: term()) -&gt;
	{ok, {SRPParams :: srp_param_type(), Salt :: binary(), DerivedKey :: binary()}} | error.

</pre>
<p>For Pre-Shared Key (PSK) cipher suites, the lookup fun will be called by the client and server to determine the shared secret. When called by the client, PSKIdentity will be set to the hint presented by the server or undefined. When called by the server, PSKIdentity is the identity presented by the client.</p><p>For Secure Remote Password (SRP), the fun will only be used by the server to obtain parameters that it will use to generate its session keys. <em>DerivedKey</em> should be derived according to  RFC 2945 and  RFC 5054: <em>crypto:sha([Salt, crypto:sha([Username, &lt;&lt;$:&gt;&gt;, Password])]) </em></p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{padding_check, boolean()}: This option only affects TLS-1.0 connections. If set to false it disables the block cipher padding check to be able to interoperate with legacy software.</p>
  </dd>

</dl>
<p><strong></strong> Warning:</p><p>Using this option makes TLS vulnerable to the Poodle attack</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SSL OPTION DESCRIPTIONS - CLIENT SIDE</h2>
        <div class="sectioncontent">
<p>Options described here are client specific or has a slightly different meaning in the client than in the server.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{verify, verify_type()}:  In verify_none mode the default behavior will be to allow all x509-path validation errors. See also the verify_fun option.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{reuse_sessions, boolean()}: Specifies if client should try to reuse sessions when possible.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{cacertfile, path()}: The path to a file containing PEM encoded CA certificates. The CA certificates are used during server authentication and when building the client certificate chain.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{client_preferred_next_protocols, {Precedence :: server | client, ClientPrefs :: [binary()]}}:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{client_preferred_next_protocols, {Precedence :: server | client, ClientPrefs :: [binary()], Default :: binary()}}: Indicates the client will try to perform Next Protocol Negotiation.</p><p>If precedence is server the negotiated protocol will be the first protocol that appears on the server advertised list that is also on the client preference list.</p><p>If precedence is client the negotiated protocol will be the first protocol that appears on the client preference list that is also on the server advertised list.</p><p>If the client does not support any of the server advertised protocols or the server does not advertise any protocols the client will fallback to the first protocol in its list or if a default is supplied it will fallback to that instead. If the server does not support Next Protocol Negotiation the connection will be aborted if no default protocol is supplied.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{psk_identity, string()}: Specifies the identity the client presents to the server. The matching secret is found by calling the user_look_fun.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{srp_identity, {Username :: string(), Password :: string()}: Specifies the Username and Password to use to authenticate to the server.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{server_name_indication, hostname()}:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{server_name_indication, disable}: This option can be specified when upgrading a TCP socket to a TLS socket to use the TLS Server Name Indication extension.</p><p>When starting a TLS connection without upgrade the Server Name Indication extension will be sent if possible, this option may also be used to disable that behavior.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SSL OPTION DESCRIPTIONS - SERVER SIDE</h2>
        <div class="sectioncontent">
<p>Options described here are server specific or has a slightly different meaning in the server than in the client.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{cacertfile, path()}: The path to a file containing PEM encoded CA certificates. The CA certificates are used to build the server certificate chain, and for client authentication. Also the CAs are used in the list of acceptable client CAs passed to the client when a certificate is requested. May be omitted if there is no need to verify the client and if there are not any intermediate CAs for the server certificate.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{dh, der_encoded()}: The DER encoded Diffie Hellman parameters. If this option is supplied it will override the dhfile option.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{dhfile, path()}: Path to file containing PEM encoded Diffie Hellman parameters, for the server to use if a cipher suite using Diffie Hellman key exchange is negotiated. If not specified default parameters will be used.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{verify, verify_type()}: Servers only do the x509-path validation in verify_peer mode, as it then will send a certificate request to the client (this message is not sent if the verify option is verify_none) and you may then also want to specify the option fail_if_no_peer_cert.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{fail_if_no_peer_cert, boolean()}: Used together with {verify, verify_peer} by an ssl server. If set to true, the server will fail if the client does not have a certificate to send, i.e. sends a empty certificate, if set to false it will only fail if the client sends an invalid certificate (an empty certificate is considered valid).</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{reuse_sessions, boolean()}: Specifies if the server should agree to reuse sessions when the clients request to do so. See also the reuse_session option.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{reuse_session, fun(SuggestedSessionId, PeerCert, Compression, CipherSuite) -&gt; boolean()}: Enables the ssl server to have a local policy for deciding if a session should be reused or not, only meaningful if <em>reuse_sessions</em> is set to true. SuggestedSessionId is a binary(), PeerCert is a DER encoded certificate, Compression is an enumeration integer and CipherSuite is of type ciphersuite().</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{next_protocols_advertised, Protocols :: [binary()]}: The list of protocols to send to the client if the client indicates it supports the Next Protocol extension. The client may select a protocol that is not on this list. The list of protocols must not contain an empty binary. If the server negotiates a Next Protocol it can be accessed using <em>negotiated_next_protocol/1</em> method.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{psk_identity, string()}: Specifies the server identity hint the server presents to the client.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{log_alert, boolean()}: If false, error reports will not be displayed.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p>{honor_cipher_order, boolean()}: If true, use the server's preference for cipher selection. If false (the default), use the client's preference.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">GENERAL</h2>
        <div class="sectioncontent">
<p>When an ssl socket is in active mode (the default), data from the socket is delivered to the owner of the socket in the form of messages:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>{ssl, Socket, Data}</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>{ssl_closed, Socket}</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p> {ssl_error, Socket, Reason}</p>
  </dd>

</dl>
<p>A <em>Timeout</em> argument specifies a timeout in milliseconds. The default value for a <em>Timeout</em> argument is <em>infinity</em>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">
<p><strong></strong> cipher_suites() -&gt;</p><p><strong></strong> cipher_suites(Type) -&gt; ciphers()</p><p>Types:</p><p>Type = erlang | openssl | all</p><p>Returns a list of supported cipher suites. cipher_suites() is equivalent to cipher_suites(erlang). Type openssl is provided for backwards compatibility with old ssl that used openssl. cipher_suites(all) returns all available cipher suites. The cipher suites not present in cipher_suites(erlang) but in included in cipher_suites(all) will not be used unless explicitly configured by the user.</p><p><strong></strong> connect(Socket, SslOptions) -&gt;</p><p><strong></strong> connect(Socket, SslOptions, Timeout) -&gt; {ok, SslSocket} | {error, Reason}</p><p>Types:</p><p>Socket = socket()</p><p>SslOptions = [ssloption()]</p><p>Timeout = integer() | infinity</p><p>SslSocket = sslsocket()</p><p>Reason = term()</p><p>Upgrades a gen_tcp, or equivalent, connected socket to an ssl socket i.e. performs the client-side ssl handshake.</p><p><strong></strong> connect(Host, Port, Options) -&gt;</p><p><strong></strong> connect(Host, Port, Options, Timeout) -&gt; {ok, SslSocket} | {error, Reason}</p><p>Types:</p><p>Host = host()</p><p>Port = integer()</p><p>Options = [option()]</p><p>Timeout = integer() | infinity</p><p>SslSocket = sslsocket()</p><p>Reason = term()</p><p>Opens an ssl connection to Host, Port.</p><p><strong></strong> close(SslSocket) -&gt; ok | {error, Reason}</p><p>Types:</p><p>SslSocket = sslsocket()</p><p>Reason = term()</p><p>Close an ssl connection.</p><p><strong></strong> controlling_process(SslSocket, NewOwner) -&gt; ok | {error, Reason}</p><p>Types:</p><p>SslSocket = sslsocket()</p><p>NewOwner = pid()</p><p>Reason = term()</p><p>Assigns a new controlling process to the ssl-socket. A controlling process is the owner of an ssl-socket, and receives all messages from the socket.</p><p><strong></strong> connection_info(SslSocket) -&gt; {ok, {ProtocolVersion, CipherSuite}} | {error, Reason}</p><p>Types:</p><p>CipherSuite = ciphersuite()</p><p>ProtocolVersion = protocol()</p><p>Returns the negotiated protocol version and cipher suite.</p><p><strong></strong> format_error(Reason) -&gt; string()</p><p>Types:</p><p>Reason = term()</p><p>Presents the error returned by an ssl function as a printable string.</p><p><strong></strong> getopts(Socket, OptionNames) -&gt; {ok, [socketoption()]} | {error, Reason}</p><p>Types:</p><p>Socket = sslsocket()</p><p>OptionNames = [atom()]</p><p>Get the value of the specified socket options.</p><p><strong></strong> listen(Port, Options) -&gt; {ok, ListenSocket} | {error, Reason}</p><p>Types:</p><p>Port = integer()</p><p>Options = options()</p><p>ListenSocket = sslsocket()</p><p>Creates an ssl listen socket.</p><p><strong></strong> peercert(Socket) -&gt; {ok, Cert} | {error, Reason}</p><p>Types:</p><p>Socket = sslsocket()</p><p>Cert = binary()</p><p>The peer certificate is returned as a DER encoded binary. The certificate can be decoded with <em>public_key:pkix_decode_cert/2</em>.</p><p><strong></strong> peername(Socket) -&gt; {ok, {Address, Port}} | {error, Reason}</p><p>Types:</p><p>Socket = sslsocket()</p><p>Address = ipaddress()</p><p>Port = integer()</p><p>Returns the address and port number of the peer.</p><p><strong></strong> recv(Socket, Length) -&gt;</p><p><strong></strong> recv(Socket, Length, Timeout) -&gt; {ok, Data} | {error, Reason}</p><p>Types:</p><p>Socket = sslsocket()</p><p>Length = integer()</p><p>Timeout = integer()</p><p>Data = [char()] | binary()</p><p>This function receives a packet from a socket in passive mode. A closed socket is indicated by a return value <em>{error, closed}</em>.</p><p>The <em>Length</em> argument is only meaningful when the socket is in <em>raw</em> mode and denotes the number of bytes to read. If <em>Length</em> = 0, all available bytes are returned. If <em>Length</em> &gt; 0, exactly <em>Length</em> bytes are returned, or an error; possibly discarding less than <em>Length</em> bytes of data when the socket gets closed from the other side.</p><p>The optional <em>Timeout</em> parameter specifies a timeout in milliseconds. The default value is <em>infinity</em>.</p><p><strong></strong> prf(Socket, Secret, Label, Seed, WantedLength) -&gt; {ok, binary()} | {error, reason()}</p><p>Types:</p><p>Socket = sslsocket()</p><p>Secret = binary() | master_secret</p><p>Label = binary()</p><p>Seed = [binary() | prf_random()]</p><p>WantedLength = non_neg_integer()</p><p>Use the pseudo random function (PRF) of a TLS session to generate additional key material. It either takes user generated values for <em>Secret</em> and <em>Seed</em> or atoms directing it use a specific value from the session security parameters.</p><p>This function can only be used with TLS connections, <em>{error, undefined}</em> is returned for SSLv3 connections.</p><p><strong></strong> renegotiate(Socket) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Socket = sslsocket()</p><p>Initiates a new handshake. A notable return value is <em>{error, renegotiation_rejected}</em> indicating that the peer refused to go through with the renegotiation but the connection is still active using the previously negotiated session.</p><p><strong></strong> send(Socket, Data) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Socket = sslsocket()</p><p>Data = iodata()</p><p>Writes <em>Data</em> to <em>Socket</em>.</p><p>A notable return value is <em>{error, closed}</em> indicating that the socket is closed.</p><p><strong></strong> setopts(Socket, Options) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Socket = sslsocket()</p><p>Options = [socketoption]()</p><p>Sets options according to <em>Options</em> for the socket <em>Socket</em>.</p><p><strong></strong> shutdown(Socket, How) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Socket = sslsocket()</p><p>How = read | write | read_write</p><p>Reason = reason()</p><p>Immediately close a socket in one or two directions.</p><p><em>How == write</em> means closing the socket for writing, reading from it is still possible.</p><p>To be able to handle that the peer has done a shutdown on the write side, the <em>{exit_on_close, false}</em> option is useful.</p><p><strong></strong> ssl_accept(Socket) -&gt;</p><p><strong></strong> ssl_accept(Socket, Timeout) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Socket = sslsocket()</p><p>Timeout = integer()</p><p>Reason = term()</p><p>Performs the SSL/TLS server-side handshake <em>Socket</em> is a socket as returned by <strong>ssl:transport_accept/[1,2]</strong></p><p><strong></strong> ssl_accept(Socket, SslOptions) -&gt;</p><p><strong></strong> ssl_accept(Socket, SslOptions, Timeout) -&gt; {ok, Socket} | ok | {error, Reason}</p><p>Types:</p><p>Socket = socket() | sslsocket()</p><p>SslOptions = ssloptions()</p><p>Timeout = integer()</p><p>Reason = term()</p><p>If <em>Socket</em> is a socket() - upgrades a gen_tcp, or equivalent, socket to an ssl socket i.e. performs the SSL/TLS server-side handshake and returns the ssl socket.</p><p><strong></strong> Warning:</p><p>Note that the listen socket should be in {active, false} mode before telling the client that the server is ready to upgrade by calling this function, otherwise the upgrade may or may not succeed depending on timing.</p><p>If <em>Socket</em> is an sslsocket() - provides additional SSL/TLS options to those specified in <strong>ssl:listen/2 </strong> and then performs the SSL/TLS handshake.</p><p><strong></strong> sockname(Socket) -&gt; {ok, {Address, Port}} | {error, Reason}</p><p>Types:</p><p>Socket = sslsocket()</p><p>Address = ipaddress()</p><p>Port = integer()</p><p>Returns the local address and port number of the socket <em>Socket</em>.</p><p><strong></strong> start() -&gt;</p><p><strong></strong> start(Type) -&gt; ok | {error, Reason}</p><p>Types:</p><p>Type = permanent | transient | temporary</p><p>Starts the Ssl application. Default type is temporary. <strong>application(3erl)</strong></p><p><strong></strong> stop() -&gt; ok</p><p>Stops the Ssl application. <strong>application(3erl)</strong></p><p><strong></strong> transport_accept(ListenSocket) -&gt;</p><p><strong></strong> transport_accept(ListenSocket, Timeout) -&gt; {ok, NewSocket} | {error, Reason}</p><p>Types:</p><p>ListenSocket = NewSocket = sslsocket()</p><p>Timeout = integer()</p><p>Reason = reason()</p><p>Accepts an incoming connection request on a listen socket. <em>ListenSocket</em> must be a socket returned from <strong> ssl:listen/2</strong>. The socket returned should be passed to <strong> ssl:ssl_accept[2,3]</strong> to complete handshaking i.e establishing the SSL/TLS connection.</p><p><strong></strong> Warning:</p><p>The socket returned can only be used with <strong> ssl:ssl_accept[2,3]</strong> no traffic can be sent or received before that call.</p><p>The accepted socket inherits the options set for <em>ListenSocket</em> in <strong> ssl:listen/2</strong>.</p><p>The default value for <em>Timeout</em> is <em>infinity</em>. If <em>Timeout</em> is specified, and no connection is accepted within the given time, <em>{error, timeout}</em> is returned.</p><p><strong></strong> versions() -&gt; [{SslAppVer, SupportedSslVer, AvailableSslVsn}]</p><p>Types:</p><p>SslAppVer = string()</p><p>SupportedSslVer = [protocol()]</p><p>AvailableSslVsn = [protocol()]</p><p>Returns version information relevant for the ssl application.</p><p><strong></strong> negotiated_next_protocol(Socket) -&gt; {ok, Protocol} | {error, next_protocol_not_negotiated}</p><p>Types:</p><p>Socket = sslsocket()</p><p>Protocol = binary()</p><p>Returns the Next Protocol negotiated.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO ssl&hellip;</h2>
        <div class="sectioncontent">
<p><strong>inet(3erl) </strong> and <strong>gen_tcp(3erl) </strong></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="ssh_sftpd.3erl.html"><span aria-hidden="true">&larr;</span> ssh_sftpd.3erl: Specifies the channel process to handle an sftp subsystem.</a></li>
   <li class="next"><a href="ssl_session_cache_api.3erl.html">ssl_session_cache_api.3erl: Defines the api for the tls session cache so <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

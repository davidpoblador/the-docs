<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>global: A global name registration facility</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="A global name registration facility">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="global (3erl) manual">
  <meta name="twitter:description" content="A global name registration facility">
  <meta name="twitter:image" content="https://www.carta.tech/images/erlang-manpages-global-3erl.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3erl/global.3erl.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="global (3erl) manual" />
  <meta property="og:description" content="A global name registration facility" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/erlang-manpages-global-3erl.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">global<small> (3erl)</small></h1>
        <p class="lead">A global name registration facility</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/global.3erl.html">
      <span itemprop="name">global: A global name registration facility</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/erlang-manpages/">
      <span itemprop="name">erlang-manpages</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/global.3erl.html">
      <span itemprop="name">global: A global name registration facility</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This documentation describes the Global module which consists of the following functionalities:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>registration of global names;</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>global locks;</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>maintenance of the fully connected network.</p>
  </dd>

</dl>
<p>These services are controlled via the process <em>global_name_server</em> which exists on every node. The global name server is started automatically when a node is started. With the term <em>global</em> is meant over a system consisting of several Erlang nodes.</p><p>The ability to globally register names is a central concept in the programming of distributed Erlang systems. In this module, the equivalent of the <em>register/2</em> and <em>whereis/1</em> BIFs (for local name registration) are implemented, but for a network of Erlang nodes. A registered name is an alias for a process identifier (pid). The global name server monitors globally registered pids. If a process terminates, the name will also be globally unregistered.</p><p>The registered names are stored in replica global name tables on every node. There is no central storage point. Thus, the translation of a name to a pid is fast, as it is always done locally. When any action in taken which results in a change to the global name table, all tables on other nodes are automatically updated.</p><p>Global locks have lock identities and are set on a specific resource. For instance, the specified resource could be a pid. When a global lock is set, access to the locked resource is denied for all other resources other than the lock requester.</p><p>Both the registration and lock functionalities are atomic. All nodes involved in these actions will have the same view of the information.</p><p>The global name server also performs the critical task of continuously monitoring changes in node configuration: if a node which runs a globally registered process goes down, the name will be globally unregistered. To this end the global name server subscribes to <em>nodeup</em> and <em>nodedown</em> messages sent from the <em>net_kernel</em> module. Relevant Kernel application variables in this context are <em>net_setuptime</em>, <em>net_ticktime</em>, and <em>dist_auto_connect</em>. See also <a href="../man7/kernel.7.html"><strong>kernel</strong>(7)</a></strong>.</p><p>The name server will also maintain a fully connected network. For example, if node <em>N1</em> connects to node <em>N2</em> (which is already connected to <em>N3</em>), the global name servers on the nodes <em>N1</em> and <em>N3</em> will make sure that also <em>N1</em> and <em>N3</em> are connected. If this is not desired, the command line flag <em>-connect_all false</em> can be used (see also <a href="../man1/erl.1.html"><strong>erl</strong>(1)</a></strong>). In this case the name registration facility cannot be used, but the lock mechanism will still work.</p><p>If the global name server fails to connect nodes (<em>N1</em> and <em>N3</em> in the example above) a warning event is sent to the error logger. The presence of such an event does not exclude the possibility that the nodes will later connect--one can for example try the command <em>rpc:call(N1, net_adm, ping, [N2])</em> in the Erlang shell--but it indicates some kind of problem with the network.</p><p><strong></strong> Note:</p><p>If the fully connected network is not set up properly, the first thing to try is to increase the value of <em>net_setuptime</em>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DATA TYPES</h2>
        <div class="sectioncontent">

<pre>
<strong>id()</strong> = {ResourceId :: term(), LockRequesterId :: term()}

</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">

<pre>
<strong></strong>
del_lock(Id) -&gt; true

</pre>

<pre>
<strong></strong>
del_lock(Id, Nodes) -&gt; true

</pre>
<p>Types:</p><p>Id = <strong>id()</strong></p><p>Nodes = [node()]</p><p>Deletes the lock <em>Id</em> synchronously.</p>
<pre>
<strong></strong>
notify_all_name(Name, Pid1, Pid2) -&gt; none

</pre>
<p>Types:</p><p>Name = term()</p><p>Pid1 = Pid2 = pid()</p><p>This function can be used as a name resolving function for <em>register_name/3</em> and <em>re_register_name/3</em>. It unregisters both pids, and sends the message <em>{global_name_conflict, Name, OtherPid}</em> to both processes.</p>
<pre>
<strong></strong>
random_exit_name(Name, Pid1, Pid2) -&gt; pid()

</pre>
<p>Types:</p><p>Name = term()</p><p>Pid1 = Pid2 = pid()</p><p>This function can be used as a name resolving function for <em>register_name/3</em> and <em>re_register_name/3</em>. It randomly chooses one of the pids for registration and kills the other one.</p>
<pre>
<strong></strong>
random_notify_name(Name, Pid1, Pid2) -&gt; pid()

</pre>
<p>Types:</p><p>Name = term()</p><p>Pid1 = Pid2 = pid()</p><p>This function can be used as a name resolving function for <em>register_name/3</em> and <em>re_register_name/3</em>. It randomly chooses one of the pids for registration, and sends the message <em>{global_name_conflict, Name}</em> to the other pid.</p>
<pre>
<strong></strong>
register_name(Name, Pid) -&gt; yes | no

</pre>

<pre>
<strong></strong>
register_name(Name, Pid, Resolve) -&gt; yes | no

</pre>
<p>Types:</p><p>Name = term()</p><p>Pid = pid()</p><p>Resolve = <strong>method()</strong></p>
<pre>
<strong>method()</strong> =

    fun((Name :: term(), Pid :: pid(), Pid2 :: pid()) -&gt;

            pid() | none)
</pre>
<p>{<em>Module</em>, <em>Function</em>} is currently also allowed for backward compatibility, but its use is deprecated</p><p>Globally associates the name <em>Name</em> with a pid, that is, Globally notifies all nodes of a new global name in a network of Erlang nodes.</p><p>When new nodes are added to the network, they are informed of the globally registered names that already exist. The network is also informed of any global names in newly connected nodes. If any name clashes are discovered, the <em>Resolve</em> function is called. Its purpose is to decide which pid is correct. If the function crashes, or returns anything other than one of the pids, the name is unregistered. This function is called once for each name clash.</p><p><strong></strong> Warning:</p><p>If you plan to change code without restarting your system, you must use an external fun (<em>fun Module:Function/Arity</em>) as the <em>Resolve</em> function; if you use a local fun you can never replace the code for the module that the fun belongs to.</p><p>There are three pre-defined resolve functions: <em>random_exit_name/3</em>, <em>random_notify_name/3</em>, and <em>notify_all_name/3</em>. If no <em>Resolve</em> function is defined, <em>random_exit_name</em> is used. This means that one of the two registered processes will be selected as correct while the other is killed.</p><p>This function is completely synchronous. This means that when this function returns, the name is either registered on all nodes or none.</p><p>The function returns <em>yes</em> if successful, <em>no</em> if it fails. For example, <em>no</em> is returned if an attempt is made to register an already registered process or to register a process with a name that is already in use.</p><p><strong></strong> Note:</p><p>Releases up to and including OTP R10 did not check if the process was already registered. As a consequence the global name table could become inconsistent. The old (buggy) behavior can be chosen by giving the Kernel application variable <em>global_multi_name_action</em> the value <em>allow</em>.</p><p>If a process with a registered name dies, or the node goes down, the name is unregistered on all nodes.</p>
<pre>
<strong></strong>
registered_names() -&gt; [Name]

</pre>
<p>Types:</p><p>Name = term()</p><p>Returns a lists of all globally registered names.</p>
<pre>
<strong></strong>
re_register_name(Name, Pid) -&gt; yes

</pre>

<pre>
<strong></strong>
re_register_name(Name, Pid, Resolve) -&gt; yes

</pre>
<p>Types:</p><p>Name = term()</p><p>Pid = pid()</p><p>Resolve = <strong>method()</strong></p>
<pre>
<strong>method()</strong> =

    fun((Name :: term(), Pid :: pid(), Pid2 :: pid()) -&gt;

            pid() | none)
</pre>
<p>{<em>Module</em>, <em>Function</em>} is also allowed</p><p>Atomically changes the registered name <em>Name</em> on all nodes to refer to <em>Pid</em>.</p><p>The <em>Resolve</em> function has the same behavior as in <em>register_name/2,3</em>.</p>
<pre>
<strong></strong>
send(Name, Msg) -&gt; Pid

</pre>
<p>Types:</p><p>Name = Msg = term()</p><p>Pid = pid()</p><p>Sends the message <em>Msg</em> to the pid globally registered as <em>Name</em>.</p><p>Failure: If <em>Name</em> is not a globally registered name, the calling function will exit with reason <em>{badarg, {Name, Msg}}</em>.</p>
<pre>
<strong></strong>
set_lock(Id) -&gt; boolean()

</pre>

<pre>
<strong></strong>
set_lock(Id, Nodes) -&gt; boolean()

</pre>

<pre>
<strong></strong>
set_lock(Id, Nodes, Retries) -&gt; boolean()

</pre>
<p>Types:</p><p>Id = <strong>id()</strong></p><p>Nodes = [node()]</p><p>Retries = <strong>retries()</strong></p>
<pre>
<strong>id()</strong> = {ResourceId :: term(), LockRequesterId :: term()}
</pre>

<pre>
<strong>retries()</strong> = integer() &gt;= 0 | infinity
</pre>
<p>Sets a lock on the specified nodes (or on all nodes if none are specified) on <em>ResourceId</em> for <em>LockRequesterId</em>. If a lock already exists on <em>ResourceId</em> for another requester than <em>LockRequesterId</em>, and <em>Retries</em> is not equal to 0, the process sleeps for a while and will try to execute the action later. When <em>Retries</em> attempts have been made, <em>false</em> is returned, otherwise <em>true</em>. If <em>Retries</em> is <em>infinity</em>, <em>true</em> is eventually returned (unless the lock is never released).</p><p>If no value for <em>Retries</em> is given, <em>infinity</em> is used.</p><p>This function is completely synchronous.</p><p>If a process which holds a lock dies, or the node goes down, the locks held by the process are deleted.</p><p>The global name server keeps track of all processes sharing the same lock, that is, if two processes set the same lock, both processes must delete the lock.</p><p>This function does not address the problem of a deadlock. A deadlock can never occur as long as processes only lock one resource at a time. But if some processes try to lock two or more resources, a deadlock may occur. It is up to the application to detect and rectify a deadlock.</p><p><strong></strong> Note:</p><p>Some values of <em>ResourceId</em> should be avoided or Erlang/OTP will not work properly. A list of resources to avoid: <em>global</em>, <em>dist_ac</em>, <em>mnesia_table_lock</em>, <em>mnesia_adjust_log_writes</em>, <em>pg2</em>.</p>
<pre>
<strong></strong>
sync() -&gt; ok | {error, Reason :: term()}

</pre>
<p>Synchronizes the global name server with all nodes known to this node. These are the nodes which are returned from <em>erlang:nodes()</em>. When this function returns, the global name server will receive global information from all nodes. This function can be called when new nodes are added to the network.</p><p>The only possible error reason <em>Reason</em> is <em>{"global_groups definition error", Error}</em>.</p>
<pre>
<strong></strong>
trans(Id, Fun) -&gt; Res | aborted

</pre>

<pre>
<strong></strong>
trans(Id, Fun, Nodes) -&gt; Res | aborted

</pre>

<pre>
<strong></strong>
trans(Id, Fun, Nodes, Retries) -&gt; Res | aborted

</pre>
<p>Types:</p><p>Id = <strong>id()</strong></p><p>Fun = <strong>trans_fun()</strong></p><p>Nodes = [node()]</p><p>Retries = <strong>retries()</strong></p><p>Res = term()</p>
<pre>
<strong>retries()</strong> = integer() &gt;= 0 | infinity
</pre>

<pre>
<strong>trans_fun()</strong> = function() | {module(), atom()}
</pre>
<p>Sets a lock on <em>Id</em> (using <em>set_lock/3</em>). If this succeeds, <em>Fun()</em> is evaluated and the result <em>Res</em> is returned. Returns <em>aborted</em> if the lock attempt failed. If <em>Retries</em> is set to <em>infinity</em>, the transaction will not abort.</p><p><em>infinity</em> is the default setting and will be used if no value is given for <em>Retries</em>.</p>
<pre>
<strong></strong>
unregister_name(Name) -&gt; term()

</pre>
<p>Types:</p><p>Name = term()</p><p>Removes the globally registered name <em>Name</em> from the network of Erlang nodes.</p>
<pre>
<strong></strong>
whereis_name(Name) -&gt; pid() | undefined

</pre>
<p>Types:</p><p>Name = term()</p><p>Returns the pid with the globally registered name <em>Name</em>. Returns <em>undefined</em> if the name is not globally registered.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO global&hellip;</h2>
        <div class="sectioncontent">
<p><strong>global_group(3erl)</strong>, <strong>net_kernel(3erl)</strong></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="gl.3erl.html"><span aria-hidden="true">&larr;</span> gl.3erl: Standard opengl api.</a></li>
   <li class="next"><a href="global_group.3erl.html">global_group.3erl: Grouping nodes to global name registration groups <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

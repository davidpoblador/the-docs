<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Expect: Expect for perl</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Expect for perl">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Expect (3pm) manual">
  <meta name="twitter:description" content="Expect for perl">
  <meta name="twitter:image" content="https://www.carta.tech/images/libexpect-perl-Expect-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Expect.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Expect (3pm) manual" />
  <meta property="og:description" content="Expect for perl" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libexpect-perl-Expect-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Expect<small> (3pm)</small></h1>
        <p class="lead">Expect for perl</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Expect.3pm.html">
      <span itemprop="name">Expect: Expect for perl</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libexpect-perl/">
      <span itemprop="name">libexpect-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Expect.3pm.html">
      <span itemprop="name">Expect: Expect for perl</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">VERSION</h2>
        <div class="sectioncontent">
<p>1.21</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
  use Expect;

  # create an Expect object by spawning another process
  my $exp = Expect-&gt;spawn($command, @params)
    or die "Cannot spawn $command: $!&#92;n";

  # or by using an already opened filehandle (e.g. from Net::Telnet)
  my $exp = Expect-&gt;exp_init(&#92;*FILEHANDLE);

  # if you prefer the OO mindset:
  my $exp = new Expect;
  $exp-&gt;<strong>raw_pty</strong>(1);
  $exp-&gt;spawn($command, @parameters)
    or die "Cannot spawn $command: $!&#92;n";

  # send some string there:
  $exp-&gt;send("string&#92;n");

  # or, for the filehandle mindset:
  print $exp "string&#92;n";

  # then do some pattern matching with either the simple interface
  $patidx = $exp-&gt;expect($timeout, @match_patterns);

  # or multi-match on several spawned commands with callbacks,
  # just like the Tcl version
  $exp-&gt;expect($timeout,
               [ qr/regex1/ =&gt; sub { my $exp = shift;
                                     $exp-&gt;send("response&#92;n");
                                     exp_continue; } ],
               [ "regexp2" , &#92;&callback, @cbparms ],
              );

  # if no longer needed, do a soft_close to nicely shut down the command
  $exp-&gt;soft_close();

  # or be less patient with
  $exp-&gt;hard_close();
</pre>
<p>Expect.pm is built to either spawn a process or take an existing filehandle and interact with it such that normally interactive tasks can be done without operator assistance. This concept makes more sense if you are already familiar with the versatile Tcl version of Expect. The public functions that make up Expect.pm are:</p><p>  Expect-&gt;new()   Expect::interconnect(@objects_to_be_read_from)   Expect::test_handles($timeout, @objects_to_test)   Expect::version($version_requested | undef);   $object-&gt;spawn(@command)   $object-&gt;clear_accum()   $object-&gt;set_accum($value)   $object-&gt;debug($debug_level)   $object-&gt;exp_internal(0 | 1)   $object-&gt;notransfer(0 | 1)   $object-&gt;raw_pty(0 | 1)   $object-&gt;stty(@stty_modes) # See the IO::Stty docs   $object-&gt;slave()   $object-&gt;before();   $object-&gt;match();   $object-&gt;after();   $object-&gt;matchlist();   $object-&gt;match_number();   $object-&gt;error();   $object-&gt;command();   $object-&gt;exitstatus();   $object-&gt;pty_handle();   $object-&gt;do_soft_close();   $object-&gt;restart_timeout_upon_receive(0 | 1);   $object-&gt;interact($other_object, $escape_sequence)   $object-&gt;log_group(0 | 1 | undef)   $object-&gt;log_user(0 | 1 | undef)   $object-&gt;log_file("filename" | $filehandle | &#92;&coderef | undef)   $object-&gt;manual_stty(0 | 1 | undef)   $object-&gt;match_max($max_buffersize or undef)   $object-&gt;pid();   $object-&gt;send_slow($delay, @strings_to_send)   $object-&gt;set_group(@listen_group_objects | undef)   $object-&gt;set_seq($sequence,&#92;&function,&#92;@parameters);</p><p>There are several configurable package variables that affect the behavior of Expect. They are:</p><p>  $Expect::Debug;   $Expect::Exp_Internal;   $Expect::IgnoreEintr;   $Expect::Log_Group;   $Expect::Log_Stdout;   $Expect::Manual_Stty;   $Expect::Multiline_Matching;   $Expect::Do_Soft_Close;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>The Expect module is a successor of Comm.pl and a descendent of Chat.pl. It more closely ressembles the Tcl Expect language than its predecessors. It does not contain any of the networking code found in Comm.pl. I suspect this would be obsolete anyway given the advent of IO::Socket and external tools such as netcat.</p><p>Expect.pm is an attempt to have more of a <em>switch()</em> & case feeling to make decision processing more fluid.  Three separate types of debugging have been implemented to make code production easier.</p><p>It is possible to interconnect multiple file handles (and processes) much like Tcl's Expect. An attempt was made to enable all the features of Tcl's Expect without forcing Tcl on the victim programmer :-) .</p><p>Please, before you consider using Expect, read the FAQs about \*(L"I want to automate password entry for su/ssh/scp/rsh/...\*(R" and \*(L"I want to use Expect to automate [anything with a buzzword]...\*(R"</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">USAGE</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    new Expect ()
  </dt>
  <dd>
    <p>Creates a new Expect object, i.e. a pty.  You can change parameters on it before actually spawning a command.  This is important if you want to modify the terminal settings for the slave.  See <em>slave()</em> below. The object returned is actually a reblessed IO::Pty filehandle, so see there for additional methods.</p>
  </dd>
  <dt>
    Expect-&gt;exp_init(&#92;*FILEHANDLE) <em>or</em>
  </dt>
  <dd>
    
  </dd>
  <dt>
    Expect-&gt;init(&#92;*FILEHANDLE)
  </dt>
  <dd>
    <p>Initializes $new_handle_object for use with other Expect functions. It must be passed a <strong>_reference_</strong> to \s-1FILEHANDLE\s0 if you want it to work properly. IO::File objects are preferable. Returns a reference to the newly created object. You can use only real filehandles, certain tied filehandles (e.g. Net::SSH2) that lack a <em>fileno()</em> will not work. Net::Telnet objects can be used but have been reported to work only for certain hosts. \s-1YMMV\s0. Forks and execs $command. Returns an Expect object upon success or \*(C`undef\*(C' if the fork was unsuccessful or the command could not be found.  <em>spawn()</em> passes its parameters unchanged to Perls <em>exec()</em>, so look there for detailed semantics. Note that if spawn cannot <em>exec()</em> the given command, the Expect object is still valid and the next <em>expect()</em> will see \*(L"Cannot exec\*(R", so you can use that for error handling. Also note that you cannot reuse an object with an already spawned command, even if that command has exited.  Sorry, but you have to allocate a new object... Sets debug level for $object. 1 refers to general debugging information, 2 refers to verbose debugging and 0 refers to no debugging. If you call <em>debug()</em> with no parameters it will return the current debugging level.  When the object is created the debugging level will match that $Expect::Debug, normally 0. The '3' setting is new with 1.05, and adds the additional functionality of having the _full_ accumulated buffer printed every time data is read from an Expect object. This was implemented by request. I recommend against using this unless you think you need it as it can create quite a quantity of output under some circumstances.. Sets/unsets 'exp_internal' debugging. This is similar in nature to its Tcl counterpart. It is extremely valuable when debugging <em>expect()</em> sequences. When the object is created the exp_internal setting will match the value of $Expect::Exp_Internal, normally 0. Returns the current setting if called without parameters. It is highly recommended that you make use of the debugging features lest you have angry code. Set pty to raw mode before spawning.  This disables echoing, \s-1CR-\s0&gt;\s-1LF\s0 translation and an ugly hack for broken Solaris TTYs (which send &lt;space&gt;&lt;backspace&gt; to slow things down) and thus gives a more pipe-like behaviour (which is important if you want to transfer binary content).  Note that this must be set <em>before</em> spawning the program. Sets the tty mode for $object's associated terminal to the given modes.  Note that on many systems the master side of the pty is not a tty, so you have to modify the slave pty instead, see next item.  This needs IO::Stty installed, which is no longer required. Returns a filehandle to the slave part of the pty.  Very useful in modifying the terminal settings:   $object-&gt;slave-&gt;stty(qw(raw -echo)); Typical values are 'sane', 'raw', and 'raw -echo'.  Note that I recommend setting the terminal to 'raw' or 'raw -echo', as this avoids a lot of hassle and gives pipe-like (i.e. transparent) behaviour (without the buffering issue). Sends the given strings to the spawned command.  Note that the strings are not logged in the logfile (see print_log_file) but will probably be echoed back by the pty, depending on pty settings (default is echo) and thus end up there anyway.  This must also be taken into account when <em>expect()</em>ing for an answer: the next string will be the command just sent.  I suggest setting the pty to raw, which disables echo and makes the pty transparently act like a bidirectional pipe. or, more like Tcl/Expect,   expect($timeout,          &apos;-i&apos;, [ $obj1, $obj2, ... ],                [ $re_pattern, sub { ...; exp_continue; }, @subparms, ],                [ &apos;eof&apos;, sub { ... } ],                [ &apos;timeout&apos;, sub { ... }, &#92;$subparm1 ],          &apos;-i&apos;, [ $objn, ...],                &apos;-ex&apos;, $exact_pattern, sub { ... },                $exact_pattern, sub { ...; exp_continue_timeout; },                &apos;-re&apos;, $re_pattern, sub { ... },          &apos;-i&apos;, &#92;@object_list, @pattern_list,          ...); <em>Simple interface:</em> Given $timeout in seconds Expect will wait for $object's handle to produce one of the match_patterns, which are matched exactly by default. If you want a regexp match, prefix the pattern with '-re'. Due to o/s limitations $timeout should be a round number. If $timeout is 0 Expect will check one time to see if $object's handle contains any of the match_patterns. If $timeout is undef Expect will wait forever for a pattern to match. If called in a scalar context, <em>expect()</em> will return the position of the matched pattern within $match_patterns, or undef if no pattern was matched. This is a position starting from 1, so if you want to know which of an array of @matched_patterns matched you should subtract one from the return value. If called in an array context <em>expect()</em> will return ($matched_pattern_position, $error, $successfully_matching_string, $before_match, and $after_match). $matched_pattern_position will contain the value that would have been returned if <em>expect()</em> had been called in a scalar context. $error is the error that occurred that caused <em>expect()</em> to return. $error will contain a number followed by a string equivalent expressing the nature of the error. Possible values are undef, indicating no error, '1:TIMEOUT' indicating that $timeout seconds had elapsed without a match, '2:EOF' indicating an eof was read from $object, '3: spawn id($fileno) died' indicating that the process exited before matching and '4:$!' indicating whatever error was set in $ERRNO during the last read on $object's handle or during <em>select()</em>. All handles indicated by set_group plus \s-1STDOUT\s0 will have all data to come out of $object printed to them during <em>expect()</em> if log_group and log_stdout are set. Changed from older versions is the regular expression handling. By default now all strings passed to <em>expect()</em> are treated as literals. To match a regular expression pass '-re' as a parameter in front of the pattern you want to match as a regexp. Example:   $object-&gt;expect(15, &apos;match me exactly&apos;,&apos;-re&apos;,&apos;match&#92;s+me&#92;s+exactly&apos;); This change makes it possible to match literals and regular expressions in the same <em>expect()</em> call. Also new is multiline matching. ^ will now match the beginning of lines. Unfortunately, because perl doesn't use $/ in determining where lines break using $ to find the end of a line frequently doesn't work. This is because your terminal is returning \*(L"&#92;r&#92;n\*(R" at the end of every line. One way to check for a pattern at the end of a line would be to use &#92;r?$ instead of $. Example: Spawning telnet to a host, you might look for the escape character.  telnet would return to you \*(L"&#92;r&#92;nEscape character is '^]'.&#92;r&#92;n\*(R". To find this you might use $match='^Escape char.*&#92;.&#92;r?$';   $telnet-&gt;expect(10,&apos;-re&apos;,$match); <em>New more Tcl/Expect-like interface:</em> It's now possible to expect on more than one connection at a time by specifying '\*(C`-i\*(C'' and a single Expect object or a ref to an array containing Expect objects, e.g.  expect($timeout,         &apos;-i&apos;, $exp1, @patterns_1,         &apos;-i&apos;, [ $exp2, $exp3 ], @patterns_2_3,        ) Furthermore, patterns can now be specified as array refs containing [$regexp, sub { ...}, @optional_subprams] . When the pattern matches, the subroutine is called with parameters ($matched_expect_obj, @optional_subparms). The subroutine can return the symbol `exp_continue' to continue the expect matching with timeout starting anew or return the symbol `exp_continue_timeout' for continuing expect without resetting the timeout count.  $exp-&gt;expect($timeout,               [ qr/username: /i, sub { my $self = shift;                                        $self-&gt;send("$username&#92;n");                                        exp_continue; }],               [ qr/password: /i, sub { my $self = shift;                                        $self-&gt;send("$password&#92;n");                                        exp_continue; }],               $shell_prompt); `expect' is now exported by default. <em>before()</em> returns the 'before' part of the last <em>expect()</em> call. If the last <em>expect()</em> call didn't match anything, <em>exp_before()</em> will return the entire output of the object accumulated before the <em>expect()</em> call finished. Note that this is something different than Tcl Expects <em>before()</em>!! returns the 'after' part of the last <em>expect()</em> call. If the last <em>expect()</em> call didn't match anything, <em>exp_after()</em> will return <em>undef()</em>. returns the string matched by the last <em>expect()</em> call, undef if no string was matched. <em>exp_match_number()</em> returns the number of the pattern matched by the last <em>expect()</em> call. Keep in mind that the first pattern in a list of patterns is 1, not 0. Returns undef if no pattern was matched. <em>exp_matchlist()</em> returns a list of matched substrings from the brackets () inside the regexp that last matched. ($object-&gt;matchlist)[0] thus corresponds to $1, ($object-&gt;matchlist)[1] to $2, etc. <em>exp_error()</em> returns the error generated by the last <em>expect()</em> call if no pattern was matched. It is typically useful to examine the value returned by <em>before()</em> to find out what the output of the object was in determining why it didn't match any of the patterns. Clear the contents of the accumulator for $object. This gets rid of any residual contents of a handle after <em>expect()</em> or <em>send_slow()</em> such that the next <em>expect()</em> call will only see new data from $object. The contents of the accumulator are returned. Sets the content of the accumulator for $object to $value. The previous content of the accumulator is returned. <em>exp_command()</em> returns the string that was used to spawn the command. Helpful for debugging and for reused patternmatch subroutines. Returns the exit status of $object (if it already exited). Returns a string representation of the attached pty, for example: `spawn <em>id</em>\|(5)' (pty has fileno 5), `handle <em>id</em>\|(7)' (pty was initialized from fileno 7) or `\s-1STDIN\s0'. Useful for debugging. If this is set to 1, the expect timeout is retriggered whenever something is received from the spawned command.  This allows to perform some aliveness testing and still expect for patterns.     $exp-&gt;<strong>restart_timeout_upon_receive</strong>(1);     $exp-&gt;expect($timeout,                  [ timeout =&gt; &#92;&report_timeout ],                  [ qr/pattern/ =&gt; &#92;&handle_pattern],                 ); Now the timeout isn't triggered if the command produces any kind of output, i.e. is still alive, but you can act upon patterns in the output. Do not truncate the content of the accumulator after a match. Normally, the accumulator is set to the remains that come after the matched string.  Note that this setting is per object and not per pattern, so if you want to have normal acting patterns that truncate the accumulator, you have to add a     $exp-&gt;set_accum($exp-&gt;after); to their callback, e.g.     $exp-&gt;<strong>notransfer</strong>(1);     $exp-&gt;expect($timeout,                  # accumulator not truncated, pattern1 will match again                  [ "pattern1" =&gt; sub { my $self = shift;                                        ...                                      } ],                  # accumulator truncated, pattern2 will not match again                  [ "pattern2" =&gt; sub { my $self = shift;                                        ...                                        $self-&gt;set_accum($self-&gt;after());                                      } ],                 ); This is only a temporary fix until I can rewrite the pattern matching part so it can take that additional -notransfer argument.</p>
  </dd>
  <dt>
    Expect::interconnect(@objects);
  </dt>
  <dd>
    <p>Read from @objects and print to their @listen_groups until an escape sequence is matched from one of @objects and the associated function returns 0 or undef. The special escape sequence '\s-1EOF\s0' is matched when an object's handle returns an end of file. Note that it is not necessary to include objects that only accept data in @objects since the escape sequence is _read_ from an object. Further note that the listen_group for a write-only object is always empty. Why would you want to have objects listening to \s-1STDOUT\s0 (for example)? By default every member of @objects _as well as every member of its listen group_ will be set to 'raw -echo' for the duration of interconnection. Setting $object-&gt;<em>manual_stty()</em> will stop this behavior per object. The original tty settings will be restored as interconnect exits. For a generic way to interconnect processes, take a look at IPC::Run. Given a set of objects determines which objects' handles have data ready to be read. <strong>Returns an array</strong> who's members are positions in @objects that have ready handles. Returns undef if there are no such handles ready.</p>
  </dd>
  <dt>
    Expect::version($version_requested or undef);
  </dt>
  <dd>
    <p>Returns current version of Expect. As of .99 earlier versions are not supported. Too many things were changed to make versioning possible. <em>interact()</em> is essentially a macro for calling <em>interconnect()</em> for connecting 2 processes together. &#92;*FILEHANDLE defaults to &#92;*STDIN and $escape_sequence defaults to undef. Interaction ceases when $escape_sequence is read from <strong>\s-1FILEHANDLE\s0</strong>, not $object. $object's listen group will consist solely of &#92;*FILEHANDLE for the duration of the interaction. &#92;*FILEHANDLE will not be echoed on \s-1STDOUT\s0. Set/unset logging of $object to its 'listen group'. If set all objects in the listen group will have output from $object printed to them during $object-&gt;<em>expect()</em>, $object-&gt;<em>send_slow()</em>, and \*(C`Expect::interconnect($object , ...)\*(C'. Default value is on. During creation of $object the setting will match the value of $Expect::Log_Group, normally 1. Set/unset logging of object's handle to \s-1STDOUT\s0. This corresponds to Tcl's log_user variable. Returns current setting if called without parameters. Default setting is off for initialized handles.  When a process object is created (not a filehandle initialized with exp_init) the log_stdout setting will match the value of $Expect::Log_Stdout variable, normally 1. If/when you initialize \s-1STDIN\s0 it is usually associated with a tty which will by default echo to \s-1STDOUT\s0 anyway, so be careful or you will have multiple echoes. Log session to a file.  All characters send to or received from the spawned process are written to the file.  Normally appends to the logfile, but you can pass an additional mode of \*(L"w\*(R" to truncate the file upon <em>open()</em>:   $object-&gt;log_file("filename", "w"); Returns the logfilehandle. If called with an undef value, stops logging and closes logfile:   $object-&gt;log_file(undef); If called without argument, returns the logfilehandle:   $fh = $object-&gt;log_file(); Can be set to a code ref, which will be called instead of printing to the logfile:   $object-&gt;log_file(&#92;&myloggerfunc); Prints to logfile (if opened) or calls the logfile hook function. This allows the user to add arbitraty text to the logfile.  Note that this could also be done as $object-&gt;log_file-&gt;<em>print()</em> but would only work for log files, not code hooks. During Expect-&gt;<em>interconnect()</em> if $sequence is read from $object &function will be executed with parameters @function_parameters. It is <strong>_highly</strong> recommended_ that the escape sequence be a single character since the likelihood is great that the sequence will be broken into to separate reads from the $object's handle, making it impossible to strip $sequence from getting printed to $object's listen group. &#92;&function should be something like 'main::control_w_function' and @function_parameters should be an array defined by the caller, passed by reference to <em>set_seq()</em>. Your function should return a non-zero value if execution of <em>interconnect()</em> is to resume after the function returns, zero or undefined if <em>interconnect()</em> should return after your function returns. The special sequence '\s-1EOF\s0' matches the end of file being reached by $object. See <em>interconnect()</em> for details. @listener_objects is the list of objects that should have their handles printed to by $object when Expect::interconnect, $object-&gt;<em>expect()</em> or $object-&gt;<em>send_slow()</em> are called. Calling w/out parameters will return the current list of the listener objects. Sets/unsets whether or not Expect should make reasonable guesses as to when and how to set tty parameters for $object. Will match $Expect::Manual_Stty value (normally 0) when $object is created. If called without parameters <em>manual_stty()</em> will return the current manual_stty setting. Set the maximum accumulator size for object. This is useful if you think that the accumulator will grow out of hand during <em>expect()</em> calls. Since the buffer will be matched by every match_pattern it may get slow if the buffer gets too large. Returns current value if called without parameters. Not defined by default. If set, matched strings will not be deleted from the accumulator. Returns current value if called without parameters.  False by default. Return pid of $object, if one exists. Initialized filehandles will not have pids (of course). print each character from each string of @strings one at a time with $delay seconds before each character. This is handy for devices such as modems that can be annoying if you send them data too fast. After each character $object will be checked to determine whether or not it has any new data ready and if so update the accumulator for future <em>expect()</em> calls and print the output to \s-1STDOUT\s0 and @listen_group if log_stdout and log_group are appropriately set.</p>
  </dd>

</dl>
<h3>Configurable Package Variables:</h3>
<p>Defaults to 0. Newly created objects have a $object-&gt;<em>debug()</em> value of $Expect::Debug. See $object-&gt;<em>debug()</em>; Defaults to 0. When destroying objects, soft_close may take up to half a minute to shut everything down.  From now on, only hard_close will be called, which is less polite but still gives the process a chance to terminate properly.  Set this to '1' for old behaviour. Defaults to 0. Newly created objects have a $object-&gt;<em>exp_internal()</em> value of $Expect::Exp_Internal. See $object-&gt;<em>exp_internal()</em>. Defaults to 0. If set to 1, when waiting for new data, Expect will ignore \s-1EINTR\s0 errors and restart the <em>select()</em> call instead. Defaults to 1. Newly created objects have a $object-&gt;<em>log_group()</em> value of $Expect::Log_Group. See $object-&gt;<em>log_group()</em>. Defaults to 1 for spawned commands, 0 for file handles attached with <em>exp_init()</em>. Newly created objects have a $object-&gt;<em>log_stdout()</em> value of $Expect::Log_Stdout. See $object-&gt;<em>log_stdout()</em>. Defaults to 0. Newly created objects have a $object-&gt;<em>manual_stty()</em> value of $Expect::Manual_Stty. See $object-&gt;<em>manual_stty()</em>.         Defaults to 1. Affects whether or not expect() uses the /m flag for doing regular expression matching. If set to 1 /m is used.         This makes a difference when you are trying to match ^ and $. If you have this on you can match lines in the middle of a page of output using ^ and $ instead of it matching the beginning and end of the entire expression. I think this is handy.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CONTRIBUTIONS</h2>
        <div class="sectioncontent">
<p>Lee Eakin &lt;leakin@japh.itg.ti.com&gt; has ported the kibitz script from Tcl/Expect to Perl/Expect.</p><p>Jeff Carr &lt;jcarr@linuxmachines.com&gt; provided a simple example of how handle terminal window resize events (transmitted via the \s-1WINCH\s0 signal) in a ssh session.</p><p>You can find both scripts in the examples/ subdir.  Thanks to both!</p><p>Historical notes:</p><p>There are still a few lines of code dating back to the inspirational Comm.pl and Chat.pl modules without which this would not have been possible. Kudos to Eric Arnold &lt;Eric.Arnold@Sun.com&gt; and Randal 'Nuke your \s-1NT\s0 box with one line of perl code' Schwartz&lt;merlyn@stonehenge.com&gt; for making these available to the perl public.</p><p>As of .98 I think all the old code is toast. No way could this have been done without it though. Special thanks to Graham Barr for helping make sense of the IO::Handle stuff as well as providing the highly recommended IO::Tty module.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">REFERENCES</h2>
        <div class="sectioncontent">
<p>Mark Rogaski &lt;rogaski@att.com&gt; wrote:</p><p>\*(L"I figured that you'd like to know that Expect.pm has been very useful to \s-1AT&T\s0 Labs over the past couple of years (since I first talked to Austin about design decisions). We use Expect.pm for managing the switches in our network via the telnet interface, and such automation has significantly increased our reliability. So, you can honestly say that one of the largest digital networks in existence (\s-1AT&T\s0 Frame Relay) uses Expect.pm quite extensively.\*(R"</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">FAQ - Frequently Asked Questions</h2>
        <div class="sectioncontent">
<p>This is a growing collection of things that might help. Please send you questions that are not answered here to RGiersig@cpan.org</p><h3>What systems does Expect run on?</h3>
<p>Expect itself doesn't have real system dependencies, but the underlying IO::Tty needs pseudoterminals. IO::Stty uses \s-1POSIX\s0.pm and Fcntl.pm.</p><p>I have used it on Solaris, Linux and \s-1AIX\s0, others report *BSD and \s-1OSF\s0 as working.  Generally, any modern \s-1POSIX\s0 Unix should do, but there are exceptions to every rule.  Feedback is appreciated.</p><p>See IO::Tty for a list of verified systems.</p>
<h3>Can I use this module with ActivePerl on Windows?</h3>
<p>Up to now, the answer was 'No', but this has changed.</p><p>You still cannot use ActivePerl, but if you use the Cygwin environment (http://sources.redhat.com), which brings its own perl, and have the latest IO::Tty (v0.05 or later) installed, it should work (feedback appreciated).</p>
<h3>The examples in the tutorial don't work!</h3>
<p>The tutorial is hopelessly out of date and needs a serious overhaul. I appologize for this, I have concentrated my efforts mainly on the functionality.  Volunteers welcomed.</p>
<h3>How can I find out what Expect is doing?</h3>
<p>If you set</p><p>  $Expect::Exp_Internal = 1;</p><p>Expect will tell you very verbosely what it is receiving and sending, what matching it is trying and what it found.  You can do this on a per-command base with</p><p>  $exp-&gt;<strong>exp_internal</strong>(1);</p><p>You can also set</p><p>  $Expect::Debug = 1;  # or 2, 3 for more verbose output</p><p>or</p><p>  $exp-&gt;<strong>debug</strong>(1);</p><p>which gives you even more output.</p>
<h3>I am seeing the output of the command I spawned.  Can I turn that off?</h3>
<p>Yes, just set</p><p>  $Expect::Log_Stdout = 0;</p><p>to globally disable it or</p><p>   $exp-&gt;<strong>log_stdout</strong>(0);</p><p>for just that command.  'log_user' is provided as an alias so Tcl/Expect user get a \s-1DWIM\s0 experience... :-)</p>
<h3>No, I mean that when I send some text to the spawned process, it gets echoed back and I have to deal with it in the next expect.</h3>
<p>This is caused by the pty, which has probably 'echo' enabled.  A solution would be to set the pty to raw mode, which in general is cleaner for communication between two programs (no more unexpected character translations).  Unfortunately this would break a lot of old code that sends \*(L"&#92;r\*(R" to the program instead of \*(L"&#92;n\*(R" (translating this is also handled by the pty), so I won't add this to Expect just like that. But feel free to experiment with \*(C`$exp-&gt;<strong>raw_pty</strong>(1)\*(C'.</p>
<h3>How do I send control characters to a process?</h3>
<p>A: You can send any characters to a process with the print command. To represent a control character in Perl, use &#92;c followed by the letter. For example, control-G can be represented with \*(L"&#92;cG\*(R" . Note that this will not work if you single-quote your string. So, to send control-C to a process in $exp, do:</p><p>  print $exp "&#92;cC";</p><p>Or, if you prefer:</p><p>  $exp-&gt;send("&#92;cC");</p><p>The ability to include control characters in a string like this is provided by Perl, not by Expect.pm . Trying to learn Expect.pm without a thorough grounding in Perl can be very daunting. We suggest you look into some of the excellent Perl learning material, such as the books _Programming Perl_ and _Learning Perl_ by O'Reilly, as well as the extensive online Perl documentation available through the perldoc command.</p>
<h3>My script fails from time to time without any obvious reason.  It seems that I am sometimes loosing output from the spawned program.</h3>
<p>You could be exiting too fast without giving the spawned program enough time to finish.  Try adding $exp-&gt;<em>soft_close()</em> to terminate the program gracefully or do an <em>expect()</em> for 'eof'.</p><p>Alternatively, try adding a 'sleep 1' after you <em>spawn()</em> the program. It could be that pty creation on your system is just slow (but this is rather improbable if you are using the latest IO-Tty).</p>
<h3>I want to automate password entry for su/ssh/scp/rsh/...</h3>
<p>You shouldn't use Expect for this.  Putting passwords, especially root passwords, into scripts in clear text can mean severe security problems.  I strongly recommend using other means.  For 'su', consider switching to 'sudo', which gives you root access on a per-command and per-user basis without the need to enter passwords.  'ssh'/'scp' can be set up with \s-1RSA\s0 authentication without passwords.  'rsh' can use the .rhost mechanism, but I'd strongly suggest to switch to 'ssh'; to mention 'rsh' and 'security' in the same sentence makes an oxymoron.</p><p>It will work for 'telnet', though, and there are valid uses for it, but you still might want to consider using 'ssh', as keeping cleartext passwords around is very insecure.</p>
<h3>I want to use Expect to automate [anything with a buzzword]...</h3>
<p>Are you sure there is no other, easier way?  As a rule of thumb, Expect is useful for automating things that expect to talk to a human, where no formal standard applies.  For other tasks that do follow a well-defined protocol, there are often better-suited modules that already can handle those protocols.  Don't try to do \s-1HTTP\s0 requests by spawning telnet to port 80, use \s-1LWP\s0 instead.  To automate \s-1FTP\s0, take a look at Net::FTP or \*(C`ncftp\*(C' (http://www.ncftp.org).  You don't use a screwdriver to hammer in your nails either, or do you?</p>
<h3>Is it possible to use threads with Expect?</h3>
<p>Basically yes, with one restriction: you must <em>spawn()</em> your programs in the main thread and then pass the Expect objects to the handling threads. The reason is that <em>spawn()</em> uses <em>fork()</em>, and perlthrtut:</p><p>  "Thinking of mixing fork() and threads?  Please lie down and wait until the feeling passes."</p>
<h3>I want to log the whole session to a file.</h3>
<p>Use</p><p>  $exp-&gt;log_file("filename");</p><p>or</p><p>  $exp-&gt;log_file($filehandle);</p><p>or even</p><p>  $exp-&gt;log_file(&#92;&log_procedure);</p><p>for maximum flexibility.</p><p>Note that the logfile is appended to by default, but you can specify an optional mode \*(L"w\*(R" to truncate the logfile:</p><p>  $exp-&gt;log_file("filename", "w");</p><p>To stop logging, just call it with a false argument:</p><p>  $exp-&gt;log_file(undef);</p>
<h3>How can I turn off multi-line matching for my regexps?</h3>
<p>To globally unset multi-line matching for all regexps:</p><p>  $Expect::Multiline_Matching = 0;</p><p>You can do that on a per-regexp basis by stating \*(C`(?-m)\*(C' inside the regexp (you need perl5.00503 or later for that).</p>
<h3>How can I expect on multiple spawned commands?</h3>
<p>You can use the <strong>-i</strong> parameter to specify a single object or a list of Expect objects.  All following patterns will be evaluated against that list.</p><p>You can specify <strong>-i</strong> multiple times to create groups of objects and patterns to match against within the same expect statement.</p><p>This works just like in Tcl/Expect.</p><p>See the source example below.</p>
<h3>I seem to have problems with ptys!</h3>
<p>Well, pty handling is really a black magic, as it is extremely system dependend.  I have extensively revised IO-Tty, so these problems should be gone.</p><p>If your system is listed in the \*(L"verified\*(R" list of IO::Tty, you probably have some non-standard setup, e.g. you compiled your Linux-kernel yourself and disabled ptys.  Please ask your friendly sysadmin for help.</p><p>If your system is not listed, unpack the latest version of IO::Tty, do a 'perl Makefile.PL; make; make test; uname \*(C`-a\*(C'' and send me the results and I'll see what I can deduce from that.</p>
<h3>I just want to read the output of a process without \fIexpect()\fPing anything. How can I do this?</h3>
<p>[ Are you sure you need Expect for this?  How about <em>qx()</em> or open(\*(L"prog|\*(R")? ]</p><p>By using expect without any patterns to match.</p><p>  $process-&gt;expect(undef); # Forever until EOF   $process-&gt;expect($timeout); # For a few seconds   $process-&gt;<strong>expect</strong>(0); # Is there anything ready on the handle now?</p>
<h3>Ok, so now how do I get what was read on the handle?</h3>
<p>  $read = $process-&gt;before();</p>
<h3>Where's IO::Pty?</h3>
<p>Find it on \s-1CPAN\s0 as IO-Tty, which provides both.</p>
<h3>How come when I automate the passwd program to change passwords for me passwd dies before changing the password sometimes/every time?</h3>
<p>What's happening is you are closing the handle before passwd exits. When you close the handle to a process, it is sent a signal (\s-1SIGPIPE\s0?) telling it that \s-1STDOUT\s0 has gone away. The default behavior for processes is to die in this circumstance. Two ways you can make this not happen are:</p><p>  $process-&gt;soft_close();</p><p>This will wait 15 seconds for a process to come up with an \s-1EOF\s0 by itself before killing it.</p><p>  $process-&gt;expect(undef);</p><p>This will wait forever for the process to match an empty set of patterns. It will return when the process hits an \s-1EOF\s0.</p><p>As a rule, you should always <em>expect()</em> the result of your transaction before you continue with processing.</p>
<h3>How come when I try to make a logfile with \fIlog_file()\fP or \fIset_group()\fP it doesn't print anything after the last time I run \fIexpect()\fP?</h3>
<p>Output is only printed to the logfile/group when Expect reads from the process, during <em>expect()</em>, <em>send_slow()</em> and <em>interconnect()</em>. One way you can force this is to make use of</p><p>  $process-&gt;expect(undef);</p><p>and</p><p>  $process-&gt;<strong>expect</strong>(0);</p><p>which will make <em>expect()</em> run with an empty pattern set forever or just for an instant to capture the output of $process. The output is available in the accumulator, so you can grab it using $process-&gt;<em>before()</em>.</p>
<h3>I seem to have problems with terminal settings, double echoing, etc.</h3>
<p>Tty settings are a major pain to keep track of. If you find unexpected behavior such as double-echoing or a frozen session, doublecheck the documentation for default settings. When in doubt, handle them yourself using $exp-&gt;<em>stty()</em> and <em>manual_stty()</em> functions.  As of .98 you shouldn't have to worry about stty settings getting fouled unless you use interconnect or intentionally change them (like doing -echo to get a password).</p><p>If you foul up your terminal's tty settings, kill any hung processes and enter 'stty sane' at a shell prompt. This should make your terminal manageable again.</p><p>Note that IO::Tty returns ptys with your systems default setting regarding echoing, \s-1CRLF\s0 translation etc. and Expect does not change them.  I have considered setting the ptys to 'raw' without any translation whatsoever, but this would break a lot of existing things, as '&#92;r' translation would not work anymore.  On the other hand, a raw pty works much like a pipe and is more \s-1WYGIWYE\s0 (what you get is what you expect), so I suggest you set it to 'raw' by yourself:</p><p>  $exp = new Expect;   $exp-&gt;<strong>raw_pty</strong>(1);   $exp-&gt;spawn(...);</p><p>To disable echo:</p><p>  $exp-&gt;slave-&gt;stty(qw(-echo));</p>
<h3>I'm spawning a telnet/ssh session and then let the user interact with it.  But screen-oriented applications on the other side don't work properly.</h3>
<p>You have to set the terminal screen size for that.  Luckily, IO::Pty already has a method for that, so modify your code to look like this:</p><p>  my $exp = new Expect;   $exp-&gt;slave-&gt;clone_winsize_from(&#92;*STDIN);   $exp-&gt;spawn("telnet somehost);</p><p>Also, some applications need the \s-1TERM\s0 shell variable set so they know how to move the cursor across the screen.  When logging in, the remote shell sends a query (Ctrl-Z I think) and expects the terminal to answer with a string, e.g. 'xterm'.  If you really want to go that way (be aware, madness lies at its end), you can handle that and send back the value in $ENV{\s-1TERM\s0}.  This is only a hand-waving explanation, please figure out the details by yourself.</p>
<h3>I set the terminal size as explained above, but if I resize the window, the application does not notice this.</h3>
<p>You have to catch the signal \s-1WINCH\s0 (\*(L"window size changed\*(R"), change the terminal size and propagate the signal to the spawned application:</p><p>  my $exp = new Expect;   $exp-&gt;slave-&gt;clone_winsize_from(&#92;*STDIN);   $exp-&gt;spawn("ssh somehost);   $SIG{WINCH} = &#92;&winch;</p><p>  sub winch {     $exp-&gt;slave-&gt;clone_winsize_from(&#92;*STDIN);     kill WINCH =&gt; $exp-&gt;pid if $exp-&gt;pid;     $SIG{WINCH} = &#92;&winch;   }</p><p>  $exp-&gt;interact();</p><p>There is an example file ssh.pl in the examples/ subdir that shows how this works with ssh. Please note that I do strongly object against using Expect to automate ssh login, as there are better way to do that (see ssh-keygen).</p>
<h3>I noticed that the test uses a string that resembles, but not exactly matches, a well-known sentence that contains every character.  What does that mean?</h3>
<p>That means you are anal-retentive. :-)  [Gotcha there!] The \s-1OS\s0 may not be configured to grant additional pty's (pseudo terminals) to non-root users.  /usr/sbin/mkpts should be 4755, not 700 for this to work.  I don't know about security implications if you do this.</p>
<h3>How come I don't notice when the spawned process closes its stdin/out/err??</h3>
<p>You are probably on one of the systems where the master doesn't get an \s-1EOF\s0 when the slave closes stdin/out/err.</p><p>One possible solution is when you spawn a process, follow it with a unique string that would indicate the process is finished.</p><p>  $process = Expect-&gt;spawn(&apos;telnet somehost; echo _\|_\|_\|_END_\|_\|_\|_&apos;);</p><p>And then $process-&gt;expect($timeout,'_\|_\|_\|_END_\|_\|_\|_','other','patterns');</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Source Examples</h2>
        <div class="sectioncontent">
<h3>How to automate login</h3>
<p>  my $telnet = new Net::Telnet ("remotehost") # see Net::Telnet     or die "Cannot telnet to remotehost: $!&#92;n";;   my $exp = Expect-&gt;exp_init($telnet);</p><p>  # deprecated use of spawned telnet command   # my $exp = Expect-&gt;spawn("telnet localhost")   #   or die "Cannot spawn telnet: $!&#92;n";;</p><p>  my $spawn_ok;   $exp-&gt;expect($timeout,                [                 qr&apos;login: $&apos;,                 sub {                   $spawn_ok = 1;                   my $fh = shift;                   $fh-&gt;send("$username&#92;n");                   exp_continue;                 }                ],                [                 &apos;Password: $&apos;,                 sub {                   my $fh = shift;                   print $fh "$password&#92;n";                   exp_continue;                 }                ],                [                 eof =&gt;                 sub {                   if ($spawn_ok) {                     die "ERROR: premature EOF in login.&#92;n";                   } else {                     die "ERROR: could not spawn telnet.&#92;n";                   }                 }                ],                [                 timeout =&gt;                 sub {                   die "No login.&#92;n";                 }                ],                &apos;-re&apos;, qr&apos;[#&gt;:] $&apos;, #&apos; wait for shell prompt, then exit expect               );</p>
<h3>How to expect on multiple spawned commands</h3>
<p>  foreach my $cmd (@list_of_commands) {     push @commands, Expect-&gt;spawn($cmd);   }</p><p>  expect($timeout,          &apos;-i&apos;, &#92;@commands,          [           qr"pattern",          # find this pattern in output of all commands           sub {             my $obj = shift;    # object that matched             print $obj "something&#92;n";             exp_continue;       # we don&apos;t want to terminate the expect call           }          ],          &apos;-i&apos;, $some_other_command,          [           "some other pattern",           sub {             my ($obj, $parmref) = @_;             # ...</p><p>            # now we exit the expect command           },           &#92;$parm          ],         );</p>
<h3>How to propagate terminal sizes</h3>
<p>  my $exp = new Expect;   $exp-&gt;slave-&gt;clone_winsize_from(&#92;*STDIN);   $exp-&gt;spawn("ssh somehost);   $SIG{WINCH} = &#92;&winch;</p><p>  sub winch {     $exp-&gt;slave-&gt;clone_winsize_from(&#92;*STDIN);     kill WINCH =&gt; $exp-&gt;pid if $exp-&gt;pid;     $SIG{WINCH} = &#92;&winch;   }</p><p>  $exp-&gt;interact();</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">HOMEPAGE</h2>
        <div class="sectioncontent">
<p>http://sourceforge.net/projects/expectperl/</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">MAILING LISTS</h2>
        <div class="sectioncontent">
<p>There are two mailing lists available, expectperl-announce and expectperl-discuss, at</p><p>  http://lists.sourceforge.net/lists/listinfo/expectperl-announce</p><p>and</p><p>  http://lists.sourceforge.net/lists/listinfo/expectperl-discuss</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">BUG TRACKING</h2>
        <div class="sectioncontent">
<p>You can use the \s-1CPAN\s0 Request Tracker http://rt.cpan.org/ and submit new bugs under</p><p>  http://rt.cpan.org/Ticket/Create.html?Queue=Expect</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHORS</h2>
        <div class="sectioncontent">
<p>(c) 1997 Austin Schutz &lt;<em>ASchutz@users.sourceforge.net</em>&gt; (retired)</p><p><em>expect()</em> interface & functionality enhancements (c) 1999-2006 Roland Giersig.</p><p>This module is now maintained by Roland Giersig &lt;<em>RGiersig@cpan.org</em>&gt;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LICENSE</h2>
        <div class="sectioncontent">
<p>This module can be used under the same terms as Perl.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DISCLAIMER</h2>
        <div class="sectioncontent">
<p>\s-1THIS\s0 \s-1SOFTWARE\s0 \s-1IS\s0 \s-1PROVIDED\s0 ``\s-1AS\s0 \s-1IS\s0'' \s-1AND\s0 \s-1ANY\s0 \s-1EXPRESS\s0 \s-1OR\s0 \s-1IMPLIED\s0 \s-1WARRANTIES\s0, \s-1INCLUDING\s0, \s-1BUT\s0 \s-1NOT\s0 \s-1LIMITED\s0 \s-1TO\s0, \s-1THE\s0 \s-1IMPLIED\s0 \s-1WARRANTIES\s0 \s-1OF\s0 \s-1MERCHANTABILITY\s0 \s-1AND\s0 \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0 \s-1ARE\s0 \s-1DISCLAIMED\s0. \s-1IN\s0 \s-1NO\s0 \s-1EVENT\s0 \s-1SHALL\s0 \s-1THE\s0 \s-1AUTHORS\s0 \s-1BE\s0 \s-1LIABLE\s0 \s-1FOR\s0 \s-1ANY\s0 \s-1DIRECT\s0, \s-1INDIRECT\s0, \s-1INCIDENTAL\s0, \s-1SPECIAL\s0, \s-1EXEMPLARY\s0, \s-1OR\s0 \s-1CONSEQUENTIAL\s0 \s-1DAMAGES\s0 (\s-1INCLUDING\s0, \s-1BUT\s0 \s-1NOT\s0 \s-1LIMITED\s0 \s-1TO\s0, \s-1PROCUREMENT\s0 \s-1OF\s0 \s-1SUBSTITUTE\s0 \s-1GOODS\s0 \s-1OR\s0 \s-1SERVICES\s0; \s-1LOSS\s0 \s-1OF\s0 \s-1USE\s0, \s-1DATA\s0, \s-1OR\s0 \s-1PROFITS\s0; \s-1OR\s0 \s-1BUSINESS\s0 \s-1INTERRUPTION\s0) \s-1HOWEVER\s0 \s-1CAUSED\s0 \s-1AND\s0 \s-1ON\s0 \s-1ANY\s0 \s-1THEORY\s0 \s-1OF\s0 \s-1LIABILITY\s0, \s-1WHETHER\s0 \s-1IN\s0 \s-1CONTRACT\s0, \s-1STRICT\s0 \s-1LIABILITY\s0, \s-1OR\s0 \s-1TORT\s0 (\s-1INCLUDING\s0 \s-1NEGLIGENCE\s0 \s-1OR\s0 \s-1OTHERWISE\s0) \s-1ARISING\s0 \s-1IN\s0 \s-1ANY\s0 \s-1WAY\s0 \s-1OUT\s0 \s-1OF\s0 \s-1THE\s0 \s-1USE\s0 \s-1OF\s0 \s-1THIS\s0 \s-1SOFTWARE\s0, \s-1EVEN\s0 \s-1IF\s0 \s-1ADVISED\s0 \s-1OF\s0 \s-1THE\s0 \s-1POSSIBILITY\s0 \s-1OF\s0 \s-1SUCH\s0 \s-1DAMAGE\s0.</p><p>In other words: Use at your own risk.  Provided as is.  Your mileage may vary.  Read the source, Luke!</p><p>And finally, just to be sure:</p><p>Any Use of This Product, in Any Manner Whatsoever, Will Increase the Amount of Disorder in the Universe. Although No Liability Is Implied Herein, the Consumer Is Warned That This Process Will Ultimately Lead to the Heat Death of the Universe.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Exception::Handler.3pm.html"><span aria-hidden="true">&larr;</span> Exception::Handler.3pm: Report exceptions with formatted text call-stack</a></li>
   <li class="next"><a href="Expect::Simple.3pm.html">Expect::Simple.3pm: Wrapper around the expect module <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

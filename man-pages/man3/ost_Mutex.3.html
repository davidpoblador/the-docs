<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ost_Mutex: The mutex class is used to protect a section of code so that at any given time only a single thread can perform the protected operation.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="The mutex class is used to protect a section of code so that at any given time only a single thread can perform the protected operation.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="ost_Mutex (3) manual">
  <meta name="twitter:description" content="The mutex class is used to protect a section of code so that at any given time only a single thread can perform the protected operation.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcommoncpp2-doc-ost_Mutex-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/ost_Mutex.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="ost_Mutex (3) manual" />
  <meta property="og:description" content="The mutex class is used to protect a section of code so that at any given time only a single thread can perform the protected operation." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcommoncpp2-doc-ost_Mutex-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">ost_Mutex<small> (3)</small></h1>
        <p class="lead">The mutex class is used to protect a section of code so that at any given time only a single thread can perform the protected operation.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/ost_Mutex.3.html">
      <span itemprop="name">ost_Mutex: The mutex class is used to protect a section of code so that at any given time only a single thread can perform the protected operation.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcommoncpp2-doc/">
      <span itemprop="name">libcommoncpp2-doc</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/ost_Mutex.3.html">
      <span itemprop="name">ost_Mutex: The mutex class is used to protect a section of code so that at any given time only a single thread can perform the protected operation.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">
<p>#include &lt;thread.h&gt;</p><p>Inherited by <strong>ost::MapTable</strong>, <strong>ost::MutexCounter</strong>, <strong>ost::RandomFile</strong> [protected]<strong>, </strong><strong>ost::Runlist</strong><strong>, </strong><strong>ost::SerialService</strong><strong> [private]</strong><strong>, </strong><strong>ost::SharedMemPager</strong><strong>, </strong><strong>ost::SocketService</strong><strong> [private]</strong><strong>, and </strong><strong>ost::ThreadQueue</strong><strong>.</strong></p><h3>Public Member Functions</h3>
<p><strong>Mutex</strong> (const char *name=NULL)</p><p><em>The mutex is always initialized as a recursive entity. </em> virtual <strong>~Mutex</strong> ()</p><p><em>Destroying the mutex removes any system resources associated with it. </em> void <strong>nameMutex</strong> (const char *name)</p><p><em>Enable setting of mutex name for deadlock debug. </em> void <strong>enterMutex</strong> (void)</p><p><em>Entering a </em><strong>Mutex</strong><em> locks the mutex for the current thread. </em><strong></strong> void <strong>enter</strong> (void)</p><p><em>Future abi will use enter/leave/test members. </em> void <strong>leave</strong> (void)</p><p><em>Future abi will use enter/leave/test members. </em> bool <strong>test</strong> (void)</p><p><em>Future abi will use enter/leave/test members. </em> bool <strong>tryEnterMutex</strong> (void)</p><p><em>Tries to lock the mutex for the current thread. </em> void <strong>leaveMutex</strong> (void)</p><p><em>Leaving a mutex frees that mutex for use by another thread. </em></p>
<h3>Static Public Member Functions</h3>
<p>static void <strong>setDebug</strong> (bool mode)</p><p><em>Enable or disable deadlock debugging. </em></p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Detailed Description</h2>
        <div class="sectioncontent">
<p>The <strong>Mutex</strong> class is used to protect a section of code so that at any given time only a single thread can perform the protected operation.</p><p>The <strong>Mutex</strong> can be used as a base class to protect access in a derived class. When used in this manner, the ENTER_CRITICAL and LEAVE_CRITICAL macros can be used to specify when code written for the derived class needs to be protected by the default <strong>Mutex</strong> of the derived class, and hence is presumed to be 'thread safe' from multiple instance execution. One of the most basic Common C++ synchronization object is the <strong>Mutex</strong> class. A <strong>Mutex</strong> only allows one thread to continue execution at a given time over a specific section of code. <strong>Mutex</strong>'s have a enter and leave method; only one thread can continue from the Enter until the Leave is called. The next thread waiting can then get through. <strong>Mutex</strong>'s are also known as 'CRITICAL SECTIONS' in win32-speak.</p><p>The <strong>Mutex</strong> is always recursive in that if the same thread invokes the same mutex lock multiple times, it must release it multiple times. This allows a function to call another function which also happens to use the same mutex lock when called directly. This was deemed essential because a mutex might be used to block individual file requests in say, a database, but the same mutex might be needed to block a whole series of database updates that compose a 'transaction' for one thread to complete together without having to write alternate non-locking member functions to invoke for each part of a transaction.</p><p>Strangely enough, the original pthread draft standard does not directly support recursive mutexes. In fact this is the most common 'NP' extension for most pthread implementations. Common C++ emulates recursive mutex behavior when the target platform does not directly support it.</p><p>In addition to the <strong>Mutex</strong>, Common C++ supports a rwlock class. This implements the X/Open recommended 'rwlock'. On systems which do not support rwlock's, the behavior is emulated with a <strong>Mutex</strong>; however, the advantage of a rwlock over a mutex is then entirely lost. There has been some suggested clever hacks for 'emulating' the behavior of a rwlock with a pair of mutexes and a semaphore, and one of these will be adapted for Common C++ in the future for platforms that do not support rwlock's directly.</p><p><strong>Author:</strong></p><p>David Sugar dyfet@ostel.com <strong>Mutex</strong> lock for protected access.</p><p><strong>Examples: </strong> <strong>tcpservice.cpp</strong>, and <strong>tcpthread.cpp</strong>.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Constructor & Destructor Documentation</h2>
        <div class="sectioncontent">
<h3>ost::Mutex::Mutex (const char *name = \fCNULL\fP)</h3>
<p>The mutex is always initialized as a recursive entity.</p><p><strong>Parameters:</strong></p><p><em>name</em> of mutex for optional deadlock detection</p>
<h3>virtual ost::Mutex::~Mutex ()\fC [virtual]\fP</h3>
<p>Destroying the mutex removes any system resources associated with it. If a mutex lock is currently in place, it is presumed to terminate when the <strong>Mutex</strong> is destroyed.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Member Function Documentation</h2>
        <div class="sectioncontent">
<h3>void ost::Mutex::enter (void)\fC [inline]\fP</h3>
<p>Future abi will use enter/leave/test members.</p>
<h3>void ost::Mutex::enterMutex (void)</h3>
<p>Entering a <strong>Mutex</strong> locks the mutex for the current thread. This also can be done using the ENTER_CRITICAL macro or by using the ++ operator on a mutex.</p><p><strong>See Also:</strong></p><p><strong>leaveMutex</strong></p>
<h3>void ost::Mutex::leave (void)\fC [inline]\fP</h3>
<p>Future abi will use enter/leave/test members.</p>
<h3>void ost::Mutex::leaveMutex (void)</h3>
<p>Leaving a mutex frees that mutex for use by another thread. If the mutex has been entered (invoked) multiple times (recursivily) by the same thread, then it will need to be exited the same number of instances before it is free for re-use. This operation can also be done using the LEAVE_CRITICAL macro or by the -- operator on a mutex.</p><p><strong>See Also:</strong></p><p><strong>enterMutex</strong></p>
<h3>void ost::Mutex::nameMutex (const char *name)\fC [inline]\fP</h3>
<p>Enable setting of mutex name for deadlock debug.</p><p><strong>Parameters:</strong></p><p><em>name</em> for mutex.</p>
<h3>static void ost::Mutex::setDebug (boolmode)\fC [inline]\fP, \fC [static]\fP</h3>
<p>Enable or disable deadlock debugging.</p><p><strong>Parameters:</strong></p><p><em>mode</em> debug mode.</p>
<h3>bool ost::Mutex::test (void)\fC [inline]\fP</h3>
<p>Future abi will use enter/leave/test members.</p><p><strong>Returns:</strong></p><p>true if entered.</p>
<h3>bool ost::Mutex::tryEnterMutex (void)</h3>
<p>Tries to lock the mutex for the current thread. Behaves like <strong>enterMutex</strong> , except that it doesn't block the calling thread if the mutex is already locked by another thread.</p><p><strong>Returns:</strong></p><p>true if locking the mutex was succesful otherwise false</p><p><strong>See Also:</strong></p><p><strong>enterMutex</strong></p><p><strong>leaveMutex</strong></p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Author</h2>
        <div class="sectioncontent">
<p>Generated automatically by Doxygen for GNU CommonC++ from the source code.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="ost_MemPagerObject.3.html"><span aria-hidden="true">&larr;</span> ost_MemPagerObject.3: This class is used to create derived classes which are constructed within a memory pager pool.</a></li>
   <li class="next"><a href="ost_MutexCounter.3.html">ost_MutexCounter.3: The mutex counter is a counter variable which can safely be incremented or decremented by multiple threads. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>libcw: General purpose morse code functions library</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="General purpose morse code functions library">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="libcw (3) manual">
  <meta name="twitter:description" content="General purpose morse code functions library">
  <meta name="twitter:image" content="https://www.carta.tech/images/libcw6-dev-libcw-3.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3/libcw.3.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="libcw (3) manual" />
  <meta property="og:description" content="General purpose morse code functions library" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libcw6-dev-libcw-3.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">libcw<small> (3)</small></h1>
        <p class="lead">General purpose morse code functions library</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/">
      <span itemprop="name">Library calls</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/libcw.3.html">
      <span itemprop="name">libcw: General purpose morse code functions library</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libcw6-dev/">
      <span itemprop="name">libcw6-dev</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3/libcw.3.html">
      <span itemprop="name">libcw: General purpose morse code functions library</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
<strong>#include &lt;libcw.h&gt;</strong>

</pre>
<p><strong>int cw_version(void)</strong></p><p><strong>void cw_license(void)</strong></p><p><strong>const char *cw_get_audio_system_label(int audio_system)</strong></p><p><strong>int cw_get_character_count(void)</strong></p><p><strong>void cw_list_characters(char *list)</strong></p><p><strong>int cw_get_maximum_representation_length(void)</strong></p><p><strong>int cw_lookup_character(char c, char *representation)</strong></p><p><strong>char *cw_character_to_representation(int c)</strong></p><p><strong>int cw_check_representation(const char *representation)</strong></p><p><strong>bool cw_representation_is_valid(const char *representation)</strong></p><p><strong>int cw_lookup_representation(const char *representation, char *c)</strong></p><p><strong>int cw_representation_to_character(const char *representation)</strong></p><p><strong>int cw_get_procedural_character_count(void)</strong></p><p><strong>void cw_list_procedural_characters(char *list)</strong></p><p><strong>int cw_get_maximum_procedural_expansion_length(void)</strong></p><p><strong>int cw_lookup_procedural_character(char c, char *expansion, int *is_usually_expanded)</strong></p><p><strong>int cw_get_maximum_phonetic_length(void)</strong></p><p><strong>int cw_lookup_phonetic(char c, char *phonetic)</strong></p><p><strong>void cw_get_speed_limits(int *min_speed, int *max_speed)</strong></p><p><strong>void cw_get_frequency_limits(int *min_frequency, int *max_frequency)</strong></p><p><strong>void cw_get_volume_limits(int *min_volume, int *max_volume)</strong></p><p><strong>void cw_get_gap_limits(int *min_gap, int *max_gap)</strong></p><p><strong>void cw_get_tolerance_limits(int *min_tolerance, int *max_tolerance)</strong></p><p><strong>void cw_get_weighting_limits(int *min_weighting, int *max_weighting)</strong></p><p><strong>void cw_reset_send_receive_parameters(void)</strong></p><p><strong>int cw_set_send_speed(int new_value)</strong></p><p><strong>int cw_set_receive_speed(int new_value)</strong></p><p><strong>int cw_set_frequency(int new_value)</strong></p><p><strong>int cw_set_volume(int new_value)</strong></p><p><strong>int cw_set_gap(int new_value)</strong></p><p><strong>int cw_set_tolerance(int new_value)</strong></p><p><strong>int cw_set_weighting(int new_value)</strong></p><p><strong>int cw_get_send_speed(void)</strong></p><p><strong>int cw_get_receive_speed(void)</strong></p><p><strong>int cw_get_frequency(void)</strong></p><p><strong>int cw_get_volume(void)</strong></p><p><strong>int cw_get_gap(void)</strong></p><p><strong>int cw_get_tolerance(void)</strong></p><p><strong>int cw_get_weighting(void)</strong></p><p><strong>void cw_get_send_parameters(int *dot_usecs, int *dash_usecs,</strong></p><p><strong>                            int *end_of_element_usecs,</strong></p><p><strong>                            int *end_of_character_usecs, int *end_of_word_usecs,</strong></p><p><strong>                            int *additional_usecs, int *adjustment_usecs)</strong></p><p><strong>void cw_get_receive_parameters(int *dot_usecs, int *dash_usecs,</strong></p><p><strong>                               int *dot_min_usecs, int *dot_max_usecs,</strong></p><p><strong>                               int *dash_min_usecs, int *dash_max_usecs,</strong></p><p><strong>                               int *end_of_element_min_usecs,</strong></p><p><strong>                               int *end_of_element_max_usecs,</strong></p><p><strong>                               int *end_of_element_ideal_usecs,</strong></p><p><strong>                               int *end_of_character_min_usecs,</strong></p><p><strong>                               int *end_of_character_max_usecs,</strong></p><p><strong>                               int *end_of_character_ideal_usecs,</strong></p><p><strong>                               int *adaptive_threshold)</strong></p><p><strong>int cw_set_noise_spike_threshold(int new_value)</strong></p><p><strong>int cw_get_noise_spike_threshold(void)</strong></p><p><strong>void cw_block_callback(int block)</strong></p><p><strong>int cw_register_signal_handler(int signal_number, void (*callback_func)(int))</strong></p><p><strong>int cw_unregister_signal_handler(int signal_number)</strong></p><p><strong>const char *cw_get_console_device(void)</strong></p><p><strong>const char *cw_get_soundcard_device(void)</strong></p><p><strong>void cw_complete_reset(void)</strong></p><p><strong>void cw_register_keying_callback(void (*callback_func)(void*, int),</strong></p><p><strong>                                 void *callback_arg)</strong></p><p><strong>int cw_register_tone_queue_low_callback(void (*callback_func)(void*), void *callback_arg, int level)</strong></p><p><strong>bool cw_is_tone_busy(void)</strong></p><p><strong>int cw_wait_for_tone(void)</strong></p><p><strong>int cw_wait_for_tone_queue(void)</strong></p><p><strong>int cw_wait_for_tone_queue_critical(int level)</strong></p><p><strong>bool cw_is_tone_queue_full(void)</strong></p><p><strong>int cw_get_tone_queue_capacity(void)</strong></p><p><strong>int cw_get_tone_queue_length(void)</strong></p><p><strong>void cw_flush_tone_queue(void)</strong></p><p><strong>int cw_queue_tone(int usecs, int frequency)</strong></p><p><strong>void cw_reset_tone_queue(void)</strong></p><p><strong>int cw_send_dot(void)</strong></p><p><strong>int cw_send_dash(void)</strong></p><p><strong>int cw_send_character_space(void)</strong></p><p><strong>int cw_send_word_space(void)</strong></p><p><strong>int cw_send_representation(const char *representation)</strong></p><p><strong>int cw_send_representation_partial(const char *representation)</strong></p><p><strong>bool cw_character_is_valid(char c)</strong></p><p><strong>int cw_send_character(char c)</strong></p><p><strong>int cw_send_character_partial(char c)</strong></p><p><strong>bool cw_string_is_valid(const char *string)</strong></p><p><strong>int cw_send_string(const char *string)</strong></p><p><strong>void cw_get_receive_statistics(double *dot_sd, double *dash_sd,</strong></p><p><strong>                               double *element_end_sd, double *character_end_sd)</strong></p><p><strong>void cw_reset_receive_statistics(void)</strong></p><p><strong>void cw_enable_adaptive_receive(void)</strong></p><p><strong>void cw_disable_adaptive_receive(void)</strong></p><p><strong>bool cw_get_adaptive_receive_state(void)</strong></p><p><strong>int cw_start_receive_tone(const struct timeval *timestamp)</strong></p><p><strong>int cw_end_receive_tone(const struct timeval *timestamp)</strong></p><p><strong>int cw_receive_buffer_dot(const struct timeval *timestamp)</strong></p><p><strong>int cw_receive_buffer_dash(const struct timeval *timestamp)</strong></p><p><strong>int cw_receive_representation(const struct timeval *timestamp,</strong></p><p><strong>                              /* out */ char *representation,</strong></p><p><strong>                              /* out */ bool *is_end_of_word, /* out */ bool *is_error)</strong></p><p><strong>int cw_receive_character(const struct timeval *timestamp,</strong></p><p><strong>                         /* out */ char *c,</strong></p><p><strong>                         /* out */ bool *is_end_of_word, /* out */ bool *is_error)</strong></p><p><strong>void cw_clear_receive_buffer(void)</strong></p><p><strong>int cw_get_receive_buffer_capacity(void)</strong></p><p><strong>int cw_get_receive_buffer_length(void)</strong></p><p><strong>void cw_reset_receive(void)</strong></p><p><strong>void cw_enable_iambic_curtis_mode_b(void)</strong></p><p><strong>void cw_disable_iambic_curtis_mode_b(void)</strong></p><p><strong>int cw_get_iambic_curtis_mode_b_state(void)</strong></p><p><strong>int cw_notify_keyer_paddle_event(int dot_paddle_state,</strong></p><p><strong>                                 int dash_paddle_state)</strong></p><p><strong>int cw_notify_keyer_dot_paddle_event(int dot_paddle_state)</strong></p><p><strong>int cw_notify_keyer_dash_paddle_event(int dash_paddle_state)</strong></p><p><strong>void cw_get_keyer_paddles(int *dot_paddle_state, int *dash_paddle_state)</strong></p><p><strong>void cw_get_keyer_paddle_latches(int *dot_paddle_latch_state,</strong></p><p><strong>                                 int *dash_paddle_latch_state)</strong></p><p><strong>bool cw_is_keyer_busy(void)</strong></p><p><strong>int cw_wait_for_keyer_element(void)</strong></p><p><strong>int cw_wait_for_keyer(void)</strong></p><p><strong>void cw_reset_keyer(void)</strong></p><p><strong>int cw_notify_straight_key_event(int key_state)</strong></p><p><strong>int cw_get_straight_key_state(void)</strong></p><p><strong>bool cw_is_straight_key_busy(void)</strong></p><p><strong>void cw_reset_straight_key(void)</strong></p><p><strong>const char *cw_generator_get_audio_system_label(void)</strong></p><p><strong>int cw_generator_new(int audio_system, const char *device)</strong></p><p><strong>void cw_generator_delete(void)</strong></p><p><strong>int cw_generator_start(void)</strong></p><p><strong>void cw_generator_stop(void)</strong></p><p><strong>int cw_generator_set_tone_slope(cw_gen_t *gen, int slope_shape, int slope_usecs)</strong></p><p><strong>unsigned int test_cw_tone_queue_test_capacity1(void)</strong></p><p><strong>unsigned int test_cw_tone_queue_test_capacity2(void)</strong></p><p><strong>int test_cw_tone_queue_capacity_test_init(cw_tone_queue_t *tq, uint32_t capacity, uint32_t high_water_mark, int head_shift)</strong></p><h3>DESCRIPTION</h3>
<p><strong>libcw</strong> is a general purpose CW (Morse code) functions library.  It contains routines for converting characters into Morse code representations and back again, for sending Morse code characters, and for receiving characters.  It also contains routines to emulate an Iambic Morse keyer, and a straight key.</p><p>The library can be included in any program that wishes to make use of these features.  It forms the heart of three Morse code tutor applications that accompany the package in which it is distributed.</p><p>See the <strong>cw</strong>(7) man page for information on Morse code timings, and the dot and dash representations for the various Morse characters.</p>
<h3>TONE QUEUE</h3>
<p><strong>libcw</strong> contains an inbuilt tone queue.  The queue is emptied by background processing, using SIGALRM calls and itimers, so a caller program can continue with other tasks while the library sends tones and keys any external device.</p><p>As well as being used by the library functions that sound Morse code characters and provide a keyer sidetone, the primitive tone queue functions are publicly available to caller programs.</p>
<h3>CONTROLLING AN EXTERNAL DEVICE</h3>
<p><strong>libcw</strong> may be passed the address of a function that controls external keying. This function is called each time the library changes the keying state, either as a result of sending a Morse character or representation, or as a result of an iambic keyer or straight key state change.  The argument passed is a single integer, TRUE for key-down, and FALSE for key-up.</p><p><strong>libcw</strong> calls the external keying function only when the keying state changes. A call is likely each time a tone is taken off the tone queue.</p>
<h3>SENDING CW CHARACTERS AND STRINGS</h3>
<p><strong>libcw</strong> offers several functions that send individual characters and character strings as Morse code.  It also offers functions that allow specialized 'representations' to be sent.  A 'representation' is an ASCII string that consists of only the characters '.' and '-'.</p><p>Characters and strings are converted into representations, and then the correct tones for the dots and dashes in these representations are queued on the tone queue, for action by the background queue emptying process.</p>
<h3>RECEIVING CW CHARACTERS AND REPRESENTATIONS</h3>
<p><strong>libcw</strong> contains functions to allow it to receive Morse code.  To receive, the library must be told when a tone start is detected, and when a tone end is detected.  It then determines whether the tone was a dot or a dash depending on the timing difference between the two.  After the required silence gap has passed, the library may be queried to see what the received representation or character was.</p><p>Errors in receiving may be detected by means of the flags passed back on receive character functions.</p>
<h3>IAMBIC KEYER</h3>
<p><strong>libcw</strong> offers functions to simulate an Iambic Morse keyer.  The caller program needs to tell the library of paddle state changes.  Iambic keyer functions are mutually exclusive with character send and straight key functions.</p>
<h3>STRAIGHT KEY</h3>
<p><strong>libcw</strong> offers simple functions to allow effective pass-through of straight key information.  The caller program needs to tell the library of key state changes.  Straight key functions are mutually exclusive with character send and iambic keyer functions.</p>
<h3>RETURN CODES</h3>
<p>Some of the library's function return a return code of type int. The return code has two values, as defined in libcw.h: <strong>CW_SUCCESS</strong> or <strong>CW_FAILURE</strong>. The two symbolic constants are guaranteed to be identical to boolean <strong>true</strong> and <strong>false</strong>.</p>
<h3>FUNCTIONS</h3>
<p>The following list describes the functions available to a <strong>libcw</strong> caller:</p><p><strong>int cw_version(void)</strong></p><p>Brief: Return version number of libcw library</p><p>Return the version number of the library. Version numbers (major and minor) are returned as an int, composed of major_version &lt;&lt; 16 | minor_version.</p><p>testedin::test_cw_version()</p><p>Returns: library's major and minor version number encoded as single int</p><p><strong>void cw_license(void)</strong></p><p>Brief: Print libcw's license text to stdout</p><p>testedin::test_cw_license()</p><p>Function prints information about libcw version, followed by short text presenting libcw's copyright and license notice.</p><p><strong>const char *cw_get_audio_system_label(int audio_system)</strong></p><p>Brief: Get a readable label of given audio system</p><p>The function returns one of following strings: None, Null, Console, OSS, ALSA, PulseAudio, Soundcard</p><p>Returned pointer is owned and managed by the library.</p><p>TODO: change the declaration to "const char *const cw_get_audio_system_label(...)"?</p><p>Parameter: audio_system - ID of audio system</p><p>Returns: audio system's label</p><p><strong>int cw_get_character_count(void)</strong></p><p>Brief: Return the number of characters present in character lookup table</p><p>Return the number of characters that are known to libcw. The number includes:</p>
<dl class='dl-vertical'>
  <dt>
    \[bu]
  </dt>
  <dd>
    <p> ASCII 7bit letters,</p>
  </dd>
  <dt>
    \[bu]
  </dt>
  <dd>
    <p> numerals,</p>
  </dd>
  <dt>
    \[bu]
  </dt>
  <dd>
    <p> punctuation,</p>
  </dd>
  <dt>
    \[bu]
  </dt>
  <dd>
    <p> ISO 8859-1 accented characters,</p>
  </dd>
  <dt>
    \[bu]
  </dt>
  <dd>
    <p> ISO 8859-2 accented characters,</p>
  </dd>
  <dt>
    \[bu]
  </dt>
  <dd>
    <p> non-standard procedural signal extensions to standard CW characters.</p>
  </dd>

</dl>
<p>testedin::test_character_lookups()</p><p>Returns: number of characters known to libcw</p><p><strong>void cw_list_characters(char *list)</strong></p><p>Brief: Get list of characters present in character lookup table</p><p>Function provides a string containing all of the characters represented in library's lookup table.</p><p>The list includes:</p>
<dl class='dl-vertical'>
  <dt>
    \[bu]
  </dt>
  <dd>
    <p> ASCII 7bit letters,</p>
  </dd>
  <dt>
    \[bu]
  </dt>
  <dd>
    <p> numerals,</p>
  </dd>
  <dt>
    \[bu]
  </dt>
  <dd>
    <p> punctuation,</p>
  </dd>
  <dt>
    \[bu]
  </dt>
  <dd>
    <p> ISO 8859-1 accented characters,</p>
  </dd>
  <dt>
    \[bu]
  </dt>
  <dd>
    <p> ISO 8859-2 accented characters,</p>
  </dd>
  <dt>
    \[bu]
  </dt>
  <dd>
    <p> non-standard procedural signal extensions to standard CW characters.</p>
  </dd>

</dl>
<p><strong>list</strong> should be allocated and managed by caller. The length of <strong>list</strong> must be at least one greater than the number of characters represented in the character lookup table, returned by cw_get_character_count().</p><p>testedin::test_character_lookups()</p><p>Parameter: list - pointer to space to be filled by function</p><p><strong>int cw_get_maximum_representation_length(void)</strong></p><p>Brief: Get length of the longest representation</p><p>Function returns the string length of the longest representation in the character lookup table.</p><p>testedin::test_character_lookups()</p><p>Returns: a positive number - length of the longest representation</p><p><strong>int cw_lookup_character(char c, char *representation)</strong></p><p>Brief: Get representation of a given character</p><p>The function is depreciated, use cw_character_to_representation() instead.</p><p>Return the string representation (shape) of a given Morse code character <strong>c</strong>.</p><p>The routine returns CW_SUCCESS on success, and fills in the string pointer (<strong>representation</strong>) passed in. On failure, it returns CW_FAILURE and sets errno to ENOENT, indicating that the character <strong>c</strong> could not be found.</p><p>The length of <strong>representation</strong> buffer must be at least one greater than the length of longest representation held in the character lookup table. The largest value of length is returned by cw_get_maximum_representation_length().</p><p>Parameter: c - character to look up</p><p>Parameter: representation - pointer to space for representation of character</p><p>Returns: CW_SUCCESS on success</p><p>Returns: CW_FAILURE on failure</p><p><strong>char *cw_character_to_representation(int c)</strong></p><p>Brief: Get representation of a given character</p><p>On success return representation of a given character. Returned pointer is owned by caller of the function.</p><p>On failure function returns NULL and sets errno: ENOENT indicates that the character could not be found. ENOMEM indicates that character has been found, but function failed to strdup() representation.</p><p>testedin::test_character_lookups()</p><p>Parameter: c - character to look up</p><p>Returns: pointer to freshly allocated representation on success</p><p>Returns: NULL on failure</p><p><strong>int cw_check_representation(const char *representation)</strong></p><p>Brief: Check if representation of a character is valid</p><p>This function is depreciated, use cw_representation_is_valid() instead.</p><p>Check that the given string is a valid Morse representation. A valid string is one composed of only "." and "-" characters.</p><p>If representation is invalid, function returns CW_FAILURE and sets errno to EINVAL.</p><p>Parameter: representation - representation of a character to check</p><p>Returns: CW_SUCCESS on success</p><p>Returns: CW_FAILURE on failure</p><p><strong>bool cw_representation_is_valid(const char *representation)</strong></p><p>Brief: Check if representation of a character is valid</p><p>Check that the given string is a valid Morse representation. A valid string is one composed of only "." and "-" characters. This means that the function checks only if representation is error-free, and not whether the representation represents existing/defined character.</p><p>If representation is invalid, function returns false and sets errno to EINVAL.</p><p>testedin::test_representations()</p><p>Parameter: representation - representation of a character to check</p><p>Returns: true on success</p><p>Returns: false on failure</p><p><strong>int cw_lookup_representation(const char *representation, char *c)</strong></p><p>Brief: Get the character represented by a given Morse representation</p><p>This function is depreciated, use cw_representation_to_character() instead.</p><p>Function checks <strong>representation</strong>, and if it is valid and represents a known character, function returns CW_SUCCESS. Additionally, if <strong>c</strong> is non-NULL, function puts the looked up character in <strong>c</strong>.</p><p><strong>c</strong> should be allocated by caller. Function assumes that <strong>c</strong> being NULL pointer is a valid situation, and can return CW_SUCCESS in such situation.</p><p>On error, function returns CW_FAILURE. errno is set to EINVAL if any character of the representation is invalid, or ENOENT to indicate that the character represented by <strong>representation</strong> could not be found.</p><p>Parameter: representation - representation of a character to look up</p><p>Parameter: c - location where to put looked up character</p><p>Returns: CW_SUCCESS on success</p><p>Returns: CW_FAILURE on failure</p><p><strong>int cw_representation_to_character(const char *representation)</strong></p><p>Brief: Return the character represented by a given Morse representation</p><p>Function checks <strong>representation</strong>, and if it is valid and represents a known character, function returns the character (a non-zero value).</p><p>On error, function returns zero. errno is set to EINVAL if any character of the representation is invalid, or ENOENT to indicate that the character represented by <strong>representation</strong> could not be found.</p><p>testedin::test_character_lookups()</p><p>Parameter: representation - representation of a character to look up</p><p>Returns: non-zero character on success</p><p>Returns: zero on failure</p><p><strong>int cw_get_procedural_character_count(void)</strong></p><p>Brief: Get number of procedural signals</p><p>testedin::test_prosign_lookups()</p><p>Returns: the number of characters represented in the procedural signal expansion lookup table</p><p><strong>void cw_list_procedural_characters(char *list)</strong></p><p>Brief: Get list of characters for which procedural expansion is available</p><p>Function returns into <strong>list</strong> a string containing all of the Morse characters for which procedural expansion is available.  The length of <strong>list</strong> must be at least by one greater than the number of characters represented in the procedural signal expansion lookup table, returned by cw_get_procedural_character_count().</p><p><strong>list</strong> is managed by caller</p><p>testedin::test_prosign_lookups()</p><p>Parameter: list - space for returned characters</p><p><strong>int cw_get_maximum_procedural_expansion_length(void)</strong></p><p>Brief: Get length of the longest procedural expansion</p><p>Function returns the string length of the longest expansion in the procedural signal expansion table.</p><p>testedin::test_prosign_lookups()</p><p>Returns: length</p><p><strong>int cw_lookup_procedural_character(char c, char *expansion, int *is_usually_expanded)</strong></p><p>Brief: Get the string expansion of a given Morse code procedural signal character</p><p>On success the function - fills <strong>expansion</strong> with the string expansion of a given Morse code procedural signal character <strong>c</strong>; - sets is_usuall_expanded to true as a display hint for the caller; - returns CW_SUCCESS.</p><p>Both <strong>expansion</strong> and <strong>expansion</strong> must be allocated and managed by caller. They can be NULL, then the function won't attempt to use them.</p><p>The length of <strong>expansion</strong> must be at least by one greater than the longest expansion held in the procedural signal character lookup table, as returned by cw_get_maximum_procedural_expansion_length().</p><p>If procedural signal character <strong>c</strong> cannot be found, the function sets errno to ENOENT and returns CW_FAILURE.</p><p>testedin::test_prosign_lookups()</p><p>Parameter: c - character to look up</p><p>Parameter: expansion - output, space to fill with expansion of the character</p><p>Parameter: is_usually_expanded - visual hint</p><p>Returns: CW_FAILURE on failure (errno is set to ENOENT)</p><p>Returns: CW_SUCCESS on success</p><p><strong>int cw_get_maximum_phonetic_length(void)</strong></p><p>Brief: Get maximum length of a phonetic</p><p>testedin::test_phonetic_lookups()</p><p>Returns: the string length of the longest phonetic in the phonetics lookup table</p><p><strong>int cw_lookup_phonetic(char c, char *phonetic)</strong></p><p>Brief: Get the phonetic of a given character</p><p>On success the routine fills in the string pointer passed in with the phonetic of given character <strong>c</strong>.</p><p>The length of phonetic must be at least one greater than the longest phonetic held in the phonetic lookup table, as returned by cw_get_maximum_phonetic_length().</p><p>If character cannot be found, the function sets errno to ENOENT.</p><p>testedin::test_phonetic_lookups()</p><p>Parameter: c - character to look up</p><p>Parameter: phonetic - output, space for phonetic of a character</p><p>Returns: CW_SUCCESS on success</p><p>Returns: CW_FAILURE on failure</p><p><strong>void cw_get_speed_limits(int *min_speed, int *max_speed)</strong></p><p>Brief: Get speed limits</p><p>Get (through function's arguments) limits on speed of morse code that can be generated by generator.</p><p>See CW_SPEED_MIN and CW_SPEED_MAX in libcw.h for values.</p><p>testedin::test_cw_get_x_limits()</p><p>Parameter: min_speed - minimal allowed speed</p><p>Parameter: max_speed - maximal allowed speed</p><p><strong>void cw_get_frequency_limits(int *min_frequency, int *max_frequency)</strong></p><p>Brief: Get frequency limits</p><p>Get (through function's arguments) limits on frequency that can be generated by generator.</p><p>See CW_FREQUENCY_MIN and CW_FREQUENCY_MAX in libcw.h for values.</p><p>testedin::test_cw_get_x_limits()</p><p>Parameter: min_frequency - minimal allowed frequency</p><p>Parameter: max_frequency - maximal allowed frequency</p><p><strong>void cw_get_volume_limits(int *min_volume, int *max_volume)</strong></p><p>Brief: Get volume limits</p><p>Get (through function's arguments) limits on volume of sound generated by generator.</p><p>See CW_VOLUME_MIN and CW_VOLUME_MAX in libcw.h for values.</p><p>testedin::test_cw_get_x_limits() testedin::test_volume_functions()</p><p>Parameter: min_volume - minimal allowed volume</p><p>Parameter: max_volume - maximal allowed volume</p><p><strong>void cw_get_gap_limits(int *min_gap, int *max_gap)</strong></p><p>Brief: Get gap limits</p><p>Get (through function's arguments) limits on gap in cw signal generated by generator.</p><p>See CW_GAP_MIN and CW_GAP_MAX in libcw.h for values.</p><p>testedin::test_cw_get_x_limits()</p><p>Parameter: min_gap - minimal allowed gap</p><p>Parameter: max_gap - maximal allowed gap</p><p><strong>void cw_get_tolerance_limits(int *min_tolerance, int *max_tolerance)</strong></p><p>Brief: Get tolerance limits</p><p>Get (through function's arguments) limits on "tolerance" parameter of generator.</p><p>See CW_TOLERANCE_MIN and CW_TOLERANCE_MAX in libcw.h for values.</p><p>testedin::test_cw_get_x_limits()</p><p>Parameter: min_tolerance - minimal allowed tolerance</p><p>Parameter: max_tolerance - maximal allowed tolerance</p><p><strong>void cw_get_weighting_limits(int *min_weighting, int *max_weighting)</strong></p><p>Brief: Get weighting limits</p><p>Get (through function's arguments) limits on "weighting" parameter of generator.</p><p>See CW_WEIGHTING_MIN and CW_WEIGHTING_MAX in libcw.h for values.</p><p>testedin::test_cw_get_x_limits()</p><p>Parameter: min_weighting - minimal allowed weighting</p><p>Parameter: max_weighting - maximal allowed weighting</p><p><strong>void cw_reset_send_receive_parameters(void)</strong></p><p>Brief: Reset send/receive parameters</p><p>Reset the library speed, frequency, volume, gap, tolerance, weighting, adaptive receive, and noise spike threshold to their initial default values: send/receive speed 12 WPM, volume 70 %, frequency 800 Hz, gap 0 dots, tolerance 50 %, and weighting 50 %.</p><p><strong>int cw_set_send_speed(int new_value)</strong></p><p>Brief: Set sending speed of generator</p><p>See libcw.h/CW_SPEED_{INITIAL|MIN|MAX} for initial/minimal/maximal value of send speed.</p><p>errno is set to EINVAL if <strong>new_value</strong> is out of range.</p><p>testedin::test_parameter_ranges()</p><p>Parameter: new_value - new value of send speed to be assigned to generator</p><p>Returns: CW_SUCCESS on success</p><p>Returns: CW_FAILURE on failure</p><p><strong>int cw_set_receive_speed(int new_value)</strong></p><p>Brief: Set receiving speed of receiver</p><p>See documentation of cw_set_send_speed() for more information.</p><p>See libcw.h/CW_SPEED_{INITIAL|MIN|MAX} for initial/minimal/maximal value of receive speed. errno is set to EINVAL if <strong>new_value</strong> is out of range. errno is set to EPERM if adaptive receive speed tracking is enabled.</p><p>testedin::test_parameter_ranges()</p><p>Parameter: new_value - new value of receive speed to be assigned to receiver</p><p>Returns: CW_SUCCESS on success</p><p>Returns: CW_FAILURE on failure</p><p><strong>int cw_set_frequency(int new_value)</strong></p><p>Brief: Set frequency of generator</p><p>Set frequency of sound wave generated by generator. The frequency must be within limits marked by CW_FREQUENCY_MIN and CW_FREQUENCY_MAX.</p><p>See libcw.h/CW_FREQUENCY_{INITIAL|MIN|MAX} for initial/minimal/maximal value of frequency.</p><p>errno is set to EINVAL if <strong>new_value</strong> is out of range.</p><p>testedin::test_parameter_ranges()</p><p>Parameter: new_value - new value of frequency to be assigned to generator</p><p>Returns: CW_SUCCESS on success</p><p>Returns: CW_FAILURE on failure</p><p><strong>int cw_set_volume(int new_value)</strong></p><p>Brief: Set volume of generator</p><p>Set volume of sound wave generated by generator. The volume must be within limits marked by CW_VOLUME_MIN and CW_VOLUME_MAX.</p><p>Note that volume settings are not fully possible for the console speaker. In this case, volume settings greater than zero indicate console speaker sound is on, and setting volume to zero will turn off console speaker sound.</p><p>See libcw.h/CW_VOLUME_{INITIAL|MIN|MAX} for initial/minimal/maximal value of volume. errno is set to EINVAL if <strong>new_value</strong> is out of range.</p><p>testedin::test_volume_functions() testedin::test_parameter_ranges()</p><p>Parameter: new_value - new value of volume to be assigned to generator</p><p>Returns: CW_SUCCESS on success</p><p>Returns: CW_FAILURE on failure</p><p><strong>int cw_set_gap(int new_value)</strong></p><p>Brief: Set sending gap of generator</p><p>See libcw.h/CW_GAP_{INITIAL|MIN|MAX} for initial/minimal/maximal value of gap. errno is set to EINVAL if <strong>new_value</strong> is out of range.</p><p>testedin::test_parameter_ranges()</p><p>Parameter: new_value - new value of gap to be assigned to generator</p><p>Returns: CW_SUCCESS on success</p><p>Returns: CW_FAILURE on failure</p><p><strong>int cw_set_tolerance(int new_value)</strong></p><p>Brief: Set tolerance for receiver</p><p>See libcw.h/CW_TOLERANCE_{INITIAL|MIN|MAX} for initial/minimal/maximal value of tolerance. errno is set to EINVAL if <strong>new_value</strong> is out of range.</p><p>testedin::test_parameter_ranges()</p><p>Parameter: new_value - new value of tolerance to be assigned to receiver</p><p>Returns: CW_SUCCESS on success</p><p>Returns: CW_FAILURE on failure</p><p><strong>int cw_set_weighting(int new_value)</strong></p><p>Brief: Set sending weighting for generator</p><p>See libcw.h/CW_WEIGHTING_{INITIAL|MIN|MAX} for initial/minimal/maximal value of weighting. errno is set to EINVAL if <strong>new_value</strong> is out of range.</p><p>testedin::test_parameter_ranges()</p><p>Parameter: new_value - new value of weighting to be assigned for generator</p><p>Returns: CW_SUCCESS on success</p><p>Returns: CW_FAILURE on failure</p><p><strong>int cw_get_send_speed(void)</strong></p><p>Brief: Get sending speed from generator</p><p>testedin::test_parameter_ranges()</p><p>Returns: current value of the generator's send speed</p><p><strong>int cw_get_receive_speed(void)</strong></p><p>Brief: Get receiving speed from receiver</p><p>testedin::test_parameter_ranges()</p><p>Returns: current value of the receiver's receive speed</p><p><strong>int cw_get_frequency(void)</strong></p><p>Brief: Get frequency from generator</p><p>Function returns "frequency" parameter of generator, even if the generator is stopped, or volume of generated sound is zero.</p><p>testedin::test_parameter_ranges()</p><p>Returns: current value of generator's frequency</p><p><strong>int cw_get_volume(void)</strong></p><p>Brief: Get sound volume from generator</p><p>Function returns "volume" parameter of generator, even if the generator is stopped.</p><p>testedin::test_volume_functions() testedin::test_parameter_ranges()</p><p>Returns: current value of generator's sound volume</p><p><strong>int cw_get_gap(void)</strong></p><p>Brief: Get sending gap from generator</p><p>testedin::test_parameter_ranges()</p><p>Returns: current value of generator's sending gap</p><p><strong>int cw_get_tolerance(void)</strong></p><p>Brief: Get tolerance from receiver</p><p>testedin::test_parameter_ranges()</p><p>Returns: current value of receiver's tolerance</p><p><strong>int cw_get_weighting(void)</strong></p><p>Brief: Get sending weighting from generator</p><p>testedin::test_parameter_ranges()</p><p>Returns: current value of generator's sending weighting</p><p><strong>void cw_get_send_parameters(int *dot_usecs, int *dash_usecs,</strong></p><p><strong>                         int *end_of_element_usecs,</strong></p><p><strong>                         int *end_of_character_usecs, int *end_of_word_usecs,</strong></p><p><strong>                         int *additional_usecs, int *adjustment_usecs)</strong></p><p>Brief: Get timing parameters for sending</p><p>Return the low-level timing parameters calculated from the speed, gap, tolerance, and weighting set.  Parameter values are returned in microseconds.</p><p>Use NULL for the pointer argument to any parameter value not required.</p><p>Parameter: dot_usecs</p><p>Parameter: dash_usecs</p><p>Parameter: end_of_element_usecs</p><p>Parameter: end_of_character_usecs</p><p>Parameter: end_of_word_usecs</p><p>Parameter: additional_usecs</p><p>Parameter: adjustment_usecs</p><p><strong>void cw_get_receive_parameters(int *dot_usecs, int *dash_usecs,</strong></p><p><strong>                            int *dot_min_usecs, int *dot_max_usecs,</strong></p><p><strong>                            int *dash_min_usecs, int *dash_max_usecs,</strong></p><p><strong>                            int *end_of_element_min_usecs,</strong></p><p><strong>                            int *end_of_element_max_usecs,</strong></p><p><strong>                            int *end_of_element_ideal_usecs,</strong></p><p><strong>                            int *end_of_character_min_usecs,</strong></p><p><strong>                            int *end_of_character_max_usecs,</strong></p><p><strong>                            int *end_of_character_ideal_usecs,</strong></p><p><strong>                            int *adaptive_threshold)</strong></p><p>Brief: Get timing parameters for receiving, and adaptive threshold</p><p>Return the low-level timing parameters calculated from the speed, gap, tolerance, and weighting set.  Parameter values are returned in microseconds.</p><p>Use NULL for the pointer argument to any parameter value not required.</p><p>Parameter: dot_usecs</p><p>Parameter: dash_usecs</p><p>Parameter: dot_min_usecs</p><p>Parameter: dot_max_usecs</p><p>Parameter: dash_min_usecs</p><p>Parameter: dash_max_usecs</p><p>Parameter: end_of_element_min_usecs</p><p>Parameter: end_of_element_max_usecs</p><p>Parameter: end_of_element_ideal_usecs</p><p>Parameter: end_of_character_min_usecs</p><p>Parameter: end_of_character_max_usecs</p><p>Parameter: end_of_character_ideal_usecs</p><p>Parameter: adaptive_threshold</p><p><strong>int cw_set_noise_spike_threshold(int new_value)</strong></p><p>Brief: Set noise spike threshold for receiver</p><p>Set the period shorter than which, on receive, received tones are ignored. This allows the receive tone functions to apply noise canceling for very short apparent tones. For useful results the value should never exceed the dot length of a dot at maximum speed: 20000 microseconds (the dot length at 60WPM). Setting a noise threshold of zero turns off receive tone noise canceling.</p><p>The default noise spike threshold is 10000 microseconds.</p><p>errno is set to EINVAL if <strong>new_value</strong> is out of range.</p><p>Parameter: new_value - new value of noise spike threshold to be assigned to receiver</p><p>Returns: CW_SUCCESS on success</p><p>Returns: CW_FAILURE on failure</p><p><strong>int cw_get_noise_spike_threshold(void)</strong></p><p>Brief: Get noise spike threshold from receiver</p><p>See documentation of cw_set_noise_spike_threshold() for more information</p><p>Returns: current value of receiver's threshold</p><p><strong>void cw_block_callback(int block)</strong></p><p>Brief: Block the callback from being called</p><p>Function blocks the callback from being called for a critical section of caller code if <strong>block</strong> is true, and unblocks the callback if <strong>block</strong> is false.</p><p>Function works by blocking SIGALRM; a block should always be matched by an unblock, otherwise the tone queue will suspend forever.</p><p>Parameter: block - pass 1 to block SIGALRM, and 0 to unblock it</p><p><strong>int cw_register_signal_handler(int signal_number, void (*callback_func)(int))</strong></p><p>Brief: Register a signal handler and optional callback function for given signal number</p><p>On receipt of that signal, all library features will be reset to their default states.  Following the reset, if <strong>callback_func</strong> is a function pointer, the function is called; if it is SIG_DFL, the library calls exit(); and if it is SIG_IGN, the library returns from the signal handler.</p><p>This is a convenience function for clients that need to clean up library on signals, with either exit, continue, or an additional function call; in effect, a wrapper round a restricted form of sigaction.</p><p>The <strong>signal_number</strong> argument indicates which signal to catch.</p><p>On problems errno is set to EINVAL if <strong>signal_number</strong> is invalid or if a handler is already installed for that signal, or to the sigaction error code.</p><p>Parameter: signal_number</p><p>Parameter: callback_func</p><p>Returns: CW_SUCCESS - if the signal handler installs correctly</p><p>Returns: CW_FAILURE - on errors or problems</p><p><strong>int cw_unregister_signal_handler(int signal_number)</strong></p><p>Brief: Unregister a signal handler interception</p><p>Function removes a signal handler interception previously registered with cw_register_signal_handler().</p><p>Parameter: signal_number</p><p>Returns: true if the signal handler uninstalls correctly</p><p>Returns: false otherwise (with errno set to EINVAL or to the sigaction error code)</p><p><strong>const char *cw_get_console_device(void)</strong></p><p>Brief: Return char string with console device path</p><p>Returned pointer is owned by library.</p><p>Returns: char string with current console device path</p><p><strong>const char *cw_get_soundcard_device(void)</strong></p><p>Brief: Return char string with soundcard device name/path</p><p>Returned pointer is owned by library.</p><p>Returns: char string with current soundcard device name or device path</p><p><strong>void cw_complete_reset(void)</strong></p><p>Brief: Reset all library features to their default states</p><p>Clears the tone queue, receive buffers and retained state information, any current keyer activity, and any straight key activity, returns to silence, and closes soundcard and console devices.  This function is suitable for calling from an application exit handler.</p><p><strong>void cw_register_keying_callback(void (*callback_func)(void*, int),</strong></p><p><strong>                             void *callback_arg)</strong></p><p>Brief: Register external callback function for keying</p><p>Register a <strong>callback_func</strong> function that should be called when a state of a key changes from "key open" to "key closed", or vice-versa.</p><p>The first argument passed to the registered callback function is the supplied <strong>callback_arg</strong>, if any.  The second argument passed to registered callback function is the key state: CW_KEY_STATE_CLOSED (one/true) for "key closed", and CW_KEY_STATE_OPEN (zero/false) for "key open".</p><p>Calling this routine with a NULL function address disables keying callbacks.  Any callback supplied will be called in signal handler context (??).</p><p>Parameter: callback_func - callback function to be called on key state changes</p><p>Parameter: callback_arg - first argument to callback_func</p><p><strong>int cw_register_tone_queue_low_callback(void (*callback_func)(void*), void *callback_arg, int level)</strong></p><p>Brief: Register callback for low queue state</p><p>Register a function to be called automatically by the dequeue routine whenever the tone queue falls to a given <strong>level</strong>. To be more precise: the callback is called by queue manager if, after dequeueing a tone, the manager notices that tone queue length has become equal or less than <strong>level</strong>.</p><p><strong>callback_arg</strong> may be used to give a value passed back on callback calls.  A NULL function pointer suppresses callbacks.  On success, the routine returns CW_SUCCESS.</p><p>If <strong>level</strong> is invalid, the routine returns CW_FAILURE with errno set to EINVAL.  Any callback supplied will be called in signal handler context.</p><p>testedin::test_tone_queue_callback()</p><p>Parameter: callback_func - callback function to be registered</p><p>Parameter: callback_arg - argument for callback_func to pass return value</p><p>Parameter: level - low level of queue triggering callback call</p><p>Returns: CW_SUCCESS on successful registration</p><p>Returns: CW_FAILURE on failure</p><p><strong>bool cw_is_tone_busy(void)</strong></p><p>Brief: Check if tone sender is busy</p><p>Indicate if the tone sender is busy.</p><p>Returns: true if there are still entries in the tone queue</p><p>Returns: false if the queue is empty</p><p><strong>int cw_wait_for_tone(void)</strong></p><p>Brief: Wait for the current tone to complete</p><p>The routine returns CW_SUCCESS on success.  If called with SIGALRM blocked, the routine returns CW_FAILURE, with errno set to EDEADLK, to avoid indefinite waits.</p><p>testedin::test_tone_queue_1() testedin::test_tone_queue_2()</p><p>Returns: CW_SUCCESS on success</p><p>Returns: CW_FAILURE on failure</p><p><strong>int cw_wait_for_tone_queue(void)</strong></p><p>Brief: Wait for the tone queue to drain</p><p>The routine returns CW_SUCCESS on success. If called with SIGALRM blocked, the routine returns false, with errno set to EDEADLK, to avoid indefinite waits.</p><p>testedin::test_tone_queue_1() testedin::test_tone_queue_2() testedin::test_tone_queue_3()</p><p>Returns: CW_SUCCESS on success</p><p>Returns: CW_FAILURE on failure</p><p><strong>int cw_wait_for_tone_queue_critical(int level)</strong></p><p>Brief: Wait for the tone queue to drain until only as many tones as given in level remain queued</p><p>This routine is for use by programs that want to optimize themselves to avoid the cleanup that happens when the tone queue drains completely; such programs have a short time in which to add more tones to the queue.</p><p>The routine returns CW_SUCCESS on success.  If called with SIGALRM blocked, the routine returns false, with errno set to EDEADLK, to avoid indefinite waits.</p><p>Parameter: level - low level in queue, at which to return</p><p>Returns: CW_SUCCESS on success</p><p>Returns: CW_FAILURE on failure</p><p><strong>bool cw_is_tone_queue_full(void)</strong></p><p>Brief: Indicate if the tone queue is full</p><p>testedin::test_cw_tone_queue_is_full_internal()</p><p>Returns: true if tone queue is full</p><p>Returns: false if tone queue is not full</p><p><strong>int cw_get_tone_queue_capacity(void)</strong></p><p>Brief: Return the number of entries the tone queue can accommodate</p><p>testedin::test_tone_queue_3() testedin::test_cw_tone_queue_get_capacity_internal()</p><p><strong>int cw_get_tone_queue_length(void)</strong></p><p>Brief: Return the number of entries currently pending in the tone queue</p><p>testedin::test_cw_tone_queue_length_internal() testedin::test_tone_queue_1() testedin::test_tone_queue_3()</p><p><strong>void cw_flush_tone_queue(void)</strong></p><p>Brief: Cancel all pending queued tones, and return to silence.</p><p>If there is a tone in progress, the function will wait until this last one has completed, then silence the tones.</p><p>This function may be called with SIGALRM blocked, in which case it will empty the queue as best it can, then return without waiting for the final tone to complete.  In this case, it may not be possible to guarantee silence after the call.</p><p><strong>int cw_queue_tone(int usecs, int frequency)</strong></p><p>Brief: Primitive access to simple tone generation</p><p>This routine queues a tone of given duration and frequency. The routine returns CW_SUCCESS on success.  If usec or frequency are invalid, it returns CW_FAILURE with errno set to EINVAL. If the sound card, console speaker, or keying function are busy, it returns CW_FAILURE  with errno set to EBUSY.  If the tone queue is full, it returns false with errno set to EAGAIN.</p><p>testedin::test_tone_queue_0() testedin::test_tone_queue_1() testedin::test_tone_queue_2() testedin::test_tone_queue_3()</p><p>Parameter: usecs - duration of queued tone, in microseconds</p><p>Parameter: frequency - frequency of queued tone</p><p>Returns: CW_SUCCESS on success</p><p>Returns: CW_FAILURE on failure</p><p><strong>void cw_reset_tone_queue(void)</strong></p><p>Cancel all pending queued tones, reset any queue low callback registered, and return to silence.  This function is suitable for calling from an application exit handler.</p><p><strong>int cw_send_dot(void)</strong></p><p>cw_send_[dot|dash|character_space|word_space]()</p><p>Low level primitives, available to send single dots, dashes, character spaces, and word spaces.  The dot and dash routines always append the normal inter-element gap after the tone sent.  The cw_send_character_space routine sends space timed to exclude the expected prior dot/dash inter-element gap.  The cw_send_word_space routine sends space timed to exclude both the expected prior dot/dash inter-element gap and the prior end of character space.  These functions return true on success, or false with errno set to EBUSY or EAGAIN on error.</p><p>testedin::test_send_primitives()</p><p><strong>int cw_send_dash(void)</strong></p><p>See documentation of cw_send_dot() for more information</p><p>testedin::test_send_primitives()</p><p><strong>int cw_send_character_space(void)</strong></p><p>See documentation of cw_send_dot() for more information</p><p>testedin::test_send_primitives()</p><p><strong>int cw_send_word_space(void)</strong></p><p>See documentation of cw_send_dot() for more information</p><p>testedin::test_send_primitives()</p><p><strong>int cw_send_representation(const char *representation)</strong></p><p>Brief: Check, then send the given string as dots and dashes.</p><p>The representation passed in is assumed to be a complete Morse character; that is, all post-character delays will be added when the character is sent.</p><p>On success, the routine returns CW_SUCCESS. On failure, it returns CW_FAILURE, with errno set to EINVAL if any character of the representation is invalid, EBUSY if the sound card, console speaker, or keying system is busy, or EAGAIN if the tone queue is full, or if there is insufficient space to queue the tones or the representation.</p><p>testedin::test_representations()</p><p>Parameter: representation - representation to send</p><p>Returns: CW_SUCCESS on success</p><p>Returns: CW_FAILURE on failure</p><p><strong>int cw_send_representation_partial(const char *representation)</strong></p><p>Brief: Check, then send the given string as dots and dashes</p><p>The <strong>representation</strong> passed in is assumed to be only part of a larger Morse representation; that is, no post-character delays will be added when the character is sent.</p><p>On success, the routine returns CW_SUCCESS. On failure, it returns CW_FAILURE, with errno set to EINVAL if any character of the representation is invalid, EBUSY if the sound card, console speaker, or keying system is busy, or EAGAIN if the tone queue is full, or if there is insufficient space to queue the tones for the representation.</p><p>testedin::test_representations()</p><p><strong>bool cw_character_is_valid(char c)</strong></p><p>Brief: Checks that the given character is validly sendable in Morse</p><p>Function sets errno to ENOENT on failure.</p><p>testedin::test_validate_character_and_string()</p><p>Parameter: c - character to check</p><p>Returns: CW_SUCCESS if character is valid</p><p>Returns: CW_FAILURE if character is invalid</p><p><strong>int cw_send_character(char c)</strong></p><p>Brief: Lookup, and send a given ASCII character as Morse</p><p>The end of character delay is appended to the Morse sent.</p><p>On success, the routine returns CW_SUCCESS. On failure, it returns CW_FAILURE, with errno set to ENOENT if the given character <strong>c</strong> is not a valid Morse character, EBUSY if the sound card, console speaker, or keying system is busy, or EAGAIN if the tone queue is full, or if there is insufficient space to queue the tones for the character.</p><p>This routine returns as soon as the character has been successfully queued for sending; that is, almost immediately.  The actual sending happens in background processing.  See cw_wait_for_tone() and cw_wait_for_tone_queue() for ways to check the progress of sending.</p><p>testedin::test_send_character_and_string()</p><p>Parameter: c - character to send</p><p>Returns: CW_SUCCESS on success</p><p>Returns: CW_FAILURE on failure</p><p><strong>int cw_send_character_partial(char c)</strong></p><p>Brief: Lookup, and send a given ASCII character as Morse code</p><p>"partial" means that the "end of character" delay is not appended to the Morse code sent by the function, to support the formation of combination characters.</p><p>On success, the routine returns CW_SUCCESS. On error, it returns CW_FAILURE, with errno set to ENOENT if the given character <strong>is</strong> not a valid Morse character, EBUSY if the sound card, console speaker, or keying system is busy, or EAGAIN if the tone queue is full, or if there is insufficient space to queue the tones for the character.</p><p>This routine queues its arguments for background processing.  See cw_send_character() for details of how to check the queue status.</p><p>Parameter: c - character to send</p><p>Returns: CW_SUCCESS on success</p><p>Returns: CW_FAILURE on failure</p><p><strong>bool cw_string_is_valid(const char *string)</strong></p><p>Brief: Validate a string</p><p>Check that each character in the given string is valid and can be sent by libcw as a Morse character.</p><p>Function sets errno to EINVAL on failure</p><p>testedin::test_validate_character_and_string()</p><p>Parameter: string - string to check</p><p>Returns: CW_SUCCESS on success</p><p>Returns: CW_FAILURE on failure</p><p><strong>int cw_send_string(const char *string)</strong></p><p>Brief: Send a given ASCII string in Morse code</p><p>errno is set to ENOENT if any character in the string is not a valid Morse character, EBUSY if the sound card, console speaker, or keying system is in use by the iambic keyer or the straight key, or EAGAIN if the tone queue is full. If the tone queue runs out of space part way through queueing the string, the function returns EAGAIN. However, an indeterminate number of the characters from the string will have already been queued.  For safety, clients can ensure the tone queue is empty before queueing a string, or use cw_send_character() if they need finer control.</p><p>This routine queues its arguments for background processing, the actual sending happens in background processing. See cw_wait_for_tone() and cw_wait_for_tone_queue() for ways to check the progress of sending.</p><p>testedin::test_send_character_and_string()</p><p>Parameter: string - string to send</p><p>Returns: CW_SUCCESS on success</p><p>Returns: CW_FAILURE on failure</p><p><strong>void cw_get_receive_statistics(double *dot_sd, double *dash_sd,</strong></p><p><strong>                            double *element_end_sd, double *character_end_sd)</strong></p><p>Brief: Calculate and return receive timing statistics</p><p>These statistics may be used to obtain a measure of the accuracy of received CW.  The values <strong>dot_sd</strong> and <strong>dot_sd</strong> contain the standard deviation of dot and dash lengths from the ideal values, and <strong>element_end_sd</strong> and <strong>element_end_sd</strong> the deviations for inter element and inter character spacing.  Statistics are held for all timings in a 256 element circular buffer.  If any statistic cannot be calculated, because no records for it exist, the returned value is 0.0.  Use NULL for the pointer argument to any statistic not required.</p><p>Parameter: dot_sd</p><p>Parameter: dash_sd</p><p>Parameter: element_end_sd</p><p>Parameter: character_end_sd</p><p><strong>void cw_reset_receive_statistics(void)</strong></p><p>Brief: Clear the receive statistics buffer</p><p>Clear the receive statistics buffer by removing all records from it and returning it to its initial default state.</p><p><strong>void cw_enable_adaptive_receive(void)</strong></p><p>Brief: Enable adaptive receive speed tracking</p><p>If adaptive speed tracking is enabled, the receive functions will attempt to automatically adjust the receive speed setting to match the speed of the incoming Morse code. If it is disabled, the receive functions will use fixed speed settings, and reject incoming Morse which is not at the expected speed.</p><p>Adaptive speed tracking uses a moving average of the past four elements as its baseline for tracking speeds.  The default state is adaptive speed tracking disabled.</p><p><strong>void cw_disable_adaptive_receive(void)</strong></p><p>Brief: Disable adaptive receive speed tracking</p><p>See documentation of cw_enable_adaptive_receive() for more information</p><p><strong>bool cw_get_adaptive_receive_state(void)</strong></p><p>Brief: Get adaptive receive speed tracking flag</p><p>The function returns state of "adaptive receive enabled" flag. See documentation of cw_enable_adaptive_receive() for more information</p><p>Returns: true if adaptive speed tracking is enabled</p><p>Returns: false otherwise</p><p><strong>int cw_start_receive_tone(const struct timeval *timestamp)</strong></p><p>Brief: Mark beginning of receive tone</p><p>Called on the start of a receive tone.  If the <strong>timestamp</strong> is NULL, the current timestamp is used as beginning of tone.</p><p>On error the function returns CW_FAILURE, with errno set to ERANGE if the call is directly after another cw_start_receive_tone() call or if an existing received character has not been cleared from the buffer, or EINVAL if the timestamp passed in is invalid.</p><p>Parameter: timestamp</p><p>Returns: CW_SUCCESS on success</p><p>Returns: CW_FAILURE otherwise (with errno set)</p><p><strong>int cw_end_receive_tone(const struct timeval *timestamp)</strong></p><p>Brief: Mark end of tone</p><p>Called on the end of a received tone.</p><p>If the <strong>timestamp</strong> is NULL, the current time is used as timestamp of end of tone.</p><p>On success, the routine adds a dot or dash to the receiver's representation buffer, and returns CW_SUCCESS.</p><p>On failure, it returns CW_FAIURE, with errno set to: ERANGE if the call was not preceded by a cw_start_receive_tone() call, EINVAL if the timestamp passed in is not valid, ENOENT if the tone length was out of bounds for the permissible dot and dash lengths and fixed speed receiving is selected, ENOMEM if the receiver's representation buffer is full, EAGAIN if the tone was shorter than the threshold for noise and was therefore ignored.</p><p>Parameter: timestamp</p><p>Returns: CW_SUCCESS on success</p><p>Returns: CW_FAILURE on failure</p><p><strong>int cw_receive_buffer_dot(const struct timeval *timestamp)</strong></p><p>Brief: Add a dot to the receiver's representation buffer</p><p>Documentation for both cw_receive_buffer_dot() and cw_receive_buffer_dash():</p><p>Since we can't add an element to the buffer without any accompanying timing information, the functions accepts <strong>timestamp</strong> of the "end of element" event.  If the <strong>timestamp</strong> is NULL, the current timestamp is used.</p><p>These routines are for client code that has already determined whether a dot or dash was received by a method other than calling the routines cw_start_receive_tone() and cw_end_receive_tone().</p><p>On success, the relevant element is added to the receiver's representation buffer.</p><p>On failure, the routines return CW_FAILURE, with errno set to ERANGE if preceded by a cw_start_receive_tone call with no matching cw_end_receive_tone or if an error condition currently exists within the receiver's buffer, or ENOMEM if the receiver's representation buffer is full.</p><p>Parameter: timestamp - timestamp of "end of dot" event</p><p>Returns: CW_SUCCESS on success</p><p>Returns: CW_FAILURE on failure</p><p><strong>int cw_receive_buffer_dash(const struct timeval *timestamp)</strong></p><p>Brief: Add a dash to the receiver's representation buffer</p><p>See documentation of cw_receive_buffer_dot() for more information.</p><p>Parameter: timestamp - timestamp of "end of dash" event</p><p>Returns: CW_SUCCESS on success</p><p>Returns: CW_FAILURE on failure</p><p><strong>int cw_receive_representation(const struct timeval *timestamp,</strong></p><p><strong>                           /* out */ char *representation,</strong></p><p><strong>                           /* out */ bool *is_end_of_word, /* out */ bool *is_error)</strong></p><p>Brief: Get the current buffered representation from the receiver's representation buffer</p><p>On success the function fills in <strong>representation</strong> with the contents of the current representation buffer and returns CW_SUCCESS.</p><p>On failure, it returns CW_FAILURE and sets errno to: ERANGE if not preceded by a cw_end_receive_tone call, a prior successful cw_receive_representation call, or a prior cw_receive_buffer_dot or cw_receive_buffer_dash, EINVAL if the timestamp passed in is invalid, EAGAIN if the call is made too early to determine whether a complete representation has yet been placed in the buffer (that is, less than the inter-character gap period elapsed since the last cw_end_receive_tone or cw_receive_buffer_dot/dash call). This is not a *hard* error, just an information that the caller should try to get the representation later.</p><p><strong>is_end_of_word</strong> indicates that the delay after the last tone received is longer that the inter-word gap.</p><p><strong>is_error</strong> indicates that the representation was terminated by an error condition.</p><p>TODO: the function should be called cw_receiver_get_representation().</p><p>TODO: why we pass <strong>timestamp</strong> to the function when all we want from it is a representation from representation buffer? It seems that the function can be called with timestamp for last event, i.e. on end of last space. "last space" may mean space after last element (dot/dash) in a character, or a space between two characters, or (a bit different case) a space between words. Timestamp for end of space would be the same timestamp as for beginning of new tone (?).</p><p>testedin::test_helper_receive_tests()</p><p>Parameter: timestamp - timestamp of event that ends "end-of-character" space or "end-of-word" space</p><p>Parameter: representation - buffer for representation (output parameter)</p><p>Parameter: is_end_of_word - buffer for "is end of word" state (output parameter)</p><p>Parameter: is_error - buffer for "error" state (output parameter)</p><p>Returns: CW_SUCCESS on success</p><p>Returns: CW_FAILURE on failure</p><p><strong>int cw_receive_character(const struct timeval *timestamp,</strong></p><p><strong>                      /* out */ char *c,</strong></p><p><strong>                      /* out */ bool *is_end_of_word, /* out */ bool *is_error)</strong></p><p>Brief: Get a current character</p><p>Function returns the character currently stored in receiver's representation buffer.</p><p>On success the function returns CW_SUCCESS, and fills <strong>c</strong> with the contents of the current representation buffer, translated into a character.</p><p>On failure the function returns CW_FAILURE, with errno set to:</p><p>ERANGE if not preceded by a cw_end_receive_tone() call, a prior successful cw_receive_character() call, or a cw_receive_buffer_dot() or cw_receive_buffer_dash() call, EINVAL if the timestamp passed in is invalid, or EAGAIN if the call is made too early to determine whether a complete character has yet been placed in the buffer (that is, less than the inter-character gap period elapsed since the last cw_end_receive_tone() or cw_receive_buffer_dot/dash call). ENOENT if character stored in receiver cannot be recognized as valid</p><p><strong>is_end_of_word</strong> indicates that the delay after the last tone received is longer that the inter-word gap.</p><p><strong>is_error</strong> indicates that the character was terminated by an error condition.</p><p>testedin::test_helper_receive_tests()</p><p>Parameter: timestamp - timestamp of event that ends "end-of-character" space or "end-of-word" space</p><p>Parameter: c - buffer for character (output parameter)</p><p>Parameter: is_end_of_word - buffer for "is end of word" state (output parameter)</p><p>Parameter: is_error - buffer for "error" state (output parameter)</p><p>Returns: CW_SUCCESS on success</p><p>Returns: CW_FAILURE on failure</p><p><strong>void cw_clear_receive_buffer(void)</strong></p><p>Brief: Clear receiver's representation buffer</p><p>Clears the receiver's representation buffer, resets receiver's internal state. This prepares the receiver to receive tones again.</p><p>This routine must be called after successful, or terminating, cw_receive_representation() or cw_receive_character() calls, to clear the states and prepare the buffer to receive more tones.</p><p><strong>int cw_get_receive_buffer_capacity(void)</strong></p><p>Brief: Get the number of elements (dots/dashes) the receiver's buffer can accommodate</p><p>The maximum number of elements written out by cw_receive_representation() is the capacity + 1, the extra character being used for the terminating NUL.</p><p>Returns: number of elements that can be stored in receiver's representation buffer</p><p><strong>int cw_get_receive_buffer_length(void)</strong></p><p>Brief: Get the number of elements (dots/dashes) currently pending in the receiver's representation buffer</p><p>testedin::test_helper_receive_tests()</p><p>Returns: number of elements in receiver's representation buffer</p><p><strong>void cw_reset_receive(void)</strong></p><p>Brief: Clear receive data</p><p>Clear the receiver's representation buffer, statistics, and any retained receiver's state.  This function is suitable for calling from an application exit handler.</p><p><strong>void cw_enable_iambic_curtis_mode_b(void)</strong></p><p>Brief: Enable iambic Curtis mode B</p><p>Normally, the iambic keying functions will emulate Curtis 8044 Keyer mode A.  In this mode, when both paddles are pressed together, the last dot or dash being sent on release is completed, and nothing else is sent. In mode B, when both paddles are pressed together, the last dot or dash being sent on release is completed, then an opposite element is also sent. Some operators prefer mode B, but timing is more critical in this mode. The default mode is Curtis mode A.</p><p><strong>void cw_disable_iambic_curtis_mode_b(void)</strong></p><p>See documentation of cw_enable_iambic_curtis_mode_b() for more information</p><p><strong>int cw_get_iambic_curtis_mode_b_state(void)</strong></p><p>See documentation of cw_enable_iambic_curtis_mode_b() for more information</p><p><strong>int cw_notify_keyer_paddle_event(int dot_paddle_state,</strong></p><p><strong>                             int dash_paddle_state)</strong></p><p>Brief: Inform about changed state of iambic keyer's paddles</p><p>Function informs the library that the iambic keyer paddles have changed state.  The new paddle states are recorded, and if either transition from false to true, paddle latches, for iambic functions, are also set.</p><p>On success, the routine returns CW_SUCCESS. On failure, it returns CW_FAILURE, with errno set to EBUSY if the tone queue or straight key are using the sound card, console speaker, or keying system.</p><p>If appropriate, this routine starts the keyer functions sending the relevant element.  Element send and timing occurs in the background, so this routine returns almost immediately.  See cw_keyer_element_wait() and cw_keyer_wait() for details about how to check the current status of iambic keyer background processing.</p><p>testedin::test_keyer()</p><p>Parameter: dot_paddle_state</p><p>Parameter: dash_paddle_state</p><p>Returns: CW_SUCCESS on success</p><p>Returns: CW_FAILURE on failure</p><p><strong>int cw_notify_keyer_dot_paddle_event(int dot_paddle_state)</strong></p><p>Brief: Change state of dot paddle</p><p>Alter the state of just one of the two iambic keyer paddles. The other paddle state of the paddle pair remains unchanged.</p><p>See cw_keyer_paddle_event() for details of iambic keyer background processing, and how to check its status.</p><p>Parameter: dot_paddle_state</p><p><strong>int cw_notify_keyer_dash_paddle_event(int dash_paddle_state)</strong></p><p>See documentation of cw_notify_keyer_dot_paddle_event() for more information</p><p><strong>void cw_get_keyer_paddles(int *dot_paddle_state, int *dash_paddle_state)</strong></p><p>Brief: Get the current saved states of the two paddles</p><p>testedin::test_keyer()</p><p>Parameter: dot_paddle_state</p><p>Parameter: dash_paddle_state</p><p><strong>void cw_get_keyer_paddle_latches(int *dot_paddle_latch_state,</strong></p><p><strong>                             int *dash_paddle_latch_state)</strong></p><p>Brief: Get the current states of paddle latches</p><p>Function returns the current saved states of the two paddle latches. A paddle latches is set to true when the paddle state becomes true, and is cleared if the paddle state is false when the element finishes sending.</p><p>Parameter: dot_paddle_latch_state</p><p>Parameter: dash_paddle_latch_state</p><p><strong>bool cw_is_keyer_busy(void)</strong></p><p>Brief: Check if a keyer is busy</p><p>Returns: true if keyer is busy</p><p>Returns: false if keyer is not busy</p><p><strong>int cw_wait_for_keyer_element(void)</strong></p><p>Brief: Wait for end of element from the keyer</p><p>Waits until the end of the current element, dot or dash, from the keyer.</p><p>On error the function returns CW_FAILURE, with errno set to EDEADLK if SIGALRM is blocked.</p><p>testedin::test_keyer()</p><p>Returns: CW_SUCCESS on success</p><p>Returns: CW_FAILURE on failure</p><p><strong>int cw_wait_for_keyer(void)</strong></p><p>Brief: Wait for the current keyer cycle to complete</p><p>The routine returns CW_SUCCESS on success.  On error, it returns CW_FAILURE, with errno set to EDEADLK if SIGALRM is blocked or if either paddle state is true.</p><p>Returns: CW_SUCCESS on success</p><p>Returns: CW_FAILURE on failure</p><p><strong>void cw_reset_keyer(void)</strong></p><p>Brief: Reset iambic keyer data</p><p>Clear all latches and paddle states of iambic keyer, return to Curtis 8044 Keyer mode A, and return to silence.  This function is suitable for calling from an application exit handler.</p><p><strong>int cw_notify_straight_key_event(int key_state)</strong></p><p>Brief: Inform the library that the straight key has changed state</p><p>This routine returns CW_SUCCESS on success.  On error, it returns CW_FAILURE, with errno set to EBUSY if the tone queue or iambic keyer are using the sound card, console speaker, or keying control system.  If <strong>key_state</strong> indicates no change of state, the call is ignored.</p><p><strong>key_state</strong> may be either CW_KEY_STATE_OPEN (false) or CW_KEY_STATE_CLOSED (true).</p><p>testedin::test_straight_key()</p><p>Parameter: key_state - state of straight key</p><p><strong>int cw_get_straight_key_state(void)</strong></p><p>Brief: Get saved state of straight key</p><p>Returns the current saved state of the straight key.</p><p>testedin::test_straight_key()</p><p>Returns: CW_KEY_STATE_CLOSED (true) if the key is down</p><p>Returns: CW_KEY_STATE_OPEN (false) if the key up</p><p><strong>bool cw_is_straight_key_busy(void)</strong></p><p>Brief: Check if the straight key is busy</p><p>This routine is just a pseudonym for cw_get_straight_key_state(), and exists to fill a hole in the API naming conventions.</p><p>testedin::test_straight_key()</p><p>Returns: true if the straight key is busy</p><p>Returns: false if the straight key is not busy</p><p><strong>void cw_reset_straight_key(void)</strong></p><p>Brief: Clear the straight key state, and return to silence</p><p>This function is suitable for calling from an application exit handler.</p><p><strong>const char *cw_generator_get_audio_system_label(void)</strong></p><p>Brief: Get a readable label of current audio system</p><p>The function returns one of following strings: None, Null, Console, OSS, ALSA, PulseAudio, Soundcard</p><p>Returns: audio system's label</p><p><strong>int cw_generator_new(int audio_system, const char *device)</strong></p><p>Brief: Create new generator</p><p>Allocate memory for new generator data structure, set up default values of some of the generator's properties. The function does not start the generator (generator does not produce a sound), you have to use cw_generator_start() for this.</p><p>Notice that the function doesn't return a generator variable. There is at most one generator variable at any given time. You can't have two generators. In some future version of the library the function will return pointer to newly allocated generator, and then you could have as many of them as you want, but not yet.</p><p><strong>audio_system</strong> can be one of following: NULL, console, OSS, ALSA, PulseAudio, soundcard. See "enum cw_audio_systems" in libcw.h for exact names of symbolic constants.</p><p>Parameter: audio_system - audio system to be used by the generator</p><p>Parameter: device - name of audio device to be used; if NULL then library will use default device.</p><p><strong>void cw_generator_delete(void)</strong></p><p>Brief: Deallocate generator</p><p>Deallocate/destroy generator data structure created with call to cw_generator_new(). You can't start nor use the generator after the call to this function.</p><p><strong>int cw_generator_start(void)</strong></p><p>Brief: Start a generator</p><p>Start producing tones using generator created with cw_generator_new(). The source of tones is a tone queue associated with the generator. If the tone queue is empty, the generator will wait for new tones to be queued.</p><p>Returns: CW_FAILURE on errors</p><p>Returns: CW_SUCCESS on success</p><p><strong>void cw_generator_stop(void)</strong></p><p>Brief: Shut down a generator</p><p>Silence tone generated by generator (level of generated sine wave is set to zero, with falling slope), and shut the generator down.</p><p>The shutdown does not erase generator's configuration.</p><p>If you want to have this generator running again, you have to call cw_generator_start().</p><p><strong>int cw_generator_set_tone_slope(cw_gen_t *gen, int slope_shape, int slope_usecs)</strong></p><p>Brief: Set parameters of tones generated by generator</p><p>Most of variables related to slope of tones is in tone data type, but there are still some variables that are generator-specific, as they are common for all tones.  This function sets these variables.</p><p>One of the variables is a table of amplitudes for every point in slope. Values in the table are generated only once, when parameters of the slope change. This saves us from re-calculating amplitudes of slope for every tone. With the table at hand we can simply look up an amplitude of point of slope in the table of amplitudes.</p><p>You can pass -1 as value of <strong>slope_shape</strong> or <strong>slope_shape</strong>, the function will then either resolve correct values of its arguments, or will leave related parameters of slope unchanged.</p><p>The function should be called every time one of following parameters change:</p>
<dl class='dl-vertical'>
  <dt>
    \[bu]
  </dt>
  <dd>
    <p> shape of slope,</p>
  </dd>
  <dt>
    \[bu]
  </dt>
  <dd>
    <p> length of slope,</p>
  </dd>
  <dt>
    \[bu]
  </dt>
  <dd>
    <p> generator's sample rate,</p>
  </dd>
  <dt>
    \[bu]
  </dt>
  <dd>
    <p> generator's volume.</p>
  </dd>

</dl>
<p>There are four supported shapes of slopes:</p>
<dl class='dl-vertical'>
  <dt>
    \[bu]
  </dt>
  <dd>
    <p> linear (the only one supported by libcw until version 4.1.1),</p>
  </dd>
  <dt>
    \[bu]
  </dt>
  <dd>
    <p> raised cosine (supposedly the most desired shape),</p>
  </dd>
  <dt>
    \[bu]
  </dt>
  <dd>
    <p> sine,</p>
  </dd>
  <dt>
    \[bu]
  </dt>
  <dd>
    <p> rectangular.</p>
  </dd>

</dl>
<p>Use CW_TONE_SLOPE_SHAPE_* symbolic names as values of <strong>slope_shape</strong>.</p><p>FIXME: first argument of this public function is gen, but no function provides access to generator variable.</p><p>Parameter: gen - generator for which to set tone slope parameters</p><p>Parameter: slope_shape - shape of slope: linear, raised cosine, sine, rectangular</p><p>Parameter: slope_usecs - length of slope, in microseconds</p><p>Returns: CW_SUCCESS on success</p><p>Returns: CW_FAILURE on failure</p><p><strong>unsigned int test_cw_tone_queue_test_capacity1(void)</strong></p><p>Brief: Test "capacity" property of tone queue</p><p>Function tests "capacity" property of tone queue, and also tests related properties: head and tail.</p><p>In this function it is done by first enqueueing N known tones to a tone queue using cw_tone_queue_enqueue_internal(), and then "manually" checking content of tone queue to be sure that all the tones are in place.</p><p>tests::cw_tone_queue_enqueue_internal()</p><p><strong>unsigned int test_cw_tone_queue_test_capacity2(void)</strong></p><p>Brief: Test "capacity" property of tone queue</p><p>Function tests "capacity" property of tone queue, and also tests related properties: head and tail.</p><p>In this function it is done by first enqueueing N known tones to a tone queue using cw_tone_queue_enqueue_internal(), then dequeueing the tones with cw_tone_queue_dequeue_internal() and then checking that enqueued tones are the ones that we were expecting to get.</p><p>tests::cw_tone_queue_enqueue_internal()</p><p>tests::cw_tone_queue_dequeue_internal()</p><p><strong>int test_cw_tone_queue_capacity_test_init(cw_tone_queue_t *tq, uint32_t capacity, uint32_t high_water_mark, int head_shift)</strong></p><p>Brief: Initialize tone queue for tests of capacity</p><p>Initialize given queue for tests of capacity of tone queue, and of related parameters of the tq: head and tail.</p><p>First three function parameters are rather boring. What is interesting is the fourth parameter: <strong>head_shift</strong>.</p><p>In general the behaviour of tone queue (a circular list) should be independent of initial position of queue's head (i.e. from which position in the queue we start adding new elements to the queue).</p><p>By initializing the queue with different initial positions of head pointer, we can test this assertion about irrelevance of initial head position.</p><p>tests::cw_tone_queue_set_capacity_internal()</p><p>Parameter: tq - tone queue to test</p><p>Parameter: capacity - intended capacity of tone queue</p><p>Parameter: high_water_mark - high water mark to be set for tone queue</p><p>Parameter: head_shift - position of first element that will be inserted in empty queue</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTES</h2>
        <div class="sectioncontent">
<p>Despite the fact that this manual page constantly and consistently refers to Morse code elements as dots and dashes, DO NOT think in these terms when trying to learn Morse code.  Always think of them as 'dit's and 'dah's.</p><p><strong>libcw</strong> uses system itimers for its internal timing.  On most UNIX flavours, itimers are not guaranteed to signal a program exactly at the specified time, and they generally offer a resolution only as good as the normal system 'clock tick' resolution.  An itimer SIGALRM usually falls on a system clock tick, making it accurate to no better than 10mS on a typical 100Hz kernel.</p><p>The effect of this is that an itimer period is generally either exactly as specified, or, more likely, slightly longer.  At higher WPM settings, the cumulative effect of this affects timing accuracy, because at higher speeds, there are fewer 10mS clock ticks in a dot period.  For example, at 12 WPM, the dot length is 100mS, enough to contain five kernel clock ticks; at 60 WPM, the dot length is 20mS, or just two kernel clock ticks.  So at higher speeds, the effect of itimer resolutions becomes more pronounced.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO libcw&hellip;</h2>
        <div class="sectioncontent">
<p>Man pages for <strong>cw</strong>(7,LOCAL), <strong>cw</strong>(1,LOCAL), <strong>cwgen</strong>(1,LOCAL), <strong>cwcp</strong>(1,LOCAL), and <strong>xcwcp</strong>(1,LOCAL).</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="libcurl-tutorial.3.html"><span aria-hidden="true">&larr;</span> libcurl-tutorial.3: Libcurl programming tutorial</a></li>
   <li class="next"><a href="libdavix.3.html">libdavix.3: Shared library for http i/o <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

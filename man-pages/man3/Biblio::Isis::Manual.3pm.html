<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Biblio::Isis::Manual: Cds/isis manual appendix f, g and h</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Cds/isis manual appendix f, g and h">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Biblio::Isis::Manual (3pm) manual">
  <meta name="twitter:description" content="Cds/isis manual appendix f, g and h">
  <meta name="twitter:image" content="https://www.carta.tech/images/libbiblio-isis-perl-Biblio::Isis::Manual-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Biblio::Isis::Manual.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Biblio::Isis::Manual (3pm) manual" />
  <meta property="og:description" content="Cds/isis manual appendix f, g and h" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libbiblio-isis-perl-Biblio::Isis::Manual-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Biblio::Isis::Manual<small> (3pm)</small></h1>
        <p class="lead">Cds/isis manual appendix f, g and h</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Biblio::Isis::Manual.3pm.html">
      <span itemprop="name">Biblio::Isis::Manual: Cds/isis manual appendix f, g and h</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libbiblio-isis-perl/">
      <span itemprop="name">libbiblio-isis-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Biblio::Isis::Manual.3pm.html">
      <span itemprop="name">Biblio::Isis::Manual: Cds/isis manual appendix f, g and h</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This is partial scan of \s-1CDS/ISIS\s0 manual (appendix F, G and H, pages 257-272) which is than converted to text using \s-1OCR\s0 and proofread. However, there might be mistakes, and any corrections sent to \*(C`dpavlin@rot13.org\*(C' will be greatly appreciated.</p><p>This digital version is made because current version available in ditial form doesn't contain details about \s-1CDS/ISIS\s0 file format and was essential in making Biblio::Isis module.</p><p>This extract of manual has been produced in compliance with section (d) of WinIsis \s-1LICENCE\s0 for receiving institution/person which say:</p>
<pre>
 The receiving institution/person may:
</pre>
<p> (d) Print/reproduce the CDS/ISIS manuals or portions thereof,      provided that such copies reproduce the copyright notice;</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">CDS/ISIS Files</h2>
        <div class="sectioncontent">
<p>This section describes the various files of the \s-1CDS/ISIS\s0 system, the file naming conventions and the file extensions used for each type of file. All \s-1CDS/ISIS\s0 files have standard names as follows:</p><p>  nnnnnn.eee</p><p>where: is the file name (all file names, except program names, are limited to a maximum of 6 characters) is the file extension identifying a particular type of file.</p><p>Files marked with \*(C`*\*(C' are \s-1ASCII\s0 files which you may display or print. The other files are binary files.</p><p><strong>&#92;$1</strong></p><p>System files are common to all \s-1CDS/ISIS\s0 users and include the various executable programs as well as system menus, worksheets and message files provided by Unesco as well as additional ones which you may create.</p><p><em>\s-1CDS/ISIS\s0 Program</em></p><p>The name of the program file, as supplied by Unesco is</p><p>  ISIS.EXE</p><p>Depending on the release and/or target computer, there may also be one or more overlay files. These, if present, have the extension \*(C`OVL\*(C'. Check the contents of your system diskettes or tape to see whether overlay files are present.</p><p><em>System menus and worksheets</em></p><p>All system menus and worksheets have the file extension \s-1FMT\s0 and the names are built as follows:</p><p>  pctnnn.FMT</p><p>where: is the page number (A for the first page, B for the second, etc.) is the language code (e.g. E for English), which must be one of those provided for in the language selection menu xXLNG. is X for menus and Y for system worksheets is a unique identifier</p><p>For example the full name of the English version of the menu xXGEN is \*(C`AEXGEN.FMT\*(C'.</p><p>The page number is transparent to the \s-1CDS/ISIS\s0 user. Like the file extension the page number is automatically provided by the system. Therefore when a \s-1CDS/ISIS\s0 program prompts you to enter a menu or worksheet name you must not include the page number. Furthermore as file names are restricted to 6 characters, menus and worksheets names may not be longer than 5 characters.</p><p>System menus and worksheets may only have one page.</p><p>The language code is mandatory for system menus and standard system worksheets. For example if you want to link a \s-1HELP\s0 menu to the system menu \s-1EXGEN\s0, its name must begin with the letter E.</p><p>The <strong>X</strong> convention is only enforced for standard system menus. It is a good practice, however, to use the same convention for menus that you create, and to avoid creating worksheets (including data entry worksheets) with X in this position, that is with names like x<strong>X</strong>xxx.</p><p>Furthermore, if a data base name contains <strong>X</strong> or <strong>Y</strong> in the second position, then the corresponding data entry worksheets will be created in the system worksheet directory (parameter 2 of \*(C`SYSPAR.PAR\*(C') rather then the data base directory. Although this will not prevent normal operation of the data base, it is not recommended.</p><p><em>System messages files</em></p><p>System messages and prompts are stored in standard \s-1CDS/ISIS\s0 data bases. All corresponding data base files (see below) are required when updating a message file, but only the Master file is used to display messages.</p><p>There must be a message data base for each language supported through the language selection menu xXLNG.</p><p>The data base name assigned to message data bases is xMSG (where x is the language code).</p><p><em>System tables</em></p><p>System tables are used by \s-1CDS/ISIS\s0 to define character sets. Two are required at present: defines lower to upper-case translation defines the alphabetic characters.</p><p><em>System print and work files</em></p><p>Certain \s-1CDS/ISIS\s0 print functions do not send the output directly to the printer but store it on a disk file from which you may then print it at a convenient time. These files have all the file extension \*(C`LST\*(C' and are reused each time the corresponding function is executed.</p><p>In addition \s-1CDS/ISIS\s0 creates temporary work files which are normally automatically discarded at the end of the session. If the session terminates abnormally, however, they will not be deleted. A case of abnormal termination would be a power failure while you are using a \s-1CDS/ISIS\s0 program. Also these files, however, are reused each time, so that you do not normally need to delete them manually. Work files all have the extension \*(C`TMP\*(C'.</p><p>The print and work files created by \s-1CDS/ISIS\s0 are given below: Inverted file listing file (produced by \s-1ISISINV\s0) Worksheet/menu listing file (produced by \s-1ISISUTL\s0) System messages listing file (produced by \s-1ISISUTL\s0) Printed output (produced by \s-1ISISPRT\s0 when printing no print file name is supplied) Sort work file 1 Sort work file 2 Sort work file 3 Sort work file 4 Sort work file 5 Sort work file 6 Sort work file 7 Sort work file 8 Trace file created by certain programs Temporary storage for hit lists created during retrieval Temporary storage for search expressions</p>
<dl class='dl-vertical'>
  <dt>
    1
  </dt>
  <dd>
    <p>mandatory files, which must always be present. These are normally established when the data base is defined by means of the \s-1ISISDEF\s0 services and should never be deleted;</p>
  </dd>
  <dt>
    2
  </dt>
  <dd>
    <p>auxiliary files created by the system whenever certain functions are performed. These can periodically be deleted when they are no longer needed.</p>
  </dd>
  <dt>
    3
  </dt>
  <dd>
    <p>user files created by the data base user (such as display formats), which are fully under the user's responsibility.</p>
  </dd>

</dl>
<p>Each data base consists of a number of physically distinct files as indicated below. There are three categories of data base files:</p><p>In the following description \*(C`xxxxxx\*(C' is the 1-6 character data base name.</p><p><em>Mandatory data base files</em> Field Definition Table Field Select Table for Inverted file Default data entry worksheet (where p is the page number). Note that the data base name is truncated to 5 characters if necessary Default display format Master file Crossreference file (Master file index) B*tree (search term dictionary) control file B*tree Nodes (for terms up to 10 characters long) B*tree Leafs (for terms up to 10 characters long) B*tree Nodes (for terms longer than 10 characters) B*tree Leafs (for terms longer than 10 characters) Inverted file postings \s-1ANY\s0 file</p><p><em>Auxiliary files</em> Stopword file used during inverted file generation Unsorted Link file (short terms) Unsorted Link file (long terms) Sorted Link file (short terms) Sorted Link file (long terms) Master file backup Hit file index Hit file Sort convertion table (see \*(L"Uppercase conversion table (1SISUC.TAB)\*(R" on page 227)</p><p><em>User files</em> Field Select tables used for sorting Additional display formats Additional data entry worksheets Additional stopword files Save files created during retrieval</p><p>The name of user files is fully under user control. However, in order to avoid possible name conflicts it is advisable to establish some standard conventions to be followed by all \s-1CDS/ISIS\s0 users at a given site, such as for example to define \*(C`yyyyyy\*(C' as follows:</p><p>  xxxyyy</p><p>where: is a data base identifier (which could be the first three letters of the data base name if no two data bases names are allowed to begin with the same three letters) a user chosen name.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Master file structure and record format</h2>
        <div class="sectioncontent">
<p>The Master record is a variable length record consisting of three sections: a fixed length leader; a directory; and the variable length data fields.</p><p><em>Leader format</em></p><p>The leader consists of the following 7 integers (fields marked with * are 31-bit signed integers): Master file number Record length (always an even number) Backward pointer - Block number Backward pointer - Offset Offset to variable fields (this is the combined length of the Leader and Directory part of the record, in bytes) Number of fields in the record (i.e. number of directory entries) Logical deletion indicator (0=record active; 1=record marked for deletion)</p><p>\*(C`MFBWB\*(C' and \*(C`MFBWP\*(C' are initially set to 0 when the record is created. They are subsequently updated each time the record itself is updated (see below).</p><p><em>Directory format</em></p><p>The directory is a table indicating the record contents. There is one directory entry for each field present in, the record (i.e. the directory has exactly \s-1NVF\s0 entries). Each directory entry consists of 3 integers: Field Tag Offset to first character position of field in the variable field section (the first field has \*(C`POS=0\*(C') Field length in bytes</p><p>The total directory length in bytes is therefore \*(C`6*NVF\*(C'; the \*(C`BASE\*(C' field in the leader is always: \*(C`18+6*NVF\*(C'.</p><p><em>Variable fields</em></p><p>This section contains the data fields (in the order indicated by the directory). Data fields are placed one after the other, with no separating characters. The first record in the Master file is a control record which the system maintains automatically. This is never accessible to the \s-1ISIS\s0 user. Its contents are as follows (fields marked with \*(C`*\*(C' are 31-bit signed integers): always 0 \s-1MFN\s0 to be assigned to the next record created in the data base Last block number allocated to the Master file (first block is 1) Offset to next available position in last block always 0 for user data base file (1 for system message files)</p><p>(the last four fields are used for statistics during backup/restore). The Master file records are stored consecutively, one after the other, each record occupying exactly \*(C`MFRL\*(C' bytes. The file is stored as physical blocks of 512 bytes. A record may begin at any word boundary between 0-498 (no record begins between 500-510) and may span over two or more blocks.</p><p>As the Master file is created and/or updated, the system maintains an index indicating the position of each record. The index is stored in the Crossreference file (\*(C`.XRF\*(C') The \*(C`XRF\*(C' file is organized as a table of pointers to the Master file. The first pointer corresponds to \s-1MFN\s0 1, the second to \s-1MFN\s0 2, etc.</p><p>Each pointer consists of two fields: (21 bits) Block number of Master file block containing the record (11 bits) Offset in block of first character position of Master record (first block position is 0)</p><p>which are stored in a 31-bit signed integer (4 bytes) as follows:</p><p>  pointer = XRFMFB * 2048 + XRFMFP</p><p>(giving therefore a maximum Master file size of 500 Megabytes).</p><p>Each block of the \*(C`XRF\*(C' file is 512 bytes and contains 127 pointers. The first field in each block (\*(C`XRFPOS\*(C') is a 31-bit signed integer whose absolute value is the \*(C`XRF\*(C' block number. A negative \*(C`XRFPOS\*(C' indicates the last block.</p><p><em>Deleted</em> records are indicated as follows: logically deleted record (in this case \*(C`ABS(XRFMFB)\*(C' is the correct block pointer and \*(C`XRFMFP\*(C' is the offset of the record, which can therefore still be retrieved) physically deleted record inexistent record (all records beyond the highest \*(C`MFN\*(C' assigned in the data base) <em>Creation of new records</em></p><p>New records are always added at the end of the Master file, at the position indicated by the fields \*(C`NXTMFB\*(C'/\*(C`NXTMFP\*(C' in the Master file control record. The \*(C`MFN\*(C' to be assigned is also obtained from the field \*(C`NXTMFN\*(C' in the control record.</p><p>After adding the record, \*(C`NXTMFN\*(C' is increased by 1 and \*(C`NXTMFB\*(C'/\*(C`NXTMFP\*(C' are updated to point to the next available position. In addition a new pointer is created in the \*(C`XRF\*(C' file and the \*(C`XRFMFP\*(C' field corresponding to the record is increased by 1024 to indicate that this is a new record to be inverted (after the inversion of the record 1024 is subtracted from \*(C`XRFMFP\*(C').</p><p><em>Update of existing records</em></p><p>Whenever you update a record (i.e., you call it in data entry and exit with option X from the editor) the system writes the record back to the Master file. Where it is written depends on the status of the record when it was initially read.</p><p>There was no inverted file update pending for the record</p><p>This condition is indicated by the following:</p><p>On \*(C`XRF\*(C' \*(C`XRFMFP &lt; 512\*(C' and</p><p>On \*(C`MST\*(C' \*(C`MFBWB = 0\*(C' and \*(C`MFBWP = 0\*(C'</p><p>In this case, the record is always rewritten at the end of the Master file (as if it were a new record) as indicated by \*(C`NXTMFB\*(C'/\*(C`NXTMFP\*(C' in the control record. In the new version of the record \*(C`MFBWB\*(C'/\*(C`MFBWP\*(C' are set to point to the old version of the record, while in the \*(C`XRF\*(C' file the pointer points to the new version. In addition 512 is added to \*(C`XRFMFP\*(C' to indicate that an inverted file update is pending. When the inverted file is updated, the old version of the record is used to determine the postings to be deleted and the new version is used to add the new postings. After the update of the Inverted file, 512 is subtracted from \*(C`XRFMFP\*(C', and \*(C`MFBWB\*(C'/\*(C`MFBWP\*(C' are reset to 0.</p><p>An inverted file update was pending</p><p>This condition is indicated by the following:</p><p>On \*(C`XRF\*(C' \*(C`XRFMFP &gt; 512\*(C' and</p><p>On \*(C`MST\*(C' \*(C`MFBWB &gt; 0\*(C'</p><p>In this case \*(C`MFBWB\*(C'/\*(C`MFBWP\*(C' point to the version of the record which is currently reflected in the Inverted file. If possible, i.e. if the record length was not increased, the record is written back at its original location, otherwise it is written at the end of the file. In both cases, \*(C`MFBWB\*(C'/\*(C`MFBWP\*(C' are not changed.</p><p><em>Deletion of records</em></p><p>Record deletion is treated as an update, with the following additional markings:</p><p>On \*(C`XRF\*(C' \*(C`XRFMFB\*(C' is negative</p><p>On \*(C`MST\*(C' \*(C`STATUS\*(C' is set to 1 As indicated above, as Master file records are updated the \*(C`MST\*(C' file grows in size and there will be lost space in the file which cannot be used. The reorganization facilities allow this space to be reclaimed by recompacting the file.</p><p>During the backup phase a Master file backup file is created (\*(C`.BKP\*(C'). The structure and format of this file is the same as the Master file (\*(C`.MST\*(C'), except that a Crossreference file is not required as all the records are adjacent. Records marked for deletion are not backed up. Because only the latest copy of each record is backed up, the system does not allow you to perform a backup whenever an Inverted file update is pending for one or more records.</p><p>During the restore phase the backup file is read sequentially and the program recreates the \*(C`MST\*(C' and \*(C`XRF\*(C' file. At this point alt records which were marked for logical deletion (before the backup) are now marked as physically deleted (by setting \*(C`XRFMFB = -1\*(C' and \*(C`XRFMFP = 0\*(C'. Deleted records are detected by checking holes in the \*(C`MFN\*(C' numbering.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">Inverted file structure and record formats</h2>
        <div class="sectioncontent">
<p>The \s-1CDS/ISIS\s0 Inverted file consists of six physical files, five of which contain the dictionary of searchable terms (organized as a B*tree) and the sixth contains the list of postings associated with each term. In order to optimize disk storage, two separate B*trees are maintained, one for terms of up to 10 characters (stored in files \*(C`.N01\*(C'/\*(C`.L01\*(C') and one for terms longer than 10 characters, up to a maximum of 30 characters (stored in files \*(C`.N02\*(C'/\*(C`.L02\*(C'). The file \*(C`CNT\*(C' contains control fields for both B*trees. In each B*tree the file \*(C`.N0x\*(C' contains the nodes of the tree and the \*(C`.L0x\*(C' file contains the leafs. The leaf records point to the postings file \*(C`.IFP\*(C'.</p><p>The relationship between the various files is schematically represented in Figure 67.</p><p>The physical relationship between these six files is a pointer, which represents the relative address of the record being pointed to. A relative address is the ordinal record number of a record in a given file (i.e. the first record is record number 1, the second is record number 2, etc.). The file \*(C`.CNT\*(C' points to the file \*(C`.N0x\*(C', \*(C`.N0x\*(C' points to \*(C`.L0x\*(C', and \*(C`.L0x\*(C' points to \*(C`.IFP\*(C'. Because the \*(C`.IFP\*(C' is a packed file, the pointer from \*(C`.L0x\*(C' to \*(C`.IFP\*(C' has two components: the block number and the offset within the block, each expressed as an integer. This file contain two 26-byte fixed length records (one for each B*tree) each containing 10 integers as follows (fields marked with * are 31-bit signed integers): B*tree type (1 for \*(C`.N01\*(C'/\*(C`.L01\*(C', 2 for \*(C`.N02\*(C'/\*(C`.L02\*(C') Nodes order (each \*(C`.N0x\*(C' record contains at most \*(C`2*ORDN\*(C' keys) Leafs order (each \*(C`.L0x\*(C' record contains at most \*(C`2*ORDF\*(C' keys) Number of memory buffers allocated for nodes Number of buffers allocated to lst level index (\*(C`K &lt; N\*(C') Current number of index levels Pointer to Root record in \*(C`.N0x\*(C' Next available position in \*(C`.N0x\*(C' file Next available position in \*(C`.L0x\*(C' file Formal B*tree normality indicator (0 if B*tree is abnormal, 1 if B*tree is normal). A B*tree is abnormal if the nodes file \*(C`.N0x\*(C' contains only the Root.</p><p>\*(C`ORDN\*(C', \*(C`ORDF\*(C', \*(C`N\*(C' and \*(C`K\*(C' are fixed for a given generated system. Currently these values are set as follows:</p><p>\*(C`ORDN = 5\*(C'; \*(C`ORDF = 5\*(C'; \*(C`N = 15\*(C'; \*(C`K = 5\*(C' for both B*trees</p><p>                  +--------------+                   | Root address |                   +-------|------+                           |                          .CNT file                           |                      -------------                           |                          .N0x file               +-----------V--------+               | Key1 Key2 ... Keyn |                   Root               +---|-------------|--+                   |             |             +-----+             +------+             |                          |  +----------V----------+     +---------V----------+ 1st level  | Key1  Key2 ... Keyn | ... | Key1 Key2 ... Keyn |   index  +--|------------------+     +-----------------|--+     |                                          :     :                                  +-------+     |                                  |  +--V------------------+     +---------V----------+ last level  | Key1  Key2 ... Keyn | ... | Key1 Key2 ... Keyn |   index  +---------|-----------+     +---------|----------+            |                           |            |                           |         -------------            |                           |             .L0x file  +---------V-----------+     +---------V----------+  | Key1  Key2 ... Keyn | ... | Key1 Key2 ... Keyn |  +--|------------------+     +--------------------+     |     |                                            -------------     |                                                .IPF file  +--V----------------------------------+  | P1  P2  P3 ..................... Pn |  +-------------------------------------+</p><p><em>Figure 67: Inverted file structure</em></p><p>The other values are set as required when the B*trees are generated. These files contain the indexes) of the dictionary of searchable terms (\*(C`.N01\*(C' for terms shorter than 11 characters and \*(C`.N02\*(C' for terms longer than 10 characters). The \*(C`.N0x\*(C' file records have the following format (fields marked with * are 31-bit signed integers): an integer indicating the relative record number (1 for the first record, 2 for the second record, etc.) an integer indicating the number of active keys in the record ( \*(C`1 &lt;= OCK &lt;= 2*ORDN\*(C' ) an integer indicating the type of B*tree (1 for \*(C`.N01\*(C', 2 for \*(C`.N02\*(C') an array of \*(C`ORDN\*(C' entries (\*(C`OCK\*(C' of which are active), each having the following format:</p><p>a fixed length character string of length \*(C`.LEx\*(C' (\*(C`LE1 =10\*(C', \*(C`LE2 = 30\*(C') a pointer to the \*(C`.N0x\*(C' record (if \*(C`PUNT &gt; 0\*(C') or \*(C`.L0x\*(C' record (if \*(C`PUNT &lt; 0\*(C') whose \*(C`<strong>IDX</strong>(1).KEY = KEY\*(C'. \*(C`PUNT = 0\*(C' indicates an inactive entry. A positive \*(C`PUNT\*(C' indicates a branch to a hierarchically lower level index. The lowest level index (\*(C`PUNT &lt; 0\*(C') points the leafs in the \*(C`.L0x\*(C' file.</p><p>These files contain the full dictionary of searchable terms (\*(C`.L01\*(C' for terms shorter than 11 characters and \*(C`.L02\*(C' for terms longer than 10 characters). The \*(C`.L0x\*(C' file records have the following format (fields marked with \*(C`*\*(C' are 31-bit signed integers): an integer indicating the relative record number (1 for the first record, 2 for the second record, etc.) an integer indicating the number of active keys in the record (\*(C`1 &lt; OCK &lt;= 2*ORDF\*(C') an integer indicating the type of B*tree (1 for \*(C`.N01\*(C', 2 for \*(C`.N02\*(C') is the immediate successor of \*(C`IDX[OCK].KEY\*(C' in this record (this is used to speed up sequential access to the file) an array of \*(C`ORDN\*(C' entries (\*(C`OCK\*(C' of which are active), each having the following format:</p><p>a fixed length character string of length \*(C`LEx\*(C' (\*(C`LE1=10\*(C', \*(C`LE2=30\*(C') a pointer to the \*(C`.IFP\*(C' record where the list of postings associated with \*(C`KEY\*(C' begins. This pointer consists of two 31-bit signed integers as follows:</p><p>relative block number in \*(C`.IFP\*(C' offset (word number relative to 0) to postings list</p><p>This file contains the list of postings for each dictionary term. Each list of postings has the format indicated below. The file is structured in blocks of 512 characters, where (for an initially loaded and compacted file) the lists of postings for each term are adjacent, except as noted below.</p><p>The general format of each block is: a 31-bit signed integer indicating the Block number of this block (blocks are numbered from 1) An array of 127 31-bit signed integers</p><p>\*(C`IFPREC[1]\*(C' and \*(C`FPREC[2]\*(C' of the first block are a pointer to the next available position in the \*(C`.IFP\*(C' file.</p><p>Pointers from \*(C`.L0x\*(C' to \*(C`.IFP\*(C' and pointers within \*(C`.IFP\*(C' consist of two 31-bit signed integers: the first integer is a block number, and the second integer is a word offset in \*(C`IFPREC\*(C' (e.g. the offset to the first word in \*(C`IFPREC\*(C' is 0). The list of postings associated with the first search term will therefore start at 1/0.</p><p>Each list of postings consists of a header (5 double-words) followed by the actual list of postings (8 bytes for each posting). The header has the following format (each field is a 31-bit signed integer): Pointer to next segment (Block number) Pointer to next segment (offset) Total number of postings (accurate only in first segment) Number of postings in this segment (\*(C`IFPSEGP &lt;= IFPTOTP\*(C') Segment capacity (i.e. number of postings which can be stored in this segment)</p><p>Each posting is a 64-bit string partitioned as follows: (24 bits) Master file number (16 bits) Field identifier (assigned from the \*(C`FST\*(C') (8 bits) Occurrence number (16 bits) Term sequence number in field</p><p>Each field is stored in a strict left-to-right sequence with leading zeros added if necessary to adjust the corresponding bit string to the right (this allows comparisons of two postings as character strings).</p><p>The list of postings is stored in ascending \*(C`PMFN\*(C'/\*(C`PTAG\*(C'/\*(C`POCC\*(C'/\*(C`PCNT\*(C' sequence. When the inverted file is loaded sequentially (e.g. after a full inverted file generation with \s-1ISISINV\s0), each list consists of one or more adjacent segments. If \*(C`IFPTOT &lt;= 32768\*(C' then: \*(C`IFPNXTB/IFPNXTP = 0/0\*(C' and \*(C`IFPTOT = IFPSEGP = IFPSEGC\*(C'.</p><p>As updates are performed, additional segments may be created whenever new postings must be added. In this case a new segment with capacity \*(C`IFPTOTP\*(C' is created and linked to other segments (through the pointer \*(C`IFPNXTB\*(C'/\*(C`IFPNXTP\*(C') in such a way that the sequence \*(C`PMFN\*(C'/\*(C`PTAG\*(C'/\*(C`POCC\*(C'/\*(C`PCNT\*(C' is maintained. Whenever such a split occurs the postings of the segment where the new posting should have been inserted are equally distributed between this segment and the newly created segment. New segments are always written at the end of the file (which is maintained in \*(C`IFPREC[1]\*(C'/\*(C`IFPREC[2]\*(C' of the first \*(C`.IFP\*(C' block.</p><p>For example, assume that a new posting \*(C`Px\*(C' has to be inserted between \*(C`P2\*(C' and \*(C`P3\*(C' in the following list:</p><p> +----------------------------+  | 0 0 5 5 5 | P1 P2 P3 P4 P5 |  +----------------------------+</p><p>after the split (and assuming that the next available position in \*(C`.IFP\*(C' is 3/4) the list of postings will consist of the following two segments:</p><p> +----------------------------+  | 3 4 5 3 5 | P2 P2 Px -- -- |  +--|-------------------------+     |  +--V-------------------------+  | 0 0 5 3 5 | P3 P4 P5 -- -- |  +----------------------------+</p><p>In this situation, no new segment will be created until either segment becomes again full.</p><p>As mentioned above, the posting lists are normally stored one after the other. However, in order to facilitate access to the \*(C`.IFP\*(C' file the segments are stored in such a way that:</p>
<dl class='dl-vertical'>
  <dt>
    1
  </dt>
  <dd>
    <p>the header and the first posting in each list (28 bytes) are never split between two blocks.</p>
  </dd>
  <dt>
    2
  </dt>
  <dd>
    <p>a posting is never split between two blocks; if there is not enough room in the current block the whole posting is stored in the next block.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">LICENCE</h2>
        <div class="sectioncontent">
<p>\s-1UNESCO\s0 has developed and owns the intellectual property of the \s-1CDS/ISIS\s0 software (in whole or in part, including all files and documentation, from here on referred to as \s-1CDS/ISIS\s0) for the storage and retrieval of information.</p><p>For complete text of licence visit &lt;http://www.unesco.org/isis/files/winisislicense.html&gt;.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Biblio::Isis.3pm.html"><span aria-hidden="true">&larr;</span> Biblio::Isis.3pm: Read cds/isis, winisis and isismarc database</a></li>
   <li class="next"><a href="Biblio::Thesaurus.3pm.html">Biblio::Thesaurus.3pm: Perl extension for managing iso thesaurus <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

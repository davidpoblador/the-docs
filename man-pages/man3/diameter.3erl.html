<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>diameter: Main api of the diameter application.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Main api of the diameter application.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="diameter (3erl) manual">
  <meta name="twitter:description" content="Main api of the diameter application.">
  <meta name="twitter:image" content="https://www.carta.tech/images/erlang-manpages-diameter-3erl.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3erl/diameter.3erl.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="diameter (3erl) manual" />
  <meta property="og:description" content="Main api of the diameter application." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/erlang-manpages-diameter-3erl.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">diameter<small> (3erl)</small></h1>
        <p class="lead">Main api of the diameter application.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/diameter.3erl.html">
      <span itemprop="name">diameter: Main api of the diameter application.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/erlang-manpages/">
      <span itemprop="name">erlang-manpages</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3erl/diameter.3erl.html">
      <span itemprop="name">diameter: Main api of the diameter application.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>This module provides the interface with which a user can implement a Diameter node that sends and receives messages using the Diameter protocol as defined in RFC 6733.</p><p>Basic usage consists of creating a representation of a locally implemented Diameter node and its capabilities with <strong>start_service/2</strong>, adding transport capability using <strong>add_transport/2</strong> and sending Diameter requests and receiving Diameter answers with <strong>call/4</strong>. Incoming Diameter requests are communicated as callbacks to a <strong>diameter_app(3erl)</strong> callback modules as specified in the service configuration.</p><p>Beware the difference between <em>diameter</em> (not capitalized) and <em>Diameter</em> (capitalized). The former refers to the Erlang application named diameter whose main api is defined here, the latter to Diameter protocol in the sense of RFC 6733.</p><p>The diameter application must be started before calling most functions in this module.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DATA TYPES</h2>
        <div class="sectioncontent">

<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>Address()</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>DiameterIdentity()</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>Grouped()</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>OctetString()</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>Time()</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>Unsigned32()</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>UTF8String()</em>: Types corresponding to RFC 6733 AVP Data Formats. Defined in <a href="../man5/diameter_dict.5.html"><strong>diameter_dict</strong>(5)</a></strong>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>application_alias() = term()</em>: A name identifying a Diameter application in service configuration. Passed to <strong>call/4</strong> when sending requests defined by the application.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>application_module() = Mod | [Mod | ExtraArgs] | #diameter_callback{}</em>:</p>
  </dd>

</dl>

<pre>
Mod = atom()
ExtraArgs = list()

</pre>
<p>A module implementing the callback interface defined in <strong>diameter_app(3erl)</strong>, along with any extra arguments to be appended to those documented. Note that extra arguments specific to an outgoing request can be specified to <strong>call/4</strong>, in which case those are are appended to any module-specific extra arguments.</p><p>Specifying a <em>#diameter_callback{}</em> record allows individual functions to be configured in place of the usual <strong>diameter_app(3erl)</strong> callbacks. See <em>diameter_callback.erl</em> for details.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>application_opt()</em>: Options defining a Diameter application. Has one the following types.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{alias, </em><strong>application_alias()</strong>}: A unique identifier for the application in the scope of the service. Defaults to the value of the <em>dictionary</em> option if unspecified.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{dictionary, atom()}</em>: The name of an encode/decode module for the Diameter messages defined by the application. These modules are generated from files whose format is documented in <a href="../man5/diameter_dict.5.html"><strong>diameter_dict</strong>(5)</a></strong>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{module, </em><strong>application_module()</strong>}: The callback module with which messages of the Diameter application are handled. See <strong>diameter_app(3erl)</strong> for the required interface and semantics.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{state, term()}</em>: The initial callback state. The prevailing state is passed to some <strong>diameter_app(3erl)</strong> callbacks, which can then return a new state. Defaults to the value of the <em>alias</em> option if unspecified.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{call_mutates_state, true|false}</em>: Specifies whether or not the <strong>pick_peer/4</strong> application callback can modify the application state. Defaults to <em>false</em> if unspecified.</p>
  </dd>

</dl>
<p><strong></strong> Warning:</p><p><strong>pick_peer/4</strong> callbacks are serialized when this option is <em>true</em>, which is a potential performance bottleneck. A simple Diameter client may suffer no ill effects from using mutable state but a server or agent that responds to incoming request should probably avoid it.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{answer_errors, callback|report|discard}</em>: Determines the manner in which incoming answer messages containing decode errors are handled.</p><p>If <em>callback</em> then errors result in a <strong>handle_answer/4</strong> callback in the same fashion as for <strong>handle_request/3</strong>, with errors communicated in the <em>errors</em> field of the <em>#diameter_packet{}</em> passed to the callback. If <em>report</em> then an answer containing errors is discarded without a callback and a warning report is written to the log. If <em>discard</em> then an answer containing errors is silently discarded without a callback. In both the <em>report</em> and <em>discard</em> cases the return value for the <strong>call/4</strong> invocation in question is as if a callback had taken place and returned <em>{error, failure}</em>.</p><p>Defaults to <em>discard</em> if unspecified.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{request_errors, answer_3xxx|answer|callback}</em>: Determines the manner in which incoming requests are handled when an error other than 3007 (DIAMETER_APPLICATION_UNSUPPORTED, which cannot be associated with an application callback module), is detected.</p><p>If <em>answer_3xxx</em> then requests are answered without a <strong>handle_request/3</strong> callback taking place. If <em>answer</em> then even 5xxx errors are answered without a callback unless the connection in question has configured the RFC 3588 common dictionary as noted below. If <em>callback</em> then a <strong>handle_request/3</strong> callback always takes place and its return value determines the answer sent to the peer, if any.</p><p>Defaults to <em>answer_3xxx</em> if unspecified.</p>
  </dd>

</dl>
<p><strong></strong> Note:</p><p>Answers sent by diameter set the E-bit in the Diameter Header. Since RFC 3588 allows only 3xxx result codes in an <em>answer-message</em>, <em>answer</em> has the same semantics as <em>answer_3xxx</em> when the transport in question has been configured with <em>diameter_gen_base_rfc3588</em> as its common dictionary. Since RFC 6733 allows both 3xxx and 5xxx result codes in an <em>answer-message</em>, a transport with <em>diameter_gen_base_rfc6733</em> as its common dictionary does distinguish between <em>answer_3xxx</em> and <em>answer</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>call_opt()</em>: Options available to <strong>call/4</strong> when sending an outgoing Diameter request. Has one of the following types.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{extra, list()}</em>: Extra arguments to append to callbacks to the callback module in question. These are appended to any extra arguments configured on the callback itself. Multiple options append to the argument list.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{filter, </em><strong>peer_filter()</strong>}: A filter to apply to the list of available peers before passing it to the <strong>pick_peer/4</strong> callback for the application in question. Multiple options are equivalent a single <em>all</em> filter on the corresponding list of filters. Defaults to <em>none</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{timeout, </em><strong>Unsigned32()</strong>}: The number of milliseconds after which the request should timeout. Defaults to 5000.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>detach</em>: Causes <strong>call/4</strong> to return <em>ok</em> as soon as the request in question has been encoded, instead of waiting for and returning the result from a subsequent <strong>handle_answer/4</strong> or <strong>handle_error/4</strong> callback.</p>
  </dd>

</dl>
<p>An invalid option will cause <strong>call/4</strong> to fail.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>capability()</em>: AVP values sent in outgoing CER or CEA messages during capabilities exchange. Can be configured both on a service and a transport, values on the latter taking precedence. Has one of the following types.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{'Origin-Host', </em><strong>DiameterIdentity()</strong>}:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{'Origin-Realm', </em><strong>DiameterIdentity()</strong>}:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{'Host-IP-Address', [</em><strong>Address()</strong>]}: An address list is available to the start function of a <strong>transport module</strong>, which can return a new list for use in the subsequent CER or CEA. Host-IP-Address need not be specified if the transport module in question communicates an address list as described in <strong>diameter_transport(3erl)</strong></p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{'Vendor-Id', </em><strong>Unsigned32()</strong>}:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{'Product-Name', </em><strong>UTF8String()</strong>}:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{'Origin-State-Id', </em><strong>Unsigned32()</strong>}: Origin-State-Id is optional but, if configured, will be included in outgoing CER/CEA and DWR/DWA messages. Setting a value of <em>0</em> (zero) is equivalent to not setting a value, as documented in RFC 6733. The function <strong>origin_state_id/0</strong> can be used as to retrieve a value that is computed when the diameter application is started.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{'Supported-Vendor-Id', [</em><strong>Unsigned32()</strong>]}:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{'Auth-Application-Id', [</em><strong>Unsigned32()</strong>]}:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{'Inband-Security-Id', [</em><strong>Unsigned32()</strong>]}: Inband-Security-Id defaults to the empty list, which is equivalent to a list containing only 0 (NO_INBAND_SECURITY). If 1 (TLS) is specified then TLS is selected if the CER/CEA received from the peer offers it.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{'Acct-Application-Id', [</em><strong>Unsigned32()</strong>]}:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{'Vendor-Specific-Application-Id', [</em><strong>Grouped()</strong>]}:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{'Firmware-Revision', </em><strong>Unsigned32()</strong>}:</p>
  </dd>

</dl>
<p>Note that each tuple communicates one or more AVP values. It is an error to specify duplicate tuples.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>evaluable() = {M,F,A} | fun() | [evaluable() | A]</em>: An expression that can be evaluated as a function in the following sense.</p>
  </dd>

</dl>

<pre>
eval([{M,F,A} | T]) -&gt;
    apply(M, F, T ++ A);
eval([[F|A] | T]) -&gt;
    eval([F | T ++ A]);
eval([F|A]) -&gt;
    apply(F, A);
eval(F) -&gt;
    eval([F]).

</pre>
<p>Applying an <em></em><strong>evaluable()</strong> <em>E</em> to an argument list <em>A</em> is meant in the sense of <em>eval([E|A])</em>.</p><p><strong></strong> Warning:</p><p>Beware of using fun expressions of the form <em>fun Name/Arity</em> in situations in which the fun is not short-lived and code is to be upgraded at runtime since any processes retaining such a fun will have a reference to old code. In particular, such a value is typically inappropriate in configuration passed to <strong>start_service/2</strong> or <strong>add_transport/2</strong>.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>peer_filter() = term()</em>: A filter passed to <strong>call/4</strong> in order to select candidate peers for a <strong>pick_peer/4</strong> callback. Has one of the following types.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>none</em>: Matches any peer. This is a convenience that provides a filter equivalent to no filter.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>host</em>: Matches only those peers whose Origin-Host has the same value as Destination-Host in the outgoing request in question, or any peer if the request does not contain a Destination-Host AVP.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>realm</em>: Matches only those peers whose Origin-Realm has the same value as Destination-Realm in the outgoing request in question, or any peer if the request does not contain a Destination-Realm AVP.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{host, any|</em><strong>DiameterIdentity()</strong>}: Matches only those peers whose Origin-Host has the specified value, or all peers if the atom <em>any</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{realm, any|</em><strong>DiameterIdentity()</strong>: Matches only those peers whose Origin-Realm has the specified value, or all peers if the atom <em>any</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{eval, </em><strong>evaluable()</strong>}: Matches only those peers for which the specified <em></em><strong>evaluable()</strong> returns <em>true</em> when applied to the connection's <em>diameter_caps</em> record. Any other return value or exception is equivalent to <em>false</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{neg, </em><strong>peer_filter()</strong>}: Matches only those peers not matched by the specified filter.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{all, [</em><strong>peer_filter()</strong>]}: Matches only those peers matched by each filter in the specified list.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{any, [</em><strong>peer_filter()</strong>]}: Matches only those peers matched by at least one filter in the specified list.</p>
  </dd>

</dl>
<p>An invalid filter is equivalent to <em>{any,[]}</em>, a filter that matches no peer.</p>
  </dd>

</dl>
<p><strong></strong> Note:</p><p>The <em>host</em> and <em>realm</em> filters cause the Destination-Host and Destination-Realm AVPs to be extracted from the outgoing request, assuming it to be a record- or list-valued <em></em><strong>diameter_codec:message()</strong>, and assuming at most one of each AVP. If this is not the case then the <em>{host|realm, </em><strong>DiameterIdentity()</strong>} filters must be used to achieve the desired result. An empty <em></em><strong>DiameterIdentity()</strong> (which should not be typical) matches all hosts/realms for the purposes of filtering.</p><p><strong></strong> Warning:</p><p>A <em>host</em> filter is not typically desirable when setting Destination-Host since it will remove peer agents from the candidates list.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>service_event() = #diameter_event{service = </em><strong>service_name()</strong>, info = <strong>service_event_info()</strong>}: An event message sent to processes that have subscribed to these using <strong>subscribe/1</strong>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>service_event_info() = term()</em>: The <em>info</em> field of a <strong>service_event()</strong> record. Can have one of the following types.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>start</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>stop</em>: The service is being started or stopped. No event precedes a <em>start</em> event. No event follows a <em>stop</em> event, and this event implies the termination of all transport processes.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{up, Ref, Peer, Config, Pkt}</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{up, Ref, Peer, Config}</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{down, Ref, Peer, Config}</em>:</p>
  </dd>

</dl>

<pre>
Ref    = <strong>transport_ref()</strong>
Peer   = <strong>diameter_app:peer()</strong>
Config = {connect|listen, [<strong>transport_opt()</strong>]}
Pkt    = #diameter_packet{}

</pre>
<p>The RFC 3539 watchdog state machine has transitioned into (<em>up</em>) or out of (<em>down</em>) the OKAY state. If a <em>#diameter_packet{}</em> is present in an <em>up</em> event then there has been a capabilities exchange on a newly established transport connection and the record contains the received CER or CEA.</p><p>Note that a single <em>up</em> or <em>down</em> event for a given peer corresponds to multiple <strong>peer_up/3</strong> or <strong>peer_up/3</strong> callbacks, one for each of the Diameter applications negotiated during capabilities exchange. That is, the event communicates connectivity with the peer as a whole while the callbacks communicate connectivity with respect to individual Diameter applications.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{reconnect, Ref, Opts}</em>:</p>
  </dd>

</dl>

<pre>
Ref  = <strong>transport_ref()</strong>
Opts = [<strong>transport_opt()</strong>]

</pre>
<p>A connecting transport is attempting to establish/reestablish a transport connection with a peer following <strong>connect_timer</strong> or <strong>watchdog_timer</strong> expiry.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{closed, Ref, Reason, Config}</em>:</p>
  </dd>

</dl>

<pre>
Ref = <strong>transport_ref()</strong>
Config = {connect|listen, [<strong>transport_opt()</strong>]}

</pre>
<p>Capabilities exchange has failed. <em>Reason</em> can have one of the following types.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{'CER', Result, Caps, Pkt}</em>:</p>
  </dd>

</dl>

<pre>
Result = ResultCode | {capabilities_cb, CB, ResultCode|discard}
Caps = #diameter_caps{}
Pkt  = #diameter_packet{}
ResultCode = integer()
CB = <strong>evaluable()</strong>

</pre>
<p>An incoming CER has been answered with the indicated result code, or discarded. <em>Caps</em> contains pairs of values, for the local node and remote peer respectively. <em>Pkt</em> contains the CER in question. In the case of rejection by a capabilities callback, the tuple contains the rejecting callback.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{'CER', Caps, {ResultCode, Pkt}}</em>:</p>
  </dd>

</dl>

<pre>
ResultCode = integer()
Caps = #diameter_caps{}
Pkt  = #diameter_packet{}

</pre>
<p>An incoming CER contained errors and has been answered with the indicated result code. <em>Caps</em> contains values for the local node only. <em>Pkt</em> contains the CER in question.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{'CER', timeout}</em>: An expected CER was not received within <strong>capx_timeout</strong> of connection establishment.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{'CEA', Result, Caps, Pkt}</em>:</p>
  </dd>

</dl>

<pre>
Result = integer() | atom() | {capabilities_cb, CB, ResultCode|discard}
Caps = #diameter_caps{}
Pkt  = #diameter_packet{}
ResultCode = integer()

</pre>
<p>An incoming CEA has been rejected for the indicated reason. An integer-valued <em>Result</em> indicates the result code sent by the peer. <em>Caps</em> contains pairs of values for the local node and remote peer. <em>Pkt</em> contains the CEA in question. In the case of rejection by a capabilities callback, the tuple contains the rejecting callback.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{'CEA', Caps, Pkt}</em>:</p>
  </dd>

</dl>

<pre>
Caps = #diameter_caps{}
Pkt  = #diameter_packet{}

</pre>
<p>An incoming CEA contained errors and has been rejected. <em>Caps</em> contains only values for the local node. <em>Pkt</em> contains the CEA in question.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{'CEA', timeout}</em>: An expected CEA was not received within <strong>capx_timeout</strong> of connection establishment.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{watchdog, Ref, PeerRef, {From, To}, Config}</em>:</p>
  </dd>

</dl>

<pre>
Ref = <strong>transport_ref()</strong>
PeerRef = <strong>diameter_app:peer_ref()</strong>
From, To = initial | okay | suspect | down | reopen
Config = {connect|listen, [transport_opt()]}

</pre>
<p>An RFC 3539 watchdog state machine has changed state.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>any()</em>: For forward compatibility, a subscriber should be prepared to receive info fields of forms other than the above.</p>
  </dd>

</dl>

  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>service_name() = term()</em>: The name of a service as passed to <strong>start_service/2</strong> and with which the service is identified. There can be at most one service with a given name on a given node. Note that <strong>erlang:make_ref/0</strong> can be used to generate a service name that is somewhat unique.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>service_opt()</em>: An option passed to <strong>start_service/2</strong>. Can be any <em></em><strong>capability()</strong> as well as the following.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{application, [</em><strong>application_opt()</strong>]}: Defines a Diameter application supported by the service.</p><p>A service must configure one tuple for each Diameter application it intends to support. For an outgoing request, the relevant <em></em><strong>application_alias()</strong> is passed to <strong>call/4</strong>, while for an incoming request the application identifier in the message header determines the application, the identifier being specified in the application's <strong>dictionary</strong> file.</p>
  </dd>

</dl>
<p><strong></strong> Warning:</p><p>The capabilities advertised by a node must match its configured applications. In particular, <em>application</em> configuration must be matched by corresponding <strong>capability()</strong> configuration, of *-Application-Id AVPs in particular.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{restrict_connections, false | node | nodes | [node()] | evaluable()}</em>: Specifies the degree to which the service allows multiple transport connections to the same peer, as identified by its Origin-Host at capabilities exchange.</p><p>If <em>[node()]</em> then a connection is rejected if another already exists on any of the specified nodes. Types <em>false</em>, <em>node</em>, <em>nodes</em> and <strong>evaluable()</strong> are equivalent to <em>[]</em>, <em>[node()]</em>, <em>[node()|nodes()]</em> and the evaluated value respectively, evaluation of each expression taking place whenever a new connection is to be established. Note that <em>false</em> allows an unlimited number of connections to be established with the same peer.</p><p>Multiple connections are independent and governed by their own peer and watchdog state machines.</p><p>Defaults to <em>nodes</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{sequence, {H,N} | </em><strong>evaluable()</strong>}: Specifies a constant value <em>H</em> for the topmost <em>32-N</em> bits of of 32-bit End-to-End and Hop-by-Hop Identifiers generated by the service, either explicitly or as a return value of a function to be evaluated at <strong>start_service/2</strong>. In particular, an identifier <em>Id</em> is mapped to a new identifier as follows.</p>
  </dd>

</dl>

<pre>
(H bsl N) bor (Id band ((1 bsl N) - 1))

</pre>
<p>Note that RFC 6733 requires that End-to-End Identifiers remain unique for a period of at least 4 minutes and that this and the call rate places a lower bound on appropriate values of <em>N</em>: at a rate of <em>R</em> requests per second, an <em>N</em>-bit counter traverses all of its values in <em>(1 bsl N) div (R*60)</em> minutes, so the bound is <em>4*R*60 =&lt; 1 bsl N</em>.</p><p><em>N</em> must lie in the range <em>0..32</em> and <em>H</em> must be a non-negative integer less than <em>1 bsl (32-N)</em>.</p><p>Defaults to <em>{0,32}</em>.</p><p><strong></strong> Warning:</p><p>Multiple Erlang nodes implementing the same Diameter node should be configured with different sequence masks to ensure that each node uses a unique range of End-to-End and Hop-by-Hop Identifiers for outgoing requests.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{share_peers, boolean() | [node()] | evaluable()}</em>: Specifies nodes to which peer connections established on the local Erlang node are communicated. Shared peers become available in the remote candidates list passed to <strong>pick_peer/4</strong> callbacks on remote nodes whose services are configured to use them: see <em>use_shared_peers</em> below.</p><p>If <em>false</em> then peers are not shared. If <em>[node()]</em> then peers are shared with the specified list of nodes. If <em>evaluable()</em> then peers are shared with the nodes returned by the specified function, evaluated whenever a peer connection becomes available or a remote service requests information about local connections. The value <em>true</em> is equivalent to <em>fun </em><strong>erlang:nodes/0</strong>. The value <em>node()</em> in a list is ignored, so a collection of services can all be configured to share with the same list of nodes.</p><p>Defaults to <em>false</em>.</p>
  </dd>

</dl>
<p><strong></strong> Note:</p><p>Peers are only shared with services of the same name for the purpose of sending outgoing requests. Since the value of the <strong>application_opt()</strong> <em>alias</em>, passed to <strong>call/4</strong>, is the handle for identifying a peer as a suitable candidate, services that share peers must use the same aliases to identify their supported applications. They should typically also configure identical <strong>capabilities()</strong>, since by sharing peer connections they are distributing the implementation of a single Diameter node across multiple Erlang nodes.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{spawn_opt, [term()]}</em>: An options list passed to <strong>erlang:spawn_opt/2</strong> when spawning a process for an incoming Diameter request, unless the transport in question specifies another value. Options <em>monitor</em> and <em>link</em> are ignored.</p><p>Defaults to the empty list.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{use_shared_peers, boolean() | [node()] | evaluable()}</em>: Specifies nodes from which communicated peers are made available in the remote candidates list of <strong>pick_peer/4</strong> callbacks.</p><p>If <em>false</em> then remote peers are not used. If <em>[node()]</em> then only peers from the specified list of nodes are used. If <em>evaluable()</em> then only peers returned by the specified function are used, evaluated whenever a remote service communicates information about an available peer connection. The value <em>true</em> is equivalent to <em>fun </em><strong>erlang:nodes/0</strong>. The value <em>node()</em> in a list is ignored.</p><p>Defaults to <em>false</em>.</p>
  </dd>

</dl>
<p><strong></strong> Note:</p><p>A service that does not use shared peers will always pass the empty list as the second argument of <strong>pick_peer/4</strong> callbacks.</p><p><strong></strong> Warning:</p><p>Sending a request over a peer connection on a remote node is less efficient than sending it over a local connection. It may be preferable to make use of the <strong>service_opt()</strong> <em>restrict_connections</em> and maintain a dedicated connection on each node from which requests are sent.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>transport_opt()</em>: An option passed to <strong>add_transport/2</strong>. Has one of the following types.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{applications, [</em><strong>application_alias()</strong>]}: The list of Diameter applications to which the transport should be restricted. Defaults to all applications configured on the service in question. Applications not configured on the service in question are ignored.</p>
  </dd>

</dl>
<p><strong></strong> Warning:</p><p>The capabilities advertised by a node must match its configured applications. In particular, setting <em>applications</em> on a transport typically implies having to set matching *-Application-Id AVPs in a <strong>capabilities()</strong> tuple.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{capabilities, [</em><strong>capability()</strong>]}: AVPs used to construct outgoing CER/CEA messages. Values take precedence over any specified on the service in question.</p><p>Specifying a capability as a transport option may be particularly appropriate for Inband-Security-Id, in case TLS is desired over TCP as implemented by <strong>diameter_tcp(3erl)</strong>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{capabilities_cb, </em><strong>evaluable()</strong>}: A callback invoked upon reception of CER/CEA during capabilities exchange in order to ask whether or not the connection should be accepted. Applied to the <em></em><strong>transport_ref()</strong> and <em>#diameter_caps{}</em> record of the connection.</p><p>The return value can have one of the following types.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>ok</em>: Accept the connection.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>integer()</em>: Causes an incoming CER to be answered with the specified Result-Code.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>discard</em>: Causes an incoming CER to be discarded without CEA being sent.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>unknown</em>: Equivalent to returning <em>3010</em>, DIAMETER_UNKNOWN_PEER.</p>
  </dd>

</dl>
<p>Returning anything but <em>ok</em> or a 2xxx series result code causes the transport connection to be broken. Multiple <strong>capabilities_cb</strong> options can be specified, in which case the corresponding callbacks are applied until either all return <em>ok</em> or one does not.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{capx_timeout, </em><strong>Unsigned32()</strong>}: The number of milliseconds after which a transport process having an established transport connection will be terminated if the expected capabilities exchange message (CER or CEA) is not received from the peer. For a connecting transport, the timing of connection attempts is governed by <strong>connect_timer</strong> or <strong>watchdog_timer</strong> expiry. For a listening transport, the peer determines the timing.</p><p>Defaults to 10000.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{connect_timer, Tc}</em>:</p>
  </dd>

</dl>

<pre>
Tc = <strong>Unsigned32()</strong>

</pre>
<p>For a connecting transport, the RFC 6733 Tc timer, in milliseconds. This timer determines the frequency with which a transport attempts to establish an initial connection with its peer following transport configuration. Once an initial connection has been established, <strong>watchdog_timer</strong> determines the frequency of reconnection attempts, as required by RFC 3539.</p><p>For a listening transport, the timer specifies the time after which a previously connected peer will be forgotten: a connection after this time is regarded as an initial connection rather than reestablishment, causing the RFC 3539 state machine to pass to state OKAY rather than REOPEN. Note that these semantics are not governed by the RFC and that a listening transport's <strong>connect_timer</strong> should be greater than its peer's Tw plus jitter.</p><p>Defaults to 30000 for a connecting transport and 60000 for a listening transport.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{disconnect_cb, </em><strong>evaluable()</strong>}: A callback invoked prior to terminating the transport process of a transport connection having watchdog state <em>OKAY</em>. Applied to <em>application|service|transport</em> and the <em></em><strong>transport_ref()</strong> and <em></em><strong>diameter_app:peer()</strong> in question: <em>application</em> indicates that the diameter application is being stopped, <em>service</em> that the service in question is being stopped by <strong>stop_service/1</strong>, and <em>transport</em> that the transport in question is being removed by <strong>remove_transport/2</strong>.</p><p>The return value can have one of the following types.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{dpr, [option()]}</em>: Causes Disconnect-Peer-Request to be sent to the peer, the transport process being terminated following reception of Disconnect-Peer-Answer or timeout. An <em>option()</em> can be one of the following.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{cause, 0|rebooting|1|busy|2|goaway}</em>: The Disconnect-Cause to send, <em>REBOOTING</em>, <em>BUSY</em> and <em>DO_NOT_WANT_TO_TALK_TO_YOU</em> respectively. Defaults to <em>rebooting</em> for <em>Reason=service|application</em> and <em>goaway</em> for <em>Reason=transport</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{timeout, </em><strong>Unsigned32()</strong>}: The number of milliseconds after which the transport process is terminated if DPA has not been received. Defaults to 1000.</p>
  </dd>

</dl>

  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>dpr</em>: Equivalent to <em>{dpr, []}</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>close</em>: Causes the transport process to be terminated without Disconnect-Peer-Request being sent to the peer.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>ignore</em>: Equivalent to not having configured the callback.</p>
  </dd>

</dl>
<p>Multiple <strong>disconnect_cb</strong> options can be specified, in which case the corresponding callbacks are applied until one of them returns a value other than <em>ignore</em>. All callbacks returning <em>ignore</em> is equivalent to not having configured them.</p><p>Defaults to a single callback returning <em>dpr</em>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{length_errors, exit|handle|discard}</em>: Specifies how to deal with errors in the Message Length field of the Diameter Header in an incoming message. An error in this context is that the length is not at least 20 bytes (the length of a Header), is not a multiple of 4 (a valid length) or is not the length of the message in question, as received over the transport interface documented in <strong>diameter_transport(3erl)</strong>.</p><p>If <em>exit</em> then a warning report is emitted and the parent of the transport process in question exits, which causes the transport process itself to exit as described in <strong>diameter_transport(3erl)</strong>. If <em>handle</em> then the message is processed as usual, a resulting <strong>handle_request/3</strong> or <strong>handle_answer/4</strong> callback (if one takes place) indicating the <em>5015</em> error (DIAMETER_INVALID_MESSAGE_LENGTH). If <em>discard</em> then the message in question is silently discarded.</p><p>Defaults to <em>exit</em>.</p>
  </dd>

</dl>
<p><strong></strong> Note:</p><p>The default value reflects the fact that a transport module for a stream-oriented transport like TCP may not be able to recover from a message length error since such a transport must use the Message Length header to divide the incoming byte stream into individual Diameter messages. An invalid length leaves it with no reliable way to rediscover message boundaries, which may result in the failure of subsequent messages. See <strong>diameter_tcp(3erl)</strong> for the behaviour of that module.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{spawn_opt, [term()]}</em>: An options list passed to <strong>erlang:spawn_opt/2</strong> when spawning a process for an incoming Diameter request. Options <em>monitor</em> and <em>link</em> are ignored.</p><p>Defaults to the list configured on the service if not specified.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{transport_config, term()}</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{transport_config, term(), </em><strong>Unsigned32()</strong> | infinity}: A term passed as the third argument to the <strong>start/3</strong> function of the relevant <strong>transport module</strong> in order to start a transport process. Defaults to the empty list if unspecified.</p><p>The 3-tuple form additionally specifies an interval, in milliseconds, after which a started transport process should be terminated if it has not yet established a connection. For example, the following options on a connecting transport request a connection with one peer over SCTP or another (typically the same) over TCP.</p>
  </dd>

</dl>

<pre>
{transport_module, diameter_sctp}
{transport_config, SctpOpts, 5000}
{transport_module, diameter_tcp}
{transport_config, TcpOpts}

</pre>
<p>To listen on both SCTP and TCP, define one transport for each.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{transport_module, atom()}</em>: A module implementing a transport process as defined in <strong>diameter_transport(3erl)</strong>. Defaults to <em>diameter_tcp</em> if unspecified.</p><p>Multiple <em>transport_module</em> and <strong>transport_config</strong> options are allowed. The order of these is significant in this case (and only in this case), a <em>transport_module</em> being paired with the first <strong>transport_config</strong> following it in the options list, or the default value for trailing modules. Transport starts will be attempted with each of the modules in order until one establishes a connection within the corresponding timeout (see below) or all fail.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{watchdog_config, [{okay|suspect, non_neg_integer()}]}</em>: Specifies configuration that alters the behaviour of the watchdog state machine. On key <em>okay</em>, the non-negative number of answered DWR messages before transitioning from REOPEN to OKAY. On key <em>suspect</em>, the number of watchdog timeouts before transitioning from OKAY to SUSPECT when DWR is unanswered, or 0 to not make the transition.</p><p>Defaults to <em>[{okay, 3}, {suspect, 1}]</em>. Not specifying a key is equivalent to specifying the default value for that key.</p>
  </dd>

</dl>
<p><strong></strong> Warning:</p><p>The default value is as required by RFC 3539: changing it results in non-standard behaviour that should only be used to simulate misbehaving nodes during test.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>{watchdog_timer, TwInit}</em>:</p>
  </dd>

</dl>

<pre>
TwInit = <strong>Unsigned32()</strong>
       | {M,F,A}

</pre>
<p>The RFC 3539 watchdog timer. An integer value is interpreted as the RFC's TwInit in milliseconds, a jitter of +/- 2 seconds being added at each rearming of the timer to compute the RFC's Tw. An MFA is expected to return the RFC's Tw directly, with jitter applied, allowing the jitter calculation to be performed by the callback.</p><p>An integer value must be at least 6000 as required by RFC 3539. Defaults to 30000 if unspecified.</p><p>Unrecognized options are silently ignored but are returned unmodified by <strong>service_info/2</strong> and can be referred to in predicate functions passed to <strong>remove_transport/2</strong>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>transport_ref() = reference()</em>: An reference returned by <strong>add_transport/2</strong> that identifies the configuration.</p>
  </dd>

</dl>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">EXPORTS</h2>
        <div class="sectioncontent">
<p><strong></strong> add_transport(SvcName, {connect|listen, [Opt]}) -&gt; {ok, Ref} | {error, Reason}</p><p>Types:</p><p>SvcName = <strong>service_name()</strong></p><p>Opt = <strong>transport_opt()</strong></p><p>Ref = <strong>transport_ref()</strong></p><p>Reason = term()</p><p>Add transport capability to a service.</p><p>The service will start transport processes as required in order to establish a connection with the peer, either by connecting to the peer (<em>connect</em>) or by accepting incoming connection requests (<em>listen</em>). A connecting transport establishes transport connections with at most one peer, an listening transport potentially with many.</p><p>The diameter application takes responsibility for exchanging CER/CEA with the peer. Upon successful completion of capabilities exchange the service calls each relevant application module's <strong>peer_up/3</strong> callback after which the caller can exchange Diameter messages with the peer over the transport. In addition to CER/CEA, the service takes responsibility for the handling of DWR/DWA and required by RFC 3539, as well as for DPR/DPA.</p><p>The returned reference uniquely identifies the transport within the scope of the service. Note that the function returns before a transport connection has been established.</p><p><strong></strong> Note:</p><p>It is not an error to add a transport to a service that has not yet been configured: a service can be started after configuring its transports.</p><p><strong></strong> call(SvcName, App, Request, [Opt]) -&gt; Answer | ok | {error, Reason}</p><p>Types:</p><p>SvcName = <strong>service_name()</strong></p><p>App = <strong>application_alias()</strong></p><p>Request = <strong>diameter_codec:message()</strong></p><p>Answer = term()</p><p>Opt = <strong>call_opt()</strong></p><p>Send a Diameter request message.</p><p><em>App</em> specifies the Diameter application in which the request is defined and callbacks to the corresponding callback module will follow as described below and in <strong>diameter_app(3erl)</strong>. Unless the <em>detach</em> option is specified, the call returns either when an answer message is received from the peer or an error occurs. In the answer case, the return value is as returned by a <strong>handle_answer/4</strong> callback. In the error case, whether or not the error is returned directly by diameter or from a <strong>handle_error/4</strong> callback depends on whether or not the outgoing request is successfully encoded for transmission to the peer, the cases being documented below.</p><p>If there are no suitable peers, or if <strong>pick_peer/4</strong> rejects them by returning <em>false</em>, then <em>{error,no_connection}</em> is returned. Otherwise <strong>pick_peer/4</strong> is followed by a <strong>prepare_request/3</strong> callback, the message is encoded and then sent.</p><p>There are several error cases which may prevent an answer from being received and passed to a <strong>handle_answer/4</strong> callback:</p>
<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>If the initial encode of the outgoing request fails, then the request process fails and <em>{error,encode}</em> is returned.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>If the request is successfully encoded and sent but the answer times out then a <strong>handle_error/4</strong> callback takes place with <em>Reason = timeout</em>.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>If the request is successfully encoded and sent but the service in question is stopped before an answer is received then a <strong>handle_error/4</strong> callback takes place with <em>Reason = cancel</em>.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>If the transport connection with the peer goes down after the request has been sent but before an answer has been received then an attempt is made to resend the request to an alternate peer. If no such peer is available, or if the subsequent <strong>pick_peer/4</strong> callback rejects the candidates, then a <strong>handle_error/4</strong> callback takes place with <em>Reason = failover</em>. If a peer is selected then a <strong>prepare_retransmit/3</strong> callback takes place, after which the semantics are the same as following an initial <strong>prepare_request/3</strong> callback.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>If an encode error takes place during retransmission then the request process fails and <em>{error,failure}</em> is returned.</p>
  </dd>

</dl>

<dl class='dl-vertical'>
  <dt>
    <p>*</p>
  </dt>
  <dd>
    <p>If an application callback made in processing the request fails (pick_peer, prepare_request, prepare_retransmit, handle_answer or handle_error) then either <em>{error,encode}</em> or <em>{error,failure}</em> is returned depending on whether or not there has been an attempt to send the request over the transport.</p>
  </dd>

</dl>
<p>Note that <em>{error,encode}</em> is the only return value which guarantees that the request has <em>not</em> been sent over the transport connection.</p><p><strong></strong> origin_state_id() -&gt; <strong>Unsigned32()</strong></p><p>Return a reasonable value for use as Origin-State-Id in outgoing messages.</p><p>The value returned is the number of seconds since 19680120T031408Z, the first value that can be encoded as a Diameter <em></em><strong>Time()</strong>, at the time the diameter application was started.</p><p><strong></strong> remove_transport(SvcName, Pred) -&gt; ok | {error, Reason}</p><p>Types:</p><p>SvcName = <strong>service_name()</strong></p><p>Pred = Fun | MFA | <strong>transport_ref()</strong> | list() | true | false</p><p>Fun = fun((<strong>transport_ref()</strong>, connect|listen, list()) -&gt; boolean())</p><p> | fun((<strong>transport_ref()</strong>, list()) -&gt; boolean())</p><p> | fun((list()) -&gt; boolean())</p><p>MFA = {atom(), atom(), list()}</p><p>Reason = term()</p><p>Remove previously added transports.</p><p><em>Pred</em> determines which transports to remove. An arity-3-valued <em>Pred</em> removes all transports for which <em>Pred(Ref, Type, Opts)</em> returns <em>true</em>, where <em>Type</em> and <em>Opts</em> are as passed to <strong>add_transport/2</strong> and <em>Ref</em> is as returned by it. The remaining forms are equivalent to an arity-3 fun as follows.</p>
<pre>
Pred = fun(transport_ref(), list()):  fun(Ref, _, Opts) -&gt; Pred(Ref, Opts) end
Pred = fun(list()):                   fun(_, _, Opts) -&gt; Pred(Opts) end
Pred = transport_ref():               fun(Ref, _, _)  -&gt; Pred == Ref end
Pred = list():                        fun(_, _, Opts) -&gt; [] == Pred -- Opts end
Pred = true:                          fun(_, _, _) -&gt; true end
Pred = false:                         fun(_, _, _) -&gt; false end
Pred = {M,F,A}:  fun(Ref, Type, Opts) -&gt; apply(M, F, [Ref, Type, Opts | A]) end

</pre>
<p>Removing a transport causes the corresponding transport processes to be terminated. Whether or not a DPR message is sent to a peer is controlled by value of <strong>disconnect_cb</strong> configured on the transport.</p><p><strong></strong> service_info(SvcName, Info) -&gt; term()</p><p>Types:</p><p>SvcName = <strong>service_name()</strong></p><p>Info = Item | [Info]</p><p>Item = atom()</p><p>Return information about a started service. Requesting info for an unknown service causes <em>undefined</em> to be returned. Requesting a list of items causes a tagged list to be returned.</p><p><em>Item</em> can be one of the following.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>'Origin-Host'</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>'Origin-Realm'</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>'Vendor-Id'</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>'Product-Name'</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>'Origin-State-Id'</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>'Host-IP-Address'</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>'Supported-Vendor'</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>'Auth-Application-Id'</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>'Inband-Security-Id'</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>'Acct-Application-Id'</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>'Vendor-Specific-Application-Id'</em>:</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>'Firmware-Revision'</em>: Return a capability value as configured with <strong>start_service/2</strong>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>applications</em>: Return the list of applications as configured with <strong>start_service/2</strong>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>capabilities</em>: Return a tagged list of all capabilities values as configured with <strong>start_service/2</strong>.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>transport</em>: Return a list containing one entry for each of the service's transport as configured with <strong>add_transport/2</strong>. Each entry is a tagged list containing both configuration and information about established peer connections. An example return value with for a client service with Origin-Host "client.example.com" configured with a single transport connected to "server.example.com" might look as follows.</p>
  </dd>

</dl>

<pre>
[[{ref,#Ref&lt;0.0.0.93&gt;},
  {type,connect},
  {options,[{transport_module,diameter_tcp},
            {transport_config,[{ip,{127,0,0,1}},
                               {raddr,{127,0,0,1}},
                               {rport,3868},
                               {reuseaddr,true}]}]},
  {watchdog,{&lt;0.66.0&gt;,{1346,171491,996448},okay}},
  {peer,{&lt;0.67.0&gt;,{1346,171491,999906}}},
  {apps,[{0,common}]},
  {caps,[{origin_host,{"client.example.com","server.example.com"}},
         {origin_realm,{"example.com","example.com"}},
         {host_ip_address,{[{127,0,0,1}],[{127,0,0,1}]}},
         {vendor_id,{0,193}},
         {product_name,{"Client","Server"}},
         {origin_state_id,{[],[]}},
         {supported_vendor_id,{[],[]}},
         {auth_application_id,{[0],[0]}},
         {inband_security_id,{[],[0]}},
         {acct_application_id,{[],[]}},
         {vendor_specific_application_id,{[],[]}},
         {firmware_revision,{[],[]}},
         {avp,{[],[]}}]},
  {port,[{owner,&lt;0.69.0&gt;},
         {module,diameter_tcp},
         {socket,{{127,0,0,1},48758}},
         {peer,{{127,0,0,1},3868}},
         {statistics,[{recv_oct,656},
                      {recv_cnt,6},
                      {recv_max,148},
                      {recv_avg,109},
                      {recv_dvi,19},
                      {send_oct,836},
                      {send_cnt,6},
                      {send_max,184},
                      {send_avg,139},
                      {send_pend,0}]}]},
  {statistics,[{{{0,258,0},recv},3},
               {{{0,258,1},send},3},
               {{{0,257,0},recv},1},
               {{{0,257,1},send},1},
               {{{0,258,0},recv,{'Result-Code',2001}},3},
               {{{0,280,1},recv},2},
               {{{0,280,0},send},2}]}]]

</pre>
<p>Here <em>ref</em> is a <em></em><strong>transport_ref()</strong> and <em>options</em> the corresponding <em></em><strong>transport_opt()</strong> list passed to <strong>add_transport/2</strong>. The <em>watchdog</em> entry shows the state of a connection's RFC 3539 watchdog state machine. The <em>peer</em> entry identifies the <em></em><strong>diameter_app:peer_ref()</strong> for which there will have been <strong>peer_up/3</strong> callbacks for the Diameter applications identified by the <em>apps</em> entry, <em>common</em> being the <em></em><strong>application_alias()</strong>. The <em>caps</em> entry identifies the capabilities sent by the local node and received from the peer during capabilities exchange. The <em>port</em> entry displays socket-level information about the transport connection. The <em>statistics</em> entry presents Diameter-level counters, an entry like <em>{{{0,280,1},recv},2}</em> saying that the client has received 2 DWR messages: <em>{0,280,1} = {Application_Id, Command_Code, R_Flag}</em>.</p><p>Note that <em>watchdog</em>, <em>peer</em>, <em>apps</em>, <em>caps</em> and <em>port</em> entries depend on connectivity with the peer and may not be present. Note also that the <em>statistics</em> entry presents values accumulated during the lifetime of the transport configuration.</p><p>A listening transport presents its information slightly differently since there may be multiple accepted connections for the same <em></em><strong>transport_ref()</strong>. The <em>transport</em> info returned by a server with a single client connection might look as follows.</p>
<pre>
[[{ref,#Ref&lt;0.0.0.61&gt;},
  {type,listen},
  {options,[{transport_module,diameter_tcp},
            {transport_config,[{reuseaddr,true},
                               {ip,{127,0,0,1}},
                               {port,3868}]}]},
  {accept,[[{watchdog,{&lt;0.56.0&gt;,{1346,171481,226895},okay}},
            {peer,{&lt;0.58.0&gt;,{1346,171491,999511}}},
            {apps,[{0,common}]},
            {caps,[{origin_host,{"server.example.com","client.example.com"}},
                   {origin_realm,{"example.com","example.com"}},
                   {host_ip_address,{[{127,0,0,1}],[{127,0,0,1}]}},
                   {vendor_id,{193,0}},
                   {product_name,{"Server","Client"}},
                   {origin_state_id,{[],[]}},
                   {supported_vendor_id,{[],[]}},
                   {auth_application_id,{[0],[0]}},
                   {inband_security_id,{[],[]}},
                   {acct_application_id,{[],[]}},
                   {vendor_specific_application_id,{[],[]}},
                   {firmware_revision,{[],[]}},
                   {avp,{[],[]}}]},
            {port,[{owner,&lt;0.62.0&gt;},
                   {module,diameter_tcp},
                   {socket,{{127,0,0,1},3868}},
                   {peer,{{127,0,0,1},48758}},
                   {statistics,[{recv_oct,1576},
                                {recv_cnt,16},
                                {recv_max,184},
                                {recv_avg,98},
                                {recv_dvi,26},
                                {send_oct,1396},
                                {send_cnt,16},
                                {send_max,148},
                                {send_avg,87},
                                {send_pend,0}]}]}],
           [{watchdog,{&lt;0.72.0&gt;,{1346,171491,998404},initial}}]]},
  {statistics,[{{{0,280,0},recv},7},
               {{{0,280,1},send},7},
               {{{0,258,0},send,{'Result-Code',2001}},3},
               {{{0,258,1},recv},3},
               {{{0,258,0},send},3},
               {{{0,280,1},recv},5},
               {{{0,280,0},send},5},
               {{{0,257,1},recv},1},
               {{{0,257,0},send},1}]}]]

</pre>
<p>The information presented here is as in the <em>connect</em> case except that the client connections are grouped under an <em>accept</em> tuple.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>connections</em>: Return a list containing one entry for every established transport connection whose watchdog state machine is not in the <em>down</em> state. This is a flat view of <em>transport</em> info which lists only active connections and for which Diameter-level statistics are accumulated only for the lifetime of the transport connection. A return value for the server above might look as follows.</p>
  </dd>

</dl>

<pre>
[[{ref,#Ref&lt;0.0.0.61&gt;},
  {type,accept},
  {options,[{transport_module,diameter_tcp},
            {transport_config,[{reuseaddr,true},
                               {ip,{127,0,0,1}},
                               {port,3868}]}]},
  {watchdog,{&lt;0.56.0&gt;,{1346,171481,226895},okay}},
  {peer,{&lt;0.58.0&gt;,{1346,171491,999511}}},
  {apps,[{0,common}]},
  {caps,[{origin_host,{"server.example.com","client.example.com"}},
         {origin_realm,{"example.com","example.com"}},
         {host_ip_address,{[{127,0,0,1}],[{127,0,0,1}]}},
         {vendor_id,{193,0}},
         {product_name,{"Server","Client"}},
         {origin_state_id,{[],[]}},
         {supported_vendor_id,{[],[]}},
         {auth_application_id,{[0],[0]}},
         {inband_security_id,{[],[]}},
         {acct_application_id,{[],[]}},
         {vendor_specific_application_id,{[],[]}},
         {firmware_revision,{[],[]}},
         {avp,{[],[]}}]},
  {port,[{owner,&lt;0.62.0&gt;},
         {module,diameter_tcp},
         {socket,{{127,0,0,1},3868}},
         {peer,{{127,0,0,1},48758}},
         {statistics,[{recv_oct,10124},
                      {recv_cnt,132},
                      {recv_max,184},
                      {recv_avg,76},
                      {recv_dvi,9},
                      {send_oct,10016},
                      {send_cnt,132},
                      {send_max,148},
                      {send_avg,75},
                      {send_pend,0}]}]},
  {statistics,[{{{0,280,0},recv},62},
               {{{0,280,1},send},62},
               {{{0,258,0},send,{'Result-Code',2001}},3},
               {{{0,258,1},recv},3},
               {{{0,258,0},send},3},
               {{{0,280,1},recv},66},
               {{{0,280,0},send},66},
               {{{0,257,1},recv},1},
               {{{0,257,0},send},1}]}]]

</pre>
<p>Note that there may be multiple entries with the same <em>ref</em>, in contrast to <em>transport</em> info.</p>
<dl class='dl-vertical'>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em>statistics</em>: Return a <em>{{Counter, Ref}, non_neg_integer()}</em> list of counter values. <em>Ref</em> can be either a <em></em><strong>transport_ref()</strong> or a <em></em><strong>diameter_app:peer_ref()</strong>. Entries for the latter are folded into corresponding entries for the former as peer connections go down. Entries for both are removed at <strong>remove_transport/2</strong>. The Diameter-level statistics returned by <em>transport</em> and <em>connections</em> info are based upon these entries.</p>
  </dd>
  <dt>
    <p><strong></strong></p>
  </dt>
  <dd>
    <p><em></em><strong>diameter_app:peer_ref()</strong>: Return transport configuration associated with a single peer, as passed to <strong>add_transport/2</strong>. The returned list is empty if the peer is unknown. Otherwise it contains the <em>ref</em>, <em>type</em> and <em>options</em> tuples as in <em>transport</em> and <em>connections</em> info above. For example:</p>
  </dd>

</dl>

<pre>
[{ref,#Ref&lt;0.0.0.61&gt;},
 {type,accept},
 {options,[{transport_module,diameter_tcp},
           {transport_config,[{reuseaddr,true},
                              {ip,{127,0,0,1}},
                              {port,3868}]}]}]

</pre>
<p><strong></strong> services() -&gt; [SvcName]</p><p>Types:</p><p>SvcName = <strong>service_name()</strong></p><p>Return the list of started services.</p><p><strong></strong> session_id(Ident) -&gt; <strong>OctetString()</strong></p><p>Types:</p><p>Ident = <strong>DiameterIdentity()</strong></p><p>Return a value for a Session-Id AVP.</p><p>The value has the form required by section 8.8 of RFC 6733. Ident should be the Origin-Host of the peer from which the message containing the returned value will be sent.</p><p><strong></strong> start() -&gt; ok | {error, Reason}</p><p>Start the diameter application.</p><p>The diameter application must be started before starting a service. In a production system this is typically accomplished by a boot file, not by calling <em>start/0</em> explicitly.</p><p><strong></strong> start_service(SvcName, Options) -&gt; ok | {error, Reason}</p><p>Types:</p><p>SvcName = <strong>service_name()</strong></p><p>Options = [<strong>service_opt()</strong>]</p><p>Reason = term()</p><p>Start a diameter service.</p><p>A service defines a locally-implemented Diameter node, specifying the capabilities to be advertised during capabilities exchange. Transports are added to a service using <strong>add_transport/2</strong>.</p><p><strong></strong> Note:</p><p>A transport can both override its service's capabilities and restrict its supported Diameter applications so "service = Diameter node as identified by Origin-Host" is not necessarily the case.</p><p><strong></strong> stop() -&gt; ok | {error, Reason}</p><p>Stop the diameter application.</p><p><strong></strong> stop_service(SvcName) -&gt; ok | {error, Reason}</p><p>Types:</p><p>SvcName = <strong>service_name()</strong></p><p>Reason = term()</p><p>Stop a diameter service.</p><p>Stopping a service causes all associated transport connections to be broken. A DPR message with be sent as in the case of <strong>remove_transport/2</strong>.</p><p><strong></strong> Note:</p><p>Stopping a service does not remove any associated transports: <strong>remove_transport/2</strong> must be called to remove transport configuration.</p><p><strong></strong> subscribe(SvcName) -&gt; true</p><p>Types:</p><p>SvcName = <strong>service_name()</strong></p><p>Subscribe to <em></em><strong>service_event()</strong> messages from a service.</p><p>It is not an error to subscribe to events from a service that does not yet exist. Doing so before adding transports is required to guarantee the reception of all transport-related events.</p><p><strong></strong> unsubscribe(SvcName) -&gt; true</p><p>Types:</p><p>SvcName = <strong>service_name()</strong></p><p>Unsubscribe to event messages from a service.</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO diameter&hellip;</h2>
        <div class="sectioncontent">
<p><strong>diameter_app(3erl)</strong>, <strong>diameter_transport(3erl)</strong>, <a href="../man5/diameter_dict.5.html"><strong>diameter_dict</strong>(5)</a></strong></p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="dialyzer.3erl.html"><span aria-hidden="true">&larr;</span> dialyzer.3erl: The dialyzer, a discrepancy analyzer for erlang programs</a></li>
   <li class="next"><a href="diameter_app.3erl.html">diameter_app.3erl: Callback module of a diameter application. <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>POE::Component::DBIAgent: Poe component for running asynchronous dbi calls.</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Poe component for running asynchronous dbi calls.">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="POE::Component::DBIAgent (3pm) manual">
  <meta name="twitter:description" content="Poe component for running asynchronous dbi calls.">
  <meta name="twitter:image" content="https://www.carta.tech/images/libpoe-component-dbiagent-perl-POE::Component::DBIAgent-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/POE::Component::DBIAgent.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="POE::Component::DBIAgent (3pm) manual" />
  <meta property="og:description" content="Poe component for running asynchronous dbi calls." />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libpoe-component-dbiagent-perl-POE::Component::DBIAgent-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">POE::Component::DBIAgent<small> (3pm)</small></h1>
        <p class="lead">Poe component for running asynchronous dbi calls.</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/POE::Component::DBIAgent.3pm.html">
      <span itemprop="name">POE::Component::DBIAgent: Poe component for running asynchronous dbi calls.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libpoe-component-dbiagent-perl/">
      <span itemprop="name">libpoe-component-dbiagent-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/POE::Component::DBIAgent.3pm.html">
      <span itemprop="name">POE::Component::DBIAgent: Poe component for running asynchronous dbi calls.</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">SYNOPSIS</h2>
        <div class="sectioncontent">

<pre>
 sub _start {
    my ($self, $kernel, $heap) = @_[OBJECT, KERNEL, HEAP];

    $heap-&gt;{helper} = POE::Component::DBIAgent-&gt;new( DSN =&gt; [$dsn,
                                               $username,
                                               $password
                                              ],
                                       Queries =&gt; $self-&gt;make_queries,
                                       Count =&gt; 3,
                                       Debug =&gt; 1,
                                     );

        # Queries takes a hashref of the form:
        # { query_name =&gt; &apos;select blah from table where x = ?&apos;,
        #   other_query =&gt; &apos;select blah_blah from big_view&apos;,
        #   etc.
        # }

    $heap-&gt;{helper}-&gt;query(query_name =&gt;
                           { cookie =&gt; &apos;starting_query&apos; },
                           session =&gt; &apos;get_row_from_dbiagent&apos;);

 }

 sub get_row_from_dbiagent {
    my ($kernel, $self, $heap, $row, $cookie) = @_[KERNEL, OBJECT, HEAP, ARG0, ARG1];
    if ($row ne &apos;EOF&apos;) {

 # {{{ PROCESS A ROW

        #row is a listref of columns

 # }}} PROCESS A ROW

    } else {

 # {{{ NO MORE ROWS

        #cleanup code here

 # }}} NO MORE ROWS

    }

 }
</pre>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">DESCRIPTION</h2>
        <div class="sectioncontent">
<p>DBIAgent is your answer to non-blocking \s-1DBI\s0 in \s-1POE\s0.</p><p>It fires off a configurable number child processes (defaults to 3) and feeds database queries to it via two-way pipe (or sockets ... however POE::Component::Wheel::Run is able to manage it).  The primary method is \*(C`query\*(C'.</p><h3>Usage</h3>
<p>After initializing a DBIAgent and storing it in a session's heap, one executes a \*(C`query\*(C' (or \*(C`query_slow\*(C') with the query name, destination session (name or id) and destination state (as well as any query parameters, optionally) as arguments.  As each row of data comes back from the query, the destination state (in the destination session) is invoked with that row of data in its $_[ARG0] slot.  When there are no more rows to return, the data in $_[ARG0] is the string '\s-1EOF\s0'.</p><p>Not \s-1EVERY\s0 query should run through the DBIAgent.  If you need to run a short lookup from within a state, sometimes it can be a hassle to have to define a whole separate state to receive its value, and resume processing from there..  The determining factor, of course, is how long your query will take to execute.  If you are trying to retrieve one row from a properly indexed table, use \*(C`$dbh-&gt;selectrow_array()\*(C'.  If there's a join involved, or multiple rows, or a view, you probably want to use DBIAgent.  If it's a longish query and startup costs (time) don't matter to you, go ahead and do it inline.. but remember the whole of your program suspends waiting for the result.  If startup costs \s-1DO\s0 matter, use DBIAgent.</p>
<h3>Return Values</h3>
<p>The destination state in the destination session (specified in the call to \*(C`query()\*(C') will receive the return values from the query in its $_[ARG0] parameter.  DBIAgent invokes \s-1DBI\s0's \*(C`fetch\*(C' method internally, so the value will be a reference to an array.  If your query returns multiple rows, then your state will be invoked multiple times, once per row.  <strong>\s-1ADDITIONALLY\s0</strong>, your state will be called one time with $_[ARG0] containing the string '\s-1EOF\s0'. '\s-1EOF\s0' is returned <em>even</em> if the query doesn't return any other rows.  This is also what to expect for \s-1DML\s0 (\s-1INSERT\s0, \s-1UPDATE\s0, \s-1DELETE\s0) queries.  A way to utilise this might be as follows:</p><p> sub some_state {      #...      if ($enough_values_to_begin_updating) {</p><p>         $heap-&gt;{dbiagent}-&gt;query(update_values_query =&gt;                                   this_session =&gt;                                   update_next_value =&gt;                                   shift @{$heap-&gt;{values_to_be_updated}}                                  );      }  }</p><p> sub update_next_value {      my ($self, $heap) = @_[OBJECT, HEAP];      # we got &apos;EOF&apos; in ARG0 here but we don&apos;t care... we know that an      # update has been executed.</p><p>     for (1..3) {               # Do three at a time!          my $value;          last unless defined ($value = shift @{$heap-&gt;{values_to_be_updated}});          $heap-&gt;{dbiagent}-&gt;query(update_values =&gt;                                   this_session =&gt;                                   update_next_value =&gt;                                   $value                                  );      }</p><p> }</p>
<h3>\fInew()\fP</h3>
<p>Creating an instance creates a POE::Session to manage communication with the Helper processes.  Queue management is transparent and automatic.  The constructor is named \*(C`new()\*(C' (surprised, eh?  Yeah, me too).  The parameters are as follows:</p>
<dl class='dl-vertical'>
  <dt>
    \s-1DSN\s0
  </dt>
  <dd>
    <p>An arrayref of parameters to pass to \s-1DBI-\s0&gt;connect (usually a dsn, username, and password).</p>
  </dd>
  <dt>
    Queries
  </dt>
  <dd>
    <p>A hashref of the form Query_Name =&gt; \*(L"$SQL\*(R".  For example:  {    sysdate =&gt; "select sysdate from dual",    employee_record =&gt; "select * from emp where id = ?",    increase_inventory =&gt; "update inventory                           set count = count + ?                           where item_id = ?",  } As the example indicates, \s-1DBI\s0 placeholders are supported, as are \s-1DML\s0 statements.</p>
  </dd>
  <dt>
    Count
  </dt>
  <dd>
    <p>The number of helper processes to spawn.  Defaults to 3.  The optimal value for this parameter will depend on several factors, such as: how many different queries your program will be running, how much \s-1RAM\s0 you have, how often you run queries, and most importantly, how many queries you intend to run <em>simultaneously</em>.</p>
  </dd>
  <dt>
    ErrorState
  </dt>
  <dd>
    <p>An listref containing a session and event name to receive error messages from the \s-1DBI\s0.  The message arrives in \s-1ARG0\s0. The \*(C`query()\*(C' method takes at least three parameters, plus any bind values for the specific query you are executing. This parameter must be one of the keys to the Queries hashref you passed to the constructor.  It is used to indicate which query you wish to execute.</p>
  </dd>
  <dt>
    &#92;%args
  </dt>
  <dd>
    <p>This is an \s-1OPTIONAL\s0 hashref of arguments to pass to the query. Currently supported arguments:</p>
<dl class='dl-vertical'>
  <dt>
    hash
  </dt>
  <dd>
    <p>Return rows hash references instead of array references.</p>
  </dd>
  <dt>
    cookie
  </dt>
  <dd>
    <p>A cookie to pass to this query.  This is passed back unchanged to the destination state in $_[ARG1].  Can be any scalar (including references, and even \s-1POE\s0 postbacks, so be careful!).  You can use this as an identifier if you have one destination state handling multiple different queries or sessions.</p>
  </dd>
  <dt>
    delay
  </dt>
  <dd>
    <p>Insert a 1ms delay between each row of output. I know what you're thinking: \*(L"\s-1WHY\s0 would you want to slow down query responses?!?!?\*(R"  It has to do with \s-1CONCURRENCY\s0.  When a response (finally) comes in from the agent after running the query, it floods the input channel with response data.  This has the effect of monopolizing \s-1POE\s0's attention, so that any other handles (network sockets, pipes, file descriptors) keep getting pushed further back on the queue, and to all other processes \s-1EXCEPT\s0 the agent, your \s-1POE\s0 program looks hung for the amount of time it takes to process all of the incoming query data. So, we insert 1ms of time via Time::HiRes's \*(C`usleep\*(C' function.  In human terms, this is essentially negligible.  But it is just enough time to allow competing handles (sockets, files) to trigger \*(C`select()\*(C', and get handled by the POE::Kernel, in situations where concurrency has priority over transfer rate. Naturally, the Time::HiRes module is required for this functionality. If Time::HiRes is not installed, the delay is ignored.</p>
  </dd>
  <dt>
    group
  </dt>
  <dd>
    <p>Sends the return event back when \*(C`group\*(C' rows are retrieved from the database, to avoid event spam when selecting lots of rows. \s-1NB:\s0 using group means that $row will be an arrayref of rows, not just a single row.</p>
  </dd>

</dl>
<p>These parameters indicate the \s-1POE\s0 state that is to receive the data returned from the database.  The state indicated will receive the data in its $_[ARG0] parameter.  <em>\s-1PLEASE\s0</em> make sure this is a valid state, otherwise you will spend a \s-1LOT\s0 of time banging your head against the wall wondering where your query data is. These are any parameters your query requires.  <strong>\s-1WARNING:\s0</strong> You must supply exactly as many parameters as your query has placeholders! This means that if your query has \s-1NO\s0 placeholders, then you should pass \s-1NO\s0 extra parameters to \*(C`query\*(C'. Suggestions to improve this syntax are welcome.</p>
  </dd>

</dl>

<h3>\fIfinish()\fP</h3>
<p>The \*(C`finish()\*(C' method tells DBIAgent that the program is finished sending queries.  DBIAgent will shut its helpers down gracefully after they complete any pending queries.  If there are no pending queries, the DBIAgent will shut down immediately.</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">NOTES</h2>
        <div class="sectioncontent">
<ul>
<li><p>Error handling is practically non-existent.</p></li><li><p>The calling syntax is still pretty weak... but improving.  We may eventually add an optional attributes hash so that each query can be called with its own individual characteristics.</p></li><li><p>I might eventually want to support returning hashrefs, if there is any demand.</p></li><li><p>Every query is prepared at Helper startup.  This could potentially be pretty expensive.  Perhaps a cached or deferred loading might be better?  This is considering that not every helper is going to run every query, especially if you have a lot of miscellaneous queries.</p></li>
</ul><p>Suggestions welcome!  Diffs <em>more</em> welcome! :-)</p>
        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">AUTHOR</h2>
        <div class="sectioncontent">
<p>This module has been fine-tuned and packaged by Rob Bloodgood &lt;robb@empire2.com&gt;.  However, most of the queuing code originated with Fletch &lt;fletch@phydeaux.org&gt;, either directly or via his ideas.  Thank you for making this module a reality, Fletch!</p><p>However, I own all of the bugs.</p><p>This module is free software; you may redistribute it and/or modify it under the same terms as Perl itself.</p>
        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="POE::Component::Client::Ping.3pm.html"><span aria-hidden="true">&larr;</span> POE::Component::Client::Ping.3pm: A non-blocking icmp ping client</a></li>
   <li class="next"><a href="POE::Component::DBIAgent::Helper.3pm.html">POE::Component::DBIAgent::Helper.3pm: Dbi query helper for dbiagent <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>

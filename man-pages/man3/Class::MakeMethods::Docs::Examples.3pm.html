<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700&effect=destruction%7Cshadow-multiple" rel="stylesheet" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Class::MakeMethods::Docs::Examples: Sample declarations and usage</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/manpage.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="manifest" href="/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="Sample declarations and usage">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@CartaTech">
  <meta name="twitter:creator" content="@CartaTech">
  <meta name="twitter:title" content="Class::MakeMethods::Docs::Examples (3pm) manual">
  <meta name="twitter:description" content="Sample declarations and usage">
  <meta name="twitter:image" content="https://www.carta.tech/images/libclass-makemethods-perl-Class::MakeMethods::Docs::Examples-3pm.png">
  <meta property="og:url" content="https://www.carta.tech/man-pages/man3pm/Class::MakeMethods::Docs::Examples.3pm.html" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Class::MakeMethods::Docs::Examples (3pm) manual" />
  <meta property="og:description" content="Sample declarations and usage" />
  <meta property="fb:app_id" content="1241677679199500" />
  <meta property="og:image" content="https://www.carta.tech/images/libclass-makemethods-perl-Class::MakeMethods::Docs::Examples-3pm.png" />
  <meta property="og:image:width" content="600" />
  <meta property="og:image:height" content="315" />
</head>
<body>
  <div class="container final">
          <div class="page-header">
        <h1 class="font-effect-destruction">Class::MakeMethods::Docs::Examples<small> (3pm)</small></h1>
        <p class="lead">Sample declarations and usage</p>
      </div>

    <ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/">
      <span itemprop="name">Man Pages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/">
      <span itemprop="name">MISSING SECTION</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Class::MakeMethods::Docs::Examples.3pm.html">
      <span itemprop="name">Class::MakeMethods::Docs::Examples: Sample declarations and usage</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
<ol class="breadcrumb" itemscope itemtype="http://schema.org/BreadcrumbList">
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/">
      <span itemprop="name">Carta.tech</span>
    </a>
    <meta itemprop="position" content="1" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/">
      <span itemprop="name">Packages</span>
    </a>
    <meta itemprop="position" content="2" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/packages/libclass-makemethods-perl/">
      <span itemprop="name">libclass-makemethods-perl</span>
    </a>
    <meta itemprop="position" content="3" />
  </li>
  <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
    <a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="/man-pages/man3pm/Class::MakeMethods::Docs::Examples.3pm.html">
      <span itemprop="name">Class::MakeMethods::Docs::Examples: Sample declarations and usage</span>
    </a>
    <meta itemprop="position" content="4" />
  </li>
</ol>
    
      <section>
        <h2 class="font-effect-shadow-multiple">EXAMPLES</h2>
        <div class="sectioncontent">
<p>The following examples indicate some of the capabilities of Class::MakeMethods.</p><h3>A Contrived Example</h3>
<p>Object-oriented Perl code is widespread \*(-- you've probably seen code like the below a million times:</p>
<pre>
  my $obj = MyStruct-&gt;new( foo=&gt;"Foozle", bar=&gt;"Bozzle" );
  if ( $obj-&gt;foo() =~ /foo/i ) {
    $obj-&gt;bar("Barbados!");
  }
</pre>
<p>Here's a possible implementation for the class whose interface is shown above:</p><p>  package MyStruct;</p><p>  sub new {     my $callee = shift;     my $self = bless { @_ }, (ref $callee || $callee);     return $self;   }</p><p>  sub foo {     my $self = shift;     if ( scalar @_ ) {       $self-&gt;{&apos;foo&apos;} = shift();     } else {       $self-&gt;{&apos;foo&apos;}     }   }</p><p>  sub bar {     my $self = shift;     if ( scalar @_ ) {       $self-&gt;{&apos;bar&apos;} = shift();     } else {       $self-&gt;{&apos;bar&apos;}     }   }</p><p>Class::MakeMethods allows you to simply declare those methods to be of a predefined type, and it generates and installs the necessary methods in your package at compile-time.</p><p>Here's the equivalent declaration for that same basic class:</p><p>  package MyStruct;   use Class::MakeMethods::Standard::Hash (     &apos;new&apos;       =&gt; &apos;new&apos;,     &apos;scalar&apos;    =&gt; &apos;foo&apos;,     &apos;scalar&apos;    =&gt; &apos;bar&apos;,   );</p>
<h3>A Typical Example</h3>
<p>The following example shows a common case of constructing a class with several types of accessor methods</p><p>  package MyObject;   use Class::MakeMethods::Standard::Hash (     new =&gt; &apos;new&apos;,     scalar =&gt; [ &apos;foo&apos;, &apos;bar&apos; ],     array =&gt; &apos;my_list&apos;,     hash =&gt; &apos;my_index&apos;,   );</p><p>This class now has a constructor named new, two scalar accessors named foo and bar, and a pair of reference accessors named my_list and my_index. Typical usage of the class might include calls like the following:</p><p>  my $obj = MyObject-&gt;new( foo =&gt; &apos;Foozle&apos; );   print $obj-&gt;foo();</p><p>  $obj-&gt;bar(&apos;Barbados&apos;);   print $obj-&gt;bar();</p><p>  $obj-&gt;my_list(0 =&gt; &apos;Foozle&apos;, 1 =&gt; &apos;Bang!&apos;);   print $obj-&gt;<strong>my_list</strong>(1);</p><p>  $obj-&gt;my_index(&apos;broccoli&apos; =&gt; &apos;Blah!&apos;, &apos;foo&apos; =&gt; &apos;Fiddle&apos;);   print $obj-&gt;my_index(&apos;foo&apos;);</p>
<h3>Lvalue Accessors</h3>
<p>The Template subclasses support an optional \*(L"--lvalue\*(R" modifer that causes your accessors method to be marked as returning an lvalue which can be assigned to. (This feature is only available on Perl 5.6 or later.)</p><p>  package MyStruct;   use Class::MakeMethods::Template::Hash (     &apos;new&apos;                   =&gt; &apos;new&apos;,     &apos;scalar --get --lvalue&apos; =&gt; &apos;foo&apos;,     &apos;array --get --lvalue&apos;  =&gt; &apos;bar&apos;,   );</p><p>  $obj-&gt;foo = "Foozle";   print $obj-&gt;foo;</p><p>  $obj-&gt;bar = ( &apos;baz&apos;, &apos;beep&apos;, &apos;boop&apos; );   print $obj-&gt;bar-&gt;[1]; # beep</p>
<h3>String and Numeric Accessors</h3>
<p>In addition to the \*(C`scalar\*(C' accessor supported by the \*(C`Standard::*\*(C' classes, the Template subclasses also provide specialized accessors that can facilitate the use of specific types of data.</p><p>For example, we could declare the following class to hold information about available Perl packages:</p><p>  package MyVersionInfo;   use Class::MakeMethods::Template::Hash (     &apos;new&apos;     =&gt; &apos;new&apos;,     &apos;string&apos;  =&gt; &apos;package&apos;,     &apos;number&apos;  =&gt; &apos;version&apos;,   );</p><p>  sub summary {     my $self = shift;     return $self-&gt;package() . " is at version " . $self-&gt;version()   }</p><p>You could use this class as follows:</p><p>  package main;   use MyVersionInfo;</p><p>  my $obj = MyVersionInfo-&gt;new( package=&gt;"Class::MakeMethods");   $obj-&gt;version( 2.0 );   print $obj-&gt;summary();</p><p>These accessors will provide a bit of diagnostic type checking; an attempt to call \*(C`$obj-&gt;version("foo")\*(C' will cause your program to croak.</p>
<h3>String Concatenation Interface</h3>
<p>The following defines a get_concat method \*(C`i\*(C', and specifies a string to use when joining additional values when this method is called.</p><p>  use Class::MakeMethods::Template::Hash     &apos;string&apos; =&gt; [ &apos;--get_concat&apos;, &apos;i&apos;, { join =&gt; &apos; - &apos; } ];</p><p>(See Class::MakeMethods::Template::Generic for information about the \*(C`string\*(C' \*(C`get_concat\*(C' interface.)</p>
<h3>Access Control Example</h3>
<p>The following defines a secret_password method, which will croak if it is called from outside of the declaring package.</p><p>  use Class::MakeMethods::Composite::Hash     &apos;scalar&apos; =&gt; [ &apos;secret_password&apos; =&gt; { permit =&gt; &apos;pp&apos; } ];</p><p>(See Class::MakeMethods::Composite for information about the \*(C`permit\*(C' modifier.)</p><p>For template classes, the same thing is accomplished with '--private':</p><p>  use Class::MakeMethods::Template::Hash     &apos;scalar&apos; =&gt; [ &apos;--private&apos;, &apos;secret_password&apos; ];</p><p>(See Class::MakeMethods::Template::Universal for information about the \*(C`private\*(C' modifier.)</p>
<h3>Lazy-Init Interface</h3>
<p>Templapte scalar accessors declared with the \*(L"init_and_get\*(R" interface can be used for \*(L"memoization\*(R" or lazy-evaluation for object attributes. If the current accessor value is undefined, they will first call a user-provided init_* method and save its value.</p><p>  package MyWidget;   use Class::MakeMethods::Template::Hash (     &apos;new --with_values&apos; =&gt; [ &apos;new&apos; ],     &apos;scalar --init_and_get&apos; =&gt; [ &apos;foo&apos;, &apos;count&apos;, &apos;result&apos; ],   );</p><p>  sub init_foo {     return &apos;foofle&apos;;   }</p><p>  sub init_count {     return &apos;3&apos;;   }</p><p>  sub init_result {     my $self = shift;     return $self-&gt;foo x $self-&gt;count;   }   ...</p><p>  my $widget = MyWidget-&gt;new();   print $widget-&gt;result; # output: fooflefooflefoofle</p><p>  # if values are predefined, the init methods are not used   my $other_widget = MyWidget-&gt;new( foo =&gt; &apos;bar&apos;, count =&gt; 2 );   print $widget-&gt;result; # output: barbar</p><p>(See Class::MakeMethods::Template::Generic for more information about \*(C`init_and_get\*(C'. This interface is also supported by all of Generic's subclasses, so you can add lazy-init methods for global data, class data, array objects, etc. Unfortunately, to date it is only supported for scalar-value accessors...)</p>
<h3>Helper Methods</h3>
<p>Template methods often include similarly-named \*(L"helper\*(R" methods. For example, specifying the \*(L"--with_clear\*(R" interface for Template::*:scalar methods creates an extra method for each accessor x named clear_x.</p><p>  package MyClass;   use Class::MakeMethods::Template::Hash(&apos;scalar --with_clear&apos; =&gt; &apos;foo&apos;);</p><p>  my $obj = MyClass-&gt;new;   $obj-&gt;foo(23);   $obj-&gt;clear_foo;   print $obj-&gt;foo();</p>
<h3>Reference Accessor and Helper Methods</h3>
<p>For references to arrays and hashes, the Template subclasses provide accessors with extra \*(L"helper methods\*(R" to facilitate method-based interaction.</p><p>Here's a class whose instances each store a string and an array reference, along with a method to search the directories:</p><p>  package MySearchPath;   use Class::MakeMethods::Template::Hash (     &apos;new&apos;     =&gt; &apos;new&apos;,     &apos;string&apos;  =&gt; &apos;name&apos;,     &apos;array&apos;   =&gt; &apos;directories&apos;,   );</p><p>  sub search {     my $self = shift;     my $target = shift;     foreach my $dir ( $self-&gt;directories ) {       my $candidate = $dir . &apos;/&apos; . $target;       return $candidate if ( -e $candidate );     }     return;   }</p><p>Note that the directories accessor returns the contents of the array when called in a list context, making it easier to loop over.</p><p>And here's a sample usage:</p><p>  package main;   use MySearchPath;</p><p>  my $libs = MySearchPath-&gt;new( name=&gt;"libs", directories=&gt;[&apos;/usr/lib&apos;] );   $libs-&gt;push_directories( &apos;/usr/local/lib&apos; );</p><p>  print "Searching in " . $libs-&gt;count_directories() . "directories.&#92;n";   foreach ( &apos;libtiff&apos;, &apos;libjpeg&apos; ) {     my $file = $libs-&gt;search("$_.so");     print "Checking $_: " . ( $file || &apos;not found&apos; ) . "&#92;n";   }</p><p>Note the use of the push_* and count_* \*(L"helper\*(R" accessor methods, which are defined by default for all 'Template::*:array' declarations.</p><p>Consult Class::MakeMethods::Template::Generic for more information about the available types of reference accessors, and the various methods they define.</p>
<h3>Object Accessors</h3>
<p>There's also a specialized accessor for object references:</p><p>  package MyStruct;   use Class::MakeMethods::Template::Hash (     &apos;new&apos;    =&gt; &apos;new&apos;,     &apos;object&apos; =&gt; [ &apos;widget&apos; =&gt; {class=&gt;&apos;MyWidgetClass&apos;, delegate=&gt;"twiddle"} ],   );</p><p>(Note that the \*(C`class\*(C' and \*(C`delegate\*(C' values specified above are method parameters, which provide additional information about the \*(C`widget\*(C' declaration; see \*(L"Standard Declaration Syntax\*(R" for more information.)</p><p>The above declaration creates methods equivalent to the following:</p><p>  package MyStruct;</p><p>  sub widget {     my $self = shift;     if ( scalar @_ ) {       if (ref $_[0] and UNIVERSAL::isa($_[0], &apos;MyWidgetClass&apos;)) {         $self-&gt;{widget} = shift;       } else {         $self-&gt;{widget} = MyWidgetClass-&gt;new(@_);       }     } else {       return $self-&gt;{widget};     }   }</p><p>  sub clear_widget {     my $self = shift;     $self-&gt;{widget} = undef;   }</p><p>  sub twiddle {     my $self = shift;     my $obj = $self-&gt;widget()       or Carp::croak("Can&apos;t forward twiddle because widget is empty");     $obj-&gt;twiddle(@_)   }</p>
<h3>Mixing Object and Global Methods</h3>
<p>Here's a package declaration using two of the included subclasses, \*(C`Standard::Hash\*(C', for creating and accessing hash-based objects, and \*(C`Basic::Global\*(C', for simple global-value accessors:</p><p>  package MyQueueItem;</p><p>  use Class::MakeMethods::Standard::Hash (     new =&gt; { name =&gt; &apos;new&apos;, defaults=&gt;{ foo =&gt; &apos;Foozle&apos; } },     scalar =&gt; [ &apos;foo&apos;, &apos;bar&apos; ],     hash =&gt; &apos;history&apos;   );</p><p>  use Class::MakeMethods::Basic::Global (     scalar =&gt; &apos;Debug&apos;,     array  =&gt; &apos;InQueue&apos;,   );</p><p>  sub AddQueueItem {     my $class = shift;     my $instance = shift;     $instance-&gt;history(&apos;AddQueueItem&apos; =&gt; time());     $class-&gt;InQueue([0, 0], $instance);   }</p><p>  sub GetQueueItem {     my $class = shift;     $class-&gt;InQueue([0, 1], []) or $class-&gt;new   }</p>
<h3>Adding Custom Initialization to Constructors</h3>
<p>Frequently you'll want to provide some custom code to initialize new objects of your class. Most of the *:new constructor methods provides a way to ensure that this code is consistently called every time a new instance is created.</p>
<dl class='dl-vertical'>
  <dt>
    Composite::Hash:new { post_rules =&gt; [] }
  </dt>
  <dd>
    <p>The Composite classes allow you to add pre- and post-operations to any method, so you can pass in a code-ref to be executed after the <em>new()</em> method.   package MyClass;</p><p>  sub new_post_init {     my $self = ${(pop)-&gt;{result}}; # get result of original new()     length($self-&gt;foo) or $self-&gt;foo(&apos;FooBar&apos;);   # default value     warn "Initialized new object &apos;$self&apos;";   }</p><p>  use Class::MakeMethods (     &apos;Composite::Hash:new&apos; =&gt; [         &apos;new&apos; =&gt; { post_rules=&gt;[ &#92;&new_post_init ] }     ],     &apos;Composite::Hash:scalar&apos; =&gt; &apos;foo;,   );   ...   package main;   my $self = MyClass-&gt;new( foo =&gt; &apos;Foozle&apos; )</p>
  </dd>
  <dt>
    Template::Hash:new --and_then_init
  </dt>
  <dd>
    <p>Use 'Template::Hash:new --and_then_init', which will first create the object and initialize it with the provided values, and then call an <em>init()</em> method on the new object before returning it.   package MyClass;   use Class::MakeMethods::Template::Hash (     &apos;new --and_then_init&apos; =&gt; &apos;new&apos;     &apos;string&apos;  =&gt; &apos;foo&apos;   );   sub init {     my $self = shift;     length($self-&gt;foo) or $self-&gt;foo(&apos;FooBar&apos;);   # default value     warn "Initialized new object &apos;$self&apos;";   }   ...   package main;   my $self = MyClass-&gt;new( foo =&gt; &apos;Foozle&apos; )</p>
  </dd>
  <dt>
    Template::Hash:new --with_init
  </dt>
  <dd>
    <p>If you don't want your constructor to use the default hash-of-method-names style of initialization, use 'Template::Hash:new --with_init', which will create an empty object, pass its arguments to the <em>init()</em> method on the new object, and then return it.   package MyClass;   use Class::MakeMethods::Template::Hash (     &apos;new --with_init&apos; =&gt; &apos;new&apos;     &apos;string&apos;  =&gt; &apos;foo&apos;   );   sub init {     my $self = shift;     $self-&gt;foo( shift || &apos;FooBar&apos; ); # init with arg or default     warn "Initialized new object &apos;$self&apos;";   }   ...   package main;   my $self = MyClass-&gt;new( &apos;Foozle&apos; )</p>
  </dd>

</dl>
<p>Some additional notes about these constructors:</p><ul>
<li><p>The \*(C`Template::*:new\*(C' methods allow you to specify a name for your method other than \*(C`init\*(C' by passing the \*(C`init_method\*(C' parameter:   use Class::MakeMethods::Template::Hash (     &apos;new --and_then_init&apos; =&gt; [         &apos;new&apos; =&gt; { init_method =&gt;  &apos;my_init&apos; }     ],   );</p></li><li><p>If you know that you're not going to have a complex class hierarchy, you can reduce resource consumption a bit by changing the above declarations from \*(L"*::Hash\*(R" to \*(L"*::Array\*(R" so your objects end up as blessed arrays rather than blessed hashes.</p></li>
</ul>
<h3>Changing Method Names</h3>
<p>The Template subclasses allow you to control the names assigned to the methods you generate by selecting from several naming interfaces.</p><p>For example, the accessors declared above use a default, Perl-ish style interface, in which a single method can be called without an argument to retrieve the value, or with an argument to set it. However, you can also select a more Java-like syntax, with separate get* and set* methods, by including the '--java' template specification:</p><p>  package MyStruct;   use Class::MakeMethods::Template::Hash (     &apos;new&apos;     =&gt; &apos;new&apos;,     &apos;scalar&apos;  =&gt; &apos;--java Foo&apos;,   );</p><p>(Note that the declaration of Foo could also have been written as &apos;scalar --java&apos; =&gt; &apos;Foo&apos; or \*(C`&apos;scalar&apos; =&gt; [&apos;--java&apos;, &apos;Foo&apos;]\*(C', or \*(C`&apos;scalar&apos; =&gt; [ &apos;foo&apos; =\*(C' { 'interface'=&gt;'java' } ], all of which are interpreted identically; see the Class::MakeMethods section on \*(L"Argument Normalization\*(R" for details.)</p><p>Usage of this accessor would then be as follows:</p><p>  package main;   use MyStruct;</p><p>  my $obj = MyStruct-&gt;new( setFoo =&gt; "Foozle" );   print $obj-&gt;getFoo();   $obj-&gt;setFoo("Bozzle");</p>
<h3>Selecting Specific Helper Methods</h3>
<p>You can use the ability to specify interfaces to select specific helper methods rather than getting the default collection.</p><p>For example, let's say you wanted to use a Template::Hash:array, but you only wanted two methods to be installed in your class, a <em>foo()</em> accessor and a <em>shift_foo()</em> mutator. Any of the below combinations of syntax should do the trick:</p><p>  use Class::MakeMethods::Template::Hash     &apos;array&apos; =&gt; [       &apos;foo&apos; =&gt; { interface=&gt;{&apos;foo&apos;=&gt;&apos;get_set&apos;, &apos;shift_foo&apos;=&gt;&apos;shift&apos;} },     ];</p><p>If you're going to have a lot of methods with the same interface, you could pre-declare a named interface once and use it repeatedly:</p><p>  BEGIN {     require Class::MakeMethods::Template::Hash;     Class::MakeMethods::Template::Hash-&gt;named_method(&apos;array&apos;)-&gt;         {&apos;interface&apos;}-&gt;{&apos;my_get_set_shift&apos;} =             { &apos;*&apos;=&gt;&apos;get_set&apos;, &apos;shift_*&apos;=&gt;&apos;shift&apos; };   }</p><p>  use Class::MakeMethods::Template::Hash     &apos;array --my_get_set_shift&apos; =&gt; [ &apos;foo&apos;, &apos;bar&apos; ];</p>
<h3>Tree Structure Example</h3>
<p>In this example we will create a pair of classes with references to other objects.</p><p>The first class is a single-value data object implemented as a reference to a scalar.</p><p>  package MyTreeData;   use Class::MakeMethods::Template::Scalar (     &apos;new&apos;     =&gt; &apos;new&apos;,     &apos;string&apos;  =&gt; &apos;value&apos;,   );</p><p>The second class defines a node in a tree, with a constructor, an accessor for a data object from the class above, and accessors for a list of child nodes.</p><p>  package MyTreeNode;   use Class::MakeMethods::Template::Hash (     &apos;new&apos;     =&gt; &apos;new&apos;,     &apos;object -class MyTreeData&apos;  =&gt; &apos;data&apos;,     &apos;array_of_objects -class MyTreeNode&apos; =&gt; &apos;children&apos;,   );</p><p>  sub depth_first_data {     my $self = shift;     return $self-&gt;data, map { $_-&gt;depth_first_data() } $self-&gt;children;   }</p><p>Here's a sample of how the above classes could be used in a program.</p><p>  package main;   use MyTreeData;   use MyTreeNode;</p><p>  my $node = MyTreeNode-&gt;new(       data =&gt; { value=&gt;&apos;data1&apos; },       children =&gt; [ { value=&gt;&apos;data3&apos; } ]   );   $node-&gt;push_children( MyTreeNode-&gt;new( data =&gt; { value=&gt;&apos;data2&apos; } ) );</p><p>  foreach my $data ( $node-&gt;depth_first_data ) {     print $data-&gt;value();   }</p>

        </div>
      </section>

      <section>
        <h2 class="font-effect-shadow-multiple">RELATED TO Class::MakeMethods::Docs::Examples&hellip;</h2>
        <div class="sectioncontent">
<p>See Class::MakeMethods for general information about this distribution.</p><h3>Annotated Tutorials</h3>
<p>Ron Savage has posted a pair of annotated examples, linked to below. Each demonstrates building a class with MakeMethods, and each includes scads of comments that walk you through the logic and demonstrate how the various methods work together.</p><p>  http://savage.net.au/Perl-tutorials.html   http://savage.net.au/Perl-tutorials/tut-33.tgz   http://savage.net.au/Perl-tutorials/tut-34.tgz</p>

        </div>
      </section>
<nav>
  <ul class="pager">
   <li class="previous"><a href="Class::MakeMethods::Docs::Changes.3pm.html"><span aria-hidden="true">&larr;</span> Class::MakeMethods::Docs::Changes.3pm: History of class::makemethods</a></li>
   <li class="next"><a href="Class::MakeMethods::Docs::ReadMe.3pm.html">Class::MakeMethods::Docs::ReadMe.3pm: About class::makemethods <span aria-hidden="true">&rarr;</span></a></li>
  </ul>
</nav>

  </div>
  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <!-- Include all compiled plugins (below), or include individual files as needed -->
  <script src="/js/bootstrap.min.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-60781387-1', 'auto');
    ga('send', 'pageview');

  </script>
</body>
</html>
